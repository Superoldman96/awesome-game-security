Project Path: arc_gmh5225_BLUESPAWN_d12n0fqj

Source Tree:

```txt
arc_gmh5225_BLUESPAWN_d12n0fqj
├── BLUESPAWN-win-client
│   ├── BLUESPAWN-client.exe.manifest
│   ├── BLUESPAWN-client.vcxproj
│   ├── headers
│   │   ├── hunt
│   │   │   ├── Hunt.h
│   │   │   ├── HuntInfo.h
│   │   │   ├── HuntRegister.h
│   │   │   ├── RegistryHunt.h
│   │   │   ├── Scope.h
│   │   │   └── hunts
│   │   │       ├── HuntT1036.h
│   │   │       ├── HuntT1037.h
│   │   │       ├── HuntT1053.h
│   │   │       ├── HuntT1055.h
│   │   │       ├── HuntT1068.h
│   │   │       ├── HuntT1070.h
│   │   │       ├── HuntT1136.h
│   │   │       ├── HuntT1484.h
│   │   │       ├── HuntT1505.h
│   │   │       ├── HuntT1543.h
│   │   │       ├── HuntT1546.h
│   │   │       ├── HuntT1547.h
│   │   │       ├── HuntT1548.h
│   │   │       ├── HuntT1553.h
│   │   │       ├── HuntT1562.h
│   │   │       └── HuntT1569.h
│   │   ├── mitigation
│   │   │   ├── Mitigation.h
│   │   │   ├── MitigationRegister.h
│   │   │   ├── Software.h
│   │   │   ├── mitigations
│   │   │   │   ├── MitigateM1025.h
│   │   │   │   ├── MitigateM1028-WFW.h
│   │   │   │   ├── MitigateM1035-RDP.h
│   │   │   │   ├── MitigateM1042-LLMNR.h
│   │   │   │   ├── MitigateM1042-NBT.h
│   │   │   │   ├── MitigateM1042-WSH.h
│   │   │   │   ├── MitigateM1047.h
│   │   │   │   ├── MitigateM1054-RDP.h
│   │   │   │   ├── MitigateM1054-WSC.h
│   │   │   │   ├── MitigateV1093.h
│   │   │   │   ├── MitigateV1153.h
│   │   │   │   ├── MitigateV3338.h
│   │   │   │   ├── MitigateV3340.h
│   │   │   │   ├── MitigateV3344.h
│   │   │   │   ├── MitigateV3379.h
│   │   │   │   ├── MitigateV3479.h
│   │   │   │   ├── MitigateV63597.h
│   │   │   │   ├── MitigateV63687.h
│   │   │   │   ├── MitigateV63753.h
│   │   │   │   ├── MitigateV63817.h
│   │   │   │   ├── MitigateV63825.h
│   │   │   │   ├── MitigateV63829.h
│   │   │   │   ├── MitigateV71769.h
│   │   │   │   ├── MitigateV72753.h
│   │   │   │   ├── MitigateV73511.h
│   │   │   │   ├── MitigateV73519.h
│   │   │   │   └── MitigateV73585.h
│   │   │   └── policy
│   │   │       ├── CombinePolicy.h
│   │   │       ├── EventLogPolicy.h
│   │   │       ├── FirewallRulePolicy.h
│   │   │       ├── MitigationPolicy.h
│   │   │       ├── RegistryPolicy.h
│   │   │       ├── SubkeyPolicy.h
│   │   │       └── ValuePolicy.h
│   │   ├── monitor
│   │   │   ├── ETW_Wrapper.h
│   │   │   ├── Event.h
│   │   │   ├── EventListener.h
│   │   │   └── EventManager.h
│   │   ├── reaction
│   │   │   ├── CarveMemory.h
│   │   │   ├── DeleteFile.h
│   │   │   ├── Detections.h
│   │   │   ├── QuarantineFile.h
│   │   │   ├── Reaction.h
│   │   │   ├── ReactionManager.h
│   │   │   ├── RemoveValue.h
│   │   │   └── SuspendProcess.h
│   │   ├── scan
│   │   │   ├── DetectionRegister.h
│   │   │   ├── Detections.h
│   │   │   ├── FileScanner.h
│   │   │   ├── MemoryScanner.h
│   │   │   ├── ProcessScanner.h
│   │   │   ├── RegistryScanner.h
│   │   │   ├── ScanInfo.h
│   │   │   ├── Scanner.h
│   │   │   ├── ServiceScanner.h
│   │   │   └── YaraScanner.h
│   │   ├── user
│   │   │   ├── CLI.h
│   │   │   ├── banners.h
│   │   │   ├── bluespawn.h
│   │   │   └── iobase.h
│   │   └── util
│   │       ├── DynamicLinker.h
│   │       ├── Internals.h
│   │       ├── Promise.h
│   │       ├── StringUtils.h
│   │       ├── ThreadPool.h
│   │       ├── Utils.h
│   │       ├── configurations
│   │       │   ├── CollectInfo.h
│   │       │   ├── Registry.h
│   │       │   ├── RegistryValue.h
│   │       │   └── ScheduledTasks.h
│   │       ├── eventlogs
│   │       │   ├── EventLogItem.h
│   │       │   ├── EventLogs.h
│   │       │   ├── EventSubscription.h
│   │       │   └── XpathQuery.h
│   │       ├── filesystem
│   │       │   └── FileSystem.h
│   │       ├── log
│   │       │   ├── CLISink.h
│   │       │   ├── DebugSink.h
│   │       │   ├── DetectionSink.h
│   │       │   ├── JSONSink.h
│   │       │   ├── Log.h
│   │       │   ├── LogLevel.h
│   │       │   ├── LogSink.h
│   │       │   ├── Loggable.h
│   │       │   └── XMLSink.h
│   │       ├── pe
│   │       │   ├── Export_Section.h
│   │       │   ├── Image_Loader.h
│   │       │   ├── Import_Section.h
│   │       │   ├── PE_Image.h
│   │       │   ├── PE_Section.h
│   │       │   ├── Relocation_Section.h
│   │       │   └── Resource_Section.h
│   │       ├── permissions
│   │       │   └── permissions.h
│   │       ├── processes
│   │       │   ├── Analyzer.h
│   │       │   ├── CheckLolbin.h
│   │       │   ├── CommandParser.h
│   │       │   ├── PERemover.h
│   │       │   ├── ParseCobalt.h
│   │       │   ├── ProcessChecker.h
│   │       │   └── ProcessUtils.h
│   │       └── wrappers.hpp
│   ├── libpeconv.vcxproj
│   ├── pe-sieve.vcxproj
│   ├── resources
│   │   ├── BLUESPAWN-client.rc
│   │   ├── BLUESPAWN.ico
│   │   ├── SIP
│   │   ├── TrustProviders
│   │   ├── bluespawn-original
│   │   │   └── kernel32_kernelbase_ror13.yar
│   │   ├── indicators.yar
│   │   ├── mitigations.json
│   │   ├── resource.h
│   │   ├── severe.yar
│   │   ├── severe2.yar
│   │   └── third-party-integration
│   │       ├── ConventionEngine.yar
│   │       ├── core.webshell_detection.yara
│   │       ├── extended.webshell_detection.yara
│   │       ├── kiwi_passwords.yar
│   │       └── win_metasploit_related.yara
│   ├── src
│   │   ├── hunt
│   │   │   ├── Hunt.cpp
│   │   │   ├── HuntRegister.cpp
│   │   │   ├── RegistryHunt.cpp
│   │   │   ├── Scope.cpp
│   │   │   └── hunts
│   │   │       ├── HuntT1036.cpp
│   │   │       ├── HuntT1037.cpp
│   │   │       ├── HuntT1053.cpp
│   │   │       ├── HuntT1055.cpp
│   │   │       ├── HuntT1068.cpp
│   │   │       ├── HuntT1070.cpp
│   │   │       ├── HuntT1136.cpp
│   │   │       ├── HuntT1484.cpp
│   │   │       ├── HuntT1505.cpp
│   │   │       ├── HuntT1543.cpp
│   │   │       ├── HuntT1546.cpp
│   │   │       ├── HuntT1547.cpp
│   │   │       ├── HuntT1548.cpp
│   │   │       ├── HuntT1553.cpp
│   │   │       ├── HuntT1562.cpp
│   │   │       └── HuntT1569.cpp
│   │   ├── mitigation
│   │   │   ├── Mitigation.cpp
│   │   │   ├── MitigationRegister.cpp
│   │   │   ├── Software.cpp
│   │   │   ├── mitigations
│   │   │   │   ├── MitigateM1025.cpp
│   │   │   │   ├── MitigateM1028-WFW.cpp
│   │   │   │   ├── MitigateM1035-RDP.cpp
│   │   │   │   ├── MitigateM1042-LLMNR.cpp
│   │   │   │   ├── MitigateM1042-NBT.cpp
│   │   │   │   ├── MitigateM1042-WSH.cpp
│   │   │   │   ├── MitigateM1047.cpp
│   │   │   │   ├── MitigateM1054-RDP.cpp
│   │   │   │   ├── MitigateM1054-WSC.cpp
│   │   │   │   ├── MitigateV1093.cpp
│   │   │   │   ├── MitigateV1153.cpp
│   │   │   │   ├── MitigateV3338.cpp
│   │   │   │   ├── MitigateV3340.cpp
│   │   │   │   ├── MitigateV3344.cpp
│   │   │   │   ├── MitigateV3379.cpp
│   │   │   │   ├── MitigateV3479.cpp
│   │   │   │   ├── MitigateV63597.cpp
│   │   │   │   ├── MitigateV63687.cpp
│   │   │   │   ├── MitigateV63753.cpp
│   │   │   │   ├── MitigateV63817.cpp
│   │   │   │   ├── MitigateV63825.cpp
│   │   │   │   ├── MitigateV63829.cpp
│   │   │   │   ├── MitigateV71769.cpp
│   │   │   │   ├── MitigateV72753.cpp
│   │   │   │   ├── MitigateV73511.cpp
│   │   │   │   ├── MitigateV73519.cpp
│   │   │   │   └── MitigateV73585.cpp
│   │   │   └── policy
│   │   │       ├── CombinePolicy.cpp
│   │   │       ├── EventLogPolicy.cpp
│   │   │       ├── FirewallPolicy.cpp
│   │   │       ├── MitigationPolicy.cpp
│   │   │       └── RegistryPolicy.cpp
│   │   ├── monitor
│   │   │   ├── Event.cpp
│   │   │   ├── EventListener.cpp
│   │   │   ├── EventManager.cpp
│   │   │   └── etw
│   │   │       └── ETW_Wrapper.cpp
│   │   ├── reaction
│   │   │   ├── CarveMemory.cpp
│   │   │   ├── DeleteFile.cpp
│   │   │   ├── QuarantineFile.cpp
│   │   │   ├── ReactionManager.cpp
│   │   │   ├── RemoveValue.cpp
│   │   │   └── SuspendProcess.cpp
│   │   ├── scan
│   │   │   ├── Detection.cpp
│   │   │   ├── DetectionRegister.cpp
│   │   │   ├── FileScanner.cpp
│   │   │   ├── MemoryScanner.cpp
│   │   │   ├── ProcessScanner.cpp
│   │   │   ├── RegistryScanner.cpp
│   │   │   ├── ScanInfo.cpp
│   │   │   ├── Scanner.cpp
│   │   │   ├── ServiceScanner.cpp
│   │   │   └── YaraScanner.cpp
│   │   ├── user
│   │   │   ├── BLUESPAWN.cpp
│   │   │   ├── CLI.cpp
│   │   │   └── banners.cpp
│   │   ├── util
│   │   │   ├── DynamicLinker.cpp
│   │   │   ├── StringUtils.cpp
│   │   │   ├── ThreadPool.cpp
│   │   │   ├── Utils.cpp
│   │   │   ├── configurations
│   │   │   │   ├── CollectInfo.cpp
│   │   │   │   ├── RegistryKey.cpp
│   │   │   │   └── RegistryValue.cpp
│   │   │   ├── eventlogs
│   │   │   │   ├── EventLogItem.cpp
│   │   │   │   ├── EventLogs.cpp
│   │   │   │   ├── EventSubscription.cpp
│   │   │   │   └── XpathQuery.cpp
│   │   │   ├── filesystem
│   │   │   │   └── FileSystem.cpp
│   │   │   ├── log
│   │   │   │   ├── CLISink.cpp
│   │   │   │   ├── DebugSink.cpp
│   │   │   │   ├── JSONSink.cpp
│   │   │   │   ├── Log.cpp
│   │   │   │   ├── LogLevel.cpp
│   │   │   │   └── XMLSink.cpp
│   │   │   ├── pe
│   │   │   │   ├── Export_Section.cpp
│   │   │   │   ├── Image_Loader.cpp
│   │   │   │   ├── Import_Section.cpp
│   │   │   │   ├── PE_Image.cpp
│   │   │   │   ├── PE_Section.cpp
│   │   │   │   ├── Relocation_Section.cpp
│   │   │   │   └── Resource_Section.cpp
│   │   │   ├── permissions
│   │   │   │   └── permissions.cpp
│   │   │   └── processes
│   │   │       ├── Analyzer.cpp
│   │   │       ├── CheckLolbin.cpp
│   │   │       ├── CommandParser.cpp
│   │   │       ├── PERemover.cpp
│   │   │       ├── ParseCobalt.cpp
│   │   │       └── ProcessUtils.cpp
│   │   └── yara
│   │       ├── args.c
│   │       ├── args.h
│   │       ├── common.h
│   │       └── yarac.c
│   └── yarac.vcxproj
├── BLUESPAWN.sln
├── CODE_OF_CONDUCT.md
├── LICENSE
├── README.md
├── config
│   ├── buildsettings.props
│   └── buildstructure.props
├── docs
│   ├── BLUESPAWN
│   │   ├── __init__.py
│   │   ├── asgi.py
│   │   ├── settings.py
│   │   ├── static
│   │   │   └── BLUESPAWN
│   │   │       └── BLUESPAWN.css
│   │   ├── templates
│   │   │   └── BLUESPAWN
│   │   │       ├── base.html
│   │   │       └── index.html
│   │   ├── urls.py
│   │   ├── views.py
│   │   └── wsgi.py
│   ├── Pipfile
│   ├── Procfile
│   ├── bluespawn.cloud
│   ├── clear_uploads.sh
│   ├── django.ini
│   ├── manage.py
│   ├── media
│   │   ├── Defcon28-BlueTeamVillage-BLUESPAWN-Presentation.pdf
│   │   ├── coverage-all.json
│   │   ├── coverage-hunts.json
│   │   └── coverage-mitigations.json
│   ├── requirements.txt
│   └── web
│       ├── __init__.py
│       ├── admin.py
│       ├── apps.py
│       ├── models.py
│       ├── templates
│       │   ├── about.html
│       │   ├── coverage.html
│       │   ├── quickstart.html
│       │   └── report.html
│       ├── tests.py
│       ├── urls.py
│       └── views.py
├── testing
│   ├── attack
│   │   ├── hunt-t1546-012-test001.bat
│   │   └── hunt-t1546-012-test002.bat
│   ├── clean
│   │   ├── hunt-t1546-012-test001-clean.bat
│   │   └── hunt-t1546-012-test002-clean.bat
│   ├── run-atomic-prep.ps1
│   ├── run-atomic-tests.ps1
│   └── run-hunt-results-comparison.ps1
└── vcpkg_response_file.txt

```

`BLUESPAWN-win-client/BLUESPAWN-client.exe.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <description>BLUESPAWN Active Defense and EDR Software</description>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
        <application>
            <!-- Windows 10 -->
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
            <!-- Windows 8.1 -->
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <!-- Windows 8 -->
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
            <!-- Windows 7 -->
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <!-- Windows Vista -->
            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
        </application>
    </compatibility>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

`BLUESPAWN-win-client/BLUESPAWN-client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="headers\hunt\Hunt.h" />
    <ClInclude Include="headers\hunt\HuntInfo.h" />
    <ClInclude Include="headers\hunt\HuntRegister.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1036.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1037.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1053.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1055.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1068.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1070.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1136.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1484.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1505.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1543.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1546.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1547.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1553.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1562.h" />
    <ClInclude Include="headers\hunt\hunts\HuntT1569.h" />
    <ClInclude Include="headers\mitigation\policy\CombinePolicy.h" />
    <ClInclude Include="headers\mitigation\policy\EventLogPolicy.h" />
    <ClInclude Include="headers\mitigation\policy\MitigationPolicy.h" />
    <ClInclude Include="headers\mitigation\policy\RegistryPolicy.h" />
    <ClInclude Include="headers\mitigation\policy\SubkeyPolicy.h" />
    <ClInclude Include="headers\mitigation\policy\ValuePolicy.h" />
    <ClInclude Include="headers\mitigation\Software.h" />
    <ClInclude Include="headers\monitor\EventListener.h" />
    <ClInclude Include="headers\reaction\CarveMemory.h" />
    <ClInclude Include="headers\reaction\DeleteFile.h" />
    <ClInclude Include="headers\reaction\QuarantineFile.h" />
    <ClInclude Include="headers\reaction\Reaction.h" />
    <ClInclude Include="headers\reaction\RemoveValue.h" />
    <ClInclude Include="headers\reaction\SuspendProcess.h" />
    <ClInclude Include="headers\hunt\RegistryHunt.h" />
    <ClInclude Include="headers\hunt\Scope.h" />
    <ClInclude Include="headers\mitigation\Mitigation.h" />
    <ClInclude Include="headers\mitigation\MitigationRegister.h" />
    <ClInclude Include="headers\monitor\ETW_Wrapper.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\monitor\Event.h" />
    <ClInclude Include="headers\monitor\EventManager.h" />
    <ClInclude Include="headers\scan\DetectionRegister.h" />
    <ClInclude Include="headers\scan\Detections.h" />
    <ClInclude Include="headers\scan\FileScanner.h" />
    <ClInclude Include="headers\scan\MemoryScanner.h" />
    <ClInclude Include="headers\scan\ProcessScanner.h" />
    <ClInclude Include="headers\scan\RegistryScanner.h" />
    <ClInclude Include="headers\scan\Scanner.h" />
    <ClInclude Include="headers\scan\ScanInfo.h" />
    <ClInclude Include="headers\scan\ServiceScanner.h" />
    <ClInclude Include="headers\user\banners.h" />
    <ClInclude Include="headers\user\bluespawn.h" />
    <ClInclude Include="headers\user\CLI.h" />
    <ClInclude Include="headers\user\iobase.h" />
    <ClInclude Include="headers\util\DynamicLinker.h" />
    <ClInclude Include="headers\util\Internals.h" />
    <ClInclude Include="headers\util\log\JSONSink.h" />
    <ClInclude Include="headers\util\Promise.h" />
    <ClInclude Include="headers\util\StringUtils.h" />
    <ClInclude Include="headers\util\ThreadPool.h" />
    <ClInclude Include="headers\util\Utils.h" />
    <ClInclude Include="headers\util\wrappers.hpp" />
    <ClInclude Include="headers\util\configurations\CollectInfo.h" />
    <ClInclude Include="headers\util\configurations\Registry.h" />
    <ClInclude Include="headers\util\configurations\RegistryValue.h" />
    <ClInclude Include="headers\util\configurations\ScheduledTasks.h" />
    <ClInclude Include="headers\util\eventlogs\EventLogItem.h" />
    <ClInclude Include="headers\util\eventlogs\EventLogs.h" />
    <ClInclude Include="headers\util\eventlogs\EventSubscription.h" />
    <ClInclude Include="headers\util\eventlogs\XpathQuery.h" />
    <ClInclude Include="headers\util\filesystem\FileSystem.h" />
    <ClInclude Include="headers\scan\YaraScanner.h" />
    <ClInclude Include="headers\util\log\CLISink.h" />
    <ClInclude Include="headers\util\log\DebugSink.h" />
    <ClInclude Include="headers\util\log\DetectionSink.h" />
    <ClInclude Include="headers\util\log\Log.h" />
    <ClInclude Include="headers\util\log\Loggable.h" />
    <ClInclude Include="headers\util\log\LogLevel.h" />
    <ClInclude Include="headers\util\log\LogSink.h" />
    <ClInclude Include="headers\util\log\XMLSink.h" />
    <ClInclude Include="headers\util\permissions\Permissions.h" />
    <ClInclude Include="headers\util\pe\Export_Section.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\pe\Image_Loader.h" />
    <ClInclude Include="headers\util\pe\Import_Section.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\pe\PE_Image.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\pe\PE_Section.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\pe\Relocation_Section.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\pe\Resource_Section.h">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="headers\util\processes\Analyzer.h" />
    <ClInclude Include="headers\reaction\ReactionManager.h" />
    <ClInclude Include="headers\util\processes\ParseCobalt.h" />
    <ClInclude Include="headers\util\processes\CheckLolbin.h" />
    <ClInclude Include="headers\util\processes\CommandParser.h" />
    <ClInclude Include="headers\util\processes\PERemover.h" />
    <ClInclude Include="headers\util\processes\ProcessChecker.h" />
    <ClInclude Include="headers\util\processes\ProcessUtils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="external\tinyxml2\tinyxml2.cpp" />
    <ClCompile Include="src\hunt\Hunt.cpp" />
    <ClCompile Include="src\hunt\HuntRegister.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1036.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1037.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1053.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1055.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1068.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1070.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1136.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1484.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1505.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1543.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1546.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1547.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1548.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1553.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1562.cpp" />
    <ClCompile Include="src\hunt\hunts\HuntT1569.cpp" />
    <ClCompile Include="src\mitigation\policy\CombinePolicy.cpp" />
    <ClCompile Include="src\mitigation\policy\EventLogPolicy.cpp" />
    <ClCompile Include="src\mitigation\policy\MitigationPolicy.cpp" />
    <ClCompile Include="src\mitigation\policy\RegistryPolicy.cpp" />
    <ClCompile Include="src\mitigation\Software.cpp" />
    <ClCompile Include="src\monitor\EventListener.cpp" />
    <ClCompile Include="src\reaction\CarveMemory.cpp" />
    <ClCompile Include="src\scan\Detection.cpp" />
    <ClCompile Include="src\reaction\DeleteFile.cpp" />
    <ClCompile Include="src\reaction\QuarantineFile.cpp" />
    <ClCompile Include="src\reaction\RemoveValue.cpp" />
    <ClCompile Include="src\reaction\SuspendProcess.cpp" />
    <ClCompile Include="src\hunt\RegistryHunt.cpp" />
    <ClCompile Include="src\hunt\Scope.cpp" />
    <ClCompile Include="src\mitigation\Mitigation.cpp" />
    <ClCompile Include="src\mitigation\MitigationRegister.cpp" />
    <ClCompile Include="src\monitor\etw\ETW_Wrapper.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\monitor\Event.cpp" />
    <ClCompile Include="src\monitor\EventManager.cpp" />
    <ClCompile Include="src\scan\DetectionRegister.cpp" />
    <ClCompile Include="src\scan\FileScanner.cpp" />
    <ClCompile Include="src\scan\MemoryScanner.cpp" />
    <ClCompile Include="src\scan\ProcessScanner.cpp" />
    <ClCompile Include="src\scan\RegistryScanner.cpp" />
    <ClCompile Include="src\scan\Scanner.cpp" />
    <ClCompile Include="src\scan\ScanInfo.cpp" />
    <ClCompile Include="src\scan\ServiceScanner.cpp" />
    <ClCompile Include="src\user\banners.cpp" />
    <ClCompile Include="src\user\BLUESPAWN.cpp" />
    <ClCompile Include="src\user\CLI.cpp" />
    <ClCompile Include="src\util\configurations\CollectInfo.cpp" />
    <ClCompile Include="src\util\DynamicLinker.cpp" />
    <ClCompile Include="src\util\eventlogs\EventLogItem.cpp" />
    <ClCompile Include="src\util\eventlogs\EventLogs.cpp" />
    <ClCompile Include="src\util\configurations\RegistryKey.cpp" />
    <ClCompile Include="src\util\configurations\RegistryValue.cpp" />
    <ClCompile Include="src\util\eventlogs\EventSubscription.cpp" />
    <ClCompile Include="src\util\eventlogs\XpathQuery.cpp" />
    <ClCompile Include="src\util\filesystem\FileSystem.cpp" />
    <ClCompile Include="src\scan\YaraScanner.cpp" />
    <ClCompile Include="src\util\log\CLISink.cpp" />
    <ClCompile Include="src\util\log\DebugSink.cpp" />
    <ClCompile Include="src\util\log\JSONSink.cpp" />
    <ClCompile Include="src\util\log\Log.cpp" />
    <ClCompile Include="src\util\log\LogLevel.cpp" />
    <ClCompile Include="src\util\log\XMLSink.cpp" />
    <ClCompile Include="src\util\permissions\Permissions.cpp" />
    <ClCompile Include="src\util\pe\Export_Section.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\pe\Image_Loader.cpp" />
    <ClCompile Include="src\util\pe\Import_Section.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\pe\PE_Image.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\pe\PE_Section.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\pe\Relocation_Section.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\pe\Resource_Section.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="src\util\processes\Analyzer.cpp" />
    <ClCompile Include="src\util\processes\ParseCobalt.cpp" />
    <ClCompile Include="src\util\processes\CheckLolbin.cpp" />
    <ClCompile Include="src\util\processes\CommandParser.cpp" />
    <ClCompile Include="src\reaction\ReactionManager.cpp" />
    <ClCompile Include="src\util\processes\PERemover.cpp" />
    <ClCompile Include="src\util\processes\ProcessUtils.cpp" />
    <ClCompile Include="src\util\StringUtils.cpp" />
    <ClCompile Include="src\util\ThreadPool.cpp" />
    <ClCompile Include="src\util\Utils.cpp" />
    <ClInclude Include="headers\hunt\hunts\HuntT1548.h" />
    <ClInclude Include="resources\resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="pe-sieve.vcxproj">
      <Project>{bec01f8e-5892-3f6f-a741-5bbd1d0f4ef9}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resources\BLUESPAWN-client.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include=".clang-format" />
    <None Include="resources\indicators" />
    <None Include="resources\mitigations.json" />
    <None Include="resources\severe" />
    <None Include="resources\severe2" />
    <None Include="resources\SIP" />
    <None Include="resources\TrustProviders" />
  </ItemGroup>
  <ItemGroup>
    <Manifest Include="BLUESPAWN-client.exe.manifest" />
  </ItemGroup>
  <PropertyGroup>
    <TargetName>BLUESPAWN-client</TargetName>
    <GenerateManifest>false</GenerateManifest>
    <EmbedManifest>
    </EmbedManifest>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <BuildLog>
      <Path>$(SolutionDir)build\$(PlatformTarget)\$(Configuration)\$(MSBuildProjectName).log</Path>
    </BuildLog>
    <ClCompile>
      <AdditionalIncludeDirectories>$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include;$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\;$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary Condition="'$(Configuration)'=='Release'">MultiThreaded</RuntimeLibrary>
      <RuntimeLibrary Condition="'$(Configuration)'=='Debug'">MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Secur32.lib;DbgHelp.lib;Wintrust.lib;ws2_32.lib;Crypt32.lib;Shlwapi.lib;NetApi32.lib;wldap32.lib%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>mt.exe -manifest "$(ProjectDir)$(TargetName).exe.manifest" -outputresource:"$(TargetDir)$(TargetName).exe;1"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Adding manifest to BLUESPAWN-client.exe</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}</ProjectGuid>
    <RootNamespace>CommonLib</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <VcpkgTriplet Condition="'$(Platform)'=='Win32'">x86-windows-static</VcpkgTriplet>
    <VcpkgTriplet Condition="'$(Platform)'=='x64'">x64-windows-static</VcpkgTriplet>
    <ProjectName>BLUESPAWN-win-client</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\config\buildsettings.props" />
    <Import Project="..\config\buildstructure.props" />
  </ImportGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`BLUESPAWN-win-client/headers/hunt/Hunt.h`:

```h
#pragma once
#include <Windows.h>

#include <chrono>
#include <iomanip>
#include <sstream>
#include <string>

#include "HuntInfo.h"
#include "Scope.h"
#include "monitor/Event.h"

class HuntRegister;

#define GET_INFO()                                                                            \
    HuntInfo {                                                                                \
        this->name, this->dwTacticsUsed, this->dwCategoriesAffected, this->dwSourcesInvolved, \
            (long) std::chrono::duration_cast<std::chrono::milliseconds>(                     \
                std::chrono::system_clock::now().time_since_epoch())                          \
                .count()                                                                      \
    }

#define HUNT_INIT()                                       \
    std::vector<std::shared_ptr<Detection>> detections{}; \
    auto __name{ this->name };                            \
    LOG_INFO(1, "Beginning hunt for " << __name);

#define SUBTECHNIQUE_INIT(id, desc)                                                                 \
    if(!scope.Subtechniques || *scope.Subtechniques & (1 << id)) {                                  \
        auto __name{ (std::wstringstream{} << this->name << L" Subtechnique " << std::setfill(L'0') \
                                         << std::setw(3) << id << L": " #desc).str() };
#define SUBTECHNIQUE_END() }

#define SUBSECTION_INIT(id, intensity)                                                                           \
    if(!scope.Subsections || *scope.Subsections & (1 << id)) {                                                   \
        if(Bluespawn::aggressiveness < Aggressiveness::##intensity) {                                            \
            LOG_INFO(1, L"Skipping " << __name                                                                   \
                                     << L" subsection " #id "; rerun BLUESPAWN at " #intensity " to run this."); \
        } else {
#define SUBSECTION_END() \
    }                    \
    }

#define SCOPE(scope) \
    Scope::CreateSubhuntScope(1 << scope)

#define HUNT_END()                               \
    LOG_INFO(2, "Finished hunt for " << __name); \
    return detections;

#define CREATE_DETECTION(certainty, ...) \
    detections.emplace_back(             \
        Bluespawn::detections.AddDetection(Detection{ __VA_ARGS__, DetectionContext{ __name } }, certainty));

#define CREATE_DETECTION_WITH_CONTEXT(certainty, ...)           \
    detections.emplace_back(Bluespawn::detections.AddDetection( \
        Detection{                                              \
            __VA_ARGS__,                                        \
        },                                                      \
        certainty));

class Hunt {
    protected:
    /// The tactics used by the hunt, computed as a bitwise OR of entries in the enum Tactic
    DWORD dwTacticsUsed;

    /// The data sources used by the hunt, computed as a bitwise OR of entries in the enum DataSource
    DWORD dwSourcesInvolved;

    /// The categories affected by the hunt, computed as a bitwise OR of entries in the enum Category
    DWORD dwCategoriesAffected;

    /// The name of the hunt
    std::wstring name;

    public:
    /**
     * Instantiates a new hunt by the given name. Note that names should be unique and include
     * the technique number as well as the name (Such as T1004 - Winlogon Helper).
     *
     * @param name The name of the hunt
     */
    Hunt(IN CONST std::wstring& name);

    /**
     * Retrieves the name of the hunt
     *
     * @return The name of the hunt
     */
    std::wstring GetName();

    /**
     * Indicate whether the hunt uses all specified tactics from the Tactic enum.
     *
     * @param tactics The tactics to check, computed as a bitwise OR of the Tactic enum.
     *
     * @return True if the hunt uses all specified tactics; false otherwise.
     */
    bool UsesTactics(IN DWORD tactics);

    /**
     * Indicate whether the hunt uses all specified sources from the Source enum.
     *
     * @param source The source to check, computed as a bitwise OR of the Source enum.
     *
     * @return True if the hunt uses all specified sources; false otherwise.
     */
    bool UsesSources(IN DWORD sources);

    /**
     * Indicate whether the hunt uses all specified categories from the Category enum.
     *
     * @param categories The categories to check, computed as a bitwise OR of the Category enum.
     *
     * @return True if the hunt uses affects specified categories; false otherwise.
     */
    bool AffectsCategory(IN DWORD categories);

    /**
     * Runs the hunt, returning references to the detections found.
     *
     * @param scope The scope of the hunt
     *
     * @return A vector of references to the detections identified.
     */
    virtual std::vector<std::shared_ptr<Detection>> RunHunt(IN CONST Scope& scope);

    /**
     * Retrieves a vector of events to be signalled when the hunt should be rerun. This should only
     * be called once, as the events will be duplicated if called multiple times.
     *
     * @return a vector of event pointers
     */
    virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents();
};

```

`BLUESPAWN-win-client/headers/hunt/HuntInfo.h`:

```h
#pragma once

enum class Tactic {
	InitialAccess = 1,
	Execution = 2,
	Persistence = 4,
	PrivilegeEscalation = 8,
	DefenseEvasion = 0x10,
	CredentialAccess = 0x20,
	Discovery = 0x40,
	LateralMovement = 0x80,
	Collection = 0x100,
	CommandControl = 0x200,
	Exfiltration = 0x400,
	Impact = 0x800
};

enum class DataSource {
	Services = 1,
	Processes = 2,
	Drivers = 4,
	FileSystem = 8,
	Registry = 0x10,
	GPO = 0x20,
	EventLogs = 0x40,
	Network = 0x80
};

enum class Category {

	// Includes registry, group policy, and related configurations/settings
	Configurations = 0x1,

	// Includes services and drivers
	Processes = 0x2,

	Files = 0x4,
	Network = 0x8
};

enum class Aggressiveness {
	Cursory = 0x1, // Most obvious indicators (least false positives)
	Normal = 0x2, // Examine more things
	Intensive = 0x3 //  Check everything imaginable (most false positives)
};

// This struct is a POD type for storing information about a hunt to be logged.
struct HuntInfo {
	std::wstring HuntName;
	DWORD HuntTactics;
	DWORD HuntCategories;
	DWORD HuntDatasources;
	long HuntStartTime;
	HuntInfo(const std::wstring& HuntName, DWORD HuntTactics, DWORD HuntCategories, DWORD HuntDatasources, long HuntStartTime);
};

```

`BLUESPAWN-win-client/headers/hunt/HuntRegister.h`:

```h
#pragma once
#include <Windows.h>

#include <map>
#include <string>
#include <vector>

#include "Hunt.h"
#include "Scope.h"

#include "util/Promise.h"
/**
 * HuntRegister is a class meant to be used to manage running hunts and monitoring.
 * Rather than make HuntRegister a singleton, all members are instead static.
 */
class HuntRegister {
    private:
    /// A vector of registered hunts
    static std::vector<std::unique_ptr<Hunt>> vRegisteredHunts;

    /* Called before a hunt is run or added to monitor mode to see if it should be enabled. This
	 * provide the ability to use the --hunts or --exclude-hunts flags to limit to looking for only 
	 * certain MITRE ATT&CK Techniques
	 * @param hunt The particular hunt to check
	 * @param vExcludedHunts A vector of Technique IDs that should be excluded
	 * @param vIncludedHunts A vector of Technique IDs that should be the only ones to run
	 * 
	 * @return A boolean whether or not the hunt should be included
	 */
    static bool HuntRegister::HuntShouldRun(IN Hunt* hunt,
                                            IN CONST std::vector<std::wstring> vIncludedHunts,
                                            IN CONST std::vector<std::wstring> vExcludedHunts);

    public:
    /**
	 * Runs all hunts registered with the RegisterHunt function with the given scope.
	 * note that the resulting vector of detections contains only items that *may* be
	 * malicious. Furthermore, they may be duplicates and numerous false positives present.
	 * These detections should be passed to scan mode for further analysis.
	 *
	 * @param scope An optional scope object representing the limitations of the hunt
	 * @param async A boolean indicating whether this function should wait for all hunts
	 *        to finish before returning.
	 *
	 * @return A vector of possibly malicious items. 
	 */
    static std::vector<Promise<std::vector<std::shared_ptr<Detection>>>> RunHunts(
        IN CONST std::vector<std::wstring> vIncludedHunts,
        IN CONST std::vector<std::wstring> vExcludedHunts,
        IN CONST Scope& scope = {} OPTIONAL,
        IN CONST bool async = false OPTIONAL);

    /**
	 * Queues a specified hunt, returning a promise for its result
	 *
	 * @param hunt The hunt to queue
	 * @param An optional scope object representing the limitations of the hunt
	 */
    static Promise<std::vector<std::shared_ptr<Detection>>> RunHunt(
        IN Hunt* hunt, IN CONST Scope& scope = {} OPTIONAL);

    /**
	 * Sets up monitoring mode by subscribing to all monitor events for each hunt in
	 * vRegisteredHunts. Note that in earlier versions of Windows, the thread that calls
	 * this function being terminated will result in the event subscriptions ending.
	 */
    static void SetupMonitoring(IN CONST std::vector<std::wstring> vIncludedHunts,
                                IN CONST std::vector<std::wstring> vExcludedHunts);

    /**
	 * Registers a hunt. This must be called prior to SetupMonitoring or RunHunts in
	 * order for the registered hunt to be run. Note that ownership of the hunt must be
	 * transferred to the HuntRegister.
	 *
	 * @param hunt A unique pointer to the hunt
	 */
    static void RegisterHunt(IN std::unique_ptr<Hunt>&& hunt);
};

```

`BLUESPAWN-win-client/headers/hunt/RegistryHunt.h`:

```h
#pragma once
#include "util/configurations/Registry.h"
#include "util/configurations/RegistryValue.h"
#include "HuntInfo.h"

#include <vector>
#include <functional>
#include <string>

/**
 * Forward facing API for checking registry key values against known good or known bad values.
 *
 * All hunts that check registry values should interact with functions here rather than the RegistryKey class
 * when possible, and if functionality is needed that can't be provided from one of the functions here, it should
 * be implemented here. This is so that the RegistryKey class can change without destroying hunts.
 */

namespace Registry {

	typedef std::function<bool(const std::wstring&, const std::wstring&)> REG_SZ_CHECK;
	typedef std::function<bool(DWORD, DWORD)> REG_DWORD_CHECK;
	typedef std::function<bool(const AllocationWrapper&, const AllocationWrapper&)> REG_BINARY_CHECK;
	typedef std::function<bool(const std::vector<std::wstring>&, const std::vector<std::wstring>&)> REG_MULTI_SZ_CHECK;

	extern REG_SZ_CHECK CheckSzEqual;
	extern REG_SZ_CHECK CheckSzRegexMatch;
	extern REG_SZ_CHECK CheckSzNotEqual;
	extern REG_SZ_CHECK CheckSzRegexNotMatch;
	extern REG_SZ_CHECK CheckSzEmpty;

	extern REG_DWORD_CHECK CheckDwordEqual;
	extern REG_DWORD_CHECK CheckDwordNotEqual;

	extern REG_BINARY_CHECK CheckBinaryEqual;
	extern REG_BINARY_CHECK CheckBinaryNotEqual;
	extern REG_BINARY_CHECK CheckBinaryNull;

	extern REG_MULTI_SZ_CHECK CheckMultiSzSubset;
	extern REG_MULTI_SZ_CHECK CheckMultiSzExclusion;
	extern REG_MULTI_SZ_CHECK CheckMultiSzEmpty; 

	/**
	 * A container class for registry values and associated data.
	 */
	struct RegistryCheck {
		std::wstring name;
		
		RegistryType type;
		RegistryData value;
		std::variant<REG_SZ_CHECK, REG_DWORD_CHECK, REG_BINARY_CHECK, REG_MULTI_SZ_CHECK> check;

		bool MissingBad;
		
		RegistryCheck(std::wstring&& wValueName, std::wstring&& wData, bool MissingBad = false, const REG_SZ_CHECK& check = CheckSzEqual);
		RegistryCheck(std::wstring&& wValueName, DWORD&& dwData, bool MissingBad = false, const REG_DWORD_CHECK& check = CheckDwordEqual);
		RegistryCheck(std::wstring&& wValueName, AllocationWrapper&& lpData, bool MissingBad = false, const REG_BINARY_CHECK& check = CheckBinaryEqual);
		RegistryCheck(std::wstring&& wValueName, std::vector<std::wstring>&& wData, bool MissingBad = false,
			const REG_MULTI_SZ_CHECK& check = CheckMultiSzSubset);

		RegistryType GetType() const;

		bool operator()(const RegistryData& data) const;
	};

	/**
	 * Checks the values under a certain key using the RegistryCheck class. if CheckWow64 is true, this will attempt to automatically redirect to the WoW64 version
	 * of the key in addition to the 64-bit one. If CheckUsers is true, this will attempt to automatically check the same key under each user in addition to under
	 * HKLM. 
	 *
	 * @param hkHive The registry hive under which the path lies. 
	 * @param path The path to the specified key under the given hive. If CheckUsers is true, this will will also check the path under each user's account.
	 * @param CheckWow64 If true, this will also check the wow64 version of the key, if one exists
	 * @param CheckUsers If true, this will check for the path under all users' hives in addition to the given one
	 *
	 * @return A vector containing a RegistryValue object for each RegistryCheck that didn't match its valid conditions
	 */
	std::vector<RegistryValue> CheckValues(const HKEY& hkHive, const std::wstring& path, const std::vector<RegistryCheck>& values, bool CheckWow64 = true, bool CheckUsers = true);

	/**
	 * Checks for any values under a certain key. if CheckWow64 is true, this will attempt to automatically redirect to the WoW64 version of the key
	 * in addition to the 64-bit one. If CheckUsers is true, this will attempt to automatically check the same key under each user in addition to under
	 * HKLM.
	 *
	 * @param hkHive The registry hive under which the path lies.
	 * @param path The path to the specified key under the given hive. If CheckUsers is true, this will will also check the path under each user's account.
	 * @param CheckWow64 If true, this will also check the wow64 version of the key, if one exists
	 * @param CheckUsers If true, this will check for the path under all users' hives in addition to the given one
	 *
	 * @return A vector containing a RegistryValue object for each RegistryCheck that didn't match its valid conditions
	 */
	std::vector<RegistryValue> CheckKeyValues(const HKEY& hkHive, const std::wstring& path, bool CheckWow64 = true, bool CheckUsers = true);

	/**
	 * Checks for any values under a certain key. if CheckWow64 is true, this will attempt to automatically redirect to the WoW64 version of the key
	 * in addition to the 64-bit one. If CheckUsers is true, this will attempt to automatically check the same key under each user in addition to under
	 * HKLM.
	 *
	 * @param hkHive The registry hive under which the path lies.
	 * @param path The path to the specified key under the given hive. If CheckUsers is true, this will will also check the path under each user's account.
	 * @param CheckWow64 If true, this will also check the wow64 version of the key, if one exists
	 * @param CheckUsers If true, this will check for the path under all users' hives in addition to the given one
	 *
	 * @return A vector containing a RegistryValue object for each RegistryCheck that didn't match its valid conditions
	 */
	std::vector<RegistryKey> CheckSubkeys(const HKEY& hkHive, const std::wstring& path, bool CheckWow64 = true, bool CheckUsers = true);
}
```

`BLUESPAWN-win-client/headers/hunt/Scope.h`:

```h
#pragma once
#include <Windows.h>

#include <optional>
#include <vector>

/**
 * Used to define the scope of a hunt. Currently, this operates by requiring the programmer to
 * define a new class for each new scope. This is less than ideal, as scopes should eventually 
 * be defined by the end user. Future implementation will allow the programmer to pass in lambdas
 * which will be handled by the functions built in to the class, removing the need for new scopes.
 */
class Scope {
    public:
    /// This field is specific to the hunt being run. It is computed as a bitwise OR of segments of the hunt. Note that
    /// subsections should be unique per hunt and that different subtechniques should not use the same hunt segments.
    std::optional<DWORD64> Subsections;

    /// This field is specific to the hunt being run. It is computed as a bitwise OR of subtechnique IDs to be run.
    std::optional<DWORD> Subtechniques;

    static Scope CreateSubhuntScope(IN DWORD64 Subsections, IN DWORD Subtechniques = -1UL OPTIONAL);
};

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1036.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1036 examines the local file system for executables in user writable
	 * locations in %WINDIR%
	 * 
	 * @scans Cursory checks all such writable folders for executable files
	 * @scans Normal Scan not supported.
	 * @scans Intensive Scan not supported.
	 */
    class HuntT1036 : public Hunt {
        private:
        // Credit: https://twitter.com/mattifestation/status/1172520995472756737/photo/1
        std::vector<std::wstring> writableFolders = { L"%WINDIR%\\System32\\Microsoft\\crypto\\rsa\\machinekeys",
                                                      L"%WINDIR%\\System32\\tasks_"
                                                      L"migrated\\microsoft\\windows\\pla\\system",
                                                      L"%WINDIR%\\Syswow64\\tasks\\microsoft\\windows\\pla\\system",
                                                      L"%WINDIR%\\debug\\WIA",
                                                      L"%WINDIR%\\System32\\Tasks",
                                                      L"%WINDIR%\\Syswow64\\Tasks",
                                                      L"%WINDIR%\\Tasks",
                                                      L"%WINDIR%\\Registration\\crmlog",
                                                      L"%WINDIR%\\System32\\com\\dmp",
                                                      L"%WINDIR%\\System32\\fxstmp",
                                                      L"%WINDIR%\\System32\\spool\\drivers\\color",
                                                      L"%WINDIR%\\System32\\spool\\printers",
                                                      L"%WINDIR%\\System32\\spool\\servers",
                                                      L"%WINDIR%\\Syswow64\\com\\dmp",
                                                      L"%WINDIR%\\Syswow64\\fxstmp",
                                                      L"%WINDIR%\\Temp",
                                                      L"%WINDIR%\\tracing" };

        public:
        HuntT1036();

        void Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1037.h`:

```h
#pragma once
#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1037 examines the registry and filesystem for logon scripts
	 */
    class HuntT1037 : public Hunt {

        public:
        HuntT1037();

        void Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1053.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1053 looks for malicious activity hidden in scheduled tasks/jobs
	 * T1053.005: examines Windows events for new scheduled tasks
	 * 
	 * @monitor Triggers a hunt whenever Security log event ID 4698/Task-Scheduler 106 is generated
	 */
    class HuntT1053 : public Hunt {

        public:
        HuntT1053();

        std::vector<EventLogs::EventLogItem> Get4698Events();
        std::vector<EventLogs::EventLogItem> Get106Events();

        void Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1055.h`:

```h
#pragma once
#include "util/DynamicLinker.h"
#include "util/Promise.h"

#include "hunt/Hunt.h"
#include "pe_sieve.h"
#include "pe_sieve_types.h"

namespace Hunts {

    /**
	 * HuntT1055 examines all processes for shellcode injections, injected PE images,
	 * function hooks, and doppelganging. This individual hunt will eventually be broken
	 * into separate hunts
	 */
    class HuntT1055 : public Hunt {
        public:
        HuntT1055();

        /**
		 * Handles waiting for the promise to be fufilled, checking for invalidated data, and recording any detections
		 * that have been identified.
		 *
		 * @param detections A vector of detections to which any new detections will be added
		 * @param promise A promise for the result of a process scan
		 */
        static void HuntT1055::HandleReport(OUT std::vector<std::shared_ptr<Detection>>& detections,
                                            IN CONST Promise<GenericWrapper<pesieve::ReportEx*>>& promise);

		/**
		 * \brief Queues a PE sieve scan of the specified process, returning a promise for the result
		 * 
		 * \param pid The ID of the process to scan
		 * 
		 * \return A promise for the scan report for the process
		 */
		static Promise<GenericWrapper<pesieve::ReportEx*>> QueueProcessScan(DWORD pid);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1068.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

	/**
	 * HuntT1068 examines the registry and file system for evidence of CVE-2020-1048.
	 */
	class HuntT1068 : public Hunt {
	public:
		HuntT1068();

		virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
		virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
	};
}
```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1070.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1070 looks for evidence attackers tried to cover their tracks.
	 * Currently examines Sysmon logs looking for timestomp events
	 *
	 * @monitor Triggers a hunt whenever Sysmon log event ID 2 is generated
	 */
    class HuntT1070 : public Hunt {

        public:
        HuntT1070();

        void Subtechnique006(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1136.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1136 examines Windows events for new accounts created
     * T1136.001: looks for local Windows accounts that were created
	 *
	 * @monitor Triggers a hunt whenever Security log event ID 4720 is generated
	 */
    class HuntT1136 : public Hunt {
        private:
        std::wstring t1136_001 = L"001: Local Account";

        public:
        HuntT1136();

        void Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts
#pragma once

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1484.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

	/**
	 * HuntT1484 examines the local file system for presence of ntuser.man files which
	 * can be used to override GPO settings
	 */
	class HuntT1484 : public Hunt {
	public:
		HuntT1484();

		virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
		virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
	};
}
```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1505.h`:

```h
#pragma once
#include <regex>
#include <string>
#include <vector>

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1505 looks for the abuse of legitimate extensible software components
     * T1505.003: examines the locations of web roots, looking for files that are likely to be
	 * webshells.
	 */
    class HuntT1505 : public Hunt {

        std::vector<std::wstring> web_directories = { L"C:\\inetpub\\wwwroot", L"C:\\xampp\\htdocs" };
        std::vector<std::wstring> web_exts = { L".php",  L".jsp",  L".jspx", L".asp",
                                               L".aspx", L".asmx", L".ashx", L".ascx" };
        std::regex php_vuln_functions;
        std::regex asp_indicators;
        std::regex jsp_indicators;
        std::smatch match_index;

        public:
        HuntT1505();

        void Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope);
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents();
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1543.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1543 examines system services for evidence of bad.
     * T1543.003: examines Windows events for new services created
	 *
	 * @monitor Triggers a hunt whenever System log event ID 7045 is generated
	 */
    class HuntT1543 : public Hunt {

        public:
        HuntT1543();

        void Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1546.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1546 looks for event triggered persistence attacks. Currently works below:
     * T1546.002: examines the system for malicious screensavers
     * T1546.007: examines the system for malicious Netsh Helper DLLs
     * T1546.008: examines Windows Accessibility Features to see if they have been messed
     * T1546.009: examines the installed AppCertDlls to see if any are malicious
     * t1546.010: examines the installed AppInit_Dlls to see if any are malicious
     * t1546.011: examines the installed shims to see if any are malicious
     * T1546.012: examines IFEOs for debuggers and silent process exit hooks
     * T1546.015: examines CLSID registry values to detect COM hijacking
	 */
    class HuntT1546 : public Hunt {
        std::vector<std::wstring> vAccessibilityBinaries = { L"sethc.exe",   L"utilman.exe",  L"osk.exe",
                                                             L"Magnify.exe", L"Narrator.exe", L"DisplaySwitch.exe",
                                                             L"AtBroker.exe" };

        std::wstring wsIFEO = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\";

        public:
        HuntT1546();

        void Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique007(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique008(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique009(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique010(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique011(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique012(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique015(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(IN CONST Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1547.h`:

```h
#pragma once
#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1547 looks for malicious boot or logon autostart execution activity 
     * 
     * T1547.001: examines the registry for run keys and filesystem for startup items
     * T1547.002: examines the registry and filesystem for malicious APs
     * T1547.003: examines the registry and filesystem for malicious time providers
     * T1547.004: examines the registry for Winlogon helper persistence
     * T1547.005: examines the registry and filesystem for malicious SSPs
     * T1547.010: examines the registry for bad port monitors
	 * 
	 * @scans Cursory checks for bad DLLs configured as port monitors
	 * @scans Normal Scan not supported.
	 * @scans Intensive Scan not supported.
	 */
    class HuntT1547 : public Hunt {

        std::vector<std::wstring> RunKeys;

        public:
        HuntT1547();

        void Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique004(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);
        void Subtechnique010(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1548.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

	class HuntT1548 : public Hunt
	{
	public:
		HuntT1548();

		void Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

		virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
		virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
	};
}	// namespace Hunts
```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1553.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1553 looks for attackers blending in by abusing trust on the system.
     * T1553.003: examines Subject Interface Providers and Trust Providers, which can
	 * be used by malicious actors to cause malicious payloads to appear signed, and
	 * establish persistence
	 */
    class HuntT1553 : public Hunt {

        public:
        HuntT1553();

        void Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1562.h`:

```h
#pragma once

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1562 looks for ways attacks impair defenses. Currently examines the registry for firewall
	 * settings that allow applications to override the existing firewall rules.
	 */
    class HuntT1562 : public Hunt {
        private:
        std::wstring t1562_004 = L"004: Disable or Modify System Firewall";

        public:
        HuntT1562();

        void Subtechnique004(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/hunt/hunts/HuntT1569.h`:

```h
#pragma once
#include <Windows.h>

#include <vector>

#include "../Hunt.h"

namespace Hunts {

    /**
	 * HuntT1569 examines the system for malicious services
	 * 
	 * @scans Cursory scans the services that are installed and their binaries
	 * @scans Normal Scan not supported.
	 * @scans Intensive Scan not supported.
	 */
    class HuntT1569 : public Hunt {
        private:
        std::wstring t1569_002 = L"002: Service Execution";

        public:
        HuntT1569();

        void Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections);

        virtual std::vector<std::shared_ptr<Detection>> RunHunt(const Scope& scope) override;
        virtual std::vector<std::pair<std::unique_ptr<Event>, Scope>> GetMonitoringEvents() override;
    };
}   // namespace Hunts

```

`BLUESPAWN-win-client/headers/mitigation/Mitigation.h`:

```h
#pragma once

#include <map>

#include "mitigation/Software.h"
#include "mitigation/policy/MitigationPolicy.h"

#include "nlohmann/json.hpp"

using json = nlohmann::json;

/**
 * \brief Describes how a mitigation should be applied to the system by specifying a default enforcement level and 
 *        providing a list of mitigation policies for which the default application should be overriden.
 */
struct MitigationConfiguration {
    /// The level of enforcement to apply for mitigation policies not overriden in `manuals`
    EnforcementLevel defaultEnforcement;

    /// A mapping from mitigation policies to booleans indicating whether the associated policies should be enforced.
    /// This takes precedence over the default enforcement level
    std::map<MitigationPolicy*, bool> manuals;
};

/**
 * \brief Stores the results of enforcing or auditing a mitigation.
 */
struct MitigationReport {
    /**
	 * \brief Refers to the enforcement status of a MitigationPolicy. 
	 * 
	 * \note When auditing the system, and PolicyStatus generated will be one of NoMatchUnrequired, NoMatchRequired,
	 *       MatchUnrequired, Failed, or MatchRequired. When enforcing, this will instead be one of NoMatchUnrequired,
	 *       MatchUnrequired, MatchRequired, Changed, or ChangeFailed.
	 */
    enum class PolicyStatus {
        NoMatchUnrequired,  // The system state required by the policy is unmet, and the policy is not required
        NoMatchRequired,    // The system state required by the policy is unmet, and the policy is required
        MatchUnrequired,    // The system state required by the policy is met, and the policy is not required
        MatchRequired,      // The system state required by the policy is met, and the policy is required
        Changed,            // The system state was changed to match that required by the policy
        ChangeFailed,       // The system state required by the policy is unmet, and the required state couldn't be met
        Failed,             // The system state relevant to the policy could not be checked
    };

    /// Stores the enforcement status for all MitigationPolicies
    std::map<MitigationPolicy*, PolicyStatus> results;

    /**
     * \brief Indicates whether the audit or enforcement was a success.
     * 
     * \note An audit is a success if no MitigationPolicy's resulted in PolicyStatus::Failed. An enforcement is a 
     *       success if no MitigationPolicy's resulted in ChangeFailed.
     */
    bool Success() const;
};

/**
 * \brief Represents a mitigation that may be applied to the system. 
 *
 * \note For mitigations that apply to the OS, each MITRE mitigation technique should be a separate mitigation.
 *       For mitigations that apply to a single software package, each software package should
 */
class Mitigation {
    /// The name of the mitigation. This should be either the MITRE mitigation technique or specify the name of the
    /// software to which the mitigation applies (i.e. "Apply M1047 - Audit" or "Mitigations for FileZilla 3.52")
    std::wstring name;

    /// Describes the changes made by the mitigation at a high level (i.e. "Enforce binary and application integrity
    /// with digital signature verification to prevent untrusted code from executing.")
    std::wstring description;

    /// The software package targetted by this mitigation. If the mitigation targets the operating system, this should
    /// be "Windows"
    Software software;

    /// The policies enforced by this mitigation.
    std::vector<std::unique_ptr<MitigationPolicy>> policies;

    public:
    /**
	 * \brief Instantiates a mitigation object
	 * 
	 * \note See the documentation for the members of this class for more detail on what the arguments should be
	 * 
	 * \param name The name of the mitigation
	 * \param description The description of what the mitigation does
	 * \param software The software package targetted by this mitigation
	 * \param policies The mitigation policies to be enforced by this mitigation
	 */
    Mitigation(const std::wstring& name,
               const std::wstring& description,
               const Software& software,
               std::vector<std::unique_ptr<MitigationPolicy>> policies);

    Mitigation(json mitigation);

    /**
	 * \brief Compares the current state of the system against the requirements set forth by the mitigation policies.
	 *        Returns a MitigationReport describing the enforcement state of the mitigation policies.
	 * 
	 * \param config A configuration describing which mitigation policies should be considered required. See 
	 *        documentation for MitigationConfiguration for more information.
	 * 
	 * \return A MitigationReport describing the enforcement state of the mitigation policies.
	 */
    MitigationReport AuditMitigation(const MitigationConfiguration& config) const;

    /**
	 * \brief Compares the current state of the system against the requirements set forth by the mitigation policies.
	 *        Enforces any mitigation policies required that are not already in effect. 
	 *
	 * \param config A configuration describing which mitigation policies should be enforced. See documentation for
	 *        MitigationConfiguration for more information.
	 *
	 * \return A MitigationReport describing the enforcement state of the mitigation policies and the result of trying
	 *         to enforce any mitigation policies.
	 */
    MitigationReport EnforceMitigation(const MitigationConfiguration& config) const;

    /**
	 * \brief Checks if the mitigation applies to the system by ensuring the associated software is present and 
	 */
    virtual bool MitigationApplies() const;

    /**
     * \brief Retrieves the name of the mitigation
     * 
     * \return The name of the mitigation
     */
    std::wstring GetName() const;

    /**
     * \brief Retrieves the description of the mitigation
     *
     * \return The description of the mitigation
     */
    std::wstring GetDescription() const;

    /**
     * \brief Retrieves a vector of non-owning pointers to all mitigation policies in this mitigation
     * 
     * \return A vector of non-owning pointers to all mitigation policies in this mitigation
     */
    std::vector<MitigationPolicy*> GetPolicies() const;
};

```

`BLUESPAWN-win-client/headers/mitigation/MitigationRegister.h`:

```h
#pragma once

#include <map>
#include <vector>
#include <string>

#include "Mitigation.h"
#include "util/wrappers.hpp"
#include "util/filesystem/FileSystem.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

/**
 * \brief Describes a configuration for running mitigations
 */
struct MitigationsConfiguration {

    /**
     * \brief Creates a MitigationConfiguration object by parsing JSON describing the configuration
     * 
     * \param config The JSON configuration describing the configuration
     */
    MitigationsConfiguration(json config);

    /**
     * \brief Creates a MitigationConfiguration that only specifies a single enforcement level for all mitigations
     * 
     * \param level The enforcement level for all mitigations
     */
    MitigationsConfiguration(EnforcementLevel level);

    /// A mapping from pointers to mitigations to the configuration under which the associated mitigation should run
    std::map<Mitigation*, MitigationConfiguration> configurations;
};

/**
 * \brief Stores mitigations, manages parsing new mitigations from JSON, and provides an interface for auditing and
 *        enforcing mitigations
 */
class MitigationRegister {

    /// Records a list of mitigations
    std::vector<Mitigation> registeredMitigations{};

    friend class MitigationsConfiguration;

public:

    /**
     * \brief Instantiates a new MitigationRegister. This is intended to only be used by the Bluespawn class
     */
    MitigationRegister();

    /**
     * \brief Parses the JSON storing the default mitigations and loads them into the list of registered mitigations
     */
    void Initialize();

    /**
     * \brief Enforces mitigations as described in the provided configuration. This changes the system state to match
     *        that described by the mitigation policies.
     * 
     * \param config A configuration describing the level at which each mitigation should be run and any mitigation
     *        policies that should be treated specially
     * 
     * \return A mapping from mitigation pointers to MitigationReport objects describing the results of the enforcement
     *         of each mitigation policy.
     */
    std::map<Mitigation*, MitigationReport> EnforceMitigations(const MitigationsConfiguration& config) const;

    /**
     * \brief Audits mitigations as described in the provided configuration. This does not modify the system state.
     *
     * \param config A configuration describing the level at which each mitigation should be run and any mitigation
     *        policies that should be treated specially
     *
     * \return A mapping from mitigation pointers to MitigationReport objects describing the results of the enforcement
     *         of each mitigation policy.
     */
    std::map<Mitigation*, MitigationReport> AuditMitigations(const MitigationsConfiguration& config) const;

    /**
     * \brief Parses mitigations stored in JSON in the given file. This will fail if the file does not exist or 
     *        contains invalid JSON.
     * 
     * \note The fields required by the JSON configuration are described on the Bluespawn GitHub Wiki
     * 
     * \param file A File object referring to the file containing JSON describing mitigations to add.
     * 
     * \return A boolean indicating whether the mitigations were successfully parsed and loaded into this 
     *         MitigationRegister 
     */
    bool ParseMitigationsJSON(const FileSystem::File& file);

    /**
     * \brief Prints a mitigation report to the Bluespawn IO stream.
     * 
     * \param reports The return value from either AuditMitigations or EnforceMitigations
     */
    void PrintMitigationReports(const std::map<Mitigation*, MitigationReport>& reports) const;

    /**
     * \brief Parses mitigations stored in JSON in the given region of memory. This will fail if the memory is empty
     *        or contains invalid JSON.
     *
     * \note The fields required by the JSON configuration are described on the Bluespawn GitHub Wiki
     *
     * \param data An allocation wrapper referring to a region of memory containing ascii JSON describing mitigations 
     *        to add.
     *
     * \return A boolean indicating whether the mitigations were successfully parsed and loaded into this
     *         MitigationRegister
     */
    bool ParseMitigationsJSON(const AllocationWrapper& data);

    /**
     * \brief Creates a JSON configuration file that can be parsed as a MitigationsConfiguration to specify which
     *        mitigation policies should and should not be run. Everything will be configured to not run by default.
     * 
     * \param outfile The file to which the information should be written. Overwrites existing files.
     * \param mode Specifies what the JSON configuration should include. Options are listed below.
     *        0 - Create a configuration file with only a global default enforcement level
     *        1 - Create a configuration file with a global default enforcement level and an enforcement level for
     *            each mitigation
     *        2 - Creates a configuration file with a global default enforcement level, an enforcement level for each
     *            mitigation, and an override for each mitigation policy
     */
    bool CreateConfig(FileSystem::File& outfile, uint32_t mode);
};

```

`BLUESPAWN-win-client/headers/mitigation/Software.h`:

```h
#pragma once

#include <string>
#include <optional>
#include <vector>

/**
 * \brief Represents the version of a program
 */
struct Version {

	/// A vector of 32 bit unsigned integers representing the version. The first index represents the major version,
	/// the second represents the minor version, and so on. 
	std::vector<uint32_t> version;

	/**
	 * \brief Construct a Version object given a list of version numbers
	 */
	Version(std::initializer_list<uint32_t> versionNumbers);

	/**
	 * \brief Construct a Version object from a version string
	 */
	Version(const std::wstring& versionString);

	/// Comparison operators for comparing versions
	bool operator<(const Version& version) const;
	bool operator<=(const Version& version) const;
	bool operator>(const Version& version) const;
	bool operator>=(const Version& version) const;
	bool operator==(const Version& version) const;
	bool operator!=(const Version& version) const;
};

/**
 * \brief Represents a software package used by a mitigation.
 */
class Software {
protected:

	/// The name of the software (i.e. Filezilla)
	std::wstring name;

	/// A description for the software (i.e. Free FTP Server)
	std::wstring description;

	/// The installation directory for the software
	std::optional<Version> version;

	/// Indicates whether the software is present on the system
	bool present;

public:

	/** 
	 * \brief Constructor for a software object
	 * 
	 * \note By default, this checks if the program has registered itself with Windows. Some cases may require
	 *       a derived class to override this method.
	 * 
	 * \param name The name of the software. This must match the installation record exactly.
	 * \param description A description for the software
	 */
	Software(const std::wstring& name, const std::wstring& description);

	/**
	 * \brief Checks if the software is present on the system.
	 *
	 * \return True if the software is present; false otherwise.
	 */
	bool IsPresent() const;


	/**
	 * \brief Checks if the software is present on the system.
	 *
	 * \return The version of the software if found; nullopt otherwise.
	 */
	std::optional<Version> GetVersion() const;
};

class WindowsOS : public Software {
public:
	WindowsOS();
};
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1025.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1025 looks for LSA to be run as a protected process light,
	 * which requires all loaded DLLs to be properly signed and prevents other processes
	 * from interfering with LSA.
	 */
	class MitigateM1025 : public Mitigation {
	public:
		MitigateM1025();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1028-WFW.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1028-WFW looks for the Windows Firewall to be properly configured.
	 * M1028 (WFW). V-17418, V-17417, V-17407
	 */
	class MitigateM1028WFW : public Mitigation {
	public:
		MitigateM1028WFW();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1035-RDP.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {
	/**
	* Mitigation M1035 Limits access to RDP over network by ensuring that NLA is enabled.
	*/
	class MitigateM1035RDP : public Mitigation {
	public:
		MitigateM1035RDP();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1042-LLMNR.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1042-LLMNR looks for LLMNR to be disabled. This helps
	 * to prevent against T1171 and is M1042 (LLMNR).
	 */
	class MitigateM1042LLMNR : public Mitigation {
	public:
		MitigateM1042LLMNR();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1042-NBT.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1042-NBT looks for Netbios (NBT) to be disabled. This helps
	 * to prevent against T1171 and is M1042 (NBT).
	 */
	class MitigateM1042NBT : public Mitigation {
	public:
		MitigateM1042NBT();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1042-WSH.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1042-WSH looks for Windows Script Host, a typically
	 * unused and unneeded feature to be disabled. Sean Metcalf 
	 * recommends this is disabled at https://adsecurity.org/?p=3299
	 * M1042-WSH
	 */
	class MitigateM1042WSH : public Mitigation {
	public:
		MitigateM1042WSH();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1047.h`:

```h
#pragma once

#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {

	/**
	 * MitigateM1047 checks the registry to ensure that key but optional 
	 * event log channels are enabled. These sources are used by many Hunts
	 * and monitoring services in BLUESPAWN.
	 */
	class MitigateM1047 : public Mitigation {
	public:
		MitigateM1047();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	private:
		std::vector<std::wstring> channelList;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1054-RDP.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {
	/**
	* Mitigation M1054-RDP Prevents Remote Users from force logging off Console Users.
	*/
	class MitigateM1054RDP : public Mitigation {
	public:
		MitigateM1054RDP();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateM1054-WSC.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateM1054-WSC looks for the Windows Security Center to provide appropriate
	 * warnings about issues M1054 (WSC).
	 */
	class MitigateM1054WSC : public Mitigation {
	public:
		MitigateM1054WSC();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV1093.h`:

```h
#pragma once
#include "../Mitigation.h"
#include <mitigation\MitigationRegister.h>

namespace Mitigations {

	/**
	 * MitigateV1093 looks for anonymous shares that are not restricted
	 * (V-1093, CCI-001090).
	 */
	class MitigateV1093 : public Mitigation {
	public:
		MitigateV1093();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV1153.h`:

```h
#pragma once
#include "../Mitigation.h"
#include <mitigation\MitigationRegister.h>

namespace Mitigations{

	/**
	 * MitigateV1153 ensures NTLMv2 is used (V-1153).
	 */
	class MitigateV1153 : public Mitigation {
	public:
		MitigateV1153();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV3338.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {

	/**
	 * MitigateV3338 looks for unauthorized named pipes that are accessible with anonymous
	 * credentials (V-3338, CCI-001090).
	 */
	class MitigateV3338 : public Mitigation {
	public:
		MitigateV3338();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV3340.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {

	/**
	 * MitigateV3340 looks for unauthorized shares that can be accessed anonymously
	 * (V-3340).
	 */
	class MitigateV3340 : public Mitigation {
	public:
		MitigateV3340();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV3344.h`:

```h
#pragma once
#include "../Mitigation.h"
#include <mitigation\MitigationRegister.h>

namespace Mitigations{

	/**
	 * MitigateV3344 prevents non-console logons from accounts with blank passwords.
	 */
	class MitigateV3344 : public Mitigation {
	public:
		MitigateV3344();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV3379.h`:

```h
#pragma once
#include "../Mitigation.h"
#include <mitigation\MitigationRegister.h>

namespace Mitigations{

	/**
	 * MitigateV3379 ensures that the LAN Manager does not store LM hashes in the 
	 * SAM registry hive.
	 */
	class MitigateV3379 : public Mitigation {
	public:
		MitigateV3379();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV3479.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV3479 looks for DLL Safe Search Mode to be enabled
	 * (V-3479). M1044 (DLL).
	 */
	class MitigateV3479 : public Mitigation {
	public:
		MitigateV3479();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63597.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63597 looks for the setting to filter privileged tokens
	 * over the network. (V-63597). This helps protect against T1075 
	 * (PTH) and is M1052 (UAC).
	 */
	class MitigateV63597 : public Mitigation {
	public:
		MitigateV63597();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63687.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63687 looks for the cached logon value to be small
	 * (V-63687).
	 */
	class MitigateV63687 : public Mitigation {
	public:
		MitigateV63687();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63753.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63753 looks for caching of domain creds to be disabled
	 * (V-63753).
	 */
	class MitigateV63753 : public Mitigation {
	public:
		MitigateV63753();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63817.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63817 looks for the setting to include the built-in
	 * administrator account in UAC Admin Approval mode to be enabled. 
	 * (V-63817). M1052 (UAC).
	 */
	class MitigateV63817 : public Mitigation {
	public:
		MitigateV63817();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63825.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63825 looks for the setting to prompt application
	 * installations for elevation. (V-63825). M1052 (UAC).
	 */
	class MitigateV63825 : public Mitigation {
	public:
		MitigateV63825();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV63829.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV63829 looks for UAC to be enabled.
	 * (V-63829).  M1052 (UAC).
	 */
	class MitigateV63829 : public Mitigation {
	public:
		MitigateV63829();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV71769.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV71769 looks for remote calls to SAM to be restricted to Administrators
	 * (V-71769).
	 */
	class MitigateV71769 : public Mitigation {
	public:
		MitigateV71769();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV72753.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations {

	/**
	 * MitigateV72753 looks for Wdigest authentication to be disabled. (V-72753).
	 */
	class MitigateV72753 : public Mitigation {
	public:
		MitigateV72753();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}
```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV73511.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV73511 looks for Process command line logging to be enabled.
	 * (V-73511).
	 */
	class MitigateV73511 : public Mitigation {
	public:
		MitigateV73511();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV73519.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV73519 looks for SMBv1 to be disabled. (V-73519).
	 */
	class MitigateV73519 : public Mitigation {
	public:
		MitigateV73519();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/mitigations/MitigateV73585.h`:

```h
#pragma once
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"

namespace Mitigations{

	/**
	 * MitigateV73585 looks for Windows Installer to be configured to always
	 * install elevated (V-73585).
	 */
	class MitigateV73585 : public Mitigation {
	public:
		MitigateV73585();

		virtual bool MitigationIsEnforced(SecurityLevel level) override;
		virtual bool EnforceMitigation(SecurityLevel level) override;
		virtual bool MitigationApplies() override;
	};
}

```

`BLUESPAWN-win-client/headers/mitigation/policy/CombinePolicy.h`:

```h
#pragma once

#include <memory>
#include <vector>

#include "mitigation/policy/MitigationPolicy.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

/**
 * \brief Combines two or more mitigation policy objects into just one object. The policy may require all of or just 
 *        one of the policies being combined to be enforced.
 */
class CombinePolicy : public MitigationPolicy {
    /// Stores pointers to the MitigationPolicies being combined
    std::vector<std::unique_ptr<MitigationPolicy>> subpolicies;

    public:
    /**
	 * \brief Refers to an enforcement mode for the policy. It may require all subpolicies to be enforced, or just one.
	 */
    enum class Mode {
        OR,   /// Requires just one subpolicy to be enforced
        AND   /// Requires that all subpolicies be enforced
    };

    protected:
    /// Tracks the mode of this mitigation policy
    Mode mode;

    public:
    /**
	 * \brief Constructs a CombinePolicy object with the specified subpolicies and mode, defaulting to requiring all 
	 *        subpolicies to be enforced.
	 * 
	 * \param subpolicies A vector of unique pointers to the subpolicies to be combined by the created CombinePolicy
	 * \param mode The enforcement mode for this CombinePolicy, which specifies whether just one or all subpolicies 
	 *        should be enforced.
	 * \param name The name of the mitigation policy. This should attempt to very briefly describe what it does (i.e. 
	 *       "Disable Anonymously Accessible Named Pipes")
	 * \param level The level at which this mitigation policy should be begin to be enforced. This should be Low, 
	 *        Moderate, or High
	 * \param description An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used 
	 *        in X, Y and Z attacks and should be disabled. See abc.com/xyz for more info [v-123]")
	 * \param min The minimum version of the associated software where this policy applies
	 * \param max The maximum version of the associated software where this policy applies
	 */
    CombinePolicy(std::vector<std::unique_ptr<MitigationPolicy>> subpolicies,
                  const std::wstring& name,
                  EnforcementLevel level,
                  const std::optional<std::wstring>& description = std::nullopt,
                  Mode mode = Mode::AND);

    /**
	 * \brief Instantiates a CombinePolicy object from a json configuration. This may throw exceptions.
	 *
	 * \param config The json object storing information about how the policy should be created.
	 */
    CombinePolicy(json config);

    /**
	 * \brief Enforces the mitgiation policy, applying the change to the system. If the policy does not currently match
	 *        the system if the enforcement mode is OR, only the first subpolicy specified when constructed will be 
	 *        enforced.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
    virtual bool Enforce();

    /**
	 * \brief Checks if the changes specified by the subpolicies and mode match the current state of the system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false otherwise.
	 */
    virtual bool MatchesSystem() const;
};

```

`BLUESPAWN-win-client/headers/mitigation/policy/EventLogPolicy.h`:

```h
#pragma once

#include <set>

#include "mitigation/policy/MitigationPolicy.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

/**
 * \brief Implements a MitigationPolicy for enabling event log channels
 */
class EventLogPolicy : public MitigationPolicy {

protected:
	/// The names of subkeys to check for.
	std::set<std::wstring> channelNames;

public:

	/**
	 * \brief Instantiates a MitigationPolicy object from a json configuration. This may throw exceptions.
	 *
	 * \param config The json object storing information about how the policy should be created.
	 */
	EventLogPolicy(json config);

	/**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
	virtual bool Enforce();

	/**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false otherwise.
	 */
	virtual bool MatchesSystem() const;
};

```

`BLUESPAWN-win-client/headers/mitigation/policy/FirewallRulePolicy.h`:

```h
#pragma once

#include "mitigation/policy/MitigationPolicy.h"
#include "nlohmann/json.hpp"
#include "util/filesystem/FileSystem.h"
#include <variant>

using json = nlohmann::json;

/**
 * \brief Represents an IP address, either in IPv4 or IPv6 
 */
struct IP {

	enum class Version {
		IPv4, IPv6
	};

	/// The version of IP address stored in this object
	Version type;

	/// Holds the value of the IP (in big endian)
	std::variant<uint32_t, uint16_t[8]> ip;

	/**
	 * \brief Instantiates an IP from the string representation of the IP address
	 * 
	 * \param ip The string representation of the IP address
	 */
	IP(const std::wstring& ip);

	/**
	 * \brief Instantiates an IP from an IPv4 address encoded in little endian as a 32 bit unsigned integer
	 * 
	 * \param ip The IPv4 address encoded in big endian as a 32 bit unsigned integer
	 */
	IP(uint32_t ip);

	/**
	 * \brief Instantiates an IP from an IPv6 address encoded in 8 little 16 bit unsigned integers
	 *
	 * \param ip The IPv6 address encoded in 8 big endian 16 bit unsigned integers
	 */
	IP(uint16_t ip[8]);

	/**
	 * \brief Produces a string representation of the IP address referenced by this object.
	 * 
	 * \return The string representation of the IP address referenced by this object.
	 */
	std::wstring ToString() const;
};

/**
 * \brief Refers to a range of IP addresses
 */
struct IPRange {

	/// Minimum and maximum IP included in this range, inclusive
	IP minIP, maxIP;

	/**
	 * \brief Construct an IP range holding a single IP that is given
	 * 
	 * \param singleIP The single IP to be contained within this IP range
	 */
	IPRange(const IP& singleIP);

	/**
	 * \brief Construct an IP range with a minimum IP and maximum IP.
	 * 
	 * \note Throws an exception if both IPs are not in the same version of IP
	 * 
	 * \param minIP The minimum IP in this range
	 * \param maxIP The maximum IP in this range
	 */
	IPRange(const IP& minIP, const IP& maxIP);

	/**
	 * \brief Checks if a given IP is contained within the range referenced by this. Returns false if they aren't using
	 *        the same version of IP (IPv4, IPv6)
	 * 
	 * \param ip The IP to check
	 * 
	 * \return True if the given IP is contained within the range referenced by this; false otherwise.
	 */
	bool IPInRange(const IP& ip) const;

	/**
	 * \brief Converts the IP range to its string representation
	 */
	std::wstring ToString() const;
};

/// Specify whether the type of connection should be allowed
enum class FirewallAction {
	ALLOW, // Connections matching the conditions specified should be allowed
	BLOCK  // Connections matching the conditions specified should be blocked
};

/**
 * \brief Implements a FirewallRulePolicy for ensuring types of connections are or are not allowed.
 * 
 * \note FirewallRulePolicy objects enforcing that some connections be allowed *require* that the connection
 *       described be able to pass through the firewall. This may result in allow rules being added or block 
 *       rules being modified to meet this requirement. Inconsistent FirewallRulePolicies will result in an 
 *       error.
 * 
 * \note All firewall rule policies should only be listed as rules under a firewall base policy
 */
class FirewallRulePolicy : public MitigationPolicy {
public:

	/// Specifies the direction the connection originates from
	enum class Dir {
		In, Out
	};

	/// The protocol used by the connection
	enum class Protocol {
		TCP,    // TCP protocol
		UDP,    // UDP protocol
		TCPUDP, // Either TCP or UDP
		ICMP,   // ICMP "ping" protocol
	};

protected:

	/// The direction from which the connection originates
	Dir direction;

	/// The action to be taken on the connections matching the conditions specified here
	FirewallAction action;

	/// The protocol in consideration
	Protocol protocol = Protocol::TCPUDP;

	/// The destination ports in consideration, if any. If none are specified, all ports apply
	std::vector<uint16_t> ports;

	/// The programs for which this rule should apply, if any. If none are specified, all programs apply
	std::vector<FileSystem::File> scopedPrograms;

	/// The services for which this rule should apply, if any. If none are specified, all services apply
	std::vector<SC_HANDLE> scopedServices; // TODO: Add services utility module and replace with wrapped service

	/// The ranges of connection source IPs for which this rule should apply, if any. If none are specified, then all
	/// source IPs apply.
	std::vector<IPRange> connectionSourceRanges;

	/// The ranges of connection destination IPs for which this rule should apply, if any. If none are specified, then 
	/// all destination IPs apply.
	std::vector<IPRange> connectionDestinationRanges;

public:

	/**
	 * \brief Instantiates a FirewallRulePolicy object from a json configuration. This may throw exceptions.
	 *
	 * \param config The json object storing information about how the policy should be created.
	 */
	FirewallRulePolicy(json config);

	/**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
	virtual bool Enforce() const override;

	/**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the
	 *        system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false
	 *         otherwise.
	 */
	virtual bool MatchesSystem() const override;
};

class FirewallBasePolicy : public MitigationPolicy {

	/// Specifies the default action for packets not matching any FirewallRulePolicy
	FirewallAction defaultAction;

	/// Specifies whether preexisting allow or block rules without an associated FirewallRulePolicy should be allowed
	/// to remain in effect, overriding the default action 
	bool allowPreexisting;

	/// A list of firewall rule policies to be enforced
	std::vector<FirewallRulePolicy> rules;

	/**
	 * \brief Instantiates a FirewallRulePolicy object from a json configuration. This may throw exceptions.
	 *
	 * \param config The json object storing information about how the policy should be created.
	 */
	FirewallBasePolicy(json config);

	/**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
	virtual bool Enforce() const override;

	/**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the
	 *        system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false
	 *         otherwise.
	 */
	virtual bool MatchesSystem() const override;
};
```

`BLUESPAWN-win-client/headers/mitigation/policy/MitigationPolicy.h`:

```h
#pragma once

#include <optional>
#include <string>
#include <vector>

#include "mitigation/Software.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

enum class EnforcementLevel {
    None = 0,
    Low = 1,
    Moderate = 2,
    High = 3,
    All = 4,
};

class CombinePolicy;

/**
 * \brief A policy to be enforced by a mitigation. Each mitigation policy represents a single setting,
 *        configuration, or change to be enforced. 
 * 
 * \note When possible, mitigation policies should be extended for types of mitigation policies rather
 *       than for individual mitigations. Mitigation policies involving registry keys, for example, can
 *       be implemented by instantiating a RegistryPolicy and specifying the keys and values in question.
 */
class MitigationPolicy {
    protected:
    /// A boolean tracking whether the policy should be enforced
    bool isEnforced;

    /// The name of the policy. This should attempt to very briefly describe what it does (i.e. "Disable Anonymously
    /// Accessible Named Pipes")
    std::wstring name;

    /// An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used in X, Y and Z attacks
    /// and should be disabled. See abc.com/xyz for more info [v-123]")
    std::optional<std::wstring> description;

    /// The level at which this mitigaiton policy should begin to be enforced. This should be Low, Moderate, or High
    EnforcementLevel level;

    /// Idenfies the minimum and maximum versions of the software for which this mitigation policy applies.
    std::optional<Version> minVersion, maxVersion;

    friend class CombinePolicy;

    public:
    /**
	 * \brief Instantiates a MitigationPolicy object. This should only be called from withing derived classes' 
	 *        constructors.
	 * 
	 * \param name The name of the mitigation policy. This should attempt to very briefly describe what it does (i.e. 
	 *       "Disable Anonymously Accessible Named Pipes")
	 * \param level The level at which this mitigation policy should be begin to be enforced. This should be Low, 
	 *        Moderate, or High
	 * \param description An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used 
	 *        in X, Y and Z attacks and should be disabled. See abc.com/xyz for more info [v-123]")
	 * \param min The minimum version of the associated software where this policy applies
	 * \param max The maximum version of the associated software where this policy applies
	 */
    MitigationPolicy(const std::wstring& name,
                     EnforcementLevel level,
                     const std::optional<std::wstring>& description = std::nullopt,
                     const std::optional<Version>& min = std::nullopt,
                     const std::optional<Version>& max = std::nullopt);

    MitigationPolicy(json config);

    /**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 * 
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
    virtual bool Enforce() = 0;

    /**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the
	 *        system.
	 * 
	 * \return True if the system has the changes specified by the mitigation policy enforced; false 
	 *         otherwise.
	 */
    virtual bool MatchesSystem() const = 0;

	/**
	 * \brief Retrieves the name of the mitigation policy
	 *
	 * \return The name of the policy
	 */
	std::wstring GetPolicyName() const;

	/**
	 * \brief Retrieves the description of the mitigation policy
	 *
	 * \return The description of the policy
	 */
	std::optional<std::wstring> GetDescription() const;

    /**
	 * \brief Returns whether or not the mitigation policy is set to be enforced
	 * 
	 * \return True if the mitigation policy is set to be enforced, false otherwise.
	 */
    bool IsEnforced() const;

    /**
	 * \brief Override default enforcement level settings and specify manually whether this policy should be enforced.
	 * 
	 * \param enforced A boolean indicating whether this policy should be enforced.
	 */
    void SetEnforced(bool enforced);

    /**
	 * \brief Set whether or not this policy should be enforced by specifying an enforcement level. If the given level
	 *        is higher than or equal to the policy's enforcement level, the policy will be enforced.
	 *
	 * \param level The level at which the associated mitigation is being enforced.
	 */
    void SetEnforced(EnforcementLevel level);

    /**
	 * \brief Get the minimum level at which the MitigationPolicy will be enforced by default.
	 * 
	 * \return The minimum level at which the MitigationPolicy will be enforced by default.
	 */
    EnforcementLevel GetEnforcementLevel() const;

    /**
	 * \brief Check if the version given meets the required versions for this mitigation policies. 
	 *
	 * \note If nullopt is passed in, this returns true if and only if the min and max versions for this policy are
	 *       both nullopt. If the min or max version is nullopt, it is treated as not having a minimum or maximum 
	 *       version respectively. 
	 */
    bool GetVersionMatch(std::optional<Version> version) const;
};
```

`BLUESPAWN-win-client/headers/mitigation/policy/RegistryPolicy.h`:

```h
#pragma once

#include "util/configurations/Registry.h"
#include "util/configurations/RegistryValue.h"

#include "mitigation/policy/MitigationPolicy.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

using namespace Registry;

/// Forward declare subpolicies here for namespacing purposes
class ValuePolicy;
class SubkeyPolicy;

/**
 * \brief Implements a mitigation policy pertaining to registry settings. This class is abstract;
 *        developers should instead instantiate one of its children describing more accurately what
 *        the policy requires (i.e RegistryPolicy::ValuePolicy)
 */
class RegistryPolicy : public MitigationPolicy {
    /// The keys being referenced by this policy
    std::vector<RegistryKey> keys;

    friend class ValuePolicy;
    friend class SubkeyPolicy;

    protected:
    /**
	 * \brief Instantiates a RegistryPolicy object. This should only be called from withing derived classes'
	 *        constructors.
	 *
	 * \param key The registry key associated with this registry policy
	 * \param name The name of the mitigation policy. This should attempt to very briefly describe what it does (i.e. 
	 *       "Disable Anonymously Accessible Named Pipes")
	 * \param level The level at which this mitigation policy should be begin to be enforced. This should be Low, 
	 *        Moderate, or High
	 * \param description An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used 
	 *        in X, Y and Z attacks and should be disabled. See abc.com/xyz for more info [v-123]")
	 * \param min The minimum version of the associated software where this policy applies
	 * \param max The maximum version of the associated software where this policy applies
	 */
    RegistryPolicy(const RegistryKey& key,
                   const std::wstring& name,
                   EnforcementLevel level,
                   const std::optional<std::wstring>& description = std::nullopt,
                   const std::optional<Version>& min = std::nullopt,
                   const std::optional<Version>& max = std::nullopt);

    RegistryPolicy(json config);
};

```

`BLUESPAWN-win-client/headers/mitigation/policy/SubkeyPolicy.h`:

```h
#pragma once

#include <set>

#include "mitigation/policy/RegistryPolicy.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

using namespace Registry;

/**
 * \brief Implements a RegistryPolicy for enforcement of policies over subkeys of a specified registry key
 */
class SubkeyPolicy : public RegistryPolicy {
    public:
    /**
	 * \brief Describes the manner in the value policy affects the registry
	 */
    enum class SubkeyPolicyType {
        Whitelist,   /// Allow only the subkey names specified by this policy
        Blacklist    /// Do not allow the subkey names specified by this policy
    };

    protected:
    /// The names of subkeys to check for.
    std::set<std::wstring> subkeyNames;

    /// The type of policy to be enforced.
    SubkeyPolicyType policyType;

    public:
    /**
	 * \brief Instantiates a SubkeyPolicy object.
	 *
	 * \param key The registry key associated with this registry policy
	 * \param subkeyNames The names of subkeys this policy looks for. This is interpretted according to the policyType.
	 * \param policyType The policy for how the subkey names provided should be treated.
	 * \param name The name of the mitigation policy. This should attempt to very briefly describe what it does (i.e.
	 *       "Disable Anonymously Accessible Named Pipes")
	 * \param level The level at which this mitigation policy should be begin to be enforced. This should be Low,
	 *        Moderate, or High
	 * \param description An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used
	 *        in X, Y and Z attacks and should be disabled. See abc.com/xyz for more info [v-123]")
	 * \param min The minimum version of the associated software where this policy applies
	 * \param max The maximum version of the associated software where this policy applies
	 */
    SubkeyPolicy(const RegistryKey& key,
                 const std::vector<std::wstring>& subkeyNames,
                 SubkeyPolicyType policyType,
                 const std::wstring& name,
                 EnforcementLevel level,
                 const std::optional<std::wstring>& description = std::nullopt,
                 const std::optional<Version>& min = std::nullopt,
                 const std::optional<Version>& max = std::nullopt);

    /**
	 * \brief Instantiates a SubkeyPolicy object from a json configuration. This may throw exceptions.
	 *
	 * \param config The json object storing information about how the policy should be created.
	 */
    SubkeyPolicy(json config);

    /**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
    virtual bool Enforce();

    /**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false otherwise.
	 */
    virtual bool MatchesSystem() const;
};

```

`BLUESPAWN-win-client/headers/mitigation/policy/ValuePolicy.h`:

```h
#pragma once

#include "mitigation/policy/RegistryPolicy.h"
#include "nlohmann/json.hpp"

using json = nlohmann::json;

using namespace Registry;

/**
 * \brief Implements a RegistryPolicy for enforcement of policies over registry values
 */
class ValuePolicy : public RegistryPolicy {
public:

	/**
	 * \brief Describes the manner in which a ValuePolicy treats its data
	 */
	enum class ValuePolicyType {
		RequireExact,    /// Require the registry data to match the data provided exactly
		ForbidExact,     /// Forbid the registry data from matching the data provided exactly
		RequireAsSubset, /// Require the registry to hold at least the provided data values
						 /// This only applies for REG_MULTI_SZ registry values.
		RequireSubsetOf, /// Require the registry to hold nothing but the provided data values
						 /// This only applies for REG_MULTI_SZ registry values.
		ForbidSubsetOf,  /// Require the registry to hold none of the provided data values
						 /// This only applies for REG_MULTI_SZ registry values.
		ForbidValue,     /// Require the specified registry value to not appear under the associated key.
	};

protected:

	/// The name of the registry value. Leave empty for the default value.
	std::wstring valueName;

	/// The data referenced by the policy.
	RegistryData data;

	/// An optional replacement for the data. This is only used if the policyType is ForbidExact and the value holds 
	/// the forbidden data. If this is nullopt, the value will be deleted.
	std::optional<RegistryData> replacement;

	/// The type of policy to be enforced.
	ValuePolicyType policyType;

public:

	/**
	 * \brief Instantiates a ValuePolicy object.
	 *
	 * \param key The registry key associated with this registry policy
	 * \param valueName The name of the registry value. Leave empty for the default value.
	 * \param data The data referenced by the policy. This is interpretted according to the policyType.
	 * \param policyType The policy for how the data referenced should be treated.
	 * \param name The name of the mitigation policy. This should attempt to very briefly describe what it does (i.e.
	 *       "Disable Anonymously Accessible Named Pipes")
	 * \param level The level at which this mitigation policy should be begin to be enforced. This should be Low,
	 *        Moderate, or High
	 * \param description An optional explanation for the policy (i.e. "Anonymously accessible named pipes can be used
	 *        in X, Y and Z attacks and should be disabled. See abc.com/xyz for more info [v-123]")
	 * \param replacement An optional replacement for the data. This is only used if the policyType is ForbidExact and 
	 *        the value holds the forbidden data. If this is nullopt, the value will be deleted.
	 * \param min The minimum version of the associated software where this policy applies
	 * \param max The maximum version of the associated software where this policy applies
	 */
	ValuePolicy(const RegistryKey& key, const std::wstring& valueName, const RegistryData& data, 
				ValuePolicyType policyType, const std::wstring& name, EnforcementLevel level, 
				const std::optional<std::wstring>& description = std::nullopt, 
				const std::optional<RegistryData>& replacement = std::nullopt,
				const std::optional<Version> & min = std::nullopt, const std::optional<Version> & max = std::nullopt);

	/**
	 * \brief Instantiates a ValuePolicy object from a json configuration. This may throw exceptions.
	 * 
	 * \param config The json object storing information about how the policy should be created.
	 */
	ValuePolicy(json config);

	/**
	 * \brief Enforces the mitgiation policy, applying the change to the system.
	 *
	 * \return True if the system has the mitigation policy enforced; false otherwise.
	 */
	virtual bool Enforce() override;

	/**
	 * \brief Checks if the changes specified by the mitigation policy match the current state of the
	 *        system.
	 *
	 * \return True if the system has the changes specified by the mitigation policy enforced; false
	 *         otherwise.
	 */
	virtual bool MatchesSystem() const override;
};
```

`BLUESPAWN-win-client/headers/monitor/ETW_Wrapper.h`:

```h
#pragma once
/*

#include "krabs.hpp"
#include <thread>
*/

/*
Providers on a Windows machine can be found with
cmd: logman.exe query providers
or Powershell: Get-NetEventProvider -ShowInstalled | Select-Object Name,Guid | sort Name
*/
/*
namespace etw_guid {
	static krabs::guid powershell = krabs::guid(L"{A0C1853B-5C40-4B15-8766-3CF1C58F985A}");
	static krabs::guid firewall = krabs::guid(L"{E595F735-B42A-494B-AFCD-B68666945CD3}");
	static krabs::guid groupPolicy = krabs::guid(L"{AEA1B4FA-97D1-45F2-A64C-4D69FFFD92C9}");
}

class ETW_Wrapper {
	public:
		ETW_Wrapper();
		~ETW_Wrapper();

		void init();
		void addPowershellCallback(const std::function <void(const EVENT_RECORD&)>& f);
		void addFirewallCallback(const std::function <void(const EVENT_RECORD&)>& f);
		void addGPCallback(const std::function <void(const EVENT_RECORD&)>& f);

	private:
		krabs::user_trace userTrace;

		krabs::provider<> pshellProvider;
		krabs::provider<> firewallProvider;
		krabs::provider<> groupPolicyProvider;

		std::thread * traceThread;
		void startUserTrace();
};
*/
```

`BLUESPAWN-win-client/headers/monitor/Event.h`:

```h
#pragma once

#include <functional>
#include <optional>
#include <vector>

#include "util/configurations/Registry.h"
#include "util/configurations/RegistryValue.h"
#include "util/eventlogs/EventSubscription.h"
#include "util/eventlogs/XpathQuery.h"
#include "util/filesystem/FileSystem.h"

#include "hunt/Scope.h"

enum class EventType { EventLog, Registry, FileSystem };

class Event {
    public:
    EventType type;

    void AddCallback(const std::function<void(IN CONST Scope&)>& callback, IN CONST Scope& scope = {} OPTIONAL);

    virtual void RunCallbacks() const;

    virtual bool Subscribe() = 0;

    virtual bool operator==(const Event& e) const = 0;

    protected:
    Event(EventType type);

    std::vector<std::pair<std::function<void(IN CONST Scope&)>, Scope>> callbacks;
};

class EventLogEvent : public Event {
public:

    /**
     * Creates a new event triggered by an xml
     */
    EventLogEvent(
        IN CONST std::wstring& channel, 
        IN int eventID,
        IN CONST std::vector<EventLogs::XpathQuery>& queries = {} OPTIONAL
    );

    std::function<void(EventLogs::EventLogItem)> eventLogTrigger;

    std::wstring GetChannel() const;
    int GetEventID() const;
    std::vector<EventLogs::XpathQuery> GetQueries() const;

    virtual bool Subscribe();

    virtual bool operator==(const Event& e) const;

private:
    std::optional<EventSubscription> eventSub;
    std::wstring channel;
    int eventID;
    std::vector<EventLogs::XpathQuery> queries;
};

class RegistryEvent : public Event {
    // Event that is triggered when the key changes
    HandleWrapper hEvent;

    // True if this event watches subkeys. Note that this will be unable to determine
    // which value (or subkey) was changed.
    bool WatchSubkeys;

    // The registry key being watched
    Registry::RegistryKey key;

    public:
    RegistryEvent(const Registry::RegistryKey& key, bool WatchSubkeys = false);

    const HandleWrapper& GetEvent() const;

    const Registry::RegistryKey& GetKey() const;

    virtual bool Subscribe();

    virtual bool operator==(const Event& e) const;
};

class FileEvent : public Event {
    /// Directory to be watched
    FileSystem::Folder directory;

    /// Event that is triggered when the key changes
    GenericWrapper<HANDLE> hEvent;

    public:
    FileEvent(const FileSystem::Folder& file);

    const GenericWrapper<HANDLE>& GetEvent() const;

    const FileSystem::Folder& GetFolder() const;

    virtual bool Subscribe();

    virtual bool operator==(const Event& e) const;
};

/// Template specialization defining how unique_ptrs to Events should be hashed
template<>
class std::hash<std::unique_ptr<Event>> {
    size_t operator()(IN CONST std::unique_ptr<Event>& evt) const;
};

/// Template specialization defining how unique_ptrs to Events should be compared
template<>
class std::equal_to<std::unique_ptr<Event>> {
    bool operator()(IN CONST std::unique_ptr<Event>& left, IN CONST std::unique_ptr<Event>& right) const;
};

namespace Registry {

    /**
	 * Creates a vector of events to be triggered when any value under a specified registry key path changes,
	 * automatically mirrored across users if WatchUsers is true and mirrored to WoW64 if WatchWow64 is true. The 
	 * events generated will also trigger when any subkey is changed if WatchSubkeys is set to true.
	 *
	 * @param dest The vector to which events created by this function will be added
     * @param scope The scope for events that are added
	 * @param hkHive The hive under which the path will be searched. If WatchUsers is true, this will be also be 
	 *        substituted by each user's hive. In most cases, hkHive should be HKEY_LOCAL_MACHINE.
	 * @param path The path of the key under the hive.
	 * @param WatchWow64 Indicates whether events should be generated for Wow64 versions of keys, if present
	 * @param WatchUsers Indicates whether events should be generated for the key at the path under each user's hive,
	 *        if present
	 * @param WatchSubkeys Indicates whether all events generated should be triggered when any subkey is modified
	 */
    void GetRegistryEvents(OUT std::vector<std::pair<std::unique_ptr<Event>, Scope>>& dest,
                           IN CONST Scope& scope,
                           IN HKEY hkHive,
                           IN CONST std::wstring& path,
                           IN bool WatchWow64 = true OPTIONAL,
                           IN bool WatchUsers = true OPTIONAL,
                           IN bool WatchSubkeys = false OPTIONAL);
}   // namespace Registry

```

`BLUESPAWN-win-client/headers/monitor/EventListener.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>
#include <map>
#include <thread>

#include "util/wrappers.hpp"

/**
 * An event manager for seemlessly subscribing and unsubscribing to and from events. Since this
 * class can handle all types of events, there is no need for multiple instances. Furthermore,
 * due to the internal structure of the class, it is more efficient the more events there are
 * being subscribed to. For these reasons, EventListener is a singleton class.
 */
class EventListener {
private:

	/**
	 * By default, the maximum number of events that can be waited on by WaitForMultipleObjects is
	 * 64, and it's quite possible that BLUESPAWN will need to be able to wait for more than 64
	 * different events. This class is designed to handle waiting on up to 63 events, triggering
	 * different callbacks for each event triggered.
	 *
	 * This class is meant for internal usage within EventListener
	 */
	class SubEventListener {

		/// Indicates the number of events that can be added before maximum capacity is reached
		DWORD dwSlotsFree;

		/// Stores the event handles being waited on
		std::vector<HANDLE> events;

		/// Maps events to callbacks to be run when the event is triggered
		std::map<HANDLE, std::vector<std::function<void()>>> map;

		/// A critical section guarding accesses to `map`, `events`,  and `dwSlotsFree`
		/// An SRW lock *may* perform better here, but in practice, most accesses will be writes
		CriticalSection hSection;

		/// A manager event, triggered when a new event is to be added to the queue. Used to 
		/// interrupt the current wait so another event can be added.
		/// Always acquire hSection before setting the manager event so that the event listening 
		/// thread can't begin a new wait between when the manager was set and changes are done.
		/// Always set the manager event before modifying `events`, `dwSlotsFree`, or `map`
		HandleWrapper hManager;

		/// A response event triggered whenever the manager trigger is processed. After setting 
		/// hManager, always wait for a response before continuing
		HandleWrapper hManagerResponse;

		/// A handle to the thread waiting on the events
		std::thread hThread;

		/// Keeps track of the number of consecutive wait failures
		DWORD dwFailureCount;

		/// Terminates the thread next time hManager is signaled if true
		bool terminate;

		/// A handler for processing when an event is notified
		void HandleEventNotify(HANDLE hEventNotified);

		/// The listener function run in a separate thread
		void ListenForEvents();

	public:

		/**
		 * Creates the listener, the thread, and the mutex needed to manage the event listening.
		 * The thread will be started in ListenForEvents immediately.
		 */
		SubEventListener();
		~SubEventListener();

		/// Copy constructor is deleted. Since the thread references `this`, it is very difficult to change.
		SubEventListener(const SubEventListener&) = delete;
		SubEventListener operator=(const SubEventListener&) = delete;

		/// Move constructor is deleted. Since the thread references `this`, it is very difficult to change.
		SubEventListener(SubEventListener&&) = delete;
		SubEventListener operator=(SubEventListener&&) = delete;

		/** 
		 * Tries to subscribe to an event. This function will fail if there is no room in this SubEventListener.
		 * If the event has already been subscribed to, the callbacks will be combined with those already present.
		 * Note that if the intent is to add callbacks, it is recommended that TryAddCallbacks be called instead.
		 * This function acquires hSection and releases it upon completion.
		 *
		 * @param hEvent The event being subscribed to or having callbacks added
		 * @param callbacks A vector of functions to be called when the event is triggered
		 *
		 * @return True if the function completed successfully; false if hEvent couldn't be subscribed to.
		 */
		bool TrySubscribe(
			IN const HANDLE& hEvent, 
			IN const std::vector<std::function<void()>>& callbacks
		);

		/**
		 * Checks if this SubEventListener has already subscribed to the given event. If so, this will return
		 * an optional containing the callbacks for the event. Otherwise, std::nullopt will be returned. 
		 * This function acquires hSection and releases it upon completion.
		 *
		 * @param hEvent The event to check the subscription of.
		 *
		 * @return An optional containing the callbacks for the event if present; otherwise std::nullopt
		 */
		std::optional<std::vector<std::function<void()>>> GetSubscription(
			IN const HANDLE& hEvent
		) const;

		/**
		 * Tries to add a callback to an event. This function will fail if there is this SubEventListener isn't
		 * subscribed to hEvent. 
		 * This function acquires hSection and releases it upon completion.
		 *
		 * @param hEvent The event for which the callback will be added
		 * @param callback A function to be called when hEvent is triggered
		 *
		 * @return True if the function completed successfully; false if hEvent wasn't subscribed to
		 */
		bool TryAddCallback(
			IN const HANDLE& hEvent,
			IN const std::function<void()>& callback
		);

		/**
		 * Tries to remove a callback from an event. This function will fail if there is this SubEventListener isn't
		 * subscribed to hEvent. Note that if hEvent's subscription does not contain the callback to be removed, this
		 * function will still return true. If there is a need to determine whether the subscription included the callback,
		 * see GetSubscription.
		 * This function acquires hSection and releases it upon completion.
		 *
		 * @param hEvent The event for which the callback will be removed.
		 * @param callback A function to be removed from the subscription to hEvent.
		 *
		 * @return True if the function is no longer in the subscription to hEvent; false if hEvent wasn't subscribed to
		 */
		bool TryRemoveCallback(
			IN const HANDLE& hEvent,
			IN const std::function<void()>& callback
		);

		/**
		 * Tries to remove the subscription for an event. This function will fail if this SubEventListener isn't
		 * subscribed to hEvent.
		 *
		 * @param hEvent The event whose subscription will be removed.
		 *
		 * @return True if the function completed successfully; false if the function failed
		 */
		bool TryUnsubscribe(
			IN const HANDLE& hEvent
		);
	};

	/// A vector for internal use containing the SubEventListeners.
	std::vector<std::unique_ptr<SubEventListener>> subeventlisteners;

	/// A critical section protecting access to subeventlisteners
	CriticalSection hSection;

	static EventListener instance;

	/// Creates an event listener
	EventListener();

public:

	/**
	 * Returns a reference to an EventListener instance. Since EventListener is a singleton class, this is
	 * the method used to obtain an instance.
	 *
	 * @return A reference to an EventListener instance.
	 */
	static EventListener& GetInstance();

	/**
	 * Tries to subscribe to an event. This function will fail if there is no room in this SubEventListener.
	 * If the event has already been subscribed to, the callbacks will be combined with those already present.
	 * Note that if the intent is to add callbacks, it is recommended that TryAddCallbacks be called instead.
	 * This function acquires hSection and releases it upon completion.Callbacks are handled by the thread that 
	 * manages waiting, so any callback function that requires significant calculation should create a new thread
	 * or signal some other thread to carry out the task.
	 *
	 * @param hEvent The event being subscribed to or having callbacks added
	 * @param callbacks A vector of functions to be called when the event is triggered
	 *
	 * @return True if the function completed successfully; false if hEvent couldn't be subscribed to.
	 */
	bool Subscribe(
		const HANDLE& hEvent,
		const std::vector<std::function<void()>>& callbacks
	);

	/**
	 * Checks if this EventListener has already subscribed to the given event. If so, this will return
	 * an optional containing the callbacks for the event. Otherwise, std::nullopt will be returned.
	 * This function acquires hSection and releases it upon completion.
	 *
	 * @param hEvent The event to check the subscription of.
	 *
	 * @return An optional containing the callbacks for the event if present; otherwise std::nullopt
	 */
	std::optional<std::vector<std::function<void()>>> GetSubscription(
		IN const HANDLE& hEvent
	) const;

	/**
	 * Tries to add a callback to an event. This function will fail if this EventListener is not
	 * subscribed to hEvent. Callbacks are handled by the thread that manages waiting, so any callback 
	 * function that requires significant calculation should create a new thread or signal some other 
	 * thread to carry out the task.
	 * This function acquires hSection and releases it upon completion.
	 *
	 * @param hEvent The event for which the callback will be added
	 * @param callback A function to be called when hEvent is triggered
	 *
	 * @return True if the function completed successfully; false if hEvent wasn't subscribed to
	 */
	bool AddCallback(
		IN const HANDLE& hEvent,
		IN const std::function<void()>& callback
	);

	/**
	 * Tries to remove a callback from an event. This function will fail if there is this EventListener isn't
	 * subscribed to hEvent. Note that if hEvent's subscription does not contain the callback to be removed, this
	 * function will still return true. If there is a need to determine whether the subscription included the 
	 * callback, see GetSubscription. Note that only the callback function is checked; bound arguments are ignored,
	 * which may result in undesired deletion of certain callbacks.
	 * This function acquires hSection and releases it upon completion.
	 *
	 * @param hEvent The event for which the callback will be removed.
	 * @param callback A function to be removed from the subscription to hEvent.
	 *
	 * @return True if the function is no longer in the subscription to hEvent; false if hEvent wasn't subscribed to
	 */
	bool RemoveCallback(
		IN const HANDLE& hEvent,
		IN const std::function<void()>& callback
	);

	/**
	 * Tries to remove the subscription for an event. This function will fail if this SubEventListener isn't
	 * subscribed to hEvent.
	 *
	 * @param hEvent The event whose subscription will be removed.
	 *
	 * @return True if the function completed successfully; false if the function failed
	 */
	bool Unsubscribe(
		IN const HANDLE& hEvent
	);
};
```

`BLUESPAWN-win-client/headers/monitor/EventManager.h`:

```h
#pragma once

#include <functional>
#include <string>
#include "hunt/Scope.h"
#include "Event.h"
#include "util/eventlogs/EventSubscription.h"

class EventManager {

	public:
		DWORD SubscribeToEvent(std::unique_ptr<Event>&& e, const std::function<void(IN CONST Scope&)>& callback,
							   IN CONST Scope& scope);
		
		// EventManager is a singleton class; call GetInstance() to get an instance of it.
		static EventManager& GetInstance();

	private:

		// Make constructor private for singleton class
		EventManager();

		// Delete copy and move constructors
		EventManager(const EventManager&) = delete;
		EventManager(EventManager&&) = delete;
		EventManager operator=(const EventManager&) = delete;
		EventManager operator=(EventManager&&) = delete;

		static EventManager manager;
		std::vector<std::unique_ptr<Event>> vEventList;
};
```

`BLUESPAWN-win-client/headers/reaction/CarveMemory.h`:

```h
#pragma once
#include "Reaction.h"

#include "hunt/HuntInfo.h"
#include "user/iobase.h"

namespace Reactions{

	class CarveMemoryReaction : public Reaction {

		/**
		 * Reacts to a registry detection by carving infected memory sections from a process
		 * Note that this will cause a crash if function pointers are stored to the infected
		 * memory for functions with more than four arguments in x64 or any arguments with 
		 * stdcall functions in x86.
		 *
		 * @param detection The detection to which the reaction will be applied.
		 */
		virtual void React(
			IN Detection& detection
		);

		/**
		 * Function to determine if this reaction applies to a detection. This ensures that
		 * the detection is not stale and that it references a registry value.
		 *
		 * @param detection The detection to check
		 *
		 * @return True if this reaction applies; false otherwise
		 */
		virtual bool Applies(
			IN CONST Detection& detection
		);
	};
}


```

`BLUESPAWN-win-client/headers/reaction/DeleteFile.h`:

```h
#pragma once
#include <optional>

#include "util/DynamicLinker.h"

#include "Reaction.h"
#include "hunt/HuntInfo.h"
#include "user/iobase.h"

namespace Reactions {

    class DeleteFileReaction : public Reaction {
        /**
		 * Reacts to a file detection by deleting it, taking ownership if necessary
		 *
		 * @param detection The detection to which the reaction will be applied.
		 */
        virtual void React(IN Detection& detection);

        /**
		 * Function to determine if this reaction applies to a detection. This ensures that
		 * the detection is not stale and reference a file
		 *
		 * @param detection The detection to check
		 *
		 * @return True if this reaction applies; false otherwise
		 */
        virtual bool Applies(IN CONST Detection& detection);
    };
}   // namespace Reactions

```

`BLUESPAWN-win-client/headers/reaction/QuarantineFile.h`:

```h
#pragma once
#include <optional>

#include "util/DynamicLinker.h"

#include "Reaction.h"
#include "hunt/HuntInfo.h"
#include "user/iobase.h"

namespace Reactions {

	class QuarantineFileReaction : public Reaction {
		/**
		 * Reacts to a file detection by quarantining it
		 *
		 * @param detection The detection to which the reaction will be applied.
		 */
		virtual void React(IN Detection& detection);

		/**
		 * Function to determine if this reaction applies to a detection. This ensures that
		 * the detection is not stale and reference a file
		 *
		 * @param detection The detection to check
		 *
		 * @return True if this reaction applies; false otherwise
		 */
		virtual bool Applies(IN CONST Detection& detection);
	};
}   // namespace Reactions

```

`BLUESPAWN-win-client/headers/reaction/Reaction.h`:

```h
#pragma once

#include <functional>

#include "scan/Detections.h"

/// Forward declare ReactionManager to it can be a friend
class ReactionManager;

class Reaction {
    /// Indicates if this reaction runs even if a remediator already exists
    bool IgnoreRemediator = false;

    friend class ReactionManager;

    public:
    /**
	 * React to a detection. The reaction manager will ensure that this reaction
	 * applies to the detection before calling this function.
	 *
	 * @param detection The detection to which the reaction will be applied.
	 */
    virtual void React(IN Detection& detection) = 0;

    /**
	 * Function to determine if this reaction applies to a detection.
	 *
	 * @param detection The detection to check
	 *
	 * @return True if this reaction applies; false otherwise
	 */
    virtual bool Applies(IN CONST Detection& detection) = 0;
};

```

`BLUESPAWN-win-client/headers/reaction/ReactionManager.h`:

```h
#pragma once
#include <Windows.h>

#include <vector>
#include <string>

#include "reaction/Reaction.h"
#include "hunt/HuntInfo.h"
#include "scan/Detections.h"

/**
 * A container class for handling reactions to various types of detections.
 */
class ReactionManager {
protected: 
	
	/// Handlers for detections
	std::vector<std::unique_ptr<Reaction>> reactions;

public: 

	/**
	 * Runs reactions applying to each detection. Note that if the detection has a remediator,
	 * only reactions with IgnoreRemediator set to true will be run. The caller must acquire the
	 * detection's critical section before attempting to call this function.
	 *
	 * @param detection The detection for which handlers will be run
	 */
	void React(
		IN Detection& detection
	) CONST;

	/**
	 * Adds a handler to be run for each detection
	 *
	 * @param handler A reaction to be added to the manager's list of reactions
	 */
	void AddHandler(
		IN std::unique_ptr<Reaction>&& reaction
	);
};
```

`BLUESPAWN-win-client/headers/reaction/RemoveValue.h`:

```h
#pragma once
#include "Reaction.h"

#include "hunt/HuntInfo.h"
#include "user/iobase.h"
#include "util/DynamicLinker.h"

#include <optional>

namespace Reactions{

	class RemoveValueReaction : public Reaction {

		/**
		 * Reacts to a registry detection by removing it from the registry
		 *
		 * @param detection The detection to which the reaction will be applied.
		 */
		virtual void React(
			IN Detection& detection
		);

		/**
		 * Function to determine if this reaction applies to a detection. This ensures that
		 * the detection is not stale and that it references a registry value.
		 *
		 * @param detection The detection to check
		 *
		 * @return True if this reaction applies; false otherwise
		 */
		virtual bool Applies(
			IN CONST Detection& detection
		);
	};
}


```

`BLUESPAWN-win-client/headers/reaction/SuspendProcess.h`:

```h
#pragma once
#include "Reaction.h"

#include "hunt/HuntInfo.h"
#include "user/iobase.h"
#include "util/DynamicLinker.h"

#include <optional>

DEFINE_FUNCTION(NTSTATUS, NtSuspendProcess, NTAPI, IN HANDLE ProcessHandle);

namespace Reactions{

	class SuspendProcessReaction : public Reaction {

		/**
		 * Reacts to a process detection by suspeding the process
		 *
		 * @param detection The detection to which the reaction will be applied.
		 */
		virtual void React(
			IN Detection& detection
		);

		/**
		 * Function to determine if this reaction applies to a detection. This ensures that
		 * the detection is not stale and that it references a process.
		 *
		 * @param detection The detection to check
		 *
		 * @return True if this reaction applies; false otherwise
		 */
		virtual bool Applies(
			IN CONST Detection& detection
		);
	};
}



```

`BLUESPAWN-win-client/headers/scan/DetectionRegister.h`:

```h
#pragma once

#include <map>
#include <unordered_set>
#include <queue>

#include "scan/Detections.h"

#include "util/Promise.h"

/**
 * Keeps track of all detections found so far
 */
class DetectionRegister {

	/// A vector containing all detections made
	std::vector<std::shared_ptr<Detection>> detections;

	/// A mapping of detection IDs to their associated detections
	std::unordered_map<DWORD, std::shared_ptr<Detection>> ids;

	/// CriticalSection guarding accesses to `detections` and `ids`.
	CriticalSection hGuard;

	/// A set containing all detections scanned
	std::unordered_set<std::shared_ptr<Detection>> scanned;

	/// CriticalSection guarding access to `scanned`
	CriticalSection hScannedGuard;

	/// A set containing all detections found but not done being scanned
	std::unordered_set<std::shared_ptr<Detection>> queue;

	/// CriticalSection guarding accesses to `queue`.
	CriticalSection hQueueGuard;

	/// Event to be signalled when there are no remaining queued detections
	HandleWrapper hEvent;

	/// The The minimum level of certainty required to search for associated detections
	Certainty threshold;

	/// Called behind the scenes when queueing a scan with AddDetection
	void AddDetectionAsync(
		IN CONST std::shared_ptr<Detection>& detection,
		IN CONST Certainty& level = Certainty::None OPTIONAL
	);

	/// Used to update the certainty of a detection, possibly triggering assocation scans
	void UpdateDetectionCertainty(
		IN CONST std::shared_ptr<Detection>& detection,
		IN CONST Certainty& level = Certainty::None OPTIONAL
	);

public:

	/**
	 * Instantiates a new DetectionRegister with a specified threshold for running associativity
	 * scans. 
	 *
	 * @param threshold The minimum level of certainty required to search for associated detections
	 *        for any detection registered
	 */	
	DetectionRegister(
		IN CONST Certainty& threshold
	);

	/**
	 * Adds a task to the threadpool to scan a detection and add it to `detections`. If it is
	 * found to be malicious, associated detections will be identified and added as well. If the
	 * detection already exists, the certainty specified (if any) will be combined with the 
	 * certainty it already has, which may trigger new detections being added.
	 *
	 * @param detection The detection to add
	 * @param level The degree of certainty that this detection is malicious. By default, this is 
	 *              Certainty::None
	 *
	 * @return A reference to the detection added.
	 */
	std::shared_ptr<Detection> AddDetection(
		IN Detection&& detection, 
		IN CONST Certainty& level = Certainty::None OPTIONAL
	);

	/** 
	 * Retrieves all detections above a specified certainty level. This implicitly calls Wait()
	 *
	 * @param level The minimum certainty of detections to be retrieved
	 * 
	 * @return A vector of detections above the specified level
	 */
	std::vector<std::shared_ptr<Detection>> GetAllDetections(
		IN CONST Certainty& level = Certainty::Moderate OPTIONAL
	) CONST;
	
	/**
	 * Gets a detection by its ID
	 *
	 * @param ID The ID of the detection to retrieve
	 *
	 * @return A pointer to the requested detection if available; nullptr otherwise.
	 */
	std::shared_ptr<Detection> GetByID(
		IN DWORD ID
	) CONST;

	/**
	 * Waits for all queued detections to be finished being scanned. 
	 */
	void Wait() CONST;

	/**
	 * Implicit cast to handle returns an event to be signalled when there are no more detection
	 * scans queued.
	 */
	operator HANDLE() CONST;
};
```

`BLUESPAWN-win-client/headers/scan/Detections.h`:

```h
#pragma once

#include <Windows.h>

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <atomic>

#include "util/configurations/RegistryValue.h"
#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "scan/YaraScanner.h"
#include "scan/ScanInfo.h"

/// Identifies the type of detection a Detection object represents
enum class DetectionType {
	ProcessDetection,
	RegistryDetection,
	FileDetection,
	ServiceDetection,
	OtherDetection,
};

/// Describes the type of registry entry associated with a RegistryDetectionData object
enum class RegistryDetectionType {
	CommandReference, // The associated value is either a REG_SZ or REG_EXPAND_SZ that references a command used to run
	                  // a program
	FileReference,    // The associated value is either a REG_SZ or REG_EXPAND_SZ that references a file
	FolderReference,  // The associated value is either a REG_SZ or REG_EXPAND_SZ that references a folder
	PipeReference,    // The associated value is either a REG_SZ that references a named pipe
	ShareReference,   // The associated value is either a REG_SZ that references a share
	UserReference,    // The associated value is either a REG_SZ that references a user
	Configuration,    // The associated value references a configuration for the operating system
	Unknown,          // The associated value is assumed malicious, though its usage is unknown
};

/// Describes the type of detection is associated with a ProcessDetectionData object
enum class ProcessDetectionType {
	MaliciousProcess, // Refers to the process itself rather than something within it
	MaliciousImage,   // Refers to a specific image within the process
	MaliciousMemory,  // Refers to a location in memory of the process
	MaliciousCommand, // Refers to a command to be used to spawn a process. If a specific process is identified,
	                  // the type should be MaliciousProcess instead
};

/**
 * Stores information about a process or memory location identified as possibly malicious
 */
struct ProcessDetectionData {

	/// Describes the type of detection is associated with this
	ProcessDetectionType type;

	/// The process ID of the process
	std::optional<DWORD> PID;

	/// The thread IDs of the threads within the process that triggered the detection. 
	/// This will rarely be used.
	std::optional<DWORD> TID;

	/// An open handle to the process
	std::optional<HandleWrapper> ProcessHandle;

	/// The name of the process
	std::optional<std::wstring> ProcessName;

	/// The path to the executable image of the process
	std::optional<std::wstring> ProcessPath;

	/// The command used to spawn the process
	std::optional<std::wstring> ProcessCommand;

	/// The parent of the process
	std::optional<std::shared_ptr<ProcessDetectionData>> ParentProcess;

	/// The base address of the potentially malicious memory segment inside the process
	std::optional<PVOID64> BaseAddress;

	/// The size of the potentially malicious memory segment
	std::optional<DWORD> MemorySize;

	/// The name of the image in memory being referenced by the detection. 
	std::optional<std::wstring> ImageName;

	/**
	 * Instantiates a ProcessDetectionData object representing a malicious image loaded in
	 * to a process. This constructor is intended to be used primarily when a handle to the
	 * process is infeasible to obtain. Note that this constructor is intended to be used 
	 * when a loaded libary is determined to be malicious, not when the library is infected,
	 * hooked, stomped, hollowed, doppelganged, or similar. No arguments will be deduced
	 * when using this constructor.
	 * 
	 * @param PID The process ID of the process
	 * @param ProcessName The name of the process
	 * @param ImageName The name of the image in memory being referenced by the detection
	 * @param BaseAddress The base address of the image in memory
	 * @param MemorySize The size of the image in memory
	 * @param ProcessPath The path to the executable image of the process
	 * @param ProcessCommand The command used to spawn the process
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information
	 *        on the parent process.
	 */
	static ProcessDetectionData CreateImageDetectionData(
		IN DWORD PID,
		IN CONST std::wstring& ProcessName,
		IN CONST std::wstring& ImageName,
		IN CONST std::optional<PVOID64>& BaseAddress = std::nullopt OPTIONAL,
		IN CONST std::optional<DWORD>& MemorySize = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * Instantiates a ProcessDetectionData object representing a malicious image loaded in
	 * to a process. This constructor is intended to be used whenever a handle is available.
	 * Most of the arguments can be calculated, though if they are available, passing them
	 * improves efficiency. Note that this constructor is intended to be used when a loaded
	 * libary is determined to be malicious, not when the library is infected, hooked, stomped, 
	 * hollowed, doppelganged, or similar.
	 *
	 * @param PID The process ID of the process
	 * @param ProcessName The name of the process
	 * @param ImageName The name of the image in memory being referenced by the detection
	 * @param BaseAddress The base address of the image in memory. If skipped, this will be 
     *		  automatically deduced
	 * @param MemorySize The size of the image in memory. If skipped, this will be automatically
     *		  deduced
	 * @param ProcessPath The path to the executable image of the process. If skipped, this will 
     *		  be automatically deduced
	 * @param ProcessCommand The command used to spawn the process. If skipped, this will be 
     *		  automatically deduced
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information
	 *        on the parent process. If skipped, this will be automatically deduced
	 */
	static ProcessDetectionData CreateImageDetectionData(
		IN CONST HandleWrapper& ProcessHandle,
		IN CONST std::wstring& ProcessName,
		IN CONST std::wstring& ImageName,
		IN CONST std::optional<PVOID64>& BaseAddress = std::nullopt OPTIONAL,
		IN CONST std::optional<DWORD>& MemorySize = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * 
	 * This constructor is intended to be used primarily when a handle to the process is
	 * infeasible to obtain. This constructor generally will be used when there is little other
	 * information available as to what specifically is malicious or when the process is
	 * achieving a malicious purpose even though each image inside is benign (as with powershell).
	 *
	 * @param PID The process ID of the process
	 * @param ProcessName The name of the process
	 * @param ProcessPath The path to the executable image of the process
	 * @param ProcessCommand The command used to spawn the process
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information
	 *        on the parent process.
	 */
	static ProcessDetectionData CreateProcessDetectionData(
		IN DWORD PID,
		IN CONST std::wstring& ProcessName,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * Instantiates a ProcessDetectionData object representing a process which may be malicious. 
	 * This constructor is intended to be used whenever a handle is available. Most of the 
	 * arguments can be calculated, though if they are available, passing them improves efficiency. 
	 * This constructor generally will be used when there is little other information available as 
	 * to what specifically is malicious or when the process is achieving a malicious purpose even 
	 * though each image inside is benign (as with powershell).
	 *
	 * @param PID The process ID of the process
	 * @param ProcessName The name of the process
	 * @param ProcessPath The path to the executable image of the process. If skipped, this will
	 *		  be automatically deduced
	 * @param ProcessCommand The command used to spawn the process. If skipped, this will be
	 *		  automatically deduced
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information
	 *        on the parent process. If skipped, this will be automatically deduced
	 */
	static ProcessDetectionData CreateProcessDetectionData(
		IN CONST HandleWrapper& ProcessHandle,
		IN CONST std::wstring& ProcessName,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * Instantiates a ProcessDetectionData object representing a malicious memory section loaded in to a process. This 
	 * constructor is intended to be used primarily when a handle to the process is infeasible to obtain. Note that 
	 * this constructor is intended to be used when the library is infected, hooked, stomped, hollowed, doppelganged, 
	 * or similar, not when a loaded libary is determined to be malicious. No arguments will be deduced when using this
	 * constructor.
	 *
	 * @param PID The process ID of the process
	 * @param ProcessName The name of the process
	 * @param BaseAddress The base address of the memory section
	 * @param MemorySize The size of the memory section
	 * @param ImageName The name of the image in memory being referenced by the detection
	 * @param ProcessPath The path to the executable image of the process
	 * @param ProcessCommand The command used to spawn the process
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information on the parent process
	 */
	static ProcessDetectionData CreateMemoryDetectionData(
		IN DWORD PID,
		IN CONST std::wstring& ProcessName,
		IN PVOID64 BaseAddress,
		IN DWORD MemorySize,
		IN CONST std::optional<std::wstring>& ImageName = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * Instantiates a ProcessDetectionData object representing a malicious memory section loaded in to a process. This 
	 * constructor is intended to be used whenever a handle is available. Most of the arguments can be calculated, 
	 * though if they are available, passing them improves efficiency. Note that this constructor is intended to be 
	 * used when the library is infected, hooked, stomped, hollowed, doppelganged, or similar, not when a loaded libary
	 * is determined to be malicious.
	 *
	 * @param ProcessHandle An open handle to the process
	 * @param ProcessName The name of the process
	 * @param BaseAddress The base address of the memory section
	 * @param MemorySize The size of the memory section
	 * @param ImageName The name of the image in memory being referenced by the detection. If skipped, this will be 
	 *        automatically deduced if possible.
	 * @param ProcessPath The path to the executable image of the process. If skipped, this will be automatically 
	 *        deduced
	 * @param ProcessCommand The command used to spawn the process. If skipped, this will be automatically deduced
	 * @param ParentProcess An pointer to a ProcessDetectionData struct containing information on the parent process. 
	 *        If skipped, this will be automatically deduced
	 */
	static ProcessDetectionData CreateMemoryDetectionData(
		IN CONST HandleWrapper& ProcessHandle,
		IN CONST std::wstring& ProcessName,
		IN PVOID64 BaseAddress,
		IN DWORD MemorySize,
		IN CONST std::optional<std::wstring>& ImageName = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessPath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& ProcessCommand = std::nullopt OPTIONAL,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess = nullptr OPTIONAL
	);

	/**
	 * Instantiates a ProcessDetectionData object representing a malicious command used to spawn a process.
	 *
	 * @param ProcessCommand The command used to spawn a process
	 */
	static ProcessDetectionData CreateCommandDetectionData(
		IN CONST std::wstring& ProcessCommand
	);

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal representations
	 * but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() CONST;

	/**
	 * Compute a hash for this detection data
	 *
	 * @return A hash for this detection data
	 */
	size_t Hash() CONST;

	/**
	 * Override comparison operator
	 *
	 * @param detection The data to compare
	 *
	 * @return True if the data is equal to this; false otherwise
	 */
	bool operator==(const ProcessDetectionData& detection) CONST;

private:

	/// Record the hash of the data
	size_t hash = 0;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization = {};

	/// Raw constructor for a ProcessDetectionData
	ProcessDetectionData(
		IN ProcessDetectionType type,
		IN CONST std::optional<DWORD> PID,
		IN CONST std::optional<DWORD> & TID,
		IN CONST std::optional<HandleWrapper>& ProcessHandle,
		IN CONST std::optional<std::wstring> & ProcessName,
		IN CONST std::optional<std::wstring>& ProcessPath,
		IN CONST std::optional<std::wstring>& ProcessCommand,
		IN std::unique_ptr<ProcessDetectionData>&& ParentProcess,
		IN CONST std::optional<PVOID64>& BaseAddress,
		IN CONST std::optional<DWORD>& MemorySize,
		IN CONST std::optional<std::wstring>& ImageName
	);
};

/**
 * Stores information about a file identified as possibly malicious
 */
struct FileDetectionData {

	/// Indicates whether the file was found on the filesystem
	bool FileFound;

	/// Information about the directory listing for the file
	std::wstring FilePath;
	std::wstring FileName;
	std::optional<std::wstring> FileExtension;

	/// The type of the file. This differs from extensions in that mutliple different
	/// file extensions may correspond to the same filetype. 
	std::optional<std::wstring> FileType;

	/// Command run to open the file. Stored in HKCR\<File Type>\shell\open\command
	std::optional<std::wstring> Executor;

	/// A handle for the file
	std::optional<FileSystem::File> FileHandle;

	/// Hashes of the file
	std::optional<std::wstring> MD5;
	std::optional<std::wstring> SHA1;
	std::optional<std::wstring> SHA256;

	/// Timestamps associated with the file
	std::optional<FILETIME> LastOpened;
	std::optional<FILETIME> FileCreated;

	/// Information about a yara scan performed on the file
	std::optional<YaraScanResult> yara;

	/// Indicates whether the file is properly signed and the signature is trusted
	std::optional<bool> FileSigned;

	/// The title of the signer of this file, given that the file is signed
	std::optional<std::wstring> Signer;

	/**
	 * Creates a FileDetectionData using an open handle to the file. This works under the assumption that the 
	 * detection matches the file found on disk. If generating this detection from event logs or other records this 
	 * may not be the case. If the file has already been scanned with yara, it is recommended that the result be passed
	 * in to the constructor so that it doesn't have to be scanned a second time.
	 * 
	 * @param file A File object representing the file.
	 * @param scan The result of a yara scan performed on a file. This parameter is optional, but providing the result 
	 * will avoid the need for the scan to be repeated.
	 */
	FileDetectionData(
		IN CONST FileSystem::File& file,
		IN CONST std::optional<YaraScanResult>& scan = std::nullopt OPTIONAL
	);

	/**
	 * Creates a FileDetectionData using the file's path on disk. This constructor is best used when the file could not
	 * be found or it is infeasible to construct a File object representing the underlying file. If a File object is 
	 * available, using the other constructor will be more efficient.
	 *
	 * @param FilePath The path of the file
	 */
	FileDetectionData(
		IN CONST std::wstring& FilePath
	);

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal representations
	 * but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() CONST;

	/**
	 * Compute a hash for this detection data
	 *
	 * @return A hash for this detection data
	 */
	size_t Hash() CONST;

	/**
	 * Override comparison operator
	 *
	 * @param detection The data to compare
	 *
	 * @return True if the data is equal to this; false otherwise
	 */
	bool operator==(const FileDetectionData& detection) const;

private:

	/// Record the hash of the data
	size_t hash = 0;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization = {};
};

/**
 * Stores information about a registry entry identified as possibly malicious. This entry may be a whole registry key,
 * a registry value, or just part of a registry value.
 *
 * If a registry value is detected on and it is a REG_MULTI_SZ, rather than creating one detection for the value as a 
 * whole, create a separate detection for each potentially malicious entry in the value as a REG_SZ.
 */
struct RegistryDetectionData {

	/// The path of the registry key associated with the registry entry
	std::wstring KeyPath;

	/// The key associated with the registry entry.
	Registry::RegistryKey key;

	/// An optional value under the key associated with the registry entry
	std::optional<Registry::RegistryValue> value;

	/// The raw data contained in the registry entry.
	std::optional<AllocationWrapper> data;

	/// The type of data in this registry detection
	RegistryDetectionType type;

	/**
	 * Creates a RegistryDetectionData, referencing either a registry key, a registry value, or part of a registry 
	 * value. If a registry value is detected on and it is a REG_MULTI_SZ, rather than creating one detection for the 
	 * value as a whole, create a separate detection for each potentially malicious entry in the value as a REG_SZ.
	 *
	 * @param key The associated with the registry entry.
	 * @param value An optional value under the key associated with the registry entry
	 * @param type The type of data referenced by this registry value. This defaults to Unknown
	 * @param data An optional allocation wrapper storing the raw data associated with the registry entry. If `value` 
	 *        represents only part of a registry value's data, this should not be set.
	 */
	RegistryDetectionData(
		IN CONST Registry::RegistryKey& key,
		IN CONST std::optional<Registry::RegistryValue>& value = std::nullopt OPTIONAL,
		IN RegistryDetectionType type = RegistryDetectionType::Unknown OPTIONAL,
		IN CONST std::optional<AllocationWrapper>& data = std::nullopt OPTIONAL
	);

	/**
	 * Creates a RegistryDetectionData, referencing either a registry key, a registry value, or part of a registry
	 * value. If a registry value is detected on and it is a REG_MULTI_SZ, rather than creating one detection for the
	 * value as a whole, create a separate detection for each potentially malicious entry in the value as a REG_SZ.
	 *
	 * @param value A RegistryValue object containing information about the value
	 * @param type The type of data referenced by this registry value. This defaults to Unknown.
	 */
	RegistryDetectionData(
		IN CONST Registry::RegistryValue& value,
		IN RegistryDetectionType type = RegistryDetectionType::Unknown OPTIONAL
	);

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal representations
	 * but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() CONST;

	/**
	 * Compute a hash for this detection data
	 *
	 * @return A hash for this detection data
	 */
	size_t Hash() CONST;

	/**
	 * Override comparison operator
	 *
	 * @param detection The data to compare
	 *
	 * @return True if the data is equal to this; false otherwise
	 */
	bool operator==(const RegistryDetectionData& detection) const;

private:

	/// Record the hash of the data
	size_t hash = 0;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization = {};
};

/**
 * Stores information about a service identified as possibly malicious. Note that when creating a service detection 
 * object, it is recommended that the registry keys and files associated with the service should have separate 
 * detection objects.
 */
struct ServiceDetectionData {

	/// The name of the service
	std::optional<std::wstring> ServiceName;

	/// The display name of the service
	std::optional<std::wstring> DisplayName;

	/// The description of the service
	std::optional<std::wstring> Description;

	/// The service path
	std::optional<std::wstring> FilePath;

	/**
	 * Creates a ServiceDetectionData object, referencing a windows service that may be malicious. Either DisplayName
	 * or ServiceName is required.
	 * 
	 * @param ServiceName The name of the service
	 * @param DisplayName The display name of the service
	 * @param FilePath The path the the service executable
	 * @param Description The description of the service
	 */
	ServiceDetectionData(
		IN CONST std::optional<std::wstring>& ServiceName = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& DisplayName = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& FilePath = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& Description = std::nullopt OPTIONAL
	);

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal representations
	 * but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() CONST;

	/**
	 * Compute a hash for this detection data
	 *
	 * @return A hash for this detection data
	 */
	size_t Hash() CONST;

	/**
	 * Override comparison operator
	 *
	 * @param detection The data to compare
	 *
	 * @return True if the data is equal to this; false otherwise
	 */
	bool operator==(const ServiceDetectionData& detection) const = default;

private:

	/// Record the hash of the data
	size_t hash = 0;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization = {};
};

/**
 * Stores information about something not covered by other detection types identified as possibly malicious. This 
 * includes things such as users, groups, shares, pipes, and more.
 */
struct OtherDetectionData {
	
	/// A string describing the type of detection associated with this object.
	std::wstring DetectionType;

	/// Stores data about the detection
	std::map<std::wstring, std::wstring> DetectionProperties;

	/**
	 * Creates an OtherDetectionData object, referencing something on the system identified as possibly malicious. 
	 * OtherDetectionData objects consist of a type and a map of properties and their values, represented as strings.
	 *
	 * @param DetectionType A string describing the type of detection associated with this object
	 * @param DetectionProperties A mapping of property to value describing what's being referenced by this.
	 */
	OtherDetectionData(
		IN CONST std::wstring& DetectionType,
		IN CONST std::map<std::wstring, std::wstring>& DetectionProperties
	);

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal representations 
	 * but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() CONST;

	/**
	 * Compute a hash for this detection data
	 *
	 * @return A hash for this detection data
	 */
	size_t Hash() CONST;

	/**
	 * Override comparison operator
	 *
	 * @param detection The data to compare
	 *
	 * @return True if the data is equal to this; false otherwise
	 */
	bool operator==(const OtherDetectionData& detection) const = default;

private:

	/// Record the hash of the data
	size_t hash = 0;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization = {};
};

/// Stores contextual information around a detection
struct DetectionContext {
	
	/// A set of the hunts that identified the detection
	std::set<std::wstring> hunts;
	
	/// The time at which the first evidence of the detection was created
	std::optional<FILETIME> FirstEvidenceTime;

	/// The time at which the detection was created
	FILETIME DetectionCreatedTime;

	/// An optional note describing why this detection was marked as potentially malicious
	std::optional<std::wstring> note;

	/**
	 * Creates a DetectionContext for a detection. 
	 *
	 * @param DetectionCreatedTime The time at which the detection was created
	 * @param hunt If the associated detection is created by a hunt, this is the hunt responsible for creating it
	 * @param FirstEvidenceTime The time at which the first evidence of this detection was created
	 */
	DetectionContext(
		IN CONST std::optional<std::wstring>& hunt = std::nullopt OPTIONAL,
		IN CONST std::optional<FILETIME>& FirstEvidenceTime = std::nullopt OPTIONAL,
		IN CONST std::optional<std::wstring>& note = std::nullopt OPTIONAL
	);
};

/// A container for the various type of detection data a Detection object may reference
typedef std::variant<
	ProcessDetectionData,
	FileDetectionData,
	RegistryDetectionData,
	ServiceDetectionData,
	OtherDetectionData
> DetectionData;

/**
 * Represents something that has been identified as potentially malicious. Each detection object can be further broken 
 * down in to the types laid out in the DetectionType enum. Each type of detection then has an associated DetectionData
 * object providing information on the details of what was detected. Each detection also may hold a remediator, which 
 * will handle the detection, either removing it, fixing it, or mitigating it. This remediator can be used by a 
 * reaction and should be set when the detection is created if possible. Finally, the the detection will hold a 
 * DetectionContext object, which holds information about the detection itself, such as the hunts that generated it, 
 * when it was generated, and when the thing being detected was first identified.
 */
class Detection {
private:

	/// Record the hash of the data
	size_t hash;

	/// Record the serialization of the data
	std::map<std::wstring, std::wstring> serialization;

	/// A shared counter to keep track of detection IDs and ensure each new detection gets assigned
	/// a unique identifier.
	static volatile std::atomic<DWORD> IDCounter;

	/// A struct used to serialize detection data
	static struct {
		std::map<std::wstring, std::wstring> operator()(ProcessDetectionData data){
			return data.Serialize();
		}
		std::map<std::wstring, std::wstring> operator()(FileDetectionData data){
			return data.Serialize(); 
		}
		std::map<std::wstring, std::wstring> operator()(RegistryDetectionData data){
			return data.Serialize();
		}
		std::map<std::wstring, std::wstring> operator()(ServiceDetectionData data){
			return data.Serialize();
		}
		std::map<std::wstring, std::wstring> operator()(OtherDetectionData data){
			return data.Serialize(); 
		}
	} serializer;

	/// A struct used to hash detection data
	static struct {
		size_t operator()(ProcessDetectionData data){ return data.Hash(); }
		size_t operator()(FileDetectionData data){ return data.Hash(); }
		size_t operator()(RegistryDetectionData data){ return data.Hash(); }
		size_t operator()(ServiceDetectionData data){ return data.Hash(); }
		size_t operator()(OtherDetectionData data){ return data.Hash(); }
	} hasher;

	/// Declare related hash classes to be friends
	friend class std::hash<Detection>;
	friend class std::hash<std::shared_ptr<Detection>>;

public:

	/// A unique identifier for this detection
	DWORD dwID;

	/// Indicates whether the data represented by this detection is consistent with the current state of the operating
	/// system.
	bool DetectionStale;

	/// Indicates the type of this detection
	DetectionType type;

	/// Describes what this detection object is representing
	DetectionData data;

	/// Information related to the scans performed on this detection
	ScanInfo info;

	/// A function that when run will remediate the detection, either removing it, fixing it, or  mitigating it.
	std::optional<std::function<void()>> remediator;

	/// Describes the context surrounding the detection such as when the first evidence of the detection was created, 
	/// the hunts generating this detection, and the time the detection was generated.
	DetectionContext context;

	/// A critical section guarding access to members of this class
	CriticalSection hGuard;

	/**
	 * Creates a Detection object, given associated data, optional context, an optional remediator, and an optional 
	 * indicator as to whether the detection is stale.
	 *
	 * @param data The data associated with the detection to be created. The type will be deduced.
	 * @param context The context surrounding the detection. If not provided, this will default to only include the 
	 *        time.
	 * @param remediator A function that can be used to remediate the detection if it is determined to be malicious. 
	 *        By default, there is no remediator.
	 * @param DetectionStale A boolean indicating whether the data represented by this detection is consistent with 
	 *        the current state of the operating system. This defaults to false.
	 */
	Detection(
		IN CONST DetectionData& data,
		IN CONST std::optional<DetectionContext>& context = std::nullopt OPTIONAL,
		IN CONST std::optional<std::function<void()>>& remediator = std::nullopt OPTIONAL,
		IN bool DetectionStale = false OPTIONAL
	);

	/// Define a copy constructor
	Detection(
		IN CONST Detection& detection
	);
	
	/// Define assignment operator
	Detection& operator=(
		IN CONST Detection& detection
	);

	/**
	 * Override for equality comparison operator. This checks if the data matches, ignoring other fields.
	 *
	 * @param detection The detection to compare
	 * 
	 * @return True if the detection is equal to this; false otherwise
	 */
	bool operator==(
		IN CONST Detection& detection
	) const;

	/**
	 * Serialize the detection data in to a mapping of values. Note this should not include any internal 
	 * representations but rather only include values that have meaning outside of BLUESPAWN's running.
	 *
	 * @return A mapping of properties to human-readable values
	 */
	const std::map<std::wstring, std::wstring>& Serialize() const;

	/**
	 * Implicit cast to a CRITICAL_SECTION pointer for use in synchronization functions
	 *
	 * @return hGuard
	 */
	operator LPCRITICAL_SECTION();

	/**
	 * Implicit cast to a CriticalSection pointer for use in synchronization functions
	 *
	 * @return hGuard
	 */
	operator CriticalSection();
};

/// Template specialization defining how hashes of Detection objects should be calculated
template<>
struct std::hash<Detection> {

	/// Hashes a detection using its data
	size_t operator()(
		IN CONST Detection& detection
	) const;
};

/// Template specialization defining how hashes of reference wrappers for Detection objects should be calculated
template<>
struct std::hash<std::shared_ptr<Detection>> {

	/// Hashes a detection using its data
	size_t operator()(
		IN CONST std::shared_ptr<Detection>& detection
	) const;
};

/// Template specialization defining how equality of reference wrappers for Detection objects should be calculated
template<>
struct std::equal_to<std::shared_ptr<Detection>> {

	/// Compares reference wrappers by comparing their wrapped value
	bool operator()(
		IN CONST std::shared_ptr<Detection>& _Left,
		IN CONST std::shared_ptr<Detection>& _Right
	) const;
};
```

`BLUESPAWN-win-client/headers/scan/FileScanner.h`:

```h
#pragma once

#include "scan/ScanInfo.h"

#include <unordered_map>
#include <vector>
#include <unordered_set>

#include "scan/Scanner.h"

class FileScanner : public Scanner {
	
	/// A mapping of module names to sets of the PIDs of processes with the module loaded
	std::unordered_map<std::wstring, std::unordered_set<DWORD>> modules;

	/// A mapping of hashes to the modules that match the hash
	std::unordered_map<std::wstring, std::unordered_set<std::wstring>> hashes;

	/// The last time that `modules` was updated
	FILETIME ModuleLastUpdateTime;

	/// The rate at which `modules` is updated, in milliseconds
	static const DWORD MODULE_UPDATE_INTERVAL{ 300000 };

	/// CriticalSection guarding access to `modules`, `hashes`, and `ModuleLastUpdateTime`
	CriticalSection hGuard;

	/// Checks if `modules` needs to be updated, and if so, updates it and `ModuleLastUpdateTime`
	void UpdateModules();

public:
	
	/**
	 * Searches through the strings given for strings referencing a file
	 *
	 * @param strings A vector of strings to search
	 *
	 * @return A vector of strings referencing files
	 */
	static std::vector<std::wstring> ExtractFilePaths(
		IN CONST std::vector<std::wstring>& strings
	);

	/** 
	 * Searches through memory for strings (hex range 0x20 to 0x79) of a certain minimum length, either
	 * in ascii or unicode
	 * 
	 * @param data The memory to search through
	 * @param dwMinLength The minimum length of strings being searched for
	 *
	 * @return A vector containing all strings, converted to widestrings
	 */
	static std::vector<std::wstring> ExtractStrings(
		IN CONST AllocationWrapper& data, 
		IN DWORD dwMinLength = 5 OPTIONAL
	);

	/**
	 * Gets a vector of detections associated with the provided detection. This searches for processes with
	 * the file loaded into memory and depending on the aggressiveness, any file paths or registry paths in
	 * the file.
	 *
	 * @param detection The detection to find associations for
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * Performs a fast scan to determine whether the info provided is potentially malicious.
	 * This checks if the file exists, and if so, returns true if the file is not signed.
	 *
	 * @param info A string used to identify some object
	 *
	 * @return True if the object represented by the string is potentially malicious
	 */
	static bool PerformQuickScan(
		IN CONST std::wstring& info
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious. This is computed as
	 * a combination of whether the file is signed and which (if any) yara rules it matches
	 *
	 * @param detection The Detection to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/MemoryScanner.h`:

```h
#pragma once

#include <unordered_map>
#include <string>

#include "scan/Detections.h"
#include "scan/Scanner.h"

class MemoryScanner : public Scanner {
public:

	/**
	 * Gets a vector of detections associated with the provided detection. This is done by checking if the
	 * memory in question is mapped to a file, and returning the file if so. This also checks for file paths
	 * included in the memory section.
	 *
	 * @param detection The detection for which associations will be found
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * This function will return false, as there is no "quick" scan to check if memory may be bad
	 *
	 * @param info Unused
	 *
	 * @return False
	 */
	virtual bool PerformQuickScan(
		IN CONST std::wstring& info
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious. This is done by checking 
	 * memory protections and if the aggressiveness is intensive, scanning the memory with yara.
	 *
	 * @param detection The Detection object to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/ProcessScanner.h`:

```h
#pragma once

#include <unordered_map>
#include <string>

#include "scan/Detections.h"
#include "scan/Scanner.h"

class ProcessScanner : public Scanner {
private:

	/**
	 * Scans a command for possibly associated detections. The intended use-case of this is to find things
	 * such as malware.exe in the command `cmd.exe /c "malware.exe"`.
	 */
	std::unordered_map<std::shared_ptr<Detection>, Association> SearchCommand(
		IN CONST std::wstring& ProcessCommand
	);

public:

	/**
	 * Gets a vector of detections associated with the provided detection. This is done by finding child
	 * processes and files referenced in the command used to spawn the process.
	 *
	 * @param detection The detection for which associations will be found
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * This function will treat `info` as a command to determine if any process created with that command would
	 * be malicious.
	 *
	 * @param info A command to scan
	 *
	 * @return True if the command appears malicious; false otherwise
	 */
	static bool PerformQuickScan(
		IN CONST std::wstring& info
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious.
	 *
	 * @param detection The Detection to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/RegistryScanner.h`:

```h
#pragma once

#include <unordered_map>
#include <string>

#include "scan/Detections.h"
#include "scan/Scanner.h"

class RegistryScanner : public Scanner {
public:
	
	/**
	 * Extracts strings that match registry key names under any of the five default hives.
	 *
	 * @param strings The strings to search
	 *
	 * @return a vector of registry paths found in `strings`, including the hives under which they were found.
	 */
	static std::vector<std::wstring> RegistryScanner::ExtractRegistryKeys(
		IN CONST std::vector<std::wstring>& strings
	);

	/**
	 * Gets a vector of detections associated with the provided detection. This is done by finding the associated
	 * item with the registry value, if such a value is present.
	 *
	 * @param detection The detection for which associations will be found
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious. This is done by checking for hidden
	 * information in the value, if such a value is present.
	 *
	 * @param detection The Detection object to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/ScanInfo.h`:

```h
#pragma once

#include <windows.h>

#include <memory>
#include <vector>
#include <map>
#include <atomic>

class Scanner;
class Detection;

/// Forward declare template specializaiton for hashing reference wrappers for detections
template<>
struct std::hash<std::shared_ptr<Detection>>;

#include "util/wrappers.hpp"

/// Represents the degree of certainty that a detection is malicious
class Certainty {

	/// A double holding a number between 0 and 1, indicating how strongly the referenced detection
	/// is believed to be malicious, with 1 being the most certain that it is malicious
	double confidence;

public:

	/// Define static certainty values
	const static Certainty Certain;  // 1.00
	const static Certainty Strong;   // 0.75
	const static Certainty Moderate; // 0.50
	const static Certainty Weak;     // 0.25
	const static Certainty None;     // 0.00

	Certainty(double value);
	operator double() const;

	/**
	 * If the strengths of two associations are to be combined, this function will compute the
	 * resulting association. Using the numerical value of associations, the formula is
	 * 1 - (1 - a1) * (1 - a2).
	 */
	Certainty operator+(Certainty c) const;

	/**
	 * If an association is to be the composite of two associations, this function will compute the
	 * resulting association. Using the numerical value of associations, the formula is
	 * a1 * a2.
	 */
	Certainty operator*(Certainty c) const;

	/**
	 * Used for comparing between certainties. Note that is computes approximate comparisons rather
	 * than exact comparisons. Thus, any value within 0.125 of `confidence` is considered equal
	 */
	bool operator==(Certainty c) const;
	bool operator!=(Certainty c) const;
	bool operator<=(Certainty c) const;
	bool operator>=(Certainty c) const;

	// These functions use exact comparisons rather than approximate comparisons
	bool operator>(Certainty c) const;
	bool operator<(Certainty c) const;
};

/// An association is the degree of certainty that two detections are related
typedef Certainty Association;

/**
 * A ScanInfo is the core unit of BLUESPAWN's scan functionality. This records information
 * such as associations, resulting certainty from scans, and associative certainty.
 */
class ScanInfo {

	/// A mapping of detections to their association strength with the current node.
	std::unique_ptr<std::unordered_map<std::shared_ptr<Detection>, Association>> associations;

	/// The degree of certainty that the detection referenced by this scan node is malicious
	/// Note that this ignores all associations
	Certainty certainty;

	/// The degree of certainty that the detection referenced by this scan node is malicious
	/// Note that this is calculated only based on associations
	Certainty cAssociativeCertainty;

	/// Indicates whether cAssociativeCertainty has gone stale and must be recalculated
	bool bAssociativeStale;

	/// Guards access to `associations`
	CriticalSection hGuard;

	friend class DetectionRegister;
	friend class RegistryScanner;
	friend class FileScanner;
	friend class ProcessScanner;
	friend class MemoryScanner;
	friend class ServiceScanner;
	friend class Detection;

public:

	/**
	 * Constructs a new ScanInfo object
	 */
	ScanInfo();

	/**
	 * Gets a map of the associations of this node.
	 *
	 * @return The associations of this node
	 */
	std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociations();

	/**
	 * Retrieves the certainty that the detection this is a part of is malicious. If any association has
	 * been added since the last call to GetCertainty, the associative certainty will be recalculated.
	 *
	 * @return The certainty that the detection this is a part of is malicious
	 */
	Certainty GetCertainty();

	/**
	 * Retrieves the certainty that the associated detection's data refers to something malicious. This function 
	 * ignores assocaitivity certainty.
	 *
	 * @return The certainty that the detection this is a part of is malicious
	 */
	Certainty GetIntrinsicCertainty();

	/**
	 * Sets the degree of certainty that the detection referenced by this scan node is malicious. This does not affect 
	 * the associative certainty of this ScanNode.
	 *
	 * @param certainty The value of certainty to be set
	 */
	void SetCertainty(
		IN CONST Certainty& certainty
	);

	/**
	 * Adds to the degree of certainty that the detection referenced by this scan node is malicious. This does not affect
	 * the associative certainty of this ScanNode.
	 *
	 * @param certainty The value of certainty to be added
	 */
	void AddCertainty(
		IN CONST Certainty& certainty
	);

	/**
	 * Implicit cast to a CRITICAL_SECTION pointer for use in synchronization functions
	 *
	 * @return hGuard
	 */
	operator LPCRITICAL_SECTION() const;

	/**
	 * Adds an association between this node and the given node with the given strength. Note that
	 * this only adds the association one way; node->AddAssociation(*this) must be called separately
	 * for the association to be bidirectional (as all associations should be).
	 *
	 * @param node The node to add an association to.
	 * @param strength The strength of the association between the two nodes
	 */
	void AddAssociation(
		IN CONST std::shared_ptr<Detection>& node,
		IN CONST Association& strength
	);
};
```

`BLUESPAWN-win-client/headers/scan/Scanner.h`:

```h
#pragma once

#include <vector>

#include "scan/Detections.h"
#include "scan/ScanInfo.h"

class Scanner {
public:

	/// A static vector of publically accessible scanners
	static std::vector<std::shared_ptr<Scanner>> scanners;

	/**
	 * Gets a vector of detections associated with the provided detection
	 * 
	 * @param detection The detection to find associations for
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious.
	 *
	 * @param detection The Detection to scan
	 *
	 * @return A Certainty indicating the degree of certainty to which the detection
	 *         is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/ServiceScanner.h`:

```h
#pragma once

#include <unordered_map>
#include <string>

#include "scan/Detections.h"
#include "scan/Scanner.h"

class ServiceScanner : public Scanner {
public:

	/**
	 * Gets a vector of detections associated with the provided detection. This is done by finding the associated
	 * registry entry and all associated files
	 *
	 * @param detection The detection for which associations will be found
	 *
	 * @return A vector of detections associated with the provided detection
	 */
	virtual std::unordered_map<std::shared_ptr<Detection>, Association> GetAssociatedDetections(
		IN CONST Detection& detection
	);

	/**
	 * Performs a quick scan on the specified service to determine if it may be malicious. This is done by checking
	 * if the service path referenced by the service refers to a signed binary or if the service name / display name
	 * appear potentially malicious. At least one argument must be present.
	 *
	 * @param ServiceName The name of the service, if known. If not known, this may be set to nullopt
	 * @param ServiceDisplayName The display name of the service, if known. If not known, this may be set to nullopt
	 * @param ServicePath The path to the service executable, if known. If not known, this may be set to nullopt
	 *
	 * @return true if the service may be malicious, false otherwise
	 */
	static bool PerformQuickScan(
		IN CONST std::optional<std::wstring>& ServiceName,
		IN CONST std::optional<std::wstring>& ServiceDisplayName,
		IN CONST std::optional<std::wstring>& ServicePath = std::nullopt OPTIONAL
	);

	/**
	 * Scans a detection and returns the certainty that the detection is malicious. This is done by checking service 
	 * names that meet certain properties, are known to have malicious uses, or appear generated by common offensive
	 * tools
	 *
	 * @param detection The Detection object to scan
	 *
	 * @return A Certainty indicating the degree of certainty for which the detection is malicious
	 */
	virtual Certainty ScanDetection(
		IN CONST Detection& detection
	);
};
```

`BLUESPAWN-win-client/headers/scan/YaraScanner.h`:

```h
#pragma once

#include <string>
#include <vector>

#include "util/filesystem/FileSystem.h"
#include "util/wrappers.hpp"

#include "yara/types.h"

enum class YaraStatus {
    Success,
    RulesMissing,
    RulesInvalid,
    Failure,
};

struct YaraScanResult {
    std::vector<std::wstring> vKnownBadRules;
    std::vector<std::wstring> vIndicatorRules;

    YaraStatus status;

    operator bool();
    bool operator!();

    void AddBadRule(IN CONST std::wstring& identifier);
    void AddIndicatorRule(IN CONST std::wstring& identifier);
};

class YaraScanner {
    private:
    static const YaraScanner instance;

    YaraScanner();

    YR_RULES* KnownBad = nullptr;
    YR_RULES* KnownBad2 = nullptr;
    YR_RULES* Indicators = nullptr;

    YaraStatus status;

    public:
    static const YaraScanner& GetInstance();

    ~YaraScanner();

    YaraScanResult ScanFile(const FileSystem::File& file) const;
    YaraScanResult ScanMemory(LPVOID location, DWORD size) const;
    YaraScanResult ScanMemory(const AllocationWrapper& allocation) const;
    YaraScanResult ScanMemory(const MemoryWrapper<>& memory) const;

    YaraScanner(const YaraScanner&) = delete;
    YaraScanner operator=(const YaraScanner&) = delete;
    YaraScanner(YaraScanner&&) = delete;
    YaraScanner operator=(YaraScanner&&) = delete;
};

```

`BLUESPAWN-win-client/headers/user/CLI.h`:

```h
#pragma once

#include "user/iobase.h"
#include "util/wrappers.hpp"

#include <map>

/**
 * This class serves as a way for BLUESPAWN's modules to interact with the user through a command line interface.
 * This class acts as a pseudo-singleton, permitting only one instance per input-output handle pair.
 */
class CLI : public IOBase {
private:
	HandleWrapper hMutex;

	/**
	 * Creates a new CLI object with a given input and output handle.
	 *
	 */
	CLI();

	static const CLI instance;

public:

	static const CLI& GetInstance();

	/**
	 * This method displays a prompt to the user and presents a number of options. The user may select from among the provided
	 * options. If no valid option has been selected by the time the maximum delay is exceeded, an empty wstring will be returned.
	 * Otherwise, the returned wstring is guaranteed to be present in the provided options, or if no options are provided, it will
	 * be empty. Note that calling this function with no options is equivalent to calling AlertUser.
	 *
	 * @param prompt The prompt to display to the user
	 * @param options The options from which the user may choose
	 * @param dwMaximumDelay The maximum delay before returning an empty wstring, in milliseconds
	 *
	 * @return The option that the user chose, or an empty wstring if no options were provided.
	 */
	virtual std::wstring GetUserSelection(const std::wstring& prompt, const std::vector<std::wstring>& options,
		DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const;

	/**
	 * This method displays a message to the user. No action is required for this function to return.
	 *
	 * @param information The message to be displayed to the user.
	 */
	virtual void InformUser(const std::wstring& information, ImportanceLevel level = ImportanceLevel::LOW) const;

	/**
	 * This method displays a message to the user. This will not return until the user acknowledges the message or
	 * the timeout occurs. Passing a value of INFINITY to dwMaximumDelay will indicate that the only case in which
	 * this function should return is when the user acknowledges the message.
	 *
	 * @param information The message to be displayed to the user.
	 * @param dwMaximumDelay The maximum delay before returning, in milliseconds.
	 *
	 * @return True if the user acknowledged the message, false otherwise.
	 */
	virtual bool AlertUser(const std::wstring& information, DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const;

	/**
	 * This method displays a confirmation message to the user. This will display the prompt and three options:
	 * cancel, yes, or no. This will not return until the user has selected an option or until the maximum delay
	 * is exceeded, whichever comes first. If a timeout occurs or the user chooses cancel, -1 will be returned.
	 * If the user responds no, 0 is returned. If the user responds yes, 1 is returned.
	 *
	 * @param information The message to be displayed to the user.
	 * @param dwMaximumDelay The maximum delay before returning, in milliseconds.
	 *
	 * @return If a timeout occurs or the user chooses cancel, -1 will be returned. If the user responds no, 0 is
	 * returned. If the user responds yes, 1 is returned.
	 */
	virtual DWORD GetUserConfirm(const std::wstring& prompt, DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const;

	const HandleWrapper& GetMutex() const;
};
enum class MessageColor {
	BLACK = 0x0,
	DARKBLUE = 0x1,
	DARKGREEN = 0x2,
	CYAN = 0x3,
	DARKRED = 0x4,
	DARKPINK = 0x5,
	GOLD = 0x6,
	LIGHTGRAY = 0x7,
	DARKGREY = 0x8,
	BLUE = 0x9,
	GREEN = 0xA,
	LIGHTBLUE = 0xB,
	RED = 0xC,
	PINK = 0xD,
	YELLOW = 0xE,
	WHITE = 0xF
};



```

`BLUESPAWN-win-client/headers/user/banners.h`:

```h
#pragma once

#include <vector>
#include <string>

static std::vector<std::string> banners = {
	R"(

    _/_/_/    _/        _/    _/  _/_/_/_/    _/_/_/  _/_/_/      _/_/    _/          _/  _/      _/   
   _/    _/  _/        _/    _/  _/        _/        _/    _/  _/    _/  _/          _/  _/_/    _/    
  _/_/_/    _/        _/    _/  _/_/_/      _/_/    _/_/_/    _/_/_/_/  _/    _/    _/  _/  _/  _/     
 _/    _/  _/        _/    _/  _/              _/  _/        _/    _/    _/  _/  _/    _/    _/_/      
_/_/_/    _/_/_/_/    _/_/    _/_/_/_/  _/_/_/    _/        _/    _/      _/  _/      _/      _/       


)",
		R"(

 ____  ____  ____  ____  ____  ____  ____  ____  ____ 
||B ||||L ||||U ||||E ||||S ||||P ||||A ||||W ||||N ||
||__||||__||||__||||__||||__||||__||||__||||__||||__||
|/__\||/__\||/__\||/__\||/__\||/__\||/__\||/__\||/__\|



)",
		R"(

________ ______ _____  ____________________________ _______ ___       _______   __
___  __ )___  / __  / / /___  ____/__  ___/___  __ \___    |__ |     / /___  | / /
__  __  |__  /  _  / / / __  __/   _____ \ __  /_/ /__  /| |__ | /| / / __   |/ / 
_  /_/ / _  /___/ /_/ /  _  /___   ____/ / _  ____/ _  ___ |__ |/ |/ /  _  /|  /  
/_____/  /_____/\____/   /_____/   /____/  /_/      /_/  |_|____/|__/   /_/ |_/   


)",
		R"(
 /$$$$$$$  /$$       /$$   /$$ /$$$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$  /$$      /$$ /$$   /$$
| $$__  $$| $$      | $$  | $$| $$_____/ /$$__  $$| $$__  $$ /$$__  $$| $$  /$ | $$| $$$ | $$
| $$  \ $$| $$      | $$  | $$| $$      | $$  \__/| $$  \ $$| $$  \ $$| $$ /$$$| $$| $$$$| $$
| $$$$$$$ | $$      | $$  | $$| $$$$$   |  $$$$$$ | $$$$$$$/| $$$$$$$$| $$/$$ $$ $$| $$ $$ $$
| $$__  $$| $$      | $$  | $$| $$__/    \____  $$| $$____/ | $$__  $$| $$$$_  $$$$| $$  $$$$
| $$  \ $$| $$      | $$  | $$| $$       /$$  \ $$| $$      | $$  | $$| $$$/ \  $$$| $$\  $$$
| $$$$$$$/| $$$$$$$$|  $$$$$$/| $$$$$$$$|  $$$$$$/| $$      | $$  | $$| $$/   \  $$| $$ \  $$
|_______/ |________/ \______/ |________/ \______/ |__/      |__/  |__/|__/     \__/|__/  \__/
)",

		R"(

FFFFFFD FFD     FFD   FFDFFFFFFFDFFFFFFFDFFFFFFD  FFFFFD FFD    FFDFFFD   FFD
FFAEEFFDFFG     FFG   FFGFFAEEEECFFAEEEECFFAEEFFDFFAEEFFDFFG    FFGFFFFD  FFG
FFFFFFACFFG     FFG   FFGFFFFFD  FFFFFFFDFFFFFFACFFFFFFFGFFG FD FFGFFAFFD FFG
FFAEEFFDFFG     FFG   FFGFFAEEC  BEEEEFFGFFAEEEC FFAEEFFGFFGFFFDFFGFFGBFFDFFG
FFFFFFACFFFFFFFDBFFFFFFACFFFFFFFDFFFFFFFGFFG     FFG  FFGBFFFAFFFACFFG BFFFFG
BEEEEEC BEEEEEEC BEEEEEC BEEEEEECBEEEEEECBEC     BEC  BEC BEECBEEC BEC  BEEEC

)" };

void print_banner();
```

`BLUESPAWN-win-client/headers/user/bluespawn.h`:

```h
#pragma once

#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <Windows.h>

#include <map>

#include "util/configurations/Registry.h"
#include "util/log/DetectionSink.h"
#include "util/log/Log.h"

#include "hunt/Hunt.h"
#include "hunt/HuntRegister.h"
#include "mitigation/Mitigation.h"
#include "mitigation/MitigationRegister.h"
#include "reaction/ReactionManager.h"
#include "scan/DetectionRegister.h"
#include "user/banners.h"
#include "user/CLI.h"

enum class BluespawnMode { HUNT, SCAN, MONITOR, MITIGATE };

class Bluespawn {
    std::map<BluespawnMode, int> modes;
    std::vector<std::wstring> vIncludedHunts;
    std::vector<std::wstring> vExcludedHunts; 

    std::optional<MitigationsConfiguration> mitigationConfig;

    void RunMitigations(bool enforce);
    void RunHunts();
    void RunMonitor();
    void RunScan();

    public:
    std::vector<FileSystem::File> scanFiles;
    std::vector<int> scanProcesses;

    Bluespawn();

    void AddReaction(std::unique_ptr<Reaction>&& reaction);
    void EnableMode(BluespawnMode mode, int argument = 0);
    void SetIncludedHunts(std::vector<std::string> includedHunts);
    void SetExcludedHunts(std::vector<std::string> excludedHunts);
    void SetMitigationConfig(const MitigationsConfiguration& config);
    void Run();

    void check_correct_arch();

    static const IOBase& io;
    static HuntRegister huntRecord;
    static MitigationRegister mitigationRecord;
    static Aggressiveness aggressiveness;
    static DetectionRegister detections;
    static std::vector<std::shared_ptr<DetectionSink>> detectionSinks;
    static bool EnablePreScanDetections;

    static ReactionManager reaction;
};

```

`BLUESPAWN-win-client/headers/user/iobase.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>
#include <string>
#include <set>

enum class ImportanceLevel {
	LOW = 0,
	MEDIUM = 1,
	HIGH = 2
};

/**
 * This class is used to serve as an abstract interface for all user interfaces. User interfaces will
 * implement at least the methods defined here, either in GUI form or in CLI form.
 *
 * Other modules and subsystems in BLUESPAWN will refrain from user interaction not managed through this
 * IO base.
 */
class IOBase {

public: 

	/**
	 * This method displays a prompt to the user and presents a number of options. The user may select from among the provided
	 * options. If no valid option has been selected by the time the maximum delay is exceeded, an empty string will be returned.
	 * Otherwise, the returned string is guaranteed to be present in the provided options, or if no options are provided, it will
	 * be empty. Note that calling this function with no options is equivalent to calling AlertUser.
	 *
	 * @param prompt The prompt to display to the user
	 * @param options The options from which the user may choose
	 * @param dwMaximumDelay The maximum delay before returning an empty string, in milliseconds
	 *
	 * @return The option that the user chose, or an empty string if no options were provided.
	 */
	virtual std::wstring GetUserSelection(const std::wstring& prompt, const std::vector<std::wstring>& options, 
		DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const = 0;

	/**
	 * This method displays a message to the user. No action is required for this function to return.
	 *
	 * @param information The message to be displayed to the user.
	 */
	virtual void InformUser(const std::wstring& information, ImportanceLevel level = ImportanceLevel::LOW) const = 0;

	/**
	 * This method displays a message to the user. This will not return until the user acknowledges the message or
	 * the timeout occurs. Passing a value of INFINITY to dwMaximumDelay will indicate that the only case in which
	 * this function should return is when the user acknowledges the message.
	 *
	 * @param information The message to be displayed to the user.
	 * @param dwMaximumDelay The maximum delay before returning, in milliseconds.
	 *
	 * @return True if the user acknowledged the message, false otherwise.
	 */
	virtual bool AlertUser(const std::wstring& information, DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const = 0;

	/**
	 * This method displays a confirmation message to the user. This will display the prompt and three options:
	 * cancel, yes, or no. This will not return until the user has selected an option or until the maximum delay
	 * is exceeded, whichever comes first. If a timeout occurs or the user chooses cancel, -1 will be returned.
	 * If the user responds no, 0 is returned. If the user responds yes, 1 is returned.
	 *
	 * @param information The message to be displayed to the user.
	 * @param dwMaximumDelay The maximum delay before returning, in milliseconds.
	 *
	 * @return If a timeout occurs or the user chooses cancel, -1 will be returned. If the user responds no, 0 is 
	 * returned. If the user responds yes, 1 is returned.
	 */
	virtual DWORD GetUserConfirm(const std::wstring& prompt, DWORD dwMaximumDelay = -1, ImportanceLevel level = ImportanceLevel::LOW) const = 0;
};
```

`BLUESPAWN-win-client/headers/util/DynamicLinker.h`:

```h
#pragma once

#include <Windows.h>
#include <winternl.h>

#include <vector>
#include <functional>

#define DEFINE_FUNCTION(retval, name, convention, ...)    \
    typedef retval(convention *name##_type)(__VA_ARGS__); \
    namespace Linker { extern name##_type name##; }

#define LINK_FUNCTION(name, dll)                                                                        \
    namespace Linker {                                                                                  \
        name##_type name## = reinterpret_cast<name##_type>(GetProcAddress(LoadLibraryW(L#dll), #name)); \
    }
```

`BLUESPAWN-win-client/headers/util/Internals.h`:

```h
#pragma once

#include <Windows.h>

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG TitleIndex;
    ULONG Type;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, * PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;

```

`BLUESPAWN-win-client/headers/util/Promise.h`:

```h
#pragma once

#include <windows.h>

#include <optional>
#include <functional>

#include "util/wrappers.hpp"

// https://stackoverflow.com/questions/6534041/how-to-check-whether-operator-exists
// Used to avoid a requirement for all types used in a promise to have an == operator
// defined.
namespace detail{
	template<typename L, typename R = L>
	struct has_operator_equals_impl {
		template<typename T = L, typename U = R> // template parameters here to enable SFINAE
		static auto test(T&& t, U&& u) -> decltype(t == u, void(), std::true_type{});
		static auto test(...) -> std::false_type{};
		using type = decltype(test(std::declval<L>(), std::declval<R>()));
	};
} // namespace detail

/**
 * Represents a value from an asynchronous function that may be available later.
 */
template<class T>
class Promise {
private:

	/// Indicates whether the promise is guaranteed to be fufilled
	const bool guaranteed;

	/// An event that will be set when the promise is either fufilled or
	/// invalidated
	const HandleWrapper hEvent;

	/// A critical section used to guard access to members of this class
	const CriticalSection hGuard;

	/// A struct containing members meant to be the same across all copies
	/// of the same Promise. These will be held in a shared pointer.
	struct Members {
		/// Holds the value used to fufill the promise, if any
		std::optional<T> value;

		/// A vector of functions to be called when the promise is fufilled
		std::vector<std::function<void(const T&)>> SuccessFunctions;

		/// A vector of functions to be called when the promise is invalidated
		std::vector<std::function<void()>> FailureFunctions;
	};

	/// A shared pointer to members, to be shared across copies of the same 
	/// promise.
	std::shared_ptr<Members> members;


public:

	/**
	 * Instantiates a promise.
	 *
	 * @param guaranteed Indicates whether this promise is guaranteed not to be
	 *        invalidated.
	 */
	Promise(
		IN bool guaranteed = false OPTIONAL
	) : guaranteed{ guaranteed },
		hEvent{ CreateEventW(nullptr, true, false, nullptr) },
		hGuard{}, 
		members{ std::make_shared<Members>() }{}

	/**
	 * Instantiates a promise already fufilled.
	 *
	 * @param guaranteed Indicates whether this promise is guaranteed not to be
	 *        invalidated.
	 */
	Promise(
		IN CONST T& value
	) : guaranteed{ true },
		hEvent{ CreateEventW(nullptr, true, true, nullptr) },
		hGuard{},
		members{ std::make_shared<Members>(value) }{}


	/**
	 * Waits for the promise to be either fufilled or invalidated, and then
	 * returns an optional, holding the value used to fufill it or nullopt
	 * if invalidated.
	 *
	 * @return Returns an optional, holding the value used to fufill it or 
	 * nullopt if invalidated.
	 */
	std::optional<T> GetValue() const {
		auto status{ WaitForSingleObject(hEvent, INFINITE) };
		if(status != WAIT_OBJECT_0){
			throw std::exception("Waiting for value failed");
		}

		return members->value;
	}

	/**
	 * Adds a functioned to be called if the promise is fufilled. If the promise
	 * has already been fufilled, then the provided function will be immediately
	 * called. Note that the provided function will be called by the thread fufilling
	 * the promise if the promise has not yet been fufilled, so it may be preferable
	 * to design the callback to queue a task to a threadpool or start a new thread.
	 *
	 * @param callback The function to call if and when the promise is fufilled.
	 */
	void OnSuccess(
		IN CONST std::function<void(const T&)>& callback
	){
		EnterCriticalSection(hGuard);

		if(!Fufilled()){
			members->SuccessFunctions.emplace_back(callback);
			LeaveCriticalSection(hGuard);
		} else{
			LeaveCriticalSection(hGuard);
			if(value){
				callback(*value);
			}
		}
	}

	/**
	 * Adds a functioned to be called if the promise is invalidated. If the promise 
	 * has already been invalidated, then the provided function will be immediately
	 * called. Note that the provided function will be called by the thread invalidating
	 * the promise if the promise has not yet been invalidating, so it may be preferable
	 * to design the callback to queue a task to a threadpool or start a new thread.
	 *
	 * @param callback The function to call if and when the promise is invalidated.
	 */
	void OnFailure(
		IN CONST std::function<void()>& callback
	){
		EnterCriticalSection(hGuard);

		if(!Fufilled()){
			members->SuccessFunctions.emplace_back(callback);
			LeaveCriticalSection(hGuard);
		} else{
			LeaveCriticalSection(hGuard);
			if(!value){
				callback();
			}
		}
	}

	/**
	 * Attempts to fufill the promise with a value. This will trigger the functions 
	 * registered with OnSuccess if successful. 
	 *
	 * @return True if the promise has been fufilled with the value provided; false
	 *         if the promise had already been fufilled using a different value or if
	 *         the promise has been invalidated.
	 */
	bool Fufill(
		IN CONST T& value
	){
		EnterCriticalSection(hGuard);

		if(!Finished()){
			members->value = value;
			SetEvent(hEvent);
			auto copy{ members->SuccessFunctions };

			LeaveCriticalSection(hGuard);

			for(const auto& func : copy){
				func(value);
			}

			return true;
		} else{
			LeaveCriticalSection(hGuard);
			
			return false;
		}
	}

	/**
	 * Attempts to invalidate the promise, indicating that no value ever be
	 * returned. This will trigger the functions registered with OnFailure if
	 * successful. If the promise has already been fufilled, this will return 
	 * false. Throws an exception if this promise is guaranteed.
	 *
	 * @return True if the promise has been invalidated; false otherwise.
	 */
	bool Invalidate(){
		if(guaranteed){
			throw std::exception("Invalidating a guaranteed promise");
		}

		EnterCriticalSection(hGuard);

		if(!Finished()){
			SetEvent(hEvent);
			auto copy{ members->FailureFunctions };
			LeaveCriticalSection(hGuard);

			for(const auto& func : copy){
				func();
			}

			return true;
		} else{
			LeaveCriticalSection(hGuard);

			return !members->value;
		}
	}

	/**
	 * Indicates whether the promise has been fufilled.
	 *
	 * @return true if this promise has been fufilled; false otherwise.
	 */
	bool Fufilled() const {
		return Finished() && members->value;
	}

	/**
	 * Indicates whether the promise has been invalidated.
	 *
	 * @return true if this promise has been invalidated; false otherwise.
	 */
	bool Invalidated() const {
		return Finished() && !members->value;
	}

	/**
	 * Indicates whether the promise has been either fufilled or invalidated.
	 *
	 * @return true if this promise has been either fufilled invalidated; false otherwise.
	 */
	bool Finished() const {
		return WAIT_TIMEOUT != WaitForSingleObjectEx(hEvent, 0, true);
	}

	/**
	 * Indicates whether this promise is guaranteed to not be invalidated.
	 *
	 * @return True if this promise is guaranteed to not be invalidated; false otherwise.
	 */
	bool IsGuaranteed() const {
		return guaranteed;
	}

	/**
	 * Provides an implicit cast to HANDLE for use in wait functions such as
	 * WaitForSingleObject and similar. This handle will be signalled when the promise
	 * is fufilled or invalidated. Note that this handle should not be set or reset.
	 *
	 * @return A handle to the underlying event for this promise.
	 */
	operator HANDLE() const {
		return hEvent;
	}

	/**
	 * Provides an implicit cast to the expected value type of the promise. Note that
	 * this is an unsafe method and will throw an exception if the promise is invalidated.
	 *
	 * @return The value used to fufill the promise.
	 */
	operator T(){
		GetValue();

		if(!Fufilled()){
			throw std::exception("Attempting to get the value of invalidated promise");
		}

		return *members->value;
	}
};
```

`BLUESPAWN-win-client/headers/util/StringUtils.h`:

```h
#pragma once

#include <Windows.h>

#include <string>
#include <vector>

/**
* Gets the Shannon Entropy of a string
* 
* @param in The string of which to calculate the entropy
*
* @return A double storing the Shannon Entropy of the string
*/
double GetShannonEntropy(const std::wstring& in);

/**
 * Converts a wide-string to a UTF-8 encoded string
 *
 * @param in The widestring to convert
 *
 * @return The given wide-string converted to a UTF-8 encoded string
 */
std::string WidestringToString(const std::wstring& in);

/**
 * Converts a UTF-8 encoded string to a wide-string
 *
 * @param in The string to convert
 *
 * @return The string converted to a wide-string
 */
std::wstring StringToWidestring(const std::string& in);

/**
 * Expands all enviroment strings present in the input
 * 
 * @param in The string to expand all environment strings for
 *
 * @return The string with all environment strings expanded.
 */
std::wstring ExpandEnvStringsW(const std::wstring& in);

/**
 * Expands all enviroment strings present in the input
 *
 * @param in The string to expand all environment strings for
 *
 * @return The string with all environment strings expanded.
 */
std::string ExpandEnvStringsA(const std::string& in);

/**
* Zero pads a number to the specified width, useful for zeropadding dates
*
* @param value The number to be zeropadded
* @param length The width to pad to. Defaults to 2
*
* @return A wstring with the number zeropadded to the requested width
*/
std::wstring ToWstringPad(DWORD value, size_t length = 2);

/**
 * Convert a string or wstring to uppercase. Note that the only
 * allowable template classes are std::string and std::wstring.
 *
 * @param in The string/wstring to convert to uppercase.
 *
 * @return A copy of the given string, converted to uppercase.
 */
template<class T>
T ToUpperCase(const T& in);
#define ToUpperCaseA ToUpperCase<std::string>
#define ToUpperCaseW ToUpperCase<std::wstring>

/**
 * Convert a string or wstring to lowercase. Note that the only
 * allowable template classes are std::string and std::wstring.
 *
 * @param in The string/wstring to convert to lowercase.
 *
 * @return A copy of the given string, converted to lowercase.
 */
template<class T>
T ToLowerCase(const T& in);
#define ToLowerCaseA ToLowerCase<std::string>
#define ToLowerCaseW ToLowerCase<std::wstring>

/**
 * Compares two strings, ignoring case. Note that the only allowable
 * template classes are std::string and std::wstring.
 *
 * @param in1 The first string to compare
 * @param in2 The second string to compare.
 *
 * @return true if the two strings are equal; false otherwise.
 */
template<class T>
bool CompareIgnoreCase(const T& in1, const T& in2);
#define CompareIgnoreCaseA CompareIgnoreCase<std::string>
#define CompareIgnoreCaseW CompareIgnoreCase<std::wstring>

/**
 * Replaces all instances of a substring found inside of a string
 *
 * @param string The string to modify
 * @param search The substring to be replaced
 * @param replacement The replacement for the substring
 *
 * @return A string with the replacements applied.
 */
template<class T>
T StringReplace(const T& string, const T& search, const T& replacement);
#define StringReplaceA StringReplace<std::string>
#define StringReplaceW StringReplace<std::wstring>
#define CompareIgnoreCaseW CompareIgnoreCase<std::wstring>

/**
 * Split a string into substrings based on a delimter. This currently
 * does not support regular expressions.
 *
 * @param in The string/wstring to split.
 * @param delimiter The substring to split on. 
 *
 * @return A vector containing the components of `in` split by `delimiter`
 */
template<class T>
std::vector<std::basic_string<T>> SplitString(const std::basic_string<T>& in, const std::basic_string<T>& delimiter);
#define SplitStringA SplitString<CHAR>
#define SplitStringW SplitString<WCHAR>

```

`BLUESPAWN-win-client/headers/util/ThreadPool.h`:

```h
#pragma once

#include <functional>
#include <queue>
#include <memory>
#include <vector>
#include <thread>

#include "util/Promise.h"
#include "util/wrappers.hpp"

class ThreadPool {
private:

	/// A queue of tasks to be executed by the threadpool
	std::queue<std::function<void()>> tasks;

	/// A vector of worker threads 
	std::vector<std::thread> threads;

	/// A critical section guarding access to tasks and threads
	CriticalSection hGuard;

	/// A semaphore counting the number of tasks in the queue
	HandleWrapper hSemaphore;

	/// An event object that will be signalled whenever the threadpool has no remaining tasks
	HandleWrapper hEvent;

	/// A boolean indicating whether the threadpool is active. If false, all threads will
	/// terminate when they finish their tasks.
	bool active;

	/// The number of tasks not finished being executed. Access is protected by hGuard
	size_t count;

	/// The threadpool instance
	static ThreadPool instance;

	/// Private constructor
	ThreadPool();

	/// A vector of functions to be called when an exception is raised
	std::vector<std::function<void(const std::exception& e)>> vExceptionHandlers;

	/// The function that each worker thread runs in, for internal use only
	void ThreadFunction();

public:

	~ThreadPool();

	/**
	 * Returns a reference to the threadpool instance
	 */
	static ThreadPool& GetInstance();

	// Delete the move and copy constructors; this is a singleton class
	ThreadPool(const ThreadPool&) = delete;
	ThreadPool(ThreadPool&&) = delete;
	ThreadPool operator=(const ThreadPool&) = delete;
	ThreadPool operator=(ThreadPool&&) = delete;

	/**
	 * Enqueues a task to the threadpool. This task will be executed at some
	 * point in the future by the threadpool.
	 */
	void EnqueueTask(
		IN CONST std::function<void()>& task
	);

	/**
	 * Enqueue a function to the threadpool and return a promise for its return value. The promise will be fufilled if
	 * the function returns a value or invalidated if the function throws an exception. If more complex fufillment or 
	 * invalidation guidelines are required, design an std::function to handle creation of the promise and use 
	 * EnqueueTask instead.
	 *
	 * @param function The function to return a promise for
	 *
	 * @return A promise which will hold the return value of the function
	 */
	template<class T>
	Promise<T> RequestPromise(
		IN CONST std::function<T()>& function
	){
		Promise<T> promise{ false };
		EnqueueTask([promise, function]() mutable {
			try {
				promise.Fufill(function());
			} catch(...){
				promise.Invalidate();
			}
		});
		return promise;
	}

	/**
	 * Adds a function to be called whenever a task raises an exception. This
	 * function call will be enqueued as a separate task to the threadpool rather
	 * than being immediately handled. 
	 *
	 * @param function A function to be called whenever a task raises an exception.
	 *        The exception will be passed as an argument to the function.
	 */
	void AddExceptionHandler(
		IN CONST std::function<void(const std::exception& e)>& function
	);

	/**
	 * Waits for all tasks to be finished before returning.
	 */
	void Wait() const;
};

```

`BLUESPAWN-win-client/headers/util/Utils.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>
#include <string>

#define ADD_ALL_VECTOR(v1, v2)  \
    {                           \
        auto& tmp = v2;         \
		for(auto& v : tmp){     \
			v1.emplace_back(v); \
		}                       \
    }

int64_t SystemTimeToInteger(const SYSTEMTIME& st);
std::wstring FormatWindowsTime(const SYSTEMTIME& systemtime);
std::wstring FormatWindowsTime(const FILETIME& systemtime);
std::wstring FormatWindowsTime(const std::wstring& windowsTime);

```

`BLUESPAWN-win-client/headers/util/configurations/CollectInfo.h`:

```h
#pragma once

#include <string>

std::wstring GetComputerDNSHostname();

```

`BLUESPAWN-win-client/headers/util/configurations/Registry.h`:

```h
#pragma once

#include <Windows.h>

#include <string>
#include <vector>
#include <map>
#include <optional>
#include <variant>
#include <type_traits>

#include "util/DynamicLinker.h"
#include "util/wrappers.hpp"

#include "util/log/Loggable.h"

DEFINE_FUNCTION(DWORD, NtQueryKey, NTAPI, HANDLE KeyHandle, int KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
DEFINE_FUNCTION(NTSTATUS, NtQueryValueKey, NTAPI, HANDLE KeyHandle, PUNICODE_STRING ValueName, int KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
DEFINE_FUNCTION(NTSTATUS, NtDeleteValueKey, NTAPI, HANDLE KeyHandle, PUNICODE_STRING ValueName);

#define DEFAULT L""

/**
 * This enum represents the datatypes stored in the registry.
 * While other types do exist, for now, support only exists for the below types.
 */
enum class RegistryType {
	REG_SZ_T,
	REG_EXPAND_SZ_T,
	REG_MULTI_SZ_T,
	REG_DWORD_T,
	REG_BINARY_T
};

namespace Registry {

	typedef std::variant<std::wstring, DWORD, AllocationWrapper, std::vector<std::wstring>> RegistryData;

	extern std::map<std::wstring, HKEY> vHiveNames;
	extern std::map<HKEY, std::wstring> vHives;

	/**
	 * This class is for interaction with the Windows Registry. A single instance of this
	 * class represents a key in the registry, not to be confused with a value. Note that each
	 * key will have multiple values in addition to some number of subkeys. Each value is associated
	 * with data, which will generally be a REG_DWORD, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ, or 
	 * REG_BINARY. This class provides support for all of these. 
	 */
	class RegistryKey : 
		public Loggable {
	public:

		/**
		 * Checks if a given registry key exists.
		 *
		 * @param hive The registry hive to search for `name`
		 * @param name The path to the registry key under `hive`
		 * @param WoW64 True if the key should be reflected/redirected for WoW64; false otherwise.
		 *
		 * @return true if the key exists; false otherwise
		 */
		static bool CheckKeyExists(HKEY hive, const std::wstring& name, bool WoW64 = false);

		/* Copy constructor for a RegistryKey */
		RegistryKey(const RegistryKey& key) noexcept;

		/* Move constructor for a RegistryKey */
		RegistryKey(RegistryKey&& key) noexcept;

		/**
		 * Creates a RegistryKey object from the backing associated HKEY.
		 *
		 * @param key The HKEY handle on the registry key to create an instance for.
		 */
		RegistryKey(HKEY key);

		/**
		 * Creates a RegistryKey object from a path relative to a given HKEY.
		 * For example, the HKEY may reference the key at HKLM\SYSTEM and the path may be 
		 * CurrentControlSet\Services. The resulting instance would reference the key stored at
		 * HKLM\SYSTEM\CurrentControlSet\Services.
		 *
		 * @param base The base key.
		 * @param path The path relative to the base key.
		 * @param WoW64 Indicate whether this instance should refer to the WoW64 version of a key. For keys without 
		 *        WoW64 versions, this has no effect. If Wow6432node is part of the provided path, this value is ignored.
		 */
		RegistryKey(HKEY base, std::wstring path, bool WoW64 = false);

		/**
		 * Creates a RegistryKey object to reference a key at a given path.
		 *
		 * @param path The path of the registry key to reference.
		 */
		RegistryKey(std::wstring path, bool WoW64 = false);

		/**
		 * \brief Construct a RegistryKey object reference to a key present under another RegistryKey object.
		 * 
		 * \param baseKey The base key.
		 * \param subkeyName The relative path to the base key.
		 * \param WoW64 Indicate whether this instance should refer to the WoW64 version of a key. For keys without 
		 *        WoW64 versions, this has no effect. If Wow6432node is part of the provided path, this value is ignored.
		 */
		RegistryKey(const RegistryKey& baseKey, const std::wstring& subkeyName, bool wow64 = false);

		/** Copy operator overload */
		RegistryKey& operator=(const RegistryKey& key) noexcept;

		/** Move operator overload */
		RegistryKey& operator=(RegistryKey&& key) noexcept;

	private:

		/**
		 * This class handles reference tracking for registry key handles
		 */
		class Tracker {
		private:

			/// A mapping of HKEYs to the number of references to that key
			std::unordered_map<HKEY, int> counts;

			/// A critical section guarding access to counts
			CriticalSection hGuard;

		public:

			explicit Tracker();

			/**
			 * Increments the number of references for hKey
			 *
			 * @param hKey The handle to increment references for
			 */
			void Increment(IN HKEY hKey);

			/**
			 * Decrements the number of references for hKey, closing the handle if it reaches zero
			 *
			 * @param hKey The handle to decrement references for
			 */
			void Decrement(IN HKEY hKey);

			/**
			 * Gets the number of references to a given HKEY
			 *
			 * @param hKey The HKEY to check the number of references for
			 *
			 * @return The number of references to hKey
			 */
			int Get(IN HKEY hKey);
		};

		static std::shared_ptr<RegistryKey::Tracker> __tracker;

		std::shared_ptr<Tracker> tracker;

		HKEY hkBackingKey;

		bool bKeyExists;
		bool bWow64;

		HKEY hkHive{};
		std::wstring path{};

	public:
		/** Destructor for a RegistryKey. Decrements a reference count, and if zero, closes the handle */
		~RegistryKey();

		/** 
		 * Indicates whether this instance references a registry key that exists.
		 *
		 * @return true if the referenced key exists; false otherwise
		 */
		bool Exists() const;

		/**
		 * Indicates whether the referenced key contains a certain value.
		 *
		 * @param wsValueName The name of the value to check.
		 *
		 * @return true if the referenced key has the given value; false otherwise
		 */
		bool ValueExists(const std::wstring& wsValueName) const;

		/**
		 * If the registry key referenced by this instance doesn't exist, this will create it.
		 * 
		 * @return true if the registry key already existed or was created; false otherwise.
		 */
		bool Create();

		/**
		 * Reads the raw bytes present in a given value. 
		 *
		 * @return A AllocationWrapper object pointing to the bytes read if the value is present, or
		 *	       an empty memory wrapper if the value is not present.
		 */
		AllocationWrapper GetRawValue(const std::wstring& wsValueName) const;

		/**
		 * Writes bytes to a given value under the key referenced by this object.
		 *
		 * @param name The name of the value to set
		 * @param bytes The bytes to write to the value
		 * @param type The datatype of the value
		 *
		 * @return True if the value was successfully set; false otherwise
		 */
		bool SetRawValue(const std::wstring& name, AllocationWrapper bytes, DWORD type = REG_BINARY) const;

		/**
		 * Reads data from the specified value and handles conversion to common types.
		 * Supported types: std::wstring (REG_SZ and REG_EXPAND_SZ), std::vector<std::wstring>
		 * (REG_MULTI_SZ), and DWORD (REG_DWORD). 
		 * In other types, the data stored in the value will be converted to the template type.
		 *
		 * @param wsValueName The name of the value to read.
		 *
		 * @return An optional containing the object stored in the registry, or nullopt if an error
		 *		   occured or the value does exist.
		 */
		template<class T>
		std::optional<T> GetValue(const std::wstring& wsValueName) const;

		/**
		 * Returns the type of a value under the currently referenced registry key.
		 * Currently, this only supports REG_SZ, REG_EXPAND_SZ, REG_DWORD, and REG_MULTI_SZ.
		 *
		 * @param wsValueName The name of the value to check
		 *
		 * @return An optional containing the registry type, or nullopt if the value does not exist or
		 *		   an error ocurred.
		 */
		std::optional<RegistryType> GetValueType(const std::wstring& wsValueName) const;

		/**
		 * Sets data for a specified value under the referenced key and handles conversions from
		 * common types. For common types, the size and type do not need to be specified.
		 * Supported types: std::wstring, std::string, LPCSTR, LPCWSTR, DWORD, and
		 * std::vector<std::wstring>.
		 *
		 * @param name The name of the value to set.
		 * @param value The data to write to the value.
		 * @param size The size of the data to write. This is ignored if the type is one of the
		 *        supported types for this function.
		 * @param type The registry datatype for the data to write. This is ignored if the type is
		 *	      one of the supported types for this function.
		 *
		 * @return True if the value was successfully set; false otherwise.
		 */
		template<class T>
		bool SetValue(const std::wstring& name, T value, DWORD size = sizeof(T), DWORD type = REG_BINARY) const;

		template<>
		bool RegistryKey::SetValue(const std::wstring& name, std::vector<std::wstring> value, DWORD _size, DWORD type) const{
			SIZE_T size = 1;
			for(auto string : value){
				size += (string.length() + 1);
			}

			auto data = new WCHAR[size];
			auto allocation = AllocationWrapper{ data, static_cast<DWORD>(size * sizeof(WCHAR)), AllocationWrapper::CPP_ARRAY_ALLOC };
			unsigned ptr = 0;

			for(auto string : value){
				LPCWSTR lpRawString = string.c_str();
				for(unsigned i = 0; i < string.length() + 1; i++){
					if(ptr < size){
						data[ptr++] = lpRawString[i];
					}
				}
			}

			if(ptr < size){
				data[ptr] = { static_cast<WCHAR>(0) };
			}

			bool succeeded = SetRawValue(name, allocation, REG_MULTI_SZ);

			return succeeded;
		}

		/**
		 * Sets data for a specified value under the referenced key given a RegistryData object wrapping the underlying
		 * data
		 *
		 * @param name The name of the value to set.
		 * @param value The data to write to the value.
		 *
		 * @return True if the value was successfully set; false otherwise.
		 */
		bool SetDataValue(const std::wstring& name, RegistryData value) const;

		/**
		 * Returns a list of values present under the currently referenced registry key.
		 *
		 * @return a list of values present under the currently referenced registry key.
		 */
		std::vector<std::wstring> EnumerateValues() const;

		/**
		 * Returns a list of subkeys under the currently referenced registry key.
		 *
		 * @return a list of subkeys under the currently referenced registry key.
		 */
		std::vector<RegistryKey> EnumerateSubkeys() const;

		/**
		 * Returns a list of subkey names under the currently referenced registry key.
		 *
		 * @return a list of subkey names under the currently referenced registry key.
		 */
		std::vector<std::wstring> EnumerateSubkeyNames() const;

		/**
		 * Returns the full path of the referenced registry key witout the Hive.
		 *
		 * @return the full path of the referenced registry key without the Hive.
		 */
		std::wstring GetNameWithoutHive() const;

		/**
		 * Returns the full path of the referenced registry key.
		 *
		 * @return the full path of the referenced registry key.
		 */
		std::wstring GetName() const;

		/**
		 * Returns the full path of the referenced registry key.
		 *
		 * @return the full path of the referenced registry key.
		 */
		virtual std::wstring ToString() const;

		/**
		 * Override the < operator so registry keys can be used in sets, maps, and trees.
		 *
		 * @param key The key to compare
		 *
		 * @return true or false
		 */
		bool operator<(const RegistryKey& key) const;

		/**
		 * Override the == operator for comparisons.
		 *
		 * @param key The key to compare
		 *
		 * @return true or false
		 */
		bool operator==(const RegistryKey& key) const;

		/**
		 * Removes a value from the referenced registry key.
		 *
		 * @param wsValueName The name of the value to be removed
		 *
		 * @return a boolean indicating whether the value was successfully removed
		 */
		bool RemoveValue(const std::wstring& wsValueName) const;

		/**
		 * \brief Deletes the specified subkey under the referenced registry key, all its subkeys, and all its values
		 * 
		 * \param name The name of the subkey to delete.
		 * 
		 * \return True if the subkey no longer exists.
		 */
		bool DeleteSubkey(const std::wstring& subkey) const;

		operator HKEY() const;
	};
}

template<>
struct std::hash<Registry::RegistryKey> {
	size_t operator()(
		IN CONST Registry::RegistryKey& key
		) const;
};
```

`BLUESPAWN-win-client/headers/util/configurations/RegistryValue.h`:

```h
#pragma once
#include "Registry.h"
#include "util/log/Loggable.h"

#include "util/wrappers.hpp"

#include <vector>
#include <unordered_set>
#include <functional>
#include <string>
#include <variant>

namespace Registry {

	/**
	 * A container class for registry values and associated data.
	 */
	struct RegistryValue : public Loggable {
		RegistryKey key;
		std::wstring wValueName;
		RegistryType type;

		RegistryData data{};

		RegistryValue(const RegistryKey& key, const std::wstring& wValueName, std::wstring&& wData);
		RegistryValue(const RegistryKey& key, const std::wstring& wValueName, DWORD&& dwData);
		RegistryValue(const RegistryKey& key, const std::wstring& wValueName, AllocationWrapper&& lpData);
		RegistryValue(const RegistryKey& key, const std::wstring& wValueName, std::vector<std::wstring>&& wData);

		/**
		 * Attempts to create a RegistryValue object from a value name and the key under which the value can be found
		 *
		 * @param key The key under which the value can be found
		 * @param name The name of the value
		 *
		 * @return An optional containing the RegistryValue object if the value was found, and nullopt otherwise
		 */
		static std::optional<RegistryValue> Create(
			IN CONST RegistryKey& key,
			IN CONST std::wstring& name
		);

		RegistryType GetType() const;

		std::wstring GetPrintableName() const;

		virtual std::wstring ToString() const;

		bool operator==(const RegistryValue& value) const;
		bool operator<(const RegistryValue& value) const;
	};
}
```

`BLUESPAWN-win-client/headers/util/configurations/ScheduledTasks.h`:

```h
#pragma once
#pragma comment(lib, "taskschd.lib")

#include <windows.h>
//TODO: Pare down as needed
#include <string>
#include <vector>
#include <set>
#include <iostream>
#include <taskschd.h>
#include <chrono>
#include "util/log/Log.h"


namespace ScheduledTasks {
	//TODO: Add any needed typedef and variables

	//STUFF WANTED:
	/*
		Interface Defined For:
			Next Runtime - handled by ScheduledTask::getRuntime()
				Ability to change - handled by ScheduledTask::setRuntime(Date)
				Ability to instantly run - handled by ScheduledTask::stop()
				Ability to stop running - handled by ScheduledTask::run()
			Security Descriptor - handled by ScheduledTask::getSecurityDescriptor()
				Ability to change - handled by ScheduledTask::setSecurityDescriptor(std::wstring)
			Enabled - handled by ScheduledTask::getEnabled()
				Ability to change - handled by ScheduledTask::setEnabled(bool)
			State - handled by ScheduledTask::getState()
			Registration info (date, author, etc.) - handled by ScheduledTask::getRegistration()
			Name - handled by ScheduledTask::getTaskName()
			Ability to get scheduled task by task name - handled by TaskCollection::getTasksByName(std::wstring)
			Ability to get tasks by location - handled by TaskCollection::getTasksByLocation(std::wstring, bool)
					Actions - handled by TaskAction
			ActionType - handled by TaskAction::getType()
			Action taken - handled by TaskAction::getActionRepresentation()
				Ability to change - handled by TaskAction::setAction(std::wstring)
			Delete - handled by ScheduledTask::deleteTask()
		Later Tasks:
			Triggers
				Ability to change
			Ability to change name
			Task Path
			Create 
	*/
	class TaskAction {
		//Email and Show Message actions should always be marked as bad, as they are deprecated
		TASK_ACTION_TYPE type;
		std::wstring id;
		IExecAction* internalExec;
		IComHandlerAction* internalCom;
	public:
		//TODO: Constructors
		TaskAction(IAction action);

		~TaskAction();

		TASK_ACTION_TYPE getType();
		std::wstring getActionRepresentation();
		bool setAction(std::wstring newAction);
	};

	class ScheduledTask : public Loggable {
		//TODO: Local variables here

		std::wstring taskName;
		std::chrono::duration runtime;
		std::vector<TaskAction>* actions;
		std::wstring securityDescriptor;
		IRegisteredTask* internalRepresentation;
		ITaskDefinition* internalDefinition;
		TaskRegistration* registration;
	public:
		//TODO: Constructors
		~ScheduledTask();


		bool taskExists();
		
		std::chrono::duration getRunTime();
		bool setRunTime(const std::chrono::duration& runtime);
		std::wstring getTaskName();
		std::wstring getSecurityDescriptor();
		bool setSecurityDescriptor(const std::wstring& descriptor);
		TaskRegistration* getRegistration();
		TASK_STATE getState();
		bool getEnabled();
		bool setEnabled(bool enabled);
		bool stop();
		bool run();//Maybe allow for arguments as well
		bool deleteTask();//Must delete reference to this class after this call
	};

	class TaskRegistration {
		IRegistrationInfo internalReprsentation;
		std::wstring author;
		DATE registrationDate;
	public:
		//TODO:Constructors
		~TaskRegistration();
		std::wstring getAuthor();
		bool setAuthor(const std::wstring& authorName);
		DATE getRegistrationDate();
		bool setRegistrationDate();
	};

	class TaskCollection : ScheduledTask{
		IRegisteredTaskCollection* tasks; 
	public:
		//TODO: Constructors
		TaskCollection(IRegisteredTaskCollection* t);

		~TaskCollection();
		TaskCollection next();
		TaskCollection prev();
		TaskCollection start();
		TaskCollection end();
		bool atBeginning();
		bool atEnd();

		static TaskCollection getTasksByName(std::wstring name);
		static TaskCollection getTasksInFolder(std::wstring relativePath, bool recurse);
	};
}
```

`BLUESPAWN-win-client/headers/util/eventlogs/EventLogItem.h`:

```h
#pragma once
#include <string>
#include <unordered_map>
#include <Windows.h>
#include <winevt.h>
#include "util/wrappers.hpp"

namespace EventLogs {

	class EventWrapper : public GenericWrapper<EVT_HANDLE> {
	public:
		EventWrapper(EVT_HANDLE handle) :
			GenericWrapper(handle, std::function<void(EVT_HANDLE)>(EvtClose), INVALID_HANDLE_VALUE){};
	};

	class EventLogItem {
		public:
			std::wstring GetProperty(std::wstring prop) const;
			std::unordered_map<std::wstring, std::wstring> GetProperties() const;
			std::wstring GetChannel() const;
			std::wstring GetTimeCreated() const;
			std::wstring GetXML() const;
			unsigned int GetEventID() const;
			unsigned int GetEventRecordID() const;

			void SetProperty(std::wstring& property, std::wstring& value);
			void SetChannel(std::wstring& channel);
			void SetTimeCreated(std::wstring& time);
			void SetXML(std::wstring& xml);
			void SetEventID(unsigned int id);
			void SetEventRecordID(unsigned int id);

		private:
			unsigned int eventID;
			unsigned int eventRecordID;
			std::wstring timeCreated;
			std::wstring channel;
			std::wstring rawXML;
			std::unordered_map<std::wstring, std::wstring> props;
	};

}
```

`BLUESPAWN-win-client/headers/util/eventlogs/EventLogs.h`:

```h
#pragma once   

#include "windows.h"
#include <string>
#include <sddl.h>
#include <stdio.h>
#include <winevt.h>
#include <vector>
#include "util/eventlogs/EventSubscription.h"
#include "util/eventlogs/EventLogItem.h"
#include "util/wrappers.hpp"
#include "XpathQuery.h"

#pragma comment(lib, "wevtapi.lib")

namespace EventLogs {

	typedef std::vector<std::pair<std::wstring, std::wstring>> ParamList;

	/**
	* @param channel the channel to look for the event log (exe, 'Microsoft-Windows-Sysmon/Operational')
	* @param id the event ID to filter for
	* @param params pair mappings of xpaths to values to filter the event log results by
	* @return the number of events detected, or -1 if something went wrong.
	*/
	std::vector<EventLogItem> QueryEvents(const std::wstring& channel, unsigned int id, const std::vector<XpathQuery>& filters = {});

	/**
	* Get the string value of a parameter in an event
	*
	* @param hEvent a handle to an event
	* @param value a pointer to a wstring where the parameter value will be stored
	* @param param the parameter whose value is being queried. Must be a valud XPATH query
	* @return the status of the operation
	*/
	std::optional<std::wstring> GetEventParam(const EventWrapper& hEvent, const std::wstring& param);
	/**
	* Get the XML representation of an event
	*
	* @param hEvent a handle to an event
	* @param data pointer to a wstring where the XML result will be stored
	* @return the status of the operation
	*/
	std::optional<std::wstring> GetEventXML(const EventWrapper& hEvent);

	/**
	* Create an EVENT_DETECTION struct from an event handle
	*
	* @param hEvent the handle being turned into a detection object
	* @param pDetection a pointer to the detection struct to store the results
	* @param params a list of XPATH parameters to include optionally in the struct
	* @return the status of the operation
	*/
	std::optional<EventLogItem> EventToEventLogItem(const EventWrapper& hEvent, const std::vector<std::wstring>& params);

	Detection EventLogItemToDetection(const EventLogItem& pItem);

	/**
	* Subscribe a HuntTriggerReaction to a specific Windows event
	*
	* @param pwsPath the event channel to subscribe to
	* @param id the id of the event to subscribe to
	* @param callback the function to call when event subscriptions are returned
	* @param status the status of the operation
	* @returns a shared pointer to the datasturctures storing the event subscription information
	*/
	std::optional<std::reference_wrapper<EventSubscription>> SubscribeToEvent(const std::wstring& pwsPath, unsigned int id, const std::function<void(EventLogItem)>& callback, const std::vector<XpathQuery>& filters = {});

	/**
	* A utility function called by QueryEvents
	*/
	std::vector<EventLogItem> ProcessResults(const EventWrapper& hEvent, const std::vector<XpathQuery>& filters);

	bool IsChannelOpen(const std::wstring& channel);
	bool OpenChannel(const std::wstring& channel);

}
```

`BLUESPAWN-win-client/headers/util/eventlogs/EventSubscription.h`:

```h
#pragma once   

#include "windows.h"
#include <stdio.h>
#include <winevt.h>
#include <functional>
#include "scan/Detections.h"
#include "util/eventlogs/EventLogItem.h"

#pragma comment(lib, "wevtapi.lib")

/**
* A class used to connect a HuntTriggerReaction to the Windows async call when an event is generated
*/
class EventSubscription {
	public:
		EventSubscription(std::function<void(EventLogs::EventLogItem)> callback);

		/**
		* The function called by the underlying Windows OS as a callback.
		* In turn calls reaction->EventIdentified
		*/
		DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, EVT_HANDLE hEvent);

		/**
		* Set the event handle so it can be closed when this object is deleted
		*/
		void setSubHandle(const EventLogs::EventWrapper& hSubscription);

	private:
		std::function<void(EventLogs::EventLogItem)> callback;
		EventLogs::EventWrapper hSubscription;
};
```

`BLUESPAWN-win-client/headers/util/eventlogs/XpathQuery.h`:

```h
#pragma once

#include <string>
#include <vector>
#include <optional>

namespace EventLogs {

	// Duplicate typedef as in EventLogs.h because including EventLogs.h breaks everything
	typedef std::vector<std::pair<std::wstring, std::wstring>> ParamList;

	class XpathQuery {
		public:
			XpathQuery(const std::wstring& path, const ParamList attributes, std::optional<std::wstring> value = std::optional<std::wstring>());
			std::wstring ToString();
			bool SearchesByValue();
		private:
			std::wstring generateQuery();
			std::wstring query;
			std::wstring path;
			const ParamList attributes;
			std::optional<std::wstring> value;
	};

}
```

`BLUESPAWN-win-client/headers/util/filesystem/FileSystem.h`:

```h
#pragma once

#include <Windows.h>

#include <optional>
#include <set>
#include <string>
#include <vector>

#include "util/DynamicLinker.h"
#include "util/log/Loggable.h"
#include "util/permissions/permissions.h"
#include "util/wrappers.hpp"

#define BUFSIZE 1024
#define MD5LEN 16

DEFINE_FUNCTION(NTSTATUS,
                NtCreateFile,
                __kernel_entry NTAPI,
                PHANDLE FileHandle,
                ACCESS_MASK DesiredAccess,
                POBJECT_ATTRIBUTES ObjectAttributes,
                PIO_STATUS_BLOCK IoStatusBlock,
                PLARGE_INTEGER AllocationSize,
                ULONG FileAttributes,
                ULONG ShareAccess,
                ULONG CreateDisposition,
                ULONG CreateOptions,
                PVOID EaBuffer,
                ULONG EaLength);

#define SHA1LEN 20
#define SHA256LEN 32

enum class HashType { MD5_HASH, SHA1_HASH, SHA256_HASH };

namespace FileSystem {
    /**
	* Function to check if a file path is valid
	*
	* @param path A wstring containing the path to check
	* 
	* @return true if the path points to a valid file, false otherwise
	*/
    bool CheckFileExists(const std::wstring& path);

    /**
	* Function to find a file named name.exe in a registry dependent search path
	*
	* @param name A wstring containing the name of the file for which to search
	* 
	* @return A wstring containing the full path to the file if found, or std::nullopt
	*	if the file wasn't found. 
	*/
    std::optional<std::wstring> SearchPathExecutable(const std::wstring& name);

    struct FileAttribs {
        std::wstring extension;
    };

    struct FileSearchAttribs {
        std::vector<std::wstring> extensions;
    };

    class File : public Loggable {
        //Whether or not this current file actually exists on the filesystem
        bool bFileExists;

        //Whether or not the program has write access to the file
        bool bWriteAccess;

        //Whether or not the program has read access to the file
        bool bReadAccess;

        //Path to the file
        std::wstring FilePath;

        //Handle for the file
        HandleWrapper hFile;

        //Attributes of the file
        FileAttribs Attribs;

        /**
		* Function to get offsets in format needed by SetFilePointer
		*
		* @param val - value to be translated. Upper bit will be ignored
		* @param lowerVal - variable to store lower value
		* @param upperVal - variable to store upper value
		* @param upper - variable to store pointer to upper value
		*/
        DWORD SetFilePointer(DWORD64 dwFilePointer) const;

        /**
		* Function to check if a file is signed in the system catalogs
		*
		* return true if the file is signed in the system catalogs, false if it isn't or on error
		*/
        bool GetFileInSystemCatalogs() const;

        /**
		* Function to assist in retrieving file hashes
		*
		* @param HashType
		*
		* return std::wstring value of the requested hash type
		*/
        std::optional<std::wstring> CalculateHashType(HashType sHashType) const;

        public:
        /**
		* Creates a file object with a given path
		* If the file already exists, opens a handle to it
		*
		* @param path The path to the file to be opened
		*/
        File(IN const std::wstring& path);

        /*Getter for the FilePath field*/
        std::wstring GetFilePath() const;

        /*Getter for the Attribs field*/
        FileAttribs GetFileAttribs() const;

        /*Getter for the bFileExists field*/
        bool GetFileExists() const;

        /**
		* Function to check if program has write access to the file
		*
		* return true if program has write access, false otherwise
		*/
        bool HasWriteAccess() const;

        /**
		* Function to check if program has read access to the file
		*
		* return true if program has read access, false otherwise
		*/
        bool HasReadAccess() const;

        /**
		* Function to write to arbitrary offset in the file
		*
		* @param value The value to be written
		* @param offset The offset to write to
		* @param truncate If true truncate the file after the write
		* @param insert If true insert the value at the offset. If false, overwrite the bytes at that location in the file
		*
		* @return true if write successful, false if write unsuccessful
		*/
    bool Write(IN const LPCVOID value, IN const long offset, IN const unsigned long length, __in_opt const bool truncate = false,
				   __in_opt const bool insert = false) const;

        /**
		* Function to read from arbitrary offset in the file
		*
		* @param buffer The buffer to read to
		* @param offset The offset to read from
		* @param amount	How many bytes to read. Amount should be less than or equal to the size of the buffer - 1
		* @param amountRead How many bytes were successfully read
		*
		* @return true if read successful, false if read unsuccessful
		*/
        bool Read(OUT LPVOID buffer,
                  __in_opt const unsigned long amount,
                  __in_opt const long offset = 0,
                  __out_opt PDWORD amountRead = nullptr) const;

        /**
		* Function to read from arbitrary offset in the file
		*
		* @param buffer The buffer to read to
		* @param offset The offset to read from
		* @param amount	How many bytes to read. Amount should be less than or equal to the size of the buffer - 1
		* @param amountRead How many bytes were successfully read
		*
		* @return true if read successful, false if read unsuccessful
		*/
        AllocationWrapper
        Read(__in_opt unsigned long amount = -1, __in_opt long offset = 0, __out_opt PDWORD amountRead = nullptr) const;

        /**
		* Function to compute the MD5 hash of the file
		*
		* @return The MD5 hash of the object or an empty string if unable to calculate hash
		*/
        std::optional<std::wstring> GetMD5Hash() const;

        /**
		* Function to compute the SHA1 hash of the file
		*
		* @return The SHA1 hash of the object or an empty string if unable to calculate hash
		*/
        std::optional<std::wstring> GetSHA1Hash() const;

        /**
		* Function to compute the SHA256 hash of the file
		*
		* @return The SHA256 hash of the object or an empty string if unable to calculate hash
		*/
        std::optional<std::wstring> GetSHA256Hash() const;

        /**
		* Function to see if a file matches a given set of search criteria
		*
		* @param searchAttribs - a FileSearchAttribs object
		*
		* @return a boolean indicating if the file matched the criteria
		*/
        bool MatchesAttributes(IN const FileSearchAttribs& searchAttribs) const;

        /**
		 * Finds the issuer of the certificate, if present
		 * 
		 * @return the issuer of the certificate, if present
		 */
        std::optional<std::wstring> File::GetCertificateIssuer() const;

        /**
		 * Returns whether or not the current file is signed.
		 *
		 * @return true if the file is properly signed; false if not signed or an error occured.
		 */
        bool GetFileSigned() const;

        /**
		 * Indicates whether the file was signed by Microsoft.
		 *
		 * @return true if the file is properly signed by microsoft; false otherwise
		 */
        bool IsMicrosoftSigned() const;

        /**
		* Function to create the file if it doesn't exist
		*
		* @return true if creation was successful, false if unsuccessful
		*/
        bool Create();

        /**
		* Function to delete the file
		*
		* @return true if deletion was successful, false if unsuccessful
		*/
        bool Delete();

        /**
		* Function to truncate or extend file length
		*
		* @param length - new length of the file in bytes
		*
		* @return true if trucation or extension was successful, false if unsuccessful
		*/
        bool ChangeFileLength(IN const long length) const;

        /**
		 * Gets the number of bytes in the referenced file
		 *
		 * @return The size of the referenced file
		 */
        DWORD64 GetFileSize() const;

        /**
		 * Gets the file path (and thus its name)
		 *
		 * @return The file path of the object
		 */
        virtual std::wstring ToString() const;

        /**
		* Function to get the file owner
		*
		* @return an Owner object representing the owner of the file
		*/
        std::optional<Permissions::Owner> GetFileOwner() const;

        /**
		* Function to set a file owner
		*
		* @param owner An Owner object representing the new file owner
		* @return true if the file is now owned by the new user, false otherwise
		*/
        bool SetFileOwner(const Permissions::Owner& owner);

        /**
		* Function to get the permissions a user or group has on a file
		*
		* @param owner An Owner object to check permissions for
		* @return An ACCESS_MASK object 
		*/
        ACCESS_MASK GetAccessPermissions(const Permissions::Owner& owner);

        /**
		* Function to get permissions that the everyone group has
		*
		* @return the permissions granted to the everyone group
		*/
        ACCESS_MASK GetEveryonePermissions();

        /**
		* Function to set bluespawn's process owner as the owner of the file
		*
		* @return true if successful, false otherwise
		*/
        bool TakeOwnership();

        /**
		* Function to grant certain permissions to certain user or group
		*
		* @param owner The user or group to grant permissions to
		* @param amAccess The access to grant to owner
		*
		* @return true if the permissions were granted, false otherwise
		*/
        bool GrantPermissions(const Permissions::Owner& owner, const ACCESS_MASK& amAccess);

        /**
		* Function to deny certain permissions to certain user or group
		*
		* @param owner The user or group to deny permissions to
		* @param amAccess The access to deny the owner
		*
		* @return true if the permissions were denied, false otherwise
		*/
        bool DenyPermissions(const Permissions::Owner& owner, const ACCESS_MASK& amAccess);

        /**
		* Function to quarantine file
		*
		* @return true if the file is quarantined, false otherwise
		*/
        bool Quarantine();

        /**
		* Function to get the creation time of the file
		*
		* @return a FILETIME struct containing the creation time of the file. If an error,
		*     occurs the function returns std::nullopt and calls SetLastError with the error
		*/
        std::optional<FILETIME> GetCreationTime() const;

        /**
		* Function to get the last modified time of the file
		*
		* @return a FILETIME struct containing the last modified time of the file. If an error,
		*     occurs the function returns std::nullopt and calls SetLastError with the error
		*/
        std::optional<FILETIME> GetModifiedTime() const;

        /**
		* Function to get the last access time of the file
		*
		* @return a FILETIME struct containing the last access time of the file. If an error,
		*     occurs the function returns std::nullopt and calls SetLastError with the error
		*/
        std::optional<FILETIME> GetAccessTime() const;
    };

    class Folder {
        //Path to the current folder
        std::wstring FolderPath;

        //Whether or not the current folder exists
        bool bFolderExists;

        //Handle to current file or directory
        FindWrapper hCurFile;

        //Is the current handle a file or directory
        bool bIsFile;

        //Whether or not BLUESPAWN has write access to the folder
        bool bFolderWrite;

        //Information about found files
        WIN32_FIND_DATA ffd;

        public:
        /**
		* Constructor for the folder object
		*
		* @param path - the path to the folder
		*/
        Folder(const std::wstring& path);

        /*Getter for FolderPath field*/
        std::wstring GetFolderPath() const;

        /**
		* Function to move to the next file
		*
		* @return true if successfully moved to next file false if no next file exists
		*/
        bool MoveToNextFile();

        /**
		* Function to move to the beginnning of the directory
		*
		* @return true if successful, false otherwise
		*/

        bool MoveToBeginning();

        /*Getter for the bFolderExists field*/
        bool GetFolderExists() const;

        /**
		* Function to check if current handle is directory or file
		*
		* @return true if current is a file, false otherwise.
		*/
        bool GetCurIsFile() const;

        /**
		* Function to check if BLUESPAWN has write access to the current folder
		* 
		* @return true if bFolderWrite is true, false otherwise
        */
        bool GetFolderWrite() const;

        /**
		* Function to enter the current directory
		*
		* @return a folder object representing the currently pointed to directory if successful
		*/

        std::optional<Folder> EnterDir();

        /**
		* Function to open the current file for reading and writing
		*
		* @return The file if found, otherwise nothing
		*/
        std::optional<File> Open() const;

        /**
		* Function to add a file to the directory
		*
		* @return The file if successfully created
		*/

        std::optional<File> AddFile(IN const std::wstring& fileName) const;

        /**
		* Function to remove current file and move to next handle
		*
		* @return true if the file was removed, false otherwise
		* TODO: Add support for deleting folders
		*/
        bool RemoveFile() const;

        /**
		* Function to return all files matching some attributes
		*
		* @param attribs - the attributes for returned files to match, std::nullopt gets everything
		* @param recurDepth - the depth to recursively search, -1 recurses infinitely
		*
		* @return all files that match the given parameters
		*/
        std::vector<File> GetFiles(__in_opt std::optional<FileSearchAttribs> attribs = std::nullopt,
                                   __in_opt int recurDepth = 0);

        /**
		* Function to return all subdirectories in the current folder
		*
		* @param recurDepth - the depth to recursively search, -1 recurses infinitely
		*
		* @return all subfolders in the current folder
		*/
        std::vector<Folder> GetSubdirectories(__in_opt int recurDepth = 0);

        /**
		* Function to get the folder owner
		*
		* @return an Owner object representing the owner of the file
		*/
        std::optional<Permissions::Owner> GetFolderOwner() const;

        /**
		* Function to set a folder owner
		*
		* @param owner An Owner object representing the new folder owner
		* @return true if the folder is now owned by the new user, false otherwise
		*/
        bool SetFolderOwner(const Permissions::Owner& owner);

        /**
		* Function to get the permissions a user or group has on a folder
		*
		* @param owner An Owner object to check permissions for
		* @return An ACCESS_MASK object
		*/
        ACCESS_MASK GetAccessPermissions(const Permissions::Owner& owner);

        /**
		* Function to get permissions that the everyone group has
		*
		* @return the permissions granted to the everyone group
		*/
        ACCESS_MASK GetEveryonePermissions();

        /**
		* Function to set bluespawn's process owner as the owner of the folder
		*
		* @return true if successful, false otherwise
		*/
        bool TakeOwnership();
    };
}   // namespace FileSystem

```

`BLUESPAWN-win-client/headers/util/log/CLISink.h`:

```h
#pragma once

#include <map>

#include "LogSink.h"
#include "LogLevel.h"
#include "DetectionSink.h"

namespace Log {

	/**
	 * CLISink provides a sink for the logger that directs output to the console.
	 * 
	 * Each log message is prepended with the severity of the log, as defined in MessagePrepends. This prepended text 
	 * is colored with the color indicated in PrependColors. 
	 */
	class CLISink : public LogSink, public DetectionSink {
	private:

		/// Enum containing color codes for console colors
		enum class MessageColor {
			BLACK     = 0x0,
			DARKBLUE  = 0x1,
			DARKGREEN = 0x2,
			CYAN      = 0x3,
			DARKRED   = 0x4,
			DARKPINK  = 0x5,
			GOLD      = 0x6,
			LIGHTGREY = 0x7,
			DARKGREY  = 0x8,
			BLUE      = 0x9,
			GREEN     = 0xA,
			LIGHTBLUE = 0xB,
			RED       = 0xC,
			PINK      = 0xD,
			YELLOW    = 0xE,
			WHITE     = 0xF,
		};

		/// Prepends for messages
		std::wstring MessagePrepends[5] = { L"[ERROR]", L"[WARNING]", L"[INFO]", L"[VERBOSE]", L"[DETECTION]" };

		/// Colors for the message prepends
		MessageColor PrependColors[5] = { MessageColor::RED, MessageColor::YELLOW, MessageColor::BLUE, 
			MessageColor::LIGHTBLUE, MessageColor::GOLD };

		/// Mutex guarding accesses to the console
		HandleWrapper hMutex;

		/**
		 * Sets the color of text written to the console. The low order nibble is the color of the text, and the high 
		 * order nibble is the color of the background. Colors are defined in the MessageColor enum. Note that this 
		 * function is for internal use, and any external calls to it will be overridden by the next log message.
		 *
		 * @param color The color to set the console
		 */
		void SetConsoleColor(MessageColor color);

	public:

		CLISink();

		/**
		 * Outputs a message to the console if its logging level is enabled. The log message is prepended with its 
		 * severity level.
		 *
		 * @param level The level at which the message is being logged
		 * @param message The message to log
		 */
		virtual void LogMessage(
			IN CONST LogLevel& level, 
			IN CONST std::wstring& message
		) override;

		/**
		 * Compares this CLISink to another LogSink. Currently, as only one console is supported, any other CLISink is
		 * considered to be equal. This is subject to change in the event that support for more consoles is added.
		 *
		 * @param sink The LogSink to compare
		 *
		 * @return Whether or not the argument and this sink are considered equal.
		 */
		virtual bool operator==(
			IN CONST LogSink& sink
		) const;

		/**
		 * Updates the raw and combined certainty values associated with a detection
		 *
		 * @param detection The detection to update
		 */
		virtual void UpdateCertainty(
			IN CONST std::shared_ptr<Detection>& detection
		);

		/**
		 * Records a detection to the console.
		 *
		 * @param detection The detection to record
		 * @param type The type of record this is, either PreScan or PostScan
		 */
		virtual void RecordDetection(
			IN CONST std::shared_ptr<Detection>& detection,
			IN RecordType type
		);

		/**
		 * Records an association between two detections to the console
		 *
		 * @param first The first detection in the assocation. This detection's ID will be lower than the second's.
		 * @param second The second detection in the association.
		 * @param strength The strength of the connection
		 */
		virtual void RecordAssociation(
			IN CONST std::shared_ptr<Detection>& first,
			IN CONST std::shared_ptr<Detection>& second,
			IN CONST Association& strength
		);
	};
}

```

`BLUESPAWN-win-client/headers/util/log/DebugSink.h`:

```h
#pragma once

#include "LogSink.h"
#include "DetectionSink.h"

#include "util/wrappers.hpp"

namespace Log {

	/**
	 * DebugSink provides a sink for the logger that directs output to the debug console.
	 *
	 * Each log message is prepended with the severity of the log, as defined in MessagePrepends.
	 */
	class DebugSink : public LogSink, public DetectionSink {
	private:

		/// A list of different prepends to be used at each log level
		static inline std::wstring MessagePrepends[4] = { L"[ERROR]", L"[WARNING]", L"[INFO]", L"[VERBOSE]" };

		/// A critical section ensuring associated messages occur consecutively
		CriticalSection hGuard;

	public:

		/**
		 * Outputs a message to the debug console if its logging level is enabled. The log message is prepended with 
		 * its severity level.
		 *
		 * @param level The level at which the message is being logged
		 * @param message The message to log
		 */
		virtual void LogMessage(
			IN CONST LogLevel& level,
			IN CONST std::wstring& message
		) override;

		/**
		 * Compares this Debug to another LogSink. Currently, as only one debug console is supported, any other
		 * DebugSink is considered to be equal. This is subject to change in the event that support for more debug
		 * consoles is added.
		 *
		 * @param sink The LogSink to compare
		 *
		 * @return Whether or not the argument and this sink are considered equal.
		 */
		virtual bool operator==(
			IN CONST LogSink& sink
		) const;

		/**
		 * Records a detection to the debug console.
		 *
		 * @param detection The detection to record
		 * @param type The type of record this is, either PreScan or PostScan
		 */
		virtual void RecordDetection(
			IN CONST std::shared_ptr<Detection>& detection,
			IN RecordType type
		);

		/**
		 * Records an association between two detections to the console
		 *
		 * @param first The first detection in the assocation. This detection's ID will be lower than the second's.
		 * @param second The second detection in the association.
		 * @param strength The strength of the connection
		 */
		virtual void RecordAssociation(
			IN CONST std::shared_ptr<Detection>& first,
			IN CONST std::shared_ptr<Detection>& second,
			IN CONST Association& strength
		);

		/**
		 * Updates the raw and combined certainty values associated with a detection
		 *
		 * @param detection The detection to update
		 */
		virtual void UpdateCertainty(
			IN CONST std::shared_ptr<Detection>& detection
		);
	};
}
```

`BLUESPAWN-win-client/headers/util/log/DetectionSink.h`:

```h
#pragma once

#include <Windows.h>

#include "scan/Detections.h"

enum class RecordType {
	
	/**
	 * Detections will be sent to the DetectionSink with PreScan every time a new Detection object
	 * is sent to the DetectionRegister. This will occur before any de-duplication or scans. There
	 * are expected to be a number of false positives of type PreScan
	 */
	PreScan,

	/**
	 * Detections will be sent to the DetectionSink with PostScan every time a Detection is scanned.
	 * This may be triggered multiple times for the same detection if a duplicate exists and causes the
	 * non-associative certainty to change. For duplicates where the non-associative certainty does
	 * not change, this will not be triggered.
	 */
	PostScan
};

class DetectionSink {
public:

	/**
	 * Records a detection to the sink. This may be recorded before the detection has been scanned or
	 * immediately after the scan. If all scans have not yet been finished, there may be associations 
	 * between detections not yet discovered. Be sure to acquire appropriate mutices before accessing 
	 * fields of the detection in implementations of this interface. Note: callers of this function
	 * must not hold either of the CriticalSections of the detection, or else a deadlock may arise.
	 *
	 * @param detection The detection to record
	 * @param type The type of record this is, either PreScan or PostScan
	 */
	virtual void RecordDetection(
		IN CONST std::shared_ptr<Detection>& detection,
		IN RecordType type
	) = 0;

	/**
	 * Records an association between two detections. If an association between the two already exists,
	 * then this represents a second assocation between the two, which should be added to the pre-existing
	 * association. 
	 *
	 * @param first The first detection in the assocation. This detection's ID will be lower than the second's.
	 * @param second The second detection in the association.
	 * @param strength The strength of the connection
	 */
	virtual void RecordAssociation(
		IN CONST std::shared_ptr<Detection>& first,
		IN CONST std::shared_ptr<Detection>& second,
		IN CONST Association& strength
	) = 0;

	/**
	 * Updates the raw and combined certainty values associated with a detection
	 *
	 * @param detection The detection to update
	 */
	virtual void UpdateCertainty(
		IN CONST std::shared_ptr<Detection>& detection
	) = 0;
};
```

`BLUESPAWN-win-client/headers/util/log/JSONSink.h`:

```h
#pragma once

#include <nlohmann/json.hpp>

#include "DetectionSink.h"
#include "LogSink.h"

using json = nlohmann::json;

namespace Log {

    /**
	 * JSONSink provides a sink for the logger that saves log messages to an JSON file.
	 */
    class JSONSink : public LogSink, public DetectionSink {
        /// Guards access to the JSON document
        CriticalSection hGuard;

        /// The JSON document
        json JSONDoc;

        /// The root element in the JSON document
        json Root;

        /// The element to which logs will be added
        json LogRoot;

        /// The name of the file to which the JSON will be written
        std::wstring wFileName;

        /// Tags for messages sent at different levels
        std::string MessageTags[4] = { "error", "warning", "info", "other" };

        /// A handle to a thread that periodically flushes the log to the file
        HandleWrapper thread;

        /// A set of IDs created for detections already in the JSON
        std::set<DWORD> detections;

        /* 
        * This private function is called by RecordAssociation to update the JSON of 
        * detections to reflect a link between two detections.
        */
        void AddAssociation(IN DWORD detection_id, IN DWORD associated, IN double strength);

        void JSONSink::InsertElement(IN json JSONDoc,
                                     IN json parent,
                                     IN CONST std::string& name,
                                     IN CONST std::wstring& value);

        public:
        /**
		 * Default constructor for JSONSink. By default, the log will be saved to a file including the date and time in
		 * the name.
		 */
        JSONSink();

        /**
		 * Constructor for JSONSink. The log will be saved to the folder passed as the argument
		 *
		 * @param wOutputDir The folder to save the log to.
		 */
        JSONSink(const std::wstring& wOutputDir);

        /**
		 * Constructor for JSONSink. The log will be saved to the folder\name passed as the arguments
		 *
		 * @param wOutputDir The folder to save the log to.
		 * @param wFileName The name of the file to save the log as.
		 */
        JSONSink(const std::wstring& wOutputDir, const std::wstring& wFileName);

        /// Delete copy and move constructors and assignment operators
        JSONSink operator=(const JSONSink&) = delete;
        JSONSink operator=(JSONSink&&) = delete;
        JSONSink(const JSONSink&) = delete;
        JSONSink(JSONSink&&) = delete;

        /// Custom destructor
        ~JSONSink();

        /**
		 * Outputs a message to the debug console if its logging level is enabled. 
		 *
		 * @param level The level at which the message is being logged
		 * @param message The message to log
		 */
        virtual void LogMessage(const LogLevel& level, const std::wstring& message);

        /**
		 * Compares this JSONSink to another LogSink. All LogSink objects referring to the same file are considered 
		 * equal
		 *
		 * @param sink The LogSink to compare
		 *
		 * @return Whether or not the argument and this sink are considered equal.
		 */
        virtual bool operator==(const LogSink& sink) const;

        /**
		 * Flushes the log to the file.
		 */
        void Flush();

        /**
		 * Updates the raw and combined certainty values associated with a detection
		 * 
		 * @param detection The detection to update
		 */
        virtual void UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection);

        /**
		 * Records a detection to the JSON document.
		 *
		 * @param detection The detection to record
		 * @param type The type of record this is, either PreScan or PostScan
		 */
        virtual void RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type);

        /**
		 * Records an association between two detections to the JSON document
		 *
		 * @param first The first detection in the assocation. This detection's ID will be lower than the second's.
		 * @param second The second detection in the association.
		 */
        virtual void RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
                                       IN CONST std::shared_ptr<Detection>& second,
                                       IN CONST Association& strength);
    };
}   // namespace Log

```

`BLUESPAWN-win-client/headers/util/log/Log.h`:

```h
#pragma once

#include <Windows.h>
#include <string>
#include <sstream>
#include <functional>
#include <vector>

#include "LogLevel.h"
#include "Loggable.h"
#include "LogSink.h"
#include "util/Utils.h"

// A generic macro to log a message with a given set of sinks at a given level
#define LOG(LEVEL, ...) \
    Log::LogMessage(LEVEL) << __VA_ARGS__

// A macro to log an error in the set of sinks specified by AddSink and RemoveSink
#define LOG_ERROR(...) \
   LOG(Log::LogLevel::LogError, __VA_ARGS__ << Log::endlog)

// A macro to log an LSTATUS and/or HRESULT error
#define LOG_SYSTEM_ERROR(ERROR_ID) \
   LOG_ERROR("System Error Code 0x" << std::uppercase << std::hex << ERROR_ID << ": " << Log::FormatErrorMessage(ERROR_ID));

// A macro that evaluates to a string describing the code in GetLastError()
#define SYSTEM_ERROR \
	"System Error Code 0x" << std::uppercase << std::hex << GetLastError() << ": " << Log::FormatErrorMessage(GetLastError())

// A macro to log a warning in the set of sinks specified by AddSink and RemoveSink
#define LOG_WARNING(...) \
   LOG(Log::LogLevel::LogWarn, __VA_ARGS__ << Log::endlog)

// A macro to log information in the set of sinks specified by AddSink and RemoveSink
#define LOG_INFO(VERBOSITY, ...) \
   LOG(Log::LogLevel::LogInfo##VERBOSITY, __VA_ARGS__ << Log::endlog)

// A macro to log verbose information in the set of sinks specified by AddSink and RemoveSink
// at a specified verbosity. Under current configurations, this should be between 1 and 3 inclusive.
#define LOG_VERBOSE(VERBOSITY, ...) \
   LOG(Log::LogLevel::LogVerbose##VERBOSITY, __VA_ARGS__ << Log::endlog)

namespace Log {

	// A vector containing the set of sinks to be used when LOG_ERROR, LOG_WARNING, etc are used.
	// This vector is updated by the AddSink and RemoveSink functions.
	extern std::vector<std::shared_ptr<LogSink>> _LogSinks;

	// A dummy class to indicate the termination of a log message.
	class LogTerminator {};

	// Indicates the end of a log message
	extern LogTerminator endlog;

	/**
	 * A class to handle log messages built around the style of a stream. The above macros are the
	 * preferred method of interracting with this class.
	 */
	class LogMessage {
	protected:
		// The internal stream used to keep track of the log message
		std::wstringstream stream{};
		
		// The level at which the log message is being logged.
		LogLevel level;

		/**
		 * An internal constructor used create a log message based off of an already existing
		 * stream.
		 *
		 * @param level The log level at which this message is logged.
		 * @param message The pre-existing contents of the message
		 */
		LogMessage(
			IN CONST LogLevel& level,
			IN CONST std::wstringstream& message
		);

		/**
		 * StringStream does most of the work needed to handle a stream of values being logged
		 * to this message. This function serves as a wrapper around adding an object to the internal
		 * stream.
		 *
		 * @param LogItem The item to add to the log message.
		 *
		 * @return a reference to this log message.
		 */
		template<class T>
		LogMessage& InnerLog(
			IN CONST T LogItem, 
			IN CONST std::false_type&
		){
			stream << LogItem;
			return *this;
		}

		/**
		 * At some point, it may become beneficial to log the current state of a component.
		 * This is meant to serve as a handler for components implementing the Loggable
		 * interface.
		 *
		 * @param loggable The component to log
		 *
		 * @return a reference to this log message.
		 */
		LogMessage& InnerLog(
			IN CONST Loggable& loggable, 
			IN CONST std::true_type&
		);

	public:

		/**
		 * Creates a log message at a given level and with a sink
		 *
		 * @param level The log level at which this message is logged.
		 */
		LogMessage(
			IN CONST LogLevel& level
		);

		/**
		 * When the LogTerminator is supplied to the stream, the stream is terminated and forwarded to
		 * the sinks for recording. After this happens, the log message is emptied and able to be used
		 * again.
		 *
		 * @param terminator An instance of the LogTerminator class used to denote the termination of a 
		 *        message
		 *
		 * @return a reference to this log message.
		 */
		virtual LogMessage& operator<<(
			IN CONST LogTerminator& termiantor
		);

		/**
		 * Tag dispatcher for the InnerLog functions. Used to add elements to this log message
		 *
		 * @param LogItem Item to add to this log message
		 *
		 * @return a reference to this log message
		 */
		template<class T>
		LogMessage& operator<<(
			IN CONST T& LogItem
		){
			return InnerLog(LogItem, std::is_base_of<Loggable, T>{});
		}
	};

	/**
	 * Adds a given LogSink to the specified levels as a sink for all log messages of that level.
	 * If the provided sink is equal to any sink in the vector already, this will return false,
	 * and the sink will not be added.
	 *
	 * @param sink The sink to be added
	 * @param levels A vector of the log levels that will be logged to the sink
	 */
	void AddSink(
		IN CONST std::shared_ptr<LogSink>& sink,
		IN CONST std::vector<std::reference_wrapper<LogLevel>>& levels
	);

	/**
	* Gets a System Error Message's Description given the error code
	*
	* @param DWORD returned from GetLastError()
	*
	* @return A std::wstring containing the System Error Message Description
	*/
	std::wstring FormatErrorMessage(DWORD dwNum);
}

```

`BLUESPAWN-win-client/headers/util/log/LogLevel.h`:

```h
#pragma once

#include <Windows.h>

#include <string>
#include <optional>
#include <vector>

namespace Log {
	/**
	 * This denotes the severity of a log message. This is intended to be used by
	 * LogSinks to choose how to record a given log message.
	 */
	enum class Severity {
		LogError = 0,
		LogWarn = 1,
		LogInfo = 2,
		LogVerbose = 3
	};

	/**
	 * This indicates the level of detail in the log level.
	 */
	enum class Detail {
		Low = 0,
		Moderate = 1,
		High = 2
	};

	/// Forward declare log sink
	class LogSink;

	/**
	 * This class represents the "level" of a log message. This is similar to Severity
	 * in that it categorizes logs, but it's inteded to extend the functionality present
	 * in a manner that doesn't affect the log sinks by allowing the enabling or disabling
	 * of certain logging levels.
	 */
	class LogLevel {
	private:
		
		/// Whether or not sinks should record log messages under this level
		bool enabled;

		/// The sinks to which messages at this level will be recorded
		std::vector<LogSink*> sinks;

	public:
		/// The severity at which this log level operates
		const Severity severity;

		/// The level of detail present at this logging level
		const std::optional<Detail> detail;

		/// Default logging levels available, though custom ones can be created
		static LogLevel
			LogError,    // Intended for logging errors
			LogWarn,     // Intended for logging warnings
			LogInfo1,    // Intended for logging high level operational information
			LogInfo2,    // Intended for logging moderately detailed operational information
			LogInfo3,    // Intended for logging very detailed operational information
			LogVerbose1, // Intended for a low level of verbosity
			LogVerbose2, // Intended for a moderate level of verbosity
			LogVerbose3; // Intended for a high level of verbosity

		/**
		 * Creates a new log level, enabled by default, with a given severity.
		 * 
		 * @param severity The severity of messages under this logging level
		 * @param detail The level of detail present at this logging level
		 */
		LogLevel(
			IN Severity severity,
			IN CONST std::optional<Detail>& detail = std::nullopt OPTIONAL
		);

		/**
		 * Creates a new log level with a given severity.
		 *
		 * @param severity The severity of messages under this logging level
		 * @param DefaultState Indicates whether or not log messages should be recorded
		 *        by default when logged at this logging level.
		 */
		LogLevel(
			IN Severity severity, 
			IN bool DefaultState,
			IN CONST std::optional<Detail>& detail = std::nullopt OPTIONAL
		);

		/**
		 * Enables logging at this level
		 */
		void Enable();

		/**
		 * Disables logging at this level
		 */
		void Disable();

		/**
		 * Toggles logging at this level
		 */
		bool Toggle();

		/**
		 * Indicates whether or not this log level is enabled.
		 *
		 * @return A boolean indicating whether or not log messages at this level should
		 *       be recorded.
		 */
		bool Enabled() const;

		/**
		 * Adds a sink to which messages logged at this level are recorded. If the level already
		 * is logging to the sink, this has no effect.
		 *
		 * @param sink The sink to add 
		 */
		void AddSink(
			IN LogSink* sink
		);

		/**
		 * Logs the given message at this level in the sinks configured for this level
		 *
		 * @param message The message to log
		 */
		void LogMessage(
			IN CONST std::wstring& message
		);
	};
}
```

`BLUESPAWN-win-client/headers/util/log/LogSink.h`:

```h
#pragma once

#include <string>
#include <vector>
#include <memory>
#include <optional>

#include "scan/Detections.h"
#include "hunt/HuntInfo.h"

#include "LogLevel.h"

namespace Log {
	/**
	 * LogSink provides an interface for more sinks to be added and integrate with the
	 * logging framework. 
	 *
	 * In this framework, all log messages are sent to some number of sinks, and the sinks
	 * are the endpoints of the logging. A sink may be a file to be written to, a console to
	 * be outputted to, a network connection to be transmitted to, or something else entirely.
	 * Inheriting from LogSink allows a class to interface with the logging framework and 
	 * receive messages to log.
	 */
	class LogSink {
	public:

		/**
		 * This function should be implemented to log a given message at a given level.
		 *
		 * @param level The level at which to log
		 * @param message The message to be logged
		 */
		virtual void LogMessage(const LogLevel& level, const std::wstring& message) = 0;

		/**
		 * This function should be implemented to determine whether two log sinks are equal.
		 * This function is used in the AddSink and RemoveSink methods to prevent duplicates
		 * and to determine which sink should be removed.
		 *
		 * @param sink The sink to check for equality.
		 *
		 * @return Whether or not the argument and this sink are considered equal.
		 */
		virtual bool operator==(const LogSink& sink) const = 0;
	};
}
```

`BLUESPAWN-win-client/headers/util/log/Loggable.h`:

```h
#pragma once

#include <string>

/**
 *  Loggable is an interface classes must inherit from if they are fed
 *  directly to the logger. 
 */
class Loggable {
public:
	/**
	 *  ToString should return a string representation of the class.
	 *
	 *  @return A string representation of the class.
	 */
	virtual std::wstring ToString() const = 0;
};


```

`BLUESPAWN-win-client/headers/util/log/XMLSink.h`:

```h
#pragma once

#include "../tinyxml2/tinyxml2.h"
#include "DetectionSink.h"
#include "LogSink.h"

namespace Log {

    /**
	 * XMLSink provides a sink for the logger that saves log messages to an XML file.
	 */
    class XMLSink : public LogSink, public DetectionSink {
        /// Guards access to the XML document
        CriticalSection hGuard;

        /// The XML document
        tinyxml2::XMLDocument XMLDoc;

        /// The root element in the XML document
        tinyxml2::XMLElement* Root;

        /// The element to which logs will be added
        tinyxml2::XMLElement* LogRoot;

        /// The name of the file to which the XML will be written
        std::wstring wFileName;

        /// Tags for messages sent at different levels
        std::string MessageTags[4] = { "error", "warning", "info", "other" };

        /// A handle to a thread that periodically flushes the log to the file
        HandleWrapper thread;

        /// A mapping of IDs to XML entries created for detections
        std::unordered_map<DWORD, tinyxml2::XMLElement*> detections;

        public:
        /**
		 * Default constructor for XMLSink. By default, the log will be saved to a file including the date and time in
		 * the name.
		 */
        XMLSink();

        /**
		 * Constructor for XMLSink. The log will be saved with the folder path passed as the argument
		 *
		 * @param wOutputDir The name of the folder to save the logs to.
		 */
        XMLSink(const std::wstring& wOutputDir);

        /**
		 * Constructor for XMLSink. The log will be saved with the folder path and name passed as the arguments
		 *
		 * @param wOutputDir The name of the folder to save the logs to.
		 * @param wFileName The name of the file to save the log as.
		 */
        XMLSink(const std::wstring& wOutputDir, const std::wstring& wFileName);

        /// Delete copy and move constructors and assignment operators
        XMLSink operator=(const XMLSink&) = delete;
        XMLSink operator=(XMLSink&&) = delete;
        XMLSink(const XMLSink&) = delete;
        XMLSink(XMLSink&&) = delete;

        /// Custom destructor
        ~XMLSink();

        /**
		 * Outputs a message to the debug console if its logging level is enabled. 
		 *
		 * @param level The level at which the message is being logged
		 * @param message The message to log
		 */
        virtual void LogMessage(const LogLevel& level, const std::wstring& message);

        /**
		 * Compares this XMLSink to another LogSink. All LogSink objects referring to the same file are considered 
		 * equal
		 *
		 * @param sink The LogSink to compare
		 *
		 * @return Whether or not the argument and this sink are considered equal.
		 */
        virtual bool operator==(const LogSink& sink) const;

        /**
		 * Flushes the log to the file.
		 */
        void Flush();

        /**
		 * Updates the raw and combined certainty values associated with a detection
		 * 
		 * @param detection The detection to update
		 */
        virtual void UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection);

        /**
		 * Records a detection to the XML document.
		 *
		 * @param detection The detection to record
		 * @param type The type of record this is, either PreScan or PostScan
		 */
        virtual void RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type);

        /**
		 * Records an association between two detections to the XML document
		 *
		 * @param first The first detection in the assocation. This detection's ID will be lower than the second's.
		 * @param second The second detection in the association.
		 */
        virtual void RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
                                       IN CONST std::shared_ptr<Detection>& second,
                                       IN CONST Association& strength);
    };
}   // namespace Log

```

`BLUESPAWN-win-client/headers/util/pe/Export_Section.h`:

```h
#pragma once
#include "util/pe/PE_Section.h"

#include <string>
#include <vector>

#include "util/DynamicLinker.h"

DEFINE_FUNCTION(NTSTATUS, LdrpPreprocessDllName, NTAPI, __in PUNICODE_STRING input, __out PUNICODE_STRING output, PULONG_PTR zero1, PULONG_PTR zero2);

struct PE_Export {
	DWORD rva;
	WORD ordinal;
	std::string name;
	std::wstring redirect;

	PE_Export(DWORD rva, WORD ordinal, std::string name);
	PE_Export(WORD ordinal, std::string name, std::wstring redirect);
};

class Export_Section : public PE_Section {
public:
	std::vector<PE_Export> exports;
	IMAGE_EXPORT_DIRECTORY ExportDirectory;

	Export_Section(const PE_Section& section);

	DWORD64 GetExportAddress(std::string name) const;
	DWORD64 GetExportAddress(WORD ordinal) const;
};


```

`BLUESPAWN-win-client/headers/util/pe/Image_Loader.h`:

```h
#pragma once

#include <Windows.h>

#include "util/wrappers.hpp"
#include "util/DynamicLinker.h"

#include "util/pe/PE_Image.h"

DEFINE_FUNCTION(NTSTATUS, NtQueryInformationProcess, __kernel_entry NTAPI, IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInnformationLength,
	OUT PULONG ReturnLength);

typedef struct _UNICODE_STRING32 {
	USHORT Length;
	USHORT MaximumLength;
	DWORD Buffer; // PWSTR
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _LDR_ENTRY32 {
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	DWORD DllBase;    // LPVOID
	DWORD EntryPoint; // LPVOID
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	union {
		ULONG TimeDateStamp;
		DWORD LoadedImports;
	};
} LDR_ENTRY32, *PLDR_ENTRY32;

typedef struct _LDR_DATA32 {
	ULONG Length;
	BOOLEAN Initialized;
	DWORD SsHandle;         // PVOID
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	DWORD EntryInProgress;  // PVOID
	BOOLEAN ShutdownInProgress;
	DWORD ShutdownThreadId; // HANDLE
} LDR_DATA32, *PLDR_DATA32;

typedef struct _UNICODE_STRING64 {
	USHORT Length;
	USHORT MaximumLength;
	DWORD64 Buffer; // PWSTR
} UNICODE_STRING64, * PUNICODE_STRING64;

typedef struct _LDR_ENTRY64 {
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	DWORD64 DllBase;    // LPVOID
	DWORD64 EntryPoint; // LPVOID
	ULONG SizeOfImage;
	UNICODE_STRING64 FullDllName;
	UNICODE_STRING64 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY64 HashLinks; 
	union {
		ULONG TimeDateStamp;
		DWORD64 LoadedImports;
	};
} LDR_ENTRY64, *PLDR_ENTRY64;

typedef struct _LDR_DATA64 {
	ULONG Length;
	BOOLEAN Initialized;
	DWORD64 SsHandle;         // PVOID
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	DWORD64 EntryInProgress;  // PVOID
	BOOLEAN ShutdownInProgress;
	DWORD64 ShutdownThreadId; // HANDLE
} LDR_DATA64, * PLDR_DATA64;

struct Loaded_Image64 {
	HandleWrapper process;
	std::wstring ImageName;
	std::wstring ImagePath;
	DWORD ImageSize;
	DWORD64 ImageAddress;
	DWORD64 EntryPoint;

	Loaded_Image64(const LDR_ENTRY64& entry, const HandleWrapper& process);
};

struct Loaded_Image32 {
	HandleWrapper process;
	std::wstring ImageName;
	std::wstring ImagePath;
	DWORD ImageSize;
	DWORD ImageAddress;
	DWORD EntryPoint;

	Loaded_Image32(const LDR_ENTRY32& entry, const HandleWrapper& process);
};

struct Loaded_Image {
	Architecture arch;

	std::optional<Loaded_Image32> image32;
	std::optional<Loaded_Image64> image64;

	Loaded_Image(const LDR_ENTRY32& entry, const HandleWrapper& process);
	Loaded_Image(const LDR_ENTRY64& entry, const HandleWrapper& process);
	
	std::wstring GetName();
};

class Image_Loader {
public:
	std::vector<Loaded_Image> LoadedImages;
	Architecture arch;
	const HandleWrapper& process;
	DWORD64 address;

	Image_Loader(const HandleWrapper& process = GetCurrentProcess());

	bool ContainsImage(const std::wstring& name) const;

	std::optional<Loaded_Image> GetImageInfo(const std::wstring& name) const;

	std::optional<Loaded_Image> GetAssociatedImage(LPVOID address) const;
};


```

`BLUESPAWN-win-client/headers/util/pe/Import_Section.h`:

```h
#pragma once
#include "util/pe/pe_section.h"

#include <vector>
#include <string>
#include <map>
#include <set>

#pragma pack(push, 1)

typedef struct _IMPORT_DIRECTORY_TABLE {
	DWORD dwImportLookupTableRVA;
	DWORD dwTimestamp;
	DWORD dwForwarderChain;  // Microsoft refuses to document this
	DWORD dwNameRVA;
	DWORD dwImportAddressTableRVA;
} IMPORT_DIRECTORY_TABLE, *PIMAGE_DIRECTORY_TABLE;

typedef struct _IMPORT_LOOKUP_TABLE64 {
	DWORD64 type : 1;
	DWORD64 value : 63; // if type = 1, this is a SHORT representing the ordinal to import. 
						// else this is a DWORD representing the hint/name RVA
} IMPORT_LOOKUP_TABLE64, * PIMPORT_LOOKUP_TABLE64;

typedef struct _IMPORT_LOOKUP_TABLE32 {
	DWORD type : 1;
	DWORD value : 31; // if type = 1, this is a SHORT representing the ordinal to import. 
				      // else this is a DWORD representing the hint/name RVA
} IMPORT_LOOKUP_TABLE32, * PIMPORT_LOOKUP_TABLE32;

struct Hint {
	WORD hint;
	std::string name;
};
struct Import {
	bool IsOrdinal;
	WORD ordinal;
	Hint hint;
};

typedef IMPORT_LOOKUP_TABLE64 IMPORT_ADDRESS_TABLE64, *PIMAGE_ADDRESS_TABLE64;
typedef IMPORT_LOOKUP_TABLE32 IMPORT_ADDRESS_TABLE32, *PIMAGE_ADDRESS_TABLE32;

#pragma pack(pop)

class PE_Image;

class Import_Library {
public:
	std::wstring sLibraryName{};
	const PE_Image& image;
	
	Import_Library(const PE_Image& image, const IMPORT_DIRECTORY_TABLE& ImportDirectoryTable);

	// A mapping from Imports to RVAs of the related Import Address Table entry.
	std::vector<std::pair<Import, DWORD>> vImportToIAT{};

	bool LoadImportLibrary(const HandleWrapper& context);
};

class Import_Section : public PE_Section {
public:
	std::vector<Import_Library> imports;

	Import_Section(const PE_Section& section);

	bool LoadAllImports(const HandleWrapper& context);

	std::set<std::wstring> GetRequiredLibraries() const;
};

```

`BLUESPAWN-win-client/headers/util/pe/PE_Image.h`:

```h
#ifndef PE_IMAGE_H
#define PE_IMAGE_H

#include <Windows.h>
#include <winternl.h>

#include <map>
#include <optional>

#include "util/Wrappers.hpp"

#include "util/pe/PE_Section.h"
#include "Relocation_Section.h"
#include "Import_Section.h"
#include "Export_Section.h"
#include "Resource_Section.h"

enum Architecture { x86, x64 };

class PE_Image {
private:
	DWORD dwHeaderSize;
	MemoryWrapper<> BaseAddress;

public:
	MemoryWrapper<> base;
	std::optional<std::wstring> swzImageName;
	std::optional<std::wstring> swzImagePath;

	Architecture arch;

	bool expanded;
	bool freeOnDestroy;

	std::map<std::string, PE_Section> sections;

	Relocation_Section* relocations;
	Import_Section* imports;
	Export_Section* exports;
	Resource_Section* resources;

	DWORD dwExpandSize;
	DWORD dwImageSize;
	DWORD dwEntryPoint;

	PE_Image(LPVOID lpBaseAddress, HANDLE hProcess = GetCurrentProcess(), bool expanded = false, 
		std::optional<std::wstring> swzImageName = std::nullopt, std::optional<std::wstring> swzImagePath = std::nullopt);
	PE_Image(std::wstring FileName);
	~PE_Image();

	bool ValidatePE() const;

	DWORD RVAToOffset(DWORD rva) const;
	DWORD OffsetToRVA(DWORD rva) const;

	std::optional<PE_Image> LoadTo(MemoryWrapper<> target, bool AvoidTargetChanges = false);

	bool ApplyLocalRelocations(DWORD64 offset);
	bool ApplyTargetRelocations(MemoryWrapper<> target) const;

	bool ParseLocalImports(HandleWrapper process);
	bool ParseTargetImports(MemoryWrapper<> target) const;

	bool ApplyProtections(MemoryWrapper<> target) const;
};

#endif

```

`BLUESPAWN-win-client/headers/util/pe/PE_Section.h`:

```h
#pragma once

#include <Windows.h>

#include <string>

#include "util/Wrappers.hpp"

class PE_Image;
class PE_Section {
public:
	MemoryWrapper<> SectionContent;
	const PE_Image& AssociatedImage;

	IMAGE_SECTION_HEADER SectionHeader;

	std::wstring Signature;

	bool expanded;

	PE_Section(const PE_Image& image, IMAGE_SECTION_HEADER SectionHeader = {}, MemoryWrapper<> lpImageBase = { nullptr }, bool expanded = false);
	PE_Section(const PE_Section& copy);

	bool ContainsRVA(DWORD rva) const;
	bool ContainsOffset(DWORD offset) const;

	DWORD ConvertOffsetToRVA(DWORD offset) const;
	DWORD ConvertRVAToOffset(DWORD rva) const;

	std::wstring GetSignature() const;

	operator IMAGE_SECTION_HEADER() const;
};


```

`BLUESPAWN-win-client/headers/util/pe/Relocation_Section.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>

#include "util/pe/PE_Section.h"
#include "util/wrappers.hpp"

struct Relocation_Block;

struct RelocBlock {
	DWORD dwRelocationOffset;
	DWORD dwBlockSize;
};
struct RelocEntry {
	WORD type : 3;
	WORD offset : 9;
};

struct Relocation_Entry {
	WORD type : 3;
	WORD offset : 9;

	const Relocation_Block& block;

	DWORD GetRVA();

	Relocation_Entry(RelocEntry entry, const Relocation_Block& block);
};

struct Relocation_Block {
	DWORD rva;
	DWORD size;

	std::vector<Relocation_Entry> entries;

	Relocation_Block(DWORD rva, DWORD size, MemoryWrapper<RelocEntry> location);

	std::vector<DWORD> GetRelocRVAs();
};

class Relocation_Section : public PE_Section {
public:
	std::vector<Relocation_Block> vRelocationBlocks;

	Relocation_Section(const PE_Section& section);

	std::vector<DWORD> GetRelocRVAs();
};
```

`BLUESPAWN-win-client/headers/util/pe/Resource_Section.h`:

```h
#pragma once
#include "util/pe/PE_Section.h"

#include <string>
#include <vector>

#include "util/wrappers.hpp"

class PE_Resource {
public:
	MemoryWrapper<> resource;
	std::wstring name;
	DWORD id;
};

class Resource_Section : public PE_Section {
public:
	std::vector<PE_Resource> resources;

	Resource_Section(const PE_Section& section);
};


```

`BLUESPAWN-win-client/headers/util/permissions/permissions.h`:

```h
#pragma once

#include <Windows.h>
#include <winnt.h>
#include <AclAPI.h>
#include <sddl.h>
#include <string>
#define PSTRING __PSTRING
#define STRING __STRING
#define UNICODE_STRING __UNICODE_STRING
#define PUNICODE_STRING __PUNICODE_STRING
#include <NTSecAPI.h>
#undef PSTRING
#undef STRING
#undef UNICODE_STRING
#undef PUNICODE_STRING

#include "util/log/Loggable.h"
#include "util/wrappers.hpp"

namespace Permissions{
	/**
	* Functions to check if an access mask includes a permission
	*
	* @param access - the access mask to check
	* @return true if the access mask includes the permission or ALL, false otherwise
	*/
	bool AccessIncludesAll(const ACCESS_MASK& access);
	bool AccessIncludesWrite(const ACCESS_MASK& access);
	bool AccessIncludesRead(const ACCESS_MASK& access);
	bool AccessIncludesExecute(const ACCESS_MASK& access);
	bool AccessIncludesWriteOwner(const ACCESS_MASK& access);
	bool AccessIncludesDelete(const ACCESS_MASK& access);

	/**
	* Function to add an access to an access mask
	*
	* @param access - the access mask to be changed
	*/
	void AccessAddAll(ACCESS_MASK& access);
	void AccessAddWrite(ACCESS_MASK& access);
	void AccessAddRead(ACCESS_MASK& access);
	void AccessAddExecute(ACCESS_MASK& access);
	void AccessAddWriteOwner(ACCESS_MASK& access);
	void AccessAddDelete(ACCESS_MASK& access);

	class SecurityDescriptor : public GenericWrapper<PISECURITY_DESCRIPTOR> {
		PSID lpUserSID;
		PSID lpGroupSID;
		PACL dacl;
		PACL sacl;

	protected:
		enum class SecurityDataType {
			USER_SID, GROUP_SID, DACL, SACL
		};

		SecurityDescriptor(DWORD dwSize, SecurityDataType type);

	public:
		/**
		* Create a SecurityDescriptor to hold a UserSID
		*
		* @param dwSize The size in bytes of the SID
		*
		* @return a SecurityDescriptor with the lpUserSID value set to a pointer to dwSize
		*	bytes of memory
		*/
		static SecurityDescriptor CreateUserSID(DWORD dwSize);
		/**
		* Create a SecurityDescriptor to hold a GroupSID
		*
		* @param dwSize The size in bytes of the SID
		*
		* @return a SecurityDescriptor with the lpGroupSID value set to a pointer to dwSize
		*	bytes of memory
		*/
		static SecurityDescriptor CreateGroupSID(DWORD dwSize);
		/**
		* Create a SecurityDescriptor to hold a DACL
		*
		* @param dwSize The size in bytes of the dacl
		*
		* @return a SecurityDescriptor with the dacl value set to a pointer to dwSize
		*	bytes of memory
		*/
		static SecurityDescriptor CreateDACL(DWORD dwSize);
		/**
		* Create a SecurityDescriptor to hold a sacl
		*
		* @param dwSize The size in bytes of the sacl
		*
		* @return a SecurityDescriptor with the sacl value set to a pointer to dwSize
		*	bytes of memory
		*/
		static SecurityDescriptor CreateSACL(DWORD dwSize);

		/**
		* Constructor to create a security descriptor from a PISECURITY_DESCRIPTOR
		*
		* @param lpSecurity A PISECURITY_DESCRIPTOR object. All valid fields in lpSecurity
		*	will be copied to the corresponding field in the SecurityDescriptor object, if
		*	such a field exists
		*/
		SecurityDescriptor(PISECURITY_DESCRIPTOR lpSecurity = nullptr);

		/*Getter for the lpUserSID field*/
		PSID GetUserSID() const;
		/*Getter for the lpGroupSID field*/
		PSID GetGroupSID() const;
		/*Getter for the dacl field*/
		PACL GetDACL() const;
		/*Getter for the sacl field*/
		PACL GetSACL() const;
	};

	/*Enum for storing type of Owner an Owner object is*/
	enum OwnerType {
		NONE, USER, GROUP
	};

	class LsaHandleWrapper : public GenericWrapper<LSA_HANDLE> {
	public:
		LsaHandleWrapper(LSA_HANDLE handle);
		LsaHandleWrapper(LSA_HANDLE handle, std::function<void(LSA_HANDLE)> fSafeClose);
		static void SafeCloseLsaHandle(LSA_HANDLE handle);
	};

	class Owner : public Loggable {
		//Policy Handler for User Rights Assignment Tracking
		static LsaHandleWrapper lPolicyHandle;

		//Boolean to track if the handle wrapper is initialized
		static bool bPolicyInitialized;

		//List of super user privileges
		static const std::vector<std::wstring> vSuperUserPrivs;

		/**
		* Function to initialize lPolicyHandle and set bPolicyInitialized
		* to true if initialization succeeded.
		*/
		static void InitializePolicy();

		/**
		* Function de-initialize lPolicyHandle
		* param handle - the handle to de initialize
		*/
		static void DeinitializePolicy(LSA_HANDLE handle);
	protected:
		//Whether or not this owner is on the system
		bool bExists;

		//The user's SID structure
		SecurityDescriptor sdSID;

		//Owner's qualified name
		std::wstring wName;

		//Domain to which the user belongs
		std::wstring wDomainName;

		//The type of the owner
		OwnerType otType;

		/**
		* Function to convert a wstring to an LSA_UNICODE_STRING
		* 
		* @param str the wstring to convert
		*
		* @return an LSA_UNICODE_STRING corresponding to the given wstring
		*/
		static std::shared_ptr<LSA_UNICODE_STRING> Owner::WStringToLsaUnicodeString(IN const std::wstring& str);

		/**
		* Constructor for an owner object based off sid
		*
		* @param sid A SecurityDescriptor with lpUserSID set to the sid of the owner. Other
		*	fields will be filled in if an owner of that sid exists.
		*/
		static std::wstring Owner::LsaUnicodeStringToWString(IN const LSA_UNICODE_STRING& str);

		/**
		* Constructor for an owner object that sets wName, bExists, and otOwnerType, but no other fields
		*
		* @param name A wstring containing value to be copied to wName
		* @param exists A boolean containing value to be copied ot bExists
		* @param t An OwnerType containing value to be copied to otOwnerType
		*/
		Owner(IN const std::wstring& name, IN bool exists, IN OwnerType t);

		/**
		* Constructor for an owner object that sets sdSID, bExists, and otOwnerType, but no other fields
		*
		* @param sid A SecurityDescriptor containing value to be copied to sdSID. Should have lpUserSID set
		*	to valid PSID if t is USER, and lpGroupSID set to valid PSID if t is GROUP.
		* @param exists A boolean containing value to be copied ot bExists
		* @param t An OwnerType containing value to be copied to otOwnerType
		*/
		Owner(IN const SecurityDescriptor& sid, IN bool exists, IN OwnerType t);

		/**
		* Constructor for an owner object that sets all fields to given values. Performs no checking
		* that given name and sid line up.
		*
		* @param name A wstring containing value to be copied to wName
		* @ param domain A wstring containing value to be copied to wDomain
		* @param sid A SecurityDescriptor containing value to be copied to sdSID. Should have lpUserSID set
		*	to valid PSID if t is USER, and lpGroupSID set to valid PSID if t is GROUP.
		* @param exists A boolean containing value to be copied ot bExists
		* @param t An OwnerType containing value to be copied to otOwnerType
		*/
		Owner(IN const std::wstring& name, IN const std::wstring& domain, IN const SecurityDescriptor& sid, IN bool exists, IN OwnerType t);


	public:
		/**
		* Constructor for an owner object based off name
		*
		* @param name A wstring containing the name of an object. Other fields will
		*	be filled in if an owner of that name exists.
		*/
		Owner(IN const std::wstring& name);
		
		/**
		* Constructor for an owner object based off sid
		* 
		* @param sid A SecurityDescriptor with lpUserSID set to the sid of the owner. Other
		*	fields will be filled in if an owner of that sid exists. 
		*/
		Owner(IN const SecurityDescriptor& sid);
		
		/**
		* Function to get whether or not the owner exists on the system
		*
		* @return true if the owner exists, false otherwise
		*/
		bool Exists() const;
		/**
		* Function to get the name of a user
		*
		* @return wstring containing the name of the owner in form
		*/
		std::wstring GetName() const;


		/**
		* Function to get the name of the domain the owner belongs to
		*
		* @return wstring containing the domain name that the owner belongs to
		*/
		std::wstring GetDomainName() const;

		/**
		* Function to get the SID of the owner
		*
		* @return SID structure with the owner's SID
		*/
		PSID GetSID() const;

		/**
		* Function to get the owner type
		*
		* @return OwnerType value of GROUP, USER, or NONE
		*/
		OwnerType GetOwnerType() const;

		/**
		 * Gets the owner's name
		 *
		 * @return The name of the owner
		 */
		virtual std::wstring ToString() const;

		/**
		* Function to get a list of privileges the owner has
		*
		* @return the list of privileges an owner explicity has, and if they 
		*     are a user, includes the privileges granted to them by the
		*     groups they're in.
		*/
		std::vector<std::wstring> GetPrivileges();

		/**
		* Function to check if the owner has a certain privilege
		*
		* @param wPriv the name of the privilege to check for. Names should
		*    be given as constants listed here: https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants
		* 
		* @return true if the owner has the privilege, false otherwise
		*/
		bool HasPrivilege(IN const std::wstring& wPriv);

		/**
		* Function to enumerate all owners with a given privilege
		* 
		* @param wPriv a wstring containing the privilege to check for.
		*     Names should be from: https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants
		*
		* @return a vector of Owner objects containing all owners with the given privilege.
		*     If the function fails, the vector will be empty and GetLastError() will contain
		*     the failure reason. If GetLastError() returns ERROR_SUCCESS, the function succeeded
		*     but there were no Owners with the given privilege. 
		*/
		static std::vector<Owner> GetOwnersWithPrivilege(IN const std::wstring& wPriv);

		/**
		* Function to remove a privilege from an owner object
		* 
		* @param wPriv a wstring containing the name of the privilege to remove
		*
		* @return true if the function succeeded, false otherwise. If the function fails,
		*     GetLastError() will return the reason for failure.
		*/
		bool RemovePrivilege(IN const std::wstring& wPriv);

		/**
		* Function to check if an owner has a superuser privilege.
		*
		* @return true if the user has any of these privileges, false otherwise
		*/
		bool HasSuperUserPrivs();

		/**
		* Function to remove all super user privileges from an owner
		*
		* @return true if function succeeds, false otherwise. If the function
		*     fails, GetLastError() will contain the reason for failure
		*/
		bool RemoveSuperUserPrivs();

		/**
		* Function to delete an owner from the system
		*
		* @return true if the user was deleted, false otherwise
		*/
		bool Delete();
	};

	class User : public Owner {


	public:

		/**
		* Creates a User object based off a qualified user name
		*
		* @param uName The qualified username of the user
		*/
		User(IN const std::wstring& uName);

		/**
		* Create a User object based off an SID
		*
		* @param sid SecurityDescriptor with UserSID set to SID of the user
		*/
		User(IN const SecurityDescriptor& sid);
	};

	class Group : public Owner {
	public:

		/**
		* Create a group based off of group name
		*
		* @param name The name of the group
		*/
		Group(IN const std::wstring& name);

		/**
		* Create a group based off of a user name
		*
		* @param sid SecurityDesicrptor with group SID set to the SID of the group
		*/
		Group(IN const SecurityDescriptor& sid);
	};

	/**
	* Gets the rights a specific owner object has under a given acl
	*
	* @param owner The owner object for whom to check rights
	* @param acl The acl from which to read rights
	*
	* @return ACCESS_MASK containing the rights the owner object has
	*/
	ACCESS_MASK GetOwnerRightsFromACL(const Owner& owner, const SecurityDescriptor& acl);

	/**
	* Get the owner of the Bluespawn process
	*
	* @return An Owner object representing the owner of the Bluespawn process,
	*	or std::nullopt if the function failed
	*/
	std::optional<Owner> GetProcessOwner();

	/**
	* Function to update the ACL of an object
	* @param wsObjectName A wstring containing the name of the object for which to update permissions
	* @param seObjectType An SE_OBJECT_TYPE desciribing the type of the object for which to update permissions
	* @param oOwner An Owner object representing the owner for whom to update permissions
	* @param amDesiredAccess An ACCESS_MASK containing the permissions to grant or deny to oOwner
	* @param bDeny If false, grant access to amDesiredAccess, if true deny access. Defaults to false
	*
	* @return true if the objects ACL was updated. False otherwise. If false, GetLastError will contain the error.
	*/
	bool UpdateObjectACL(const std::wstring& wsObjectName, SE_OBJECT_TYPE seObjectType, const Owner& oOwner, ACCESS_MASK amDesiredAccess, bool bDeny = false);
}
```

`BLUESPAWN-win-client/headers/util/processes/Analyzer.h`:

```h
#include <Windows.h>
#include <winternl.h>

#include <memory>
#include <functional>

#define ALLOCATE(name, size)                                                             \
    LPVOID name = VirtualAlloc(nullptr, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); \
    std::unique_ptr<VOID, std::function<void(LPVOID)>> name##ScopeGuard{ name, [](LPVOID ptr){ VirtualFree(ptr, 0, MEM_RELEASE); } };

#define CREATE_HANDLE(name, ...) \
    HANDLE name = __VA_ARGS__;   \
    std::unique_ptr<VOID, std::function<void(HANDLE)>> name##ScopeGuard{ name, [](HANDLE ptr){ CloseHandle(ptr); } };

#define IMAGE_SECTION_INVALID         0x1000
#define IMAGE_FILE_INVALID            0x2000
#define IMAGE_LOADER_INVALID          0x4000

#define ERROR_OCCURED                 0x80000000

#define ADDRESS_NOT_IN_IMAGE_SECTION  IMAGE_SECTION_INVALID | 0x1
#define IMAGE_DOES_NOT_MATCH_FILE     IMAGE_SECTION_INVALID | 0x2
#define EXECUTION_NOT_IN_TEXT_SECTION IMAGE_SECTION_INVALID | 0x4
#define IMAGE_HEADERS_MISMATCH        IMAGE_SECTION_INVALID | 0x8

#define IMAGE_FILE_NOT_SIGNED         IMAGE_FILE_INVALID    | 0x1
#define IMAGE_FILE_NOT_FOUND          IMAGE_FILE_INVALID    | 0x2

#define IMAGE_LOADER_NAME_MISMATCH    IMAGE_LOADER_INVALID  | 0x1
#define IMAGE_LOADER_SIZE_MISMATCH    IMAGE_LOADER_INVALID  | 0x2

#define FAIL_IF_INVALID_HANDLE(name, ...)          \
    CREATE_HANDLE(name, __VA_ARGS__);              \
    if(name == INVALID_HANDLE_VALUE || name == 0){ \
        return ERROR_OCCURED | GetLastError();     \
    }

#define FAIL_IF_FALSE(...)                     \
    if(!(__VA_ARGS__)){                        \
        return ERROR_OCCURED | GetLastError(); \
	}

#define FAIL_IF_NOT_SUCCESS(...)     \
    {                                \
        STATUS status = __VA_ARGS__; \
        if(status != ERROR_SUCCESS)  \
             return status;          \
    }

typedef unsigned __int32 STATUS;

typedef struct _LDR_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
} LDR_ENTRY, *PLDR_ENTRY;

typedef struct _LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} LDR_DATA, *PLDR_DATA;

class Analyzer {
public:
	STATUS ValidateThread(HANDLE hThread, HANDLE hProcess);
	STATUS ValidateProcess(HANDLE hProcess);
	STATUS ValidateAddress(HANDLE hProcess, LPVOID lpAddress);

	STATUS ValidateAddressInImage(HANDLE hProcess, LPVOID lpAddress, LPVOID* lpBaseAddress);
	STATUS ValidateFile(HANDLE hFile);
	STATUS ValidateTextExecution(HANDLE hProcess, LPVOID lpAddress, LPVOID lpBaseAddress);
	STATUS ValidateLoader(HANDLE process, LPVOID BaseAddress, HANDLE hFile);
	STATUS ValidateMatchesFile(HANDLE hProcess, HANDLE hFile, LPVOID lpBaseAddress);
	STATUS ValidateImageSection(HANDLE hProcess, LPVOID lpAddress, PHANDLE hFile);
};
```

`BLUESPAWN-win-client/headers/util/processes/CheckLolbin.h`:

```h
#pragma once

#include <string>

#include "util/filesystem/FileSystem.h"

/**
 * Checks whether the file given is a well known living off the land binary.
 * This is done by comparing the hash of this file against that of known lolbins such
 * as cmd.exe, powershell.exe, netsh.exe, net.exe, net1.exe, explorer.exe, rundll32.exe,
 * wscript.exe, wmic.exe, regsvr32.exe, and cscript.exe
 *
 * @param file The file to check
 *
 * @return true if this file is a lolbin; false otherwise
 */
bool IsLolbin(const FileSystem::File& file);

/**
 * Checks whether a command will run a "living off the land" binary in a potentially malicious
 * manner. See IsLolbin for more information.
 *
 * @param command The command to check
 *
 * @return True if command may execute malicious code through a lolbin; false if otherwise.
 */
bool IsLolbinMalicious(const std::wstring& command);
```

`BLUESPAWN-win-client/headers/util/processes/CommandParser.h`:

```h
#pragma once

#include <vector>
#include <string>

std::vector<std::wstring> TokenizeCommand(const std::wstring& command);
std::vector<std::wstring> GetArgumentTokens(const std::wstring& command);
```

`BLUESPAWN-win-client/headers/util/processes/PERemover.h`:

```h
#pragma once

#include <Windows.h>

#include <string>

#include "util/wrappers.hpp"
#include "util/dynamiclinker.h"

DEFINE_FUNCTION(NTSTATUS, NtResumeProcess, NTAPI, IN HANDLE ProcessHandle);

class PERemover {
	HandleWrapper hProcess;
	LPVOID lpBaseAddress;
	DWORD dwImageSize;
	
	bool AddressIsInRegion(LPVOID lpAddress);
	bool AdjustPointer(LPVOID lpAddress);

	bool CheckThreads();
	bool WalkThreadBack(const HandleWrapper& hThread, DWORD dwTID);
	bool AdjustPointers();
	bool WipeMemory();

public:
	PERemover(const HandleWrapper& hProcess, LPVOID lpBaseAddress, DWORD dwImageSize = -1);
	PERemover(DWORD dwPID, LPVOID lpBaseAddress, DWORD dwImageSize = -1);
	PERemover(const HandleWrapper& hProcess, const std::wstring& wsImageName);
	PERemover(DWORD dwPID, const std::wstring& wsImageName);

	bool RemoveImage();
};
```

`BLUESPAWN-win-client/headers/util/processes/ParseCobalt.h`:

```h
#pragma once

#include "util/wrappers.hpp"

bool DumpBeaconInformation(const MemoryWrapper<>& memory);
```

`BLUESPAWN-win-client/headers/util/processes/ProcessChecker.h`:

```h
#pragma once

#include <Windows.h>

bool ProcessIsDoppelganger(DWORD pid);
bool ProcessContainsShellcode(DWORD pid);
bool ProcessContainsHollows(DWORD pid);
bool ProcessContainsPEImplants(DWORD pid);
bool ProcessContainsHooks(DWORD pid);
```

`BLUESPAWN-win-client/headers/util/processes/ProcessUtils.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>
#include <string>

#include "util/wrappers.hpp"
#include "util/dynamiclinker.h"

#include "util/pe/Image_Loader.h"
#include "util/filesystem/FileSystem.h"

struct Hook {
	LPVOID ModificationAddress;
	LPVOID RedirectionAddress;
};

bool HookIsOkay(const Hook& hook);

std::vector<LPVOID> GetExecutableNonImageSections(DWORD pid);
std::vector<LPVOID> GetUnregisteredImages(DWORD pid);
std::vector<LPVOID> GetModifiedImages(DWORD pid);
std::vector<LPVOID> GetHooks(DWORD pid);

std::wstring GetProcessImage(DWORD dwPID);
std::wstring GetProcessImage(const HandleWrapper& hProcess);
std::wstring GetProcessCommandline(DWORD dwPID);
std::wstring GetProcessCommandline(const HandleWrapper& hProcess);
std::wstring GetImagePathFromCommand(std::wstring wsCmd);
std::vector<std::wstring> EnumModules(DWORD dwPID);
std::vector<std::wstring> EnumModules(const HandleWrapper& hProcess);
LPVOID GetModuleAddress(DWORD dwPID, const std::wstring& wsModuleName);
LPVOID GetModuleAddress(const HandleWrapper& hProcess, const std::wstring& wsModuleName);
DWORD GetRegionSize(DWORD dwPID, LPVOID lpRegionAddress);
DWORD GetRegionSize(const HandleWrapper& hProcess, LPVOID lpRegionAddress);
std::optional<FileSystem::File> GetMappedFile(DWORD dwPID, LPVOID address);
std::optional<FileSystem::File> GetMappedFile(const HandleWrapper& hProcess, LPVOID address);

namespace Utils::Process {
	AllocationWrapper ReadProcessMemory(const HandleWrapper& hProcess, LPVOID lpBaseAddress, DWORD dwSize);
	AllocationWrapper ReadProcessMemory(DWORD dwPID, LPVOID lpBaseAddress, DWORD dwSize);
}

```

`BLUESPAWN-win-client/headers/util/wrappers.hpp`:

```hpp
#pragma once
#include <Windows.h>

#include <map>
#include <string>
#include <memory>
#include <optional>
#include <functional>
#include <lm.h>
#define PSTRING __PSTRING
#define STRING __STRING
#define UNICODE_STRING __UNICODE_STRING
#define PUNICODE_STRING __PUNICODE_STRING
#include <NTSecAPI.h>
#undef PSTRING
#undef STRING
#undef UNICODE_STRING
#undef PUNICODE_STRING

template<class T>
class GenericWrapper {
protected:
	std::shared_ptr<T> ReferenceCounter;
	std::optional<T> BadValue;

public:

	GenericWrapper(T object, std::function<void(T)> freeFunction = [](T object){ delete object; }, std::optional<T> BadValue = std::nullopt) :
		BadValue{ BadValue },
		ReferenceCounter{ new T(object), [BadValue, freeFunction](auto* object){
			if((!BadValue || *BadValue != *object) && *object){ freeFunction(*object); }
			delete object;
		} }{}

		operator T() const{ return *ReferenceCounter; }
		T operator *() const{ return *ReferenceCounter; }
		T operator ->() const{ return *ReferenceCounter; }
		T* operator &() const{ return const_cast<T*>(&*ReferenceCounter); }
		bool operator ==(T object) const{ return *ReferenceCounter == object; }
		void reassign(T object){ *ReferenceCounter = object; }
		bool operator !() const{ return !*ReferenceCounter || *ReferenceCounter == BadValue; }
		operator bool() const{ return !operator!(); }
		T Release(){ auto tmp = *ReferenceCounter; *ReferenceCounter = BadValue; return tmp; }
		T Get() const{ return *ReferenceCounter; }
};

class HandleWrapper : public GenericWrapper<HANDLE> {
public:
	HandleWrapper(HANDLE handle) :
		GenericWrapper(handle, SafeCloseHandle, INVALID_HANDLE_VALUE){};
	static void SafeCloseHandle(HANDLE handle){
		BY_HANDLE_FILE_INFORMATION hInfo;
		if(GetFileInformationByHandle(handle, &hInfo)){
			CloseHandle(handle);
		} else{
			HRESULT a = GetLastError();
			if(a != ERROR_INVALID_HANDLE){
				CloseHandle(handle);
			}
		}
	}
};

class FindWrapper : public GenericWrapper<HANDLE> {
public:
	FindWrapper(HANDLE handle) :
		GenericWrapper(handle, FindClose, INVALID_HANDLE_VALUE){};
};

typedef HandleWrapper MutexType;
class AcquireMutex {
	std::shared_ptr<MutexType> tracker;

public:
	explicit AcquireMutex(MutexType mutex) :
		tracker{ new MutexType(mutex), [](auto* m){ ReleaseMutex(*m); } }{
		::WaitForSingleObject(*tracker, INFINITE);
	}
};


class CriticalSection {
	std::shared_ptr<CRITICAL_SECTION> counter;

public:
	CriticalSection(){
		counter = { 
			new CRITICAL_SECTION{}, [](PCRITICAL_SECTION section) mutable {
			    DeleteCriticalSection(section); 
			    delete section; 
		    }
		};
		InitializeCriticalSection(&*counter);
	}

	operator LPCRITICAL_SECTION() const { return static_cast<LPCRITICAL_SECTION>(&*counter); }
};

class BeginCriticalSection {
	CriticalSection critsec;

public:
	explicit BeginCriticalSection(const CriticalSection& section) :
		critsec{ section }{
		::EnterCriticalSection(critsec);
	}
	~BeginCriticalSection(){
		::LeaveCriticalSection(critsec);
	}
};

class AllocationWrapper {
	std::optional<std::shared_ptr<char[]>> Memory;
	PCHAR pointer;
	SIZE_T AllocationSize;

public:
	enum AllocationFunction {
		VIRTUAL_ALLOC, HEAP_ALLOC, MALLOC, CPP_ALLOC, CPP_ARRAY_ALLOC, STACK_ALLOC, LOCAL_ALLOC, GLOBAL_ALLOC, LSA_ALLOC, NET_ALLOC
	};

	AllocationWrapper(LPVOID memory, SIZE_T size, AllocationFunction AllocationType = STACK_ALLOC) :
		pointer{ reinterpret_cast<PCHAR>(memory) },
		Memory{ 
			size && memory ? std::optional<std::shared_ptr<char[]>>{{
				reinterpret_cast<PCHAR>(memory), [AllocationType](char* value){
					if (AllocationType == CPP_ALLOC)
						delete value;
					else if (AllocationType == CPP_ARRAY_ALLOC)
						delete[] value;
					else if (AllocationType == MALLOC)
						free(value);
					else if (AllocationType == HEAP_ALLOC)
						HeapFree(GetProcessHeap(), 0, value);
					else if (AllocationType == VIRTUAL_ALLOC)
						VirtualFree(value, 0, MEM_RELEASE);
					else if (AllocationType == GLOBAL_ALLOC)
						GlobalFree(value);
					else if (AllocationType == LOCAL_ALLOC)
						LocalFree(value);
					else if (AllocationType == LSA_ALLOC)
						LsaFreeMemory(value);
					else if (AllocationType == NET_ALLOC)
						NetApiBufferFree(value);
				}
			}} : std::nullopt
	    },
		AllocationSize{ size }{}

	CHAR& operator[](int i) const{
		return pointer[i];
	}

	operator bool() const{
		return Memory.has_value();
	}

	bool operator !() const{
		return !static_cast<bool>(*this);
	}

	operator LPVOID() const{
		return pointer;
	}

	DWORD GetSize() const{
		return Memory.has_value() ? AllocationSize : 0;
	}

	template<class T>
	std::optional<T> operator*() const{
		return Dereference();
	}

	template<class T>
	std::optional<T> Dereference() const{
		if(AllocationSize < sizeof(T) || !Memory.has_value()){
			return std::nullopt;
		} else{
			return *reinterpret_cast<T*>(pointer);
		}
	}

	std::optional<std::wstring> ReadWString() const{
		if(Memory.has_value()){
			SIZE_T size = wcsnlen(reinterpret_cast<PWCHAR>(pointer), AllocationSize / 2);
			PWCHAR buffer = new WCHAR[size + 1];
			CopyMemory(buffer, pointer, size * 2);
			buffer[size] = 0;
			auto str = std::wstring{ buffer };
			delete[] buffer;
			return str;
		} else return std::nullopt;
	}

	std::optional<std::string> ReadString() const{
		if(Memory.has_value()){
			SIZE_T size = strnlen(reinterpret_cast<PCHAR>(pointer), AllocationSize);
			PCHAR buffer = new CHAR[size + 1];
			CopyMemory(buffer, pointer, size);
			buffer[size] = 0;
			auto str = std::string{ buffer };
			delete[] buffer;
			return str;
		} else return std::nullopt;
	}

	bool CompareMemory(const AllocationWrapper& wrapper) const{
		if(!wrapper && !Memory.has_value()){
			return true;
		} else if(!wrapper || !Memory.has_value()){
			return false;
		} else if(wrapper.AllocationSize == AllocationSize){
			return RtlEqualMemory(wrapper.pointer, pointer, AllocationSize);
		} else{
			return false;
		}
	}

	bool operator==(const AllocationWrapper& wrapper) const{
		return CompareMemory(wrapper);
	}

	bool operator!=(const AllocationWrapper& wrapper) const{
		return !CompareMemory(wrapper);
	}

	bool SetByte(SIZE_T offset, char value){
		if(offset < AllocationSize){
			pointer[offset] = value;
			return true;
		}
		return false;
	}

	template<class T = LPVOID>
	T* GetAsPointer() const { 
		return reinterpret_cast<T*>(pointer); 
	}
};

template<class T = CHAR>
class MemoryWrapper {
	T LocalCopy{};

public:
	T* address;
	HandleWrapper process;
	SIZE_T MemorySize;

	MemoryWrapper(LPVOID lpMemoryBase, SIZE_T size = sizeof(T), HANDLE process = GetCurrentProcess())
		: address{ reinterpret_cast<T*>(lpMemoryBase) }, process{ process }, MemorySize{ size } {}

	T Dereference() const{
		if(!process){
			return *address;
		} else{
			T mem = {};
			ReadProcessMemory(process, address, &mem, sizeof(T), nullptr);
			return mem;
		}
	}

	T operator *() const{
		return Dereference();
	}
	T** operator &() const{
		return &(address);
	}
	operator T* () const{
		return (address);
	}
	T* operator->(){
		if(!process){
			return address;
		} else{
			LocalCopy = {};
			if(ReadProcessMemory(process, address, &LocalCopy, sizeof(LocalCopy), nullptr)){
				return &LocalCopy;
			} else{
				return nullptr;
			}
		}
	}

	template<class V>
	MemoryWrapper<V> Convert() const{
		return { reinterpret_cast<V*>(address), MemorySize, process };
	}

	MemoryWrapper<T> GetOffset(SIZE_T offset) const{
		if(offset > MemorySize){
			return { nullptr, 0, process };
		} else{
			return { reinterpret_cast<T*>(PCHAR(address) + offset), MemorySize - offset, process };
		}
	}

	bool CompareMemory(MemoryWrapper<T> memory) const{
		auto data1 = Dereference();
		auto data2 = memory.Dereference();
		return !memcmp(&data1, &data2, min(memory.MemorySize, MemorySize));
	}

	bool Protect(DWORD protections, SIZE_T size = -1){
		if(size == -1) size = MemorySize;
		DWORD dwOldProtections{};
		if(!process){
			return VirtualProtect(address, size, protections, &dwOldProtections);
		} else{
			return VirtualProtectEx(process, address, size, protections, &dwOldProtections);
		}
	}

	std::string ReadString(){
		if(!process){
			return std::string{ reinterpret_cast<char*>(address) };
		} else{
			int idx = 0;
			int maxIdx = 10;
			char* memory = new char[maxIdx * 2];
			bool valid = false;
			while(!valid && !ReadProcessMemory(process, address, memory, maxIdx = min(maxIdx * 2, MemorySize), nullptr)){
				for(; idx < maxIdx; idx++){
					if(memory[idx] == 0){
						valid = true;
						break;
					}
					delete[] memory;
					memory = new char[maxIdx * 2];
				}
			}
			if(valid){
				return std::string{ memory };
			} else{
				return std::string{};
			}
		}
	}

	std::wstring ReadWstring(){
		if(!process){
			return std::wstring{ reinterpret_cast<WCHAR*>(address) };
		} else{
			int idx = 0;
			int maxIdx = 10;
			wchar_t* memory = new wchar_t[maxIdx * 2];
			bool valid = false;
			while(!valid && !ReadProcessMemory(process, address, memory, (maxIdx = min(maxIdx * 2, MemorySize / sizeof(WCHAR))) * sizeof(WCHAR), nullptr)){
				for(; idx < maxIdx; idx++){
					if(memory[idx] == 0){
						valid = true;
						break;
					}
				}
				delete[] memory;
				memory = new wchar_t[maxIdx * 2];
			}
			if(valid){
				return std::wstring{ memory };
			} else{
				return std::wstring{};
			}
		}
	}

	operator bool() const{ return address; }
	bool operator !() const{ return !address; }

	AllocationWrapper ToAllocationWrapper(DWORD size = -1UL) const{
		size = min(size, MemorySize);
		if(size > 0x8000){
			AllocationWrapper wrapper{ ::VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE), size,
				AllocationWrapper::VIRTUAL_ALLOC };
			if(process){
				if(ReadProcessMemory(process, address, wrapper, size, nullptr)){
					return wrapper;
				} else{
					return { nullptr, 0 };
				}
			} else{
				MoveMemory(wrapper, address, size);
				return wrapper;
			}
		} else{
			AllocationWrapper wrapper{ ::HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size), size,
				AllocationWrapper::HEAP_ALLOC };
			if(process){
				if(ReadProcessMemory(process, address, wrapper, size, nullptr)){
					return wrapper;
				} else{
					return { nullptr, 0 };
				}
			} else{
				MoveMemory(wrapper, address, size);
				return wrapper;
			}
		}
	}
};

#define WRAP(type, name, value, function) \
    GenericWrapper<type> name = {value, [&](type data){ function; }}

#define SCOPE_LOCK(function, name) \
    GenericWrapper<DWORD> __##name = { 1, [&](DWORD data){ function; }, 0 }

```

`BLUESPAWN-win-client/libpeconv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="16.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}</ProjectGuid>
    <ProjectName>libpeconv</ProjectName>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <BuildLog>
      <Path>$(SolutionDir)build\$(PlatformTarget)\$(Configuration)\$(MSBuildProjectName).log</Path>
    </BuildLog>
    <ClCompile>
      <AdditionalIncludeDirectories>$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\include;$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <UndefinePreprocessorDefinitions>UNICODE</UndefinePreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Secur32.lib;DbgHelp.lib;Wintrust.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Lib>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </AdditionalDependencies>
    </Lib>
    <Lib>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </AdditionalDependencies>
    </Lib>
    <Lib>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </AdditionalDependencies>
    </Lib>
    <Lib>
      <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildsettings.props" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ItemGroup>
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_hdrs_helper.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_mode_detector.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_raw_to_virtual.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_virtual_to_raw.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\relocate.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\util.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\buffer_util.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\remote_pe_reader.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\imports_loader.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\delayed_imports_loader.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\fix_imports.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_loader.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\pe_dumper.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\exports_lookup.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\function_resolver.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\hooks.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\exported_func.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\exports_mapper.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\resource_parser.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\file_util.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\resource_util.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\imports_uneraser.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\load_config_util.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\load_config_defs.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include\peconv\caves.h" />
    <ClInclude Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\fix_dot_net_ep.h" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_hdrs_helper.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_mode_detector.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_raw_to_virtual.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_virtual_to_raw.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\relocate.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\buffer_util.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\remote_pe_reader.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\imports_loader.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\delayed_imports_loader.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\fix_imports.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_loader.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\pe_dumper.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\exports_lookup.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\function_resolver.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\hooks.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\exported_func.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\exports_mapper.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\resource_parser.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\file_util.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\resource_util.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\imports_uneraser.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\load_config_util.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\caves.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\util.cpp" />
    <ClCompile Include="$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\src\fix_dot_net_ep.cpp" />
  </ItemGroup>
</Project>
```

`BLUESPAWN-win-client/pe-sieve.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="16.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}</ProjectGuid>
    <ProjectName>pe-sieve</ProjectName>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <BuildLog>
      <Path>$(SolutionDir)build\$(PlatformTarget)\$(Configuration)\$(MSBuildProjectName).log</Path>
    </BuildLog>
    <ClCompile>
      <AdditionalIncludeDirectories>$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\include;$(SolutionDir)BLUESPAWN-win-client\external\pe-sieve\libpeconv\libpeconv\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <UndefinePreprocessorDefinitions>UNICODE</UndefinePreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Secur32.lib;DbgHelp.lib;Wintrust.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildsettings.props" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ItemGroup>
    <ClCompile Include="external\pe-sieve\postprocessors\dump_report.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\imp_rec\iat_block.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\imp_rec\iat_finder.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\imp_rec\import_table_finder.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\imp_rec\imp_reconstructor.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\pe_buffer.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\pe_reconstructor.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\report_formatter.cpp" />
    <ClCompile Include="external\pe-sieve\postprocessors\results_dumper.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\artefact_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\code_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\headers_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\hook_targets_resolver.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\iat_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\mapping_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\mempage_data.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\module_data.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\patch_analyzer.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\patch_list.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\scanned_modules.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\scanner.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\scan_report.cpp" />
    <ClCompile Include="external\pe-sieve\scanners\workingset_scanner.cpp" />
    <ClCompile Include="external\pe-sieve\utils\artefacts_util.cpp" />
    <ClCompile Include="external\pe-sieve\utils\console_color.cpp" />
    <ClCompile Include="external\pe-sieve\utils\debug.cpp" />
    <ClCompile Include="external\pe-sieve\utils\format_util.cpp" />
    <ClCompile Include="external\pe-sieve\utils\modules_enum.cpp" />
    <ClCompile Include="external\pe-sieve\utils\path_converter.cpp" />
    <ClCompile Include="external\pe-sieve\utils\path_util.cpp" />
    <ClCompile Include="external\pe-sieve\utils\process_minidump.cpp" />
    <ClCompile Include="external\pe-sieve\utils\process_privilege.cpp" />
    <ClCompile Include="external\pe-sieve\utils\process_reflection.cpp" />
    <ClCompile Include="external\pe-sieve\utils\process_util.cpp" />
    <ClCompile Include="external\pe-sieve\utils\workingset_enum.cpp" />
    <ClInclude Include="external\pe-sieve\pe_sieve.h" />
    <ClInclude Include="external\pe-sieve\include\pe_sieve_types.h" />
    <ClInclude Include="external\pe-sieve\params_info\pe_sieve_params_info.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\dump_report.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\imp_rec\iat_block.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\imp_rec\iat_finder.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\imp_rec\import_table_finder.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\imp_rec\imp_reconstructor.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\pe_buffer.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\pe_reconstructor.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\report_formatter.h" />
    <ClInclude Include="external\pe-sieve\postprocessors\results_dumper.h" />
    <ClInclude Include="external\pe-sieve\scanners\artefact_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\code_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\headers_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\hook_targets_resolver.h" />
    <ClInclude Include="external\pe-sieve\scanners\iat_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\mapping_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\mempage_data.h" />
    <ClInclude Include="external\pe-sieve\scanners\module_data.h" />
    <ClInclude Include="external\pe-sieve\scanners\module_scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\module_scan_report.h" />
    <ClInclude Include="external\pe-sieve\scanners\patch_analyzer.h" />
    <ClInclude Include="external\pe-sieve\scanners\patch_list.h" />
    <ClInclude Include="external\pe-sieve\scanners\pe_section.h" />
    <ClInclude Include="external\pe-sieve\scanners\scanned_modules.h" />
    <ClInclude Include="external\pe-sieve\scanners\scanner.h" />
    <ClInclude Include="external\pe-sieve\scanners\scan_report.h" />
    <ClInclude Include="external\pe-sieve\scanners\workingset_scanner.h" />
    <ClInclude Include="external\pe-sieve\include\pe_sieve_api.h" />
    <ClCompile Include="external\pe-sieve\pe_sieve.cpp" />
    <ClInclude Include="external\pe-sieve\color_scheme.h" />
    <ClCompile Include="external\pe-sieve\params_info\pe_sieve_params_info.cpp" />
    <ClCompile Include="external\pe-sieve\dll_main.cpp" />
    <ClInclude Include="external\pe-sieve\utils\artefacts_util.h" />
    <ClInclude Include="external\pe-sieve\utils\console_color.h" />
    <ClInclude Include="external\pe-sieve\utils\format_util.h" />
    <ClInclude Include="external\pe-sieve\utils\modules_enum.h" />
    <ClInclude Include="external\pe-sieve\utils\ntddk.h" />
    <ClInclude Include="external\pe-sieve\utils\path_converter.h" />
    <ClInclude Include="external\pe-sieve\utils\path_util.h" />
    <ClInclude Include="external\pe-sieve\utils\process_minidump.h" />
    <ClInclude Include="external\pe-sieve\utils\process_privilege.h" />
    <ClInclude Include="external\pe-sieve\utils\process_reflection.h" />
    <ClInclude Include="external\pe-sieve\utils\process_util.h" />
    <ClInclude Include="external\pe-sieve\utils\workingset_enum.h" />
    <None Include="external\pe-sieve\main.def" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="$(SolutionDir)BLUESPAWN-win-client\libpeconv.vcxproj">
      <Project>{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}</Project>
      <Name>libpeconv</Name>
    </ProjectReference>
  </ItemGroup>
</Project>
```

`BLUESPAWN-win-client/resources/BLUESPAWN-client.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

MAINICON ICON "resources\\BLUESPAWN.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 0,5,0
 PRODUCTVERSION 0,5,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "BLUESPAWN Project"
            VALUE "FileDescription", "BLUESPAWN Active Defense & EDR Software"
            VALUE "FileVersion", "0.5.0"
            VALUE "InternalName", "BLUESPAWN-client.exe"
            VALUE "LegalCopyright", "Copyright (C) 2020 BLUESPAWN"
            VALUE "OriginalFilename", "BLUESPAWN-client.exe"
            VALUE "ProductName", "BLUESPAWN Client"
            VALUE "ProductVersion", "0.5.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// yararule
//

YaraSevere              yararule                "resources\\severe"
YaraSevere2             yararule                "resources\\severe2"

YaraIndicators          yararule                "resources\\indicators"

GoodSIP                 textfile                "resources\\SIP"
GoodTrustProviders      textfile                "resources\\TrustProviders"

DefaultMitigations      textfile                "resources\\mitigations.json"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`BLUESPAWN-win-client/resources/SIP`:

```
CryptSIPDllCreateIndirectData:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipCreateIndirectData C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,CreateIndirectData 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPCreateIndirectData 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsCreateHash 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,CreateIndirectData CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipCreateIndirectData D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipCreateIndirectData 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipCreateIndirectData 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipCreateHash C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,CreateIndirectData DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7SipCreateIndirectData DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPCreateIndirectData BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_CryptSIPCreateIndirectData CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPCreateIndirectData 9FA65764-C36F-4319-9737-658A34585BB7,mso.dll,MsoVBADigSigCreateIndirectData
CryptSIPDllGetSignedDataMsg:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipGetSignedDataMsg C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,GetSignedDataMsg 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPGetSignedDataMsg 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsGetSignature 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,GetSignedDataMsg CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipGetSignedDataMsg D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipGetSignedDataMsg 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipGetSignedDataMsg 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipGetSignature C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,GetSignedDataMsg DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7xSipGetSignedDataMsg DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSignedDataMsg BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_CryptSIPGetSignedDataMsg CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPGetSignedDataMsg 9FA65764-C36F-4319-9737-658A34585BB7,mso.dll,MsoVBADigSigGetSignedDataMsg
CryptSIPDllIsMyFileType2:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipIsFileSupportedName 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,IsFileSupportedName 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPIsMyTypeOfFile 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsIsMyFileType 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,IsFileSupportedName CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipIsFileSupportedName D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipIsFileSupportedName 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipIsFileSupportedName 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipIsMyFileType 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,IsFileSupportedName 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7xSipIsFileSupportedName BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_IsFileSupportedName CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPIsFileSupportedName
CryptSIPDllPutSignedDataMsg:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipPutSignedDataMsg C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,PutSignedDataMsg 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPPutSignedDataMsg 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsPutSignature 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,PutSignedDataMsg CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipPutSignedDataMsg D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipPutSignedDataMsg 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipPutSignedDataMsg 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipPutSignature C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,PutSignedDataMsg DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7xSipPutSignedDataMsg DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPPutSignedDataMsg BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_CryptSIPPutSignedDataMsg CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPPutSignedDataMsg 9FA65764-C36F-4319-9737-658A34585BB7,mso.dll,MsoVBADigSigPutSignedDataMsg
CryptSIPDllRemoveSignedDataMsg:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipRemoveSignedDataMsg C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,RemoveSignedDataMsg 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPRemoveSignedDataMsg 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsDelSignature 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,RemoveSignedDataMsg CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipRemoveSignedDataMsg D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipRemoveSignedDataMsg 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipRemoveSignedDataMsg 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipDelSignature C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,RemoveSignedDataMsg DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7xSipRemoveSignedDataMsg DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPRemoveSignedDataMsg BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_CryptSIPRemoveSignedDataMsg CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPRemoveSignedDataMsg 9FA65764-C36F-4319-9737-658A34585BB7,mso.dll,MsoVBADigSigRemoveSignedDataMsg
CryptSIPDllVerifyIndirectData:0AC5DF4B-CE07-4DE2-B76E-23C839A09FD1,AppxSip.dll,AppxSipVerifyIndirectData C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPVerifyIndirectData 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPVerifyIndirectData 1A610570-38CE-11D4-A2A3-00104BD35090,wshext.dll,VerifyIndirectData 000C10F1-0000-0000-C000-000000000046,MSISIP.DLL,MsiSIPVerifyIndirectData 603BCC1F-4B59-4E08-B724-D2C6297EF351,pwrshsip.dll,PsVerifyHash 06C9E010-38CE-11D4-A2A3-00104BD35090,wshext.dll,VerifyIndirectData CF78C6DE-64A2-4799-B506-89ADFF5D16D6,AppxSip.dll,EappxSipVerifyIndirectData D1D04F0C-9ABA-430D-B0E4-D7E96ACCE66C,AppxSip.dll,EappxBundleSipVerifyIndirectData 0F5F58B3-AADE-4B9A-A434-95742D92ECEB,AppxSip.dll,AppxBundleSipVerifyIndirectData 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipVerifyHash C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPVerifyIndirectData 1629F04E-2799-4DB5-8FE5-ACE10F17EBAB,wshext.dll,VerifyIndirectData DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPVerifyIndirectData 5598CFF1-68DB-4340-B57F-1CACF88C9A51,AppxSip.dll,P7xSipVerifyIndirectData DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPVerifyIndirectData C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.dll,CryptSIPVerifyIndirectData BA08A66F-113B-4D58-9329-A1B37AF30F0E,XapAuthenticodeSip.dll,XAP_CryptSIPVerifyIndirectData CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPVerifyIndirectData 9FA65764-C36F-4319-9737-658A34585BB7,mso.dll,MsoVBADigSigVerifyIndirectData
CryptSIPDllGetCaps:C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps 9F3053C5-439D-4BF7-8A77-04F0450A1D9F,EsdSip.dll,EsdSipGetCaps C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetCaps CB034CC7-4A2D-8E07-48E7-F82436FFA03E,navsip.dll,NavSIPGetCaps
CryptSIPDllGetSealedDigest:C689AABA-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest 9BA61D3F-E73A-11D0-8CD2-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest C689AAB9-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest DE351A42-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest DE351A43-8E59-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest C689AAB8-8E78-11D0-8C47-00C04FC295EE,WINTRUST.DLL,CryptSIPGetSealedDigest
```

`BLUESPAWN-win-client/resources/TrustProviders`:

```
CertCheck:7801EBD0-CF4B-11D0-851F-0060979387EA,Cryptdlg.dll,CertTrustCertPolicy 00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubCheckCert D41E4F1D-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubCheckCert D41E4F1F-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubCheckCert C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubCheckCert F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,SoftpubCheckCert A7F4C378-21BE-494e-BA0F-BB12C5D208C5,WINTRUST.DLL,SoftpubCheckCert 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,SoftpubCheckCert 31D1ADC1-D329-11D1-8ED8-0080C76516C6,WINTRUST.DLL,SoftpubCheckCert 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubCheckCert 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubCheckCert FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,SoftpubCheckCert 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubCheckCert 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubCheckCert 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoSoftpubCheckCert
Certificate:7801EBD0-CF4B-11D0-851F-0060979387EA,WINTRUST.DLL,WintrustCertificateTrust 00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,WintrustCertificateTrust D41E4F1D-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,WintrustCertificateTrust D41E4F1F-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,WintrustCertificateTrust C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,WintrustCertificateTrust F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,WintrustCertificateTrust A7F4C378-21BE-494e-BA0F-BB12C5D208C5,WINTRUST.DLL,WintrustCertificateTrust 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,WintrustCertificateTrust 31D1ADC1-D329-11D1-8ED8-0080C76516C6,WINTRUST.DLL,WintrustCertificateTrust 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,WintrustCertificateTrust 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,HTTPSCertificateTrust FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,GenericChainCertificateTrust 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,WintrustCertificateTrust 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,WintrustCertificateTrust 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoWintrustCertificateTrust
Cleanup:7801EBD0-CF4B-11D0-851F-0060979387EA,Cryptdlg.dll,CertTrustCleanup 00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubCleanup C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubCleanup F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,DriverCleanupPolicy 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,DriverCleanupPolicy 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubCleanup 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubCleanup FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,SoftpubCleanup 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubCleanup 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubCleanup 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoSoftpubCleanupPolicy
FinalPolicy:7801EBD0-CF4B-11D0-851F-0060979387EA,Cryptdlg.dll,CertTrustFinalPolicy 00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubAuthenticode D41E4F1D-A407-11D1-8BC9-00C04FA30A41,urlmon.dll,CORPolicyProvider D41E4F1F-A407-11D1-8BC9-00C04FA30A41,ieframe.dll,CORLockDownProvider C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubAuthenticode F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,DriverFinalPolicy A7F4C378-21BE-494e-BA0F-BB12C5D208C5,mscorsecimpl.dll,CORPolicyEE 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,ConfigCiFinalPolicy 31D1ADC1-D329-11D1-8ED8-0080C76516C6,mscorsec.dll,CORPolicyEE 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubAuthenticode 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,HTTPSFinalProv FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,GenericChainFinalProv 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubAuthenticode 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubAuthenticode 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoWintrustFinalPolicy
Initialization:7801EBD0-CF4B-11D0-851F-0060979387EA,Cryptdlg.dll,CertTrustInit 00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubInitialize D41E4F1D-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubInitialize D41E4F1F-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubInitialize C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubInitialize F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,DriverInitializePolicy A7F4C378-21BE-494e-BA0F-BB12C5D208C5,WINTRUST.DLL,SoftpubInitialize 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,DriverInitializePolicy 31D1ADC1-D329-11D1-8ED8-0080C76516C6,WINTRUST.DLL,SoftpubInitialize 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubInitialize 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubInitialize FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,SoftpubInitialize 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubDefCertInit 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubInitialize 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoSoftpubInitialize
Message:00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubLoadMessage D41E4F1D-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubLoadMessage D41E4F1F-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubLoadMessage C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubLoadMessage F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,SoftpubLoadMessage A7F4C378-21BE-494e-BA0F-BB12C5D208C5,WINTRUST.DLL,SoftpubLoadMessage 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,SoftpubLoadMessage 31D1ADC1-D329-11D1-8ED8-0080C76516C6,WINTRUST.DLL,SoftpubLoadMessage 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubLoadMessage 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubLoadMessage FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,SoftpubLoadMessage 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubLoadMessage 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubLoadMessage 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoSoftpubLoadMessage
Signature:00AAC56B-CD44-11D0-8CC2-00C04FC295EE,WINTRUST.DLL,SoftpubLoadSignature D41E4F1D-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubLoadSignature D41E4F1F-A407-11D1-8BC9-00C04FA30A41,WINTRUST.DLL,SoftpubLoadSignature C6B2E8D0-E005-11CF-A134-00C04FD7BF43,WINTRUST.DLL,SoftpubLoadSignature F750E6C3-38EE-11D1-85E5-00C04FC295EE,WINTRUST.DLL,SoftpubLoadSignature A7F4C378-21BE-494e-BA0F-BB12C5D208C5,WINTRUST.DLL,SoftpubLoadSignature 6078065b-8f22-4b13-bd9b-5b762776f386,WINTRUST.DLL,SoftpubLoadSignature 31D1ADC1-D329-11D1-8ED8-0080C76516C6,WINTRUST.DLL,SoftpubLoadSignature 573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubLoadSignature 573E31F8-AABA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubLoadSignature FC451C16-AC75-11D1-B4B8-00C04FB66EA0,WINTRUST.DLL,SoftpubLoadSignature 189A3842-3041-11D1-85E1-00C04FC295EE,WINTRUST.DLL,SoftpubLoadSignature 64B9D180-8DA2-11CF-8736-00AA00A485EB,WINTRUST.DLL,SoftpubLoadSignature 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoSoftpubLoadSignature
DiagnosticPolicy:573E31F8-DDBA-11D0-8CCB-00C04FC295EE,WINTRUST.DLL,SoftpubDumpStructure 4ECC1CC8-31B7-45CE-B4B9-2DD45C2FF958,mso.dll,MsoWintrustTestPolicy
```

`BLUESPAWN-win-client/resources/bluespawn-original/kernel32_kernelbase_ror13.yar`:

```yar
rule kernel32_kernelbase_dll_ror13 {
	meta:
		description = "Detects ROR13 encoded hashes for kernel32/kernelbase functions"
		license = "BSD-3"
		author = "Jake Smith"
		date = "2020-03-26"

	strings:
		$dllname_kernel32_ror13_upper = { 5B BC 4A 6A }
		$dllname_kernel32_ror13_lower = { 6F FD 5A BF }
		$dllname_kernelbase_ror13_upper = { E3 BA EF 2D }
		$dllname_kernelbase_ror13_lower = { 38 FC 40 83 }
		
		$kernel32_ror13_function_CallNamedPipeA = { 3F A0 1B 5A }
		$kernel32_ror13_function_CallNamedPipeW = { 55 A0 1B 5A }
		$kernel32_ror13_function_CheckElevation = { 03 97 5F 14 }
		$kernel32_ror13_function_CheckElevationEnabled = { FE 0B 35 54 }
		$kernel32_ror13_function_CheckRemoteDebuggerPresent = { 80 7D AF 43 }
		$kernel32_ror13_function_ConnectNamedPipe = { F9 C9 09 CB }
		$kernel32_ror13_function_CreateFile2 = { 96 17 00 7C }
		$kernel32_ror13_function_CreateFileA = { A5 17 00 7C }
		$kernel32_ror13_function_CreateFileW = { BB 17 00 7C }
		$kernel32_ror13_function_CreateNamedPipeA = { 46 68 2D 0B }
		$kernel32_ror13_function_CreateNamedPipeW = { 5C 68 2D 0B }
		$kernel32_ror13_function_CreatePipe = { 80 8F 0C 17 }
		$kernel32_ror13_function_CreateProcessA = { 72 FE B3 16 }
		$kernel32_ror13_function_CreateProcessAsUserA = { 8B C4 5D 63 }
		$kernel32_ror13_function_CreateProcessAsUserW = { A1 C4 5D 63 }
		$kernel32_ror13_function_CreateProcessInternalA = { 72 FA 4D DB }
		$kernel32_ror13_function_CreateProcessInternalW = { 88 FA 4D DB }
		$kernel32_ror13_function_CreateRemoteThread = { DD 9C BD 72 }
		$kernel32_ror13_function_CreateRemoteThreadEx = { D4 37 8F B1 }
		$kernel32_ror13_function_DeleteFileA = { 25 B0 FF C2 }
		$kernel32_ror13_function_DeleteFileW = { 3B B0 FF C2 }
		$kernel32_ror13_function_EnumerateLocalComputerNamesA = { 36 D2 15 9E }
		$kernel32_ror13_function_EnumerateLocalComputerNamesW = { 4C D2 15 9E }
		$kernel32_ror13_function_GetComputerNameA = { 8F 22 A4 96 }
		$kernel32_ror13_function_GetComputerNameExA = { 26 A5 C8 AC }
		$kernel32_ror13_function_GetComputerNameExW = { 3C A5 C8 AC }
		$kernel32_ror13_function_GetComputerNameW = { A5 22 A4 96 }
		$kernel32_ror13_function_GetCurrentProcess = { E6 17 8F 7B }
		$kernel32_ror13_function_GetCurrentProcessId = { 02 FA 0D E6 }
		$kernel32_ror13_function_GetModuleHandleA = { 04 49 32 D3 }
		$kernel32_ror13_function_GetModuleHandleExA = { 75 42 52 D0 }
		$kernel32_ror13_function_GetModuleHandleExW = { 8B 42 52 D0 }
		$kernel32_ror13_function_GetModuleHandleW = { 1A 49 32 D3 }
		$kernel32_ror13_function_GetProcAddress = { AA FC 0D 7C }
		$kernel32_ror13_function_GetProcAddress2 = { 49 F7 02 78 }
		$kernel32_ror13_function_LoadLibraryA = { 8E 4E 0E EC }
		$kernel32_ror13_function_LoadLibraryExA = { FC A4 53 07 }
		$kernel32_ror13_function_LoadLibraryExW = { 12 A5 53 07 }
		$kernel32_ror13_function_LoadLibraryW = { A4 4E 0E EC }
		$kernel32_ror13_function_LoadModule = { EC 79 F9 BB }
		$kernel32_ror13_function_ReadFile = { 16 65 FA 10 }
		$kernel32_ror13_function_ReadFileEx = { FC 45 C1 40 }
		$kernel32_ror13_function_RegCreateKeyExA = { B4 E6 64 8B }
		$kernel32_ror13_function_RegCreateKeyExW = { CA E6 64 8B }
		$kernel32_ror13_function_RegOpenKeyExA = { 81 EB 4A A8 }
		$kernel32_ror13_function_RegOpenKeyExW = { 97 EB 4A A8 }
		$kernel32_ror13_function_RegSetValueExA = { DD 9A 1C 2D }
		$kernel32_ror13_function_RegSetValueExW = { F3 9A 1C 2D }
		$kernel32_ror13_function_ReplaceFile = { 6C A0 ED 00 }
		$kernel32_ror13_function_ReplaceFileA = { AE 07 60 03 }
		$kernel32_ror13_function_ReplaceFileW = { C4 07 60 03 }
		$kernel32_ror13_function_TerminateProcess = { 83 B9 B5 78 }
		$kernel32_ror13_function_TerminateThread = { 89 6F 01 BD }
		$kernel32_ror13_function_VirtualAlloc = { 54 CA AF 91 }
		$kernel32_ror13_function_VirtualAlloc2 = { 58 A4 53 E5 }

	condition:
		(1 of ($dllname_kernel*)) and (2 of ($kernel32_ror13_function_*))
}
```

`BLUESPAWN-win-client/resources/indicators.yar`:

```yar
include "../external/yara-rules/capabilities/capabilities.yar"
include "../external/yara-rules/antidebug_antivm/antidebug_antivm.yar"

```

`BLUESPAWN-win-client/resources/mitigations.json`:

```json
{
	"mitigations": [
		{
			"name": "M1025 - Privileged Process Integrity",
			"description": "Protect processes with high privileges that can be used to interact with critical system components through use of protected process light, anti-process injection defenses, or other process integrity enforcement measures",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "registry-value-policy",
					"name": "Run LSA As PPL",
					"description": "Run the Local Security Authority as a Protected Process Lite, preventing process injection and other attacks on lsass.exe's memory",
					"enforcement-level": "moderate",
					"min-software-version": "6.3",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "RunAsPPL",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				}
			]
		},
		{
			"name": "M1028 - Operating System Configuration",
			"description": "Make configuration changes related to the operating system or a common feature of the operating system that result in system hardening against techniques.",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "registry-value-policy",
					"name": "V-17417",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. This setting enables the firewall when connected to a public network",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile",
					"value-name": "EnableFirewall",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17415",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. This setting enables the firewall when connected to the domain.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile",
					"value-name": "EnableFirewall",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17416",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. This setting enables the firewall when connected to a private network.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile",
					"value-name": "EnableFirewall",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17440",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. The display of notifications to the user when a program is blocked from receiving an inbound connection on a public network must be enabled to alert the user of potential issues.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile",
					"value-name": "DisableNotifications",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17420",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. The display of notifications to the user when a program is blocked from receiving an inbound connection in the domain must be enabled to alert the user of potential issues.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile",
					"value-name": "DisableNotifications",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17430",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. The display of notifications to the user when a program is blocked from receiving an inbound connection on a private network must be enabled to alert the user of potential issues.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile",
					"value-name": "DisableNotifications",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17438",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. Unsolicited inbound connections may be malicious attempts to gain access to a system. Unsolicited inbound connections, for which there is no rule allowing the connection, will be blocked on a public network",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile",
					"value-name": "DefaultInboundAction",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17418",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. Unsolicited inbound connections may be malicious attempts to gain access to a system. Unsolicited inbound connections, for which there is no rule allowing the connection, will be blocked in the domain.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile",
					"value-name": "DefaultInboundAction",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-17428",
					"description": "A firewall provides a line of defense against attack. To be effective, it must be enabled and properly configured. Unsolicited inbound connections may be malicious attempts to gain access to a system. Unsolicited inbound connections, for which there is no rule allowing the connection, will be blocked on a private network. ",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile",
					"value-name": "DefaultInboundAction",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-1093: Anonymous enumeration of shares must be restricted",
					"description": "This is a High finding because allowing anonymous logon users (null session connections) to list all account names and enumerate all shared resources can provide a map of potential points to attack the system.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "restrictanonymous",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-1153: The LanMan authentication level must be set to send NTLMv2 response only, and to refuse LM and NTLM",
					"description": "The Kerberos v5 authentication protocol is the default for authentication of users who are logging on to domain accounts. NTLM which is less secure, is retained in later Windows versions for compatibility with clients and servers that are running earlier versions of Windows or applications that still use it. It is also used to authenticate logons to stand-alone computers that are running later versions.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "LmCompatibilityLevel",
					"data-value": 5,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3338: Unauthorized named pipes are accessible with anonymous credentials",
					"description": "This is a High finding because of the potential for gaining unauthorized system access. Pipes are internal system communications processes. They are identified internally by ID numbers that vary between systems. To make access to these processes easier, these pipes are given names that do not vary between systems. This setting controls which of these pipes anonymous users may access.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters",
					"value-name": "NullSessionPipes",
					"data-value": [],
					"data-type": "REG_MULTI_SZ",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3340: Unauthorized shares can be accessed anonymously",
					"description": "This is a High finding finding because of the potential for gaining unauthorized system access. Any shares listed can be accessed by any network user. This could lead to the exposure or corruption of sensitive data.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters",
					"value-name": "NullSessionShares",
					"data-value": [],
					"data-type": "REG_MULTI_SZ",
					"registry-value-policy-type": "require-subset-of"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3344: Local accounts with blank passwords restricted to console logon only",
					"description": "This is a Category 1 finding because no accounts with blank passwords should exist on a system. The password policy should prevent this from occurring. However, if a local account with a blank password does exist, enabling this setting will limit the account to local console logon only.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "LimitBlankPasswordUse",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3376: The system must be configured to prevent the storage of passwords and credentials.",
					"description": " This setting controls the storage of passwords and credentials for network authentication on the local system. Such credentials must not be stored on the local machine, as that may lead to account compromise.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "DisableDomainCreds",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3379: The system is configured to store the LAN Manager hash of the password in the SAM",
					"description": "This setting controls whether or not a LAN Manager hash of the password is stored in the SAM the next time the password is changed. The LAN Manager hash uses a weak encryption algorithm and there are several tools available that use this hash to retrieve account passwords.",
					"enforcement-level": "low",
					"key-path": "HKLM\\System\\CurrentControlSet\\Control\\Lsa",
					"value-name": "NoLMHash",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-3479: The system will be configured to use Safe DLL Search Mode",
					"description": "The default search behavior, when an application calls a function in a Dynamic Link Library (DLL), is to search the current directory followed by the directories contained in the systems path environment variable. An unauthorized DLL inserted into an applications working directory could allow malicious code to be run on the system. Creating the following registry key and setting the appropriate value forces the system to search the %Systemroot% for the DLL before searching the current directory or the rest of the path",
					"enforcement-level": "low",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager",
					"value-name": "SafeDllSearchMode",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-63597: Apply UAC privileged token filtering for network logons",
					"description": "With User Account Control enabled, filtering the privileged token for built-in administrator accounts will prevent the elevated privileges of these accounts from being used over the network.",
					"enforcement-level": "low",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager",
					"value-name": "SafeDllSearchMode",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-63687: Caching of logon credentials must be limited",
					"description": "The default Windows configuration caches the last logon credentials for users who log on interactively to a system. This feature is provided for system availability reasons, such as the user's machine being disconnected from the network or domain controllers being unavailable. Even though the credential cache is well-protected, if a system is attacked, an unauthorized individual may isolate the password to a domain user account using a password-cracking program and gain access to the domain.",
					"enforcement-level": "low",
					"key-path": "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
					"value-name": "CachedLogonsCount",
					"data-value": 0,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-63817: User Account Control approval mode for the built-in Administrator must be enabled",
					"description": "User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, including administrative accounts, unless authorized. This setting configures the built-in Administrator account so that it runs in Admin Approval Mode.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
					"value-name": "FilterAdministratorToken",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-63825: User Account Control must be configured to detect application installations and prompt for elevation",
					"description": "User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, including administrative accounts, unless authorized. This setting requires Windows to respond to application installation requests by prompting for credentials.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
					"value-name": "EnableInstallerDetection",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-63829: User Account Control must run all administrators in Admin Approval Mode, enabling UAC",
					"description": "User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, including administrative accounts, unless authorized. This setting enables UAC.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
					"value-name": "EnableLUA",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-71769: Remote calls to the Security Account Manager (SAM) must be restricted to Administrators",
					"description": "The Windows Security Account Manager (SAM) stores users' passwords. Restricting remote rpc connections to the SAM to Administrators helps protect those credentials.",
					"enforcement-level": "low",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa",
					"value-name": "RestrictRemoteSAM",
					"data-value": "O:BAG:BAD:(A;;RC;;;BA)",
					"data-type": "REG_SZ",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-73585 - The Windows Installer Always install with elevated privileges option must be disabled",
					"description": "Standard user accounts must not be granted elevated privileges. Enabling Windows Installer to elevate privileges when installing applications can allow malicious persons and applications to gain full control of a system.",
					"enforcement-level": "low",
					"key-path": "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
					"value-name": "InstallAlwaysElevated",
					"data-value": 0,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				}
			]
		},
		{
			"name": "M1035 - Limit Access to Resource over Network",
			"description": "Prevent access to file shares, remote access to systems, unnecessary services. Mechanisms to limit access may include use of network concentrators, RDP gateways, etc",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "registry-value-policy",
					"name": "Nessus Plugin ID 58453",
					"description": "This is a High severity finding due to the Bluekeep vulnerability that allows for a worm to quickly move through a network when NLA is disabled. RDP is a service that allows remote access to Windows computers",
					"enforcement-level": "low",
					"min-software-version": "5.1.2600",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp",
					"value-name": "UserAuthentication",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				}
			]
		},
		{
			"name": "M1042 - Disable or Remove Feature or Program ",
			"description": "Remove or deny access to unnecessary and potentially vulnerable software to prevent abuse by adversaries.",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "registry-value-policy",
					"name": "Disable LLMNR",
					"description": "Link-Local Multicast Name Resolution (LLMNR) serve as alternate methods for host identification. Adversaries can spoof an authoritative source for name resolution on a victim network by responding to LLMNR (UDP 5355)/NBT-NS (UDP 137) traffic as if they know the identity of the requested host.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient",
					"value-name": "EnableMulticast",
					"data-value": 0,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "Disable NBT-NS",
					"description": "NetBIOS Name Service (NBT-NS) serve as alternate methods for host identification. Adversaries can spoof an authoritative source for name resolution on a victim network by responding to LLMNR (UDP 5355)/NBT-NS (UDP 137) traffic as if they know the identity of the requested host.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\*",
					"value-name": "NetbiosOptions",
					"data-value": 2,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "Disable WSH",
					"description": "Windows Script Host enables the execution of wscript and cscript which allow VB, JS, and other scripts to be run. This feature is not typically needed, and Sean Metcalf recommends disabling it https://adsecurity.org/?p=3299.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\Software\\Microsoft\\Windows Script Host\\Settings",
					"value-name": "Enabled",
					"data-value": 0,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-73519: The Server Message Block (SMB) v1 protocol must be disabled on the SMB server",
					"description": "SMBv1 is a legacy protocol that uses the MD5 algorithm as part of SMB. MD5 is known to be vulnerable to a number of attacks such as collision and preimage attacks as well as not being FIPS compliant. Disabling SMBv1 support may prevent access to file or print sharing resources with systems or devices that only support SMBv1. File shares and print services hosted on Windows Server 2003 are an example, however Windows Server 2003 is no longer a supported operating system. Some older network attached devices may only support SMBv1",
					"enforcement-level": "low",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
					"value-name": "SMB1",
					"data-value": 0,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "combined-policy",
					"name": "V-72753: WDigest Authentication must be disabled",
					"description": "When the WDigest Authentication protocol is enabled, plain text passwords are stored in the Local Security Authority Subsystem Service (LSASS) exposing them to theft. This setting will prevent WDigest from storing credentials in memory.",
					"enforcement-level": "low",
					"mode": "or",
					"subpolicies": [
						{
							"policy-type": "registry-value-policy",
							"name": "Set UseLogonCredential to 0",
							"enforcement-level": "low",
							"min-software-version": "6.3",
							"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest",
							"value-name": "UseLogonCredential",
							"data-value": 0,
							"data-type": "REG_DWORD",
							"registry-value-policy-type": "require-exact"
						},
						{
							"policy-type": "registry-value-policy",
							"name": "Remove WDigest",
							"enforcement-level": "low",
							"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa",
							"value-name": "Security Packages",
							"data-value": [ "wdigest" ],
							"data-type": "REG_MULTI_SZ",
							"registry-value-policy-type": "forbid-subset-of"
						}
					]
				}
			]
		},
		{
			"name": "M1047 - Audit",
			"description": "Configure the system to perform audits or scans of systems, permissions, insecure software, insecure configurations, etc. to identify potential weaknesses",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "combined-policy",
					"name": "Enable Sysmon Service",
					"description": "If the sysmon service is installed, ensure it is enabled.",
					"enforcement-level": "moderate",
					"mode": "or",
					"subpolicies": [
						{
							"policy-type": "registry-value-policy",
							"name": "Sysmon Service Enabled",
							"enforcement-level": "moderate",
							"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Sysmon",
							"value-name": "start",
							"data-value": 2,
							"data-type": "REG_DWORD",
							"registry-value-policy-type": "require-exact"
						},
						{
							"policy-type": "registry-value-policy",
							"name": "Sysmon64 Service Enabled",
							"enforcement-level": "moderate",
							"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Sysmon64",
							"value-name": "start",
							"data-value": 2,
							"data-type": "REG_DWORD",
							"registry-value-policy-type": "require-exact"
						},
						{
							"policy-type": "registry-subkey-policy",
							"name": "Sysmon not installed",
							"enforcement-level": "low",
							"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services",
							"subkey-policy-type": "blacklist",
							"subkey-names": [ "Sysmon", "Sysmon64" ]
						}
					]
				},
				{
					"policy-type": "registry-value-policy",
					"name": "EventLog Service Enabled",
					"description": "Enables the Windows Event Log Service",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SYSTEM\\CurrentControlSet\\Services\\EventLog",
					"value-name": "start",
					"data-value": 2,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "V-73511: Command line data must be included in process creation events",
					"description": "Maintaining an audit trail of system activity logs can help identify configuration errors, troubleshoot service disruptions, and analyze compromises that have occurred, as well as detect attacks. Collecting this data is essential for analyzing the security of information assets and detecting signs of suspicious and unexpected behavior.",
					"enforcement-level": "moderate",
					"key-path": "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit",
					"value-name": "ProcessCreationIncludeCmdLine_Enabled",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "require-exact"
				},
				{
					"policy-type": "event-log",
					"name": "Enable Event Logs",
					"description": "Enable important event log channels",
					"enforcement-level": "low",
					"channels": [
						"Microsoft-Windows-CertificateServicesClient-Lifecycle-System/Operational",
						"Microsoft-Windows-Bits-Client/Operational",
						"Microsoft-Windows-AppLocker/EXE and DLL",
						"Microsoft-Windows-AppLocker/MSI and Script",
						"Security",
						"System",
						"Microsoft-Windows-Powershell/Operational",
						"Microsoft-Windows-TaskScheduler/Operational",
						"Microsoft-Windows-Windows Defender/Operational",
						"Microsoft-Windows-Windows Defender/Operational",
						"Microsoft-Windows-Windows Firewall With Advanced Security/Firewall"
					]
				}
			]
		},
		{
			"name": "M1054 - Software Configuration",
			"description": "Implement configuration changes to software (other than the operating system) to mitigate security risks associated to how the software operates",
			"software": "Windows",
			"policies": [
				{
					"policy-type": "registry-value-policy",
					"name": "Antispyware Notifications",
					"enforcement-level": "low",
					"key-path": "HKLM\\Software\\Microsoft\\Security Center",
					"value-name": "AntiSpyWareDisableNotify",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "Antivirus Notifications",
					"enforcement-level": "low",
					"key-path": "HKLM\\Software\\Microsoft\\Security Center",
					"value-name": "AntiVirusDisableNotify",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "UAC Notifications",
					"enforcement-level": "low",
					"key-path": "HKLM\\Software\\Microsoft\\Security Center",
					"value-name": "UacDisableNotify",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				},
				{
					"policy-type": "registry-value-policy",
					"name": "Firewall Notifications",
					"enforcement-level": "low",
					"key-path": "HKLM\\Software\\Microsoft\\Security Center",
					"value-name": "FirewallDisableNotify",
					"data-value": 1,
					"data-type": "REG_DWORD",
					"registry-value-policy-type": "forbid-exact"
				}
			]
		}
	]
}
```

`BLUESPAWN-win-client/resources/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by BLUESPAWN-client.rc
//
#define YaraSevere                      6
#define YaraSevere2                     7
#define YaraIndicators                  8
#define GoodSIP                         9
#define GoodTrustProviders              10
#define DefaultMitigations              11
#define IDR_YARARULE2                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`BLUESPAWN-win-client/resources/severe.yar`:

```yar
include "bluespawn-original/kernel32_kernelbase_ror13.yar"

/* https://github.com/nsacyber/Mitigating-Web-Shells */
include "third-party-integration/extended.webshell_detection.yara"

/* https://github.com/gentilkiwi/mimikatz */
include "third-party-integration/kiwi_passwords.yar"

/* https://github.com/mikesxrs/Open-Source-YARA-rules/blob/7fe5d74f508d4781737f300557c2ead9b6f2c0c9/adamburt/win_metasploit_related.yara */
include "third-party-integration/win_metasploit_related.yara"

/* https://github.com/stvemillertime/ConventionEngine/blob/master/ConventionEngine.yar */
include "third-party-integration/ConventionEngine.yar"


/* Yara-Rules Project */
include "../external/yara-rules/cve_rules/CVE-2015-1701.yar"
include "../external/yara-rules/cve_rules/CVE-2015-2426.yar"
include "../external/yara-rules/exploit_kits/EK_Angler.yar"
include "../external/yara-rules/exploit_kits/EK_Blackhole.yar"
include "../external/yara-rules/exploit_kits/EK_BleedingLife.yar"
include "../external/yara-rules/exploit_kits/EK_Crimepack.yar"
include "../external/yara-rules/exploit_kits/EK_Eleonore.yar"
include "../external/yara-rules/exploit_kits/EK_Fragus.yar"
include "../external/yara-rules/exploit_kits/EK_Phoenix.yar"
include "../external/yara-rules/exploit_kits/EK_Sakura.yar"
include "../external/yara-rules/exploit_kits/EK_ZeroAcces.yar"
include "../external/yara-rules/exploit_kits/EK_Zerox88.yar"
include "../external/yara-rules/exploit_kits/EK_Zeus.yar"
include "../external/yara-rules/malware/APT_APT3102.yar"
include "../external/yara-rules/malware/APT_Cobalt.yar"
include "../external/yara-rules/malware/APT_Equation.yar"
include "../external/yara-rules/malware/APT_FVEY_ShadowBrokers_Jan17_Screen_Strings.yar"
include "../external/yara-rules/malware/GEN_PowerShell.yar"
include "../external/yara-rules/malware/RANSOM_DoublePulsar_Petya.yar"
include "../external/yara-rules/malware/RAT_Meterpreter_Reverse_Tcp.yar"
include "../external/yara-rules/malware/TOOLKIT_Chinese_Hacktools.yar"
include "../external/yara-rules/malware/TOOLKIT_Gen_powerkatz.yar"
include "../external/yara-rules/malware/TOOLKIT_PassTheHash.yar"
include "../external/yara-rules/malware/TOOLKIT_Powerstager.yar"
include "../external/yara-rules/malware/TOOLKIT_exe2hex_payload.yar"
include "../external/yara-rules/packers/packer.yar"

```

`BLUESPAWN-win-client/resources/severe2.yar`:

```yar
/* 

NON-COMMERCIAL

Files under here are licensed under CC BY-NC 4.0 (Non-Commercial): https://creativecommons.org/licenses/by-nc/4.0/
Please remove the below lines and recompile the project to use in a commercial setting.

*/


include "../external/signature-base/yara/apt_cobaltstrike.yar"
include "../external/signature-base/yara/apt_cobaltstrike_evasive.yar"
include "../external/signature-base/yara/crime_emotet.yar"
include "../external/signature-base/yara/exploit_cve_2014_4076.yar"
include "../external/signature-base/yara/exploit_cve_2015_1674.yar"
include "../external/signature-base/yara/exploit_uac_elevators.yar"
include "../external/signature-base/yara/gen_armitage.yar"
include "../external/signature-base/yara/gen_case_anomalies.yar"
include "../external/signature-base/yara/gen_cert_payloads.yar"
include "../external/signature-base/yara/gen_chaos_payload.yar"
include "../external/signature-base/yara/gen_cmd_script_obfuscated.yar"
include "../external/signature-base/yara/gen_empire.yar"
include "../external/signature-base/yara/gen_enigma_protector.yar"
include "../external/signature-base/yara/gen_google_anomaly.yar"
include "../external/signature-base/yara/gen_hta_anomalies.yar"
include "../external/signature-base/yara/gen_impacket_tools.yar"
include "../external/signature-base/yara/gen_invoke_mimikatz.yar"
include "../external/signature-base/yara/gen_invoke_psimage.yar"
include "../external/signature-base/yara/gen_invoke_thehash.yar"
include "../external/signature-base/yara/gen_kerberoast.yar"
include "../external/signature-base/yara/gen_loaders.yar"
include "../external/signature-base/yara/gen_macro_ShellExecute_action.yar"
include "../external/signature-base/yara/gen_mal_link.yar"
include "../external/signature-base/yara/gen_mal_scripts.yar"
include "../external/signature-base/yara/gen_merlin_agent.yar"
include "../external/signature-base/yara/gen_metasploit_loader_rsmudge.yar"
include "../external/signature-base/yara/gen_metasploit_payloads.yar"
include "../external/signature-base/yara/gen_mimikittenz.yar"
include "../external/signature-base/yara/gen_mimipenguin.yar"
include "../external/signature-base/yara/gen_nopowershell.yar"
include "../external/signature-base/yara/gen_p0wnshell.yar"
include "../external/signature-base/yara/gen_powerkatz.yar"
include "../external/signature-base/yara/gen_powershdll.yar"
include "../external/signature-base/yara/gen_powershell_empire.yar"
include "../external/signature-base/yara/gen_powershell_invocation.yar"
include "../external/signature-base/yara/gen_powershell_obfuscation.yar"
include "../external/signature-base/yara/gen_powershell_suite.yar"
include "../external/signature-base/yara/gen_powershell_susp.yar"
include "../external/signature-base/yara/gen_powershell_toolkit.yar"
include "../external/signature-base/yara/gen_powersploit_dropper.yar"
include "../external/signature-base/yara/gen_ps_empire_eval.yar"
include "../external/signature-base/yara/gen_ps_osiris.yar"
include "../external/signature-base/yara/gen_ps1_shellcode.yar"
include "../external/signature-base/yara/gen_rottenpotato.yar"
include "../external/signature-base/yara/gen_shikataganai.yar"
include "../external/signature-base/yara/gen_susp_lnk.yar"
include "../external/signature-base/yara/gen_susp_lnk_files.yar"
include "../external/signature-base/yara/gen_susp_obfuscation.yar"
include "../external/signature-base/yara/gen_susp_xor.yar"
include "../external/signature-base/yara/gen_sysinternals_anomaly.yar"
include "../external/signature-base/yara/gen_unicorn_obfuscated_powershell.yar"
include "../external/signature-base/yara/gen_url_persitence.yar"
include "../external/signature-base/yara/gen_winpayloads.yar"
include "../external/signature-base/yara/gen_wmi_implant.yar"
include "../external/signature-base/yara/gen_xor_hunting.yar"
include "../external/signature-base/yara/generic_dumps.yar"
include "../external/signature-base/yara/generic_exe2hex_payload.yar"
include "../external/signature-base/yara/thor-webshells.yar"
include "../external/signature-base/vendor/yara/airbnb_binaryalert.yar"




/* Excluded due to syntax errors:

general_cloaking.yar
generic_anomalies.yar
thor_inverse_matches.yar
yara_mixed_ext_vars.yar

*/

```

`BLUESPAWN-win-client/resources/third-party-integration/ConventionEngine.yar`:

```yar
// Rule appendix for the Definitive Dossier of Devilish Debug Details
// Blog link: https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html
// For more info, bother @stvemillertime or the #AdvancedPractices team on Twitter
// Updated on 2019-08-30, initial performance improvements by Florian Roth (@cyb3rops)
import "pe"
// used only in ConventionEngine_Anomaly_OutsideOfDebug
rule ConventionEngine_Keyword_Obfuscat
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "6724cef5a9a670d68e8ec00b6614997c"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}obfuscat[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Hook
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "92156ddfa4c1ec330ffd24ccef127a7a"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}hook[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Evil
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "9359b24a96df49972eda1750a35802de"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}evil[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Inject
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "081686496db01e44871f4e4a09e35fed"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}inject[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Trojan
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "060b2135d69fb33e8fc1c4d2bf7e2899"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}trojan[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Hide
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "dd8af240a7a4a81b5f80250b44a778c4"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}hide[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Anti
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "d350ae5dc15bcc18fde382b84f4bb3d0"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}anti[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Payload
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "10c534cacf65b604c1c2a30341bd2394"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}payload[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Keylog
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "1d7fd704fe4e41feff9e3a005ed868d6"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}keylog[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Bypass
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "00b8356235e510be95e367a25418b5cc"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}bypass[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Beacon
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "798afd5f648774c3133ea5e087efc2c1"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}beacon[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_UAC
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "2e62974fbce2fc1bbde763b986ad7b77"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}uac[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Svchost
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "c1206ba56f7f0c2698adcb3280f345be"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}svchost[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Svhost
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "8edf49fd8421edc7f58997bb16961cf4"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}svhost[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Dropper
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "4847f692942358aff51b72ffcb3e40ac"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}dropper[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Attack
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "d6b1989d9c271b8575326e4fca159ae8"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}attack[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Encrypt
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "65746ec8d8488066a129821c27fcbfb3"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}encrypt[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Exploit
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "4215d029dd26c29ce3e0cab530979b19"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}exploit[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Ransom
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "363bfef1781c107a08f46267f7676579"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}ransom[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Spy
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "15db41840f77723aa7e43460d9d3a5cc"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}spy[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Horse
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "1aa4a05fa321676b9934cd3aa54a5f95"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}horse[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_CVE
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "89dd326a64fdd77b467d2db1cc15e8ef"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}cve[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_shellcode
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "2cd7bc18377abb2464f55453e5bfab20"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}shellcode[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Fake
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "124c475d67aa8391f5220efcc64ca5b3"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}fake[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Backdoor
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0017c2bfa513960f9ea4fee46382959b"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}backdoor[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_BDoor
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "ba08b593250c3ca5c13f56e2ca97d85e"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}(bkdoor|bckdoor|backdr)[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Zombie
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "05ce6c5b7e14c34d4e6189dc19675c98"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}zombie[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Rootkit
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "8d4c375e452c688b413882365437435b"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}rootkit[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Fuck
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "bce1069dd099f15170c5fd05bae921b5"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}fuck[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_LoadDLL
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "e03f94cf5e3b1df208967a87df13ccb5"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}loaddll[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Reflect
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "d4990a8d2ff6f2433acdad04521f85c6"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}reflect[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Sleep
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0ce134d66531d2070b2c7db1ffb0dc6f"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}sleep[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Sploit
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0637c45bdefaa93d26124c1f3899443a"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}sploit[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Reverse
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "fccb98a9a510cdcf7c730eba548729de"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}reverse[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Socket
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "9c836dcd5251c4c9272b408b486e65db"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}socket[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_PowerShell
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "33700535591774417e3282f7b40ae8ad"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}PowerShell[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Infect
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "fdfea54231be21760b722d5cef32da2a"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}infect[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Worm
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "fdfea54231be21760b722d5cef32da2a"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}worm[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Katz
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0512c5a8807e4fdeb662e61d81cd1645"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}katz[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Mimi
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "a2bcbcc1465be96fbb957b14f29d1ea4"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}mimi[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Droper
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "5410ab108cd251a2db724db762d6606c"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}droper[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_0day
{
 meta:
 author = "@a_tweeter_user"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "e8df15f480b7044cf44faff4273dba8f"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}0day[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Penetration
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "5f7796346d22ec5bd8c7b5a2e6caca3c"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}penetration[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Wiper
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "3b740cca401715985f3a0c28f851b60e"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}wiper[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Bootkit
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "b427a55b62d7f00c532d695c9b04b4d2"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}bootkit[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Bot
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "df1e54a3832aff3e714fa2c122aa7ea9"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}(bot_|_bot| bot|bot |bot\\|-bot|bot-|\\bot)[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Csrss
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "72e743f7752367b461c42561021eb30d"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}csrss[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Flood
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "17a8d440545859444491f2feca7c129f"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}flood[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Overflow
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}overflow[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Kali
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "2cc23a6d971a8dc2093b73f72c2380b4"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}kali[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Malware
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "198ee041e8f3eb12a19bc321f86ccb88"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}malware[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Miner
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0409644ae4d1afb21c53339e244b5cc8"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}miner[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Xmrig
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "433f936511c2302342f175ad020e34f1"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}xmrig[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_LOL
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "05486e8707ae94befde0bafd9bee5429"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}lol[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_FUD
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "07c281acbe2eeb479a73580560cec0b8"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}fud[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Install
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "74494aff87db1ef5843cbf8c4d40cab1"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}install[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Steal
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "f3f47f3986e9c55d36c49beefa627b54"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}steal[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Launch
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}launch[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Downloader
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "8c843aa6ded2f2cb4a78a8b4534ac063"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}downloader[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Hack
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "afe58fee2460947291e93bad9fb095ce"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}hack[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Kill
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "6d250a11f68b1fd4ed0505fb2965b6f7"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}kill[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Implant
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "40451f20371329b992fb1b85c754d062"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}implant[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and filesize < 3MB
}
rule ConventionEngine_Keyword_RAT
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "18244062e6169b79f68d9b413cfd2c04"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}(\\rat|rat\\|\srat|\-rat|rat\.|rat\s)[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 $this = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}administrator[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and not $this
}
rule ConventionEngine_Keyword_Shell
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "32a16eff23f6c35e22b0b7d041728f62"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}shell[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 $this = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}(shellcode|powershell)[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and not $this
}
rule ConventionEngine_Keyword_Admin
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "67fff57bb44d3458b17f0c7a7a45f405"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}Admin[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 $this = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}administrator[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and not $this
}
rule ConventionEngine_Keyword_Proxy
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "7486404888b3223ef171a310426b2387"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}proxy[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Virus
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "5a537470e936dbb9611f95fb7f136a6e"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}virus[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Bind
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "0a2d51b0e58e41407f1a08744f1443b0"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}bind[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_1337
{
 meta:
 author = "@itsreallynick"
 description = "Searching for PE files with PDB path keywords, terms or anomalies. -YOUR BOY CARR"
 sample_md5 = "e9ecca14f19fe192fc48e714a649cadd"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]?:?\\[\\\s|*\s]?.{0,250}\\[l1]33[7t][\\\s|*\s]?.{0,250}\.pdb\x00/ nocase
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Thinstall
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "2ef545036c95aab395f3f2a3a0d38a9f"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}thinstall[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Keyword_Driver
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "24a6ec8ebf9c0867ed1c097f4a653b8d"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}driver[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and filesize < 3MB
}
rule ConventionEngine_Keyword_Client
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "24a6ec8ebf9c0867ed1c097f4a653b8d"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}client[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and filesize < 3MB
}
rule ConventionEngine_Keyword_Server
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "24a6ec8ebf9c0867ed1c097f4a653b8d"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}server[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and filesize < 3MB
}
rule ConventionEngine_Term_GoogleDrive
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}(Google Drive|Google \xd0\xb4\xd0\xb8\xd1\x81\xd0\xba|Google \xe4\xba\x91\xe7\xab\xaf\xe7\xa1\xac\xe7\x9b\x98)[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Windows
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "25b965b0f56a7dc8a0e2aa7e72778497"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\Windows\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Documents
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "e766b979aecfc603b561b19e3880a7bc"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\\Documents[\x00-\xFF]{0,200}\.pdb\x00/
 $this = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\\Documents and Settings[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and not $this
}
rule ConventionEngine_Term_DocumentsAndSettings
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "e766b979aecfc603b561b19e3880a7bc"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\\Documents and Settings[\x00-\xFF]{0,200}\.pdb\x00/
 $this = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\\Documents\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and not $this
}
rule ConventionEngine_Term_Dropbox
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "5d6bfa1a1add10dbd6745ddf915812ed"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}dropbox[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_OneDrive
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}OneDrive[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_ConsoleApplication
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "4840ee7971322e1a6da801643432b25f"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}overflow[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_WindowsApplication
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "f097c1b0c8fe178de14717a4fc8f2a91"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}WindowsApplication[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_WindowsFormsApplication
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "b51c35d5606c173961b2aa4e6867b40a"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}WindowsFormsApplication[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_NewFolder
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "fe23fa6df4d8fb500859f0f76e92552d"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}New Folder[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Copy
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "6156214b767254d5282bc7feef950dca"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}- Copy[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Desktop
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "71cdba3859ca8bd03c1e996a790c04f9"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}Desktop[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Users
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "09e4e6fa85b802c46bc121fcaecc5666"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}Users[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_Users_X
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "09e4e6fa85b802c46bc121fcaecc5666"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}\/Users\/[\x00-\xFF]{0,500}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_VisualStudio
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}Visual Studio[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Term_VmwareHost
{
 meta:
 author = "@itsreallynick"
 description = "Searching for PE files with PDB path keywords, terms, or anomalies. -YOUR BOY CARR"
 sample_md5 = "2742750991eb6687440ef53a7a93df94"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}\\\\vmware-host\\[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_Slash
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "09e4e6fa85b802c46bc121fcaecc5666"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}\/[\x00-\xFF]{0,500}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_NonAscii
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "07b62497e41898c22e5d5351607aac8e"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}[^\x00-\x7F]{1,}[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and filesize < 1MB
}
rule ConventionEngine_Anomaly_DriveShare
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "e7414d82d69b902b5bc1efd0f3e201d7"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}\\.{0,50}\\[a-zA-Z]\$\\[\x00-\xFF]{0,200}\.pdb\x00/ nocase
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_MultiPDB_Double
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "013f3bde3f1022b6cf3f2e541d19353c"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre == 2
}
rule ConventionEngine_Anomaly_MultiPDB_Triple
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "013f3bde3f1022b6cf3f2e541d19353c"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre == 3
}
rule ConventionEngine_Anomaly_MultiPDB_Quadruple
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "063915c2ac8dcba0c283407ff91e48e1"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre == 4
}
rule ConventionEngine_Anomaly_MultiPDB_Quintuple_Plus
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "08faf27c5738b34186613b4c98905690"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre >= 5
}
rule ConventionEngine_Anomaly_Short_SingleChar
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "26f7394147f00ef7c3146ddcafb8f161"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[\x00-\xFF]{1}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_Short_DoubleChar
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[\x00-\xFF]{2}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_Short_TripleChar
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[\x00-\xFF]{3}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_NulledOut
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "94218fba95e3f03796dd005a2851b5af"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x01-\xFF]{16}[\x01-\xFF]{1}\x00\x00\x00[\x00]{10,500}/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}
rule ConventionEngine_Anomaly_NulledOut_DoublePlus
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "bf0fea133818387cca7eaef5a52c0aed"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x01-\xFF]{16}[\x01-\xFF]{1}\x00\x00\x00[\x00]{10,500}/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre >= 2
}
rule ConventionEngine_Anomaly_OutsideOfDebug
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "bf0fea133818387cca7eaef5a52c0aed"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,500}\.pdb\x00/
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre and pe.data_directories[pe.IMAGE_DIRECTORY_ENTRY_DEBUG].virtual_address == 0
}
rule ConventionEngine_Term_Users_User
{
 meta:
 author = "@stvemillertime"
 description = "Searching for PE files with PDB path keywords, terms or anomalies."
 sample_md5 = "b7c3039203278bc289fd3756571bd468"
 ref_blog = "https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html"
 strings:
 $pcre = /RSDS[\x00-\xFF]{20}[a-zA-Z]:\\[\x00-\xFF]{0,200}Users\\user[\x00-\xFF]{0,200}\.pdb\x00/ nocase ascii
 condition:
 (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre
}

```

`BLUESPAWN-win-client/resources/third-party-integration/core.webshell_detection.yara`:

```yara
/*
    WARNING: Host-based security systems may DETECT this file as malicious!
    Because the text used in these signatures is also used in some malware definitions, this file may be detected as malicious. If this happens, it is recommended that the limited.yara.bin file be used instead. Because limited.yara.bin is a compiled yara ruleset, it is unlikely to trigger host-based security systems
*/

private rule b374k
{
    meta:
        author = "Blair Gillam (@blairgillam)"

    strings:
        $string = "b374k"
        $password_var = "$s_pass"
        $default_password = "0de664ecd2be02cdd54234a0d1229b43"

    condition:
        any of them
}

private rule pas_tool
{
    meta:
        author = "US CERT"

    strings:
        $php = "<?php"
        $base64decode = /\='base'\.\(\d+\*\d+\)\.'_de'\.'code'/ 
        $strreplace = "(str_replace("
        $md5 = ".substr(md5(strrev("
        $gzinflate = "gzinflate"
        $cookie = "_COOKIE"
        $isset = "isset"

    condition:
        (filesize > 20KB and filesize < 22KB) and
        #cookie == 2 and
        #isset == 3 and
        all of them
}

private rule pbot
{
    meta:
        author = "Jacob Baines (Tenable)"

    strings:
        $ = "class pBot" ascii
        $ = "function start(" ascii
        $ = "PING" ascii
        $ = "PONG" ascii

    condition:
        all of them
}

private rule passwordProtection
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $md5 = /md5\s*\(\s*\$_(GET|REQUEST|POST|COOKIE|SERVER)[^)]+\)\s*===?\s*['"][0-9a-f]{32}['"]/ nocase
        $sha1 = /sha1\s*\(\s*\$_(GET|REQUEST|POST|COOKIE|SERVER)[^)]+\)\s*===?\s*['"][0-9a-f]{40}['"]/ nocase
    condition:
        (any of them) 
}

private rule generic_jsp
{
    meta:
        source = "https://www.tenable.com/blog/hunting-for-web-shells"

    strings:
        $ = /Runtime.getRuntime\(\).exec\(request.getParameter\(\"[a-zA-Z0-9]+\"\)\);/ ascii

    condition:
        all of them
}

private rule eval
{
    meta:
        source = "https://www.tenable.com/blog/hunting-for-web-shells"

    strings:
        $ = /eval[\( \t]+((base64_decode[\( \t]+)|(str_rot13[\( \t]+)|(gzinflate[\( \t]+)|(gzuncompress[\( \t]+)|(strrev[\( \t]+)|(gzdecode[\( \t]+))+/

    condition:
        all of them
}

private rule fopo
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /\$[a-zA-Z0-9]+=\"\\(142|x62)\\(141|x61)\\(163|x73)\\(145|x65)\\(66|x36)\\(64|x34)\\(137|x5f)\\(144|x64)\\(145|x65)\\(143|x63)\\(157|x6f)\\(144|x64)\\(145|x65)\";@eval\(/

    condition:
        all of them
}

private rule hardcoded_urldecode
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /urldecode[\t ]*\([\t ]*'(%[0-9a-fA-F][0-9a-fA-F])+'[\t ]*\)/

    condition:
        all of them
}

private rule chr_obfuscation
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /\$[^=]+=[\t ]*(chr\([0-9]+\)\.?){2,}/

    condition:
        all of them
}

private rule phpInImage
{
    meta:
        source = "Vlad https://github.com/vlad-s"

    strings:
        $php_tag = "<?php"
        $gif = {47 49 46 38 ?? 61} // GIF8[version]a
        $jfif = { ff d8 ff e? 00 10 4a 46 49 46 }
        $png = { 89 50 4e 47 0d 0a 1a 0a }
        $jpeg = {FF D8 FF E0 ?? ?? 4A 46 49 46 } 

    condition:
        (($gif at 0) or ($jfif at 0) or ($png at 0) or ($jpeg at 0)) and $php_tag
}

rule hiddenFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Hidden functionality allows malware to masquerade as another filetype"

    condition:
        phpInImage
}

rule webshellArtifact 
{
    meta:
        author = "NSA Cybersecurity"
        description = "Artifacts common to web shells and rare in benign files"

    condition:
        b374k or pas_tool or pbot or generic_jsp
}

rule suspiciousFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Artifacts common to web shells and somewhat rare in benign files"

    condition:
        passwordProtection or hardcoded_urldecode or fopo or eval
}

rule obfuscatedFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Obfuscation sometimes hides malicious functionality"

    condition:
        chr_obfuscation
}

```

`BLUESPAWN-win-client/resources/third-party-integration/extended.webshell_detection.yara`:

```yara
/*
    WARNING: Host-based security systems may DETECT this file as malicious!
    Because the text used in these signatures is also used in some malware definitions, this file may be detected as malicious. If this happens, it is recommended that the limited.yara.bin file be used instead. Because limited.yara.bin is a compiled yara ruleset, it is unlikely to trigger host-based security systems

    ADDITIONAL WARNING: These extended rules are EXPECTED to have some false positives. These rules rely on detecting suspicious indicators that are often present in web shell malware but may also occur within benign files. 
*/


private rule b374k
{
    meta:
        author = "Blair Gillam (@blairgillam)"

    strings:
        $string = "b374k"
        $password_var = "$s_pass"
        $default_password = "0de664ecd2be02cdd54234a0d1229b43"

    condition:
        any of them
}

private rule pas_tool
{
    meta:
        author = "US CERT"

    strings:
        $php = "<?php"
        $base64decode = /\='base'\.\(\d+\*\d+\)\.'_de'\.'code'/ 
        $strreplace = "(str_replace("
        $md5 = ".substr(md5(strrev("
        $gzinflate = "gzinflate"
        $cookie = "_COOKIE"
        $isset = "isset"

    condition:
        (filesize > 20KB and filesize < 22KB) and
        #cookie == 2 and
        #isset == 3 and
        all of them
}

private rule pbot
{
    meta:
        author = "Jacob Baines (Tenable)"

    strings:
        $ = "class pBot" ascii
        $ = "function start(" ascii
        $ = "PING" ascii
        $ = "PONG" ascii

    condition:
        all of them
}

private rule passwordProtection
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $md5 = /md5\s*\(\s*\$_(GET|REQUEST|POST|COOKIE|SERVER)[^)]+\)\s*===?\s*['"][0-9a-f]{32}['"]/ nocase
        $sha1 = /sha1\s*\(\s*\$_(GET|REQUEST|POST|COOKIE|SERVER)[^)]+\)\s*===?\s*['"][0-9a-f]{40}['"]/ nocase
    condition:
        (any of them) 
}

private rule ObfuscatedPhp
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $eval = /(<\?php|[;{}])[ \t]*@?(eval|preg_replace|system|assert|passthru|(pcntl_)?exec|shell_exec|call_user_func(_array)?)\s*\(/ nocase  // ;eval( <- this is dodgy
        $eval_comment = /(eval|preg_replace|system|assert|passthru|(pcntl_)?exec|shell_exec|call_user_func(_array)?)\/\*[^\*]*\*\/\(/ nocase  // eval/*lol*/( <- this is dodgy
        $b374k = "'ev'.'al'"
        $align = /(\$\w+=[^;]*)*;\$\w+=@?\$\w+\(/  //b374k
        $weevely3 = /\$\w=\$[a-zA-Z]\('',\$\w\);\$\w\(\);/  // weevely3 launcher
        $c99_launcher = /;\$\w+\(\$\w+(,\s?\$\w+)+\);/  // http://bartblaze.blogspot.fr/2015/03/c99shell-not-dead.html
        $nano = /\$[a-z0-9-_]+\[[^]]+\]\(/ //https://github.com/UltimateHackers/nano
        $ninja = /base64_decode[^;]+getallheaders/ //https://github.com/UltimateHackers/nano
        $variable_variable = /\${\$[0-9a-zA-z]+}/
        $too_many_chr = /(chr\([\d]+\)\.){8}/  // concatenation of more than eight `chr()`
        $concat = /(\$[^\n\r]+\.){5}/  // concatenation of more than 5 words
        $concat_with_spaces = /(\$[^\n\r]+\. ){5}/  // concatenation of more than 5 words, with spaces
        $var_as_func = /\$_(GET|POST|COOKIE|REQUEST|SERVER)\s*\[[^\]]+\]\s*\(/
        $comment = /\/\*([^*]|\*[^\/])*\*\/\s*\(/  // eval /* comment */ (php_code)
condition:
        (any of them)
}

private rule DodgyPhp
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $basedir_bypass = /curl_init\s*\(\s*["']file:\/\// nocase
        $basedir_bypass2 = "file:file:///" // https://www.intelligentexploit.com/view-details.html?id=8719
        $disable_magic_quotes = /set_magic_quotes_runtime\s*\(\s*0/ nocase

        $execution = /\b(eval|assert|passthru|exec|include|system|pcntl_exec|shell_exec|base64_decode|`|array_map|ob_start|call_user_func(_array)?)\s*\(\s*(base64_decode|php:\/\/input|str_rot13|gz(inflate|uncompress)|getenv|pack|\\?\$_(GET|REQUEST|POST|COOKIE|SERVER))/ nocase  // function that takes a callback as 1st parameter
        $execution2 = /\b(array_filter|array_reduce|array_walk(_recursive)?|array_walk|assert_options|uasort|uksort|usort|preg_replace_callback|iterator_apply)\s*\(\s*[^,]+,\s*(base64_decode|php:\/\/input|str_rot13|gz(inflate|uncompress)|getenv|pack|\\?\$_(GET|REQUEST|POST|COOKIE|SERVER))/ nocase  // functions that takes a callback as 2nd parameter
        $execution3 = /\b(array_(diff|intersect)_u(key|assoc)|array_udiff)\s*\(\s*([^,]+\s*,?)+\s*(base64_decode|php:\/\/input|str_rot13|gz(inflate|uncompress)|getenv|pack|\\?\$_(GET|REQUEST|POST|COOKIE|SERVER))\s*\[[^]]+\]\s*\)+\s*;/ nocase  // functions that takes a callback as 2nd parameter

        $htaccess = "SetHandler application/x-httpd-php"
        $iis_com = /IIS:\/\/localhost\/w3svc/
        $include = /include\s*\(\s*[^\.]+\.(png|jpg|gif|bmp)/  // Clever includes
        $ini_get = /ini_(get|set|restore)\s*\(\s*['"](safe_mode|open_basedir|disable_(function|classe)s|safe_mode_exec_dir|safe_mode_include_dir|register_globals|allow_url_include)/ nocase
        $register_function = /register_[a-z]+_function\s*\(\s*['"]\s*(eval|assert|passthru|exec|include|system|shell_exec|`)/  // https://github.com/nbs-system/php-malware-finder/issues/41
        $safemode_bypass = /\x00\/\.\.\/|LD_PRELOAD/
        $shellshock = /\(\)\s*{\s*[a-z:]\s*;\s*}\s*;/
        $udp_dos = /fsockopen\s*\(\s*['"]udp:\/\// nocase
        $various = "<!--#exec cmd="  //http://www.w3.org/Jigsaw/Doc/User/SSI.html#exec
        $at_eval = /@eval\s*\(/ nocase
        $double_var = /\${\s*\${/
        $extract = /extract\s*\(\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)/
        $reversed = /noitcnuf_etaerc|metsys|urhtssap|edulcni|etucexe_llehs/ nocase
				$silenced_include =/@\s*include\s*/ nocase

    condition:
        (any of them)
}

private rule DangerousPhp
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $system = "system" fullword nocase  // localroot bruteforcers have a lot of this

        $ = "array_filter" fullword nocase
        $ = "assert" fullword nocase
        $ = "backticks" fullword nocase
        $ = "call_user_func" fullword nocase
        $ = "eval" fullword nocase
        $ = "exec" fullword nocase
        $ = "fpassthru" fullword nocase
        $ = "fsockopen" fullword nocase
        $ = "function_exists" fullword nocase
        $ = "getmygid" fullword nocase
        $ = "shmop_open" fullword nocase
        $ = "mb_ereg_replace_callback" fullword nocase
        $ = "passthru" fullword nocase
        $ = /pcntl_(exec|fork)/ fullword nocase
        $ = "php_uname" fullword nocase
        $ = "phpinfo" fullword nocase
        $ = "posix_geteuid" fullword nocase
        $ = "posix_getgid" fullword nocase
        $ = "posix_getpgid" fullword nocase
        $ = "posix_getppid" fullword nocase
        $ = "posix_getpwnam" fullword nocase
        $ = "posix_getpwuid" fullword nocase
        $ = "posix_getsid" fullword nocase
        $ = "posix_getuid" fullword nocase
        $ = "posix_kill" fullword nocase
        $ = "posix_setegid" fullword nocase
        $ = "posix_seteuid" fullword nocase
        $ = "posix_setgid" fullword nocase
        $ = "posix_setpgid" fullword nocase
        $ = "posix_setsid" fullword nocase
        $ = "posix_setsid" fullword nocase
        $ = "posix_setuid" fullword nocase
        $ = "preg_replace_callback" fullword
        $ = "proc_open" fullword nocase
        $ = "proc_close" fullword nocase
        $ = "popen" fullword nocase
        $ = "register_shutdown_function" fullword nocase
        $ = "register_tick_function" fullword nocase
        $ = "shell_exec" fullword nocase
        $ = "shm_open" fullword nocase
        $ = "show_source" fullword nocase
        $ = "socket_create(AF_INET, SOCK_STREAM, SOL_TCP)" nocase
        $ = "stream_socket_pair" nocase
        $ = "suhosin.executor.func.blacklist" nocase
        $ = "unregister_tick_function" fullword nocase
        $ = "win32_create_service" fullword nocase
        $ = "xmlrpc_decode" fullword nocase 
        $ = /ob_start\s*\(\s*[^\)]/  //ob_start('assert'); echo $_REQUEST['pass']; ob_end_flush();

        $whitelist = /escapeshellcmd|escapeshellarg/ nocase

    condition:
        (not $whitelist and (5 of them or #system > 250))
}

private rule IRC
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $ = "USER" fullword nocase
        $ = "PASS" fullword nocase
        $ = "PRIVMSG" fullword nocase
        $ = "MODE" fullword nocase
        $ = "PING" fullword nocase
        $ = "PONG" fullword nocase
        $ = "JOIN" fullword nocase
        $ = "PART" fullword nocase

    condition:
        5 of them
}

private rule base64rule
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $user_agent = "SFRUUF9VU0VSX0FHRU5UCg"
        $eval = "ZXZhbCg"
        $system = "c3lzdGVt"
        $preg_replace = "cHJlZ19yZXBsYWNl"
        $exec = "ZXhlYyg"
        $base64_decode = "YmFzZTY0X2RlY29kZ"
        $perl_shebang = "IyEvdXNyL2Jpbi9wZXJsCg"
        $cmd_exe = "Y21kLmV4ZQ"
        $powershell = "cG93ZXJzaGVsbC5leGU"

    condition:
        any of them
}

private rule hex
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $globals = "\\x47\\x4c\\x4f\\x42\\x41\\x4c\\x53" nocase
        $eval = "\\x65\\x76\\x61\\x6C\\x28" nocase
        $exec = "\\x65\\x78\\x65\\x63" nocase
        $system = "\\x73\\x79\\x73\\x74\\x65\\x6d" nocase
        $preg_replace = "\\x70\\x72\\x65\\x67\\x5f\\x72\\x65\\x70\\x6c\\x61\\x63\\x65" nocase
        $http_user_agent = "\\x48\\124\\x54\\120\\x5f\\125\\x53\\105\\x52\\137\\x41\\107\\x45\\116\\x54" nocase
        $base64_decode = "\\x61\\x73\\x65\\x36\\x34\\x5f\\x64\\x65\\x63\\x6f\\x64\\x65\\x28\\x67\\x7a\\x69\\x6e\\x66\\x6c\\x61\\x74\\x65\\x28" nocase
    
    condition:
        any of them
}

private rule Hpack
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
		$globals = "474c4f42414c53" nocase
        $eval = "6576616C28" nocase
        $exec = "65786563" nocase
        $system = "73797374656d" nocase
        $preg_replace = "707265675f7265706c616365" nocase
        $base64_decode = "61736536345f6465636f646528677a696e666c61746528" nocase
    
    condition:
        any of them
}

private rule strrev
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $globals = "slabolg" nocase fullword
        $preg_replace = "ecalper_gerp" nocase fullword
        $base64_decode = "edoced_46esab" nocase fullword
        $gzinflate = "etalfnizg" nocase fullword
    
    condition:
        any of them
}


private rule SuspiciousEncoding
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    condition:
        (base64rule or hex or strrev or Hpack)
}

private rule DodgyStrings
{
    meta:
        source = "https://github.com/nbs-system/php-malware-finder"
		
    strings:
        $ = ".bash_history"
        $ = /AddType\s+application\/x-httpd-(php|cgi)/ nocase
        $ = /php_value\s*auto_prepend_file/ nocase
        $ = /SecFilterEngine\s+Off/ nocase  // disable modsec
        $ = /Add(Handler|Type|OutputFilter)\s+[^\s]+\s+\.htaccess/ nocase
        $ = ".mysql_history"
        $ = ".ssh/authorized_keys"
        $ = "/(.*)/e"  // preg_replace code execution
        $ = "/../../../"
        $ = "/etc/passwd"
        $ = "/etc/proftpd.conf"
        $ = "/etc/resolv.conf"
        $ = "/etc/shadow"
        $ = "/etc/syslog.conf"
        $ = "/proc/cpuinfo" fullword
        $ = "/var/log/lastlog"
        $ = "/windows/system32/"
        $ = "LOAD DATA LOCAL INFILE" nocase
        $ = "WScript.Shell"
        $ = "WinExec"
        $ = "b374k" fullword nocase
        $ = "backdoor" fullword nocase
        $ = /(c99|r57|fx29)shell/
        $ = /defac(ed|er|ement|ing)/ fullword nocase
        $ = "evilc0ders" fullword nocase
        $ = "exploit" fullword nocase
        $ = "find . -type f" fullword
        $ = "hashcrack" nocase
        $ = "id_rsa" fullword
        $ = "ipconfig" fullword nocase
        $ = "kingdefacer" nocase
        $ = "Wireghoul" nocase fullword
        $ = "LD_PRELOAD" fullword
        $ = "libpcprofile"  // CVE-2010-3856 local root
        $ = "locus7s" nocase
        $ = "ls -la" fullword
        $ = "meterpreter" fullword
        $ = "nc -l" fullword
        $ = "netstat -an" fullword
        $ = "php://"
        $ = "ps -aux" fullword
        $ = "rootkit" fullword nocase
        $ = "slowloris" fullword nocase
        $ = "suhosin" fullword
        $ = "sun-tzu" fullword nocase // quote from the Art of War
        $ = /trojan (payload)?/
        $ = "uname -a" fullword
        $ = "visbot" nocase fullword
        $ = "warez" fullword nocase
        $ = "whoami" fullword
        $ = /(r[e3]v[e3]rs[e3]|w[3e]b|cmd)\s*sh[e3]ll/ nocase
        $ = /-perm -0[24]000/ // find setuid files
        $ = /\/bin\/(ba)?sh/ fullword
        $ = /hack(ing|er|ed)/ nocase
        $ = /(safe_mode|open_basedir) bypass/ nocase
        $ = /xp_(execresultset|regenumkeys|cmdshell|filelist)/

        $vbs = /language\s*=\s*vbscript/ nocase
        $asp = "scripting.filesystemobject" nocase

    condition:
        (IRC or 2 of them)
}

private rule generic_jsp
{
    meta:
        source= "https://www.tenable.com/blog/hunting-for-web-shells"

    strings:
        $ = /Runtime.getRuntime\(\).exec\(request.getParameter\(\"[a-zA-Z0-9]+\"\)\);/ ascii

    condition:
        all of them
}

private rule eval
{
    meta:
        source = "https://www.tenable.com/blog/hunting-for-web-shells"

    strings:
        $ = /eval[\( \t]+((base64_decode[\( \t]+)|(str_rot13[\( \t]+)|(gzinflate[\( \t]+)|(gzuncompress[\( \t]+)|(strrev[\( \t]+)|(gzdecode[\( \t]+))+/

    condition:
        all of them
}

private rule fopo
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /\$[a-zA-Z0-9]+=\"\\(142|x62)\\(141|x61)\\(163|x73)\\(145|x65)\\(66|x36)\\(64|x34)\\(137|x5f)\\(144|x64)\\(145|x65)\\(143|x63)\\(157|x6f)\\(144|x64)\\(145|x65)\";@eval\(/

    condition:
        all of them
}

private rule hardcoded_urldecode
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /urldecode[\t ]*\([\t ]*'(%[0-9a-fA-F][0-9a-fA-F])+'[\t ]*\)/

    condition:
        all of them
}

private rule chr_obfuscation
{
    meta:
        source = "https://github.com/tenable/yara-rules/blob/master/webshells/"

    strings:
        $ = /\$[^=]+=[\t ]*(chr\([0-9]+\)\.?){2,}/

    condition:
        all of them
}

private rule phpInImage
{
    meta:
        source = "Vlad https://github.com/vlad-s"

    strings:
        $php_tag = "<?php"
        $gif = {47 49 46 38 ?? 61} // GIF8[version]a
        $jfif = { ff d8 ff e? 00 10 4a 46 49 46 }
        $png = { 89 50 4e 47 0d 0a 1a 0a }
        $jpeg = {FF D8 FF E0 ?? ?? 4A 46 49 46 } 

    condition:
        (($gif at 0) or ($jfif at 0) or ($png at 0) or ($jpeg at 0)) and $php_tag
}

rule hiddenFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Hidden functionality allows malware to masquerade as another filetype"

    condition:
        phpInImage
}

rule webshellArtifact 
{
    meta:
        author = "NSA Cybersecurity"
        description = "Artifacts common to web shells and rare in benign files"

    condition:
        b374k or pas_tool or pbot or generic_jsp
}

rule suspiciousFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Artifacts common to web shells and somewhat rare in benign files"

    condition:
        passwordProtection or hardcoded_urldecode or fopo or eval
}

rule obfuscatedFunctionality
{
    meta:
        author = "NSA Cybersecurity"
        description = "Obfuscation sometimes hides malicious functionality"

    condition:
        ObfuscatedPhp or chr_obfuscation or SuspiciousEncoding
}

rule possibleIndicator
{
    meta:
        author = "NSA Cybersecurity"
        description = "Artifacts common to web shells and less common in benign files"

    condition:
		DodgyPhp or DangerousPhp or DodgyStrings
}

```

`BLUESPAWN-win-client/resources/third-party-integration/kiwi_passwords.yar`:

```yar
/*	Benjamin DELPY `gentilkiwi`
	http://blog.gentilkiwi.com
	benjamin@gentilkiwi.com
	Licence : https://creativecommons.org/licenses/by/4.0/
*/
rule mimikatz
{
	meta:
		description		= "mimikatz"
		author			= "Benjamin DELPY (gentilkiwi)"
		tool_author		= "Benjamin DELPY (gentilkiwi)"

	strings:
		$exe_x86_1		= { 89 71 04 89 [0-3] 30 8d 04 bd }
		$exe_x86_2		= { 8b 4d e? 8b 45 f4 89 75 e? 89 01 85 ff 74 }
		
		$exe_x64_1		= { 33 ff 4? 89 37 4? 8b f3 45 85 c? 74}
		$exe_x64_2		= { 4c 8b df 49 [0-3] c1 e3 04 48 [0-3] 8b cb 4c 03 [0-3] d8 }

		$dll_1			= { c7 0? 00 00 01 00 [4-14] c7 0? 01 00 00 00 }
		$dll_2			= { c7 0? 10 02 00 00 ?? 89 4? }
		
		$sys_x86		= { a0 00 00 00 24 02 00 00 40 00 00 00 [0-4] b8 00 00 00 6c 02 00 00 40 00 00 00 }
		$sys_x64		= { 88 01 00 00 3c 04 00 00 40 00 00 00 [0-4] e8 02 00 00 f8 02 00 00 40 00 00 00 }

	condition:
		(all of ($exe_x86_*)) or (all of ($exe_x64_*)) or (all of ($dll_*)) or (any of ($sys_*))
}


rule mimikatz_lsass_mdmp
{
	meta:
		description		= "LSASS minidump file for mimikatz"
		author			= "Benjamin DELPY (gentilkiwi)"

	strings:
		$lsass			= "System32\\lsass.exe"	wide nocase

	condition:
		(uint32(0) == 0x504d444d) and $lsass
}


rule mimikatz_kirbi_ticket
{
	meta:
		description		= "KiRBi ticket for mimikatz"
		author			= "Benjamin DELPY (gentilkiwi)"

	strings:
		$asn1			= { 76 82 ?? ?? 30 82 ?? ?? a0 03 02 01 05 a1 03 02 01 16 }

	condition:
		$asn1 at 0
}


rule wce
{
	meta:
		description		= "wce"
		author			= "Benjamin DELPY (gentilkiwi)"
		tool_author		= "Hernan Ochoa (hernano)"

	strings:
		$hex_legacy		= { 8b ff 55 8b ec 6a 00 ff 75 0c ff 75 08 e8 [0-3] 5d c2 08 00 }
		$hex_x86		= { 8d 45 f0 50 8d 45 f8 50 8d 45 e8 50 6a 00 8d 45 fc 50 [0-8] 50 72 69 6d 61 72 79 00 }
		$hex_x64		= { ff f3 48 83 ec 30 48 8b d9 48 8d 15 [0-16] 50 72 69 6d 61 72 79 00 }

	condition:
		any of them
}


rule lsadump
{
	meta:
		description		= "LSA dump programe (bootkey/syskey) - pwdump and others"
		author			= "Benjamin DELPY (gentilkiwi)"

	strings:
		$str_sam_inc	= "\\Domains\\Account" ascii nocase
		$str_sam_exc	= "\\Domains\\Account\\Users\\Names\\" ascii nocase
		$hex_api_call	= {(41 b8 | 68) 00 00 00 02 [0-64] (68 | ba) ff 07 0f 00 }
		$str_msv_lsa	= { 4c 53 41 53 52 56 2e 44 4c 4c 00 [0-32] 6d 73 76 31 5f 30 2e 64 6c 6c 00 }
		$hex_bkey		= { 4b 53 53 4d [20-70] 05 00 01 00}

	condition:
		($str_sam_inc and not $str_sam_exc) or $hex_api_call or $str_msv_lsa or $hex_bkey
}

rule power_pe_injection
{
	meta:
		description		= "PowerShell with PE Reflective Injection"
		author			= "Benjamin DELPY (gentilkiwi)"

	strings:
		$str_loadlib	= "0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9"
		
	condition:
		$str_loadlib
}
```

`BLUESPAWN-win-client/resources/third-party-integration/win_metasploit_related.yara`:

```yara
import "pe"

rule metasploit_payload_msfpayload
{
	meta:
		description = "This rule detects generic metasploit callback payloads generated with msfpayload"
		Author = "Adam Burt (adam_burt@symantec.com)"
	strings:
		$a1 = "asf"
		$a2 = "release"
		$a3 = "build"
		$a4 = "support"
		$a5 = "ab.pdb"
		$l1 = "WS2_32.dll"
		$l2 = "mswsock"
		$l3 = "ntdll.dll"
		$l4 = "KERNEL32.dll"
		$l5 = "shell32"
		$l6 = "malloc"
		$l7 = "fopen"
		$l8 = "fclose"
		$l9 = "fprintf"
		$l10 = "strncpy"
	condition:
		all of ($l*)
		and all of ($a*)

}


rule metasploit_service_starter
{
	meta:
		description = "This rule detects related metasploit service starters"
		author = "Adam Burt (adam_burt@symantec.com)"
	strings:
		$a1 = "StartServiceCtrlDispatcher"
		$a2 = "RegisterServiceCtrlHandle"
		$a3 = "CloseHandle"
		$a4 = "memset"
		$a5 = "rundll32.exe"
		$a6 = "msvcrt.dll"
	condition:
		pe.sections[3].name == ".bss"
		and pe.sections[3].virtual_size == 0x00000030
		and pe.sections[2].virtual_size == 0x0000001c
		and pe.sections[4].virtual_size == 0x00000224
		and all of them
}

```

`BLUESPAWN-win-client/src/hunt/Hunt.cpp`:

```cpp
#include "hunt/Hunt.h"
#include "hunt/HuntRegister.h"

HuntInfo::HuntInfo(const std::wstring& HuntName, DWORD HuntTactics, DWORD HuntCategories, DWORD HuntDatasources, long HuntStartTime) :
	HuntName{ HuntName },
	HuntTactics{ HuntTactics },
	HuntCategories{ HuntCategories },
	HuntDatasources{ HuntDatasources }, 
	HuntStartTime{ HuntStartTime }{}

Hunt::Hunt(IN CONST std::wstring& name) : 
	name{ name }{
	dwTacticsUsed = 0;
	dwSourcesInvolved = 0;
	dwCategoriesAffected = 0;
}

std::wstring Hunt::GetName() {
	return name;
}

std::vector<std::shared_ptr<Detection>> Hunt::RunHunt(IN CONST Scope& scope){
	return {};
}

std::vector<std::pair<std::unique_ptr<Event>, Scope>> Hunt::GetMonitoringEvents() {
	return std::vector<std::pair<std::unique_ptr<Event>, Scope>>();
}

bool Hunt::AffectsCategory(IN DWORD dwStuff){
	return (dwStuff && dwCategoriesAffected) == dwStuff;
}

bool Hunt::UsesTactics(IN DWORD dwTactics){
	return (dwTactics && dwTacticsUsed) == dwTactics;
}

bool Hunt::UsesSources(IN DWORD dwSources){
	return (dwSources && dwSourcesInvolved) == dwSources;
}

```

`BLUESPAWN-win-client/src/hunt/HuntRegister.cpp`:

```cpp
#include "hunt/HuntRegister.h"

#include <functional>
#include <iostream>

#include "util/log/Log.h"

#include "monitor/EventManager.h"
#include "user/bluespawn.h"
#include "util/Utils.h"
#include "util/ThreadPool.h"
#include "util/Promise.h"

decltype(HuntRegister::vRegisteredHunts) HuntRegister::vRegisteredHunts{};

void HuntRegister::RegisterHunt(std::unique_ptr<Hunt>&& hunt) {
    vRegisteredHunts.emplace_back(std::move(hunt));
}

bool HuntRegister::HuntShouldRun(IN Hunt* hunt,
                                 IN CONST std::vector<std::wstring> vIncludedHunts,
                                 IN CONST std::vector<std::wstring> vExcludedHunts) {
    if(vExcludedHunts.size() != 0) {
        for(auto name : vExcludedHunts) {
            if(hunt->GetName().find(name) != std::wstring::npos) {
                return false;
            }
        }
        return true;
    }
    if(vIncludedHunts.size() != 0) {
        for(auto name : vIncludedHunts) {
            if(hunt->GetName().find(name) != std::wstring::npos) {
                return true;
            }
        }
        return false;
    }
    return true;
}

std::vector<Promise<std::vector<std::shared_ptr<Detection>>>>
HuntRegister::RunHunts(IN CONST std::vector<std::wstring> vIncludedHunts,
                       IN CONST std::vector<std::wstring> vExcludedHunts,
                       IN CONST Scope& scope OPTIONAL,
                       IN CONST bool async OPTIONAL) {
    if(vExcludedHunts.size() != 0) {
        Bluespawn::io.InformUser(L"Starting a hunt for " +
                                 std::to_wstring(vRegisteredHunts.size() - vExcludedHunts.size()) + L" techniques.");
    } else if(vIncludedHunts.size() != 0) {
        Bluespawn::io.InformUser(L"Starting a hunt for " + std::to_wstring(vIncludedHunts.size()) + L" techniques.");
    } else {
        Bluespawn::io.InformUser(L"Starting a hunt for " + std::to_wstring(vRegisteredHunts.size()) + L" techniques.");
    }

    std::vector<Promise<std::vector<std::shared_ptr<Detection>>>> detections{};
    for(auto& hunt : vRegisteredHunts) {
        if(HuntShouldRun(hunt.get(), vIncludedHunts, vExcludedHunts)) {
            detections.emplace_back(RunHunt(hunt.get(), scope));
        }
    }

    if(async) {
        std::vector<HANDLE> handles(detections.begin(), detections.end());

        for(size_t idx{ 0 }; idx < handles.size(); idx += MAXIMUM_WAIT_OBJECTS) {
            auto count{ min(handles.size() - idx, MAXIMUM_WAIT_OBJECTS) };
            auto result{ WaitForMultipleObjects(count, handles.data() + idx, true, INFINITE) };
            if(result != WAIT_OBJECT_0) {
                LOG_ERROR("Failed to wait for hunts to finish (status 0x" << std::hex << result << ", error "
                                                                          << std::hex << GetLastError() << ")");
                throw std::exception("Failed to wait for hunts to finish!");
            }
        }

        auto successes{ std::count_if(detections.begin(), detections.end(),
                                      [](auto result) { return result.Fufilled(); }) };

        Bluespawn::io.InformUser(L"Successfully ran " + std::to_wstring(successes) + L" hunts.");
    }

    return detections;
}

Promise<std::vector<std::shared_ptr<Detection>>> HuntRegister::RunHunt(IN Hunt* hunt, IN CONST Scope& scope OPTIONAL) {
    Bluespawn::io.InformUser(L"Starting scan for " + hunt->GetName());

    return ThreadPool::GetInstance().RequestPromise<std::vector<std::shared_ptr<Detection>>>(
        [hunt, scope]() mutable { return hunt->RunHunt(scope); });
}

void HuntRegister::SetupMonitoring(IN CONST std::vector<std::wstring> vIncludedHunts,
                                   IN CONST std::vector<std::wstring> vExcludedHunts) {
    auto& EvtManager{ EventManager::GetInstance() };
    for(auto& hunt : vRegisteredHunts) {
        if(HuntShouldRun(hunt.get(), vIncludedHunts, vExcludedHunts)) {
            Bluespawn::io.InformUser(L"Setting up monitoring for " + hunt->GetName());
            for(auto& event : hunt->GetMonitoringEvents()) {
                auto callback{ std::bind(&Hunt::RunHunt, hunt.get(), std::placeholders::_1) };
                DWORD status{ EvtManager.SubscribeToEvent(std::move(event.first), callback, event.second) };
                if(status != ERROR_SUCCESS) {
                    LOG_ERROR(L"Monitoring for " << hunt->GetName() << L" failed with error code " << status);
                }
            }
        }
    }
}

```

`BLUESPAWN-win-client/src/hunt/RegistryHunt.cpp`:

```cpp
#include "hunt/RegistryHunt.h"
#include "util/log/Log.h"

#include <regex>
#include <set>

namespace Registry {
	REG_SZ_CHECK CheckSzEqual = [](const std::wstring& s1, const std::wstring& s2){ return s1 == s2; };
	REG_SZ_CHECK CheckSzNotEqual = [](const std::wstring& s1, const std::wstring& s2){ return s1 != s2; };
	REG_SZ_CHECK CheckSzEmpty = [](const std::wstring& s1, const std::wstring& s2){ return s1.length() == 0; };
	REG_SZ_CHECK CheckSzRegexMatch = [](const std::wstring& s1, const std::wstring& s2){ return std::regex_match(s1, std::wregex(s2)); };
	REG_SZ_CHECK CheckSzRegexNotMatch = [](const std::wstring& s1, const std::wstring& s2){ return !std::regex_match(s1, std::wregex(s2)); };

	REG_DWORD_CHECK CheckDwordEqual = [](DWORD d1, DWORD d2){ return d1 == d2; };
	REG_DWORD_CHECK CheckDwordNotEqual = [](DWORD d1, DWORD d2){ return d1 != d2; };

	REG_BINARY_CHECK CheckBinaryEqual = [](const AllocationWrapper& s1, const AllocationWrapper& s2){
		return s1.CompareMemory(s2);
	};
	REG_BINARY_CHECK CheckBinaryNotEqual = [](const AllocationWrapper& s1, const AllocationWrapper& s2){
		return !s1.CompareMemory(s2);
	};
	REG_BINARY_CHECK CheckBinaryNull = [](const AllocationWrapper& s1, const AllocationWrapper& s2){ return !s1; };

	REG_MULTI_SZ_CHECK CheckMultiSzSubset = [](const std::vector<std::wstring>& s1, const std::vector<std::wstring>& s2){
		std::unordered_set<std::wstring> vals = { s2.begin(), s2.end() };
		for(auto string : s1){
			if(vals.find(string) == vals.end()){
				return false;
			}
		}
		return true;
	};
	REG_MULTI_SZ_CHECK CheckMultiSzExclusion = [](const std::vector<std::wstring>& s1, const std::vector<std::wstring>& s2){
		std::unordered_set<std::wstring> vals = { s2.begin(), s2.end() };
		for(auto string : s1){
			if(vals.find(string) != vals.end()){
				return false;
			}
		}
		return true;
	};
	REG_MULTI_SZ_CHECK CheckMultiSzEmpty = [](const std::vector<std::wstring>& s1, const std::vector<std::wstring>& s2){
		return s1.size() == 0;
	};

	RegistryCheck::RegistryCheck(std::wstring&& wValueName, std::wstring&& wData, bool MissingBad, const REG_SZ_CHECK& check) :
		name{ std::forward<std::wstring>(wValueName) },
		value{ std::forward<std::wstring>(wData) },
		type{ RegistryType::REG_SZ_T },
		MissingBad{ MissingBad },
		check{ check }{}

	RegistryCheck::RegistryCheck(std::wstring&& wValueName, DWORD&& dwData, bool MissingBad, const REG_DWORD_CHECK& check) :
		name{ std::forward<std::wstring>(wValueName) },
		value{ std::forward<DWORD>(dwData) },
		type{ RegistryType::REG_DWORD_T },
		MissingBad{ MissingBad },
		check{ check }{}

	RegistryCheck::RegistryCheck(std::wstring&& wValueName, AllocationWrapper&& lpData, bool MissingBad, const REG_BINARY_CHECK& check) :
		name{ std::forward<AllocationWrapper>(lpData) },
		value{ std::forward<std::wstring>(wValueName) },
		type{ RegistryType::REG_BINARY_T },
		MissingBad{ MissingBad },
		check{ check }{}

	RegistryCheck::RegistryCheck(std::wstring&& wValueName, std::vector<std::wstring>&& vData, bool MissingBad, const REG_MULTI_SZ_CHECK& check) :
		name{ std::forward<std::wstring>(wValueName) },
		value{ std::forward<std::vector<std::wstring>>(vData) },
		type{ RegistryType::REG_MULTI_SZ_T },
		MissingBad{ MissingBad },
		check{ check }{}

	RegistryType RegistryCheck::GetType() const {
		return type;
	}

	bool RegistryCheck::operator()(const RegistryData& data) const {
		if(type == RegistryType::REG_DWORD_T){
			return (std::get<REG_DWORD_CHECK>(check))(std::get<DWORD>(data), std::get<DWORD>(value));
		} else if(type == RegistryType::REG_SZ_T){
			return (std::get<REG_SZ_CHECK>(check))(std::get<std::wstring>(data), std::get<std::wstring>(value));
		} else if(type == RegistryType::REG_MULTI_SZ_T){
			return (std::get<REG_MULTI_SZ_CHECK>(check))(std::get<std::vector<std::wstring>>(data), std::get<std::vector<std::wstring>>(value));
		} else {
			return (std::get<REG_BINARY_CHECK>(check))(std::get<AllocationWrapper>(data), std::get<AllocationWrapper>(value));
		}
	}

	std::vector<RegistryValue> CheckValues(const HKEY& hkHive, const std::wstring& path, const std::vector<RegistryCheck>& checks, bool CheckWow64, bool CheckUsers){
		std::vector<RegistryValue> vIdentifiedValues{};
		std::vector<RegistryKey> vKeys{ RegistryKey{hkHive, path} };
		if(CheckWow64){
			RegistryKey Wow64Key{ hkHive, path, true };
			if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
				vKeys.emplace_back(Wow64Key);
			}
		}
		if(CheckUsers){
			std::vector<RegistryKey> hkUserHives{ RegistryKey{HKEY_USERS}.EnumerateSubkeys() };
			for(auto& hive : hkUserHives){
				RegistryKey key{ HKEY(hive), path, false };
				if(key.Exists() && std::count(vKeys.begin(), vKeys.end(), key) == 0){
					vKeys.emplace_back(key);
				}
				if(CheckWow64){
					RegistryKey Wow64Key{ HKEY(hive), path, true };
					if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
						vKeys.emplace_back(Wow64Key);
					}
				}
			}
		}

		for(auto& key : vKeys){
			LOG_VERBOSE(1, "Checking values under " << key.ToString());

			for(const RegistryCheck& check : checks){
				if(check.GetType() == RegistryType::REG_SZ_T || check.GetType() == RegistryType::REG_EXPAND_SZ_T){
					auto data = key.GetValue<std::wstring>(check.name);
					if(!data.has_value()){
						if(check.MissingBad){
							LOG_INFO(3, "Under key " << key << ", desired value " << check.name << " was missing.");
							vIdentifiedValues.emplace_back(RegistryValue{ key, check.name, std::move(std::wstring{}) });
						}
					} else if(!check(*data)){
						auto value = RegistryValue{ key, check.name, std::move(*data) };
						LOG_INFO(2, "Under key " << key << ", value " << value.GetPrintableName() << " had potentially malicious data " << value);
						vIdentifiedValues.emplace_back(value);
					}
				} else if(check.GetType() == RegistryType::REG_MULTI_SZ_T){
					auto data = key.GetValue<std::vector<std::wstring>>(check.name);
					if(!data.has_value()){
						if(check.MissingBad){
							LOG_INFO(3, "Under key " << key << ", desired value " << check.name << " was missing.");
							vIdentifiedValues.emplace_back(RegistryValue{ key, check.name, std::move(std::vector<std::wstring>{}) });
						}
					} else if(!check(*data)){
						auto value = RegistryValue{ key, check.name, std::move(*data) };
						LOG_INFO(2, "Under key " << key << ", value " << value.GetPrintableName() << " had potentially malicious data " << value);
						vIdentifiedValues.emplace_back(value);
					}
				} else if(check.GetType() == RegistryType::REG_DWORD_T){
					auto data = key.GetValue<DWORD>(check.name);
					if(!data.has_value()){
						if(check.MissingBad){
							LOG_INFO(3, "Under key " << key << ", desired value " << check.name << " was missing.");
							vIdentifiedValues.emplace_back(RegistryValue{ key, check.name, std::move(0) });
						}
					} else if(!check(*data)){
						auto value = RegistryValue{ key, check.name, std::move(*data) };
						LOG_INFO(2, "Under key " << key << ", value " << value.GetPrintableName() << " had potentially malicious data " << value);
						vIdentifiedValues.emplace_back(value);
					}
				} else if(check.GetType() == RegistryType::REG_BINARY_T){
					auto data = key.GetRawValue(check.name);
					if(!data){
						if(check.MissingBad){
							LOG_INFO(3, "Under key " << key << ", desired value " << check.name << " was missing.");
							vIdentifiedValues.emplace_back(RegistryValue{ key, check.name, std::move(AllocationWrapper{ nullptr, 0 }) });
						}
					} else if(!check(data)){
						auto value = RegistryValue{ key, check.name, std::move(data) };
						LOG_INFO(2, "Under key " << key << ", value " << value.GetPrintableName() << " had potentially malicious data " << value);
						vIdentifiedValues.emplace_back(value);
					}
				}
			}
		}
		return vIdentifiedValues;
	}

	std::vector<RegistryValue> CheckKeyValues(const HKEY& hkHive, const std::wstring& path, bool CheckWow64, bool CheckUsers){
		std::vector<RegistryValue> vIdentifiedValues{};
		std::vector<RegistryKey> vKeys{ RegistryKey{hkHive, path} };
		if(CheckWow64){
			RegistryKey Wow64Key{ hkHive, path, true };
			if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
				vKeys.emplace_back(Wow64Key);
			}
		}
		if(CheckUsers){
			std::vector<RegistryKey> hkUserHives{ RegistryKey{HKEY_USERS}.EnumerateSubkeys() };
			for(auto& hive : hkUserHives){
				RegistryKey key{ HKEY(hive), path, false };
				if(key.Exists() && std::count(vKeys.begin(), vKeys.end(), key) == 0){
					vKeys.emplace_back(key);
				}
				if(CheckWow64){
					RegistryKey Wow64Key{ HKEY(hive), path, true };
					if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
						vKeys.emplace_back(Wow64Key);
					}
				}
			}
		}

		std::vector<RegistryValue> vRegValues = {};
		for(auto& key : vKeys){
			auto values = key.EnumerateValues();

			for(const auto& value : values){
				auto type = key.GetValueType(value);
				if(type == RegistryType::REG_SZ_T || type == RegistryType::REG_EXPAND_SZ_T){
					auto data = key.GetValue<std::wstring>(value);
					auto regValue = RegistryValue{ key, value, std::move(!data ? L"" : *data) };

					LOG_INFO(2, "Under key " << key << ", value " << regValue.GetPrintableName() << " was present with data " << regValue);

					vRegValues.emplace_back(regValue);
				} else if(type == RegistryType::REG_MULTI_SZ_T){
					auto data = key.GetValue<std::vector<std::wstring>>(value);
					auto regValue = RegistryValue{ key, value, std::move(!data ? std::vector<std::wstring>{} : *data) };

					LOG_INFO(2, "Under key " << key << ", value " << regValue.GetPrintableName() << " was present with data " << regValue);

					vRegValues.emplace_back(regValue);
				} else if(type == RegistryType::REG_DWORD_T){
					auto data = key.GetValue<DWORD>(value);
					auto regValue = RegistryValue{ key, value, std::move(!data ? 0 : *data) };

					LOG_INFO(2, "Under key " << key << ", value " << regValue.GetPrintableName() << " was present with data " << regValue);

					vRegValues.emplace_back(regValue);
				} else {
					auto data = key.GetRawValue(value);
					auto regValue = RegistryValue{ key, value, std::move(data) };

					LOG_INFO(2, "Under key " << key << ", value " << regValue.GetPrintableName() << " was present with data " << regValue);

					vRegValues.emplace_back(regValue);
				}
			}
		}

		return vRegValues;
	}

	std::vector<RegistryKey> CheckSubkeys(const HKEY& hkHive, const std::wstring& path, bool CheckWow64, bool CheckUsers){
		std::vector<RegistryValue> vIdentifiedValues{};
		std::vector<RegistryKey> vKeys{ RegistryKey{hkHive, path} };
		if(CheckWow64){
			RegistryKey Wow64Key{ hkHive, path, true };
			if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
				vKeys.emplace_back(Wow64Key);
			}
		}
		if(CheckUsers){
			std::vector<RegistryKey> hkUserHives{ RegistryKey{HKEY_USERS}.EnumerateSubkeys() };
			for(auto& hive : hkUserHives){
				RegistryKey key{ HKEY(hive), path, false };
				if(key.Exists() && std::count(vKeys.begin(), vKeys.end(), key) == 0){
					vKeys.emplace_back(key);
				}
				if(CheckWow64){
					RegistryKey Wow64Key{ HKEY(hive), path, true };
					if(Wow64Key.Exists() && std::count(vKeys.begin(), vKeys.end(), Wow64Key) == 0){
						vKeys.emplace_back(Wow64Key);
					}
				}
			}
		}

		std::vector<RegistryKey> subkeys{};
		for(auto& key : vKeys){
			auto& subs = key.EnumerateSubkeys();
			for(auto& sub : subs){
				subkeys.emplace_back(sub);
			}
		}
		return subkeys;
	}
}

```

`BLUESPAWN-win-client/src/hunt/Scope.cpp`:

```cpp
#include "hunt/Scope.h"

Scope Scope::CreateSubhuntScope(IN DWORD64 Subsections, IN DWORD Subtechniques OPTIONAL) {
    Scope scope{};
    scope.Subtechniques = Subtechniques;
    if(Subsections != -1ULL) {
        scope.Subsections = Subsections;
    }

    return scope;
}

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1036.cpp`:

```cpp
#include "hunt/hunts/HuntT1036.h"

#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "scan/FileScanner.h"
#include "user/bluespawn.h"

#define SEARCH_WRITABLE 0

namespace Hunts {

    HuntT1036::HuntT1036() : Hunt(L"T1036 - Masquerading") {
        dwCategoriesAffected = (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::DefenseEvasion;
    }

    void HuntT1036::Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(005, Match Legitimate Name or Location);

        SUBSECTION_INIT(SEARCH_WRITABLE, Intensive);
        for(auto folder : writableFolders) {
            auto f = FileSystem::Folder(folder);
            if(f.GetFolderExists()) {
                LOG_INFO(2, L"Scanning " << f.GetFolderPath());
                for(auto value : f.GetFiles(std::nullopt, -1)) {
                    if(FileScanner::PerformQuickScan(value.GetFilePath())) {
                        CREATE_DETECTION(Certainty::None, FileDetectionData{ value });
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1036::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique005(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1036::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        if(Bluespawn::aggressiveness >= Aggressiveness::Intensive) {
            Scope scope{ Scope::CreateSubhuntScope(1 << SEARCH_WRITABLE) };
            for(auto folder : writableFolders) {
                auto f = FileSystem::Folder(folder);
                if(f.GetFolderExists()) {
                    events.push_back(std::make_pair(std::make_unique<FileEvent>(f), scope));
                    for(auto subdir : f.GetSubdirectories(-1)) {
                        events.push_back(std::make_pair(std::make_unique<FileEvent>(subdir), scope));
                    }
                }
            }
        }

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1037.cpp`:

```cpp
#include "hunt/hunts/HuntT1037.h"

#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "hunt/RegistryHunt.h"
#include "user/bluespawn.h"

using namespace Registry;

#define LOGON_SCRIPT 0

namespace Hunts {
    HuntT1037::HuntT1037() : Hunt(L"T1037 - Boot or Logon Initialization Scripts") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::Registry | (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::PrivilegeEscalation;
    }

    void HuntT1037::Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(001, Logon Script[Windows]);

        SUBSECTION_INIT(LOGON_SCRIPT, Cursory);
        for(auto detection : CheckValues(HKEY_CURRENT_USER, L"Environment",
                                         { { L"UserInitMprLogonScript", L"", false, CheckSzEmpty } }, true, true)) {
            // Moderate contextual certainty due to the infequency of use for this registry value in legitimate cases
            CREATE_DETECTION(Certainty::Moderate, RegistryDetectionData{ detection });
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1037::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique001(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1037::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1037.001: Logon Script (Windows)
        Registry::GetRegistryEvents(events, SCOPE(LOGON_SCRIPT), HKEY_CURRENT_USER, L"Environment", true, true, false);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1053.cpp`:

```cpp
#include "hunt/hunts/HuntT1053.h"

#include "util/Utils.h"
#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"

#include "scan/YaraScanner.h"
#include "user/bluespawn.h"

#define EVT_4698 0
#define EVT_106 1

namespace Hunts {

    HuntT1053::HuntT1053() : Hunt(L"T1053 - Scheduled Task/Job") {
        dwCategoriesAffected = (DWORD) Category::Files | (DWORD) Category::Processes;
        dwSourcesInvolved = (DWORD) DataSource::EventLogs;
        dwTacticsUsed = (DWORD) Tactic::Execution | (DWORD) Tactic::Persistence | (DWORD) Tactic::PrivilegeEscalation;
    }

    void HuntT1053::Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(005, Scheduled Task);

        SUBSECTION_INIT(EVT_4698, Cursory);
        std::vector<EventLogs::XpathQuery> queries;
        auto param1 = EventLogs::ParamList();
        auto param2 = EventLogs::ParamList();
        auto param3 = EventLogs::ParamList();
        auto param4 = EventLogs::ParamList();
        param1.push_back(std::make_pair(L"Name", L"'SubjectUserName'"));
        param2.push_back(std::make_pair(L"Name", L"'SubjectDomainName'"));
        param3.push_back(std::make_pair(L"Name", L"'TaskName'"));
        param4.push_back(std::make_pair(L"Name", L"'TaskContent'"));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param1));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param2));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param3));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param4));

        auto queryResults = EventLogs::QueryEvents(L"Security", 4698, queries);

        // clang-format off
        for(auto result : queryResults){
            CREATE_DETECTION(Certainty::Moderate, OtherDetectionData{ L"Scheduled Task", {
                { L"Name", result.GetProperty(L"Event/EventData/Data[@Name='TaskName']") },
                { L"User", result.GetProperty(L"Event/EventData/Data[@Name='SubjectUserName']") },
                { L"Content", result.GetProperty(L"Event/EventData/Data[@Name='TaskContent']") }
            }});
        }
        SUBSECTION_END();

        SUBSECTION_INIT(EVT_106, Cursory);
        std::vector<EventLogs::XpathQuery> queries2;
        auto param5 = EventLogs::ParamList();
        auto param6 = EventLogs::ParamList();
        param5.push_back(std::make_pair(L"Name", L"'TaskName'"));
        param6.push_back(std::make_pair(L"Name", L"'UserContext'"));
        queries2.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param5));
        queries2.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param6));

        auto queryResults2 = EventLogs::QueryEvents(L"Microsoft-Windows-TaskScheduler/Operational", 106, queries2);

        for(auto result : queryResults2){
            CREATE_DETECTION(Certainty::Moderate, OtherDetectionData{ L"Scheduled Task", {
                { L"Name", result.GetProperty(L"Event/EventData/Data[@Name='TaskName']") },
                { L"User", result.GetProperty(L"Event/EventData/Data[@Name='SubjectUserName']") }
            }});
        }
        // clang-format on
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1053::RunHunt(const Scope& scope) {
        HUNT_INIT();

        // Looks for T1053.005: Scheduled Task
        Subtechnique005(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1053::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        events.push_back(std::make_pair(std::make_unique<EventLogEvent>(L"Security", 4698), SCOPE(EVT_4698)));
        events.push_back(std::make_pair(std::make_unique<EventLogEvent>(L"Microsoft-Windows-TaskScheduler/Operational", 
                                                                        106), SCOPE(EVT_106)));

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1055.cpp`:

```cpp
#include "hunt/hunts/HuntT1055.h"

#include <Psapi.h>
#pragma pack(push, 8)
#include <TlHelp32.h>
#pragma pack(pop)
#include <Windows.h>

#include "util/StringUtils.h"
#include "util/ThreadPool.h"
#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"
#include "util/processes/ProcessUtils.h"
#include "util/wrappers.hpp"

#include "pe_sieve.h"
#include "pe_sieve_types.h"
#include "user/bluespawn.h"
#include "utils/debug.h"

extern "C" {
void __stdcall PESieve_help(void);
DWORD __stdcall PESieve_version(void);
pesieve::t_report __stdcall PESieve_scan(pesieve::t_params args);
};

bool debug_output = false;

namespace Hunts {

    HuntT1055::HuntT1055() : Hunt(L"T1055 - Process Injection") {
        debug_output = false;
        dwCategoriesAffected = (DWORD) Category::Processes;
        dwSourcesInvolved = (DWORD) DataSource::Processes;
        dwTacticsUsed = (DWORD) Tactic::PrivilegeEscalation | (DWORD) Tactic::DefenseEvasion;
    }

    void HuntT1055::HandleReport(OUT std::vector<std::shared_ptr<Detection>>& detections,
                                 IN CONST Promise<GenericWrapper<pesieve::ReportEx*>>& promise) {
        auto __name{ L"T1055 - Process Injection" };
        auto value{ promise.GetValue() };
        if(value) {
            auto report{ *value };
            auto summary{ report->scan_report->generateSummary() };
            if(summary.skipped) {
                LOG_INFO(2, "Skipped scanning " << summary.skipped << " modules in process "
                                                << report->scan_report->getPid()
                                                << ". This is likely due to use of .NET");
            }

            if(summary.suspicious && !summary.errors) {
                std::wstring path = StringToWidestring(report->scan_report->mainImagePath);

                for(auto module : report->scan_report->moduleReports) {
                    if(module->status == pesieve::SCAN_SUSPICIOUS) {
                        CREATE_DETECTION_WITH_CONTEXT(Certainty::Strong,
                                                      ProcessDetectionData::CreateMemoryDetectionData(
                                                          report->scan_report->getPid(), path, module->module,
                                                          static_cast<DWORD>(module->moduleSize),
                                                          StringToWidestring(module->moduleFile), path),
                                                      DetectionContext{ __name });
                    }
                }
            }
        }
    }

    Promise<GenericWrapper<pesieve::ReportEx*>> HuntT1055::QueueProcessScan(DWORD pid){
        return ThreadPool::GetInstance().RequestPromise<GenericWrapper<pesieve::ReportEx*>>([pid](){
            pesieve::t_params params{
                pid,
                3,
                Bluespawn::aggressiveness == Aggressiveness::Intensive ? pesieve::PE_DNET_NONE :
                                                                         pesieve::PE_DNET_SKIP_HOOKS,
                pesieve::PE_IMPREC_NONE,
                true,
                pesieve::OUT_NO_DIR,
                Bluespawn::aggressiveness != Aggressiveness::Intensive,
                Bluespawn::aggressiveness == Aggressiveness::Intensive,
                Bluespawn::aggressiveness == Aggressiveness::Intensive ? pesieve::PE_IATS_FILTERED :
                                                                         pesieve::PE_IATS_NONE,
                Bluespawn::aggressiveness == Aggressiveness::Intensive ? pesieve::PE_DATA_SCAN_NO_DEP :
                                                                         pesieve::PE_DATA_NO_SCAN,
                false,
                pesieve::PE_DUMP_AUTO,
                false,
                0
            };

            WRAP(pesieve::ReportEx*, report, scan_and_dump(params), delete data);
            if(!report){
                LOG_INFO(2, "Unable to scan process " << pid << " due to an error in PE-Sieve.dll");
                throw std::exception{ "Failed to scan process" };
            }

            return report;
        });
    }

    std::vector<std::shared_ptr<Detection>> HuntT1055::RunHunt(const Scope& scope) {
        HUNT_INIT();

        SUBSECTION_INIT(0, Normal);
        HandleWrapper snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };
        if(snapshot) {
            PROCESSENTRY32W info{};
            info.dwSize = sizeof(info);
            if(Process32FirstW(snapshot, &info)) {
                std::vector<Promise<GenericWrapper<pesieve::ReportEx*>>> results{};
                do {
                    auto pid{ info.th32ProcessID };
                    if(info.szExeFile == std::wstring{ L"vmmem" }) {
                        LOG_INFO(2, L"Skipping scans for process with PID " << pid << ".");
                        continue;
                    }

                    results.emplace_back(QueueProcessScan(pid));
                } while(Process32NextW(snapshot, &info));

                for(auto& promise : results) {
                    HandleReport(detections, promise);
                }
            } else {
                auto error{ GetLastError() };
                LOG_ERROR("Unable to enumerate processes - Process related hunts will not run." << GetLastError());
            }
        } else {
            LOG_ERROR("Unable to enumerate processes - Process related hunts will not run.");
        }
        SUBSECTION_END();

        HUNT_END();
    }

}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1068.cpp`:

```cpp
#include "hunt/hunts/HuntT1068.h"

#include <regex>

#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "user/bluespawn.h"

using namespace Registry;

#define PRINTERS 0
#define PORTS 1

namespace Hunts {

    HuntT1068::HuntT1068() : Hunt(L"T1068 - Exploitation for Privilege Escalation") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::Registry | (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::PrivilegeEscalation;
    }

    std::vector<std::shared_ptr<Detection>> HuntT1068::RunHunt(const Scope& scope) {
        HUNT_INIT();

        SUBSECTION_INIT(PRINTERS, Cursory)
        RegistryKey printers{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers",
                              true };
        for(auto printer : printers.EnumerateSubkeys()) {
            if(printer.ValueExists(L"Port")) {
                auto value{ RegistryValue::Create(printer, L"Port") };
                FileSystem::File filepath{ value->ToString() };

                // Regex ensures the file is an actual drive and not, say, a COM port
                if(std::regex_match(filepath.GetFilePath(), std::wregex(L"([a-zA-z]{1}:\\\\)(.*)")) &&
                   filepath.GetFileExists() && filepath.HasReadAccess()) {
                    CREATE_DETECTION(Certainty::Strong,
                                     RegistryDetectionData{ *value, RegistryDetectionType::FileReference });
                }
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(PORTS, Cursory);
        RegistryKey ports{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports", true };
        for(auto value : ports.EnumerateValues()) {
            FileSystem::File filepath{ value };

            // Regex ensures the file is an actual drive and not, say, a COM port
            if(std::regex_match(filepath.GetFilePath(), std::wregex(L"([a-zA-z]{1}:\\\\)(.*)")) &&
               filepath.GetFileExists() && filepath.HasReadAccess()) {
                CREATE_DETECTION(Certainty::Strong, RegistryDetectionData{ *RegistryValue::Create(ports, value),
                                                                           RegistryDetectionType::Unknown });
                CREATE_DETECTION(Certainty::Strong, FileDetectionData{ filepath });
            }
        }
        SUBSECTION_END();

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1068::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // CVE-2020-1048
        Registry::GetRegistryEvents(events, SCOPE(PRINTERS), HKEY_LOCAL_MACHINE,
                                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers", true, false, 
                                    true);
        Registry::GetRegistryEvents(events, SCOPE(PORTS), HKEY_LOCAL_MACHINE, 
                                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports", true, false, false);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1070.cpp`:

```cpp
#include "hunt/hunts/HuntT1070.h"

#include <iostream>

#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"
#include "util/processes/ProcessUtils.h"

#include "user/bluespawn.h"

#define TIMESTOMP 0

namespace Hunts {

    HuntT1070::HuntT1070() : Hunt(L"T1070 - Indicator Removal on Host") {
        dwCategoriesAffected = (DWORD) Category::Files | (DWORD) Category::Processes;
        dwSourcesInvolved = (DWORD) DataSource::EventLogs;
        dwTacticsUsed = (DWORD) Tactic::DefenseEvasion;
    }

    void HuntT1070::Subtechnique006(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(006, Timestomp);

        SUBSECTION_INIT(TIMESTOMP, Normal);
        // Looks for T1070.006 Timestomp
        // Create existance queries so interesting data is output
        std::vector<EventLogs::XpathQuery> queries;
        auto param1 = EventLogs::ParamList();
        auto param2 = EventLogs::ParamList();
        auto param3 = EventLogs::ParamList();
        auto param4 = EventLogs::ParamList();
        auto param5 = EventLogs::ParamList();
        param1.push_back(std::make_pair(L"Name", L"'Image'"));
        param2.push_back(std::make_pair(L"Name", L"'ProcessId'"));
        param3.push_back(std::make_pair(L"Name", L"'TargetFilename'"));
        param4.push_back(std::make_pair(L"Name", L"'CreationUtcTime'"));
        param5.push_back(std::make_pair(L"Name", L"'PreviousCreationUtcTime'"));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param1));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param2));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param3));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param4));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param5));

        auto queryResults = EventLogs::QueryEvents(L"Microsoft-Windows-Sysmon/Operational", 2, queries);
        for(auto query : queryResults){
            FileSystem::File file{ query.GetProperty(L"Event/EventData/Data[@Name='TargetFilename']") };
            CREATE_DETECTION(Certainty::Strong, FileDetectionData{ file });

            // Scan process
            HandleWrapper hProcess{ 
                OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false,
                            std::stoi(query.GetProperty(L"Event/EventData/Data[@Name='ProcessId']"))) };
            if(hProcess){
                auto image{ GetProcessImage(hProcess) };
                CREATE_DETECTION(Certainty::Moderate,
                                 ProcessDetectionData::CreateProcessDetectionData(GetProcessId(hProcess), image));
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1070::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique006(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1070::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events{};

        events.push_back(std::make_pair(std::make_unique<EventLogEvent>(L"Microsoft-Windows-Sysmon/Operational", 2), 
                                        SCOPE(TIMESTOMP)));

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1136.cpp`:

```cpp
#include "hunt/hunts/HuntT1136.h"

#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"

#include "user/bluespawn.h"

#define USER_LOG 0
#define HIDDEN_USER 1

namespace Hunts {

    HuntT1136::HuntT1136() : Hunt(L"T1136 - Create Account") {
        dwCategoriesAffected = (DWORD) Category::Configurations;
        dwSourcesInvolved = (DWORD) DataSource::EventLogs;
        dwTacticsUsed = (DWORD) Tactic::Persistence;
    }

    void HuntT1136::Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(001, Local Account);

        SUBSECTION_INIT(USER_LOG, Normal);

        // Looks for T1136.001: Local Account
        // Create existance queries so interesting data is output
        std::vector<EventLogs::XpathQuery> queries;
        auto param1 = EventLogs::ParamList();
        auto param2 = EventLogs::ParamList();
        param1.push_back(std::make_pair(L"Name", L"'TargetUserName'"));
        param2.push_back(std::make_pair(L"Name", L"'SubjectUserName'"));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param1));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param2));

        auto results = EventLogs::QueryEvents(L"Security", 4720, queries);
        for(auto result : results){
            // clang-format off
            CREATE_DETECTION(Certainty::None, OtherDetectionData{ L"User", {
                { L"Username", result.GetProperty(L"Event/EventData/Data[@Name='TargetUserName']") },
                { L"Creator", result.GetProperty(L"Event/EventData/Data[@Name='SubjectUserName']") }
            }});
            // clang-format on
        }
        SUBSECTION_END();

        SUBSECTION_INIT(HIDDEN_USER, Cursory);

        Permissions::User uHiddenUser(L"$");

        if (uHiddenUser.Exists()) {
            CREATE_DETECTION(Certainty::Certain, OtherDetectionData{ L"User", {
                { L"Username", L"$" },
                { L"Context", L"Users with this name are hidden from net user command."}
            }});
        }

        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1136::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique001(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1136::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1136.001: Local Account
        events.push_back(std::make_pair(std::make_unique<EventLogEvent>(L"Security", 4720), SCOPE(USER_LOG)));

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1484.cpp`:

```cpp
#include "hunt/hunts/HuntT1484.h"

#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "user/bluespawn.h"

#define NTUSER_MAN 0

namespace Hunts {

    HuntT1484::HuntT1484() : Hunt(L"T1484 - Group Policy Modification") {
        dwCategoriesAffected = (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::FileSystem | (DWORD) DataSource::GPO;
        dwTacticsUsed = (DWORD) Tactic::DefenseEvasion;
    }

    std::vector<std::shared_ptr<Detection>> HuntT1484::RunHunt(const Scope& scope) {
        HUNT_INIT();

        SUBSECTION_INIT(NTUSER_MAN, Normal)
        auto userFolders = FileSystem::Folder(L"C:\\Users").GetSubdirectories(1);
        for(auto userFolder : userFolders) {
            FileSystem::File ntuserman{ userFolder.GetFolderPath() + L"\\ntuser.man" };
            if(ntuserman.GetFileExists()) {
                CREATE_DETECTION(Certainty::Moderate, FileDetectionData{ ntuserman });
            }
        }
        SUBSECTION_END();

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1484::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        auto scope{ SCOPE(NTUSER_MAN) };
        events.push_back(std::make_pair(std::make_unique<FileEvent>(FileSystem::Folder(L"C:\\Users")), scope));
        auto userFolders = FileSystem::Folder(L"C:\\Users").GetSubdirectories(1);
        for(auto userFolder : userFolders) {
            events.push_back(std::make_pair(std::make_unique<FileEvent>(userFolder), scope));
        }

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1505.cpp`:

```cpp
#include "hunt/hunts/HuntT1505.h"

#include "util/StringUtils.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "scan/YaraScanner.h"
#include "user/bluespawn.h"

#define WEB_SHELL 0

namespace Hunts {
    HuntT1505::HuntT1505() : Hunt(L"T1505 - Server Software Component"),
        //PHP regex credit to: https://github.com/emposha/PHP-Shell-Detector
        php_vuln_functions{ R"(preg_replace.*\/e|`.*?\$.*?`|\bcreate_function\b|\bpassthru\b|\bshell_exec\b|\bexec\b|\bbase64_decode\b|\bedoced_46esab\b|\beval\b|\bsystem\b|\bproc_open\b|\bpopen\b|\bcurl_exec\b|\bcurl_multi_exec\b|\bparse_ini_file\b|\bshow_source\b)" },
        asp_indicators{ R"(\bcmd.exe\b|\bpowershell.exe\b|\bwscript.shell\b|\bprocessstartinfo\b|\bcreatenowindow\b|\bcmd\b|\beval request\b|\bexecute request\b|\boscriptnet\b|createobject\("scripting.filesystemobject"\))" },
        jsp_indicators{ R"(\bcmd.exe\b|\bpowershell.exe\b|\bgetruntime\(\)\.exec\b)" }{
        dwCategoriesAffected = (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::PrivilegeEscalation;
    }

    void HuntT1505::Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(003, Web Shell);

        SUBSECTION_INIT(WEB_SHELL, Normal);
        // Looks for T1505.003: Web Shell

        for(std::wstring path : web_directories){
            auto hWebRoot = FileSystem::Folder(path);
            FileSystem::FileSearchAttribs attribs;
            attribs.extensions = web_exts;
            std::vector<FileSystem::File> files = hWebRoot.GetFiles(attribs, -1);

            for(const auto& file : files){
                long offset = 0;
                unsigned long targetAmount = 1000000;
                DWORD amountRead = 0;
                auto file_ext = ToLowerCaseW(file.GetFileAttribs().extension);
                bool detected = false;

                do{
                    auto read = file.Read(targetAmount, offset, &amountRead);
                    read.SetByte(amountRead, '\0');
                    std::string sus_file = ToLowerCaseA(*read.ReadString());
                    if(file_ext.compare(L".php") == 0){
                        if(regex_search(sus_file, match_index, php_vuln_functions)){
                            CREATE_DETECTION(Certainty::Strong, FileDetectionData{ file });
                            LOG_INFO(1, L"Located likely web shell in file "
                                     << file.GetFilePath() << L" in text "
                                     << StringToWidestring(
                                         sus_file.substr(match_index.position(), match_index.length())));
                            detected = true;
                            break;
                        }
                    } else if(file_ext.substr(0, 4).compare(L".jsp") == 0){
                        if(regex_search(sus_file, match_index, jsp_indicators)){
                            CREATE_DETECTION(Certainty::Strong, FileDetectionData{ file });
                            LOG_INFO(1, L"Located likely web shell in file "
                                     << file.GetFilePath() << L" in text "
                                     << StringToWidestring(
                                         sus_file.substr(match_index.position(), match_index.length())));
                            detected = true;
                            break;
                        }
                    } else if(file_ext.substr(0, 3).compare(L".as") == 0){
                        if(regex_search(sus_file, match_index, asp_indicators)){
                            CREATE_DETECTION(Certainty::Strong, FileDetectionData{ file });
                            LOG_INFO(1, L"Located likely web shell in file "
                                     << file.GetFilePath() << L" in text "
                                     << StringToWidestring(
                                         sus_file.substr(match_index.position(), match_index.length())));
                            detected = true;
                            break;
                        }
                    }
                    offset += amountRead - 1000;
                } while(static_cast<SIZE_T>(offset + 1000) < file.GetFileSize());

                // Use YARA to also scan the files if our regex didn't detect anything suspicious
                if(!detected){
                    const auto& yara = YaraScanner::GetInstance();
                    YaraScanResult result{ yara.ScanFile(file) };
                    if(!result && result.vKnownBadRules.size() > 0){
                        CREATE_DETECTION(Certainty::Strong, FileDetectionData{ file, result });
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1505::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique003(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1505::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        auto scope{ SCOPE(WEB_SHELL) };
        // Looks for T1505.003: Web Shell
        for(auto dir : web_directories) {
            auto folder = FileSystem::Folder{ dir };
            if(folder.GetFolderExists()) {
                events.push_back(std::make_pair(std::make_unique<FileEvent>(folder), scope));
                for(auto subdir : folder.GetSubdirectories()) {
                    events.push_back(std::make_pair(std::make_unique<FileEvent>(subdir), scope));
                }
            }
        }

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1543.cpp`:

```cpp
#include "hunt/hunts/HuntT1543.h"

#include <iostream>
#include <set>

#include "util/StringUtils.h"
#include "util/Utils.h"
#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"
#include "util/processes/ProcessUtils.h"

#include "hunt/RegistryHunt.h"
#include "scan/FileScanner.h"
#include "scan/ProcessScanner.h"
#include "scan/ServiceScanner.h"
#include "scan/YaraScanner.h"
#include "user/bluespawn.h"

using namespace Registry;

#define DNS_SECTION 0
#define NTDS_SECTION 1
#define WINSOCK_PARAMS 2
#define WINSOCK_CATALOG 3
#define WINSOCK_CUR_CATALOG 4
#define FAILURE_SECTION 5
#define LOGS_SECTION 6

namespace Hunts {

    HuntT1543::HuntT1543() : Hunt(L"T1543 - Create or Modify System Process") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::Registry | (DWORD) DataSource::FileSystem |
                            (DWORD) DataSource::EventLogs;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::PrivilegeEscalation;
    }

    void HuntT1543::Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(003, Windows Service);

        // DNS Service Audit
        SUBSECTION_INIT(DNS_SECTION, Cursory);
        for(auto& detection : CheckValues(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters",
                                          {
                                              { L"ServerLevelPluginDll", L"", false, CheckSzEmpty },
                                          },
                                          false, false)) {
            CREATE_DETECTION(Certainty::Strong,
                             RegistryDetectionData{ detection, RegistryDetectionType::FileReference });
        }
        SUBSECTION_END();

        // NTDS Service Audit
        SUBSECTION_INIT(NTDS_SECTION, Cursory);
        for(auto& detection : CheckValues(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\NTDS",
                                          {
                                              { L"LsaDbExtPt", L"", false, CheckSzEmpty },
                                              { L"DirectoryServiceExtPt", L"", false, CheckSzEmpty },
                                          },
                                          false, false)) {
            CREATE_DETECTION(Certainty::Moderate,
                             RegistryDetectionData{ detection, RegistryDetectionType::FileReference });
        }
        SUBSECTION_END();

        // Winsock2 Service Audit
        auto winsock2 = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters" };
        SUBSECTION_INIT(WINSOCK_PARAMS, Cursory);
        for(auto paramdll : { L"AutodialDLL", L"NameSpace_Callout" }) {
            auto detection{ Registry::RegistryValue::Create(winsock2, paramdll) };
            if(detection && FileScanner::PerformQuickScan(detection->ToString())) {
                CREATE_DETECTION(Certainty::Moderate,
                                 RegistryDetectionData{ *detection, RegistryDetectionType::FileReference });
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(WINSOCK_CATALOG, Cursory);
        auto appids = RegistryKey{ winsock2, L"AppId_Catalog" };
        for(auto subkey : appids.EnumerateSubkeys()) {
            auto detection{ Registry::RegistryValue::Create(winsock2, L"AppFullPath") };
            if(detection && FileScanner::PerformQuickScan(detection->ToString())) {
                CREATE_DETECTION(Certainty::Moderate,
                                 RegistryDetectionData{ *detection, RegistryDetectionType::FileReference });
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(WINSOCK_CUR_CATALOG, Cursory);
        auto currentCallout = winsock2.GetValue<std::wstring>(L"Current_NameSpace_Catalog");
        if(currentCallout) {
            auto namespaceCatalog = RegistryKey{ winsock2, currentCallout.value() + L"\\Catalog_Entries" };
            auto namespaceCatalog64 = RegistryKey{ winsock2, currentCallout.value() + L"\\Catalog_Entries64" };
            for(auto subkey : { namespaceCatalog, namespaceCatalog64 }) {
                for(auto entry : subkey.EnumerateSubkeys()) {
                    auto detection{ Registry::RegistryValue::Create(winsock2, L"LibraryPath") };
                    if(detection && FileScanner::PerformQuickScan(detection->ToString())) {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ *detection, RegistryDetectionType::FileReference });
                    }
                }
            }
        }
        SUBSECTION_END();

        // Service Failure Audit
        SUBSECTION_INIT(FAILURE_SECTION, Normal);
        auto services = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" };
        for(auto service : services.EnumerateSubkeys()) {
            auto detection{ Registry::RegistryValue::Create(service, L"FailureCommand") };
            if(detection && ProcessScanner::PerformQuickScan(detection->ToString())) {
                CREATE_DETECTION(Certainty::Moderate,
                                 RegistryDetectionData{ *detection, RegistryDetectionType::CommandReference });
            }
        }
        SUBSECTION_END();

        // Looks for 7045 New Service Created events
        SUBSECTION_INIT(LOGS_SECTION, Normal);
        std::vector<EventLogs::XpathQuery> queries;
        auto param1 = EventLogs::ParamList();
        auto param2 = EventLogs::ParamList();
        auto param3 = EventLogs::ParamList();
        auto param4 = EventLogs::ParamList();
        param1.push_back(std::make_pair(L"Name", L"'ServiceName'"));
        param2.push_back(std::make_pair(L"Name", L"'ImagePath'"));
        param3.push_back(std::make_pair(L"Name", L"'ServiceType'"));
        param4.push_back(std::make_pair(L"Name", L"'StartType'"));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param1));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param2));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param3));
        queries.push_back(EventLogs::XpathQuery(L"Event/EventData/Data", param4));

        auto queryResults = EventLogs::QueryEvents(L"System", 7045, queries);

        for(auto result : queryResults) {
            auto imageName{ result.GetProperty(L"Event/EventData/Data[@Name='ServiceName']") };
            auto imagePath{ GetImagePathFromCommand(result.GetProperty(L"Event/EventData/Data[@Name='ImagePath']")) };

            FILETIME ft{};

            ULONGLONG time = (ULONGLONG) stoull(result.GetTimeCreated());
            ULONGLONG nano = 0;

            ft.dwHighDateTime = (DWORD)((time >> 32) & 0xFFFFFFFF);
            ft.dwLowDateTime = (DWORD)(time & 0xFFFFFFFF);

            auto malicious{ Certainty::None };

            bool svchost{ false };
            if(imagePath.find(L"svchost.exe") != std::wstring::npos) {
                // svchost services are rarely if ever should have 7045 events
                malicious = malicious + Certainty::Weak;
                svchost = true;
            } else if(ServiceScanner::PerformQuickScan(std::nullopt, imageName, imagePath)) {
                malicious = malicious + Certainty::Moderate;
            }

            if(malicious > Certainty::None) {
                // clang-format off
                CREATE_DETECTION_WITH_CONTEXT(
                    malicious, ServiceDetectionData{ std::nullopt, imageName, imagePath },
                    DetectionContext{ __name, ft, svchost ? std::optional<std::wstring>{
                    L"Most if not all svchost services should come preinstalled and therefore should not show up in "
                    "the event logs. However, this can sometimes happen legitimately" } : std::nullopt });
                // clang-format on
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1543::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique003(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1543::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1543.003: Windows Service
        GetRegistryEvents(events, SCOPE(FAILURE_SECTION), HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services",
                          false, false);
        GetRegistryEvents(events, SCOPE(NTDS_SECTION), HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\NTDS",
                          false, false);
        GetRegistryEvents(events, SCOPE(DNS_SECTION), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters", false, false);
        GetRegistryEvents(events, Scope::CreateSubhuntScope((1 << WINSOCK_PARAMS) | (1 << WINSOCK_CUR_CATALOG)),
                          HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters", false,
                          false, true);
        GetRegistryEvents(events, SCOPE(WINSOCK_CATALOG), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters\\AppId_Catalog", false, false);
        events.push_back(std::make_pair(std::make_unique<EventLogEvent>(L"System", 7045), SCOPE(LOGS_SECTION)));

        return events;
    }

}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1546.cpp`:

```cpp
#include "hunt/hunts/HuntT1546.h"

#include <algorithm>

#include "util/StringUtils.h"
#include "util/Utils.h"
#include "util/configurations/Registry.h"
#include "util/filesystem/Filesystem.h"
#include "util/log/Log.h"
#include "util/processes/CheckLolbin.h"
#include "util/processes/ProcessUtils.h"

#include "hunt/RegistryHunt.h"
#include "scan/FileScanner.h"
#include "scan/ProcessScanner.h"
#include "user/bluespawn.h"

using namespace Registry;

#define NETSH_HELPER 0
#define ACCESSIBILITY_HIJACK 1
#define ACCESSIBILITY_REPLACE 2
#define APPCERT_DLL 3
#define APPINIT_DLL 4
#define APPLICATION_SHIM 5
#define IFEO_HIJACK 6
#define COM_HIJACK 7
#define SCREENSAVER_KEY 8
#define SCREENSAVER_FILE 9

namespace Hunts {

    HuntT1546::HuntT1546() : Hunt(L"T1546 - Event Triggered Execution") {
        dwCategoriesAffected = (DWORD) Category::Configurations;
        dwSourcesInvolved = (DWORD) DataSource::Registry;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::DefenseEvasion;
    }

#define ADD_FILE(file, ...)                                             \
    if(files.find(file) != files.end()) {                               \
        files.at(file).emplace_back(__VA_ARGS__);                       \
    } else {                                                            \
        files.emplace(file, std::vector<RegistryValue>{ __VA_ARGS__ }); \
    }

    void HuntT1546::Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(002, Screensaver);

        SUBSECTION_INIT(SCREENSAVER_KEY, Cursory);
        for(const auto& detection : CheckValues(HKEY_CURRENT_USER, L"Control Panel\\Desktop",
                                                { { L"SCRNSAVE.exe", L"", false, CheckSzEmpty } })){
            CREATE_DETECTION(Certainty::None,
                             RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
        }
        SUBSECTION_END();

        SUBSECTION_INIT(SCREENSAVER_FILE, Cursory);
        auto path{ L"C:\\Windows\\System32\\scrnsave.scr" };
        if(FileSystem::CheckFileExists(path) && !FileSystem::File{ path }.GetFileSigned()){
            CREATE_DETECTION(Certainty::None, FileDetectionData{ path });
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    void HuntT1546::Subtechnique007(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(7, Netsh Helper DLL);

        SUBSECTION_INIT(NETSH_HELPER, Cursory);
        for(auto& helperDllValue : CheckKeyValues(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Netsh", true, false)) {
            if(FileScanner::PerformQuickScan(helperDllValue.ToString())) {
                CREATE_DETECTION(Certainty::Moderate,
                                 RegistryDetectionData{ helperDllValue, RegistryDetectionType::FileReference });
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique008(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(8, Accessibility Features);

        SUBSECTION_INIT(ACCESSIBILITY_HIJACK, Cursory);
        for(auto& key : vAccessibilityBinaries) {
            std::vector<RegistryValue> debugger{ CheckValues(HKEY_LOCAL_MACHINE, wsIFEO + key,
                                                             {
                                                                 { L"Debugger", L"", false, CheckSzEmpty },
                                                             },
                                                             true, false) };
            for(auto& detection : debugger) {
                CREATE_DETECTION(Certainty::Certain,
                                 RegistryDetectionData{ detection.key, detection,
                                                        RegistryDetectionType::CommandReference,
                                                        detection.key.GetRawValue(detection.wValueName) });
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(ACCESSIBILITY_REPLACE, Normal);
        for(auto name : vAccessibilityBinaries) {
            FileSystem::File file{ FileSystem::File(L"C:\\Windows\\System32\\" + name) };

            if(!file.IsMicrosoftSigned()) {
                CREATE_DETECTION(Certainty::Certain, FileDetectionData{ file });
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique009(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(9, AppCert DLLs);

        SUBSECTION_INIT(APPCERT_DLL, Cursory);
        Registry::RegistryKey appcert_key{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Session Manager" };
        if(appcert_key.ValueExists(L"AppCertDLLs")) {
            for(auto dll : *appcert_key.GetValue<std::vector<std::wstring>>(L"AppCertDLLs")) {
                CREATE_DETECTION(Certainty::Strong,
                                 RegistryDetectionData{ appcert_key,
                                                        RegistryValue{ appcert_key, L"AppCertDLLs", std::move(dll) },
                                                        RegistryDetectionType::FileReference });
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique010(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(10, AppInit DLLs);

        SUBSECTION_INIT(APPINIT_DLL, Cursory);
        for(auto& detection :
            CheckValues(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
                        {
                            { L"AppInit_Dlls", L"", false, CheckSzEmpty },
                            { L"LoadAppInit_Dlls", 0, false, CheckDwordEqual },
                            { L"RequireSignedAppInit_DLLs", 1, false, CheckDwordEqual },
                        },
                        true, false)) {
            CREATE_DETECTION(Certainty::Strong,
                             RegistryDetectionData{ detection, detection.type == RegistryType::REG_DWORD_T ?
                                                                   RegistryDetectionType::Configuration :
                                                                   RegistryDetectionType::FileReference });
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique011(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(11, Application Shimming);

        SUBSECTION_INIT(APPLICATION_SHIM, Normal);
        auto& shims{ CheckKeyValues(HKEY_LOCAL_MACHINE,
                                    L"SOFTWARE\\Microsoft\\Windows "
                                    L"NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB",
                                    true, true) };
        ADD_ALL_VECTOR(shims, CheckKeyValues(HKEY_LOCAL_MACHINE,
                                             L"SOFTWARE\\Microsoft\\Windows "
                                             L"NT\\CurrentVersion\\AppCompatFlags\\Custom",
                                             true, true));

        for(const auto& detection : shims) {
            CREATE_DETECTION(Certainty::Strong, RegistryDetectionData{ detection, RegistryDetectionType::Unknown });
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique012(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(12, Image File Execution Options Injection);

        SUBSECTION_INIT(IFEO_HIJACK, Normal);
        auto IFEO = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File "
                                                     L"Execution Options" };
        for(auto name : IFEO.EnumerateSubkeyNames()) {
            std::vector<RegistryValue> values{ CheckValues(
                HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\" + name,
                {
                    { L"Debugger", L"", false, CheckSzEmpty },
                    { L"GlobalFlag", 0, false, [](DWORD d1, DWORD d2) { return !(d1 & 0x200); } },
                },
                true, false) };

            for(const auto& detection : values) {
                if(detection.wValueName == L"GlobalFlag") {
                    CREATE_DETECTION_WITH_CONTEXT(
                        Certainty::Strong, RegistryDetectionData{ detection, RegistryDetectionType::FileReference },
                        DetectionContext{ __name }, [detection]() {
                            detection.key.SetValue<DWORD>(L"GlobalFlag", std::get<DWORD>(detection.data) & ~0x200);
                        });
                } else {
                    CREATE_DETECTION(Certainty::Strong,
                                     RegistryDetectionData{ detection, RegistryDetectionType::FileReference });
                }
            }

            RegistryKey subkey{ IFEO, name };
            auto GFlags = subkey.GetValue<DWORD>(L"GlobalFlag");
            if(GFlags && *GFlags & 0x200) {
                auto name = subkey.GetName();
                name = name.substr(name.find_last_of(L"\\") + 1);

                std::vector<RegistryValue> values2{ CheckValues(
                    HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\" + name,
                    {
                        { L"ReportingMode", 0, false, CheckDwordEqual },
                        { L"MonitorProcess", L"", false, CheckSzEmpty },
                    },
                    true, false) };

                for(const auto& detection : values2) {
                    if(detection.type == RegistryType::REG_DWORD_T) {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ detection, RegistryDetectionType::Configuration });
                    } else {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    void HuntT1546::Subtechnique015(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(15, Component Object Model Hijacking);

        SUBSECTION_INIT(COM_HIJACK, Intensive);
        // Looks for T1546.015: Component Object Model Hijacking
        if(Bluespawn::aggressiveness >= Aggressiveness::Intensive) {
            std::map<std::wstring, std::vector<RegistryValue>> files{};

            for(auto key : CheckSubkeys(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", true, true)) {
                RegistryKey subkey{ key, L"InprocServer32" };
                if(subkey.Exists() && subkey.ValueExists(L"")) {
                    auto filename{ *subkey.GetValue<std::wstring>(L"") };
                    auto path{ FileSystem::SearchPathExecutable(filename) };
                    if(path) {
                        ADD_FILE(*path, RegistryValue{ subkey, L"", std::move(filename) });
                    }
                }
                subkey = { key, L"InprocServer" };
                if(subkey.Exists() && subkey.ValueExists(L"")) {
                    auto filename{ *subkey.GetValue<std::wstring>(L"") };
                    auto path{ FileSystem::SearchPathExecutable(filename) };
                    if(path) {
                        ADD_FILE(*path, RegistryValue{ subkey, L"", std::move(filename) });
                    }
                }
                if(key.ValueExists(L"InprocHandler32")) {
                    auto filename{ *key.GetValue<std::wstring>(L"InprocHandler32") };
                    auto path{ FileSystem::SearchPathExecutable(filename) };
                    if(path) {
                        ADD_FILE(*path, RegistryValue{ key, L"InprocHandler32", std::move(filename) });
                    }
                }
                if(key.ValueExists(L"InprocHandler")) {
                    auto filename{ *key.GetValue<std::wstring>(L"InprocHandler") };
                    auto path{ FileSystem::SearchPathExecutable(filename) };
                    if(path) {
                        ADD_FILE(*path, RegistryValue{ key, L"InprocHandler", std::move(filename) });
                    }
                }
                if(key.ValueExists(L"LocalServer")) {
                    auto filename{ *key.GetValue<std::wstring>(L"LocalServer") };
                    ADD_FILE(filename, RegistryValue{ key, L"LocalServer", *subkey.GetValue<std::wstring>(L"") });
                }
                subkey = { key, L"LocalServer32" };
                if(subkey.Exists() && subkey.ValueExists(L"")) {
                    auto filename{ *subkey.GetValue<std::wstring>(L"") };
                    ADD_FILE(filename, RegistryValue{ subkey, L"", *subkey.GetValue<std::wstring>(L"") });
                }
                if(subkey.Exists() && subkey.ValueExists(L"ServerExecutable")) {
                    auto filename{ *subkey.GetValue<std::wstring>(L"ServerExecutable") };
                    ADD_FILE(filename,
                             RegistryValue{ subkey, L"ServerExecutable", *subkey.GetValue<std::wstring>(L"") });
                }
            }

            for(auto pair : files) {
                auto path{ pair.first };
                if(!FileSystem::CheckFileExists(path)) {
                    path = GetImagePathFromCommand(path);
                    if(!FileSystem::CheckFileExists(path)) {
                        continue;
                    }
                }

                auto dll{ path.find(L".dll") != std::wstring::npos };
                if((dll && FileScanner::PerformQuickScan(path)) ||
                   (!dll && ProcessScanner::PerformQuickScan(pair.first))) {
                    for(auto& value : pair.second) {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ value, dll ? RegistryDetectionType::FileReference :
                                                                             RegistryDetectionType::CommandReference });
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1546::RunHunt(IN CONST Scope& scope) {
        HUNT_INIT();

        Subtechnique002(scope, detections);
        Subtechnique007(scope, detections);
        Subtechnique008(scope, detections);
        Subtechnique009(scope, detections);
        Subtechnique010(scope, detections);
        Subtechnique011(scope, detections);
        Subtechnique012(scope, detections);
        Subtechnique015(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1546::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1546.002: Screensaver
        GetRegistryEvents(events, SCOPE(SCREENSAVER_KEY), HKEY_CURRENT_USER, L"Control Panel\\Desktop", true, false,
                          false);

        // Looks for T1546.007: Netsh Helper DLL
        GetRegistryEvents(events, SCOPE(NETSH_HELPER), HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Netsh", true, false,
                          false);

        // Looks for T1546.008: Accessibility Features
        for(auto key : vAccessibilityBinaries) {
            Registry::GetRegistryEvents(events, SCOPE(ACCESSIBILITY_HIJACK), HKEY_LOCAL_MACHINE, wsIFEO + key, true,
                                        false, false);
        }

        // Looks for T1546.009: AppCert DLLs
        GetRegistryEvents(events, SCOPE(APPCERT_DLL), HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Control\\Session Manager", true, false, false);

        // Looks for T1546.010: AppInit DLLs
        GetRegistryEvents(events, SCOPE(APPINIT_DLL), HKEY_LOCAL_MACHINE,
                          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows", true, false, false);

        // Looks for T1546.011: Application Shimming
        GetRegistryEvents(events, SCOPE(APPLICATION_SHIM), HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB");
        GetRegistryEvents(events, SCOPE(APPLICATION_SHIM), HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom");
        events.push_back(
            std::make_pair(std::make_unique<FileEvent>(FileSystem::Folder{ L"C:\\Windows\\AppPatch\\Custom" }),
                           SCOPE(APPLICATION_SHIM)));
        events.push_back(std::make_pair(std::make_unique<FileEvent>(FileSystem::Folder{ L"C:"
                                                                                        L"\\Windows\\AppPatch\\Custom\\"
                                                                                        L"Custom64" }),
                                        SCOPE(APPLICATION_SHIM)));

        // Looks for T1546.012: Image File Execution Options Injection
        Registry::GetRegistryEvents(events, SCOPE(IFEO_HIJACK), HKEY_LOCAL_MACHINE,
                                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                                    true, false, true);

        // Looks for T1546.015: Component Object Model Hijacking
        if(Bluespawn::aggressiveness >= Aggressiveness::Intensive) {
            Registry::GetRegistryEvents(events, SCOPE(COM_HIJACK), HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID",
                                        true, true, true);
        }

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1547.cpp`:

```cpp
#include "hunt/hunts/HuntT1547.h"

#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "hunt/RegistryHunt.h"
#include "scan/FileScanner.h"
#include "scan/ProcessScanner.h"
#include "user/bluespawn.h"

using namespace Registry;

#define RUN_KEY 0
#define COMMAND_PROCESSOR 1
#define STARTUP_FOLDER 2
#define STARTUP_ITEMS 3
#define AUTH_PACKAGE 4
#define LSA_EXTENSION 5
#define WINLOGON 6
#define WINLOGON_NOTIFY 7
#define SSP 8
#define PORT_MON 9
#define TIME_PROV 10

namespace Hunts {

    HuntT1547::HuntT1547() : Hunt(L"T1547 - Boot or Logon Autostart Execution") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Files;
        dwSourcesInvolved = (DWORD) DataSource::Registry | (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::PrivilegeEscalation;

        auto HKLMRun = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\Run" };
        auto HKLMRunServices = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices" };
        auto HKLMRunOnce = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce" };
        auto HKLMRunServicesOnce = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceServices" };
        auto HKLMRunOnceEx = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx" };
        auto HKLMRunServicesOnceEx = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceServicesEx" };
        auto HKLMExplorerRun = std::wstring{ L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run" };

        RunKeys = {
            HKLMRun,       HKLMRunServices,       HKLMRunOnce,     HKLMRunServicesOnce,
            HKLMRunOnceEx, HKLMRunServicesOnceEx, HKLMExplorerRun,
        };
    }

    void HuntT1547::Subtechnique001(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(001, Registry Run Keys / Startup Folder);

        SUBSECTION_INIT(RUN_KEY, Cursory);
        for(auto& key : RunKeys) {
            for(auto& detection : CheckKeyValues(HKEY_LOCAL_MACHINE, key)) {
                if(ProcessScanner::PerformQuickScan(std::get<std::wstring>(detection.data))) {
                    CREATE_DETECTION(Certainty::Moderate,
                                     RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
                }
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(COMMAND_PROCESSOR, Cursory);
        for(auto& detection : CheckValues(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Command Processor",
                                          { { L"AutoRun", L"", false, CheckSzEmpty } })) {
            CREATE_DETECTION(Certainty::Strong,
                             RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
        }
        SUBSECTION_END();

        SUBSECTION_INIT(STARTUP_FOLDER, Cursory);
        for(auto& detection : CheckValues(
                HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
                { { L"Startup", L"%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
                    false, CheckSzEqual } })) {
            CREATE_DETECTION(Certainty::Moderate,
                             RegistryDetectionData{ detection, RegistryDetectionType::FolderReference });
        }

        for(auto& detection :
            CheckValues(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                        { { L"Common Startup", L"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
                            false, CheckSzEqual } })) {
            CREATE_DETECTION(Certainty::Moderate,
                             RegistryDetectionData{ detection, RegistryDetectionType::FolderReference });
        }
        SUBSECTION_END();

        SUBSECTION_INIT(STARTUP_ITEMS, Cursory);
        std::vector<FileSystem::Folder> startup_directories = { FileSystem::Folder(
            L"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp") };
        auto userFolders = FileSystem::Folder{ L"C:\\Users" }.GetSubdirectories(1);
        for(auto userFolder : userFolders) {
            FileSystem::Folder folder{ userFolder.GetFolderPath() + L"\\AppData\\Roaming\\Microsoft\\Windows\\Start "
                                                                    L"Menu\\Programs\\StartUp" };
            if(folder.GetFolderExists()) {
                startup_directories.emplace_back(folder);
            }
        }
        for(auto folder : startup_directories) {
            LOG_VERBOSE(1, L"Scanning " << folder.GetFolderPath());
            for(auto value : folder.GetFiles(std::nullopt, -1)) {
                if(FileScanner::PerformQuickScan(value.GetFilePath())) {
                    CREATE_DETECTION(Certainty::Weak, FileDetectionData{ value });
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    void HuntT1547::Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(002, Authentication Package);

        SUBSECTION_INIT(AUTH_PACKAGE, Cursory);
        auto lsa = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
        for(auto PackageGroup : { L"Authentication Packages", L"Notification Packages" }) {
            auto packages = lsa.GetValue<std::vector<std::wstring>>(PackageGroup);
            if(packages) {
                for(auto package : *packages) {
                    auto filepath = FileSystem::SearchPathExecutable(package + L".dll");

                    if(filepath && FileScanner::PerformQuickScan(*filepath)) {
                        // Can't use a macro since we need the shared_ptr of the detection
                        auto value{ Bluespawn::detections.AddDetection(
                            Detection{ RegistryDetectionData{ RegistryValue{ lsa, PackageGroup, std::move(package) },
                                                              RegistryDetectionType::FileReference },
                                       DetectionContext{ __name } },
                            Certainty::Moderate) };
                        detections.emplace_back(value);

                        // Since the security package is missing the dll extension, the scanner may not find the
                        // associated file
                        auto file{ Bluespawn::detections.AddDetection(
                            Detection{ FileDetectionData{ *filepath }, DetectionContext{ __name } }, Certainty::Weak) };
                        detections.emplace_back(file);

                        // Define the association here since the scanner may not pick up on it
                        file->info.AddAssociation(value, Association::Certain);
                        value->info.AddAssociation(file, Association::Certain);
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBSECTION_INIT(LSA_EXTENSION, Cursory);
        auto lsaext = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\LsaExtensionConfig" };
        for(auto subkeyName : lsaext.EnumerateSubkeyNames()) {
            if(subkeyName == L"Interfaces") {
                for(auto subkey : RegistryKey{ lsaext, L"Interfaces" }.EnumerateSubkeys()) {
                    auto ext{ RegistryValue::Create(subkey, L"Extension") };
                    if(ext && FileScanner::PerformQuickScan(ext->ToString())) {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ *ext, RegistryDetectionType::FileReference });
                    }
                }
            } else {
                auto subkey = RegistryKey{ lsaext, subkeyName };
                auto exts = subkey.GetValue<std::vector<std::wstring>>(L"Extensions");
                if(exts) {
                    for(auto ext : *exts) {
                        if(FileScanner::PerformQuickScan(ext)) {
                            CREATE_DETECTION(
                                Certainty::Moderate,
                                RegistryDetectionData{ RegistryValue{ subkey, L"Extensions", std::move(ext) },
                                                       RegistryDetectionType::FileReference });
                        }
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    void HuntT1547::Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections){
        SUBTECHNIQUE_INIT(003, Time Providers);

        SUBSECTION_INIT(TIME_PROV, Cursory);
        RegistryKey time{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders" };
        for(auto subkey : time.EnumerateSubkeys()){
            if(auto value{ RegistryValue::Create(subkey, L"DllName") }){
                auto path{ FileSystem::SearchPathExecutable(std::get<std::wstring>(value->data)) };
                if(path && FileScanner::PerformQuickScan(*path)){
                    CREATE_DETECTION(Certainty::Moderate, RegistryDetectionData{ *value });
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }
    
    void HuntT1547::Subtechnique004(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(004, Winlogon Helper DLL);

        SUBSECTION_INIT(WINLOGON, Cursory);
        // clang-format off
        auto userinitRegex{ 
            L"(C:\\\\[Ww](INDOWS|indows)\\\\[Ss](YSTEM32|ystem32)\\\\)?[Uu](SERINIT|serinit)\\.(exe|EXE),?" };
        std::vector<RegistryValue> winlogons{ CheckValues(HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", {
                { L"Shell", L"explorer\\.exe,?", false, CheckSzRegexMatch },
                { L"UserInit", userinitRegex, false, CheckSzRegexMatch }
            }, true, true) };
        // clang-format on

        for(auto& detection : winlogons) {
            // Moderate contextual certainty due to how rarely these values are used legitimately
            CREATE_DETECTION(Certainty::Moderate, RegistryDetectionData{ detection, RegistryDetectionType::FileReference });
        }
        SUBSECTION_END();

        SUBSECTION_INIT(WINLOGON_NOTIFY, Cursory);
        std::vector<RegistryValue> notifies{ CheckKeyValues(
            HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify", true, true) };
        for(auto& notify : CheckSubkeys(
                HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify", true, true)) {
            if(notify.ValueExists(L"DllName")) {
                notifies.emplace_back(RegistryValue{ notify, L"DllName", *notify.GetValue<std::wstring>(L"DllName") });
            }
        }

        for(auto& detection : notifies) {
            // Weak contextual certainty due to how rarely these values are used legitimately
            CREATE_DETECTION(Certainty::Weak, RegistryDetectionData{ detection, RegistryDetectionType::FileReference });
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    void HuntT1547::Subtechnique005(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(005, Security Support Provider);

        SUBSECTION_INIT(SSP, Cursory);
        RegistryKey lsa3{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
        RegistryKey lsa4{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig" };

        for(auto& key : { lsa3, lsa4 }) {
            auto packages{ key.GetValue<std::vector<std::wstring>>(L"Security Packages") };
            if(packages) {
                for(auto& package : *packages) {
                    if(package != L"\"\"") {
                        auto filepath = FileSystem::SearchPathExecutable(package + L".dll");

                        if(filepath && FileScanner::PerformQuickScan(*filepath)) {
                            // Can't use a macro since we need the shared_ptr of the detection
                            auto value{ Bluespawn::detections.AddDetection(
                                Detection{ RegistryDetectionData{
                                               RegistryValue{ key, L"Security Packages", std::move(package) },
                                               RegistryDetectionType::FileReference },
                                           DetectionContext{ __name } },
                                Certainty::Moderate) };
                            detections.emplace_back(value);

                            // Since the security package is missing the dll extension, the scanner may not find the
                            // associated file
                            auto file{ Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ *filepath },
                                                                                     DetectionContext{ __name } },
                                                                          Certainty::Weak) };
                            detections.emplace_back(file);

                            // Define the association ourself
                            file->info.AddAssociation(value, Association::Certain);
                            value->info.AddAssociation(file, Association::Certain);
                        }
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    void HuntT1547::Subtechnique010(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(010, Port Monitors);

        SUBSECTION_INIT(PORT_MON, Cursory);
        RegistryKey monitors{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors" };

        for(auto monitor : monitors.EnumerateSubkeys()) {
            if(monitor.ValueExists(L"Driver")) {
                auto filepath{ FileSystem::SearchPathExecutable(monitor.GetValue<std::wstring>(L"Driver").value()) };

                if(filepath && FileScanner::PerformQuickScan(*filepath)) {
                    CREATE_DETECTION(Certainty::Moderate,
                                     RegistryDetectionData{ *RegistryValue::Create(monitor, L"Driver"),
                                                            RegistryDetectionType::FileReference });
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1547::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique001(scope, detections);
        Subtechnique002(scope, detections);
        Subtechnique003(scope, detections);
        Subtechnique004(scope, detections);
        Subtechnique005(scope, detections);
        Subtechnique010(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1547::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1547.001: Registry Run Keys / Startup Folder
        for(auto key : RunKeys) {
            GetRegistryEvents(events, SCOPE(RUN_KEY), HKEY_LOCAL_MACHINE, key);
        }
        GetRegistryEvents(events, SCOPE(COMMAND_PROCESSOR), HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Command Processor");
        GetRegistryEvents(events, SCOPE(STARTUP_FOLDER), HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
        GetRegistryEvents(events, SCOPE(STARTUP_FOLDER), HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
        auto userFolders = FileSystem::Folder(L"C:\\Users").GetSubdirectories(1);
        for(auto userFolder : userFolders) {
            FileSystem::Folder folder{ userFolder.GetFolderPath() + L"\\AppData\\Roaming\\Microsoft\\Windows\\Start "
                                                                    L"Menu\\Programs\\StartUp" };
            if(folder.GetFolderExists()) {
                events.push_back(
                    std::make_pair(std::make_unique<FileEvent>(folder), SCOPE(STARTUP_ITEMS)));
            }
        }

        // Looks for T1547.002 (Authentication Package) and T1547.005 (Security Support Provider)
        GetRegistryEvents(events, Scope::CreateSubhuntScope((1 << SSP) | (1 << AUTH_PACKAGE)), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\Lsa", false, false);
        GetRegistryEvents(events, Scope::CreateSubhuntScope((1 << SSP) | (1 << AUTH_PACKAGE)), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig", false, false);
        GetRegistryEvents(events, SCOPE(LSA_EXTENSION), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\LsaExtensionConfig", false, false);

        // Looks for T1547.003: Time Provider
        GetRegistryEvents(events, SCOPE(TIME_PROV), HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders", false, false, true);

        // Looks for T1547.004: Winlogon Helper DLL
        GetRegistryEvents(events, SCOPE(WINLOGON), HKEY_LOCAL_MACHINE,
                          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
        GetRegistryEvents(events, SCOPE(WINLOGON_NOTIFY), HKEY_LOCAL_MACHINE,
                          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify", true, true, true);

        // Looks for T1547.010: Port Monitors
        GetRegistryEvents(events, SCOPE(PORT_MON), HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors", false, false, true);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1548.cpp`:

```cpp
#include "hunt/hunts/HuntT1548.h"

#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"

#include "util/eventlogs/EventLogs.h"
#include "util/processes/ProcessUtils.h"

#include "user/bluespawn.h"

#define FODHELPER 0
#define EVT_VIEWER_REGISTRY 1
#define SDCLT_REGISTRY 2

using namespace Registry;

namespace Hunts {
	HuntT1548::HuntT1548() : Hunt(L"T1548 - Abuse Elevation Control Mechanism") {
		dwCategoriesAffected = (DWORD)Category::Processes | (DWORD)Category::Configurations;
		dwSourcesInvolved = (DWORD)DataSource::Processes | (DWORD)DataSource::Registry;
		dwTacticsUsed = (DWORD)Tactic::PrivilegeEscalation | (DWORD)Tactic::DefenseEvasion;
	}

	void HuntT1548::Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(002, Bypass User Access Control);

		SUBSECTION_INIT(FODHELPER, Cursory);

		// Reference: https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/
		// Test Commands:
		//		1. reg add "HKCU\SOFTWARE\Classes\ms-settings\shell\open\command" /v "DelegateExecute"
		//		2. reg add "HKCU\SOFTWARE\Classes\ms-settings\shell\open\command" /ve /t REG_SZ /d "cmd.exe" 
		RegistryKey msSettingsCommand{ HKEY_CURRENT_USER, L"SOFTWARE\\Classes\\ms-settings\\shell\\open\\command" };
        if(msSettingsCommand.ValueExists(L"DelegateExecute")) {
            for(auto& detection :
                CheckValues(HKEY_CURRENT_USER, L"SOFTWARE\\Classes\\ms-settings\\shell\\open\\command",
                            { { DEFAULT, L"REG_SZ", false, CheckSzEmpty } }, true, true)) {
                CREATE_DETECTION(Certainty::Strong,
                                 RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
            }
        }

        SUBSECTION_END();

		// Reference: https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/
		// Test Command: reg add "HKCU\SOFTWARE\Classes\mscfile\shell\open\command" /ve /t REG_SZ /d "cmd.exe" 
		// Metasploit module: https://www.exploit-db.com/exploits/40268
        SUBSECTION_INIT(EVT_VIEWER_REGISTRY, Cursory);

		for(RegistryValue& detection :
            CheckValues(HKEY_CURRENT_USER, L"SOFTWARE\\Classes\\mscfile\\shell\\open\\command",
                        { { DEFAULT, L"REG_SZ", false, CheckSzEmpty } }, false, false)) {
            CREATE_DETECTION(Certainty::Strong,
                             RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
        }

		SUBSECTION_END();

		// Reference: https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/
		// Test Command: reg add "HKCU\SOFTWARE\Classes\exefile\shell\runas\command" /v "IsolatedCommand" /t REG_SZ /d "cmd.exe" 
		SUBSECTION_INIT(SDCLT_REGISTRY, Cursory);

        for(auto& detection : CheckValues(HKEY_CURRENT_USER, L"SOFTWARE\\Classes\\exefile\\shell\\runas\\command",
                                          { { L"IsolatedCommand", L"REG_SZ", false, CheckSzEmpty } }, true, true)) {
            CREATE_DETECTION(Certainty::Strong,
                             RegistryDetectionData{ detection, RegistryDetectionType::CommandReference });
        }
		SUBSECTION_END();

		SUBTECHNIQUE_END();
	}
	std::vector<std::shared_ptr<Detection>> HuntT1548::RunHunt(const Scope& scope)
	{
		HUNT_INIT();

		Subtechnique002(scope, detections);

		HUNT_END();
	}
	std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1548::GetMonitoringEvents()
	{
		std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        GetRegistryEvents(events, SCOPE(FODHELPER), HKEY_CURRENT_USER,
                          L"SOFTWARE\\Classes\\ms-settings\\shell\\open\\command", true, true, true);

        GetRegistryEvents(events, SCOPE(EVT_VIEWER_REGISTRY), HKEY_CURRENT_USER,
                          L"SOFTWARE\\Classes\\mscfile\\shell\\open\\command", true, true);

		GetRegistryEvents(events, SCOPE(SDCLT_REGISTRY), HKEY_CURRENT_USER,
                          L"SOFTWARE\\Classes\\exefile\\shell\\runas\\command", true, true);

		return events;
	}
}
```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1553.cpp`:

```cpp
#include "hunt/hunts/HuntT1553.h"

#include <map>
#include <queue>
#include <vector>

#include "util/StringUtils.h"
#include "util/Utils.h"
#include "util/configurations/Registry.h"
#include "util/filesystem/Filesystem.h"
#include "util/log/Log.h"
#include "util/processes/ProcessUtils.h"

#include "../resources/resource.h"
#include "hunt/RegistryHunt.h"
#include "user/bluespawn.h"

using namespace Registry;

#define SIPS 0
#define PROVIDERS 1
#define SIGNED 2

namespace Hunts {

    HuntT1553::HuntT1553() : Hunt(L"T1553 - Subvert Trust Controls") {
        dwCategoriesAffected = (DWORD) Category::Configurations;
        dwSourcesInvolved = (DWORD) DataSource::Registry;
        dwTacticsUsed = (DWORD) Tactic::Persistence | (DWORD) Tactic::DefenseEvasion;
    }

    std::wstring GetResource(DWORD identifier) {
        auto hRsrcInfo = FindResourceW(nullptr, MAKEINTRESOURCE(identifier), L"textfile");
        if(!hRsrcInfo) {
            return { nullptr, 0 };
        }

        auto hRsrc = LoadResource(nullptr, hRsrcInfo);
        if(!hRsrc) {
            return { nullptr, 0 };
        }

        return StringToWidestring(
            { reinterpret_cast<LPCSTR>(LockResource(hRsrc)), SizeofResource(nullptr, hRsrcInfo) });
    }

    std::unordered_map<std::wstring, std::unordered_map<std::wstring, std::pair<std::wstring, std::wstring>>>
    ParseResource(DWORD dwResourceID) {
        auto resource{ GetResource(dwResourceID) };

        std::unordered_map<std::wstring, std::unordered_map<std::wstring, std::pair<std::wstring, std::wstring>>> map{};

        auto lines{ SplitStringW(resource, L"\n") };
        for(auto& line : lines) {
            std::unordered_map<std::wstring, std::pair<std::wstring, std::wstring>> values;
            auto type{ line.substr(0, line.find(L":")) };
            auto entries{ SplitStringW(line.substr(line.find(L":") + 1), L" ") };
            for(auto& entry : entries) {
                auto parts{ SplitStringW(entry, L",") };
                auto path{ FileSystem::SearchPathExecutable(parts[1]) };
                if(path) {
                    values.emplace(parts[0], std::pair<std::wstring, std::wstring>{ ToLowerCaseW(*path), parts[2] });
                } else {
                    values.emplace(parts[0], std::pair<std::wstring, std::wstring>{ ToLowerCaseW(parts[1]), parts[2] });
                }
            }
            map.emplace(type, std::move(values));
        }

        return map;
    }

    void HuntT1553::Subtechnique003(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(3, SIP and Trust Provider Hijacking);

        std::unordered_map<std::wstring, std::vector<std::pair<RegistryValue, std::wstring>>> files{};

        // Verify SIPs
        SUBSECTION_INIT(SIPS, Intensive);
        auto goodSIP{ ParseResource(GoodSIP) };
        for(auto keypath : { L"SOFTWARE\\Microsoft\\Cryptography\\OID\\EncodingType 0",
                             L"SOFTWARE\\WoW6432Node\\Microsoft\\Cryptography\\OID\\EncodingType 0" }) {
            RegistryKey key{ HKEY_LOCAL_MACHINE, keypath };
            for(auto subkey : key.EnumerateSubkeyNames()) {
                if(goodSIP.find(subkey) != goodSIP.end()) {
                    auto& entry{ goodSIP.at(subkey) };
                    RegistryKey SIPType{ key, subkey };

                    for(auto GUID : SIPType.EnumerateSubkeyNames()) {
                        RegistryKey GUIDInfo{ SIPType, GUID };
                        auto dll{ RegistryValue::Create(GUIDInfo, L"Dll") };
                        auto func{ RegistryValue::Create(GUIDInfo, L"FuncName") };
                        GUID = GUID.substr(1, GUID.length() - 2);

                        if(entry.find(GUID) != entry.end()) {
                            auto& pair{ entry.at(GUID) };
                            if(func && func->ToString() != pair.second) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *func, RegistryDetectionType::Configuration },
                                    DetectionContext{ __name },
                                    [GUIDInfo, pair](){ GUIDInfo.SetValue(L"FuncName", pair.second); });
                            }

                            if(dll) {
                                if(files.find(dll->ToString()) == files.end()) {
                                    files.emplace(dll->ToString(),
                                                  std::vector<std::pair<RegistryValue, std::wstring>>{
                                                      std::pair<RegistryValue, std::wstring>{ *dll, pair.first } });
                                } else {
                                    files.at(dll->ToString())
                                        .emplace_back(std::pair<RegistryValue, std::wstring>{ *dll, pair.first });
                                }
                            }
                        } else {
                            auto message{ L"Nonstandard subject interface provider GUID " + GUID + L" (DLL: " +
                                          dll->ToString() + L", Function: " + func->ToString() + L")" };

                            if(func) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *func, RegistryDetectionType::Configuration },
                                    DetectionContext{ __name, std::nullopt, message });
                            }

                            if(dll) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *dll, RegistryDetectionType::FileReference },
                                    DetectionContext{ __name, std::nullopt, message });
                            }
                        }
                    }
                }
            }
        }
        SUBSECTION_END();

        // Verify trust providers
        SUBSECTION_INIT(PROVIDERS, Intensive);
        auto goodTrustProviders{ ParseResource(GoodTrustProviders) };
        for(auto keypath : { L"SOFTWARE\\Microsoft\\Cryptography\\Providers\\Trust",
                             L"SOFTWARE\\WoW6432Node\\Microsoft\\Cryptography\\Providers\\Trust" }) {
            RegistryKey key{ HKEY_LOCAL_MACHINE, keypath };
            for(auto& subkey : key.EnumerateSubkeyNames()) {
                if(goodTrustProviders.find(subkey) != goodTrustProviders.end()) {
                    auto& entry{ goodTrustProviders.at(subkey) };
                    RegistryKey ProviderType{ key, subkey };

                    for(auto& GUID : ProviderType.EnumerateSubkeyNames()) {
                        RegistryKey GUIDInfo{ ProviderType, GUID };
                        auto dll{ RegistryValue::Create(GUIDInfo, L"$DLL") };
                        auto func{ RegistryValue::Create(GUIDInfo, L"$Function") };
                        GUID = GUID.substr(1, GUID.length() - 2);

                        if(entry.find(GUID) != entry.end()) {
                            auto& pair{ entry.at(GUID) };
                            if(func && func->ToString() != pair.second) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *func, RegistryDetectionType::Configuration },
                                    DetectionContext{ __name },
                                    [GUIDInfo, pair](){ GUIDInfo.SetValue(L"$Function", pair.second); });
                            }

                            if(files.find(dll->ToString()) == files.end()) {
                                files.emplace(dll->ToString(),
                                              std::vector<std::pair<RegistryValue, std::wstring>>{
                                                  std::pair<RegistryValue, std::wstring>{ *dll, pair.first } });
                            } else {
                                files.at(dll->ToString())
                                    .emplace_back(std::pair<RegistryValue, std::wstring>{ *dll, pair.first });
                            }
                        } else {
                            auto message{ L"Nonstandard trust provider GUID " + GUID + L" for " + subkey + L" (DLL: " +
                                          dll->ToString() + L", Function: " + func->ToString() + L")" };
                            if(func) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *func, RegistryDetectionType::Configuration },
                                    DetectionContext{ __name, std::nullopt, message });
                            }

                            if(dll) {
                                CREATE_DETECTION_WITH_CONTEXT(
                                    Certainty::Strong,
                                    RegistryDetectionData{ *dll, RegistryDetectionType::FileReference },
                                    DetectionContext{ __name, std::nullopt, message });
                            }
                        }
                    }
                }
            }
        }
        SUBSECTION_END();

        // Verify collection of DLLs
        for(auto& pair : files) {
            auto dllpath{ FileSystem::SearchPathExecutable(pair.first) };
            if(!dllpath) {
                auto message{ L"DLL " + pair.first + L" not found and may be a target for hijacking" };

                // Assume the worst - if the DLL path isn't found, it's because there's a target process that WILL find it
                for(auto& value : pair.second) {
                    CREATE_DETECTION_WITH_CONTEXT(
                        Certainty::Weak, RegistryDetectionData{ value.first, RegistryDetectionType::FileReference },
                        DetectionContext{ __name, std::nullopt, message });
                }
            } else {
                dllpath = ToLowerCaseW(*dllpath);
                auto location{ dllpath->find(L"syswow64") };
                if(location != std::wstring::npos) {
                    dllpath->replace(dllpath->begin() + location, dllpath->begin() + location + 8, L"system32");
                }
                for(auto& value : pair.second) {
                    if(dllpath != value.second &&
                       (dllpath->length() >= value.second.length() &&
                        dllpath->substr(dllpath->length() - value.second.length()) != value.second)) {
                        auto message{ L"Path for dll " + *dllpath + L" does not match " + value.second +
                                      L" and may have been hijacked" };
                        CREATE_DETECTION_WITH_CONTEXT(
                            Certainty::Weak, RegistryDetectionData{ value.first, RegistryDetectionType::FileReference },
                            DetectionContext{ __name, std::nullopt, message });
                    }
                }
            }
        }

        // Ensure only Microsoft signed DLLs are used here
        SUBSECTION_INIT(SIGNED, Intensive);
        std::vector<std::wstring> keypaths{ L"SOFTWARE\\Microsoft\\Cryptography\\OID\\EncodingType 0",
                                            L"SOFTWARE\\Microsoft\\Cryptography\\Providers\\Trust" };
        for(auto keypath : keypaths) {
            for(auto key : CheckSubkeys(HKEY_LOCAL_MACHINE, keypath, true, false)) {
                std::queue<RegistryKey> keys{};
                keys.emplace(key);

                while(keys.size()) {
                    auto check{ keys.front() };
                    keys.pop();

                    for(auto val : check.EnumerateValues()) {
                        auto type{ check.GetValueType(val) };
                        if(type == RegistryType::REG_SZ_T || type == RegistryType::REG_EXPAND_SZ_T) {
                            auto path{ FileSystem::SearchPathExecutable(*check.GetValue<std::wstring>(val)) };
                            if(path) {
                                if(!FileSystem::File(*path).IsMicrosoftSigned()) {
                                    CREATE_DETECTION(Certainty::Strong,
                                                     RegistryDetectionData{ *RegistryValue::Create(check, val),
                                                                            RegistryDetectionType::FileReference });
                                }
                            } else if(ToLowerCaseW(val).find(L"dll") != std::wstring::npos) {
                                CREATE_DETECTION(Certainty::Strong,
                                                 RegistryDetectionData{ *RegistryValue::Create(check, val),
                                                                        RegistryDetectionType::FileReference });
                            }
                        }
                    }
                    for(auto subkey : check.EnumerateSubkeys()) {
                        keys.emplace(subkey);
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1553::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique003(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1553::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        Registry::GetRegistryEvents(events, Scope::CreateSubhuntScope((1 << SIPS) | (1 << SIGNED)), HKEY_LOCAL_MACHINE,
                                    L"SOFTWARE\\Microsoft\\Cryptography\\OID\\EncodingType 0", true, false, true);
        Registry::GetRegistryEvents(events, Scope::CreateSubhuntScope((1 << PROVIDERS) | (1 << SIGNED)),
                                    HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Cryptography\\Providers\\Trust", true,
                                    false, true);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1562.cpp`:

```cpp
#include "hunt/hunts/HuntT1562.h"

#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "scan/FileScanner.h"
#include "user/bluespawn.h"

using namespace Registry;

#define REGISTRY_FIREWALL 0

namespace Hunts {

    HuntT1562::HuntT1562() : Hunt(L"T1562 - Impair Defenses") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Network;
        dwSourcesInvolved = (DWORD) DataSource::Registry;
        dwTacticsUsed = (DWORD) Tactic::DefenseEvasion;
    }

    void HuntT1562::Subtechnique004(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(004, Disable or Modify System Firewall);

        SUBSECTION_INIT(REGISTRY_FIREWALL, Normal);
        RegistryKey DomainProfile{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters"
                                                       L"\\FirewallPolicy\\DomainProfile" };
        RegistryKey StandardProfile{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameter"
                                                         L"s\\FirewallPolicy\\StandardProfile" };
        RegistryKey PublicProfile{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters"
                                                       L"\\FirewallPolicy\\PublicProfile" };

        for(auto key : { DomainProfile, StandardProfile, PublicProfile }) {
            RegistryKey allowedapps{ key, L"AuthorizedApplications\\List" };
            if(allowedapps.Exists()) {
                for(auto ProgramException : allowedapps.EnumerateValues()) {
                    CREATE_DETECTION(Certainty::Strong,
                                     RegistryDetectionData{ *RegistryValue::Create(allowedapps, ProgramException),
                                                            RegistryDetectionType::Configuration });
                    if(FileScanner::PerformQuickScan(ProgramException)) {
                        CREATE_DETECTION(Certainty::Weak, FileDetectionData{ ProgramException });
                    }
                }
            }

            auto ports = RegistryKey{ key, L"GloballyOpenPorts\\List" };
            if(ports.Exists()) {
                for(auto PortsException : ports.EnumerateValues()) {
                    CREATE_DETECTION(Certainty::Strong,
                                     RegistryDetectionData{ *RegistryValue::Create(ports, PortsException),
                                                            RegistryDetectionType::Configuration });
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1562::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique004(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1562::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        Registry::GetRegistryEvents(events, SCOPE(REGISTRY_FIREWALL), HKEY_LOCAL_MACHINE,
                                    L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\Do"
                                    L"mainProfile",
                                    false, false, true);
        Registry::GetRegistryEvents(events, SCOPE(REGISTRY_FIREWALL), HKEY_LOCAL_MACHINE,
                                    L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\St"
                                    L"andardProfile",
                                    false, false, true);
        Registry::GetRegistryEvents(events, SCOPE(REGISTRY_FIREWALL), HKEY_LOCAL_MACHINE,
                                    L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\Pu"
                                    L"blicProfile",
                                    false, false, true);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/hunt/hunts/HuntT1569.cpp`:

```cpp
#include "hunt/hunts/HuntT1569.h"

#include "util/Utils.h"
#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"
#include "util/processes/CheckLolbin.h"
#include "util/processes/ProcessUtils.h"

#include "hunt/RegistryHunt.h"
#include "scan/FileScanner.h"
#include "scan/ProcessScanner.h"
#include "user/bluespawn.h"

using namespace Registry;

#define REGISTRY_SERVICES 0

namespace Hunts {
    HuntT1569::HuntT1569() : Hunt(L"T1569 - Service Execution") {
        dwCategoriesAffected = (DWORD) Category::Configurations | (DWORD) Category::Files | (DWORD) Category::Processes;
        dwSourcesInvolved = (DWORD) DataSource::Registry | (DWORD) DataSource::FileSystem;
        dwTacticsUsed = (DWORD) Tactic::Execution;
    }

    void HuntT1569::Subtechnique002(IN CONST Scope& scope, OUT std::vector<std::shared_ptr<Detection>>& detections) {
        SUBTECHNIQUE_INIT(2, Service Execution);

        SUBSECTION_INIT(REGISTRY_SERVICES, Normal);
        auto services = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" };

        for(auto service : services.EnumerateSubkeys()) {
            if(service.GetValue<DWORD>(L"Type") >= 0x10u) {
                auto cmd{ Registry::RegistryValue::Create(service, L"ImagePath") };
                if(ProcessScanner::PerformQuickScan(cmd->ToString())) {
                    CREATE_DETECTION(Certainty::Moderate,
                                     RegistryDetectionData{ *cmd, RegistryDetectionType::CommandReference });
                }

                RegistryKey subkey = RegistryKey{ service, L"Parameters" };
                for(auto regkey : { service, subkey }) {
                    auto svcdll{ Registry::RegistryValue::Create(regkey, L"ServiceDll") };
                    if(svcdll && FileScanner::PerformQuickScan(svcdll->ToString())) {
                        CREATE_DETECTION(Certainty::Moderate,
                                         RegistryDetectionData{ *svcdll, RegistryDetectionType::FileReference });
                    }
                }
            }
        }
        SUBSECTION_END();

        SUBTECHNIQUE_END();
    }

    std::vector<std::shared_ptr<Detection>> HuntT1569::RunHunt(const Scope& scope) {
        HUNT_INIT();

        Subtechnique002(scope, detections);

        HUNT_END();
    }

    std::vector<std::pair<std::unique_ptr<Event>, Scope>> HuntT1569::GetMonitoringEvents() {
        std::vector<std::pair<std::unique_ptr<Event>, Scope>> events;

        // Looks for T1569.002: Service Execution
        GetRegistryEvents(events, SCOPE(REGISTRY_SERVICES), HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services",
                          false, false, true);

        return events;
    }
}   // namespace Hunts

```

`BLUESPAWN-win-client/src/mitigation/Mitigation.cpp`:

```cpp
#include "mitigation/Mitigation.h"

#include "mitigation/MitigationRegister.h"
#include "mitigation/policy/ValuePolicy.h"
#include "mitigation/policy/SubkeyPolicy.h"
#include "mitigation/policy/CombinePolicy.h"
#include "mitigation/policy/EventLogPolicy.h"

#include "util/StringUtils.h"

Mitigation::Mitigation(const std::wstring& name,
                       const std::wstring& description,
                       const Software& software,
                       std::vector<std::unique_ptr<MitigationPolicy>> policies) :
    name{ name },
    description{ description }, software{ software } {
    for(auto& policy : policies){
        this->policies.emplace_back(std::move(policy));
    }
}

Mitigation::Mitigation(json mitigation) : software(L"", L""){
    assert(mitigation.find("name") != mitigation.end());
    assert(mitigation.find("description") != mitigation.end());
    assert(mitigation.find("software") != mitigation.end());
    assert(mitigation.find("policies") != mitigation.end());

    name = StringToWidestring(mitigation["name"].get<std::string>());
    description = StringToWidestring(mitigation["description"].get<std::string>());
    if(mitigation["software"].get<std::string>() == "Windows"){
        software = WindowsOS();
    } else{
        software = Software(StringToWidestring(mitigation["software"].get<std::string>()), 
                            StringToWidestring(mitigation["software-description"].get<std::string>()));
    }
    for(auto& policy : mitigation["policies"]){
        assert(policy.find("policy-type") != policy.end());

        auto type{ policy["policy-type"].get<std::string>() };
        if(type == "registry-value-policy"){
            policies.emplace_back(std::make_unique<ValuePolicy>(policy));
        } else if(type == "registry-subkey-policy"){
            policies.emplace_back(std::make_unique<SubkeyPolicy>(policy));
        } else if(type == "combined-policy"){
            policies.emplace_back(std::make_unique<CombinePolicy>(policy));
        } else if(type == "event-log"){
            policies.emplace_back(std::make_unique<EventLogPolicy>(policy));
        } else{
            throw std::exception(("Unknown mitigation policy type \"" + type + "\"").c_str());
        }
    }
}

std::wstring Mitigation::GetName() const {
    return this->name;
}

std::wstring Mitigation::GetDescription() const {
    return this->description;
}

bool Mitigation::MitigationApplies() const {
    if(!software.IsPresent()) {
        return false;
    }
    auto version{ software.GetVersion() };
    for(auto& policy : policies) {
        if(policy->GetVersionMatch(version)) {
            return true;
        }
    }
    return false;
}

MitigationReport Mitigation::AuditMitigation(const MitigationConfiguration& config) const {
    MitigationReport report{};
    auto version{ software.GetVersion() };
    for(auto& policy : policies) {
        if(policy->GetVersionMatch(version)) {
            try {
                auto match{ policy->MatchesSystem() };
                if(config.manuals.find(policy.get()) != config.manuals.end() ?
                       config.manuals.at(policy.get()) :
                       config.defaultEnforcement >= policy->GetEnforcementLevel()) {
                    report.results.emplace(policy.get(), match ? MitigationReport::PolicyStatus::MatchRequired :
                                                                 MitigationReport::PolicyStatus::NoMatchRequired);
                } else {
                    report.results.emplace(policy.get(), match ? MitigationReport::PolicyStatus::MatchUnrequired :
                                                                 MitigationReport::PolicyStatus::NoMatchUnrequired);
                }
            } catch(std::exception& e) { report.results.emplace(policy.get(), MitigationReport::PolicyStatus::Failed); }
        }
    }
    return report;
}

MitigationReport Mitigation::EnforceMitigation(const MitigationConfiguration& config) const {
    MitigationReport report{ AuditMitigation(config) };
    for(auto& result : report.results) {
        if(result.second == MitigationReport::PolicyStatus::NoMatchRequired ||
           result.second == MitigationReport::PolicyStatus::Failed) {
            try {
                report.results.at(result.first) = result.first->Enforce() ?
                                                      MitigationReport::PolicyStatus::Changed :
                                                      MitigationReport::PolicyStatus::ChangeFailed;
            } catch(std::exception& e) {
                report.results.at(result.first) = MitigationReport::PolicyStatus::ChangeFailed;
            }
        }
    }
    return report;
}

std::vector<MitigationPolicy*> Mitigation::GetPolicies() const {
    std::vector<MitigationPolicy*> copy{};
    for(auto& policy : policies){
        copy.emplace_back(policy.get());
    }
    return copy;
}

bool MitigationReport::Success() const{
    for(auto& pair : results){
        if(pair.second == MitigationReport::PolicyStatus::ChangeFailed ||
           pair.second == MitigationReport::PolicyStatus::Failed){
            return false;
        }
    }
    return true;
}
```

`BLUESPAWN-win-client/src/mitigation/MitigationRegister.cpp`:

```cpp
#include "mitigation/MitigationRegister.h"

#include "util/StringUtils.h"
#include "util/log/Log.h"
#include "util/permissions/permissions.h"

#include "../resources/resource.h"
#include "nlohmann/json.hpp"
#include "user/CLI.h"
#include "user/bluespawn.h"

using json = nlohmann::json;

EnforcementLevel ParseLevelName(const std::string& levelString) {
    EnforcementLevel level;
    if(levelString == "none") {
        level = EnforcementLevel::None;
    } else if(levelString == "low") {
        level = EnforcementLevel::Low;
    } else if(levelString == "moderate") {
        level = EnforcementLevel::Moderate;
    } else if(levelString == "high") {
        level = EnforcementLevel::High;
    } else if(levelString == "all") {
        level = EnforcementLevel::All;
    } else if(Bluespawn::io.GetUserConfirm(L"Unknown enforcement level: " + StringToWidestring(levelString) +
                                               L"; Set to moderate?",
                                           -1, ImportanceLevel::MEDIUM) == 1) {
        level = EnforcementLevel::Moderate;
    } else {
        Bluespawn::io.InformUser(L"Setting enforcement level to none", ImportanceLevel::HIGH);
        level = EnforcementLevel::None;
    }
    return level;
}

MitigationsConfiguration::MitigationsConfiguration(json config) {
    auto level{ EnforcementLevel::None };
    if(config.find("default-enforcement-level") != config.end()) {
        auto levelString{ ToLowerCaseA(config["default-enforcement-level"].get<std::string>()) };
        level = ParseLevelName(levelString);
    } else {
        Bluespawn::io.InformUser(L"Enforcing no mitigations by default", ImportanceLevel::HIGH);
    }

    for(auto& mitigation : Bluespawn::mitigationRecord.registeredMitigations) {
        configurations.emplace(&mitigation, MitigationConfiguration{ level });
    }

    if(config.find("mitigations") != config.end()) {
        for(auto& mitigationConfig : config["mitigations"]) {
            if(mitigationConfig.find("name") == mitigationConfig.end()) {
                Bluespawn::io.InformUser(L"Skipping malformed mitigation configuration; missing name",
                                         ImportanceLevel::HIGH);
            }

            auto& name{ StringToWidestring(mitigationConfig.at("name").get<std::string>()) };
            bool found{ false };
            for(auto& mitigation : configurations) {
                if(CompareIgnoreCaseW(name, mitigation.first->GetName())) {
                    found = true;

                    if(mitigationConfig.find("enforcement-level") != mitigationConfig.end()) {
                        mitigation.second.defaultEnforcement =
                            ParseLevelName(ToLowerCaseA(mitigationConfig["enforcement-level"].get<std::string>()));
                    }

                    if(mitigationConfig.find("overrides") != mitigationConfig.end()) {
                        for(auto& override : mitigationConfig["overrides"]) {
                            if(override.find("enabled") == override.end()) {
                                Bluespawn::io.InformUser(L"Skipping malformed override policy configuration; missing "
                                                         "`enabled`",
                                                         ImportanceLevel::HIGH);
                            }
                            if(override.find("policy-name") != override.end()) {
                                auto policyName{ StringToWidestring(override.at("policy-name").get<std::string>()) };
                                bool policyFound{ false };
                                for(auto& policy : mitigation.first->GetPolicies()) {
                                    if(CompareIgnoreCaseW(policy->GetPolicyName(), policyName)) {
                                        policyFound = true;
                                        mitigation.second.manuals.emplace(policy, override.at("enabled").get<bool>());
                                    }
                                }
                                if(!policyFound) {
                                    Bluespawn::io.InformUser(L"Skipping override policy configuration for \"" +
                                                                 policyName + L"\"; unknown name",
                                                             ImportanceLevel::HIGH);
                                }
                            } else {
                                Bluespawn::io.InformUser(L"Skipping malformed override policy configuration; missing "
                                                         "`policy-name`",
                                                         ImportanceLevel::HIGH);
                            }
                        }
                    }
                }
            }
            if(!found) {
                Bluespawn::io.InformUser(L"Skipping configuration for \"" + name + L"\"; unknown mitigation",
                                         ImportanceLevel::HIGH);
            }
        }
    }
}

MitigationsConfiguration::MitigationsConfiguration(EnforcementLevel level) {
    for(auto& mitigation : Bluespawn::mitigationRecord.registeredMitigations) {
        configurations.emplace(&mitigation, MitigationConfiguration{ level });
    }
}

MitigationRegister::MitigationRegister() {}

void MitigationRegister::Initialize() {
    auto hRsrcInfo = FindResourceW(nullptr, MAKEINTRESOURCE(DefaultMitigations), L"textfile");
    if(!hRsrcInfo) {
        LOG_ERROR("Unable to load default mitigations");
        throw std::exception("Unable to load default mitigations");
    }

    auto hRsrc = LoadResource(nullptr, hRsrcInfo);
    if(!hRsrc) {
        Bluespawn::io.AlertUser(L"Unable to load default mitigations!", -1, ImportanceLevel::HIGH);
        LOG_ERROR("Unable to load default mitigations");
        throw std::exception("Unable to load default mitigations");
    }

    ParseMitigationsJSON(AllocationWrapper{ LockResource(hRsrc), SizeofResource(nullptr, hRsrcInfo) });
}

std::map<Mitigation*, MitigationReport>
MitigationRegister::EnforceMitigations(const MitigationsConfiguration& config) const {
    std::map<Mitigation*, MitigationReport> results;
    for(auto& mitigation : config.configurations) {
        results.emplace(mitigation.first, mitigation.first->EnforceMitigation(mitigation.second));
    }
    return results;
}

std::map<Mitigation*, MitigationReport>
MitigationRegister::AuditMitigations(const MitigationsConfiguration& config) const {
    std::map<Mitigation*, MitigationReport> results;
    for(auto& mitigation : config.configurations) {
        results.emplace(mitigation.first, mitigation.first->AuditMitigation(mitigation.second));
    }
    return results;
}

void MitigationRegister::PrintMitigationReports(const std::map<Mitigation*, MitigationReport>& reports) const {
    std::wstring output{ L"Mitigation Report:\n" };
    for(auto& pair : reports) {
        output += L"Report for mitigation \"" + pair.first->GetName() + L"\":\n";
        for(auto& policy : pair.second.results) {
            output += L"\tPolicy \"" + policy.first->GetPolicyName() + L"\": ";
            if(policy.second == MitigationReport::PolicyStatus::Changed) {
                output += L"Applied changes\n";
            } else if(policy.second == MitigationReport::PolicyStatus::ChangeFailed) {
                output += L"Failed to apply changes\n";
            } else if(policy.second == MitigationReport::PolicyStatus::Failed) {
                output += L"Failed to audit\n";
            } else if(policy.second == MitigationReport::PolicyStatus::MatchRequired) {
                output += L"System matched required policy\n";
            } else if(policy.second == MitigationReport::PolicyStatus::MatchUnrequired) {
                output += L"System matched unrequired policy\n";
            } else if(policy.second == MitigationReport::PolicyStatus::NoMatchRequired) {
                output += L"System did not match required policy\n";
            } else if(policy.second == MitigationReport::PolicyStatus::NoMatchUnrequired) {
                output += L"System did not match unrequired policy\n";
            } else {
                output += L"Unknown result\n";
            }
        }
    }
    Bluespawn::io.InformUser(output);
}

bool MitigationRegister::ParseMitigationsJSON(const FileSystem::File& file) {
    return ParseMitigationsJSON(file.Read());
}

bool MitigationRegister::ParseMitigationsJSON(const AllocationWrapper& contents) {
    if(contents.GetSize()) {
        try {
            char* buffer = contents.GetAsPointer<char>();
            auto data{ json::parse(nlohmann::detail::span_input_adapter(buffer, contents.GetSize())) };
            if(data.find("mitigations") == data.end()) {
                throw std::exception("unable to find mitigations");
            }
            auto mitigations{ data["mitigations"] };
            for(auto& mitigation : mitigations) {
                registeredMitigations.push_back(Mitigation(mitigation));
            }
            return true;
        } catch(std::exception& e) {
            Bluespawn::io.AlertUser(L"Unable to parse JSON for mitigations! Ensure there are no errors in your "
                                    "configuration file. Error: " + StringToWidestring(e.what()),
                                    -1, ImportanceLevel::HIGH);
            LOG_ERROR("Unable to parse mitigations");
        }
    }
    return false;
}

bool MitigationRegister::CreateConfig(FileSystem::File& file, uint32_t mode) {
    if(!file.GetFileExists()) {
        if(!file.Create()) {
            Bluespawn::io.AlertUser(L"Unable to create configuration file " + file.GetFilePath());
            return false;
        }
    }

    if(!file.HasWriteAccess()) {
        file.TakeOwnership();
        file.GrantPermissions(*Permissions::GetProcessOwner(), GENERIC_WRITE);
    }

    if(!file.HasWriteAccess()) {
        Bluespawn::io.AlertUser(L"Unable to write to configuration file " + file.GetFilePath());
        return false;
    }

    json base;
    base["default-enforcement-level"] = "none";
    if(mode){
        json mitigations = json::array();
        base["mitigations"] = mitigations;
        for(auto& mitigation : registeredMitigations){
            json jsonMitigation;
            jsonMitigation["name"] = WidestringToString(mitigation.GetName());
            jsonMitigation["description"] = WidestringToString(mitigation.GetDescription());
            jsonMitigation["enforcement-level"] = "none";
            if(mode == 2){
                json policies = json::array();
                for(auto& policy : mitigation.GetPolicies()){
                    json jsonPolicy;
                    jsonPolicy["policy-name"] = WidestringToString(policy->GetPolicyName());
                    if(policy->GetDescription()){
                        jsonPolicy["description"] = WidestringToString(*policy->GetDescription());
                    }
                    jsonPolicy["enabled"] = false;
                    policies.emplace_back(jsonPolicy);
                }
                jsonMitigation.emplace("overrides", policies);
            }
            base["mitigations"].emplace_back(jsonMitigation);
        }
    }

    auto dumped{ base.dump(4) };
    return file.Write(dumped.c_str(), 0, dumped.size(), true, false);
}

```

`BLUESPAWN-win-client/src/mitigation/Software.cpp`:

```cpp
#include "mitigation/Software.h"
#include "util/configurations/Registry.h"
#include "util/StringUtils.h"

#include <Windows.h>
#include <Msi.h>

#pragma comment(lib, "Msi.lib")

Version::Version(std::initializer_list<uint32_t> list) : version{ std::move(list) }{}
Version::Version(const std::wstring& versionString){
	auto parts{ SplitStringW(versionString.data(), L".") };
	for(const auto& part : parts){
		version.emplace_back(std::stoi(part));
	}
}
bool Version::operator<(const Version& v) const{
	for(int i = 0; i < version.size(); i++){
		if(i >= v.version.size()){
			if(version[i] != 0){
				return false;
			}
		} else{
			if(version[i] > v.version[i]){
				return false;
			} else if(version[i] < v.version[i]){
				return true;
			}
		}
	}
	for(int i = version.size(); i < v.version.size(); i++){
		if(v.version[i] != 0){
			return true;
		}
	}
	return false;
}
bool Version::operator>(const Version& v) const{
	for(int i = 0; i < version.size(); i++){
		if(i >= v.version.size()){
			if(version[i] != 0){
				return true;
			}
		} else{
			if(version[i] > v.version[i]){
				return true;
			} else if(version[i] < v.version[i]){
				return false;
			}
		}
	}
	for(int i = version.size(); i < v.version.size(); i++){
		if(v.version[i] != 0){
			return false;
		}
	}
	return false;
}
bool Version::operator==(const Version& v) const{
	for(int i = 0; i < version.size(); i++){
		if(i >= v.version.size()){
			if(version[i] != 0){
				return false;
			}
		} else{
			if(version[i] != v.version[i]){
				return false;
			}
		}
	}
	for(int i = version.size(); i < v.version.size(); i++){
		if(v.version[i] != 0){
			return false;
		}
	}
	return true;
}
bool Version::operator<=(const Version& v) const{ return !(*this > v); }
bool Version::operator>=(const Version& v) const{ return !(*this < v); }
bool Version::operator!=(const Version& v) const{ return !(*this == v); }

Software::Software(const std::wstring& name, const std::wstring& description) : 
	name{ name }, description{ description }, present{ false }, version{ std::nullopt }{

	if(!name.length()){
		return;
	}

	WCHAR guid[39];
	for(int i = 0; !MsiEnumProductsW(0, guid); i++){
		DWORD length = 0;
		if(ERROR_MORE_DATA == MsiGetProductInfoW(guid, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, nullptr, &length)){
			std::vector<WCHAR> productName(length += 1);
			if(!MsiGetProductInfoW(guid, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, productName.data(), &length) &&
			   name == productName.data()){
				present = true;
				length = 0;
				if(ERROR_MORE_DATA == MsiGetProductInfoW(guid, INSTALLPROPERTY_VERSIONSTRING, nullptr, &length)){
					std::vector<WCHAR> versionString(length += 1);
					if(!MsiGetProductInfoW(guid, INSTALLPROPERTY_VERSIONSTRING, versionString.data(), &length)){
						try{
							version = Version(versionString.data());
						} catch(std::exception& e){
							version = std::nullopt;
						}
					}
				}
			}
		}
	}
}
bool Software::IsPresent() const {
	return present;
}
std::optional<Version> Software::GetVersion() const{
	return version;
}
WindowsOS::WindowsOS() : Software(L"", L"Base Windows operating system"){
	name = L"Windows";

	auto versionInfoKey{ 
		Registry::RegistryKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WIndows NT\\CurrentVersion") };
	auto majorVer{ *versionInfoKey.GetValue<DWORD>(L"CurrentMajorVersionNumber") };
	auto minorVer{ *versionInfoKey.GetValue<DWORD>(L"CurrentMinorVersionNumber") };
	try{
		auto buildNumber{ 
			static_cast<uint32_t>(std::stoi(*versionInfoKey.GetValue<std::wstring>(L"CurrentBuildNumber"))) };
		version = Version{ majorVer, minorVer, buildNumber };
	} catch(std::exception& e){
		version = Version{ majorVer, minorVer };
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1025.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1025.h"
#include "mitigation/policy/ValuePolicy.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations{
	Mitigation M1025{
		std::wstring(L"M1025 - Privileged Process Integrity"),
		std::wstring(L"Protect processes with high privileges that can be used to interact with critical system components through "
		"use of protected process light, anti-process injection defenses, or other process integrity enforcement "
		"measures."),
		WindowsOS(),
		{
			std::make_unique<RegistryPolicy::ValuePolicy>(
				RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" },
				L"RunAsPPL", 1, RegistryPolicy::ValuePolicy::ValuePolicyType::RequireExact,
				L"Run LSA as PPL", EnforcementLevel::Moderate, L"Run the Local Security Authority as a Protected "
				"Process Lite, preventing process injection and other attacks on lsass.exe's memory", std::nullopt,
				Version{ 6, 3 }
			)
		}
	};
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1028-WFW.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1028-WFW.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateM1028WFW::MitigateM1028WFW() :
		Mitigation(
			L"M1028-WFW - Windows Firewall must be enabled with no exceptions",
			L"The Windows Firewall is an important host-based security control that"
			" should not be disabled. Furthermore, it should not permit exceptions. "
			"Instead, users should create proper rules for specific programs.",
			L"wfw",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::High
		) {}

	bool MitigateM1028WFW::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto DomainProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile" };
		auto StandardProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile" };
		auto PublicProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile" };

		for (auto key : { DomainProfile, StandardProfile, PublicProfile }) {
			// V-17417
			if (!key.ValueExists(L"EnableFirewall") || key.GetValue<DWORD>(L"EnableFirewall") != 1) {
				LOG_VERBOSE(1, L"Value for EnableFirewall is not set to 1 for " << key.ToString());
				return false;
			}
			if (!key.ValueExists(L"DisableNotifications") || key.GetValue<DWORD>(L"DisableNotifications") != 0) {
				LOG_VERBOSE(1, L"Value for DisableNotifications is not set to 0 for " << key.ToString());
				return false;
			}
			// V-17418
			if (!key.ValueExists(L"DefaultInboundAction") || key.GetValue<DWORD>(L"DefaultInboundAction") != 1) {
				LOG_VERBOSE(1, L"Value for DefaultInboundAction is not set to 1 for " << key.ToString());
				return false;
			}
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1028WFW::EnforceMitigation(SecurityLevel level) {
		auto DomainProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile" };
		auto StandardProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile" };
		auto PublicProfile = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile" };

		for (auto key : { DomainProfile, StandardProfile, PublicProfile }) {
			LOG_VERBOSE(1, L"Attempting to set EnableFirewall to 1 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"EnableFirewall", 1)) {
				return false;
			}

			LOG_VERBOSE(1, L"Attempting to set DisableNotifications to 0 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"DisableNotifications", 0)) {
				return false;
			}

			LOG_VERBOSE(1, L"Attempting to set DefaultInboundAction to 1 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"DefaultInboundAction", 1)) {
				return false;
			}
		}

		return true;
	}

	bool MitigateM1028WFW::MitigationApplies(){
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1035-RDP.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1035-RDP.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"
using namespace Registry;
namespace Mitigations {
	MitigateM1035RDP::MitigateM1035RDP() :
		Mitigation(
			L"M1035-RDP - Limit Access to Resource over Network",
			L"This is a High severity finding due to the Bluekeep vulnerability that allows for a worm to quickly move through "
				"a network when NLA is disabled. RDP is a service that allows remote access to Windows computers.",
			L"RDP",
			SoftwareAffected::ExposedService,
			MitigationSeverity::High
		) {}

	bool MitigateM1035RDP::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, L"Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp" };
		if (key.ValueExists(L"UserAuthentication")) {
			auto value = *key.GetValue<DWORD>(L"UserAuthentication");
			if (value == 1) {
				LOG_VERBOSE(1, "NLA is enabled for RDP.");
				return true;
			}
		}
		LOG_VERBOSE(1, "NLA is disabled for RDP.");
		return false;
	}

	bool MitigateM1035RDP::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, L"Enforcing mitigation " << name);
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp" };
		if (key.SetValue<DWORD>(L"UserAuthentication", 1)) {
			LOG_VERBOSE(1, "NLA successfully enabled for RDP.");
			return true;
		}
		else {
			LOG_VERBOSE(1, "Unable to enable NLA for RDP");
			return false;
		}
	}

	bool MitigateM1035RDP::MitigationApplies() {
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1042-LLMNR.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1042-LLMNR.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateM1042LLMNR::MitigateM1042LLMNR() :
		Mitigation(
			L"M1042-LLMNR - Link-Local Multicast Name Resolution (LLMNR) should be disabled",
			L"Link-Local Multicast Name Resolution (LLMNR) serve as alternate methods for "
			"host identification. Adversaries can spoof an authoritative source for name "
			"resolution on a victim network by responding to LLMNR (UDP 5355)/NBT-NS (UDP 137) "
			"traffic as if they know the identity of the requested host.",
			L"llmnr",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Low
		) {}

	bool MitigateM1042LLMNR::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient" };
		std::wstring value = L"EnableMulticast";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 0){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 0.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1042LLMNR::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient" };
		std::wstring value = L"EnableMulticast";
		DWORD data = 0;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 0.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateM1042LLMNR::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1042-NBT.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1042-NBT.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateM1042NBT::MitigateM1042NBT() :
		Mitigation(
			L"M1042-NBT - NetBIOS Name Service (NBT-NS) should be disabled",
			L" NetBIOS Name Service (NBT-NS) serve as alternate methods for "
			"host identification. Adversaries can spoof an authoritative source for name "
			"resolution on a victim network by responding to LLMNR (UDP 5355)/NBT-NS (UDP 137) "
			"traffic as if they know the identity of the requested host.",
			L"nbt",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Low
		) {}

	bool MitigateM1042NBT::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto base = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces" };
		std::wstring value = L"NetbiosOptions";

		for (auto key : base.EnumerateSubkeys()) {
			if (key.GetValue<DWORD>(value) != 2) {
				LOG_VERBOSE(1, L"Value for " << key << value << L" is not set to 2.");
				return false;
			}
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1042NBT::EnforceMitigation(SecurityLevel level) {
		auto base = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces" };
		std::wstring value = L"NetbiosOptions";
		DWORD data = 2;

		int failcount = 0;

		for (auto key : base.EnumerateSubkeys()) {
			if (key.GetValue<DWORD>(value) != 2) {
				LOG_VERBOSE(1, L"Attempting to set " << key << value << L" to 2.");
				if (!key.SetValue<DWORD>(value, data)) {
					LOG_VERBOSE(1, L"Unable to set " << key << value << L" to 2.");
					failcount++; 
				}
			}
		}

		if (failcount == 0) {
			LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
			return true;
		}
		else {
			LOG_VERBOSE(1, L"Failed to enforce " << failcount << L" values for Mitigation " << name);
			return false;
		}
	}

	bool MitigateM1042NBT::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1042-WSH.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1042-WSH.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateM1042WSH::MitigateM1042WSH() :
		Mitigation(
			L"M1042-WSH - Windows Script Host (WSH) should be disabled",
			L"Windows Script Host enables the execution of wscript and cscript "
			"which allow VB, JS, and other scripts to be run. This feature is not "
			"typically needed, and Sean Metcalf recommends disabling it https://adsecurity.org/?p=3299. "
			"This corresponds to M1042.",
			L"wsh",
			SoftwareAffected::InternalService,
			MitigationSeverity::Low
		) {}

	bool MitigateM1042WSH::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		for (auto& detection : CheckValues(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows Script Host\\Settings", {
			{ L"Enabled", 0, true, CheckDwordEqual },
		})) {
			LOG_VERBOSE(1, L"Value for Enabled does not exist or is not set to 0.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1042WSH::EnforceMitigation(SecurityLevel level) {
		for (auto& detection : CheckValues(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows Script Host\\Settings", {
			{ L"Enabled", 0, true, CheckDwordEqual },
		})) {
			LOG_VERBOSE(1, L"Attempting to set Enabled to 0.");
			if (!detection.key.SetValue<DWORD>(L"Enabled", 0)) {
				return false;
			}
		}

		return true;
	}

	bool MitigateM1042WSH::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1047.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1047.h"

#include "util/log/Log.h"
#include "util/configurations/Registry.h"
#include "util/eventlogs/EventLogs.h"

namespace Mitigations {

	MitigateM1047::MitigateM1047() :
		Mitigation(
			L"M1047 - Audit",
			L"checks the registry to ensure that key but optional \
			event log channels are enabled. These sources are used by many Hunts \
			and monitoring services in BLUESPAWN.",
			L"evt",
			SoftwareAffected::InternalService,
			MitigationSeverity::Medium
		) {
	
		channelList.push_back(L"Microsoft-Windows-CertificateServicesClient-Lifecycle-System/Operational");
		channelList.push_back(L"Microsoft-Windows-Bits-Client/Operational");
		channelList.push_back(L"Microsoft-Windows-AppLocker/EXE and DLL");
		channelList.push_back(L"Microsoft-Windows-AppLocker/MSI and Script");
		channelList.push_back(L"Security");
		channelList.push_back(L"System");
		channelList.push_back(L"Microsoft-Windows-Powershell/Operational");
		channelList.push_back(L"Microsoft-Windows-TaskScheduler/Operational");
		channelList.push_back(L"Microsoft-Windows-Windows Defender/Operational");
		channelList.push_back(L"Microsoft-Windows-Windows Defender/Operational");
		channelList.push_back(L"Microsoft-Windows-Windows Firewall With Advanced Security/Firewall");
		channelList.push_back(L"Microsoft-Windows-Sysmon/Operational");
	}

	bool MitigateM1047::MitigationIsEnforced(SecurityLevel level) {
		bool enforced = true;

		// Check if Sysmon service is installed is is not disabled or manual
		auto sysmon64 = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Sysmon64" };
		auto sysmon = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Sysmon" };

		if (!sysmon.Exists() && !sysmon64.Exists()) {
			LOG_VERBOSE(1, L"Sysmon is not installed.");
			enforced = false;
		}
		if (sysmon.Exists() && *sysmon.GetValue<DWORD>(L"Start") >= 3UL || 
			sysmon64.Exists() && *sysmon64.GetValue<DWORD>(L"Start") >= 3UL) {

			LOG_VERBOSE(1, L"Sysmon is set to manual or disabled.");
			enforced = false;
		}

		// Check if EventLog service is enabled and not manual
		auto eventLogService = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EventLog" };
		if (!eventLogService.Exists()) {
			LOG_VERBOSE(1, L"Windows Event Log Service is not installed.");
			enforced = false;
		}
		else if (eventLogService.GetValue<DWORD>(L"Start") >= 3u) {
			LOG_VERBOSE(1, L"Windows Event Log Service is set to manual or disabled.");
			enforced = false;
		}

		for (std::wstring channel : channelList) {
			if (!EventLogs::IsChannelOpen(channel)) {
				LOG_VERBOSE(1, channel + L" is disabled.");
				enforced = false;
			}
		}

		return enforced;
	}

	bool MitigateM1047::EnforceMitigation(SecurityLevel level) {
		bool enforced = true;

		// Ensure Sysmon service is installed is is not disabled or manual
		auto sysmon64 = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Sysmon64" };
		auto sysmon = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Sysmon" };

		if (!sysmon.Exists() && !sysmon64.Exists()) {
			LOG_VERBOSE(1, L"Sysmon is not installed.");
			enforced = false;
		}
		if (sysmon.Exists() && *sysmon.GetValue<DWORD>(L"Start") >= 3UL) {
			LOG_VERBOSE(1, L"Attempting to set SYSTEM\\CurrentControlSet\\Services\\Sysmon\\Start to 2.");
			enforced &= sysmon.SetValue<DWORD>(L"Start", 2);
		}
		if (sysmon64.Exists() && *sysmon64.GetValue<DWORD>(L"Start") >= 3UL) {
			LOG_VERBOSE(1, L"Attempting to set SYSTEM\\CurrentControlSet\\Services\\Sysmon64\\Start to 2.");
			enforced &= sysmon64.SetValue<DWORD>(L"Start", 2);
		}

		// Check if EventLog service is enabled and not manual
		auto eventLogService = Registry::RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EventLog" };
		if (!eventLogService.Exists()) {
			LOG_VERBOSE(1, L"Windows Event Log Service is not installed.");
			enforced = false;
		}
		else if (*eventLogService.GetValue<DWORD>(L"Start") >= 3UL) {
			LOG_VERBOSE(1, L"Attempting to set SYSTEM\\CurrentControlSet\\Services\\EventLog\\Start to 2.");
			enforced &= eventLogService.SetValue<DWORD>(L"Start", 2);
		}

		for (std::wstring channel : channelList) {
			if (!EventLogs::IsChannelOpen(channel)) {
				LOG_VERBOSE(1, L"Attempting to open event log channel " + channel + L".");
				bool result = EventLogs::OpenChannel(channel);
				if (!result) {
					LOG_VERBOSE(1, L"Failed to open event log channel " + channel + L".");
					enforced &= result;
				}
			}
		}

		return enforced;
	}

	bool MitigateM1047::MitigationApplies() {
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1054-RDP.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1054-RDP.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;
namespace Mitigations {
	MitigateM1054RDP::MitigateM1054RDP() :
		Mitigation(
			L"M1054-RDP - Software Configuration (RDP)",
			L"This is a Medium severity finding as remote administrators should not have privilege "
			"other console users for access to a machine in most environments.",
			L"rdp",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Medium
		) {}

	bool MitigateM1054RDP::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services" };
		std::wstring value = L"fDisableForcibleLogoff";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if (key.GetValue<DWORD>(value) != 1) {
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1054RDP::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services" };
		std::wstring value = L"fDisableForcibleLogoff";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateM1054RDP::MitigationApplies() {
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateM1054-WSC.cpp`:

```cpp
#include "mitigation/mitigations/MitigateM1054-WSC.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateM1054WSC::MitigateM1054WSC() :
		Mitigation(
			L"M1054-WSC - Windows Security Center provides appropriate security alerts",
			L"The Windows Security Center provides warnings on basic security settings",
			L"wsc",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Low
		) {}

	bool MitigateM1054WSC::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto WindowsSecurityCenter = RegistryKey{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Security Center" };
		auto WindowsSecurityCenterWow64 = RegistryKey{ HKEY_LOCAL_MACHINE, L"Software\\Wow6432Node\\Microsoft\\Security Center" };

		for (auto key : { WindowsSecurityCenter, WindowsSecurityCenterWow64 }) {
			if (!key.ValueExists(L"AntiSpyWareDisableNotify") || key.GetValue<DWORD>(L"AntiSpyWareDisableNotify") != 0) {
				LOG_VERBOSE(1, L"Value for AntiSpyWareDisableNotify is not set to 0 for " << key.ToString());
				return false;
			}
			if (!key.ValueExists(L"AntiVirusDisableNotify") || key.GetValue<DWORD>(L"AntiVirusDisableNotify") != 0) {
				LOG_VERBOSE(1, L"Value for AntiVirusDisableNotify is not set to 0 for " << key.ToString());
				return false;
			}
			if (!key.ValueExists(L"UacDisableNotify") || key.GetValue<DWORD>(L"UacDisableNotify") != 0) {
				LOG_VERBOSE(1, L"Value for UacDisableNotify is not set to 0 for " << key.ToString());
				return false;
			}
			if (!key.ValueExists(L"FirewallDisableNotify") || key.GetValue<DWORD>(L"FirewallDisableNotify") != 0) {
				LOG_VERBOSE(1, L"Value for FirewallDisableNotify is not set to 0 for " << key.ToString());
				return false;
			}
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateM1054WSC::EnforceMitigation(SecurityLevel level) {
		auto WindowsSecurityCenter = RegistryKey{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Security Center" };
		auto WindowsSecurityCenterWow64 = RegistryKey{ HKEY_LOCAL_MACHINE, L"Software\\Wow6432Node\\Microsoft\\Security Center" };

		for (auto key : { WindowsSecurityCenter, WindowsSecurityCenterWow64 }) {
			LOG_VERBOSE(1, L"Attempting to set AntiSpyWareDisableNotify to 0 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"AntiSpyWareDisableNotify", 0)) {
				return false;
			}

			LOG_VERBOSE(1, L"Attempting to set AntiVirusDisableNotify to 0 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"AntiVirusDisableNotify", 0)) {
				return false;
			}

			LOG_VERBOSE(1, L"Attempting to set UacDisableNotify to 0 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"UacDisableNotify", 0)) {
				return false;
			}

			LOG_VERBOSE(1, L"Attempting to set FirewallDisableNotify to 0 for " << key.ToString());
			if (!key.SetValue<DWORD>(L"FirewallDisableNotify", 0)) {
				return false;
			}
		}

		return true;
	}

	bool MitigateM1054WSC::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV1093.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV1093.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV1093::MitigateV1093() :
		Mitigation(
			L"V-1093 - Anonymous enumeration of shares must be restricted",
			L"This is a High finding because allowing anonymous logon users (null session connections) to list all"
				"account names and enumerate all shared resources can provide a map of potential points to attack the system.",
			L"lsa",
			SoftwareAffected::ExposedService,
			MitigationSeverity::High
		) {}

	bool MitigateV1093::MitigationIsEnforced(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" };
		auto data = key.GetValue<DWORD>(L"RestrictAnonymous");
		if(!data || !*data){
			LOG_INFO(1, L"[" + name + L"] RestrictAnonymous value is not set to 1");
			return false;
		}

		return true;
	}

	bool MitigateV1093::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" };

		return key.SetValue<DWORD>(L"restrictanonymous", 1);
	}

	bool MitigateV1093::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV1153.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV1153.h"

#include "hunt/RegistryHunt.h"
#include "util/configurations/Registry.h"
#include "util/log/Log.h"
#include <algorithm>

using namespace Registry;

namespace Mitigations{

	MitigateV1153::MitigateV1153() :
		Mitigation(
			L"V-1153 - The LanMan authentication level must be set to send NTLMv2 response only, and to refuse LM and NTLM",
			L"The Kerberos v5 authentication protocol is the default for authentication of users who are logging on to domain "
			L"accounts. NTLM which is less secure, is retained in later Windows versions for compatibility with clients and servers "
			L"that are running earlier versions of Windows or applications that still use it. It is also used to authenticate logons "
			L"to stand-alone computers that are running later versions.",
			L"lsa",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Medium
		) {}

	bool CheckLMCompatibilityLevel(bool enforce){
		auto lsa = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" };
		if(!lsa.ValueExists(L"LmCompatibilityLevel") || lsa.GetValue<DWORD>(L"LmCompatibilityLevel") != 5){
			if(enforce){
				LOG_VERBOSE(1, "Setting LM Compatibility Level to 5 (allow only NTLMv2)");
				return lsa.SetValue<DWORD>(L"LmCompatibilityLevel", 5);
			} else {
				LOG_VERBOSE(1, "Detected misconfigured LM Compatibility level");
				return false;
			}
		}
		LOG_VERBOSE(1, "LM Compatibility Level is correctly set");
		return true;
	}

	bool MitigateV1153::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		return CheckLMCompatibilityLevel(false);
	}

	bool MitigateV1153::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, "Enforcing Mitigation for " << name);

		return CheckLMCompatibilityLevel(level >= SecurityLevel::Medium);
	}

	bool MitigateV1153::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV3338.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV3338.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"
#include <algorithm>

using namespace Registry;

namespace Mitigations {

	MitigateV3338::MitigateV3338() : 
		Mitigation(
			L"V-3338 - Unauthorized named pipes are accessible with anonymous credentials",
			L"This is a High finding because of the potential for gaining unauthorized system access. Pipes are internal system communications processes. "
				"They are identified internally by ID numbers that vary between systems. To make access to these processes easier, these pipes are given names "
				"that do not vary between systems. This setting controls which of these pipes anonymous users may access.",
			L"lanmanserver",
			SoftwareAffected::ExposedService,
			MitigationSeverity::High
		) {}

	bool MitigateV3338::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\LanManServer\\Parameters" };
		if(key.ValueExists(L"NullSessionPipes")){
			auto values = *key.GetValue<std::vector<std::wstring>>(L"NullSessionPipes");
			auto vGoodValues = std::vector<std::wstring>{};
			for(auto value : values){
				if(value.size() == 0){ // TODO: Add exceptions on domain controllers (netlogon, samr, lsarpc)
					LOG_VERBOSE(1, "Found a non-zero number of named pipes accessible anonymously.");
					return false;
				}
			}
		}
		LOG_VERBOSE(1, "Found no named pipes accessible anonymously.");
		return true;
	}

	bool MitigateV3338::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, "Enforcing Mitigation for " << name);
		
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\LanManServer\\Parameters" };
		if(key.ValueExists(L"NullSessionPipes")){
			auto values = *key.GetValue<std::vector<std::wstring>>(L"NullSessionPipes");
			/* TODO: Add prompt to ask if this is a domain controller */
			//auto vGoodValues = std::vector<std::wstring>{L"NETLOGON", L"SAMR", L"LSARPC"};
			auto vGoodValues = std::vector<std::wstring>{};
			for(auto value : values){
				if (std::find(vGoodValues.begin(), vGoodValues.end(), value) == vGoodValues.end()) {
					LOG_VERBOSE(1, L"Found a named pipe (" + value + L") that should not be allowed.");
				}
			}
			LOG_VERBOSE(2, L"Setting accessible named pipes to specified good values.");
			return key.SetValue<std::vector<std::wstring>>(L"NullSessionPipes", vGoodValues);
		}
		return true;
	}

	bool MitigateV3338::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV3340.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV3340.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV3340::MitigateV3340() :
		Mitigation(
			L"V-3340 - Unauthorized shares can be accessed anonymously",
			L"This is a Category 1 finding because of the potential for gaining unauthorized "
			"system access. Any shares listed can be accessed by any network user. This could "
			"lead to the exposure or corruption of sensitive data.",
			L"lanmanserver",
			SoftwareAffected::ExposedService,
			MitigationSeverity::High
		) {}

	bool MitigateV3340::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\LanManServer\\Parameters" };
		std::wstring value = L"NullSessionShares";

		auto values = *key.GetValue<std::vector<std::wstring>>(value);

		if(values.size() != 0){
			LOG_VERBOSE(1, L"Value for " << value << L" is not blank.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV3340::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\LanManServer\\Parameters" };
		std::wstring value = L"NullSessionShares";
		auto data = std::vector<std::wstring>{};

		LOG_VERBOSE(1, L"Attempting to make " << value << L" blank.");
		return key.SetValue<std::vector<std::wstring>>(value, data);
	}

	bool MitigateV3340::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV3344.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV3344.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations{

	MitigateV3344::MitigateV3344() :
		Mitigation(
			L"V-3344 - Local accounts with blank passwords restricted to console logon only",
			L"This is a Category 1 finding because no accounts with blank passwords should exist on a system. "
			"The password policy should prevent this from occurring. However, if a local account with a blank "
			"password does exist, enabling this setting will limit the account to local console logon only.",
			L"lsa",
			SoftwareAffected::ExposedService,
			MitigationSeverity::High
		) {}

	bool  LimitBlankPasswordUse(bool enforce){
		auto lsa = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" };
		if(!lsa.ValueExists(L"LimitBlankPasswordUse") || lsa.GetValue<DWORD>(L"LimitBlankPasswordUse") != 1){
			if(enforce){
				LOG_VERBOSE(1, "Setting LimitBlankPasswordUse to 1");
				return lsa.SetValue<DWORD>(L"LimitBlankPasswordUse", 1);
			} else {
				LOG_VERBOSE(1, "Detected LSA allowing non-console logons with blank passwords");
				return false;
			}
		}
		LOG_VERBOSE(1, "LSA is denying non-console logons with blank passwords");
		return true;
	}

	bool MitigateV3344::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		return  LimitBlankPasswordUse(false);
	}

	bool MitigateV3344::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, "Enforcing Mitigation for " << name);

		return  LimitBlankPasswordUse(level >= SecurityLevel::Medium);
	}

	bool MitigateV3344::MitigationApplies(){
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV3379.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV3379.h"

#include "hunt/RegistryHunt.h"
#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations{

	MitigateV3379::MitigateV3379() :
		Mitigation(
			L"V-3379 - The system is configured to store the LAN Manager hash of the password in the SAM",
			L"This setting controls whether or not a LAN Manager hash of the password is stored in the SAM "
			"the next time the password is changed. The LAN Manager hash uses a weak encryption algorithm and "
			"there are several tools available that use this hash to retrieve account passwords",
			L"lsa",
			SoftwareAffected::InternalService,
			MitigationSeverity::High
		) {}

	bool CheckNoLMHash(bool enforce){
		auto lsa = RegistryKey{ HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Lsa" };
		if(!lsa.ValueExists(L"NoLMHash") || lsa.GetValue<DWORD>(L"NoLMHash") != 1){
			if(enforce){
				LOG_VERBOSE(1, "Setting NoLMHash to 1 (Don't store hashes)");
				return lsa.SetValue<DWORD>(L"NoLMHash", 1);
			} else {
				LOG_VERBOSE(1, "Detected misconfigured NoLMHash value");
				return false;
			}
		}
		LOG_VERBOSE(1, "NoLMHash is correctly set");
		return true;
	}

	bool MitigateV3379::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		return CheckNoLMHash(false);
	}

	bool MitigateV3379::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, "Enforcing Mitigation for " << name);

		return CheckNoLMHash(level >= SecurityLevel::Medium);
	}

	bool MitigateV3379::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV3479.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV3479.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV3479::MitigateV3479() :
		Mitigation(
			L"V-3479 - The system will be configured to use Safe DLL Search Mode",
			L"The default search behavior, when an application calls a function in a Dynamic Link Library (DLL), "
			"is to search the current directory followed by the directories contained in the systems path environment "
			"variable. An unauthorized DLL inserted into an applications working directory could allow malicious code "
			"to be run on the system. Creating the following registry key and setting the appropriate value forces the "
			"system to search the %Systemroot% for the DLL before searching the current directory or the rest of the path.",
			L"smss",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV3479::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Session Manager" };
		std::wstring value = L"SafeDllSearchMode";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV3479::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Session Manager" };
		std::wstring value = L"SafeDllSearchMode";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV3479::MitigationApplies(){
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63597.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63597.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV63597::MitigateV63597() :
		Mitigation(
			L"V-63597 - Apply UAC privileged token filtering for network logons",
			L"With User Account Control enabled, filtering the privileged token for built-in "
			"administrator accounts will prevent the elevated privileges of these accounts "
			"from being used over the network.",
			L"uac",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV63597::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"LocalAccountTokenFilterPolicy";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 0){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 0.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63597::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"LocalAccountTokenFilterPolicy";
		DWORD data = 0;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 0.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63597::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63687.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63687.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV63687::MitigateV63687() :
		Mitigation(
			L"V-63687 - Caching of logon credentials must be limited",
			L"The default Windows configuration caches the last logon credentials for users who log on "
			"interactively to a system. This feature is provided for system availability reasons, such as "
			"the user's machine being disconnected from the network or domain controllers being unavailable. "
			"Even though the credential cache is well-protected, if a system is attacked, an unauthorized "
			"individual may isolate the password to a domain user account using a password-cracking program "
			"and gain access to the domain.",
			L"lsa",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Low
		) {}

	bool MitigateV63687::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" };
		std::wstring value = L"CachedLogonsCount";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) > 1u){
			LOG_VERBOSE(1, L"Value for " << value << L" is greater than 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63687::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" };
		std::wstring value = L"CachedLogonsCount";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63687::MitigationApplies(){
		return true;
	}
}

```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63753.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63753.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV63753::MitigateV63753() :
		Mitigation(
			L"V-63753 - Prevent the storage of passwords and credentials used for Network Authentication",
			L"This setting controls the storage of passwords and credentials for network authentication "
			"on the local system. Such credentials must not be stored on the local machine as that may "
			"lead to account compromise. This setting refers primarily to Domain Credentials.",
			L"lsa",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV63753::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
		std::wstring value = L"DisableDomainCreds";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63753::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
		std::wstring value = L"DisableDomainCreds";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63753::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63817.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63817.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV63817::MitigateV63817() :
		Mitigation(
			L"V-63817 - User Account Control approval mode for the built-in Administrator must be enabled",
			L"User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, "
			"including administrative accounts, unless authorized. This setting configures the built-in "
			"Administrator account so that it runs in Admin Approval Mode.",
			L"uac",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV63817::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"FilterAdministratorToken";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63817::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"FilterAdministratorToken";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63817::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63825.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63825.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV63825::MitigateV63825() :
		Mitigation(
			L"V-63825 - User Account Control must be configured to detect application installations and prompt for elevation",
			L"User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, including "
			"administrative accounts, unless authorized. This setting requires Windows to respond to application installation "
			"requests by prompting for credentials.",
			L"uac",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV63825::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"EnableInstallerDetection";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63825::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"EnableInstallerDetection";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63825::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV63829.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV63829.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV63829::MitigateV63829() :
		Mitigation(
			L"V-63829 - User Account Control must run all administrators in Admin Approval Mode, enabling UAC",
			L"User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, "
			"including administrative accounts, unless authorized. This setting enables UAC.",
			L"uac",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::Medium
		) {}

	bool MitigateV63829::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"EnableLUA";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV63829::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" };
		std::wstring value = L"EnableLUA";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV63829::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV71769.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV71769.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV71769::MitigateV71769() :
		Mitigation(
			L"V-71769 - Remote calls to the Security Account Manager (SAM) must be restricted to Administrators",
			L"The Windows Security Account Manager (SAM) stores users' passwords. Restricting remote rpc "
			"connections to the SAM to Administrators helps protect those credentials.",
			L"sam",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Medium
		) {}

	bool MitigateV71769::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
		std::wstring value = L"RestrictRemoteSAM";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<std::wstring>(value) != L"O:BAG:BAD:(A;;RC;;;BA)"){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to O:BAG:BAD:(A;;RC;;;BA).");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV71769::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Lsa" };
		std::wstring value = L"RestrictRemoteSAM";
		std::wstring data = L"O:BAG:BAD:(A;;RC;;;BA)";

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to O:BAG:BAD:(A;;RC;;;BA).");
		return key.SetValue<std::wstring>(value, data);
	}

	bool MitigateV71769::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV72753.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV72753.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV72753::MitigateV72753() : 
		Mitigation(
			L"V-72753 - WDigest Authentication must be disabled",
			L"When the WDigest Authentication protocol is enabled, plain text passwords are stored in the Local Security Authority"
			"Subsystem Service (LSASS) exposing them to theft. This setting will prevent WDigest from storing credentials in memory.",
			L"lsa",
			SoftwareAffected::OperatingSystem,
			MitigationSeverity::High
		) {}

	bool MitigateV72753::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\Wdigest" };
		std::wstring value = L"UseLogonCredential";

		if(IsWindowsVersionOrGreater(6, 2, 0)){ // Win 8.1+
			if(!key.ValueExists(value)){
				return true;
			}
		} else if(!key.ValueExists(value)){
			return false;
		}

		if(key.GetValue<DWORD>(value) == 1){
			if(level == SecurityLevel::Low){
				LOG_INFO(1, L"[" + name + L"] Mitigation is not being enforced due to low security level.");
				return true;
			}
			return false;
		}
		return true;
	}

	bool MitigateV72753::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\Wdigest" };
		std::wstring value = L"UseLogonCredential";
		DWORD data = 0;

		if (!IsWindowsVersionOrGreater(6, 2, 0) || key.ValueExists(value)) {
			return key.SetValue<DWORD>(value, data);
		}

		return true;
	}

	bool MitigateV72753::MitigationApplies(){
		return IsWindowsVersionOrGreater(6, 0, 0); // Win 7+
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV73511.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV73511.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

using namespace Registry;

namespace Mitigations {

	MitigateV73511::MitigateV73511() :
		Mitigation(
			L"V-73511 - Command line data must be included in process creation events",
			L"Maintaining an audit trail of system activity logs can help identify configuration "
			"errors, troubleshoot service disruptions, and analyze compromises that have occurred, "
			"as well as detect attacks. Collecting this data is essential for analyzing the security "
			"of information assets and detecting signs of suspicious and unexpected behavior.",
			L"evt",
			SoftwareAffected::InternalService,
			MitigationSeverity::Medium
		) {}

	bool MitigateV73511::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit" };
		std::wstring value = L"ProcessCreationIncludeCmdLine_Enabled";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 1){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 1.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV73511::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit" };
		std::wstring value = L"ProcessCreationIncludeCmdLine_Enabled";
		DWORD data = 1;

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 1.");
		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV73511::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV73519.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV73519.h"

#include "hunt/RegistryHunt.h"
#include "util/configurations/Registry.h"
#include "util/log/Log.h"
#include <algorithm>

using namespace Registry;

namespace Mitigations{

	MitigateV73519::MitigateV73519() :
		Mitigation(
			L"V-73519 - The Server Message Block (SMB) v1 protocol must be disabled on the SMB server",
			L"SMBv1 is a legacy protocol that uses the MD5 algorithm as part of SMB. MD5 is known to be vulnerable to a "
			L"number of attacks such as collision and preimage attacks as well as not being FIPS compliant. Disabling SMBv1 "
			L"support may prevent access to file or print sharing resources with systems or devices that only support SMBv1. "
			"File shares and print services hosted on Windows Server 2003 are an example, however Windows Server 2003 is no "
			"longer a supported operating system. Some older network attached devices may only support SMBv1.",
			L"lanmanserver",
			SoftwareAffected::ExposedService,
			MitigationSeverity::Medium
		) {}

	bool CheckSMBv1(bool enforce){
		auto lanmankey = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters" };
		if(!lanmankey.ValueExists(L"SMB1") || lanmankey.GetValue<DWORD>(L"SMB1") != 0){
			LOG_VERBOSE(1, L"SMBv1 has been detected.");
			if(enforce){
				LOG_VERBOSE(1, L"Disabling SMBv1... Restart required");
				return lanmankey.SetValue<DWORD>(L"SMB1", 0);
			}
			return false;
		}
		LOG_VERBOSE(1, "SMBv1 not detected");
		return true;
	}

	bool MitigateV73519::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		return CheckSMBv1(false);
	}

	bool MitigateV73519::EnforceMitigation(SecurityLevel level) {
		LOG_INFO(1, "Enforcing Mitigation for " << name);

		return CheckSMBv1(level >= SecurityLevel::Medium);
	}

	bool MitigateV73519::MitigationApplies(){
		auto lanmankey = RegistryKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\LanmanServer" };
		return lanmankey.Exists() && lanmankey.ValueExists(L"Start") && *lanmankey.GetValue<DWORD>(L"Start") != 4;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/mitigations/MitigateV73585.cpp`:

```cpp
#include "mitigation/mitigations/MitigateV73585.h"
#include "hunt/RegistryHunt.h"

#include "util/configurations/Registry.h"
#include "util/log/Log.h"

#include <VersionHelpers.h>

using namespace Registry;

namespace Mitigations {

	MitigateV73585::MitigateV73585() :
		Mitigation(
			L"V-73585 - The Windows Installer Always install with elevated privileges option must be disabled",
			L"Standard user accounts must not be granted elevated privileges. Enabling Windows Installer to elevate "
			"privileges when installing applications can allow malicious persons and applications to gain full "
			"control of a system.",
			L"uac",
			SoftwareAffected::InternalService,
			MitigationSeverity::High
		) {}

	bool MitigateV73585::MitigationIsEnforced(SecurityLevel level) {
		LOG_INFO(1, "Checking for presence of " << name);

		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows\\Installer" };
		std::wstring value = L"AlwaysInstallElevated";

		if (!key.ValueExists(value)) {
			LOG_VERBOSE(1, L"Value for " << value << L" does not exist.");
			return false;
		}

		if(key.GetValue<DWORD>(value) != 0){
			LOG_VERBOSE(1, L"Value for " << value << L" is not set to 0.");
			return false;
		}

		LOG_VERBOSE(1, L"Mitigation " << name << L" is enforced.");
		return true;
	}

	bool MitigateV73585::EnforceMitigation(SecurityLevel level) {
		auto key = RegistryKey{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Policies\\Microsoft\\Windows\\Installer" };
		std::wstring value = L"AlwaysInstallElevated";
		DWORD data = 0;

		if (!key.Exists()) {
			LOG_VERBOSE(1, "Key does not exist. Creating key and setting value to 0.");
			return key.Create() && key.SetValue<DWORD>(value, data);
		}

		LOG_VERBOSE(1, L"Attempting to set " << value << L" to 0.");

		return key.SetValue<DWORD>(value, data);
	}

	bool MitigateV73585::MitigationApplies(){
		return true;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/policy/CombinePolicy.cpp`:

```cpp
#include "mitigation/policy/CombinePolicy.h"

#include "mitigation/policy/ValuePolicy.h"
#include "mitigation/policy/SubkeyPolicy.h"
#include "util/StringUtils.h"

CombinePolicy::CombinePolicy(std::vector<std::unique_ptr<MitigationPolicy>> subpolicies, const std::wstring& name,
							 EnforcementLevel level, const std::optional<std::wstring>& description, Mode mode) :
	MitigationPolicy(name, level, description), subpolicies{ std::move(subpolicies) }, mode{ mode }{
	assert(subpolicies.size() != 0);

	minVersion = subpolicies[0]->minVersion;
	maxVersion = subpolicies[0]->maxVersion;

	for(int idx = 1; idx < subpolicies.size(); idx++){
		if(minVersion != std::nullopt){
			minVersion = subpolicies[idx]->minVersion ? 
				(*subpolicies[idx]->minVersion < *minVersion ? subpolicies[idx]->minVersion : minVersion) : 
				std::nullopt;
		}
		if(maxVersion != std::nullopt){
			maxVersion = subpolicies[idx]->maxVersion ?
				(*subpolicies[idx]->maxVersion < *maxVersion ? subpolicies[idx]->maxVersion : maxVersion) :
				std::nullopt;
		}
	}
}

CombinePolicy::CombinePolicy(json policy) : MitigationPolicy(policy){
	assert(policy.find("mode") != policy.end());
	assert(policy.find("subpolicies") != policy.end());

	auto typeString{ ToLowerCaseA(policy["mode"].get<std::string>()) };
	if(typeString == "and"){ mode = Mode::AND; } 
	else if(typeString == "or"){ mode = Mode::OR; } 
	else throw std::exception(("Unknown combination mode: " + typeString).c_str());

	for(auto& subpolicy : policy["subpolicies"]){
		auto type{ subpolicy["policy-type"].get<std::string>() };
		if(type == "registry-value-policy"){
			subpolicies.emplace_back(std::make_unique<ValuePolicy>(subpolicy));
		} else if(type == "registry-subkey-policy"){
			subpolicies.emplace_back(std::make_unique<SubkeyPolicy>(subpolicy));
		} else if(type == "combined-policy"){
			subpolicies.emplace_back(std::make_unique<CombinePolicy>(subpolicy));
		} else{
			throw std::exception(("Unknown mitigation policy type \"" + type + "\"").c_str());
		}
	}
}

bool CombinePolicy::Enforce(){
	if(IsEnforced()){
		if(!MatchesSystem()){
			if(mode == Mode::OR){
				if(subpolicies.size()){
					return subpolicies[0]->Enforce();
				}
				return false;
			} else{
				bool enforced = true;
				for(auto& subpolicy : subpolicies){
					enforced = enforced && subpolicy->Enforce();
				}
				return enforced;
			}
		} else{
			return true;
		}
	} else return MatchesSystem();
}

bool CombinePolicy::MatchesSystem() const{
	if(mode == Mode::OR){
		for(auto& subpolicy : subpolicies){
			if(subpolicy->MatchesSystem()){
				return true;
			}
		}
		return false;
	} else{
		bool enforced = true;
		for(auto& subpolicy : subpolicies){
			enforced = enforced && subpolicy->MatchesSystem();
		}
		return enforced;
	}
}
```

`BLUESPAWN-win-client/src/mitigation/policy/EventLogPolicy.cpp`:

```cpp
#include "mitigation/policy/EventLogPolicy.h"
#include "util/StringUtils.h"
#include "util/eventlogs/EventLogs.h"

EventLogPolicy::EventLogPolicy(json policy) : MitigationPolicy(policy){
	assert(policy.find("channels") != policy.end());

	for(auto& channel : policy["channels"]){
		channelNames.emplace(StringToWidestring(channel.get<std::string>()));
	}
}

bool EventLogPolicy::Enforce(){
	if(IsEnforced()){
		if(!MatchesSystem()){
			bool enforced = false;
			for(auto& channel : channelNames){
				if(!EventLogs::IsChannelOpen(channel)){
					enforced = enforced && EventLogs::OpenChannel(channel);
				}
			}
			return enforced;
		} else{
			return true;
		}
	} else return MatchesSystem();
}

bool EventLogPolicy::MatchesSystem() const{
	for(auto& channel : channelNames){
		if(!EventLogs::IsChannelOpen(channel)){
			return false;
		}
	}
	return true;
}
```

`BLUESPAWN-win-client/src/mitigation/policy/FirewallPolicy.cpp`:

```cpp
#include "mitigation/policy/FirewallRulePolicy.h"
#include "util/StringUtils.h"

#include <sstream>

IP::IP(const std::wstring& ip){
	if(ip.find(L'.') != ip.npos && ip.find(L':') != ip.npos){
		throw std::exception("Malformed IP!");
	}

	if(ip.find(L'.') != ip.npos){
		type = Version::IPv4;
		auto parts{ SplitStringW(ip, L".") };
		assert(parts.size() <= 4 && parts.size() >= 2);
		long numbers[4]{ 
			std::stol(parts[0]), 
			parts.size() > 2 ? std::stol(parts[1]) : 0,
			parts.size() > 3 ? std::stol(parts[2]) : 0,
			std::stol(parts[parts.size() - 1]),
		};
		this->ip = 0;
		for(int i = 0; i < 4; i++){
			if(numbers[i] >= 0 && numbers[i] <= 255){
				this->ip = (std::get<uint32_t>(this->ip) << 8) | numbers[i];
			} else{
				throw std::exception("Invalid IP!");
			}
		}
	} else if(ip.find(L':') != ip.npos){
		type = Version::IPv6;
		if(ip.find(L"::") != ip.npos){
			auto halves{ SplitStringW(ip, L"::") };
			assert(halves.size() == 2);

			for(int i = 0; i < 8; i++){
				std::get<uint16_t[8]>(this->ip)[i] = 0;
			}

			int total = 0;
			for(int i = 0; i < 2; i++){
				auto parts{ SplitStringW(ip, L":") };
				total += parts.size();

				auto idx{ i == 0 ? 0 : 8 - parts.size()};
				for(auto& part : parts){
					auto val{ std::stol(part, nullptr, 16) };
					if(val >= 0 && val <= 0xFFFF){
						std::get<uint16_t[8]>(this->ip)[idx++] = val;
					} else{
						throw std::exception("Invalid IP!");
					}
				}
			}
			assert(total <= 8);
		} else{
			auto parts{ SplitStringW(ip, L":") };
			assert(parts.size() == 8);

			auto idx{ 0ul };
			for(auto& part : parts){
				auto val{ std::stol(part, nullptr, 16) };
				if(val >= 0 && val <= 0xFFFF){
					std::get<uint16_t[8]>(this->ip)[idx++] = val;
				} else{
					throw std::exception("Invalid IP!");
				}
			}
		}
	} else{
		throw std::exception("Malformed IP!");
	}
}

IP::IP(uint32_t ip) : type{ Version::IPv4 }, ip{ ip }{}
IP::IP(uint16_t ip[8]) : type{ Version::IPv6 }{
	for(int i = 0; i < 8; i++){
		std::get<uint16_t[8]>(this->ip)[i] = ip[i];
	}
}
std::wstring IP::ToString() const {
	if(type == Version::IPv4){
		auto ip{ std::get<uint32_t>(this->ip) };
		return std::to_wstring(ip >> 24) + L"." + std::to_wstring((ip >> 16) & 0xFF) + L"." + 
			std::to_wstring((ip >> 8) & 0xFF) + L"." + std::to_wstring(ip & 0xFF);
	} else{
		std::pair<int, int> best;
		int start = 0;
		for(int i = 0; i < 8; i++){
			if(std::get<uint16_t[8]>(ip)[i] != 0){
				if(i - start > best.second){
					best = std::make_pair(start, i - start);
				}
				start = i + 1;
			}
		}
		std::wstringstream str{};
		for(int i = 0; i < (best.second == 0 ? 7 : best.first); i++){
			str << std::hex << std::get<uint16_t[8]>(ip)[i] << L":";
		}
		if(best.second == 0){
			str << std::hex << std::get<uint16_t[8]>(ip)[7];
		} else{
			for(int i = best.first + best.second; i < 8; i++){
				str << L":" << std::hex << std::get<uint16_t[8]>(ip)[i];
			}
		}
		return str.str();
	}
}

IPRange::IPRange(const IP& singleIP) : minIP(singleIP), maxIP(singleIP){}

IPRange::IPRange(const IP& minIP, const IP& maxIP) : minIP(minIP), maxIP(maxIP){
	assert(minIP.type == maxIP.type);
}

bool IPRange::IPInRange(const IP& ip) const {
	if(ip.type != minIP.type){
		return false;
	}
	if(ip.type == IP::Version::IPv4){
		return std::get<uint32_t>(minIP.ip) <= std::get<uint32_t>(ip.ip) && 
			std::get<uint32_t>(ip.ip) <= std::get<uint32_t>(maxIP.ip);
	} else{
		for(int i = 0; i < 8; i++){
			if(std::get<uint16_t[8]>(ip.ip)[i] > std::get<uint16_t[8]>(minIP.ip)[i]){
				break;
			} else if(std::get<uint16_t[8]>(ip.ip)[i] < std::get<uint16_t[8]>(minIP.ip)[i]){
				return false;
			}
		}
		for(int i = 0; i < 8; i++){
			if(std::get<uint16_t[8]>(ip.ip)[i] > std::get<uint16_t[8]>(maxIP.ip)[i]){
				return false;
			} else if(std::get<uint16_t[8]>(ip.ip)[i] < std::get<uint16_t[8]>(minIP.ip)[i]){
				break;
			}
		}
		return true;
	}
}

std::wstring IPRange::ToString() const{ return minIP.ToString() + L" - " + maxIP.ToString(); };

FirewallBasePolicy::FirewallBasePolicy(json config) : MitigationPolicy(config){
	assert(config.find("default-action") != config.end());

	auto default{ config["default-action"].get<std::string>() };
	if(CompareIgnoreCaseA(default, "block")){
		defaultAction = FirewallAction::BLOCK;
	} else if(CompareIgnoreCaseA(default, "allow")){
		defaultAction = FirewallAction::ALLOW;
	} else{
		throw std::exception(("Invalid default action: " + default).c_str());
	}

	if(config.find("allow-preexisting") != config.end()){
		allowPreexisting = config["allow-preexisting"].get<bool>();
	} else{
		allowPreexisting = true;
	}

	if(config.find("rules") != config.end()){
		for(auto& rule : rules){
			this->rules.emplace_back(FirewallRulePolicy{ rule });
		}
	}
}

FirewallRulePolicy::FirewallRulePolicy(json config) : MitigationPolicy(config){
	assert(config.find("direction") != config.end());
	assert(config.find("action") != config.end());

	if(config.find("protocol") != config.end()){

	}
	if(config.find("ports") != config.end()){

	}
	if(config.find("scoped-programs") != config.end()){

	}
	if(config.find("scoped-services") != config.end()){

	}
	if(config.find("destination-ips") != config.end()){

	}
	if(config.find("source-ips") != config.end()){

	}
}
```

`BLUESPAWN-win-client/src/mitigation/policy/MitigationPolicy.cpp`:

```cpp
#include "mitigation/policy/MitigationPolicy.h"

#include "util/StringUtils.h"

bool MitigationPolicy::IsEnforced() const{ return isEnforced; }

std::wstring MitigationPolicy::GetPolicyName() const{ return name; }

EnforcementLevel MitigationPolicy::GetEnforcementLevel() const{ return level; }

void MitigationPolicy::SetEnforced(bool enforce){ isEnforced = enforce; }

void MitigationPolicy::SetEnforced(EnforcementLevel level){ isEnforced = level >= this->level; }

std::optional<std::wstring> MitigationPolicy::GetDescription() const{ return this->description; }

MitigationPolicy::MitigationPolicy(const std::wstring& name, EnforcementLevel level, 
								   const std::optional<std::wstring>& description,
								   const std::optional<Version>& min, const std::optional<Version>& max) : 
	name{ name }, level{ level }, description{ description }, minVersion{ min }, maxVersion{ max }{}

MitigationPolicy::MitigationPolicy(json policy){
    assert(policy.find("name") != policy.end());
    assert(policy.find("enforcement-level") != policy.end());

    name = StringToWidestring(policy["name"].get<std::string>());
    description = policy.find("description") != policy.end() ?
        std::optional<std::wstring>(StringToWidestring(policy["description"].get<std::string>())) : std::nullopt;

    auto levelString{ ToLowerCaseA(policy["enforcement-level"].get<std::string>()) };
    if(levelString == "low"){ level = EnforcementLevel::Low; } 
    else if(levelString == "moderate"){ level = EnforcementLevel::Moderate; } 
    else if(levelString == "high"){ level = EnforcementLevel::High; } 
    else throw std::exception(("Unknown enforcement level: " + levelString).c_str());

    minVersion = policy.find("min-software-version") != policy.end() ?
        std::optional<Version>(StringToWidestring(policy["min-software-version"].get<std::string>())) : std::nullopt;
    maxVersion = policy.find("max-software-version") != policy.end() ?
        std::optional<Version>(StringToWidestring(policy["max-software-version"].get<std::string>())) : std::nullopt;
}

bool MitigationPolicy::GetVersionMatch(std::optional<Version> version) const{
	if(minVersion == std::nullopt && maxVersion == std::nullopt){
		return true;
	}
	if(version == std::nullopt){
		return false;
	}
	return (!minVersion || *minVersion <= *version) && (!maxVersion || *maxVersion >= *version);
}


```

`BLUESPAWN-win-client/src/mitigation/policy/RegistryPolicy.cpp`:

```cpp
#include "mitigation/policy/RegistryPolicy.h"

#include <assert.h>

#include <regex>

#include "util/StringUtils.h"

#include "mitigation/policy/SubkeyPolicy.h"
#include "mitigation/policy/ValuePolicy.h"
#include "user/bluespawn.h"

RegistryPolicy::RegistryPolicy(const RegistryKey& key,
                               const std::wstring& name,
                               EnforcementLevel level,
                               const std::optional<std::wstring>& description,
                               const std::optional<Version>& min,
                               const std::optional<Version>& max) :
    MitigationPolicy(name, level, description, min, max),
    keys{ key } {}

bool NameIsMatch(const std::wstring& subkeyName, std::wstring request) {
    for(auto find{ request.find(L"*") }; find != std::string::npos; find = request.find(L"*", find + 2)) {
        request.replace(request.begin() + find, request.begin() + find + 1, L".*");
    }
    return std::regex_match(ToLowerCaseW(subkeyName), std::wregex{ ToLowerCaseW(request) });
}

RegistryPolicy::RegistryPolicy(json policy) : MitigationPolicy(policy) {
    assert(policy.find("key-path") != policy.end());
    auto keyPath(StringToWidestring(policy["key-path"].get<std::string>()));
    auto keyPathParts{ SplitStringW(keyPath, L"\\") };
    bool care{ !wcscmp(keyPath.c_str(), L"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer") };
    std::vector<RegistryKey> keys{ RegistryKey(keyPathParts[0]) };
    for(auto idx = 1; idx < keyPathParts.size(); idx++) {
        std::vector<RegistryKey> children{};
        for(auto& key : keys) {
            if(keyPathParts[idx].find(L'*') != std::wstring::npos){
                for(auto& subkeyName : key.EnumerateSubkeyNames()){
                    if(NameIsMatch(subkeyName, keyPathParts[idx])){
                        children.emplace_back(RegistryKey{ key, subkeyName });
                    }
                }
            } else{
                children.emplace_back(RegistryKey{ key, keyPathParts[idx] });
            }
        }
        keys = children;
    }
    this->keys = keys;
}

ValuePolicy::ValuePolicy(const RegistryKey& key,
                         const std::wstring& valueName,
                         const RegistryData& data,
                         ValuePolicyType policyType,
                         const std::wstring& name,
                         EnforcementLevel level,
                         const std::optional<std::wstring>& description,
                         const std::optional<RegistryData>& replacement,
                         const std::optional<Version>& min,
                         const std::optional<Version>& max) :
    RegistryPolicy(key, name, level, description, min, max),
    valueName{ valueName }, data{ data }, policyType{ policyType }, replacement{ replacement } {}

ValuePolicy::ValuePolicy(json policy) : RegistryPolicy(policy) {
    assert(policy.find("value-name") != policy.end());
    assert(policy.find("registry-value-policy-type") != policy.end());
    valueName = StringToWidestring(policy["value-name"].get<std::string>());

    auto typeString{ ToLowerCaseA(policy["registry-value-policy-type"].get<std::string>()) };
    if(typeString == "forbid-exact") {
        policyType = ValuePolicyType::ForbidExact;
    } else if(typeString == "forbid-subset-of") {
        policyType = ValuePolicyType::ForbidSubsetOf;
    } else if(typeString == "require-subset-of") {
        policyType = ValuePolicyType::RequireSubsetOf;
    } else if(typeString == "require-exact") {
        policyType = ValuePolicyType::RequireExact;
    } else if(typeString == "require-as-subset") {
        policyType = ValuePolicyType::RequireAsSubset;
    } else if(typeString == "forbid-value") {
        policyType = ValuePolicyType::ForbidValue;
    } else
        throw std::exception(("Unknown registry policy type: " + typeString).c_str());

    if(policyType != ValuePolicyType::ForbidValue) {
        assert(policy.find("data-value") != policy.end());
        assert(policy.find("data-type") != policy.end());

        auto datatypeString{ ToLowerCaseA(policy["data-type"].get<std::string>()) };
        if(datatypeString == "reg_dword") {
            assert(typeString == "forbid-exact" || typeString == "require-exact");
            data = policy["data-value"].get<DWORD>();
        } else if(datatypeString == "reg_sz") {
            assert(typeString == "forbid-exact" || typeString == "require-exact");
            data = StringToWidestring(policy["data-value"].get<std::string>());
        } else if(datatypeString == "reg_multi_sz") {
            std::vector<std::wstring> dataValue{};
            for(auto& entry : policy["data-value"]) {
                dataValue.emplace_back(StringToWidestring(entry.get<std::string>()));
            }
            data = dataValue;
        } else if(datatypeString == "reg_binary") {
            assert(typeString == "forbid-exact" || typeString == "require-exact");
            auto stringRepresentation{ policy["data-value"].get<std::string>() };
            auto len{ stringRepresentation.size() };
            AllocationWrapper dataValue(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len), len,
                                        AllocationWrapper::HEAP_ALLOC);
            CopyMemory(dataValue, stringRepresentation.data(), len);
            data = dataValue;
        } else
            throw std::exception(("Unknown registry data type: " + datatypeString).c_str());
    }
    if(policyType == ValuePolicyType::ForbidExact && policy.count("replacement-data-type") && 
       policy.count("replacement-data-value")){
        auto datatypeString{ ToLowerCaseA(policy["replacement-data-type"].get<std::string>()) };
        if(datatypeString == "reg_dword"){
            replacement = policy["replacement-data-value"].get<DWORD>();
        } else if(datatypeString == "reg_sz"){
            replacement = StringToWidestring(policy["replacement-data-value"].get<std::string>());
        } else if(datatypeString == "reg_multi_sz"){
            std::vector<std::wstring> dataValue{};
            for(auto& entry : policy["replacement-data-value"]){
                dataValue.emplace_back(StringToWidestring(entry.get<std::string>()));
            }
            replacement = dataValue;
        } else if(datatypeString == "reg_binary"){
            auto stringRepresentation{ policy["replacement-data-value"].get<std::string>() };
            auto len{ stringRepresentation.size() };
            AllocationWrapper dataValue(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len), len,
                                        AllocationWrapper::HEAP_ALLOC);
            CopyMemory(dataValue, stringRepresentation.data(), len);
            replacement = dataValue;
        } else
            throw std::exception(("Unknown registry data type: " + datatypeString).c_str());
    }
}

std::vector<std::wstring>& ReadMultiValue(RegistryValue& value, const std::wstring& name) {
    if(value.GetType() != RegistryType::REG_MULTI_SZ_T) {
        Bluespawn::io.InformUser(L"Mitigation policy `" + name + L"` is treating " + value.ToString() +
                                 L" as a REG_MULTI_SZ. This may lead to undesired behavior.");
        std::wstring elem;
        if(value.GetType() == RegistryType::REG_SZ_T) {
            elem = std::get<std::wstring>(value.data);
        } else if(value.GetType() == RegistryType::REG_DWORD_T) {
            elem = std::to_wstring(std::get<DWORD>(value.data));
        } else {
            throw std::exception("Unable to convert registry binary value to REG_MULTI_SZ");
        }
        value.type = RegistryType::REG_MULTI_SZ_T;
        value.data = std::vector<std::wstring>{ elem };
    }

    return std::get<std::vector<std::wstring>>(value.data);
}

bool ValuePolicy::Enforce() {
    if(IsEnforced()) {
        if(policyType == ValuePolicyType::ForbidValue){
            for(auto& key : keys){
                if(key.ValueExists(valueName) && !key.RemoveValue(valueName)){
                    return false;
                }
            }
            return true;
        } else if(policyType == ValuePolicyType::RequireExact){
            for(auto& key : keys){
                if(!key.Exists()){
                    key.Create();
                }
                if(!key.ValueExists(valueName) || !(RegistryValue::Create(key, valueName)->data == data)){
                    if(!key.SetDataValue(valueName, data)){
                        return false;
                    }
                }
            }
            return true;
        } else if(policyType == ValuePolicyType::ForbidExact){
            for(auto& key : keys){
                if(key.ValueExists(valueName) && (RegistryValue::Create(key, valueName)->data == data)){
                    if(replacement){
                        if(!key.SetDataValue(valueName, *replacement)){
                            return false;
                        }
                    } else{
                        if(!key.RemoveValue(valueName)){
                            return false;
                        }
                    }
                }
            }
            return true;
        } else if(policyType == ValuePolicyType::RequireAsSubset){
            for(auto& key : keys){
                if(!key.Exists()){
                    key.Create();
                }
                auto curVal{ RegistryValue::Create(key, valueName) };
                if(!curVal){
                    if(!key.SetDataValue(valueName, data)){
                        return false;
                    }
                }

                try{
                    auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                    auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                    for(auto& elem : reqData){
                        bool found = false;
                        for(auto& present : regData){
                            if(elem == present){
                                found = true;
                            }
                        }
                        if(!found){
                            regData.emplace_back(elem);
                        }
                    }
                    if(!key.SetValue(valueName, regData)){
                        return false;
                    }
                } catch(std::exception& e){
                    if(!key.SetDataValue(valueName, data)){
                        return false;
                    }
                }
            }
            return true;
        } else if(policyType == ValuePolicyType::RequireSubsetOf){
            for(auto& key : keys){
                auto curVal{ RegistryValue::Create(key, valueName) };
                std::vector<std::wstring> fixedData{};

                try{
                    auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                    auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                    for(auto& elem : regData){
                        bool found = false;
                        for(auto& present : reqData){
                            if(elem == present){
                                found = true;
                            }
                        }
                        if(found){
                            fixedData.emplace_back(elem);
                        }
                    }
                } catch(std::exception& e){}   // exception came from ReadMultiValue; discard it
                if(!key.SetValue(valueName, fixedData)){
                    return false;
                }
            }
            return true;
        } else{
            for(auto& key : keys){
                auto curVal{ RegistryValue::Create(key, valueName) };
                std::vector<std::wstring> fixedData{};

                try{
                    auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                    auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                    for(auto& elem : regData){
                        bool found = false;
                        for(auto& present : reqData){
                            if(elem == present){
                                found = true;
                            }
                        }
                        if(!found){
                            fixedData.emplace_back(elem);
                        }
                    }
                } catch(std::exception& e){}   // exception came from ReadMultiValue; discard it
                if(!key.SetValue(valueName, fixedData)){
                    return false;
                }
            }
            return true;
        }
    } else{
         return MatchesSystem();
    }
}

bool ValuePolicy::MatchesSystem() const {
    if(policyType == ValuePolicyType::ForbidValue) {
        for(auto& key : keys) {
            if(key.ValueExists(valueName)) {
                return false;
            }
        }
        return true;
    } else if(policyType == ValuePolicyType::RequireExact) {
        for(auto& key : keys){
            if(!key.ValueExists(valueName) || RegistryValue::Create(key, valueName)->data != data){
                return false;
            }
        }
        return true;
    } else if(policyType == ValuePolicyType::ForbidExact) {
        for(auto& key : keys){
            if(key.ValueExists(valueName) && RegistryValue::Create(key, valueName)->data == data){
                return false;
            }
        }
        return true;
    } else if(policyType == ValuePolicyType::RequireAsSubset) {
        for(auto& key : keys){
            auto curVal{ RegistryValue::Create(key, valueName) };
            if(!curVal){
                return false;
            }

            try{
                auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                for(auto& elem : reqData){
                    bool found = false;
                    for(auto& present : regData){
                        if(elem == present){
                            found = true;
                        }
                    }
                    if(!found){
                        return false;
                    }
                }
            } catch(std::exception& e){
                Bluespawn::io.InformUser(StringToWidestring(e.what()));
                return false;
            }
        }
        return true;
    } else if(policyType == ValuePolicyType::RequireSubsetOf) {
        for(auto& key : keys){
            auto curVal{ RegistryValue::Create(key, valueName) };
            if(!curVal){
                continue;
            }

            try{
                auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                for(auto& elem : regData){
                    bool found = false;
                    for(auto& present : reqData){
                        if(elem == present){
                            found = true;
                        }
                    }
                    if(!found){
                        return false;
                    }
                }
            } catch(std::exception& e){
                Bluespawn::io.InformUser(StringToWidestring(e.what()));
                return false;
            }
        }
        return true;
    } else {
        for(auto& key : keys){
            auto curVal{ RegistryValue::Create(key, valueName) };
            if(!curVal){
                continue;
            }

            try{
                auto& regData{ ReadMultiValue(*curVal, GetPolicyName()) };
                auto& reqData{ std::get<std::vector<std::wstring>>(data) };
                for(auto& elem : regData){
                    bool found = false;
                    for(auto& present : reqData){
                        if(elem == present){
                            found = true;
                        }
                    }
                    if(found){
                        return false;
                    }
                }
            } catch(std::exception& e){
                Bluespawn::io.InformUser(StringToWidestring(e.what()));
                return false;
            }
        }
        return true;
    }
}

SubkeyPolicy::SubkeyPolicy(const RegistryKey& key,
                           const std::vector<std::wstring>& subkeyNames,
                           SubkeyPolicyType policyType,
                           const std::wstring& name,
                           EnforcementLevel level,
                           const std::optional<std::wstring>& description,
                           const std::optional<Version>& min,
                           const std::optional<Version>& max) :
    RegistryPolicy(key, name, level, description, min, max),
    subkeyNames(subkeyNames.begin(), subkeyNames.end()), policyType{ policyType } {}

SubkeyPolicy::SubkeyPolicy(json policy) : RegistryPolicy(policy) {
    assert(policy.find("subkey-names") != policy.end());
    assert(policy.find("subkey-policy-type") != policy.end());

    auto typeString{ ToLowerCaseA(policy["subkey-policy-type"].get<std::string>()) };
    if(typeString == "blacklist") {
        policyType = SubkeyPolicyType::Blacklist;
    } else if(typeString == "whitelist") {
        policyType = SubkeyPolicyType::Whitelist;
    } else
        throw std::exception(("Unknown registry policy type: " + typeString).c_str());

    for(auto& entry : policy["subkey-names"]) {
        subkeyNames.emplace(StringToWidestring(entry.get<std::string>()));
    }
}

bool SubkeyPolicy::Enforce() {
    if(IsEnforced()) {
        if(!MatchesSystem()) {
            for(auto& key : keys){
                auto subkeys{ key.EnumerateSubkeyNames() };
                if(policyType == SubkeyPolicyType::Whitelist){
                    for(auto& subkey : subkeys){
                        if(subkeyNames.find(subkey) == subkeyNames.end()){
                            if(!key.DeleteSubkey(subkey)){
                                return false;
                            }
                        }
                    }
                } else{
                    for(auto& subkey : subkeys){
                        if(subkeyNames.find(subkey) != subkeyNames.end()){
                            if(!key.DeleteSubkey(subkey)){
                                return false;
                            }
                        }
                    }
                }
            }
            return true;
        } else
            return true;
    } else {
        return MatchesSystem();
    }
}

bool SubkeyPolicy::MatchesSystem() const {
    for(auto& key : keys){
        auto subkeys{ key.EnumerateSubkeyNames() };
        if(policyType == SubkeyPolicyType::Whitelist){
            for(auto& subkey : subkeys){
                if(subkeyNames.find(subkey) == subkeyNames.end()){
                    return false;
                }
            }
        } else{
            for(auto& subkey : subkeys){
                if(subkeyNames.find(subkey) != subkeyNames.end()){
                    return false;
                }
            }
        }
    }
    return true;
}

```

`BLUESPAWN-win-client/src/monitor/Event.cpp`:

```cpp
#include "monitor/Event.h"
#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"
#include "monitor/EventListener.h"
#include "user/bluespawn.h"

Event::Event(EventType type) : type(type) {}

void Event::AddCallback(const std::function<void(IN CONST Scope&)>& callback, IN CONST Scope& scope) {
	callbacks.push_back(std::make_pair(callback, scope));
}

void Event::RunCallbacks() const {
	for(auto pair : callbacks){
		pair.first(pair.second);
	}
}

/************************
***   EventLogEvent   ***
*************************/
EventLogEvent::EventLogEvent(const std::wstring& channel, int eventID, const std::vector<EventLogs::XpathQuery>& queries) :
	Event(EventType::EventLog), 
    channel(channel), 
	eventID(eventID), 
	eventLogTrigger{ [this](EventLogs::EventLogItem){ this->RunCallbacks(); } } {}

bool EventLogEvent::Subscribe(){
	LOG_VERBOSE(1, L"Subscribing to EventLog " << channel << L" for Event ID " << eventID);
	DWORD status{};
	auto subscription = EventLogs::SubscribeToEvent(GetChannel(), GetEventID(), eventLogTrigger, queries);
	if(subscription){
		eventSub = *subscription;
	}
	return status;
}

std::wstring EventLogEvent::GetChannel() const {
	return channel;
}

int EventLogEvent::GetEventID() const {
	return eventID;
}

std::vector<EventLogs::XpathQuery> EventLogEvent::GetQueries() const {
	return this->queries;
}

bool EventLogEvent::operator==(const Event& e) const {
	if(e.type == EventType::EventLog && dynamic_cast<const EventLogEvent*>(&e)){
		auto evt = dynamic_cast<const EventLogEvent*>(&e);
		return evt->GetChannel() == channel && evt->GetEventID() == eventID;
	} else return false;
}

RegistryEvent::RegistryEvent(const Registry::RegistryKey& key, bool WatchSubkeys) :
	Event(EventType::Registry),
	key{ key },
	WatchSubkeys{ WatchSubkeys },
	hEvent{ CreateEventW(nullptr, false, false, nullptr) }{}

bool RegistryEvent::Subscribe(){
	LOG_VERBOSE(1, L"Subscribing to Registry Key " << key.ToString());
	auto& manager{ EventListener::GetInstance() };

	auto keypath{ key.GetName() };
	auto status{ RegNotifyChangeKeyValue(key, WatchSubkeys, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_THREAD_AGNOSTIC, hEvent, true) };
	if(ERROR_SUCCESS != status){
		LOG_ERROR("Failed to subscribe to changes to " << key << " (Error " << status << ")");
		return false;
	}

	// Make class members locals so they can be captured
	auto key{ this->key };
	auto WatchSubkeys{ this->WatchSubkeys };
	auto hEvent{ this->hEvent };

	auto subscription = manager.Subscribe(hEvent, {
		[key, WatchSubkeys, hEvent](){
			auto status{ RegNotifyChangeKeyValue(key, WatchSubkeys, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_THREAD_AGNOSTIC, hEvent, true) };
			auto name{ key.GetName() };
			if(ERROR_SUCCESS != status){
				LOG_ERROR("Failed to resubscribe to changes to " << key << " (Error " << status << ")");
			}
		},
		std::bind(&RegistryEvent::RunCallbacks, this)
    });

	if(!subscription){
		LOG_ERROR("Failed to register subscription for changes to " << key);
		return false;
	}

	return true;
}

bool RegistryEvent::operator==(const Event& e) const {
	if(e.type == EventType::Registry && dynamic_cast<const RegistryEvent*>(&e)){
		auto evt = dynamic_cast<const RegistryEvent*>(&e);
		return evt->key.GetName() == key.GetName() && evt->WatchSubkeys == WatchSubkeys;
	} else return false;
}

const HandleWrapper& RegistryEvent::GetEvent() const {
	return hEvent;
}

const Registry::RegistryKey& RegistryEvent::GetKey() const{
	return key;
}

FileEvent::FileEvent(const FileSystem::Folder& directory) :
	Event(EventType::FileSystem),
	directory{ directory },
	hEvent{ nullptr }{}

bool FileEvent::Subscribe(){
	LOG_VERBOSE(1, L"Subscribing to File " << directory.GetFolderPath());

	auto& manager{ EventListener::GetInstance() };

	hEvent = GenericWrapper<HANDLE>{ FindFirstChangeNotificationW(directory.GetFolderPath().c_str(), false, 0x17F), FindCloseChangeNotification };
	if(!hEvent){
		LOG_ERROR("Failed to resubscribe to changes to " << directory.GetFolderPath() << " (Error " << GetLastError() << ")");
		return false;
	}

	// Make local copies to be captured in the lambda
	auto hEvent{ this->hEvent };
	auto directory{ this->directory };

	auto subscription = manager.Subscribe(hEvent, {
		[directory, hEvent](){
			auto status{ FindNextChangeNotification(hEvent) };
			if(!status){
				LOG_ERROR("Failed to resubscribe to changes to " << directory.GetFolderPath() << " (Error " << GetLastError() << ")");
			}
		},
		std::bind(&FileEvent::RunCallbacks, this)
	});
	if(!subscription){
		LOG_ERROR("Failed to register subscription for changes to " << directory.GetFolderPath());
		return false;
	}

	return true;
}

bool FileEvent::operator==(const Event& e) const {
	if(e.type == EventType::FileSystem && dynamic_cast<const FileEvent*>(&e)){
		auto evt = dynamic_cast<const FileEvent*>(&e);
		return evt->GetFolder().GetFolderPath() == directory.GetFolderPath();
	} else return false;
}

const GenericWrapper<HANDLE>& FileEvent::GetEvent() const {
	return hEvent;
}

const FileSystem::Folder& FileEvent::GetFolder() const {
	return directory;
}

namespace Registry {
	void GetRegistryEvents(OUT std::vector<std::pair<std::unique_ptr<Event>, Scope>>& dest, IN CONST Scope& scope,
						   IN HKEY hkHive, IN CONST std::wstring& path, IN bool WatchWow64 OPTIONAL, 
						   IN bool WatchUsers OPTIONAL, IN bool WatchSubkeys OPTIONAL){
		std::unordered_set<RegistryKey> vKeys{ RegistryKey{ hkHive, path } };
		if(WatchWow64){
			RegistryKey Wow64Key{ HKEY(hkHive), path, true };
			if(Wow64Key.Exists()){
				vKeys.emplace(Wow64Key);
			}
		}
		if(WatchUsers){
			auto hkUserHives{ RegistryKey{ HKEY_USERS }.EnumerateSubkeys() };
			for(auto& hive : hkUserHives){
				RegistryKey key{ HKEY(hive), path, false };
				if(key.Exists()){
					vKeys.emplace(key);
				}
				if(WatchWow64){
					RegistryKey Wow64Key{ HKEY(hive), path, true };
					if(Wow64Key.Exists()){
						vKeys.emplace(Wow64Key);
					}
				}
			}
		}
		
		for(auto& key : vKeys){
			dest.emplace_back(std::make_pair(std::make_unique<RegistryEvent>(key), scope));
		}
	}
}

```

`BLUESPAWN-win-client/src/monitor/EventListener.cpp`:

```cpp
#include "monitor/EventListener.h"

#include "util/wrappers.hpp"
#include "util/log/Log.h"
#include "util/ThreadPool.h"

void EventListener::SubEventListener::HandleEventNotify(HANDLE hEvent){
    std::vector<std::function<void()>> functions{};
    if(map.find(hEvent) != map.end()){
        for(auto& f : map.at(hEvent)){
            functions.emplace_back(f);
        }
    }
    if(functions.size()){
        ThreadPool::GetInstance().EnqueueTask([functions](){
            std::for_each(functions.begin(), functions.end(), [](auto& f){ f(); });
        });
    }
}

void EventListener::SubEventListener::ListenForEvents(){
    while(true){

        // Enter a critical section to ensure this function isn't accessing data that isn't ready
        EnterCriticalSection(hSection);
        auto slots{ events.size() };
        auto data{ events.data() };
        LeaveCriticalSection(hSection);

        // Wait on the manager and events
        auto status = WaitForMultipleObjects(slots, data, false, INFINITE);

        // Manager is triggered
        if(status == WAIT_OBJECT_0){
            LOG_VERBOSE(3, "Manager event has been signalled; restarting wait");

            // Trigger manager response
            SetEvent(hManagerResponse);

            // If the thread should terminate, return
            if(terminate){
                return;
            }

            // Recalculate the number of slots and the events, begin wait again
            continue;
        }

        // Event has triggered a callback
        else if(status > WAIT_OBJECT_0 && status < WAIT_OBJECT_0 + slots){
            LOG_VERBOSE(1, "An event has been triggered; processing callbacks");

            // Handle the event notification
            EnterCriticalSection(hSection);
            HandleEventNotify(events[status - WAIT_OBJECT_0]);
            LeaveCriticalSection(hSection);

            // Recalculate the number of slots and the events, begin wait again
            continue;
        }

        else {
            LOG_ERROR("Failed to wait on events with status " << std::hex << status << "; Error code " << GetLastError());
            dwFailureCount++;
            if(dwFailureCount >= 5){
                LOG_ERROR("Five consecutive errors have occured in a SubEventListener; Abandoning " << slots - 1 << " events");
                return;
            }
        }
    }
}

EventListener::SubEventListener::SubEventListener() : 
    hSection{},
    hManager{ CreateEventA(nullptr, false, false, nullptr) },
    hManagerResponse{ CreateEventA(nullptr, false, false, nullptr) },
    dwSlotsFree{ MAXIMUM_WAIT_OBJECTS - 1 },
    dwFailureCount{ 0 },
    events{},
    terminate{ false },
    hThread{ &EventListener::SubEventListener::ListenForEvents, this }{
    events.emplace_back(hManager);
}

EventListener::SubEventListener::~SubEventListener(){
    // Indicate that the thread should terminate next time hManager is set
    terminate = true;

    // Set hManager, terminating the thread. No need to wait on the response; the join
    // will take care of waiting the appropriate amount of time.
    SetEvent(hManager);

    // Wait for the thread to finish
    hThread.join();
}

bool EventListener::SubEventListener::TrySubscribe(
    IN const HANDLE& hEvent,
    IN const std::vector<std::function<void()>>& callbacks
){
    // When reading or writing events, you must enter a critical section
    auto lock{ BeginCriticalSection(hSection) };

    // Check if event already has a subscription
    if(map.find(hEvent) != map.end()){
        LOG_WARNING("Event has already been subscribed to; combining callbacks. Note that it is recommended "
                    "that TryAddCallback be called instead of TrySubscribe to add callbacks");

        auto& eventcallbacks{ map.at(hEvent) };
        for(auto& callback : callbacks){
            eventcallbacks.emplace_back(callback);
        }

        return true;
    }

    if(dwSlotsFree > 0){
        // Set the manager event since we're writing to map 
        SetEvent(hManager);

        LeaveCriticalSection(hSection);
        auto status{ WaitForSingleObject(hManagerResponse, 1000) };

        // Ensure the manager event has been processed before making changes
        while(WAIT_OBJECT_0 != status){
            if(WAIT_TIMEOUT == status){
                // A loop of WaitForSingleObjects with a timeout of 1000 tends to be faster than
                // a single WaitForSingleObject with a timeout of INFINITE
                status = WaitForSingleObject(hManagerResponse, 1000);
            } else {
                EnterCriticalSection(hSection);

                // An error occured; return failure
                SetLastError(status);
                return false;
            }
        }
        EnterCriticalSection(hSection);

        events.emplace_back(hEvent);
        map.emplace(std::move(std::pair<HANDLE, std::vector<std::function<void()>>>{ hEvent, callbacks }));
        dwSlotsFree--;
        return true;
    }

    return false;
}

std::optional<std::vector<std::function<void()>>> EventListener::SubEventListener::GetSubscription(
    IN const HANDLE& hEvent
) const {
    // Enter a critical section before reading `map`
    auto lock{ BeginCriticalSection(hSection) };

    auto result{ map.find(hEvent) };
    if(result == map.end()){
        return std::nullopt;
    }

    return map.at(hEvent);
}

bool EventListener::SubEventListener::TryAddCallback(
    IN const HANDLE& hEvent,
    IN const std::function<void()>& callback
){
    // Enter a critical section before reading `map`
    auto lock{ BeginCriticalSection(hSection) };

    auto result{ map.find(hEvent) };
    if(result == map.end()){
        return false;
    }

    // Modification is allowed without setting hManager because it doesn't change
    // the dwSlotsFree or ordering of elements in map or events
    map.at(hEvent).push_back(callback);
    return true;
}

// Function adopted from https://stackoverflow.com/questions/20833453/comparing-stdfunctions-for-equality
LPVOID getAddress(std::function<void()> f){
    return *(f.template target<void(*)()>());
}

bool EventListener::SubEventListener::TryRemoveCallback(
    IN const HANDLE& hEvent,
    IN const std::function<void()>& callback
){
    // Enter a critical section before reading `map`
    auto lock{ BeginCriticalSection(hSection) };

    auto result{ map.find(hEvent) };
    if(result == map.end()){
        return false;
    }

    auto& callbacks{ map.at(hEvent) };
    for(unsigned idx = 0; idx < callbacks.size(); idx++){

        // operator== is not defined for two std::functions; instead compare their addresses
        // Note that this does not check bound arguments
        if(getAddress(callbacks[idx]) == getAddress(callback)){

            // Modification of callbacks is allowed without setting hManager because it
            // doesn't change the dwSlotsFree or ordering of elements in map or events
            callbacks.erase(callbacks.begin() + idx);
            idx--;
        }
    }

    return true;
}

bool EventListener::SubEventListener::TryUnsubscribe(
    IN const HANDLE& hEvent
){
    auto lock{ BeginCriticalSection(hSection) };

    auto result{ map.find(hEvent) };
    if(result == map.end()){
        return false;
    }

    // Set hManager before modifying events, map, or dwSlotsFree
    SetEvent(hManager);

    auto status{ WaitForSingleObject(hManagerResponse, 1000) };

    // Ensure the manager event has been processed before making changes
    while(WAIT_OBJECT_0 != status){

        if(WAIT_ABANDONED_0 == status){
            // Manager response has gone stale
            hManagerResponse = CreateEventA(nullptr, false, false, nullptr);
        } else if(WAIT_TIMEOUT == status){
            status = WaitForSingleObject(hManagerResponse, 1000);
        } else {
            // An error occured; return failure
            return false;
        }
    }

    map.erase(hEvent);
    for(unsigned idx = 0; idx < events.size(); idx++){
        if(events[idx] == hEvent){
            events.erase(events.begin() + idx);
            idx--;
        }
    }

    dwSlotsFree++;

    return true;
}

EventListener EventListener::instance{};

EventListener::EventListener() : subeventlisteners{}{}

EventListener& EventListener::GetInstance(){
    return instance;
}

bool EventListener::Subscribe(
    const HANDLE& hEvent,
    const std::vector<std::function<void()>>& callbacks
){
    // Acquire lock before accessing subeventlisteners
    auto lock{ BeginCriticalSection(hSection) };

    for(auto& sublistener : subeventlisteners){
        // Try to subscribe to all subeventlisteners. It's O(n) time, but without a much more 
        // complicated structure, there's not really a better way. Even then, this O(n) is a 
        // fast O(n) and is likely faster than asymtotically better methods.
        if(sublistener->TrySubscribe(hEvent, callbacks)){
            return true;
        }
    }
    LOG_VERBOSE(1, "No sub-event listeners available; creating a new one");
    
    auto& listener{ std::make_unique<SubEventListener>() };
    auto success{ listener->TrySubscribe(hEvent, callbacks) };
    subeventlisteners.emplace_back(std::move(listener));

    if(!success){
        LOG_ERROR("Failed to add an event to an empty sub-event listener!");
        return false;
    }

    return true;
}

std::optional<std::vector<std::function<void()>>> EventListener::GetSubscription(
    IN const HANDLE& hEvent
) const {
    // Acquire lock before accessing subeventlisteners
    auto lock{ BeginCriticalSection(hSection) };

    for(auto& sublistener : subeventlisteners){
        // See justification in EventListener::Subscribe
        if(auto& sub = sublistener->GetSubscription(hEvent)){
            return sub;
        }
    }

    LOG_WARNING("Unable to get subscription for event; Event may not have a subscription.");
    return std::nullopt;
}

bool EventListener::AddCallback(
    IN const HANDLE& hEvent,
    IN const std::function<void()>& callback
){
    // Acquire lock before accessing subeventlisteners
    auto lock{ BeginCriticalSection(hSection) };

    for(auto& sublistener : subeventlisteners){
        // See justification in EventListener::Subscribe
        if(sublistener->TryAddCallback(hEvent, callback)){
            return true;
        }
    }

    LOG_ERROR("Unable to add callback to event; Event may not have a subscription.");
    return false;
}

bool EventListener::RemoveCallback(
    IN const HANDLE& hEvent,
    IN const std::function<void()>& callback
){
    // Acquire lock before accessing subeventlisteners
    auto lock{ BeginCriticalSection(hSection) };

    for(auto& sublistener : subeventlisteners){
        // See justification in EventListener::Subscribe
        if(sublistener->TryRemoveCallback(hEvent, callback)){
            return true;
        }
    }

    LOG_ERROR("Unable to remove callback from event; Event may not have a subscription.");
    return false;
}

bool EventListener::Unsubscribe(
    IN const HANDLE& hEvent
){
    // Acquire lock before accessing subeventlisteners
    auto lock{ BeginCriticalSection(hSection) };

    for(auto& sublistener : subeventlisteners){
        // See justification in EventListener::Subscribe
        if(sublistener->TryUnsubscribe(hEvent)){
            return true;
        }
    }

    LOG_ERROR("Unable to unsubscribe from event; Event may not have a subscription.");
    return false;
}
```

`BLUESPAWN-win-client/src/monitor/EventManager.cpp`:

```cpp
#include "monitor/EventManager.h"

#include "util/eventlogs/EventLogs.h"
#include "util/log/Log.h"

EventManager EventManager::manager;

EventManager::EventManager(){}

EventManager& EventManager::GetInstance(){
	return manager;
}

DWORD EventManager::SubscribeToEvent(std::unique_ptr<Event>&& e, const std::function<void(IN CONST Scope&)>& callback, 
									 IN CONST Scope& scope){
	DWORD status = ERROR_SUCCESS;

	for(auto& evt : vEventList){
		if(*evt == *e){
			evt->AddCallback(callback, scope);
			return status;
		}
	} 

	e->AddCallback(callback, scope);
	e->Subscribe();

	vEventList.push_back(std::move(e));

	return status;
}
```

`BLUESPAWN-win-client/src/monitor/etw/ETW_Wrapper.cpp`:

```cpp
/*
#include "monitor/ETW_Wrapper.h"
#include <iostream>

ETW_Wrapper::ETW_Wrapper() : pshellProvider(etw_guid::powershell),
firewallProvider(etw_guid::firewall),
groupPolicyProvider(etw_guid::groupPolicy)
{
}

ETW_Wrapper::~ETW_Wrapper() {
	traceThread->join();
	delete traceThread;
}

void ETW_Wrapper::addPowershellCallback(const std::function <void(const EVENT_RECORD&)>& f) {
	pshellProvider.add_on_event_callback(f);
}

void ETW_Wrapper::addFirewallCallback(const std::function <void(const EVENT_RECORD&)>& f) {
	firewallProvider.add_on_event_callback(f);
}

void ETW_Wrapper::addGPCallback(const std::function <void(const EVENT_RECORD&)>& f) {
	groupPolicyProvider.add_on_event_callback(f);
}

void ETW_Wrapper::init() {
	// user_trace providers typically have any and all flags, whose meanings are
	// unique to the specific providers that are being invoked. To understand these
	// flags, you'll need to look to the ETW event producer.
	//pshellProvider.any(0xf0010000000003ff);

	traceThread = new std::thread(&ETW_Wrapper::startUserTrace, this);
}

void ETW_Wrapper::startUserTrace() {
	userTrace.enable(pshellProvider);
	userTrace.enable(firewallProvider);
	userTrace.enable(groupPolicyProvider);

	// begin listening for events. This call blocks, so if you want to do other things
	// while this runs, you'll need to call this on another thread.
	userTrace.start();
}
*/
```

`BLUESPAWN-win-client/src/reaction/CarveMemory.cpp`:

```cpp
#include "reaction/CarveMemory.h"

#include <iostream>
#include <string>

#include "util/log/Log.h"
#include "util/processes/PERemover.h"

#include "user/bluespawn.h"

namespace Reactions {

    void CarveMemoryReaction::React(IN Detection& detection) {
        auto& data{ std::get<ProcessDetectionData>(detection.data) };
        if(!data.PID) {
            return;
        }

        HandleWrapper process{ OpenProcess(PROCESS_SUSPEND_RESUME, false, *data.PID) };
        if(process) {
            if(Bluespawn::io.GetUserConfirm(L"`" + (data.ProcessCommand ? *data.ProcessCommand : *data.ProcessName) +
                                            L"` (PID " + std::to_wstring(*data.PID) +
                                            L") appears to be infected. "
                                            "Carve out infected memory?") == 1) {
                if(data.ImageName) {
                    if(!PERemover{ *data.PID, *data.ImageName }.RemoveImage()) {
                        LOG_ERROR(L"Failed to carve image " << *data.ImageName << L" from process with PID "
                                                            << *data.PID);
                    } else {
                        LOG_INFO(1, L"Successfully carved image " << *data.ImageName << L" from process with PID "
                                                                  << *data.PID);
                    }
                } else {
                    if(!PERemover{ *data.PID, *data.BaseAddress, *data.MemorySize }.RemoveImage()) {
                        LOG_ERROR(L"Failed to carve memory at " << *data.BaseAddress << L" from process with PID "
                                                                << *data.PID);
                    } else {
                        LOG_INFO(1, L"Successfully carved memory at " << *data.BaseAddress << L" from process with PID "
                                                                      << *data.PID);
                    }
                }
            }
        } else {
            LOG_ERROR("Unable to open potentially infected process " << *data.PID);
        }
    }

    bool CarveMemoryReaction::Applies(IN CONST Detection& detection) {
        return !detection.DetectionStale && detection.type == DetectionType::ProcessDetection &&
               std::get<ProcessDetectionData>(detection.data).type != ProcessDetectionType::MaliciousProcess;
    }
}   // namespace Reactions

```

`BLUESPAWN-win-client/src/reaction/DeleteFile.cpp`:

```cpp
#include "reaction/DeleteFile.h"

#include <iostream>
#include <string>

#include "util/log/Log.h"
#include "util/wrappers.hpp"

#include "user/bluespawn.h"

namespace Reactions {

    void DeleteFileReaction::React(IN Detection& detection) {
        auto data{ std::get<FileDetectionData>(detection.data) };
        if(Bluespawn::io.GetUserConfirm(L"File " + data.FilePath + L" appears to be malicious. Delete file?") == 1) {
            if(!data.FileHandle->Delete()) {
                if(!data.FileHandle->TakeOwnership()) {
                    LOG_VERBOSE(1, "Unable to take ownership of " << data.FilePath << ", still attempting to delete. "
                                                                  << SYSTEM_ERROR);
                }
                ACCESS_MASK del{ 0 };
                Permissions::AccessAddDelete(del);
                std::optional<Permissions::Owner> BluespawnOwner = Permissions::GetProcessOwner();
                if(BluespawnOwner == std::nullopt) {
                    LOG_WARNING("Unable to get process owner, still attempting to delete. " << SYSTEM_ERROR);
                } else {
                    if(!data.FileHandle->GrantPermissions(*BluespawnOwner, del)) {
                        LOG_ERROR("Unable to grant delete permission, still attempting to delete. (Error: "
                                  << GetLastError() << ")");
                    }
                }
                if(!data.FileHandle->Delete()) {
                    LOG_ERROR("Unable to delete file " << data.FilePath << ". " << SYSTEM_ERROR);
                } else {
                    detection.DetectionStale = true;
                }
            } else {
                detection.DetectionStale = true;
            }
        }
    }

    bool DeleteFileReaction::Applies(IN CONST Detection& detection) {
        return !detection.DetectionStale && detection.type == DetectionType::FileDetection;
    }
}   // namespace Reactions

```

`BLUESPAWN-win-client/src/reaction/QuarantineFile.cpp`:

```cpp
#include "reaction/QuarantineFile.h"

#include <iostream>
#include <string>

#include "util/wrappers.hpp"

#include "util/log/Log.h"

#include "user/bluespawn.h"

namespace Reactions {
    void QuarantineFileReaction::React(IN Detection& detection) {
        auto data{ std::get<FileDetectionData>(detection.data) };
        if(Bluespawn::io.GetUserConfirm(L"File " + data.FilePath + L" appears to be malicious. Delete file?") == 1) {
            if(!data.FileHandle->Quarantine()) {
                LOG_ERROR("Unable to quarantine file " << data.FilePath << ". " << SYSTEM_ERROR);
            } else {
                detection.DetectionStale = true;
            }
        }
    }

    bool QuarantineFileReaction::Applies(IN CONST Detection& detection) {
        return !detection.DetectionStale && detection.type == DetectionType::FileDetection;
    }
}   // namespace Reactions

```

`BLUESPAWN-win-client/src/reaction/ReactionManager.cpp`:

```cpp
#include "reaction/ReactionManager.h"

#include "user/bluespawn.h"

#include <algorithm>  

void ReactionManager::React(IN Detection& detection) CONST {
	EnterCriticalSection(detection.hGuard);
	if(detection.remediator && 
	   Bluespawn::io.GetUserConfirm(L"Detection ID " + std::to_wstring(detection.dwID) + L" has a remediator. Use it?",
									-1, ImportanceLevel::MEDIUM)){
		(*detection.remediator)();
		detection.DetectionStale = true;
	}
	std::for_each(reactions.begin(), reactions.end(), [&detection](const auto& f){
		if(f->Applies(detection) && (!detection.remediator || f->IgnoreRemediator)){
			f->React(detection);
		}
	});
	LeaveCriticalSection(detection.hGuard);
}

void ReactionManager::AddHandler(IN std::unique_ptr<Reaction>&& reaction){
	reactions.emplace_back(std::move(reaction));
}
```

`BLUESPAWN-win-client/src/reaction/RemoveValue.cpp`:

```cpp
#include <string>
#include <iostream>

#include "reaction/RemoveValue.h"
#include "util/configurations/Registry.h"
#include "util/wrappers.hpp"
#include "user/bluespawn.h"
#include "util/log/Log.h"

namespace Reactions{

	void RemoveValueReaction::React(IN Detection& detection){
		auto& data{ std::get<RegistryDetectionData>(detection.data) };
		if(data.value){
			if(Bluespawn::io.GetUserConfirm(L"Registry key `" + data.key.ToString() + L"` contains potentially "
											"malicious value `" + data.value->wValueName + L"` with data `" + 
											data.value->ToString() + L"`. Remove this value?") == 1){
				auto type{ data.key.GetValueType(data.value->wValueName) };
				if(data.key.GetValueType(data.value->wValueName) == data.value->GetType()){
					if(!data.key.RemoveValue(data.value->wValueName)){
						LOG_ERROR("Unable to remove registry value `" << data.value->ToString() << "`: `" <<
								  data.value->wValueName << "` (Error " << GetLastError() << ")");
					} else{
						detection.DetectionStale = true;
					}
				} else{
					if(type == RegistryType::REG_MULTI_SZ_T){
						auto val{ *data.key.GetValue<std::vector<std::wstring>>(data.value->wValueName) };
						for(size_t idx{ 0 }; idx < val.size(); idx++){
							if(val[idx] == std::get<std::wstring>(data.value->data)){
								val.erase(val.begin() + idx);
								idx--;
							}
						}
						if(!data.key.SetValue<std::vector<std::wstring>>(data.value->wValueName, val)){
							LOG_ERROR("Unable to remove registry value `" << data.value->ToString() << "`: `" <<
									  data.value->wValueName << "` (Error " << GetLastError() << ")");
						} else{
							detection.DetectionStale = true;
						}
					} else{
						LOG_ERROR("Unable to remove registry value `" << data.value->ToString() << "` from `" <<
								  data.value->wValueName << "` (Error " << GetLastError() << ")");
					}
				}
			}
		}
	}

	bool RemoveValueReaction::Applies(IN CONST Detection& detection){
		return !detection.DetectionStale && detection.type == DetectionType::RegistryDetection;
	}
}

```

`BLUESPAWN-win-client/src/reaction/SuspendProcess.cpp`:

```cpp
#include <string>
#include <iostream>

#include "reaction/SuspendProcess.h"
#include "util/wrappers.hpp"
#include "util/log/Log.h"
#include "user/bluespawn.h"

#include <psapi.h>

LINK_FUNCTION(NtSuspendProcess, NTDLL.DLL)

namespace Reactions{

	void SuspendProcessReaction::React(IN Detection& detection){
		auto& data{ std::get<ProcessDetectionData>(detection.data) };
		if(data.PID){
			HandleWrapper process{ OpenProcess(PROCESS_SUSPEND_RESUME, false, *data.PID) };
			if(process){
				if(Bluespawn::io.GetUserConfirm(L"`" + (data.ProcessCommand ? *data.ProcessCommand : *data.ProcessName) +
												L"` (PID " + std::to_wstring(*data.PID) + L") appears to be infected. "
												"Suspend process?") == 1){
					Linker::NtSuspendProcess(process);
				}
			} else{
				LOG_ERROR("Unable to open potentially infected process " << *data.PID);
			}
		}
	}

	bool SuspendProcessReaction::Applies(IN CONST Detection& detection){
		return !detection.DetectionStale && detection.type == DetectionType::ProcessDetection;
	}
}
```

`BLUESPAWN-win-client/src/scan/Detection.cpp`:

```cpp
#include <sstream>

#include "util/StringUtils.h"
#include "util/Utils.h"

#include "util/processes/ProcessUtils.h"

#include "scan/Detections.h"

size_t ComputeHash(IN CONST std::map<std::wstring, std::wstring>& map) {
    size_t hash{ 0 };

    std::hash<std::wstring> hasher{};
    for(auto& pair : map) {
        auto first{ hasher(pair.first) };
        auto second{ hasher(pair.second) };
#ifdef _WIN64
        hash = ((hash << 35) | (hash >> 29)) ^ ((first >> 32) | ((first << 32) >> 32)) ^
               ((second << 32) | ((second >> 32) << 32));
#else
        hash = ((hash << 19) | (hash >> 13)) ^ ((first >> 16) | ((first << 16) >> 16)) ^
            ((second << 16) | ((second >> 16) << 16));
#endif
    }

    return hash;
}

size_t ComputeHash(IN CONST std::vector<std::wstring>& values){
    size_t hash{ 0 };

    std::hash<std::wstring> hasher{};
    for(auto& val : values){
        auto first{ hasher(val) };
#ifdef _WIN64
        hash = ((hash << 35) | (hash >> 29)) ^ ((first >> 32) | ((first << 32) >> 32));
#else
        hash = ((hash << 19) | (hash >> 14)) ^ ((first >> 16) | ((first << 16) >> 16));
#endif
    }

    return hash;
}

ProcessDetectionData
ProcessDetectionData::CreateImageDetectionData(IN DWORD PID,
                                               IN CONST std::wstring& ProcessName,
                                               IN CONST std::wstring& ImageName,
                                               IN CONST std::optional<PVOID64>& BaseAddress OPTIONAL,
                                               IN CONST std::optional<DWORD>& MemorySize OPTIONAL,
                                               IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                               IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                               IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    HandleWrapper hProcess{ OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, PID) };
    if(hProcess) {
        return CreateImageDetectionData(hProcess, ProcessName, ImageName, BaseAddress, MemorySize, ProcessPath,
                                        ProcessCommand, std::move(ParentProcess));
    } else {
        return ProcessDetectionData{
            ProcessDetectionType::MaliciousMemory,
            PID,                        // PID
            std::nullopt,               // TID
            std::nullopt,               // ProcessHandle
            ProcessName,                // ProcessName
            ProcessPath,                // ProcessPath
            ProcessCommand,             // ProcessCommand
            std::move(ParentProcess),   // ParentProcess
            BaseAddress,                // BaseAddress
            MemorySize,                 // MemorySize
            ImageName                   // ImageName
        };
    }
}

ProcessDetectionData
ProcessDetectionData::CreateImageDetectionData(IN CONST HandleWrapper& ProcessHandle,
                                               IN CONST std::wstring& ProcessName,
                                               IN CONST std::wstring& ImageName,
                                               IN CONST std::optional<PVOID64>& BaseAddress OPTIONAL,
                                               IN CONST std::optional<DWORD>& MemorySize OPTIONAL,
                                               IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                               IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                               IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    auto addr{ BaseAddress ? *BaseAddress : GetModuleAddress(ProcessHandle, ImageName) };

    return ProcessDetectionData{
        ProcessDetectionType::MaliciousImage,                                     // type
        GetProcessId(ProcessHandle),                                              // PID
        std::nullopt,                                                             // TID
        ProcessHandle,                                                            // ProcessHandle
        ProcessName,                                                              // ProcessName
        ProcessPath ? ProcessPath : GetProcessImage(ProcessHandle),               // ProcessPath
        ProcessCommand ? ProcessCommand : GetProcessCommandline(ProcessHandle),   // ProcessCommand
        std::move(ParentProcess),                                                 // ParentProcess
        addr,                                                                     // BaseAddress
        MemorySize ? MemorySize : GetRegionSize(ProcessHandle, addr),             // MemorySize
        ImageName                                                                 // ImageName
    };
}

ProcessDetectionData
ProcessDetectionData::CreateProcessDetectionData(IN DWORD PID,
                                                 IN CONST std::wstring& ProcessName,
                                                 IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                                 IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                                 IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    HandleWrapper hProcess{ OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, PID) };
    if(hProcess) {
        return CreateProcessDetectionData(hProcess, ProcessName, ProcessPath, ProcessCommand, std::move(ParentProcess));
    } else {
        return ProcessDetectionData{
            ProcessDetectionType::MaliciousProcess,
            PID,                        // PID
            std::nullopt,               // TID
            std::nullopt,               // ProcessHandle
            ProcessName,                // ProcessName
            ProcessPath,                // ProcessPath
            ProcessCommand,             // ProcessCommand
            std::move(ParentProcess),   // ParentProcess
            std::nullopt,               // BaseAddress
            std::nullopt,               // MemorySize
            std::nullopt                // ImageName
        };
    }
}

ProcessDetectionData ProcessDetectionData::CreateCommandDetectionData(IN CONST std::wstring& ProcessCommand) {
    return ProcessDetectionData{
        ProcessDetectionType::MaliciousCommand,
        std::nullopt,     // PID
        std::nullopt,     // TID
        std::nullopt,     // ProcessHandle
        std::nullopt,     // ProcessName
        std::nullopt,     // ProcessPath
        ProcessCommand,   // ProcessCommand
        nullptr,          // ParentProcess
        std::nullopt,     // MemorySize
        std::nullopt,     // BaseAddress
        std::nullopt      // ImageName
    };
}

ProcessDetectionData
ProcessDetectionData::CreateProcessDetectionData(IN CONST HandleWrapper& ProcessHandle,
                                                 IN CONST std::wstring& ProcessName,
                                                 IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                                 IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                                 IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    return ProcessDetectionData{
        ProcessDetectionType::MaliciousProcess,                                   // type
        GetProcessId(ProcessHandle),                                              // PID
        std::nullopt,                                                             // TID
        ProcessHandle,                                                            // ProcessHandle
        ProcessName,                                                              // ProcessName
        ProcessPath ? ProcessPath : GetProcessImage(ProcessHandle),               // ProcessPath
        ProcessCommand ? ProcessCommand : GetProcessCommandline(ProcessHandle),   // ProcessCommand
        std::move(ParentProcess),                                                 // ParentProcess
        std::nullopt,                                                             // BaseAddress
        std::nullopt,                                                             // MemorySize
        std::nullopt                                                              // ImageName
    };
}

ProcessDetectionData
ProcessDetectionData::CreateMemoryDetectionData(IN DWORD PID,
                                                IN CONST std::wstring& ProcessName,
                                                IN PVOID64 BaseAddress,
                                                IN DWORD MemorySize,
                                                IN CONST std::optional<std::wstring>& ImageName OPTIONAL,
                                                IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                                IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                                IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    HandleWrapper hProcess{ OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, PID) };
    if(hProcess) {
        return CreateMemoryDetectionData(hProcess, ProcessName, BaseAddress, MemorySize, ImageName, ProcessPath,
                                         ProcessCommand, std::move(ParentProcess));
    } else {
        auto image{ ImageName };
        if(image && !image->length()){
            image = std::nullopt;
        }
        return ProcessDetectionData{
            ProcessDetectionType::MaliciousMemory,
            PID,                        // PID
            std::nullopt,               // TID
            std::nullopt,               // ProcessHandle
            ProcessName,                // ProcessName
            ProcessPath,                // ProcessPath
            ProcessCommand,             // ProcessCommand
            std::move(ParentProcess),   // ParentProcess
            BaseAddress,                // BaseAddress
            MemorySize,                 // MemorySize
            image                       // ImageName
        };
    }
}

ProcessDetectionData
ProcessDetectionData::CreateMemoryDetectionData(IN CONST HandleWrapper& ProcessHandle,
                                                IN CONST std::wstring& ProcessName,
                                                IN PVOID64 BaseAddress,
                                                IN DWORD MemorySize,
                                                IN CONST std::optional<std::wstring>& ImageName OPTIONAL,
                                                IN CONST std::optional<std::wstring>& ProcessPath OPTIONAL,
                                                IN CONST std::optional<std::wstring>& ProcessCommand OPTIONAL,
                                                IN std::unique_ptr<ProcessDetectionData>&& ParentProcess OPTIONAL) {
    std::optional<std::wstring> image{ ImageName };
    if(!image) {
        auto mapped{ GetMappedFile(ProcessHandle, BaseAddress) };
        if(mapped) { image = mapped->GetFilePath(); }
    }
    if(image && !image->length()){
        image = std::nullopt;
    }

    return ProcessDetectionData{
        ProcessDetectionType::MaliciousMemory,                                    // type
        GetProcessId(ProcessHandle),                                              // PID
        std::nullopt,                                                             // TID
        ProcessHandle,                                                            // ProcessHandle
        ProcessName,                                                              // ProcessName
        ProcessPath ? ProcessPath : GetProcessImage(ProcessHandle),               // ProcessPath
        ProcessCommand ? ProcessCommand : GetProcessCommandline(ProcessHandle),   // ProcessCommand
        std::move(ParentProcess),                                                 // ParentProcess
        BaseAddress,                                                              // BaseAddress
        MemorySize,                                                               // MemorySize
        image                                                                     // ImageName
    };
}

ProcessDetectionData::ProcessDetectionData(IN ProcessDetectionType type,
                                           IN CONST std::optional<DWORD> PID,
                                           IN CONST std::optional<DWORD>& TID,
                                           IN CONST std::optional<HandleWrapper>& ProcessHandle,
                                           IN CONST std::optional<std::wstring>& ProcessName,
                                           IN CONST std::optional<std::wstring>& ProcessPath,
                                           IN CONST std::optional<std::wstring>& ProcessCommand,
                                           IN std::unique_ptr<ProcessDetectionData>&& ParentProcess,
                                           IN CONST std::optional<PVOID64>& BaseAddress,
                                           IN CONST std::optional<DWORD>& MemorySize,
                                           IN CONST std::optional<std::wstring>& ImageName) :
    type{ type },
    PID{ PID }, TID{ TID }, ProcessHandle{ ProcessHandle }, ProcessName{ ProcessName }, ProcessPath{ ProcessPath },
    ProcessCommand{ ProcessCommand }, ParentProcess{ std::move(ParentProcess) }, BaseAddress{ BaseAddress },
    MemorySize{ MemorySize }, ImageName{ ImageName } {
    auto tied{ std::tie(type, PID, TID, ProcessHandle, ProcessName, ProcessPath, ProcessCommand, ParentProcess,
                        BaseAddress, MemorySize, ImageName) };

    serialization = std::map<std::wstring, std::wstring>{
        { L"Type", type == ProcessDetectionType::MaliciousImage ?
                       L"Image" :
                       type == ProcessDetectionType::MaliciousMemory ?
                       L"Memory" :
                       type == ProcessDetectionType::MaliciousProcess ? L"Process" : L"Command" },
    };
    if(PID) serialization.emplace(L"PID", std::to_wstring(*PID));
    if(TID) serialization.emplace(L"TID", std::to_wstring(*TID));
    if(ProcessName) serialization.emplace(L"Process Name", *ProcessName);
    if(ProcessPath) serialization.emplace(L"Process Path", *ProcessPath);
    if(ProcessCommand) serialization.emplace(L"Process Command", *ProcessCommand);
    if(ParentProcess && ParentProcess->PID) serialization.emplace(L"Parent PID", std::to_wstring(*ParentProcess->PID));
    if(BaseAddress) {
        std::wstringstream wss{};
        wss << std::hex << *BaseAddress;
        serialization.emplace(L"Base Address", wss.str());
    }
    if(MemorySize) serialization.emplace(L"Memory Size", std::to_wstring(*MemorySize));
    if(ImageName) serialization.emplace(L"Image Name", *ImageName);

    hash = ComputeHash(serialization);
}

const std::map<std::wstring, std::wstring>& ProcessDetectionData::Serialize() CONST {
    return serialization;
}

size_t ProcessDetectionData::Hash() CONST {
    return hash;
}

bool ProcessDetectionData::operator==(IN CONST ProcessDetectionData& data) CONST {
    if(type != data.type){
        return false;
    }
    if(type == ProcessDetectionType::MaliciousCommand){
        return *ProcessCommand == *data.ProcessCommand;
    } else if(type == ProcessDetectionType::MaliciousImage){
        return *PID == *data.PID && *ImageName == *data.ImageName;
    } else if(type == ProcessDetectionType::MaliciousMemory){
        return *PID == *data.PID && *BaseAddress == *data.BaseAddress;
    } else{
        return *PID == *data.PID;
    }
}

FileDetectionData::FileDetectionData(IN CONST FileSystem::File& file,
                                     IN CONST std::optional<YaraScanResult>& scan OPTIONAL) :
    FileFound{ file.GetFileExists() },
    FilePath{ file.GetFilePath() }, FileName{ FilePath.find(L"\\/") == std::wstring::npos ?
                                                  FilePath :
                                                  FilePath.substr(FilePath.find_last_of(L"\\/")) },
    FileExtension{ file.GetFileAttribs().extension },
    FileHandle{ file }, MD5{ file.GetMD5Hash() }, SHA1{ file.GetSHA1Hash() }, SHA256{ file.GetSHA256Hash() },
    LastOpened{ file.GetAccessTime() }, FileCreated{ file.GetCreationTime() },
    yara{ scan ?
              scan :
              (FileFound ? std::optional<YaraScanResult>(YaraScanner::GetInstance().ScanFile(file)) : std::nullopt) },
    FileSigned{ FileFound ? std::optional<bool>(file.GetFileSigned()) : std::nullopt }, Signer{
        FileSigned && *FileSigned ? file.GetCertificateIssuer() : std::nullopt
    } {
    if(FileExtension) {
        Registry::RegistryKey FileExtClass{ HKEY_CLASSES_ROOT, *FileExtension };
        if(FileExtClass.Exists() && FileExtClass.ValueExists(L"")) {
            FileType = FileExtClass.GetValue<std::wstring>(L"");
            if(FileType) {
                Registry::RegistryKey FileClass{ HKEY_CLASSES_ROOT, *FileType };
                if(FileClass.Exists()) {
                    Registry::RegistryKey shell{ FileClass, L"shell\\open\\command" };
                    auto command{ shell.GetValue<std::wstring>(L"") };
                    if(command) { 
                        Executor = StringReplaceW(StringReplaceW(*command, L"%1", FilePath), L"%*", L"");
                    }
                }
            }
        }
    }

    serialization = std::map<std::wstring, std::wstring>{
        { L"Path", FilePath },
        { L"Name", FileName },
        { L"Exists", FileFound ? L"true" : L"false" },
    };
    if(FileExtension) serialization.emplace(L"Extension", *FileExtension);
    if(FileType) serialization.emplace(L"File Type", *FileType);
    if(Executor) serialization.emplace(L"File Executor", *Executor);
    if(MD5) serialization.emplace(L"MD5 Hash", *MD5);
    if(SHA1) serialization.emplace(L"SHA1 Hash", *SHA1);
    if(SHA256) serialization.emplace(L"SHA256 Hash", *SHA256);
    if(LastOpened) serialization.emplace(L"Last Opened", FormatWindowsTime(*LastOpened));
    if(FileCreated) serialization.emplace(L"Date Created", FormatWindowsTime(*FileCreated));
    if(yara) {
        std::wstring malicious{};
        for(auto& mal : yara->vKnownBadRules) {
            if(malicious.length()) malicious += L", ";
            malicious += mal;
        }
        std::wstring identifier{};
        for(auto& id : yara->vIndicatorRules) {
            if(identifier.length()) identifier += L", ";
            identifier += id;
        }
        serialization.emplace(L"Malicious Yara Rules", malicious);
        serialization.emplace(L"Other Yara Rules", identifier);
    }
    if(FileSigned) serialization.emplace(L"Signed", *FileSigned ? L"true" : L"false");
    if(Signer) serialization.emplace(L"Signer", *Signer);

    hash = ComputeHash(std::vector<std::wstring>{ FilePath, SHA256 ? *SHA256 : L"" });
}

FileDetectionData::FileDetectionData(IN CONST std::wstring& path) :
    FileDetectionData(FileSystem::File{ path }, std::nullopt) {}

const std::map<std::wstring, std::wstring>& FileDetectionData::Serialize() CONST {
    return serialization;
}

size_t FileDetectionData::Hash() CONST {
    return hash;
}

bool FileDetectionData::operator==(IN CONST FileDetectionData& data) const {
    if(data.SHA256 != SHA256) { return false; }
    return FilePath == data.FilePath;
}

RegistryDetectionData::RegistryDetectionData(IN CONST Registry::RegistryKey& key,
                                             IN CONST std::optional<Registry::RegistryValue>& value OPTIONAL,
                                             IN RegistryDetectionType type OPTIONAL,
                                             IN CONST std::optional<AllocationWrapper>& data OPTIONAL) :
    KeyPath{ key.GetName() },
    key{ key }, value{ value }, type{ type }, data{ data } {
    serialization = std::map<std::wstring, std::wstring>{
        { L"Key Path", key.GetName() },
        { L"Registry Entry Type", type == RegistryDetectionType::CommandReference ?
                                      L"Command" :
                                      type == RegistryDetectionType::Configuration ?
                                      L"Configuration" :
                                      type == RegistryDetectionType::FileReference ?
                                      L"File" :
                                      type == RegistryDetectionType::FolderReference ?
                                      L"Folder" :
                                      type == RegistryDetectionType::PipeReference ?
                                      L"Pipe" :
                                      type == RegistryDetectionType::ShareReference ?
                                      L"Share" :
                                      type == RegistryDetectionType::UserReference ? L"User" : L"Unknown" }
    };
    if(value) {
        serialization.emplace(L"Key Value Name", value->wValueName);
        serialization.emplace(L"Key Value Data", value->ToString());
    }

    hash = ComputeHash(std::vector<std::wstring>{ KeyPath, value ? value->wValueName : L"" });
}

RegistryDetectionData::RegistryDetectionData(IN CONST Registry::RegistryValue& value,
                                             IN RegistryDetectionType type OPTIONAL) :
    RegistryDetectionData{ value.key, value, type, value.key.GetRawValue(value.wValueName) } {}

const std::map<std::wstring, std::wstring>& RegistryDetectionData::Serialize() CONST {
    return serialization;
}

size_t RegistryDetectionData::Hash() CONST {
    return hash;
}

bool RegistryDetectionData::operator==(IN CONST RegistryDetectionData& data) CONST {
    return KeyPath == data.KeyPath && value->wValueName == data.value->wValueName;
}

ServiceDetectionData::ServiceDetectionData(IN CONST std::optional<std::wstring>& ServiceName OPTIONAL,
                                           IN CONST std::optional<std::wstring>& DisplayName OPTIONAL,
                                           IN CONST std::optional<std::wstring>& FilePath OPTIONAL,
                                           IN CONST std::optional<std::wstring>& Description OPTIONAL) :
    ServiceName{ ServiceName },
    DisplayName{ DisplayName }, FilePath{ FilePath }, Description{ Description } {
    serialization = std::map<std::wstring, std::wstring>{};
    if(ServiceName) { serialization.emplace(L"Service Name", *ServiceName); }
    if(FilePath) { serialization.emplace(L"Service Executable", *FilePath); }
    if(DisplayName) { serialization.emplace(L"Display Name", *DisplayName); }
    if(Description) { serialization.emplace(L"Description", *Description); }

    hash = ComputeHash(serialization);
}

const std::map<std::wstring, std::wstring>& ServiceDetectionData::Serialize() CONST {
    return serialization;
}

size_t ServiceDetectionData::Hash() CONST {
    return hash;
}

OtherDetectionData::OtherDetectionData(IN CONST std::wstring& DetectionType,
                                       IN CONST std::map<std::wstring, std::wstring>& DetectionProperties) :
    DetectionType{ DetectionType },
    DetectionProperties{ DetectionProperties }, serialization(DetectionProperties.begin(), DetectionProperties.end()) {
    serialization.emplace(L"Detection Type", DetectionType);
    hash = ComputeHash(serialization);
}

const std::map<std::wstring, std::wstring>& OtherDetectionData::Serialize() CONST {
    return serialization;
}

size_t OtherDetectionData::Hash() CONST {
    return hash;
}

DetectionContext::DetectionContext(IN CONST std::optional<std::wstring>& hunt OPTIONAL,
                                   IN CONST std::optional<FILETIME>& FirstEvidenceTime OPTIONAL,
                                   IN CONST std::optional<std::wstring>& note OPTIONAL) :
    FirstEvidenceTime{ FirstEvidenceTime },
    note{ note } {
    if(hunt) hunts.emplace(*hunt);

    GetSystemTimeAsFileTime(&DetectionCreatedTime);
}

decltype(Detection::serializer) Detection::serializer{};
decltype(Detection::hasher) Detection::hasher{};

Detection::Detection(IN CONST DetectionData& data,
                     IN CONST std::optional<DetectionContext>& context OPTIONAL,
                     IN CONST std::optional<std::function<void()>>& remediator OPTIONAL,
                     IN bool DetectionStale OPTIONAL) :
    data{ data },
    DetectionStale{ DetectionStale }, type{ DetectionType::OtherDetection }, dwID{ IDCounter++ },
    remediator{ remediator }, context{ context ? *context : DetectionContext{} } {
    if(data.index() == 0) {
        type = DetectionType::ProcessDetection;
    } else if(data.index() == 1) {
        type = DetectionType::FileDetection;
    } else if(data.index() == 2) {
        type = DetectionType::RegistryDetection;
    } else if(data.index() == 3) {
        type = DetectionType::ServiceDetection;
    }

    hash = std::visit(hasher, data);
    auto tmp{ std::visit(serializer, data) };
    serialization = std::map<std::wstring, std::wstring>(tmp.begin(), tmp.end());
}

Detection::Detection(IN CONST Detection& detection) :
    data{ detection.data }, DetectionStale{ detection.DetectionStale }, type{ detection.type }, dwID{ detection.dwID },
    remediator{ detection.remediator }, context{ detection.context }, hash{ detection.hash }, 
    serialization{ detection.serialization } {
    info.associations = std::make_unique<std::unordered_map<std::shared_ptr<Detection>, Association>>(
        *detection.info.associations);
    info.bAssociativeStale = detection.info.bAssociativeStale;
    info.cAssociativeCertainty = detection.info.cAssociativeCertainty;
    info.certainty = detection.info.certainty;
}

Detection& Detection::operator=(IN CONST Detection& detection) {
    data = detection.data;
    DetectionStale = detection.DetectionStale;
    type = detection.type;
    dwID = detection.dwID;
    remediator = detection.remediator;
    context = detection.context;
    hash = detection.hash;
    serialization = detection.serialization;
    info = {};
    info.associations = std::make_unique<std::unordered_map<std::shared_ptr<Detection>, Association>>(
        *detection.info.associations);
    info.bAssociativeStale = detection.info.bAssociativeStale;
    info.cAssociativeCertainty = detection.info.cAssociativeCertainty;
    info.certainty = detection.info.certainty;
    return *this;
}

bool Detection::operator==(IN CONST Detection& detection) CONST {
    if(type != detection.type) { return false; }

    if(type == DetectionType::ProcessDetection) {
        return std::get<ProcessDetectionData>(data) == std::get<ProcessDetectionData>(detection.data);
    } else if(type == DetectionType::ServiceDetection) {
        return std::get<ServiceDetectionData>(data) == std::get<ServiceDetectionData>(detection.data);
    } else if(type == DetectionType::RegistryDetection) {
        return std::get<RegistryDetectionData>(data) == std::get<RegistryDetectionData>(detection.data);
    } else if(type == DetectionType::FileDetection) {
        return std::get<FileDetectionData>(data) == std::get<FileDetectionData>(detection.data);
    } else {
        return std::get<OtherDetectionData>(data) == std::get<OtherDetectionData>(detection.data);
    }
}

Detection::operator PCRITICAL_SECTION() {
    return hGuard;
}

Detection::operator CriticalSection(){
    return hGuard;
}

const std::map<std::wstring, std::wstring>& Detection::Serialize() CONST {
    return serialization;
};

size_t std::hash<Detection>::operator()(IN CONST Detection& detection) CONST {
    return detection.hash;
}

size_t
std::hash<std::shared_ptr<Detection>>::operator()(IN CONST std::shared_ptr<Detection>& detection) CONST {
    return detection->hash;
}

bool std::equal_to<std::shared_ptr<Detection>>::operator()(
    IN CONST std::shared_ptr<Detection>& _Left, IN CONST std::shared_ptr<Detection>& _Right) CONST {
    return *_Left == *_Right;
}

```

`BLUESPAWN-win-client/src/scan/DetectionRegister.cpp`:

```cpp
#include "scan/DetectionRegister.h"

#include <unordered_set>

#include "util/ThreadPool.h"

#include "scan/Scanner.h"
#include "user/bluespawn.h"

DetectionRegister::DetectionRegister(IN CONST Certainty& threshold) :
    threshold{ threshold }, hEvent{ CreateEventW(nullptr, true, true, nullptr) } {}

void DetectionRegister::AddDetectionAsync(IN CONST std::shared_ptr<Detection>& detection,
                                          IN CONST Certainty& certainty) {
    EnterCriticalSection(*detection);
    detection->info.SetCertainty(certainty);
    for(auto& scan : Scanner::scanners) {
        detection->info.AddCertainty(scan->ScanDetection(*detection));
    }

    auto associations{ detection->info.GetAssociations() };
    LeaveCriticalSection(*detection);
    for(auto& pair : associations){
        pair.first->info.bAssociativeStale = true;
        for(auto& sink : Bluespawn::detectionSinks){
            sink->UpdateCertainty(pair.first);
        }
    }
    EnterCriticalSection(*detection);

    for(auto& scan : Scanner::scanners) {
        for(auto& pair : scan->GetAssociatedDetections(*detection)){
            detection->info.AddAssociation(pair.first, pair.second);
            pair.first->info.AddAssociation(detection, pair.second);

            auto first{ detection->dwID < pair.first->dwID ? detection : pair.first };
            auto second{ detection->dwID < pair.first->dwID ? pair.first : detection };

            LeaveCriticalSection(*detection);
            for(auto& sink : Bluespawn::detectionSinks){
                sink->RecordAssociation(first, second, pair.second);
            }
            EnterCriticalSection(*detection);
        }
    }

    EnterCriticalSection(hScannedGuard);
    scanned.emplace(detection);
    LeaveCriticalSection(hScannedGuard);

    EnterCriticalSection(hQueueGuard);
    queue.erase(detection);
    if(queue.size() == 0) {
        SetEvent(hEvent);
    }
    LeaveCriticalSection(hQueueGuard);

    if(detection->info.GetCertainty() >= threshold) {
        LeaveCriticalSection(*detection);
        for(auto& sink : Bluespawn::detectionSinks) {
            sink->RecordDetection(detection, RecordType::PostScan);
        }

        EnterCriticalSection(*detection);
        Bluespawn::reaction.React(*detection);
    }
    LeaveCriticalSection(*detection);
}

void DetectionRegister::UpdateDetectionCertainty(IN CONST std::shared_ptr<Detection>& detection,
                                                 IN CONST Certainty& certainty) {
    EnterCriticalSection(*detection);

    // if the detection is queued and we can enter its critical section, it hasn't been scanned yet
    bool queued{ false };
    EnterCriticalSection(hQueueGuard);
    if(queue.find(detection) != queue.end()) {
        detection->info.AddCertainty(certainty);
        queued = true;
    }
    LeaveCriticalSection(hQueueGuard);

    // The detection has been scanned
    if(!queued) {
        bool below{ !(detection->info.GetCertainty() >= threshold) };

        detection->info.AddCertainty(certainty);

        // This update caused it to pass the threshold, so scan for assocations
        if(below && detection->info.GetCertainty() >= threshold) {
            for(auto& scan : Scanner::scanners) {
                for(auto& pair : scan->GetAssociatedDetections(*detection)) {
                    detection->info.AddAssociation(pair.first, pair.second);
                    pair.first->info.AddAssociation(detection, pair.second);

                    auto first{ detection->dwID < pair.first->dwID ? detection : pair.first };
                    auto second{ detection->dwID < pair.first->dwID ? pair.first : detection };
                    for(auto& sink : Bluespawn::detectionSinks) {
                        sink->RecordAssociation(first, second, pair.second);
                    }
                }
            }

            LeaveCriticalSection(*detection);
            for(auto& sink : Bluespawn::detectionSinks){
                sink->RecordDetection(detection, RecordType::PostScan);
            }

            EnterCriticalSection(*detection);
            Bluespawn::reaction.React(*detection);
        } else if(!below && detection->info.GetCertainty() >= threshold){
            LeaveCriticalSection(*detection);
            for(auto& sink : Bluespawn::detectionSinks){
                sink->UpdateCertainty(detection);
            }
            EnterCriticalSection(*detection);
        }

        // Existing associations' associativity scores are now stale
        for(auto& pair : detection->info.GetAssociations()) {
            pair.first->info.bAssociativeStale = true;
            for(auto& sink : Bluespawn::detectionSinks){
                sink->UpdateCertainty(pair.first);
            }
        }
    } 

    LeaveCriticalSection(*detection);
}

std::shared_ptr<Detection> DetectionRegister::AddDetection(IN Detection&& raw, IN CONST Certainty& certainty) {
    auto detection{ std::make_shared<Detection>(raw) };
    for(auto& sink : Bluespawn::detectionSinks){
        sink->RecordDetection(detection, RecordType::PreScan);
    }

    EnterCriticalSection(hScannedGuard);
    auto itr{ scanned.find(detection) };
    if(itr != scanned.end()) {
        LeaveCriticalSection(hScannedGuard);
        auto ref{ *itr };
        for(auto& hunt : raw.context.hunts){
            if(ref->context.hunts.find(hunt) == ref->context.hunts.end()){
                ThreadPool::GetInstance().EnqueueTask(
                    std::bind(&DetectionRegister::UpdateDetectionCertainty, this, ref, certainty));
                return ref;
            }
        }
        return ref;
    }
    LeaveCriticalSection(hScannedGuard);

    EnterCriticalSection(hQueueGuard);
    itr = queue.find(detection);
    if(itr != queue.end()) {
        LeaveCriticalSection(hQueueGuard);
        auto ref{ *itr };
        for(auto& hunt : raw.context.hunts){
            if(ref->context.hunts.find(hunt) == ref->context.hunts.end()){
                ThreadPool::GetInstance().EnqueueTask(
                    std::bind(&DetectionRegister::UpdateDetectionCertainty, this, ref, certainty));
                return ref;
            }
        }
        return ref;
    }
    LeaveCriticalSection(hQueueGuard);

    EnterCriticalSection(hGuard);
    detections.emplace_back(detection);
    std::shared_ptr<Detection> ref{ detections[detections.size() - 1] };
    ids.emplace(detection->dwID, ref);
    LeaveCriticalSection(hGuard);

    for(auto& sink : Bluespawn::detectionSinks) {
        sink->RecordDetection(ref, RecordType::PreScan);
    }

    ResetEvent(hEvent);

    EnterCriticalSection(hQueueGuard);
    queue.emplace(ref);
    LeaveCriticalSection(hQueueGuard);

    ThreadPool::GetInstance().EnqueueTask(std::bind(&DetectionRegister::AddDetectionAsync, this, ref, certainty));

    return ref;
}

void DetectionRegister::Wait() CONST {
    auto status{ WaitForSingleObject(hEvent, INFINITE) };
    if(status != ERROR_SUCCESS) {
        BeginCriticalSection _{ hQueueGuard };
        if(queue.size() != 0) {
            throw std::exception{ "Failed to wait for detection register to finish scans!" };
        }
    }
}

DetectionRegister::operator HANDLE() CONST {
    return hEvent;
}

std::vector<std::shared_ptr<Detection>> DetectionRegister::GetAllDetections(IN CONST Certainty& level OPTIONAL) CONST {
    Wait();
    BeginCriticalSection _{ hScannedGuard };
    std::vector<std::shared_ptr<Detection>> found{};
    for(auto detection : scanned) {
        if(detection->info.certainty >= level) {
            found.emplace_back(detection);
        }
    }
    return found;
}

std::shared_ptr<Detection> DetectionRegister::GetByID(IN DWORD ID) CONST{
    BeginCriticalSection _{ hGuard };
    if(ids.find(ID) != ids.end()){
        return ids.at(ID);
    } else{
        return nullptr;
    }
}
```

`BLUESPAWN-win-client/src/scan/FileScanner.cpp`:

```cpp
#include "scan/FileScanner.h"

#include <Psapi.h>

#include <regex>

#include "util/StringUtils.h"
#include "util/wrappers.hpp"

#include "util/filesystem/FileSystem.h"
#include "util/processes/ProcessUtils.h"

#include "scan/ProcessScanner.h"
#include "scan/RegistryScanner.h"
#include "scan/ScanInfo.h"
#include "scan/YaraScanner.h"
#include "user/bluespawn.h"

bool GetFilesSimilar(const AllocationWrapper& lpFile1, const AllocationWrapper& lpFile2) {
    return lpFile1.GetSize() == lpFile2.GetSize() &&
           lpFile1.GetSize() == RtlCompareMemory(lpFile1, lpFile2, lpFile1.GetSize());
}

std::vector<std::wstring> FileScanner::ExtractStrings(IN CONST AllocationWrapper& data, IN DWORD dwMinLength OPTIONAL) {
    std::vector<std::wstring> strings{};

    DWORD dwStringStart{};
    for(DWORD idx = 0; idx < data.GetSize(); idx++) {
        if(!(data[idx] >= 0x20 && data[idx] <= 0x7F)) {
            DWORD dwStringLength = idx - dwStringStart;
            if(dwStringLength >= dwMinLength) {
                strings.emplace_back(
                    StringToWidestring(std::string{ PCHAR(LPVOID(data)) + dwStringStart, dwStringLength }));
            }

            dwStringStart = idx + 1;
        }
    }

    auto dwStringLength = data.GetSize() - dwStringStart;
    if(dwStringLength >= dwMinLength) {
        strings.emplace_back(StringToWidestring(std::string{ PCHAR(LPVOID(data)) + dwStringStart, dwStringLength }));
    }

    dwStringStart = 0;
    auto mem{ reinterpret_cast<PWCHAR>(LPVOID(data)) };
    for(DWORD idx = 0; 2 * idx < data.GetSize(); idx++) {
        if(!(mem[idx] >= 0x20 && mem[idx] < 0x7E)) {
            dwStringLength = idx - dwStringStart;
            if(dwStringLength >= dwMinLength) {
                strings.emplace_back(std::wstring{ PWCHAR(LPVOID(data)) + dwStringStart, dwStringLength });
            }

            dwStringStart = idx + 1;
        }
    }

    dwStringLength = data.GetSize() / 2 - dwStringStart;
    if(dwStringLength >= dwMinLength && data.GetSize() / 2 > dwStringStart) {
        strings.emplace_back(std::wstring{ mem + dwStringStart, dwStringLength });
    }

    return strings;
}

std::vector<std::wstring> FileScanner::ExtractFilePaths(IN CONST std::vector<std::wstring>& strings) {
    std::vector<std::wstring> filepaths{};
    std::wregex regex{ L"[a-zA-Z]:([/\\\\][a-zA-Z0-9(). @_-]+)+" };
    for(auto& string : strings) {
        std::wsmatch match{};
        if(std::regex_search(string, match, regex)) {
            for(auto& filename : match) {
                if(FileSystem::CheckFileExists(filename.str())) {
                    filepaths.emplace_back(filename.str());
                }
            }
        }
    }
    return filepaths;
}

void FileScanner::UpdateModules() {
    BeginCriticalSection _{ hGuard };

    FILETIME time{};
    GetSystemTimeAsFileTime(&time);

    uint64_t tdiff{ (static_cast<uint64_t>(time.dwHighDateTime - ModuleLastUpdateTime.dwHighDateTime) << 32) +
                    time.dwLowDateTime - ModuleLastUpdateTime.dwLowDateTime };
    DWORD dwSecondsElapsed = tdiff / 10000;
    if(dwSecondsElapsed >= MODULE_UPDATE_INTERVAL) {
        modules.clear();
        hashes.clear();

        std::vector<DWORD> processes(1024);
        DWORD dwBytesNeeded{};
        auto success{ EnumProcesses(processes.data(), 1024 * sizeof(DWORD), &dwBytesNeeded) };
        if(dwBytesNeeded > 1024 * sizeof(DWORD)) {
            processes.resize(dwBytesNeeded / sizeof(DWORD));
            success = EnumProcesses(processes.data(), dwBytesNeeded, &dwBytesNeeded);
        }

        auto dwProcCount{ dwBytesNeeded / sizeof(DWORD) };
        for(int i = 0; i < dwProcCount; i++) {
            auto modules{ EnumModules(processes[i]) };
            for(auto& mod : modules) {
                auto name{ ToLowerCaseW(mod) };
                if(FileScanner::modules.find(name) == FileScanner::modules.end()) {
                    FileScanner::modules.emplace(name, std::unordered_set<DWORD>{ processes[i] });
                } else {
                    FileScanner::modules.at(name).emplace(processes[i]);
                }
            }
        }

        for(auto& mod : modules) {
            auto path{ FileSystem::SearchPathExecutable(mod.first) };
            if(path) {
                auto hash{ FileSystem::File{ *path }.GetSHA256Hash() };
                if(hash) {
                    if(hashes.count(*hash)) {
                        hashes.at(*hash).emplace(mod.first);
                    } else {
                        hashes.emplace(*hash, std::unordered_set<std::wstring>{ mod.first });
                    }
                }
            }
        }

        ModuleLastUpdateTime = time;
    }
}

bool IsPEFile(IN CONST FileSystem::File& file){
    if(file.GetFileExists()){
        if(!file.HasReadAccess()){
            LOG_WARNING(L"Unable to properly scan " << file << L" due to lack of read access.");
            return false;
        }

        auto headers{ file.Read(0x400) };
        MemoryWrapper<> memory{ static_cast<LPVOID>(headers), headers.GetSize() };
        if(*memory.Convert<WORD>() != 0x5A4D){
            return false;
        }

        DWORD offset{ *memory.GetOffset(0x3C).Convert<DWORD>() };
        if(offset + 4 >= 0x400){
            LOG_INFO(2, "File " << file << " may conform to the PE32+ standard, but it is not normal PE.");
            return false;
        }

        return *memory.GetOffset(offset).Convert<DWORD>() == 0x4550UL;
    } else{
        return false;
    }
}

bool FileScanner::PerformQuickScan(IN CONST std::wstring& string) {
    if(FileSystem::CheckFileExists(string)) {
        return !FileSystem::File{ string }.GetFileSigned();
    } else if(auto path{ FileSystem::SearchPathExecutable(string) }){
        return !FileSystem::File{ *path }.GetFileSigned();
    } else{
        return false;
    }
}

std::unordered_map<std::shared_ptr<Detection>, Association>
FileScanner::GetAssociatedDetections(IN CONST Detection& detection) {
    if(detection.type != DetectionType::FileDetection || detection.info.certainty < Certainty::Moderate) {
        return {};
    }

    std::unordered_map<std::shared_ptr<Detection>, Association> detections{};

    auto data{ std::get<FileDetectionData>(detection.data) };

    if(data.Executor && !IsPEFile(*data.FileHandle) && ProcessScanner::PerformQuickScan(*data.Executor)) {
        detections.emplace(Bluespawn::detections.AddDetection(
            Detection{ ProcessDetectionData::CreateCommandDetectionData(*data.Executor) }), Association::Strong);
    }

    if(data.FileFound) {
        UpdateModules();

        EnterCriticalSection(hGuard);
        auto hashes{ this->hashes };
        auto modules{ this->modules };
        LeaveCriticalSection(hGuard);

        if(data.SHA256) {
            if(hashes.count(*data.SHA256)) {
                auto loaded{ hashes.at(*data.SHA256) };
                for(auto& lib : loaded) {
                    for(auto pid : modules.at(lib)) {
                        auto alloc{ GetModuleAddress(pid, lib) };
                        if(alloc) {
                            auto dwAllocSize{ GetRegionSize(pid, alloc) };
                            detections.emplace(
                                Bluespawn::detections.AddDetection(Detection{
                                    ProcessDetectionData::CreateImageDetectionData(pid, GetProcessImage(pid), lib) }),
                                Association::Certain);
                        }
                    }
                }
            }
        }

        if(!detection.DetectionStale && data.FileHandle && Bluespawn::aggressiveness == Aggressiveness::Intensive) {
            auto strings = ExtractStrings(data.FileHandle->Read(), 8);
            auto filenames = ExtractFilePaths(strings);
            for(auto& filename : filenames) {
                if(FileScanner::PerformQuickScan(filename)){
                    detections.emplace(Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ filename } }),
                                       Association::Weak);
                }
            }
        }
    }

    return detections;
}

Certainty FileScanner::ScanDetection(IN CONST Detection& detection) {
    Certainty certainty{ Certainty::None };
    if(detection.type == DetectionType::FileDetection) {
        auto& file{ std::get<FileDetectionData>(detection.data) };
        if(!file.FileFound) {
            return Certainty::None;
        }

        if(IsPEFile(*file.FileHandle)){
            if(file.FileHandle->IsMicrosoftSigned()){
                return Certainty::None;
            }
            if(!*file.FileSigned){
                certainty = certainty + Certainty::Moderate;
            }
            if(file.yara){
                for(auto& rule : file.yara->vKnownBadRules){
                    // Tune this!
                    certainty = certainty + Certainty::Moderate;
                }
            }
        } else{
            if(file.Executor){
                if(ProcessScanner::PerformQuickScan(*file.Executor)){
                    certainty = certainty + Certainty::Moderate;
                }
            }
        }

        LOG_INFO(2, L"Scanned file " << file.FilePath << ". Certainty: " << static_cast<double>(certainty));
    }
    return certainty;
}

```

`BLUESPAWN-win-client/src/scan/MemoryScanner.cpp`:

```cpp
#include "scan/MemoryScanner.h"

#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/processes/ProcessUtils.h"
#include "util/wrappers.hpp"

#include "hunt/Hunt.h"
#include "scan/FileScanner.h"
#include "scan/RegistryScanner.h"
#include "scan/YaraScanner.h"
#include "user/bluespawn.h"

std::unordered_map<std::shared_ptr<Detection>, Association>
MemoryScanner::GetAssociatedDetections(IN CONST Detection& detection) {
    if(detection.type != DetectionType::ProcessDetection || detection.DetectionStale) {
        return {};
    }

    ProcessDetectionData data{ std::get<ProcessDetectionData>(detection.data) };
    if(!data.BaseAddress || !data.MemorySize) {
        return {};
    }

    std::unordered_map<std::shared_ptr<Detection>, Association> detections{};

    if(data.ImageName) {
        if(data.type == ProcessDetectionType::MaliciousImage) {
            detections.emplace(Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ *data.ImageName } }),
                               Association::Certain);
        } else {
            detections.emplace(Bluespawn::detections.AddDetection(
                                   Detection{ FileDetectionData{ *data.ImageName },
                                              DetectionContext{ std::nullopt, detection.context.FirstEvidenceTime,
                                                                L"This image appears to have been modified to behave "
                                                                "maliciously, so while it's possible this file is "
                                                                "malicious, this detection was created to serve as an "
                                                                "IoC" } }),
                               Association::Moderate);
        }
    }

    if(Bluespawn::aggressiveness > Aggressiveness::Normal && data.ProcessHandle &&
       detection.info.certainty >= Certainty::Moderate) {
        auto memory{ Utils::Process::ReadProcessMemory(*data.ProcessHandle, *data.BaseAddress, *data.MemorySize) };
        if(memory) {
            auto strings = FileScanner::ExtractStrings(memory, 8);
            auto filenames = FileScanner::ExtractFilePaths(strings);
            for(auto& filename : filenames) {
                if(FileScanner::PerformQuickScan(filename)) {
                    detections.emplace(Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ filename } }),
                                       Association::Weak);
                }
            }
        }
    }

    return detections;
}

bool MemoryScanner::PerformQuickScan(IN CONST std::wstring& in) {
    return false;
}

#define IS_PAGE_EXECUTABLE(prot) (prot & 0xF0)
#define IS_PAGE_WRITECOPY(prot) (prot == 0x80 || prot == 0x08)
#define IS_PAGE_WRITEABLE(prot) (prot & 0xCC)

Certainty MemoryScanner::ScanDetection(IN CONST Detection& detection) {
    if(detection.type != DetectionType::ProcessDetection || detection.DetectionStale) {
        return Certainty::None;
    }

    ProcessDetectionData data{ std::get<ProcessDetectionData>(detection.data) };
    if(!data.BaseAddress || !data.MemorySize || !data.ProcessHandle) {
        return Certainty::None;
    }

    Certainty certainty{ Certainty::None };

    if(Bluespawn::aggressiveness == Aggressiveness::Intensive) {
        auto& scanner{ YaraScanner::GetInstance() };
        auto scan{ scanner.ScanMemory(MemoryWrapper<>{ *data.BaseAddress, *data.MemorySize, *data.ProcessHandle }) };
        for(auto& rule : scan.vKnownBadRules) {
            LOG_INFO(2, L"Memory at " << *data.BaseAddress << L" in process with PID "
                                      << GetProcessId(*data.ProcessHandle) << L" violates yara rule " << rule);
            certainty = certainty + Certainty::Moderate;
        }
    }

    MEMORY_BASIC_INFORMATION info{};
    if(VirtualQueryEx(*data.ProcessHandle, *data.BaseAddress, &info, sizeof(info))) {
        bool wc{ IS_PAGE_WRITECOPY(info.AllocationProtect) };
        if(IS_PAGE_EXECUTABLE(info.AllocationProtect) && !wc) {
            certainty = certainty + Certainty::Moderate;
            LOG_INFO(3, L"Allocation at " << *data.BaseAddress << L" in process with PID "
                                          << GetProcessId(*data.ProcessHandle) << L" has suspicious permissions "
                                          << std::hex << info.Protect);
        }

        auto addr{ reinterpret_cast<PCHAR>(*data.BaseAddress) };
        while(addr < reinterpret_cast<PCHAR>(*data.BaseAddress) + *data.MemorySize) {
            if(VirtualQueryEx(*data.ProcessHandle, addr, &info, sizeof(info))) {
                if(IS_PAGE_EXECUTABLE(info.Protect) && (IS_PAGE_WRITEABLE(info.Protect) || !wc)) {
                    LOG_INFO(3, L"Page at " << reinterpret_cast<PVOID64>(addr) << L" in process with PID "
                                            << GetProcessId(*data.ProcessHandle) << L" has suspicious permissions "
                                            << std::hex << info.Protect);
                    certainty = certainty + Certainty::Moderate;
                }
                addr += info.RegionSize;
            } else
                return certainty;
        }
    } else {
        LOG_WARNING(L"Failed to analyze memory protections for memory at "
                    << *data.BaseAddress << L" in process with PID " << GetProcessId(*data.ProcessHandle)
                    << L" with error 0x" << std::hex << GetLastError());
    }

    return certainty;
}

```

`BLUESPAWN-win-client/src/scan/ProcessScanner.cpp`:

```cpp
#include "scan/ProcessScanner.h"

#include <TlHelp32.h>

#include "util/configurations/Registry.h"
#include "util/filesystem/FileSystem.h"
#include "util/processes/CheckLolbin.h"
#include "util/processes/ProcessUtils.h"
#include "util/wrappers.hpp"

#include "scan/FileScanner.h"
#include "user/bluespawn.h"

std::unordered_map<std::shared_ptr<Detection>, Association>
ProcessScanner::SearchCommand(IN CONST std::wstring& ProcessCommand) {
    // TODO: Better handling for parsing commands
    //LOG_ERROR(L"Unable to properly scan command `" << ProcessCommand << L"`; function not implemented");
    std::unordered_map<std::shared_ptr<Detection>, Association> detections{};

    auto image{ GetImagePathFromCommand(ProcessCommand) };
    if(FileScanner::PerformQuickScan(image)) {
        detections.emplace(Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ image } }),
                           Association::Strong);
    }

    return detections;
}

std::unordered_map<std::shared_ptr<Detection>, Association>
ProcessScanner::GetAssociatedDetections(IN CONST Detection& detection) {
    if(detection.type != DetectionType::ProcessDetection) {
        return {};
    }

    std::unordered_map<std::shared_ptr<Detection>, Association> detections{};
    ProcessDetectionData data{ std::get<ProcessDetectionData>(detection.data) };

    if((data.type == ProcessDetectionType::MaliciousProcess || data.type == ProcessDetectionType::MaliciousCommand) &&
       data.ProcessCommand) {
        auto associated{ SearchCommand(*data.ProcessCommand) };
        for(auto& pair : associated) {
            detections.emplace(pair.first, pair.second);
        }
    }

    if(data.type == ProcessDetectionType::MaliciousProcess) {
        HandleWrapper snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };

        PROCESSENTRY32W entry{};
        entry.dwSize = sizeof(entry);

        if(Process32FirstW(snapshot, &entry)) {
            do {
                if(entry.th32ParentProcessID == data.PID) {
                    detections.emplace(
                        Bluespawn::detections.AddDetection(Detection{
                            ProcessDetectionData::CreateProcessDetectionData(entry.th32ProcessID, entry.szExeFile) }),
                        Association::Moderate);
                } else if(entry.th32ProcessID == data.PID) {
                    HandleWrapper parent{ OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false,
                                                      entry.th32ParentProcessID) };
                    if(parent) {
                        detections.emplace(Bluespawn::detections.AddDetection(
                                               Detection{ ProcessDetectionData::CreateProcessDetectionData(
                                                   entry.th32ParentProcessID, GetProcessImage(parent)) }),
                                           Association::Weak);
                    } else {
                        detections.emplace(
                            Bluespawn::detections.AddDetection(Detection{
                                ProcessDetectionData::CreateProcessDetectionData(entry.th32ParentProcessID, L"Unknow"
                                                                                                            L"n") }),
                            Association::Weak);
                    }
                }
            } while(Process32NextW(snapshot, &entry));
        }
    }

    return detections;
}

bool ProcessScanner::PerformQuickScan(IN CONST std::wstring& in) {
    // `in` is a command. Start by finding the associated executable
    auto file{ GetImagePathFromCommand(in) };

    // Check if the file appears malicious
    if(FileScanner::PerformQuickScan(file)) {
        return true;
    }

    // Check if the file appears to use a "lolbin" to obfuscate its execution
    bool lolbin{ IsLolbinMalicious(in) };

    return lolbin;
}

Certainty ProcessScanner::ScanDetection(IN CONST Detection& detection) {
    /// TODO: Implement check for LOLBins

    if(detection.type != DetectionType::ProcessDetection) {
        return Certainty::None;
    }

    ProcessDetectionData data{ std::get<ProcessDetectionData>(detection.data) };
    if(data.type == ProcessDetectionType::MaliciousProcess && data.ProcessCommand) {
        if(IsLolbinMalicious(*data.ProcessCommand)) {
            return Certainty::Moderate;
        }
    }

    return Certainty::None;
}

```

`BLUESPAWN-win-client/src/scan/RegistryScanner.cpp`:

```cpp
#include "scan/RegistryScanner.h"

#include "util/wrappers.hpp"
#include "util/StringUtils.h"
#include "util/configurations/RegistryValue.h"
#include "util/processes/ProcessUtils.h"
#include "scan/YaraScanner.h"
#include "scan/ProcessScanner.h"
#include "scan/FileScanner.h"
#include "user/bluespawn.h"

#include <regex>

std::vector<std::wstring> RegistryScanner::ExtractRegistryKeys(IN CONST std::vector<std::wstring>& strings){
	std::vector<std::wstring> keys{};
	std::wregex regex{ L"(system|software)([/\\\\][a-zA-Z0-9\\. @_-]+)+" };
	for(auto& string : strings){
		std::wsmatch match{};
		auto lower{ ToLowerCaseW(string) };
		if(std::regex_search(lower, match, regex)){
			for(auto& keyname : match){
				for(auto hive : Registry::vHives){
					if(Registry::RegistryKey::CheckKeyExists(hive.first, keyname.str())){
						keys.emplace_back(hive.second + L"\\" + keyname.str());
					}
				}
			}
		}
	}
	return keys;
}

std::unordered_map<std::shared_ptr<Detection>, Association> RegistryScanner::GetAssociatedDetections(
	IN CONST Detection& detection){
	if(detection.type != DetectionType::RegistryDetection || detection.DetectionStale){
		return {};
	}

	auto data{ std::get<RegistryDetectionData>(detection.data) };
	if(!data.key.Exists()){
		return {};
	}

	std::unordered_map<std::shared_ptr<Detection>, Association> detections{};

	if(!data.value){
		if(Bluespawn::aggressiveness == Aggressiveness::Intensive){
			for(auto val : data.key.EnumerateValues()){
				detections.emplace(Bluespawn::detections.AddDetection(Detection{
					RegistryDetectionData{ data.key, Registry::RegistryValue::Create(data.key, val) }
				}), Association::Moderate);
			}
		}

		return detections;
	} else if(!data.key.ValueExists(data.value->wValueName)){
		return {};
	}

	/// TODO: Add more of these
	if(data.type == RegistryDetectionType::CommandReference){
		if(ProcessScanner::PerformQuickScan(std::get<std::wstring>(data.value->data))){
			detections.emplace(Bluespawn::detections.AddDetection(Detection{
				ProcessDetectionData::CreateCommandDetectionData(std::get<std::wstring>(data.value->data))
			}), Association::Certain);
		}
	} else if(data.type == RegistryDetectionType::FileReference){
		auto name{ std::get<std::wstring>(data.value->data) };
		auto path{ FileSystem::SearchPathExecutable(name) };
		if(path && FileScanner::PerformQuickScan(*path)){
			detections.emplace(Bluespawn::detections.AddDetection(Detection{
				FileDetectionData{ *path }
			}), Association::Certain);
		}
	}

	return detections;
}

Certainty RegistryScanner::ScanDetection(IN CONST Detection& detection){
	if(Bluespawn::aggressiveness != Aggressiveness::Intensive || detection.type != DetectionType::RegistryDetection ||
	   detection.DetectionStale){
		
		return Certainty::None;
	}

	Certainty certainty{ Certainty::None };
	auto data{ std::get<RegistryDetectionData>(detection.data) };
	if(data.value){
		auto mem{ data.key.GetRawValue(data.value->wValueName) };
		if(mem.GetSize() > 0x10){
			auto result{ YaraScanner::GetInstance().ScanMemory(mem) };
			for(auto& rule : result.vKnownBadRules){
				// Tune this!
				certainty = certainty + Certainty::Moderate;
			}
		}
	}

	return certainty;
}
```

`BLUESPAWN-win-client/src/scan/ScanInfo.cpp`:

```cpp
#include "scan/ScanInfo.h"

#include <queue>
#include <unordered_map>
#include <atomic>

#include "scan/Detections.h"

const Certainty Certainty::Certain =  1.00;
const Certainty Certainty::Strong =   0.75;
const Certainty Certainty::Moderate = 0.50;
const Certainty Certainty::Weak =     0.25;
const Certainty Certainty::None =     0.00;
Certainty::Certainty(double certainty) : confidence{ certainty }{}
Certainty::operator double() const { return confidence; }
Certainty Certainty::operator*(Certainty c) const { return confidence * c.confidence; }
Certainty Certainty::operator+(Certainty c) const { return 1 - (1 - confidence) * (1 - c.confidence); }
bool Certainty::operator==(Certainty c) const {
	return c.confidence > confidence ? c.confidence - confidence <= 0.125 : confidence - c.confidence <= 0.125;
}
bool Certainty::operator!=(Certainty c) const { 
	return c.confidence > confidence ? c.confidence - confidence > 0.125 : confidence - c.confidence > 0.125; 
}
bool Certainty::operator>=(Certainty c) const { return *this > c || *this == c; }
bool Certainty::operator<=(Certainty c) const { return *this > c || *this == c; }
bool Certainty::operator>(Certainty c) const { return confidence > c.confidence; }
bool Certainty::operator<(Certainty c) const { return confidence < c.confidence; }

volatile std::atomic<DWORD> Detection::IDCounter{ 1 };

ScanInfo::ScanInfo() : 
	certainty{ Certainty::None },
	cAssociativeCertainty{ Certainty::None },
	associations{ std::make_unique<std::unordered_map<std::shared_ptr<Detection>, Association>>() },
	bAssociativeStale{ true }{}

std::unordered_map<std::shared_ptr<Detection>, Association> ScanInfo::GetAssociations(){
	BeginCriticalSection _{ hGuard };
	return *associations;
}

Certainty ScanInfo::GetCertainty(){ 
	BeginCriticalSection _{ hGuard };
	if(bAssociativeStale){
		cAssociativeCertainty = Certainty::None;
		
		for(auto& pair : *associations){
			LeaveCriticalSection(hGuard);
			auto raw{ pair.first->info.GetIntrinsicCertainty() };
			EnterCriticalSection(hGuard);
			cAssociativeCertainty = cAssociativeCertainty + (raw * pair.second);
		}

		bAssociativeStale = false;
	}
	return certainty + cAssociativeCertainty; 
};

Certainty ScanInfo::GetIntrinsicCertainty(){
	BeginCriticalSection _{ hGuard };
	return certainty;
};

void ScanInfo::AddAssociation(IN CONST std::shared_ptr<Detection>& node, IN CONST Association& a){
	BeginCriticalSection _{ hGuard };
	bAssociativeStale = true;
	if(associations->find(node) == associations->end()){
		associations->emplace(node, a);
	} else{
		auto& assoc{ associations->at(node) };
		assoc = assoc + a;
	}
}

void ScanInfo::SetCertainty(IN CONST Certainty& certainty){
	this->certainty = certainty;
}

void ScanInfo::AddCertainty(IN CONST Certainty& certainty){
	this->certainty = this->certainty + certainty;
}

ScanInfo::operator LPCRITICAL_SECTION() const {
	return hGuard;
}
```

`BLUESPAWN-win-client/src/scan/Scanner.cpp`:

```cpp
#include "scan/Scanner.h"

#include "scan/FileScanner.h"
#include "scan/MemoryScanner.h"
#include "scan/ProcessScanner.h"
#include "scan/RegistryScanner.h"

std::vector<std::shared_ptr<Scanner>> Scanner::scanners{
    std::make_shared<FileScanner>(),
    std::make_shared<MemoryScanner>(),
    std::make_shared<ProcessScanner>(),
    std::make_shared<RegistryScanner>(),
};

std::unordered_map<std::shared_ptr<Detection>, Association>
Scanner::GetAssociatedDetections(IN CONST Detection& detection) {
    return {};
}

Certainty Scanner::ScanDetection(IN CONST Detection& detection) {
    return Certainty::None;
}

```

`BLUESPAWN-win-client/src/scan/ServiceScanner.cpp`:

```cpp
#include "scan/ServiceScanner.h"

#include <queue>

#include "util/StringUtils.h"

#include "scan/ProcessScanner.h"
#include "user/bluespawn.h"

std::unordered_map<std::shared_ptr<Detection>, Association>
ServiceScanner::GetAssociatedDetections(IN CONST Detection& detection) {
    if(detection.type != DetectionType::ServiceDetection) {
        return {};
    }

    std::unordered_map<std::shared_ptr<Detection>, Association> detections{};
    ServiceDetectionData data{ std::get<ServiceDetectionData>(detection.data) };

    if(data.FilePath) {
        detections.emplace(Bluespawn::detections.AddDetection(Detection{ FileDetectionData{ *data.FilePath } }),
                           Association::Certain);
    }

    if(!detection.DetectionStale) {
        std::wstring name{};
        if(!data.ServiceName && data.DisplayName) {
            GenericWrapper<SC_HANDLE> ServiceManager{ OpenSCManagerW(nullptr, nullptr, GENERIC_READ),
                                                      CloseServiceHandle };
            std::vector<WCHAR> KeyName(256);
            DWORD size{};
            if(!GetServiceKeyNameW(ServiceManager, data.DisplayName->c_str(), KeyName.data(), &size)) {
                KeyName.resize(size);
                if(GetServiceKeyNameW(ServiceManager, data.DisplayName->c_str(), KeyName.data(), &size)) {
                    name = KeyName.data();
                }
            } else {
                name = KeyName.data();
            }
        }

        if(name.length() || data.ServiceName) {
            if(data.ServiceName) {
                name = *data.ServiceName;
            }

            Registry::RegistryKey ServicesKey{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" };

            std::queue<Registry::RegistryKey> bfsQueue{};
            bfsQueue.emplace(Registry::RegistryKey{ ServicesKey, name });
            std::set<Registry::RegistryKey> visited{};   // To avoid symlink loops
            while(!bfsQueue.empty()) {
                auto key{ bfsQueue.front() };
                bfsQueue.pop();

                if(visited.find(key) == visited.end()) {
                    visited.emplace(key);

                    for(auto name : key.EnumerateValues()) {
                        auto val{ Registry::RegistryValue::Create(key, name) };

                        // TODO: Add support for exes and dlls in REG_MULTI_SZ values
                        if(val && val->GetType() == RegistryType::REG_SZ_T ||
                           val->GetType() == RegistryType::REG_EXPAND_SZ_T) {
                            auto str{ ToLowerCaseW(std::get<std::wstring>(val->data)) };
                            if(str.find(L".exe") || str.find(L".dll")) {
                                detections.emplace(Bluespawn::detections.AddDetection(Detection{ RegistryDetectionData{
                                                       key, val, RegistryDetectionType::FileReference } }),
                                                   Association::Strong);
                            }
                        }
                    }

                    for(auto subkey : key.EnumerateSubkeys()) {
                        bfsQueue.emplace(subkey);
                    }
                }
            }
        }
    }

    return detections;
}

bool StringContainsKeywords(IN CONST std::wstring& str) {
    auto name{ ToLowerCaseW(str) };
    return name.find(L"psexecsvc") != std::wstring::npos || name.find(L"mimi") != std::wstring::npos;
}

bool ServiceScanner::PerformQuickScan(IN CONST std::optional<std::wstring>& ServiceName,
                                      IN CONST std::optional<std::wstring>& ServiceDisplayName,
                                      IN CONST std::optional<std::wstring>& ServicePath OPTIONAL) {
    if(ServicePath) {
        if(ProcessScanner::PerformQuickScan(*ServicePath)) {
            return true;
        }

        if(ServicePath->find(L"mimidrv.sys") != std::wstring::npos) {
            return true;
        }
    }

    if(ServiceName && StringContainsKeywords(*ServiceName)) {
        return true;
    }

    if(ServiceDisplayName && StringContainsKeywords(*ServiceDisplayName)) {
        return true;
    }

    return false;
}

Certainty ServiceScanner::ScanDetection(IN CONST Detection& detection) {
    if(detection.type == DetectionType::ServiceDetection) {
        ServiceDetectionData data{ std::get<ServiceDetectionData>(detection.data) };
        if(data.ServiceName && StringContainsKeywords(*data.ServiceName))
            return Certainty::Strong;
        if(data.DisplayName && StringContainsKeywords(*data.DisplayName))
            return Certainty::Strong;
        if(data.FilePath && StringContainsKeywords(*data.FilePath))
            return Certainty::Strong;
    }

    return Certainty::None;
}

```

`BLUESPAWN-win-client/src/scan/YaraScanner.cpp`:

```cpp
#include "scan/YaraScanner.h"

#include <zip.h>

#include "util/StringUtils.h"
#include "util/log/Log.h"
#include "util/wrappers.hpp"

#include "../resources/resource.h"
#include "yara/libyara.h"
#include "yara/rules.h"

const YaraScanner YaraScanner::instance{};

AllocationWrapper GetResourceRule(DWORD identifier) {
    auto hRsrcInfo = FindResourceW(nullptr, MAKEINTRESOURCE(identifier), L"yararule");
    if(!hRsrcInfo) {
        return { nullptr, 0 };
    }

    auto hRsrc = LoadResource(nullptr, hRsrcInfo);
    if(!hRsrc) {
        return { nullptr, 0 };
    }

    zip_error_t err{};
    auto lpZipSource = zip_source_buffer_create(LockResource(hRsrc), SizeofResource(nullptr, hRsrcInfo), 0, &err);
    if(lpZipSource) {
        auto zip = zip_open_from_source(lpZipSource, 0, &err);
        if(zip) {
            auto fdRules = zip_fopen(zip, "data", 0);
            if(fdRules) {
                zip_stat_t stats{};
                if(-1 != zip_stat(zip, "data", ZIP_STAT_SIZE, &stats)) {
                    if(-1 != stats.size) {
                        AllocationWrapper data{ HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                                          static_cast<SIZE_T>(stats.size)),
                                                static_cast<SIZE_T>(stats.size), AllocationWrapper::HEAP_ALLOC };
                        if(-1 != zip_fread(fdRules, data, stats.size)) {
                            zip_fclose(fdRules);
                            zip_close(zip);
                            zip_source_close(lpZipSource);

                            return data;
                        }
                    }
                }

                zip_fclose(fdRules);
            }
            zip_close(zip);
        }
        zip_source_close(lpZipSource);
    }

    return { nullptr, 0 };
}

struct AllocationWrapperStream {
    AllocationWrapper wrapper;
    size_t offset;
};

size_t ReadAllocationWrapper(LPVOID dest, size_t size, size_t count, AllocationWrapperStream* data) {
    size_t desired_amnt = size * count;
    size_t actual_amnt = min(desired_amnt, data->wrapper.GetSize() - data->offset);

    CopyMemory(dest, reinterpret_cast<PCHAR>((LPVOID) data->wrapper) + data->offset, actual_amnt);

    data->offset += actual_amnt;
    return actual_amnt / size;
}

YR_RULES* LoadRules(const AllocationWrapper& memory) {
    AllocationWrapperStream stream_data = { memory, 0 };
    YR_STREAM stream = { &stream_data, YR_STREAM_READ_FUNC(ReadAllocationWrapper) };
    YR_RULES* rules;
    auto status = yr_rules_load_stream(&stream, &rules);
    if(status != ERROR_SUCCESS) {
        return nullptr;
    }
    return rules;
}

YaraScanner::YaraScanner() : status{ YaraStatus::Success } {
    yr_initialize();

    auto hSevereYara = GetResourceRule(YaraSevere);
    if(!hSevereYara) {
        status = YaraStatus::RulesMissing;
        return;
    }
    KnownBad = LoadRules(hSevereYara);
    if(!KnownBad) {
        status = YaraStatus::RulesMissing;
        return;
    }

    auto hSevereYara2 = GetResourceRule(YaraSevere2);
    if(!hSevereYara2) {
        status = YaraStatus::RulesMissing;
        return;
    }
    KnownBad2 = LoadRules(hSevereYara2);
    if(!KnownBad2) {
        status = YaraStatus::RulesMissing;
        return;
    }

    auto hIndicatorsYara = GetResourceRule(YaraIndicators);
    if(!hIndicatorsYara) {
        status = YaraStatus::RulesInvalid;
        return;
    }
    Indicators = LoadRules(hIndicatorsYara);
    if(!Indicators) {
        status = YaraStatus::RulesInvalid;
        return;
    }
}

YaraScanner::~YaraScanner() {
    if(KnownBad) {
        yr_rules_destroy(KnownBad);
        KnownBad = nullptr;
    }

    if(KnownBad2) {
        yr_rules_destroy(KnownBad2);
        KnownBad2 = nullptr;
    }

    if(Indicators) {
        yr_rules_destroy(Indicators);
        Indicators = nullptr;
    }
    yr_finalize();
}

const YaraScanner& YaraScanner::GetInstance() {
    return instance;
}

struct YaraScanArg {
    YaraScanResult result;
    enum { Severe, Indicator } type;
};

int YaraCallbackFunction(int message, LPVOID lpMessageData, YaraScanArg* arg) {
    if(message == CALLBACK_MSG_RULE_MATCHING) {
        auto rule = reinterpret_cast<YR_RULE*>(lpMessageData);
        if(arg->type == arg->Severe) {
            arg->result.AddBadRule(StringToWidestring(rule->identifier));
        } else if(arg->type == arg->Indicator) {
            arg->result.AddIndicatorRule(StringToWidestring(rule->identifier));
        }
    }
    return CALLBACK_CONTINUE;
}

YaraScanResult YaraScanner::ScanFile(const FileSystem::File& file) const {
    if(status != YaraStatus::Success) {
        YaraScanResult res = {};
        res.status = status;
        return res;
    }

    auto memory = file.Read();
    if(!memory) {
        YaraScanResult result{};
        result.status = YaraStatus::Failure;
        return result;
    }
    auto result{ ScanMemory(memory) };

    for(auto identifier : result.vKnownBadRules) {
        LOG_INFO(1, file.GetFilePath() << L" matches known malicious identifier " << identifier);
    }
    for(auto identifier : result.vIndicatorRules) {
        LOG_INFO(2, file.GetFilePath() << L" matches known indicator identifier " << identifier);
    }

    return result;
}

YaraScanResult YaraScanner::ScanMemory(const AllocationWrapper& memory) const {
    YaraScanArg arg{};
    arg.result.status = YaraStatus::Success;
    arg.type = arg.Severe;
    auto status = yr_rules_scan_mem(KnownBad, reinterpret_cast<const uint8_t*>((LPVOID) memory), memory.GetSize(), 0,
                                    YR_CALLBACK_FUNC(YaraCallbackFunction), &arg, 0);
    if(status != ERROR_SUCCESS) {
        arg.result.status = YaraStatus::Failure;
    }

    arg.type = arg.Severe;
    status = yr_rules_scan_mem(KnownBad2, reinterpret_cast<const uint8_t*>((LPVOID) memory), memory.GetSize(), 0,
                               YR_CALLBACK_FUNC(YaraCallbackFunction), &arg, 0);
    if(status != ERROR_SUCCESS) {
        arg.result.status = YaraStatus::Failure;
    }

    arg.type = arg.Indicator;
    status = yr_rules_scan_mem(Indicators, reinterpret_cast<const uint8_t*>((LPVOID) memory), memory.GetSize(), 0,
                               YR_CALLBACK_FUNC(YaraCallbackFunction), &arg, 0);
    if(status != ERROR_SUCCESS) {
        arg.result.status = YaraStatus::Failure;
    }

    return arg.result;
}

YaraScanResult YaraScanner::ScanMemory(LPVOID memory, DWORD dwSize) const {
    return ScanMemory(AllocationWrapper{ memory, dwSize });
}

YaraScanResult YaraScanner::ScanMemory(const MemoryWrapper<>& memory) const {
    return ScanMemory(memory.ToAllocationWrapper());
}

void YaraScanResult::AddBadRule(const std::wstring& identifier) {
    vKnownBadRules.emplace_back(identifier);
}

void YaraScanResult::AddIndicatorRule(const std::wstring& identifier) {
    vIndicatorRules.emplace_back(identifier);
}

YaraScanResult::operator bool() {
    return vKnownBadRules.empty() && status == YaraStatus::Success;
}

bool YaraScanResult::operator!() {
    return !(vKnownBadRules.empty() && status == YaraStatus::Success);
}

```

`BLUESPAWN-win-client/src/user/BLUESPAWN.cpp`:

```cpp
#include "user/bluespawn.h"

#include <iostream>
#include <memory>

#include "util/DynamicLinker.h"
#include "util/StringUtils.h"
#include "util/ThreadPool.h"
#include "util/eventlogs/EventLogs.h"
#include "util/log/CLISink.h"
#include "util/log/DebugSink.h"
#include "util/log/JSONSink.h"
#include "util/log/XMLSink.h"

#include "hunt/hunts/HuntT1036.h"
#include "hunt/hunts/HuntT1037.h"
#include "hunt/hunts/HuntT1053.h"
#include "hunt/hunts/HuntT1055.h"
#include "hunt/hunts/HuntT1068.h"
#include "hunt/hunts/HuntT1070.h"
#include "hunt/hunts/HuntT1136.h"
#include "hunt/hunts/HuntT1484.h"
#include "hunt/hunts/HuntT1505.h"
#include "hunt/hunts/HuntT1543.h"
#include "hunt/hunts/HuntT1546.h"
#include "hunt/hunts/HuntT1547.h"
#include "hunt/hunts/HuntT1548.h"
#include "hunt/hunts/HuntT1553.h"
#include "hunt/hunts/HuntT1562.h"
#include "hunt/hunts/HuntT1569.h"
#include "reaction/CarveMemory.h"
#include "reaction/DeleteFile.h"
#include "reaction/QuarantineFile.h"
#include "reaction/RemoveValue.h"
#include "reaction/SuspendProcess.h"
#include "scan/FileScanner.h"
#include "scan/ProcessScanner.h"
#include "user/CLI.h"

#pragma warning(push)

#pragma warning(disable : 26451)
#pragma warning(disable : 26444)

#include "cxxopts.hpp"

#pragma warning(pop)

#include <VersionHelpers.h>

#include <iostream>

DEFINE_FUNCTION(BOOL, IsWow64Process2, NTAPI, HANDLE hProcess, USHORT* pProcessMachine, USHORT* pNativeMachine);
LINK_FUNCTION(IsWow64Process2, KERNEL32.DLL);

const IOBase& Bluespawn::io = CLI::GetInstance();
HuntRegister Bluespawn::huntRecord{};
MitigationRegister Bluespawn::mitigationRecord{};
Aggressiveness Bluespawn::aggressiveness{ Aggressiveness::Normal };
DetectionRegister Bluespawn::detections{ Certainty::Moderate };
ReactionManager Bluespawn::reaction{};
std::vector<std::shared_ptr<DetectionSink>> Bluespawn::detectionSinks{};
bool Bluespawn::EnablePreScanDetections{ false };

std::map<std::string, std::unique_ptr<Reaction>> reactions{};

Bluespawn::Bluespawn() {
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1036>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1037>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1053>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1055>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1068>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1070>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1136>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1484>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1505>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1543>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1546>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1547>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1548>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1553>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1562>());
    huntRecord.RegisterHunt(std::make_unique<Hunts::HuntT1569>());

    mitigationRecord.Initialize();

    reactions.emplace("carve-memory", std::make_unique<Reactions::CarveMemoryReaction>());
    reactions.emplace("delete-file", std::make_unique<Reactions::DeleteFileReaction>());
    reactions.emplace("quarantine-file", std::make_unique<Reactions::QuarantineFileReaction>());
    reactions.emplace("remove-value", std::make_unique<Reactions::RemoveValueReaction>());
    reactions.emplace("suspend", std::make_unique<Reactions::SuspendProcessReaction>());
}

void Bluespawn::RunHunts() {
    Bluespawn::io.InformUser(L"Starting a Hunt");
    DWORD tactics = UINT_MAX;
    DWORD dataSources = UINT_MAX;
    DWORD affectedThings = UINT_MAX;
    Scope scope{};

    huntRecord.RunHunts(vIncludedHunts, vExcludedHunts, scope);
}

void Bluespawn::RunMitigations(bool enforce) {
    if(enforce) {
        Bluespawn::io.InformUser(L"Enforcing Mitigations");
        mitigationRecord.PrintMitigationReports(mitigationRecord.EnforceMitigations(*mitigationConfig));
    } else {
        Bluespawn::io.InformUser(L"Auditing Mitigations");
        mitigationRecord.PrintMitigationReports(mitigationRecord.AuditMitigations(*mitigationConfig));
    }
}

void Bluespawn::RunMonitor() {
    DWORD tactics = UINT_MAX;
    DWORD dataSources = UINT_MAX;
    DWORD affectedThings = UINT_MAX;
    Scope scope{};

    Bluespawn::io.InformUser(L"Monitoring the system");
    huntRecord.SetupMonitoring(vIncludedHunts, vExcludedHunts);

    HandleWrapper hRecordEvent{ CreateEventW(nullptr, false, false, L"Local\\FlushLogs") };
    while(true) {
        SetEvent(hRecordEvent);
        Sleep(5000);
    }
}

void Bluespawn::AddReaction(std::unique_ptr<Reaction>&& reaction) {
    Bluespawn::reaction.AddHandler(std::move(reaction));
}

void Bluespawn::EnableMode(BluespawnMode mode, int option) {
    modes.emplace(mode, option);
}

void Bluespawn::SetIncludedHunts(std::vector<std::string> includedHunts) {
    for(auto& id : includedHunts) {
        Bluespawn::vIncludedHunts.emplace_back(StringToWidestring(id));
    }
}

void Bluespawn::SetExcludedHunts(std::vector<std::string> excludedHunts) {
    for(auto& id : excludedHunts) {
        Bluespawn::vExcludedHunts.emplace_back(StringToWidestring(id));
    }
}

void Bluespawn::RunScan(){
    std::vector<std::shared_ptr<Detection>> detections;
    for(auto& file : scanFiles){
        if(FileScanner::PerformQuickScan(file.GetFilePath())){
            detections.emplace_back(Bluespawn::detections.AddDetection(Detection(FileDetectionData{ file })));
        }
    }
    for(auto pid : scanProcesses){
        Hunts::HuntT1055::HandleReport(detections, Hunts::HuntT1055::QueueProcessScan(pid));
    }
}

void Bluespawn::Run() {
    if(modes.find(BluespawnMode::MITIGATE) != modes.end()) {
        RunMitigations(modes[BluespawnMode::MITIGATE]);
    }
    if(modes.find(BluespawnMode::HUNT) != modes.end()) {
        RunHunts();
    }
    if(modes.find(BluespawnMode::MONITOR) != modes.end()){
        RunMonitor();
    }
    if(modes.find(BluespawnMode::SCAN) != modes.end()){
        RunScan();
    }

    ThreadPool::GetInstance().Wait();
    Bluespawn::detections.Wait();
}

void print_help(cxxopts::ParseResult result, cxxopts::Options options) {
    std::string help_category = result["help"].as<std::string>();

    std::string output = "";
    if(CompareIgnoreCase(help_category, std::string{ "hunt" })) {
        output = options.help({ "hunt" });
    } else if(CompareIgnoreCase(help_category, std::string{ "monitor" })) {
        output = std::regex_replace(options.help({ "hunt" }), std::regex("hunt options"), "monitor options");
    } else if(CompareIgnoreCase(help_category, std::string{ "mitigate" })) {
        output = options.help({ "mitigate" });
    } else {
        output = std::regex_replace(options.help(), std::regex("hunt options"), "hunt/monitor options");
    }
    Bluespawn::io.InformUser(StringToWidestring(output));
}

void Bluespawn::SetMitigationConfig(const MitigationsConfiguration& config){
    mitigationConfig = config;
}

void Bluespawn::check_correct_arch() {
    BOOL bIsWow64 = FALSE;
    if(IsWindows10OrGreater() && Linker::IsWow64Process2) {
        USHORT ProcessMachine;
        USHORT NativeMachine;
        Linker::IsWow64Process2(GetCurrentProcess(), &ProcessMachine, &NativeMachine);
        if(ProcessMachine != IMAGE_FILE_MACHINE_UNKNOWN) {
            bIsWow64 = TRUE;
        }
    } else {
        IsWow64Process(GetCurrentProcess(), &bIsWow64);
    }
    if(bIsWow64) {
        Bluespawn::io.AlertUser(L"Running the x86 version of BLUESPAWN on an x64 system! This configuration is not "
                                L"fully supported, so we recommend downloading the x64 version.",
                                5000, ImportanceLevel::MEDIUM);
        LOG_WARNING("Running the x86 version of BLUESPAWN on an x64 system! This configuration is not fully supported, "
                    "so we recommend downloading the x64 version.");
    }
}

void ParseLogSinks(const std::string& sinks, const std::string& logdir) {
    std::set<std::string> sink_set;
    for(unsigned startIdx = 0; startIdx < sinks.size();) {
        auto endIdx{ sinks.find(',', startIdx) };
        auto sink{ sinks.substr(startIdx, endIdx - startIdx) };
        sink_set.emplace(sink);
        startIdx = endIdx + 1;
        if(endIdx == std::string::npos) {
            break;
        }
    }

    std::wstring outputFolderPath = L".";

    auto outputDir = FileSystem::Folder(StringToWidestring(logdir));
    if(outputDir.GetFolderExists() && !outputDir.GetCurIsFile() && outputDir.GetFolderWrite()) {
        outputFolderPath = outputDir.GetFolderPath();
    } else {
        LOG_ERROR(L"Unable to access " << StringToWidestring(logdir)
                                       << L" to write logs. Defaulting to current directory.");
        Bluespawn::io.AlertUser(L"Unable to access " + StringToWidestring(logdir) +
                                    L" to write logs. Defaulting to current directory.",
                                5000, ImportanceLevel::MEDIUM);
    }

    std::vector<std::reference_wrapper<Log::LogLevel>> levels{
        Log::LogLevel::LogError, Log::LogLevel::LogWarn,     Log::LogLevel::LogInfo1,    Log::LogLevel::LogInfo2,
        Log::LogLevel::LogInfo3, Log::LogLevel::LogVerbose1, Log::LogLevel::LogVerbose2, Log::LogLevel::LogVerbose3,
    };

    for(auto sink : sink_set) {
        if(sink == "console") {
            auto console = std::make_shared<Log::CLISink>();
            Log::AddSink(console, levels);
            Bluespawn::detectionSinks.emplace_back(console);
        } else if(sink == "xml") {
            auto XML = std::make_shared<Log::XMLSink>(outputFolderPath);
            Log::AddSink(XML, levels);
            Bluespawn::detectionSinks.emplace_back(XML);
        } else if(sink == "json") {
            auto JSON = std::make_shared<Log::JSONSink>(outputFolderPath);
            Log::AddSink(JSON, levels);
            Bluespawn::detectionSinks.emplace_back(JSON);
        } else if(sink == "debug") {
            auto debug = std::make_shared<Log::DebugSink>();
            Log::AddSink(debug, levels);
            Bluespawn::detectionSinks.emplace_back(debug);
        } else {
            Bluespawn::io.AlertUser(L"Unknown log sink \"" + StringToWidestring(sink) + L"\"", INFINITY,
                                    ImportanceLevel::MEDIUM);
        }
    }
}

Aggressiveness GetAggressiveness(const cxxopts::OptionValue& value) {
    Aggressiveness aHuntLevel{};
    auto level{ value.as<std::string>() };

    if(CompareIgnoreCase<std::string>(level, "Cursory")) {
        aHuntLevel = Aggressiveness::Cursory;
    } else if(CompareIgnoreCase<std::string>(level, "Normal")) {
        aHuntLevel = Aggressiveness::Normal;
    } else if(CompareIgnoreCase<std::string>(level, "Intensive")) {
        aHuntLevel = Aggressiveness::Intensive;
    } else {
        LOG_ERROR("Error " << StringToWidestring(level)
                           << " - Unknown level. Please specify either Cursory, Normal, or Intensive");
        LOG_ERROR("Will default to Normal for this run.");
        Bluespawn::io.InformUser(L"Error " + StringToWidestring(level) +
                                 L" - Unknown level. Please specify either Cursory, Normal, or Intensive");
        Bluespawn::io.InformUser(L"Will default to Normal.");
        aHuntLevel = Aggressiveness::Normal;
    }

    return aHuntLevel;
}

int main(int argc, char* argv[]) {
    Log::LogLevel::LogError.Enable();
    Log::LogLevel::LogWarn.Enable();
    ThreadPool::GetInstance().AddExceptionHandler([](const auto& e) { LOG_ERROR(e.what()); });

    Bluespawn bluespawn{};

    print_banner();

    bluespawn.check_correct_arch();

    if(argc == 1) {
        Bluespawn::io.AlertUser(L"Please launch BLUESPAWN from a CLI and specify what you want it to do. You can use "
                                L"the --help flag to see what options are available.",
                                INFINITE, ImportanceLevel::MEDIUM);
    }

    cxxopts::Options options("BLUESPAWN.exe", "BLUESPAWN: An Active Defense and EDR software to empower Blue Teams");

    // clang-format off
    options.add_options()
        ("h,hunt", "Hunt for malicious activity on the system", cxxopts::value<bool>())
        ("n,monitor", "Monitor the system for malicious activity, dispatching hunts as changes are detected.",
            cxxopts::value<bool>())
        ("m,mitigate", "Mitigate vulnerabilities by applying security settings.", 
            cxxopts::value<bool>())
        ("s,scan", "Scan a particular process, file, or folder", cxxopts::value<bool>())
        ("log", "Specify how BLUESPAWN should log events. Options are console, xml, json, and debug.",
            cxxopts::value<std::string>()->default_value("console")->implicit_value("console"))
        ("help", "Help Information. You can also specify a category for help on a specific module such as hunt.",
            cxxopts::value<std::string>()->implicit_value("general"))
        ("v,verbose", "Verbosity", cxxopts::value<int>()->default_value("1"))
        ("debug", "Enable Debug Output", cxxopts::value<int>()->default_value("0"))
        ("a,aggressiveness", "Sets the aggressiveness of BLUESPAWN. Options are cursory, normal, and intensive",
         cxxopts::value<std::string>()->default_value("Normal"))
        ("r,react", "Specifies how BLUESPAWN should react to potential threats dicovered during hunts. Available reactions are remove-value, carve-memory, suspend, delete-file, and quarantine-file",
         cxxopts::value<std::string>()->default_value(""))
        ;

    options.add_options("scan")
        ("scan-folder", "Specify a folder to scan", cxxopts::value<std::vector<std::string>>()->implicit_value({}))
        ("scan-file", "Specify a file to scan", cxxopts::value<std::vector<std::string>>()->implicit_value({}))
        ("scan-process", "Specify a process to scan by PID", cxxopts::value<std::vector<int>>()->implicit_value({}))
        ;

    options.add_options("hunt")
		("hunts", "Only run the hunts specified. Provide as a comma separated list of Mitre ATT&CK Technique IDs.", 
            cxxopts::value<std::vector<std::string>>())
		("exclude-hunts", "Run all hunts except those specified. Provide as a comma separated list of Mitre ATT&CK Technique IDs.", 
            cxxopts::value<std::vector<std::string>>())
		;

    options.add_options("log")
		("o,output", "Specify the output folder for any logs written to a file", 
            cxxopts::value<std::string>()->default_value("."))
        ;

    options.add_options("mitigate")
		("mode", "Selects whether to audit or enforce each mitigations. Options are audit and enforce. Ignored if "
                 "--gen-config is specified",
            cxxopts::value<std::string>()->default_value("audit")->implicit_value("audit"))
        ("config-json", "Specify a file containing a JSON configuration for which mitigations and policies should run", 
            cxxopts::value<std::string>())
        ("enforcement-level", "Specify the enforcement level for mitigations. This is used to select which policies "
                               "should be run. Available levels are none, low, moderate, high, and all",
            cxxopts::value<std::string>()->default_value("moderate")->implicit_value("moderate"))
        ("add-mitigations", "Specify additional JSON files containing mitigations.",
            cxxopts::value<std::vector<std::string>>())
        ("gen-config", "Generate a default JSON configuration file (./bluespawn-mitigation-config.json) with the "
                       "specified level of detail. Options are global, mitigations, and mitigation-policies. Will not "
                       "run any mitigations if this is specified",
            cxxopts::value<std::string>()->default_value("mitigations"))
        ;
    // clang-format on

    try {
        auto result = options.parse(argc, argv);

        if(result.count("help")) {
            print_help(result, options);
            return 0;
        }

        if(result["verbose"].as<int>() >= 1) {
            Log::LogLevel::LogInfo1.Enable();
        }
        if(result["verbose"].as<int>() >= 2) {
            Log::LogLevel::LogInfo2.Enable();
        }
        if(result["verbose"].as<int>() >= 3) {
            Log::LogLevel::LogInfo3.Enable();
        }

        if(result.count("debug")) {
            if(result["debug"].as<int>() >= 1) {
                Log::LogLevel::LogVerbose1.Enable();
            }
            if(result["debug"].as<int>() >= 2) {
                Log::LogLevel::LogVerbose2.Enable();
            }
            if(result["debug"].as<int>() >= 3) {
                Log::LogLevel::LogVerbose3.Enable();
            }
        }

        ParseLogSinks(result["log"].as<std::string>(), result["output"].as<std::string>());

        if(result.count("aggressiveness")){
            bluespawn.aggressiveness = GetAggressiveness(result["aggressiveness"]);
        }

        if(result.count("hunt") || result.count("monitor") || result.count("scan")) {
            if(result.count("hunt")) {
                bluespawn.EnableMode(BluespawnMode::HUNT);
            }
            if(result.count("monitor")) {
                bluespawn.EnableMode(BluespawnMode::MONITOR);
            }

            if(result.count("scan")){
                if(result.count("scan-file")){
                    for(auto& filePath : result["scan-file"].as<std::vector<std::string>>()){
                        FileSystem::File file{ StringToWidestring(filePath) };
                        if(!file.GetFileExists()){
                            Bluespawn::io.AlertUser(L"File " + file.GetFilePath() + L" not found");
                            continue;
                        }
                        bluespawn.scanFiles.emplace_back(file);
                    }
                }
                if(result.count("scan-folder")){
                    for(auto& folderPath : result["scan-folder"].as<std::vector<std::string>>()){
                        FileSystem::Folder folder{ StringToWidestring(folderPath) };
                        if(!folder.GetFolderExists()){
                            Bluespawn::io.AlertUser(L"Folder " + folder.GetFolderPath() + L" not found");
                            continue;
                        }
                        auto folderContents{ folder.GetFiles() };
                        for(auto& file : folderContents){
                            bluespawn.scanFiles.emplace_back(file);
                        }
                    }
                }
                if(result.count("scan-process")){
                    for(auto& process : result["scan-process"].as<std::vector<int>>()){
                        bluespawn.scanProcesses.emplace_back(process);
                    }
                }
                bluespawn.EnableMode(BluespawnMode::SCAN);
            }

            if(result.count("hunts")) {
                bluespawn.SetIncludedHunts(result["hunts"].as<std::vector<std::string>>());
            } else if(result.count("exclude-hunts")) {
                bluespawn.SetExcludedHunts(result["exclude-hunts"].as<std::vector<std::string>>());
            }

            auto UserReactions = result["react"].as<std::string>();
            std::set<std::string> reaction_set;
            for(unsigned startIdx = 0; startIdx < UserReactions.size();) {
                auto endIdx{ UserReactions.find(',', startIdx) };
                auto sink{ UserReactions.substr(startIdx, endIdx - startIdx) };
                reaction_set.emplace(sink);
                startIdx = endIdx + 1;
                if(endIdx == std::string::npos) {
                    break;
                }
            }

            for(auto reaction : reaction_set) {
                if(reactions.find(reaction) != reactions.end()) {
                    bluespawn.AddReaction(std::move(reactions[reaction]));
                } else {
                    bluespawn.io.AlertUser(L"Unknown reaction \"" + StringToWidestring(reaction) + L"\"", INFINITY,
                                           ImportanceLevel::MEDIUM);
                }
            }
        }

        if(result.count("mitigate")) {
            if(result.count("add-mitigations")){
                for(auto& path : result["add-mitigations"].as<std::vector<std::string>>()){
                    Bluespawn::mitigationRecord.ParseMitigationsJSON({ StringToWidestring(path) });
                }
            }
            if(result.count("gen-config")){
                auto opt{ ToLowerCaseA(result["gen-config"].as<std::string>()) };
                std::map<std::string, int> genConfigOptions{
                    {"global", 0},
                    {"mitigations", 1},
                    {"mitigation-policies", 2}
                };
                if(genConfigOptions.count(opt)){
                    if(Bluespawn::mitigationRecord.CreateConfig(
                        FileSystem::File{ L".\\bluespawn-mitigation-config.json" }, genConfigOptions[opt])){
                        Bluespawn::io.InformUser(L"Saved configuration to .\\bluespawn-mitigation-config.json");
                    }
                } else{
                    Bluespawn::io.AlertUser(StringToWidestring("Unknown gen-config mode \"" + opt + "\". Options are "
                                                               "global, mitigations, and mitigation-policies"));
                }
            } else{
                auto mode{ result["mode"].as<std::string>() };
                bool enforce{ mode == "e" || mode == "enforce" };
                std::map<std::string, EnforcementLevel> enforcementLevelOptions{
                    {"none", EnforcementLevel::None},
                    {"low", EnforcementLevel::Low},
                    {"moderate", EnforcementLevel::Moderate},
                    {"high", EnforcementLevel::High},
                    {"all", EnforcementLevel::All},
                };
                auto fileSpecified{ result.count("config-json") };
                if(!fileSpecified){
                    auto level{ EnforcementLevel::None };
                    auto levelSpecified{ result["enforcement-level"].as<std::string>() };
                    if(enforcementLevelOptions.count(levelSpecified)){
                        level = enforcementLevelOptions[levelSpecified];
                    } else{
                        Bluespawn::io.AlertUser(
                            StringToWidestring("Unknown enforcement level \"" + levelSpecified + "\". Options are none,"
                                               "low, moderate, high, and all. Defaulting to none"));
                    }
                    bluespawn.SetMitigationConfig(level);
                } else{
                    auto file{ FileSystem::File(StringToWidestring(result["config-json"].as<std::string>())) };
                    if(file.GetFileExists()){
                        try{
                            auto contents{ file.Read() };
                            bluespawn.SetMitigationConfig(json::parse(nlohmann::detail::span_input_adapter(
                                contents.GetAsPointer<char>(), contents.GetSize())));
                        } catch(std::exception& e){
                            Bluespawn::io.AlertUser(L"Error parsing JSON: " + StringToWidestring(e.what()));
                        }
                    } else{
                        Bluespawn::io.AlertUser(L"JSON configuration file " + file.GetFilePath() + L" not found!");
                        bluespawn.SetMitigationConfig(EnforcementLevel::None);
                    }
                }
                bluespawn.EnableMode(BluespawnMode::MITIGATE, enforce);
            }
        }

        bluespawn.Run();
    } catch(cxxopts::OptionParseException e1) {
        Bluespawn::io.InformUser(StringToWidestring(options.help()));
        LOG_ERROR(e1.what());
    }
    return 0;
}

```

`BLUESPAWN-win-client/src/user/CLI.cpp`:

```cpp
#include "user/CLI.h"
#include "util/log/Log.h"
#include <chrono>
#include <iostream>
#include <limits>
#include "util/stringutils.h"

#undef max

//Identifiers for different message types
#define INFORM_ID L"[*]"
#define ALERT_ID L"[!]"
#define CONFIRM_ID L"[+]"
#define SELECT_ID L"[?]"

//Colors for different parts of messages
const MessageColor ID_COLOR = MessageColor::BLUE;
const MessageColor TEXT_COLOR = MessageColor::LIGHTGRAY;

//Case-insensitive options for user confirmation.
const std::set<std::wstring> affirmativeOptions = { L"yes", L"y" };
const std::set<std::wstring> negativeOptions = { L"no", L"n" };
const std::set<std::wstring> cancelOptions = { L"c", L"cancel" };

const std::wstring descriptions[3] = {
	L"[LOW]",
	L"[MEDIUM]",
	L"[HIGH]"
};

const MessageColor colors[3] = {
	MessageColor::GREEN,
	MessageColor::YELLOW,
	MessageColor::RED
};

CLI::CLI() : hMutex{ CreateMutexW(nullptr, false, L"Local\\CLI-Mutex") } {}

void Print(const std::wstring& wMessage, MessageColor color = TEXT_COLOR, bool newline=true){
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hConsole, static_cast<WORD>(color));
	if(newline){
		std::wcout << wMessage << std::endl;
	} else {
		std::wcout << wMessage;
	}
}

std::optional<std::wstring> GetInput(DWORD dwMaximumDelay){
	std::wstring output{};
	auto result = WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), dwMaximumDelay);
	if(result == WAIT_OBJECT_0){
		std::wstring input{};
		std::getline(std::wcin, input);
		return input;
	} else {
		return std::nullopt;
	}
}

const CLI CLI::instance{};

const CLI& CLI::GetInstance(){
	return instance;
}

std::wstring CLI::GetUserSelection(const std::wstring& prompt, const std::vector<std::wstring>& options,
	DWORD dwMaximumDelay, ImportanceLevel level) const {
	auto mutex = AcquireMutex(hMutex);
	Print(SELECT_ID, ID_COLOR, false);
	Print(descriptions[static_cast<DWORD>(level)], colors[static_cast<DWORD>(level)], false);
	Print(L" " + prompt);

	int i = 0;
	for (auto str : options) {
		i += 1;
		Print(std::to_wstring(i), MessageColor::CYAN, false);
		Print(L". " + str);
	}
	Print(L"Please enter a number 1 through " + std::to_wstring(i) + L" to continue. ", MessageColor::LIGHTGRAY, false);

	while(true){
		size_t userIn = 0;
		std::wstringstream stream{};
		auto input = GetInput(dwMaximumDelay);
		if(!input){
			return {};
		} else {
			stream << *input;
			stream >> userIn;
			if(stream.good() && userIn > 0 && userIn <= i){
				return options[userIn - 1];
			} else {
				Print(L"Please enter a number 1 through " + std::to_wstring(i) + L" to continue. ", MessageColor::LIGHTGRAY, false);
			}
		}
	};

	return L"";
}

void CLI::InformUser(const std::wstring& information, ImportanceLevel level) const {
	auto mutex = AcquireMutex(hMutex);
	Print(INFORM_ID, ID_COLOR, false);
	Print(descriptions[static_cast<DWORD>(level)], colors[static_cast<DWORD>(level)], false);
	Print(L" " + information);
}
bool CLI::AlertUser(const std::wstring& information, DWORD dwMaximumDelay, ImportanceLevel level) const {
	auto mutex = AcquireMutex(hMutex);
	Print(ALERT_ID, ID_COLOR, false);
	Print(descriptions[static_cast<DWORD>(level)], colors[static_cast<DWORD>(level)], false);
	Print(L" " + information);
	Print(L"Press enter to continue. ", MessageColor::LIGHTGRAY, false);
	Print(L"");
	return GetInput(dwMaximumDelay).has_value();
}

DWORD CLI::GetUserConfirm(const std::wstring& prompt, DWORD dwMaximumDelay, ImportanceLevel level) const {
	auto mutex = AcquireMutex(hMutex);
	Print(CONFIRM_ID, ID_COLOR, false);
	Print(descriptions[static_cast<DWORD>(level)], colors[static_cast<DWORD>(level)], false);
	Print(L" " + prompt);
	while(true){
		Print(L"Enter y(es), n(o), or c(ancel). ", MessageColor::LIGHTGRAY, false);
		auto result = GetInput(dwMaximumDelay);
		if(!result){
			return -1;
		} else {
			auto choice = ToLowerCase(*result);
			if(affirmativeOptions.find(choice) != affirmativeOptions.end()) {
				return 1;
			} else if(negativeOptions.find(choice) != negativeOptions.end()) {
				return 0;
			} else if(cancelOptions.find(choice) != cancelOptions.end()) {
				return -1;
			}
		}
	}
}

const HandleWrapper& CLI::GetMutex() const {
	return hMutex;
}
```

`BLUESPAWN-win-client/src/user/banners.cpp`:

```cpp
#include "user/banners.h"

#include <algorithm>
#include <iostream>
#include <time.h>

#include "util/log/Log.h"

void print_banner() {
	// Put these in a file, then include that file in the resources for the exe

	std::replace(banners.at(4).begin(), banners.at(4).end(), 'A', (char)201u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'B', (char)200u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'C', (char)188u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'D', (char)187u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'E', (char)205u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'F', (char)219u);
	std::replace(banners.at(4).begin(), banners.at(4).end(), 'G', (char)186u);

	srand(static_cast<unsigned int>(time(nullptr)));

	std::cout << banners.at(std::rand() % banners.size()) << std::endl;
}

```

`BLUESPAWN-win-client/src/util/DynamicLinker.cpp`:

```cpp
#include "util/DynamicLinker.h"

#include <Windows.h>
#include <winternl.h>

#include <vector>
#include <functional>
#include <iostream>

namespace Linker {
	std::vector<std::function<bool()>> LoadCalls = {};

	bool LinkFunctions(){
		for(auto func : LoadCalls){
			if(!func()){
				return false;
			}
		}
		return true;
	}
}
```

`BLUESPAWN-win-client/src/util/StringUtils.cpp`:

```cpp
#include "util/StringUtils.h"

#include <algorithm>
#include <cmath>
#include <codecvt>
#include <map>
#include <string>
#include <vector>

double GetShannonEntropy(const std::wstring& str) {
    // Code from https://rosettacode.org/wiki/Entropy#C.2B.2B
    std::map<char, int> frequencies;
    for(char c : str)
        frequencies[c]++;
    int numlen = str.length();
    double infocontent = 0;
    for(std::pair<char, int> p : frequencies) {
        double freq = static_cast<double>(p.second) / numlen;
        infocontent -= freq * (log(freq) / log(2));
    }

    return infocontent;
}

std::wstring StringToWidestring(const std::string& str) {
    std::wstring s = { str.begin(), str.end() };
    return s;
}

std::string WidestringToString(const std::wstring& wstr) {
    std::string s = { wstr.begin(), wstr.end() };
    return s;
}

std::wstring ExpandEnvStringsW(const std::wstring& in) {
    WCHAR* expanded = new WCHAR[MAX_PATH];
    auto result = ExpandEnvironmentStringsW(in.c_str(), expanded, MAX_PATH);
    if(result > MAX_PATH) {
        delete[] expanded;
        expanded = new WCHAR[result];
        result = ExpandEnvironmentStringsW(in.c_str(), expanded, result);
    }

    std::wstring str{ expanded };

    delete[] expanded;

    return str;
}

std::string ExpandEnvStringsA(const std::string& in){
	CHAR* expanded = new CHAR[MAX_PATH];
	auto result = ExpandEnvironmentStringsA(in.c_str(), expanded, MAX_PATH);
	if(result > MAX_PATH){
		delete[] expanded;
		expanded = new CHAR[result];
		result = ExpandEnvironmentStringsA(in.c_str(), expanded, result);
	}

    std::string str{ expanded };

    delete[] expanded;

    return str;
}

std::wstring ToWstringPad(DWORD value, size_t length) {
    wchar_t* buf = new wchar_t[length + 1];
    swprintf(buf, (L"%0" + std::to_wstring(length) + L"d").c_str(), value);
    std::wstring str = buf;
    delete[] buf;
    return str;
}

template<class T>
T ToUpperCase(const T& in) {
    T copy = in;
    transform(copy.begin(), copy.end(), copy.begin(), ::toupper);
    return copy;
}

template std::wstring ToUpperCase(const std::wstring& in);
template std::string ToUpperCase(const std::string& in);

template<class T>
T ToLowerCase(const T& in) {
    T copy = in;
    transform(copy.begin(), copy.end(), copy.begin(), ::tolower);
    return copy;
}

template std::wstring ToLowerCase(const std::wstring& in);
template std::string ToLowerCase(const std::string& in);

template<class T>
bool CompareIgnoreCase(const T& in1, const T& in2) {
    return ToLowerCase(in1) == ToLowerCase(in2);
}

template bool CompareIgnoreCase(const std::wstring& in1, const std::wstring& in2);
template bool CompareIgnoreCase(const std::string& in, const std::string& in2);

template<class T>
T StringReplace(const T& string, const T& search, const T& replacement) {
    auto copy{ string };
    for(auto find{ copy.find(search) }; find != std::string::npos;
        find = copy.find(search, find + replacement.size())) {
        copy.replace(copy.begin() + find, copy.begin() + find + search.length(), replacement);
    }
    return copy;
}

template std::wstring
StringReplace(const std::wstring& string, const std::wstring& search, const std::wstring& replacement);
template std::string
StringReplace(const std::string& string, const std::string& search, const std::string& replacement);
template bool CompareIgnoreCase(const std::string& in, const std::string& in2);

template<class T>
std::vector<std::basic_string<T>> SplitString(const std::basic_string<T>& in, const std::basic_string<T>& delimiter) {
    std::vector<std::basic_string<T>> substrs{};
    for(size_t i = 0; i < in.length();) {
        auto next{ in.find(delimiter, i) };
        substrs.emplace_back(in.substr(i, next - i));
        if(next == std::basic_string<T>::npos) {
            return std::move(substrs);
        }
        i = next + delimiter.length();
    }
    return substrs;
}

template std::vector<std::wstring> SplitString(const std::wstring& in, const std::wstring& delimiter);
template std::vector<std::string> SplitString(const std::string& in, const std::string& delimiter);

```

`BLUESPAWN-win-client/src/util/ThreadPool.cpp`:

```cpp
#include "util/ThreadPool.h"

#include <eh.h>

ThreadPool ThreadPool::instance{};

void ThreadPool::ThreadFunction(){
	while(active){
		auto result{ WaitForSingleObject(hSemaphore, INFINITE) };
		if(result == WAIT_OBJECT_0){
			if(!active){
				return;
			}

			EnterCriticalSection(hGuard);
			auto function{ tasks.front() };
			tasks.pop();
			LeaveCriticalSection(hGuard);

			try{
				function();

				EnterCriticalSection(hGuard);
				count--;
				if(count == 0){
					SetEvent(hEvent);
				}
				LeaveCriticalSection(hGuard);

			} catch(std::exception e){
				EnterCriticalSection(hGuard);
				count--;
				if(count == 0){
					SetEvent(hEvent);
				}
				LeaveCriticalSection(hGuard);

				auto functions{ vExceptionHandlers };

				// Defer handling the exceptions until later
				EnqueueTask([functions, e](){
					for(auto& function : functions){
						function(e);
					}
				});
			}
		} else{
			if(WaitForSingleObject(hSemaphore, 0) == WAIT_FAILED){
				// hSemaphore has become invalidated somehow. Recreate it
				hSemaphore = CreateSemaphoreW(nullptr, 0, static_cast<LONG>(-1), nullptr);
			}
		}
	}
}

ThreadPool::ThreadPool() :
	hSemaphore{ CreateSemaphoreW(nullptr, 0, LONG_MAX, nullptr) },
	hEvent{ CreateEventW(nullptr, true, true, nullptr) },
	active{ true }{

	auto error{ GetLastError() };
	// https://stackoverflow.com/questions/457577/catching-access-violation-exceptions
	_set_se_translator([](unsigned int u, EXCEPTION_POINTERS* pExp){
		std::string error = "Structured Exception: ";
		char result[11];
		sprintf_s(result, 11, "0x%08X", u);
		error += result;
		throw std::exception(error.c_str());
    });

	auto count{ std::thread::hardware_concurrency() };

	for(unsigned int idx = 0; idx < count; idx++){
		threads.emplace_back(std::thread{ &ThreadPool::ThreadFunction, this });
	}
}

ThreadPool::~ThreadPool(){
	active = false;

	ReleaseSemaphore(hSemaphore, threads.size(), nullptr);

	for(auto& thread : threads){
		thread.join();
	}
}

void ThreadPool::EnqueueTask(IN CONST std::function<void()>& function){
	ResetEvent(hEvent);

	auto lock{ BeginCriticalSection(hGuard) };

	tasks.emplace(function);
	count++;

	ReleaseSemaphore(hSemaphore, 1, nullptr);
}

ThreadPool& ThreadPool::GetInstance(){
	return instance;
}

void ThreadPool::AddExceptionHandler(
	IN CONST std::function<void(const std::exception & e)>& function){
	vExceptionHandlers.emplace_back(function);
}

void ThreadPool::Wait() const {
	while(true){
		auto status{ WaitForSingleObject(hEvent, INFINITE) };
		if(status == WAIT_OBJECT_0){
			EnterCriticalSection(hGuard);
			if(count == 0){
				LeaveCriticalSection(hGuard);
				return;
			}
			LeaveCriticalSection(hGuard);
		} else{
			throw std::exception{ "Error waiting for threadpool to finish" };
		}
	}
}
```

`BLUESPAWN-win-client/src/util/Utils.cpp`:

```cpp
#include "util/Utils.h"
#include <windows.h>
#include <iostream>
#include <sstream>
#include <iomanip>

int64_t SystemTimeToInteger(const SYSTEMTIME& st){
	FILETIME ft;
	SystemTimeToFileTime(&st, &ft);

	ULARGE_INTEGER lv_Large;

	lv_Large.LowPart = ft.dwLowDateTime;
	lv_Large.HighPart = ft.dwHighDateTime;

	return lv_Large.QuadPart;
}

std::wstring FormatWindowsTime(const SYSTEMTIME& st){
	std::wostringstream w;
	w << std::setfill(L'0') << st.wYear << "-" << std::setw(2) << st.wMonth << "-" << std::setw(2) << st.wDay << " " <<
		std::setw(2) << st.wHour << ":" << std::setw(2) << st.wMinute << ":" << std::setw(2) << st.wSecond << "." <<
		((st.wMilliseconds % 10000000) * 100) << "Z";
	return w.str();
}


std::wstring FormatWindowsTime(const FILETIME& ft){
	SYSTEMTIME st;
	FileTimeToSystemTime(&ft, &st);

	std::wostringstream w;
	w << std::setfill(L'0') << st.wYear << "-" << std::setw(2) << st.wMonth << "-" << std::setw(2) << st.wDay << " " <<
		std::setw(2) << st.wHour << ":" << std::setw(2) << st.wMinute << ":" << std::setw(2) << st.wSecond << "." <<
		st.wMilliseconds << "Z";
	return w.str();
}


std::wstring FormatWindowsTime(const std::wstring& windowsTime){
	SYSTEMTIME st;
	FILETIME ft;

	ULONGLONG time = (ULONGLONG) stoull(windowsTime);
	ULONGLONG nano = 0;

	ft.dwHighDateTime = (DWORD) ((time >> 32) & 0xFFFFFFFF);
	ft.dwLowDateTime = (DWORD) (time & 0xFFFFFFFF);

	FileTimeToSystemTime(&ft, &st);
	nano = (time % 10000000) * 100; // Display nanoseconds instead of milliseconds for higher resolution

	std::wostringstream w;
	w << std::setfill(L'0') << st.wYear << "-" << std::setw(2) << st.wMonth << "-" << std::setw(2) << st.wDay << " " <<
		std::setw(2) << st.wHour << ":" << std::setw(2) << st.wMinute << ":" << std::setw(2) << st.wSecond << "." <<
		nano << "Z";
	return w.str();
}

```

`BLUESPAWN-win-client/src/util/configurations/CollectInfo.cpp`:

```cpp
#include "util/configurations/CollectInfo.h"

#include <Windows.h>

#include "util/log/Log.h"

std::wstring GetComputerDNSHostname() {
    DWORD dwSize;

    if(GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, NULL, &dwSize) == ERROR_MORE_DATA) {
        LPWSTR lpBuffer = new WCHAR[dwSize];
        if(GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, lpBuffer, &dwSize) == ERROR_SUCCESS) {
            return lpBuffer;
        }
    }
    LOG_VERBOSE(2, L"Unable to obtain computer hostname");
    return L"";
}

```

`BLUESPAWN-win-client/src/util/configurations/RegistryKey.cpp`:

```cpp
#include <Windows.h>

#include <iostream>
#include <optional>

#include "util/StringUtils.h"
#include "util/Internals.h"

#include "util/configurations/Registry.h"

LINK_FUNCTION(NtQueryKey, ntdll.dll);
LINK_FUNCTION(NtQueryValueKey, ntdll.dll);
LINK_FUNCTION(NtDeleteValueKey, ntdll.dll);

namespace Registry {
	std::map<std::wstring, HKEY> vHiveNames{
		{L"HKLM", HKEY_LOCAL_MACHINE},
		{L"HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE},

		{L"HKCR", HKEY_CLASSES_ROOT},
		{L"HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT},

		{L"HKCU", HKEY_CURRENT_USER},
		{L"HKEY_CURRENT_USER", HKEY_CURRENT_USER},

		{L"HKU", HKEY_USERS},
		{L"HKEY_USERS", HKEY_USERS},

		{L"HKCC", HKEY_CURRENT_CONFIG},
		{L"HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG},
	};

	std::map<HKEY, std::wstring> vHives{
		{HKEY_LOCAL_MACHINE, L"HKEY_LOCAL_MACHINE"},
		{HKEY_CLASSES_ROOT, L"HKEY_CLASSES_ROOT"},
		{HKEY_CURRENT_USER, L"HKEY_CURRENT_USER"},
		{HKEY_USERS, L"HKEY_USERS"},
		{HKEY_CURRENT_CONFIG, L"HKEY_CURRENT_CONFIG"},
	};

	RegistryKey::Tracker::Tracker(){}

	void RegistryKey::Tracker::Increment(IN HKEY hKey){
		BeginCriticalSection _{ hGuard };
		if(hKey){
			if(counts.find(hKey) == counts.end()){
				counts[hKey] = 1;
			} else{
				counts[hKey]++;
			}
		}
	}

	void RegistryKey::Tracker::Decrement(IN HKEY hKey){
		BeginCriticalSection _{ hGuard };
		if(hKey){
			if(counts.find(hKey) != counts.end()){
				if(!--counts[hKey] && !(reinterpret_cast<ULONG_PTR>(hKey) & 0xFFFFFFFF80000000)){
					CloseHandle(hKey);
				}
			}
		}
	}

	int RegistryKey::Tracker::Get(IN HKEY hKey){
		BeginCriticalSection _{ hGuard };
		if(counts.find(hKey) != counts.end()){
			return counts[hKey];
		} else{
			return 0;
		}
	}

	std::shared_ptr<RegistryKey::Tracker> RegistryKey::__tracker{ std::make_shared<RegistryKey::Tracker>() };

	RegistryKey::RegistryKey(const RegistryKey& key) noexcept :
		bKeyExists{ key.bKeyExists },
		bWow64{ key.bWow64 },
		hkBackingKey{ key.hkBackingKey },
		path{ key.path },
		hkHive{ key.hkHive },
		tracker{ __tracker }{

		tracker->Increment(hkBackingKey);
	}

	RegistryKey& RegistryKey::operator=(const RegistryKey& key) noexcept {
		this->bKeyExists = key.bKeyExists;
		this->bWow64 = key.bWow64;
		this->hkBackingKey = key.hkBackingKey;
		this->path = key.path;
		this->hkHive = key.hkHive;

		tracker->Increment(hkBackingKey);

		return *this;
	}

	RegistryKey::RegistryKey(RegistryKey&& key) noexcept :
		bKeyExists{ key.bKeyExists },
		bWow64{ key.bWow64 },
		hkBackingKey{ key.hkBackingKey },
		path{ std::move(key.path) },
		hkHive{ key.hkHive },
		tracker{ __tracker }{

		key.bKeyExists = false;
		key.bWow64 = false;
		key.path = {};
		key.hkHive = nullptr;
		key.hkBackingKey = nullptr;
	}

	RegistryKey& RegistryKey::operator=(RegistryKey&& key) noexcept {
		this->bKeyExists = key.bKeyExists;
		this->bWow64 = key.bWow64;
		this->hkBackingKey = key.hkBackingKey;
		this->path = std::move(key.path);
		this->hkHive = key.hkHive;

		key.bKeyExists = false;
		key.bWow64 = false;
		key.path = {};
		key.hkHive = nullptr;
		key.hkBackingKey = nullptr;

		return *this;
	}

	/// TODO - Add smart WoW64 checking
	RegistryKey::RegistryKey(HKEY key) :
		bKeyExists{ true },
		bWow64{ false },
		hkBackingKey{ key },
		tracker{ __tracker }{

		tracker->Increment(hkBackingKey);
	}

	RegistryKey::RegistryKey(HKEY hive, std::wstring path, bool WoW64) :
		tracker{ __tracker }, hkHive{ hive }, path{ path }{
		auto wLowerPath = ToLowerCase(path);

		bWow64 = WoW64 || wLowerPath.find(L"wow6432node") != std::wstring::npos;
		LSTATUS status = RegOpenKeyExW(hive, path.c_str(), 0, KEY_ALL_ACCESS | (bWow64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), &hkBackingKey);
		if(status == ERROR_ACCESS_DENIED){
			status = RegOpenKeyExW(hive, path.c_str(), 0, KEY_READ | KEY_NOTIFY | (bWow64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), &hkBackingKey);
		}

		if(status != ERROR_SUCCESS){
			bKeyExists = false;
		} else {
			bKeyExists = true;

			tracker->Increment(hkBackingKey);
		}
	}

	RegistryKey::RegistryKey(const RegistryKey& hive, const std::wstring& path, bool wow64) :
		RegistryKey{ hive.Exists() ? hive.hkBackingKey : hive.hkHive, hive.Exists() ? path : hive.path + L"\\" + path, 
		             wow64 }{}
	
	RegistryKey::RegistryKey(std::wstring name, bool WoW64) :
		tracker{ __tracker }{
		name = ToUpperCase(name);

		SIZE_T slash = name.find_first_of(L"/\\");

		std::wstring HiveName = slash == std::wstring::npos ? name : name.substr(0, slash);

		if(vHiveNames.find(HiveName) == vHiveNames.end()){
			this->bKeyExists = false;
			this->bWow64 = false;
			this->hkBackingKey = nullptr;
		}

		else {
			hkHive = vHiveNames[HiveName];

			if(slash == name.length() || slash == std::wstring::npos){
				this->bKeyExists = true;
				this->bWow64 = false;
				this->hkBackingKey = hkHive;
			}

			else {
				path = name.substr(slash + 1, name.length());
				auto wLowerPath = ToLowerCase(path);

				bWow64 = WoW64 || wLowerPath.find(L"wow6432node") != std::wstring::npos;
				LSTATUS status = RegOpenKeyEx(hkHive, path.c_str(), 0, KEY_ALL_ACCESS | (WoW64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), &hkBackingKey);
				if(status == ERROR_ACCESS_DENIED){
					status = RegOpenKeyEx(hkHive, path.c_str(), 0, KEY_READ | KEY_NOTIFY | (WoW64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), &hkBackingKey);
				}

				if(status == ERROR_SUCCESS){
					tracker->Increment(hkBackingKey);

					bKeyExists = true;
				} else {
					bKeyExists = false;
				}
			}
		}
	}

	RegistryKey::~RegistryKey(){
		if(Exists()){
			tracker->Decrement(hkBackingKey);
		}
	}

	bool RegistryKey::CheckKeyExists(HKEY hive, const std::wstring& name, bool WoW64){
		auto wLowerPath = ToLowerCase(name);

		HKEY key{};
		WoW64 = WoW64 || wLowerPath.find(L"wow6432node") != std::wstring::npos;
		LSTATUS status = RegOpenKeyExW(hive, name.c_str(), 0,
									   KEY_READ | KEY_NOTIFY | (WoW64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), &key);
		if(status == ERROR_ACCESS_DENIED){ return true; }

		if(status == ERROR_SUCCESS){
			if(!__tracker->Get(key)){ RegCloseKey(key); }
			return true;
		}

		return false;
	}

	bool RegistryKey::Exists() const {
		return bKeyExists;
	}

	bool RegistryKey::ValueExists(const std::wstring& wsValueName) const {
		if(!Exists()){
			return false;
		}

		UNICODE_STRING RegistryKeyName{ 
			static_cast<USHORT>(wsValueName.length() * 2), 
			static_cast<USHORT>(wsValueName.length() * 2 + 2),
			const_cast<PWSTR>(wsValueName.c_str())
		};

		ULONG size{};
		NTSTATUS status{ Linker::NtQueryValueKey(hkBackingKey, &RegistryKeyName, 0, nullptr, 0, &size) }; //First 0 is KeyValueBasicInformation

		return status != 0xC0000034; //0xC0000034 = STATUS_OBJECT_NAME_NOT_FOUND
	}

	bool RegistryKey::Create(){
		if(Exists()){
			return true;
		}

		if(!hkHive){
			SetLastError(ERROR_NOT_FOUND);
			return false;
		}

		LSTATUS status = RegCreateKeyExW(hkHive, path.c_str(), 0, nullptr, 0, 
										KEY_ALL_ACCESS | (this->bWow64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY), nullptr,
										&hkBackingKey, nullptr);
		if(status == ERROR_SUCCESS){
			bKeyExists = true;

			tracker->Increment(hkBackingKey);

			return true;
		}

		SetLastError(status);

		return false;
	}

	AllocationWrapper RegistryKey::GetRawValue(const std::wstring& wsValueName) const {
		if(!Exists()){
			SetLastError(FILE_DOES_NOT_EXIST);
			return { nullptr, 0 };
		}

		UNICODE_STRING RegistryKeyName{
			static_cast<USHORT>(wsValueName.length() * 2),
			static_cast<USHORT>(wsValueName.length() * 2 + 2),
			const_cast<PWSTR>(wsValueName.c_str())
		};

		ULONG size{};
		NTSTATUS status{ Linker::NtQueryValueKey(hkBackingKey, &RegistryKeyName, 1, nullptr, 0, &size) }; //First 1 is KeyValueFullInformation

		auto data = AllocationWrapper{ new CHAR[size], size, AllocationWrapper::CPP_ARRAY_ALLOC };
		status = Linker::NtQueryValueKey(hkBackingKey, &RegistryKeyName, 1, data, size, &size);

		if (!NT_SUCCESS(status)) {
			SetLastError(status);
			return { nullptr, 0 };
		}

		KEY_VALUE_FULL_INFORMATION* KeyValueInfo{ data.GetAsPointer<KEY_VALUE_FULL_INFORMATION>() };

		DWORD dwDataSize = KeyValueInfo->DataLength;
		DWORD dwDataOffset = KeyValueInfo->DataOffset;

		auto lpbValue = new BYTE[dwDataSize];
		MoveMemory(lpbValue, reinterpret_cast<PCHAR>(KeyValueInfo) + dwDataOffset, dwDataSize);

		return { lpbValue, dwDataSize, AllocationWrapper::CPP_ARRAY_ALLOC };
	}

	std::optional<RegistryType> RegistryKey::GetValueType(const std::wstring& wsValueName) const {
		if(!Exists()){
			SetLastError(FILE_DOES_NOT_EXIST);
			return std::nullopt;
		}

		UNICODE_STRING RegistryKeyName{
			static_cast<USHORT>(wsValueName.length() * 2),
			static_cast<USHORT>(wsValueName.length() * 2 + 2),
			const_cast<PWSTR>(wsValueName.c_str())
		};

		ULONG size{};
		NTSTATUS status{ Linker::NtQueryValueKey(hkBackingKey, &RegistryKeyName, 0, nullptr, 0, &size) }; //First 0 is KeyValueBasicInformation

		std::vector<CHAR> data(size);
		status = Linker::NtQueryValueKey(hkBackingKey, &RegistryKeyName, 0, data.data(), size, &size);

		if(!NT_SUCCESS(status)){
			SetLastError(status);
			return std::nullopt;
		}

		auto KeyValueInfo{ reinterpret_cast<KEY_VALUE_BASIC_INFORMATION*>(data.data()) };

		DWORD dwType = KeyValueInfo->Type;

		if(dwType == REG_SZ){
			return RegistryType::REG_SZ_T;
		} else if(dwType == REG_EXPAND_SZ){
			return RegistryType::REG_EXPAND_SZ_T;
		} else if(dwType == REG_MULTI_SZ){
			return RegistryType::REG_MULTI_SZ_T;
		} else if(dwType == REG_DWORD){
			return RegistryType::REG_DWORD_T;
		}

		return RegistryType::REG_BINARY_T;
	}

	template<class T>
	std::optional<T> RegistryKey::GetValue(const std::wstring& wsValueName) const {
		if(ValueExists(wsValueName)){
			return GetRawValue(wsValueName).Dereference<T>();
		}
		return std::nullopt;
	}

	template std::optional<DWORD> RegistryKey::GetValue(const std::wstring& wsValueName) const;

	template<>
	std::optional<std::wstring> RegistryKey::GetValue(const std::wstring& wsValueName) const {
		if(ValueExists(wsValueName)){
			return GetRawValue(wsValueName).ReadWString();
		}
		return std::nullopt;
	}

	template<>
	std::optional<std::vector<std::wstring>> RegistryKey::GetValue(const std::wstring& wsValueName) const {
		if(ValueExists(wsValueName)){
			std::vector<std::wstring> strings{};

			LPCWSTR data = reinterpret_cast<LPCWSTR>((LPVOID) GetRawValue(wsValueName));

			while(*data){
				std::wstring str = data;
				strings.emplace_back(data);

				data += str.length() + 1;
			}

			return strings;
		}

		return std::nullopt;
	}

	bool RegistryKey::SetRawValue(const std::wstring& name, AllocationWrapper bytes, DWORD dwType) const {
		if(!Exists()){
			return false;
		}

		LSTATUS status = RegSetValueEx(hkBackingKey, name.c_str(), 0, dwType, reinterpret_cast<BYTE*>((LPVOID) bytes),
									   bytes.GetSize());
		if(status != ERROR_SUCCESS){
			SetLastError(status);
			return false;
		}

		return true;
	}

	template<class T>
	bool RegistryKey::SetValue(const std::wstring& name, T value, DWORD size, DWORD type) const {
		return SetRawValue(name, { reinterpret_cast<BYTE*>(value), size, AllocationWrapper::STACK_ALLOC }, type);
	}

	template<>
	bool RegistryKey::SetValue(const std::wstring& name, LPCWSTR value, DWORD size, DWORD type) const {
		return RegistryKey::SetRawValue(name, { PBYTE(value), wcslen(value) * 2 + 2, AllocationWrapper::STACK_ALLOC },
										type);
	}
	template bool RegistryKey::SetValue<LPCWSTR>(const std::wstring& name, LPCWSTR value, DWORD size, 
												 DWORD type) const;

	template<>
	bool RegistryKey::SetValue(const std::wstring& name, LPCSTR value, DWORD size, DWORD type) const {
		return RegistryKey::SetRawValue(name, { PBYTE(value), strlen(value), AllocationWrapper::STACK_ALLOC }, type);
	}
	template bool RegistryKey::SetValue<LPCSTR>(const std::wstring& name, LPCSTR value, DWORD size, DWORD type) const;

	template<>
	bool RegistryKey::SetValue(const std::wstring& name, DWORD value, DWORD size, DWORD type) const {
		return SetRawValue(name, { reinterpret_cast<BYTE*>(&value), 4, AllocationWrapper::STACK_ALLOC }, REG_DWORD);
	}
	template bool RegistryKey::SetValue<DWORD>(const std::wstring& name, DWORD value, DWORD size, DWORD type) const;

	template<> 
	bool RegistryKey::SetValue(const std::wstring& name, std::wstring value, DWORD size, DWORD type) const {
		return SetValue<LPCWSTR>(name, value.c_str(), static_cast<DWORD>((value.size() + 1) * 2), REG_SZ);
	}
	template bool RegistryKey::SetValue<std::wstring>(const std::wstring& name, std::wstring value, DWORD size, 
													  DWORD type) const;

	template<>
	bool RegistryKey::SetValue(const std::wstring& name, std::string value, DWORD size, DWORD type) const{
		return SetValue<std::wstring>(name, StringToWidestring(value));
	}
	template bool RegistryKey::SetValue<std::string>(const std::wstring& name, std::string value, DWORD size, 
													 DWORD type) const;

	bool RegistryKey::SetDataValue(const std::wstring& name, RegistryData value) const{
		auto idx = value.index();
		if(idx == 0){
			return SetValue<std::wstring>(name, std::get<0>(value));
		}
		if(idx == 1){
			return SetValue<DWORD>(name, std::get<1>(value));
		}
		if(idx == 2){
			return SetRawValue(name, std::get<2>(value), REG_BINARY);
		}
		if(idx == 3){
			return SetValue<std::vector<std::wstring>>(name, std::get<3>(value));
		} else{
			throw std::exception("Unknown registry data type");
		}
	}

	template bool RegistryKey::SetValue<std::vector<std::wstring>>(const std::wstring& name, std::vector<std::wstring> value,
		DWORD _size, DWORD type) const;

	std::vector<RegistryKey> RegistryKey::EnumerateSubkeys() const {
		if(!Exists()){
			SetLastError(ERROR_NOT_FOUND);
			return {};
		}

		DWORD dwSubkeyCount{};
		DWORD dwLongestSubkey{};
		LSTATUS status = RegQueryInfoKey(hkBackingKey, nullptr, nullptr, 0, &dwSubkeyCount, &dwLongestSubkey, 
			                             nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);

		std::vector<RegistryKey> vSubKeys{};

		if(status == ERROR_SUCCESS && dwSubkeyCount) {
			for(unsigned i = 0; i < dwSubkeyCount; i++) {
				DWORD length = dwLongestSubkey * 2;
				LPWSTR lpwName = new WCHAR[length];
				status = RegEnumKey(hkBackingKey, i, lpwName, length);

				if(status == ERROR_SUCCESS) {
					vSubKeys.push_back({ hkBackingKey, lpwName });
				}

				delete[] lpwName;
			}
		} else {
			SetLastError(status);
		}

		return vSubKeys;
	}

	std::vector<std::wstring> RegistryKey::EnumerateSubkeyNames() const{
		if(!Exists()){
			SetLastError(ERROR_NOT_FOUND);
			return {};
		}

		DWORD dwSubkeyCount{};
		DWORD dwLongestSubkey{};
		LSTATUS status = RegQueryInfoKeyW(hkBackingKey, nullptr, nullptr, 0, &dwSubkeyCount, &dwLongestSubkey,
										 nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);

		std::vector<std::wstring> vSubKeys{};

		if(status == ERROR_SUCCESS && dwSubkeyCount){
			for(unsigned i = 0; i < dwSubkeyCount; i++){
				std::vector<WCHAR> name(dwLongestSubkey + 1);
				status = RegEnumKeyW(hkBackingKey, i, name.data(), dwLongestSubkey + 1);

				if(status == ERROR_SUCCESS){
					vSubKeys.push_back(std::wstring{ name.data() });
				}
			}
		} else{
			SetLastError(status);
		}

		return vSubKeys;
	}

	std::vector<std::wstring> RegistryKey::EnumerateValues() const {
		if(!Exists()){
			SetLastError(ERROR_NOT_FOUND);
			return {};
		}

		DWORD dwValueCount{};
		DWORD dwLongestValue{};
		LSTATUS status = RegQueryInfoKey(hkBackingKey, nullptr, nullptr, 0, nullptr, nullptr, nullptr, &dwValueCount, 
			                             &dwLongestValue, nullptr, nullptr, nullptr);

		std::vector<std::wstring> vSubKeys{};

		if(status == ERROR_SUCCESS && dwValueCount) {
			for(unsigned i = 0; i < dwValueCount; i++) {
				DWORD length = dwLongestValue * 2;
				LPWSTR lpwName = new WCHAR[length];
				status = RegEnumValueW(hkBackingKey, i, lpwName, &length, nullptr, nullptr, nullptr, nullptr);

				if(status == ERROR_SUCCESS) {
					vSubKeys.push_back({ lpwName, length });
				}

				delete[] lpwName;
			}
		} else {
			SetLastError(status);
		}

		return vSubKeys;
	}

	std::wstring RegistryKey::GetNameWithoutHive() const {
		std::wstring ret = GetName();
		auto location = ret.find(L"HKEY_LOCAL_MACHINE");
		if (location != std::string::npos) {
			ret.replace(location, 19, L"");
		}
		location = ret.find(L"HKEY_USERS");
		if (location != std::string::npos) {
			ret.replace(location, 11, L"");
		}
		return ret;
	}

	std::wstring RegistryKey::GetName() const {
		if(!Exists()){
			SetLastError(ERROR_NOT_FOUND);
			return {};
		}

		// Taken largely from https://stackoverflow.com/questions/937044/determine-path-to-registry-key-from-hkey-handle-in-c
		std::wstring keyPath = {};
		if(hkBackingKey && Linker::NtQueryKey){
			DWORD size = 0;
			DWORD result = 0;
			result = Linker::NtQueryKey(hkBackingKey, 3, 0, 0, &size);
			if(result == ((NTSTATUS) 0xC0000023L)){
				size = size + sizeof(wchar_t);
				wchar_t* buffer = new wchar_t[size / sizeof(wchar_t)];
				if(buffer != NULL){
					result = Linker::NtQueryKey(hkBackingKey, 3, buffer, size, &size);
					if(result == 0){
						buffer[size / sizeof(wchar_t)] = L'\0';
						keyPath = std::wstring(buffer + 2);
					}
					delete[] buffer;
					auto location = keyPath.find(L"\\REGISTRY\\MACHINE");
					if(location != std::string::npos){
						keyPath.replace(location, 17, L"HKEY_LOCAL_MACHINE");
					}
					location = keyPath.find(L"\\REGISTRY\\USER");
					if(location != std::string::npos){
						keyPath.replace(location, 14, L"HKEY_USERS");
					}
				}
			}
		}
		return keyPath;
	}

	std::wstring RegistryKey::ToString() const {
		return GetName();
	}

	bool RegistryKey::operator==(const RegistryKey& key) const {
		return hkBackingKey == key.hkBackingKey;
	}

	bool RegistryKey::operator<(const RegistryKey& key) const {
		return hkBackingKey < key.hkBackingKey;
	}

	bool RegistryKey::RemoveValue(const std::wstring& wsValueName) const {

		UNICODE_STRING RegistryKeyName{
			static_cast<USHORT>(wsValueName.length() * 2),
			static_cast<USHORT>(wsValueName.length() * 2 + 2),
			const_cast<PWSTR>(wsValueName.c_str())
		};

		NTSTATUS status{ Linker::NtDeleteValueKey(hkBackingKey, &RegistryKeyName)};
		SetLastError(status);
		return NT_SUCCESS(status);
	}

	RegistryKey::operator HKEY() const {
		return hkBackingKey;
	}

	bool RegistryKey::DeleteSubkey(const std::wstring& name) const {
		if(!Exists()){
			return true;
		}

		if(!RegistryKey::CheckKeyExists(hkBackingKey, name, bWow64)){
			return true;
		}

		LSTATUS status = RegDeleteKeyExW(hkBackingKey, name.c_str(), bWow64 ? KEY_WOW64_32KEY : KEY_WOW64_64KEY, 0);
		if(status == ERROR_SUCCESS){
			return true;
		}

		SetLastError(status);

		return false;
	}
}

size_t std::hash<Registry::RegistryKey>::operator()(IN CONST Registry::RegistryKey& key) const{
	return reinterpret_cast<size_t>(static_cast<HKEY>(key));
}

```

`BLUESPAWN-win-client/src/util/configurations/RegistryValue.cpp`:

```cpp
#include "util/configurations/RegistryValue.h"
#include "util/configurations/Registry.h"

#include <memory>
#include <sstream>
#include <iomanip>

namespace Registry {

	RegistryValue::RegistryValue(const RegistryKey& key, const std::wstring& wValueName, std::wstring&& wData) :
		key{ key },
		wValueName{ wValueName },
		type{ RegistryType::REG_SZ_T },
		data{ std::forward<std::wstring>(wData) }{}

	RegistryValue::RegistryValue(const RegistryKey& key, const std::wstring& wValueName, DWORD&& dData) :
		key{ key },
		wValueName{ wValueName },
		type{ RegistryType::REG_DWORD_T },
		data{ std::forward<DWORD>(dData) }{}

	RegistryValue::RegistryValue(const RegistryKey& key, const std::wstring& wValueName, AllocationWrapper&& lpData) :
		key{ key },
		wValueName{ wValueName },
		type{ RegistryType::REG_BINARY_T },
		data{ std::forward<AllocationWrapper>(lpData) }{}

	RegistryValue::RegistryValue(const RegistryKey& key, const std::wstring& wValueName, std::vector<std::wstring>&& vData) :
		key{ key },
		wValueName{ wValueName },
		type{ RegistryType::REG_MULTI_SZ_T },
		data{ std::forward<std::vector<std::wstring>>(vData) }{}


	std::optional<RegistryValue> RegistryValue::Create(IN CONST RegistryKey& key, 
													   IN CONST std::wstring& wsValueName){
		if(key.ValueExists(wsValueName)){
			auto type{ key.GetValueType(wsValueName) };
			if(type == RegistryType::REG_DWORD_T){
				return RegistryValue{ key, wsValueName, *key.GetValue<DWORD>(wsValueName) };
			} else if(type == RegistryType::REG_MULTI_SZ_T){
				return RegistryValue{ key, wsValueName, *key.GetValue<std::vector<std::wstring>>(wsValueName) };
			} else if(type == RegistryType::REG_EXPAND_SZ_T || type == RegistryType::REG_SZ_T){
				return RegistryValue{ key, wsValueName, *key.GetValue<std::wstring>(wsValueName) };
			} else return RegistryValue{ key, wsValueName, key.GetRawValue(wsValueName) };
		}

		return std::nullopt;
	}

	RegistryType RegistryValue::GetType() const {
		return type;
	}

	std::wstring RegistryValue::GetPrintableName() const {
		std::wstringstream oss;
		for (int i = 0; i < wValueName.length(); i++) {
			if (wValueName[i] < 0x20 || wValueName[i] > 0x7F) {
				oss << L"\\x" << std::hex << std::setw(2) << std::setfill(L'0') << static_cast<int>(wValueName[i]);
			}
			else {
				oss << wValueName[i];
			}
		}
		return oss.str();
	}

	std::wstring RegistryValue::ToString() const {
		if(type == RegistryType::REG_SZ_T || type == RegistryType::REG_EXPAND_SZ_T)
			return std::get<std::wstring>(data);
		else if(type == RegistryType::REG_DWORD_T)
			return std::to_wstring(std::get<DWORD>(data));
		else if(type == RegistryType::REG_MULTI_SZ_T){
			std::wstring string = L"[\"";
			for(auto& str : std::get<std::vector<std::wstring>>(data)){
				string += str + L"\", \"";
			}
			return string.substr(0, string.length() - 3) + L"\"]";
		} else {
			auto& lpData = std::get<AllocationWrapper>(data);
			if(!lpData){
				return L"(null)";
			}

			std::wstring string = L"";
			for(auto i = 0; i < lpData.GetSize(); i++){
				wchar_t buf[3];
				wsprintf(buf, L"%02x", lpData[i]);
				string += buf;
				string += L" ";
			}
			return string;
		}
	}

	bool RegistryValue::operator==(const RegistryValue& value) const{
		return value.key == key && value.wValueName == wValueName && value.data == data;
	}

	bool RegistryValue::operator<(const RegistryValue& value) const{
		return value.key < key ||
			(value.key == key && value.wValueName < wValueName);
	}
}
```

`BLUESPAWN-win-client/src/util/eventlogs/EventLogItem.cpp`:

```cpp
#include "util/eventlogs/EventLogItem.h"

namespace EventLogs {

	std::wstring EventLogItem::GetProperty(std::wstring prop) const {
		std::wstring val;

		auto it = this->props.find(prop);
		if (it != this->props.end())
			val = it->second;

		return val;
	}
	std::unordered_map<std::wstring, std::wstring> EventLogItem::GetProperties() const {
		return this->props;
	}
	std::wstring EventLogItem::GetChannel() const {
		return this->channel;
	}
	std::wstring EventLogItem::GetTimeCreated() const {
		return this->timeCreated;
	}
	std::wstring EventLogItem::GetXML() const {
		return this->rawXML;
	}
	unsigned int EventLogItem::GetEventID() const {
		return this->eventID;
	}
	unsigned int EventLogItem::GetEventRecordID() const {
		return this->eventRecordID;
	}

	void EventLogItem::SetProperty(std::wstring& prop, std::wstring& value) {
		auto it = this->props.find(prop);
		if (it != this->props.end())
			this->props.erase(it);

		this->props.insert(std::make_pair(prop, value));
	}
	void EventLogItem::SetChannel(std::wstring& channel) {
		this->channel = channel;
	}
	void EventLogItem::SetTimeCreated(std::wstring& time) {
		this->timeCreated = time;
	}
	void EventLogItem::SetXML(std::wstring& xml) {
		this->rawXML = xml;
	}
	void EventLogItem::SetEventID(unsigned int id) {
		this->eventID = id;
	}
	void EventLogItem::SetEventRecordID(unsigned int id) {
		this->eventRecordID = id;
	}

}
```

`BLUESPAWN-win-client/src/util/eventlogs/EventLogs.cpp`:

```cpp
#include "util/eventlogs/EventLogs.h"

#include <string>

#include "util/StringUtils.h"
#include "util/Utils.h"
#include "util/log/Log.h"

const int SIZE_DATA = 4096;
const int ARRAY_SIZE = 10;

namespace EventLogs {

    /**
	 * The callback function directly called by event subscriptions.
	 * In turn it calls the EventSubscription::SubscriptionCallback of a specific class instance.
	 */
    DWORD WINAPI CallbackWrapper(EVT_SUBSCRIBE_NOTIFY_ACTION Action, PVOID UserContext, EVT_HANDLE Event) {
        return reinterpret_cast<EventSubscription*>(UserContext)->SubscriptionCallback(Action, Event);
    }

    std::optional<std::wstring> EventLogs::GetEventParam(const EventWrapper& hEvent, const std::wstring& param) {
        auto queryParam = param.c_str();
        EventWrapper hContext = EvtCreateRenderContext(1, &queryParam, EvtRenderContextValues);
        if(!hContext) {
            LOG_ERROR(L"EventLogs::GetEventParam: EvtCreateRenderContext failed with " +
                      std::to_wstring(GetLastError()));
            return std::nullopt;
        }

        DWORD dwBufferSize{};
        if(!EvtRender(hContext, hEvent, EvtRenderEventValues, dwBufferSize, nullptr, &dwBufferSize, nullptr)) {
            if(ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
                auto pRenderedValues = AllocationWrapper{ HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize),
                                                          dwBufferSize, AllocationWrapper::HEAP_ALLOC };
                if(pRenderedValues) {
                    if(EvtRender(hContext, hEvent, EvtRenderEventValues, dwBufferSize, pRenderedValues, &dwBufferSize,
                                 nullptr)) {
                        /*
						Table of variant members found here: https://docs.microsoft.com/en-us/windows/win32/api/winevt/ns-winevt-evt_variant
						Table of type values found here: https://docs.microsoft.com/en-us/windows/win32/api/winevt/ne-winevt-evt_variant_type
						*/
                        PEVT_VARIANT result = reinterpret_cast<PEVT_VARIANT>((LPVOID) pRenderedValues);
                        if(result->Type == EvtVarTypeString)
                            return std::wstring(result->StringVal);
                        else if(result->Type == EvtVarTypeFileTime) {
                            wchar_t ar[30];
                            _ui64tow(result->FileTimeVal, ar, 10);
                            return ar;
                        } else if(result->Type == EvtVarTypeUInt16) {
                            return std::to_wstring(result->UInt16Val);
                        } else if(result->Type == EvtVarTypeUInt32) {
                            return std::to_wstring(result->UInt32Val);
                        } else if(result->Type == EvtVarTypeUInt64) {
                            return std::to_wstring(result->UInt64Val);
                        } else if(result->Type == EvtVarTypeNull)
                            return L"NULL";
                        else {
                            return L"Unknown VARIANT: " + std::to_wstring(result->Type);
                        }
                    }
                }
            }
        }
        return std::nullopt;
    }

    std::optional<std::wstring> EventLogs::GetEventXML(const EventWrapper& hEvent) {
        DWORD dwBufferSize = 0;
        if(!EvtRender(NULL, hEvent, EvtRenderEventXml, dwBufferSize, nullptr, &dwBufferSize, nullptr)) {
            if(ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
                auto pRenderedContent = AllocationWrapper{ HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize),
                                                           dwBufferSize, AllocationWrapper::HEAP_ALLOC };
                if(pRenderedContent) {
                    if(EvtRender(NULL, hEvent, EvtRenderEventXml, dwBufferSize, pRenderedContent, &dwBufferSize,
                                 nullptr)) {
                        return reinterpret_cast<LPCWSTR>((LPVOID) pRenderedContent);
                    }
                }
            }
        }

        return std::nullopt;
    }

    // Enumerate all the events in the result set.
    std::vector<EventLogItem> EventLogs::ProcessResults(const EventWrapper& hResults,
                                                        const std::vector<XpathQuery>& filters) {
        EVT_HANDLE hEvents[ARRAY_SIZE];

        std::vector<EventLogItem> results;
        std::vector<std::wstring> params;
        for(auto query : filters) {
            if(!query.SearchesByValue()) {
                params.push_back(query.ToString());
            }
        }

        DWORD dwReturned{};
        while(EvtNext(hResults, ARRAY_SIZE, hEvents, INFINITE, 0, &dwReturned)) {
            for(DWORD i = 0; i < dwReturned; i++) {
                auto item = EventToEventLogItem(hEvents[i], params);
                if(item) {
                    results.push_back(*item);
                }

                EvtClose(hEvents[i]);
                hEvents[i] = NULL;
            }
        }

        for(unsigned i = 0; i < ARRAY_SIZE; i++) {
            if(hEvents[i]) {
                EvtClose(hEvents[i]);
            }
        }

        if(GetLastError() != ERROR_NO_MORE_ITEMS) {
            LOG_VERBOSE(1, "EventLogs::ProcessResults: EvtNext failed with " << GetLastError());
        }

        return results;
    }

    std::optional<EventLogItem> EventToEventLogItem(const EventWrapper& hEvent,
                                                    const std::vector<std::wstring>& params) {

        std::optional<std::wstring> eventIDStr, eventRecordIDStr, timeCreated, channel, rawXML;

        if(std::nullopt == (eventIDStr = GetEventParam(hEvent, L"Event/System/EventID")))
            return std::nullopt;
        if(std::nullopt == (eventRecordIDStr = GetEventParam(hEvent, L"Event/System/EventRecordID")))
            return std::nullopt;
        if(std::nullopt == (timeCreated = GetEventParam(hEvent, L"Event/System/TimeCreated/@SystemTime")))
            return std::nullopt;
        if(std::nullopt == (channel = GetEventParam(hEvent, L"Event/System/Channel")))
            return std::nullopt;
        if(std::nullopt == (rawXML = GetEventXML(hEvent)))
            return std::nullopt;

        EventLogItem pItem{};

        // Provide values for filtered parameters
        for(std::wstring key : params) {
            std::optional<std::wstring> val = GetEventParam(hEvent, key);
            if(!val) {
                return std::nullopt;
            }

            pItem.SetProperty(key, *val);
        }

        pItem.SetEventID(std::stoul(*eventIDStr));
        pItem.SetEventRecordID(std::stoul(*eventRecordIDStr));
        pItem.SetTimeCreated(*timeCreated);
        pItem.SetChannel(*channel);
        pItem.SetXML(*rawXML);

        return pItem;
    }

    std::vector<EventLogItem>
    EventLogs::QueryEvents(const std::wstring& channel, unsigned int id, const std::vector<XpathQuery>& filters) {
        std::vector<EventLogItem> items;

        auto query = std::wstring(L"Event/System[EventID=") + std::to_wstring(id) + std::wstring(L"]");
        for(auto param : filters)
            query += L" and " + param.ToString();

        EventWrapper hResults =
            EvtQuery(NULL, channel.c_str(), query.c_str(), EvtQueryChannelPath | EvtQueryReverseDirection);
        if(!hResults) {
            if(ERROR_EVT_CHANNEL_NOT_FOUND == GetLastError())
                LOG_WARNING("EventLogs::QueryEvents: Unable to find channel " << channel);
            else if(ERROR_EVT_INVALID_QUERY == GetLastError())
                LOG_ERROR(L"EventLogs::QueryEvents: The query " << query << L" is not valid.");
            else
                LOG_ERROR("EventLogs::QueryEvents: EvtQuery failed with " << SYSTEM_ERROR);
        } else {
            items = ProcessResults(hResults, filters);
        }

        return items;
    }

    std::vector<EventSubscription> subscriptions = {};

    std::optional<std::reference_wrapper<EventSubscription>>
    EventLogs::SubscribeToEvent(const std::wstring& pwsPath,
                                unsigned int id,
                                const std::function<void(EventLogItem)>& callback,
                                const std::vector<XpathQuery>& filters) {
        auto query = std::wstring(L"Event/System[EventID=") + std::to_wstring(id) + std::wstring(L"]");
        for(auto param : filters)
            query += L" and " + param.ToString();

        subscriptions.emplace_back(EventSubscription{ callback });
        auto& eventSub = subscriptions[subscriptions.size() - 1];

        EventWrapper hSubscription = EvtSubscribe(NULL, NULL, pwsPath.c_str(), query.c_str(), NULL,
                                                  &subscriptions[subscriptions.size() - 1], CallbackWrapper,
                                                  EvtSubscribeToFutureEvents);
        eventSub.setSubHandle(hSubscription);

        if(!hSubscription) {
            if(ERROR_EVT_CHANNEL_NOT_FOUND == GetLastError())
                LOG_WARNING("EventLogs::QueryEvents: Unable to find channel " << pwsPath);
            else if(ERROR_EVT_INVALID_QUERY == GetLastError())
                LOG_ERROR(L"EventLogs::SubscribeToEvent: query " << query << L" is not valid.");
            else
                LOG_ERROR("EventLogs::SubscribeToEvent: EvtSubscribe failed with " << GetLastError());

            return std::nullopt;
        }

        return eventSub;
    }

    bool IsChannelOpen(const std::wstring& channel) {
        PEVT_VARIANT pProperty = NULL;
        PEVT_VARIANT pTemp = NULL;
        DWORD dwBufferSize = 0;
        DWORD dwBufferUsed = 0;

        // Open the channel config
        EventWrapper hChannel{ EvtOpenChannelConfig(NULL, channel.c_str(), 0) };
        if(NULL == hChannel) {
            LOG_ERROR(L"EventLogs::IsChannelOpen: EvtOpenChannelConfig failed with " + std::to_wstring(GetLastError()) +
                      L" for channel " + channel);
            return false;
        }

        // Attempt to get the channel property
        if(!EvtGetChannelConfigProperty(hChannel, EvtChannelConfigEnabled, 0, dwBufferSize, pProperty, &dwBufferUsed)) {
            auto status{ GetLastError() };
            if(ERROR_INSUFFICIENT_BUFFER == status) {
                dwBufferSize = dwBufferUsed;
                pTemp = (PEVT_VARIANT) realloc(pProperty, dwBufferSize);

                if(pTemp) {
                    pProperty = pTemp;
                    pTemp = NULL;
                    EvtGetChannelConfigProperty(hChannel, EvtChannelConfigEnabled, 0, dwBufferSize, pProperty,
                                                &dwBufferUsed);
                } else {
                    if(pProperty)
                        free(pProperty);

                    LOG_ERROR(L"EventLogs::IsChannelOpen: realloc failed for channel " + channel);
                    return false;
                }
            }

            if(ERROR_SUCCESS != (status = GetLastError())) {
                LOG_ERROR(L"EventLogs::IsChannelOpen: EvtGetChannelConfigProperty failed with " +
                          std::to_wstring(GetLastError()) + L" for channel " + channel);
                return false;
            }
        }
        if(pProperty)
            free(pProperty);

        return pProperty->BooleanVal;
    }

    bool OpenChannel(const std::wstring& channel) {
        EVT_HANDLE hChannel = NULL;
        EVT_VARIANT ChannelProperty;
        DWORD dwBufferSize = sizeof(EVT_VARIANT);
        hChannel = EvtOpenChannelConfig(NULL, channel.c_str(), 0);
        if(NULL == hChannel) {
            LOG_ERROR(L"EventLogs::OpenChannel: EvtOpenChannelConfig failed with " + std::to_wstring(GetLastError()) +
                      L" for channel " + channel);
            return false;
        }
        RtlZeroMemory(&ChannelProperty, dwBufferSize);

        ChannelProperty.Type = EvtVarTypeBoolean;
        ChannelProperty.BooleanVal = TRUE;

        if(!EvtSetChannelConfigProperty(hChannel, EvtChannelConfigEnabled, 0, &ChannelProperty)) {
            LOG_ERROR(L"EventLogs::OpenChannel: EvtSetChannelConfigProperty failed with " +
                      std::to_wstring(GetLastError()) + L" for channel " + channel);
            return false;
        }
        if(!EvtSaveChannelConfig(hChannel, 0)) {
            LOG_ERROR(L"EventLogs::OpenChannel: EvtSaveChannelConfig failed with " + std::to_wstring(GetLastError()) +
                      L" for channel " + channel);
            return false;
        }

        return true;
    }

}   // namespace EventLogs

```

`BLUESPAWN-win-client/src/util/eventlogs/EventSubscription.cpp`:

```cpp
#include "util/eventlogs/EventSubscription.h"
#include "util/log/Log.h"
#include "util/eventlogs/EventLogs.h"

// The callback that receives the events that match the query criteria. 
DWORD WINAPI EventSubscription::SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, EVT_HANDLE hEvent) {
	DWORD status = ERROR_SUCCESS;

	if(action == EvtSubscribeActionDeliver){
		auto item = EventLogs::EventToEventLogItem(hEvent, {});
		if(!item){
			return GetLastError();
		}
		callback(*item);
	} else {
		LOG_ERROR(L"EventSubscription::SubscriptionCallback: Unknown action.");
	}

	return ERROR_SUCCESS;
}

EventSubscription::EventSubscription(std::function<void(EventLogs::EventLogItem)> callback) : callback(callback), hSubscription{ INVALID_HANDLE_VALUE } {}

void EventSubscription::setSubHandle(const EventLogs::EventWrapper& hSubscription) {
	this->hSubscription = hSubscription;
}
```

`BLUESPAWN-win-client/src/util/eventlogs/XpathQuery.cpp`:

```cpp
#pragma once

#include "util/eventlogs/XpathQuery.h"

namespace EventLogs {

	XpathQuery::XpathQuery(const std::wstring& path, const ParamList attributes, std::optional<std::wstring> value) :
		path(path), attributes(attributes), value(value) {
		this->query = generateQuery();
	}

	std::wstring XpathQuery::ToString() {
		return query;
	}

	bool XpathQuery::SearchesByValue() {
		return value.has_value();
	}

	std::wstring XpathQuery::generateQuery() {
		// Replace last '/' of the path with '[' unless there are attributes
		// and no value (aka, a query for the existance of an attribute)
		std::wstring query;

		if (value || attributes.size() == 0) {
			std::size_t found = path.find_last_of(L"/");
			query = path.substr(0, found) + L"[" + path.substr(found + 1);
		}
		else
			query = path;

		if (attributes.size() > 0) {
			query += L"[";

			// Add attributes seperated by ' and '
			auto it = attributes.begin();
			query += L"@" + it->first + L"=" + it->second;
			it++;
			for (; it != attributes.end(); it++)
				query += L" and @" + it->first + L"=" + it->second;

			query += L"]";
		}

		// Add the value if it exists
		if (value)
			query += L"=" + value.value();

		// Close the upper path if the last '/' of the path was
		// replaced with '['
		if (value || attributes.size() == 0)
			query += L"]";

		return query;
	}

}
```

`BLUESPAWN-win-client/src/util/filesystem/FileSystem.cpp`:

```cpp
#include "util/filesystem/FileSystem.h"

#include <Shlwapi.h>
#include <SoftPub.h>
#include <Wincrypt.h>
#include <fileapi.h>
#include <mscat.h>
#include <windows.h>

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#include "util/StringUtils.h"
#include "util/log/Log.h"
#include "util/permissions/permissions.h"
#include "util/wrappers.hpp"

#include "aclapi.h"

LINK_FUNCTION(NtCreateFile, ntdll.dll);

namespace FileSystem {
    bool CheckFileExists(const std::wstring& path) {
        auto attribs = GetFileAttributesW(path.c_str());
        if(INVALID_FILE_ATTRIBUTES == attribs && GetLastError() == ERROR_FILE_NOT_FOUND) {
            LOG_VERBOSE(3, "File " << path << " does not exist.");
            return false;
        }

        if(attribs & FILE_ATTRIBUTE_DIRECTORY) {
            LOG_VERBOSE(3, "File " << path << " is a directory.");
            return false;
        }
        LOG_VERBOSE(3, "File " << path << " exists");
        return true;
    }

    std::optional<std::wstring> SearchPathExecutable(const std::wstring& name) {
        std::wstring fullname = ExpandEnvStringsW(name);

        auto size = SearchPathW(nullptr, fullname.c_str(), L".exe", 0, nullptr, nullptr);
        if(!size) {
            return std::nullopt;
        }

        std::vector<WCHAR> buffer(static_cast<size_t>(size) + 1);
        WCHAR* filename{};
        if(!SearchPathW(nullptr, fullname.c_str(), L".exe", size + 1, buffer.data(), &filename)) {
            return std::nullopt;
        }

        return buffer.data();
    }

    DWORD File::SetFilePointer(DWORD64 val) const {
        //Calculate the offset into format needed for SetFilePointer
        long lowerMask = 0xFFFFFFFF;
        DWORD64 upperMask = static_cast<DWORD64>(0xFFFFFFFF) << 32;
        auto lowerVal = static_cast<DWORD>(val & lowerMask);
        auto upperVal = static_cast<DWORD>((val & upperMask) >> 32);
        return ::SetFilePointer(hFile, lowerVal, reinterpret_cast<PLONG>(&upperVal), 0);
    }

    std::vector<std::wstring> GetCatalog(const HandleWrapper& hFile) {
        if(!hFile) {
            return {};
        }

        HCATADMIN admin{};
        GUID gAction = DRIVER_ACTION_VERIFY;
        if(!CryptCATAdminAcquireContext(&admin, &gAction, 0)) {
            LOG_ERROR("Error acquiring catalog admin context " << SYSTEM_ERROR);
            return {};
        }
        GenericWrapper<HCATADMIN> hCatAdmin{ admin, [](auto val) { CryptCATAdminReleaseContext(&val, 0); },
                                             INVALID_HANDLE_VALUE };

        DWORD dwHashLength{ 0 };
        if(!CryptCATAdminCalcHashFromFileHandle(hFile, &dwHashLength, NULL, 0)) {
            LOG_ERROR("Error getting hash size " << SYSTEM_ERROR);
            return {};
        }

        std::vector<BYTE> pbHash(dwHashLength);
        if(!CryptCATAdminCalcHashFromFileHandle(hFile, &dwHashLength, pbHash.data(), 0)) {
            LOG_VERBOSE(2, "Error getting file hash for " << static_cast<HANDLE>(hFile) << " " << SYSTEM_ERROR);
            return {};
        }

        std::vector<std::wstring> catalogfiles{};
        GenericWrapper<HCATINFO> hCatInfo{
            CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash.data(), dwHashLength, 0, nullptr),
            [&hCatAdmin](auto val) { CryptCATAdminReleaseCatalogContext(&hCatAdmin, &val, 0); }, INVALID_HANDLE_VALUE
        };
        while(hCatInfo) {
            CATALOG_INFO ciCatalogInfo = {};
            ciCatalogInfo.cbStruct = sizeof(ciCatalogInfo);

            if(!CryptCATCatalogInfoFromContext(hCatInfo, &ciCatalogInfo, 0)) {
                LOG_ERROR("Couldn't get catalog info for catalog containing hash of file");
                break;
            }

            LOG_VERBOSE(3, "Hash for file found in catalog " << ciCatalogInfo.wszCatalogFile);
            catalogfiles.emplace_back(ciCatalogInfo.wszCatalogFile);
            hCatInfo.reassign(CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash.data(), dwHashLength, 0, &hCatInfo));
        }

        return catalogfiles;
    }

    bool File::GetFileInSystemCatalogs() const { return GetCatalog(hFile).size(); }

    std::optional<std::wstring> File::CalculateHashType(HashType hashType) const {
        // Adapted largely from https://stackoverflow.com/a/13259720/4815264
        auto data{ Read() };
        if(!data) {
            LOG_VERBOSE(2, "File " << FilePath << " cannot be hashed.");
        }

        HCRYPTPROV prov{};
        if(!CryptAcquireContextW(&prov, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
            LOG_ERROR("Unable to create cryptography provider");
            return std::nullopt;
        }
        GenericWrapper<HCRYPTPROV> hProv{ prov, std::bind(CryptReleaseContext, std::placeholders::_1, 0) };

        bool success{ false };
        HCRYPTPROV hash{};
        switch(hashType) {
        case HashType::SHA1_HASH: success = CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hash); break;
        case HashType::MD5_HASH: success = CryptCreateHash(hProv, CALG_MD5, 0, 0, &hash); break;
        case HashType::SHA256_HASH: success = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hash); break;
        }

        GenericWrapper<HCRYPTPROV> hHash{ hash, CryptDestroyHash };

        if(!success) {
            LOG_ERROR("Unable to create hash providers");
            return std::nullopt;
        }

        if(!CryptHashData(hHash, data.GetAsPointer<const BYTE>(), data.GetSize(), 0)) {
            LOG_ERROR("Failed to hash file " << FilePath << " (" << SYSTEM_ERROR << ")");
            return std::nullopt;
        }

        DWORD cbHashSize = 0, dwCount = sizeof(DWORD);
        if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*) &cbHashSize, &dwCount, 0)) {
            LOG_ERROR("Failed to read hash size for " << FilePath << " (" << SYSTEM_ERROR << ")");
            return std::nullopt;
        }

        std::vector<BYTE> buffer(cbHashSize);
        if(!CryptGetHashParam(hHash, HP_HASHVAL, reinterpret_cast<BYTE*>(buffer.data()), &cbHashSize, 0)) {
            LOG_ERROR("Failed to read hash for " << FilePath << " (" << SYSTEM_ERROR << ")");
            return std::nullopt;
        }

        std::wstringstream oss{};
        for(auto& byte : buffer) {
            oss.fill('0');
            oss.width(2);
            oss << std::hex << static_cast<const int>(byte);
        }

        return oss.str();
    }

    File::File(IN const std::wstring& path) : hFile{ nullptr } {
        if(!path.length()) {
            bFileExists = false;
            bWriteAccess = false;
            bReadAccess = false;
            return;
        }
        FilePath = ExpandEnvStringsW(path);
        LOG_VERBOSE(2, "Attempting to open file: " << FilePath << ".");
        if(FilePath.at(0) == L'\\') {
            UNICODE_STRING UnicodeName{ static_cast<USHORT>(FilePath.length() * 2),
                                        static_cast<USHORT>(FilePath.length() * 2),
                                        const_cast<PWCHAR>(FilePath.c_str()) };
            OBJECT_ATTRIBUTES attributes{};
            IO_STATUS_BLOCK IoStatus{};
            InitializeObjectAttributes(&attributes, &UnicodeName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, nullptr,
                                       nullptr);
            NTSTATUS Status{ Linker::NtCreateFile(
                &hFile, GENERIC_READ | GENERIC_WRITE, &attributes, &IoStatus, nullptr, FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN, FILE_SEQUENTIAL_ONLY, nullptr, 0) };
            if(NT_SUCCESS(Status)) {
                this->hFile = hFile;
                bFileExists = true;
                bWriteAccess = true;
                bReadAccess = true;
            } else if(Status == 0xC0000022 || Status == 0xC0000043) {   //STATUS_ACCESS_DENIED, STATUS_SHARING_VIOLATION
                Status = Linker::NtCreateFile(&hFile, GENERIC_READ, &attributes, &IoStatus, nullptr,
                                              FILE_ATTRIBUTE_NORMAL,
                                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN,
                                              FILE_SEQUENTIAL_ONLY, nullptr, 0);
                if(NT_SUCCESS(Status)) {
                    this->hFile = hFile;
                    bFileExists = true;
                    bWriteAccess = false;
                    bReadAccess = true;
                } else {
                    LOG_ERROR("Unable to create a file handle for file " << FilePath << " (NTSTATUS " << Status << ")");
                    bFileExists = true;
                    bWriteAccess = false;
                    bReadAccess = false;
                }
            } else {
                LOG_VERBOSE(2, "Couldn't open file since file doesn't exist (" << FilePath << ").");
                bFileExists = false;
                bWriteAccess = false;
                bReadAccess = false;
            }
        } else {
            hFile = CreateFileW(FilePath.c_str(), GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, nullptr, OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, nullptr);
            if(!hFile && GetLastError() == ERROR_FILE_NOT_FOUND) {
                LOG_VERBOSE(2, "Couldn't open file, file doesn't exist " << FilePath << ".");
                bFileExists = false;
                bWriteAccess = false;
                bReadAccess = false;
            } else if(!hFile && (GetLastError() == ERROR_ACCESS_DENIED || GetLastError() == ERROR_SHARING_VIOLATION)) {
                bWriteAccess = false;
                hFile = CreateFileW(FilePath.c_str(), GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, nullptr, OPEN_EXISTING,
                                    FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, nullptr);
                if(!hFile && GetLastError() == ERROR_SHARING_VIOLATION) {
                    LOG_VERBOSE(2, "Couldn't open file, sharing violation " << FilePath << ".");
                    bFileExists = true;
                    bReadAccess = false;
                } else if(!hFile && GetLastError() == ERROR_ACCESS_DENIED) {
                    LOG_VERBOSE(2, "Couldn't open file, Access Denied" << FilePath << ".");
                    bFileExists = true;
                    bReadAccess = false;
                } else if(GetLastError() != ERROR_SUCCESS) {
                    LOG_VERBOSE(2, "Couldn't open file " << FilePath << ". " << SYSTEM_ERROR);
                    bFileExists = true;
                    bReadAccess = false;
                } else {
                    LOG_VERBOSE(2, "File " << FilePath << " opened.");
                    bFileExists = true;
                    bReadAccess = true;
                }
            } else if(ERROR_SUCCESS == GetLastError()) {
                LOG_VERBOSE(2, "File " << FilePath << " opened.");
                bFileExists = true;
                bWriteAccess = true;
                bReadAccess = true;
            } else {
                LOG_VERBOSE(2, "File " << FilePath << " failed to open with error " << GetLastError());
                bFileExists = false;
                bWriteAccess = false;
                bReadAccess = false;
            }
        }
        Attribs.extension = PathFindExtensionW(FilePath.c_str());
    }

    std::wstring File::GetFilePath() const { return FilePath; }

    FileAttribs File::GetFileAttribs() const { return Attribs; }

    bool File::GetFileExists() const { return bFileExists; }

    bool File::HasWriteAccess() const { return bWriteAccess; }

    bool File::HasReadAccess() const { return bReadAccess; }

    bool File::Write(IN const LPCVOID value,
                     IN const long offset,
                     IN const unsigned long length,
                     IN const bool truncate OPTIONAL,
                     IN const bool insert OPTIONAL) const {
        SCOPE_LOCK(SetFilePointer(0), ResetFilePointer);
        LOG_VERBOSE(2, "Writing to file " << FilePath << " at " << offset << ". Insert = " << insert);

        DWORD dwBytesIO{};

        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't write to file " << FilePath << ". File doesn't exist");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return false;
        }

        if(!bWriteAccess) {
            LOG_VERBOSE(2, "Can't write to file " << FilePath << ". Insufficient permissions.");
            SetLastError(ERROR_ACCESS_DENIED);
            return false;
        }

        //Insert value into file at specified offset
        if(insert && !truncate) {
            DWORD64 dwFileSize = GetFileSize();
            for(DWORD64 dwCopyOffset = 0; dwCopyOffset < length; dwCopyOffset += min(1 << 20, length - dwCopyOffset)) {
                DWORD dwCopySize = min(1 << 20, length - dwCopyOffset);
                AllocationWrapper buffer = { new char[dwCopySize], dwCopySize, AllocationWrapper::CPP_ARRAY_ALLOC };
                if(SetFilePointer(dwFileSize - dwCopyOffset - dwCopySize) == INVALID_SET_FILE_POINTER) {
                    LOG_ERROR("Can't set file pointer to " << offset << " in file " << FilePath << ".");
                    return false;
                }
                if(!ReadFile(hFile, buffer, dwCopySize, &dwBytesIO, nullptr)) {
                    LOG_ERROR("Unable to read " << FilePath << " at offset " << dwFileSize - dwCopyOffset - dwCopySize
                                                << " " << SYSTEM_ERROR);
                    return false;
                }
                if(SetFilePointer(dwFileSize - dwCopyOffset) == INVALID_SET_FILE_POINTER) {
                    LOG_ERROR("Can't set file pointer to " << offset << " in file " << FilePath << ".");
                    return false;
                }
                if(!WriteFile(hFile, buffer, dwCopySize, &dwBytesIO, nullptr)) {
                    LOG_ERROR("Unable to write to " << FilePath << " at offset " << dwFileSize - dwCopyOffset << " "
                                                    << SYSTEM_ERROR);
                    return false;
                }
            }
        }
        //Write value over file at specified offset
        if(SetFilePointer(offset) == INVALID_SET_FILE_POINTER) {
            LOG_ERROR("Can't set file pointer to " << offset << " in file " << FilePath << ".");
            return false;
        }

        if(!WriteFile(hFile, value, length, &dwBytesIO, nullptr)) {
            LOG_ERROR("Failed to write to " << FilePath << " at offset " << offset << " with " << SYSTEM_ERROR);
            return false;
        }

        if(truncate) {
            if(!SetEndOfFile(hFile)) {
                LOG_ERROR("Couldn't truncate file " << FilePath);
                return false;
            }
        }
        LOG_VERBOSE(1, "Successfule wrote to " << FilePath << "at offset" << offset);
        return true;
    }

    bool File::Read(OUT LPVOID buffer,
                    IN const unsigned long amount OPTIONAL,
                    IN const long offset OPTIONAL,
                    OUT PDWORD amountRead OPTIONAL) const {
        SCOPE_LOCK(SetFilePointer(0), ResetFilePointer);
        LOG_VERBOSE(2, "Attempting to read " << amount << " bytes from " << FilePath << " at offset " << offset);
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't read from " << FilePath << ". File doesn't exist.");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return false;
        }

        if(!bReadAccess) {
            LOG_VERBOSE(2, "Can't read from " << FilePath << ". Insufficient permissions.");
            SetLastError(ERROR_ACCESS_DENIED);
            return false;
        }

        if(SetFilePointer(offset) == INVALID_SET_FILE_POINTER) {
            LOG_ERROR("Can't set file pointer to " << offset << " in file " << FilePath << ".");
            return false;
        }

        DWORD dwBytesRead{};
        if(!amountRead) {
            amountRead = &dwBytesRead;
        }

        if(!ReadFile(hFile, buffer, amount, amountRead, NULL)) {
            LOG_ERROR("Failed to read from " << FilePath << " at offset " << offset << " with error "
                                             << GetLastError());
            return false;
        }
        LOG_VERBOSE(1, "Successfully wrote " << amount << " bytes to " << FilePath);
        return true;
    }

    AllocationWrapper
    File::Read(__in_opt unsigned long amount, __in_opt long offset, __out_opt PDWORD amountRead) const {
        if(amount == -1) {
            amount = GetFileSize();
        }
        AllocationWrapper memory = { HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, amount + 1), amount + 1,
                                     AllocationWrapper::HEAP_ALLOC };
        bool success = Read(memory, amount, offset, amountRead);
        return success ? memory : AllocationWrapper{ nullptr, 0 };
    }

    bool File::MatchesAttributes(IN const FileSearchAttribs& searchAttribs) const {
        if(searchAttribs.extensions.size() > 0) {
            std::wstring ext = ToLowerCaseW(GetFileAttribs().extension);
            if(std::count(searchAttribs.extensions.begin(), searchAttribs.extensions.end(), ext) == 0) {
                return false;
            }
        }

        return true;
    }

    bool File::GetFileSigned() const {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't check file signature for " << FilePath << ". File doesn't exist.");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return false;
        }
        if(!bReadAccess) {
            LOG_VERBOSE(2, "Can't check file signature for " << FilePath << ". Insufficient permissions.");
            SetLastError(ERROR_ACCESS_DENIED);
            return false;
        }
        WINTRUST_FILE_INFO FileData{};
        FileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
        FileData.pcwszFilePath = FilePath.c_str();
        FileData.hFile = hFile;
        FileData.pgKnownSubject = NULL;

        GUID verification = WINTRUST_ACTION_GENERIC_VERIFY_V2;

        WINTRUST_DATA WinTrustData{};

        WinTrustData.cbStruct = sizeof(WinTrustData);
        WinTrustData.pPolicyCallbackData = NULL;
        WinTrustData.pSIPClientData = NULL;
        WinTrustData.dwUIChoice = WTD_UI_NONE;
        WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
        WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
        WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;
        WinTrustData.hWVTStateData = NULL;
        WinTrustData.pwszURLReference = NULL;
        WinTrustData.dwUIContext = 0;
        WinTrustData.pFile = &FileData;

        LONG result = WinVerifyTrust((HWND) INVALID_HANDLE_VALUE, &verification, &WinTrustData);
        WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrust(NULL, &verification, &WinTrustData);
        if(result == ERROR_SUCCESS) {
            LOG_VERBOSE(1, FilePath << " is signed.");
            return true;
        } else {
            //Verify signature in system catalog
            bool bInCatalog = File::GetFileInSystemCatalogs();
            if(bInCatalog) {
                LOG_VERBOSE(1, FilePath << " signed in system catalogs.");
                return true;
            }
        }
        LOG_VERBOSE(1, FilePath << " not signed or located in system catalogs.");
        return false;
    }

    std::optional<std::wstring> File::GetCertificateIssuer() const {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't check file signature for " << FilePath << ". File doesn't exist.");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return std::nullopt;
        }

        if(!bReadAccess) {
            LOG_VERBOSE(2, "Can't check file signature for " << FilePath << ". Insufficient permissions.");
            SetLastError(ERROR_ACCESS_DENIED);
            return std::nullopt;
        }

        if(!GetFileSigned()) {
            return std::nullopt;
        }

        if(File::GetFileInSystemCatalogs()) {
            auto catalogs{ GetCatalog(hFile) };
            if(catalogs.size()) {
                return FileSystem::File{ catalogs[0] }.GetCertificateIssuer();
            } else {
                LOG_ERROR("Unable to get the catalog for " << FilePath << ": " << SYSTEM_ERROR);
            }
        } else {
            DWORD dwEncoding{};
            DWORD dwContentType{};
            DWORD dwFormatType{};
            HCERTSTORE store;
            HCRYPTMSG msg;
            auto status{ CryptQueryObject(CERT_QUERY_OBJECT_FILE, FilePath.c_str(),
                                          CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0,
                                          &dwEncoding, &dwContentType, &dwFormatType, &store, &msg, nullptr) };
            if(!status) {
                LOG_ERROR("Failed to query signature for " << FilePath << ": " << SYSTEM_ERROR);
                return std::nullopt;
            }
            GenericWrapper<HCERTSTORE> hStore{ store, [](HCERTSTORE store) { CertCloseStore(store, 0); },
                                               INVALID_HANDLE_VALUE };
            GenericWrapper<HCRYPTMSG> hMsg{ msg, CryptMsgClose, INVALID_HANDLE_VALUE };

            DWORD dwSignerInfoSize{};
            status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, nullptr, &dwSignerInfoSize);
            if(!status) {
                LOG_ERROR("Failed to query signer information size for " << FilePath << ": " << SYSTEM_ERROR);
                return std::nullopt;
            }

            std::vector<CHAR> info(dwSignerInfoSize);
            status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, info.data(), &dwSignerInfoSize);
            if(!status) {
                LOG_ERROR("Failed to query signer information for " << FilePath << ": " << SYSTEM_ERROR);
                return std::nullopt;
            }

            auto signer{ reinterpret_cast<PCMSG_SIGNER_INFO>(info.data())->Issuer };
            DWORD dwSize = CertNameToStrW(X509_ASN_ENCODING, &signer, CERT_SIMPLE_NAME_STR, nullptr, 0);

            std::vector<WCHAR> buffer(dwSize);
            CertNameToStrW(X509_ASN_ENCODING, &signer, CERT_SIMPLE_NAME_STR, buffer.data(), dwSize);

            return std::wstring{ buffer.data(), dwSize };
        }

        return std::nullopt;
    }

    bool File::IsMicrosoftSigned() const {
        auto issuer{ GetCertificateIssuer() };
        return issuer && ToLowerCaseW(*issuer).find(L"microsoft") != std::wstring::npos;
    }

    std::optional<std::wstring> File::GetMD5Hash() const {
        LOG_VERBOSE(3, "Attempting to get MD5 hash of " << FilePath);
        return CalculateHashType(HashType::MD5_HASH);
    }

    std::optional<std::wstring> File::GetSHA1Hash() const {
        LOG_VERBOSE(3, "Attempting to get SHA1 hash of " << FilePath);
        return CalculateHashType(HashType::SHA1_HASH);
    }

    std::optional<std::wstring> File::GetSHA256Hash() const {
        LOG_VERBOSE(3, "Attempting to get SHA256 hash of " << FilePath);
        return CalculateHashType(HashType::SHA256_HASH);
    }

    bool File::Create() {
        LOG_VERBOSE(1, "Attempting to create file: " << FilePath);
        if(bFileExists) {
            LOG_ERROR("Can't create " << FilePath << ". File already exists.");
            return false;
        }
        hFile = CreateFileW(FilePath.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW,
                            FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, NULL);
        if(INVALID_HANDLE_VALUE == hFile) {
            LOG_ERROR("Error creating file " << FilePath << ". " << SYSTEM_ERROR);
            bFileExists = false;
            return false;
        }
        LOG_VERBOSE(1, FilePath << " successfully created.");
        bFileExists = true;
        bReadAccess = true;
        bWriteAccess = true;
        return true;
    }

    bool File::Delete() {
        LOG_VERBOSE(1, "Attempting to delete file " << FilePath);
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't delete file " << FilePath << ". File doesn't exist");
            return false;
        }
        CloseHandle(hFile);
        if(!DeleteFileW(FilePath.c_str())) {
            LOG_ERROR("Deleting file " << FilePath << " failed with " << SYSTEM_ERROR);
            hFile = CreateFileW(FilePath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW,
                                FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, NULL);
            if(INVALID_HANDLE_VALUE == hFile) {
                DWORD dwStatus = GetLastError();
                LOG_ERROR("Couldn't reopen " << FilePath << ". Error = " << dwStatus);
                bFileExists = false;
                return false;
            }
            bFileExists = true;
            return false;
        }
        LOG_VERBOSE(1, FilePath << "deleted.");
        bFileExists = false;
        return true;
    }

    bool FileSystem::File::ChangeFileLength(IN const long length) const {
        SCOPE_LOCK(SetFilePointer(0), ResetFilePointer);
        if(bFileExists) {
            LOG_VERBOSE(2, "Attempting to change length of " << FilePath << " to " << length);

            if(!SetFilePointer(length)) {
                LOG_ERROR("Couldn't change file pointer to " << length << " in file " << FilePath);
                return false;
            }

            if(!SetEndOfFile(hFile)) {
                LOG_ERROR("Couldn't change the length of file " << FilePath);
                return false;
            }
            LOG_VERBOSE(2, "Changed length of " << FilePath << " to " << length);
            return true;
        } else
            return false;
    }

    DWORD64 File::GetFileSize() const {
        DWORD high = {};
        auto size = ::GetFileSize(hFile, &high);
        return (static_cast<DWORD64>(high) << 32) + size;
    }

    std::wstring File::ToString() const { return FilePath; }

    std::optional<Permissions::Owner> File::GetFileOwner() const {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't get owner of nonexistent file " << FilePath);
            return std::nullopt;
        }
        PSID psOwnerSID = NULL;
        PISECURITY_DESCRIPTOR pDesc = NULL;
        if(GetSecurityInfo(hFile, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &psOwnerSID, nullptr, nullptr, nullptr,
                           reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pDesc)) != ERROR_SUCCESS) {
            LOG_ERROR("Error getting file owner for file " << FilePath << ". " << SYSTEM_ERROR);
            return std::nullopt;
        }
        pDesc->Owner = psOwnerSID;

        Permissions::SecurityDescriptor secDesc(pDesc);
        return Permissions::Owner(secDesc);
    }

    bool File::SetFileOwner(const Permissions::Owner& owner) {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't get owner of nonexistent file " << FilePath);
            SetLastError(ERROR_FILE_NOT_FOUND);
            return false;
        }
        if(!this->bWriteAccess) {
            LOG_WARNING("Can't write owner of file " << FilePath << ". Lack permissions");
            SetLastError(ERROR_ACCESS_DENIED);
            return false;
        }
        if(SetSecurityInfo(hFile, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, owner.GetSID(), nullptr, nullptr,
                           nullptr) != ERROR_SUCCESS) {
            LOG_ERROR("Error setting the file owner for file " << FilePath << " to " << owner << ". " << SYSTEM_ERROR);
            return false;
        }
        LOG_VERBOSE(3, "Set the owner for file " << FilePath << " to " << owner << ".");
        return true;
    }

    ACCESS_MASK File::GetAccessPermissions(const Permissions::Owner& owner) {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't get permissions of nonexistent file " << FilePath);
            SetLastError(ERROR_FILE_NOT_FOUND);
            return 0;
        }
        PACL paDACL = NULL;
        PISECURITY_DESCRIPTOR pDesc = NULL;
        if(GetSecurityInfo(hFile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, nullptr, nullptr, &paDACL, nullptr,
                           reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pDesc)) != ERROR_SUCCESS) {
            LOG_ERROR("Error getting permissions on file " << FilePath << " for owner " << owner << ". "
                                                           << SYSTEM_ERROR);
            return 0;
        }

        //Correct positional memory of the ACL is weird and doesn't naturally work with the SecurityDescriptor class.
        //This gets the right data to the right place
        Permissions::SecurityDescriptor secDesc = Permissions::SecurityDescriptor::CreateDACL(paDACL->AclSize);
        memcpy(secDesc.GetDACL(), paDACL, paDACL->AclSize);
        LocalFree(pDesc);
        return Permissions::GetOwnerRightsFromACL(owner, secDesc);
    }

    ACCESS_MASK File::GetEveryonePermissions() {
        Permissions::Owner everyone(L"Everyone");
        return this->GetAccessPermissions(everyone);
    }

    bool File::TakeOwnership() {
        std::optional<Permissions::Owner> BluespawnOwner = Permissions::GetProcessOwner();
        if(BluespawnOwner == std::nullopt) {
            return false;
        }
        return this->SetFileOwner(*BluespawnOwner);
    }

    bool File::GrantPermissions(const Permissions::Owner& owner, const ACCESS_MASK& amAccess) {
        return Permissions::UpdateObjectACL(FilePath, SE_FILE_OBJECT, owner, amAccess);
    }

    bool File::DenyPermissions(const Permissions::Owner& owner, const ACCESS_MASK& amAccess) {
        return Permissions::UpdateObjectACL(FilePath, SE_FILE_OBJECT, owner, amAccess, true);
    }

    bool File::Quarantine() {
        if(!bFileExists) {
            LOG_VERBOSE(2, "Can't quarantine file " << FilePath << ". File doesn't exist");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return false;
        }
        ACCESS_MASK amEveryoneDeniedAccess{ 0 };
        Permissions::AccessAddAll(amEveryoneDeniedAccess);
        return DenyPermissions(Permissions::Owner(L"Everyone"), amEveryoneDeniedAccess);
    }

    std::optional<FILETIME> File::GetCreationTime() const {
        if(!bFileExists || !bReadAccess) {
            LOG_VERBOSE(2, "Can't get creation time of " << FilePath << ", file doesn't exist or no read access");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return std::nullopt;
        }
        FILETIME fReturnInfo;
        if(GetFileTime(hFile, &fReturnInfo, nullptr, nullptr)) {
            return fReturnInfo;
        } else {
            LOG_ERROR("Error getting creation time of " << FilePath << ". (Error: " << GetLastError() << ")");
            return std::nullopt;
        }
    }

    std::optional<FILETIME> File::GetModifiedTime() const {
        if(!bFileExists || !bReadAccess) {
            LOG_VERBOSE(2, "Can't get last modified time of " << FilePath << ", file doesn't exist or no read access");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return std::nullopt;
        }
        FILETIME fReturnInfo;
        if(GetFileTime(hFile, nullptr, nullptr, &fReturnInfo)) {
            return fReturnInfo;
        } else {
            LOG_ERROR("Error getting last modified time of " << FilePath << ". " << SYSTEM_ERROR);
            return std::nullopt;
        }
    }

    std::optional<FILETIME> File::GetAccessTime() const {
        if(!bFileExists || !bReadAccess) {
            LOG_VERBOSE(2, "Can't get last access time of " << FilePath << ", file doesn't exist or no read access");
            SetLastError(ERROR_FILE_NOT_FOUND);
            return std::nullopt;
        }
        FILETIME fReturnInfo;
        if(GetFileTime(hFile, nullptr, &fReturnInfo, nullptr)) {
            return fReturnInfo;
        } else {
            LOG_ERROR("Error getting last access time of " << FilePath << ". " << SYSTEM_ERROR);
            return std::nullopt;
        }
    }

    Folder::Folder(const std::wstring& path) : hCurFile{ nullptr } {
        FolderPath = ExpandEnvStringsW(path);
        std::wstring searchName = FolderPath;
        searchName += L"\\*";
        bFolderExists = true;
        bFolderWrite = false;
        auto f = FindFirstFileW(searchName.c_str(), &ffd);
        hCurFile = { f };
        if(hCurFile == INVALID_HANDLE_VALUE) {
            LOG_VERBOSE(2, "Couldn't find folder " << FolderPath);
            bFolderExists = false;
        }
        else{
            if(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                bIsFile = false;
                PSECURITY_DESCRIPTOR pDesc{ nullptr };
                PACL paDACL{ NULL };
                auto status = GetNamedSecurityInfoW(reinterpret_cast<LPCWSTR>(FolderPath.c_str()), SE_FILE_OBJECT,
                                                    DACL_SECURITY_INFORMATION, nullptr, nullptr, &paDACL, nullptr, &pDesc);
                if(status == ERROR_SUCCESS){
                    auto owner = Permissions::GetProcessOwner();
                    Permissions::SecurityDescriptor secDesc = Permissions::SecurityDescriptor::CreateDACL(paDACL->AclSize);
                    memcpy(secDesc.GetDACL(), paDACL, paDACL->AclSize);
                    LocalFree(pDesc);
                    ACCESS_MASK mask = Permissions::GetOwnerRightsFromACL(owner.value(), secDesc);
                    if(Permissions::AccessIncludesWrite(mask)){
                        bFolderWrite = true;
                    }
                }
            } else{
                bIsFile = true;
            }
        }
    }

    std::wstring Folder::GetFolderPath() const { return FolderPath; }

    bool Folder::MoveToNextFile() {
        if(FindNextFileW(hCurFile, &ffd) != 0) {
            if(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                bIsFile = false;
            } else {
                bIsFile = true;
            }
            return true;
        }
        return false;
    }

    bool Folder::MoveToBeginning() {
        std::wstring searchName = FolderPath;
        searchName += L"\\*";
        hCurFile = FindFirstFileW(searchName.c_str(), &ffd);
        if(hCurFile == INVALID_HANDLE_VALUE) {
            LOG_VERBOSE(3, "Cannot move to beginning of nonexistent folder " << FolderPath);
            return false;
        }
        if(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            bIsFile = false;
        } else {
            bIsFile = true;
        }
        return true;
    }

    bool Folder::GetFolderExists() const { return bFolderExists; }

    bool Folder::GetCurIsFile() const { return bIsFile; }

    bool Folder::GetFolderWrite() const { return bFolderWrite; }

    std::optional<File> Folder::Open() const {
        if(bIsFile) {
            std::wstring fileName(ffd.cFileName);
            std::wstring filePath(FolderPath);
            filePath += std::wstring(L"\\") + fileName;
            std::wstring out = filePath.c_str();
            File file = FileSystem::File(out);
            if(file.GetFileExists()) {
                return std::optional<File>{ file };
            }
        }
        return std::nullopt;
    }

    std::optional<Folder> Folder::EnterDir() {
        if(!bIsFile) {
            std::wstring folderName = FolderPath;
            folderName += L"\\";
            folderName += ffd.cFileName;
            Folder folder = Folder(folderName.c_str());
            if(folder.GetFolderExists())
                return folder;
        }
        return std::nullopt;
    }

    std::optional<File> Folder::AddFile(IN const std::wstring& fileName) const {
        std::wstring filePath = FolderPath;
        std::wstring fName = fileName;
        filePath += L"\\" + fName;
        File file = File(filePath.c_str());
        if(file.GetFileExists()) {
            return file;
        }
        if(file.Create()) {
            return file;
        }
        return std::nullopt;
    }

    bool FileSystem::Folder::RemoveFile() const {
        if(GetCurIsFile()) {
            std::optional<File> f = Open();
            if(f && f->GetFileExists()) {
                if(f->Delete()) {
                    return true;
                }
            }
        }
        return false;
    }

    std::vector<File> Folder::GetFiles(__in_opt std::optional<FileSearchAttribs> attribs, __in_opt int recurDepth) {
        if(MoveToBeginning() == 0) {
            LOG_VERBOSE(2, "Couldn't iterate subfolders of nonexistent folder " << FolderPath);
            return std::vector<File>();
        }
        std::vector<File> toRet = std::vector<File>();
        do {
            if(GetCurIsFile()) {
                std::optional<File> f = Open();
                if(f) {
                    if(!attribs) {
                        toRet.emplace_back(*f);
                    } else {
                        if(f->MatchesAttributes(attribs.value())) {
                            toRet.emplace_back(*f);
                        }
                    }
                }
            } else if(recurDepth != 0 && ffd.cFileName != std::wstring{ L"." } &&
                      ffd.cFileName != std::wstring{ L".." }) {
                std::vector<File> temp;
                std::optional<Folder> f = EnterDir();
                if(f) {
                    if(recurDepth == -1) {
                        temp = f->GetFiles(attribs, recurDepth);
                    } else {
                        temp = f->GetFiles(attribs, recurDepth - 1);
                    }
                    while(!temp.empty()) {
                        File file = temp.at(temp.size() - 1);
                        temp.pop_back();
                        toRet.emplace_back(file);
                    }
                }
            }
        } while(MoveToNextFile());
        return toRet;
    }

    std::vector<Folder> Folder::GetSubdirectories(__in_opt int recurDepth) {
        if(MoveToBeginning() == 0) {
            LOG_VERBOSE(2, "Couldn't iterate subfolders of nonexistent folder " << FolderPath);
            return {};
        }
        std::vector<Folder> toRet = {};
        do {
            if(!GetCurIsFile() && recurDepth != 0 && ffd.cFileName != std::wstring{ L"." } &&
               ffd.cFileName != std::wstring{ L".." }) {
                std::vector<Folder> temp;
                std::optional<Folder> f = EnterDir();
                if(f.has_value()) {
                    toRet.emplace_back(f.value());
                    if(recurDepth == -1) {
                        temp = f->GetSubdirectories(recurDepth);
                    } else {
                        temp = f->GetSubdirectories(recurDepth - 1);
                    }
                    while(!temp.empty()) {
                        auto folder = temp.at(temp.size() - 1);
                        temp.pop_back();
                        toRet.emplace_back(folder);
                    }
                }
            }
        } while(MoveToNextFile());
        return toRet;
    }

    std::optional<Permissions::Owner> Folder::GetFolderOwner() const {
        if(!bFolderExists) {
            LOG_VERBOSE(2, "Couldn't find owner of nonexistent folder " << FolderPath);
            return std::nullopt;
        }
        PSID psOwnerSID = NULL;
        PISECURITY_DESCRIPTOR pDesc = NULL;
        if(GetNamedSecurityInfoW((LPWSTR) FolderPath.c_str(), SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &psOwnerSID,
                                 nullptr, nullptr, nullptr,
                                 reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pDesc)) != ERROR_SUCCESS) {
            LOG_WARNING("Error getting file owner for folder " << FolderPath << ". " << SYSTEM_ERROR);
            return std::nullopt;
        }
        pDesc->Owner = psOwnerSID;

        Permissions::SecurityDescriptor secDesc(pDesc);
        return Permissions::Owner(secDesc);
    }

    bool Folder::SetFolderOwner(const Permissions::Owner& owner) {
        if(!bFolderExists) {
            LOG_VERBOSE(2, "Couldn't set owner of nonexistent folder " << FolderPath);
            return false;
        }
        if(SetNamedSecurityInfoW((LPWSTR) FolderPath.c_str(), SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION,
                                 owner.GetSID(), nullptr, nullptr, nullptr) != ERROR_SUCCESS) {
            LOG_WARNING("Error setting the folder owner for folder " << FolderPath << " to " << owner << ". "
                                                                     << SYSTEM_ERROR);
            return false;
        }
        LOG_VERBOSE(3, "Set the owner for folder " << FolderPath << " to " << owner << ".");
        return true;
    }

    ACCESS_MASK Folder::GetAccessPermissions(const Permissions::Owner& owner) {
        if(!bFolderExists) {
            LOG_VERBOSE(2, "Couldn't find permissions for nonexistent folder " << FolderPath);
            return 0;
        }
        PACL paDACL = NULL;
        PISECURITY_DESCRIPTOR pDesc = NULL;
        if(GetNamedSecurityInfoW((LPWSTR) FolderPath.c_str(), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, nullptr,
                                 nullptr, &paDACL, nullptr,
                                 reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pDesc)) != ERROR_SUCCESS) {
            LOG_WARNING("Error getting permissions on file " << FolderPath << " for owner " << owner
                                                             << ". Error: " << SYSTEM_ERROR);
            return 0;
        }
        //Correct positional memory of the ACL is weird and doesn't naturally work with the SecurityDescriptor class.
        //This gets the right data to the right place
        Permissions::SecurityDescriptor secDesc = Permissions::SecurityDescriptor::CreateDACL(paDACL->AclSize);
        memcpy(secDesc.GetDACL(), paDACL, paDACL->AclSize);
        LocalFree(pDesc);
        return Permissions::GetOwnerRightsFromACL(owner, secDesc);
    }

    ACCESS_MASK Folder::GetEveryonePermissions() {
        Permissions::Owner everyone(L"Everyone");
        return this->GetAccessPermissions(everyone);
    }

    bool Folder::TakeOwnership() {
        std::optional<Permissions::Owner> BluespawnOwner = Permissions::GetProcessOwner();
        if(BluespawnOwner == std::nullopt) {
            return false;
        }
        return this->SetFolderOwner(*BluespawnOwner);
    }
}   // namespace FileSystem

```

`BLUESPAWN-win-client/src/util/log/CLISink.cpp`:

```cpp
#include "util/log/CLISink.h"

#include <Windows.h>

#include <iostream>

#include "util/Utils.h"

#include "user/bluespawn.h"

namespace Log {

    void CLISink::SetConsoleColor(CLISink::MessageColor color) {
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        SetConsoleTextAttribute(hConsole, static_cast<WORD>(color));
    }

    CLISink::CLISink() : hMutex{ CreateMutexW(nullptr, false, L"Local\\CLI-Mutex") } {}

    void CLISink::LogMessage(IN CONST LogLevel& level, IN CONST std::wstring& message) {
        AcquireMutex mutex{ hMutex };
        if(level.Enabled()) {
            SetConsoleColor(CLISink::PrependColors[static_cast<WORD>(level.severity)]);
            std::wcout << CLISink::MessagePrepends[static_cast<WORD>(level.severity)] << " ";
            SetConsoleColor(CLISink::MessageColor::LIGHTGREY);
            std::wcout << message << std::endl;
        }
    }

    bool CLISink::operator==(IN CONST LogSink& sink) const { return (bool) dynamic_cast<const CLISink*>(&sink); }

    void CLISink::RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type) {
        if(type == RecordType::PreScan && Bluespawn::EnablePreScanDetections || type == RecordType::PostScan) {
            BeginCriticalSection _{ *detection };

            AcquireMutex mutex{ hMutex };

            SetConsoleColor(CLISink::PrependColors[4]);
            std::wcout << CLISink::MessagePrepends[4] << (type == RecordType::PreScan ? L"[Pre-Scan] " : L" ");
            SetConsoleColor(CLISink::MessageColor::LIGHTGREY);

            std::wcout << L"Detection ID: " << detection->dwID << std::endl;

            std::wcout << L"\tDetection Recorded at " << FormatWindowsTime(detection->context.DetectionCreatedTime)
                       << std::endl;
            if(detection->context.note) {
                std::wcout << L"\tNote: " << *detection->context.note << std::endl;
            }
            if(detection->context.FirstEvidenceTime) {
                std::wcout << L"\tFirst Evidence at " << FormatWindowsTime(*detection->context.FirstEvidenceTime)
                           << std::endl;
            }

            if(detection->context.hunts.size()) {
                std::wcout << L"\tDetected by: ";
                short cnt = detection->context.hunts.size();
                for(auto& hunt : detection->context.hunts) {
                    cnt--;
                    std::wcout << hunt;
                    if(cnt > 0) {
                        std::wcout << L", ";
                    }
                }
                std::wcout << std::endl;
            }

            if(detection->DetectionStale) {
                std::wcout << L"\tDetection is stale" << std::endl;
            }

            std::wcout << L"\tDetection Type: "
                       << (detection->type == DetectionType::FileDetection ?
                               L"File" :
                               detection->type == DetectionType::ProcessDetection ?
                               L"Process" :
                               detection->type == DetectionType::RegistryDetection ?
                               L"Registry" :
                               detection->type == DetectionType::ServiceDetection ?
                               L"Service" :
                               std::get<OtherDetectionData>(detection->data).DetectionType)
                       << std::endl;

            std::wcout << L"\tDetection Certainty: " << static_cast<double>(detection->info.GetCertainty())
                       << std::endl;
            std::wcout << L"\tDetection Data: " << std::endl;

            auto properties{ detection->Serialize() };
            for(auto& pair : properties) {
                std::wcout << L"\t\t" << pair.first << ": " << pair.second << std::endl;
            }
        }
    }

    void CLISink::RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
                                    IN CONST std::shared_ptr<Detection>& second,
                                    IN CONST Association& a) {
        AcquireMutex mutex{ hMutex };

        SetConsoleColor(CLISink::PrependColors[2]);
        std::wcout << CLISink::MessagePrepends[2];
        SetConsoleColor(CLISink::MessageColor::LIGHTGREY);
        std::wcout << L" Detections with IDs " << first->dwID << L" and " << second->dwID << L" now are associated"
                   << L" with strength " << static_cast<double>(a) << std::endl;
    }

    void CLISink::UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection) {
        BeginCriticalSection _{ *detection };
        AcquireMutex mutex{ hMutex };

        SetConsoleColor(CLISink::PrependColors[2]);
        std::wcout << CLISink::MessagePrepends[2];
        SetConsoleColor(CLISink::MessageColor::LIGHTGREY);
        std::wcout << L" Detection with ID " << detection->dwID << L" now has certainty "
                   << static_cast<double>(detection->info.GetCertainty()) << std::endl;
    }
}   // namespace Log

```

`BLUESPAWN-win-client/src/util/log/DebugSink.cpp`:

```cpp
#include <Windows.h>

#include <sstream>

#include "util/log/DebugSink.h"
#include "user/bluespawn.h"
#include "util/Utils.h"

#define DEBUG_STREAM(...) \
    OutputDebugStringW((std::wstringstream{} << __VA_ARGS__).str().c_str())

#define DETECTION_DEBUG_STREAM(...)                                                                                  \
    DEBUG_STREAM((type == RecordType::PreScan ? L"[Pre-Scan Detection]" : L"[Detection]") << L"[ID " << detection->dwID << \
                 L"]" << __VA_ARGS__);

namespace Log{

	void DebugSink::LogMessage(IN CONST LogLevel& level, IN CONST std::wstring& message){
		BeginCriticalSection _{ hGuard };

		if(level.Enabled()){
			DEBUG_STREAM(DebugSink::MessagePrepends[static_cast<WORD>(level.severity)] << L" " << message);
		}
	}

	bool DebugSink::operator==(IN CONST LogSink& sink) const{
		return (bool) dynamic_cast<const DebugSink*>(&sink);
	}

	void DebugSink::RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type){

		if(type == RecordType::PreScan && Bluespawn::EnablePreScanDetections || type == RecordType::PostScan){

			BeginCriticalSection __{ *detection };
			BeginCriticalSection _{ hGuard };

			DETECTION_DEBUG_STREAM(L" Detection Logged at " << FormatWindowsTime(detection->context.DetectionCreatedTime));
			if(detection->context.note){
				DETECTION_DEBUG_STREAM(L" Note: " << *detection->context.note);
			}
			if(detection->context.FirstEvidenceTime){
				DETECTION_DEBUG_STREAM(L" First Evidence: " << FormatWindowsTime(*detection->context.FirstEvidenceTime));
			}

			if(detection->context.hunts.size()){
				std::wstringstream hunts{};
				for(auto& hunt : detection->context.hunts){
					hunts << hunt << L", ";
				}
				DETECTION_DEBUG_STREAM(L" Associated Hunts: " << hunts.str());
			}

			if(detection->DetectionStale){
				DETECTION_DEBUG_STREAM(L" Detection is Stale");
			}

			DETECTION_DEBUG_STREAM(L" Detection Type: " << 
				(detection->type == DetectionType::FileDetection ? L"File" :
				 detection->type == DetectionType::ProcessDetection ? L"Process" :
				 detection->type == DetectionType::RegistryDetection ? L"Registry" :
				 detection->type == DetectionType::ServiceDetection ? L"Service" :
				 std::get<OtherDetectionData>(detection->data).DetectionType));

			DETECTION_DEBUG_STREAM(L" Detection Certainty: " << static_cast<double>(detection->info.GetCertainty()));

			auto properties{ detection->Serialize() };
			for(auto& pair : properties){
				DETECTION_DEBUG_STREAM(L"[Data] " << pair.first << L": " << pair.second);
			}
		}
	}

	void DebugSink::RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
									IN CONST std::shared_ptr<Detection>& second, IN CONST Association& a){
		BeginCriticalSection _{ hGuard };

		DEBUG_STREAM(L"[Detection][ID " << first->dwID << L"]" << L" Associated with " << second->dwID << 
					 L" with strength " << static_cast<double>(a));
	}

	void DebugSink::UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection){
		BeginCriticalSection __{ *detection };
		BeginCriticalSection _{ hGuard };

		DEBUG_STREAM(L"[Detection][ID " << detection->dwID << L"]" << L" now has certainty "
					 << static_cast<double>(detection->info.GetCertainty()));
	}
}

```

`BLUESPAWN-win-client/src/util/log/JSONSink.cpp`:

```cpp
#include "util/log/JSONSink.h"

#include <chrono>
#include <fstream>
#include <iostream>

#include "util/StringUtils.h"
#include "util/Utils.h"

#include "user/bluespawn.h"

namespace Log {

    void UpdateLog(JSONSink* sink) {
        HandleWrapper hRecordEvent{ CreateEventW(nullptr, false, false, L"Local\\FlushLogs") };
        while(true) {
            WaitForSingleObject(hRecordEvent, INFINITE);
            sink->Flush();
        }
    }

    JSONSink::JSONSink() :
        thread{ CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, CREATE_SUSPENDED, nullptr) } {
        JSONDoc = json::object();
        JSONDoc["bluespawn"] = json::object();
        JSONDoc["bluespawn"]["log-messages"] = json::array();

        SYSTEMTIME time{};
        GetLocalTime(&time);
        wFileName = L"bluespawn-" + ToWstringPad(time.wMonth) + L"-" + ToWstringPad(time.wDay) + L"-" +
                    ToWstringPad(time.wYear, 4) + L"-" + ToWstringPad(time.wHour) + ToWstringPad(time.wMinute) + L"-" +
                    ToWstringPad(time.wSecond) + L".json";
        ResumeThread(thread);
    }

    JSONSink::JSONSink(const std::wstring& wOutputDir) :
        thread{ CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, 0, nullptr) } {
        SYSTEMTIME time{};
        GetLocalTime(&time);
        wFileName = wOutputDir + L"\\bluespawn-" + ToWstringPad(time.wMonth) + L"-" + ToWstringPad(time.wDay) + L"-" +
                    ToWstringPad(time.wYear, 4) + L"-" + ToWstringPad(time.wHour) + ToWstringPad(time.wMinute) + L"-" +
                    ToWstringPad(time.wSecond) + L".json";
        JSONDoc = json::object();
        JSONDoc["bluespawn"] = json::object();
        JSONDoc["bluespawn"]["log-messages"] = json::array();
    }

    JSONSink::JSONSink(const std::wstring& wOutputDir, const std::wstring& wFileName) :
        wFileName{ wOutputDir + L"\\" + wFileName }, thread{
            CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, 0, nullptr)
        } {
        JSONDoc = json::object();
        JSONDoc["bluespawn"] = json::object();
        JSONDoc["bluespawn"]["log-messages"] = json::array();
    }

    JSONSink::~JSONSink() {
        std::ofstream out(WidestringToString(wFileName));
        out << std::setw(4) << JSONDoc << std::endl;
        TerminateThread(thread, 0);
    }

    void
    JSONSink::InsertElement(IN json JSONDoc, IN json parent, IN CONST std::string& name, IN CONST std::wstring& value) {
        parent[name] = WidestringToString(value).c_str();
    }

    void JSONSink::UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection) {
        BeginCriticalSection __{ *detection };
        BeginCriticalSection _{ hGuard };

        if(detections.find(detection->dwID) != detections.end()) {
            for(auto& item : JSONDoc["bluespawn"]["detections"]) {
                if(item["id"] == detection->dwID) {
                    const auto cert = item.find("certainty");
                    const auto rawcert = item.find("raw-certainty");
                    item.erase(cert);
                    item.erase(rawcert);
                    item["certainty"] = std::to_string(detection->info.GetCertainty());
                    item["raw-certainty"] = std::to_string(detection->info.GetIntrinsicCertainty());
                    return;
                }
            }
        }
    }

    void JSONSink::AddAssociation(IN DWORD detection_id, IN DWORD associated, IN double strength) {
        /// Note that the critical section for hGuard is already acquired as this function is only called
        /// by RecordAssociation

        for(auto& item : JSONDoc["bluespawn"]["detections"]) {
            if(item["id"] == detection_id) {
                if(item.find("associated-detections") != item.end()) {
                    /// update association strength for association already in associated-detections of detection_id
                    for(auto& child : item["associated-detections"]) {
                        if(child["id"] == associated) {
                            const auto cur_strength = child.find("strength");
                            child.erase(cur_strength);
                            child["strength"] = std::to_string(
                                (1.0 - (1 - std::stod((std::string) cur_strength.value())) * (1 - strength)));
                            return;
                        }
                    }

                    /// add new association in associated-detections of detection_id
                    item["associated-detections"].push_back(
                        { { "strength", static_cast<double>(strength) }, { "id", associated } });
                    return;
                }

                /// create associated-detections within detection_id and add new association
                item["associated-detections"] = json::array();
                item["associated-detections"].push_back(
                    { { "strength", static_cast<double>(strength) }, { "id", associated } });
                return;
            }
        }
    }

    void JSONSink::RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type) {
        if(type == RecordType::PreScan && !Bluespawn::EnablePreScanDetections) {
            return;
        }

        BeginCriticalSection __{ *detection };
        BeginCriticalSection _{ hGuard };

        if(JSONDoc["bluespawn"]["detections"] == nullptr) {
            JSONDoc["bluespawn"]["detections"] = json::array();
        }

        if(detections.find(detection->dwID) != detections.end()) {
            /// Delete current detection within json
            for(auto& it : JSONDoc["bluespawn"]["detections"].items()) {
                if(it.value().at("id").get<std::string>() == std::to_string(detection->dwID)) {
                    JSONDoc["bluespawn"]["detections"].erase(JSONDoc["bluespawn"]["detections"].begin() + (int&) it);
                    break;
                }
            }
        } else {
            detections.insert(detection->dwID);
        }

        json detect = {};

        if(type == RecordType::PreScan) {
            detect["prescan"] = "true";
        }

        detect["type"] = (detection->type == DetectionType::FileDetection ?
                              "File" :
                          detection->type == DetectionType::ProcessDetection ?
                              "Process" :
                          detection->type == DetectionType::RegistryDetection ?
                              "Registry" :
                          detection->type == DetectionType::ServiceDetection ?
                              "Service" :
                              WidestringToString(std::get<OtherDetectionData>(detection->data).DetectionType));

        detect["id"] = std::to_string(detection->dwID);
        detect["time"] = WidestringToString(FormatWindowsTime(detection->context.DetectionCreatedTime));

        if(detection->context.FirstEvidenceTime) {
            detect["first-evidence-time"] = FormatWindowsTime(*detection->context.FirstEvidenceTime);
        }

        if(detection->context.note) {
            detect["note"] = WidestringToString(*detection->context.note);
        }

        detect["certainty"] = std::to_string(detection->info.GetCertainty());
        detect["raw-certainty"] = std::to_string(detection->info.GetIntrinsicCertainty());

        if(detection->context.hunts.size()) {
            detect["associated-hunts"] = json::array();
            for(const auto& hunt : detection->context.hunts) {
                detect["associated-hunts"].push_back(WidestringToString(hunt));
            }
        }

        detect["associated-data"] = json::object();
        for(const auto& entry : detection->Serialize()) {
            detect["associated-data"][WidestringToString(entry.first)] = WidestringToString(entry.second);
        }

        auto assoc{ detection->info.GetAssociations() };
        if(assoc.size()) {
            detect["associated-detections"] = json::array();
            for(const auto& det : assoc) {
                detect["associated-detections"].push_back(
                    { { "strength", static_cast<double>(det.second) }, { "id", std::to_string(det.first->dwID) } });
            }
        }

        JSONDoc["bluespawn"]["detections"].push_back(detect);
    }

    void JSONSink::RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
                                     IN CONST std::shared_ptr<Detection>& second,
                                     IN CONST Association& strength) {
        UpdateCertainty(first);
        UpdateCertainty(second);

        BeginCriticalSection _{ hGuard };

        if(detections.find(first->dwID) != detections.end()) {
            AddAssociation(first->dwID, second->dwID, strength);
        }

        if(detections.find(second->dwID) != detections.end()) {
            AddAssociation(second->dwID, first->dwID, strength);
        }
    }

    void JSONSink::LogMessage(const LogLevel& level, const std::wstring& message) {
        BeginCriticalSection _{ hGuard };

        if(level.Enabled()) {
            std::map<std::string, std::string> msg = {};
            if(level.detail) {
                msg["detail"] = *level.detail == Detail::High     ? "high" :
                                *level.detail == Detail::Moderate ? "moderate" :
                                                                    "low";
            }
            SYSTEMTIME time{};
            GetLocalTime(&time);
            msg["time"] = WidestringToString(FormatWindowsTime(time)).c_str();
            msg["message"] = WidestringToString(message).c_str();
            JSONDoc["bluespawn"]["log-messages"].push_back(msg);
        }
    }

    bool JSONSink::operator==(const LogSink& sink) const {
        return (bool) dynamic_cast<const JSONSink*>(&sink) &&
               dynamic_cast<const JSONSink*>(&sink)->wFileName == wFileName;
    }

    void JSONSink::Flush() {
        std::ofstream out(WidestringToString(wFileName));
        out << std::setw(4) << JSONDoc << std::endl;
    }
};   // namespace Log

```

`BLUESPAWN-win-client/src/util/log/Log.cpp`:

```cpp
#include "util/log/Log.h"

#include <iostream>

#include "util/StringUtils.h"

namespace Log {
    std::vector<std::shared_ptr<Log::LogSink>> _LogSinks;
    LogTerminator endlog{};

    LogMessage& LogMessage::operator<<(IN CONST LogTerminator& terminator) {
        auto message{ stream.str() };

        stream = std::wstringstream{};
        level.LogMessage(message);

        return *this;
    }

    LogMessage& LogMessage::InnerLog(IN CONST Loggable& loggable, IN CONST std::true_type&) {
        return operator<<(loggable.ToString());
    }

    template<>
    LogMessage& LogMessage::InnerLog(IN CONST LPCSTR& data, IN CONST std::false_type&) {
        stream << StringToWidestring(data);
        return *this;
    }

    template<>
    LogMessage& LogMessage::InnerLog(IN CONST std::string& data, IN CONST std::false_type&) {
        stream << StringToWidestring(data);
        return *this;
    }

    LogMessage::LogMessage(IN CONST LogLevel& level) : level{ level } {}
    LogMessage::LogMessage(IN CONST LogLevel& level, IN CONST std::wstringstream& message) : level{ level }, stream{} {
        stream << message.str();
    }

    void AddSink(IN CONST std::shared_ptr<LogSink>& sink,
                 IN CONST std::vector<std::reference_wrapper<LogLevel>>& levels) {
        LogSink* pointer{ sink.get() };
        bool exists{ false };

        for(auto& existing : _LogSinks) {
            if(*existing == *sink) {
                pointer = existing.get();
                exists = true;
            }
        }

        if(!exists) {
            _LogSinks.emplace_back(sink);
        }

        for(auto level : levels) {
            level.get().AddSink(pointer);
        }
    }

    std::wstring FormatErrorMessage(DWORD dwErrorCode) {
        //https://stackoverflow.com/a/45565001/3302799
        LPWSTR psz{ nullptr };
        auto cchMsg = FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER, nullptr,
            dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPTSTR>(&psz), 0, nullptr);
        if(cchMsg) {
            auto delfunc{ [](void* p) { ::LocalFree(p); } };
            std::unique_ptr<WCHAR, decltype(delfunc)> ptrBuffer(psz, delfunc);
            return std::wstring(ptrBuffer.get(), cchMsg);
        } else {
            auto error_code{ ::GetLastError() };
            return L"Unable to format error message!";
        }
    }
}   // namespace Log

```

`BLUESPAWN-win-client/src/util/log/LogLevel.cpp`:

```cpp
#include "util/log/LogLevel.h"
#include "util/log/LogSink.h"

namespace Log {

	LogLevel::LogLevel(IN Severity severity,
					   IN CONST std::optional<Detail>& detail OPTIONAL) :
		enabled{ true },
		severity{ severity },
		detail{ detail }{}
	LogLevel::LogLevel(IN Severity severity,
					   IN bool DefaultState,
					   IN CONST std::optional<Detail>& detail OPTIONAL) :
		enabled{ enabled },
		severity{ severity },
		detail{ detail }{}

	LogLevel LogLevel::LogError{Severity::LogError, true };

	LogLevel LogLevel::LogWarn{Severity::LogWarn, true };

	LogLevel LogLevel::LogInfo1{ Severity::LogInfo, true, Detail::Low };

	LogLevel LogLevel::LogInfo2{ Severity::LogInfo, false, Detail::Moderate };

	LogLevel LogLevel::LogInfo3{ Severity::LogInfo, false, Detail::High };

	LogLevel LogLevel::LogVerbose1{ Severity::LogVerbose, false, Detail::Low };

	LogLevel LogLevel::LogVerbose2{ Severity::LogVerbose, false, Detail::Moderate };

	LogLevel LogLevel::LogVerbose3{ Severity::LogVerbose, false, Detail::High };

	void LogLevel::Enable(){ enabled = true; }
	void LogLevel::Disable(){ enabled = false; }
	bool LogLevel::Toggle(){ return enabled = !enabled; }
	bool LogLevel::Enabled() const { return enabled; }

	void LogLevel::AddSink(IN LogSink* sink){
		for(auto existing : sinks){
			if(*existing == *sink){
				return;
			}
		}

		sinks.emplace_back(sink);
	}

	void LogLevel::LogMessage(IN CONST std::wstring& message){
		if(enabled){
			for(auto sink : sinks){
				sink->LogMessage(*this, message);
			}
		}
	}
}
```

`BLUESPAWN-win-client/src/util/log/XMLSink.cpp`:

```cpp
#include "util/log/XMLSink.h"

#include <chrono>
#include <iostream>

#include "util/StringUtils.h"
#include "util/Utils.h"

#include "user/bluespawn.h"

namespace Log {

    void UpdateLog(XMLSink* sink) {
        HandleWrapper hRecordEvent{ CreateEventW(nullptr, false, false, L"Local\\FlushLogs") };
        while(true) {
            WaitForSingleObject(hRecordEvent, INFINITE);
            sink->Flush();
        }
    }

    XMLSink::XMLSink() :
        Root{ XMLDoc.NewElement("bluespawn") }, LogRoot{ XMLDoc.NewElement("log-messages") }, thread{
            CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, CREATE_SUSPENDED, nullptr)
        } {
        SYSTEMTIME time{};
        GetLocalTime(&time);
        wFileName = L"bluespawn-" + ToWstringPad(time.wMonth) + L"-" + ToWstringPad(time.wDay) + L"-" +
                    ToWstringPad(time.wYear, 4) + L"-" + ToWstringPad(time.wHour) + ToWstringPad(time.wMinute) + L"-" +
                    ToWstringPad(time.wSecond) + L".xml";
        XMLDoc.InsertEndChild(Root);
        Root->InsertEndChild(LogRoot);
        ResumeThread(thread);
    }

    XMLSink::XMLSink(const std::wstring& wOutputDir) :
        Root{ XMLDoc.NewElement("bluespawn") }, LogRoot{ XMLDoc.NewElement("log-messages") }, thread{
            CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, 0, nullptr)
        } {
        SYSTEMTIME time{};
        GetLocalTime(&time);
        wFileName = wOutputDir + L"\\bluespawn-" + ToWstringPad(time.wMonth) + L"-" + ToWstringPad(time.wDay) + L"-" +
                    ToWstringPad(time.wYear, 4) + L"-" + ToWstringPad(time.wHour) + ToWstringPad(time.wMinute) + L"-" +
                    ToWstringPad(time.wSecond) + L".xml";
        XMLDoc.InsertEndChild(Root);
    }

    XMLSink::XMLSink(const std::wstring& wOutputDir, const std::wstring& wFileName) :
        Root{ XMLDoc.NewElement("bluespawn") }, wFileName{ wOutputDir + L"\\" + wFileName }, LogRoot{ XMLDoc.NewElement(
                                                                                                 "log-messages") },
        thread{ CreateThread(nullptr, 0, PTHREAD_START_ROUTINE(UpdateLog), this, 0, nullptr) } {
        XMLDoc.InsertEndChild(Root);
    }

    XMLSink::~XMLSink() {
        XMLDoc.SaveFile(WidestringToString(wFileName).c_str());
        TerminateThread(thread, 0);
    }

    void InsertElement(IN tinyxml2::XMLDocument& XMLDoc,
                       IN tinyxml2::XMLElement* parent,
                       IN CONST std::string& name,
                       IN CONST std::wstring& value) {
        auto elem{ XMLDoc.NewElement(name.c_str()) };
        elem->SetText(WidestringToString(value).c_str());
        parent->InsertEndChild(elem);
    }

    void XMLSink::UpdateCertainty(IN CONST std::shared_ptr<Detection>& detection) {
        BeginCriticalSection __{ *detection };
        BeginCriticalSection _{ hGuard };
        if(detections.find(detection->dwID) != detections.end()) {
            for(auto child{ detections.at(detection->dwID)->FirstChildElement() }; child;
                child = child->NextSiblingElement()) {
                if(child->Name() == std::string{ "certainty" }) {
                    child->SetText(detection->info.GetCertainty());
                }
                if(child->Name() == std::string{ "raw-certainty" }) {
                    child->SetText(detection->info.GetIntrinsicCertainty());
                }
            }
        }
    }

    void AddAssociation(IN tinyxml2::XMLDocument& doc, IN tinyxml2::XMLElement* to, IN DWORD id, IN double strength) {
        for(auto child{ to->FirstChildElement() }; child; child = child->NextSiblingElement()) {
            if(child->Name() == std::string{ "associated-detections" }) {
                for(auto elem{ child->FirstChildElement() }; elem; elem = elem->NextSiblingElement()) {
                    if(elem->GetText() == std::to_string(id)) {
                        double existing{ 0 };
                        elem->FindAttribute("strength")->QueryDoubleValue(&existing);
                        elem->SetAttribute("strength", 1.0 - (1 - existing) * (1 - strength));
                        return;
                    }
                }

                auto elem{ doc.NewElement("association") };
                elem->SetAttribute("strength", strength);
                elem->SetText(std::to_string(id).c_str());
                child->InsertEndChild(elem);
                return;
            }
        }

        auto assocations{ doc.NewElement("associated-detections") };
        auto elem{ doc.NewElement("association") };
        elem->SetAttribute("strength", strength);
        elem->SetText(std::to_string(id).c_str());
        assocations->InsertEndChild(elem);
        to->InsertEndChild(assocations);
    }

    void XMLSink::RecordDetection(IN CONST std::shared_ptr<Detection>& detection, IN RecordType type) {
        if(type == RecordType::PreScan && !Bluespawn::EnablePreScanDetections) {
            return;
        }

        BeginCriticalSection __{ *detection };
        BeginCriticalSection _{ hGuard };

        tinyxml2::XMLElement* detect{ nullptr };
        if(detections.find(detection->dwID) != detections.end()) {
            detect = detections.at(detection->dwID);
            detect->DeleteChildren();
        } else {
            detect = XMLDoc.NewElement("detection");
            detections.emplace(detection->dwID, detect);
            Root->InsertEndChild(detect);
        }

        if(type == RecordType::PreScan) {
            detect->SetAttribute("prescan", true);
        }

        detect->SetAttribute("type",
                             (detection->type == DetectionType::FileDetection ?
                                  "File" :
                              detection->type == DetectionType::ProcessDetection ?
                                  "Process" :
                              detection->type == DetectionType::RegistryDetection ?
                                  "Registry" :
                              detection->type == DetectionType::ServiceDetection ?
                                  "Service" :
                                  WidestringToString(std::get<OtherDetectionData>(detection->data).DetectionType))
                                 .c_str());

        detect->SetAttribute("id", std::to_string(detection->dwID).c_str());
        detect->SetAttribute("time",
                             WidestringToString(FormatWindowsTime(detection->context.DetectionCreatedTime)).c_str());

        if(detection->context.FirstEvidenceTime) {
            InsertElement(XMLDoc, detect, "first-evidence-time",
                          FormatWindowsTime(*detection->context.FirstEvidenceTime));
        }

        if(detection->context.note) {
            InsertElement(XMLDoc, detect, "note", *detection->context.note);
        }

        InsertElement(XMLDoc, detect, "certainty", std::to_wstring(detection->info.GetCertainty()));
        InsertElement(XMLDoc, detect, "raw-certainty", std::to_wstring(detection->info.GetIntrinsicCertainty()));

        if(detection->context.hunts.size()) {
            auto hunts{ XMLDoc.NewElement("associated-hunts") };
            for(const auto& hunt : detection->context.hunts) {
                InsertElement(XMLDoc, hunts, "hunt", hunt);
            }
            detect->InsertEndChild(hunts);
        }

        auto data{ XMLDoc.NewElement("associated-data") };
        for(const auto& entry : detection->Serialize()) {
            auto elem{ XMLDoc.NewElement("property") };
            elem->SetAttribute("name", WidestringToString(entry.first).c_str());
            elem->SetText(WidestringToString(entry.second).c_str());
            data->InsertEndChild(elem);
        }
        detect->InsertEndChild(data);

        auto assoc{ detection->info.GetAssociations() };
        if(assoc.size()) {
            auto assocations{ XMLDoc.NewElement("associated-detections") };
            for(const auto& det : assoc) {
                auto elem{ XMLDoc.NewElement("association") };
                elem->SetAttribute("strength", static_cast<double>(det.second));
                elem->SetText(std::to_string(det.first->dwID).c_str());
                assocations->InsertEndChild(elem);
            }
            detect->InsertEndChild(assocations);
        }
    }

    void XMLSink::RecordAssociation(IN CONST std::shared_ptr<Detection>& first,
                                    IN CONST std::shared_ptr<Detection>& second,
                                    IN CONST Association& strength) {
        UpdateCertainty(first);
        UpdateCertainty(second);

        BeginCriticalSection _{ hGuard };

        if(detections.find(first->dwID) != detections.end()) {
            AddAssociation(XMLDoc, detections.at(first->dwID), second->dwID, strength);
        }

        if(detections.find(second->dwID) != detections.end()) {
            AddAssociation(XMLDoc, detections.at(second->dwID), first->dwID, strength);
        }
    }

    void XMLSink::LogMessage(const LogLevel& level, const std::wstring& message) {
        BeginCriticalSection _{ hGuard };

        if(level.Enabled()) {
            auto msg = XMLDoc.NewElement(MessageTags[static_cast<DWORD>(level.severity)].c_str());
            if(level.detail) {
                msg->SetAttribute("detail", *level.detail == Detail::High     ? "high" :
                                            *level.detail == Detail::Moderate ? "moderate" :
                                                                                "low");
            }

            SYSTEMTIME time{};
            GetLocalTime(&time);
            msg->SetAttribute("time", WidestringToString(FormatWindowsTime(time)).c_str());

            msg->SetText(WidestringToString(message).c_str());
            LogRoot->InsertEndChild(msg);
        }
    }

    bool XMLSink::operator==(const LogSink& sink) const {
        return (bool) dynamic_cast<const XMLSink*>(&sink) &&
               dynamic_cast<const XMLSink*>(&sink)->wFileName == wFileName;
    }

    void XMLSink::Flush() { XMLDoc.SaveFile(WidestringToString(wFileName).c_str()); }
};   // namespace Log

```

`BLUESPAWN-win-client/src/util/pe/Export_Section.cpp`:

```cpp
#include "util/pe/Export_Section.h"
#include "util/pe/PE_Image.h"
#include "util/pe/Image_Loader.h"

#include "util/DynamicLinker.h"
#include "util/StringUtils.h"
#include "util/log/Log.h"

#include <Windows.h>
#include <winternl.h>

#include <vector>
#include <string>
#include <functional>

LINK_FUNCTION(LdrpPreprocessDllName, NTDLL.dll);

PE_Export::PE_Export(DWORD rva, WORD ordinal, std::string name) : 
	rva{ rva }, ordinal{ ordinal }, name{ name }, redirect{} {}
PE_Export::PE_Export(WORD ordinal, std::string name, std::wstring redirect) : 
	rva{ 0 }, ordinal{ ordinal }, name{ name }, redirect{ redirect } {}

Export_Section::Export_Section(const PE_Section& section) : 
	exports{}, ExportDirectory{}, PE_Section{ section }{
	ExportDirectory = *section.SectionContent.Convert<IMAGE_EXPORT_DIRECTORY>();
	
	int dwExportCount = ExportDirectory.NumberOfFunctions;
	MemoryWrapper<DWORD> lpFunctionAddresses = AssociatedImage.base.GetOffset(
		AssociatedImage.expanded ? AssociatedImage.RVAToOffset(ExportDirectory.AddressOfFunctions) : ExportDirectory.AddressOfFunctions
	).Convert<DWORD>();
	MemoryWrapper<DWORD> lpNameAddresses = AssociatedImage.base.GetOffset(
		AssociatedImage.expanded ? AssociatedImage.RVAToOffset(ExportDirectory.AddressOfNames) : ExportDirectory.AddressOfNames
	).Convert<DWORD>();
	MemoryWrapper<WORD> lpOrdinalAddresses = AssociatedImage.base.GetOffset(
		AssociatedImage.expanded ? AssociatedImage.RVAToOffset(ExportDirectory.AddressOfNameOrdinals) : ExportDirectory.AddressOfNameOrdinals
	).Convert<WORD>();

	for(int i = 0; i < dwExportCount; i++){
		auto name = AssociatedImage.base.GetOffset(*lpNameAddresses.GetOffset(i * sizeof(DWORD))).ReadString();
		auto address = *lpFunctionAddresses.GetOffset(i * sizeof(DWORD));

		if(!AssociatedImage.sections.at(".text").ContainsRVA(address)){
			exports.emplace_back(PE_Export{ address, *lpOrdinalAddresses.GetOffset(i * sizeof(WORD)), name });
		} else {
			std::string redirection = lpNameAddresses.GetOffset(address - ExportDirectory.AddressOfNames).ReadString();

			size_t idx = redirection.find(".");
			std::wstring dllName = StringToWidestring(redirection.substr(0, idx));
			std::string importName = redirection.substr(idx + 1);

			std::wstring wsProcessedDllName{};
			wsProcessedDllName.resize(MAX_PATH);

			UNICODE_STRING usPreprocessed = { static_cast<USHORT>(dllName.length() * 2), static_cast<USHORT>(MAX_PATH * 2), &dllName[0] };
			UNICODE_STRING usProcessed = { static_cast<USHORT>(wsProcessedDllName.length() * 2), static_cast<USHORT>(MAX_PATH * 2), &wsProcessedDllName[0] };
			ULONG_PTR zero = 0;

			NTSTATUS status = Linker::LdrpPreprocessDllName(&usPreprocessed, &usProcessed, &zero, &zero);
			if(!NT_SUCCESS(status)){
				LOG_ERROR("An error occured while attempting to parse " << importName << ", located in " << dllName);
			} else {
				exports.emplace_back(PE_Export{ *lpOrdinalAddresses.GetOffset(i * sizeof(WORD)), name, wsProcessedDllName });
			}
		}
	}
}

DWORD64 Export_Section::GetExportAddress(std::string name) const {
	for(auto dllExport : exports){
		if(dllExport.name == name){
			return GetExportAddress(dllExport.ordinal);
		}
	}
	return 0;
}

DWORD64 Export_Section::GetExportAddress(WORD ordinal) const {
	for(auto dllExport : exports){
		if(dllExport.ordinal == ordinal){
			if(dllExport.rva){
				return AssociatedImage.base.GetOffset(AssociatedImage.RVAToOffset(dllExport.rva));
			} else {
				auto hProcess = AssociatedImage.base.process;
				auto Loader = Image_Loader(hProcess);
				if(!Loader.ContainsImage(StringToWidestring(dllExport.name))){
					PE_Image image = PE_Image(StringToWidestring(dllExport.name));
					if(!image.ValidatePE()){
						return 0;
					}
					if(!image.LoadTo({ VirtualAllocEx(hProcess, nullptr, image.dwExpandSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE),
						image.dwExpandSize, hProcess }, true)){
						return 0;
					}
					Loader.AddImage(Loaded_Image{ image, true, image.swzImagePath.has_value() ? *image.swzImagePath : L"" });
				}

				auto ImageInfo = Loader.GetImageInfo(StringToWidestring(dllExport.name));
				if(!ImageInfo.has_value()){
					return 0;
				}
				auto Image = ImageInfo->GetImage();
				return Image.exports->GetExportAddress(ordinal);
			}
		}
	}
	return 0;
}
```

`BLUESPAWN-win-client/src/util/pe/Image_Loader.cpp`:

```cpp
#include "util/pe/Image_Loader.h"
#include "util/log/Log.h"

#include <functional>

LINK_FUNCTION(NtQueryInformationProcess, NTDLL.dll);

bool CompareStrings(const UNICODE_STRING32& s1, const HandleWrapper& process1, const UNICODE_STRING32& s2, const HandleWrapper& process2){
	if(s1.Length != s2.Length)
		return false;
	return MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s1.Buffer)), s1.Length * 2 + 2, process1).ReadWstring() ==
		MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s1.Buffer)), s2.Length * 2 + 2, process2).ReadWstring();
}

bool CompareStrings(const UNICODE_STRING64& s1, const HandleWrapper& process1, const UNICODE_STRING64& s2, const HandleWrapper& process2){
	if(s1.Length != s2.Length)
		return false;
	return MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s1.Buffer)), s1.Length * 2 + 2, process1).ReadWstring() ==
		MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s2.Buffer)), s2.Length * 2 + 2, process2).ReadWstring();
}
bool CompareStrings(const UNICODE_STRING32& s1, const HandleWrapper& process1, const std::wstring& s2){
	if(s1.Length != s2.length())
		return false;
	return MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s1.Buffer)), s1.Length * 2 + 2, process1).ReadWstring() == s2;
}
bool CompareStrings(const UNICODE_STRING64& s1, const HandleWrapper& process1, const std::wstring& s2){
	if(s1.Length != s2.length())
		return false;
	return MemoryWrapper<>(reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(s1.Buffer)), s1.Length * 2 + 2, process1).ReadWstring() == s2;
}

Loaded_Image32::Loaded_Image32(const LDR_ENTRY32& entry, const HandleWrapper& process) :
	EntryPoint{ entry.EntryPoint },
	ImageAddress{ entry.DllBase },
	ImagePath{ MemoryWrapper<WCHAR>{ reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(entry.FullDllName.Buffer)), 
	    static_cast<SIZE_T>(entry.FullDllName.Length + 1), process }.ReadWstring() },
	ImageName{ MemoryWrapper<WCHAR>{ reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(entry.BaseDllName.Buffer)),
	    static_cast<SIZE_T>(entry.BaseDllName.Length + 1), process }.ReadWstring() },
	ImageSize{ entry.SizeOfImage },
	process{ process }{}

Loaded_Image64::Loaded_Image64(const LDR_ENTRY64& entry, const HandleWrapper& process) :
	EntryPoint{ entry.EntryPoint },
	ImageAddress{ entry.DllBase },
	ImagePath{ MemoryWrapper<WCHAR>{ reinterpret_cast<LPVOID>(entry.FullDllName.Buffer), static_cast<SIZE_T>(entry.FullDllName.Length + 1), 
	    process }.ReadWstring() },
	ImageName{ MemoryWrapper<WCHAR>{ reinterpret_cast<LPVOID>(entry.BaseDllName.Buffer), static_cast<SIZE_T>(entry.BaseDllName.Length + 1), 
	    process }.ReadWstring() },
	ImageSize{ entry.SizeOfImage },
	process{ process }{}

Loaded_Image::Loaded_Image(const LDR_ENTRY32& entry, const HandleWrapper& process) :
	arch{ Architecture::x86 },
	image32{ Loaded_Image32{ entry, process } },
	image64{ std::nullopt } {}

Loaded_Image::Loaded_Image(const LDR_ENTRY64& entry, const HandleWrapper& process) :
	arch{ Architecture::x64 },
	image64{ Loaded_Image64{ entry, process } },
	image32{ std::nullopt } {}

std::wstring Loaded_Image::GetName(){
	return arch == x64 ? image64->ImageName : image32->ImageName;
}

Image_Loader::Image_Loader(const HandleWrapper& process) : 
	process{ process }, LoadedImages{}{
	if(process){
		PROCESS_BASIC_INFORMATION information{};
		NTSTATUS status = Linker::NtQueryInformationProcess(process, ProcessBasicInformation, &information, sizeof(information), nullptr);
		if(!NT_SUCCESS(status)){
			LOG_ERROR("Error " << status << " occured when finding the PEB of process " << process.Get());
		}
		BOOL wow64 = false;
		IsWow64Process(process, &wow64);

		if(wow64){
			arch = x86;
			address = *MemoryWrapper<DWORD>(information.PebBaseAddress, sizeof(DWORD) * 4, process).GetOffset(sizeof(DWORD) * 3);
		} else {
#ifdef _WIN64 
			arch = x64;
			address = *MemoryWrapper<DWORD64>(information.PebBaseAddress, sizeof(DWORD64) * 4, process).GetOffset(sizeof(DWORD64) * 3);
#else
			arch = x86;
			address = *MemoryWrapper<DWORD>(information.PebBaseAddress, sizeof(DWORD) * 4, process).GetOffset(sizeof(DWORD) * 3);
#endif
		}
	} else {
#ifdef _WIN64
		address = __readgsqword(0x60);
		arch = x64;
#else
		address = __readfsdword(0x30);
		arch = x86;
#endif
	}

	if(arch == x64){
		auto FirstAddress = MemoryWrapper<LDR_DATA64>{ reinterpret_cast<LPVOID>(address), sizeof(LDR_DATA64), process }->InLoadOrderModuleList.Flink;
		auto entry = *MemoryWrapper<LDR_ENTRY64>{reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(FirstAddress)), sizeof(LDR_ENTRY64), process};
		while(entry.EntryPoint){
			LoadedImages.emplace_back(Loaded_Image{ entry, process });
			entry = *MemoryWrapper<LDR_ENTRY64>{reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(entry.InLoadOrderModuleList.Flink)), sizeof(LDR_ENTRY64), process};
		}
	} else {
		auto FirstAddress = MemoryWrapper<LDR_DATA32>{ reinterpret_cast<LPVOID>(address), sizeof(LDR_DATA32), process }->InLoadOrderModuleList.Flink;
		auto entry = *MemoryWrapper<LDR_ENTRY32>{reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(FirstAddress)), sizeof(LDR_ENTRY32), process};
		while(entry.EntryPoint){
			LoadedImages.emplace_back(Loaded_Image{ entry, process });
			entry = *MemoryWrapper<LDR_ENTRY32>{reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(entry.InLoadOrderModuleList.Flink)), sizeof(LDR_ENTRY32), process};
		}
	}
}

bool Image_Loader::ContainsImage(const std::wstring& wImageName) const {
	for(auto image : LoadedImages){
		if(image.GetName() == wImageName){
			return true;
		}
	}
	return false;
}


std::optional<Loaded_Image> Image_Loader::GetImageInfo(const std::wstring& wImageName) const {
	for(auto image : LoadedImages){
		if(image.GetName() == wImageName){
			return image;
		}
	}
	return std::nullopt;
}

std::optional<Loaded_Image> Image_Loader::GetAssociatedImage(LPVOID address) const {
	for(auto image : LoadedImages){
		auto addr{ reinterpret_cast<ULONG_PTR>(address) };
		if(image.arch == x86 && static_cast<DWORD>(addr) >= image.image32->ImageAddress && 
		   static_cast<DWORD>(addr) < image.image32->ImageAddress + image.image32->ImageSize &&
		   static_cast<DWORD64>(addr) == static_cast<DWORD>(addr)){
			return image;
		} else if(image.arch == x64 && static_cast<DWORD64>(addr) >= image.image64->ImageAddress &&
				  static_cast<DWORD64>(addr) < image.image64->ImageAddress + image.image64->ImageSize){
			return image;
		}
	}
	return std::nullopt;
}
```

`BLUESPAWN-win-client/src/util/pe/Import_Section.cpp`:

```cpp
#include "util/pe/Import_Section.h"
#include "util/pe/PE_Image.h"
#include "util/pe/Image_Loader.h"
#include "util/StringUtils.h"

#include <queue>

bool LoadLibraries(const HandleWrapper& process, const std::set<std::wstring>& libs){
	Image_Loader loader = { process };
	std::queue<std::tuple<PE_Image*, MemoryWrapper<>, std::wstring>> images = {};
	std::set<std::wstring> ToImport = libs;
	
	// Perform a BFS on library dependency tree to import them all
	while(!ToImport.empty()){
		std::set<std::wstring> MoreLibs = {};
		for(auto lib : libs){
			if(!loader.ContainsImage(lib)){
				auto image = new PE_Image(lib);
				if(!image->ValidatePE()){
					return false;
				}

				images.emplace(std::tuple<PE_Image*, MemoryWrapper<>, std::wstring>{ image,
					VirtualAllocEx(process, nullptr, image->dwExpandSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE), lib });
				if(!loader.AddImage(Loaded_Image{ image, false, lib })){
					return false;
				}

				for(auto ImportLibrary : image->imports->GetRequiredLibraries()){
					if(!loader.ContainsImage(ImportLibrary) && libs.find(ImportLibrary) == libs.end()){
						MoreLibs.emplace(ImportLibrary);
					}
				}
			}
		}
		ToImport = MoreLibs;
	}

	// Process imports on all imported libraries.
	while(!images.empty()){
		auto info = images.front();
		images.pop();

		PE_Image* image = info._Myfirst._Val;
		MemoryWrapper<> address = info._Get_rest()._Myfirst._Val;
		std::wstring name = info._Get_rest()._Get_rest()._Myfirst._Val;

		if(image->LoadTo(address)){
			return false;
		}
		loader.MarkLoaded(name);
		delete image;
	}
	return true;
}

Import_Library::Import_Library(const PE_Image& image, const IMPORT_DIRECTORY_TABLE& ImportDirectoryTable) : image{ image }{
	DWORD dwNameOffset = image.expanded ? ImportDirectoryTable.dwNameRVA : image.RVAToOffset(ImportDirectoryTable.dwNameRVA);
	DWORD dwLookupTableOffset = image.expanded ? ImportDirectoryTable.dwImportLookupTableRVA : image.RVAToOffset(ImportDirectoryTable.dwImportLookupTableRVA);
	DWORD dwIATOffset = image.expanded ? ImportDirectoryTable.dwImportAddressTableRVA : image.RVAToOffset(ImportDirectoryTable.dwImportAddressTableRVA);;
	this->sLibraryName = StringToWidestring(image.base.GetOffset(dwNameOffset).ReadString());
	if(image.arch == x64){
		MemoryWrapper<IMPORT_LOOKUP_TABLE64> entry = image.base.GetOffset(dwLookupTableOffset).Convert<IMPORT_LOOKUP_TABLE64>();
		while(entry->value){
			Import i = {};
			if(entry->type){
				i = { true, static_cast<WORD>(entry->value), 0 };
			} else {
				DWORD dwHintOffset = image.expanded ? entry->value : image.RVAToOffset(entry->value);
				WORD hint = *image.base.GetOffset(dwHintOffset).Convert<WORD>();
				std::string name = image.base.GetOffset(dwHintOffset + 2).ReadString();
				i = { false, 0, {hint, name} };
			}
			vImportToIAT.emplace_back(std::pair<Import, DWORD>{ i, dwIATOffset });
			dwLookupTableOffset += 8;
			dwIATOffset += 8;
		}
	} else {
		MemoryWrapper<IMPORT_LOOKUP_TABLE32> entry = image.base.GetOffset(dwLookupTableOffset).Convert<IMPORT_LOOKUP_TABLE32>();
		while(entry->value){
			Import i = {};
			if(entry->type){
				i = { true, static_cast<WORD>(entry->value), 0 };
			} else {
				DWORD dwHintOffset = image.expanded ? entry->value : image.RVAToOffset(entry->value);
				WORD hint = *image.base.GetOffset(dwHintOffset).Convert<WORD>();
				std::string name = image.base.GetOffset(dwHintOffset + 2).ReadString();
				i = { false, 0, {hint, name} };
			}
			vImportToIAT.emplace_back(std::pair<Import, DWORD>{ i, dwIATOffset });
			dwLookupTableOffset += 4;
			dwIATOffset += 4;
		}
	}
}

bool Import_Library::LoadImportLibrary(const HandleWrapper& context){
	auto info = Image_Loader(context).GetImageInfo(sLibraryName);
	if(!info.has_value()){
		return false;
	}

	auto& TargetImage = info->GetImage();
	for(auto pair : vImportToIAT){
		auto im = pair.first;
		auto offset = pair.second;
		if(im.IsOrdinal){
			if(image.arch == x64){
				DWORD64 address = TargetImage.exports->GetExportAddress(im.ordinal);
				if(!address){
					return false;
				}

				image.base.Write(reinterpret_cast<CHAR*>(&address), sizeof(address), offset);
			}
		}
	}
	return true;
}

Import_Section::Import_Section(const PE_Section& section) : PE_Section{ section } {
	MemoryWrapper<IMPORT_DIRECTORY_TABLE> table = SectionContent.Convert<IMPORT_DIRECTORY_TABLE>();
	while((*table).dwImportLookupTableRVA){
		imports.emplace_back(Import_Library{ section.AssociatedImage, *table });
	}
}

bool Import_Section::LoadAllImports(const HandleWrapper& context){
	std::set<std::wstring> images = {};

	if(!LoadLibraries(context, GetRequiredLibraries())) return false;

	for(auto lib : imports){
		if(!lib.LoadImportLibrary(context)) return false;
	}
	return true;
}

std::set<std::wstring> Import_Section::GetRequiredLibraries() const {
	std::set<std::wstring> names = {};
	for(auto lib : imports){
		names.emplace(lib.sLibraryName);
	}
	return names;
}
```

`BLUESPAWN-win-client/src/util/pe/PE_Image.cpp`:

```cpp
#include "util/pe/PE_Image.h"
#include "util/pe/PE_Section.h"
#include "util/wrappers.hpp"

bool PE_Image::ValidatePE() const {
	MemoryWrapper<> PESignature = { new BYTE[2]{0x4D, 0x5A}, 2 };
	MemoryWrapper<> PE2Signature = { new BYTE[4]{0x50, 0x45, 0x00, 0x00}, 4 };
	return base.CompareMemory(PESignature) && base.GetOffset(base.Convert<IMAGE_DOS_HEADER>()->e_lfanew).CompareMemory(PE2Signature);
}

IMAGE_SECTION_HEADER CreateVirtualHeader(std::string name, DWORD dwRVA, DWORD dwSize, DWORD dwRawAddress){
	IMAGE_SECTION_HEADER VirtualHeader = { 0, 0, 0, 0, 0, 0, 0, 0, dwSize, dwRVA, dwSize, dwRawAddress, 0, 0, 0, 0, IMAGE_SCN_MEM_READ };
	for(int idx = 0; idx < name.length(); idx++){
		VirtualHeader.Name[idx] = static_cast<BYTE>(name.at(idx));
	}
	return VirtualHeader;
}

PE_Image::PE_Image(LPVOID lpBaseAddress, HANDLE hProcess, bool expanded, std::optional<std::wstring> swzImageName,
	std::optional<std::wstring> swzImagePath) : 
	expanded{ expanded },
	base{ nullptr },
	BaseAddress{ nullptr },
	relocations{ nullptr },
	imports{ nullptr },
	exports{ nullptr },
	resources{ nullptr },
	swzImageName{ swzImageName },
	swzImagePath{ swzImagePath }{
	MemoryWrapper<IMAGE_DOS_HEADER> dos = { lpBaseAddress, sizeof(IMAGE_DOS_HEADER), hProcess };

	DWORD NTHeaderOffset = dos->e_lfanew;

	MemoryWrapper<WORD> NTHeaderStart = { lpBaseAddress, NTHeaderOffset + 3 * sizeof(WORD), hProcess };
	WORD architecture = *NTHeaderStart.GetOffset(NTHeaderOffset).GetOffset(2 * sizeof(WORD));
	arch = architecture == IMAGE_FILE_MACHINE_I386 ? x86 : x64;

	auto NTHeaders32 = *MemoryWrapper<IMAGE_NT_HEADERS32>{ NTHeaderStart, sizeof(IMAGE_NT_HEADERS32), hProcess };
	auto NTHeaders64 = *MemoryWrapper<IMAGE_NT_HEADERS64>{ NTHeaderStart, sizeof(IMAGE_NT_HEADERS64), hProcess };

	this->BaseAddress = arch == 64 ? MemoryWrapper<>{&(NTHeaderStart.Convert<IMAGE_NT_HEADERS64>()->OptionalHeader.ImageBase), 8, hProcess} :
		MemoryWrapper<>{ &(NTHeaderStart.Convert<IMAGE_NT_HEADERS32>()->OptionalHeader.ImageBase), 4, hProcess };

	this->dwExpandSize = arch == x64 ? NTHeaders64.OptionalHeader.SizeOfImage : NTHeaders32.OptionalHeader.SizeOfImage;
	this->dwHeaderSize = arch == x64 ? NTHeaders64.OptionalHeader.SizeOfHeaders : NTHeaders32.OptionalHeader.SizeOfHeaders;
	this->dwEntryPoint = arch == x64 ? NTHeaders64.OptionalHeader.AddressOfEntryPoint : NTHeaders32.OptionalHeader.AddressOfEntryPoint;

	this->sections = {};
	MemoryWrapper<IMAGE_SECTION_HEADER> SectionHeaders = {
		NTHeaderStart.GetOffset(arch == x64 ? sizeof(NTHeaders64) : sizeof(NTHeaders32)),
		(arch == x64 ? NTHeaders64.FileHeader.NumberOfSections : NTHeaders32.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER),
		hProcess
	};

	do sections.emplace(PCHAR(SectionHeaders->Name), PE_Section{ *this, *SectionHeaders, MemoryWrapper<>{ lpBaseAddress, 0xFFFFFFFF, hProcess}, expanded });
	while(SectionHeaders = SectionHeaders.GetOffset(sizeof(IMAGE_SECTION_HEADER)));

	for(auto entry : sections){
		IMAGE_SECTION_HEADER header = entry.second;
		this->dwImageSize = max(dwImageSize, header.PointerToRawData + header.SizeOfRawData);
	}

	this->base = { lpBaseAddress, expanded ? dwExpandSize : dwImageSize, hProcess };

	DWORD dwExportSize = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	DWORD dwExportRVA = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	this->exports = new Export_Section(PE_Section(*this, CreateVirtualHeader(".edata", dwExportRVA, dwExportSize, RVAToOffset(dwExportRVA)), base, expanded));

	DWORD dwImportSize = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
	DWORD dwImportRVA = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	this->imports = new Import_Section(PE_Section(*this, CreateVirtualHeader(".idata", dwImportRVA, dwImportSize, RVAToOffset(dwImportRVA)), base, expanded));

	DWORD dwRelocSize = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
	DWORD dwRelocRVA = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
	this->relocations = new Relocation_Section(PE_Section(*this, CreateVirtualHeader(".reloc", dwRelocRVA, dwRelocSize, RVAToOffset(dwRelocRVA)), base, expanded));

	DWORD dwResourceSize = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
	DWORD dwResourceRVA = arch == x64 ? NTHeaders64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress :
		NTHeaders32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
	this->resources = new Resource_Section(PE_Section(*this, CreateVirtualHeader(".rsrc", dwResourceRVA, dwResourceSize, RVAToOffset(dwResourceRVA)), base, expanded));
}

std::optional<PE_Image> PE_Image::LoadTo(MemoryWrapper<> location, bool AvoidTargetChanges){
	if(location.MemorySize < dwExpandSize || !ValidatePE()){
		return std::nullopt;
	} else {
		if(AvoidTargetChanges){
			if(!ApplyLocalRelocations(reinterpret_cast<DWORD64>(location.address) - BaseAddress)) return std::nullopt;
			if(!ParseLocalImports(location.process)) return std::nullopt;
			if(!location.Write(base, dwHeaderSize, 0)) return std::nullopt;

			for(auto section : sections){
				if(!location.Write(section.second.SectionContent, section.second.SectionContent.MemorySize, 0)) return std::nullopt;
			}
		} else {
			if(!location.Write(base, dwHeaderSize, 0)) return std::nullopt;

			for(auto section : sections){
				if(!location.Write(section.second.SectionContent, section.second.SectionContent.MemorySize, 0)) return std::nullopt;
			}

			if(!ApplyTargetRelocations(location)) return std::nullopt;
			if(!ParseTargetImports(location)) return std::nullopt;
		}

		if(!ApplyProtections(location)) return std::nullopt;

		return std::optional<PE_Image>{PE_Image{ location.address, location.process, true }};
	}
}

bool PE_Image::ApplyLocalRelocations(DWORD64 offset){
	if(!ValidatePE() || relocations->GetSignature() != L".reloc"){
		return false;
	}

	if(expanded){
		return ApplyTargetRelocations(base);
	}

	if(arch == x64) {
		BaseAddress.Convert<DWORD64>().Write(&offset);
	} else {
		DWORD off32 = static_cast<DWORD>(offset);
		BaseAddress.Convert<DWORD>().Write(&off32);
	}

	auto RelocRVAs = relocations->GetRelocRVAs();

	for(auto rva : RelocRVAs){
		rva = relocations->ConvertRVAToOffset(rva);

		DWORD64 PatchedMemory64 = offset + *base.GetOffset(rva).Convert<DWORD64>();
		DWORD PatchedMemory32 = static_cast<DWORD>(offset + *base.GetOffset(rva).Convert<DWORD>());
		if(!base.Write(arch == x64 ? (PCHAR) &PatchedMemory64 : (PCHAR) &PatchedMemory32, arch == x64 ? 8 : 4, rva)){
			return false;
		}
	}

	return true;
}

bool PE_Image::ApplyTargetRelocations(MemoryWrapper<> TargetLocation) const {
	DWORD64 offset = reinterpret_cast<DWORD64>(TargetLocation.address) - BaseAddress;

	if(relocations->GetSignature() != L".reloc"){
		return false;
	}

	auto RelocRVAs = relocations->GetRelocRVAs();

	DWORD BaseOffset = static_cast<DWORD>(reinterpret_cast<DWORD64>(BaseAddress.address) - reinterpret_cast<DWORD64>(base.address));
	if(arch == x64) {
		TargetLocation.Convert<DWORD64>().Write(&offset, 8, BaseOffset);
	} else {
		DWORD off32 = static_cast<DWORD>(offset);
		TargetLocation.Convert<DWORD>().Write(&off32, 4, BaseOffset);
	}

	for(auto rva : RelocRVAs){
		DWORD64 PatchedMemory64 = offset + *base.GetOffset(rva).Convert<DWORD64>();
		DWORD PatchedMemory32 = static_cast<DWORD>(offset + *base.GetOffset(rva).Convert<DWORD>());
		if(!TargetLocation.Write(arch == x64 ? (PCHAR) &PatchedMemory64 : (PCHAR) &PatchedMemory32, arch == x64 ? 8 : 4, rva)){
			return false;
		}
	}

	return true;
}

bool PE_Image::ParseLocalImports(HandleWrapper process){
	return imports->LoadAllImports(process);
}

bool PE_Image::ParseTargetImports(MemoryWrapper<> TargetLocation) const {
	return imports->LoadAllImports(TargetLocation.process);
}

bool PE_Image::ApplyProtections(MemoryWrapper<> TargetLocation) const {
	TargetLocation.Protect(PAGE_READONLY);

	DWORD dwProtectionMap[8]{
		PAGE_NOACCESS,           PAGE_READONLY,
		PAGE_READWRITE,          PAGE_READWRITE,

		PAGE_EXECUTE,            PAGE_EXECUTE_READ,
		PAGE_EXECUTE_WRITECOPY,  PAGE_EXECUTE_READWRITE,
	};

	for(auto pair : sections){
		DWORD dwProtIdx = ((pair.second.SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) ? 4 : 0) +
			((pair.second.SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE) ? 2 : 0) +
			((pair.second.SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) ? 1 : 0);
		DWORD protection = dwProtectionMap[dwProtIdx];
		protection |= (pair.second.SectionHeader.Characteristics & IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOACCESS : 0;
		if(!TargetLocation.GetOffset(pair.second.SectionHeader.VirtualAddress).Protect(protection, pair.second.SectionHeader.SizeOfRawData)){
			return false;
		}
	}
	return true;
}

DWORD PE_Image::RVAToOffset(DWORD rva) const {
	for(auto pair : sections){
		if(pair.second.ContainsRVA(rva)){
			return pair.second.ConvertRVAToOffset(rva);
		}
	}

	return rva;
}

DWORD PE_Image::OffsetToRVA(DWORD offset) const {
	for(auto pair : sections){
		if(pair.second.ContainsOffset(offset)){
			return pair.second.ConvertOffsetToRVA(offset);
		}
	}

	return offset;
}
```

`BLUESPAWN-win-client/src/util/pe/PE_Section.cpp`:

```cpp
#include "util/pe/PE_Section.h"
#include "util/pe/PE_Image.h"

#include <Windows.h>

#include <string>

PE_Section::PE_Section(const PE_Image& image, IMAGE_SECTION_HEADER SectionHeader, MemoryWrapper<> lpImageBase, bool expanded) : 
	AssociatedImage{ image },
	expanded{ expanded },
	SectionContent{ lpImageBase.GetOffset(expanded ? SectionHeader.VirtualAddress : SectionHeader.PointerToRawData) }{
	this->SectionHeader = SectionHeader;

	WCHAR signature[9]{};
	for(int i = 0; i < 8; i++){
		signature[i] = SectionHeader.Name[i];
	}

	this->Signature = signature;
}

PE_Section::PE_Section(const PE_Section& copy) :
	SectionHeader{ detection->SectionHeader },
	SectionContent{ detection->SectionContent },
	Signature{ detection->Signature },
	AssociatedImage{ detection->AssociatedImage },
	expanded{ detection->expanded }{}

bool PE_Section::ContainsOffset(DWORD offset) const {
	return offset >= SectionHeader.PointerToRawData && offset < SectionHeader.PointerToRawData + SectionHeader.SizeOfRawData;
}

bool PE_Section::ContainsRVA(DWORD rva) const {
	return rva >= SectionHeader.VirtualAddress && rva < SectionHeader.VirtualAddress + SectionHeader.SizeOfRawData;
}

DWORD PE_Section::ConvertOffsetToRVA(DWORD offset) const {
	return ContainsOffset(offset) ? offset - SectionHeader.PointerToRawData + SectionHeader.VirtualAddress : 0;
}

DWORD PE_Section::ConvertRVAToOffset(DWORD offset) const {
	return ContainsRVA(offset) ? offset - SectionHeader.VirtualAddress + SectionHeader.SizeOfRawData : 0;
}

std::wstring PE_Section::GetSignature() const {
	return Signature;
}

PE_Section::operator IMAGE_SECTION_HEADER() const {
	return SectionHeader;
}
```

`BLUESPAWN-win-client/src/util/pe/Relocation_Section.cpp`:

```cpp
#include "util/pe/Relocation_Section.h"

#include <Windows.h>

#include "util/pe/PE_Section.h"

Relocation_Entry::Relocation_Entry(RelocEntry entry, const Relocation_Block& block) : block{ block }{
	this->type = entry.type;
	this->offset = entry.offset;
}

DWORD Relocation_Entry::GetRVA(){
	// TODO: Add more than the trivial case!
	if(type != 0){
		return block.rva + offset;
	} else return 0;
}

Relocation_Block::Relocation_Block(DWORD offset, DWORD size, MemoryWrapper<RelocEntry> memory){
	for(unsigned int i = 0; i < size; i += sizeof(RelocEntry)){
		entries.emplace_back(memory.GetOffset(i).Dereference(), *this);
	}
}

std::vector<DWORD> Relocation_Block::GetRelocRVAs(){
	std::vector<DWORD> RVAs = {};
	for(auto entry : entries){
		if(entry.type != 0){
			RVAs.emplace_back(entry.GetRVA());
		}
	}
	return RVAs;
}

Relocation_Section::Relocation_Section(const PE_Section& section) : PE_Section(section) {
	RelocBlock BlockInfo = { 1, 1 };
	for(DWORD offset = 0; offset < section.SectionHeader.SizeOfRawData && BlockInfo.dwBlockSize != 0 && BlockInfo.dwRelocationOffset != 0; offset += BlockInfo.dwBlockSize){
		BlockInfo = *section.SectionContent.GetOffset(offset).Convert<RelocBlock>();
		Relocation_Block block = { BlockInfo.dwRelocationOffset, BlockInfo.dwBlockSize, section.SectionContent.GetOffset(offset + 8).Convert<RelocEntry>() };
		vRelocationBlocks.emplace_back(block);
	}
};

std::vector<DWORD> Relocation_Section::GetRelocRVAs(){
	std::vector<DWORD> RVAs = {};
	for(auto block : vRelocationBlocks){
		for(auto entry : block.GetRelocRVAs()){
			RVAs.emplace_back(entry);
		}
	}

	return RVAs;
}
```

`BLUESPAWN-win-client/src/util/permissions/permissions.cpp`:

```cpp
#include "util/permissions/permissions.h"
#include "util/log/Log.h"
#include <lm.h>


namespace Permissions {

	bool AccessIncludesAll(const ACCESS_MASK& access) {
		return ((access & GENERIC_ALL) == GENERIC_ALL) ||
			((access & FILE_ALL_ACCESS) == FILE_ALL_ACCESS);
	}

	bool AccessIncludesWrite(const ACCESS_MASK& access) {
		return AccessIncludesAll(access) || 
			((access & GENERIC_WRITE) == GENERIC_WRITE) ||
			((access & FILE_GENERIC_WRITE) == FILE_GENERIC_WRITE);
	}
	
	bool AccessIncludesRead(const ACCESS_MASK& access) {
		return AccessIncludesAll(access) || 
			((access & GENERIC_READ) == GENERIC_READ) || 
			((access & FILE_GENERIC_READ) == FILE_GENERIC_READ);
	}
	
	bool AccessIncludesExecute(const ACCESS_MASK& access) {
		return AccessIncludesAll(access) || 
			((access & GENERIC_EXECUTE) == GENERIC_EXECUTE) ||
			((access & FILE_GENERIC_EXECUTE) == FILE_GENERIC_EXECUTE);
	}

	bool AccessIncludesWriteOwner(const ACCESS_MASK& access) {
		return AccessIncludesAll(access) || 
			((access & WRITE_OWNER) == WRITE_OWNER);
	}

	bool AccessContainsDelete(const ACCESS_MASK& access) {
		return AccessIncludesAll(access) ||
			((access & DELETE) == DELETE);
	}

	void AccessAddAll(ACCESS_MASK& access) {
		access |= GENERIC_ALL;
	}

	void AccessAddWrite(ACCESS_MASK& access) {
		access |= GENERIC_WRITE;
	}

	void AccessAddRead(ACCESS_MASK& access) {
		access |= GENERIC_READ;
	}

	void AccessAddExecute(ACCESS_MASK& access) {
		access |= GENERIC_EXECUTE;
	}

	void AccessAddWriteOwner(ACCESS_MASK& access) {
		access |= WRITE_OWNER;
	}

	void AccessAddDelete(ACCESS_MASK& access) {
		access |= DELETE;
	}

	ACCESS_MASK GetOwnerRightsFromACL(const Owner& owner, const SecurityDescriptor& acl) {
		TRUSTEE_W tOwnerTrustee;
		BuildTrusteeWithSidW(&tOwnerTrustee, owner.GetSID());
		ACCESS_MASK amAccess{ 0 };
		auto dacl = acl.GetDACL();
		auto x{ GetLastError() };
		HRESULT hr = GetEffectiveRightsFromAclW(dacl, &tOwnerTrustee, &amAccess);
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Error getting rights from acl with owner " << owner << ". ERROR: " << hr );
			return 0;
		}
		return amAccess;
	}

	bool UpdateObjectACL(const std::wstring& wsObjectName, SE_OBJECT_TYPE seObjectType, const Owner& oOwner, ACCESS_MASK amDesiredAccess, bool bDeny) {
		PACL pOldDacl;
		PSECURITY_DESCRIPTOR pDesc{ nullptr };
		HRESULT hr = GetNamedSecurityInfoW(reinterpret_cast<LPCWSTR>(wsObjectName.c_str()), seObjectType, DACL_SECURITY_INFORMATION, nullptr, nullptr, &pOldDacl, nullptr, &pDesc);
		AllocationWrapper awDesc{ pDesc, 0, AllocationWrapper::LOCAL_ALLOC };
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Couldn't read current DACL for object " << wsObjectName << ". (Error " << hr << ")");
			SetLastError(hr);
			return false;
		}
		ACCESS_MODE amAccessMode = bDeny ? DENY_ACCESS : GRANT_ACCESS;
		EXPLICIT_ACCESS ea;
		ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
		ea.grfAccessPermissions = amDesiredAccess;
		ea.grfAccessMode = amAccessMode;
		ea.grfInheritance = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
		BuildTrusteeWithSidW(&ea.Trustee, oOwner.GetSID());

		PACL pNewDacl{ nullptr };
		hr = SetEntriesInAcl(1, &ea, pOldDacl, &pNewDacl);
		AllocationWrapper awNewDacl{ pNewDacl, 0, AllocationWrapper::LOCAL_ALLOC };
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Couldn't update DACL for object " << wsObjectName << ". (Error " << hr << ")");
			SetLastError(hr);
			return false;
		}

		hr = SetNamedSecurityInfoW(const_cast<LPWSTR>(wsObjectName.c_str()), seObjectType,
			DACL_SECURITY_INFORMATION,
			NULL, NULL, pNewDacl, NULL);
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Couldn't set new DACL for object " << wsObjectName << ". (Error " << hr << ")");
			SetLastError(hr);
			return false;
		}
		return true;
	}


	SecurityDescriptor::SecurityDescriptor(DWORD dwSize, SecurityDescriptor::SecurityDataType type) :
		GenericWrapper<PISECURITY_DESCRIPTOR>(reinterpret_cast<PISECURITY_DESCRIPTOR>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize)),
			[](LPVOID memory) { HeapFree(GetProcessHeap(), 0, memory); }, nullptr) {
		switch (type) {
		case SecurityDescriptor::SecurityDataType::USER_SID:
			lpUserSID = reinterpret_cast<PSID>(*ReferenceCounter);
			break;
		case SecurityDescriptor::SecurityDataType::GROUP_SID:
			lpGroupSID = reinterpret_cast<PSID>(*ReferenceCounter);
			break;
		case SecurityDescriptor::SecurityDataType::DACL:
			dacl = reinterpret_cast<PACL>(*ReferenceCounter);
			break;
		case SecurityDescriptor::SecurityDataType::SACL:
			sacl = reinterpret_cast<PACL>(*ReferenceCounter);
			break;
		}
	}

	SecurityDescriptor::SecurityDescriptor(PISECURITY_DESCRIPTOR lpSecurity) :
		GenericWrapper<PISECURITY_DESCRIPTOR>(lpSecurity, LocalFree, nullptr) {
		if (lpSecurity) {
			lpUserSID = lpSecurity->Owner;
			lpGroupSID = lpSecurity->Group;
			dacl = lpSecurity->Dacl;
			sacl = lpSecurity->Sacl;
		}
	}

	SecurityDescriptor SecurityDescriptor::CreateUserSID(DWORD dwSize) {
		return SecurityDescriptor(dwSize, SecurityDescriptor::SecurityDataType::USER_SID);
	}

	SecurityDescriptor SecurityDescriptor::CreateGroupSID(DWORD dwSize) {
		return SecurityDescriptor(dwSize, SecurityDescriptor::SecurityDataType::GROUP_SID);
	}

	SecurityDescriptor SecurityDescriptor::CreateDACL(DWORD dwSize) {
		return SecurityDescriptor(dwSize, SecurityDescriptor::SecurityDataType::DACL);
	}

	SecurityDescriptor SecurityDescriptor::CreateSACL(DWORD dwSize) {
		return SecurityDescriptor(dwSize, SecurityDescriptor::SecurityDataType::SACL);
	}

	PACL SecurityDescriptor::GetDACL() const { return this->dacl; }
	PACL SecurityDescriptor::GetSACL() const { return this->sacl; }
	PSID SecurityDescriptor::GetUserSID() const { return this->lpUserSID; }
	PSID SecurityDescriptor::GetGroupSID() const { return this->lpGroupSID; }

	LsaHandleWrapper::LsaHandleWrapper(LSA_HANDLE handle) :
		GenericWrapper(handle, std::function<void(LSA_HANDLE)>(SafeCloseLsaHandle), nullptr) {}

	LsaHandleWrapper::LsaHandleWrapper(LSA_HANDLE handle, std::function<void(LSA_HANDLE)> fSafeClose) : 
		GenericWrapper(handle, std::function<void(LSA_HANDLE)>(fSafeClose), nullptr) {}

	bool Owner::bPolicyInitialized{ false };
	LsaHandleWrapper Owner::lPolicyHandle{ nullptr };
	const std::vector<std::wstring> Owner::vSuperUserPrivs{ SE_DEBUG_NAME, SE_IMPERSONATE_NAME, SE_TCB_NAME, SE_LOAD_DRIVER_NAME,
			SE_ASSIGNPRIMARYTOKEN_NAME, SE_TAKE_OWNERSHIP_NAME };

	void LsaHandleWrapper::SafeCloseLsaHandle(LSA_HANDLE handle) {
		LsaClose(handle);
	}

	void Owner::InitializePolicy() {
		LSA_HANDLE lTempPolicyHandle;
		LSA_OBJECT_ATTRIBUTES lObjectAttr{};
		HRESULT hr = LsaNtStatusToWinError(LsaOpenPolicy(nullptr, &lObjectAttr, GENERIC_ALL, &lTempPolicyHandle));
		if (hr != ERROR_SUCCESS) {
			bPolicyInitialized = false;
			LOG_ERROR("Couldn't open policy handle. (Error:" << hr << ")");
			SetLastError(hr);
		}
		else {
			lPolicyHandle = { lTempPolicyHandle, std::function<void(LSA_HANDLE)>(Owner::DeinitializePolicy) };
			bPolicyInitialized = true;
		}
	}

	void Owner::DeinitializePolicy(LSA_HANDLE handle) {
		LsaClose(handle);
		bPolicyInitialized = false;
	}

	std::shared_ptr<LSA_UNICODE_STRING> Owner::WStringToLsaUnicodeString(IN const std::wstring& str) {
		LSA_UNICODE_STRING lsaWStr{};
		DWORD len = 0;
		len = str.length();
		PWCHAR cstr = new WCHAR[len + 1];
		MoveMemory(cstr, str.c_str(), (len + 1) * sizeof(WCHAR));
		lsaWStr.Buffer = cstr;
		lsaWStr.Length = (USHORT)((len) * sizeof(WCHAR));
		lsaWStr.MaximumLength = (USHORT)((len + 1) * sizeof(WCHAR));
		return std::shared_ptr<LSA_UNICODE_STRING>{ new LSA_UNICODE_STRING(lsaWStr), [](auto* object) {delete[] object->Buffer; delete object; }};
	}

	std::wstring Owner::LsaUnicodeStringToWString(IN const LSA_UNICODE_STRING& str) {
		return { str.Buffer };
	}

	Owner::Owner(IN const std::wstring& name) : wName{ name }, bExists{ true } {
		DWORD dwSIDLen{};
		DWORD dwDomainLen{};
		SID_NAME_USE SIDType{};
		LookupAccountNameW(nullptr, wName.c_str(), nullptr, &dwSIDLen, nullptr, &dwDomainLen, &SIDType);
		SecurityDescriptor tempSID = SecurityDescriptor::CreateUserSID(dwSIDLen);
		std::vector<WCHAR> Domain(dwDomainLen);
		DWORD dwTempDomainLen = dwDomainLen;
		DWORD dwTempSIDLen = dwSIDLen;
		LookupAccountNameW(nullptr, wName.c_str(), tempSID.GetUserSID(), &dwTempSIDLen, Domain.data(), &dwTempDomainLen, &SIDType);

		if (SIDType == SidTypeUser || SIDType == SidTypeDeletedAccount) {
			otType = OwnerType::USER;
			LOG_VERBOSE(3, "Owner with name " << wName << " is a user.");
			sdSID = SecurityDescriptor::CreateUserSID(dwSIDLen);
			if (!LookupAccountNameW(nullptr, wName.c_str(), sdSID.GetUserSID(), &dwSIDLen, Domain.data(), &dwDomainLen, &SIDType)) {
				LOG_ERROR("Error getting user with name " << wName << " " << GetLastError());
				bExists = false;
			}
			else {
				wDomainName = std::wstring(Domain.data());
				if (SIDType == SidTypeDeletedAccount) {
					LOG_VERBOSE(2, "User with name " << wName << " has been deleted.");
					bExists = false;
				}
				else if (SIDType != SidTypeUser) {
					LOG_VERBOSE(2, "User with name " << wName << " does not exist.");
					bExists = false;
				}
				else {
					LOG_VERBOSE(3, "User with name " << wName << " found.");
				}
			}
		}
		else if (SIDType == SidTypeGroup || SIDType == SidTypeWellKnownGroup || SIDType == SidTypeAlias) {
			otType = OwnerType::GROUP;
			if (SIDType == SidTypeWellKnownGroup) {
				LOG_VERBOSE(3, "Owner with name " << wName << " is a well known group.");
			}
			else {
				LOG_VERBOSE(3, "Owner with name " << wName << " is a group.");
			}
			sdSID = SecurityDescriptor::CreateGroupSID(dwSIDLen);
			if (!LookupAccountNameW(nullptr, wName.c_str(), sdSID.GetGroupSID(), &dwSIDLen, Domain.data(), &dwDomainLen, &SIDType)) {
				LOG_ERROR("Error getting group with name " << wName << " " << GetLastError());
				bExists = false;
			}
			else {
				wDomainName = std::wstring(Domain.data());
				LOG_VERBOSE(3, "Group with name " << wName << " exists.");
			}
		}
		else {
			otType = OwnerType::NONE;
			LOG_ERROR("Name " << wName << " does not correspond to a known owner type.");
			bExists = false;
		}
	}

	Owner::Owner(IN const SecurityDescriptor& sid) : sdSID{ sid }, bExists{ true } {
		DWORD dwDomainLen{};
		DWORD dwNameLen{};
		SID_NAME_USE SIDType{ SidTypeUnknown };
		LookupAccountSidW(nullptr, sdSID.GetUserSID(), nullptr, &dwNameLen, nullptr, &dwDomainLen, &SIDType);

		std::vector<WCHAR> Domain(dwDomainLen);
		std::vector<WCHAR> Name(dwNameLen);

		if (!LookupAccountSid(nullptr, sdSID.GetUserSID(), Name.data(), &dwNameLen, Domain.data(), &dwDomainLen, &SIDType)) {
			LOG_ERROR("Error getting owner " << GetLastError());
			bExists = false;
		}
		else {
			wDomainName = std::wstring(Domain.data());
			wName = std::wstring(Name.data());
			if (SIDType == SidTypeDeletedAccount) {
				otType = OwnerType::USER;
				LOG_VERBOSE(2, "User " << wName << " has been deleted.");
				bExists = false;
			}
			else if (SIDType == SidTypeGroup || SIDType == SidTypeWellKnownGroup || SIDType == SidTypeAlias) {
				LOG_VERBOSE(2, "Group " << wName << " exists.");
				otType = OwnerType::GROUP;
				auto temp = SecurityDescriptor::CreateGroupSID(GetLengthSid(sdSID.GetUserSID()));
				MoveMemory(temp.GetGroupSID(), sdSID.GetUserSID(), GetLengthSid(sdSID.GetUserSID()));
				sdSID = temp;
			}
			else if (SIDType == SidTypeUser) {
				LOG_VERBOSE(3, "User " << wName << " Exists.");
				otType = OwnerType::USER;
			}
			else {
				otType = OwnerType::NONE;
				LOG_ERROR("Unknown owner type.");
				bExists = false;
			}
		}
	}

	Owner::Owner(IN const std::wstring& name, IN bool exists, IN OwnerType type) : wName{ name }, bExists{ exists }, otType{ type } {}

	Owner::Owner(IN const SecurityDescriptor& sid, IN bool exists, IN OwnerType type) : sdSID{ sid }, bExists{ exists }, otType{ type } {}

	Owner::Owner(IN const std::wstring& name, IN const std::wstring& domain, IN const SecurityDescriptor& sid, IN bool exists, IN OwnerType type) :
		wName{ name }, wDomainName{ domain }, sdSID{ sid }, bExists{ exists }, otType{ type } {}

	bool Owner::Exists() const {
		return bExists;
	}

	std::wstring Owner::GetName() const {
		return wName;
	}

	std::wstring Owner::GetDomainName() const {
		return wDomainName;
	}

	PSID Owner::GetSID() const {
		if (otType == OwnerType::USER) return sdSID.GetUserSID();
		return sdSID.GetGroupSID();
	}

	OwnerType Owner::GetOwnerType() const {
		return otType;
	}

	std::wstring Owner::ToString() const {
		return wName;
	}

	std::vector<std::wstring> Owner:: GetPrivileges() {
		//Ensure policy handle is initialized
		if (!bPolicyInitialized) {
			InitializePolicy();
			if (!bPolicyInitialized) {
				LOG_ERROR("Error getting owner privliges, couldn't initialize policy handle.");
				return std::vector<std::wstring>{ };
			}
		}
		PLSA_UNICODE_STRING pReceivedPrivs{ nullptr };
		ULONG uPrivCount{ 0 };
		std::vector<std::wstring> vPrivs{ };
		auto hr = LsaNtStatusToWinError(LsaEnumerateAccountRights(lPolicyHandle, GetSID(), &pReceivedPrivs, &uPrivCount));
		AllocationWrapper awReceivedPrivsHandler{ pReceivedPrivs, 0, AllocationWrapper::NET_ALLOC };
		if (hr != ERROR_SUCCESS && otType != OwnerType::USER) {
			LOG_ERROR("Error getting owner privileges. (Error: " << GetLastError() << ")");
			SetLastError(hr);
			return std::vector<std::wstring>{ };
		}
		else if (hr == ERROR_SUCCESS) {
			for (int i = 0; i < uPrivCount; i++) {
				vPrivs.emplace_back(LsaUnicodeStringToWString(pReceivedPrivs[i]));
			}
		}
		//Get privileges from groups that a user belongs to
		if (otType == OwnerType::USER) {
			PGROUP_USERS_INFO_0 pGroupInfo{ nullptr };
			DWORD dEntriesRead{ 0 };
			DWORD dEntriesTotal{ 0 };
			NET_API_STATUS stat = NetUserGetLocalGroups(wDomainName.c_str(), wName.c_str(), 0, LG_INCLUDE_INDIRECT , reinterpret_cast<LPBYTE *>(&pGroupInfo), MAX_PREFERRED_LENGTH, &dEntriesRead, &dEntriesTotal);
			AllocationWrapper awGroupInfoHandler{ pGroupInfo, sizeof(GROUP_USERS_INFO_0) * dEntriesRead, AllocationWrapper::NET_ALLOC };
			if (stat != NERR_Success) {
				LOG_ERROR("Error getting user groups. (Net Error: " << stat << ")");
				return vPrivs;
			}
			//Add all privileges from groups to list of user's privileges
			for (int i = 0; i < dEntriesRead; i++) {
				Owner oGroup{ pGroupInfo[i].grui0_name };
				hr = LsaNtStatusToWinError(LsaEnumerateAccountRights(lPolicyHandle, oGroup.GetSID(), &pReceivedPrivs, &uPrivCount));
				awReceivedPrivsHandler = { pReceivedPrivs, 0, AllocationWrapper::NET_ALLOC };
				if (hr != ERROR_SUCCESS) {
					LOG_ERROR("Error getting group privileges. (Error: " << GetLastError() << ")");
				}
				else {
					for (int i = 0; i < uPrivCount; i++) {
						vPrivs.emplace_back(LsaUnicodeStringToWString(pReceivedPrivs[i]));
					}
				}
			}
		}
		SetLastError(ERROR_SUCCESS);
		return vPrivs;
	}

	bool Owner::HasPrivilege(IN const std::wstring& wPriv) {
		auto vOwnerPrivs = GetPrivileges();
		for (auto iter = vOwnerPrivs.begin(); iter != vOwnerPrivs.end(); iter++) {
			if (wPriv.compare(WStringToLsaUnicodeString(*iter)->Buffer) == 0) return true;
		}
		return false;
	}


	std::vector<Owner> Owner::GetOwnersWithPrivilege(IN const std::wstring& wPriv) {
		//Ensure policy handle is initialized
		if (!bPolicyInitialized) {
			InitializePolicy();
			if (!bPolicyInitialized) {
				LOG_ERROR("Error getting owners with privlige, couldn't initialize policy handle.");
				return std::vector<Owner>{ };
			}
		}
		LSA_UNICODE_STRING lPrivName = *WStringToLsaUnicodeString(wPriv);
		PLSA_ENUMERATION_INFORMATION pOwners{ nullptr };
		ULONG uNumOwners{ 0 };
		auto hr = LsaNtStatusToWinError(LsaEnumerateAccountsWithUserRight(lPolicyHandle, &lPrivName, reinterpret_cast<PVOID *>(&pOwners), &uNumOwners));
		AllocationWrapper awOwnersHandler{ pOwners, 0, AllocationWrapper::NET_ALLOC };
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Error getting accounts with user privilege. (Error: " << hr << ")");
			SetLastError(hr);
			return std::vector<Owner>{ };
		}
		std::vector<Owner> vOwners;
		for (int i = 0; i < uNumOwners; i++) {
			DWORD dwSidLen = GetLengthSid(pOwners[i].Sid);
			SecurityDescriptor sdSID = SecurityDescriptor::CreateUserSID(dwSidLen);
			MoveMemory(sdSID.GetUserSID(), pOwners[i].Sid, dwSidLen);
			vOwners.emplace_back(Owner{ sdSID });
		}
		SetLastError(ERROR_SUCCESS);
		return vOwners;
	}

	bool Owner::RemovePrivilege(IN const std::wstring& wPriv) {
		//Ensure policy handle is initialized
		if (!bPolicyInitialized) {
			InitializePolicy();
			if (!bPolicyInitialized) {
				LOG_ERROR("Error removing owner privlige, couldn't initialize policy handle.");
				return false;
			}
		}
		LSA_UNICODE_STRING lPrivName = *WStringToLsaUnicodeString(wPriv);
		auto hr = LsaNtStatusToWinError(LsaRemoveAccountRights(lPolicyHandle, GetSID(), false, &lPrivName, 1));
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Error removing privilege from account. (Error: " << hr << ")");
			SetLastError(hr);
			return false;
		}
		return true;
	}

	bool Owner::HasSuperUserPrivs() {
		auto vOwnerPrivs = GetPrivileges();
		for (auto priv : vSuperUserPrivs) {
			for (auto iter = vOwnerPrivs.begin(); iter != vOwnerPrivs.end(); iter++) {
				if (priv.compare(WStringToLsaUnicodeString(*iter)->Buffer) == 0) return true;
			}
		}
		return false;
	}

	bool Owner::RemoveSuperUserPrivs() {
		//Ensure policy handle is initialized
		if (!bPolicyInitialized) {
			InitializePolicy();
			if (!bPolicyInitialized) {
				LOG_ERROR("Error removing owner privlige, couldn't initialize policy handle.");
				return false;
			}
		}
		std::vector<LSA_UNICODE_STRING> lSuperUserPrivs{ };
		for (auto priv : vSuperUserPrivs) {
			lSuperUserPrivs.emplace_back(*WStringToLsaUnicodeString(priv));
		}
		auto hr = LsaNtStatusToWinError(LsaRemoveAccountRights(lPolicyHandle, GetSID(), false, lSuperUserPrivs.data(), lSuperUserPrivs.size()));
		if (hr != ERROR_SUCCESS) {
			LOG_ERROR("Error removing privilege from account. (Error: " << hr << ")");
			SetLastError(hr);
			return false;
		}
	}

	bool Owner::Delete() {
		if (otType == OwnerType::USER) {
			NET_API_STATUS nStat = NetUserDel(nullptr, GetName().c_str());
			if (nStat != NERR_Success) {
				LOG_ERROR("Error deleting user " << GetName() << ". (Net Error: " << nStat << ")");
				return false;
			}
			bExists = false;
			return true;
		}
		else if (otType == OwnerType::GROUP) {
			NET_API_STATUS nStat = NetLocalGroupDel(nullptr, GetName().c_str());
			if (nStat != NERR_Success) {
				LOG_ERROR("Error deleting group " << GetName() << ". (Net Error: " << nStat << ")");
				return false;
			}
			bExists = false;
			return true;

		}
		return true;
	}

	User::User(IN const std::wstring& uName) : Owner{ uName , true, OwnerType::USER} {
		DWORD dwSIDLen{};
		DWORD dwDomainLen{};
		SID_NAME_USE SIDType{};
		LookupAccountNameW(nullptr, wName.c_str(), nullptr, &dwSIDLen, nullptr, &dwDomainLen, &SIDType);

		sdSID = SecurityDescriptor::CreateUserSID(dwSIDLen);
		std::vector<WCHAR> Domain(dwDomainLen);
		if (!LookupAccountNameW(nullptr, wName.c_str(), sdSID.GetUserSID(), &dwSIDLen, Domain.data(), &dwDomainLen, &SIDType)) {
			if (GetLastError() == ERROR_NONE_MAPPED) {
				LOG_VERBOSE(2, L"User with name " << wName << " doesn't exist.");
			}
			else {
				LOG_ERROR("Error getting user with name " << wName << " " << GetLastError());
			}
			bExists = false;
		}
		else {
			wDomainName = std::wstring(Domain.data());
			if (SIDType == SidTypeDeletedAccount) {
				LOG_VERBOSE(2, "User with name " << wName << " has been deleted.");
				bExists = false;
			}
			else if (SIDType != SidTypeUser) {
				LOG_VERBOSE(2, "User with name " << wName << " does not exist.");
				bExists = false;
			}
			else {
				LOG_VERBOSE(3, "User with name " << wName << " found.");
			}
		}
	}

	User::User(IN const SecurityDescriptor& sid) : Owner{ sid , true, OwnerType::USER } {
		DWORD dwDomainLen{};
		DWORD dwNameLen{};
		SID_NAME_USE SIDType{ SidTypeUnknown };
		LookupAccountSidW(nullptr, sdSID.GetUserSID(), nullptr, &dwNameLen, nullptr, &dwDomainLen, &SIDType);

		std::vector<WCHAR> Domain(dwDomainLen);
		std::vector<WCHAR> Name(dwNameLen);

		if (!LookupAccountSid(nullptr, sdSID.GetUserSID(), Name.data(), &dwNameLen, Domain.data(), &dwDomainLen, &SIDType)) {
			if (GetLastError() == ERROR_NONE_MAPPED) {
				LOG_VERBOSE(2, L"User doesn't exist.");
			}
			else {
				LOG_ERROR("Error getting user " << GetLastError());
			}
			bExists = false;
		}
		else {
			wDomainName = std::wstring(Domain.data());
			wName = std::wstring(Name.data());
			if (SIDType == SidTypeDeletedAccount) {
				LOG_VERBOSE(2, "User " << wName << " has been deleted.");
				bExists = false;
			}
			else if (SIDType != SidTypeUser) {
				LOG_VERBOSE(2, "User doesn't exist.");
				bExists = false;
			}
			else {
				LOG_VERBOSE(3, "User " << wName << " Exists.");
			}
		}
	}

	Group::Group(IN const std::wstring& name) : Owner{ name, true, OwnerType::GROUP } {
		DWORD dwSIDLen{};
		DWORD dwDomainLen{};
		SID_NAME_USE SIDType{};
		LookupAccountNameW(nullptr, wName.c_str(), nullptr, &dwSIDLen, nullptr, &dwDomainLen, &SIDType);

		sdSID = SecurityDescriptor::CreateUserSID(dwSIDLen);
		std::vector<WCHAR> Domain(dwDomainLen);
		if (!LookupAccountNameW(nullptr, wName.c_str(), sdSID.GetUserSID(), &dwSIDLen, Domain.data(), &dwDomainLen, &SIDType)) {
			LOG_ERROR("Error getting user with name " << wName << " " << GetLastError());
			bExists = false;
		}
		else {
			wDomainName = std::wstring(Domain.data());
			if (SIDType == SidTypeWellKnownGroup) {
				LOG_VERBOSE(2, "Group with name " << wName << " is a well known group.");
			}
			else if (SIDType == SidTypeGroup || SIDType == SidTypeAlias) {
				LOG_VERBOSE(2, "Group with name " << wName << " found.");
			}
			else {
				LOG_VERBOSE(3, "Group with name " << wName << " does not exist.");
				bExists = false;
			}
		}
	}

	Group::Group(IN const SecurityDescriptor& sid) : Owner{ sid, true, OwnerType::GROUP } {
		DWORD dwDomainLen{};
		DWORD dwNameLen{};
		SID_NAME_USE SIDType{ SidTypeUnknown };
		LookupAccountSidW(nullptr, sdSID.GetUserSID(), nullptr, &dwNameLen, nullptr, &dwDomainLen, &SIDType);

		std::vector<WCHAR> Domain(dwDomainLen);
		std::vector<WCHAR> Name(dwNameLen);

		if (!LookupAccountSid(nullptr, sdSID.GetUserSID(), Name.data(), &dwNameLen, Domain.data(), &dwDomainLen, &SIDType)) {
			LOG_ERROR("Error getting user " << GetLastError());
			bExists = false;
		}
		else {
			wDomainName = std::wstring(Domain.data());
			wName = std::wstring(Name.data());
			if (SIDType == SidTypeWellKnownGroup) {
				LOG_VERBOSE(2, "Group with name " << wName << " is a well known group.");
			}
			else if (SIDType == SidTypeGroup || SIDType == SidTypeAlias) {
				LOG_VERBOSE(2, "Group with name " << wName << " found.");
			}
			else {
				LOG_VERBOSE(3, "Group with name " << wName << " does not exist.");
				bExists = false;
			}
		}
	}

	std::optional<Owner> GetProcessOwner() {
		HandleWrapper hToken{ nullptr };
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
			LOG_ERROR("Couldn't access process token. Error " << GetLastError());
			return std::nullopt;
		}
		DWORD dwSize{ 0 };
		GetTokenInformation(hToken, TokenOwner, nullptr, dwSize, &dwSize);
		AllocationWrapper owner{ GlobalAlloc(GPTR, dwSize), dwSize, AllocationWrapper::GLOBAL_ALLOC };
		DWORD dwDomainLen{};
		DWORD dwNameLen{};
		SID_NAME_USE SIDType{ SidTypeUnknown };

		std::vector<WCHAR> Domain(dwDomainLen);
		std::vector<WCHAR> Name(dwNameLen);
		if (owner == nullptr) {
			LOG_ERROR("Unable to allocate space for owner token.");
			return std::nullopt;
		}
		if (!GetTokenInformation(hToken, TokenOwner, owner, dwSize, &dwSize)) {
			LOG_ERROR("Couldn't get owner from token. Error " << GetLastError());
			return std::nullopt;
		}
		LookupAccountSidW(nullptr, owner.GetAsPointer<TOKEN_OWNER>()->Owner, nullptr, &dwNameLen, nullptr, &dwDomainLen, &SIDType);
		Domain = std::vector<WCHAR>(dwDomainLen);
		Name = std::vector<WCHAR>(dwNameLen);

		if (!LookupAccountSid(nullptr, owner.GetAsPointer<TOKEN_OWNER>()->Owner, Name.data(), &dwNameLen, Domain.data(), &dwDomainLen, &SIDType)) {
			LOG_ERROR("Error getting owner " << GetLastError());
		}
		CloseHandle(hToken);
		return Owner(Name.data());
	}
}
```

`BLUESPAWN-win-client/src/util/processes/Analyzer.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <DbgHelp.h>
#include <Psapi.h>
#include <SoftPub.h>

#include "util/processes/Analyzer.h"

#include <iostream>

auto _NtQueryInformationProcess = (NTSTATUS(NTAPI*)(HANDLE, PROCESSINFOCLASS, LPVOID, ULONG, PULONG)) GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryInformationProcess");

STATUS Analyzer::ValidateProcess(HANDLE hProcess){
	//std::cout << "Validating process with PID " << GetProcessId(hProcess) << std::endl;

	FAIL_IF_INVALID_HANDLE(hThreadSnapshot, CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0));
	
	int PID = GetProcessId(hProcess);

	THREADENTRY32 ThreadEntry = { sizeof(THREADENTRY32), 0 };

	FAIL_IF_FALSE(Thread32First(hThreadSnapshot, &ThreadEntry));

	do if(ThreadEntry.th32OwnerProcessID == PID){
		FAIL_IF_INVALID_HANDLE(hThread, OpenThread(THREAD_ALL_ACCESS, false, ThreadEntry.th32ThreadID));
		FAIL_IF_NOT_SUCCESS(ValidateThread(hThread, hProcess));
	} while(Thread32Next(hThreadSnapshot, &ThreadEntry));

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateThread(HANDLE hThread, HANDLE hProcess){
	//std::cout << "Validating thread " << GetThreadId(hThread) << " in process with PID " << GetProcessId(hProcess) << std::endl;
	CONTEXT context{};
	context.ContextFlags = CONTEXT_CONTROL;
	GetThreadContext(hThread, &context);

	STACKFRAME64 stack{};
	stack.AddrPC.Mode = AddrModeFlat;
	stack.AddrStack.Mode = AddrModeFlat;
	stack.AddrFrame.Mode = AddrModeFlat;

#ifdef _WIN64
	stack.AddrPC.Offset = context.Rip;
	stack.AddrStack.Offset = context.Rsp;
	stack.AddrFrame.Offset = context.Rbp;

	FAIL_IF_NOT_SUCCESS(ValidateAddress(hProcess, (LPVOID) context.Rip))

	DWORD dwMachineType = IMAGE_FILE_MACHINE_AMD64;
	BOOL wow64 = false;
	IsWow64Process(hProcess, &wow64);
	if(wow64){
		dwMachineType = IMAGE_FILE_MACHINE_I386;
	}
#else
	stack.AddrPC.Offset = context.Eip;
	stack.AddrStack.Offset = context.Esp;
	stack.AddrFrame.Offset = context.Ebp;

	FAIL_IF_FALSE(ValidateAddress(hProcess, (LPVOID) context.Eip))

	DWORD dwMachineType = IMAGE_FILE_MACHINE_I386;
#endif

	while(StackWalk64(dwMachineType, hProcess, hThread, &stack, &context, nullptr, SymFunctionTableAccess64, SymGetModuleBase64, nullptr)){
		FAIL_IF_NOT_SUCCESS(ValidateAddress(hProcess, (LPVOID) stack.AddrPC.Offset));
	}

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateAddress(HANDLE hProcess, LPVOID lpAddress){
	//std::cout << "Validating address " << lpAddress << std::endl;

	LPVOID lpBaseAddress{};
	FAIL_IF_NOT_SUCCESS(ValidateAddressInImage(hProcess, lpAddress, &lpBaseAddress));
	//std::cout << "Address is in image" << std::endl;

	FAIL_IF_NOT_SUCCESS(ValidateTextExecution(hProcess, lpAddress, lpBaseAddress));
	//std::cout << "Address is in .text section" << std::endl;

	HANDLE hFile{};
	FAIL_IF_NOT_SUCCESS(ValidateImageSection(hProcess, lpBaseAddress, &hFile));
	std::unique_ptr<VOID, std::function<void(HANDLE)>> hFileScopeGuard{ hFile, [](HANDLE ptr){ CloseHandle(ptr); } };
	//std::cout << "Address is in a valid memory-mapped file" << std::endl;

	FAIL_IF_NOT_SUCCESS(ValidateMatchesFile(hProcess, hFile, lpBaseAddress));
	//std::cout << "In-memory image matches file" << std::endl;

	FAIL_IF_NOT_SUCCESS(ValidateFile(hFile));
	//std::cout << "File is signed" << std::endl;

	FAIL_IF_NOT_SUCCESS(ValidateLoader(hProcess, lpBaseAddress, hFile));
	//std::cout << "Loader and image match" << std::endl;

	//std::cout << "Address has passed all checks" << std::endl << std::endl;

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateAddressInImage(HANDLE hProcess, LPVOID lpAddress, LPVOID* lpBaseAddress){
	PROCESS_BASIC_INFORMATION pbi{};

	FAIL_IF_NOT_SUCCESS(_NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr));
	FAIL_IF_FALSE(pbi.PebBaseAddress);

	PEB peb{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), nullptr));

	LDR_DATA loader{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, peb.Ldr, &loader, sizeof(loader), nullptr));

	LDR_ENTRY image{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, loader.InLoadOrderModuleList.Flink, &image, sizeof(image), nullptr));

	do {
		if(!image.DllBase){
			break;
		}
		if((SIZE_T) lpAddress >= (SIZE_T) image.DllBase && (SIZE_T) lpAddress < (SIZE_T) image.DllBase + image.SizeOfImage){
			*lpBaseAddress = image.DllBase;
			return ERROR_SUCCESS;
		}
	} while(ReadProcessMemory(hProcess, image.InLoadOrderModuleList.Flink, &image, sizeof(image), nullptr));

	std::cout << "Invalid address: " << lpAddress << std::endl;
	return ADDRESS_NOT_IN_IMAGE_SECTION;
}

STATUS Analyzer::ValidateTextExecution(HANDLE hProcess, LPVOID lpAddress, LPVOID lpBaseAddress){
	IMAGE_DOS_HEADER DOSHeader{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, lpBaseAddress, &DOSHeader, sizeof(DOSHeader), nullptr));

	IMAGE_NT_HEADERS NTHeaders{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, (LPVOID)((SIZE_T) lpBaseAddress + DOSHeader.e_lfanew),
		                            &NTHeaders, sizeof(NTHeaders), nullptr));

	PIMAGE_SECTION_HEADER sections = (PIMAGE_SECTION_HEADER)((SIZE_T) lpBaseAddress + DOSHeader.e_lfanew +
		                                                     sizeof(NTHeaders));

	for(int i = 0; i < NTHeaders.FileHeader.NumberOfSections; i++){
		IMAGE_SECTION_HEADER section{};
		FAIL_IF_FALSE(ReadProcessMemory(hProcess, &sections[i], &section, sizeof(section), nullptr));

		if(!strcmp((char*) section.Name, ".text")){
			SIZE_T rva = section.VirtualAddress;
			SIZE_T va = rva + (SIZE_T) lpBaseAddress;
			bool in_text = (SIZE_T) lpAddress >= va && (SIZE_T) lpAddress < va + section.SizeOfRawData;
			if(!in_text){
				return EXECUTION_NOT_IN_TEXT_SECTION;
			}
			
			return ERROR_SUCCESS;
		}
	}
	
	return ERROR_NOT_FOUND;
}

STATUS Analyzer::ValidateImageSection(HANDLE hProcess, LPVOID lpBaseAddress, PHANDLE hFile){
	char lpFileName[256]{};
	if(!GetMappedFileNameA(hProcess, lpBaseAddress, lpFileName, 256)){
		return ADDRESS_NOT_IN_IMAGE_SECTION;
	}

	char* sFileName = PCHAR(lpFileName) + 21;
	sFileName[0] = 'C';
	sFileName[1] = ':';

	*hFile = CreateFileA(sFileName, GENERIC_READ, FILE_SHARE_READ, nullptr,
		                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if(!*hFile || *hFile == INVALID_HANDLE_VALUE){
		return IMAGE_FILE_NOT_FOUND;
	}

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateMatchesFile(HANDLE hProcess, HANDLE hFile, LPVOID lpBaseAddress){
	//For now, just do the text section and headers. In the future, roll back the relocations
	//and imports, then compare everything to the file

	DWORD dwFileSize = GetFileSize(hFile, nullptr);
	FAIL_IF_FALSE(dwFileSize);

	ALLOCATE(lpFileContents, dwFileSize);

	FAIL_IF_FALSE(lpFileContents);

	FAIL_IF_FALSE(ReadFile(hFile, lpFileContents, dwFileSize, nullptr, nullptr));

	PIMAGE_DOS_HEADER pFileDOSHeader = (PIMAGE_DOS_HEADER) lpFileContents;
	PIMAGE_NT_HEADERS pFileNtHeader = (PIMAGE_NT_HEADERS) ((SIZE_T) lpFileContents + pFileDOSHeader->e_lfanew);
	pFileNtHeader->OptionalHeader.ImageBase = ULONG_PTR(lpBaseAddress);

	IMAGE_DOS_HEADER RemoteDOSHeader;
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, lpBaseAddress, &RemoteDOSHeader, sizeof(RemoteDOSHeader), nullptr));

	IMAGE_NT_HEADERS RemoteNTHeaders;
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, (LPVOID) ((SIZE_T) lpBaseAddress + RemoteDOSHeader.e_lfanew),
		&RemoteNTHeaders, sizeof(RemoteNTHeaders), nullptr));

	ALLOCATE(lpRemoteImage, RemoteNTHeaders.OptionalHeader.SizeOfImage);

	FAIL_IF_FALSE(lpRemoteImage);

	FAIL_IF_FALSE(ReadProcessMemory(hProcess, lpBaseAddress, lpRemoteImage, RemoteNTHeaders.OptionalHeader.SizeOfImage, nullptr));
	if(memcmp(lpFileContents, lpRemoteImage, pFileNtHeader->OptionalHeader.SizeOfHeaders)){
		return IMAGE_HEADERS_MISMATCH;
	}

	/*PIMAGE_SECTION_HEADER sections = (PIMAGE_SECTION_HEADER) (ULONG_PTR(lpFileContents) + pFileDOSHeader->e_lfanew + sizeof(PIMAGE_NT_HEADERS));

	for(int i = 0; i < pFileNtHeader->FileHeader.NumberOfSections; i++){
		std::cout << "Reading section " << (char*) sections[i].Name << std::endl;
		if(!strcmp((char*) sections[i].Name, ".text")){
			LPVOID lpFileTextSection = (LPVOID) ((SIZE_T) lpFileContents + sections[i].PointerToRawData);
			LPVOID lpRemoteTextSection = (LPVOID) ((SIZE_T) lpRemoteImage + sections[i].VirtualAddress);
			if(memcmp(lpFileTextSection, lpRemoteTextSection, sections[i].SizeOfRawData)){
				return IMAGE_DOES_NOT_MATCH_FILE;
			}

			return ERROR_SUCCESS;
		}
	}*/

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateFile(HANDLE hFile){
	WCHAR strFileName[256]{};
	FAIL_IF_FALSE(GetFinalPathNameByHandleW(hFile, strFileName, 256, FILE_NAME_NORMALIZED | VOLUME_NAME_DOS));

	WINTRUST_FILE_INFO FileData{};
	FileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
	FileData.pcwszFilePath = strFileName;
	FileData.hFile = hFile;
	FileData.pgKnownSubject = NULL;

	GUID verification = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	WINTRUST_DATA WinTrustData{};

	WinTrustData.cbStruct = sizeof(WinTrustData);
	WinTrustData.pPolicyCallbackData = NULL;
	WinTrustData.pSIPClientData = NULL;
	WinTrustData.dwUIChoice = WTD_UI_NONE;
	WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
	WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
	WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;
	WinTrustData.hWVTStateData = NULL;
	WinTrustData.pwszURLReference = NULL;
	WinTrustData.dwUIContext = 0;
	WinTrustData.pFile = &FileData;

	LONG result = WinVerifyTrust((HWND) INVALID_HANDLE_VALUE, &verification, &WinTrustData);
	if(result){
		return IMAGE_FILE_NOT_SIGNED;
	}

	return ERROR_SUCCESS;
}

STATUS Analyzer::ValidateLoader(HANDLE hProcess, LPVOID lpBaseAddress, HANDLE hFile){
	PROCESS_BASIC_INFORMATION pbi;

	FAIL_IF_NOT_SUCCESS(_NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr));

	PEB peb{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), nullptr));

	LDR_DATA loader{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, peb.Ldr, &loader, sizeof(loader), nullptr));

	LDR_ENTRY image{};
	FAIL_IF_FALSE(ReadProcessMemory(hProcess, loader.InLoadOrderModuleList.Flink, &image, sizeof(image), nullptr));

	WCHAR strFileName[256]{};
	FAIL_IF_FALSE(GetFinalPathNameByHandleW(hFile, strFileName, 256, FILE_NAME_NORMALIZED | VOLUME_NAME_DOS));

	do {
		if(!image.DllBase){
			break;
		}
		if(lpBaseAddress == image.DllBase){
			WCHAR wstrLoaderImageName[256]{};
			FAIL_IF_FALSE(ReadProcessMemory(hProcess, image.FullDllName.Buffer, wstrLoaderImageName, image.FullDllName.Length, nullptr));

			bool bNameMismatch = _wcsicmp(wstrLoaderImageName, strFileName + 4);
			if(bNameMismatch){
				return IMAGE_LOADER_NAME_MISMATCH;
			}

			IMAGE_DOS_HEADER DOSHeader{};
			FAIL_IF_FALSE(ReadProcessMemory(hProcess, lpBaseAddress, &DOSHeader, sizeof(IMAGE_DOS_HEADER), nullptr));

			IMAGE_NT_HEADERS NTHeaders{};
			FAIL_IF_FALSE(ReadProcessMemory(hProcess, DOSHeader.e_lfanew + PCHAR(lpBaseAddress), &NTHeaders, sizeof(IMAGE_NT_HEADERS), nullptr));

			bool bSizeMismatch = image.SizeOfImage != NTHeaders.OptionalHeader.SizeOfImage;
			if(bSizeMismatch){
				return IMAGE_LOADER_SIZE_MISMATCH;
			}

			return ERROR_SUCCESS;
		}
	} while(ReadProcessMemory(hProcess, image.InLoadOrderModuleList.Flink, &image, sizeof(image), nullptr));

	return ERROR_NOT_FOUND;
}
```

`BLUESPAWN-win-client/src/util/processes/CheckLolbin.cpp`:

```cpp


#include <map>
#include <set>
#include <string>
#include <vector>

#include "util/StringUtils.h"

#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"
#include "util/processes/CommandParser.h"
#include "util/processes/ProcessUtils.h"

std::vector<std::wstring> lolbins{ L"cmd.exe",
                                   L"powershell.exe",
                                   L"explorer.exe",
                                   L"net.exe",
                                   L"net1.exe",
                                   L"At.exe",
                                   L"Atbroker.exe",
                                   L"Bash.exe",
                                   L"Bitsadmin.exe",
                                   L"Cmstp.exe",
                                   L"Diskshadow.exe",
                                   L"Dnscmd.exe",
                                   L"Extexport.exe",
                                   L"Forfiles.exe",
                                   L"Ftp.exe",
                                   L"Gpscript.exe",
                                   L"Hh.exe",
                                   L"Ie4uinit.exe",
                                   L"Ieexec.exe",
                                   L"Infdefaultinstall.exe",
                                   L"Installutil.exe",
                                   L"Mavinject.exe",
                                   L"Microsoft.Workflow.Compiler.exe",
                                   L"Mmc.exe",
                                   L"Msbuild.exe",
                                   L"Msconfig.exe",
                                   L"Msdt.exe",
                                   L"Mshta.exe",
                                   L"Msiexec.exe",
                                   L"Netsh.exe",
                                   L"Odbcconf.exe",
                                   L"Pcalua.exe",
                                   L"Pcwrun.exe",
                                   L"Presentationhost.exe",
                                   L"Rasautou.exe",
                                   L"Regasm.exe",
                                   L"Register-cimprovider.exe",
                                   L"Regsvcs.exe",
                                   L"Regsvr32.exe",
                                   L"Rundll32.exe",
                                   L"Runonce.exe",
                                   L"Runscripthelper.exe",
                                   L"Schtasks.exe",
                                   L"Scriptrunner.exe",
                                   L"SyncAppvPublishingServer.exe",
                                   L"Tttracer.exe",
                                   L"Verclsid.exe",
                                   L"Wab.exe",
                                   L"Wmic.exe",
                                   L"Xwizard.exe",
                                   L"Appvlp.exe",
                                   L"Bginfo.exe",
                                   L"Cdb.exe",
                                   L"csi.exe",
                                   L"Devtoolslauncher.exe",
                                   L"dnx.exe",
                                   L"Dotnet.exe",
                                   L"Dxcap.exe",
                                   L"Mftrace.exe",
                                   L"Msdeploy.exe",
                                   L"msxsl.exe",
                                   L"rcsi.exe",
                                   L"Sqlps.exe",
                                   L"SQLToolsPS.exe",
                                   L"Squirrel.exe",
                                   L"te.exe",
                                   L"Tracker.exe",
                                   L"Update.exe",
                                   L"vsjitdebugger.exe",
                                   L"Wsl.exe",
                                   L"Advpack.dll",
                                   L"Ieadvpack.dll",
                                   L"Ieaframe.dll",
                                   L"Mshtml.dll",
                                   L"Pcwutl.dll",
                                   L"Setupapi.dll",
                                   L"Shdocvw.dll",
                                   L"Shell32.dll",
                                   L"Syssetup.dll",
                                   L"Url.dll",
                                   L"Zipfldr.dll" };

std::set<std::wstring> LolbinHashes{};

std::map<std::wstring, std::wstring> hashmap{};

bool IsLolbin(const FileSystem::File& file) {
    if(!file.GetFileExists()) {
        return false;
    }

    if(!LolbinHashes.size()) {
        for(auto name : lolbins) {
            auto path{ FileSystem::SearchPathExecutable(name) };
            if(path) {
                auto hash{ FileSystem::File{ *path }.GetSHA256Hash() };
                if(hash) {
                    LolbinHashes.emplace(*hash);
                    hashmap.emplace(name, *hash);
                }
            }
        }
    }

    auto hash{ file.GetSHA256Hash() };
    if(hash && LolbinHashes.count(*hash)) {
        return true;
    }

    return false;
}

bool IsLolbinMalicious(const std::wstring& command) {
    std::wstring executable{ GetImagePathFromCommand(command) };

    LOG_VERBOSE(1, "Checking if " << command << " will execute a lolbin maliciously");

    if(!IsLolbin(executable)) {
        return false;
    }

    auto args{ GetArgumentTokens(command) };

    LOG_VERBOSE(3, "Getting hash of " << executable);
    auto hash{ FileSystem::File(executable).GetSHA256Hash() };

    LOG_VERBOSE(3, "Checking if " << executable << " is rundll32");
    if(hashmap.count(L"Rundll32.exe") && hashmap.at(L"Rundll32.exe") == hash) {
        if(args.size() && args[0] != L"/sta") {
            auto arg{ args[0] };
            auto br{ arg.find_first_of(L" \t,") };
            auto dll{ arg.substr(0, br) };
            auto dllpath{ FileSystem::SearchPathExecutable(dll) };

            FileSystem::File dllfile{ *dllpath };
            if(!dllpath || !dllfile.GetFileSigned()) {
                LOG_INFO(2, "rundll32 found to be executing " << dll);
                return true;
            }

            if(hashmap.count(L"Shell32.dll") && hashmap.at(L"Shell32.dll") == dllfile.GetSHA256Hash() &&
               br != std::wstring::npos) {
                auto start{ arg.find_first_not_of(L" ,\t", br) };
                auto func{ arg.substr(start, arg.find_first_of(L" ,\t", start)) };
                LOG_INFO(3, "rundll32 found to be executing shell32");
                return !CompareIgnoreCaseW(func, L"SHCreateLocalServerRunDll");
            } else {
                LOG_INFO(2, "rundll32 found to be executing " << dll);
                return true;
            }
        }
        return false;
    }

    LOG_VERBOSE(3, "Checking if " << executable << " is mmc.exe");
    if(hashmap.count(L"Mmc.exe") && hashmap.at(L"Mmc.exe") == hash) {
        for(auto& arg : args) {
            if(FileSystem::SearchPathExecutable(arg)) {
                LOG_INFO(3, "mmc found to be executing " << arg);
                return true;
            }
        }
        return false;
    }

    LOG_VERBOSE(3, "Checking if " << executable << " is presentationhost");
    if(hashmap.count(L"Presentationhost.exe") && hashmap.at(L"Presentationhost.exe") == hash) {
        for(auto& arg : args) {
            if(FileSystem::SearchPathExecutable(arg)) {
                LOG_INFO(3, "PresentationHost found to be executing " << arg);
                return true;
            }
        }
        return false;
    }

    LOG_VERBOSE(3, "Checking if " << executable << " is Mshta.exe");
    if(hashmap.count(L"Mshta.exe") && hashmap.at(L"Mshta.exe") == hash) {
        return args.size();
    }

    LOG_VERBOSE(3, "Checking if " << executable << " is Msiexec.exe");
    if(hashmap.count(L"Msiexec.exe") && hashmap.at(L"Msiexec.exe") == hash){
        return args.size() && args[0] != L"/V";
    }

    LOG_VERBOSE(3, "Checking if " << executable << " is explorer.exe");
    if(hashmap.count(L"explorer.exe") && hashmap.at(L"explorer.exe") == hash) {
        for(auto& arg : args) {
            if(FileSystem::SearchPathExecutable(arg)) {
                LOG_INFO(2, "explorer found to be executing " << arg);
                return true;
            }
        }
        return false;
    } else{
        return true;
    }
}

```

`BLUESPAWN-win-client/src/util/processes/CommandParser.cpp`:

```cpp
#include "util/processes/ProcessUtils.h"
#include "util/processes/CommandParser.h"

#include <string>

#include "util/StringUtils.h"

#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

std::wstring GetImagePathFromCommand(std::wstring wsCmd){
    if(wsCmd.substr(0, 11) == L"\\SystemRoot"){
        wsCmd = L"%SYSTEMROOT%" + wsCmd.substr(11);
    }

    wsCmd = ExpandEnvStringsW(wsCmd);

    auto start = wsCmd.find_first_not_of(L" \f\v\t\n\r", 0);
    if(wsCmd.size() >= 4 && wsCmd.substr(start, 4) == L"\\??\\"){
        start += 4;
    }
    if(start == std::wstring::npos){
        return L"";
    } else if(wsCmd.at(start) == '"' || wsCmd.at(start) == '\''){
        auto name = wsCmd.substr(start + 1, wsCmd.find_first_of(L"'\"", start + 1) - start - 1);
        auto path = FileSystem::SearchPathExecutable(name);
        if(path){
            return *path;
        } else return name;
    } else{
        auto idx = start;
        while(idx != std::wstring::npos){
            auto spacepos = wsCmd.find(L" ", idx);
            auto name = wsCmd.substr(start, spacepos - start);
            auto path = FileSystem::SearchPathExecutable(name);
            if(path && FileSystem::CheckFileExists(*path)){
                return *path;
            }

            if(name.length() > 4 && CompareIgnoreCaseW(name.substr(name.length() - 4), L".exe")){
                return name;
            }

            if(spacepos == std::wstring::npos){
                return name;
            }

            idx = spacepos + 1;
        }

        return wsCmd.substr(start, wsCmd.find_first_of(L" \t\n\r", start) - start);
    }
}

std::vector<std::wstring> TokenizeCommand(const std::wstring& command){
    std::vector<std::wstring> tokens{};

    std::vector<std::wstring> words{ SplitStringW(command, L" ") };

    std::wstring quoted{};

    bool inquotes = false;
    bool singlequotes = false;
    for(auto& str : words){
        if(inquotes){
            if(str.length() && ((!singlequotes && str.find_last_of(L"\"") == str.length() - 1) ||
                                (singlequotes && str.find_last_of(L"'") == str.length() - 1))){
                inquotes = false;
                quoted += L" " + str.substr(0, str.length() - 1);
                for(size_t idx = 0; idx < str.length() - 1; idx++){
                    if(!singlequotes && str.at(idx) == L'\\' && str.at(idx + 1) == L'"'){
                        str.replace(str.begin() + idx, str.begin() + idx + 2, L"\"");
                    }
                    if(singlequotes && str.at(idx) == L'\\' && str.at(idx + 1) == L'\''){
                        str.replace(str.begin() + idx, str.begin() + idx + 2, L"'");
                    }
                }
                tokens.emplace_back(quoted);
            } else{
                quoted += L" " + str;
            }
        } else{
            if(str.at(0) == L'"' || str.at(0) == '\''){
                quoted = str.substr(1);
                inquotes = true;
                singlequotes = str.at(0) == '\'';
            } else{
                tokens.emplace_back(str);
            }
        }
    }

    if(inquotes){
        tokens.emplace_back(quoted);
    }

    return tokens;
}

std::vector<std::wstring> GetArgumentTokens(const std::wstring& command){
    LOG_VERBOSE(2, "Finding arguments for command " << command);

    std::wstring executable{};
    auto start = command.find_first_not_of(L" \f\v\t\n\r", 0);

    if(command.substr(start, 4) == L"\\??\\"){
        start += 4;
    }
    if(start == std::wstring::npos){
        return {};
    } else if(command.at(start) == '"' || command.at(start) == '\''){
        auto end{ command.find_first_of(L"'\"", start + 1) - start - 1 };
        start = command.find_first_not_of(L" \f\v\t\n\r", end);
        
        LOG_VERBOSE(3, "Command is quoted; rest begins at " << start);
        return TokenizeCommand(command.substr(start));
    }

    LOG_VERBOSE(3, "Command is not quoted; searching for executable");
    auto tokens{ TokenizeCommand(command.substr(start)) };
    LOG_VERBOSE(3, "Successfully tokenized command");
    for(size_t idx = 0; idx < tokens.size(); idx++){
        if(!executable.length()){
            executable += tokens[idx];
        } else executable += L" " + tokens[idx];

        LOG_VERBOSE(3, "Trying " << executable);
        auto path = FileSystem::SearchPathExecutable(executable);
        if(path){
            return std::vector<std::wstring>(tokens.begin() + idx + 1, tokens.end());
        }
    }

    return {};
}
```

`BLUESPAWN-win-client/src/util/processes/PERemover.cpp`:

```cpp
#include "util/processes/PERemover.h"

#include <DbgHelp.h>
#include <Psapi.h>
#include <TlHelp32.h>
#include <Windows.h>
#include <winternl.h>

#include "util/log/Log.h"
#include "util/processes/ProcessUtils.h"

#include "reaction/SuspendProcess.h"

LINK_FUNCTION(NtResumeProcess, NTDLL.DLL)

PERemover::PERemover(const HandleWrapper& hProcess, LPVOID lpBaseAddress, DWORD dwImageSize) :
    hProcess{ hProcess }, lpBaseAddress{ lpBaseAddress }, dwImageSize{ dwImageSize == -1 ?
                                                                           GetRegionSize(hProcess, lpBaseAddress) :
                                                                           dwImageSize } {
    if(!hProcess) {
        auto x = GetLastError();
        LOG_ERROR(L"Failed to retrieve process handle");
    }
}
PERemover::PERemover(DWORD dwPID, LPVOID lpBaseAddress, DWORD dwImageSize) :
    PERemover(OpenProcess(PROCESS_ALL_ACCESS, false, dwPID), lpBaseAddress, dwImageSize) {}
PERemover::PERemover(const HandleWrapper& hProcess, const std::wstring& wsImageName) :
    PERemover(hProcess, GetModuleAddress(hProcess, wsImageName.c_str()), -1) {}
PERemover::PERemover(DWORD dwPID, const std::wstring& wsImageName) :
    PERemover(OpenProcess(PROCESS_ALL_ACCESS, false, dwPID), GetModuleAddress(dwPID, wsImageName.c_str()), -1) {}

bool PERemover::RemoveImage() {
    Linker::NtSuspendProcess(hProcess);
    LOG_VERBOSE(2, "Suspended process with PID " << GetProcessId(hProcess) << " to remove image at " << lpBaseAddress);

    SCOPE_LOCK(Linker::NtResumeProcess(hProcess), RESUME_PROCESS);

    if(CheckThreads() && AdjustPointers() && WipeMemory()) {
        LOG_INFO(2, "Successfully removed image at " << lpBaseAddress << " from process with PID "
                                                     << GetProcessId(hProcess));
        return true;
    }

    LOG_ERROR("Failed to finish removing the memory from process with PID " << GetProcessId(hProcess));
    return false;
}

bool PERemover::AddressIsInRegion(LPVOID lpAddress) {
    return reinterpret_cast<ULONG_PTR>(lpAddress) >= reinterpret_cast<ULONG_PTR>(lpBaseAddress) &&
           reinterpret_cast<ULONG_PTR>(lpAddress) < reinterpret_cast<ULONG_PTR>(lpBaseAddress) + dwImageSize;
}

bool PERemover::CheckThreads() {
    HandleWrapper hThreadSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if(!hThreadSnapshot) {
        LOG_ERROR("Unable to open Tool Help Snapshot entry to scan threads"
                  << " (Error " << GetLastError() << ")");
        return false;
    }

    int PID = GetProcessId(hProcess);

    THREADENTRY32 ThreadEntry = { sizeof(THREADENTRY32), 0 };
    if(!Thread32First(hThreadSnapshot, &ThreadEntry)) {
        LOG_ERROR("Unable to open thread  entry to scan threads"
                  << " (Error " << GetLastError() << ")");
        return false;
    }

    do
        if(ThreadEntry.th32OwnerProcessID == PID) {
            HandleWrapper hThread = OpenThread(THREAD_ALL_ACCESS, false, ThreadEntry.th32ThreadID);
            if(!hThread) {
                LOG_ERROR("Unable to open thread with TID " << ThreadEntry.th32ThreadID
                                                            << " to scan for infected memory (Error " << GetLastError()
                                                            << ")");
                return false;
            }

            LOG_VERBOSE(2, "Thread with TID " << ThreadEntry.th32ThreadID
                                              << " detected in target process. Scanning stack now");
            if(!WalkThreadBack(hThread, ThreadEntry.th32ThreadID)) {
                LOG_ERROR("Unable to remove malicious threads from infected process");
                return false;
            }
        }
    while(Thread32Next(hThreadSnapshot, &ThreadEntry));

    return true;
}

/// TODO: Actually walk the thread back instead of terminating it
bool PERemover::WalkThreadBack(const HandleWrapper& hThread, DWORD dwTID) {
    CONTEXT context{};
    ZeroMemory(&context, sizeof(CONTEXT));
    context.ContextFlags = CONTEXT_FULL;
    if(!GetThreadContext(hThread, &context)) {
        LOG_ERROR("Unable to get the context of thread in infected process");
        return false;
    }

    STACKFRAME64 stack{};
    stack.AddrPC.Mode = AddrModeFlat;
    stack.AddrStack.Mode = AddrModeFlat;
    stack.AddrFrame.Mode = AddrModeFlat;

#ifdef _WIN64
    stack.AddrPC.Offset = context.Rip;
    stack.AddrStack.Offset = context.Rsp;
    stack.AddrFrame.Offset = context.Rbp;

    DWORD dwMachineType = IMAGE_FILE_MACHINE_AMD64;
    BOOL wow64 = false;
    IsWow64Process(hProcess, &wow64);
    if(wow64) {
        dwMachineType = IMAGE_FILE_MACHINE_I386;
    }

    if(AddressIsInRegion(reinterpret_cast<LPVOID>(context.Rip))) {
        if(TerminateThread(hThread, 0)) {
            LOG_INFO(1, "Thread with TID " << dwTID << " was executing malicious code at "
                                           << reinterpret_cast<LPVOID>(context.Rip) << " and was terminated");
            return true;
        } else {
            LOG_ERROR("Thread with TID " << dwTID << " was executing malicious code at "
                                         << reinterpret_cast<LPVOID>(context.Rip) << " but couldn't terminated"
                                         << " (Error " << GetLastError() << ")");
            return false;
        }
    }
#else
    stack.AddrPC.Offset = context.Eip;
    stack.AddrStack.Offset = context.Esp;
    stack.AddrFrame.Offset = context.Ebp;

    DWORD dwMachineType = IMAGE_FILE_MACHINE_I386;

    if(AddressIsInRegion(reinterpret_cast<LPVOID>(context.Eip))) {
        if(TerminateThread(hThread, 0)) {
            LOG_INFO(1, "Thread with TID " << dwTID << " was executing malicious code at "
                                           << reinterpret_cast<LPVOID>(context.Eip) << " and was terminated");
            return true;
        } else {
            LOG_ERROR("Thread with TID " << dwTID << " was executing malicious code at "
                                         << reinterpret_cast<LPVOID>(context.Eip) << " but couldn't terminated");
            return false;
        }
    }
#endif
    SymInitialize(hProcess, nullptr, true);
    while(StackWalk64(dwMachineType, hProcess, hThread, &stack, &context, nullptr, SymFunctionTableAccess64,
                      SymGetModuleBase64, nullptr)) {
        if(AddressIsInRegion(reinterpret_cast<LPVOID>(stack.AddrPC.Offset))) {
            if(TerminateThread(hThread, 0)) {
                LOG_INFO(1, "Thread with TID " << dwTID << " was executing malicious code at "
                                               << reinterpret_cast<LPVOID>(stack.AddrPC.Offset)
                                               << " and was terminated");
                return true;
            } else {
                LOG_ERROR("Thread with TID " << dwTID << " was executing malicious code at "
                                             << reinterpret_cast<LPVOID>(stack.AddrPC.Offset)
                                             << " but couldn't terminated"
                                             << " (Error " << GetLastError() << ")");
                return false;
            }
        }
    }
    SymCleanup(hProcess);

    return true;
}

DWORD GetFunctionStackSize(LPVOID lpFunction, const HandleWrapper& hProcess, const HandleWrapper& hThread) {
    CONTEXT context{};

    STACKFRAME64 stack{};
    stack.AddrPC.Mode = AddrModeFlat;
    stack.AddrStack.Mode = AddrModeFlat;
    stack.AddrFrame.Mode = AddrModeFlat;
    stack.AddrPC.Offset = reinterpret_cast<ULONG_PTR>(lpFunction);
    stack.AddrStack.Offset = 0x10000;
    stack.AddrFrame.Offset = 0x10000;

    context.ContextFlags = CONTEXT_CONTROL;
#ifdef _WIN64
    context.Rip = reinterpret_cast<ULONG_PTR>(lpFunction);
    context.Rsp = 0x10000;
    context.Rbp = 0x10000;

    DWORD dwMachineType = IMAGE_FILE_MACHINE_AMD64;
    BOOL wow64 = false;
    IsWow64Process(hProcess, &wow64);
    if(wow64) {
        dwMachineType = IMAGE_FILE_MACHINE_I386;
    }

#else
    context.Eip = reinterpret_cast<ULONG_PTR>(lpFunction);
    context.Esp = 0x10000;
    context.Ebp = 0x10000;

    DWORD dwMachineType = IMAGE_FILE_MACHINE_I386;
#endif

    SetThreadContext(hThread, &context);

    SymInitialize(hProcess, nullptr, true);
    if(StackWalk64(dwMachineType, hProcess, hThread, &stack, &context, nullptr, SymFunctionTableAccess64,
                   SymGetModuleBase64, nullptr) &&
       StackWalk64(dwMachineType, hProcess, hThread, &stack, &context, nullptr, SymFunctionTableAccess64,
                   SymGetModuleBase64, nullptr)) {
        if(stack.AddrStack.Offset == 0x10000) {
            return 0;
        }

        return stack.AddrStack.Offset - 0x10000 - sizeof(ULONG_PTR);
    }
    SymCleanup(hProcess);

    return 0;
}

bool PERemover::AdjustPointer(LPVOID lpAddress) {
    LOG_VERBOSE(2, "Updating address " << lpAddress << " to prevent calls to image");

    MEMORY_BASIC_INFORMATION memory{};
    if(!VirtualQueryEx(hProcess, lpAddress, &memory, sizeof(memory))) {
        LOG_ERROR("Unable to read memory protections at " << lpAddress << " (Error " << GetLastError() << ")");
        return false;
    } else {
        if(memory.Protect & 0xF0) {
            LOG_VERBOSE(3, "Address " << lpAddress << " is executable memory; patching with a return");

            // DWORD dwStackChange = GetFunctionStackSize(lpAddress, hProcess, hThread);
            // LOG_VERBOSE(3, "Determined that the function at " << lpAddress << " adds " << dwStackChange << " to the stack");

            DWORD dwOverwriteSize{};

#ifdef _WIN64
            bool x64 = true;
            BOOL wow64 = false;
            IsWow64Process(hProcess, &wow64);
            if(wow64) {
                x64 = false;
            }
#else
            bool x64 = false;
#endif
            // push 0
            // pop rax ; same opcode for pop eax
            // ret
            unsigned char instruction[4]{ 0x6a, 0x00, 0x58, 0xc3 };

            DWORD dwOldProtections{};
            if(!VirtualProtectEx(hProcess, lpAddress, 4, PAGE_READWRITE, &dwOldProtections)) {
                LOG_ERROR("Unable to adjust memory protections at " << lpAddress << " (Error " << GetLastError()
                                                                    << ")");
                return false;
            }
            if(!WriteProcessMemory(hProcess, lpAddress, instruction, 4, nullptr)) {
                LOG_ERROR("Unable to adjust memory protections at " << lpAddress << " (Error " << GetLastError()
                                                                    << ")");
                return false;
            }
            if(!VirtualProtectEx(hProcess, lpAddress, 4, dwOldProtections, &dwOldProtections)) {
                LOG_ERROR("Unable to repair memory protections at " << lpAddress << " (Error " << GetLastError()
                                                                    << ")");
                return false;
            }
        } else {
            LOG_VERBOSE(3, "Address " << lpAddress << " is data; ignoring.");
            // This is likely data and/or a pointer. In the interest of not causing crashes, this will be ignored.
        }
    }
    return true;
}

bool PERemover::AdjustPointers() {
    ULONG_PTR address = 0;
    while(address < (1LL << 48)) {
        MEMORY_BASIC_INFORMATION memory{};
        if(!VirtualQueryEx(hProcess, reinterpret_cast<LPVOID>(address), &memory, sizeof(memory))) {
            return true;
        } else {
            address += memory.RegionSize;

            AllocationWrapper buffer = { VirtualAlloc(nullptr, memory.RegionSize, MEM_COMMIT | MEM_RESERVE,
                                                      PAGE_READWRITE),
                                         memory.RegionSize, AllocationWrapper::VIRTUAL_ALLOC };
            if(ReadProcessMemory(hProcess, memory.BaseAddress, buffer, memory.RegionSize, nullptr)) {
                for(int i = 0; i < memory.RegionSize - sizeof(ULONG_PTR); i++) {
                    auto lpCheckAddress = *reinterpret_cast<LPVOID*>(reinterpret_cast<ULONG_PTR>(LPVOID(buffer)) + i);
                    if(AddressIsInRegion(lpCheckAddress)) {
                        if(!AdjustPointer(lpCheckAddress)) {
                            LOG_ERROR("Unable to adjust pointer to bad memory at " << address + i << " (Error "
                                                                                   << GetLastError() << ")");
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}

bool PERemover::WipeMemory() {
    // For now, this will only wipe exports and the entrypoint.

    AllocationWrapper headers = { VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE), 0x1000,
                                  AllocationWrapper::VIRTUAL_ALLOC };
    if(!ReadProcessMemory(hProcess, lpBaseAddress, headers, 0x1000, nullptr)) {
        LOG_ERROR("Unable to read memory to wipe at " << lpBaseAddress << " (Error " << GetLastError() << ")");
        return false;
    }

    if(headers[0] == 'M' && headers[1] == 'Z') {
        DWORD dwNTHeaderOffset = reinterpret_cast<PIMAGE_DOS_HEADER>(LPVOID(headers))->e_lfanew;

        DWORD dwEntrypointRVA{};
        DWORD dwExportsRVA{};
        DWORD dwExportsSize{};

        if(dwNTHeaderOffset + sizeof(IMAGE_NT_HEADERS64) < 0x1000) {
            auto lpNTHeaders =
                reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<PCHAR>(LPVOID(headers)) + dwNTHeaderOffset);
            if(lpNTHeaders->Signature != 0x00004550) {
                return true;
            }

            dwEntrypointRVA = lpNTHeaders->OptionalHeader.AddressOfEntryPoint;
            dwExportsRVA = lpNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
            dwExportsSize = lpNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        } else {
            AllocationWrapper NTHeaders = { VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE),
                                            0x1000, AllocationWrapper::VIRTUAL_ALLOC };
            if(!ReadProcessMemory(hProcess, reinterpret_cast<PCHAR>(lpBaseAddress) + dwNTHeaderOffset, NTHeaders,
                                  0x1000, nullptr)) {
                LOG_ERROR("Unable to read memory to wipe at " << lpBaseAddress << " (Error " << GetLastError() << ")");
                return false;
            }

            auto lpNTHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(LPVOID(NTHeaders));
            if(lpNTHeaders->Signature != 0x00004550) {
                return true;
            }

            dwEntrypointRVA = lpNTHeaders->OptionalHeader.AddressOfEntryPoint;
            dwExportsRVA = lpNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
            dwExportsSize = lpNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        }

        if(dwEntrypointRVA && !AdjustPointer(reinterpret_cast<PCHAR>(lpBaseAddress) + dwEntrypointRVA)) {
            LOG_ERROR("Failed to adjust the entrypoint of image to remove");
            return false;
        }

        if(dwExportsRVA && dwExportsSize) {
            AllocationWrapper Exports = { VirtualAlloc(nullptr, dwExportsSize, MEM_COMMIT | MEM_RESERVE,
                                                       PAGE_READWRITE),
                                          dwExportsSize, AllocationWrapper::VIRTUAL_ALLOC };
            if(!ReadProcessMemory(hProcess, reinterpret_cast<PCHAR>(lpBaseAddress) + dwExportsRVA, Exports,
                                  dwExportsSize, nullptr)) {
                LOG_ERROR("Unable to read memory to wipe at " << lpBaseAddress << " (Error " << GetLastError() << ")");
                return false;
            }

            auto lpExports = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(LPVOID(Exports));
            auto dwFunctions = lpExports->NumberOfFunctions;
            auto lpFuncionsPtr = reinterpret_cast<PDWORD>(reinterpret_cast<ULONG_PTR>(LPVOID(Exports)) +
                                                          lpExports->AddressOfFunctions - dwExportsRVA);

            for(DWORD i = 0; i < dwFunctions; i++) {
                if(lpFuncionsPtr[i] && !AdjustPointer(reinterpret_cast<PCHAR>(lpBaseAddress) + lpFuncionsPtr[i])) {
                    LOG_ERROR("Failed to adjust an export of image to remove");
                    return false;
                }
            }
        }
    }

    return true;
}

```

`BLUESPAWN-win-client/src/util/processes/ParseCobalt.cpp`:

```cpp
#include "util/processes/ParseCobalt.h"

#include <Windows.h>

#include <map>
#include <optional>

#include "util/StringUtils.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"
#include "util/wrappers.hpp"

std::optional<AllocationWrapper> FindBeaconInfoQuick(const MemoryWrapper<>& memory) {
    IMAGE_DOS_HEADER hdr{};
    auto offset{ memory.Convert<IMAGE_DOS_HEADER>()->e_lfanew };
    if(memory.Convert<IMAGE_DOS_HEADER>()->e_magic != 0x5D4A) {
        return std::nullopt;
    }

    auto section{ memory.GetOffset(offset + sizeof(IMAGE_NT_HEADERS)).Convert<IMAGE_SECTION_HEADER>() };
    while(section->Name) {
        if(*reinterpret_cast<PDWORD64>(section->Name) == *reinterpret_cast<PDWORD64>(".data\0\0")) {
            DWORD dwRawDword{ *memory.GetOffset(section->PointerToRawData + 0x30).Convert<DWORD>() ^ 0x01000100 };
            DWORD dwVirDword{ *memory.GetOffset(section->VirtualAddress + 0x30).Convert<DWORD>() ^ 0x01000100 };
            if(dwRawDword == 0x2E2E2E2E || dwRawDword == 0x69696969) {
                auto wrapper{
                    memory.GetOffset(section->PointerToRawData + 0x30).Convert<DWORD>().ToAllocationWrapper(4096)
                };
                if(!wrapper) {}
                for(size_t idx1 = 0; idx1 < wrapper.GetSize(); idx1++) {
                    if(dwRawDword == 0x69696969) {
                        wrapper.SetByte(idx1, wrapper[idx1] ^ 0x69);
                    } else {
                        wrapper.SetByte(idx1, wrapper[idx1] ^ 0x2E);
                    }
                }
                return wrapper;
            } else if(dwRawDword == 0x2E2E2E2E || dwRawDword == 0x69696969) {
                auto wrapper{
                    memory.GetOffset(section->PointerToRawData + 0x30).Convert<DWORD>().ToAllocationWrapper(4096)
                };
                for(size_t idx1 = 0; idx1 < wrapper.GetSize(); idx1++) {
                    if(dwRawDword == 0x69696969) {
                        wrapper.SetByte(idx1, wrapper[idx1] ^ 0x69);
                    } else {
                        wrapper.SetByte(idx1, wrapper[idx1] ^ 0x2E);
                    }
                }
                return wrapper;
            } else {
                return std::nullopt;
            }
        }
        section = section.GetOffset(sizeof(IMAGE_SECTION_HEADER));
    }
    return std::nullopt;
}

std::optional<AllocationWrapper> FindBeaconInfo(const MemoryWrapper<>& memory) {
    // Experimentation shows that the configuration information is located 0x30 bytes into the .data section
    // Check that before searching the entire module
    auto quick{ FindBeaconInfoQuick(memory) };
    if(quick) {
        return quick;
    }

    DWORD64 start{ 0x020001000100 };
    DWORD64 xor3{ 0x696969696969 };
    DWORD64 xor4{ 0x2E2E2E2E2E2E };
    for(size_t idx = 0; idx < memory.MemorySize - 8; idx++) {
        auto pattern{ (*memory.GetOffset(idx).Convert<DWORD64>() & 0xFFFFFFFFFFFF) ^ start };
        if(pattern == xor3 || pattern == xor4) {
            LOG_VERBOSE(2, "Beacon magic bytes found in memory");
            auto wrapper{ memory.GetOffset(idx).ToAllocationWrapper(4096) };
            for(size_t idx1 = 0; idx1 < wrapper.GetSize(); idx1++) {
                if(pattern == xor3) {
                    wrapper.SetByte(idx1, wrapper[idx1] ^ 0x69);
                } else {
                    wrapper.SetByte(idx1, wrapper[idx1] ^ 0x2E);
                }
            }
            return wrapper;
        }
    }

    return std::nullopt;
}

// From https://github.com/Sentinel-One/CobaltStrikeParser/blob/master/parse_beacon_config.py
std::map<DWORD, std::string> names{
    { 1, "BeaconType" },
    { 2, "Port" },
    { 3, "SleepTime" },
    { 4, "MaxGetSize" },
    { 5, "Jitter" },
    { 6, "MaxDNS" },
    { 7, "PublicKey" },
    { 8, "C2Server" },
    { 9, "UserAgent" },
    { 10, "HttpPostUri" },
    { 12, "HttpGet_Metadata" },
    { 13, "HttpPost_Metadata" },
    { 14, "SpawnTo" },
    { 15, "PipeName" },
    { 19, "DNS_Idle" },
    { 20, "DNS_Sleep" },
    { 21, "SSH_Host" },
    { 22, "SSH_Port" },
    { 23, "SSH_Username" },
    { 24, "SSH_Password_Plaintext" },
    { 25, "SSH_Password_Pubkey" },
    { 26, "HttpGet_Verb" },
    { 27, "HttpPost_Verb" },
    { 28, "HttpPostChunk" },
    { 29, "Spawnto_x86" },
    { 30, "Spawnto_x64" },
    { 31, "CryptoScheme" },
    { 32, "Proxy_Config" },
    { 33, "Proxy_User" },
    { 34, "Proxy_Password" },
    { 35, "Proxy_Behavior" },
    { 37, "Watermark" },
    { 38, "bStageCleanup" },
    { 39, "bCFGCaution" },
    { 40, "KillDate" },
    { 43, "bProcInject_StartRWX" },
    { 44, "bProcInject_UseRWX" },
    { 45, "bProcInject_MinAllocSize" },
    { 46, "ProcInject_PrependAppend_x86" },
    { 47, "ProcInject_PrependAppend_x64" },
    { 51, "ProcInject_Execute" },
    { 52, "ProcInject_AllocationMethod" },
    { 50, "bUsesCookies" },
    { 54, "HostHeader" },
};

std::map<DWORD, std::map<DWORD, std::string>> enums{
    { 1,
      { { 0x0, "HTTP" },
        { 0x1, "Hybrid HTTP DNS" },
        { 0x2, "SMB" },
        { 0x4, "TCP" },
        { 0x8, "HTTPS" },
        { 0x10, "Bind TCP" } } },
};

std::string PrintHex(PUCHAR lpAddress, DWORD dwSize) {
    std::string string = "";
    for(auto i = 0; i < dwSize; i++) {
        char buf[3];
        sprintf(buf, "%02x", lpAddress[i]);
        string += buf;
        string += " ";
    }
    return string;
}

std::string PrettyPrintConfiguration(PCHAR address, DWORD dwOffset) {
    USHORT setting{ *reinterpret_cast<PUSHORT>(address + dwOffset) };
    USHORT type{ *reinterpret_cast<PUSHORT>(address + dwOffset + 2) };
    USHORT size{ *reinterpret_cast<PUSHORT>(address + dwOffset + 4) };

    // Swap endianness
    setting = ((setting & 0xFF) << 8) | (setting >> 8);
    type = ((type & 0xFF) << 8) | (type >> 8);
    size = ((size & 0xFF) << 8) | (size >> 8);

    std::string name{ names.count(setting) ? names.at(setting) : ("Unknown Setting " + std::to_string(setting)) };
    if(type == 0x0001) {   // TYPE_SHORT
        USHORT data{ *reinterpret_cast<PUSHORT>(address + dwOffset + 6) };
        data = ((data & 0xFF) << 8) | (data >> 8);
        if(enums.count(setting) && enums.at(setting).count(data)) {
            return name + ": " + enums.at(setting).at(data);
        }
        return name + ": " + std::to_string(data);
    } else if(type == 0x0002) {   // TYPE_INT
        DWORD data{ *reinterpret_cast<PDWORD>(address + dwOffset + 6) };
        data = ((data & 0xFF) << 24) | ((data & 0xFF00) << 8) | ((data & 0xFF0000) >> 8) | (data >> 24);
        if(enums.count(setting) && enums.at(setting).count(data)) {
            return name + ": " + enums.at(setting).at(data);
        }
        return name + ": " + std::to_string(data);
    } else if(type == 0x0003) {
        PUCHAR data{ reinterpret_cast<PUCHAR>(address + dwOffset + 6) };
        bool binary = false;
        bool ended = false;
        for(USHORT idx = 0; idx < size && !ended && !binary; idx++) {
            if(data[idx] == '\0') {
                ended = true;
            } else if(data[idx] > 0x7F || data[idx] < 0x20) {
                binary = true;
            }
        }

        if(!binary) {
            return name + ": " + std::string{ reinterpret_cast<PCHAR>(data) };
        } else {
            return name + ": " + PrintHex(data, size);
        }
    } else {
        return "";
    }
}

bool DumpBeaconInformation(const MemoryWrapper<>& memory) {
    LOG_VERBOSE(3, "Preparing to try to dump cobalt strike configuration");
    auto info{ FindBeaconInfo(memory) };
    if(info) {
        // Beacon found; create file to dump to
        SYSTEMTIME time{};
        GetLocalTime(&time);
        auto pid{ GetProcessId(memory.process) };
        auto wFileName{ L"bluespawn-" + ToWstringPad(time.wMonth) + L"-" + ToWstringPad(time.wDay) + L"-" +
                        ToWstringPad(time.wYear, 4) + L"-" + ToWstringPad(time.wHour) + ToWstringPad(time.wMinute) +
                        L"-" + ToWstringPad(time.wSecond) + L"-PID-" + ToWstringPad(pid, 5) };
        auto num = 0ul;
        while(FileSystem::CheckFileExists(wFileName + L"-" + std::to_wstring(num))) {
            num++;
        }

        FileSystem::File file{ wFileName + L"-" + std::to_wstring(num) };
        file.Create();

        std::string output{};
        PCHAR memory{ info->GetAsPointer<CHAR>() };
        DWORD dwOffset{ 0 };
        while(dwOffset < info->GetSize()) {
            output += PrettyPrintConfiguration(memory, dwOffset) + "\n";
            auto size{ *reinterpret_cast<PUSHORT>(memory + dwOffset + 4) };
            size = ((size & 0xFF) << 8) | (size >> 8);
            dwOffset += size + 6;
        }
        file.Write(const_cast<char*>(output.c_str()), 0, output.length());

        return true;
    } else
        return false;
}

```

`BLUESPAWN-win-client/src/util/processes/ProcessUtils.cpp`:

```cpp
#include "util/processes/ProcessUtils.h"

#include <Psapi.h>

#include "util/StringUtils.h"
#include "util/filesystem/FileSystem.h"
#include "util/log/Log.h"

#include "shlwapi.h"

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    PVOID Handle;
} CURDIR, *PCURDIR;

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    WORD Flags;
    WORD Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS_ {
    ULONG MaximumLength;
    ULONG Length;
    ULONG Flags;
    ULONG DebugFlags;
    PVOID ConsoleHandle;
    ULONG ConsoleFlags;
    PVOID StandardInput;
    PVOID StandardOutput;
    PVOID StandardError;
    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];
    ULONG EnvironmentSize;
} RTL_USER_PROCESS_PARAMETERS_, *PRTL_USER_PROCESS_PARAMETERS_;

bool HookIsOkay(const Hook& hook) {
    // Once Detours is set up, this will become significantly more complicated...
    return false;
}

std::vector<LPVOID> GetExecutableNonImageSections(DWORD pid) {
    // Make use of APIs in PE Sieve...
    return {};
}

std::wstring GetProcessCommandline(const HandleWrapper& process) {
    if(process) {
        PROCESS_BASIC_INFORMATION information{};
        NTSTATUS status = Linker::NtQueryInformationProcess(process, ProcessBasicInformation, &information,
                                                            sizeof(information), nullptr);
        if(NT_SUCCESS(status)) {
            auto peb = information.PebBaseAddress;

            ULONG_PTR pointer{};
            if(!ReadProcessMemory(process, &peb->ProcessParameters, &pointer, sizeof(pointer), nullptr)) {
                LOG_WARNING("Unable to read memory from process with PID "
                            << GetProcessId(process) << " to find its command line (error " << GetLastError() << ")");
                return {};
            }
            RTL_USER_PROCESS_PARAMETERS_ params{};
            if(!ReadProcessMemory(process, LPVOID(pointer), &params, sizeof(params), nullptr)) {
                LOG_WARNING("Unable to read memory from process with PID "
                            << GetProcessId(process) << " to find its command line (error " << GetLastError() << ")");
                return {};
            }

            DWORD dwLength = params.CommandLine.Length;
            auto cmdline =
                AllocationWrapper{ new WCHAR[dwLength / 2 + 1], dwLength + 2, AllocationWrapper::CPP_ARRAY_ALLOC };
            if(!ReadProcessMemory(process, params.CommandLine.Buffer, cmdline, dwLength, nullptr)) {
                LOG_WARNING("Unable to read memory from process with PID "
                            << GetProcessId(process) << " to find its command line (error " << GetLastError() << ")");
                return {};
            }
            cmdline.SetByte(dwLength, 0);
            cmdline.SetByte(dwLength + 1, 0);

            return std::wstring{ reinterpret_cast<PWCHAR>(LPVOID(cmdline)) };
        } else {
            LOG_WARNING("Unable to query information from process with PID "
                        << GetProcessId(process) << " to find its command line (error " << status << ")");
            return {};
        }
    } else {
        LOG_WARNING("Unable to get command line of invalid process");
        return {};
    }
}

std::wstring GetProcessCommandline(DWORD dwPID) {
    HandleWrapper process{ OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, dwPID) };
    if(process) {
        return GetProcessCommandline(process);
    } else {
        LOG_WARNING("Unable to open process with PID " << dwPID << " to find its command line (error " << GetLastError()
                                                       << ")");
        return {};
    }
}

std::wstring GetProcessImage(const HandleWrapper& process) {
    if(process) {
        std::vector<WCHAR> name(MAX_PATH);
        DWORD dwSize{ MAX_PATH };
        QueryFullProcessImageNameW(process, 0, name.data(), &dwSize);
        dwSize += 1;
        name.resize(dwSize);
        if(QueryFullProcessImageNameW(process, 0, name.data(), &dwSize)) {
            return name.data();
        } else {
            LOG_WARNING("Unable to get image path of process - " << SYSTEM_ERROR);
            return {};
        }
    } else {
        LOG_WARNING("Unable to get image path of invalid process");
        return {};
    }
}

std::wstring GetProcessImage(DWORD dwPID) {
    HandleWrapper process{ OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, dwPID) };
    if(process) {
        return GetProcessImage(process);
    } else {
        LOG_WARNING("Unable to open process with PID " << dwPID << " to find its command line (error " << GetLastError()
                                                       << ")");
        return {};
    }
}

std::vector<std::wstring> EnumModules(DWORD dwPID) {
    HandleWrapper hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, dwPID);
    if(hProcess) {
        return EnumModules(hProcess);
    } else {
        LOG_INFO(2, "Unable to open process with PID " << dwPID << " to enumerate its modules (error " << GetLastError()
                                                       << ")");
        return {};
    }
}

std::vector<std::wstring> EnumModules(const HandleWrapper& hProcess) {
    std::vector<HMODULE> modules(1024);
    DWORD dwBytesNeeded{};
    auto status{ EnumProcessModules(hProcess, modules.data(), 1024 * sizeof(HMODULE), &dwBytesNeeded) };
    while(dwBytesNeeded > modules.size() * sizeof(HMODULE)) {
        modules.resize(dwBytesNeeded / sizeof(HMODULE));
        status = EnumProcessModules(hProcess, modules.data(), 1024 * sizeof(HMODULE), &dwBytesNeeded);
    }

    std::vector<std::wstring> vModules{};

    if(status){
        for(auto mod : modules) {
            WCHAR path[MAX_PATH];
            if(GetModuleFileNameExW(hProcess, mod, path, MAX_PATH)) {
                vModules.emplace_back(path);
            } else {
                LOG_WARNING("Unable to get name of module at " << mod << " in process with PID "
                                                               << GetProcessId(hProcess));
            }
        }
    } else {
        LOG_WARNING("Unable to enumerate modules in process with PID " << GetProcessId(hProcess) << " (Error "
                                                                       << GetLastError() << ")");
    }

    return vModules;
}

LPVOID GetModuleAddress(DWORD dwPID, const std::wstring& wsModuleName) {
    HandleWrapper hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, dwPID);
    if(hProcess) {
        return GetModuleAddress(hProcess, wsModuleName);
    } else {
        LOG_INFO(2, "Unable to open process with PID " << dwPID << " to enumerate its modules (error " << GetLastError()
                                                       << ")");
        return {};
    }
}

LPVOID GetModuleAddress(const HandleWrapper& hProcess, const std::wstring& wsModuleName) {
    std::vector<HMODULE> modules(1024);
    DWORD dwBytesNeeded{};
    auto status{ EnumProcessModules(hProcess, modules.data(), 1024 * sizeof(HMODULE), &dwBytesNeeded) };
    while(dwBytesNeeded > modules.size() * sizeof(HMODULE)){
        modules.resize(dwBytesNeeded / sizeof(HMODULE));
        status = EnumProcessModules(hProcess, modules.data(), 1024 * sizeof(HMODULE), &dwBytesNeeded);
    }

    if(status){
        for(auto mod : modules) {
            WCHAR path[MAX_PATH];
            if(GetModuleFileNameExW(hProcess, mod, path, MAX_PATH)) {
                if(CompareIgnoreCaseW(path, wsModuleName)) {
                    return mod;
                }
            } else {
                LOG_WARNING("Unable to get name of module at " << mod << " in process with PID "
                                                               << GetProcessId(hProcess));
            }
        }
    } else {
        LOG_WARNING("Unable to enumerate modules in process with PID " << GetProcessId(hProcess) << " (Error "
                                                                       << GetLastError() << ")");
    }

    LOG_WARNING("Unable to find address of module " << wsModuleName << " in process with PID "
                                                    << GetProcessId(hProcess));
    return nullptr;
}

DWORD GetRegionSize(const HandleWrapper& hProcess, LPVOID lpBaseAddress) {
    DWORD dwImageSize = 0;
    ULONG_PTR address = reinterpret_cast<ULONG_PTR>(lpBaseAddress);

    while(true) {
        MEMORY_BASIC_INFORMATION memory{};
        if(VirtualQueryEx(hProcess, reinterpret_cast<LPVOID>(address), &memory, sizeof(memory))) {
            if(memory.AllocationBase == lpBaseAddress) {
                dwImageSize += memory.RegionSize;
                address += memory.RegionSize;
            } else
                break;
        } else
            break;
    }

    LOG_VERBOSE(2, "Determined the size of the region to remove is " << dwImageSize);
    return dwImageSize;
}

DWORD GetRegionSize(DWORD dwPID, LPVOID lpBaseAddress) {
    HandleWrapper hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, dwPID);
    if(hProcess) {
        return GetRegionSize(hProcess, lpBaseAddress);
    } else {
        LOG_WARNING("Unable to open process with PID " << dwPID << " to determine size of region at " << lpBaseAddress
                                                       << " (error " << GetLastError() << ")");
        return {};
    }
}

std::optional<FileSystem::File> GetMappedFile(DWORD dwPID, LPVOID lpAllocationBase) {
    HandleWrapper hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, dwPID);
    if(hProcess) {
        return GetMappedFile(hProcess, lpAllocationBase);
    } else {
        LOG_WARNING("Unable to open process with PID " << dwPID << " to determine size of region at "
                                                       << lpAllocationBase << " (error " << GetLastError() << ")");
        return {};
    }
}

std::optional<FileSystem::File> GetMappedFile(const HandleWrapper& hProcess, LPVOID lpAllocationBase) {
    std::vector<WCHAR> filename(MAX_PATH);
    auto len = GetMappedFileNameW(hProcess, lpAllocationBase, filename.data(), MAX_PATH);
    if(!len) {
        return std::nullopt;
    }

    return FileSystem::File(std::wstring{ filename.data(), len });
}

namespace Utils::Process {
    AllocationWrapper ReadProcessMemory(const HandleWrapper& hProcess, LPVOID lpBaseAddress, DWORD dwSize) {
        if(hProcess) {
            if(dwSize == -1) {
                dwSize = GetRegionSize(hProcess, lpBaseAddress);
            }

            AllocationWrapper wrapper{ VirtualAlloc(nullptr, dwSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE),
                                       dwSize };

            if(::ReadProcessMemory(hProcess, lpBaseAddress, wrapper, dwSize, nullptr)) {
                return wrapper;
            } else {
                LOG_WARNING("Unable to read memory at " << lpBaseAddress << " in process with PID "
                                                        << GetProcessId(hProcess) << " (error " << GetLastError()
                                                        << ")");
            }
        } else {
            LOG_WARNING("Unable to read memory from invalid process!");
        }
        return { nullptr, 0 };
    }

    AllocationWrapper ReadProcessMemory(DWORD dwPID, LPVOID lpBaseAddress, DWORD dwSize) {
        HandleWrapper hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, dwPID);
        if(hProcess) {
            return ReadProcessMemory(hProcess, lpBaseAddress, dwSize);
        } else {
            LOG_WARNING("Unable to open process with PID " << dwPID << " to read memory at " << lpBaseAddress
                                                           << " (error " << GetLastError() << ")");
            return { nullptr, 0 };
        }
    }
}   // namespace Utils::Process

```

`BLUESPAWN-win-client/src/yara/args.c`:

```c
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include <yara.h>

#include "args.h"

#define args_is_long_arg(arg)  \
    (arg[0] == '-' && arg[1] == '-' && arg[2] != '\0')


#define args_is_short_arg(arg)  \
    (arg[0] == '-' && arg[1] != '-' && arg[1] != '\0')


args_option_t* args_get_short_option(
    args_option_t* options,
    const char opt){
    while(options->type != ARGS_OPT_END){
        if(opt == options->short_name)
            return options;

        options++;
    }

    return NULL;
}


args_option_t* args_get_long_option(
    args_option_t* options,
    const char* arg){
    arg += 2; // skip starting --

    while(options->type != ARGS_OPT_END){
        if(options->long_name != NULL){
            size_t l = strlen(options->long_name);

            if((arg[l] == '\0' || arg[l] == '=') &&
               strstr(arg, options->long_name) == arg){
                return options;
            }
        }

        options++;
    }

    return NULL;
}


args_error_type_t args_parse_option(
    args_option_t* opt,
    const char* opt_arg,
    int* opt_arg_was_used){
    char* endptr = NULL;

    if(opt_arg_was_used != NULL)
        *opt_arg_was_used = 0;

    if(opt->count == opt->max_count)
        return ARGS_ERROR_TOO_MANY;

    switch(opt->type){
    case ARGS_OPT_BOOLEAN:
        *(bool*) opt->value = true;
        break;

    case ARGS_OPT_INTEGER:

        if(opt_arg == NULL)
            return ARGS_ERROR_REQUIRED_INTEGER_ARG;

        *(int*) opt->value = strtol(opt_arg, &endptr, 0);

        if(*endptr != '\0')
            return ARGS_ERROR_REQUIRED_INTEGER_ARG;

        if(opt_arg_was_used != NULL)
            *opt_arg_was_used = 1;

        break;

    case ARGS_OPT_STRING:

        if(opt_arg == NULL)
            return ARGS_ERROR_REQUIRED_STRING_ARG;

        if(opt->max_count > 1)
            ((const char**) opt->value)[opt->count] = opt_arg;
        else
            *(const char**) opt->value = opt_arg;

        if(opt_arg_was_used != NULL)
            *opt_arg_was_used = 1;

        break;

    default:
        assert(0);
    }

    opt->count++;

    return ARGS_ERROR_OK;
}


void args_print_error(
    args_error_type_t error,
    const char* option){
    switch(error){
    case ARGS_ERROR_UNKNOWN_OPT:
        fprintf(stderr, "unknown option `%s`\n", option);
        break;
    case ARGS_ERROR_TOO_MANY:
        fprintf(stderr, "too many `%s` options\n", option);
        break;
    case ARGS_ERROR_REQUIRED_INTEGER_ARG:
        fprintf(stderr, "option `%s` requires an integer argument\n", option);
        break;
    case ARGS_ERROR_REQUIRED_STRING_ARG:
        fprintf(stderr, "option `%s` requires a string argument\n", option);
        break;
    case ARGS_ERROR_UNEXPECTED_ARG:
        fprintf(stderr, "option `%s` doesn't expect an argument\n", option);
        break;
    default:
        return;
    }
}


int args_parse(
    args_option_t* options,
    int argc,
    const char** argv){
    args_error_type_t error = ARGS_ERROR_OK;

    int i = 1;  // start with i = 1, argv[0] is the program name
    int o = 0;

    while(i < argc){
        const char* arg = argv[i];

        if(args_is_long_arg(arg)){
            args_option_t* opt = args_get_long_option(options, arg);

            if(opt != NULL){
                const char* equal = strchr(arg, '=');

                if(equal)
                    error = args_parse_option(opt, equal + 1, NULL);
                else
                    error = args_parse_option(opt, NULL, NULL);
            } else{
                error = ARGS_ERROR_UNKNOWN_OPT;
            }
        } else if(args_is_short_arg(arg)){
            for(int j = 1; arg[j] != '\0'; j++){
                args_option_t* opt = args_get_short_option(options, arg[j]);

                if(opt != NULL){
                    if(arg[j + 1] == '\0'){
                        int arg_used;

                        // short option followed by a space, argv[i + 1] could be
                        // an argument for the option (i.e: -a <arg>)
                        error = args_parse_option(opt, argv[i + 1], &arg_used);

                        // argv[i + 1] was actually an argument to the option, skip it.
                        if(arg_used)
                            i++;
                    } else{
                        // short option followed by another option (i.e: -ab), no
                        // argument for this option
                        error = args_parse_option(opt, NULL, NULL);
                    }
                } else{
                    error = ARGS_ERROR_UNKNOWN_OPT;
                }

                if(error != ARGS_ERROR_OK)
                    break;
            }
        } else{
            argv[o++] = arg;
        }

        if(error != ARGS_ERROR_OK){
            args_print_error(error, arg);
            exit(1);
        }

        i++;
    }

    return o;
}


void args_print_usage(
    args_option_t* options,
    int help_alignment){
    char buffer[128];

    for(; options->type != ARGS_OPT_END; options++){
        int len = sprintf(buffer, "  ");

        if(options->short_name != '\0')
            len += sprintf(buffer + len, "-%c", options->short_name);
        else
            len += sprintf(buffer + len, "     ");

        if(options->short_name != '\0' && options->long_name != NULL)
            len += sprintf(buffer + len, ",  ");

        if(options->long_name != NULL)
            len += sprintf(buffer + len, "--%s", options->long_name);

        if(options->type == ARGS_OPT_STRING ||
           options->type == ARGS_OPT_INTEGER){
            len += sprintf(
                buffer + len,
                "%s%s",
                (options->long_name != NULL) ? "=" : " ",
                options->type_help);
        }

        printf("%-*s%s\n", help_alignment, buffer, options->help);
    }
}

```

`BLUESPAWN-win-client/src/yara/args.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef ARGPARSE_H
#define ARGPARSE_H

#include <stdio.h>


#ifdef __cplusplus
extern "C" {
#endif


    typedef enum _args_error_type {
        ARGS_ERROR_OK,
        ARGS_ERROR_UNKNOWN_OPT,
        ARGS_ERROR_TOO_MANY,
        ARGS_ERROR_REQUIRED_INTEGER_ARG,
        ARGS_ERROR_REQUIRED_STRING_ARG,
        ARGS_ERROR_UNEXPECTED_ARG,
    } args_error_type_t;


    typedef enum _args_option_type {
        // special
        ARGS_OPT_END,
        ARGS_OPT_GROUP,
        // options with no arguments
        ARGS_OPT_BOOLEAN,
        // options with arguments (optional or required)
        ARGS_OPT_INTEGER,
        ARGS_OPT_STRING,
    } args_option_type_t;


    typedef struct _args_option {
        args_option_type_t type;
        const char short_name;
        const char* long_name;
        void* value;
        int max_count;
        const char* help;
        const char* type_help;
        int count;
    } args_option_t;


#define OPT_BOOLEAN(short_name, long_name, value, ...) \
    { ARGS_OPT_BOOLEAN, short_name, long_name, value, 1, __VA_ARGS__ }

#define OPT_INTEGER(short_name, long_name, value, ...) \
    { ARGS_OPT_INTEGER, short_name, long_name, value, 1, __VA_ARGS__ }

#define OPT_STRING_MULTI(short_name, long_name, value, max_count, ...) \
    { ARGS_OPT_STRING, short_name, long_name, value, max_count, __VA_ARGS__ }

#define OPT_STRING(short_name, long_name, value, ...) \
    OPT_STRING_MULTI(short_name, long_name, value, 1, __VA_ARGS__)

#define OPT_END() { ARGS_OPT_END, 0 }


    int args_parse(
        args_option_t* options,
        int argc,
        const char** argv);


    void args_print_usage(
        args_option_t* options,
        int alignment);


#ifdef __cplusplus
}
#endif

#endif

```

`BLUESPAWN-win-client/src/yara/common.h`:

```h
/*
Copyright (c) 2017. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef COMMON_H
#define COMMON_H

#include <stdbool.h>

#ifdef _WIN32
#include <io.h>
#define access    _access_s
#else
#include <unistd.h>
#endif

#define exit_with_code(code) { result = code; goto _exit; }


bool compile_files(
    YR_COMPILER* compiler,
    int argc,
    const char** argv){
    for(int i = 0; i < argc - 1; i++){
        FILE* rule_file;
        const char* ns;
        const char* file_name;
        char* colon = NULL;
        int errors;

        if(access(argv[i], 0) != 0){
            // A file with the name specified by the command-line argument wasn't
            // found, it may be because the name is prefixed with a namespace, so
            // lets try to find the colon that separates the namespace from the
            /// actual file name.
            colon = (char*) strchr(argv[i], ':');
        }

        // The namespace delimiter must be a colon not followed by a slash or
        // backslash.
        if(colon && *(colon + 1) != '\\' && *(colon + 1) != '/'){

            file_name = colon + 1;
            *colon = '\0';
            ns = argv[i];
        } else{
            file_name = argv[i];
            ns = NULL;
        }

        if(strcmp(file_name, "-") == 0)
            rule_file = stdin;
        else
            rule_file = fopen(file_name, "r");

        if(rule_file == NULL){
            fprintf(stderr, "error: could not open file: %s\n", file_name);
            return false;
        }

        errors = yr_compiler_add_file(compiler, rule_file, ns, file_name);

        fclose(rule_file);

        if(errors > 0)
            return false;
    }

    return true;
}


bool is_integer(const char* str){
    if(*str == '-')
        str++;

    if(*str == '\0')
        return false;

    while(*str){
        if(!isdigit(*str))
            return false;
        str++;
    }

    return true;
}


bool is_float(const char* str){
    bool has_dot = false;

    if(*str == '-')      // skip the minus sign if present
        str++;

    if(*str == '.')      // float can't start with a dot
        return false;

    while(*str){
        if(*str == '.'){
            if(has_dot)      // two dots, not a float
                return false;

            has_dot = true;
        } else if(!isdigit(*str)){
            return false;
        }

        str++;
    }

    return has_dot; // to be float must contain a dot
}

#endif

```

`BLUESPAWN-win-client/src/yara/yarac.c`:

```c
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _WIN32

#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <time.h>

#else

#include <windows.h>

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <yara.h>

#include "args.h"
#include "common.h"

/// BEGIN MODIFICATIONS
#include <zip.h>
#include <string>
/// END MODITIFICATIONS

#ifndef MAX_PATH
#define MAX_PATH 256
#endif

#define MAX_ARGS_EXT_VAR   32


typedef struct COMPILER_RESULTS
{
    int errors;
    int warnings;

} COMPILER_RESULTS;


static char* atom_quality_table;
static char* ext_vars[MAX_ARGS_EXT_VAR + 1];
static bool ignore_warnings = false;
static bool show_version = false;
static bool show_help = false;
static bool fail_on_warnings = false;
static int max_strings_per_rule = 10000;


#define USAGE_STRING \
    "Usage: yarac [OPTION]... [NAMESPACE:]SOURCE_FILE... OUTPUT_FILE"

args_option_t options[] =
{
  OPT_STRING(0, "atom-quality-table", &atom_quality_table,
      "path to a file with the atom quality table", "FILE"),

  OPT_STRING_MULTI('d', "define", &ext_vars, MAX_ARGS_EXT_VAR,
      "define external variable", "VAR=VALUE"),

  OPT_BOOLEAN(0, "fail-on-warnings", &fail_on_warnings,
      "fail on warnings"),

  OPT_BOOLEAN('h', "help", &show_help,
      "show this help and exit"),

  OPT_INTEGER(0, "max-strings-per-rule", &max_strings_per_rule,
      "set maximum number of strings per rule (default=10000)", "NUMBER"),

  OPT_BOOLEAN('w', "no-warnings", &ignore_warnings,
      "disable warnings"),

  OPT_BOOLEAN('v', "version", &show_version,
      "show version information"),

  OPT_END()
};


static void report_error(
    int error_level,
    const char* file_name,
    int line_number,
    const YR_RULE* rule,
    const char* message,
    void* user_data){
    char* msg_type;

    if(error_level == YARA_ERROR_LEVEL_ERROR){
        msg_type = "error";
    } else if(!ignore_warnings){
        COMPILER_RESULTS* compiler_results = (COMPILER_RESULTS*) user_data;
        compiler_results->warnings++;
        msg_type = "warning";
    } else{
        return;
    }

    if(rule != NULL){
        fprintf(
            stderr,
            "%s(%d): %s in rule \"%s\": %s\n",
            file_name,
            line_number,
            msg_type,
            rule->identifier,
            message);
    } else{
        fprintf(
            stderr,
            "%s(%d): %s: %s\n",
            file_name,
            line_number,
            msg_type,
            message);
    }
}


static bool define_external_variables(
    YR_COMPILER* compiler){
    for(int i = 0; ext_vars[i] != NULL; i++){
        char* equal_sign = strchr(ext_vars[i], '=');

        if(!equal_sign){
            fprintf(stderr, "error: wrong syntax for `-d` option.\n");
            return false;
        }

        // Replace the equal sign with null character to split the external
        // variable definition (i.e: myvar=somevalue) in two strings: identifier
        // and value.

        *equal_sign = '\0';

        char* identifier = ext_vars[i];
        char* value = equal_sign + 1;

        if(is_float(value)){
            yr_compiler_define_float_variable(
                compiler,
                identifier,
                atof(value));
        } else if(is_integer(value)){
            yr_compiler_define_integer_variable(
                compiler,
                identifier,
                atoi(value));
        } else if(strcmp(value, "true") == 0 || strcmp(value, "false") == 0){
            yr_compiler_define_boolean_variable(
                compiler,
                identifier,
                strcmp(value, "true") == 0);
        } else{
            yr_compiler_define_string_variable(
                compiler,
                identifier,
                value);
        }
    }

    return true;
}


int main(
    int argc,
    const char** argv){
    COMPILER_RESULTS cr;

    YR_COMPILER* compiler = NULL;
    YR_RULES* rules = NULL;

    int result;

    argc = args_parse(options, argc, argv);

    if(show_version){
        printf("%s\n", YR_VERSION);
        return EXIT_SUCCESS;
    }

    if(show_help){
        printf("%s\n\n", USAGE_STRING);

        args_print_usage(options, 40);
        printf("\nSend bug reports and suggestions to: vmalvarez@virustotal.com\n");

        return EXIT_SUCCESS;
    }

    if(argc < 2){
        fprintf(stderr, "yarac: wrong number of arguments\n");
        fprintf(stderr, "%s\n\n", USAGE_STRING);
        fprintf(stderr, "Try `--help` for more options\n");

        exit_with_code(EXIT_FAILURE);
    }

    result = yr_initialize();

    if(result != ERROR_SUCCESS)
        exit_with_code(EXIT_FAILURE);

    if(yr_compiler_create(&compiler) != ERROR_SUCCESS)
        exit_with_code(EXIT_FAILURE);

    if(!define_external_variables(compiler))
        exit_with_code(EXIT_FAILURE);

    if(atom_quality_table != NULL){
        result = yr_compiler_load_atom_quality_table(
            compiler, atom_quality_table, 0);

        if(result != ERROR_SUCCESS){
            fprintf(stderr, "error loading atom quality table\n");
            exit_with_code(EXIT_FAILURE);
        }
    }

    cr.errors = 0;
    cr.warnings = 0;

    yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);

    if(!compile_files(compiler, argc, argv))
        exit_with_code(EXIT_FAILURE);

    if(cr.errors > 0)
        exit_with_code(EXIT_FAILURE);

    if(fail_on_warnings && cr.warnings > 0)
        exit_with_code(EXIT_FAILURE);

    result = yr_compiler_get_rules(compiler, &rules);

    if(result != ERROR_SUCCESS){
        fprintf(stderr, "error: %d\n", result);
        exit_with_code(EXIT_FAILURE);
    }

    result = yr_rules_save(rules, argv[argc - 1]);

    if(result != ERROR_SUCCESS){
        fprintf(stderr, "error: %d\n", result);
        exit_with_code(EXIT_FAILURE);
    }
    /// BEGIN MODIFICATIONS
    else{
        std::string name = std::string{ argv[argc - 1] } + ".z";
        int err{};
        auto zip = zip_open(name.c_str(), ZIP_CREATE, &err);
        if(zip){
            auto source = zip_source_file(zip, argv[argc - 1], 0, 0);
            if(source){
                if(-1 == zip_file_add(zip, "data", source, ZIP_FL_OVERWRITE)){
                    zip_close(zip);
                    zip_source_close(source);
                    goto _exit;
                }
                zip_source_close(source);
                zip_close(zip);
                MoveFileExA(name.c_str(), argv[argc - 1], MOVEFILE_REPLACE_EXISTING);
            }
            if(!source){
                zip_close(zip);
                goto _exit;
            }
        } else{
            goto _exit;
        }
    }
    /// END MODIFICATIONS

    result = EXIT_SUCCESS;

_exit:

    if(compiler != NULL)
        yr_compiler_destroy(compiler);

    if(rules != NULL)
        yr_rules_destroy(rules);

    yr_finalize();

    return result;
}

```

`BLUESPAWN-win-client/yarac.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7C72350B-AA5B-41AD-8957-CE3924A7F11B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>yarac</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <VcpkgTriplet Condition="'$(Platform)'=='Win32'">x86-windows-static</VcpkgTriplet>
    <VcpkgTriplet Condition="'$(Platform)'=='x64'">x64-windows-static</VcpkgTriplet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)config\buildstructure.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <PreBuildEvent>
      <Command>del "$(ProjectDir)resources\severe" &amp;&amp; del "$(ProjectDir)resources\severe2" &amp;&amp; del "$(ProjectDir)resources\indicators"</Command>
    </PreBuildEvent>
	<PostBuildEvent>
      <Command>cmd /c "
"$(SolutionDir)artifacts\$(PlatformTarget)\$(Configuration)\yarac.exe" "$(ProjectDir)resources\severe.yar" "$(ProjectDir)resources\severe" &amp; 
"$(SolutionDir)artifacts\$(PlatformTarget)\$(Configuration)\yarac.exe" "$(ProjectDir)resources\severe2.yar" "$(ProjectDir)resources\severe2" &amp; 
"$(SolutionDir)artifacts\$(PlatformTarget)\$(Configuration)\yarac.exe" "$(ProjectDir)resources\indicators.yar" "$(ProjectDir)resources\indicators" &amp; 
exit 0
"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <CompileAs>CompileAsCpp</CompileAs>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <CompileAs>CompileAsCpp</CompileAs>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CompileAs>CompileAsCpp</CompileAs>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>No</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>ws2_32.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CompileAs>CompileAsCpp</CompileAs>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>No</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>ws2_32.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\yara\args.c" />
    <ClCompile Include="src\yara\yarac.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`BLUESPAWN.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28922.388
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BLUESPAWN-win-client", "BLUESPAWN-win-client\BLUESPAWN-client.vcxproj", "{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}"
	ProjectSection(ProjectDependencies) = postProject
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B} = {7C72350B-AA5B-41AD-8957-CE3924A7F11B}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pe-sieve", "BLUESPAWN-win-client\pe-sieve.vcxproj", "{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libpeconv", "BLUESPAWN-win-client\libpeconv.vcxproj", "{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "yarac", "BLUESPAWN-win-client\yarac.vcxproj", "{7C72350B-AA5B-41AD-8957-CE3924A7F11B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Debug|x64.ActiveCfg = Debug|x64
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Debug|x64.Build.0 = Debug|x64
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Debug|x86.ActiveCfg = Debug|Win32
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Debug|x86.Build.0 = Debug|Win32
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Release|x64.ActiveCfg = Release|x64
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Release|x64.Build.0 = Release|x64
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Release|x86.ActiveCfg = Release|Win32
		{159B2E72-9553-4E17-9BEC-CB92FCA8D0B0}.Release|x86.Build.0 = Release|Win32
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Debug|x64.ActiveCfg = Debug|x64
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Debug|x64.Build.0 = Debug|x64
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Debug|x86.ActiveCfg = Debug|Win32
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Debug|x86.Build.0 = Debug|Win32
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Release|x64.ActiveCfg = Release|x64
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Release|x64.Build.0 = Release|x64
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Release|x86.ActiveCfg = Release|Win32
		{BEC01F8E-5892-3F6F-A741-5BBD1D0F4EF9}.Release|x86.Build.0 = Release|Win32
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Debug|x64.ActiveCfg = Debug|x64
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Debug|x64.Build.0 = Debug|x64
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Debug|x86.ActiveCfg = Debug|Win32
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Debug|x86.Build.0 = Debug|Win32
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Release|x64.ActiveCfg = Release|x64
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Release|x64.Build.0 = Release|x64
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Release|x86.ActiveCfg = Release|Win32
		{C9D09618-1DE6-3323-AED8-9B885AC8D9F3}.Release|x86.Build.0 = Release|Win32
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Debug|x64.ActiveCfg = Debug|x64
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Debug|x64.Build.0 = Debug|x64
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Debug|x86.ActiveCfg = Debug|Win32
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Debug|x86.Build.0 = Debug|Win32
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Release|x64.ActiveCfg = Release|x64
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Release|x64.Build.0 = Release|x64
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Release|x86.ActiveCfg = Release|Win32
		{7C72350B-AA5B-41AD-8957-CE3924A7F11B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4A517F1F-F52C-42AC-BD95-A9D96484CB3A}
	EndGlobalSection
EndGlobal

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at bluespawn@virginia.edu. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
![BLUESPAWN-logo2-temp](https://user-images.githubusercontent.com/3931697/89133344-0e439500-d4e9-11ea-992f-6ae8ebe66177.png)

# BLUESPAWN

![Version](https://img.shields.io/github/v/release/ION28/BLUESPAWN?include_prereleases) ![License](https://img.shields.io/github/license/ION28/BLUESPAWN?color=yellow) ![Platform](https://img.shields.io/badge/platform-x86%20%7C%20x64-lightgrey) ![Operating System](https://img.shields.io/badge/os-Windows%207%2F08%2B-blue) [![Discord](https://img.shields.io/discord/713926524167913544?color=blueviolet&label=Discord&logo=Discord&logoColor=white)](https://discord.gg/JMxPPfZ)

#### Code Status

[![Win Client build](https://github.com/ION28/BLUESPAWN/workflows/BLUESPAWN-win-client%20build/badge.svg)](https://github.com/ION28/BLUESPAWN/actions) [![Codacy Badge](https://api.codacy.com/project/badge/Grade/d070613d09404e14b47f69147a99064e)](https://www.codacy.com/manual/ION28/BLUESPAWN?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=ION28/BLUESPAWN&amp;utm_campaign=Badge_Grade) ![Last Commit](https://img.shields.io/github/last-commit/ION28/BLUESPAWN/develop)

## Our Mission
BLUESPAWN helps blue teams monitor systems in real-time against active attackers by detecting anomalous activity

## What is BLUESPAWN
BLUESPAWN is an **active defense** and **endpoint detection and response tool** which means it can be used by defenders to quickly **detect**, **identify**, and **eliminate** malicious activity and malware across a network.

## Get Involved & Contribute to the project
Want to help make BLUESPAWN even more effective at locating and stopping malware? Join us on [the BLUESPAWN Discord Server](https://discord.gg/JMxPPfZ) and help with development or even just suggest a feature or report a bug. No experience required - there's no better way to learn about development or security than by just jumping right in!

If you'd like to help contribute code, you can get started by checking out our wiki page on [setting up your development environment](https://github.com/ION28/BLUESPAWN/wiki/Setting-up-your-Development-Environment). Please feel free to reach out to us in Discord if you run into any problems getting set up! We generally track bugs and new features through Issues and coordinate in chat when doing any development work.

## Why we made BLUESPAWN
We've created and open-sourced this for a number of reasons which include the following:

* **Move Faster**: We wanted tooling specifically designed to quickly identify malicious activity on a system
* **Know our Coverage**: We wanted to know exactly what our tools could detect and not rely on blackbox software as much (ie AV programs). This approach will help us to better focus our efforts on specific lines of effort and have confidence in the status of others.
* **Better Understanding**: We wanted to better understand the Windows attack surface in order to defend it better
* **More Open-Source Blue Team Software**: While there are many open-source Red Team Tools out there, the vast majority of some of the best Blue Team tools are closed-source (ie, AVs, EDRs, SysInternals, etc). We shouldn't need to rely on security through obscurity to prevent malicious actors (obviously very difficult, but something to strive for!)
* **Demonstrate Features of Operating System APIs**: We combed through a ton of Microsoft Documentation, StackOverflow Answers, and more to create this. Hopefully others may find some of the code useful.

## Coverage of MITRE ATT&CK
Visit [this map](https://bluespawn.cloud/coverage/) to see current coverage capabilities

## Try out BLUESPAWN 

> Note: BLUESPAWN is under active *alpha* development, so many features may not work as expected yet and detections may be too narrow scope or generate lots of false positives.

> Note 2: BLUESPAWN is meant to be run by a security professional in most cases and as such, will detect on non-malicious activity sometimes. While BLUESPAWN helps to quickly surface potentially bad things, it expects the user to use the available information to make the final determination.

0. Check out the [Wiki pages](https://github.com/ION28/BLUESPAWN/wiki) to learn more about the available [command line options](https://github.com/ION28/BLUESPAWN/wiki/Getting-Started), [examples](https://github.com/ION28/BLUESPAWN/wiki/Examples), and more.
1. Download the latest release from [this page](https://github.com/ION28/BLUESPAWN/releases)
2. Open an Administrative Command Prompt
3. Run the following command to see the available options
```cmd
.\BLUESPAWN-client-x64.exe --help
```

### Mitigate Mode
4. Run the following from your Administrative Command Prompt to audit your system for the presence of many security settings
```cmd
.\BLUESPAWN-client-x64.exe --mitigate --action=audit
```
![BLUESPAWN in Action-Mitigate](https://user-images.githubusercontent.com/3931697/89669848-25e69900-d8ae-11ea-836d-1618d7377211.png)

### Hunt Mode
5. Run BLUESPAWN from the Administrative Command Prompt to hunt for malicious activity on the system
```cmd
.\BLUESPAWN-client-x64.exe --hunt -a Cursory --log=console,xml
```
![BLUESPAWN in Action-Hunt](https://user-images.githubusercontent.com/3931697/89669912-4878b200-d8ae-11ea-967b-03318468d711.png)

### Monitor Mode
6. Run BLUESPAWN from the Administrative Command Prompt to monitor for malicious activity on the system
```cmd
.\BLUESPAWN-client-x64.exe --monitor -a Cursory --log=console,xml
```
![BLUESPAWN in Action-Monitor](https://user-images.githubusercontent.com/3931697/89670008-752cc980-d8ae-11ea-8490-1e0473d5f3c6.png)


## Lines of Effort
BLUESPAWN consists of 3 major modes as listed below. Several of these modules have submodules (which may not be created in the codebase yet) as listed below and all are in varying stages of planning, research, and development. Additionally, they are supported by a number of other modules.

* **Hunt** (Hunts for evidence of malicious behavior)

* **Mitigate** (Mitigates vulnerabilities by applying security settings)

* **Monitor** (Continuously monitors the system for potentially malicious behavior)

* **Scan** (Used to assess items identified by hunts and make a decision whether or not it is suspicious/malware)

* **User** (Contains program main, IOBase, and other similar functions)

* **Util** (Contains a collection of modules that support core operations)
    * Configurations
    * Event Logs
    * File System
    * Log
    * PEs
    * Processes

## Talks, Publications, and Other Mentions

Here are some of the places you may have heard about the project :)

[![DEFCON 28 Blue Team Village](https://user-images.githubusercontent.com/3931697/89669226-11ee6780-d8ad-11ea-9361-fba4cb92c97c.png)](https://github.com/ION28/BLUESPAWN/blob/master/docs/media/Defcon28-BlueTeamVillage-BLUESPAWN-Presentation.pdf)

DEFCON 28 Blue Team Village - [Overview](https://cfc.blueteamvillage.org/call-for-content-2020/talk/NCWJFG/), [Slides](https://github.com/ION28/BLUESPAWN/blob/master/docs/media/Defcon28-BlueTeamVillage-BLUESPAWN-Presentation.pdf)

National Collegiate Cyber Defense Competition, 2020 Red Team Debrief - [Youtube](https://youtu.be/UsZhMRMGLMA?t=3582)

BLUESPAWN Research Paper at UVA - [Paper](https://libraetd.lib.virginia.edu/downloads/1j92g810n?filename=Smith_Jacob_Technical_Report.pdf), DOI 10.18130/v3-b1n6-ef83

## Contact Us
If you have any questions, comments, or suggestions, please feel free to send us an email at <bluespawn@virginia.edu> or message us in [the BLUESPAWN Discord Server](https://discord.gg/JMxPPfZ).

## Licensing & Compliance
The core BLUESPAWN code is licensed under [GNU General Public License (GPL) v3.0](https://github.com/ION28/BLUESPAWN/blob/master/LICENSE).

Note that the project integrates several other libraries to provide additional features/detections. One of these is Florian Roth's [signature-base](https://github.com/Neo23x0/signature-base) which is licensed under the [Creative Commons Attribution-NonCommercial 4.0 International License](http://creativecommons.org/licenses/by-nc/4.0/). YARA rules from this project are integrated into the standard build without any changes. In order to use BLUESPAWN for any commercial purposes, you must remove everything under the "Non-Commercial Only" line in [this file](https://github.com/ION28/BLUESPAWN/blob/master/BLUESPAWN-win-client/resources/severe2.yar) and recompile the project.

## Project Authors
Made with :heart: by the UVA Cyber Defense Team and the other awesome people in the core dev team listed below

* Jake Smith ([Github](https://github.com/ION28), [Twitter](https://twitter.com/jtsmith282))
* Jack McDowell ([Github](https://github.com/Jack-McDowell))
* Calvin Krist ([Github](https://github.com/CalvinKrist), [Twitter](https://twitter.com/CalvinKrist))
* Will Mayes ([Github](https://github.com/wtm99), [Twitter](https://twitter.com/will_mayes99))
* David Smith ([Github](https://github.com/DavidSmith166))
* Aaron Gdanski ([Github](https://github.com/agski331))
* Grant Matteo ([Github](https://github.com/GrantMatteo))

## Contributors
Thanks to all of the folks listed below for their contributions to BLUESPAWN!

* Alexander Kluth ([Github](https://github.com/akluth))
* Yehuda Hido Cohen ([Github](https://github.com/mryode))

Want to help? Take a look at the current issues, add ideas for new features, write some code, and create a pull request!

## Special Thanks
We would like to provide a special thank you to the following projects that have helped us to build BLUESPAWN:

* Github's support of open-source projects, especially the ability for unlimited use Github Actions
* Microsoft's documentation and examples on the Windows API
* The Department of Defense's Defense Information Systems Agency (DISA) for their great work in publishing STIGs and various other technical security guidance for Windows.
* [@hasherezade](https://github.com/hasherezade)'s [PE Sieve](https://github.com/hasherezade/pe-sieve), which currently manages our process analytics
* VirusTotal's [YARA](https://github.com/VirusTotal/yara) Project which we use to scan data for malicious identifiers
* The [Yara Rules Project](https://twitter.com/yararules)'s [Rules](https://github.com/Yara-Rules/rules) repository which contains a large collection of open-source YARA rules
* [@Neo23x0](https://github.com/Neo23x0)'s open-source [signature-base](https://github.com/Neo23x0/signature-base) project which contains a large collection of YARA rules
* The [MITRE's ATT&CK Project](https://attack.mitre.org/) which has put together an amazing framework for which to consider, document, and categorize attacker tradercraft
* Red Canary's [Atomic Red Team](https://github.com/redcanaryco/atomic-red-team) and [Invoke-AtomicRedTeam](https://github.com/redcanaryco/invoke-atomicredteam) Projects which have been incredibly useful in helping to test the detections we are building
* Amazon's [Open Source at AWS Initiative](https://aws.amazon.com/opensource/) who has provided our team some AWS promotional credits to help us reserach and test BLUESPAWN better
* The [NSA Cybersecurity Directorate](https://github.com/nsacyber)'s Windows [Event Forwarding Guidance](https://github.com/nsacyber/Event-Forwarding-Guidance)
* [Sean Metcalf](https://twitter.com/PyroTek3)'s Active Directory Security blog [ADSecurity](https://adsecurity.org/)
* Geoff Chappell's [website on Windows components](https://www.geoffchappell.com/index.htm)
* [Matt Graeber](https://twitter.com/mattifestation)'s amazing Windows Security research including his [Subverting Trust in Windows Paper](https://www.specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf)
* [@op7ic](https://github.com/op7ic)'s [EDR-Testing-Script](https://github.com/op7ic/EDR-Testing-Script) Project
* The Japan Computer Emergency Response Team (JPCERT)'s [Tool Analysis Result Sheet](https://jpcertcc.github.io/ToolAnalysisResultSheet/) for its documentation of attacker behavior and correlation with detection opportunities
* [@jarro2783](https://github.com/jarro2783)'s [cxxopts](https://github.com/jarro2783/cxxopts) which we use to parse command line arguments
* [@leethomason](https://github.com/leethomason)'s [tinyxml2](https://github.com/leethomason/tinyxml2) library which we use to output scan information to XML

```

`config/buildsettings.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <UseDebugLibraries Condition="'$(Configuration)'=='Release'">false</UseDebugLibraries>
    <UseDebugLibraries Condition="'$(Configuration)'=='Debug'">true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup>
    <_PropertySheetDisplayName>buildsettings</_PropertySheetDisplayName>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir)headers;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WarningLevel>Level1</WarningLevel>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <Optimization Condition="'$(Configuration)'=='Debug'">Disabled</Optimization>
      <Optimization Condition="'$(Configuration)'=='Release'">MaxSpeed</Optimization>
      <PreprocessorDefinitions>DELAYLOAD_IMPORTS_DEFINED;_UNICODE;UNICODE;_ITERATOR_DEBUG_LEVEL=0;_WIN32_WINNT=0x601;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary Condition="'$(Configuration)'=='Release'">MultiThreaded</RuntimeLibrary>
      <RuntimeLibrary Condition="'$(Configuration)'=='Debug'">MultiThreadedDebug</RuntimeLibrary>
      <MinimalRebuild>false</MinimalRebuild>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <OptimizeReferences Condition="'$(Configuration)'=='Release'">true</OptimizeReferences>
      <GenerateDebugInformation Condition="'$(Configuration)'=='Debug'">true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;Version.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
</Project>
```

`config/buildstructure.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <OutDir>$(SolutionDir)artifacts\$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(PlatformTarget)\$(Configuration)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <BuildLog>
      <Path>$(SolutionDir)build\$(PlatformTarget)\$(Configuration)\$(MSBuildProjectName).log</Path>
    </BuildLog>
  </ItemDefinitionGroup>
</Project>
```

`docs/BLUESPAWN/asgi.py`:

```py
"""
ASGI config for BLUESPAWN project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'BLUESPAWN.settings')

application = get_asgi_application()

```

`docs/BLUESPAWN/settings.py`:

```py
"""
Django settings for BLUESPAWN project.

Generated by 'django-admin startproject' using Django 3.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'lm+m&mmq=r3i&bbk#c750e10ir%2rdy2df9*s$!vo@jkv2y1!w'

DEBUG = False
if os.environ.get("DEBUG") == "True":
    DEBUG = True

if os.environ.get("DEBUG") == "True":
    ALLOWED_HOSTS = ['*']
else:
    ALLOWED_HOSTS = ['www.bluespawn.cloud', 'bluespawn.cloud']

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
        'bootstrap4',
        'web'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'BLUESPAWN.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'BLUESPAWN/templates'), os.path.join(BASE_DIR, 'web/templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'BLUESPAWN.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'

PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))
STATIC_ROOT = os.path.join(PROJECT_DIR, 'static')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'

```

`docs/BLUESPAWN/static/BLUESPAWN/BLUESPAWN.css`:

```css
main.pt-3 {
	padding-top: 0px !important;
}

.container {
	padding-top: 1em;
}

```

`docs/BLUESPAWN/templates/BLUESPAWN/base.html`:

```html
{% load static %} <html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/js/bootstrap.min.js"></script>
		<link rel="stylesheet" 
href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<script src="https://kit.fontawesome.com/47c0b1c943.js" crossorigin="anonymous"></script>
		<link href="{% static 'BLUESPAWN/BLUESPAWN.css' %}" rel="stylesheet">
	</head>
	
	<body>
		<div class="cover-container d-flex h-100 mx-auto flex-column">
			<nav class="navbar navbar-expand-lg px-5 navbar-dark" style="background: #0078d7;">
				<!-- Logo -->
				<!--<a class="navbar-brand" href="/">
					<img src="{% static 'BLUESPAWN/logo.png' %}" width="30" height="30" 
alt="">
				</a>-->
				
				<!-- BLUESPAWN home text -->
				<a class="navbar-brand" href="/">BLUESPAWN</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" 
data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" 
aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>
				<!-- Elements that will turn into a drop-down on small screens -->
				<div class="collapse navbar-collapse" id="navbarSupportedContent">
					<ul class="navbar-nav mr-auto">
						<li class="nav-item">
							<a class="nav-link" href="/about"><i class="fas 
fa-info-circle"></i>&nbsp; About</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="/quickstart"><i class="fas 
fa-play-circle"></i>&nbsp; Getting Started</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="/coverage"><i class="fas 
fa-lock"></i>&nbsp; MITRE ATT&amp;CK Coverage</a>
						</li>
						<!--<li class="nav-item">
							<a class="nav-link" href="/report"><i class="fas 
fa-file-contract"></i>&nbsp; Report Generator</a>
						</li>-->
					</ul>
				</div>
				
			</nav>
		
			<main role="main" class="pt-3">
				{% block content %}
				{% endblock %}
			</main>
			
			<footer class="page-footer font-small blue pt-4" style="background-color:#F2F2F1">
			  <div class="footer-copyright text-center py-3">© 2020 Copyright: BLUESPAWN Development Team </div>
			</footer>
		</div>
		
	</body>
	
</html>

```

`docs/BLUESPAWN/templates/BLUESPAWN/index.html`:

```html
{% extends 'BLUESPAWN/base.html' %} {% block content %} {% load static %} <section class="jumbotron 
text-center jumbotron-fluid h-100"> <div class="container" id="hometext">
	<h1 class="jumbotron-heading">An open-source, Active Defense & EDR Program</h1>
	<p></p>
	<p class="pb-2">
	<a href="/quickstart" class="btn btn-lg btn-primary">Get Started with BLUESPAWN</a>
	<a href="https://github.com/ION28/BLUESPAWN/releases" class="btn btn-lg btn-success">Download</a>
	</p>
	
</div> </section> <section class="py-5">
    <div class="container">
		<!--<div class="row">
			<div class="alert alert-dismissible alert-primary">
			  <button type="button" class="close" data-dismiss="alert">&times;</button>
			  <h4 class="alert-heading">This project is still <i>alpha</i>!</h4>
			  <p class="mb-0">BLUESPAWN is under active alpha development, so many features may not work as expected yet and detections may be too narrow scope or generate lots of false positives.</p>
			</div>
		</div>
		<br>-->
		<div class="row">
			<div class="col-12">
				<h2>What is it?</h2>
			</div>
		</div>
		<br>
		<div class="row">
			<div class="col-12">
				<blockquote class="blockquote text-center">
				  <p class="mb-0">BLUESPAWN is an <span class="text-primary">active defense and endpoint detection and response tool</span> which means it can be used by defenders to quickly <span class="text-danger">detect, identify, and eliminate</span> malicious activity and malware across a network.</p>
				</blockquote>
			</div>
		</div>
		<br>
		<hr>
		<br>
		<div class="row">
			<div class="col-12">
				<h2>Why BLUESPAWN?</h2>
			</div>
		</div>
		<br>
		<div class="row">
			<div class="col-lg-4 col-12">
				<div class="card border-0 text-center">
				  <i class="text-info fa fa-tachometer-alt fa-4x"></i>
				  <h3>Move Faster</h3>
					<div class="card-body">
						<p class="card-text">A security analyst should be able to quickly detect, assess, and respond to any malicious activity on a live system.</p>
					</div>
				</div>
			</div>
			<div class="col-lg-4 col-12">
				<div class="card border-0 text-center">
				  <i class="text-success fa fa-check-square fa-4x"></i>
				  <h3>Know Your Coverage</h3>
					<div class="card-body">
						<p class="card-text">Defenders should know exactly what their tools will catch so they can better focus their efforts on specific lines of effort and have confidence in the status of others</p>
					</div>
				</div>
			</div>
			<div class="col-lg-4 col-12">
				<div class="card border-0 text-center">
				  <i class="text-danger fa fa-project-diagram fa-4x"></i>
				  <h3>Analyze the Windows Attack Surface</h3>
					<div class="card-body">
						<p class="card-text">Blue teams should seek to better understand their attack surface in order to defend it better.</p>
					</div>
				</div>
			</div>
		</div>
		<div class="row">
			<div class="col-lg-6 col-12">
				<div class="card border-0 text-center">
				  <i class="text-warning fa fa-shield-alt fa-4x"></i>
				  <h3>Embrace Open-Source Blue Team Software</h3>
					<div class="card-body">
						<p class="card-text">While there are many open-source Red Team Tools out there, the vast majority of some of the best Blue Team tools are closed-source (ie, AVs, EDRs, SysInternals, etc). That makes it harder for students to learn about these.</p>
					</div>
				</div>
			</div>
			<div class="col-lg-6 col-12">
				<div class="card border-0 text-center">
				  <i class="text-primary fa fa-windows fa-4x"></i>
				  <h3>Understand more about the Windows API</h3>
					<div class="card-body">
						<p class="card-text">We combed through a ton of Microsoft Documentation, StackOverflow Answers, and more to create this. Hopefully others may find some of the code useful.</p>
					</div>
				</div>
			</div>
		</div>
	</div> </section> {% endblock %}

```

`docs/BLUESPAWN/urls.py`:

```py
"""BLUESPAWN URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.contrib.staticfiles.urls import static
from django.contrib.staticfiles.urls import staticfiles_urlpatterns
import BLUESPAWN.views as views
from BLUESPAWN import settings

urlpatterns = [
    path('', views.index, name="index"),
    path('admin/', admin.site.urls),
    path('', include('web.urls')),
]

urlpatterns += staticfiles_urlpatterns()
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```

`docs/BLUESPAWN/views.py`:

```py
from django.shortcuts import render

'''
View function for the home page of the website
'''
def index(request):
    return render(request, 'BLUESPAWN/index.html')

```

`docs/BLUESPAWN/wsgi.py`:

```py
"""
WSGI config for BLUESPAWN project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'BLUESPAWN.settings')

application = get_wsgi_application()

```

`docs/Pipfile`:

```
[[source]]
name = "pypi"
url = "https://pypi.org/simple"
verify_ssl = true

[dev-packages]

[packages]
gunicorn = "*"
django-bootstrap4 = "*"
django-crispy-forms = "*"
Django = "*"

[requires]
python_version = "3.6"

```

`docs/Procfile`:

```
release: python manage.py migrate
web: gunicorn BLUESPAWN.wsgi

```

`docs/bluespawn.cloud`:

```cloud
server {

	root /var/www/bluespawn.cloud/html;
	index index.html;

	server_name bluespawn.cloud www.bluespawn.cloud;
	
	location / {
		# django running in uWSGI
		uwsgi_pass unix:///run/uwsgi/app/django/socket;
		include uwsgi_params;
		uwsgi_read_timeout 300s;
		client_max_body_size 5M;
	}

	location /static/ {
		alias /home/ubuntu/BLUESPAWN/docs/BLUESPAWN/static/;
	}

	location /media/ {
		alias /home/ubuntu/BLUESPAWN/docs/media/;
	}

    listen [::]:443 ssl ipv6only=on; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/bluespawn.cloud/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/bluespawn.cloud/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot


}
server {
    if ($host = www.bluespawn.cloud) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


    if ($host = bluespawn.cloud) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


	listen 80;
	listen [::]:80;

	server_name bluespawn.cloud www.bluespawn.cloud;
    return 404; # managed by Certbot




}

```

`docs/clear_uploads.sh`:

```sh
find ~/BLUESPAWN/docs/media/scans/ -type f -mtime +1 -exec rm {} +

```

`docs/django.ini`:

```ini
[uwsgi]
chdir = /home/ubuntu/BLUESPAWN/docs
env = DJANGO_SETTINGS_MODULE=BLUESPAWN.settings
module = BLUESPAWN.wsgi
home = /home/ubuntu/venv
workers = 1

```

`docs/manage.py`:

```py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'BLUESPAWN.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```

`docs/media/coverage-all.json`:

```json
{
    "name": "BLUESPAWN Overall",
    "version": "3.0",
    "domain": "mitre-enterprise",
    "description": "Current Coverage of BLUESPAWN",
	"filters": {
		"stages": [
			"act"
		],
		"platforms": [
			"windows"
		]
	},
	"sorting": 0,
	"layout": {
		"layout": "flat",
		"showID": false,
		"showName": true
	},
	"hideDisabled": false,
    "techniques": [
		{
			"techniqueID": "T1003",
			"tactic": "credential-access",
			"color": "#FCF26B",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025), DLL Safe Search mode is enabled (V-3479), Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1003.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025), DLL Safe Search mode is enabled (V-3479), Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1021",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1021.002",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1036",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bad files in user writable folders in %WINDIR%",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1036.005",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bad files in user writable folders in %WINDIR%",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1037",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1037.001",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1037",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1037.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.001",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.002",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.003",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.004",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.005",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.011",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.012",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.013",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.004",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.005",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.011",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.012",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.013",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1059",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Disables Windows Script Hosts which prevents some scripts from executing (M1042-WSH)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1059.005",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Disables Windows Script Hosts which prevents some scripts from executing (M1042-WSH)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1068",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking for printer ports that reference a file (CVE-2020-1048)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1070",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking Sysmon Logs for EID 2 events, YARA scanning those files, and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1070.006",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking Sysmon Logs for EID 2 events, YARA scanning those files, and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1135",
			"tactic": "discovery",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1136",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4720 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1136.001",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4720 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1484",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for ntuser.man files in all user directories and monitoring for these files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1484",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking for ntuser.man files in all user directories and monitoring for these files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1505",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by analyzing files in web locations for bad functions/strings",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1505.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by analyzing files in web locations for bad functions/strings",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1543",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1543.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1543",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1543.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad Netsh Helper Dlls, Accessibility Features tampering, AppCert Dlls, Appinit Dlls, Application Shimming, Image File Execution Options backdooring, and COM Hijacking",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1546.002",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking the screensaver executable and registry entries that control the screensaver",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.007",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking all Netsh Helper Dlls and monitoring for them",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.008",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking looking for Debuggers and YARA scanning Accessibility Files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.009",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppCert DLLs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.010",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppInit_DLLs and LoadAppInit_DLLs keys",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.011",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for Application Shimming and Custom DBs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.012",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking Registry keys for Image File Execution Options.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.015",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking all configured CLSIDs and their associated files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad Netsh Helper Dlls, Accessibility Features tampering, AppCert Dlls, Appinit Dlls, Application Shimming, Image File Execution Options backdooring, and COM Hijacking",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1546.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking the screensaver executable and registry entries that control the screensaver",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.007",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking all Netsh Helper Dlls and monitoring for them",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.008",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking looking for Debuggers and YARA scanning Accessibility Files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.009",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppCert DLLs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.010",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppInit_DLLs and LoadAppInit_DLLs keys",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.011",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for Application Shimming and Custom DBs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.012",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking Registry keys for Image File Execution Options.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.015",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking all configured CLSIDs and their associated files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad registry run keys, startup files, authentication packages, winlogon helper Dlls, security support providers, and port monitors. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.001",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Coverd by checking most Run* keys. Future coverage will be obtained through checking files in Startup folders",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional Auth/Notif Packages. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by examining all registered time providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.004",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking the Notify, Userinit, and Shell values",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional SSPs. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.008",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.010",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking the port monitors on the system and their associated drivers",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad registry run keys, startup files, authentication packages, winlogon helper Dlls, security support providers, and port monitors. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Coverd by checking most Run* keys. Future coverage will be obtained through checking files in Startup folders",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional Auth/Notif Packages. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by examining all registered time providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.004",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking the Notify, Userinit, and Shell values",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional SSPs. Mitigation to disable Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.008",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.010",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking the port monitors on the system and their associated drivers",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1548",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1548.002",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1548",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1548.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1550",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1550.002",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1550",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1550.002",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1553",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by checking all of the SIP and Trust Providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1553.003",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by checking all of the SIP and Trust Providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1556",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1556.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1556",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1556.001",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1557",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1557.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1557",
			"tactic": "collection",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1557.001",
			"tactic": "collection",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1562",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bypasses to Windows Firewall in the Registry through AuthorizedApplications and GloballyAccessiblePorts. Mitigation to check a variety of firewall/Windows Security Notification Center settings (M1028-WFW, M1054-WSC, V-73511)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1562.004",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bypasses to Windows Firewall in the Registry through AuthorizedApplications and GloballyAccessiblePorts. Mitigation to check a variety of firewall/Windows Security Notification Center settings (M1028-WFW, M1054-WSC, V-73511)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1569",
			"tactic": "execution",
			"color": "#5AADFF",
			"comment": "Covered by checking Services key/subkeys and analyzing each of the binaries",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1569.002",
			"tactic": "execution",
			"color": "#5AADFF",
			"comment": "Covered by checking Services key/subkeys and analyzing each of the binaries",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		}
    ],
	"gradient": {
		"colors": [
			"#ff6666",
			"#ffe766",
			"#8ec843"
		],
		"minValue": 0,
		"maxValue": 100
	},
    "legendItems": [
        {
            "label": "Strong BLUESPAWN Coverage",
            "color": "#5AADFF"
        },
        {
            "label": "Partial BLUESPAWN Coverage",
            "color": "#FCF26B"
        }
    ],
	"metadata": [],
	"showTacticRowBackground": false,
	"tacticRowBackground": "#dddddd",
	"selectTechniquesAcrossTactics": true,
	"selectSubtechniquesWithParent": false
}

```

`docs/media/coverage-hunts.json`:

```json
{
    "name": "BLUESPAWN Hunts",
    "version": "3.0",
    "domain": "mitre-enterprise",
    "description": "Current Coverage of Hunts in BLUESPAWN",
	"filters": {
		"stages": [
			"act"
		],
		"platforms": [
			"windows"
		]
	},
	"sorting": 0,
	"layout": {
		"layout": "flat",
		"showID": false,
		"showName": true
	},
	"hideDisabled": false,
    "techniques": [
		{
			"techniqueID": "T1036",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bad files in user writable folders in %WINDIR%",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1036.005",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bad files in user writable folders in %WINDIR%",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1037",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1037.001",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1037",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1037.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking HKCU\\Environment\\UserInitMprLogonScript",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1053",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1053.005",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4698, Task-Scheduler/106 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.001",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.002",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.003",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.004",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.005",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.011",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.012",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.013",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.004",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.005",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.011",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.012",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1055.013",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by scanning all running processes for indicators of process injection with pe-sieve and various other checks.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1068",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking for printer ports that reference a file (CVE-2020-1048)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1070",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking Sysmon Logs for EID 2 events, YARA scanning those files, and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1070.006",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking Sysmon Logs for EID 2 events, YARA scanning those files, and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1136",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4720 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1136.001",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Covered by checking EventLogs for Security/4720 events and monitoring for these events",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1484",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for ntuser.man files in all user directories and monitoring for these files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1484",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Covered by checking for ntuser.man files in all user directories and monitoring for these files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1505",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by analyzing files in web locations for bad functions/strings",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1505.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by analyzing files in web locations for bad functions/strings",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1543",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1543.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1543",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1543.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by notifying a user when event logs are created for new service creation and by checking Services in the registry for things like FailureCommands that are suspicious.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad Netsh Helper Dlls, Accessibility Features tampering, AppCert Dlls, Appinit Dlls, Application Shimming, Image File Execution Options backdooring, and COM Hijacking",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1546.002",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking the screensaver executable and registry entries that control the screensaver",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.007",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking all Netsh Helper Dlls and monitoring for them",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.008",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking looking for Debuggers and YARA scanning Accessibility Files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.009",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppCert DLLs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.010",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppInit_DLLs and LoadAppInit_DLLs keys",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.011",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for Application Shimming and Custom DBs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.012",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking Registry keys for Image File Execution Options.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.015",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking all configured CLSIDs and their associated files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad Netsh Helper Dlls, Accessibility Features tampering, AppCert Dlls, Appinit Dlls, Application Shimming, Image File Execution Options backdooring, and COM Hijacking",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1546.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking the screensaver executable and registry entries that control the screensaver",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.007",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking all Netsh Helper Dlls and monitoring for them",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.008",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking looking for Debuggers and YARA scanning Accessibility Files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.009",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppCert DLLs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.010",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking AppInit_DLLs and LoadAppInit_DLLs keys",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.011",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for Application Shimming and Custom DBs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.012",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking Registry keys for Image File Execution Options.",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1546.015",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking all configured CLSIDs and their associated files",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad registry run keys, startup files, authentication packages, winlogon helper Dlls, security support providers, and port monitors",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.001",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Coverd by checking most Run* keys. Future coverage will be obtained through checking files in Startup folders",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional Auth/Notif Packages",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.003",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by examining all registered time providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.004",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking the Notify, Userinit, and Shell values",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional SSPs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.010",
			"tactic": "persistence",
			"color": "#5AADFF",
			"comment": "Covered by checking the port monitors on the system and their associated drivers",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking for bad registry run keys, startup files, authentication packages, winlogon helper Dlls, security support providers, and port monitors",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.001",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Coverd by checking most Run* keys. Future coverage will be obtained through checking files in Startup folders",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional Auth/Notif Packages",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.003",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by examining all registered time providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.004",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking the Notify, Userinit, and Shell values",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by registry checking for any additional SSPs",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.010",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "Covered by checking the port monitors on the system and their associated drivers",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1553",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by checking all of the SIP and Trust Providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1553.003",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Covered by checking all of the SIP and Trust Providers on the system",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1562",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bypasses to Windows Firewall in the Registry through AuthorizedApplications and GloballyAccessiblePorts",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1562.004",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Covered by checking for bypasses to Windows Firewall in the Registry through AuthorizedApplications and GloballyAccessiblePorts",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1569",
			"tactic": "execution",
			"color": "#5AADFF",
			"comment": "Covered by checking Services key/subkeys and analyzing each of the binaries",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1569.002",
			"tactic": "execution",
			"color": "#5AADFF",
			"comment": "Covered by checking Services key/subkeys and analyzing each of the binaries",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		}
    ],
	"gradient": {
		"colors": [
			"#ff6666",
			"#ffe766",
			"#8ec843"
		],
		"minValue": 0,
		"maxValue": 100
	},
    "legendItems": [
        {
            "label": "Strong BLUESPAWN Coverage",
            "color": "#5AADFF"
        },
        {
            "label": "Partial BLUESPAWN Coverage",
            "color": "#FCF26B"
        }
    ],
	"metadata": [],
	"showTacticRowBackground": false,
	"tacticRowBackground": "#dddddd",
	"selectTechniquesAcrossTactics": true,
	"selectSubtechniquesWithParent": false
}

```

`docs/media/coverage-mitigations.json`:

```json
{
    "name": "BLUESPAWN Mitigations",
    "version": "3.0",
    "domain": "mitre-enterprise",
    "description": "Current Coverage of Mitigations in BLUESPAWN",
	"filters": {
		"stages": [
			"act"
		],
		"platforms": [
			"windows"
		]
	},
	"sorting": 0,
	"layout": {
		"layout": "flat",
		"showID": false,
		"showName": true
	},
	"hideDisabled": false,
    "techniques": [
		{
			"techniqueID": "T1562",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Checks a variety of firewall/Windows Security Notification Center settings (M1028-WFW, M1054-WSC, V-73511)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1562.001",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Checks a variety of firewall/Windows Security Notification Center settings (M1028-WFW, M1054-WSC, V-73511)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.008",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1547.002",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.005",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1547.008",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1556",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1556.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1556",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1556.001",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025). DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1003",
			"tactic": "credential-access",
			"color": "#FCF26B",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025), DLL Safe Search mode is enabled (V-3479), Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1003.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Runs LSASS as a PPL and requires drivers loaded into LSASS to be signed by Microsoft (M1025), DLL Safe Search mode is enabled (V-3479), Disables Wdigest which limits effectiveness of Credential Dumping (V-72753)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1557",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1557.001",
			"tactic": "credential-access",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1557",
			"tactic": "collection",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1557.001",
			"tactic": "collection",
			"color": "#5AADFF",
			"comment": "Disables LLMNR and NBT-NS to prevent against LLMNR/NBT-NS spoofing attacks (M1042-LLMNR, M1042-NBT)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1059",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Disables Windows Script Hosts which prevents some scripts from executing (M1042-WSH)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1059.005",
			"tactic": "execution",
			"color": "#FCF26B",
			"comment": "Disables Windows Script Hosts which prevents some scripts from executing (M1042-WSH)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1135",
			"tactic": "discovery",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1021",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1021.002",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Limits anonymous access to shares (V-1093)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1550",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1550.002",
			"tactic": "lateral-movement",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1550",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1550.002",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "Filters Admin tokens over the network (V-63597)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1548",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1548.002",
			"tactic": "defense-evasion",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1548",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1548.002",
			"tactic": "privilege-escalation",
			"color": "#5AADFF",
			"comment": "A number of settings to strengthen UAC are applied (V-63817)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "persistence",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "privilege-escalation",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		},
		{
			"techniqueID": "T1574",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": true
		},
		{
			"techniqueID": "T1574.001",
			"tactic": "defense-evasion",
			"color": "#FCF26B",
			"comment": "DLL Safe Search mode is enabled (V-3479)",
			"enabled": true,
			"metadata": [],
			"showSubtechniques": false
		}
    ],
	"gradient": {
		"colors": [
			"#ff6666",
			"#ffe766",
			"#8ec843"
		],
		"minValue": 0,
		"maxValue": 100
	},
    "legendItems": [
        {
            "label": "Strong BLUESPAWN Coverage",
            "color": "#5AADFF"
        },
        {
            "label": "Partial BLUESPAWN Coverage",
            "color": "#FCF26B"
        }
    ],
	"metadata": [],
	"showTacticRowBackground": false,
	"tacticRowBackground": "#dddddd",
	"selectTechniquesAcrossTactics": true,
	"selectSubtechniquesWithParent": false
}

```

`docs/requirements.txt`:

```txt
gunicorn
django
django-bootstrap4
python-docx
lxml

```

`docs/web/admin.py`:

```py
from django.contrib import admin

# Register your models here.

```

`docs/web/apps.py`:

```py
from django.apps import AppConfig


class WebConfig(AppConfig):
    name = 'web'

```

`docs/web/models.py`:

```py
from django.db import models


```

`docs/web/templates/about.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
  {% extends 'BLUESPAWN/base.html' %} {% block title %}About{% endblock %} {% block content %} {% load bootstrap4%} {% load static %}
  <div class="container">
    <div class="row">
      <div class="col-12 mb-12">
        <h1>About BLUESPAWN</h1>
		<hr>
      </div>
    </div>
    <div class="row">
      <div class="col-12">
        <h2 id="contact-us">Contact Us</h2>
      </div>
      <div class="col-12">
        <p>If you have any questions, comments, or suggestions, please feel free to send us an email at <a href=
        "&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#98;&#108;&#x75;&#x65;&#x73;&#x70;&#x61;&#119;&#x6e;&#x40;&#118;&#105;&#x72;&#x67;&#105;&#x6e;&#105;&#97;&#x2e;&#101;&#x64;&#117;">&#98;&#108;&#x75;&#x65;&#x73;&#x70;&#x61;&#119;&#x6e;&#x40;&#118;&#105;&#x72;&#x67;&#105;&#x6e;&#105;&#97;&#x2e;&#101;&#x64;&#117;</a></p>
      </div>
    </div>
    <h2 id="licensing-compliance">Licensing &amp; Compliance</h2>
    <p>The core BLUESPAWN code is licensed under <a href="https://github.com/ION28/BLUESPAWN/blob/master/LICENSE">GNU General Public License (GPL) v3.0</a>.</p>
    <p>Note that the project integrates several other libraries to provide additional features/detections. One of these is Florian Roth&#39;s <a href="https://github.com/Neo23x0/signature-base">signature-base</a> which is licensed under the <a href=
    "http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. YARA rules from this project are integrated into the standard build without any changes. In order to use BLUESPAWN for any
    commercial purposes, you must remove everything under the &quot;Non-Commercial Only&quot; line in <a href="https://github.com/ION28/BLUESPAWN/blob/master/BLUESPAWN-win-client/resources/severe2.yar">this file</a> and recompile the project.</p>
    <h2 id="project-authors">Project Authors</h2>
    <p>Made with 💗 by the UVA Cyber Defense Team Windows Group</p>
    <ul>
      <li>Jake Smith (<a href="https://github.com/ION28">Github</a>, <a href="https://twitter.com/jtsmith282">Twitter</a>)
      </li>
      <li>Jack McDowell (<a href="https://github.com/jnmcd/">Github</a>)
      </li>
      <li>Calvin Krist (<a href="https://github.com/CalvinKrist">Github</a>, <a href="https://twitter.com/CalvinKrist">Twitter</a>)
      </li>
      <li>Will Mayes (<a href="https://github.com/wtm99">Github</a>, <a href="https://twitter.com/will_mayes99">Twitter</a>)
      </li>
      <li>Aaron Gdanski (<a href="https://github.com/agski331">Github</a>)
      </li>
      <li>Grant Matteo (<a href="https://github.com/GrantMatteo">Github</a>)
      </li>
    </ul>
    <h2 id="contributors">Contributors</h2>
    <p>Thanks to all of the folks listed below for their contributions to BLUESPAWN!</p>
    <ul>
      <li>Alexander Kluth (<a href="https://github.com/akluth">Github</a>)
      </li>
    </ul>
    <p>Want to help? Take a look at the current issues, add ideas for new features, write some code, and create a pull request!</p>
    <h2 id="special-thanks">Special Thanks</h2>
    <p>We would like to provide a special thank you to the following projects that have helped us to build BLUESPAWN:</p>
    <ul>
      <li>Github&#39;s support of open-source projects, especially the ability for unlimited use Github Actions</li>
      <li>Microsoft&#39;s documentation and examples on the Windows API</li>
      <li>The Department of Defense&#39;s Defense Information Systems Agency (DISA) for their great work in publishing STIGs and various other technical security guidance for Windows.</li>
      <li>
        <a href="https://github.com/hasherezade">@hasherezade</a>&#39;s <a href="https://github.com/hasherezade/pe-sieve">PE Sieve</a>, which currently manages our process analytics
      </li>
      <li>VirusTotal&#39;s <a href="https://github.com/VirusTotal/yara">YARA</a> Project which we use to scan data for malicious identifiers
      </li>
      <li>The <a href="https://twitter.com/yararules">Yara Rules Project</a>&#39;s <a href="https://github.com/Yara-Rules/rules">Rules</a> repository which contains a large collection of open-source YARA rules
      </li>
      <li>
        <a href="https://github.com/Neo23x0">@Neo23x0</a>&#39;s open-source <a href="https://github.com/Neo23x0/signature-base">signature-base</a> project which contains a large collection of YARA rules
      </li>
      <li>The <a href="https://attack.mitre.org/">MITRE&#39;s ATT&amp;CK Project</a> which has put together an amazing framework for which to consider, document, and categorize attacker tradercraft
      </li>
      <li>Red Canary&#39;s <a href="https://github.com/redcanaryco/atomic-red-team">Atomic Red Team</a> and <a href="https://github.com/redcanaryco/invoke-atomicredteam">Invoke-AtomicRedTeam</a> Projects which have been incredibly useful in helping
      to test the detections we are building
      </li>
      <li>Amazon&#39;s <a href="https://aws.amazon.com/opensource/">Open Source at AWS Initiative</a> who has provided our team some AWS promotional credits to help us reserach and test BLUESPAWN better
      </li>
      <li>The <a href="https://github.com/nsacyber">NSA Cybersecurity Directorate</a>&#39;s Windows <a href="https://github.com/nsacyber/Event-Forwarding-Guidance">Event Forwarding Guidance</a>
      </li>
      <li>
        <a href="https://twitter.com/PyroTek3">Sean Metcalf</a>&#39;s Active Directory Security blog <a href="https://adsecurity.org/">ADSecurity</a>
      </li>
      <li>
        <a href="https://github.com/op7ic">@op7ic</a>&#39;s <a href="https://github.com/op7ic/EDR-Testing-Script">EDR-Testing-Script</a> Project
      </li>
      <li>The Japan Computer Emergency Response Team (JPCERT)&#39;s <a href="https://jpcertcc.github.io/ToolAnalysisResultSheet/">Tool Analysis Result Sheet</a> for its documentation of attacker behavior and correlation with detection opportunities
      </li>
      <li>
        <a href="https://github.com/jarro2783">@jarro2783</a>&#39;s <a href="https://github.com/jarro2783/cxxopts">cxxopts</a> which we use to parse command line arguments
      </li>
      <li>
        <a href="https://github.com/leethomason">@leethomason</a>&#39;s <a href="https://github.com/leethomason/tinyxml2">tinyxml2</a> library which we use to output scan information to XML
      </li>
    </ul>
  </div>{% endblock %}
</body>
</html>

```

`docs/web/templates/coverage.html`:

```html
{% extends 'BLUESPAWN/base.html' %}
{% block title %}About{% endblock %}
{% block content %}
{% load bootstrap4%}
{% load static %}

<div class="container">
	<div class="row">
		<div class="col-12 mb-12">
			<h1>Current MITRE ATT&amp;CK Coverage</h1>
			<hr>
		</div>
	</div>
	<div class="row">
		<div class="col-12 d-lg-none d-xl-none">
			<p>Please visit this site on a laptop or desktop to view BLUESPAWN's ATT&amp;CK coverage</p>
		</div>
		<div class="col-12 d-none d-lg-block">
			<iframe src="https://ion28.github.io/attack-navigator/#layerURL=https%3A%2F%2Fraw%2Egithubusercontent%2Ecom%2FION28%2FBLUESPAWN%2Fdevelop%2Fdocs%2Fmedia%2Fcoverage%2Dmitigations%2Ejson&layerURL=https%3A%2F%2Fraw%2Egithubusercontent%2Ecom%2FION28%2FBLUESPAWN%2Fdevelop%2Fdocs%2Fmedia%2Fcoverage%2Dhunts%2Ejson&layerURL=https%3A%2F%2Fraw%2Egithubusercontent%2Ecom%2FION28%2FBLUESPAWN%2Fdevelop%2Fdocs%2Fmedia%2Fcoverage%2Dall%2Ejson" width="110%" height="2150"></iframe>
			<br><br>
		</div>
	</div>
</div>
{% endblock %}

```

`docs/web/templates/quickstart.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
  {% extends 'BLUESPAWN/base.html' %} {% block title %}About{% endblock %} {% block content %} {% load bootstrap4%} {% load static %}
  <div class="container">
    <div class="row">
      <div class="col-12 mb-12">
        <h1>Getting Started with BLUESPAWN</h1>
        <hr>
      </div>
    </div>
    <div class="row">
      <div class="col-12">
        <blockquote>
          <p><span class="badge badge-warning">Note!</span> BLUESPAWN is under active <em>alpha</em> development, so many features may not work as expected yet and detections may be too narrow scope or generate lots of false positives.</p>
          <p><span class="badge badge-warning">Note 2!</span>  BLUESPAWN is meant to be run by a security professional in most cases and as such, will detect on non-malicious activity sometimes. While BLUESPAWN helps to quickly surface potentially bad things, it expects the user to use the
          available information to make the final determination.</p>
        </blockquote>
        <ol>
          <li>Download the latest release from <a href="https://github.com/ION28/BLUESPAWN/releases">this page</a>
          </li>
          <li>Open an Administrative Command Prompt</li>
          <li>Run the following command to see the available options
            <pre><code class="lang-cmd">.\BLUESPAWN-client-x64.exe --help
</code></pre>
          </li>
        </ol>
        <h3 id="mitigate-mode">Mitigate Mode</h3>
        <ol>
          <li>Run the following from your Administrative Command Prompt to audit your system for the presence of many security settings
            <pre><code class="lang-cmd"><span class="hljs-string">.</span><span class="hljs-comment">\BLUESPAWN-client-x64.exe --mitigate --action=audit</span>
</code></pre><img width="100%" alt="BLUESPAWN in Action-Mitigate"
                src="https://user-images.githubusercontent.com/3931697/89669848-25e69900-d8ae-11ea-836d-1618d7377211.png">
          </li>
        </ol>
        <h3 id="hunt-mode">Hunt Mode</h3>
        <ol>
          <li>Run BLUESPAWN from the Administrative Command Prompt to hunt for malicious activity on the system
            <pre><code class="lang-cmd"><span class="hljs-string">.</span><span class="hljs-comment">\BLUESPAWN-client-x64.exe --hunt -a Cursory --log=console,xml</span>
</code></pre><img width="100%" alt="BLUESPAWN in Action-Hunt"
                src="https://user-images.githubusercontent.com/3931697/89669912-4878b200-d8ae-11ea-967b-03318468d711.png">
          </li>
        </ol>
        <h3 id="hunt-mode">Monitor Mode</h3>
        <ol>
          <li>Run BLUESPAWN from the Administrative Command Prompt to monitor for malicious activity on the system
            <pre><code class="lang-cmd"><span class="hljs-string">.</span><span class="hljs-comment">\BLUESPAWN-client-x64.exe --monitor -a Cursory --log=console,xml</span>
</code></pre><img width="100%" alt="BLUESPAWN in Action-Monitor"
                src="https://user-images.githubusercontent.com/3931697/89670008-752cc980-d8ae-11ea-8490-1e0473d5f3c6.png">
          </li>
        </ol>
      </div>
    </div>
  </div>{% endblock %}
</body>
</html>

```

`docs/web/templates/report.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
  {% extends 'BLUESPAWN/base.html' %} {% block title %}About{% endblock %} {% block content %} {% load bootstrap4%} {% bootstrap_css %}
  <div class="container">
    <div class="row">
      <div class="col-12 mb-12">
        <h1>Convert BLUESPAWN XML Report to DOCX</h1>
	{% if request.GET.error == '1' %}
	<div class="alert alert-danger" role="alert">Upload or Report Generation failed!</div>
	{% endif %}
      </div>
    </div>
    <br>
    <div class="row">
	<div class="col-12">
	 	<p>Upload your BLUESPAWN XML Scan Report, and convert it to a .docx. Note that we have to process the XML on the server side in order to generate the .docx file. All generated reports get deleted after 1 day and the XML file uploaded only exists long enough to generate the report.</p>
	</div>
    </div>
    <div class="row">
      <div class="col-12">
        <form action="/report/"
              class="form-group"
              enctype="multipart/form-data"
              id="generate_report"
              method="post"
              name="generate_report">
          {% csrf_token %}
          <div class="form-group">
		  <input type="file" name="scanxml">
          </div><br>
          <br>
          <input class="btn btn-success"
                type="submit"
                value="Generate Report">
        </form>
      </div>
    </div>
    {% if generated_report_url %}
    <div class="row">
	<div class="col-12">
		<p>Click to download report at <a href="/media/scans/{{ generated_report_url }}">this link</a></p>
	</div>
    </div>
    {% endif %}
  </div>{% endblock %}
</body>
</html>

```

`docs/web/tests.py`:

```py
from django.test import TestCase

# Create your tests here.

```

`docs/web/urls.py`:

```py
from django.urls import path
from django.conf.urls import url
from django.views.generic import TemplateView
from .views import UploadScanView
from . import views
app_name = 'web'

urlpatterns = [
    path('about/', TemplateView.as_view(template_name='about.html'), name='about'),
    path('quickstart/', TemplateView.as_view(template_name='quickstart.html'), name='quickstart'),
    path('coverage/', TemplateView.as_view(template_name='coverage.html'), name='coverage'),
    path('report/', UploadScanView, name='report'),
]

```

`docs/web/views.py`:

```py
from django.http import HttpResponse
from django.shortcuts import render, redirect
from django.urls import reverse
from django.views import generic
from django import template
from django.core.files.storage import FileSystemStorage
from django.conf import settings

from lxml import etree as ET
import uuid
import os
from docx import Document

def generate_report(scanxml):
    report_root = ET.parse(scanxml).getroot()

    report = Document()
    report.add_heading('BLUESPAWN Host Compromise Analysis Report (HCAR)', 0)

    # Parse XML File
    detections = list(report_root.findall('hunt/detection'))
    detections_hunts = []
    detections_files = []
    detections_registry = []
    detections_processes = []
    detections_eventlogs = []
    file_cnt = 0
    registry_cnt = 0
    process_cnt = 0
    eventlog_cnt = 0

    for hunt in report_root.findall('hunt'):
        if hunt.find('detection') is not None:
            detections_hunts.append([hunt.find('name').text])

    for detection in detections:
        if detection.get('type') == 'File':
            file_cnt += 1
            detections_files.append([
                detection.find('path').text if detection.find('path') is not None else "N/A", 
                detection.find('size').text if detection.find('size') is not None else "N/A", 
                detection.find('md5').text if detection.find('md5') is not None else "N/A", 
                detection.find('sha1').text if detection.find('sha1') is not None else "N/A", 
                detection.find('sha256').text if detection.find('sha256') is not None else "N/A",
                detection.getparent().find('name').text if detection.getparent().find('name').text is not None else "N/A"
            ])
        elif detection.get('type') == 'Registry':
            registry_cnt += 1
            detections_registry.append([
                detection.find('key').text if detection.find('key') is not None else "N/A", 
                detection.find('value').text if detection.find('value') is not None else "N/A", 
                detection.find('data').text if detection.find('data') is not None else "N/A",
                detection.getparent().find('name').text if detection.getparent().find('name').text is not None else "N/A"
            ]) 
        elif detection.get('type') == 'Process':
            process_cnt += 1
            detections_processes.append([
                detection.find('path').text if detection.find('path') is not None else "N/A", 
                detection.find('cmdline').text if detection.find('cmdline') is not None else "N/A", 
                detection.find('username').text if detection.find('username') is not None else "N/A",
                detection.find('pid').text if detection.find('pid') is not None else "N/A",
                detection.find('method').text if detection.find('method') is not None else "N/A"
            ]) 
        '''
        elif detection.get('type') == 'Event':
            eventlog_cnt += 1
            detections_eventlogs.append([
                detection.find('id').text if detection.find('id') is not None else "N/A", 
                detection.find('channel').text if detection.find('channel') is not None else "N/A"
            ]) 
        '''

    # MITRE ATT&CK IDs Table
    if file_cnt > 0 or registry_cnt > 0 or process_cnt > 0 or eventlog_cnt > 0:
        report.add_heading('MTIRE ATT&CK IDs:', level=1)
        mitre_table = report.add_table(rows=1, cols=3, style='Table Grid')
        mitre_table_header = mitre_table.rows[0].cells
        mitre_table_header[0].text = 'Technique ID/Name:'
        mitre_table_header[1].text = 'Tactic:'
        mitre_table_header[2].text = 'Description:'
        for item in detections_hunts:
            r = mitre_table.add_row().cells
            r[0].text = str(item[0])

    # Indicators of Attack
    report.add_heading('Indicators of Attack (IOAs)', level=1)
    report.add_heading('Files (%i)' % file_cnt, level=2)
    if file_cnt > 0:
        file_table = report.add_table(rows=1, cols=3, style='Table Grid')
        file_table_header = file_table.rows[0].cells
        file_table_header[0].text = 'Filename:'
        file_table_header[1].text = 'Details:'
        file_table_header[2].text = 'Associated Technique:'
        for item in detections_files:
            r = file_table.add_row().cells
            r[0].text = str(item[0])
            r[1].text = ('Size: ' + str(item[1]) + '\nMD5: ' + str(item[2]) + 
                '\nSHA1: ' + str(item[3]) + '\nSHA256: ' + str(item[4]))
            r[2].text = str(item[5])

    report.add_heading('Registry (%i)' % registry_cnt, level=2)
    if registry_cnt > 0:
        registry_table = report.add_table(rows=1, cols=4, style='Table Grid')
        registry_table_header = registry_table.rows[0].cells
        registry_table_header[0].text = 'Key:'
        registry_table_header[1].text = 'Value:'
        registry_table_header[2].text = 'Data:'
        registry_table_header[3].text = 'Associated Technique:'
        for item in detections_registry:
            r = registry_table.add_row().cells
            r[0].text = str(item[0])
            r[1].text = str(item[1])
            r[2].text = str(item[2])
            r[3].text = str(item[3])
    
    report.add_heading('Processes (%i)' % process_cnt, level=2)
    if process_cnt > 0:
        process_table = report.add_table(rows=1, cols=5, style='Table Grid')
        process_table_header = process_table.rows[0].cells
        process_table_header[0].text = 'Path:'
        process_table_header[1].text = 'Command Line:'
        process_table_header[2].text = 'Username:'
        process_table_header[3].text = 'PID:'
        process_table_header[4].text = 'Method:'
        for item in detections_processes:
            r = process_table.add_row().cells
            r[0].text = str(item[0])
            r[1].text = str(item[1])
            r[2].text = str(item[2])
            r[3].text = str(item[3])
            r[4].text = str(item[4])
    '''    
    report.add_heading('Event Logs (%i)' % eventlog_cnt, level=2)
    if eventlog_cnt > 0:
        eventlog_table = report.add_table(rows=1, cols=3, style='Table Grid')
        eventlog_table_header = eventlog_table.rows[0].cells
        eventlog_table_header[0].text = 'ID:'
        eventlog_table_header[1].text = 'Channel:'
        eventlog_table_header[2].text = 'Information:'
        for item in detections_eventlogs:
            r = eventlog_table.add_row().cells
            r[0].text = str(item[0])
            r[1].text = str(item[1])
    ''' 

    report_name = str(uuid.uuid4()) + '.docx'
    report.save(os.path.join(getattr(settings, 'BASE_DIR'), 'media/scans/' + report_name))

    return report_name

def UploadScanView(request):
    if request.method == 'POST' and request.FILES['scanxml']:
        scan = request.FILES['scanxml']
        fs = FileSystemStorage()
        ext = scan.name.split('.')[-1]
        filename = "%s.%s" % (uuid.uuid4(), ext)

        if ext != 'xml':
            return redirect('/report?error=1')

        upload = fs.save('scans/' + filename, scan)

        try:
            report_name = generate_report(os.path.join(getattr(settings, 'BASE_DIR'), 'media/scans/' + filename))
            fs.delete(os.path.join(getattr(settings, 'BASE_DIR'), 'media/scans/' + filename))
            return render(request, 'report.html', {
                'generated_report_url' : report_name
            })
        except:
            return redirect('/report?error=1')

    return render(request, 'report.html')


```

`testing/attack/hunt-t1546-012-test001.bat`:

```bat
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /d "C:\temp\evil.exe"
```

`testing/attack/hunt-t1546-012-test002.bat`:

```bat
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\paint.exe" /v Debugger /d "C:\windows\system32\calc.exe"
```

`testing/clean/hunt-t1546-012-test001-clean.bat`:

```bat
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /f
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /f
```

`testing/clean/hunt-t1546-012-test002-clean.bat`:

```bat
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\paint.exe" /f
```

`testing/run-atomic-prep.ps1`:

```ps1
# Needed for T1505.003
# mkdir C:\inetpub\wwwroot

```

`testing/run-atomic-tests.ps1`:

```ps1
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/install-atomicredteam.ps1')

Install-AtomicRedTeam -getAtomics -verbose

Import-Module "C:\AtomicRedTeam\invoke-atomicredteam\Invoke-AtomicRedTeam.psd1" -Force

# Test Parameters
$T1136001Args = @{ "password" = "Chiapet1" }
$T1505003Args = @{ "web_shell_path" = "C:\inetpub\wwwroot"; "web_shells" = "C:\AtomicRedTeam\atomics\T1505.003\src" }
$T1546007Args = @{ "helper_file" = "C:\AtomicRedTeam\atomics\T1134.004\bin\calc.dll" }
$T1546010Args = @{ "registry_file" = "C:\AtomicRedTeam\atomics\T1546.010\src\T1546.010.reg" }

try {
Invoke-AtomicTest T1037.001 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
#Invoke-AtomicTest T1053.005 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
# Invoke-AtomicTest T1055 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1136.001 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv' -InputArgs $T1136001Args
Invoke-AtomicTest T1505.003 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv' -InputArgs $T1505003Args
Invoke-AtomicTest T1543.003 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
# Commented out due to bad ART Test Invoke-AtomicTest T1546.002 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1546.007 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv' -InputArgs $T1546007Args
Invoke-AtomicTest T1546.008 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1546.010 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv' -InputArgs $T1546010Args
Invoke-AtomicTest T1546.011 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1546.012 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1546.015 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1547.001 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1547.004 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1547.005 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1562.004 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
Invoke-AtomicTest T1569.002 -ExecutionLogPath 'd:\a\BLUESPAWN\BLUESPAWN\AtomicTestsResults.csv'
} catch {}

```

`testing/run-hunt-results-comparison.ps1`:

```ps1
$tests = Import-Csv .\AtomicTestsResults.csv
[xml]$results = Get-Content .\BLUESPAWNHuntResults.xml

$TotalTests = 0
$TestsPassed = 0

ForEach($Technique in ($tests | ForEach-Object { $_.Technique } | get-unique)) {
	$TotalTests += 1

	$TechniqueTests = $tests | Where-Object { $_.Technique -eq $Technique }
	$TechniqueTestCount = (($TechniqueTests | Measure).count)

    $TechniqueMajor = $Technique.split(".")[0]
    $TechniqueMinor = $Technique.split(".")[1]
	
	$TechniqueResults = $results.bluespawn.detection."associated-hunts" | Where-Object { $_.hunt -like "$TechniqueMajor*" -and $_.hunt -like [string]"*$TechniqueMinor*" }

	$TechniqueDetectionCount = (($TechniqueResults | Measure).count)
	
	if($TechniqueDetectionCount -ge $TechniqueTestCount) {
		Write-Host "${TechniqueTestCount}/${TechniqueTestCount} Tests for Technique ${Technique}: PASSED"
		$TestsPassed += 1
	} else {
		Write-Host "${TechniqueDetectionCount}/${TechniqueTestCount} Tests for Technique ${Technique}: FAILED"
	}
}

Write-Host
Write-Host "${TestsPassed}/${TotalTests} Atomic Tests Passed"

# Write-Error "${TestsPassed}/${TotalTests} Atomic Tests Passed" -ErrorAction Stop

```

`vcpkg_response_file.txt`:

```txt
cxxopts:x64-windows-static
cxxopts:x86-windows-static
yara:x64-windows-static
yara:x86-windows-static
libzip:x64-windows-static
libzip:x86-windows-static
nlohmann-json:x64-windows-static
nlohmann-json:x86-windows-static

```