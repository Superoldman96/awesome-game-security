Project Path: arc_gmh5225_pe-protector_9hzdh850

Source Tree:

```txt
arc_gmh5225_pe-protector_9hzdh850
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── aplib
│   ├── aplib.h
│   └── aplib.lib
├── choco-packages.config
├── common
│   ├── CMakeLists.txt
│   ├── Opcodes.def
│   ├── SCommand.cpp
│   ├── SCommand.h
│   ├── Types.cpp
│   └── Types.h
├── compiler
│   ├── CMakeLists.txt
│   ├── Parser.cpp
│   ├── Parser.h
│   └── main.cpp
├── data
│   └── pe-protector-stub.asm
├── examples
│   ├── CMakeLists.txt
│   └── hello-world.cpp
├── log
│   ├── CLog.cpp
│   ├── CLog.h
│   └── CMakeLists.txt
├── pe-protector
│   ├── CMakeLists.txt
│   ├── ClientFile.cpp
│   ├── ClientFile.h
│   ├── Data.cpp
│   ├── Data.h
│   ├── Import.cpp
│   ├── Import.h
│   ├── Instruction.cpp
│   ├── Instruction.h
│   ├── InstructionModRM.cpp
│   ├── InstructionModRM.h
│   ├── Mutation.cpp
│   ├── Mutation.h
│   ├── Opcodes.cpp
│   ├── Opcodes.h
│   ├── PeHeader.cpp
│   ├── PeHeader.h
│   ├── ProtectPe.cpp
│   ├── ProtectPe.h
│   ├── Resources.cpp
│   ├── Resources.h
│   ├── main.cpp
│   ├── pe-protector.rc
│   └── resource.h
├── scripts
│   └── bootstrap-packages.sh
├── test
│   ├── CMakeLists.txt
│   ├── ClientFileTest.cpp
│   ├── CommandTest.cpp
│   ├── DataTest.cpp
│   ├── ImportTest.cpp
│   ├── InstructionTest.cpp
│   ├── MutationTest.cpp
│   ├── ParserTest.cpp
│   ├── PeHeaderTest.cpp
│   ├── ProtectPeTest.cpp
│   └── ResourcesTest.cpp
├── vcpkg
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.17 FATAL_ERROR)
project(pe-protector VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

#set(CMAKE_SYSTEM_PROCESSOR "i686")
#set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32  -fno-permissive" CACHE STRING "c++ flags")
#set(CMAKE_C_FLAGS   "${CMAKE_C_FLAGS} -m32" CACHE STRING "c flags")

enable_testing()

add_subdirectory(pe-protector)
add_subdirectory(compiler)
add_subdirectory(common)
add_subdirectory(log)
add_subdirectory(test)
add_subdirectory(examples)

```

`CMakePresets.json`:

```json
{
    "version": 2,
    "cmakeMinimumRequired": {
        "major": 3,
        "minor": 20,
        "patch": 0
    },
    "configurePresets": [
        {
            "name": "debug",
            "displayName": "Debug Config",
            "generator": "MinGW Makefiles",
            "binaryDir": "${sourceParentDir}/build-debug",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "CMAKE_TOOLCHAIN_FILE": "./vcpkg/scripts/buildsystems/vcpkg.cmake",
                "VCPKG_INSTALLED_DIR": "${sourceParentDir}/vcpkg_installed"
            }
        },
        {
            "name": "release",
            "displayName": "Release Config",
            "generator": "MinGW Makefiles",
            "binaryDir": "${sourceParentDir}/build-release",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release",
                "CMAKE_TOOLCHAIN_FILE": "./vcpkg/scripts/buildsystems/vcpkg.cmake",
                "VCPKG_INSTALLED_DIR": "${sourceParentDir}/vcpkg_installed"
            }
        }
    ],
    "buildPresets": [
        {
            "name": "debug",
            "configurePreset": "debug"
        },
        {
            "name": "release",
            "configurePreset": "release"
        }
    ],
    "testPresets": [
        {
            "name": "debug",
            "configurePreset": "debug"
        },
        {
            "name": "release",
            "configurePreset": "release"
        }
    ]
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2021 ATsahikian

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![Viewer Status](https://komarev.com/ghpvc/?username=atsahikian)
![Build Status](https://travis-ci.com/ATsahikian/pe-protector.svg?branch=master)
[![Build](https://github.com/ATsahikian/pe-protector/actions/workflows/ci.yml/badge.svg)](https://github.com/ATsahikian/pe-protector/actions/workflows/ci.yml)

# Pe-protector

Pe-protector helps you hide your sensitive windows executable files from being cracked. The stub file can be tuned to make protected file unique and undetectable.

Features:
- Mutation of assembler instructions.
- Build-in x86 assembler.
- Highly extensible and flexible stub file.
- Compression of source file.

# Build
Install dependencies:
- `choco install choco-packages.config -y`

Build steps:
- `git clone --recurse-submodules https://github.com/ATsahikian/pe-protector`
- `cd ./pe-protector`
- `cmake --preset release && cmake --build --preset release && ctest --preset release`  

```

`aplib/aplib.h`:

```h
/*
 * aPLib compression library  -  the smaller the better :)
 *
 * COFF 64-bit format header file
 *
 * Copyright (c) 1998-2014 Joergen Ibsen
 * All Rights Reserved
 *
 * http://www.ibsensoftware.com/
 */

#ifndef APLIB_H_INCLUDED
#define APLIB_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifndef APLIB_ERROR
# define APLIB_ERROR ((unsigned int) (-1))
#endif

unsigned int aP_pack(const void *source,
                     void *destination,
                     unsigned int length,
                     void *workmem,
                     int (*callback)(unsigned int, unsigned int, unsigned int, void *),
                     void *cbparam);

unsigned int aP_workmem_size(unsigned int inputsize);

unsigned int aP_max_packed_size(unsigned int inputsize);

unsigned int aP_depack_asm(const void *source, void *destination);

unsigned int aP_depack_asm_fast(const void *source, void *destination);

unsigned int aP_depack_asm_safe(const void *source,
                                unsigned int srclen,
                                void *destination,
                                unsigned int dstlen);

unsigned int aP_crc32(const void *source, unsigned int length);

unsigned int aPsafe_pack(const void *source,
                         void *destination,
                         unsigned int length,
                         void *workmem,
                         int (*callback)(unsigned int, unsigned int, unsigned int, void *),
                         void *cbparam);

unsigned int aPsafe_check(const void *source);

unsigned int aPsafe_get_orig_size(const void *source);

unsigned int aPsafe_depack(const void *source,
                           unsigned int srclen,
                           void *destination,
                           unsigned int dstlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* APLIB_H_INCLUDED */

```

`choco-packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
    <package id="winlibs"/>
    <package id="cmake"/>
</packages>

```

`common/CMakeLists.txt`:

```txt
add_library(
  libcommon
  SCommand.h
  SCommand.cpp
  Types.h
  Types.cpp
  Opcodes.def)

target_include_directories(
  libcommon
 PUBLIC
  "${CMAKE_SOURCE_DIR}")

target_link_libraries(
  libcommon
 PRIVATE
  liblog)
```

`common/Opcodes.def`:

```def


   // Order of commands is important

   OPCODE_FIRST(ADC, 0x14,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //14 ib ADC AL, imm8 ADD with carry imm8 to AL
   OPCODE_NEXT( ADC, 0x66,0x15,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //15 iw ADC AX, imm16 ADD with carry imm16 to AX
   OPCODE_NEXT( ADC, 0x15,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //15 id ADC EAX, imm32 ADD with carry imm32 to EAX
   OPCODE_NEXT( ADC, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R2)     //80 /2 ib ADC r/m8, imm8 ADD with carry imm8 to r/m8
   OPCODE_NEXT( ADC, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R2)
   OPCODE_NEXT( ADC, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R2)     //81 /2 iw ADC r/m16,imm16 ADD with carry imm16 to r/m16
   OPCODE_NEXT( ADC, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R2)
   OPCODE_NEXT( ADC, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R2)     //81 /2 id ADC r/m32,imm32 ADD with CF imm32 to r/m32
   OPCODE_NEXT( ADC, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R2)
   OPCODE_NEXT( ADC, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R2)     //83 /2 ib ADC r/m16,imm8 ADD with CF sign-extended imm8 to r/m16
   OPCODE_NEXT( ADC, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R2)
   OPCODE_NEXT( ADC, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R2)     //83 /2 ib ADC r/m32,imm8 ADD with CF sign-extended imm8 into r/m32
   OPCODE_NEXT( ADC, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R2)
   OPCODE_NEXT( ADC, 0x10,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //10 / r ADC r/m8,r8 ADD with carry byte register to r/m8
   OPCODE_NEXT( ADC, 0x10,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( ADC, 0x66,0x11,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //11 / r ADC r/m16,r16 ADD with carry r16 to r/m16
   OPCODE_NEXT( ADC, 0x66,0x11,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( ADC, 0x11,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //11 / r ADC r/m32,r32 ADD with CF r32 to r/m32
   OPCODE_NEXT( ADC, 0x11,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( ADC, 0x12,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //12 / r ADC r8,r/m8 ADD with carry r/m8 to byte register
   OPCODE_NEXT( ADC, 0x12,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( ADC, 0x66,0x13,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //13 / r ADC r16,r/m16 ADD with carry r/m16 to r16
   OPCODE_NEXT( ADC, 0x66,0x13,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( ADC, 0x13,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //13 / r ADC r32,r/m32 ADD with CF r/m32 to r32
   OPCODE_NEXT( ADC, 0x13,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)
																     
   OPCODE_FIRST(ADD, 0x04,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //04 ib ADD AL, imm8 ADD imm8 to AL
   OPCODE_NEXT( ADD, 0x66,0x05,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //05 iw ADD AX, imm16 ADD imm16 to AX
   OPCODE_NEXT( ADD, 0x05,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //05 id ADD EAX, imm32 ADD imm32 to EAX
   OPCODE_NEXT( ADD, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R0)     //80 /0 ib ADD r/m8,imm8 ADD imm8 to r/m8
   OPCODE_NEXT( ADD, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R0)
   OPCODE_NEXT( ADD, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R0)     //81 /0 iw ADD r/m16,imm16 ADD imm16 to r/m16
   OPCODE_NEXT( ADD, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R0)
   OPCODE_NEXT( ADD, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R0)     //81 /0 id ADD r/m32,imm32 ADD imm32 to r/m32
   OPCODE_NEXT( ADD, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R0)
   OPCODE_NEXT( ADD, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R0)     //83 /0 ib ADD r/m16,imm8 ADD sign-extended imm8 to r/m16
   OPCODE_NEXT( ADD, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R0)
   OPCODE_NEXT( ADD, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R0)     //83 /0 ib ADD r/m32,imm8 ADD sign-extended imm8 to r/m32
   OPCODE_NEXT( ADD, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R0)
   OPCODE_NEXT( ADD, 0x00,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //00 / r ADD r/m8,r8 ADD r8 to r/m8
   OPCODE_NEXT( ADD, 0x00,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( ADD, 0x66,0x01,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //01 / r ADD r/m16,r16 ADD r16 to r/m16
   OPCODE_NEXT( ADD, 0x66,0x01,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( ADD, 0x01,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //01 / r ADD r/m32,r32 ADD r32 to r/m32
   OPCODE_NEXT( ADD, 0x01,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( ADD, 0x02,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //02 / r ADD r8,r/m8 ADD r/m8 to r8
   OPCODE_NEXT( ADD, 0x02,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( ADD, 0x66,0x03,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //03 / r ADD r16,r/m16 ADD r/m16 to r16
   OPCODE_NEXT( ADD, 0x66,0x03,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( ADD, 0x03,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //03 / r ADD r32,r/m32 ADD r/m32 to r32
   OPCODE_NEXT( ADD, 0x03,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)
																     
   OPCODE_FIRST(AND, 0x24,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //24 ib AND AL, imm8 AL AND imm8
   OPCODE_NEXT( AND, 0x66,0x25,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //25 iw AND AX, imm16 AX AND i mm16
   OPCODE_NEXT( AND, 0x25,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //25 id AND EAX, imm32 EAX AND imm32
   OPCODE_NEXT( AND, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R4)     //80 /4 ib AND r/m8,imm8 r/m8 AND imm8
   OPCODE_NEXT( AND, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R4)
   OPCODE_NEXT( AND, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R4)     //81 /4 iw AND r/m16,imm16 r/m16 AND imm16
   OPCODE_NEXT( AND, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R4)
   OPCODE_NEXT( AND, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R4)     //81 /4 id AND r/m32,imm32 r/m32 AND imm32
   OPCODE_NEXT( AND, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R4)   
   OPCODE_NEXT( AND, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R4)     //83 /4 ib AND r/m16,imm8 r/m16 AND imm8 (sign-extended)
   OPCODE_NEXT( AND, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R4)
   OPCODE_NEXT( AND, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R4)     //83 /4 ib AND r/m32,imm8 r/m32 AND imm8 (sign-extended)
   OPCODE_NEXT( AND, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R4)
   OPCODE_NEXT( AND, 0x20,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //20 /r AND r/m8,r8 r/m8 AND r8
   OPCODE_NEXT( AND, 0x20,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( AND, 0x66,0x21,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //21 / r AND r/m16,r16 r/m16 AND r16
   OPCODE_NEXT( AND, 0x66,0x21,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( AND, 0x21,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //21 / r AND r/m32,r32 r/m32 AND r32
   OPCODE_NEXT( AND, 0x21,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)
   OPCODE_NEXT( AND, 0x22,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //22 / r AND r8,r/m8 r8 AND r/m8
   OPCODE_NEXT( AND, 0x22,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( AND, 0x66,0x23,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //23 / r AND r16,r/m16 r16 AND r/m16
   OPCODE_NEXT( AND, 0x66,0x23,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( AND, 0x23,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //23 / r AND r32,r/m32 r32 AND r/m32
   OPCODE_NEXT( AND, 0x23,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(CALL,0x66,0xe8,0x00,0x00, 0x02, REL16, NON,   NON,   EMPTY)  //E8 cw CALL rel16 Call near, relative, displacement relative to next instruction
   OPCODE_NEXT( CALL,0xe8,0x00,0x00,0x00, 0x01, REL32, NON,   NON,   EMPTY)  //E8 cd CALL rel32 Call near, relative, displacement relative to next instruction
   OPCODE_NEXT( CALL,0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R2)     //FF /2 CALL r/m16 Call near, absolute indirect, address given in r/m16
   OPCODE_NEXT( CALL,0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R2)         
   OPCODE_NEXT( CALL,0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R2)     //FF /2 CALL r/m32 Call near, absolute indirect, address given in r/m32
   OPCODE_NEXT( CALL,0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R2)         
                                                                             //9A cd CALL ptr16:16 Call far, absolute, address given in operAND
                                                                             //9A cp CALL ptr16:32 Call far, absolute, address given in operAND
 //OPCODE_NEXT( CALL,0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R3)     //FF /3 CALL m16:16 Call far, absolute indirect, address given in m16:16
 //OPCODE_NEXT( CALL,0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R3)
 //OPCODE_NEXT( CALL,0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R3)     //FF /3 CALL m16:32 Call far, absolute indirect, address given in m16:32
 //OPCODE_NEXT( CALL,0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R3)

   OPCODE_FIRST(RET, 0xc3,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //C3 RET Near RETurn to CALLing procedure
                                                                             //CB RET Far RETurn to CALLing procedure
   OPCODE_NEXT( RET, 0xc2,0x00,0x00,0x00, 0x01, IMM16, NON,   NON,   EMPTY)  //C2 iw RET imm16 Near RETurn to CALLing procedure AND POP imm16 bytes from stack
                                                                             //CA iw RET imm16 Far RETurn to CALLing procedure AND POP imm16 bytes from stack
   OPCODE_FIRST(CMP, 0x3c,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //3C ib CMP AL, imm8 Compare imm8 with AL
   OPCODE_NEXT( CMP, 0x66,0x3d,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //3D iw CMP AX, imm16 Compare imm16 with AX
   OPCODE_NEXT( CMP, 0x3d,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //3D id CMP EAX, imm32 Compare imm32 with EAX
   OPCODE_NEXT( CMP, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R7)     //80 /7 ib CMP r/m8, imm8 Compare imm8 with r/m8
   OPCODE_NEXT( CMP, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R7)
   OPCODE_NEXT( CMP, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R7)     //81 /7 iw CMP r/m16, imm16 Compare imm16 with r/m16
   OPCODE_NEXT( CMP, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R7)
   OPCODE_NEXT( CMP, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R7)     //81 /7 id CMP r/m32,imm32 Compare imm32 with r/m32
   OPCODE_NEXT( CMP, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R7)   
   OPCODE_NEXT( CMP, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R7)     //83 /7 ib CMP r/m16,imm8 Compare imm8 with r/m16
   OPCODE_NEXT( CMP, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R7)
   OPCODE_NEXT( CMP, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R7)     //83 /7 ib CMP r/m32,imm8 Compare imm8 with r/m32
   OPCODE_NEXT( CMP, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R7)
   OPCODE_NEXT( CMP, 0x38,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //38 / r CMP r/m8,r8 Compare r8 with r/m8
   OPCODE_NEXT( CMP, 0x38,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( CMP, 0x66,0x39,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //39 / r CMP r/m16,r16 Compare r16 with r/m16
   OPCODE_NEXT( CMP, 0x66,0x39,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( CMP, 0x39,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //39 / r CMP r/m32,r32 Compare r32 with r/m32
   OPCODE_NEXT( CMP, 0x39,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)
   OPCODE_NEXT( CMP, 0x3a,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //3A / r CMP r8,r/m8 Compare r/m8 with r8
   OPCODE_NEXT( CMP, 0x3a,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( CMP, 0x66,0x3b,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //3B / r CMP r16,r/m16 Compare r/m16 with r16
   OPCODE_NEXT( CMP, 0x66,0x3b,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( CMP, 0x3b,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //3B / r CMP r32,r/m32 Compare r/m32 with r32
   OPCODE_NEXT( CMP, 0x3b,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(CBW, 0x66,0x98,0x00,0x00, 0x02, NON,   NON,   NON,   EMPTY)  //98 CBW AX  sign-extend of AL
   OPCODE_FIRST(CWDE,0x98,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //98 CWDE EAX  sign-extend of AX
   OPCODE_FIRST(CWD, 0x66,0x99,0x00,0x00, 0x02, NON,   NON,   NON,   EMPTY)  //99 CWD DX:AX
   OPCODE_FIRST(CDQ, 0x99,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //99 CDQ EDX:EAX

   OPCODE_FIRST(CLC, 0xf8,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //F8 CLC CLEAr CF flag
   OPCODE_FIRST(CLD, 0xfc,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //FC CLD CLEAr DF flag
   OPCODE_FIRST(CLI, 0xfa,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //FA CLI CLEAr interrupt flag; interrupts disabled when interrupt

   OPCODE_FIRST(CMPSB,0xa6,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //A6 CMPSB
   OPCODE_FIRST(CMPSW,0x66,0xa7,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //A7 CMPSW
   OPCODE_FIRST(CMPSD,0xa7,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //A7 CMPSD

   OPCODE_FIRST(DIV, 0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R6)     //F6 /6 DIV r/m8 Unsigned DIVide AX by r/m8
   OPCODE_NEXT( DIV, 0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R6)
   OPCODE_NEXT( DIV, 0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R6)     //F7 /6 DIV r/m16 Unsigned DIVide DX:AX by r/m16; AX
   OPCODE_NEXT( DIV, 0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R6)
   OPCODE_NEXT( DIV, 0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R6)     //F7 /6 DIV r/m32 Unsigned DIVide EDX:EAX by r/m32 doublewORd
   OPCODE_NEXT( DIV, 0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R6)

   OPCODE_FIRST(IDIV,0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R7)     //F6 /7 IDIV r/m8 Signed DIVide
   OPCODE_NEXT( IDIV,0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R7)
   OPCODE_NEXT( IDIV,0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R7)     //F7 /7 IDIV r/m16 Signed DIVide
   OPCODE_NEXT( IDIV,0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R7)            
   OPCODE_NEXT( IDIV,0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R7)     //F7 /7 IDIV r/m32 Signed DIVide
   OPCODE_NEXT( IDIV,0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R7)

   OPCODE_FIRST(IMUL,0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R5)     //F6 /5 IMUL r/m8 AX¬ AL * r/m byte
   OPCODE_NEXT( IMUL,0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R5)
   OPCODE_NEXT( IMUL,0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R5)     //F7 /5 IMUL r/m16 DX:AX ¬ AX * r/m wORd
   OPCODE_NEXT( IMUL,0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R5)
   OPCODE_NEXT( IMUL,0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R5)     //F7 /5 IMUL r/m32 EDX:EAX ¬ EAX * r/m doublewORd
   OPCODE_NEXT( IMUL,0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R5)
   OPCODE_NEXT( IMUL,0x66,0xaf,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //0F AF / r IMUL r16,r/m16 wORd register
   OPCODE_NEXT( IMUL,0x66,0xaf,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( IMUL,0xaf,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //0F AF / r IMUL r32,r/m32 doublewORd register
   OPCODE_NEXT( IMUL,0xaf,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)
   OPCODE_NEXT( IMUL,0x66,0x6b,0x00,0x00, 0x02, REG16, REG16, IMM8,  R_RM)   //6B / r ib IMUL r16,r/m16,imm8 wORd register
   OPCODE_NEXT( IMUL,0x66,0x6b,0x00,0x00, 0x02, REG16, MEM16, IMM8,  R_RM)
   OPCODE_NEXT( IMUL,0x6b,0x00,0x00,0x00, 0x01, REG32, REG32, IMM8,  R_RM)   //6B / r ib IMUL r32,r/m32,imm8 doublewORd register byte
   OPCODE_NEXT( IMUL,0x6b,0x00,0x00,0x00, 0x01, REG32, MEM32, IMM8,  R_RM)
   OPCODE_NEXT( IMUL,0x66,0x6b,0x00,0x00, 0x02, REG16, IMM8,  NON,   R_RM)   //6B / r ib IMUL r16,imm8 wORd register
   OPCODE_NEXT( IMUL,0x6b,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R_RM)   //6B / r ib IMUL r32,imm8 doublewORd register
   OPCODE_NEXT( IMUL,0x66,0x69,0x00,0x00, 0x02, REG16, REG16, IMM16, RM_R)   //69 / r iw IMUL r16,r/ m16,imm16
   OPCODE_NEXT( IMUL,0x66,0x69,0x00,0x00, 0x02, REG16, MEM16, IMM16, RM_R)
   OPCODE_NEXT( IMUL,0x69,0x00,0x00,0x00, 0x01, REG32, REG32, IMM32, RM_R)   //69 / r id IMUL r32,r/ m32,imm32
   OPCODE_NEXT( IMUL,0x69,0x00,0x00,0x00, 0x01, REG32, MEM32, IMM32, RM_R)
   OPCODE_NEXT( IMUL,0x66,0x69,0x00,0x00, 0x02, REG16, IMM16, NON,   RM_R)   //69 / r iw IMUL r16,imm16 wORd register ¬ r/m16 * immediate wORd
   OPCODE_NEXT( IMUL,0x69,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   RM_R)   //69 / r id IMUL r32,imm32 doublewORd register ¬ r/m32 * immediate doublewORd

   OPCODE_FIRST(INC, 0xfe,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R0)     //FE /0 INC r/m8 Increment r/m byte by 1
   OPCODE_NEXT( INC, 0xfe,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R0)
   OPCODE_NEXT( INC, 0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R0)     //FF /0 INC r/m16 Increment r/m wORd by 1
 //OPCODE_NEXT( INC, 0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R0)   
   OPCODE_NEXT( INC, 0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R0)     //FF /0 INC r/m32 Increment r/m doublewORd by 1
 //OPCODE_NEXT( INC, 0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R0)
   OPCODE_NEXT( INC, 0x66,0x40,0x00,0x00, 0x02, REG16, NON,   NON,   PW)     //40+ rw INC r16 Increment wORd register by 1
   OPCODE_NEXT( INC, 0x40,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   PD)     //40+ rd INC r32 Increment doublewORd register by 1

   OPCODE_FIRST(DEC, 0xfe,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R1)     //FE /1 DEC r/m8 Decrement r/m8 by 1
   OPCODE_NEXT( DEC, 0xfe,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R1)        
   OPCODE_NEXT( DEC, 0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R1)     //FF /1 DEC r/m16 Decrement r/m16 by 1
 //OPCODE_NEXT( DEC, 0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R1)
   OPCODE_NEXT( DEC, 0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R1)     //FF /1 DEC r/m32 Decrement r/m32 by 1
 //OPCODE_NEXT( DEC, 0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R1)        
   OPCODE_NEXT( DEC, 0x66,0x48,0x00,0x00, 0x02, REG16, NON,   NON,   PW)     //48+rw DEC r16 Decrement r16 by 1
   OPCODE_NEXT( DEC, 0x48,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   PD)     //48+rd DEC r32 Decrement r32 by 1

   OPCODE_FIRST(JA,  0x77,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //77 cb JA rel8 Jump shORt if above (CF=0 AND ZF=0)
   OPCODE_NEXT( JA,  0x66,0x0f,0x87,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 87 cw/cd JA rel16/32 Jump near if above (CF=0 AND ZF=0)
   OPCODE_NEXT( JA,  0x0f,0x87,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JAE, 0x73,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //73 cb JAE rel8 Jump shORt if above OR equal (CF=0)
   OPCODE_NEXT( JAE, 0x66,0x0f,0x83,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 83 cw/cd JAE rel16/32 Jump near if above OR equal (CF=0)
   OPCODE_NEXT( JAE, 0x0f,0x83,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JB,  0x72,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //72 cb JB rel8 Jump shORt if below (CF=1)
   OPCODE_NEXT( JB,  0x66,0x0f,0x82,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 82 cw/cd JB rel16/32 Jump near if below (CF=1)
   OPCODE_NEXT( JB,  0x0f,0x82,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY) 
   OPCODE_FIRST(JBE, 0x76,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //76 cb JBE rel8 Jump shORt if below OR equal (CF=1 OR ZF=1)
   OPCODE_NEXT( JBE, 0x66,0x0f,0x86,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 86 cw/cd JBE rel16/32 Jump near if below OR equal (CF=1 OR ZF=1)
   OPCODE_NEXT( JBE, 0x0f,0x86,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JC,  0x72,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //72 cb JC rel8 Jump shORt if carry (CF=1)
   OPCODE_NEXT( JC,  0x66,0x0f,0x82,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 82 cw/cd JC rel16/32 Jump near if carry (CF=1)
   OPCODE_NEXT( JC,  0x0f,0x82,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JCXZ,0x66,0xe3,0x00,0x00, 0x02, REL8,  NON,   NON,   EMPTY)  //E3 cb JCXZ rel8 Jump shORt if CX register is 0
   OPCODE_FIRST(JECXZ,0xe3,0x00,0x00,0x00,0x01, REL8,  NON,   NON,   EMPTY)  //E3 cb JECXZ rel8 Jump shORt if ECX register is 0
   OPCODE_FIRST(JE,  0x74,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //74 cb JE rel8 Jump shORt if equal (ZF=1)
   OPCODE_NEXT( JE,  0x66,0x0f,0x84,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 84 cw/cd JE rel16/32 Jump near if equal (ZF=1)
   OPCODE_NEXT( JE,  0x0f,0x84,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JG,  0x7f,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7F cb JG rel8 Jump shORt if greater (ZF=0 AND SF=OF)
   OPCODE_NEXT( JG,  0x66,0x0f,0x8f,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8F cw/cd JG rel16/32 Jump near if greater (ZF=0 AND SF=OF)
   OPCODE_NEXT( JG,  0x0f,0x8f,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JGE, 0x7d,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7D cb JGE rel8 Jump shORt if greater OR equal (SF=OF)
   OPCODE_NEXT( JGE, 0x66,0x0f,0x8d,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8D cw/cd JGE rel16/32 Jump near if greater OR equal (SF=OF)
   OPCODE_NEXT( JGE, 0x0f,0x8d,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JL,  0x7c,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7C cb JL rel8 Jump shORt if less (SF<>OF)
   OPCODE_NEXT( JL,  0x66,0x0f,0x8c,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8C cw/cd JL rel16/32 Jump near if less (SF<>OF)
   OPCODE_NEXT( JL,  0x0f,0x8c,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JLE, 0x7e,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7E cb JLE rel8 Jump shORt if less OR equal (ZF=1 OR SF<>OF)
   OPCODE_NEXT( JLE, 0x66,0x0f,0x8e,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8E cw/cd JLE rel16/32 Jump near if less OR equal (ZF=1 OR SF<>OF)
   OPCODE_NEXT( JLE, 0x0f,0x8e,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNA, 0x76,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //76 cb JNA rel8 Jump shORt if NOT above (CF=1 OR ZF=1)
   OPCODE_NEXT( JNA, 0x66,0x0f,0x86,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 86 cw/cd JNA rel16/32 Jump near if NOT above (CF=1 OR ZF=1)
   OPCODE_NEXT( JNA, 0x0f,0x86,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNAE,0x72,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //72 cb JNAE rel8 Jump shORt if NOT above OR equal (CF=1)
   OPCODE_NEXT( JNAE,0x66,0x0f,0x82,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 82 cw/cd JNAE rel16/32 Jump near if NOT above OR equal (CF=1)
   OPCODE_NEXT( JNAE,0x0f,0x82,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNB, 0x73,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //73 cb JNB rel8 Jump shORt if NOT below (CF=EMPTY)
   OPCODE_NEXT( JNB, 0x66,0x0f,0x83,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 83 cw/cd JNB rel16/32 Jump near if NOT below (CF=0)
   OPCODE_NEXT( JNB, 0x0f,0x83,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNBE,0x77,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //77 cb JNBE rel8 Jump shORt if NOT below OR equal (CF=0 AND ZF=0)
   OPCODE_NEXT( JNBE,0x66,0x0f,0x87,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 87 cw/cd JNBE rel16/32 Jump near if NOT below OR equal (CF=0 AND ZF=0)
   OPCODE_NEXT( JNBE,0x0f,0x87,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNC, 0x73,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //73 cb JNC rel8 Jump shORt if NOT carry (CF=0)
   OPCODE_NEXT( JNC, 0x66,0x0f,0x83,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 83 cw/cd JNC rel16/32 Jump near if NOT carry (CF=0)
   OPCODE_NEXT( JNC, 0x0f,0x83,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNE, 0x75,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //75 cb JNE rel8 Jump shORt if NOT equal (ZF=0)
   OPCODE_NEXT( JNE, 0x66,0x0f,0x85,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 85 cw/cd JNE rel16/32 Jump near if NOT equal (ZF=0)
   OPCODE_NEXT( JNE, 0x0f,0x85,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNG, 0x7e,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7E cb JNG rel8 Jump shORt if NOT greater (ZF=1 OR SF<>OF)
   OPCODE_NEXT( JNG, 0x66,0x0f,0x8e,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8E cw/cd JNG rel16/32 Jump near if NOT greater (ZF=1 OR SF<>OF)
   OPCODE_NEXT( JNG, 0x0f,0x8e,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNGE,0x7c,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7C cb JNGE rel8 Jump shORt if NOT greater OR equal (SF<>OF)
   OPCODE_NEXT( JNGE,0x66,0x0f,0x8c,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8C cw/cd JNGE rel16/32 Jump near if NOT greater OR equal (SF<>OF)
   OPCODE_NEXT( JNGE,0x0f,0x8c,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNL, 0x7d,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7D cb JNL rel8 Jump shORt if NOT less (SF=OF)
   OPCODE_NEXT( JNL, 0x66,0x0f,0x8d,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8D cw/cd JNL rel16/32 Jump near if NOT less (SF=OF)
   OPCODE_NEXT( JNL, 0x0f,0x8d,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNLE,0x7f,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7F cb JNLE rel8 Jump shORt if NOT less OR equal (ZF=0 AND SF=OF)
   OPCODE_NEXT( JNLE,0x66,0x0f,0x8f,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8F cw/cd JNLE rel16/32 Jump near if NOT less OR equal (ZF=0 AND SF=OF)
   OPCODE_NEXT( JNLE,0x0f,0x8f,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNO, 0x71,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //71 cb JNO rel8 Jump shORt if NOT overflow (OF=0)
   OPCODE_NEXT( JNO, 0x66,0x0f,0x81,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 81 cw/cd JNO rel16/32 Jump near if NOT overflow (OF=0)
   OPCODE_NEXT( JNO, 0x0f,0x81,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNP, 0x7b,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7B cb JNP rel8 Jump shORt if NOT parity (PF=0)
   OPCODE_NEXT( JNP, 0x66,0x0f,0x8b,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8B cw/cd JNP rel16/32 Jump near if NOT parity (PF=0)
   OPCODE_NEXT( JNP, 0x0f,0x8b,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNS, 0x79,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //79 cb JNS rel8 Jump shORt if NOT sign (SF=0)
   OPCODE_NEXT( JNS, 0x66,0x0f,0x89,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 89 cw/cd JNS rel16/32 Jump near if NOT sign (SF=0)
   OPCODE_NEXT( JNS, 0x0f,0x89,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JNZ, 0x75,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //75 cb JNZ rel8 Jump shORt if NOT zero (ZF=0)
   OPCODE_NEXT( JNZ, 0x66,0x0f,0x85,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 85 cw/cd JNZ rel16/32 Jump near if NOT zero (ZF=0)
   OPCODE_NEXT( JNZ, 0x0f,0x85,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JO,  0x70,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //70 cb JO rel8 Jump shORt if overflow (OF=1)
   OPCODE_NEXT( JO,  0x66,0x0f,0x80,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 80 cw/cd JO rel16/32 Jump near if overflow (OF=1)
   OPCODE_NEXT( JO,  0x0f,0x80,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JP,  0x7a,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7A cb JP rel8 Jump shORt if parity (PF=1)
   OPCODE_NEXT( JP,  0x66,0x0f,0x8a,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8A cw/cd JP rel16/32 Jump near if parity (PF=1)
   OPCODE_NEXT( JP,  0x0f,0x8a,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JPE, 0x7a,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7A cb JPE rel8 Jump shORt if parity even (PF=1)
   OPCODE_NEXT( JPE, 0x66,0x0f,0x8a,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8A cw/cd JPE rel16/32 Jump near if parity even (PF=1)
   OPCODE_NEXT( JPE, 0x0f,0x8a,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JPO, 0x7b,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //7B cb JPO rel8 Jump shORt if parity odd (PF=0)
   OPCODE_NEXT( JPO, 0x66,0x0f,0x8b,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 8B cw/cd JPO rel16/32 Jump near if parity odd (PF=0)
   OPCODE_NEXT( JPO, 0x0f,0x8b,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JS,  0x78,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //78 cb JS rel8 Jump shORt if sign (SF=1)
   OPCODE_NEXT( JS,  0x66,0x0f,0x88,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 88 cw/cd JS rel16/32 Jump near if sign (SF=1)
   OPCODE_NEXT( JS,  0x0f,0x88,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)
   OPCODE_FIRST(JZ,  0x74,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //74 cb JZ rel8 Jump shORt if zero (ZF = 1)
   OPCODE_NEXT( JZ,  0x66,0x0f,0x84,0x00, 0x03, REL16, NON,   NON,   EMPTY)  //0F 84 cw/cd JZ rel16/32 Jump near if 0 (ZF=1)
   OPCODE_NEXT( JZ,  0x0f,0x84,0x00,0x00, 0x02, REL32, NON,   NON,   EMPTY)

   OPCODE_FIRST(JMP, 0xeb,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //EB cb JMP rel8 Jump shORt, relative, displacement relative to next instruction
   OPCODE_NEXT( JMP, 0x66,0xe9,0x00,0x00, 0x02, REL16, NON,   NON,   EMPTY)  //E9 cw JMP rel16 Jump near, relative, displacement relative to next instruction
   OPCODE_NEXT( JMP, 0xe9,0x00,0x00,0x00, 0x01, REL32, NON,   NON,   EMPTY)  //E9 cd JMP rel32 Jump near, relative, displacement relative to next instruction
   OPCODE_NEXT( JMP, 0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R4)     //FF /4 JMP r/m16 Jump near, absolute indirect, address given in r/m16
   OPCODE_NEXT( JMP, 0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R4)
   OPCODE_NEXT( JMP, 0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R4)     //FF /4 JMP r/m32 Jump near, absolute indirect, address given in r/m32
   OPCODE_NEXT( JMP, 0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R4)
                                                                             //EA cd JMP ptr16:16 Jump far, absolute, address given in operAND
                                                                             //EA cp JMP ptr16:32 Jump far, absolute, address given in operAND
 //OPCODE_NEXT( JMP, 0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R5)     //FF /5 JMP m16:16 Jump far, absolute indirect, address given in m16:16
 //OPCODE_NEXT( JMP, 0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R5)
 //OPCODE_NEXT( JMP, 0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R5)     //FF /5 JMP m16:32 Jump far, absolute indirect, address given in m16:32
 //OPCODE_NEXT( JMP, 0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R5)         

   OPCODE_FIRST(LEA, 0x66,0x8d,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //8D / r LEA r16,m StORe effective address fOR m in register r16
   OPCODE_NEXT( LEA, 0x66,0x8d,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( LEA, 0x8d,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //8D / r LEA r32,m StORe effective address fOR m in register r32
   OPCODE_NEXT( LEA, 0x8d,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)      
 
   OPCODE_FIRST(LODSB,0xac,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AC LODSB Load byte at address DS:(E)SI into AL
   OPCODE_FIRST(LODSW,0x66,0xad,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //AD LODSW Load wORd at address DS:(E)SI into AX
   OPCODE_FIRST(LODSD,0xad,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AD LODSD Load doublewORd at address DS:(E)SI into EAX
 
   OPCODE_FIRST(LOOP,0xe2,0x00,0x00,0x00, 0x01, REL8,  NON,   NON,   EMPTY)  //E2 cb LOOP rel8 Decrement count; jump shORt if count = 0
   OPCODE_FIRST(LEAVE,0xc9,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //C9 LEAVE Set ESP to EBP, then POP EBP
   OPCODE_FIRST(LOOPE,0xe1,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //E1 cb LOOPE
   OPCODE_FIRST(LOOPZ,0xe1,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //E1 cb LOOPZ
   OPCODE_FIRST(LOOPNE,0xe0,0x00,0x00,0x00,0x01,NON,   NON,   NON,   EMPTY)  //E0 cb LOOPNE
   OPCODE_FIRST(LOOPNZ,0xe0,0x00,0x00,0x00,0x01,NON,   NON,   NON,   EMPTY)  //E0 cb LOOPNZ
 
   OPCODE_FIRST(MOV, 0x8A,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //   8A / r MOV r8,r/m8 Move r/m8 to r8
   OPCODE_NEXT( MOV, 0x8A,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( MOV, 0x66,0x8B,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //   8B / r MOV r16,r/m16 Move r/m16 to r16
   OPCODE_NEXT( MOV, 0x66,0x8B,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( MOV, 0x8B,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //   8B / r MOV r32,r/m32 Move r/m32 to r32
   OPCODE_NEXT( MOV, 0x8B,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)
   OPCODE_NEXT( MOV, 0x88,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //   88 / r MOV r/m8,r8 Move r8 to r/m8
   OPCODE_NEXT( MOV, 0x88,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( MOV, 0x66,0x89,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //   89 / r MOV r/m16,r16 Move r16 to r/m16
   OPCODE_NEXT( MOV, 0x66,0x89,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( MOV, 0x89,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //   89 / r MOV r/m32,r32 Move r32 to r/m32
   OPCODE_NEXT( MOV, 0x89,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( MOV, 0xB0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   PB)     //   B0+ rb MOV r8,imm8 Move imm8 to r8
   OPCODE_NEXT( MOV, 0x66,0xB8,0x00,0x00, 0x02, REG16, IMM16, NON,   PW)     //   B8+ rw MOV r16,imm16 Move imm16 to r16
   OPCODE_NEXT( MOV, 0xB8,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   PD)     //   B8+ rd MOV r32,imm32 Move imm32 to r32
   OPCODE_NEXT( MOV, 0xC6,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R0)     //   C6 / 0 MOV r/m8,imm8 Move imm8 to r/m8
 //OPCODE_NEXT( MOV, 0xC6,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R0)         
   OPCODE_NEXT( MOV, 0x66,0xC7,0x00,0x00, 0x02, MEM16, IMM16, NON,   R0)     //   C7 / 0 MOV r/m16,imm16 Move imm16 to r/m16
 //OPCODE_NEXT( MOV, 0x66,0xC7,0x00,0x00, 0x02, REG16, IMM16, NON,   R0)         
   OPCODE_NEXT( MOV, 0xC7,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R0)     //   C7 / 0 MOV r/m32,imm32 Move imm32 to r/m32
 //OPCODE_NEXT( MOV, 0xC7,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R0)         

 //OPCODE_NEXT( MOV, 0xa0,0x00,0x00,0x00, 0x01, AL,    MEM8,  NON,   MOFFS8) //A0 MOV AL, moffs8* Move byte at ( seg:offset) to AL
 //OPCODE_NEXT( MOV, 0x66,0xa1,0x00,0x00, 0x02, AX,    MEM16, NON,   MOFFS16)//A1 MOV AX, moffs16* Move wORd at ( seg:offset) to AX
 //OPCODE_NEXT( MOV, 0xa1,0x00,0x00,0x00, 0x01, EAX,   MEM32, NON,   MOFFS32)//A1 MOV EAX, moffs32* Move doublewORd at ( seg:offset) to EAX
 //OPCODE_NEXT( MOV, 0xa2,0x00,0x00,0x00, 0x01, MEM8,  AL,    NON,   MOFFS8) //A2 MOV moffs8*,AL Move AL to ( seg:offset)
 //OPCODE_NEXT( MOV, 0x66,0xa3,0x00,0x00, 0x02, MEM16, AX,    NON,   MOFFS16)//A3 MOV moffs16*,AX Move AX to ( seg:offset)
 //OPCODE_NEXT( MOV, 0xa3,0x00,0x00,0x00, 0x01, MEM32, EAX,   NON,   MOFFS32)//A3 MOV moffs32*,EAX Move EAX to ( seg:offset)

   OPCODE_FIRST(MOVSB,0xa4,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //A4 MOVSB Move byte at address DS:(E)SI to address ES:(E)DI
   OPCODE_FIRST(MOVSW,0x66,0xa5,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //A5 MOVSW Move wORd at address DS:(E)SI to address ES:(E)DI
   OPCODE_FIRST(MOVSD,0xa5,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //A5 MOVSD Move doublewORd at address DS:(E)SI to address ES:(E)DI   

 //OPCODE_FIRST(XCHG,0x66,0x90,0x00,0x00, 0x02, AX,    REG16, NON,   PW)     //90+ rw XCHG AX, r16 Exchange r16 with AX
 //OPCODE_NEXT( XCHG,0x66,0x90,0x00,0x00, 0x02, REG16, AX,    NON,   PW)     //90+ rw XCHG r16,AX Exchange AX with r16
 //OPCODE_NEXT( XCHG,0x90,0x00,0x00,0x00, 0x01, EAX,   REG32, NON,   PD)     //90+ rd XCHG EAX, r32 Exchange r32 with EAX
 //OPCODE_NEXT( XCHG,0x90,0x00,0x00,0x00, 0x01, REG32, EAX,   NON,   PD)     //90+ rd XCHG r32,EAX Exchange EAX with r32
   OPCODE_FIRST(XCHG,0x86,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //86 / r XCHG r/m8,r8 Exchange r8 (byte register) with byte from r/m8
   OPCODE_NEXT( XCHG,0x86,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( XCHG,0x86,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //86 / r XCHG r8,r/m8 Exchange byte from r/m8 with r8 (byte register)
   OPCODE_NEXT( XCHG,0x86,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)               
   OPCODE_NEXT( XCHG,0x66,0x87,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //87 / r XCHG r/m16,r16 Exchange r16 with wORd from r/m16
   OPCODE_NEXT( XCHG,0x66,0x87,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( XCHG,0x66,0x87,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //87 / r XCHG r16,r/m16 Exchange wORd from r/m16 with r16
   OPCODE_NEXT( XCHG,0x66,0x87,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( XCHG,0x87,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //87 / r XCHG r/m32,r32 Exchange r32 with doublewORd from r/m32
   OPCODE_NEXT( XCHG,0x87,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( XCHG,0x87,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //87 / r XCHG r32,r/m32 Exchange doublewORd from r/m32 with r32
   OPCODE_NEXT( XCHG,0x87,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(MOVSX,0x66,0x0f,0xbe,0x00,0x03, REG16, REG8,  NON,   R_RM)   //0F BE / r MOVSX r16,r/m8 Move byte to wORd with sign-extension
   OPCODE_NEXT( MOVSX,0x66,0x0f,0xbe,0x00,0x03, REG16, MEM8,  NON,   R_RM)
   OPCODE_NEXT( MOVSX,0x0f,0xbe,0x00,0x00,0x02, REG32, REG8,  NON,   R_RM)   //0F BE / r MOVSX r32,r/m8 Move byte to doublewORd, sign-extension
   OPCODE_NEXT( MOVSX,0x0f,0xbe,0x00,0x00,0x02, REG32, MEM8,  NON,   R_RM)
   OPCODE_NEXT( MOVSX,0x0f,0xbf,0x00,0x00,0x02, REG32, REG16, NON,   R_RM)   //0F BF / r MOVSX r32,r/m16 Move wORd to doublewORd, sign-extension
   OPCODE_NEXT( MOVSX,0x0f,0xbf,0x00,0x00,0x02, REG32, MEM16, NON,   R_RM)

   OPCODE_FIRST(MOVZX,0x66,0x0f,0xb6,0x00,0x03, REG16, REG8,  NON,   R_RM)   //0F B6 / r MOVZX r16,r/m8 Move byte to wORd with zero-extension
   OPCODE_NEXT( MOVZX,0x66,0x0f,0xb6,0x00,0x03, REG16, MEM8,  NON,   R_RM)
   OPCODE_NEXT( MOVZX,0x0f,0xb6,0x00,0x00,0x02, REG32, REG8,  NON,   R_RM)   //0F B6 / r MOVZX r32,r/m8 Move byte to doublewORd, zero-extension
   OPCODE_NEXT( MOVZX,0x0f,0xb6,0x00,0x00,0x02, REG32, MEM8,  NON,   R_RM)
   OPCODE_NEXT( MOVZX,0x0f,0xb7,0x00,0x00,0x02, REG32, REG16, NON,   R_RM)   //0F B7 / r MOVZX r32,r/m16 Move wORd to doublewORd, zero-extension
   OPCODE_NEXT( MOVZX,0x0f,0xb7,0x00,0x00,0x02, REG32, MEM16, NON,   R_RM)
      
   OPCODE_FIRST(MUL, 0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R4)     //F6 /4 MUL r/m8 Unsigned MULtiply (AX ¬ AL * r/m8)
   OPCODE_NEXT( MUL, 0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R4)    
   OPCODE_NEXT( MUL, 0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R4)     //F7 /4 MUL r/m16 Unsigned MULtiply (DX:AX ¬ AX * r/m16)
   OPCODE_NEXT( MUL, 0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R4)         
   OPCODE_NEXT( MUL, 0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R4)     //F7 /4 MUL r/m32 Unsigned MULtiply (EDX:EAX ¬ EAX * r/m32)
   OPCODE_NEXT( MUL, 0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R4)   

   OPCODE_FIRST(NEG, 0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R3)     //F6 /3 NEG r/m8 Two's complement NEGate r/m8
   OPCODE_NEXT( NEG, 0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R3)
   OPCODE_NEXT( NEG, 0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R3)     //F7 /3 NEG r/m16 Two's complement NEGate r/m16
   OPCODE_NEXT( NEG, 0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R3)
   OPCODE_NEXT( NEG, 0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R3)     //F7 /3 NEG r/m32 Two's complement NEGate r/m32    
   OPCODE_NEXT( NEG, 0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R3)

   OPCODE_FIRST(NOP, 0x90,0x00,0x00,0x00, 0x01, NON,   NON,   NON,   EMPTY)  //90 NOP No operation

   OPCODE_FIRST(NOT, 0xf6,0x00,0x00,0x00, 0x01, REG8,  NON,   NON,   R2)     //F6 /2 NOT r/m8 Reverse each bit of r/m8
   OPCODE_NEXT( NOT, 0xf6,0x00,0x00,0x00, 0x01, MEM8,  NON,   NON,   R2)
   OPCODE_NEXT( NOT, 0x66,0xf7,0x00,0x00, 0x02, REG16, NON,   NON,   R2)     //F7 /2 NOT r/m16 Reverse each bit of r/m16
   OPCODE_NEXT( NOT, 0x66,0xf7,0x00,0x00, 0x02, MEM16, NON,   NON,   R2)
   OPCODE_NEXT( NOT, 0xf7,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R2)     //F7 /2 NOT r/m32 Reverse each bit of r/m32
   OPCODE_NEXT( NOT, 0xf7,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R2)

   OPCODE_FIRST(OR,  0x0c,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //0C ib OR AL, imm8 AL OR imm8
   OPCODE_NEXT( OR,  0x66,0x0d,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //0D iw OR AX, imm16 AX OR imm16
   OPCODE_NEXT( OR,  0x0d,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //0D id OR EAX, imm32 EAX OR imm32
   OPCODE_NEXT( OR,  0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R1)     //80 /1 ib OR r/m8,imm8 r/m8 OR imm8
   OPCODE_NEXT( OR,  0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R1)
   OPCODE_NEXT( OR,  0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R1)     //81 /1 iw OR r/m16,imm16 r/m16 OR imm16
   OPCODE_NEXT( OR,  0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R1)
   OPCODE_NEXT( OR,  0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R1)     //81 /1 id OR r/m32,imm32 r/m32 OR imm32
   OPCODE_NEXT( OR,  0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R1)
   OPCODE_NEXT( OR,  0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R1)     //83 /1 ib OR r/m16,imm8 r/m16 OR imm8 (sign-extended)
   OPCODE_NEXT( OR,  0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R1)
   OPCODE_NEXT( OR,  0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R1)     //83 /1 ib OR r/m32,imm8 r/m32 OR imm8 (sign-extended)
   OPCODE_NEXT( OR,  0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R1)
   OPCODE_NEXT( OR,  0x08,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //08 / r OR r/m8,r8 r/m8 OR r8
   OPCODE_NEXT( OR,  0x08,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( OR,  0x66,0x09,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //09 / r OR r/m16,r16 r/m16 OR r16
   OPCODE_NEXT( OR,  0x66,0x09,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)    
   OPCODE_NEXT( OR,  0x09,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //09 / r OR r/m32,r32 r/m32 OR r32
   OPCODE_NEXT( OR,  0x09,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( OR,  0x0a,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //0A / r OR r8,r/m8 r8 OR r/m8
   OPCODE_NEXT( OR,  0x0a,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( OR,  0x66,0x0a,0x00,0x00, 0x01, REG16, REG16, NON,   R_RM)   //0B / r OR r16,r/m16 r16 OR r/m16
   OPCODE_NEXT( OR,  0x66,0x0a,0x00,0x00, 0x01, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( OR,  0x0b,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //0B / r OR r32,r/m32 r32 OR r/m32
   OPCODE_NEXT( OR,  0x0b,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(POP, 0x66,0x8f,0x00,0x00, 0x02, MEM16, NON,   NON,   R0)     //8F /0 POP m16 Pop top of stack into m16; INCrement stack pointer
   OPCODE_NEXT( POP, 0x8f,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R0)     //8F /0 POP m32 Pop top of stack into m32; INCrement stack pointer
   OPCODE_NEXT( POP, 0x66,0x58,0x00,0x00, 0x02, REG16, NON,   NON,   PW)     //58+ rw POP r16 Pop top of stack into r16; INCrement stack pointer
   OPCODE_NEXT( POP, 0x58,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   PD)     //58+ rd POP r32 Pop top of stack into r32; INCrement stack pointer

   OPCODE_FIRST(POPA,0x66,0x61,0x00,0x00, 0x02, NON,   NON,   NON,   EMPTY)  //61 POPA Pop DI, SI, BP, BX, DX, CX, AND AX
   OPCODE_FIRST(POPAD,0x61,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //61 POPAD Pop EDI, ESI, EBP, EBX, EDX, ECX, AND EAX
   OPCODE_FIRST(POPF,0x66,0x9d,0x00,0x00, 0x02, NON,   NON,   NON,   EMPTY)  //9D POPF Pop top of stack into lower 16 bits of EFLAGS
   OPCODE_FIRST(POPFD,0x61,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //9D POPFD Pop top of stack into EFLAGS

   OPCODE_FIRST(PUSH,0x66,0xff,0x00,0x00, 0x02, MEM16, NON,   NON,   R6)     //FF /6 PUSH r/m16 Push r/m16
 //OPCODE_NEXT( PUSH,0x66,0xff,0x00,0x00, 0x02, REG16, NON,   NON,   R6) 
   OPCODE_NEXT( PUSH,0xff,0x00,0x00,0x00, 0x01, MEM32, NON,   NON,   R6)     //FF /6 PUSH r/m32 Push r/m32
 //OPCODE_NEXT( PUSH,0xff,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   R6)
   OPCODE_NEXT( PUSH,0x66,0x50,0x00,0x00, 0x02, REG16, NON,   NON,   PW)     //50+ rw PUSH r16 Push r16
   OPCODE_NEXT( PUSH,0x50,0x00,0x00,0x00, 0x01, REG32, NON,   NON,   PD)     //50+ rd PUSH r32 Push r32
   OPCODE_NEXT( PUSH,0x6a,0x00,0x00,0x00, 0x01, IMM8,  NON,   NON,   EMPTY)  //6A PUSH imm8 Push imm8
   OPCODE_NEXT( PUSH,0x66,0x68,0x00,0x00, 0x02, IMM16, NON,   NON,   EMPTY)  //68 PUSH imm16 Push imm16
   OPCODE_NEXT( PUSH,0x68,0x00,0x00,0x00, 0x01, IMM32, NON,   NON,   EMPTY)  //68 PUSH imm32 Push imm32
   OPCODE_FIRST(PUSHA,0x66,0x60,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //60 PUSHA Push AX, CX, DX, BX, ORiginal SP, BP, SI, AND DI
   OPCODE_FIRST(PUSHAD,0x60,0x00,0x00,0x00,0x01,NON,   NON,   NON,   EMPTY)  //60 PUSHAD Push EAX, ECX, EDX, EBX, ORiginal ESP, EBP, ESI, AND EDI
   OPCODE_FIRST(PUSHF,0x66,0x9c,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //9C PUSHF Push lower 16 bits of EFLAGS
   OPCODE_FIRST(PUSHFD,0x9c,0x00,0x00,0x00,0x01,NON,   NON,   NON,   EMPTY)  //9C PUSHFD Push EFLAGS

   OPCODE_FIRST(RCL, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R2)     //D0 /2 RCL r/m8,1 Rotate 9 bits (CF, r/m8) left once
   OPCODE_NEXT( RCL, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R2)
   OPCODE_NEXT( RCL, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R2)     //D2 /2 RCL r/m8,CL Rotate 9 bits (CF, r/m8) left CL times
   OPCODE_NEXT( RCL, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R2)
   OPCODE_NEXT( RCL, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R2)     //C0 /2 ib RCL r/m8,imm8 Rotate 9 bits (CF, r/m8) left imm8 times
   OPCODE_NEXT( RCL, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R2)
   OPCODE_NEXT( RCL, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R2)     //D1 /2 RCL r/m16,1 Rotate 17 bits (CF, r/m16) left once
   OPCODE_NEXT( RCL, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R2)
   OPCODE_NEXT( RCL, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R2)     //D3 /2 RCL r/m16,CL Rotate 17 bits (CF, r/m16) left CL times
   OPCODE_NEXT( RCL, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R2)
   OPCODE_NEXT( RCL, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R2)     //C1 /2 ib RCL r/m16,imm8 Rotate 17 bits (CF, r/m16) left imm8 times
   OPCODE_NEXT( RCL, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R2)
   OPCODE_NEXT( RCL, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R2)     //D1 /2 RCL r/m32,1 Rotate 33 bits (CF, r/m32) left once
   OPCODE_NEXT( RCL, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R2)
   OPCODE_NEXT( RCL, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R2)     //D3 /2 RCL r/m32,CL Rotate 33 bits (CF, r/m32) left CL times
   OPCODE_NEXT( RCL, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R2)
   OPCODE_NEXT( RCL, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R2)     //C1 /2 ib RCL r/m32,imm8 Rotate 33 bits (CF, r/m32) left imm8 times
   OPCODE_NEXT( RCL, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R2)

   OPCODE_FIRST(RCR, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R3)     //D0 /3 RCR r/m8,1 Rotate 9 bits (CF, r/m8) right once
   OPCODE_NEXT( RCR, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R3)
   OPCODE_NEXT( RCR, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R3)     //D2 /3 RCR r/m8,CL Rotate 9 bits (CF, r/m8) right CL times
   OPCODE_NEXT( RCR, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R3)
   OPCODE_NEXT( RCR, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R3)     //C0 /3 ib RCR r/m8,imm8 Rotate 9 bits (CF, r/m8) right imm8 times
   OPCODE_NEXT( RCR, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R3)
   OPCODE_NEXT( RCR, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R3)     //D1 /3 RCR r/m16,1 Rotate 17 bits (CF, r/m16) right once
   OPCODE_NEXT( RCR, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R3)
   OPCODE_NEXT( RCR, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R3)     //D3 /3 RCR r/m16,CL Rotate 17 bits (CF, r/m16) right CL times
   OPCODE_NEXT( RCR, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R3)
   OPCODE_NEXT( RCR, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R3)     //C1 /3 ib RCR r/m16,imm8 Rotate 17 bits (CF, r/m16) right imm8 times
   OPCODE_NEXT( RCR, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R3)
   OPCODE_NEXT( RCR, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R3)     //D1 /3 RCR r/m32,1 Rotate 33 bits (CF, r/m32) right once
   OPCODE_NEXT( RCR, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R3)
   OPCODE_NEXT( RCR, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R3)     //D3 /3 RCR r/m32,CL Rotate 33 bits (CF, r/m32) right CL times
   OPCODE_NEXT( RCR, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R3)
   OPCODE_NEXT( RCR, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R3)     //C1 /3 ib RCR r/m32,imm8 Rotate 33 bits (CF, r/m32) right imm8 times
   OPCODE_NEXT( RCR, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R3)

   OPCODE_FIRST(ROL, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R0)     //D0 /0 ROL r/m8,1 Rotate 8 bits r/m8 left once
   OPCODE_NEXT( ROL, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R0)
   OPCODE_NEXT( ROL, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R0)     //D2 /0 ROL r/m8,CL Rotate 8 bits r/m8 left CL times
   OPCODE_NEXT( ROL, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R0)
   OPCODE_NEXT( ROL, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R0)     //C0 /0 ib ROL r/m8,imm8 Rotate 8 bits r/m8 left imm8 times
   OPCODE_NEXT( ROL, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R0)
   OPCODE_NEXT( ROL, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R0)     //D1 /0 ROL r/m16,1 Rotate 16 bits r/m16 left once
   OPCODE_NEXT( ROL, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R0)
   OPCODE_NEXT( ROL, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R0)     //D3 /0 ROL r/m16,CL Rotate 16 bits r/m16 left CL times
   OPCODE_NEXT( ROL, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R0)
   OPCODE_NEXT( ROL, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R0)     //C1 /0 ib ROL r/m16,imm8 Rotate 16 bits r/m16 left imm8 times
   OPCODE_NEXT( ROL, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R0)
   OPCODE_NEXT( ROL, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R0)     //D1 /0 ROL r/m32,1 Rotate 32 bits r/m32 left once
   OPCODE_NEXT( ROL, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R0)
   OPCODE_NEXT( ROL, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R0)     //D3 /0 ROL r/m32,CL Rotate 32 bits r/m32 left CL times
   OPCODE_NEXT( ROL, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R0)
   OPCODE_NEXT( ROL, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R0)     //C1 /0 ib ROL r/m32,imm8 Rotate 32 bits r/m32 left imm8 times    
   OPCODE_NEXT( ROL, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R0)    

   OPCODE_FIRST(ROR, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R1)     //D0 /1 ROR r/m8,1 Rotate 8 bits r/m8 right once
   OPCODE_NEXT( ROR, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R1)
   OPCODE_NEXT( ROR, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R1)     //D2 /1 ROR r/m8,CL Rotate 8 bits r/m8 right CL times
   OPCODE_NEXT( ROR, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R1)
   OPCODE_NEXT( ROR, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R1)     //C0 /1 ib ROR r/m8,imm8 Rotate 8 bits r/m16 right imm8 times
   OPCODE_NEXT( ROR, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R1)
   OPCODE_NEXT( ROR, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R1)     //D1 /1 ROR r/m16,1 Rotate 16 bits r/m16 right once
   OPCODE_NEXT( ROR, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R1)
   OPCODE_NEXT( ROR, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R1)     //D3 /1 ROR r/m16,CL Rotate 16 bits r/m16 right CL times
   OPCODE_NEXT( ROR, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R1)
   OPCODE_NEXT( ROR, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R1)     //C1 /1 ib ROR r/m16,imm8 Rotate 16 bits r/m16 right imm8 times
   OPCODE_NEXT( ROR, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R1)
   OPCODE_NEXT( ROR, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R1)     //D1 /1 ROR r/m32,1 Rotate 32 bits r/m32 right once
   OPCODE_NEXT( ROR, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R1)
   OPCODE_NEXT( ROR, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R1)     //D3 /1 ROR r/m32,CL Rotate 32 bits r/m32 right CL times
   OPCODE_NEXT( ROR, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R1)
   OPCODE_NEXT( ROR, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R1)     //C1 /1 ib ROR r/m32,imm8 Rotate 32 bits r/m32 right imm8 times    
   OPCODE_NEXT( ROR, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R1)    

   OPCODE_FIRST(SHR, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R5)     //D0 /5 SHR r/m8,1 Unsigned DIVide r/m8 by 2, once
   OPCODE_NEXT( SHR, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R5)
   OPCODE_NEXT( SHR, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R5)     //D0 /5 SHR r/m8,1 Unsigned DIVide r/m8 by 2, once
   OPCODE_NEXT( SHR, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R5)
   OPCODE_NEXT( SHR, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R5)     //C0 /5 ib SHR r/m8,imm8 Unsigned DIVide r/m8 by 2, imm8 times
   OPCODE_NEXT( SHR, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R5)
   OPCODE_NEXT( SHR, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R5)     //D1 /5 SHR r/m16,1 Unsigned DIVide r/m16 by 2, once
   OPCODE_NEXT( SHR, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R5)
   OPCODE_NEXT( SHR, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R5)     //D3 /5 SHR r/m16,CL Unsigned DIVide r/m16 by 2, CL times
   OPCODE_NEXT( SHR, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R5)
   OPCODE_NEXT( SHR, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R5)     //C1 /5 ib SHR r/m16,imm8 Unsigned DIVide r/m16 by 2, imm8 times
   OPCODE_NEXT( SHR, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R5)
   OPCODE_NEXT( SHR, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R5)     //D1 /5 SHR r/m32,1 Unsigned DIVide r/m32 by 2, once
   OPCODE_NEXT( SHR, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R5)
   OPCODE_NEXT( SHR, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R5)     //D3 /5 SHR r/m32,CL Unsigned DIVide r/m32 by 2, CL times
   OPCODE_NEXT( SHR, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R5)
   OPCODE_NEXT( SHR, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R5)     //C1 /5 ib SHR r/m32,imm8 Unsigned DIVide r/m32 by 2, imm8 times
   OPCODE_NEXT( SHR, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R5)    

   OPCODE_FIRST(SHL, 0xd0,0x00,0x00,0x00, 0x01, REG8,  IMM1,  NON,   R4)     //D0 /4 SHL r/m8,1 Multiply r/m8 by 2, once
   OPCODE_NEXT( SHL, 0xd0,0x00,0x00,0x00, 0x01, MEM8,  IMM1,  NON,   R4)
   OPCODE_NEXT( SHL, 0xd2,0x00,0x00,0x00, 0x01, REG8,  CL,    NON,   R4)     //D2 /4 SHL r/m8,CL Multiply r/m8 by 2, CL times
   OPCODE_NEXT( SHL, 0xd2,0x00,0x00,0x00, 0x01, MEM8,  CL,    NON,   R4)
   OPCODE_NEXT( SHL, 0xc0,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R4)     //C0 /4 ib SHL r/m8,imm8 Multiply r/m8 by 2, imm8 times
   OPCODE_NEXT( SHL, 0xc0,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R4)
   OPCODE_NEXT( SHL, 0x66,0xd1,0x00,0x00, 0x02, REG16, IMM1,  NON,   R4)     //D1 /4 SHL r/m16,1 Multiply r/m16 by 2, once
   OPCODE_NEXT( SHL, 0x66,0xd1,0x00,0x00, 0x02, MEM16, IMM1,  NON,   R4)
   OPCODE_NEXT( SHL, 0x66,0xd3,0x00,0x00, 0x02, REG16, CL,    NON,   R4)     //D3 /4 SHL r/m16,CL Multiply r/m16 by 2, CL times
   OPCODE_NEXT( SHL, 0x66,0xd3,0x00,0x00, 0x02, MEM16, CL,    NON,   R4)
   OPCODE_NEXT( SHL, 0x66,0xc1,0x00,0x00, 0x02, REG16, IMM8,  NON,   R4)     //C1 /4 ib SHL r/m16,imm8 Multiply r/m16 by 2, imm8 times
   OPCODE_NEXT( SHL, 0x66,0xc1,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R4)
   OPCODE_NEXT( SHL, 0xd1,0x00,0x00,0x00, 0x01, REG32, IMM1,  NON,   R4)     //D1 /4 SHL r/m32,1 Multiply r/m32 by 2, once
   OPCODE_NEXT( SHL, 0xd1,0x00,0x00,0x00, 0x01, MEM32, IMM1,  NON,   R4)
   OPCODE_NEXT( SHL, 0xd3,0x00,0x00,0x00, 0x01, REG32, CL,    NON,   R4)     //D3 /4 SHL r/m32,CL Multiply r/m32 by 2, CL times
   OPCODE_NEXT( SHL, 0xd3,0x00,0x00,0x00, 0x01, MEM32, CL,    NON,   R4)
   OPCODE_NEXT( SHL, 0xc1,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R4)     //C1 /4 ib SHL r/m32,imm8 Multiply r/m32 by 2, imm8 times
   OPCODE_NEXT( SHL, 0xc1,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R4)    

   OPCODE_FIRST(STOSB,0xaa,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AA STOSB StORe AL at address ES:(E)DI
   OPCODE_FIRST(STOSW,0x66,0xab,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //AB STOSW StORe AX at address ES:(E)DI
   OPCODE_FIRST(STOSD,0xab,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AB STOSD StORe EAX at address ES:(E)DI    
   OPCODE_FIRST(SCASB,0xae,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AE SCAS m8 Compare AL with byte at ES:(E)DI AND set status flags
   OPCODE_FIRST(SCASW,0x66,0xaf,0x00,0x00,0x02, NON,   NON,   NON,   EMPTY)  //AF SCAS m16 Compare AX with wORd at ES:(E)DI AND set status flags
   OPCODE_FIRST(SCASD,0xaf,0x00,0x00,0x00,0x01, NON,   NON,   NON,   EMPTY)  //AF SCAS m32 Compare EAX with doublewORd at ES(E)DI AND set status flags

   OPCODE_FIRST(SUB, 0x2c,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //2C ib SUB AL, imm8 Subtract imm8 from AL
   OPCODE_NEXT( SUB, 0x66,0x2d,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //2D iw SUB AX, imm16 Subtract imm16 from AX
   OPCODE_NEXT( SUB, 0x2d,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //2D id SUB EAX, imm32 Subtract imm32 from EAX
   OPCODE_NEXT( SUB, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R5)     //80 /5 ib SUB r/m8,imm8 Subtract imm8 from r/m8
   OPCODE_NEXT( SUB, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R5)
   OPCODE_NEXT( SUB, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R5)     //81 /5 iw SUB r/m16,imm16 Subtract imm16 from r/m16
   OPCODE_NEXT( SUB, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R5)
   OPCODE_NEXT( SUB, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R5)     //81 /5 id SUB r/m32,imm32 Subtract imm32 from r/m32
   OPCODE_NEXT( SUB, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R5)
   OPCODE_NEXT( SUB, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R5)     //83 /5 ib SUB r/m16,imm8 Subtract sign-extended imm8 from r/m16
   OPCODE_NEXT( SUB, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R5)
   OPCODE_NEXT( SUB, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R5)     //83 /5 ib SUB r/m32,imm8 Subtract sign-extended imm8 from r/m32
   OPCODE_NEXT( SUB, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R5)
   OPCODE_NEXT( SUB, 0x28,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //28 / r SUB r/m8,r8 Subtract r8 from r/m8
   OPCODE_NEXT( SUB, 0x28,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( SUB, 0x66,0x29,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //29 / r SUB r/m16,r16 Subtract r16 from r/m16
   OPCODE_NEXT( SUB, 0x66,0x29,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( SUB, 0x29,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //29 / r SUB r/m32,r32 Subtract r32 from r/m32
   OPCODE_NEXT( SUB, 0x29,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( SUB, 0x2a,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //2A / r SUB r8,r/m8 Subtract r/m8 from r8
   OPCODE_NEXT( SUB, 0x2a,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( SUB, 0x66,0x2b,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //2B / r SUB r16,r/m16 Subtract r/m16 from r16
   OPCODE_NEXT( SUB, 0x66,0x2b,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( SUB, 0x2b,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //2B / r SUB r32,r/m32 Subtract r/m32 from r32
   OPCODE_NEXT( SUB, 0x2b,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(SBB, 0x1c,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //1C ib SBB AL, imm8 Subtract with bORrow imm8 from AL
   OPCODE_NEXT( SBB, 0x66,0x1d,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //1D iw SBB AX, imm16 Subtract with bORrow imm16 from AX
   OPCODE_NEXT( SBB, 0x1d,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //1D id SBB EAX, imm32 Subtract with bORrow imm32 from EAX
   OPCODE_NEXT( SBB, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R3)     //80 /3 ib SBB r/m8,imm8 Subtract with bORrow imm8 from r/m8
   OPCODE_NEXT( SBB, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R3)
   OPCODE_NEXT( SBB, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R3)     //81 /3 iw SBB r/m16,imm16 Subtract with bORrow imm16 from r/m16
   OPCODE_NEXT( SBB, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R3)
   OPCODE_NEXT( SBB, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R3)     //81 /3 id SBB r/m32,imm32 Subtract with bORrow imm32 from r/m32
   OPCODE_NEXT( SBB, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R3)
   OPCODE_NEXT( SBB, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R3)     //83 /3 ib SBB r/m16,imm8 Subtract with bORrow sign-extended imm8 from r/m16
   OPCODE_NEXT( SBB, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R3)
   OPCODE_NEXT( SBB, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R3)     //83 /3 ib SBB r/m32,imm8 Subtract with bORrow sign-extended imm8 from r/m32
   OPCODE_NEXT( SBB, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R3)
   OPCODE_NEXT( SBB, 0x18,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //18 / r SBB r/m8,r8 Subtract with bORrow r8 from r/m8
   OPCODE_NEXT( SBB, 0x18,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( SBB, 0x66,0x19,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //19 / r SBB r/m16,r16 Subtract with bORrow r16 from r/m16
   OPCODE_NEXT( SBB, 0x66,0x19,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( SBB, 0x19,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //19 / r SBB r/m32,r32 Subtract with bORrow r32 from r/m32
   OPCODE_NEXT( SBB, 0x19,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( SBB, 0x1a,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //1A / r SBB r8,r/m8 Subtract with bORrow r/m8 from r8
   OPCODE_NEXT( SBB, 0x1a,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( SBB, 0x66,0x1b,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //1B / r SBB r16,r/m16 Subtract with bORrow r/m16 from r16
   OPCODE_NEXT( SBB, 0x66,0x1b,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM)
   OPCODE_NEXT( SBB, 0x1b,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //1B / r SBB r32,r/m32 Subtract with bORrow r/m32 from r32
   OPCODE_NEXT( SBB, 0x1b,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

   OPCODE_FIRST(TEST,0xa8,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //A8 ib TEST AL, imm8 AND imm8 with AL; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0x66,0xa9,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //A9 iw TEST AX, imm16 AND imm16 with AX; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0xa9,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //A9 id TEST EAX, imm32 AND imm32 with EAX; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0xf6,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R0)     //F6 /0 ib TEST r/m8,imm8 AND imm8 with r/m8; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0xf6,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R0)
   OPCODE_NEXT( TEST,0x66,0xf7,0x00,0x00, 0x02, REG16, IMM16, NON,   R0)     //F7 /0 iw TEST r/m16,imm16 AND imm16 with r/m6; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0x66,0xf7,0x00,0x00, 0x02, MEM16, IMM16, NON,   R0)
   OPCODE_NEXT( TEST,0xf7,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R0)     //F7 /0 id TEST r/m32,imm32 AND imm32 with r/m32; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0xf7,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R0)
   OPCODE_NEXT( TEST,0x84,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //84 / r TEST r/m8,r8 AND r8 with r/m8; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0x84,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( TEST,0x66,0x85,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //85 / r TEST r/m16,r16 AND r16 with r/m16; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0x66,0x85,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( TEST,0x85,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //85 / r TEST r/m32,r32 AND r32 with r/m32; set SF, ZF, PF accORding to result
   OPCODE_NEXT( TEST,0x85,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)

   OPCODE_FIRST(XOR, 0x34,0x00,0x00,0x00, 0x01, AL,    IMM8,  NON,   EMPTY)  //34 ib XOR AL, imm8 AL XOR imm8
   OPCODE_NEXT( XOR, 0x66,0x35,0x00,0x00, 0x02, AX,    IMM16, NON,   EMPTY)  //35 iw XOR AX, imm16 AX XOR imm16
   OPCODE_NEXT( XOR, 0x35,0x00,0x00,0x00, 0x01, EAX,   IMM32, NON,   EMPTY)  //35 id XOR EAX, imm32 EAX XOR imm32
   OPCODE_NEXT( XOR, 0x80,0x00,0x00,0x00, 0x01, REG8,  IMM8,  NON,   R6)     //80 /6 ib XOR r/m8,imm8 r/m8 XOR imm8
   OPCODE_NEXT( XOR, 0x80,0x00,0x00,0x00, 0x01, MEM8,  IMM8,  NON,   R6)
   OPCODE_NEXT( XOR, 0x66,0x81,0x00,0x00, 0x02, REG16, IMM16, NON,   R6)     //81 /6 iw XOR r/m16,imm16 r/m16 XOR imm16
   OPCODE_NEXT( XOR, 0x66,0x81,0x00,0x00, 0x02, MEM16, IMM16, NON,   R6)
   OPCODE_NEXT( XOR, 0x81,0x00,0x00,0x00, 0x01, REG32, IMM32, NON,   R6)     //81 /6 id XOR r/m32,imm32 r/m32 XOR imm32
   OPCODE_NEXT( XOR, 0x81,0x00,0x00,0x00, 0x01, MEM32, IMM32, NON,   R6)
   OPCODE_NEXT( XOR, 0x66,0x83,0x00,0x00, 0x02, REG16, IMM8,  NON,   R6)     //83 /6 ib XOR r/m16,imm8 r/m16 XOR imm8 (sign-extended)
   OPCODE_NEXT( XOR, 0x66,0x83,0x00,0x00, 0x02, MEM16, IMM8,  NON,   R6)
   OPCODE_NEXT( XOR, 0x83,0x00,0x00,0x00, 0x01, REG32, IMM8,  NON,   R6)     //83 /6 ib XOR r/m32,imm8 r/m32 XOR imm8 (sign-extended)
   OPCODE_NEXT( XOR, 0x83,0x00,0x00,0x00, 0x01, MEM32, IMM8,  NON,   R6)
   OPCODE_NEXT( XOR, 0x30,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   RM_R)   //30 / r XOR r/m8,r8 r/m8 XOR r8
   OPCODE_NEXT( XOR, 0x30,0x00,0x00,0x00, 0x01, MEM8,  REG8,  NON,   RM_R)
   OPCODE_NEXT( XOR, 0x66,0x31,0x00,0x00, 0x02, REG16, REG16, NON,   RM_R)   //31 / r XOR r/m16,r16 r/m16 XOR r16
   OPCODE_NEXT( XOR, 0x66,0x31,0x00,0x00, 0x02, MEM16, REG16, NON,   RM_R)
   OPCODE_NEXT( XOR, 0x31,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   RM_R)   //31 / r XOR r/m32,r32 r/m32 XOR r32
   OPCODE_NEXT( XOR, 0x31,0x00,0x00,0x00, 0x01, MEM32, REG32, NON,   RM_R)
   OPCODE_NEXT( XOR, 0x32,0x00,0x00,0x00, 0x01, REG8,  REG8,  NON,   R_RM)   //32 / r XOR r8,r/m8 r8 XOR r/m8
   OPCODE_NEXT( XOR, 0x32,0x00,0x00,0x00, 0x01, REG8,  MEM8,  NON,   R_RM)
   OPCODE_NEXT( XOR, 0x66,0x33,0x00,0x00, 0x02, REG16, REG16, NON,   R_RM)   //33 / r XOR r16,r/m16 r8 XOR r/m8
   OPCODE_NEXT( XOR, 0x66,0x33,0x00,0x00, 0x02, REG16, MEM16, NON,   R_RM) 
   OPCODE_NEXT( XOR, 0x33,0x00,0x00,0x00, 0x01, REG32, REG32, NON,   R_RM)   //33 / r XOR r32,r/m32 r8 XOR r/m8
   OPCODE_NEXT( XOR, 0x33,0x00,0x00,0x00, 0x01, REG32, MEM32, NON,   R_RM)

```

`common/SCommand.cpp`:

```cpp
#include "SCommand.h"

#include "log/CLog.h"

#include <sstream>

namespace NPeProtector {
namespace {
std::string toString(const std::vector<NRegister::EType>& registers) {
  std::ostringstream result;
  for (unsigned int i = 0; i < registers.size(); ++i) {
    result << NRegister::gStrings[registers[i]] << " ";
  }
  return result.str();
}

std::string toString(const SConstant& constant) {
  std::ostringstream result;
  result << "labels {";
  for (unsigned int i = 0; i < constant.mLabels.size(); ++i) {
    result << NSign::gStrings[constant.mLabels[i].mSign] << " ";
    result << constant.mLabels[i].mIndex << " ";
  }
  result << "} value " << constant.mValue;

  return result.str();
}

std::string toString(const SMemory& memory) {
  std::ostringstream result;
  result << "reg {" << toString(memory.mRegisters) << "} ";
  result << "scale " << memory.mScale << " ";
  result << "seg " << NSegment::gStrings[memory.mSegment] << " ";
  result << "constant {" << toString(memory.mConstant) << "}";
  return result.str();
}

std::string toString(const std::vector<SOperand>& operands) {
  std::ostringstream result;
  for (unsigned int i = 0; i < operands.size(); ++i) {
    result << "type " << NOperand::gStrings[operands[i].mType];
    switch (operands[i].mType) {
      case NOperand::REG8:
      case NOperand::REG16:
      case NOperand::REG32:
        result << " reg " << NRegister::gStrings[operands[i].mRegister];
        break;
      case NOperand::MEM8:
      case NOperand::MEM16:
      case NOperand::MEM32:
        result << " mem {" << toString(operands[i].mMemory) << "}";
        break;
      case NOperand::CONSTANT:
        result << " constant {" << toString(operands[i].mConstant) << "}";
        break;
    }
    result << (i == operands.size() - 1 ? "" : ", ");
  }
  return result.str();
}

std::string toString(const SData& data) {
  std::ostringstream result;
  result << "name " << data.mName << " ";
  result << "sizeData " << data.mSizeData << " ";
  result << "constants {";
  for (unsigned int i = 0; i < data.mConstants.size(); ++i) {
    result << toString(data.mConstants[i]) << " ";  // ??
  }
  result << "} ";
  result << "count " << data.mCount;

  return result.str();
}

std::string toString(const SImport& import) {
  std::ostringstream result;
  result << "dllName " << import.mDllName << " ";
  result << "function " << import.mFunctionName;
  return result.str();
}

std::string toString(const SSection& section) {
  std::ostringstream result;
  result << "name " << section.mName << " ";
  result << "attributes " << section.mAttributes;  // TODO
  return result.str();
}

std::string toString(const SInstruction& instruction) {
  std::ostringstream result;
  result << "prefix " << NPrefix::gStrings[instruction.mPrefix] << " ";
  result << "type " << NInstruction::gStrings[instruction.mType] << " ";
  result << "operands {" << toString(instruction.mOperands) << "} ";
  result << "trash " << instruction.mTrash;
  return result.str();
}
}  // namespace

void deserialize(std::istream& input, char& value) {
  input.read(&value, sizeof(value));
}

void serialize(std::ostream& output, const char value) {
  output.write(&value, sizeof(value));
}

void deserialize(std::istream& input, NRegister::EType& value) {
  input.read((char*)(&value), sizeof(value));
}

void deserialize(std::istream& input, int& value) {
  input.read((char*)(&value), sizeof(value));
}

void serialize(std::ostream& output, const int value) {
  output.write((char*)(&value), sizeof(value));
}

void serialize(std::ostream& output, const std::size_t value) {
  output.write((char*)(&value), sizeof(value));
}

void deserialize(std::istream& input, std::size_t& value) {
  input.read((char*)(&value), sizeof(value));
}

void deserialize(std::istream& input, std::string& values) {
  int size;
  deserialize(input, size);
  for (int i = 0; i < size; ++i) {
    char value;
    deserialize(input, value);
    values += value;
  }
}

void serialize(std::ostream& output, const std::string& values) {
  serialize(output, static_cast<int>(values.size()));

  for (unsigned int i = 0; i < values.size(); ++i) {
    serialize(output, values[i]);
  }
}

void deserialize(std::istream& input, SLabel& label) {
  deserialize(input, reinterpret_cast<int&>(label.mSign));
  deserialize(input, label.mIndex);
}

void serialize(std::ostream& output, const SLabel& label) {
  serialize(output, label.mSign);
  serialize(output, label.mIndex);
}

void deserialize(std::istream& input, SConstant& constant) {
  deserialize(input, constant.mLabels);
  deserialize(input, reinterpret_cast<int&>(constant.mValue));
}

void serialize(std::ostream& output, const SConstant& constant) {
  serialize(output, constant.mLabels);
  serialize(output, static_cast<int>(constant.mValue));
}

void deserialize(std::istream& input, SMemory& operandMemory) {
  deserialize(input, operandMemory.mRegisters);
  deserialize(input, operandMemory.mScale);
  deserialize(input, reinterpret_cast<int&>(operandMemory.mSegment));
  deserialize(input, operandMemory.mConstant);
}
void serialize(std::ostream& output, const SMemory& operandMemory) {
  serialize(output, operandMemory.mRegisters);
  serialize(output, operandMemory.mScale);
  serialize(output, operandMemory.mSegment);
  serialize(output, operandMemory.mConstant);
}
void deserialize(std::istream& input, SOperand& operand) {
  deserialize(input, reinterpret_cast<int&>(operand.mType));
  deserialize(input, operand.mMemory);
  deserialize(input, reinterpret_cast<int&>(operand.mRegister));
  deserialize(input, operand.mConstant);
}
void serialize(std::ostream& output, const SOperand& operand) {
  serialize(output, operand.mType);
  serialize(output, operand.mMemory);
  serialize(output, operand.mRegister);
  serialize(output, operand.mConstant);
}

void deserialize(std::istream& input, SInstruction& instruction) {
  deserialize(input, reinterpret_cast<int&>(instruction.mPrefix));
  deserialize(input, reinterpret_cast<int&>(instruction.mType));
  deserialize(input, instruction.mOperands);
  deserialize(input, instruction.mTrash);
}

void serialize(std::ostream& output, const SInstruction& instruction) {
  serialize(output, instruction.mPrefix);
  serialize(output, instruction.mType);
  serialize(output, instruction.mOperands);
  serialize(output, instruction.mTrash);
}

void deserialize(std::istream& input, SSection& section) {
  deserialize(input, section.mName);
  deserialize(input, section.mAttributes);
}

void serialize(std::ostream& output, const SSection& section) {
  serialize(output, section.mName);
  serialize(output, section.mAttributes);
}

void deserialize(std::istream& input, SImport& import) {
  deserialize(input, import.mDllName);
  deserialize(input, import.mFunctionName);
}

void serialize(std::ostream& output, const SImport& import) {
  serialize(output, import.mDllName);
  serialize(output, import.mFunctionName);
}

void deserialize(std::istream& input, SDirective& directive) {
  deserialize(input, directive.mName);
  deserialize(input, directive.mDirectorySize);
}

void serialize(std::ostream& output, const SDirective& directive) {
  serialize(output, directive.mName);
  serialize(output, directive.mDirectorySize);
}

void deserialize(std::istream& input, SData& data) {
  deserialize(input, data.mName);
  deserialize(input, data.mSizeData);
  deserialize(input, data.mConstants);
  deserialize(input, data.mCount);
}

void serialize(std::ostream& output, const SData& data) {
  serialize(output, data.mName);
  serialize(output, data.mSizeData);
  serialize(output, data.mConstants);
  serialize(output, data.mCount);
}

void deserialize(std::istream& input, SCommand& command) {
  deserialize(input, reinterpret_cast<int&>(command.mType));
  deserialize(input, reinterpret_cast<int&>(command.mRVA));
  deserialize(input, reinterpret_cast<int&>(command.mRAW));
  deserialize(input, command.mNameLabel);
  deserialize(input, command.mNumberLine);
  deserialize(input, command.mInstruction);
  deserialize(input, command.mData);
  deserialize(input, command.mDirective);
  deserialize(input, command.mImport);
  deserialize(input, command.mSection);
}

void serialize(std::ostream& output, const SCommand& command) {
  serialize(output, command.mType);
  serialize(output, static_cast<int>(command.mRVA));
  serialize(output, static_cast<int>(command.mRAW));
  serialize(output, command.mNameLabel);
  serialize(output, command.mNumberLine);
  serialize(output, command.mInstruction);
  serialize(output, command.mData);
  serialize(output, command.mDirective);
  serialize(output, command.mImport);
  serialize(output, command.mSection);
}

void loggingCommands(const std::vector<SCommand>& commands) {
  for (unsigned int i = 0; i < commands.size(); ++i) {
    switch (commands[i].mType) {
      case NCommand::INSTRUCTION:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d "
            "instruction {%s}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine,
            toString(commands[i].mInstruction).c_str());
        break;
      case NCommand::DATA:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d data "
            "{%s}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine, toString(commands[i].mData).c_str());
        break;
      case NCommand::DIRECTIVE:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d "
            "directive {%s %d}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine, commands[i].mDirective.mName.c_str(),
            commands[i].mDirective.mDirectorySize);
        break;
      case NCommand::IMPORT:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d "
            "import {%s}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine, toString(commands[i].mImport).c_str());
        break;
      case NCommand::EXTERN:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d data "
            "{%s}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine, toString(commands[i].mData).c_str());
        break;
      case NCommand::SECTION:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d "
            "section {%s}",
            i, NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine, toString(commands[i].mSection).c_str());
        break;
      case NCommand::END:
        LOG_DEBUG(
            "command[%d] type %s rva %p raw %p nameLabel %s numberLine %d", i,
            NCommand::gStrings[commands[i].mType], commands[i].mRVA,
            commands[i].mRAW, commands[i].mNameLabel.c_str(),
            commands[i].mNumberLine);
        break;
    }
  }
}
}  // namespace NPeProtector
```

`common/SCommand.h`:

```h
#pragma once

#include "Types.h"

#include <istream>
#include <vector>

namespace NPeProtector {
/**
 * @brief Contains reference to command in list<SCommand>
 */
struct SLabel {
  /**
   * @brief Label sign
   */
  NSign::EType mSign{};
  /**
   * @brief Index in list<SCommand>
   */
  std::size_t mIndex{};
};

/**
 * @brief Contains list of labels and constant value.
 * It's used in memory operand, ex: DWORD PTR [label1 - label2 + 666]
 */
struct SConstant {
  /**
   * @brief List of labels
   */
  std::vector<SLabel> mLabels{};
  /**
   * @brief Value of constant
   */
  uint32_t mValue{};
};

/**
 * @brief Describes memory operand in assembler instruction
 */
struct SMemory {
  std::vector<NRegister::EType> mRegisters{};

  int mScale{};  // 1->>2; 2->>4; 3-->>>8; scale! //TODO int

  NSegment::EType mSegment{NSegment::NON};

  SConstant mConstant{};
};

/**
 * @brief Describes operand in assembler instruction
 */
struct SOperand {
  /**
   * @brief Type of operand (register, memory or constant).
   */
  NOperand::EType mType{NOperand::NON};
  /**
   * @brief It's used when type = memory
   */
  SMemory mMemory{};
  /**
   * @brief It's used when type = register
   */
  NRegister::EType mRegister{};
  /**
   * @brief It's used when type = constant
   */
  SConstant mConstant{};
};

/**
 * @brief Describes assembler instruction
 */
struct SInstruction {
  NPrefix::EType mPrefix{NPrefix::NON};
  /**
   * @brief Type of instruction
   */
  NInstruction::EType mType{};
  /**
   * @brief Operands of instruction
   */
  std::vector<SOperand> mOperands{};
  /**
   * @brief Currently it's not used
   */
  int mTrash{};
};

/**
 * @brief Describes data in source code
 */
struct SData {
  /**
   * @brief Name of data, ex: API_ExAllocatePool dd 12345678h
   */
  std::string mName{};
  /**
   * @brief Size of single item of data. Ex: API_ExAllocatePool dd 12345678h =>
   * mSizeData = 4 bytes The total size = mSizeData * mCount
   */
  int mSizeData{};
  /**
   * @brief if data is dup vector.size == 1 and count > 1. If data.size ==
   * count then it's array.
   */
  std::vector<SConstant> mConstants{};
  /**
   * @brief Count of data
   */
  int mCount{};
};

/**
 * @brief Describes import function
 */
struct SImport {
  /**
   * @brief Dll name
   */
  std::string mDllName{};
  /**
   * @brief Function name
   */
  std::string mFunctionName{};
};

/**
 * @brief Describes pe section
 */
struct SSection {
  /**
   * @brief Name of section
   */
  std::string mName{};
  /**
   * @brief Attributes of section, see NSectionAttributes.
   */
  int mAttributes{};
};

/**
 * @brief Describes directive. It can be IMPORT_DIRECTORY, RECOURCE_DIRECTORY or
 * COMPRESSED_FILE.
 */
struct SDirective {
  /**
   * @brief Name of directive.
   * It can be IMPORT_DIRECTORY, RECOURCE_DIRECTORY or COMPRESSED_FILE.
   */
  std::string mName{};
  /**
   * @brief Size of directive
   */
  int mDirectorySize{};
};

/**
 * @brief It's the key struct.
 * It can contain: INSTRUCTION, DATA, DIRECTIVE, IMPORT, EXTERN, SECTION or END.
 */
struct SCommand {
  /**
   * @brief Type of command
   */
  NCommand::EType mType{NCommand::END};
  /**
   * @brief RVA(offset in memory)
   */
  uint32_t mRVA{};
  /**
   * @brief RAW (offset in file)
   */
  uint32_t mRAW{};
  /**
   * @brief Label of command
   */
  std::string mNameLabel{};
  /**
   * @brief Line number in source code. It's used for only for debug purpose.
   */
  int mNumberLine{};
  /**
   * @brief Instruction, if type == INSTRUCTION
   */
  SInstruction mInstruction{};
  /**
   * @brief Data, if type == DATA
   */
  SData mData{};
  /**
   * @brief Directive, if type == DIRECTIVE
   */
  SDirective mDirective{};
  /**
   * @brief Import, if type == IMPORT
   */
  SImport mImport{};
  /**
   * @brief Section, if type == SECTION
   */
  SSection mSection{};
};

/**
 * @brief Dump all command in trace file
 */
void loggingCommands(const std::vector<NPeProtector::SCommand>& commands);

void deserialize(std::istream& input, char& value);
void deserialize(std::istream& input, NRegister::EType& value);
void deserialize(std::istream& input, int& value);
void deserialize(std::istream& input, std::string& values);
void deserialize(std::istream& input, SLabel& label);
void deserialize(std::istream& input, SConstant& constant);
void deserialize(std::istream& input, SMemory& operandMemory);
void deserialize(std::istream& input, SOperand& operand);
void deserialize(std::istream& input, SInstruction& instruction);
void deserialize(std::istream& input, SSection& section);
void deserialize(std::istream& input, SImport& import);
void deserialize(std::istream& input, SData& data);
void deserialize(std::istream& input, SData& data);
void deserialize(std::istream& input, SCommand& command);

void serialize(std::ostream& output, const char value);
void serialize(std::ostream& output, const int value);
void serialize(std::ostream& output, const std::string& values);
void serialize(std::ostream& output, const SLabel& label);
void serialize(std::ostream& output, const SConstant& constant);
void serialize(std::ostream& output, const SMemory& operandMemory);
void serialize(std::ostream& output, const SOperand& operand);
void serialize(std::ostream& output, const SInstruction& instruction);
void serialize(std::ostream& output, const SSection& section);
void serialize(std::ostream& output, const SImport& import);
void serialize(std::ostream& output, const SData& data);
void serialize(std::ostream& output, const SCommand& command);

template <typename T>
void deserialize(std::istream& input, std::vector<T>& values) {
  int size;
  deserialize(input, size);

  for (int i = 0; i < size; ++i) {
    T value;
    deserialize(input, value);
    values.push_back(value);
  }
}

template <typename T>
void serialize(std::ostream& output, const std::vector<T>& values) {
  serialize(output, static_cast<int>(values.size()));

  for (unsigned int i = 0; i < values.size(); ++i) {
    serialize(output, values[i]);
  }
}
}  // namespace NPeProtector
```

`common/Types.cpp`:

```cpp
#include "Types.h"

#define ARRAY_SIZE(array) (sizeof((array)) / sizeof((array[0])))

namespace NPeProtector {
namespace NDataType {
const char* const gStrings[] = {
    "DD", "DWORD", "DW", "WORD", "DB", "BYTE",
};
const int gSize = ARRAY_SIZE(NDataType::gStrings);
}  // namespace NDataType

namespace NCommand {
const char* const gStrings[] = {"INSTRUCTION", "DATA",    "DIRECTIVE", "IMPORT",
                                "EXTERN",      "SECTION", "END"};
const int gSize = ARRAY_SIZE(NCommand::gStrings);
}  // namespace NCommand
namespace NSign {
const char* const gStrings[] = {"PLUS", "MINUS"};
const int gSize = ARRAY_SIZE(NSign::gStrings);
}  // namespace NSign

namespace NOperand {
const char* const gStrings[] = {
    "NON", "REG8", "REG16", "REG32", "MEM8", "MEM16", "MEM32", "CONSTANT",
};
const int gSize = ARRAY_SIZE(NOperand::gStrings);
}  // namespace NOperand

namespace NPrefix {
const char* const gStrings[] = {"REPZ", "REPNZ", "NON"};
const int gSize = ARRAY_SIZE(NPrefix::gStrings);
}  // namespace NPrefix
namespace NRegister {
// strigns for type NRegister::EType
const char* const gStrings[] = {
    "EAX", "EBX", "ECX", "EDX", "ESP", "EBP", "ESI", "EDI",
    "AX",  "BX",  "CX",  "DX",  "SP",  "BP",  "SI",  "DI",
    "AL",  "BL",  "CL",  "DL",  "AH",  "BH",  "CH",  "DH",
};
const int gSize = ARRAY_SIZE(NRegister::gStrings);
}  // namespace NRegister

namespace NSegment {
const char* const gStrings[] = {
    "CS", "DS", "ES", "FS", "GS", "SS", "NON",
};
const int gSize = ARRAY_SIZE(NSegment::gStrings);
}  // namespace NSegment

namespace NInstruction {
// create instructions string
const char* const gStrings[] = {
#define OPCODE_FIRST(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                     operand1, operand2, operand3, flag)                   \
#name,
#define OPCODE_NEXT(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                    operand1, operand2, operand3, flag)

#include "Opcodes.def"

#undef OPCODE_NEXT
#undef OPCODE_FIRST
};
const int gSize = ARRAY_SIZE(NInstruction::gStrings);
}  // namespace NInstruction
}  // namespace NPeProtector
```

`common/Types.h`:

```h
#pragma once

namespace NPeProtector {
/**
 * @brief Describes type of data in source code, ex: myData DWORD 999
 */
namespace NDataType {
enum EType {
  DD,
  DWORD,
  DW,
  WORD,
  DB,
  BYTE,
};
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NDataType

/**
 * @brief Describes type of SCommand
 */
namespace NCommand {
enum EType { INSTRUCTION, DATA, DIRECTIVE, IMPORT, EXTERN, SECTION, END };
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NCommand

/**
 * @brief Describes section attributes
 */
namespace NSectionAttributes {
static const int READ = 1;
static const int WRITE = 2;
static const int EXECUTE = 4;
static const int CODE = 8;
static const int INITIALIZED = 16;
}  // namespace NSectionAttributes

/**
 * @brief Describes sign of label
 */
namespace NSign {
enum EType { PLUS, MINUS };
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NSign

/**
 * @brief Describes type of operand in assebmler instruction
 */
namespace NOperand {
enum EType {
  NON,
  REG8,
  REG16,
  REG32,
  MEM8,
  MEM16,
  MEM32,
  CONSTANT,
};
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NOperand

/**
 * @brief Describes prefix of assembler instruction
 */
namespace NPrefix {
enum EType { REPZ, REPNZ, NON };
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NPrefix

/**
 * @brief Describes register
 */
namespace NRegister {
enum EType {
  EAX,
  EBX,
  ECX,
  EDX,
  ESP,
  EBP,
  ESI,
  EDI,
  AX,
  BX,
  CX,
  DX,
  SP,
  BP,
  SI,
  DI,
  AL,
  BL,
  CL,
  DL,
  AH,
  BH,
  CH,
  DH,
};
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NRegister

/**
 * @brief Describes segment register
 */
namespace NSegment {
enum EType {
  CS,
  DS,
  ES,
  FS,
  GS,
  SS,
  NON,
};
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NSegment

/**
 * @brief Describes type of instruction
 */
namespace NInstruction {
enum EType {
#define OPCODE_FIRST(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                     operand1, operand2, operand3, flag)                   \
  name,
#define OPCODE_NEXT(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                    operand1, operand2, operand3, flag)

#include "Opcodes.def"

#undef OPCODE_NEXT
#undef OPCODE_FIRST
};
extern const int gSize;
extern const char* const gStrings[];
}  // namespace NInstruction
}  // namespace NPeProtector
```

`compiler/CMakeLists.txt`:

```txt

find_package(range-v3 CONFIG REQUIRED)
find_package(Boost REQUIRED)

add_library(
  libcompiler
  Parser.h
  Parser.cpp)

target_link_libraries(
  libcompiler
 PUBLIC
  libcommon
 PRIVATE
  liblog
  range-v3 
  range-v3-meta 
  range-v3::meta 
  range-v3-concepts
  Boost::boost)

target_include_directories(
  libcompiler
 PUBLIC
  "${CMAKE_SOURCE_DIR}")

add_executable(
  compiler
  main.cpp)

target_link_libraries(
  compiler
 PRIVATE
  libcompiler
  liblog)

```

`compiler/Parser.cpp`:

```cpp
#include "Parser.h"

#include "common/SCommand.h"
#include "common/Types.h"

#include <boost/fusion/include/adapted.hpp>
#include "boost/tuple/tuple.hpp"
#include "boost/variant.hpp"

#include <assert.h>
#include <ctype.h>
#include <array>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>

#include <boost/spirit/home/x3.hpp>
#include <boost/spirit/include/support_istream_iterator.hpp>

#include <range/v3/all.hpp>

#define ARRAY_SIZE(array) (sizeof((array)) / sizeof((array[0])))

namespace NPeProtector {
namespace {

// TODO move to parser
int getAttributes(const std::string& attributes) {
  int result = 0;
  for (unsigned int i = 0; i < attributes.size(); ++i) {
    switch (attributes[i]) {
      case 'r':
      case 'R':
        result |= NSectionAttributes::READ;
        break;
      case 'w':
      case 'W':
        result |= NSectionAttributes::WRITE;
        break;
      case 'e':
      case 'E':
        result |= NSectionAttributes::EXECUTE;
        break;
      case 'c':
      case 'C':
        result |= NSectionAttributes::CODE;
        break;
      case 'i':
      case 'I':
        result |= NSectionAttributes::INITIALIZED;
        break;
    }
  }
  return result;
}

NOperand::EType operandType(const NRegister::EType reg) {
  switch (reg) {
    case NRegister::EAX:
    case NRegister::EBX:
    case NRegister::ECX:
    case NRegister::EDX:
    case NRegister::EBP:
    case NRegister::ESP:
    case NRegister::EDI:
    case NRegister::ESI:
      return NOperand::REG32;
    case NRegister::AX:
    case NRegister::BX:
    case NRegister::CX:
    case NRegister::DX:
    case NRegister::BP:
    case NRegister::SP:
    case NRegister::DI:
    case NRegister::SI:
      return NOperand::REG16;
    case NRegister::AL:
    case NRegister::BL:
    case NRegister::CL:
    case NRegister::DL:
    case NRegister::AH:
    case NRegister::BH:
    case NRegister::CH:
    case NRegister::DH:
      return NOperand::REG8;
  }
  throw std::exception();
}
}  // namespace
std::vector<SCommand> parse(std::istream& input) {
  using namespace boost::spirit;

  std::vector<SCommand> result;
  std::unordered_map<std::string, std::size_t> label2Index;
  std::vector<std::string> nameList;

  input >> std::noskipws;
  auto begin = boost::spirit::istream_iterator{input};
  auto end = boost::spirit::istream_iterator{};

  x3::symbols<x3::unused_type> _keywords;
  _keywords.add("DD", x3::unused);
  _keywords.add("DWORD", x3::unused);
  _keywords.add("DW", x3::unused);
  _keywords.add("WORD", x3::unused);
  _keywords.add("DB", x3::unused);
  _keywords.add("BYTE", x3::unused);
  _keywords.add("EXTERN", x3::unused);
  _keywords.add("SECTION", x3::unused);
  _keywords.add("PTR", x3::unused);
  _keywords.add("DUP", x3::unused);
  _keywords.add("IMPORT", x3::unused);
  _keywords.add("DIRECTIVE", x3::unused);

  x3::symbols<uint32_t> dataSizeSymbols;
  // "DD", "DWORD", "DW", "WORD", "DB", "BYTE",
  dataSizeSymbols.add("dd", 4);
  dataSizeSymbols.add("dword", 4);
  dataSizeSymbols.add("dw", 2);
  dataSizeSymbols.add("word", 2);
  dataSizeSymbols.add("db", 1);
  dataSizeSymbols.add("byte", 1);

  x3::symbols<NOperand::EType> memTypeSymbols;
  memTypeSymbols.add("dd", NOperand::MEM32);
  memTypeSymbols.add("dword", NOperand::MEM32);
  memTypeSymbols.add("dw", NOperand::MEM16);
  memTypeSymbols.add("word", NOperand::MEM16);
  memTypeSymbols.add("db", NOperand::MEM8);
  memTypeSymbols.add("byte", NOperand::MEM8);

  x3::symbols<NInstruction::EType> instSymbols;
  // TODO: loop detection
  for (uint32_t i = 0; i < NInstruction::gSize; ++i) {
    instSymbols.add(NInstruction::gStrings[i], NInstruction::EType(i));
    _keywords.add(NInstruction::gStrings[i], x3::unused);
  }

  x3::symbols<NRegister::EType> registerSymbols;
  // TODO: loop detection
  for (uint32_t i = 0; i < NRegister::gSize; ++i) {
    registerSymbols.add(NRegister::gStrings[i], NRegister::EType(i));
    _keywords.add(NRegister::gStrings[i], x3::unused);
  }

  x3::symbols<NPrefix::EType> prefixSymbols;
  for (uint32_t i = 0; i < NPrefix::gSize; ++i) {
    prefixSymbols.add(NPrefix::gStrings[i], NPrefix::EType(i));
    _keywords.add(NPrefix::gStrings[i], x3::unused);
  }

  x3::symbols<NSegment::EType> segmentSymbols;
  for (uint32_t i = 0; i < NSegment::gSize; ++i) {
    segmentSymbols.add(NSegment::gStrings[i], NSegment::EType(i));
    _keywords.add(NSegment::gStrings[i], x3::unused);
  }

  x3::symbols<NSign::EType> signSymbols;
  signSymbols.add("-", NSign::MINUS)("+", NSign::PLUS);

  auto const keywords =
      x3::lexeme[x3::no_case[_keywords] >> !(x3::alnum | '_')];

  auto blank = x3::omit[+x3::blank];

  auto anyChar = x3::rule<class anyChar, char>() = x3::char_ - x3::eol;

  auto quotedString = x3::rule<class quotedString, std::string>() =
      x3::lexeme['"' >> *(x3::char_ - '"') >> '"'];

  auto comment = x3::rule<class comment>() = x3::lit(';') >> x3::omit[*anyChar];

  auto name = x3::rule<class name, std::string>() =
      x3::lexeme[(x3::alpha | x3::char_('_')) >>
                 *(x3::alnum | x3::char_('.') | x3::char_('_'))] -
      keywords;

  auto directive = x3::rule<class directive, std::string>() =
      x3::lexeme[x3::lit("DIRECTIVE") >> blank >> name];

  // TODO think about top level functions
  auto directiveFn = [&result](const auto& ctx) {
    SCommand d;
    d.mType = NCommand::DIRECTIVE;
    d.mDirective.mName = x3::_attr(ctx);
    result.push_back(d);
  };

  auto import = x3::rule<class import, std::string>() =
      x3::lexeme[x3::no_case[x3::lit("IMPORT")] >> blank >> name];

  auto importFn = [&result, &label2Index](const auto& ctx) {
    // TODO rewrite this code
    const std::string functionName = x3::_attr(ctx);
    SCommand i;
    i.mType = NCommand::IMPORT;
    i.mNameLabel = functionName;
    size_t dot = i.mNameLabel.find('.');
    if (dot != std::string::npos) {
      i.mImport.mDllName = functionName.substr(0, dot) + ".dll";
      i.mImport.mFunctionName = functionName.substr(dot + 1);
    } else {
      throw std::runtime_error{"Wrong import name"};
    }
    label2Index[functionName] = result.size();
    result.push_back(i);
  };

  auto extern_ = x3::rule<class extern_, std::pair<uint32_t, std::string>>() =
      x3::lexeme[x3::no_case[x3::lit("EXTERN")] >> blank >>
                 x3::no_case[dataSizeSymbols] >> blank >> name];

  auto externFn = [&result, &label2Index](auto& ctx) {
    SCommand e;
    e.mType = NCommand::EXTERN;
    e.mNameLabel = x3::_attr(ctx).second;
    e.mData.mSizeData = x3::_attr(ctx).first;
    label2Index[e.mNameLabel] = result.size();
    result.push_back(e);
  };

  auto section = x3::rule<
      class sectoin,
      std::pair<std::string /*name*/, std::string /*type TODO: parse it*/>>() =
      x3::lexeme[x3::no_case[x3::lit("SECTION")] >> blank >> quotedString >>
                 blank >> name /*type*/];

  auto sectionFn = [&result](auto const& ctx) {
    SCommand s;
    s.mType = NCommand::SECTION;
    s.mSection.mName = x3::_attr(ctx).first;
    s.mSection.mAttributes = getAttributes(x3::_attr(ctx).second);
    result.push_back(s);
  };

  auto label = x3::rule<class label, std::string>() = name >> x3::lit(':');
  auto labelFn = [&result, &label2Index](auto const& ctx) {
    label2Index[x3::_attr(ctx)] = result.size();
  };

  NSign::EType signVar{};
  auto signVarSet = [&signVar](auto const& ctx) { signVar = x3::_attr(ctx); };
  auto signVarReset = [&signVar](auto const& ctx) { signVar = NSign::PLUS; };

  auto number = x3::rule<class number, int32_t>() =
      x3::lexeme[(x3::hex >> (x3::lit('h') | x3::lit('H')))] | x3::uint_;

  auto constantVarNameSet = [&signVar, &nameList](auto& ctx) {
    x3::_val(ctx).mLabels.push_back({signVar, nameList.size()});
    nameList.push_back(x3::_attr(ctx));
  };
  auto constantVarNumSet = [&signVar](auto& ctx) {
    x3::_val(ctx).mValue +=
        signVar == NSign::PLUS ? x3::_attr(ctx) : -x3::_attr(ctx);
  };

  auto constant = x3::rule<class constant, SConstant>() =
      x3::eps[signVarReset] >>
      ((name[constantVarNameSet] | number[constantVarNumSet]) %
       signSymbols[signVarSet]);

  auto constantAppend = x3::rule<class constantAppend, SConstant>() =
      x3::eps[signVarReset] >> signSymbols[signVarSet] >>
      ((name[constantVarNameSet] | number[constantVarNumSet]) %
       signSymbols[signVarSet]);

  auto constantStr = x3::rule<class constantStr, std::string>() =
      x3::lexeme['"' >> +(x3::char_ - '"') >> '"'];

  auto dataStr =
      x3::rule<class dataStr, std::pair<std::string, std::string>>() =
          x3::lexeme[name >> blank >>
                     x3::no_case[x3::lit("DB") | x3::lit("BYTE")] >> blank] >>
          constantStr;

  auto dataStrFn = [&result, &label2Index](auto const& ctx) {
    SCommand d;
    d.mType = NCommand::DATA;
    d.mData.mName = x3::_attr(ctx).first;
    d.mData.mSizeData = 1;  // byte size
    const std::string& str = x3::_attr(ctx).second;
    std::transform(str.cbegin(), str.cend(),
                   std::back_inserter(d.mData.mConstants), [](char c) {
                     return SConstant{{}, uint32_t(c)};
                   });
    d.mData.mCount = 1;
    label2Index[x3::_attr(ctx).first] = result.size();
    result.push_back(d);
  };

  auto constantVarListPush = [](auto& ctx) {
    x3::_val(ctx).push_back(x3::_attr(ctx));
  };
  auto constantList = x3::rule<class constantList, std::vector<SConstant>>() =
      constant[constantVarListPush] % x3::lit(',');
  auto data =
      x3::rule<class data,
               boost::tuple<std::string, uint32_t, std::vector<SConstant>>>() =
          name >> x3::no_case[dataSizeSymbols] >> constantList;

  auto dataFn = [&result, &label2Index](auto& ctx) {
    SCommand d;
    d.mType = NCommand::DATA;
    d.mData.mName = boost::get<0>(x3::_attr(ctx));
    d.mData.mSizeData = boost::get<1>(x3::_attr(ctx));
    d.mData.mConstants = boost::get<2>(x3::_attr(ctx));
    d.mData.mCount = 1;
    label2Index[boost::get<0>(x3::_attr(ctx))] = result.size();
    result.push_back(d);
  };

  auto dataDup =
      x3::rule<class dataDup,
               boost::tuple<std::string, uint32_t, int32_t, int32_t>>() =
          x3::lexeme[name >> blank >> x3::no_case[dataSizeSymbols] >> blank >>
                     number >> blank >> x3::no_case[x3::lit("DUP")]] >>
          x3::lit('(') >> number >> x3::lit(')');

  auto dataDupFn = [&result, &label2Index](auto& ctx) {
    SCommand d;
    d.mType = NCommand::DATA;
    d.mData.mName = boost::get<0>(x3::_attr(ctx));
    d.mData.mSizeData = boost::get<1>(x3::_attr(ctx));
    d.mData.mConstants.push_back(
        // TODO remove static_cast
        SConstant{{}, static_cast<uint32_t>(boost::get<3>(x3::_attr(ctx)))});
    d.mData.mCount = boost::get<2>(x3::_attr(ctx));
    label2Index[boost::get<0>(x3::_attr(ctx))] = result.size();
    result.push_back(d);
  };

  auto operandVarMemTypeSet = [](auto& ctx) {
    x3::_val(ctx).mType = x3::_attr(ctx);
  };
  auto operandVarMemSegmentSet = [](auto& ctx) {
    x3::_val(ctx).mMemory.mSegment = x3::_attr(ctx);
  };
  auto operandVarMemRegisterSet = [](auto& ctx) {
    x3::_val(ctx).mMemory.mRegisters.push_back(x3::_attr(ctx));
  };
  auto operandVarMemScaleSet = [](auto& ctx) {
    x3::_val(ctx).mMemory.mScale = x3::_attr(ctx) - '0';
  };
  auto operandVarMemConstantSet = [](auto& ctx) {
    x3::_val(ctx).mMemory.mConstant = x3::_attr(ctx);
  };

  auto memory =
      x3::lexeme[x3::no_case[memTypeSymbols] >> blank >> x3::no_case["PTR"]]
                [operandVarMemTypeSet] >>
      -x3::no_skip[blank >> segmentSymbols >> -blank >> x3::lit(':')]
                  [operandVarMemSegmentSet] >>
      x3::lit('[') >>
      ((registerSymbols[operandVarMemRegisterSet] >>
        -(x3::lit('+') >> registerSymbols)[operandVarMemRegisterSet] >>
        -(x3::lit('*') >> x3::char_("248"))[operandVarMemScaleSet] >>
        -constantAppend[operandVarMemConstantSet]) |
       constant[operandVarMemConstantSet]) >>
      x3::lit(']');

  auto operandVarRegisterSet = [](auto& ctx) {
    x3::_val(ctx).mRegister = x3::_attr(ctx);
    x3::_val(ctx).mType = operandType(x3::_attr(ctx));
  };

  auto operandVarConstantSet = [](auto& ctx) {
    x3::_val(ctx).mConstant = x3::_attr(ctx);
    x3::_val(ctx).mType = NOperand::CONSTANT;
  };

  auto operand = x3::rule<class operand, SOperand>() =
      x3::skip[x3::no_case[registerSymbols][operandVarRegisterSet] | memory |
               constant[operandVarConstantSet]];

  auto instVarPrefixSet = [](auto& ctx) {
    x3::_val(ctx).mPrefix = x3::_attr(ctx);
  };
  auto instVarInstSet = [](auto& ctx) { x3::_val(ctx).mType = x3::_attr(ctx); };
  auto instVarOperandSet = [](auto& ctx) {
    x3::_val(ctx).mOperands.push_back(x3::_attr(ctx));
  };

  auto inst = x3::rule<class inst, SInstruction>() =
      x3::lexeme[-(prefixSymbols >> blank)[instVarPrefixSet] >>
                 (x3::no_case[instSymbols] >>
                  !x3::char_("a-zA-Z0-9"))[instVarInstSet]] >>
      -(operand[instVarOperandSet] % x3::char_(','));

  auto instFn = [&result](const auto& ctx) {
    SCommand i;
    i.mType = NCommand::INSTRUCTION;
    i.mInstruction = x3::_attr(ctx);
    result.push_back(i);
  };

  auto const parseResult = x3::phrase_parse(
      begin, end,
      (-(extern_[externFn] | import[importFn] | directive[directiveFn] |
         section[sectionFn] | (-label[labelFn] >> inst[instFn]) |
         label[labelFn] | dataStr[dataStrFn] | dataDup[dataDupFn] |
         data[dataFn]) >>
       -comment) %
          x3::eol,
      x3::blank);

  if (!parseResult || begin != end) {
    throw std::runtime_error{"Failed to parser asm file"};
  }

  for (auto& r : result) {
    switch (r.mType) {
      case NCommand::DATA:
        for (auto& c : r.mData.mConstants) {
          for (auto& l : c.mLabels) {
            assert(l.mIndex < nameList.size());
            l.mIndex = label2Index.at(nameList[l.mIndex]);
          }
        }
        break;
      case NCommand::INSTRUCTION:
        for (auto& o : r.mInstruction.mOperands) {
          for (auto& l : o.mConstant.mLabels) {
            assert(l.mIndex < nameList.size());
            l.mIndex = label2Index.at(nameList[l.mIndex]);
          }
          for (auto& l : o.mMemory.mConstant.mLabels) {
            assert(l.mIndex < nameList.size());
            l.mIndex = label2Index.at(nameList[l.mIndex]);
          }
        }
        break;
    }
  }

  result.push_back({NCommand::END});

  // TODO debug
  // loggingCommands(result);

  return result;
}

}  // namespace NPeProtector
```

`compiler/Parser.h`:

```h
#pragma once

#include <vector>

#include "common\SCommand.h"

namespace NPeProtector {
std::vector<SCommand> parse(std::istream& input);
}  // namespace NPeProtector
```

`compiler/main.cpp`:

```cpp
#include "Parser.h"

#include "common/SCommand.h"
#include "common/Types.h"
#include "log/CLog.h"

#include <algorithm>
#include <fstream>
#include <functional>
#include <iosfwd>
#include <iostream>
#include <ostream>
#include <sstream>
#include <streambuf>
#include <string>

/**
 * @brief Compile.exe file.asm file.bin
 */
int main(int argc, char* argv[], char* env[]) {
  int exitCode = 0;
  if (argc == 3) {
    LOG_INITIALIZE(std::string(argv[0]) + ".log");
    try {
      std::ifstream file(argv[1]);
      if (file.is_open()) {
        const std::vector<NPeProtector::SCommand>& commands =
            NPeProtector::parse(file);

        std::ofstream binFile(argv[2], std::ios_base::binary);

        NPeProtector::serialize(binFile, commands);
      } else {
        exitCode = 1;
        printf("error: can't open file %s", argv[1]);
      }
    } catch (const std::runtime_error& e) {
      std::cout << e.what();
    }
  } else {
    printf("Compile.exe file.asm file.bin");
  }

  return exitCode;
}

```

`data/pe-protector-stub.asm`:

```asm
; pe-protector
IMPORT KERNEL32.VirtualAlloc
IMPORT KERNEL32.VirtualFree
IMPORT KERNEL32.VirtualProtect
IMPORT KERNEL32.LoadLibraryA
IMPORT KERNEL32.GetProcAddress
IMPORT KERNEL32.IsDebuggerPresent

EXTERN DD externImageBase
EXTERN DD externImageSize
EXTERN DD externOEP

SECTION ".text" crwe
_stubBegin:

;   MOV  EAX,DWORD PTR FS:[18H]
;   MOV  EAX,DWORD PTR [EAX + 30H]
;   MOVZX EAX,BYTE PTR [EAX + 2H]

   ; test seh begin
   PUSH _sehHandler
   PUSH DWORD PTR FS:[0]	      ; address of next ERR struct
   MOV  DWORD PTR FS:[0], ESP 	  ; push ERR address in FS:[0]

   MOV  EAX, 1234H
   MOV  EBX, DWORD PTR [EAX]

   POP DWORD PTR FS:[0]	   ; return previous address from FS:[0]
   ADD ESP, 4H	           ; clear stack
   JMP  _begin

_sehHandler:

; ESP + 4	pointer to EXCEPTION_RECORD
; ESP + 8	pointer to ERR
; ESP + CH	pointer to CONTEXT
; ESP + 10H	Param

   ; first debug check
   MOV EAX, 10 ; fake instruction
   CMP BYTE PTR [_sehHandler], 0CCH
   JZ _stubBegin

   ; second debug check
   CALL DWORD PTR [KERNEL32.IsDebuggerPresent]
   CMP EAX, 1
	JZ _stubBegin

   MOV  EAX, DWORD PTR [ESP + 0CH]
   ; +B0 eax register
   MOV DWORD PTR [EAX + 0B0H], _begin

   MOV  EAX, 0	  ; Returned values:
                  ; eax = 1 execption wasn;t processed, pass to the next exception handler in chain
                  ; eax = 0 reload context and continue execution
   RET

_begin:
   ; 0. save api
   MOV  EAX, DWORD PTR [KERNEL32.LoadLibraryA]
   MOV  DWORD PTR [ddLoadLibraryA], EAX

   MOV  EAX, DWORD PTR [KERNEL32.GetProcAddress]
   MOV  DWORD PTR [ddGetProcAddress], EAX

   MOV  EAX, DWORD PTR [KERNEL32.VirtualFree]
   MOV  DWORD PTR [ddVirtualFree], EAX

   ; 1. allocate memory for stub code
   PUSH 40H                                 ; PAGE_EXECUTE_READWRITE = 0x40
   PUSH 1000H                               ; MEM_COMMIT             = 0x00001000
   PUSH _stubEnd - _stubBegin               ; size of allocated memory
   PUSH 0                                   ; zero if any address
   CALL DWORD PTR [KERNEL32.VirtualAlloc]   ; LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
   ; save allocated memory
   MOV  DWORD PTR [ddStubMemory], EAX

   ; 2. allocate memory for compressed data
   PUSH 40H                                 ; PAGE_EXECUTE_READWRITE = 0x40
   PUSH 1000H                               ; MEM_COMMIT             = 0x00001000
   PUSH _compressedFileEnd - _compressedFileBegin ; size of allocated memory
   PUSH 0                                   ; zero if any address
   CALL DWORD PTR [KERNEL32.VirtualAlloc]   ; LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
   ; save allocated memory
   MOV  DWORD PTR [ddCompressedFileMemory], EAX

   ; 3. set readwrite attributes to image
   PUSH ddOldProtectFlags                    ; lpflOldProtect
   PUSH 40h                                  ; PAGE_EXECUTE_READWRITE - 0x40
   PUSH externImageSize                      ; size
   PUSH externImageBase                      ; lpAddress
   CALL DWORD PTR [KERNEL32.VirtualProtect]  ; BOOL WINAPI VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);

   ; 3. copy stub code to the allocated memory
   MOV  ESI, _stubBegin
   MOV  EDI, DWORD PTR [ddStubMemory]
   MOV  ECX, _stubEnd - _stubBegin
   REPZ  MOVSB

   ; 4. copy compressed file to the allocated memory
   MOV  ESI, _compressedFileBegin
   MOV  EDI, DWORD PTR [ddCompressedFileMemory]
   MOV  ECX, _compressedFileEnd - _compressedFileBegin
   REPZ  MOVSB

   ; save relative offset in ebp register
   MOV  EBP, DWORD PTR [ddStubMemory]
   SUB  EBP, _stubBegin

   ; 5. pass control
   MOV  EAX, DWORD PTR [ddStubMemory]
   ADD  EAX, _jumpToAllocatedMemory - _stubBegin
   JMP  EAX
_jumpToAllocatedMemory:

   ; I am in the allocated memory
   MOV ECX, ECX
   MOV EDX, EDX

   ; test memory
   MOV EBX, DWORD PTR [EBP + ddStubMemory]
   MOV EBX, DWORD PTR [EBP + ddCompressedFileMemory]

   ; decompress
   PUSH externImageBase                     ; destination TODO provide externMemoryBase
   PUSH  DWORD PTR [EBP + ddCompressedFileMemory] ; source
   CALL _aP_depack_asm                      ; void aP_depack_asm(const void *source, void *destination)
   ADD  ESP, 8                              ; erase stack after cdecl call

   ; Restore import

   ; struct IMAGE_DOS_HEADER
   ; 0x3C LONG e_lfanew                     ; File address of new exe header

   ; ASSUME EDI:PTR IMAGE_DOS_HEADER
   MOV  EDI, externImageBase
   MOV  EAX, externImageBase
   ADD  EAX, DWORD PTR [EDI + 3CH]         ; IMAGE_DOS_HEADER.e_lfanew
   ; struct IMAGE_NT_HEADERS32
   ; 0x78 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]
   ; 0x80 DWORD DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress

   ; ASSUME EAX:PTR IMAGE_NT_HEADERS32
   MOV  ESI, DWORD PTR [EAX + 80H]          ; 0x80 IMAGE_NT_HEADERS32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
   ADD  ESI, externImageBase

   ; struct IMAGE_IMPORT_DESCRIPTOR
   ; 0x00 DWORD OriginalFirstThunk
   ; 0x04 DWORD TimeDateStamp
   ; 0x08 DWORD ForwarderChain
   ; 0x0C DWORD Name
   ; 0x10 DWORD FirstThunk
_importDescriptionLoopStart:
   ; ASSUME ESI:PTR IMAGE_IMPORT_DESCRIPTOR
   CMP  DWORD PTR [ESI + 0CH], 0            ; IMAGE_IMPORT_DESCRIPTOR.Name == 0
   JZ   _importDescriptionLoopExit
      ; load library
      MOV  EAX, externImageBase
      ADD  EAX, DWORD PTR [ESI + 0CH]       ; image base + IMAGE_IMPORT_DESCRIPTOR.Name
      PUSH EAX                              ; lpFileName
      CALL DWORD PTR [EBP + ddLoadLibraryA]  ; HMODULE LoadLibrary(LPCTSTR lpFileName);
      MOV  DWORD PTR [EBP + ddModuleHandle], EAX ; save HMODULE in EDI

      ; load thunk array
      MOV  EDI, externImageBase
      ADD  EDI, DWORD PTR [ESI + 10H]       ; IMAGE_IMPORT_DESCRIPTOR.FirstThunk

_importDescriptionThunkLoopStart:
      ; ASSUME EDI:PTR THUNK
      CMP  DWORD PTR [EDI], 0
      JZ   _importDescriptionThunkLoopExit
         TEST  DWORD PTR [EDI], 80000000H    ; if thunk contains ordinal value or name
         JZ   _importDescriptionThunkName
            MOV  EAX, DWORD PTR [EDI]
            AND  EAX, 0FFFFH
            PUSH EAX                                ; lpProcName
            PUSH DWORD PTR [EBP + ddModuleHandle]   ; hLib
            CALL DWORD PTR [EBP + ddGetProcAddress] ; FARPROC GetProcAddress(HMODULE hModule, LPCSTR  lpProcName);
            ; save address
            MOV  DWORD PTR [EDI], EAX
            JMP  _importDescriptionThunkSkipName
_importDescriptionThunkName:
            MOV  EAX, externImageBase
            ADD  EAX, DWORD PTR [EDI]          ; EAX points to NAME

            ; struct _IMAGE_IMPORT_BY_NAME
            ; 0x00 WORD Hint
            ; 0x02 CHAR Name[1]

            ; ASSUME EAX:PTR IMAGE_IMPORT_BY_NAME
            ADD  EAX, 2

            PUSH EAX                                ; lpProcName
            PUSH DWORD PTR [EBP + ddModuleHandle]   ; hLib
            CALL DWORD PTR [EBP + ddGetProcAddress] ; FARPROC GetProcAddress(HMODULE hModule, LPCSTR  lpProcName);
            ; save address
            MOV  DWORD PTR [EDI], EAX
_importDescriptionThunkSkipName:

      ADD  EDI, 4
      JMP  _importDescriptionThunkLoopStart
_importDescriptionThunkLoopExit:

    ADD  ESI, 14H              ; sizeof IMAGE_IMPORT_DESCRIPTOR
    JMP _importDescriptionLoopStart

_importDescriptionLoopExit:


; antiDump:
   ;/*<thisrel this+0x30>*/ /*|0x4|*/ struct _PEB* ProcessEnvironmentBlock;
;   MOV   EAX, DWORD PTR FS:[30h]   ; EAX ->> PEB Struct

   ;/*<thisrel this+0xc>*/ /*|0x4|*/ struct _PEB_LDR_DATA* Ldr;
;   MOV   EAX, DWORD PTR [EAX + 0CH]  ;EAX->>_PEB_LDR_DATA

   ;/*<thisrel this+0xc>*/ /*|0x8|*/ struct _LIST_ENTRY InLoadOrderModuleList.Flink
;   MOV   EAX, DWORD PTR [EAX + 0CH]  ;EAX->>_LDR_DATA_TABLE_ENTRY

   ; loop
;   MOV   EBX, externImageBase
;_antiDump_loopStart:
;   CMP   EBX, DWORD PTR [EAX + 18H]   ;/*<thisrel this + 0x18>*/ /*|0x4|*/ void* DllBase;
;   JNZ   _antiDump_loopNext
   ; fix DllBase
;   MOV   DWORD PTR [EAX + 18h], 0     ;/*<thisrel this + 0x18>*/ /*|0x4|*/ void* DllBase;
   ; fix SizeOfImage
;   MOV   DWORD PTR [EAX + 20H], 0          ;/*<thisrel this + 0x20>*/ /*|0x4|*/ unsigned long SizeOfImage;
;   JMP  _antiDump_loopExit
;_antiDump_loopNext:
;   PUSH DWORD PTR [EAX]       ;/*<thisrel this + 0x0>*/ /*|0x8|*/ struct _LIST_ENTRY InLoadOrderLinks.Flink
;   POP  EAX
;   JMP  _antiDump_loopStart
;_antiDump_loopExit:

   PUSH 8000H                                          ; MEM_RELEASE 0x8000
   PUSH 0;_compressedFileEnd - _compressedFileBegin      ; dwSize
   PUSH DWORD PTR [EBP + ddCompressedFileMemory]       ; lpAddress
   CALL DWORD PTR [EBP + ddVirtualFree] ; BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

   PUSH 8000H                               ; MEM_RELEASE 0x8000
   PUSH 0;_stubEnd - _stubBegin               ; dwSize
   PUSH DWORD PTR [EBP + ddStubMemory]      ; lpAddress
   ; goto the original entry point
   MOV  EAX, externImageBase
   ADD  EAX, externOEP
   PUSH EAX
   JMP  DWORD PTR [EBP + ddVirtualFree] ; BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);


   ; goto the original entry point
;   MOV  EAX, externImageBase
;   ADD  EAX, externOEP
;   JMP  EAX

; aP_depack_asm(const void *source, void *destination)
_aP_depack_asm:
    PUSHAD

    MOV    ESI, DWORD PTR [ESP + 36]    ; C CALLing convention
    MOV    EDI, DWORD PTR [ESP + 40]

    CLD
    MOV    DL, 80H
    XOR    EBX, EBX

literal:
    MOVSB
    MOV    BL, 2
nexttag:
    CALL   getbit
    JNC    literal

    XOR    ECX, ECX
    CALL   getbit
    JNC    codepair
    XOR    EAX, EAX
    CALL   getbit
    JNC    shortmatch
    MOV    BL, 2
    INC    ECX
    MOV    AL, 10h
getmorebits:
    CALL   getbit
    ADC    AL, AL
    JNC    getmorebits
    JNZ    domatch
    STOSB
    JMP    nexttag
codepair:
    CALL   getgamma_no_ECX
    SUB    ECX, EBX
    JNZ    normalcodepair
    CALL   getgamma
    JMP    domatch_lastpos

shortmatch:
    LODSB
    SHR    EAX, 1
    JZ     donedepacking
    ADC    ECX, ECX
    JMP    domatch_with_2inc

normalcodepair:
    XCHG   EAX, ECX
    DEC    EAX
    SHL    EAX, 8
    LODSB
    CALL   getgamma
    CMP    EAX, 32000
    JAE    domatch_with_2inc
    CMP    AH, 5
    JAE    domatch_with_inc
    CMP    EAX, 7fh
    JA     domatch_new_lastpos

domatch_with_2inc:
    INC    ECX

domatch_with_inc:
    INC    ECX

domatch_new_lastpos:
    XCHG   EAX, EBP
domatch_lastpos:
    MOV    EAX, EBP

    MOV    BL, 1

domatch:
    PUSH   ESI
    MOV    ESI, EDI
    SUB    ESI, EAX
    REPZ   MOVSB
    POP    ESI
    JMP    nexttag

getbit:
    ADD     dl, dl
    jnz     stillbitsleft
    MOV     dl,byte PTR [ESI]
    inc     ESI
    adc     dl, dl
stillbitsleft:
    RET

getgamma:
    xor    ECX, ECX
getgamma_no_ECX:
    inc    ECX
getgammaloop:
    CALL   getbit
    adc    ECX, ECX
    CALL   getbit
    jc     getgammaloop
    RET

donedepacking:
    SUB    EDI,DWORD PTR [ESP + 40]
    MOV    DWORD PTR [ESP + 28], EDI    ; RETurn unpacked length in EAX

    POPAD
    RET

 
   ddStubMemory DD 0
   ddCompressedFileMemory DD 0
   ddOldProtectFlags  DD 0
   ddLoadLibraryA DD 0
   ddModuleHandle DD 0
   ddGetProcAddress DD 0
   ddVirtualFree DD 0
_stubEnd:
   dummy DB 0

SECTION ".rdata"  ir
   DIRECTIVE IMPORT_DIRECTORY
   dummy0 DD 0FF88FF88H                     ; signature
   DIRECTIVE RECOURCE_DIRECTORY
   dummy1 DD 0FF88FF88H                     ; signature

_compressedFileBegin:
   DIRECTIVE COMPRESSED_FILE
_compressedFileEnd:
   dummy2 DD 0FF88FF88H                     ; signature

```

`examples/CMakeLists.txt`:

```txt

add_executable(
  hello-world
  hello-world.cpp)

add_test(
 NAME
  protect-hello-world
 COMMAND
  pe-protector $<TARGET_FILE:hello-world>)

add_test(
 NAME
  protected-hello-world-test
 COMMAND
  $<TARGET_FILE_DIR:hello-world>/protected-$<TARGET_FILE_NAME:hello-world>)

```

`examples/hello-world.cpp`:

```cpp
#include <iostream>

int main() {
  std::cout << "Hello World!" << std::endl;
  return 0;
}
```

`log/CLog.cpp`:

```cpp
#include "CLog.h"

#include <stdarg.h>
#include <time.h>
#include <sstream>
#include <string>
#include <thread>

namespace {
std::string timeToString(const time_t& time) {
  char buffer[80];

  strftime(buffer, 80, "%c", localtime(&time));

  return std::string(buffer);
}
}  // namespace

CLog& CLog::getInstance() {
  static CLog log;
  return log;
}

bool CLog::initialize(const std::string& fileName) {
  // mFileHandle = fopen(fileName.c_str(), "w");
  return true;
}

void CLog::log(const std::string& type, const char* const format, ...) {
  va_list args;
  va_start(args, format);

  // if (mFileHandle != 0) {
  std::stringstream ss;
  ss << std::this_thread::get_id();

  fprintf(stderr, "[%s] [%s] [%s] : ", timeToString(time(0)).c_str(),
          ss.str().c_str(), type.c_str());

  vfprintf(stderr, format, args);

  fprintf(stderr, "\n");

  fflush(stderr);
  //}

  va_end(args);
}

CLog::CLog() : mFileHandle() {}

CLog::~CLog() {
  if (mFileHandle != 0) {
    fclose(mFileHandle);
  }
}

```

`log/CLog.h`:

```h
#pragma once

#include <stdio.h>
#include <string>

/**
 * @brief Logger
 */
class CLog {
 public:
  /**
   * @brief Get single instance of logger
   */
  static CLog& getInstance();
  /**
   * @brief Initialize logger
   * @param[in] fileName file where traces will be written
   */
  bool initialize(const std::string& fileName);
  /**
   * @brief Send to log file message
   * @param[in] type type of message. It can be DEBUG, ERROR, WARNING or
   * whatever
   * @param[in] format format string in printf style
   */
  void log(const std::string& type, const char* format, ...);

 private:
  /**
   * @brief Constructor
   */
  CLog();
  /**
   * @brief Destructor
   */
  ~CLog();
  /**
   * @brief Copy constructor
   */
  CLog(const CLog&);
  /**
   * @brief Assign operator
   */
  CLog& operator=(const CLog&);
  /**
   * @brief File handle
   */
  FILE* mFileHandle;
};

/**
 * @brief Helper macros
 */
#define LOG_INITIALIZE(fileName) CLog::getInstance().initialize(fileName)
#define LOG_ERROR(format, ...) \
  CLog::getInstance().log("error", format, ##__VA_ARGS__)
#ifndef NDEBUG
#define LOG_DEBUG(format, ...) \
  CLog::getInstance().log("debug", format, ##__VA_ARGS__)
#else
#define LOG_DEBUG(format, ...)
#endif

```

`log/CMakeLists.txt`:

```txt

add_library(
  liblog
  CLog.h
  CLog.cpp)

target_include_directories(
  liblog
 PUBLIC
  "${CMAKE_SOURCE_DIR}")

```

`pe-protector/CMakeLists.txt`:

```txt
# TODO extract libpe for pe parser
add_library(
  libpe-protector
  ClientFile.h
  ClientFile.cpp
  Data.h
  Data.cpp
  Import.h
  Import.cpp
  Instruction.h
  Instruction.cpp
  InstructionModRM.h
  InstructionModRM.cpp
  Mutation.h
  Mutation.cpp
  Opcodes.h
  Opcodes.cpp
  PeHeader.h
  PeHeader.cpp
  ProtectPe.cpp
  ProtectPe.h
  Resources.h
  Resources.cpp)

target_link_libraries(
  libpe-protector
 PUBLIC
  libcommon
 PRIVATE
  liblog
  Dbghelp
  "${CMAKE_SOURCE_DIR}/aplib/aplib.lib")

target_include_directories(
  libpe-protector
 PUBLIC
  "${CMAKE_SOURCE_DIR}")

#target_link_options(
#  libpe-protector
 #PUBLIC
#  "/SAFESEH:NO")

set(PE_PROTECTOR_STUB_BIN "pe-protector-stub.bin")

add_executable(
  pe-protector
  main.cpp
  pe-protector.rc
  resource.h
  ${PE_PROTECTOR_STUB_BIN})

target_compile_definitions(
  pe-protector
 PRIVATE
  PE_PROTECTOR_STUB_BIN="${PE_PROTECTOR_STUB_BIN}")

target_link_libraries(
  pe-protector
 PRIVATE
  libpe-protector
  liblog)

add_custom_command(
 OUTPUT ${PE_PROTECTOR_STUB_BIN}
 COMMAND
   compiler
   ${CMAKE_SOURCE_DIR}/data/pe-protector-stub.asm
   ${PE_PROTECTOR_STUB_BIN}
 DEPENDS
  compiler
  ${CMAKE_SOURCE_DIR}/data/pe-protector-stub.asm)

```

`pe-protector/ClientFile.cpp`:

```cpp
#include "ClientFile.h"

#include "aplib/aplib.h"

#include <assert.h>
#include <windows.h>
#include <stdexcept>
#include <string>

#include <dbghelp.h>

namespace NPeProtector {
namespace {
class CFileMapping {
 public:
  CFileMapping(const std::string& fileName)
      : mFileHandle(INVALID_HANDLE_VALUE),
        mMapppingHandle(INVALID_HANDLE_VALUE),
        mPointer(),
        mNtHeaderPtr(),
        mSize() {
    mFileHandle = CreateFileA(fileName.c_str(), GENERIC_READ, FILE_SHARE_READ,
                              0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (mFileHandle != INVALID_HANDLE_VALUE) {
      mMapppingHandle =
          CreateFileMapping(mFileHandle, 0, PAGE_READONLY | SEC_IMAGE, 0, 0, 0);
      if (mMapppingHandle != INVALID_HANDLE_VALUE) {
        mPointer = MapViewOfFile(mMapppingHandle, FILE_MAP_READ, 0, 0, 0);
        if (mPointer != 0) {
          mNtHeaderPtr = ImageNtHeader((void*)mPointer);
          if (mNtHeaderPtr != 0) {
            mSize = mNtHeaderPtr->OptionalHeader.SizeOfImage;
          } else {
            throw std::runtime_error{
                "CFileMapping::ImageNtHeader returns error"};
          }
        } else {
          throw std::runtime_error{"CFileMapping::MapViewOfFile returns error"};
        }
      } else {
        throw std::runtime_error{
            "CFileMapping::CreateFileMapping returns error"};
      }
    } else {
      throw std::runtime_error{"CFileMapping::CreateFileA returns error"};
    }
  }

  const void* getPointer() const { return mPointer; }

  const IMAGE_NT_HEADERS& getNtHeader() const {
    assert(mNtHeaderPtr != 0);

    return *mNtHeaderPtr;
  }

  int getSize() const { return mSize; }

  ~CFileMapping() {
    if (mPointer != 0) {
      UnmapViewOfFile(mPointer);
    }
    if (mMapppingHandle != INVALID_HANDLE_VALUE) {
      CloseHandle(mMapppingHandle);
    }
    if (mFileHandle != INVALID_HANDLE_VALUE) {
      CloseHandle(mFileHandle);
    }
  }

 private:
  HANDLE mFileHandle;
  HANDLE mMapppingHandle;
  const void* mPointer;
  const IMAGE_NT_HEADERS* mNtHeaderPtr;
  int mSize;
};

const IMAGE_RESOURCE_DIRECTORY_ENTRY* getDirectoryEntry(
    const IMAGE_RESOURCE_DIRECTORY* directory) {
  return reinterpret_cast<const IMAGE_RESOURCE_DIRECTORY_ENTRY*>(directory + 1);
};

const IMAGE_RESOURCE_DIRECTORY* findResource(
    void* base,
    const IMAGE_RESOURCE_DIRECTORY* const directory,
    const int id) {
  const IMAGE_RESOURCE_DIRECTORY_ENTRY* entries = getDirectoryEntry(directory);

  for (int i = directory->NumberOfNamedEntries;
       i < directory->NumberOfNamedEntries + directory->NumberOfIdEntries;
       i++) {
    if (entries[i].Id == id) {
      return (IMAGE_RESOURCE_DIRECTORY*)((char*)base +
                                         entries[i].OffsetToDirectory);
    }
  }
  return 0;
}

std::vector<std::vector<char> > getAllResource(const CFileMapping& fileMapping,
                                               const int id) {
  std::vector<std::vector<char> > result;
  // get resource directory
  const DWORD rvaResource =
      fileMapping.getNtHeader()
          .OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]
          .VirtualAddress;
  if (rvaResource != 0) {
    const IMAGE_RESOURCE_DIRECTORY* const resource =
        (IMAGE_RESOURCE_DIRECTORY*)((char*)fileMapping.getPointer() +
                                    rvaResource);
    const IMAGE_RESOURCE_DIRECTORY* const iconDirectoryL2 =
        findResource((void*)resource, resource, id /*3 RT_ICON*/);
    if (iconDirectoryL2 != 0) {
      try {
        const IMAGE_RESOURCE_DIRECTORY_ENTRY* iconEntryL2 =
            getDirectoryEntry(iconDirectoryL2);
        for (int i = iconDirectoryL2->NumberOfNamedEntries;
             i < iconDirectoryL2->NumberOfIdEntries +
                     iconDirectoryL2->NumberOfNamedEntries;
             ++i) {
          const IMAGE_RESOURCE_DIRECTORY* iconDirectoryL3 =
              (IMAGE_RESOURCE_DIRECTORY*)((char*)resource +
                                          iconEntryL2->OffsetToDirectory);
          const IMAGE_RESOURCE_DIRECTORY_ENTRY* iconEntryL3 =
              getDirectoryEntry(iconDirectoryL3);
          IMAGE_RESOURCE_DATA_ENTRY* dataEntry =
              (IMAGE_RESOURCE_DATA_ENTRY*)((char*)resource +
                                           iconEntryL3->OffsetToDirectory);

          // dataEntry->OffsetToData = RVA
          const char* data =
              ((char*)fileMapping.getPointer() + dataEntry->OffsetToData);
          const int size = dataEntry->Size;

          result.push_back(std::vector<char>(data, data + size));

          iconEntryL2++;
        }
      } catch (...) {
        throw std::runtime_error("Failed to get resources");
      }
    }
  }
  return result;
}

// get first resource!
std::vector<char> getFirstResource(const CFileMapping& fileMapping,
                                   const int id) {
  std::vector<char> result;
  // get resource directory
  const DWORD rvaResource =
      fileMapping.getNtHeader()
          .OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]
          .VirtualAddress;
  if (rvaResource != 0) {
    const IMAGE_RESOURCE_DIRECTORY* const resource =
        (IMAGE_RESOURCE_DIRECTORY*)((char*)fileMapping.getPointer() +
                                    rvaResource);
    const IMAGE_RESOURCE_DIRECTORY* const iconDirectoryL2 =
        findResource((void*)resource, resource, id /*3 RT_ICON*/);
    if (iconDirectoryL2 != 0) {
      try {
        const IMAGE_RESOURCE_DIRECTORY_ENTRY* iconEntryL2 =
            getDirectoryEntry(iconDirectoryL2);
        const IMAGE_RESOURCE_DIRECTORY* iconDirectoryL3 =
            (IMAGE_RESOURCE_DIRECTORY*)((char*)resource +
                                        iconEntryL2->OffsetToDirectory);
        const IMAGE_RESOURCE_DIRECTORY_ENTRY* iconEntryL3 =
            getDirectoryEntry(iconDirectoryL3);
        IMAGE_RESOURCE_DATA_ENTRY* dataEntry =
            (IMAGE_RESOURCE_DATA_ENTRY*)((char*)resource +
                                         iconEntryL3->OffsetToDirectory);

        // dataEntry->OffsetToData = RVA
        const char* data =
            ((char*)fileMapping.getPointer() + dataEntry->OffsetToData);
        const int size = dataEntry->Size;

        result.insert(result.end(), data, data + size);
      } catch (...) {
        throw std::runtime_error("Failed to get resources");
      }
    }
  }
  return result;
}

std::vector<char> compressFile(const CFileMapping& file) {
  /* allocate workmem and destination memory */
  char* workmem = (char*)malloc(aP_workmem_size(file.getSize()));
  char* compressed = (char*)malloc(aP_max_packed_size(file.getSize()));

  /* compress data[] to compressed[] */
  size_t outlength = aP_pack(file.getPointer(), compressed, file.getSize(),
                             workmem, NULL, NULL);

  /* if APLIB_ERROR is returned, and error occured */
  if (outlength == APLIB_ERROR) {
    throw std::runtime_error("aplib: an error occured!\n");
  }

  // copy
  std::vector<char> result(compressed, compressed + outlength);

  free(workmem);
  free(compressed);

  return result;
}
}  // namespace

SClientFile getPeFileInfo(const char* filename) {
  SClientFile result;

  CFileMapping fileMapping(filename);
  if (fileMapping.getNtHeader().OptionalHeader.Magic ==
      IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
    if (fileMapping.getNtHeader()
            .OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]
            .VirtualAddress == 0) {
      // TODO print warning
      /*if (fileMapping.getNtHeader()
              .OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS]
              .VirtualAddress == 0) {*/
      result.mIcons = getAllResource(fileMapping, 3 /*icon*/);
      result.mManifest = getFirstResource(fileMapping, 0x18 /*manifest*/);
      result.mGroupIcons = getFirstResource(fileMapping, 0x0E /*group icons*/);
      result.mCompressed = compressFile(fileMapping);
      result.mImageBase = fileMapping.getNtHeader().OptionalHeader.ImageBase;
      result.mImageSize = fileMapping.getNtHeader().OptionalHeader.SizeOfImage;
      result.mOEP =
          fileMapping.getNtHeader().OptionalHeader.AddressOfEntryPoint;
      /*} else {
        throw std::runtime_error("pe-protector doesn't support files with TLS");
      }*/
    } else {
      throw std::runtime_error("IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR != 0");
    }
  } else {
    throw std::runtime_error(
        "OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC");
  }
  return result;
}
}  // namespace NPeProtector

```

`pe-protector/ClientFile.h`:

```h
#pragma once

#include <cstdint>
#include <vector>

namespace NPeProtector {
/**
 * @brief Keeps all necessary information about source file
 */
struct SClientFile {
  /**
   * @brief Compressed source file
   */
  std::vector<char> mCompressed;
  /**
   * @brief Group icons resources
   */
  std::vector<char> mGroupIcons;
  /**
   * @brief Icons resources
   */
  std::vector<std::vector<char> > mIcons;
  /**
   * @brief Manifest resources
   */
  std::vector<char> mManifest;
  /**
   * @brief Image base of source file in memory
   */
  uint32_t mImageBase;
  /**
   * @brief Size of image in memory of source file
   */
  uint32_t mImageSize;
  /**
   * @brief Original entry point (RVA)
   */
  uint32_t mOEP;
};

/**
 * @brief Fills SClientFile from source file
 * @param[in] filename name of source file
 * @return SClientFile
 */
SClientFile getPeFileInfo(const char* filename);
}  // namespace NPeProtector

```

`pe-protector/Data.cpp`:

```cpp
#include "Data.h"
#include "PeHeader.h"

#include <assert.h>
#include <ostream>

namespace NPeProtector {
uint32_t getConstantValue(const SConstant& constant,
                          const std::vector<SCommand>& commands) {
  uint32_t result = constant.mValue;

  for (unsigned int i = 0; i < constant.mLabels.size(); ++i) {
    if (constant.mLabels[i].mSign == NSign::PLUS) {
      result += commands[constant.mLabels[i].mIndex].mRVA + gImageBase;
    } else {
      result -= commands[constant.mLabels[i].mIndex].mRVA + gImageBase;
    }
  }
  return result;
}

int getDataSize(const SData& data) {
  assert((data.mCount > 1 && data.mConstants.size() == 1) ||
         (data.mCount == 1 && data.mConstants.size() >= 1));

  return data.mCount * data.mSizeData * data.mConstants.size();
}

void putData(std::ostream& output,
             const SData& data,
             const std::vector<SCommand>& commands) {
  assert((data.mCount > 1 && data.mConstants.size() == 1) ||
         (data.mCount == 1 && data.mConstants.size() >= 1));

  for (int i = 0; i < data.mCount; ++i) {
    for (unsigned int j = 0; j < data.mConstants.size(); ++j) {
      const uint32_t value = getConstantValue(data.mConstants[j], commands);
      switch (data.mSizeData) {
        case 1: {
          const char db = static_cast<char>(value);
          output.write((char*)&db, 1);
          break;
        }
        case 2: {
          const short dw = static_cast<short>(value);
          output.write((char*)&dw, 2);
          break;
        }
        case 4: {
          output.write((char*)&value, 4);
          break;
        }
        default:
          throw std::runtime_error("Wrong data size");
      }
    }
  }
}
}  // namespace NPeProtector

```

`pe-protector/Data.h`:

```h
#pragma once

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
/**
 * @brief Get size of data
 * @param[in] data data
 * @return Size
 */
int getDataSize(const SData& data);
/**
 * @brief Put data in stream
 * @param[in] output output stream
 * @param[in] data data
 * @param[in] commands commands
 */
void putData(std::ostream& output,
             const SData& data,
             const std::vector<SCommand>& commands);
}  // namespace NPeProtector

```

`pe-protector/Import.cpp`:

```cpp
#include "Import.h"

#include <assert.h>
#include <windows.h>
#include <map>
#include <ostream>

namespace NPeProtector {
namespace {
typedef std::pair<int /*index in commands*/, std::string /*function name*/>
    tIndexToFunction;
typedef std::vector<tIndexToFunction> tFunctions;
typedef std::map<std::string, tFunctions> tImport;

typedef tFunctions::const_iterator tFunctionIterator;
typedef tImport::const_iterator tImportIterator;

tImport getImport(const std::vector<SCommand>& commands) {
  tImport result;
  for (unsigned int i = 0; i < commands.size(); ++i) {
    if (commands[i].mType == NCommand::IMPORT) {
      result[commands[i].mImport.mDllName].push_back(
          tIndexToFunction(i, commands[i].mImport.mFunctionName));
    }
  }
  return result;
}

// total amount of functions!
int getNumberFunctions(const tImport& import) {
  int result = 0;
  for (tImportIterator i = import.begin(); i != import.end(); ++i) {
    for (tFunctionIterator j = i->second.begin(); j != i->second.end(); ++j) {
      result += 1;
    }
  }
  return result;
}

uint32_t toRVA(uint8_t* pointer, uint8_t* base, uint32_t importRVA) {
  return (pointer - base) + importRVA;
}
}  // namespace

int getImportSize(const std::vector<SCommand>& commands) {
  const tImport& import = getImport(commands);

  int size = 0;
  for (tImportIterator i = import.begin(); i != import.end(); ++i) {
    size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
    size += i->first.length() + 1;
    size += ((i->second.size() + 1 /*end*/) * sizeof(uint32_t)) *
            2 /*OriginalFirstThunk + FirstThunk*/;
    for (tFunctionIterator j = i->second.begin(); j != i->second.end(); ++j) {
      size += j->second.length() + 1 /*zero byte*/ +
              sizeof(uint32_t) /*IMAGE_IMPORT_BY_NAME::Hint*/;
    }
  }
  size += sizeof(IMAGE_IMPORT_DESCRIPTOR) /*end*/;

  return size;
}

void resolveImport(std::vector<SCommand>& commands, const uint32_t importRVA) {
  const tImport& import = getImport(commands);

  const int dllNumber = import.size();
  const int descriptionSize = (dllNumber + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);
  const int originalFirstChunkSize =
      (getNumberFunctions(import) + dllNumber) * sizeof(uint32_t);

  uint32_t firstChunkRVA = importRVA + descriptionSize + originalFirstChunkSize;

  for (tImportIterator i = import.begin(); i != import.end(); ++i) {
    for (tFunctionIterator j = i->second.begin(); j != i->second.end(); ++j) {
      assert(commands[j->first].mType == NCommand::IMPORT);
      commands[j->first].mRVA = firstChunkRVA;
      firstChunkRVA += sizeof(uint32_t);
    }
    firstChunkRVA += sizeof(uint32_t);
  }
}

void putImport(std::ostream& output,
               const std::vector<SCommand>& commands,
               const uint32_t importRVA) {
  const tImport& import = getImport(commands);
  /*
   IMAGE_IMPORT_DESCRIPTOR(1)
   IMAGE_IMPORT_DESCRIPTOR(2)
   IMAGE_IMPORT_DESCRIPTOR(end)
   originalFirstChunk(1)(1)
   originalFirstChunk(1)(2)
   originalFirstChunk(1)(3)
   originalFirstChunk(1)(end)
   originalFirstChunk(2)(1)
   originalFirstChunk(2)(2)
   originalFirstChunk(2)(end)
   firstChunk(1)(1)
   firstChunk(1)(2)
   firstChunk(1)(3)
   firstChunk(1)(end)
   firstChunk(2)(1)
   firstChunk(2)(2)
   firstChunk(2)(end)
   dllName(1)
   functionName(1)(1)
   functionName(1)(2)
   functionName(1)(3)
   dllName(2)
   functionName(2)(1)
   functionName(2)(2)
   **/

  const int dllNumber = import.size();
  const int descriptionSize = (dllNumber + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);
  const int originalFirstChunkSize =
      (getNumberFunctions(import) + dllNumber) * sizeof(uint32_t);
  const int firstChunkSize = originalFirstChunkSize;

  const int importSize = getImportSize(commands);

  char* const buffer = new char[importSize];
  memset(buffer, 0, importSize);

  IMAGE_IMPORT_DESCRIPTOR* descriptionPtr =
      reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(buffer);
  uint32_t* originalFirstChunkPtr =
      reinterpret_cast<uint32_t*>(buffer + descriptionSize);
  uint32_t* firstChunkPtr = reinterpret_cast<uint32_t*>(
      buffer + descriptionSize + originalFirstChunkSize);
  char* namesPtr = reinterpret_cast<char*>(
      buffer + descriptionSize + originalFirstChunkSize + firstChunkSize);

  for (tImportIterator i = import.begin(); i != import.end(); ++i) {
    descriptionPtr->OriginalFirstThunk =
        toRVA(reinterpret_cast<uint8_t*>(originalFirstChunkPtr),
              reinterpret_cast<uint8_t*>(buffer), importRVA);
    descriptionPtr->FirstThunk =
        toRVA(reinterpret_cast<uint8_t*>(firstChunkPtr),
              reinterpret_cast<uint8_t*>(buffer), importRVA);
    descriptionPtr->Name = toRVA(reinterpret_cast<uint8_t*>(namesPtr),
                                 reinterpret_cast<uint8_t*>(buffer), importRVA);

    // copy dll name
#pragma warning(push)
#pragma warning(disable : 4996)
    strcpy(namesPtr, i->first.c_str());
#pragma warning(pop)

    namesPtr += strlen(i->first.c_str()) + 1;

    for (tFunctionIterator j = i->second.begin(); j != i->second.end(); ++j) {
      *originalFirstChunkPtr =
          toRVA(reinterpret_cast<uint8_t*>(namesPtr),
                reinterpret_cast<uint8_t*>(buffer), importRVA);
      *firstChunkPtr = toRVA(reinterpret_cast<uint8_t*>(namesPtr),
                             reinterpret_cast<uint8_t*>(buffer), importRVA);
      // copy hint
      *(namesPtr + 0) = 0;
      *(namesPtr + 1) = 0;

#pragma warning(push)
#pragma warning(disable : 4996)
      strcpy(namesPtr + 2,
             /*importSize - ((namesPtr + 2)- buffer),*/ j->second.c_str());
#pragma warning(pop)

      namesPtr += strlen(j->second.c_str()) + 1 + 2;

      originalFirstChunkPtr++;
      firstChunkPtr++;
    }
    descriptionPtr++;

    // terminated zeros;
    originalFirstChunkPtr++;
    firstChunkPtr++;
  }

  output.write(buffer, importSize);

  delete[] buffer;
}
}  // namespace NPeProtector

```

`pe-protector/Import.h`:

```h
#pragma once

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
/**
 * @brief Setup all import reference in commands
 * @param[in] commands commands
 * @param[in] importRVA offset where import will be
 */
void resolveImport(std::vector<SCommand>& commands, const uint32_t importRVA);
/**
 * @brief Get size of import directory
 * @param[in] commands commands but processed only import command
 * @return Size
 */
int getImportSize(const std::vector<SCommand>& commands);
/**
 * @brief Put import directory in stream
 * @param[in] output output stream
 * @param[in] commands commands
 * @param[in] importRVA offset where import will be
 */
void putImport(std::ostream& output,
               const std::vector<SCommand>& commands,
               const uint32_t importRVA);
}  // namespace NPeProtector

```

`pe-protector/Instruction.cpp`:

```cpp
#include "Instruction.h"

#include "InstructionModRM.h"
#include "Opcodes.h"
#include "PeHeader.h"

#include <assert.h>
#include <ostream>

namespace NPeProtector {
namespace {
int getSegmentSize(const NSegment::EType segment) {
  switch (segment) {
    case NSegment::CS:
    case NSegment::DS:
    case NSegment::ES:
    case NSegment::FS:
    case NSegment::GS:
    case NSegment::SS:
      return 1;
  }
  return 0;
}

void putSegment(std::ostream& output, const NSegment::EType segment) {
  char value = 0;
  switch (segment) {
    case NSegment::CS:
      value = 0x2E;
      break;
    case NSegment::DS:
      value = 0x3e;
      break;
    case NSegment::ES:
      value = 0x26;
      break;
    case NSegment::FS:
      value = 0x64;
      break;
    case NSegment::GS:
      value = 0x65;
      break;
    case NSegment::SS:
      value = 0x36;
      break;
  }
  if (value != 0) {
    output.write(&value, 1);
  }
}

void putPrefix(std::ostream& output, const NPrefix::EType prefix) {
  unsigned char value = 0;
  switch (prefix) {
    case NPrefix::REPZ:
      value = 0xF3;
      break;
    case NPrefix::REPNZ:
      value = 0xF2;
      break;
  }
  if (value != 0) {
    output.write((char*)&value, 1);
  }
}

int getPrefixSize(const NPrefix::EType prefix) {
  switch (prefix) {
    case NPrefix::REPZ:
    case NPrefix::REPNZ:
      return 1;
  }
  return 0;
}

bool isMatchOperand(const SOpcode::EOperand opcodeOperand,
                    const SOperand& operand) {
  switch (opcodeOperand) {
    case SOpcode::AL:
      return operand.mType == NOperand::REG8 &&
             operand.mRegister == NRegister::AL;
    case SOpcode::AX:
      return operand.mType == NOperand::REG16 &&
             operand.mRegister == NRegister::AX;
    case SOpcode::EAX:
      return operand.mType == NOperand::REG32 &&
             operand.mRegister == NRegister::EAX;
    case SOpcode::CL:
      return operand.mType == NOperand::REG8 &&
             operand.mRegister == NRegister::CL;
    case SOpcode::REG8:
      return operand.mType == NOperand::REG8;
    case SOpcode::REG16:
      return operand.mType == NOperand::REG16;
    case SOpcode::REG32:
      return operand.mType == NOperand::REG32;
    case SOpcode::MEM8:
      return operand.mType == NOperand::MEM8;
    case SOpcode::MEM16:
      return operand.mType == NOperand::MEM16;
    case SOpcode::MEM32:
      return operand.mType == NOperand::MEM32;
    case SOpcode::IMM1:
      return operand.mType == NOperand::CONSTANT &&
             operand.mConstant.mValue == 1 && operand.mConstant.mLabels.empty();
    case SOpcode::IMM8:
      return operand.mType == NOperand::CONSTANT &&
             getDisplacementSize(operand.mConstant, false) == 1;
    case SOpcode::IMM16:
      return operand.mType == NOperand::CONSTANT &&
             getDisplacementSize(operand.mConstant, false) == 2;
    case SOpcode::IMM32:
      return operand.mType == NOperand::CONSTANT;
    case SOpcode::REL8:
    case SOpcode::REL16:
      return false;
    case SOpcode::REL32:
      return operand.mType == NOperand::CONSTANT;
    case SOpcode::NON:
      throw std::runtime_error("Failed to get type of operand");
  };
  return false;
}

bool isMatch(const SOpcode& opcode, const SInstruction& instruction) {
  if (opcode.mType == instruction.mType) {
    switch (instruction.mOperands.size()) {
      case 0:
        return opcode.mOperand1 == SOpcode::NON &&
               opcode.mOperand2 == SOpcode::NON &&
               opcode.mOperand3 == SOpcode::NON;
      case 1:
        return opcode.mOperand1 != SOpcode::NON &&
               opcode.mOperand2 == SOpcode::NON &&
               opcode.mOperand3 == SOpcode::NON &&
               isMatchOperand(opcode.mOperand1, instruction.mOperands[0]);
      case 2:
        return opcode.mOperand1 != SOpcode::NON &&
               opcode.mOperand2 != SOpcode::NON &&
               opcode.mOperand3 == SOpcode::NON &&
               isMatchOperand(opcode.mOperand1, instruction.mOperands[0]) &&
               isMatchOperand(opcode.mOperand2, instruction.mOperands[1]);
      case 3:
        return opcode.mOperand1 != SOpcode::NON &&
               opcode.mOperand2 != SOpcode::NON &&
               opcode.mOperand3 != SOpcode::NON &&
               isMatchOperand(opcode.mOperand1, instruction.mOperands[0]) &&
               isMatchOperand(opcode.mOperand2, instruction.mOperands[1]) &&
               isMatchOperand(opcode.mOperand3, instruction.mOperands[2]);
      default:
        // error
        throw std::runtime_error("TODO");
    }
  }
  return false;
}
bool isOperandMemory(const NOperand::EType type) {
  return type == NOperand::MEM8 || type == NOperand::MEM16 ||
         type == NOperand::MEM32;
}

const SOpcode& getOpcode(const SInstruction& instruction) {
  for (int i = 0; i < gOpcodeSize; ++i) {
    if (isMatch(gOpcodes[i], instruction)) {
      return gOpcodes[i];
    }
  }
  throw std::runtime_error("Failed to find proper instruction");
}

bool isOperandImm(const SOpcode::EOperand opcodeOperand) {
  return opcodeOperand == SOpcode::IMM8 || opcodeOperand == SOpcode::IMM16 ||
         opcodeOperand == SOpcode::IMM32;
}

bool isOperandRel(const SOpcode::EOperand opcodeOperand) {
  return opcodeOperand == SOpcode::REL8 || opcodeOperand == SOpcode::REL16 ||
         opcodeOperand == SOpcode::REL32;
}

int getOperandSize(const SOpcode::EOperand opcodeOperand) {
  switch (opcodeOperand) {
    case SOpcode::IMM8:
    case SOpcode::REL8:
      return 1;
    case SOpcode::IMM16:
    case SOpcode::REL16:
      return 2;
    case SOpcode::IMM32:
    case SOpcode::REL32:
      return 4;
  }
  return 0;
}

void putConstant(std::ostream& output, const int value, const int size) {
  switch (size) {
    case 0: {
      break;
    }
    case 1: {
      const char c = static_cast<char>(value);
      output.write(&c, 1);
      break;
    }
    case 2: {
      const short s = static_cast<short>(value);
      output.write((char*)&value, 2);
      break;
    }
    case 4: {
      output.write((char*)&value, 4);
      break;
    }
    default:
      throw std::runtime_error("Failed to put constant");
  }
}

void putConstant(std::ostream& output,
                 const SOpcode::EOperand opcodeOperand,
                 const SConstant& constant,
                 const std::vector<SCommand>& commands) {
  // process second operand
  switch (opcodeOperand) {
    case SOpcode::IMM8: {
      const char value = static_cast<char>(getDisplacement(constant, commands));
      output.write(&value, 1);
      break;
    }
    case SOpcode::IMM16: {
      const short value =
          static_cast<short>(getDisplacement(constant, commands));
      output.write((char*)&value, 2);
      break;
    }
    case SOpcode::IMM32: {
      const int value = getDisplacement(constant, commands);
      output.write((char*)&value, 4);
      break;
    }
    default:
      throw std::runtime_error("Failed to put operand");
  }
}

void putRelativeConstant(std::ostream& output,
                         const SOpcode::EOperand opcodeOperand,
                         const SConstant& constant,
                         const std::vector<SCommand>& commands,
                         uint32_t rva) {
  // process second operand
  switch (opcodeOperand) {
    case SOpcode::REL8:
    case SOpcode::REL16: {
      throw std::runtime_error("Failed to put operand");
      break;
    }
    case SOpcode::REL32: {
      DWORD disp = static_cast<DWORD>(getDisplacement(constant, commands));
      const DWORD value = disp - (rva + 4 + gImageBase);
      output.write((char*)&value, 4);
      break;
    }
    default:
      throw std::runtime_error("Failed to put operand");
  }
}

void putDisplacement(std::ostream& output,
                     const SMemory& memory,
                     const std::vector<SCommand>& commands) {
  const int displacementSize =
      memory.mRegisters.size() == 0
          ? 4
          : getDisplacementSize(memory.mConstant, true);

  if (displacementSize == 0) {
    if (isDummyDisplacement8(memory)) {
      putConstant(output, 0, 1);
    }
  } else {
    const int displacement = getDisplacement(memory.mConstant, commands);
    // put 1 or 2 or 4 bytes
    putConstant(output, displacement, displacementSize);
  }
}

}  // namespace

int getInstructionSize(const SInstruction& instruction) {
  const SOpcode& opcode = getOpcode(instruction);

  // putPrefix(output, instruction.mPrefix);

  int result = opcode.mOpcodeSize;

  result += getPrefixSize(instruction.mPrefix);
  switch (opcode.mFlag) {
    case SOpcode::R0:  // /0
    case SOpcode::R1:  // /1
    case SOpcode::R2:  // /2
    case SOpcode::R3:  // /3
    case SOpcode::R4:  // /4
    case SOpcode::R5:  // /5
    case SOpcode::R6:  // /6
    case SOpcode::R7:  // /7
    case SOpcode::RM_R: {
      result += 1; /*ModRM*/
      if (isOperandMemory(instruction.mOperands[0].mType)) {
        SMemory RM_Memory = normalizeMemory(instruction.mOperands[0].mMemory);
        result += isSIB_Required(RM_Memory);
        result += isDummyDisplacement8(RM_Memory);
        result += RM_Memory.mRegisters.size() == 0
                      ? 4
                      : getDisplacementSize(RM_Memory.mConstant, true);
        result += getSegmentSize(RM_Memory.mSegment);
      }

      break;
    }
    case SOpcode::R_RM: {
      result += 1; /*ModRM*/
      if (isOperandMemory(instruction.mOperands[1].mType)) {
        SMemory RM_Memory = normalizeMemory(instruction.mOperands[1].mMemory);
        result += isSIB_Required(RM_Memory);
        result += isDummyDisplacement8(RM_Memory);
        result += RM_Memory.mRegisters.size() == 0
                      ? 4
                      : getDisplacementSize(RM_Memory.mConstant, true);
        result += getSegmentSize(RM_Memory.mSegment);
      }
      break;
    }
    case SOpcode::MOFFS8: {
      result += 1;
      break;
    }
    case SOpcode::MOFFS16: {
      result += 2;
      break;
    }
    case SOpcode::MOFFS32: {
      result += 4;
      break;
    }
    case SOpcode::PB:  // +rb
    case SOpcode::PW:  // +rw
    case SOpcode::PD:  // +rd
    case SOpcode::EMPTY:
      break;
  }
  result += getOperandSize(opcode.mOperand1) +
            getOperandSize(opcode.mOperand2) + getOperandSize(opcode.mOperand3);
  return result;
}

void putInstruction(std::ostream& output,
                    const SInstruction& instruction,
                    const std::vector<SCommand>& commands,
                    uint32_t rva) {
  const SOpcode& opcode = getOpcode(instruction);

  putPrefix(output, instruction.mPrefix);

  switch (opcode.mFlag) {
    case SOpcode::R0:  // /0
    case SOpcode::R1:  // /1
    case SOpcode::R2:  // /2
    case SOpcode::R3:  // /3
    case SOpcode::R4:  // /4
    case SOpcode::R5:  // /5
    case SOpcode::R6:  // /6
    case SOpcode::R7:  // /7
    {
      SOperand normalizedRM(instruction.mOperands[0]);
      if (isOperandMemory(normalizedRM.mType)) {
        normalizedRM.mMemory =
            normalizeMemory(instruction.mOperands[0].mMemory);

        putSegment(output, normalizedRM.mMemory.mSegment);
      }

      output.write((char*)opcode.mOpcode, opcode.mOpcodeSize);

      // process first operand
      const char modRM = getModRM(normalizedRM, opcode.mFlag - SOpcode::R0);
      output.write(&modRM, 1);

      if (isOperandMemory(normalizedRM.mType)) {
        if (isSIB_Required(normalizedRM.mMemory)) {
          const char sib = getSIB(normalizedRM.mMemory);
          output.write(&sib, 1);
        }

        putDisplacement(output, normalizedRM.mMemory, commands);
      }
      break;
    }
    case SOpcode::RM_R: {
      // process both operands
      assert(instruction.mOperands.size() > 1 &&
             (instruction.mOperands[1].mType == NOperand::REG8 ||
              instruction.mOperands[1].mType == NOperand::REG16 ||
              instruction.mOperands[1].mType == NOperand::REG32));

      SOperand normalizedRM(instruction.mOperands[0]);
      if (isOperandMemory(normalizedRM.mType)) {
        normalizedRM.mMemory =
            normalizeMemory(instruction.mOperands[0].mMemory);

        putSegment(output, normalizedRM.mMemory.mSegment);
      }

      output.write((char*)opcode.mOpcode, opcode.mOpcodeSize);

      const char modRM =
          getModRM(normalizedRM, instruction.mOperands[1].mRegister);
      output.write(&modRM, 1);

      if (isOperandMemory(normalizedRM.mType)) {
        if (isSIB_Required(normalizedRM.mMemory)) {
          const char sib = getSIB(normalizedRM.mMemory);
          output.write(&sib, 1);
        }

        putDisplacement(output, normalizedRM.mMemory, commands);
      }
      break;
    }
    case SOpcode::R_RM: {
      // process both operands
      assert(instruction.mOperands.size() > 1 &&
             (instruction.mOperands[0].mType == NOperand::REG8 ||
              instruction.mOperands[0].mType == NOperand::REG16 ||
              instruction.mOperands[0].mType == NOperand::REG32));

      SOperand normalizedRM(instruction.mOperands[1]);
      if (isOperandMemory(normalizedRM.mType)) {
        normalizedRM.mMemory =
            normalizeMemory(instruction.mOperands[1].mMemory);
        putSegment(output, normalizedRM.mMemory.mSegment);
      }

      output.write((char*)opcode.mOpcode, opcode.mOpcodeSize);

      const char modRM =
          getModRM(normalizedRM, instruction.mOperands[0].mRegister);
      output.write(&modRM, 1);

      if (isOperandMemory(normalizedRM.mType)) {
        if (isSIB_Required(normalizedRM.mMemory)) {
          const char sib = getSIB(normalizedRM.mMemory);
          output.write(&sib, 1);
        }

        putDisplacement(output, normalizedRM.mMemory, commands);
      }
      break;
    }
    case SOpcode::MOFFS8: {
      break;
    }
    case SOpcode::MOFFS16: {
      break;
    }
    case SOpcode::MOFFS32: {
      break;
    }
    case SOpcode::PB:  // +rb
    case SOpcode::PW:  // +rw
    case SOpcode::PD:  // +rd
    {
      SOpcode opcodeRegister(opcode);

      if (instruction.mOperands.size() >= 1 &&
          (instruction.mOperands[0].mType == NOperand::REG8 ||
           instruction.mOperands[0].mType == NOperand::REG16 ||
           instruction.mOperands[0].mType == NOperand::REG32)) {
        opcodeRegister.mOpcode[opcodeRegister.mOpcodeSize - 1] |=
            getRegisterCode(instruction.mOperands[0].mRegister);
      }
      output.write((char*)opcodeRegister.mOpcode, opcodeRegister.mOpcodeSize);
      break;
    }
    case SOpcode::EMPTY:
      output.write((char*)opcode.mOpcode, opcode.mOpcodeSize);
      rva += opcode.mOpcodeSize;  // it needs for relative address !
      break;
  }

  if (isOperandImm(opcode.mOperand1)) {
    assert(instruction.mOperands.size() > 0 &&
           instruction.mOperands[0].mType == NOperand::CONSTANT);
    putConstant(output, opcode.mOperand1, instruction.mOperands[0].mConstant,
                commands);
  }

  if (isOperandImm(opcode.mOperand2)) {
    assert(instruction.mOperands.size() > 1 &&
           instruction.mOperands[1].mType == NOperand::CONSTANT);
    putConstant(output, opcode.mOperand2, instruction.mOperands[1].mConstant,
                commands);
  }

  if (isOperandImm(opcode.mOperand3)) {
    assert(instruction.mOperands.size() > 2 &&
           instruction.mOperands[2].mType == NOperand::CONSTANT);
    putConstant(output, opcode.mOperand3, instruction.mOperands[2].mConstant,
                commands);
  }

  if (isOperandRel(opcode.mOperand1)) {
    assert(instruction.mOperands.size() > 0 &&
           instruction.mOperands[0].mType == NOperand::CONSTANT);
    putRelativeConstant(output, opcode.mOperand1,
                        instruction.mOperands[0].mConstant, commands, rva);
  }

  if (isOperandRel(opcode.mOperand2)) {
    assert(instruction.mOperands.size() > 1 &&
           instruction.mOperands[1].mType == NOperand::CONSTANT);
    putRelativeConstant(output, opcode.mOperand2,
                        instruction.mOperands[1].mConstant, commands, rva);
  }

  if (isOperandRel(opcode.mOperand3)) {
    assert(instruction.mOperands.size() > 2 &&
           instruction.mOperands[2].mType == NOperand::CONSTANT);
    putRelativeConstant(output, opcode.mOperand3,
                        instruction.mOperands[2].mConstant, commands, rva);
  }
}
}  // namespace NPeProtector
```

`pe-protector/Instruction.h`:

```h
#pragma once

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
/**
 * @brief Get size of instruction
 * @param[in] instruction instruction
 * @return Size
 */
int getInstructionSize(const SInstruction& instruction);
/**
 * @brief Put instruction in stream
 * @param[in] output output stream
 * @param[in] instruction instruction
 * @param[in] commands commands
 * @param[in] rva offset where instruction wiil be
 */
void putInstruction(std::ostream& output,
                    const SInstruction& instruction,
                    const std::vector<SCommand>& commands,
                    uint32_t rva);
}  // namespace NPeProtector
```

`pe-protector/InstructionModRM.cpp`:

```cpp
#include "InstructionModRM.h"

#include "PeHeader.h"

#include "common/SCommand.h"

#include <assert.h>
#include <exception>

namespace NPeProtector {
namespace {
int getLabel(const SLabel& label, const std::vector<SCommand>& commands) {
  int va = 0;
  if (commands[label.mIndex].mType == NCommand::EXTERN) {
    assert(commands[label.mIndex].mData.mConstants.size() == 1);
    va = commands[label.mIndex].mData.mConstants[0].mValue;
  } else {
    va = commands[label.mIndex].mRVA + gImageBase;
  }
  return label.mSign == NSign::MINUS ? 0 - va : va;
}

int getValueSize(int value, const bool isSigned) {
  if (value == 0) {
    return 0;
  } else if (isSigned && (value >= -128 && value <= 127)) {
    return 1;
  } else if (!isSigned && ((value >= -128 && value <= 127) ||
                           (value >= 0 && value <= 0xFF))) {
    return 1;
  } else {
    return 4;
  }
}

NRegister::EType getRegisterFromCode(const int code) {
  switch (code) {
    case 0x00:
      return NRegister::EAX;
    case 0x01:
      return NRegister::ECX;
    case 0x02:
      return NRegister::EDX;
    case 0x03:
      return NRegister::EBX;
    case 0x04:
      return NRegister::ESP;
    case 0x05:
      return NRegister::EBP;
    case 0x06:
      return NRegister::ESI;
    case 0x07:
      return NRegister::EDI;
  }
  throw std::runtime_error("Failed to get register from code field");
}

char getModRM_Mod(const SOperand& rm) {
  switch (rm.mType) {
    case NOperand::REG32:
    case NOperand::REG16:
    case NOperand::REG8:
      return 0x03;
    case NOperand::MEM32:
    case NOperand::MEM16:
    case NOperand::MEM8: {
      const int numberRegistersInMemory = rm.mMemory.mRegisters.size();
      const int sizeOfDisplacement =
          getDisplacementSize(rm.mMemory.mConstant, true);
      if ((numberRegistersInMemory == 1 &&
           rm.mMemory.mRegisters[0] == NRegister::EBP &&
           sizeOfDisplacement == 0) ||
          (numberRegistersInMemory == 2 &&
           rm.mMemory.mRegisters[1] == NRegister::EBP &&
           sizeOfDisplacement == 0)) {
        // dword ptr [ebp] - There's no such instruction, it needs to use fake
        // disp8 dword ptr [eax + ebp] - There's no such instruction, it needs
        // to use fake disp8 dword ptr [2 * eax + ebp] - There's no such
        // instruction, it needs to use fake disp8
        return 0x01;
      }
      if (((sizeOfDisplacement == 0) ||
           (sizeOfDisplacement == 4 && numberRegistersInMemory == 0)) ||
          ((sizeOfDisplacement == 0) ||
           (sizeOfDisplacement == 1 && numberRegistersInMemory == 0))) {
        return 0x00;
      } else if (sizeOfDisplacement == 1) {
        return 0x01;
      } else if (sizeOfDisplacement == 4 && numberRegistersInMemory > 0) {
        return 0x02;
      }
    }
  }
  throw std::runtime_error("Failed to get modrm mod field");
}

char getModRM_RM(const SOperand& rm) {
  NRegister::EType reg = NRegister::EType(0);

  switch (rm.mType) {
    case NOperand::REG32:
    case NOperand::REG16:
    case NOperand::REG8:
      return getRegisterCode(rm.mRegister);
    case NOperand::MEM32:
    case NOperand::MEM16:
    case NOperand::MEM8:
      if (rm.mMemory.mRegisters.size() == 0) {
        return 0x05;
      } else if (rm.mMemory.mRegisters.size() == 1) {
        switch (rm.mMemory.mRegisters[0]) {
          case NRegister::EAX:
          case NRegister::AX:
          case NRegister::AL:
            return 0x00;
          case NRegister::ECX:
          case NRegister::CX:
          case NRegister::CL:
            return 0x01;
          case NRegister::EDX:
          case NRegister::DX:
          case NRegister::DL:
            return 0x02;
          case NRegister::EBX:
          case NRegister::BX:
          case NRegister::BL:
            return 0x03;
          case NRegister::ESP:
          case NRegister::SP:
          case NRegister::AH:
            return 0x04;  // point to sib byte
          case NRegister::EBP:
          case NRegister::BP:
          case NRegister::CH:
            return 0x05;
            // if (getDisplacementSize(rm.mMemory.mConstant) == 0) {
            //  return 0x04;  // point to sib byte
            //} else {
            //  return 0x05;
            // }
          case NRegister::ESI:
          case NRegister::SI:
          case NRegister::DH:
            return 0x06;
          case NRegister::EDI:
          case NRegister::DI:
          case NRegister::BH:
            return 0x07;
        }
      } else if (rm.mMemory.mRegisters.size() == 2) {
        return 0x04;  // point to sib byte
      }
  }
  throw std::runtime_error("Failed to get modrm rm field");
}

char getModRM_Reg(const NRegister::EType reg) {
  return getRegisterCode(reg);
}

char getSIB_SS(const int scale) {
  switch (scale) {
    case 0:
      return 0x00;
    case 2:
      return 0x01;
    case 4:
      return 0x02;
    case 8:
      return 0x03;
  }
  throw std::runtime_error("Failed to get sib ss field");
}

char getSIB_Index(const SMemory& memory) {
  if (memory.mRegisters.size() == 1 && memory.mRegisters[0] == NRegister::ESP) {
    return 0x04;
  } else if (memory.mRegisters.size() == 2) {
    return getRegisterCode(memory.mRegisters[0]);
  }
  throw std::runtime_error("Failed to get SIB index");
}

char getSIB_Reg(const SMemory& memory) {
  if (memory.mRegisters.size() == 1 && memory.mRegisters[0] == NRegister::ESP) {
    return 0x04;
  } else if (memory.mRegisters.size() == 2) {
    return getRegisterCode(memory.mRegisters[1]);
  }
  throw std::runtime_error("Failed to get SIB register");
}

bool isOperandMemory(const NOperand::EType type) {
  return type == NOperand::MEM8 || type == NOperand::MEM16 ||
         type == NOperand::MEM32;
}
}  // namespace

char getModRM(const SOperand& operandRM, const int code) {
  return getModRM(operandRM, getRegisterFromCode(code));
}

SMemory normalizeMemory(const SMemory& memory) {
  SMemory result(memory);

  if (memory.mRegisters.size() > 0 && memory.mRegisters[0] == NRegister::ESP &&
      memory.mScale > 0) {
    throw std::runtime_error("Impossible to create [NUMBER * ESP]");
  } else if (memory.mRegisters.size() == 2 &&
             memory.mRegisters[0] == NRegister::ESP &&
             memory.mRegisters[1] == NRegister::ESP) {
    throw std::runtime_error("Impossible to create [ESP + ESP]");
  } else if (memory.mRegisters.size() == 1 && memory.mScale > 0) {
    throw std::runtime_error("Impossible to create [NUMBER * REG]");
  } else if (memory.mRegisters.size() == 2 &&
             memory.mRegisters[0] == NRegister::ESP && memory.mScale == 0) {
    // swap registers
    result.mRegisters[1] = memory.mRegisters[0];
    result.mRegisters[0] = memory.mRegisters[1];
  }
  return result;
}

char getModRM(const SOperand& operandRM, const NRegister::EType operandReg) {
  struct SModRM {
    char mRM : 3;
    char mReg : 3;
    char mMod : 2;
  };

  SModRM modrm = {0};
  modrm.mRM = getModRM_RM(operandRM);
  modrm.mMod = getModRM_Mod(operandRM);
  modrm.mReg = getModRM_Reg(operandReg);

  assert(sizeof(modrm) == 1);
  return *(reinterpret_cast<char*>(&modrm));
}

bool isSIB_Required(const SMemory& memory) {
  return memory.mRegisters.size() == 2 ||
         (memory.mRegisters.size() == 1 &&
          memory.mRegisters[0] == NRegister::ESP);
}

char getSIB(const SMemory& memory) {
  struct SSIB {
    char mReg : 3;
    char mIndex : 3;
    char mSS : 2;
  };

  SSIB sib = {0};
  sib.mReg = getSIB_Reg(memory);
  sib.mIndex = getSIB_Index(memory);
  sib.mSS = getSIB_SS(memory.mScale);

  assert(sizeof(sib) == 1);

  return *(reinterpret_cast<char*>(&sib));
}

int getDisplacementSize(const SConstant& constant, const bool isSigned) {
  if (!constant.mLabels.empty()) {
    return 4;
  } else {
    return getValueSize(constant.mValue, isSigned);
  }
  return 0;
}

int getDisplacement(const SConstant& constant,
                    const std::vector<SCommand>& commands) {
  int result = constant.mValue;
  for (unsigned int i = 0; i < constant.mLabels.size(); ++i) {
    result += getLabel(constant.mLabels[i], commands);
  }
  return result;
}

bool isDummyDisplacement8(const SMemory& memory) {
  bool result = getDisplacementSize(memory.mConstant, true) == 0;
  if (result) {
    result = ((memory.mRegisters.size() == 1) &&
              (memory.mRegisters[0] == NRegister::EBP)) ||
             ((memory.mRegisters.size() == 2) &&
              (memory.mRegisters[1] == NRegister::EBP));
  }
  return result;
}

char getRegisterCode(const NRegister::EType reg) {
  switch (reg) {
    case NRegister::EAX:
    case NRegister::AX:
    case NRegister::AL:
      return 0x00;
    case NRegister::ECX:
    case NRegister::CX:
    case NRegister::CL:
      return 0x01;
    case NRegister::EDX:
    case NRegister::DX:
    case NRegister::DL:
      return 0x02;
    case NRegister::EBX:
    case NRegister::BX:
    case NRegister::BL:
      return 0x03;
    case NRegister::ESP:
    case NRegister::SP:
    case NRegister::AH:
      return 0x04;
    case NRegister::EBP:
    case NRegister::BP:
    case NRegister::CH:
      return 0x05;
    case NRegister::ESI:
    case NRegister::SI:
    case NRegister::DH:
      return 0x06;
    case NRegister::EDI:
    case NRegister::DI:
    case NRegister::BH:
      return 0x07;
  }
  throw std::runtime_error("Failed to get register code field");
}

}  // namespace NPeProtector

```

`pe-protector/InstructionModRM.h`:

```h
#pragma once

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
int getDisplacementSize(const SConstant& constant, const bool isSigned);
int getDisplacement(const SConstant& constant,
                    const std::vector<SCommand>& commands);

SMemory normalizeMemory(const SMemory& memory);

char getModRM(const SOperand& operandRM, const int code);
char getModRM(const SOperand& operandRM, const NRegister::EType operandReg);
char getSIB(const SMemory& memory);
bool isSIB_Required(const SMemory& memory);

bool isDummyDisplacement8(const SMemory& memory);
char getRegisterCode(const NRegister::EType reg);
}  // namespace NPeProtector
```

`pe-protector/Mutation.cpp`:

```cpp
#include "Mutation.h"

#include <assert.h>
#include <ctime>

namespace NPeProtector {
namespace {
bool isEspInMemory(const SOperand& operand) {
  if (operand.mType == NOperand::MEM16 || operand.mType == NOperand::MEM32 ||
      operand.mType == NOperand::MEM8) {
    for (unsigned int i = 0; i < operand.mMemory.mRegisters.size(); ++i) {
      if (operand.mMemory.mRegisters[i] == NRegister::ESP) {
        return true;
      }
    }
  }
  return false;
}

NRegister::EType getRandomRegisterForPushPop() {
  switch (std::rand() % 7) {
    case 0:
      return NRegister::EAX;
    case 1:
      return NRegister::EBX;
    case 2:
      return NRegister::ECX;
    case 3:
      return NRegister::EDX;
    case 4:
      return NRegister::EBP;
    case 5:
      return NRegister::ESI;
    case 6:
      return NRegister::EDI;
  }
  return NRegister::EAX;
}

std::vector<SCommand> getPushPop() {
  SCommand pushCommand;
  pushCommand.mType = NCommand::INSTRUCTION;
  pushCommand.mInstruction.mType = NInstruction::PUSH;

  SOperand regOperand;
  regOperand.mType = NOperand::REG32;
  regOperand.mRegister = getRandomRegisterForPushPop();
  pushCommand.mInstruction.mOperands.push_back(regOperand);

  SCommand popCommand;
  popCommand.mType = NCommand::INSTRUCTION;
  popCommand.mInstruction.mType = NInstruction::POP;
  popCommand.mInstruction.mOperands.push_back(regOperand);

  return {pushCommand, popCommand};
}

std::vector<SCommand> mutateCall(const SCommand& instruction,
                                 unsigned int nextCommandPosition) {
  assert(instruction.mInstruction.mOperands.size() == 1);
  std::vector<SCommand> result = {instruction};
  if (instruction.mInstruction.mOperands[0].mType != NOperand::CONSTANT) {
    SCommand pushCommand;
    pushCommand.mType = NCommand::INSTRUCTION;
    pushCommand.mNumberLine = instruction.mNumberLine;
    pushCommand.mInstruction.mType = NInstruction::PUSH;

    SOperand constOperand;
    constOperand.mType = NOperand::CONSTANT;
    SLabel label;
    label.mIndex = nextCommandPosition;
    label.mSign = NSign::PLUS;
    constOperand.mConstant.mLabels.push_back(label);

    pushCommand.mInstruction.mOperands.push_back(constOperand);

    SCommand jmpCommand;
    jmpCommand.mType = NCommand::INSTRUCTION;
    jmpCommand.mNumberLine = instruction.mNumberLine;
    jmpCommand.mInstruction.mType = NInstruction::JMP;
    jmpCommand.mInstruction.mOperands.push_back(
        instruction.mInstruction.mOperands[0]);

    result = {pushCommand, jmpCommand};
  }
  return result;
}

std::vector<SCommand> mutatePush(const SCommand& instruction) {
  assert(instruction.mInstruction.mOperands.size() == 1);

  std::vector<SCommand> result = {instruction};

  if (instruction.mInstruction.mOperands[0].mType != NOperand::REG8 &&
      !(instruction.mInstruction.mOperands[0].mType == NOperand::REG32 &&
        instruction.mInstruction.mOperands[0].mRegister == NRegister::ESP) &&
      instruction.mInstruction.mOperands[0].mType != NOperand::MEM8 &&
      instruction.mInstruction.mOperands[0].mType != NOperand::MEM16 &&
      instruction.mInstruction.mOperands[0].mType != NOperand::MEM32 &&
      !isEspInMemory(instruction.mInstruction.mOperands[0])) {
    SCommand subCommand;
    subCommand.mType = NCommand::INSTRUCTION;
    subCommand.mNumberLine = instruction.mNumberLine;
    subCommand.mInstruction.mType = NInstruction::SUB;

    SOperand espOperand;
    espOperand.mType = NOperand::REG32;
    espOperand.mRegister = NRegister::ESP;

    subCommand.mInstruction.mOperands.push_back(espOperand);

    SOperand constOperand;
    constOperand.mType = NOperand::CONSTANT;
    constOperand.mConstant.mValue = 4;

    subCommand.mInstruction.mOperands.push_back(constOperand);

    SCommand movCommand;
    movCommand.mType = NCommand::INSTRUCTION;
    movCommand.mNumberLine = instruction.mNumberLine;
    movCommand.mInstruction.mType = NInstruction::MOV;

    SOperand memOperand;
    memOperand.mType = NOperand::MEM32;
    memOperand.mMemory.mRegisters.push_back(NRegister::ESP);

    movCommand.mInstruction.mOperands.push_back(memOperand);
    movCommand.mInstruction.mOperands.push_back(
        instruction.mInstruction.mOperands[0]);

    result = {subCommand, movCommand};
  }
  return result;
}

std::vector<SCommand> mutateMov(const SCommand& instruction) {
  assert(instruction.mInstruction.mOperands.size() == 2);

  std::vector<SCommand> result = {instruction};
  if (instruction.mInstruction.mOperands[0].mType != NOperand::REG8 &&
      instruction.mInstruction.mOperands[0].mType != NOperand::MEM8 &&
      instruction.mInstruction.mOperands[1].mType != NOperand::REG8 &&
      instruction.mInstruction.mOperands[1].mType != NOperand::MEM8 &&
      !isEspInMemory(instruction.mInstruction.mOperands[0])) {
    SCommand pushCommand;
    pushCommand.mType = NCommand::INSTRUCTION;
    pushCommand.mNumberLine = instruction.mNumberLine;
    pushCommand.mInstruction.mType = NInstruction::PUSH;
    pushCommand.mInstruction.mOperands.push_back(
        instruction.mInstruction.mOperands[1]);

    SCommand popCommand;
    popCommand.mType = NCommand::INSTRUCTION;
    popCommand.mNumberLine = instruction.mNumberLine;
    popCommand.mInstruction.mType = NInstruction::POP;
    popCommand.mInstruction.mOperands.push_back(
        instruction.mInstruction.mOperands[0]);

    result = {pushCommand, popCommand};
  }
  return result;
}

void shiftConstants(std::vector<SCommand>& commands,
                    unsigned int position,
                    int shift) {
  if (shift > 0) {
    for (unsigned int i = 0; i < commands.size(); ++i) {
      if (commands[i].mType == NCommand::INSTRUCTION) {
        for (unsigned int j = 0; j < commands[i].mInstruction.mOperands.size();
             ++j) {
          // shift constant
          for (unsigned int k = 0;
               k <
               commands[i].mInstruction.mOperands[j].mConstant.mLabels.size();
               ++k) {
            if (commands[i]
                    .mInstruction.mOperands[j]
                    .mConstant.mLabels[k]
                    .mIndex > static_cast<int>(position)) {
              commands[i]
                  .mInstruction.mOperands[j]
                  .mConstant.mLabels[k]
                  .mIndex += shift;
            }
          }

          for (unsigned int k = 0; k < commands[i]
                                           .mInstruction.mOperands[j]
                                           .mMemory.mConstant.mLabels.size();
               ++k) {
            if (commands[i]
                    .mInstruction.mOperands[j]
                    .mMemory.mConstant.mLabels[k]
                    .mIndex > static_cast<int>(position)) {
              commands[i]
                  .mInstruction.mOperands[j]
                  .mMemory.mConstant.mLabels[k]
                  .mIndex += shift;
            }
          }
        }
      } else if (commands[i].mType == NCommand::DATA) {
        for (unsigned int j = 0; j < commands[i].mData.mConstants.size(); ++j) {
          for (unsigned int k = 0;
               k < commands[i].mData.mConstants[j].mLabels.size(); ++k) {
            if (commands[i].mData.mConstants[j].mLabels[k].mIndex >
                static_cast<int>(position)) {
              commands[i].mData.mConstants[j].mLabels[k].mIndex += shift;
            }
          }
        }
      }
    }
  }
}

bool isApLibCodeBegin(const SCommand& command) {
  return command.mNameLabel == "_aP_depack_asm";
}
}  // namespace
void mutateCommands(std::vector<SCommand>& commands) {
  std::srand(static_cast<unsigned int>(
      std::time(0)));  // use current time as seed for random generator

  const int mutatedStep = std::rand() % 9 + 1;

  for (unsigned int i = 0;
       i < commands.size() && !isApLibCodeBegin(commands[i]); ++i) {
    if (commands[i].mType == NCommand::INSTRUCTION) {
      switch (commands[i].mInstruction.mType) {
        case NInstruction::MOV: {
          if (std::rand() % 2 == 0) {
            const std::vector<SCommand>& mutatedCommands =
                mutateMov(commands[i]);
            if (mutatedCommands.size() > 1) {
              commands.erase(commands.begin() + i);
              commands.insert(commands.begin() + i, mutatedCommands.begin(),
                              mutatedCommands.end());

              shiftConstants(commands, i, mutatedCommands.size() - 1);
            }
            i += mutatedCommands.size() - 1;
          }
          break;
        }
        case NInstruction::PUSH: {
          if (std::rand() % 2 == 0) {
            const std::vector<SCommand>& mutatedCommands =
                mutatePush(commands[i]);
            if (mutatedCommands.size() > 1) {
              commands.erase(commands.begin() + i);
              commands.insert(commands.begin() + i, mutatedCommands.begin(),
                              mutatedCommands.end());

              shiftConstants(commands, i, mutatedCommands.size() - 1);
            }
            i += mutatedCommands.size() - 1;
          }
          break;
        }
        case NInstruction::CALL: {
          break;
        }
      }
      if (i % mutatedStep == 0 &&
          (commands[i].mInstruction.mType != NInstruction::CMP) &&
          (commands[i].mInstruction.mType != NInstruction::TEST)) {
        // insert random instructions!
        const std::vector<SCommand>& mutatedCommands = getPushPop();
        if (mutatedCommands.size() > 1) {
          commands.insert(commands.begin() + i + 1, mutatedCommands.begin(),
                          mutatedCommands.end());

          shiftConstants(commands, i + 1, mutatedCommands.size());
        }
        i += 2;
      }
    }
  }
}
}  // namespace NPeProtector

```

`pe-protector/Mutation.h`:

```h
#pragma once

#include "common/SCommand.h"

#include <vector>

namespace NPeProtector {
/**
 * @brief Mutate all assembler commands
 */
void mutateCommands(std::vector<SCommand>& commands);
}  // namespace NPeProtector
```

`pe-protector/Opcodes.cpp`:

```cpp
#include "Opcodes.h"

#include <windows.h>

namespace NPeProtector {
const SOpcode gOpcodes[] = {
#define OPCODE_FIRST(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                     operand1, operand2, operand3, flag)                   \
  {NInstruction::name,                                                     \
   opcode1,                                                                \
   opcode2,                                                                \
   opcode3,                                                                \
   opcode4,                                                                \
   opcodeSize,                                                             \
   SOpcode::operand1,                                                      \
   SOpcode::operand2,                                                      \
   SOpcode::operand3,                                                      \
   SOpcode::flag},
#define OPCODE_NEXT(name, opcode1, opcode2, opcode3, opcode4, opcodeSize, \
                    operand1, operand2, operand3, flag)                   \
  {NInstruction::name,                                                    \
   opcode1,                                                               \
   opcode2,                                                               \
   opcode3,                                                               \
   opcode4,                                                               \
   opcodeSize,                                                            \
   SOpcode::operand1,                                                     \
   SOpcode::operand2,                                                     \
   SOpcode::operand3,                                                     \
   SOpcode::flag},
#include "common/Opcodes.def"
#undef OPCODE_NEXT
#undef OPCODE_FIRST
};
const int gOpcodeSize = ARRAYSIZE(gOpcodes);
}  // namespace NPeProtector

```

`pe-protector/Opcodes.h`:

```h
#pragma once

#include "common/Types.h"

#include <windows.h>

namespace NPeProtector {
/**
 * @brief Describe assembler instruction
 */
struct SOpcode {
  enum EOperand {
    AL,
    AX,
    EAX,
    CL,
    REG8,
    REG16,
    REG32,
    MEM8,
    MEM16,
    MEM32,
    IMM1,
    IMM8,
    IMM16,
    IMM32,
    REL8,
    REL16,
    REL32,
    NON,
  };

  enum EFlag {
    RM_R,
    R_RM,
    R0,  // /0
    R1,  // /1
    R2,  // /2
    R3,  // /3
    R4,  // /4
    R5,  // /5
    R6,  // /6
    R7,  // /7
    PB,  // +rb
    PW,  // +rw
    PD,  // +rd
    MOFFS8,
    MOFFS16,
    MOFFS32,
    EMPTY,
  };

  NInstruction::EType mType;

  unsigned char mOpcode[4];
  char mOpcodeSize;

  EOperand mOperand1;
  EOperand mOperand2;
  EOperand mOperand3;

  EFlag mFlag;
};

extern const SOpcode gOpcodes[];
extern const int gOpcodeSize;

}  // namespace NPeProtector
```

`pe-protector/PeHeader.cpp`:

```cpp
#include "PeHeader.h"

#include "common/SCommand.h"
#include "common/Types.h"

#include <assert.h>
#include <string.h>
#include <windows.h>
#include <sstream>
#include <vector>

namespace NPeProtector {
namespace {
struct SMzHeader {
  IMAGE_DOS_HEADER mHeader;
  uint8_t mDosStub[9];
  uint8_t mDosMessage[47 + 8];
};

const SMzHeader sMzHeader = {
    {
        /*e_magic    */ 0x5a4d,  // Magic number
        /*e_cblp     */ 0x0090,  // Bytes on last page of file
        /*e_cp       */ 0x0003,  // Pages in file
        /*e_crlc     */ 0x0000,  // Relocations
        /*e_cparhdr  */ 0x0004,  // Size of header in paragraphs
        /*e_minalloc */ 0x0000,  // Minimum extra paragraphs needed
        /*e_maxalloc */ 0xffff,  // Maximum extra paragraphs needed
        /*e_ss       */ 0x0000,  // Initial (relative) SS value
        /*e_sp       */ 0x00b8,  // Initial SP value
        /*e_csum     */ 0x0000,  // Checksum
        /*e_ip       */ 0x0000,  // Initial IP value
        /*e_cs       */ 0x0000,  // Initial (relative) CS value
        /*e_lfarlc   */ 0x0040,  // File address of relocation table
        /*e_ovno     */ 0x0000,  // Overlay number
        /*e_res[4]   */ 0,
        0,
        0,
        0,                  // Reserved words
        /*e_oemid    */ 0,  // OEM identifier (for e_oeminfo)
        /*e_oeminfo  */ 0,  // OEM information; e_oemid specific
        /*e_res2[10] */ 0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,                          // Reserved words
        /*e_lfanew   */ 0x00000080  // File address of new exe header
    },
    {0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21},
    {'T',  'h',  'i',  's',  ' ',  'p',  'r',  'o',  'g',  'r',  'a',
     'm',  ' ',  'c',  'a',  'n',  'n',  'o',  't',  ' ',  'b',  'e',
     ' ',  'r',  'u',  'n',  ' ',  'i',  'n',  ' ',  'D',  'O',  'S',
     ' ',  'm',  'o',  'd',  'e',  0x2e, 0x0d, 0x0d, 0x0a, 0x24, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

IMAGE_NT_HEADERS32 sPeHeader = {
    /*PE*/ 0x00004550,
    {/*Machine               */ IMAGE_FILE_MACHINE_I386,
     /*NumberOfSections      */ 0,
     /*TimeDateStamp         */ 0,
     /*PointerToSymbolTable  */ 0,
     /*NumberOfSymbols       */ 0,
     /*SizeOfOptionalHeader  */ sizeof(IMAGE_OPTIONAL_HEADER32),
     /*Characteristics       */ IMAGE_FILE_EXECUTABLE_IMAGE |
         IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
         IMAGE_FILE_DEBUG_STRIPPED | IMAGE_FILE_32BIT_MACHINE},
    {/*Magic                   */ IMAGE_NT_OPTIONAL_HDR32_MAGIC,
     /*MajorLinkerVersion      */ 0x05,
     /*MinorLinkerVersion      */ 0x00,
     /*SizeOfCode              */ 0,
     /*SizeOfInitializedData   */ 0,
     /*SizeOfUninitializedData */ 0,
     /*AddressOfEntryPoint     */ 0x1000,
     /*BaseOfCode              */ 0x1000,
     /*BaseOfData              */ 0,
     /*ImageBase               */ 0x400000,
     /*SectionAlignment        */ 0x00001000,
     /*FileAlignment           */ 0x00000200,
     /*MajorOperatingSystemVersion*/ 0x0004,
     /*MinorOperatingSystemVersion*/ 0x0000,
     /*MajorImageVersion       */ 0x0000,
     /*MinorImageVersion       */ 0x0000,
     /*MajorSubsystemVersion   */ 0x0004,
     /*MinorSubsystemVersion   */ 0x0000,
     /*Win32VersionValue       */ 0,
     /*SizeOfImage             */ 0,
     /*SizeOfHeaders           */ 0x400,
     /*CheckSum                */ 0x0,
     /*Subsystem               */ IMAGE_SUBSYSTEM_WINDOWS_CUI, /*CUI TODO
                                                                replace*/
     /*DllCharacteristics      */ 0,
     /*SizeOfStackReserve      */ 0x100000,
     /*SizeOfStackCommit       */ 0x1000,
     /*SizeOfHeapReserve       */ 0x100000,
     /*SizeOfHeapCommit        */ 0x1000,
     /*LoaderFlags             */ 0,
     /*NumberOfRvaAndSizes     */ 0x10}};

int findDirective(const std::vector<SCommand>& commands,
                  const std::string& name) {
  for (unsigned int i = 0; i < commands.size(); ++i) {
    if (commands[i].mType == NCommand::DIRECTIVE &&
        commands[i].mDirective.mName == name) {
      return i;
    }
  }
  return -1;
}

int findSection(const std::vector<SCommand>& commands, const int startIndex) {
  for (unsigned int i = startIndex + 1; i < commands.size(); ++i) {
    if (commands[i].mType == NCommand::SECTION ||
        commands[i].mType == NCommand::END) {
      return i;
    }
  }
  return -1;
}

IMAGE_SECTION_HEADER getSection(const std::vector<SCommand>& commands,
                                const int sectionIndex,
                                const uint32_t sizeOfImage) {
  int a = sizeof(IMAGE_NT_HEADERS32);
  int b = sizeof(IMAGE_NT_HEADERS32);
  int c = sizeof(IMAGE_FILE_HEADER);
  IMAGE_NT_HEADERS32* pp = 0;
  void* p1 = &pp->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
                  .VirtualAddress;

  IMAGE_SECTION_HEADER result = {0};
  strncpy_s((char*)result.Name, sizeof(result.Name),
            commands[sectionIndex].mSection.mName.c_str(), sizeof(result.Name));

  const int nextSection = findSection(commands, sectionIndex);

  assert(nextSection != -1);

  result.PointerToRawData = commands[sectionIndex].mRAW;
  result.VirtualAddress = commands[sectionIndex].mRVA;
  result.SizeOfRawData =
      commands[nextSection].mRAW - commands[sectionIndex].mRAW;
  if (commands[nextSection].mType == NCommand::END &&
      commands[nextSection].mRVA < sizeOfImage) {
    result.Misc.VirtualSize = sizeOfImage - commands[sectionIndex].mRVA;
  } else {
    result.Misc.VirtualSize =
        commands[nextSection].mRVA - commands[sectionIndex].mRVA;
  }

  result.Characteristics = 0;

  if (commands[sectionIndex].mSection.mAttributes & NSectionAttributes::READ) {
    result.Characteristics |= IMAGE_SCN_MEM_READ;
  }
  if (commands[sectionIndex].mSection.mAttributes & NSectionAttributes::WRITE) {
    result.Characteristics |= IMAGE_SCN_MEM_WRITE;
  }
  if (commands[sectionIndex].mSection.mAttributes &
      NSectionAttributes::EXECUTE) {
    result.Characteristics |= IMAGE_SCN_MEM_EXECUTE;
  }
  if (commands[sectionIndex].mSection.mAttributes & NSectionAttributes::CODE) {
    result.Characteristics |= IMAGE_SCN_CNT_CODE;
  }
  if (commands[sectionIndex].mSection.mAttributes &
      NSectionAttributes::INITIALIZED) {
    result.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA;
  }

  return result;
}

std::vector<IMAGE_SECTION_HEADER> getSections(
    const std::vector<SCommand>& commands,
    uint32_t SizeOfImage) {
  std::vector<IMAGE_SECTION_HEADER> sections;

  for (unsigned int i = 0; i < commands.size(); ++i) {
    if (commands[i].mType == NCommand::SECTION) {
      sections.push_back(getSection(commands, i, SizeOfImage));
    }
  }
  return sections;
}
}  // namespace

int gImageBase = 0;

int getHeaderSize() {
  return 0x400;  // TODO
}

void putHeader(std::ostream& output,
               const std::vector<SCommand>& commands,
               const SClientFile& clientFile) {
  const std::vector<IMAGE_SECTION_HEADER>& sections =
      getSections(commands, clientFile.mImageSize);

  if (sections.empty()) {
    throw std::runtime_error("No sections");
  }

  sPeHeader.FileHeader.NumberOfSections = sections.size();
  sPeHeader.OptionalHeader.SizeOfImage =
      sections.back().VirtualAddress + sections.back().Misc.VirtualSize;
  sPeHeader.OptionalHeader.ImageBase = clientFile.mImageBase;

  const int importPosition = findDirective(commands, "IMPORT_DIRECTORY");
  if (importPosition != -1) {
    sPeHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
        .VirtualAddress = commands[importPosition].mRVA;
    sPeHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size =
        commands[importPosition].mDirective.mDirectorySize;
  }
  const int resourcePosition = findDirective(commands, "RECOURCE_DIRECTORY");
  if (resourcePosition != -1) {
    sPeHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]
        .VirtualAddress = commands[resourcePosition].mRVA;
    sPeHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]
        .Size = commands[resourcePosition].mDirective.mDirectorySize;
  }

  output.write((char*)&sMzHeader, sizeof(sMzHeader));
  output.write((char*)&sPeHeader, sizeof(sPeHeader));

  for (unsigned int i = 0; i < sections.size(); ++i) {
    output.write((char*)&sections[i], sizeof(sections[0]));
  }
}
}  // namespace NPeProtector
```

`pe-protector/PeHeader.h`:

```h
#pragma once

#include "ClientFile.h"

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
const int gSectionAlignment = 0x1000;
const int gFileAlignment = 0x200;
extern int gImageBase;

/**
 * @brief Get size of pe header
 */
int getHeaderSize();

/**
 * @brief Put header in stream
 * @param[in] output output stream
 * @param[in] commands commands
 * @param[in] clientFile it's used for size of image and image base.
 */
void putHeader(std::ostream& output,
               const std::vector<SCommand>& commands,
               const SClientFile& clientFile);
}  // namespace NPeProtector
```

`pe-protector/ProtectPe.cpp`:

```cpp
#include "ProtectPe.h"

#include "ClientFile.h"
#include "Data.h"
#include "Import.h"
#include "Instruction.h"
#include "Mutation.h"
#include "PeHeader.h"
#include "Resources.h"
#include "resource.h"

#include "common/SCommand.h"
#include "log/CLog.h"

#include <windef.h>

#include <windows.h>
#include <cassert>
#include <ostream>
#include <sstream>  // std::stringbuf
#include <string>   // std::string
#include <vector>

namespace NPeProtector {
// TODO move this
inline int align(int value, int al) {
  if (value % al) {
    value += al - (value % al);
  }
  return value;
}
namespace {
int getDirectiveSize(SDirective& directive,
                     const std::vector<SCommand>& commands,
                     const SClientFile& clientFile) {
  if (directive.mName == "IMPORT_DIRECTORY") {
    directive.mDirectorySize = getImportSize(commands);
    return directive.mDirectorySize;
  } else if (directive.mName == "RECOURCE_DIRECTORY") {
    directive.mDirectorySize = getResourcesSize(clientFile);
    return directive.mDirectorySize;
  } else if (directive.mName == "COMPRESSED_FILE") {
    return clientFile.mCompressed.size();
  } else {
    throw std::runtime_error(
        ("Failed to get directive " + directive.mName).c_str());
  }
  return 0;
}

void putDirective(std::ostream& output,
                  const std::vector<SCommand>& commands,
                  const SClientFile& clientFile,
                  const SDirective& directive,
                  const DWORD baseRVA) {
  if (directive.mName == "IMPORT_DIRECTORY") {
    putImport(output, commands, baseRVA);
  } else if (directive.mName == "RECOURCE_DIRECTORY") {
    putResources(output, commands, clientFile, baseRVA);
  } else if (directive.mName == "COMPRESSED_FILE") {
    if (!clientFile.mCompressed.empty()) {
      output.write(&clientFile.mCompressed.front(),
                   clientFile.mCompressed.size());
    }
  } else {
    throw std::runtime_error(
        ("Failed to get directive " + directive.mName).c_str());
  }
}

void resolveLabels(std::vector<SCommand>& commands,
                   const SClientFile& clientFile) {
  int nextRVA = align(getHeaderSize(), gSectionAlignment);
  int nextRAW = align(getHeaderSize(), gFileAlignment);
  int size = 0;
  for (unsigned int i = 0; i < commands.size(); ++i) {
    switch (commands[i].mType) {
      case NCommand::DIRECTIVE: {
        commands[i].mRVA = nextRVA;
        commands[i].mRAW = nextRAW;

        if (!_strcmpi(commands[i].mDirective.mName.c_str(),
                      "IMPORT_DIRECTORY")) {
          resolveImport(commands, commands[i].mRVA);
        }

        size = getDirectiveSize(commands[i].mDirective, commands, clientFile);
        nextRVA += size;
        nextRAW += size;
        break;
      }
      case NCommand::INSTRUCTION:
        commands[i].mRVA = nextRVA;
        commands[i].mRAW = nextRAW;
        size = getInstructionSize(commands[i].mInstruction);
        nextRVA += size;
        nextRAW += size;
        break;
      case NCommand::DATA:
        commands[i].mRVA = nextRVA;
        commands[i].mRAW = nextRAW;
        size = getDataSize(commands[i].mData);
        nextRVA += size;
        nextRAW += size;
        break;
      case NCommand::EXTERN:
      case NCommand::IMPORT:
        // skip
        break;
      case NCommand::SECTION:
      case NCommand::END:
        nextRVA = align(nextRVA, gSectionAlignment);
        nextRAW = align(nextRAW, gFileAlignment);
        commands[i].mRVA = nextRVA;
        commands[i].mRAW = nextRAW;
        break;
    }
  }
}
void putZeroBytes(std::ostream& output, const SCommand& command) {
  const int currentPosition = static_cast<int>(output.tellp());
  const int size = command.mRAW - currentPosition;

  assert(size >= 0);

  for (int i = 0; i < size; ++i) {
    char c = 0;
    output.write(&c, 1);
  }
}

void putBody(std::ostream& output,
             const std::vector<SCommand>& commands,
             const SClientFile& clientFile) {
  for (unsigned int i = 0; i < commands.size(); ++i) {
    switch (commands[i].mType) {
      case NCommand::DIRECTIVE:
        putDirective(output, commands, clientFile, commands[i].mDirective,
                     commands[i].mRVA);
        break;
      case NCommand::INSTRUCTION:
        putInstruction(output, commands[i].mInstruction, commands,
                       commands[i].mRVA);
        break;
      case NCommand::DATA:
        putData(output, commands[i].mData, commands);
        break;
      case NCommand::EXTERN:
      case NCommand::IMPORT:
        break;
      case NCommand::SECTION:  // section begin !
      case NCommand::END:
        putZeroBytes(output, commands[i]);
        break;
    }
  }
}

void setExterns(std::vector<SCommand>& commands,
                const SClientFile& clientFile) {
  for (unsigned int i = 0; i < commands.size(); ++i) {
    if (commands[i].mType == NCommand::EXTERN) {
      if (commands[i].mNameLabel == "externImageBase") {
        SConstant constant;
        constant.mValue = clientFile.mImageBase;
        commands[i].mData.mConstants.push_back(constant);
      } else if (commands[i].mNameLabel == "externImageSize") {
        SConstant constant;
        constant.mValue = clientFile.mImageSize;
        commands[i].mData.mConstants.push_back(constant);
      } else if (commands[i].mNameLabel == "externOEP") {
        SConstant constant;
        constant.mValue = clientFile.mOEP;
        commands[i].mData.mConstants.push_back(constant);
      }
    }
  }
}

std::vector<SCommand> loadCommands() {
  std::vector<SCommand> commands;

  const HRSRC rsrcHandle = ::FindResource(
      NULL, MAKEINTRESOURCE(RESOURCE_IDENTIFIER_COMMANDS), RT_RCDATA);
  if (rsrcHandle != 0) {
    const DWORD rsrcRawSize = ::SizeofResource(NULL, rsrcHandle);
    if (rsrcRawSize != 0) {
      const HGLOBAL rsrcPtr = ::LoadResource(NULL, rsrcHandle);
      if (rsrcPtr != 0) {
        std::istringstream inputRsrc(std::string((char*)rsrcPtr, rsrcRawSize));

        deserialize(inputRsrc, commands);
      }
    }
  }
  if (commands.empty()) {
    throw std::runtime_error("Failed to load resources");
  }
  return commands;
}
}  // namespace

void protectPe(std::ostream& output, const SClientFile& clientFile) {
  // get commands
  std::vector<SCommand> commands = loadCommands();

  // set externs
  setExterns(commands, clientFile);
  LOG_DEBUG("before:");
  loggingCommands(commands);
  // mutateCommands(commands);
  // mutateCommands(commands);
  mutateCommands(commands);
  mutateCommands(commands);

  LOG_DEBUG("after:");
  loggingCommands(commands);

  // resolveLabels - done
  resolveLabels(commands, clientFile);

  LOG_DEBUG("Resolved:");
  loggingCommands(commands);

  putHeader(output, commands, clientFile);
  putBody(output, commands, clientFile);
}
}  // namespace NPeProtector

```

`pe-protector/ProtectPe.h`:

```h
#pragma once

#include "ClientFile.h"

#include <iosfwd>

namespace NPeProtector {
/**
 * @brief Put the whole protected file in stream
 * @param[in] output output stream
 * @param[in] clientFile data of source file
 */
void protectPe(std::ostream& output, const SClientFile& clientFile);
}  // namespace NPeProtector
```

`pe-protector/Resources.cpp`:

```cpp
#include "Resources.h"

#include <assert.h>
#include <windows.h>
#include <algorithm>
#include <ostream>

namespace NPeProtector {
// TODO find good place!
inline int align(int value, int al) {
  if (value % al) {
    value += al - (value % al);
  }
  return value;
}

class CEntry {
 public:
  enum EDirectoryType {
    ROOT,
    LEVEL_1,
    LEVEL_2,
    LEVEL_3,  // keep DATA_ENTRY
    DATA_ENTRY = LEVEL_3,
  };

  CEntry(EDirectoryType level, int id)
      : mLevel(level), mId(id), mSelf(), mChildren() {}

  CEntry* get(int id) {
    for (unsigned int i = 0; i < mChildren.size(); ++i) {
      if (mChildren[i]->mId == id) {
        return mChildren[i];
      }
    }
    return 0;
  }

  void addChild(CEntry* entry) { mChildren.push_back(entry); }

  void setData(const std::vector<char>& data) {
    assert(mChildren.empty());

    mData = data;
  }

  void compile(char* buffer,
               uint32_t offset /*from root resource*/,
               uint32_t rva /*from root resource*/) {
    if (mLevel == DATA_ENTRY) {
      if (mSelf != 0) {
        mSelf->Id = mId;
        mSelf->DataIsDirectory = 0;
        mSelf->OffsetToDirectory = offset;
      }
      IMAGE_RESOURCE_DATA_ENTRY* dataEntry = (IMAGE_RESOURCE_DATA_ENTRY*)buffer;
      dataEntry->OffsetToData =
          rva + offset + sizeof(IMAGE_RESOURCE_DATA_ENTRY);
      dataEntry->Size = mData.size();

      buffer += sizeof(IMAGE_RESOURCE_DATA_ENTRY);

      memcpy(buffer, &mData.front(), mData.size());
    } else {
      if (mSelf != 0) {
        mSelf->Id = mId;
        mSelf->DataIsDirectory = 1;
        mSelf->OffsetToDirectory = offset;
      }
      IMAGE_RESOURCE_DIRECTORY* directory = (IMAGE_RESOURCE_DIRECTORY*)buffer;
      directory->NumberOfIdEntries = mChildren.size();

      IMAGE_RESOURCE_DIRECTORY_ENTRY* directoryEntry =
          (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(directory + 1);
      for (unsigned int i = 0; i < mChildren.size(); ++i) {
        mChildren[i]->mSelf = directoryEntry;
        directoryEntry++;
      }
    }
  }

  int getSize() {
    if (mLevel == DATA_ENTRY) {
      return sizeof(IMAGE_RESOURCE_DATA_ENTRY) + align(mData.size(), 0x10);
    } else {
      return sizeof(IMAGE_RESOURCE_DIRECTORY) +
             sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) * mChildren.size();
    }
  }

  bool operator<(const CEntry& right) const { return mLevel < right.mLevel; }
  friend bool isLess(CEntry* left, CEntry* right);

 private:
  const EDirectoryType mLevel;
  int mId;
  IMAGE_RESOURCE_DIRECTORY_ENTRY* mSelf;  // parent should set it!
  std::vector<CEntry*> mChildren;
  std::vector<char> mData;
};

bool isLess(CEntry* left, CEntry* right) {
  return left->mLevel < right->mLevel;
}

class CResourceDirectory {
 public:
  CResourceDirectory() : mRoot(new CEntry(CEntry::ROOT, 0)) {
    mList.push_back(mRoot);
  }

  void add(int id1, int id2, int id3, const std::vector<char>& data) {
    CEntry* entry1 = mRoot->get(id1);

    if (entry1 == 0) {
      entry1 = new CEntry(CEntry::LEVEL_1, id1);
      mRoot->addChild(entry1);
      mList.push_back(entry1);
    }

    CEntry* entry2 = entry1->get(id2);
    if (entry2 == 0) {
      entry2 = new CEntry(CEntry::LEVEL_2, id2);
      entry1->addChild(entry2);
      mList.push_back(entry2);
    }

    CEntry* entry3 = entry2->get(id3);
    if (entry3 == 0) {
      entry3 = new CEntry(CEntry::LEVEL_3, id3);
      entry2->addChild(entry3);
      mList.push_back(entry3);
    }
    entry3->setData(data);
  }

  std::vector<char> compile(const uint32_t rva) {
    const int bufferSize = getSize();
    char* const buffer = new char[bufferSize];
    memset(buffer, 0, bufferSize);
    int offset = 0;
    for (unsigned int i = 0; i < mList.size(); ++i) {
      mList[i]->compile(buffer + offset, offset, rva);
      offset += mList[i]->getSize();
    }

    assert(offset == bufferSize);

    std::vector<char> result(buffer, buffer + bufferSize);

    delete[] buffer;

    return result;
  }

  int getSize() {
    std::sort(mList.begin(), mList.end(), isLess);
    int result = 0;
    for (unsigned int i = 0; i < mList.size(); ++i) {
      result += mList[i]->getSize();
    }
    return result;
  }

 private:
  void sort() { std::sort(mList.begin(), mList.end(), isLess); }
  CEntry* mRoot;
  std::vector<CEntry*> mList;  // sort by level;
};

int getResourcesSize(const SClientFile& clientFile) {
  CResourceDirectory resourceDirectory;
  if (!clientFile.mIcons.empty()) {
    for (unsigned int i = 0; i < clientFile.mIcons.size(); ++i) {
      resourceDirectory.add(3 /*icon*/, i + 1, 0x409, clientFile.mIcons[i]);
    }
  }
  if (!clientFile.mGroupIcons.empty()) {
    resourceDirectory.add(0x0E /*group icon*/, 1, 0x409,
                          clientFile.mGroupIcons);
  }
  if (!clientFile.mManifest.empty()) {
    resourceDirectory.add(0x18 /*manifest*/, 1, 0x409, clientFile.mManifest);
  }
  return resourceDirectory.getSize();
}

void putResources(std::ostream& output,
                  const std::vector<SCommand>& commands,
                  const SClientFile& clientFile,
                  const uint32_t rva) {
  CResourceDirectory resourceDirectory;
  for (unsigned int i = 0; i < clientFile.mIcons.size(); ++i) {
    resourceDirectory.add(3 /*icon*/, i + 1, 0x409, clientFile.mIcons[i]);
  }
  if (!clientFile.mGroupIcons.empty()) {
    resourceDirectory.add(0x0E /*group icon*/, 1, 0x409,
                          clientFile.mGroupIcons);
  }
  if (!clientFile.mManifest.empty()) {
    resourceDirectory.add(0x18 /*manifest*/, 1, 0x409, clientFile.mManifest);
  }

  const std::vector<char>& resources = resourceDirectory.compile(rva);

  if (!resources.empty()) {
    output.write(&resources.front(), resources.size());
  }
}
}  // namespace NPeProtector
```

`pe-protector/Resources.h`:

```h
#pragma once

#include "ClientFile.h"

#include "common/SCommand.h"

#include <iosfwd>

namespace NPeProtector {
/**
 * @brief Get size of resources directory
 * @param[in] clientFile get icons, group icons and manifest.
 * @return Size
 */
int getResourcesSize(const SClientFile& clientFile);
/**
 * @brief Put resource directory in stream
 * @param[in] output output stream
 * @param[in] commands commands
 * @param[in] clientFile data of source file
 * @param[in] rva offset where resource directory will be
 */
void putResources(std::ostream& output,
                  const std::vector<SCommand>& commands,
                  const SClientFile& clientFile,
                  uint32_t rva);
}  // namespace NPeProtector
```

`pe-protector/main.cpp`:

```cpp
#include "ClientFile.h"
#include "PeHeader.h"
#include "ProtectPe.h"

#include "common/SCommand.h"
#include "log/CLog.h"

#include <filesystem>
#include <fstream>
#include <ios>
#include <ostream>

/**
 * @brief pe-protector.exe fileName
 */
int main(int argc, char* argv[], char* env[]) {
  int exitCode = 0;
  if (argc == 2) {
    std::error_code ec{};
    const std::filesystem::path sourceFile{argv[1]};
    const std::filesystem::path targetFile{
        std::filesystem::path{sourceFile}.replace_filename(
            std::string("protected-") + sourceFile.filename().string())};

    (void)remove(targetFile);
    std::filesystem::copy(argv[1], targetFile.string(),
                          // overwrite doen't work with MinGw gcc
                          // std::filesystem::copy_options::overwrite_existing,
                          ec);
    if (!ec) {
      try {
        const NPeProtector::SClientFile clientFile =
            NPeProtector::getPeFileInfo(targetFile.string().c_str());
        // test
        NPeProtector::gImageBase = clientFile.mImageBase;

        std::ofstream fileStream(targetFile.string(),
                                 std::ios_base::binary | std::ios_base::trunc);

        if (fileStream.is_open()) {
          LOG_INITIALIZE(std::string(argv[0]) + ".log");

          NPeProtector::protectPe(fileStream, clientFile);
        } else {
          printf("Failed to open file %s", targetFile.string().c_str());
          exitCode = 1;
        }
      } catch (const std::runtime_error& e) {
        printf("Failed to protect file, %s", e.what());
        exitCode = 1;
      }
    } else {
      printf("Failed to copy file, %s", argv[1]);
      exitCode = 1;
    }
  } else {
    printf("pe-protector.exe fileName");
  }
  return exitCode;
}

```

`pe-protector/pe-protector.rc`:

```rc
#include "resource.h"

#define RT_RCDATA 10

RESOURCE_IDENTIFIER_COMMANDS RT_RCDATA PE_PROTECTOR_STUB_BIN
```

`pe-protector/resource.h`:

```h
#define RESOURCE_IDENTIFIER_COMMANDS 999

```

`scripts/bootstrap-packages.sh`:

```sh
#!/bin/bash

# TODO cmake

# vcpkg
usage() {
  echo "Usage: $0 <vcpkg-root-folder>"
}

if [[ $1 = "-h" ]] || [[ $1 = "--help" ]]; then
  usage
  exit 0
fi

VCPKG_ROOT=${1:-./vcpkg}

git clone https://github.com/Microsoft/vcpkg.git ${VCPKG_ROOT} || exit 1

${VCPKG_ROOT}/bootstrap-vcpkg.sh || exit 1

${VCPKG_ROOT}/vcpkg install pe-parse || exit 1


```

`test/CMakeLists.txt`:

```txt
find_package(Boost REQUIRED COMPONENTS unit_test_framework)

add_executable(
  client-file-test
  ClientFileTest.cpp)

target_link_libraries(
  client-file-test
 PRIVATE
  Boost::unit_test_framework)

add_test(
 NAME
  client-file-test
 COMMAND
  client-file-test)

add_executable(
  command-test
  CommandTest.cpp)

target_link_libraries(
  command-test
 PRIVATE
  libcommon
  Boost::unit_test_framework )

add_test(
 NAME command-test
 COMMAND command-test)

add_executable(
  data-test
  DataTest.cpp)

target_link_libraries(
  data-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME data-test
 COMMAND data-test)

add_executable(
  import-test
  ImportTest.cpp)

target_link_libraries(
  import-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME import-test
 COMMAND import-test)

add_executable(
  instruction-test
  InstructionTest.cpp)

target_link_libraries(
  instruction-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME instruction-test
 COMMAND instruction-test)

add_executable(
  parser-test
  ParserTest.cpp)

target_link_libraries(
  parser-test
 PRIVATE
  libcompiler
  Boost::unit_test_framework)

add_test(
 NAME parser-test
 COMMAND parser-test)

add_executable(
  mutation-test
  MutationTest.cpp)

target_link_libraries(
  mutation-test
 PRIVATE
  Boost::unit_test_framework
  libpe-protector)

add_test(
 NAME mutation-test
 COMMAND mutation-test)

add_executable(
  pe-header-test
  PeHeaderTest.cpp)

target_link_libraries(
  pe-header-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME pe-header-test
 COMMAND pe-header-test)

add_executable(
  protect-pe-test
  ProtectPeTest.cpp)

target_link_libraries(
  protect-pe-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME protect-pe-test
 COMMAND protect-pe-test)

add_executable(
    resources-test
    ResourcesTest.cpp)

target_link_libraries(
  resources-test
 PRIVATE
  libpe-protector
  Boost::unit_test_framework)

add_test(
 NAME resources-test
 COMMAND resources-test)
```

`test/ClientFileTest.cpp`:

```cpp
#define BOOST_TEST_MODULE client file test
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_SUITE(ClientFileTest);

BOOST_AUTO_TEST_CASE(testGetPeFileInfo) {
  BOOST_TEST(true /* test assertion */);
}

BOOST_AUTO_TEST_SUITE_END();
```

`test/CommandTest.cpp`:

```cpp
#define BOOST_TEST_MODULE command test
#include <boost/test/included/unit_test.hpp>

#include "common/SCommand.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(CommandTest);

BOOST_AUTO_TEST_CASE(testSerializationExtern) {
  SCommand command;
  command.mType = NCommand::EXTERN;
  command.mNameLabel = "externImageBase";
  command.mData.mSizeData = 4;

  std::stringstream result;
  serialize(result, command);

  SCommand command2;
  deserialize(result, command2);

  BOOST_TEST(command.mType == command2.mType);
  BOOST_TEST(command.mNameLabel == command2.mNameLabel);
  BOOST_TEST(command.mData.mSizeData == command2.mData.mSizeData);
}

BOOST_AUTO_TEST_CASE(testSerializationImport) {
  SCommand command;
  command.mType = NCommand::IMPORT;
  command.mImport.mDllName = "KERNEL32.DLL";
  command.mImport.mFunctionName = "f3";

  std::stringstream result;
  serialize(result, command);

  SCommand command2;
  deserialize(result, command2);

  BOOST_TEST(command.mType == command2.mType);
  BOOST_TEST(command.mImport.mDllName == command2.mImport.mDllName);
  BOOST_TEST(command.mImport.mFunctionName == command2.mImport.mFunctionName);
}

BOOST_AUTO_TEST_CASE(testSerializationData) {
  SCommand command;
  command.mType = NCommand::DATA;

  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {
      SConstant{labels, 33}, SConstant{labels, 34}, SConstant{labels, 35}};
  command.mData = SData{"", 4, constants, 1};

  std::stringstream result;
  serialize(result, command);

  SCommand command2;
  deserialize(result, command2);

  BOOST_TEST(command.mType == command2.mType);
  BOOST_TEST(command.mData.mSizeData == command2.mData.mSizeData);
}

BOOST_AUTO_TEST_CASE(testSerializationInstruction) {
  SCommand command;
  command.mType = NCommand::INSTRUCTION;

  SOperand operand1;
  operand1.mType = NOperand::REG8;
  operand1.mRegister = NRegister::CH;

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  command.mInstruction =
      SInstruction{NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  std::stringstream result;
  serialize(result, command);

  SCommand command2;
  deserialize(result, command2);

  BOOST_TEST(command.mType == command2.mType);
  BOOST_TEST(command.mInstruction.mType == command2.mInstruction.mType);
  BOOST_TEST(command.mInstruction.mOperands[0].mType ==
             command2.mInstruction.mOperands[0].mType);
  BOOST_TEST(command.mInstruction.mOperands[1].mType ==
             command2.mInstruction.mOperands[1].mType);
}

BOOST_AUTO_TEST_SUITE_END();
```

`test/DataTest.cpp`:

```cpp
#define BOOST_TEST_MODULE data test
#include <boost/test/included/unit_test.hpp>

#include "iostream"
#include "pe-protector/Data.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(DataTest);

BOOST_AUTO_TEST_CASE(testGetDataSize1) {
  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {SConstant{labels, 10}};

  SData data{"", 1, constants, 2};

  const int size = getDataSize(data);

  BOOST_TEST(size == 2);
}  // namespace Test

BOOST_AUTO_TEST_CASE(testGetDataSize2) {
  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {SConstant{labels, 10}};

  SData data{"", 4, constants, 2};

  const int size = getDataSize(data);

  BOOST_TEST(size == 8);
}

BOOST_AUTO_TEST_CASE(testPutData1) {
  std::stringstream expectedResult;
  char characters[] = {33};
  expectedResult.write(characters, sizeof(characters));

  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {SConstant{labels, 33}};
  SData data{"", 1, constants, 1};

  std::stringstream result;

  putData(result, data, std::vector<SCommand>{});

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutData2) {
  std::stringstream expectedResult;
  char characters[] = {33, 33, 33};
  expectedResult.write(characters, sizeof(characters));

  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {SConstant{labels, 33}};
  SData data{"", 1, constants, 3};

  std::stringstream result;

  putData(result, data, std::vector<SCommand>{});

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutData3) {
  std::stringstream expectedResult;
  char characters[] = {33, 34, 35};
  expectedResult.write(characters, sizeof(characters));

  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {
      SConstant{labels, 33}, SConstant{labels, 34}, SConstant{labels, 35}};
  SData data{"", 1, constants, 1};

  std::stringstream result;

  putData(result, data, std::vector<SCommand>{});

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutData4) {
  std::stringstream expectedResult;
  DWORD characters[] = {33, 34, 35};
  expectedResult.write((char*)characters, sizeof(characters));

  std::vector<SLabel> labels;
  std::vector<SConstant> constants = {
      SConstant{labels, 33}, SConstant{labels, 34}, SConstant{labels, 35}};
  SData data{"", 4, constants, 1};

  std::stringstream result;

  putData(result, data, std::vector<SCommand>{});

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}
BOOST_AUTO_TEST_SUITE_END();
```

`test/ImportTest.cpp`:

```cpp
#define BOOST_TEST_MODULE import test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/Import.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(ImportTest);

BOOST_AUTO_TEST_CASE(testResolveImport1) {
  SCommand command1;
  command1.mType = NCommand::IMPORT;
  command1.mImport.mDllName = "dll1";
  command1.mImport.mFunctionName = "func1";

  std::vector<SCommand> commands = {
      command1,
  };

  resolveImport(commands, 0);

  BOOST_TEST(commands[0].mRVA == 48);
}

BOOST_AUTO_TEST_CASE(testResolveImport2) {
  SCommand command1;
  command1.mType = NCommand::IMPORT;
  command1.mImport.mDllName = "dll1";
  command1.mImport.mFunctionName = "func1";

  SCommand command2;
  command2.mType = NCommand::IMPORT;
  command2.mImport.mDllName = "dll2";
  command2.mImport.mFunctionName = "func2";

  std::vector<SCommand> commands = {command1, command2};

  resolveImport(commands, 0);

  BOOST_TEST(commands[0].mRVA == 76);
  BOOST_TEST(commands[1].mRVA == 84);
}

BOOST_AUTO_TEST_CASE(testGetImportSize1) {
  SCommand command1;
  command1.mType = NCommand::IMPORT;
  command1.mImport.mDllName = "dll1";
  command1.mImport.mFunctionName = "func1";

  std::vector<SCommand> commands = {command1};

  const int size = getImportSize(commands);

  BOOST_TEST(size == 69);
}

BOOST_AUTO_TEST_CASE(testGetImportSize2) {
  SCommand command1;
  command1.mType = NCommand::IMPORT;
  command1.mImport.mDllName = "dll1";
  command1.mImport.mFunctionName = "func1";

  SCommand command2;
  command2.mType = NCommand::IMPORT;
  command2.mImport.mDllName = "dll2";
  command2.mImport.mFunctionName = "func2";

  std::vector<SCommand> commands = {command1, command2};

  const int size = getImportSize(commands);

  BOOST_TEST(size == 118);
}
BOOST_AUTO_TEST_SUITE_END();
```

`test/InstructionTest.cpp`:

```cpp
#define BOOST_TEST_MODULE instruction test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/Instruction.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(InstructionTest);

BOOST_AUTO_TEST_CASE(testGetInstructionSizeNOP) {
  SInstruction instruction{NPrefix::NON, NInstruction::NOP,
                           std::vector<SOperand>{}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 1);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_REG8_IMM8) {
  SOperand operand1;
  operand1.mType = NOperand::REG8;
  operand1.mRegister = NRegister::CH;

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 3);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_MEM8_IMM81) {
  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EDX}, 0, NSegment::NON, SConstant{}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 3);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_MEM8_IMM82) {
  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP},
                             0,
                             NSegment::NON,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 7);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_MEM8_IMM83) {
  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             0,
                             NSegment::NON,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 8);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_MEM8_IMM84) {
  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             2,
                             NSegment::FS,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 9);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_MEM8_IMM85) {
  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             2,
                             NSegment::FS,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 9);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizeADD_REG32_REG32) {
  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SOperand operand2;
  operand2.mType = NOperand::REG32;
  operand2.mRegister = NRegister::EBP;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 2);
}

BOOST_AUTO_TEST_CASE(testGetInstructionSizePrefix) {
  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SOperand operand2;
  operand2.mType = NOperand::REG32;
  operand2.mRegister = NRegister::EBP;

  SInstruction instruction{
      NPrefix::REPZ, NInstruction::ADD, {operand1, operand2}};

  const int size = getInstructionSize(instruction);

  BOOST_TEST(size == 3);
}

BOOST_AUTO_TEST_CASE(testPutInstructionNOP) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x90};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SInstruction instruction{NPrefix::NON, NInstruction::NOP,
                           std::vector<SOperand>{}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_REG8_IMM8) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x80, 0xC5, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::REG8;
  operand1.mRegister = NRegister::CH;

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_MEM8_IMM81) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x80, 0x02, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EDX}, 0, NSegment::NON, SConstant{}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_MEM8_IMM82) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x80, 0x85, 0xFF, 0xFF, 0x00, 0x00, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP},
                             0,
                             NSegment::NON,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_MEM8_IMM83) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x80, 0x84, 0x28, 0xFF, 0xFF, 0x00, 0x00, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             0,
                             NSegment::NON,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_MEM8_IMM84) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x64, 0x80, 0x84, 0x68, 0xFF,
                                0xFF, 0x00, 0x00, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             2,
                             NSegment::FS,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_MEM8_IMM85) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x64, 0x80, 0x84, 0x68, 0xFF,
                                0xFF, 0x00, 0x00, 0x88};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::MEM8;
  operand1.mMemory = SMemory{{NRegister::EBP, NRegister::EAX},
                             2,
                             NSegment::FS,
                             SConstant{std::vector<SLabel>{}, 0xFFFF}};

  SOperand operand2;
  operand2.mType = NOperand::CONSTANT;
  operand2.mConstant.mValue = 0x88;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionADD_REG32_REG32) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0x01, 0xE8};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SOperand operand2;
  operand2.mType = NOperand::REG32;
  operand2.mRegister = NRegister::EBP;

  SInstruction instruction{
      NPrefix::NON, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}

BOOST_AUTO_TEST_CASE(testPutInstructionPrefix) {
  std::stringstream expectedResult;
  unsigned char characters[] = {0xF3, 0x01, 0xE8};
  expectedResult.write(reinterpret_cast<char*>(characters), sizeof(characters));

  std::stringstream result;

  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SOperand operand2;
  operand2.mType = NOperand::REG32;
  operand2.mRegister = NRegister::EBP;

  SInstruction instruction{
      NPrefix::REPZ, NInstruction::ADD, {operand1, operand2}};

  putInstruction(result, instruction, std::vector<SCommand>{}, 0);

  BOOST_TEST(result.rdbuf()->str() == expectedResult.rdbuf()->str());
}
BOOST_AUTO_TEST_SUITE_END();

```

`test/MutationTest.cpp`:

```cpp
#define BOOST_TEST_MODULE mutation test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/Mutation.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(MutationTest);

// method for testing mutateCommands with Mov instruction
BOOST_AUTO_TEST_CASE(testMutateCommandsMov) {
  // create command for testing "MOV EAX, EBX"
  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SOperand operand2;
  operand2.mType = NOperand::REG32;
  operand2.mRegister = NRegister::EBX;

  SInstruction instruction{
      NPrefix::NON, NInstruction::MOV, {operand1, operand2}};

  SCommand movCommand;
  movCommand.mType = NCommand::INSTRUCTION;
  movCommand.mInstruction = instruction;

  std::vector<SCommand> commands = {movCommand};

  // pass command "MOV EAX, EBX"
  mutateCommands(commands);

  // create instruction "PUSH EBX"
  SCommand pushCommand;
  pushCommand.mType = NCommand::INSTRUCTION;
  pushCommand.mInstruction.mType = NInstruction::PUSH;
  pushCommand.mInstruction.mOperands.push_back(operand2);

  // create instruction "POP EAX"
  SCommand popCommand;
  popCommand.mType = NCommand::INSTRUCTION;
  popCommand.mInstruction.mType = NInstruction::POP;
  popCommand.mInstruction.mOperands.push_back(operand1);

  std::vector<SCommand> expectedResult = {pushCommand, popCommand};

  // compare results
  BOOST_TEST(expectedResult[0].mType == commands[0].mType);
  BOOST_TEST(expectedResult[0].mInstruction.mType ==
             commands[0].mInstruction.mType);
  BOOST_TEST(expectedResult[0].mInstruction.mOperands[0].mType ==
             commands[0].mInstruction.mOperands[0].mType);
  BOOST_TEST(expectedResult[0].mInstruction.mOperands[0].mRegister ==
             commands[0].mInstruction.mOperands[0].mRegister);

  BOOST_TEST(expectedResult[1].mType == commands[1].mType);
  BOOST_TEST(expectedResult[1].mInstruction.mType ==
             commands[1].mInstruction.mType);
  BOOST_TEST(expectedResult[1].mInstruction.mOperands[0].mType ==
             commands[1].mInstruction.mOperands[0].mType);
  BOOST_TEST(expectedResult[1].mInstruction.mOperands[0].mRegister ==
             commands[1].mInstruction.mOperands[0].mRegister);
}

// method for testing mutateCommands with Push instruction
BOOST_AUTO_TEST_CASE(testMutateCommandsPush) {
  // create instruction "PUSH EAX"
  SOperand operand1;
  operand1.mType = NOperand::REG32;
  operand1.mRegister = NRegister::EAX;

  SInstruction instruction{NPrefix::NON, NInstruction::PUSH, {operand1}};

  SCommand pushCommand;
  pushCommand.mType = NCommand::INSTRUCTION;
  pushCommand.mInstruction = instruction;

  std::vector<SCommand> commands = {pushCommand};
  // pass instruction "PUSH EAX"
  mutateCommands(commands);

  // create instruction "SUB ESP, 4"
  SCommand subCommand;
  subCommand.mType = NCommand::INSTRUCTION;
  subCommand.mInstruction.mType = NInstruction::SUB;

  SOperand espOperand;
  espOperand.mType = NOperand::REG32;
  espOperand.mRegister = NRegister::ESP;

  subCommand.mInstruction.mOperands.push_back(espOperand);

  SOperand constOperand;
  constOperand.mType = NOperand::CONSTANT;
  constOperand.mConstant.mValue = 4;

  subCommand.mInstruction.mOperands.push_back(constOperand);

  // create instruction "MOV DWORD PTR [ESP], EAX"
  SCommand movCommand;
  movCommand.mType = NCommand::INSTRUCTION;
  movCommand.mInstruction.mType = NInstruction::MOV;

  SOperand memOperand;
  memOperand.mType = NOperand::MEM32;
  memOperand.mMemory.mRegisters.push_back(NRegister::ESP);

  movCommand.mInstruction.mOperands.push_back(memOperand);
  movCommand.mInstruction.mOperands.push_back(operand1);

  std::vector<SCommand> expectedResult = {subCommand, movCommand};

  // compare results
  BOOST_TEST(expectedResult[0].mType == commands[0].mType);
  BOOST_TEST(expectedResult[0].mInstruction.mType ==
             commands[0].mInstruction.mType);
  BOOST_TEST(expectedResult[0].mInstruction.mOperands[0].mType ==
             commands[0].mInstruction.mOperands[0].mType);

  BOOST_TEST(expectedResult[1].mType == commands[1].mType);
  BOOST_TEST(expectedResult[1].mInstruction.mType ==
             commands[1].mInstruction.mType);
  BOOST_TEST(expectedResult[1].mInstruction.mOperands[0].mType ==
             commands[1].mInstruction.mOperands[0].mType);
}
BOOST_AUTO_TEST_SUITE_END();
```

`test/ParserTest.cpp`:

```cpp
#define BOOST_TEST_MODULE parser test
#include <boost/test/included/unit_test.hpp>

#include "compiler/Parser.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(ParserTest);

BOOST_AUTO_TEST_CASE(testParserComments) {
  std::stringstream input;
  input << ";23\n  ;1\n  ;12";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands.size() == 1);
  BOOST_TEST(commands[0].mType == NCommand::END);
}

BOOST_AUTO_TEST_CASE(testParserImport) {
  std::stringstream input;
  input << "IMPORT KERNEL32.GetTickCount";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::IMPORT);
  BOOST_TEST(commands[0].mImport.mDllName == "KERNEL32.dll");
  BOOST_TEST(commands[0].mImport.mFunctionName == "GetTickCount");
}

BOOST_AUTO_TEST_CASE(testParserData1) {
  std::stringstream input;
  input << "name DD 123";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::DATA);
  BOOST_TEST(commands[0].mData.mName == "name");
  BOOST_TEST(commands[0].mData.mCount == 1);
  BOOST_TEST(commands[0].mData.mConstants[0].mValue == 123);
  BOOST_TEST(commands[0].mData.mSizeData == 4);
}

BOOST_AUTO_TEST_CASE(testParserData2) {
  std::stringstream input;
  input << "name DWORD 123";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::DATA);
  BOOST_TEST(commands[0].mData.mName == "name");
  BOOST_TEST(commands[0].mData.mCount == 1);
  BOOST_TEST(commands[0].mData.mConstants[0].mValue == 123);
  BOOST_TEST(commands[0].mData.mSizeData == 4);
}

BOOST_AUTO_TEST_CASE(testParserDataString) {
  std::stringstream input;
  input << "szLoadLibrary DB \"LoadLibraryA\"";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::DATA);
  BOOST_TEST(commands[0].mData.mName == "szLoadLibrary");
  BOOST_TEST(commands[0].mData.mCount == 1);
  BOOST_TEST(commands[0].mData.mConstants.size() == 12);
  BOOST_TEST(commands[0].mData.mConstants[0].mValue == (DWORD)'L');
  BOOST_TEST(commands[0].mData.mConstants[1].mValue == (DWORD)'o');
  BOOST_TEST(commands[0].mData.mConstants[2].mValue == (DWORD)'a');
  BOOST_TEST(commands[0].mData.mConstants[3].mValue == (DWORD)'d');
  BOOST_TEST(commands[0].mData.mSizeData == 1);
}

BOOST_AUTO_TEST_CASE(testParserDataCount) {
  std::stringstream input;
  input << "name DB 1, 2, 10h";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::DATA);
  BOOST_TEST(commands[0].mData.mName == "name");
  BOOST_TEST(commands[0].mData.mCount == 1);
  BOOST_TEST(commands[0].mData.mConstants[0].mValue == 1);
  BOOST_TEST(commands[0].mData.mConstants[1].mValue == 2);
  BOOST_TEST(commands[0].mData.mConstants[2].mValue == 0x10);
  BOOST_TEST(commands[0].mData.mSizeData == 1);
}

BOOST_AUTO_TEST_CASE(testParserDataDup) {
  std::stringstream input;
  input << "testDup db 30 dup (80h)";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::DATA);
  BOOST_TEST(commands[0].mData.mName == "testDup");
  BOOST_TEST(commands[0].mData.mConstants.size() == 1);
  BOOST_TEST(commands[0].mData.mConstants[0].mValue == 0x80);
  BOOST_TEST(commands[0].mData.mSizeData == 1);
  BOOST_TEST(commands[0].mData.mCount == 30);
}
BOOST_AUTO_TEST_CASE(testParserSection) {
  std::stringstream input;
  input << "SECTION \".text\" crwei";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::SECTION);
  BOOST_TEST(commands[0].mSection.mName == ".text");
  BOOST_TEST((commands[0].mSection.mAttributes & NSectionAttributes::CODE) !=
             0);
  BOOST_TEST((commands[0].mSection.mAttributes & NSectionAttributes::READ) !=
             0);
  BOOST_TEST((commands[0].mSection.mAttributes & NSectionAttributes::EXECUTE) !=
             0);
  BOOST_TEST((commands[0].mSection.mAttributes & NSectionAttributes::WRITE) !=
             0);
  BOOST_TEST((commands[0].mSection.mAttributes &
              NSectionAttributes::INITIALIZED) != 0);
}

BOOST_AUTO_TEST_CASE(testParserInstruction) {
  std::stringstream input;
  input << "MOV EAX, DWORD PTR [EAX + 0CH]";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::INSTRUCTION);
  BOOST_TEST(commands[0].mInstruction.mType == NInstruction::MOV);
  BOOST_TEST(commands[0].mInstruction.mOperands.size() == 2);
  BOOST_TEST(commands[0].mInstruction.mOperands[0].mType == NOperand::REG32);
  BOOST_TEST(commands[0].mInstruction.mOperands[0].mRegister == NRegister::EAX);
  BOOST_TEST(commands[0].mInstruction.mOperands[1].mType == NOperand::MEM32);
  BOOST_TEST(commands[0].mInstruction.mOperands[1].mMemory.mRegisters[0] ==
             NRegister::EAX);
  BOOST_TEST(commands[0].mInstruction.mOperands[1].mMemory.mConstant.mValue ==
             0x0C);
}

BOOST_AUTO_TEST_CASE(testParserExtern) {
  std::stringstream input;
  input << "EXTERN DD externImageBase";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::EXTERN);
  BOOST_TEST(commands[0].mNameLabel == "externImageBase");
  BOOST_TEST(commands[0].mData.mSizeData == 4);
}

BOOST_AUTO_TEST_CASE(testParserLabel1) {
  std::stringstream input;
  input << "labelName: NOP";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::INSTRUCTION);
  BOOST_TEST(commands[0].mInstruction.mType == NInstruction::NOP);
}

BOOST_AUTO_TEST_CASE(testParserLabel2) {
  std::stringstream input;
  input << "labelName: \n\n NOP";

  const std::vector<SCommand>& commands = parse(input);

  BOOST_TEST(commands[0].mType == NCommand::INSTRUCTION);
  BOOST_TEST(commands[0].mInstruction.mType == NInstruction::NOP);
}

BOOST_AUTO_TEST_SUITE_END();
```

`test/PeHeaderTest.cpp`:

```cpp
#define BOOST_TEST_MODULE pe header test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/PeHeader.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(PeHeaderTest);
BOOST_AUTO_TEST_CASE(testGetHeaderSize) {
  BOOST_TEST(0x400 == getHeaderSize());
}
BOOST_AUTO_TEST_SUITE_END();

```

`test/ProtectPeTest.cpp`:

```cpp
#define BOOST_TEST_MODULE protect pe test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/PeHeader.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(ProtectPeTest);
BOOST_AUTO_TEST_CASE(testProtectPe) {
  // TODO: Your test code here
}
BOOST_AUTO_TEST_SUITE_END();
```

`test/ResourcesTest.cpp`:

```cpp
#define BOOST_TEST_MODULE resources test
#include <boost/test/included/unit_test.hpp>

#include "pe-protector/ClientFile.h"
#include "pe-protector/Resources.h"

using namespace NPeProtector;

BOOST_AUTO_TEST_SUITE(ResourcesTest);
BOOST_AUTO_TEST_CASE(testGetResourcesSizeEmpty) {
  SClientFile clientFile;
  const int size = getResourcesSize(clientFile);
  BOOST_TEST(size == 16);
}

BOOST_AUTO_TEST_CASE(testGetResourcesSizeManifest) {
  SClientFile clientFile;
  clientFile.mManifest = {1, 2, 3};

  const int size = getResourcesSize(clientFile);
  BOOST_TEST(size == 104);
}

BOOST_AUTO_TEST_CASE(testGetResourcesSizeIconds) {
  SClientFile clientFile;
  clientFile.mIcons = {{1, 2, 3}, {4, 5, 6}};
  clientFile.mGroupIcons = {1, 2, 3};

  const int size = getResourcesSize(clientFile);
  BOOST_TEST(size == 256);
}

BOOST_AUTO_TEST_CASE(testGetResourcesSizeAll) {
  SClientFile clientFile;
  clientFile.mIcons = {{1, 2, 3}, {4, 5, 6}};
  clientFile.mGroupIcons = {1, 2, 3};
  clientFile.mManifest = {1, 2, 3};

  const int size = getResourcesSize(clientFile);
  BOOST_TEST(size == 344);
}
BOOST_AUTO_TEST_SUITE_END();
```

`vcpkg.json`:

```json
{
    "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
    "name": "pe-protector",
    "version": "0.0.1",
    "dependencies": [
        "boost",
        "range-v3"
    ]
}
```