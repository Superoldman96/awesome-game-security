Project Path: arc_gmh5225_Rust-Cheat-External-main_4zu33osr

Source Tree:

```txt
arc_gmh5225_Rust-Cheat-External-main_4zu33osr
├── Driver
│   ├── Rust External - Driver.cpp
│   ├── Rust External - Driver.vcxproj
│   ├── Rust External - Driver.vcxproj.filters
│   ├── import.h
│   └── skCrypt.h
├── Driver.sln
├── Hack.sln
├── README.md
└── UserMode
    ├── DirectOverlay.h
    ├── Driver
    │   ├── driver.cpp
    │   └── driver.h
    ├── Includes.h
    ├── Main.cpp
    ├── Main.h
    ├── Menu.h
    ├── Of.h
    ├── Overlay.cpp
    ├── Overlay.h
    ├── Process
    │   └── Process.h
    ├── Rust External - Client.vcxproj
    ├── Rust External - Client.vcxproj.filters
    ├── SDK
    │   ├── Aim.h
    │   ├── BasePlayer.h
    │   ├── BaseProjectile.h
    │   ├── Math.h
    │   └── Misc.h
    ├── Value.h
    ├── common.h
    ├── lib
    │   └── D2DOverlay.lib
    └── skCrypt.h

```

`Driver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Rust External - Driver.vcxproj", "{0AD55F93-C65D-4BEE-928C-821276511209}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM.ActiveCfg = Debug|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM.Build.0 = Debug|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM.Deploy.0 = Debug|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM64.Build.0 = Debug|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x64.ActiveCfg = Debug|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x64.Build.0 = Debug|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x64.Deploy.0 = Debug|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x86.ActiveCfg = Debug|Win32
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x86.Build.0 = Debug|Win32
		{0AD55F93-C65D-4BEE-928C-821276511209}.Debug|x86.Deploy.0 = Debug|Win32
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM.ActiveCfg = Release|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM.Build.0 = Release|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM.Deploy.0 = Release|ARM
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM64.ActiveCfg = Release|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM64.Build.0 = Release|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|ARM64.Deploy.0 = Release|ARM64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x64.ActiveCfg = Release|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x64.Build.0 = Release|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x64.Deploy.0 = Release|x64
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x86.ActiveCfg = Release|Win32
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x86.Build.0 = Release|Win32
		{0AD55F93-C65D-4BEE-928C-821276511209}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2B192FFD-962F-4B3F-AC3A-20EE324C54C3}
	EndGlobalSection
EndGlobal

```

`Driver/Rust External - Driver.cpp`:

```cpp
#include "import.h"
#include "skCrypt.h"

#include <ntifs.h>

extern "C" {
	NTKERNELAPI NTSTATUS IoCreateDriver(PUNICODE_STRING DriverName, PDRIVER_INITIALIZE InitializationFunction);
	NTKERNELAPI NTSTATUS MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
}

constexpr ULONG init_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x775, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
constexpr ULONG read_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x776, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
constexpr ULONG write_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x777, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);

ULONG64 get_module_base_x64(PEPROCESS proc, UNICODE_STRING module_name) {
	PPEB pPeb = PsGetProcessPeb(proc);

	if (!pPeb) {
		return 0; 
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

	if (!pLdr) {
		KeUnstackDetachProcess(&state);
		return 0; 
	}

	
	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InMemoryOrderModuleList.Flink;
		list != &pLdr->InMemoryOrderModuleList; list = (PLIST_ENTRY)list->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}
	KeUnstackDetachProcess(&state);

	return 0;
}


struct info_t {
	HANDLE target_pid = 0;
	void* target_address = 0x0;
	void* buffer_address = 0x0;
	SIZE_T size = 0;
	SIZE_T return_size = 0;
	UINT64 GA = 0;
	UINT64 UP = 0;
};

NTSTATUS ctl_io(PDEVICE_OBJECT device_obj, PIRP irp) {
	UNREFERENCED_PARAMETER(device_obj);

	static PEPROCESS s_target_process;

	irp->IoStatus.Information = sizeof(info_t);
	auto stack = IoGetCurrentIrpStackLocation(irp);
	auto buffer = (info_t*)irp->AssociatedIrp.SystemBuffer;

	if (stack) {
		if (buffer && sizeof(*buffer) >= sizeof(info_t)) {
			const auto ctl_code = stack->Parameters.DeviceIoControl.IoControlCode;

			if (ctl_code == init_code) {
				PsLookupProcessByProcessId(buffer->target_pid, &s_target_process);

				ANSI_STRING GA;
				UNICODE_STRING GAA;

				RtlInitAnsiString(&GA, skCrypt("GameAssembly.dll"));
				RtlAnsiStringToUnicodeString(&GAA, &GA, TRUE);

				buffer->GA = get_module_base_x64(s_target_process, GAA);

				ANSI_STRING UP;
				UNICODE_STRING UPA;

				RtlInitAnsiString(&UP, skCrypt("UnityPlayer.dll"));
				RtlAnsiStringToUnicodeString(&UPA, &UP, TRUE);

				buffer->UP = get_module_base_x64(s_target_process, UPA);
				if (!buffer->UP)
					buffer->UP = 1337;
			}
			else if (ctl_code == read_code)
				MmCopyVirtualMemory(s_target_process, buffer->target_address, PsGetCurrentProcess(), buffer->buffer_address, buffer->size, KernelMode, &buffer->return_size);

			else if (ctl_code == write_code)
				MmCopyVirtualMemory(PsGetCurrentProcess(), buffer->buffer_address, s_target_process, buffer->target_address, buffer->size, KernelMode, &buffer->return_size);
		}
	}

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS unsupported_io(PDEVICE_OBJECT device_obj, PIRP irp) {
	UNREFERENCED_PARAMETER(device_obj);

	irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

NTSTATUS create_io(PDEVICE_OBJECT device_obj, PIRP irp) {
	UNREFERENCED_PARAMETER(device_obj);

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

NTSTATUS close_io(PDEVICE_OBJECT device_obj, PIRP irp) {
	UNREFERENCED_PARAMETER(device_obj);

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

NTSTATUS real_main(PDRIVER_OBJECT driver_obj, PUNICODE_STRING registery_path) {
	UNREFERENCED_PARAMETER(registery_path);

	UNICODE_STRING dev_name, sym_link;
	PDEVICE_OBJECT dev_obj;

	RtlInitUnicodeString(&dev_name, skCrypt(L"\\Device\\AUzwL9x61HxK"));
	auto status = IoCreateDevice(driver_obj, 0, &dev_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &dev_obj);
	if (status != STATUS_SUCCESS) return status;

	RtlInitUnicodeString(&sym_link, skCrypt(L"\\DosDevices\\AUzwL9x61HxK"));
	status = IoCreateSymbolicLink(&sym_link, &dev_name);
	if (status != STATUS_SUCCESS) return status;

	SetFlag(dev_obj->Flags, DO_BUFFERED_IO);

	for (int t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
		driver_obj->MajorFunction[t] = unsupported_io;


	driver_obj->MajorFunction[IRP_MJ_CREATE] = create_io;
	driver_obj->MajorFunction[IRP_MJ_CLOSE] = close_io;
	driver_obj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ctl_io;
	driver_obj->DriverUnload = NULL; //add later

	ClearFlag(dev_obj->Flags, DO_DEVICE_INITIALIZING);
	return status;
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT driver_obj, PUNICODE_STRING registery_path) {
	UNREFERENCED_PARAMETER(driver_obj);
	UNREFERENCED_PARAMETER(registery_path);

	UNICODE_STRING  drv_name;
	RtlInitUnicodeString(&drv_name, skCrypt(L"\\Driver\\cartidriver"));
	IoCreateDriver(&drv_name, &real_main);

	return STATUS_SUCCESS;
}
```

`Driver/Rust External - Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0AD55F93-C65D-4BEE-928C-821276511209}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>kernel_socket_server</RootNamespace>
    <ProjectName>Driver</ProjectName>
    <WindowsTargetPlatformVersion>10.0.22621.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <CharacterSet>MultiByte</CharacterSet>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>C:\My Librirary;$(IncludePath)</IncludePath>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Rust External - Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="import.h" />
    <ClInclude Include="skCrypt.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Driver/Rust External - Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Rust External - Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="socket">
      <UniqueIdentifier>{9fd3cdb1-3c98-4d93-9d2f-a645c0d8829a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Driver">
      <UniqueIdentifier>{21e95858-604a-407a-9903-6069690bcbda}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="import.h" />
    <ClInclude Include="skCrypt.h" />
  </ItemGroup>
</Project>
```

`Driver/import.h`:

```h
#pragma once
#include <ntifs.h>
#include <minwindef.h>
#include <ntddk.h>

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;
typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;
typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;
const int IMAGE_SIZEOF_SHORT_NAME = 8;
typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;
typedef struct _IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD                 Magic;
	BYTE                 MajorLinkerVersion;
	BYTE                 MinorLinkerVersion;
	DWORD                SizeOfCode;
	DWORD                SizeOfInitializedData;
	DWORD                SizeOfUninitializedData;
	DWORD                AddressOfEntryPoint;
	DWORD                BaseOfCode;
	ULONGLONG            ImageBase;
	DWORD                SectionAlignment;
	DWORD                FileAlignment;
	WORD                 MajorOperatingSystemVersion;
	WORD                 MinorOperatingSystemVersion;
	WORD                 MajorImageVersion;
	WORD                 MinorImageVersion;
	WORD                 MajorSubsystemVersion;
	WORD                 MinorSubsystemVersion;
	DWORD                Win32VersionValue;
	DWORD                SizeOfImage;
	DWORD                SizeOfHeaders;
	DWORD                CheckSum;
	WORD                 Subsystem;
	WORD                 DllCharacteristics;
	ULONGLONG            SizeOfStackReserve;
	ULONGLONG            SizeOfStackCommit;
	ULONGLONG            SizeOfHeapReserve;
	ULONGLONG            SizeOfHeapCommit;
	DWORD                LoaderFlags;
	DWORD                NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;
typedef struct _IMAGE_NT_HEADERS64 {
	DWORD                   Signature;
	IMAGE_FILE_HEADER       FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;
extern "C"
{
	NTKERNELAPI NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

	NTKERNELAPI NTSTATUS MmCopyVirtualMemory(
		IN PEPROCESS		SourceProcess,
		IN PVOID			SourceAddress,
		IN PEPROCESS		TargetProcess,
		IN PVOID			TargetAddress,
		IN SIZE_T			BufferSize,
		IN KPROCESSOR_MODE  PreviousMode,
		OUT PSIZE_T			ReturnSize
	);

	NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(
		IN HANDLE			ProcessId,
		OUT PEPROCESS* Process
	);

	NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process(IN PEPROCESS Process);
	NTKERNELAPI PPEB NTAPI PsGetProcessPeb(IN PEPROCESS Process);

	NTKERNELAPI NTSTATUS ObReferenceObjectByName(PUNICODE_STRING ObjectName, ULONG Attributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext, PVOID* Object);
	NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(IN PVOID ModuleAddress);
	NTKERNELAPI
		PVOID
		PsGetProcessSectionBaseAddress(
			__in PEPROCESS Process
		);

}

struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};
typedef struct _SYSTEM_MODULE   // Information Class 11
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;
typedef struct _SYSTEM_MODULE_INFORMATION   // Information Class 11
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

```

`Driver/skCrypt.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`Hack.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Hack", "UserMode\Rust External - Client.vcxproj", "{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Debug|x64.ActiveCfg = Debug|x64
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Debug|x64.Build.0 = Debug|x64
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Debug|x86.ActiveCfg = Debug|Win32
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Debug|x86.Build.0 = Debug|Win32
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Release|x64.ActiveCfg = Release|x64
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Release|x64.Build.0 = Release|x64
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Release|x86.ActiveCfg = Release|Win32
		{1EA6BF6F-C2F1-44AA-B3B7-F3816DB34C3A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FF885B5C-9332-42D3-9110-D5BC45A5A12A}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# Rust-Cheat-External-main
 author removed original repo.

P.S. Its not my project....

```

`UserMode/DirectOverlay.h`:

```h
/*
	Direct2D Overlay by Coltonon
	Simple library used to make a Direct2d overlay over any application quickly.
	Simply set up your drawing loop, and initialize the overlay.

	Sample use:

-----------------------------------------------------------------------------------------
	#include "DirectOverlay.h"

	void drawLoop(int width, int height) {  // our loop to render in
		DrawString("The quick brown fox jumped over the lazy dog", 48, 100, 20, 0, 1, 1);
	}

	int main(){
		DirectOverlaySetOption(D2DOV_DRAW_FPS | D2DOV_FONT_IMPACT);	// set the font, and draw the fps
		DirectOverlaySetup(drawLoop);		// initialize our overlay
		getchar();	// The overlay operates in it's own thread, ours will continue as normal
	}
-----------------------------------------------------------------------------------------

	The #defines are settings for the window, pass them to the DirectOverlaySetOption function.
	You may OR them together '|', you must set them before calling DirectOverlaySetup.

*/

#include <Windows.h>
#include <string>

// Link the static library (make sure that file is in the same directory as this file)
#pragma comment(lib, "D2DOverlay.lib")

// Requires the targetted window to be active and the foreground window to draw.
#define D2DOV_REQUIRE_FOREGROUND	(1 << 0)

// Draws the FPS of the overlay in the top-right corner
#define D2DOV_DRAW_FPS				(1 << 1)

// Attempts to limit the frametimes so you don't render at 500fps
#define D2DOV_VSYNC					(1 << 2)

// Sets the text font to Calibri
#define D2DOV_FONT_CALIBRI			(1 << 3)

// Sets the text font to Arial
#define D2DOV_FONT_ARIAL			(1 << 4)

// Sets the text font to Courier
#define D2DOV_FONT_COURIER			(1 << 5)

// Sets the text font to Gabriola
#define D2DOV_FONT_GABRIOLA			(1 << 6)

// Sets the text font to Impact
#define D2DOV_FONT_IMPACT			(1 << 7)

// The function you call to set up the above options.  Make sure its called before the DirectOverlaySetup function
void DirectOverlaySetOption(DWORD option);

// typedef for the callback function, where you'll do the drawing.
typedef void(*DirectOverlayCallback)(int width, int height);

// Initializes a the overlay window, and the thread to run it.  Input your callback function.
// Uses the first window in the current process to target.  If you're external, use the next function
void DirectOverlaySetup(DirectOverlayCallback callbackFunction);

// Used to specify the window manually, to be used with externals.
void DirectOverlaySetup(DirectOverlayCallback callbackFunction, HWND targetWindow);

// Draws a line from (x1, y1) to (x2, y2), with a specified thickness.
// Specify the color, and optionally an alpha for the line.
void DrawLine(float x1, float y1, float x2, float y2, float thickness, float r, float g, float b, float a = 1);

// Draws a rectangle on the screen.  Width and height are relative to the coordinates of the box.  
// Use the "filled" bool to make it a solid rectangle; ignore the thickness.
// To just draw the border around the rectangle, specify a thickness and pass "filled" as false.
void DrawBox(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draws a circle.  As with the DrawBox, the "filled" bool will make it a solid circle, and thickness is only used when filled=false.
void DrawCircle(float x, float y, float radius, float thickness, float r, float g, float b, float a, bool filled);

// Allows you to draw an elipse.  Same as a circle, except you have two different radii, for width and height.
void DrawEllipse(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draw a string on the screen.  Input is in the form of an std::string.
void DrawString(std::string str, float fontSize, float x, float y, float r, float g, float b, float a = 1);
```

`UserMode/Driver/driver.cpp`:

```cpp
//#include "Driver.h"
//
//
//CDriverAPI::CDriverAPI(ULONG PID)
//	:
//	m_PID(PID)
//{}
//
//void CDriverAPI::ReadArr(uintptr_t Addr, PVOID Data, ULONG Size)
//{
//	IOCOMMAND IO_Data;
//	IO_Data.NameHash = 'LKZR';
//	IO_Data.CommandID = IO_CMD::CMD_READ_VM;
//	IO_Data.ProcessID = this->m_PID;
//	IO_Data.Src = (ULONG64)Addr;
//	IO_Data.Dst = (ULONG64)Data;
//	IO_Data.CopySize = Size;
//
//	auto requestPtr = &IO_Data;
//
//	auto status = 0ULL;
//	NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//	//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	//	MemoryAPI::SysCall<NTSTATUS>(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//}
//
//void CDriverAPI::WriteArr(uintptr_t Addr, PVOID Data, ULONG Size)
//{
//	IOCOMMAND IO_Data;
//	IO_Data.NameHash = 'LKZR';
//	IO_Data.CommandID = IO_CMD::CMD_WRITE_VM;
//	IO_Data.ProcessID = this->m_PID;
//	IO_Data.Src = (ULONG64)Data;
//	IO_Data.Dst = (ULONG64)Addr;
//	IO_Data.CopySize = Size;
//
//	auto requestPtr = &IO_Data;
//
//	auto status = 0ULL;
//	NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//	//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	//	MemoryAPI::SysCall<NTSTATUS>(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//}
//
//CDriverAPI::MODINFO CDriverAPI::GetModInfo(const char* ModName)
//{
//	IOCOMMAND IO_Data;
//	IO_Data.NameHash = 'LKZR';
//	IO_Data.ProcessID = this->m_PID;
//	IO_Data.CommandID = IO_CMD::CMD_GET_MOD_INFO;
//
//	MODINFO ModBase = { 0, 0 };
//	IO_Data.Src = (ULONG64)ModName;
//	IO_Data.Dst = (ULONG64)&ModBase;
//
//	auto requestPtr = &IO_Data;
//
//	auto status = 0ULL;
//	NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//	//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	//	MemoryAPI::SysCall<NTSTATUS>(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//
//	return ModBase;
//}
//
//bool CDriverAPI::IsDriverLoaded()
//{
//	ULONG64 Dst = 0;
//	IOCOMMAND IO_Data;
//	IO_Data.NameHash = 'LKZR';
//	IO_Data.ProcessID = GetCurrentProcessId();
//	IO_Data.CommandID = IO_CMD::CMD_CHECKSTATUS;
//	IO_Data.Src = 5;
//	IO_Data.Dst = (ULONG64)&Dst;
//
//	auto requestPtr = &IO_Data;
//	auto status = 0ULL;
//	NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//
//	//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	//	MemoryAPI::SysCall<NTSTATUS>(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//
//	return Dst == IO_Data.Src * IO_Data.Src;
//}
//
//CDriverAPI Driver;

```

`UserMode/Driver/driver.h`:

```h
//#pragma once
//#include "..\Main.h"
//using ProcCBACAPC = PVOID(NTAPI*)(PVOID, PVOID, PVOID, PVOID);
//extern ProcCBACAPC NtConvertBetweenAuxiliaryCounterAndPerformanceCounter;
//
//class CDriverAPI
//{
//	enum IO_CMD : ULONG
//	{
//		CMD_NONE = 0x100000,
//		CMD_READ_VM = 0x200000,
//		CMD_WRITE_VM = 0x300000,
//		CMD_GET_MOD_INFO = 0x600000,
//		CMD_CHECKSTATUS = 0x900000
//	};
//
//	struct IOCOMMAND
//	{
//		ULONG NameHash;
//		ULONG ProcessID;
//		ULONG CommandID;
//		ULONG64 Src, Dst;
//		ULONG CopySize;
//		DWORD Unique = 0x1234;
//	};
//
//public:
//	struct MODINFO
//	{
//		ULONG64 ModBase;
//		ULONG ModSize;
//	};
//
//	CDriverAPI() = default;
//	CDriverAPI(ULONG PID);
//
//	//read vm
//	template <typename T>
//	T Read(uintptr_t Addr)
//	{
//		T ReadData{};
//		IOCOMMAND IO_Data;
//		IO_Data.NameHash = 'LKZR';
//		IO_Data.CommandID = IO_CMD::CMD_READ_VM;
//		IO_Data.ProcessID = this->m_PID;
//		IO_Data.Src = (ULONG64)Addr;
//		IO_Data.Dst = (ULONG64)&ReadData;
//		IO_Data.CopySize = sizeof(T);
//
//		//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//		//MemoryAPI::SysCall(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//
//		auto requestPtr = &IO_Data;
//
//		auto status = 0ULL;
//		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//
//		return ReadData;
//	}
//
//	void ReadArr(uintptr_t Addr, PVOID Data, ULONG Size);
//	void WriteArr(uintptr_t Addr, PVOID Data, ULONG Size);
//
//	//write vm
//	template <typename T>
//	__declspec(noinline) void Write(uintptr_t Addr, T Data)
//	{
//		IOCOMMAND IO_Data;
//		IO_Data.NameHash = 'LKZR';
//		IO_Data.CommandID = IO_CMD::CMD_WRITE_VM;
//		IO_Data.ProcessID = this->m_PID;
//		IO_Data.Src = (ULONG64)&Data;
//		IO_Data.Dst = (ULONG64)Addr;
//		IO_Data.CopySize = sizeof(T);
//
//		auto requestPtr = &IO_Data;
//
//		auto status = 0ULL;
//		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//		//NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//		//MemoryAPI::SysCall(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	}
//
//	template <typename T>
//	void WriteProtected(uintptr_t Addr, T Data)
//	{
//		IOCOMMAND IO_Data;
//		IO_Data.NameHash = 'LKZR';
//		IO_Data.CommandID = IO_CMD::CMD_WRITE_PROT;
//		IO_Data.ProcessID = this->m_PID;
//		IO_Data.Src = (ULONG64)&Data;
//		IO_Data.Dst = (ULONG64)Addr;
//		IO_Data.CopySize = sizeof(T);
//
//		auto requestPtr = &IO_Data;
//
//		auto status = 0ULL;
//		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
//		///NtQuerySystemInformation((_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//		//MemoryAPI::SysCall(0x0036, (_SYSTEM_INFORMATION_CLASS)76, &IO_Data, sizeof(IO_Data), &IO_Data.ProcessID);
//	}
//
//	//get module base
//	MODINFO GetModInfo(const char* ModName);
//	uintptr_t Allocate(uintptr_t Addr, DWORD Size);
//	void Free(uintptr_t Addr, DWORD Size);
//	bool IsDriverLoaded();
//
//	inline void SetPID(ULONG PID)
//	{
//		this->m_PID = PID;
//	}
//
//private:
//	ULONG m_PID = 0x0;
//};
//
//extern CDriverAPI Driver;

```

`UserMode/Includes.h`:

```h
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>
#include <vector>
#include <d3dx9math.h>
#pragma comment(lib, "d3dx9.lib")
#include <algorithm>
#define _USE_MATH_DEFINES
#include <math.h>
#include <ctime>
#include <time.h>
#include <thread>
#include <map>

#define checkSetting(teamval, enemyval) (((gm.LocalPlayer.Team == player.Team) && teamval) || ((gm.LocalPlayer.Team != player.Team) && enemyval))
#define pasteColor(x) x.r, x.g, x.b
#define pasteColorA(x) x.r, x.g, x.b, x.a

```

`UserMode/Main.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>  
#include "Process/Process.h"
#include <Windows.h>
#include <string>
#include <cassert>
#include <emmintrin.h>
#include <tlhelp32.h>
#include <winternl.h>
#include <signal.h>

#include "Menu.h"
#include "skCrypt.h"
#include "Driver/driver.h"


typedef struct _UncStr
{
	char stub[0x10];
	int len;
	wchar_t str;
} *pUncStr;

using namespace std;


uint64_t game_assembly, unity_player;
int pid;

long long firstentry = 0;
UINT64 TodCycle = 0;
c_menu_framework* menu_framework = new c_menu_framework;

inline HANDLE DriverHandle;
inline HWND hwnd = NULL;
inline DWORD processID;

inline int wLeft, wTop;

#define CHECK_VALID( _v ) 0
#define Assert( _exp ) ((void)0)

#define FastSqrt(x)			(sqrt)(x)

#define M_PI 3.14159265358979323846264338327950288419716939937510

#include <msxml.h>    
#include <atomic>
#include <mutex>
#include <Windows.h>
#include <TlHelp32.h>
#include <cstdint>
#include <vector>
#include <random>
#include <memoryapi.h>
#include <string>
#include <thread>
#include <chrono>
#include <iostream>

#pragma once
#include <Windows.h>


HWND Wnd = NULL;
RECT GameRect = { NULL };
HWND GameWnd = NULL;
IDirect3D9Ex* pObject = NULL;
IDirect3DDevice9Ex* pDevice = NULL;
D3DPRESENT_PARAMETERS pParams = { NULL };

DWORD ScreenCenterX;
DWORD ScreenCenterY;
int Width = GetSystemMetrics(SM_CXSCREEN);
int Height = GetSystemMetrics(SM_CYSCREEN);
MSG Message = { NULL };
bool ShowMenu = false;
bool Initialised = false;

void ClearD3D()
{
	if (pDevice != NULL)
	{
		pDevice->EndScene();
		pDevice->Release();
	}
	if (pObject != NULL)
	{
		pObject->Release();
	}
}



constexpr DWORD init_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x775, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
constexpr DWORD read_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x776, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
constexpr DWORD write_code = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x777, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);

class driver_manager {
	HANDLE m_driver_handle = nullptr;

	struct info_t {
		UINT64 target_pid = 0;
		UINT64 target_address = 0x0;
		UINT64 buffer_address = 0x0;
		UINT64 size = 0;
		UINT64 return_size = 0;
		UINT64 GA = 0;
		UINT64 UP = 0;
	};

public:
	driver_manager(const char* driver_name, DWORD target_process_id) {
		m_driver_handle = CreateFileA(driver_name, GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
		attach_to_process(target_process_id);
	}

	void attach_to_process(DWORD process_id) {
		info_t io_info;

		io_info.target_pid = process_id;

		DeviceIoControl(m_driver_handle, init_code, &io_info, sizeof(io_info), &io_info, sizeof(io_info), nullptr, nullptr);
		game_assembly = io_info.GA;
		unity_player = io_info.UP;
		Sleep(10000);
	}

	template<typename T> T RPM(const UINT64 address) {
		info_t io_info;
		T read_data;

		io_info.target_address = address;
		io_info.buffer_address = (UINT64)&read_data;
		io_info.size = sizeof(T);

		DeviceIoControl(m_driver_handle, read_code, &io_info, sizeof(io_info), &io_info, sizeof(io_info), nullptr, nullptr);
		if (!io_info.buffer_address)
		return read_data;
	}

	template<typename T> bool WPM(const UINT64 address, const T buffer) {
		info_t io_info;

		io_info.target_address = address;
		io_info.buffer_address = (UINT64)&buffer;
		io_info.size = sizeof(T);

		DeviceIoControl(m_driver_handle, write_code, &io_info, sizeof(io_info), &io_info, sizeof(io_info), nullptr, nullptr);
		return io_info.return_size == sizeof(T);
	}
};

driver_manager* gDriver;



#define safe_read(Addr, Type) gDriver->RPM<Type>(Addr)
#define safe_write(Addr, Data, Type) gDriver->WPM<Type>(Addr, Data)


int length(uintptr_t addr) { return safe_read(addr + 0x10, int); }

std::string readstring(uintptr_t addr) {
	try {
		static char buff[128] = { 0 };
		buff[length(addr)] = '\0';

		for (int i = 0; i < length(addr); ++i) {
			if (buff[i] < 128) {
				buff[i] = safe_read(addr + 0x14 + (i * 2), char);
			}
			else {
				buff[i] = '?';
				if (buff[i] >= 0xD800 && buff[i] <= 0xD8FF)
					i++;
			}
		}
		return std::string(&buff[0], &buff[length(addr)]);
	}
	catch (const std::exception& exc) {}
	return "Error";
}
struct monostr
{
	char buffer[128];
};

std::string readchar(uintptr_t addr) {
	std::string str = safe_read(addr, monostr).buffer;
	if (!str.empty())
		return str;
	else
		return NULL;
}

#include "Of.h"

#include "Main.h"
#include "Overlay.h"



bool CreateConsole = true;

#include "Value.h"
#include "SDK/Math.h"
#include "SDK/BaseProjectile.h"
#include "SDK/BasePlayer.h"
#include "SDK/Misc.h"
#include "SDK/Aim.h"


BasePlayer* AimEntity = nullptr;
BasePlayer localclass;
BasePlayer currentent;
BasePlayer currentplayer;
BaseProjectile wep;
//bool OnServer;

#include <mutex>
inline std::mutex          entity_mutex;
inline std::vector<BasePlayer*> otherplayers;
inline std::vector<Vector3> Stash;
inline std::vector<Vector3> hemp;
inline std::vector<Vector3> backpack;
inline std::vector<Vector3> corpse;
inline std::vector<Vector3> vehicles;
inline std::vector<Vector3> DroppedItem;
inline std::vector<Vector3> Airdrop;
inline std::vector<Vector3> patrol_heli;
inline std::vector<Vector3> hackable_crate;
inline std::vector<Vector3> high_tier_crates;
inline std::vector<Vector3> low_tier_crates;
inline std::vector<Vector3> SulfurNodes;
inline std::vector<Vector3> StoneNodes;
inline std::vector<Vector3> MetalNodes;
void WeaponFix(BaseProjectile* weapon)
{
	int ItemID = 0;
	if (weapon)
		ItemID = weapon->GetItemID();
	if (!ItemID) return;

	for (DWORD64 val : semiautomatic) {
		if (ItemID == val) {
			weapon->Recoil();
			weapon->Spread();
			weapon->SAutomatic();
			weapon->FBullet();
			weapon->rapidFire();
			weapon->fastSwitch();
			weapon->instantCompound();

			return;
		}
	}
	for (DWORD64 val : sniper) {
		if (ItemID == val) {
			weapon->Recoil();
			weapon->Spread();
			weapon->FBullet();
			weapon->rapidFire();
			weapon->fastSwitch();
			weapon->instantCompound();
			weapon->SuperBow();

			return;
		}
	}
	for (DWORD64 val : automatic) {
		if (ItemID == val) {
			weapon->Recoil();
			weapon->Spread();
			weapon->FBullet();
			weapon->rapidFire();
			weapon->fastSwitch();
			weapon->instantCompound();
			return;
		}
	}

	if (ItemID == -75944661)
	{
		weapon->SuperEoka();
		weapon->fastSwitch();
		return;
	}

	for (DWORD64 val : meele) {
		if (ItemID == val) {
			weapon->LongHand();
			return;
		}
	}
}




bool cunter = false;
void InitPlayer()
{
	long long i = 0;

	const auto camera_manager_offset = safe_read(unity_player + 0x1762E80, UINT64);
	const auto camera_manager = safe_read(camera_manager_offset, UINT64);
	const auto camera = safe_read(camera_manager, UINT64);
	const auto camera_object = safe_read(camera + 0x30, UINT64);
	const auto object_class = safe_read(camera_object + 0x30, UINT64);
	const auto entity = safe_read(object_class + 0x18, UINT64);
	LocalPlayer.pViewMatrix = (Matrix4x4*)(entity + 0x2E4);
	cunter = true;
	return;
}




void Draw() {
	char fpsinfo[64];
	sprintf(fpsinfo, skCrypt("Winhack.fun"));
	
	if (Value::bools::Aim::Fov) {

		DrawCircle(Value::floats::Screen::W / 2, Value::floats::Screen::H / 2, Value::floats::Aim::Fov, 1, 255, 255, 255, 255, false);
	}
	
}
#include <comdef.h>
Vector2 Penis;




void ESP(BasePlayer* BP, BasePlayer* LP) {
	if (Value::bools::Visuals::ESP::Enable) {
		Vector2 tempFeetR, tempFeetL;
		if (LocalPlayer.WorldToScreen(BP->GBoneByID2(r_foot), tempFeetR) && LocalPlayer.WorldToScreen(BP->GBoneByID2(penis), Penis) && LocalPlayer.WorldToScreen(BP->GBoneByID2(l_foot), tempFeetL)) {
			Vector2 tempHead;
			if (LocalPlayer.WorldToScreen(BP->GBoneByID2(jaw) + Vector3(0.f, 0.16f, 0.f), tempHead))
			{
				Vector2 tempFeet = (tempFeetR + tempFeetL) / 2.f;
				float Entity_h = tempHead.y - tempFeet.y;
				float w = Entity_h / 4;
				float Entity_x = tempFeet.x - w;
				float Entity_y = tempFeet.y;
				float Entity_w = Entity_h / 2;

				bool PlayerWounded = BP->Flags(64);
				bool PlayerSleeping = BP->Flags(16);

				if (PlayerSleeping && Value::bools::Visuals::ESP::IgnoreSleeper)
					return;

				static float screenW = GetSystemMetrics(SM_CXSCREEN);
				static float screenH = GetSystemMetrics(SM_CYSCREEN);

				if (Value::bools::Visuals::ESP::Health) {
					char Health[64];
					sprintf(Health, skCrypt("%0.f HP"), BP->Health());
					DrawString(Health, 12, tempFeet.x, (tempFeet.y + 25), 1.f, 1.f, 1.f);
				}
				if (Value::bools::Visuals::ESP::Box && !PlayerSleeping && !PlayerWounded) {
					DrawBox(Entity_x + 1, Entity_y + 1, Entity_w - 2, Entity_h - 2, 1.f, 1.f, 1.f, 1.f, 1.f, false);
				}
				if (Value::bools::Visuals::ESP::Distance) {
					char Distance[64];
					sprintf(Distance, skCrypt("%d M"), (int)Math::Calc3D_Dist(LP->GBoneByID2(head), BP->GBoneByID2(head)));
					DrawString(Distance, 12, tempFeet.x, (tempFeet.y + 4), 1.f, 1.f, 1.f);
				}
				if (Value::bools::Visuals::ESP::Name) {
					DrawString(BP->GetNamecChars().c_str(), 14, tempFeet.x + 1, (tempFeet.y + 15), 1.f, 1.f, 1.f);
				}
				if (Value::bools::Visuals::ESP::Weapon) {
					DrawString(BP->GetActiveWeaponcChars().c_str(), 12, tempFeet.x, (tempFeet.y + 2), 1.f, 1.f, 1.f);
				}
			}
		}
	}
}
float W = 200.f, H = 140;;


float FOV = 1000000.f;
int EntityCount;
int RenderedEntityCount;
int RenderedPlayerCount;
void entity_esp_thread() {
	
	RenderedEntityCount = NULL; RenderedEntityCount = NULL;

	
		if (Value::bools::Visuals::World::Items::Stash) {
			for (Vector3 Pos : Stash) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Stash [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Hemp) {
			for (Vector3 Pos : hemp) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Hemp [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::AirDrop) {
			for (Vector3 Pos : Airdrop) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("AirDrop [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance2) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::CH47) {
			for (Vector3 Pos : hackable_crate) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("CH47 [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance2) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Minicopter) {
			for (Vector3 Pos : vehicles) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					if (distation <= Value::floats::Visuals::World::LimitDistance2) {
						RenderedEntityCount++;
						sprintf(text, skCrypt("Minicopter [%d m]"), distation);
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Patrol) {
			for (Vector3 Pos : patrol_heli) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					if (distation <= Value::floats::Visuals::World::LimitDistance2) {
						RenderedEntityCount++;
						sprintf(text, skCrypt("Patrol [%d m]"), distation);
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Ore::Stone) {
			for (Vector3 Pos : StoneNodes) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Stone [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Ore::Iron) {
			for (Vector3 Pos : MetalNodes) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Metal [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::World::Items::Ore::Sulfur) {
			for (Vector3 Pos : SulfurNodes) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Sulfur [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}

		if (Value::bools::Visuals::ESP::Corpse) {
			for (Vector3 Pos : corpse) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Corpse [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}


		if (Value::bools::Visuals::ESP::Backpack) {
			for (Vector3 Pos : backpack) {
				Vector2 pos;
				if (LocalPlayer.WorldToScreen(Pos, pos)) {
					int distation = (int)Math::Calc3D_Dist(LocalPlayer.BasePlayer->GBoneByID2(head), Pos);
					char text[0x100];
					sprintf(text, skCrypt("Backpack [%d m]"), distation);
					if (distation <= Value::floats::Visuals::World::LimitDistance) {
						RenderedEntityCount++;
						DrawString(text, 12, pos.x, pos.y, 1.f, 1.f, 1.f);
					}
				}
			}
		}
		if (Value::bools::Visuals::ESP::Enable) {
			for (BasePlayer* Player : otherplayers) {
				if (!Player->IsValid())
					continue;
				ESP(Player, LocalPlayer.BasePlayer);
			

				if (Value::bools::Aim::IgnoreSleepers && Player->Flags(16))
					continue;
				if (Player->IsVisible() && (AimFov(Player) < Value::floats::Aim::Fov))
				{
					AimEntity = Player;
					Aim(AimEntity);
				}
			}
		}
}




#include <vector>
#include <string>
#include <cstddef>
#include <cstdint>
#include <iostream>
#include <string.h>

std::vector<BasePlayer*> local_players;
std::vector<Vector3> local_Stash;
std::vector<Vector3> local_hemp;
std::vector<Vector3> local_corpse;
std::vector<Vector3> local_backpack;
std::vector<Vector3> local_vehicles;
std::vector<Vector3> local_Airdrop;
std::vector<Vector3> local_patrol_heli;
std::vector<Vector3> local_hackable_crate;
std::vector<Vector3> local_high_tier_crates;
std::vector<Vector3> local_low_tier_crates;
std::vector<Vector3> local_DroppedItem;
std::vector<Vector3> local_SulfurNodes;
std::vector<Vector3> local_StoneNodes;
std::vector<Vector3> local_MetalNodes;



DWORD WINAPI EntityT1(LPVOID lpParameter) {
	while (true) {

		auto oBaseEntity = gDriver->RPM<uintptr_t>(gDriver->RPM<uintptr_t>(game_assembly + ooBaseEntity_c) + 0xB8);//BaseEntity_c*

		auto unk1 = gDriver->RPM<uintptr_t>(oBaseEntity + 0x10);

		auto client_entities = gDriver->RPM<uintptr_t>(gDriver->RPM<uintptr_t>(unk1 + 0x10) + 0x28);

		auto objectList = gDriver->RPM<uintptr_t>(client_entities + 0x18);

		auto objectListSize = gDriver->RPM<uint32_t>(client_entities + 0x10);


		for (int i = 0; i <= objectListSize; i++)
		{
			DWORD64 Entity = safe_read(objectList + 0x20 + (i * 0x8), DWORD64);

			if (Entity <= 100000) continue;
			DWORD64 Object = safe_read(Entity + 0x10, DWORD64); //BaseObject
			if (Object <= 100000) continue;
			DWORD64 ObjectClass = safe_read(Object + 0x30, DWORD64); //Object
			//
			WORD tag = safe_read(ObjectClass + 0x54, WORD);
			//
			if (ObjectClass <= 100000) continue;
			uintptr_t name = safe_read(ObjectClass + 0x60, uintptr_t);
			if (!name) continue;
			auto buff = readchar(name);
			if (buff.find(skCrypt("Local")) != std::string::npos) {
				auto Player = (BasePlayer*)safe_read(Object + 0x28, DWORD64);
				if (!safe_read((uintptr_t)Player + 0x4C0, DWORD64)) continue; // public PlayerModel playerModel;??? 0x4B0
				LocalPlayer.BasePlayer = Player;
			}

			else

				if (strstr(buff.c_str(), skCrypt("small_stash_deployed.prefab"))) {
					auto flag = safe_read(Entity + 0x130, uintptr_t);//private float traveledDistance; // 0x130
					if (flag != 2048)
						continue;
					DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
					DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
					DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
					Vector3 pos = safe_read(Vec + 0x90, Vector3);

					local_Stash.push_back(pos);
				}
				else
					if (strstr(buff.c_str(), skCrypt("hemp-collectable.prefab"))) {
						DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
						DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
						DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
						Vector3 pos = safe_read(Vec + 0x90, Vector3);

						local_hemp.push_back(pos);
					}
					else
						if (strstr(buff.c_str(), skCrypt("supply_drop.prefab"))) {
							DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
							DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
							DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
							Vector3 pos = safe_read(Vec + 0x90, Vector3);

							local_Airdrop.push_back(pos);
						}
						else
							if (strstr(buff.c_str(), skCrypt("codelockedhackablecrate.prefab"))) {
								DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
								DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
								DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
								Vector3 pos = safe_read(Vec + 0x90, Vector3);

								local_hackable_crate.push_back(pos);
							}
							else
								if (strstr(buff.c_str(), skCrypt("player_corpse.prefab"))) {
									DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
									DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
									DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
									Vector3 pos = safe_read(Vec + 0x90, Vector3);

									local_corpse.push_back(pos);
								}
								else
									if (strstr(buff.c_str(), skCrypt("item_drop_backpack.prefab"))) {
										DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
										DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
										DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
										Vector3 pos = safe_read(Vec + 0x90, Vector3);

										local_backpack.push_back(pos);
									}
									else
										if (strstr(buff.c_str(), skCrypt("minicopter.entity.prefab"))) {
											DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
											DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
											DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
											Vector3 pos = safe_read(Vec + 0x90, Vector3);

											local_vehicles.push_back(pos);
										}
										else
											if (strstr(buff.c_str(), skCrypt("patrolhelicopter.prefab"))) {
												DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
												DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
												DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
												Vector3 pos = safe_read(Vec + 0x90, Vector3);

												local_patrol_heli.push_back(pos);
											}
											else
												if (strstr(buff.c_str(), skCrypt("stone-ore.prefab"))) {
													DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
													DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
													DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
													Vector3 pos = safe_read(Vec + 0x90, Vector3);

													local_StoneNodes.push_back(pos);
												}
												else
													if (strstr(buff.c_str(), skCrypt("metal-ore.prefab"))) {
														DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
														DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
														DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
														Vector3 pos = safe_read(Vec + 0x90, Vector3);

														local_MetalNodes.push_back(pos);
													}
													else
														if (strstr(buff.c_str(), skCrypt("sulfur-ore.prefab"))) {
															DWORD64 gameObject = safe_read(ObjectClass + 0x30, DWORD64); //Tag 449
															DWORD64 Trans = safe_read(gameObject + 0x8, DWORD64);
															DWORD64 Vec = safe_read(Trans + 0x38, DWORD64);
															Vector3 pos = safe_read(Vec + 0x90, Vector3);

															local_SulfurNodes.push_back(pos);
														}
		}

		//InitPlayer();
		std::this_thread::sleep_for(std::chrono::milliseconds(500));
		std::lock_guard<std::mutex>lk(entity_mutex);
		//otherplayers = std::move(local_players);
		Stash = std::move(local_Stash);
		corpse = std::move(local_corpse);
		vehicles = std::move(local_vehicles);
		DroppedItem = std::move(local_DroppedItem);
		//Animal = std::move(local_Animal);
		SulfurNodes = std::move(local_SulfurNodes);
		StoneNodes = std::move(local_StoneNodes);
		MetalNodes = std::move(local_MetalNodes);

		Airdrop = std::move(local_Airdrop);
		patrol_heli = std::move(local_patrol_heli);
		//tool_cupboard = std::move(local_tool_cupboard);
		hackable_crate = std::move(local_hackable_crate);
		hemp = std::move(local_hemp);
		backpack = std::move(local_backpack);

		//food = std::move(local_food);
		//cargo_ship = std::move(local_cargo_ship);
		high_tier_crates = std::move(local_high_tier_crates);
		low_tier_crates = std::move(local_low_tier_crates);


	}
}





DWORD WINAPI EntityT(LPVOID lpParameter) {
	while (true) {

		auto val = gDriver->RPM<uintptr_t>(gDriver->RPM<uintptr_t>(gDriver->RPM<uintptr_t>(game_assembly + ooBaseEntity_c) + 0xB8) + 0x10);
		UINT64 EntityRealm = gDriver->RPM<DWORD64>(val + 0xB8);
		auto ClientEntities = gDriver->RPM<uintptr_t>(gDriver->RPM<uintptr_t>(val + 0x10) + 0x28);
		EntityCount = safe_read(ClientEntities + 0x10, int);
		if (!EntityCount)
			continue;
		auto EntityBuffer = safe_read(ClientEntities + 0x18, uintptr_t);

		if (!EntityBuffer)
			continue;

		for (int i = 0; i < EntityCount; i++)
		{
			DWORD64 Entity = safe_read(EntityBuffer + 0x20 + (i * 0x8), DWORD64);
			if (Entity <= 100000) continue;
			DWORD64 Object = safe_read(Entity + 0x10, DWORD64); //BaseObject
			if (Object <= 100000) continue;
			DWORD64 ObjectClass = safe_read(Object + 0x30, DWORD64); //Object

			WORD tag = safe_read(ObjectClass + 0x54, WORD);

			if (ObjectClass <= 100000) continue;
			uintptr_t name = safe_read(ObjectClass + 0x60, uintptr_t);
			if (!name) continue;
			auto buff = readchar(name);


			if (buff.find(skCrypt("player.prefab")) != std::string::npos || buff.find(skCrypt("scientist")) != std::string::npos/* && (!strstr(buff.c_str(), "prop") && !strstr(buff.c_str(), "corpse"))*/)
			{
				BasePlayer* Player = (BasePlayer*)safe_read(Object + 0x28, DWORD64); //public ulong playerID;
				if (!safe_read((uintptr_t)Player + oPlayerModel, DWORD64)) continue;// 0x4A8 public PlayerModel playerModel;
				if (!Player->IsValid()) continue;
				local_players.push_back(Player);
			}


		}

		InitPlayer();
		std::this_thread::sleep_for(std::chrono::milliseconds(500));
		std::lock_guard<std::mutex>lk(entity_mutex);
		otherplayers = std::move(local_players);
	}
}

#include <TlHelp32.h>


void Loop()
{
	
		bool valid = LocalPlayer.BasePlayer->IsValid(true);
		if (LocalPlayer.BasePlayer && valid) {
			std::lock_guard<std::mutex>lk(entity_mutex);
			entity_esp_thread();
			Misc(TodCycle);

			int WeaponId = 0;
			int last = -1;
			auto* active = LocalPlayer.BasePlayer->ActiveWeapon();
			if (active) {
				if (active->UID() != 0)
				{
					if (WeaponId != active->GetItemID())
					{
						WeaponId = active->GetItemID();
					}
					last = active->UID();
					if (last)
					{
						WeaponFix(active);
					}
				}
				else if (!last)
					last = active->UID();
			}
			if (!(AimEntity->Dead()) && Value::bools::Aim::TargetLine) {
				Vector2 ScreenPos;
				if (LocalPlayer.WorldToScreen(AimEntity->GBoneByID2(spine1), ScreenPos))
				DrawLine(Value::floats::Screen::W / 2, Value::floats::Screen::H / 2, Penis.x, Penis.y, 1.f, 1.f, 1.f, 1.f, 1);
			}
		}
		else
			if (!LocalPlayer.BasePlayer)
				InitPlayer();
	
}

HANDLE memory_read = NULL, memory_write = NULL, memory_esp_write = NULL;
bool Checccck = true;



inline void drawLoop(int width, int height)
{
	menu_framework->do_menu_controls();
	Loop();

}

inline void OverlaySetup()
{
	DirectOverlaySetup(drawLoop, FindWindow(NULL, "Rust"));
}

int main() {

	

	
	if (CreateConsole == false)
	{
		ShowWindow(::GetConsoleWindow(), SW_HIDE);
	}
	else
	{
		ShowWindow(::GetConsoleWindow(), SW_SHOW);
	}

	if (Checccck == true)
	{
		pid = GetProcessIdByName(skCrypt("RustClient.exe"));
		gDriver = new driver_manager(skCrypt("\\\\.\\AUzwL9x61HxK"), pid);
		cout << "p1d: \t" << pid << endl;
		if (!gDriver) {
			std::cout << "p1d failed" << std::endl;
			Sleep(10000);
			return 0;
		}
		cout<<"GameAssembly.dll : \t"<< game_assembly << endl;
		cout <<"UnityPlayer.dll : \t" << unity_player << endl;
		if (game_assembly == NULL || unity_player == NULL)
		{
			cout << "Eror: Driver issue" << endl;
		}
		std::thread(OverlaySetup).detach();
		InitPlayer();
		Value::floats::Screen::W = GetSystemMetrics(SM_CXSCREEN);  
		Value::floats::Screen::H = GetSystemMetrics(SM_CYSCREEN);
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)EntityT, 0, 0, 0);
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)EntityT1, 0, 0, 0);

		while (true) { // Cringe :D
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
	
	}
}


```

`UserMode/Main.h`:

```h
#pragma once

#include <windows.h>
#include <winternl.h>
#include <fstream>
#include <string>
#include <vector>
#include <tlhelp32.h>
#include <d3d9.h>
#include <d3dx9.h>
#include <dwmapi.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
#pragma comment(lib, "dwmapi.lib")
#pragma comment(lib, "ntdll.lib")
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>
#include <vector>
#include <d3dx9math.h>
#pragma comment(lib, "d3dx9.lib")
#include <algorithm>
#define _USE_MATH_DEFINES
#include <math.h>
#include <ctime>
#include <time.h>
#include <thread>
#include <map>

#define checkSetting(teamval, enemyval) (((gm.LocalPlayer.Team == player.Team) && teamval) || ((gm.LocalPlayer.Team != player.Team) && enemyval))
#define pasteColor(x) x.r, x.g, x.b
#define pasteColorA(x) x.r, x.g, x.b, x.a


extern HWND Wnd;
extern RECT GameRect;
extern HWND GameWnd;
extern IDirect3D9Ex* pObject;
extern IDirect3DDevice9Ex* pDevice;
extern D3DPRESENT_PARAMETERS pParams;

extern DWORD ScreenCenterX;
extern DWORD ScreenCenterY;
extern int Width;
extern int Height;
extern const MARGINS Margin;
extern MSG Message;
extern bool ShowMenu;
extern bool Initialised;

void ClearD3D();

```

`UserMode/Menu.h`:

```h
#pragma once
#include <vector>
#include <time.h>
#include "Overlay.h"
#include "Value.h"

static float screenW = GetSystemMetrics(SM_CXSCREEN);
static float screenH = GetSystemMetrics(SM_CYSCREEN);

inline int get_frame_rate()
{
	static int i_fps, i_last_fps;
	static float fl_last_tick_count, fl_tick_count;
	fl_tick_count = clock() * 0.001f;
	i_fps++;
	if ((fl_tick_count - fl_last_tick_count) >= 1.0f)
	{
		fl_last_tick_count = fl_tick_count;
		i_last_fps = i_fps;
		i_fps = 0;
	}
	return i_last_fps;
};

class c_menu_framework
{
private:
public:
	float menu_x = 250, menu_y = 290;
	enum item_type : int {
		type_bool = 0,
		type_int = 1,
		type_float = 2
	};
	enum tab_type : int {
		type_on_off = 0,
		type_tab = 1,
		type_dont_draw = 2
	};
	static struct menu_item_t {
		std::string m_title;

		float* m_float;
		int* m_int;
		bool* m_bool = 0;
		int increment = 1;
		int minimum = 0;
		int maximum = 1;
		float m_float_step;
		int m_int_step;
		int m_type;
		int tab_type;

		float m_float_min;
		int m_int_min;

		float m_float_max;
		int m_int_max;

		std::string tool_tip;
	};

	//int m_total_items = 0;
	int m_current_pos = 0;
	int menu_page = 0;
	std::vector<menu_item_t> items;
public:

	inline void add_entry(std::string title, bool* value, int is_tab = 0, std::string tooltip = "") {
		menu_item_t m_item;
		m_item.m_title = title;
		m_item.m_bool = value;
		m_item.m_type = item_type::type_bool;
		m_item.tab_type = is_tab;
		m_item.tool_tip = tooltip;
		items.emplace_back(m_item);
	}

	template <class t>
	inline void add_entry(std::string title, t* value, t min, t max, t step) {
		menu_item_t m_item;
		m_item.m_title = title;
		if (std::is_same<t, float>()) {
			m_item.m_float = (float*)value;
			m_item.m_float_min = min;
			m_item.m_float_max = max;
			m_item.m_float_step = step;
			m_item.m_type = item_type::type_float;
		}
		else if (std::is_same<t, int>()) {
			m_item.m_int = (int*)value;
			m_item.m_int_min = min;
			m_item.m_int_max = max;
			m_item.m_int_step = step;
			m_item.m_type = item_type::type_int;
		}
		items.emplace_back(m_item);
	}

	inline void draw()
	{
		this->menu_x = Value::menux;
		this->menu_y = Value::menuy;

		static bool aimbot_tap = false;
		static bool espteam_tap = false;
		static bool espenemy_tab = false;
		static bool esploot_tab = false;
		static bool crosshair_tab = false;
		static bool color_tab = false;
		static bool misc_tab = false;
		static bool menu_tab = false;

		this->add_entry("AIMBOT", &aimbot_tap, true);
		if (aimbot_tap) {
			this->add_entry("Aim enable", &Value::bools::Aim::Enable);
			this->add_entry("PSilent", &Value::bools::Aim::PSilent);
			this->add_entry("Draw Fov", &Value::bools::Aim::Fov);
			if (Value::bools::Aim::Fov) {
				this->add_entry("Fov", &Value::floats::Aim::Fov, 1, 100, 1);
				DrawCircle(screenW / 2, screenH / 2, Value::floats::Aim::Fov, 1, 255, 255, 255, 255, false);
			}
			this->add_entry("Smooth", &Value::bools::Aim::Smooth);
			if (Value::bools::Aim::Smooth) {
				this->add_entry("Smooth +", &Value::floats::Aim::Smooth, 1.f, 10.f, 1.f);
			}
			this->add_entry("Fat Bullet", &Value::bools::Weapon::FatBullet);
			this->add_entry("IgnoreSleepers", &Value::bools::Aim::IgnoreSleepers);
			this->add_entry("TargetLine", &Value::bools::Aim::TargetLine);
		}

		this->add_entry("ESP", &espteam_tap, true);
		if (espteam_tap) {
			this->add_entry("Enable", &Value::bools::Visuals::ESP::Enable);
			this->add_entry("Name", &Value::bools::Visuals::ESP::Name);
			this->add_entry("Box", &Value::bools::Visuals::ESP::Box);
			this->add_entry("Health", &Value::bools::Visuals::ESP::Health);
			this->add_entry("Weapon", &Value::bools::Visuals::ESP::Weapon);
		}

		this->add_entry("MISC ESP", &esploot_tab, true);
		if (esploot_tab) {

			this->add_entry("Stash", &Value::bools::Visuals::World::Items::Stash);
			this->add_entry("AirDrop", &Value::bools::Visuals::World::Items::AirDrop);
			this->add_entry("CH47", &Value::bools::Visuals::World::Items::CH47);
			this->add_entry("Patrol", &Value::bools::Visuals::World::Items::Patrol);
			this->add_entry("Minicopter", &Value::bools::Visuals::World::Items::Minicopter);
			this->add_entry("Hemp", &Value::bools::Visuals::World::Items::Hemp);
			this->add_entry("Iron", &Value::bools::Visuals::World::Items::Ore::Iron);
			this->add_entry("Sulfur", &Value::bools::Visuals::World::Items::Ore::Sulfur);
			this->add_entry("Stone", &Value::bools::Visuals::World::Items::Ore::Stone);
			this->add_entry("Distance +", &Value::floats::Visuals::World::LimitDistance, 1, 2000, 1);

		}
		this->add_entry("MISC", &esploot_tab, true);
		if (esploot_tab) {
			
			this->add_entry("fastSwitch", &Value::bools::Misc::fastSwitch);
			this->add_entry("instantCompound", &Value::bools::Misc::instantCompound);
			this->add_entry("Automatic", &Value::bools::Weapon::IsAutomatic);
			this->add_entry("NoRecoil", &Value::bools::Weapon::NoRecoil);
			if (Value::bools::Weapon::NoRecoil) {
				this->add_entry("Y", &Value::floats::Player::RCSyaw, 1, 30, 1);
				this->add_entry("X", &Value::floats::Player::RCSpitch, 1, 30, 1);
			}
			this->add_entry("Nospread", &Value::bools::Weapon::NoSpread);
			this->add_entry("SuperEoka", &Value::bools::Player::SuperEoka);
			this->add_entry("SpeedHack", &Value::bools::Misc::SpeedHack);
			this->add_entry("FixCamera", &Value::bools::Misc::FixCamera);
			this->add_entry("CustomFov", &Value::bools::Player::CustomFov);
			if (Value::bools::Player::CustomFov) {
				this->add_entry("Fov", &Value::floats::Player::CustomFov, 90.f, 120.f, 1.f);
			}
			this->add_entry("KillHack (G)", &Value::bools::Misc::killhack);
			this->add_entry("Zoom (Z)", &Value::bools::Player::Zoom);
			this->add_entry("FlyHack (F)", &Value::bools::Misc::FlyHack);
			this->add_entry("LonNeck (Y)", &Value::floats::Player::LongNeck);
			this->add_entry("WalkOnWater", &Value::bools::Misc::WalkOnWater);
			this->add_entry("InfinityJump", &Value::bools::Player::PlayerWalk::InfinityJump);
			this->add_entry("FakeAdmin", &Value::bools::Player::PlayerWalk::FakeAdmin);
			this->add_entry("High Jump", &Value::bools::Player::PlayerWalk::ChangeGravity);
			this->add_entry("Longhand", &Value::bools::Player::Longhand);
			
		}

		this->add_entry("MENU", &menu_tab, true);
		if (menu_tab) {
			this->add_entry("  Menu x", &Value::menux, 0.f, 2560.f, 50.f);
			this->add_entry("  Menu y", &Value::menuy, 0.f, 1440.f, 50.f);
		}

	}
	time_t lastTime;
	inline	bool ReadKeyOnce(unsigned int keycode, unsigned int timer) {
		if ((clock() - lastTime > timer) && GetAsyncKeyState(keycode)) {
			lastTime = clock();
			return true;
		}
		return false;
	}
	inline void do_menu_controls() {
		static bool show = true;
		if (show) {
			this->draw();
			static int item_gap = 14;
			static float alpha = 1.f;
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			DrawString("Winhack.fun - " + std::to_string(get_frame_rate()), 12, this->menu_x + 28, this->menu_y - 18, 1.f, 1.f, 1.f, alpha);

			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 0.1f, 0.1f, 0.1f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 1.0f, 1.0, 1.0f, alpha, false);

			if (items.empty())
				return;
			if (m_current_pos > items.size())
				m_current_pos = items.size();

			if (!items[m_current_pos].tool_tip.empty()) {
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 1, 154, 28, 31, 31, 31, alpha, true);
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 1, 154, 28, 102, 0, 204, alpha, false);

				DrawString("NOTE:", 12, this->menu_x, this->menu_y + (items.size() * item_gap) + 5, 1, 1, 1, alpha);
				DrawString(items[m_current_pos].tool_tip.c_str(), 11, this->menu_x, this->menu_y + (items.size() * item_gap) + 16, 1, 1, 1, alpha);

			}

			for (auto item = 0; item < items.size(); ++item) {
				auto height = this->menu_y + (item_gap * item);
				char txt[1024];
				switch (items[item].m_type)
				{
				case item_type::type_bool: {
					D3DXCOLOR _bool = *items[item].m_bool ? D3DXCOLOR(0, 1.f, 0, alpha) : D3DXCOLOR(1.f, 0, 0, alpha);

					DrawString(items[item].m_title.c_str(), 12, this->menu_x, height, 1, 1, 1, alpha);
					if (items[item].tab_type == tab_type::type_on_off)
						DrawString(*items[item].m_bool ? "ON" : "OFF", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					else if (items[item].tab_type == tab_type::type_tab)
						DrawString(*items[item].m_bool ? "[-]" : "[+]", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					break;
				}
				case item_type::type_int: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1, 1, 1, alpha);
					sprintf(txt, "%i", *items[item].m_int);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				case item_type::type_float: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1.f, 1.f, 1.f, alpha);
					sprintf(txt, "%.1f", *items[item].m_float);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				default:
					break;
				}

				if (ReadKeyOnce(VK_UP, 250)) {
					this->m_current_pos -= 1;
					if (this->m_current_pos < 0)
						m_current_pos = (m_current_pos > 0) ? (m_current_pos - 1) : items.size() - 1;
				}
				if (ReadKeyOnce(VK_DOWN, 250)) {
					this->m_current_pos += 1;
					if (this->m_current_pos > items.size() - 1)
						this->m_current_pos = 0;
				}

				if (ReadKeyOnce(VK_LEFT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 1) {
							*items[m_current_pos].m_bool -= items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool < items[m_current_pos].minimum)
								*items[m_current_pos].m_bool = items[m_current_pos].minimum;
						}
						break;
					}
					case item_type::type_int: {

						*items[m_current_pos].m_int -= items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int < items[m_current_pos].m_int_min)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_max;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float -= items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float < items[m_current_pos].m_float_min)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_max;
						break;
					}
					default:
						break;
					}

				}
				if (ReadKeyOnce(VK_RIGHT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 0) {
							*items[m_current_pos].m_bool += items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool > items[m_current_pos].maximum)
								//*items[m_current_pos].m_bool = !*items[m_current_pos].m_bool;
								*items[m_current_pos].m_bool = items[m_current_pos].maximum;
						}
						break;
					}
					case item_type::type_int: {
						*items[m_current_pos].m_int += items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int > items[m_current_pos].m_int_max)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_min;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float += items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float > items[m_current_pos].m_float_max)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_min;
						break;
					}
					default:
						break;
					}


				}

			}
		}
		if (!items.empty())
			items.clear();
		if (GetAsyncKeyState(VK_DELETE)) {
			show = !show;
			Sleep(150);
		}
	}

};



```

`UserMode/Of.h`:

```h
#pragma once
DWORD64 automatic[]
{
	1545779598, // AK - 47;
	-1758372725, // Томсон
	1796682209, // SMG
	-1812555177,// LR - 300
	1318558775, // MP5
	-2069578888, // M249
	884424049,
};

DWORD64 sniper[]
{
	-778367295, // L96
	1588298435, // Болт
	1443579727, // лук
	884424049, // Блочка
	1443579727, //лук

};

DWORD64 semiautomatic[]{
	-904863145, // Берданка 
	818877484, // Пэшка
	-852563019, // берета
	1373971859, // Питон
	649912614, // револьвер
	28201841, // M39
	1953903201, // Гвоздомёт
	-1123473824, // Гранатомёт
};

DWORD64 meele[]{

	-1966748496, 2040726127, -194509282, 1540934679, 1814288539, 1491189398, 1602646136, -1137865085, 1090916276, -1978999529, 1326180354, 1488979457, 171931394, -1583967946, 200773292, -262590403, -1252059217, 795236088, -196667575, -1506397857, -1302129395, 963906841, 1104520648, -1780802565, -2069578888
};

#define oGameObjectManager 0x17C1F18 // 0x17D69F8
#define oBaseNetworkable   51846112 // BaseNetworkable_c*
#define oConVar 51837016 //ConVar_Graphics_c*
#define oTOD_Sky 51856480 //TOD_Sky_c*
#define oBasePlayer 51848808 //BasePlayer_c*
#define oOcclusionCulling 51847464 //"Signature": "OcclusionCulling_c*"
#define oConClient 51842192 //ConVar_Client_c*
#define ooBaseEntity_c 52240584 //BaseEntity_c*

//class BasePlayer
#define oPlayerFlags 0x678 // public BasePlayer.PlayerFlags playerFlags;
#define oPlayerEyes 0x680 // public PlayerEyes eyes;
#define oPlayerName 0x6D8 // protected string _displayName;
#define oPlayerHealth 0x224 // private float _health;//protected float _health;
#define olastSentTickTime 0x64C // private float lastSentTickTime;
#define oClientTeam 0x598 // public PlayerTeam clientTeam;
#define oLifestate 0x21C // public BaseCombatEntity.LifeState lifestate;
#define oSteamID 0x6C0 // public ulong userID;
#define oPlayerInventory 0x688 // public PlayerInventory inventory;
#define oActiveUID 0x5C8// private uint clActiveItem;
#define oFrozen 0x4C8// public bool Frozen;
#define oWaterBonus 0x750// public float clothingWaterSpeedBonus;
#define oNoBlockAiming 0x748 // public bool clothingBlocksAiming;
#define oSpeedReduction 0x74C// public float clothingMoveSpeedReduction;
#define oClothingAccuracyBonus 0x754 //	public float clothingAccuracyBonus;


//EntityRef
#define oHeld 0x98//private EntityRef heldEntity
#define oStancePenalty 0x31C //private float stancePenalty;
#define	oAimconePenalty	0x320 //private float aimconePenalty;
#define	oHipAimCone 0x2EC //public float hipAimCone;
#define	oAimCone 0x730 //public float aimCone;			(class BaseProjectile)
#define	oAimconePenaltyPerShot 0x2F0 //public float aimconePenaltyPerShot;
#define oSuccessFraction 0x360 // public float successFraction;
#define oAttackRadius 0x294 //public float attackRadius;
#define oEffectiveRange 0x1FC //public float effectiveRange;
#define oIsAutomatic 0x298 //public bool isAutomatic;
#define oMaxDistance 0x290 //public float maxDistance;			(class BaseMelee)
#define oRepeatDelay 0x1F4 //public float repeatDelay;

#define odisplayname 0x28 //public Translate.Phrase displayName;//public class ItemDefinition : MonoBehaviour

//BaseProjectile
#define oAuto 0x288 //public bool automatic;
#define oFastReload 0x2C0 // bool fractionalReload
#define oDistance 0x280 // public float distanceScale
#define oprojectileVelocityScale 0x284 //public float projectileVelocityScale
#define oShortname 0x20// public string shortname;//public class ItemDefinition : MonoBehaviour
#define oModelState 0x5F8// public ModelState modelState; class BasePlayer : BaseCombatEntity
#define owaterLevel 0x38 //public float waterLevel class BucketVMFluidSim : MonoBehaviour //
#define ogravityTestRadius 0x80// public float gravityTestRadius
#define ogroundAngle 0xC4 // private float groundAngle; // 0xC4
#define ocapsuleHeight 0x68// public float capsuleHeight; // 0x68
#define ocapsuleCenter 0x6C// public float capsuleCenter; // 0x6C
#define oGrounded 0x140//private bool grounded;
#define oGravityMultiplierSwimming 0x88 // public float gravityMultiplierSwimming;
#define oClothingBlocksAiming 0x750 // public bool clothingBlocksAiming;
#define oAttackReady 0x360 // protected bool attackReady;
//BaseMovement
#define oPlayerMovement 0x4E8 // public BaseMovement movement;
#define oGravityMultiplier 0x84 // public float gravityMultiplier;

#define oGroundAngle 0xC4// private float groundAngle;
#define oGroundAngleNew 0xC8 // private float groundAngleNew;

//RecoilProperties
#define oRecoilProperties 0x2D8 //public RecoilProperties recoil;
#define oRecoilMinYaw 0x18 //public float recoilYawMin;
#define oRecoilMaxYaw 0x1C //public float recoilYawMax;
#define oRecoilMinPitch 0x20 //public float recoilPitchMin;
#define oRecoilMaxPitch 0x24 //public float recoilPitchMax;


//PlayerModel
#define oPlayerModel 0x4C0 // public PlayerModel playerModel;
#define oVisible 0x278 // internal bool visible;

//PlayerInput
#define oPlayerInput 0x4E0// public PlayerInput input;
#define oBodyAngles 0x3C // private Vector3 bodyAngles;
#define oRecoilAngles 0x64 // public Vector3 recoilAngles;
#define oHasKeyFocus 0x94 // private bool hasKeyFocus;



#define oArrowBack 0x364 // private float arrowBack;
#define oTriggerReady 0x360 // protected bool attackReady;
#define oItemDefinition 0x20 // public ItemDefinition info;
#define oItemid 0x18 // public int itemid;


#define oBlockSprintOnAttack 0x299 //public bool blockSprintOnAttack;
```

`UserMode/Overlay.cpp`:

```cpp
#include "Overlay.h"
#include <vector>
#include <comdef.h>
#include <corecrt.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>




Renderer* Renderer::m_pInstance;
Renderer::Renderer()
{
}

Renderer::~Renderer()
{
}



void Renderer::DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;
	if (MaxHealth < Health)
		MaxHealth = 100;

	int size = (w * Health / (MaxHealth / 100)) / 100;
	DrawBox(x, y, w, h, 1.f, 0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2), true);

	if (size == w)
		DrawBox(x + 1, y + 1, size - 2, h - 2, 1.f, pasteColorA(color1), true);
	else
		DrawBox(x + 1, y + 1, size, h - 2, 1.f, pasteColorA(color1), true);
}



void Renderer::DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;

	if (MaxHealth < Health)
		MaxHealth = 100;
	int size = (h * Health / (MaxHealth / 100)) / 100;

	DrawBox(x, y, w, h, 1.f, 0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2), true);

	if (size == h)
		DrawBox(x + 1, y + 1 + h - size, w - 2, size - 2, 1.f, pasteColorA(color1), true);
	else
		DrawBox(x + 1, y + 1 + h - size, w - 2, size, 1.f, pasteColorA(color1), true);
}
void Renderer::DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{

	DrawBox(x, y, w, h, thickness, 0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, thickness, pasteColorA(color), false);
	DrawBox(x + 2, y + 2, w - 4, h - 4, thickness, 0.f, 0.f, 0.f, 1.f, false);

}

void Renderer::DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;

	// top
	DrawLine(x, y, x + iw, y, thickness, pasteColorA(color));					// left
	DrawLine(x + w - iw, y, x + w, y, thickness, pasteColorA(color));			// right
	DrawLine(x, y, x, y + ih, thickness, pasteColorA(color));					// top left
	DrawLine(x + w - 1, y, x + w - 1, y + ih, thickness, pasteColorA(color));	// top right
														// bottom
	DrawLine(x, y + h, x + iw, y + h, thickness, pasteColorA(color));			// left
	DrawLine(x + w - iw, y + h, x + w, y + h, thickness, pasteColorA(color));	// right
	DrawLine(x, y + h - ih, x, y + h, thickness, pasteColorA(color));			// bottom left
	DrawLine(x + w - 1, y + h - ih, x + w - 1, y + h, thickness, pasteColorA(color));	// bottom right
}




void Renderer::DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;



	// top left
	DrawLine(x + 1, y + 1, x + iw, y + 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y, x + iw, y + 2, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + 1, x + 1, y + ih, 1.f, pasteColorA(color));
	DrawLine(x, y + ih, x + 2, y + ih, thickness, 0.f, 0.f, 0.f, 1.f);

	// top right
	DrawLine(x + w - iw, y + 1, x + w - 1, y + 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y, x + w - iw, y + 2, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + 1, x + w - 2, y + ih, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + ih, x + w, y + ih, thickness, 0.f, 0.f, 0.f, 1.f);

	// bottom left
	DrawLine(x + 1, y + h - ih, x + 1, y + h, thickness, pasteColorA(color));
	DrawLine(x, y + h - ih - 1, x + 2, y + h - ih - 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + h - 1, x + iw, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y + h - 1, x + iw, y + h + 1, thickness, 0.f, 0.f, 0.f, 1.f);

	// bottom right
	DrawLine(x + w - iw, y + h - 1, x + w - 1, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y + h - 1, x + w - iw, y + h + 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + h - ih, x + w - 2, y + h, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + h - ih - 1, x + w, y + h - ih - 1, thickness, 0.f, 0.f, 0.f, 1.f);


}

void Renderer::DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background)
{
	DrawBox(x, y, w, h, 1.f, pasteColorA(Border), false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(Background), true);
}

void Renderer::DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color)
{
	if (style == CrosshairStyle::Dot)
	{
		DrawCircle(x, y, size, 1.f, pasteColorA(color), true);
	}
	else if (style == CrosshairStyle::Plus)
	{
		DrawLine(x - size, y, x + size, y, stroke, pasteColorA(color));
		DrawLine(x, y - size, x, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Cross)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Gap)
	{
		DrawLine(x - size - stroke, y, x - stroke, y, stroke, pasteColorA(color));
		DrawLine(x + size + stroke, y, x + stroke, y, stroke, pasteColorA(color));
		DrawLine(x, y - size - stroke, x, y - stroke, stroke, pasteColorA(color));
		DrawLine(x, y + size + stroke, x, y + stroke, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Diagonal)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::HitMaker)
	{
		float flScreenPosCenter[2];
		flScreenPosCenter[0] = x;
		flScreenPosCenter[1] = y;

		const int iLineSize = size;

		DrawLine(flScreenPosCenter[0] - iLineSize, flScreenPosCenter[1] - iLineSize, flScreenPosCenter[0] - (iLineSize / 4), flScreenPosCenter[1] - (iLineSize / 4), stroke, pasteColorA(color));
		DrawLine(flScreenPosCenter[0] - iLineSize, flScreenPosCenter[1] + iLineSize, flScreenPosCenter[0] - (iLineSize / 4), flScreenPosCenter[1] + (iLineSize / 4), stroke, pasteColorA(color));
		DrawLine(flScreenPosCenter[0] + iLineSize, flScreenPosCenter[1] + iLineSize, flScreenPosCenter[0] + (iLineSize / 4), flScreenPosCenter[1] + (iLineSize / 4), stroke, pasteColorA(color));
		DrawLine(flScreenPosCenter[0] + iLineSize, flScreenPosCenter[1] - iLineSize, flScreenPosCenter[0] + (iLineSize / 4), flScreenPosCenter[1] - (iLineSize / 4), stroke, pasteColorA(color));

	}
}

Renderer* Renderer::GetInstance()
{
	if (!m_pInstance)
		m_pInstance = new Renderer();

	return m_pInstance;
}
```

`UserMode/Overlay.h`:

```h
#pragma once
#include "Includes.h"
#include "DirectOverlay.h"



enum TextLayout : std::uint32_t
{
	TextLeft = 0x00,
	TextRight = 0x01,
	TextCenterV = 0x02,
	TextCenterH = 0x04,
	TextCenter = (TextCenterV | TextCenterH),
};

class Renderer
{
public:
	static Renderer* GetInstance();
private:
	Renderer();
	~Renderer();
public:
	enum CrosshairStyle
	{
		Dot,
		Plus,
		Cross,
		Gap,
		Diagonal,
		HitMaker,
	};

	void DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background);
	void DrawPlayerName(uint64_t player, std::string buffer, int distance, bool sameTeam);

	void DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color);
private:
	static Renderer* m_pInstance;
};
```

`UserMode/Process/Process.h`:

```h
#pragma once

#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>  

bool isModule(DWORD processID, const char* module, bool debug = false) {
    {
        HMODULE hMods[1024];
        HANDLE hProcess;
        DWORD cbNeeded;
        unsigned int i;

        // Print the process identifier.

        printf("\nProcess ID: %u\n", processID);

        // Get a handle to the process.

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
            PROCESS_VM_READ,
            FALSE, processID);
        if (NULL == hProcess)
            return NULL;

        // Get a list of all the modules in this process.

        if (K32EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
        {
            for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
            {
                TCHAR szModName[MAX_PATH];

                // Get the full path to the module's file.

                if (K32GetModuleFileNameExA(hProcess, hMods[i], szModName,
                    sizeof(szModName) / sizeof(TCHAR)))
                {
                    // Print the module name and handle value.
                    if (strstr(szModName, module)) {
                        if (debug)
                            printf(TEXT("\t%s (0x%08X)\n"), szModName, hMods[i]);
                        CloseHandle(hProcess);
                        return true;
                    }
                }
            }
        }

        // Release the handle to the process.

        CloseHandle(hProcess);
        return 0;
    }
}

HMODULE GetModuleAddres(DWORD processID, const char* module, bool debug = false)
{
    HMODULE hMods[1024];
    HANDLE hProcess;
    DWORD cbNeeded;
    unsigned int i;

    // Print the process identifier.
    if(debug)
        printf("\nProcess ID: %u\n", processID);

    // Get a handle to the process.

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
        PROCESS_VM_READ,
        FALSE, processID);
    if (NULL == hProcess)
        return NULL;

    // Get a list of all the modules in this process.

    if (K32EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
    {
        for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
        {
            TCHAR szModName[MAX_PATH];

            // Get the full path to the module's file.

            if (K32GetModuleFileNameExA(hProcess, hMods[i], szModName,
                sizeof(szModName) / sizeof(TCHAR)))
            {
                // Print the module name and handle value.
                if (strstr(szModName, module)) {
                    if(debug)
                        printf(TEXT("\t%s (0x%08X)\n"), szModName, hMods[i]);
                    CloseHandle(hProcess);
                    return hMods[i];
                }
            }
        }
    }

    // Release the handle to the process.

    CloseHandle(hProcess);
    return 0;
}

int GetProcessIdByName(const char* processname, bool debug = false)
{
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    DWORD result = NULL;

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcessSnap) return(FALSE);

    pe32.dwSize = sizeof(PROCESSENTRY32); // <----- IMPORTANT

    // Retrieve information about the first process,
    // and exit if unsuccessful
    if (!Process32First(hProcessSnap, &pe32))
    {
        CloseHandle(hProcessSnap);          // clean the snapshot object
        if(debug)
            printf("Failed to gather information on system processes! \n");
        return(NULL);
    }

    do
    {
        if (0 == strcmp(processname, pe32.szExeFile))
        {
            result = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);

    return result;
}
```

`UserMode/Rust External - Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1ea6bf6f-c2f1-44aa-b3b7-f3816db34c3a}</ProjectGuid>
    <RootNamespace>RustExternalClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22621.0</WindowsTargetPlatformVersion>
    <ProjectName>Hack</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>
    </LinkIncremental>
    <IncludePath>$(DXSDK_DIR)\Include;C:\My Librirary;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)\UserMode\lib;$(DXSDK_DIR)\Lib\x64;$(LibraryPath)</LibraryPath>
    <TargetExt>.exe</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>D2DOverlay.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Overlay.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectOverlay.h" />
    <ClInclude Include="Includes.h" />
    <ClInclude Include="Main.h" />
    <ClInclude Include="Menu.h" />
    <ClInclude Include="Of.h" />
    <ClInclude Include="Overlay.h" />
    <ClInclude Include="SDK\Aim.h" />
    <ClInclude Include="SDK\BasePlayer.h" />
    <ClInclude Include="SDK\BaseProjectile.h" />
    <ClInclude Include="SDK\Math.h" />
    <ClInclude Include="SDK\Misc.h" />
    <ClInclude Include="skCrypt.h" />
    <ClInclude Include="Value.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UserMode/Rust External - Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Overlay.cpp">
      <Filter>Overlay</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="SDK">
      <UniqueIdentifier>{d060546f-168b-42f7-a863-d0c37089eeb5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Overlay">
      <UniqueIdentifier>{c87b2007-e9fa-4175-9d4f-8592bf58e2dd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Misc">
      <UniqueIdentifier>{4794917d-c0fb-443f-bf95-f51fcab12e74}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="SDK\BasePlayer.h">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Math.h">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\BaseProjectile.h">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Misc.h">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="Main.h" />
    <ClInclude Include="SDK\Aim.h">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Overlay</Filter>
    </ClInclude>
    <ClInclude Include="DirectOverlay.h">
      <Filter>Overlay</Filter>
    </ClInclude>
    <ClInclude Include="Overlay.h">
      <Filter>Overlay</Filter>
    </ClInclude>
    <ClInclude Include="Value.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Of.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Includes.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="skCrypt.h">
      <Filter>Misc</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UserMode/SDK/Aim.h`:

```h

float GetBulletSpeed()
{
	switch (LocalPlayer.BasePlayer->ActiveWeapon()->GetItemID())
	{
	case 1796682209: //smg
		return 240.f;
	case 1588298435: //bolt
		return 656.25f;
	case -778367295: //l96
		return 1125.f;
	case 28201841: //m39
		return 469.f;
	case 1953903201: //nailgun
		return 50.f;
	case 649912614: //revolver
		return 300.f;
	case 818877484: //p250
		return 300.f;
	case -1367281941: //waterpipe, 250-green ammo, 100-other
		return 100.f;
	case -765183617: //double barrel, 250-green ammo, 100-other
		return 100.f;
	case -1812555177: //lr300
		return 375.f;
	case -852563019: //m92
		return 300.f;
	case -1123473824: //grenade launcher, shotgun - 250, other - 100
		return 100.f;
	case 442886268: //rocket launcher, unknown
		return 250.f;
	case -904863145: //semiautomatic rifle
		return 375.f;
	case -41440462: //spas12, 250-green ammo, 100-other
		return 100.f;
	case 1545779598: //ak47
		return 375.f;
	case 1443579727: //bow, 80-high speed arrow, 40 - fire arrow, 50 - normal
		return 50.f;
	case -75944661: //eoka, 250-green ammo, 100-other
		return 100.f;
	case 1318558775: //mp5a4
		return 240.f;
	case 795371088: //pomp shotgun, 250-green ammo, 100-other
		return 100.f;
	case 1965232394: //crossbow, 75 - normal, 120-high velocity, 60 - fire
		return 75.f;
	case -2069578888:
		return 488.f;
	case 1373971859: //python
		return 300.f;
	case -1758372725: //tompson
		return 300.f;
	default:
		return 250.f;
	}
}

float AimFov(BasePlayer* Entity)
{
	Vector2 ScreenPos;
	if (!LocalPlayer.WorldToScreen(Entity->GetBoneByID(), ScreenPos)) return 1000.f;
	return Math::Calc2D_Dist(Vector2(Value::floats::Screen::W / 2, Value::floats::Screen::H / 2), ScreenPos);
}

Vector3 Prediction(const Vector3& LP_Pos, BasePlayer* Player, BoneList Bone)
{
	Vector3 BonePos = Player->GetBoneByID();
	float Dist = Math::Calc3D_Dist(LP_Pos, BonePos);

	if (Dist > 0.001f) {
		float BulletTime = Dist / GetBulletSpeed();
		Vector3 vel = Player->GVelocity();
		Vector3 PredictVel = vel * BulletTime * 0.75f;
		BonePos += PredictVel; BonePos.y += (4.905f * BulletTime * BulletTime);
	} return BonePos;
}

void Normalize(float& Yaw, float& Pitch) {
	if (Pitch < -89) Pitch = -89;
	else if (Pitch > 89) Pitch = 89;
	if (Yaw < -360) Yaw += 360;
	else if (Yaw > 360) Yaw -= 360;
}

Vector2 ClampAngle(Vector2 qaAng)
{
	if (qaAng.x > 89.0f)
		qaAng.x = 89.0f;
	if (qaAng.x < -89.0f)
		qaAng.x = -89.0f;
	while (qaAng.y > 180.0f)
		qaAng.y -= 360.0f;
	while (qaAng.y < -180.0f)
		qaAng.y += 360.0f;
	return qaAng;
}

Vector2 ClampAngles(Vector2 vec)
{
	if (vec.x > 89.0f && vec.x <= 180.0f)
	{
		vec.x = 89.0f;
	}
	while (vec.x > 180.f)
	{
		vec.x -= 360.f;
	}
	while (vec.x < -89.0f)
	{
		vec.x = -89.0f;
	}
	while (vec.y > 180.f)
	{
		vec.y -= 360.f;
	}
	while (vec.y < -180.f)
	{
		vec.y += 360.f;
	}
	return vec;
}

void AimBotTarget(BasePlayer* player)
{
	Vector3 Local = LocalPlayer.BasePlayer->GetBoneByID();
	Vector3 PlayerPos = Prediction(Local, player, BoneList(neck));

	Vector2 current_angle = LocalPlayer.BasePlayer->GVA();
	Vector2 angle = Math::CalcAngle(Local, PlayerPos) - LocalPlayer.BasePlayer->GVA();
	Vector2 FinalAngle = LocalPlayer.BasePlayer->GVA() + angle;
	ClampAngles(FinalAngle);

	if (Value::bools::Aim::Smooth) {
		Vector2 delta = ClampAngle(FinalAngle - current_angle);
		ClampAngles(delta);
		FinalAngle.x = current_angle.x += delta.x / Value::floats::Aim::Smooth;
		FinalAngle.y = current_angle.y += delta.y / Value::floats::Aim::Smooth;
		FinalAngle = ClampAngles(FinalAngle);
	}

	Normalize(FinalAngle.y, FinalAngle.x);
	LocalPlayer.BasePlayer->SetVA(FinalAngle);

}

double ToRad(double degree)
{
	double pi = 3.14159265359;
	return (degree * (pi / 180));
}

Vector4 ToQuat(Vector3 Euler) {

	double heading = ToRad(Euler.x);
	double attitude = ToRad(Euler.y);
	double bank = ToRad(Euler.z);

	double c1 = cos(heading / 2);
	double s1 = sin(heading / 2);
	double c2 = cos(attitude / 2);
	double s2 = sin(attitude / 2);
	double c3 = cos(bank / 2);
	double s3 = sin(bank / 2);
	double c1c2 = c1 * c2;
	double s1s2 = s1 * s2;
	Vector4 Quat;
	Quat.w = c1c2 * c3 - s1s2 * s3;
	Quat.x = c1c2 * s3 + s1s2 * c3;
	Quat.y = s1 * c2 * c3 + c1 * s2 * s3;
	Quat.z = c1 * s2 * c3 - s1 * c2 * s3;
	Vector4 Quat2;
	Quat2 = { Quat.y, Quat.z, (Quat.x * -1), Quat.w };
	return Quat2;
}

void Aim(BasePlayer* player)
{
	if (Value::bools::Aim::Enable)
	{
		if (GetAsyncKeyState(0x58)) {
			//std::cout << "Target " << player->SteamID() << std::endl;
			BaseProjectile* ActWeapon = LocalPlayer.BasePlayer->ActiveWeapon();
			AimBotTarget(player);
		}
	}

	if (Value::bools::Aim::PSilent) {
		auto TargetBonePos = Prediction(LocalPlayer.BasePlayer->GBoneByID2(head), player, penis);

		Vector2 TargetAngles = Math::CalcAngle(LocalPlayer.BasePlayer->GBoneByID2(head), TargetBonePos);

		Vector2 Angles; Angles.x = TargetAngles.x, Angles.y = TargetAngles.y;

		UINT64 PlayerEyes = safe_read((uintptr_t)LocalPlayer.BasePlayer + oPlayerEyes, UINT64);
		Vector4 QuatAngles = ToQuat({ Angles.x, Angles.y, 0.0f });
		safe_write(PlayerEyes + 0x44, QuatAngles, Vector4);
		//LocalPlayer.BasePlayer->SetVA(FinalAngle);
	}
}
```

`UserMode/SDK/BasePlayer.h`:

```h
#pragma once
#include <xmmintrin.h>
#include <emmintrin.h>

enum BoneList : int
{
	l_hip = 1,
	l_knee,
	l_foot,
	l_toe,
	l_ankle_scale,
	pelvis,
	penis,
	GenitalCensor,
	GenitalCensor_LOD0,
	Inner_LOD0,
	GenitalCensor_LOD1,
	GenitalCensor_LOD2,
	r_hip,
	r_knee,
	r_foot,
	r_toe,
	r_ankle_scale,
	spine1,
	spine1_scale,
	spine2,
	spine3,
	spine4,
	l_clavicle,
	l_upperarm,
	l_forearm,
	l_hand,
	l_index1,
	l_index2,
	l_index3,
	l_little1,
	l_little2,
	l_little3,
	l_middle1,
	l_middle2,
	l_middle3,
	l_prop,
	l_ring1,
	l_ring2,
	l_ring3,
	l_thumb1,
	l_thumb2,
	l_thumb3,
	IKtarget_righthand_min,
	IKtarget_righthand_max,
	l_ulna,
	neck,
	head,
	jaw,
	eyeTranform,
	l_eye,
	l_Eyelid,
	r_eye,
	r_Eyelid,
	r_clavicle,
	r_upperarm,
	r_forearm,
	r_hand,
	r_index1,
	r_index2,
	r_index3,
	r_little1,
	r_little2,
	r_little3,
	r_middle1,
	r_middle2,
	r_middle3,
	r_prop,
	r_ring1,
	r_ring2,
	r_ring3,
	r_thumb1,
	r_thumb2,
	r_thumb3,
	IKtarget_lefthand_min,
	IKtarget_lefthand_max,
	r_ulna,
	l_breast,
	r_breast,
	BoobCensor,
	BreastCensor_LOD0,
	BreastCensor_LOD1,
	BreastCensor_LOD2,
	collision,
	displacement
};

typedef struct Str
{
	char stub[0x10];
	int len;
	wchar_t str[1];
} *str;


class BasePlayer
{
public:
	std::string playername;
	std::string prefabname;
	uintptr_t transform;
	int networkid;
	uintptr_t baseentity;
	uintptr_t PlayerWalkMovement;
	uintptr_t Items;
	int playerflags;
	uintptr_t input;
	Vector3 position;
	BaseProjectile* weapon;
	/*Player Info*/

	UINT_PTR GetName() {
		auto player_name = safe_read((uintptr_t)this + oPlayerName, UINT_PTR);
		return player_name;
	}

	UINT64 SteamID()
	{
		return safe_read((const uintptr_t)(const uintptr_t)this + oSteamID, UINT64);
	}

	float Health()
	{
		return safe_read((const uintptr_t)(const uintptr_t)this + oPlayerHealth, float);
	}

	bool Flags(int Flg)
	{
		return safe_read((const uintptr_t)(const uintptr_t)this + oPlayerFlags, int) & Flg;
	}

	bool Dead()
	{
		if (!(const uintptr_t)this) return true;
		return safe_read((const uintptr_t)(const uintptr_t)this + oLifestate, bool);
	}

	bool IsValid(bool LPlayer = false)
	{
		//std::cout << "ISvalid " <<Flags(16) << "  " << Dead() << " " << Health() << std::endl;
		if (!this) return false;
		float health = Health();
		UINT64 steam = SteamID();
		//std::cout << health << " " << steam;
		if (health > 150.f || health < 0.8f) return false;


		int nums = 0;
		do {
			nums++;
			steam /= 10;
		} while (steam > 0);
		//std::cout << " " << nums << std::endl;
		if (nums != 7 /*bot*/ && nums != 17 /*player*/) return false;
		return (((LPlayer || Value::bools::Visuals::ESP::IgnoreSleeper) ? !Flags(16) : true) && !Dead());
	}

	/*Vector*/

	Vector2 GVA()
	{
		UINT64 Input = safe_read((const uintptr_t)this + oPlayerInput, UINT64);
		return safe_read(Input + oBodyAngles, Vector2);
	}

	Vector3 GVelocity()
	{
		UINT64 PlayerModel = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerModel, UINT64);
		return safe_read(PlayerModel + 0x22C, Vector3); // 	private Vector3 newVelocity;
		//обновил
	}

	Vector3 GBoneByID2(BoneList BoneID) {
		return GetBone(GetTransform(BoneID));//GetBone
	}

	Vector3 GetBoneByID()
	{
		return GetBone(GetTransform(BoneList(neck)));
	}

	bool IsVisible() {
		if (Value::bools::Aim::VisibleCheck) {
			UINT64 PlayerModel = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerModel, UINT64);
			return safe_read(PlayerModel + oVisible, bool); 
		}
		else return true;
	}

	/*Fucktion*/

	void SetVA(const Vector2& VA)
	{
		UINT64 Input = safe_read((const uintptr_t)this + oPlayerInput, UINT64);
		safe_write(Input + oBodyAngles, VA, Vector2);
	}

	void FakeAdmin()
	{
		int Flags = safe_read((const uintptr_t)this + oPlayerFlags, int);
		safe_write((const uintptr_t)this + oPlayerFlags, (Flags |= 4), int);
	}



	void InfinityJump()
	{
		auto PlayerWalkMovement = safe_read((const uintptr_t)this + oPlayerMovement, uintptr_t);
		safe_write(PlayerWalkMovement + 0xD0, 0, float); //private float jumpTime;
		safe_write(PlayerWalkMovement + 0xD4, 0, float); //private float landTime;
		safe_write(PlayerWalkMovement + 0xCC, 10000, float); //private float groundTime;
	}

	void GravituMod()
	{
		UINT64 Movement = safe_read((const uintptr_t)this + oPlayerMovement, UINT64);
		float Gravity = 2.5f;
		if (GetKeyState(VK_MBUTTON))
		{
			safe_write(Movement + oGravityMultiplier, Gravity / Value::floats::Player::Gravity, float);
		}
		else
		{
			safe_write(Movement + oGravityMultiplier, Gravity, float);
		}
	}

	void SetFov()
	{
		auto Class = safe_read(game_assembly + oConVar, DWORD64);
		auto Field = safe_read(Class + 0xB8, DWORD64);
		safe_write(Field + 0x18, Value::floats::Player::CustomFov, float);
	}

	
	void WalkWater()
	{

		UINT64 modelState = safe_read((const uintptr_t)(const uintptr_t)this + oModelState, UINT64); // public ModelState modelState;
		UINT64 playerMovement = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerMovement, UINT64); // public BaseMovement movement;

		if (Value::bools::Misc::WalkOnWater) {



			static bool x130 = safe_read(playerMovement + oGrounded, bool);
			static float xB8 = safe_read(playerMovement + oGroundAngleNew, float);
			static float x74 = safe_read(playerMovement + oGravityMultiplier, float);
			static float x78 = safe_read(playerMovement + oGravityMultiplierSwimming, float);

			DWORD64 model = safe_read(oPlayerModel, DWORD64);
			int onLoader = safe_read(modelState + 0x2C, int);



			if (GBoneByID2(l_foot).y <= 1.0f)

			{

				safe_write(playerMovement + oGrounded, true, bool);
				safe_write(playerMovement + oGroundAngleNew, 0.f, float);
				safe_write(playerMovement + oGravityMultiplier, 0.f, float);
				safe_write(playerMovement + oGravityMultiplierSwimming, 0.f, float);
			}
			else
			{

				safe_write(playerMovement + oGrounded, x130, bool);
				safe_write(playerMovement + oGroundAngleNew, xB8, float);
				safe_write(playerMovement + oGravityMultiplier, x74, float);
				safe_write(playerMovement + oGravityMultiplierSwimming, x78, float);
			}
		}
	}

	void LongNeck() {

		DWORD64 eyes = safe_read((const uintptr_t)this + oPlayerEyes, DWORD64);
		safe_write(eyes + 0x38, Vector3(0, (1.6f), 0), Vector3);
	}

	void SpeedHack() {

		if (Value::bools::Misc::SpeedHack) {
			safe_write((const uintptr_t)(const uintptr_t)this + oSpeedReduction, -0.135, float);
		}
		else {
			safe_write((const uintptr_t)(const uintptr_t)this + oSpeedReduction, 0, float);
		}
	}


	void FlyHack()
	{
		UINT64 modelState = safe_read((const uintptr_t)(const uintptr_t)this + oModelState, UINT64); // public ModelState modelState;
		UINT64 playerMovement = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerMovement, UINT64); // public BaseMovement movement;

		if (Value::bools::Misc::FlyHack)
		{
			if (GetAsyncKeyState(0x46))
			{
				safe_write(modelState + owaterLevel, 2, float);
				safe_write(playerMovement + ogravityTestRadius, -2, float);
				safe_write(playerMovement + ogroundAngle, 0, float);
				safe_write(playerMovement + oGroundAngleNew, 0, float);
				safe_write(playerMovement + ocapsuleHeight, -300, float);
				safe_write(playerMovement + ocapsuleCenter, -300, float);

				if (GetAsyncKeyState(VK_SPACE))
					safe_write(playerMovement + oGravityMultiplier, Value::bools::Misc::FlyHack, float);
				else
					safe_write(playerMovement + oGravityMultiplier, 0.1, float);
			}
			else
			{
				safe_write(playerMovement + ogroundAngle, 0, float);
				safe_write(playerMovement + oGroundAngleNew, 50, float);
				safe_write(playerMovement + oGravityMultiplier, 2.5f, float);
				safe_write(playerMovement + ocapsuleHeight, 1.79f, float);
				safe_write(playerMovement + ocapsuleCenter, 0.899f, float);
			}
		}
	}


	void KillHack() {

		UINT64 modelState = safe_read((const uintptr_t)(const uintptr_t)this + oModelState, UINT64); // public ModelState modelState;
		UINT64 playerMovement = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerMovement, UINT64); // public BaseMovement movement;
		if (Value::bools::Misc::killhack)
		{
			if (GetAsyncKeyState(0x47)) // G 
			{

				safe_write(playerMovement + 0x14B, true, bool);
				safe_write(playerMovement + 0xE4, Vector3(101, -101, 101), Vector3);
				safe_write(playerMovement + 0xCC, 0.f, float);
			}
		}
	}

	void FixCamera()
	{
		auto klass = safe_read(game_assembly + oConClient, DWORD64);//ConVar_Client_c*
		auto camera = safe_read(klass + 0xB8, DWORD64);
		safe_write(camera + 0x2C, 1.f, float);
		safe_write(camera + 0x20, 1.f, float);
		safe_write(camera + 0x34, 1.f, float);
	}

	void Zoom()
	{

		if (GetAsyncKeyState(0x5A))//0x5A
		{

			auto klass = safe_read(game_assembly + oConVar, DWORD64);
			auto static_fields = safe_read(klass + 0xB8, DWORD64);
			safe_write(static_fields + 0x18, Value::floats::Player::Zoomvalue, float);
		}
		else
		{
			auto klass = safe_read(game_assembly + oConVar, DWORD64);
			auto static_fields = safe_read(klass + 0xB8, DWORD64);
			safe_write(static_fields + 0x18, Value::floats::Player::CustomFov, float);
		}
	}

	void todsky() {
		UINT64 klass = safe_read(game_assembly + oTOD_Sky, UINT64);
		UINT64 static_fields = safe_read(klass + 0xB8, UINT64);
		UINT64 instances = safe_read(static_fields, UINT64);
		UINT64 List = safe_read(instances + 0x10, UINT64);
		UINT64 TOD_Sky = safe_read(List + 0x20, UINT64);
		UINT64 night = safe_read(TOD_Sky + 0x58, UINT64);
		UINT64 ambient = safe_read(TOD_Sky + 0x90, UINT64);
		safe_write(night + 0x50, 6.f, float);
		safe_write(ambient + 0x18, 4.f, float);
	}
	void UpdateAmbient()
	{
		UINT64 klass = safe_read(game_assembly + oTOD_Sky, UINT64);
		UINT64 static_fields = safe_read(klass + 0xB8, UINT64);
		UINT64 instances = safe_read(static_fields, UINT64);
		UINT64 List = safe_read(instances + 0x10, UINT64);
		UINT64 TOD_Sky = safe_read(List + 0x20, UINT64);
		UINT64 ambient = safe_read(TOD_Sky + 0x90, UINT64);
		safe_write(ambient + 0x18, 720000.f, float);
	}

	

	void SpiderMan()
	{
		UINT64 Movement = safe_read((const uintptr_t)this + oPlayerMovement, UINT64);
		safe_write(Movement + oGroundAngleNew, 0.f, float);
	}

	/*Weapon Info*/
	BaseProjectile* WeaponInfo(int Id)
	{
		UINT64 Inventory = safe_read((const uintptr_t)this + oPlayerInventory, UINT64);
		UINT64 Belt = safe_read(Inventory + 0x28, UINT64);
		UINT64 ItemList = safe_read(Belt + 0x38, UINT64);
		UINT64 Items = safe_read(ItemList + 0x10, UINT64);
		return (BaseProjectile*)safe_read(Items + 0x20 + (Id * 0x8), UINT64);
	}

	BaseProjectile* ActiveWeapon()
	{
		int ActUID = safe_read((uintptr_t)this + oActiveUID, int);
		if (!ActUID) return nullptr;
		BaseProjectile* ActiveWeapon;
		for (int i = 0; i < 6; i++)
			if (ActUID == (ActiveWeapon = WeaponInfo(i))->UID()) {
				return ActiveWeapon;
			}
		return nullptr;
	}



	/*Local-Player*/
	bool IMenu()
	{
		if (!(const uintptr_t)this) return true;
		UINT64 Input = safe_read((const uintptr_t)(const uintptr_t)this + oPlayerInput, UINT64);
		return !(safe_read(Input + 0x94, bool));// private bool hasKeyFocus;
	}

	int GetTeamSize()
	{
		UINT64 ClientTeam = safe_read((const uintptr_t)(const uintptr_t)this + oClientTeam, UINT64); // valid
		UINT64 members = safe_read(ClientTeam + 0x30, UINT64);
		return safe_read(members + 0x18, UINT64);
	}

	UINT64 IsTeamMate(int Id)
	{
		UINT64 ClientTeam = safe_read((const uintptr_t)(const uintptr_t)this + oClientTeam, UINT64);
		UINT64 members = safe_read(ClientTeam + 0x30, UINT64);
		UINT64 List = safe_read(members + 0x10, UINT64);
		UINT64 player = safe_read(List + 0x20 + (Id * 0x8), UINT64);
		return safe_read(player + 0x20, UINT64);
	}

	std::string GetNamecChars() {
		return readstring(this->GetName());
	}

	std::string GetActiveWeaponcChars() {
		BaseProjectile* ActWeapon = this->ActiveWeapon();
		string ActiveWeaponName;
		if (!ActWeapon)
		{
			ActiveWeaponName = skCrypt("Empty");

		}
		else
		{
			ActiveWeaponName = readstring(ActWeapon->GetName());
		}
		return ActiveWeaponName;
	}

private:

	struct TransformAccessReadOnly
	{
		uint64_t pTransformData;
	};

	struct TransformData
	{
		uint64_t pTransformArray;
		uint64_t pTransformIndices;
	};

	struct Matrix34
	{
		Vector4 vec0;
		Vector4 vec1;
		Vector4 vec2;
	};



	Vector3 GetBone(ULONG_PTR pTransform)
	{
		__m128 result;

		const __m128 mulVec0 = { -2.000, 2.000, -2.000, 0.000 };
		const __m128 mulVec1 = { 2.000, -2.000, -2.000, 0.000 };
		const __m128 mulVec2 = { -2.000, -2.000, 2.000, 0.000 };

		TransformAccessReadOnly pTransformAccessReadOnly = safe_read(pTransform + 0x38, TransformAccessReadOnly);
		unsigned int index = safe_read(pTransform + 0x40, unsigned int);
		TransformData transformData = safe_read(pTransformAccessReadOnly.pTransformData + 0x18, TransformData);

		if (transformData.pTransformArray && transformData.pTransformIndices)
		{
			result = safe_read(transformData.pTransformArray + 0x30 * index, __m128);
			int transformIndex = safe_read(transformData.pTransformIndices + 0x4 * index, int);
			int pSafe = 0;
			while (transformIndex >= 0 && pSafe++ < 200)
			{
				Matrix34 matrix34 = safe_read(transformData.pTransformArray + 0x30 * transformIndex, Matrix34);

				__m128 xxxx = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0x00));	// xxxx
				__m128 yyyy = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0x55));	// yyyy
				__m128 zwxy = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0x8E));	// zwxy
				__m128 wzyw = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0xDB));	// wzyw
				__m128 zzzz = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0xAA));	// zzzz
				__m128 yxwy = _mm_castsi128_ps(_mm_shuffle_epi32(*(__m128i*)(&matrix34.vec1), 0x71));	// yxwy
				__m128 tmp7 = _mm_mul_ps(*(__m128*)(&matrix34.vec2), result);

				result = _mm_add_ps(
					_mm_add_ps(
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(xxxx, mulVec1), zwxy),
									_mm_mul_ps(_mm_mul_ps(yyyy, mulVec2), wzyw)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(tmp7), 0xAA))),
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(zzzz, mulVec2), wzyw),
									_mm_mul_ps(_mm_mul_ps(xxxx, mulVec0), yxwy)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(tmp7), 0x55)))),
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(yyyy, mulVec0), yxwy),
									_mm_mul_ps(_mm_mul_ps(zzzz, mulVec1), zwxy)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(tmp7), 0x00))),
							tmp7)), *(__m128*)(&matrix34.vec0));

				transformIndex = safe_read(transformData.pTransformIndices + 0x4 * transformIndex, int);
			}
		}

		return Vector3(result.m128_f32[0], result.m128_f32[1], result.m128_f32[2]);
	}

	DWORD64 GetTransform(int bone)
	{
		DWORD64 model = safe_read((const uintptr_t)this + 0x128, DWORD64);// public Model model;\\public class BaseEntity : BaseNetworkable, IProvider, ILerpTarget, IPrefabPreProcess // TypeDefIndex: 8714
		DWORD64 boneTransforms = safe_read(model + 0x48, DWORD64);//public Transform[] boneTransforms;
		DWORD64 BoneValue = safe_read((boneTransforms + (0x20 + (bone * 0x8))), DWORD64);
		return safe_read(BoneValue + 0x10, DWORD64);
	}
};


class LPlayerBase
{
public:
	BasePlayer* BasePlayer = nullptr;
	Matrix4x4* pViewMatrix = nullptr;
	bool WorldToScreen(const Vector3& EntityPos, Vector2& ScreenPos)
	{
		if (!pViewMatrix) return false;
		Vector3 TransVec = Vector3(safe_read((ULONG64)&pViewMatrix->_14, float), safe_read((ULONG64)&pViewMatrix->_24, float), safe_read((ULONG64)&pViewMatrix->_34, float));
		Vector3 RightVec = Vector3(safe_read((ULONG64)&pViewMatrix->_11, float), safe_read((ULONG64)&pViewMatrix->_21, float), safe_read((ULONG64)&pViewMatrix->_31, float));
		Vector3 UpVec = Vector3(safe_read((ULONG64)&pViewMatrix->_12, float), safe_read((ULONG64)&pViewMatrix->_22, float), safe_read((ULONG64)&pViewMatrix->_32, float));
		float w = Math::Dot(TransVec, EntityPos) + safe_read((ULONG64)&pViewMatrix->_44, float);
		if (w < 0.098f) return false;
		float y = Math::Dot(UpVec, EntityPos) + safe_read((ULONG64)&pViewMatrix->_42, float);
		float x = Math::Dot(RightVec, EntityPos) + safe_read((ULONG64)&pViewMatrix->_41, float);
		ScreenPos = Vector2((Value::floats::Screen::W / 2) * (1.f + x / w), (Value::floats::Screen::H / 2) * (1.f - y / w));
		return true;
	}

};

LPlayerBase LocalPlayer;
```

`UserMode/SDK/BaseProjectile.h`:

```h
#pragma once

const unsigned short Crc16Table[256] = {
0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};

class BaseProjectile
{
public:
	BaseProjectile* activeweapon;
	BaseProjectile* baseprojectile;
	/*Weapons info*/

	uintptr_t GetName()
	{
		DWORD64 Info = safe_read((uintptr_t)this + oItemDefinition, DWORD64);
		DWORD64 DispName = safe_read(Info + odisplayname, DWORD64);
		uintptr_t Str = (safe_read(DispName + 0x18, uintptr_t)); // default
		if (!Str) return 0; return Str;
	}

	int GetItemID()
	{
		UINT64 Info = safe_read((const uintptr_t)this + oItemDefinition, UINT64);
		return safe_read(Info + oItemid, int);
	}

	int UID()
	{
		return safe_read((const uintptr_t)this + 0x28, int);// public uint uid;//public class Item
	}

	/*Functions for weapons*/

	void SAutomatic()
	{
		if (Value::bools::Weapon::IsAutomatic)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write((const uintptr_t)Held + oAuto, 1, bool);
		}
	}


	void SuperBow()
	{
		if (Value::bools::Weapon::SuperBow)
		{
			DWORD64 Held = safe_read((const uintptr_t)this + oHeld, DWORD64);
			safe_write(Held + 0x360, 1, bool);
			safe_write(Held + 0x98, 1.f, float);
		}
	}

	void Spread()
	{
		if (Value::bools::Weapon::NoSpread)
		{
			DWORD64 Held = safe_read((const uintptr_t)this + oHeld, DWORD64);
			safe_write(Held + oStancePenalty, 0.f, float);
			safe_write(Held + oAimconePenalty, 0.f, float);
			safe_write(Held + oAimCone, 0.f, float);
			safe_write(Held + oHipAimCone, 0.f, float);
			safe_write(Held + oAimconePenaltyPerShot, 0.f, float);
		}
	}

	

	void SuperEoka()
	{
		if (Value::bools::Player::SuperEoka)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write(Held + oSuccessFraction, 1.f, float);
			safe_write(Held + 0x370, true);//private bool _didSparkThisFrame;
		}
	}

	void LongHand()
	{
		if (&Value::bools::Player::Longhand)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write(Held + 0x290, 4.5f, float);//public float maxDistance; //public class BaseMelee : AttackEntity
		}
	}

	/*void RunOnHit()
	{
		UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
		safe_write(Held + oBlockSprintOnAttack, 0, int);
	}*/

	void Recoil()
	{
		if (Value::bools::Weapon::NoRecoil)
		{
			DWORD64 Held = safe_read((const uintptr_t)this + oHeld, DWORD64);
			DWORD64 recoil = safe_read(Held + oRecoilProperties, DWORD64);
			safe_write(recoil + oRecoilMinYaw, Value::floats::Player::RCSyaw / 12 * 1.35, float);
			safe_write(recoil + oRecoilMaxYaw, Value::floats::Player::RCSyaw / 12 * 1.35, float);
			safe_write(recoil + oRecoilMinPitch, Value::floats::Player::RCSpitch / 12 * 1.35, float);
			safe_write(recoil + oRecoilMaxPitch, Value::floats::Player::RCSpitch / 12 * 1.35, float);
				
		}
	}

	void FBullet()
	{
		if (Value::bools::Weapon::FatBullet)
		{
			DWORD64 Held = safe_read((const uintptr_t)this + oHeld, DWORD64);
			DWORD64 List = safe_read(Held + 0x358, DWORD64); //private List<Projectile> createdProjectiles;
			int size = safe_read(List + 0x18, DWORD64);
			List = safe_read(List + 0x10, DWORD64);

			{
				for (int i = 0; i < size; ++i)
				{
					UINT64 Item = safe_read(List + 0x20 + (i * 0x8), UINT64);
					safe_write(Item + 0x2C, 2.0f, float);
				}
			}

		}
	}

	void rapidFire() {

		if (Value::bools::Misc::rapidFire)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write(Held + 0x1F4, 0.1, float);
			safe_write(Held + oAuto, true, bool); //this is automatic fire
		}
	}

	void fastSwitch() {
		if (Value::bools::Misc::fastSwitch)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write(Held + 0x1F0, 0, float);//deployDelay | instant deploy > AttackEntity
		}
	}

	void instantCompound() {
		if (Value::bools::Misc::instantCompound)
		{
			UINT64 Held = safe_read((const uintptr_t)(const uintptr_t)this + oHeld, UINT64);
			safe_write(Held + 0x378, 0);//stringHoldDurationMax
			safe_write(Held + 0x37C, 1000000);//stringBonusDamage
			safe_write(Held + 0x388, 1000000);//movementPenaltyRampUpTime
		}
	}

	unsigned short CRC(unsigned char* pcBlock, unsigned short len)
	{
		unsigned short crc = 0xFFFF;
		while (len--)
			crc = (crc << 8) ^ Crc16Table[(crc >> 8) ^ *pcBlock++];
		return crc;
	}

	wchar_t GShortName(int* len)
	{
		DWORD64 Info = safe_read((const uintptr_t)this + oItemDefinition, DWORD64);
		pUncStr Str = ((pUncStr)safe_read(Info + oShortname, DWORD64));
		int leng = safe_read((const uintptr_t)Str + 0x10, int);
		if (!leng) return NULL;
		if (len)*len = leng;
		return Str->str;
	}


	USHORT GetNameHash()
	{
		int Len;
		UCHAR* ShortName = (UCHAR*)GShortName(&Len);
		if (ShortName == nullptr) return 0;
		return CRC(ShortName, (Len * 2));
	}

private:
};

```

`UserMode/SDK/Math.h`:

```h
class Vector3
{
public:
	float x, y, z;

	float Magnitude()
	{
		return sqrt(this->x * this->x + this->y * this->y + this->z * this->z);
	}


	/* Used to normalize this vector */
	Vector3 Normalized()
	{
		/* Get the magnitude of this vector */
		float num = this->Magnitude();

		/* Check if number is more than max. */
		if (num > 9.99999974737875E-06)
		{
			return { this->x / num, this->y / num, this->z / num };
		}

		/* Return an empty vector */
		return Vector3();
	}

	inline Vector3() {
		x = y = z = 0.0f;
	}

	inline Vector3(float X, float Y, float Z) {
		x = X; y = Y; z = Z;
	}

	inline float operator[](int i) const {
		return ((float*)this)[i];
	}

	inline Vector3& operator-=(float v) {
		x -= v; y -= v; z -= v; return *this;
	}

	inline Vector3 operator*(float v) const {
		return Vector3(x * v, y * v, z * v);
	}

	inline Vector3 operator/(float v) const
	{
		return Vector3(x / v, y / v, z / v);
	}

	inline Vector3& operator+=(const Vector3& v) {
		x += v.x; y += v.y; z += v.z; return *this;
	}

	inline Vector3 operator-(const Vector3& v) const {
		return Vector3(x - v.x, y - v.y, z - v.z);
	}

	inline Vector3 operator+(const Vector3& v) const {
		return Vector3(x + v.x, y + v.y, z + v.z);
	}

	inline float Length() {
		return sqrtf(x * x + y * y + z * z);
	}
};

class Vector2 {
public:
	float x, y;

	inline Vector2() {
		x = y = 0.0f;
	}

	inline Vector2 operator/(float v) const {
		return Vector2(x / v, y / v);
	}
	inline Vector2(float X, float Y) {
		x = X; y = Y;
	}

	inline Vector2 operator-(const Vector2& v) const {
		return Vector2(x - v.x, y - v.y);
	}

	inline Vector2 operator+(const Vector2& v) const {
		return Vector2(x + v.x, y + v.y);
	}

	inline Vector2& operator+=(const Vector2& v) {
		x += v.x; y += v.y; return *this;
	}

	inline bool Zero() const {
		return (x > -0.1f && x < 0.1f && y > -0.1f && y < 0.1f);
	}
};

class Vector4 {
public:
	float x, y, z, w;
};

struct Matrix4x4 {
	union {
		struct {
			float        _11, _12, _13, _14;
			float        _21, _22, _23, _24;
			float        _31, _32, _33, _34;
			float        _41, _42, _43, _44;

		}; float m[4][4];
	};
};

namespace Math
{
#define M_PI 3.14159265358979323846f
#define M_RADPI	57.295779513082f
#define M_PI_F ((float)(M_PI))
#define RAD2DEG(x) ((float)(x) * (float)(180.f / M_PI_F))
#define DEG2RAD(x) ((float)(x) * (float)(M_PI_F / 180.f))
#define atan2(a, b) ((float)atan2((double)(a), (double)(b)))
	static volatile const double Infinity = INFINITY;
	typedef struct { double d0, d1; } double2;


	static inline double2 Add212RightSmaller(double2 a, double b)
	{
		double
			c0 = a.d0 + b,
			c1 = a.d0 - c0 + b + a.d1,
			d0 = c0 + c1,
			d1 = c0 - d0 + c1;
		return double2{ d0, d1 };
	}

	static inline double Add221RightSmaller(double2 a, double2 b)
	{
		double
			c0 = a.d0 + b.d0,
			c1 = a.d0 - c0 + b.d0 + b.d1 + a.d1,
			d0 = c0 + c1;
		return d0;
	}

	float abs(float a) {
		if (a < 0.f) return -a;
		else return a;
	}

	float asin(float x) {
		float negate = float(x < 0);
		x = abs(x);
		float ret = -0.0187293;
		ret *= x;
		ret += 0.0742610;
		ret *= x;
		ret -= 0.2121144;
		ret *= x;
		ret += 1.5707288;
		ret = 3.14159265358979 * 0.5 - sqrt(1.0 - x) * ret;
		return ret - 2 * negate * ret;
	}

	__forceinline float Dot(const Vector3& Vec1, const Vector3& Vec2) {
		return Vec1[0] * Vec2[0] + Vec1[1] * Vec2[1] + Vec1[2] * Vec2[2];
	}

	__forceinline float Calc3D_Dist(const Vector3& Src, const Vector3& Dst) {
		return sqrtf(pow((Src.x - Dst.x), 2) + pow((Src.y - Dst.y), 2) + pow((Src.z - Dst.z), 2));
	}

	__forceinline float Calc2D_Dist(const Vector2& Src, const Vector2& Dst) {
		return sqrt(powf(Src.x - Dst.x, 2) + powf(Src.y - Dst.y, 2));
	}

	__forceinline Vector2 CalcAngle(const Vector3& Src, const Vector3& Dst) {
		Vector3 dir = Src - Dst;
		return Vector2{ RAD2DEG(asin(dir.y / dir.Length())), RAD2DEG(-atan2(dir.x, -dir.z)) };
	}

}
```

`UserMode/SDK/Misc.h`:

```h
#pragma once

void Misc(UINT64 TodCycle)
{
	if (Value::bools::Visuals::World::AlwaysDay)
		safe_write(TodCycle + 0x10, Value::floats::Visuals::World::Time, float);

	if (Value::bools::Player::PlayerWalk::Spiderman)
		LocalPlayer.BasePlayer->SpiderMan();

	if (Value::bools::Player::PlayerWalk::FakeAdmin)
		LocalPlayer.BasePlayer->FakeAdmin();


	if (Value::floats::Player::LongNeck && GetAsyncKeyState(0x59)) {
		LocalPlayer.BasePlayer->LongNeck();
	}

	if (Value::bools::Misc::FlyHack)
		LocalPlayer.BasePlayer->FlyHack();

	if (Value::bools::Misc::SpeedHack)
		LocalPlayer.BasePlayer->SpeedHack();

	if (Value::bools::Misc::WalkOnWater)
		LocalPlayer.BasePlayer->WalkWater();

	if (Value::bools::Misc::killhack)
		LocalPlayer.BasePlayer->KillHack();

	if (Value::bools::Misc::FixCamera)
		LocalPlayer.BasePlayer->FixCamera();

	if (Value::bools::Player::PlayerWalk::ChangeGravity)
		LocalPlayer.BasePlayer->GravituMod();

	if (Value::bools::Player::PlayerWalk::InfinityJump)
		LocalPlayer.BasePlayer->InfinityJump();

	if (Value::bools::Player::CustomFov)
		LocalPlayer.BasePlayer->SetFov();

	if (Value::bools::Player::Zoom)
		LocalPlayer.BasePlayer->Zoom();

	if (Value::bools::Visuals::World::NightModeup)
		LocalPlayer.BasePlayer->todsky();

	if (Value::bools::Visuals::World::FixAmbient)
		LocalPlayer.BasePlayer->UpdateAmbient();

}
```

`UserMode/Value.h`:

```h
#pragma once
namespace Value {
    float menux = 0;
    float menuy = 0;
    namespace bools {
        namespace Aim {
            bool Enable, VisibleCheck, IgnoreTeam, TargetLine, Fov, Smooth, IgnoreSleepers;
            bool PSilent;
        }
        namespace Player {
            bool CustomFov;
            bool Zoom = false;
            bool Longhand = false;
            bool SuperEoka = false;
            namespace PlayerWalk {
                bool Spiderman = true, FakeAdmin, ChangeGravity, InfinityJump;//DebugBypass AntiAim InfinityJump
            }
            namespace PlayerModel {
            }
        }

        namespace Visuals {
            namespace PlayerPanel {
                bool Enable = true, Name, HP, Weapons;
            }
            namespace ESP {
                bool Enable, Player, NPC, IgnoreSleeper, Corpse, Backpack;
                bool Name, Box = true, Distance, SteamID, Health = true, Weapon = true;
            }
            namespace World {
                namespace Items {
                    bool Stash, Hemp, AirDrop, CH47, Minicopter, Patrol;
                    namespace Ore {
                        bool Stone, Iron, Sulfur;
                    }
                }
                bool AlwaysDay, NightModeup, FixAmbient;

            }
            namespace Radar {
                bool Enable, Sleeper;
            }
        }
        namespace Misc {
            bool killhack = false;
            int killhackkey = 0;
            int FlyHackkey = 0;
            bool WalkOnWater = false;
            bool FixCamera = false;
            bool FlyHack = false;
            bool SpeedHack = false;
            bool rapidFire = false;
            bool fastSwitch = false;
            bool instantCompound = false;
        }
        namespace Weapon {
            bool IsAutomatic, NoSpread, NoRecoil, FatBullet, SuperBow;
        }
    }
    namespace floats {
        namespace Aim {
            int Distance = 400;
            int Fov = 50;
            float Smooth = 5;
        }
        namespace Screen {
            float H;
            float W;
        }
        namespace Player {
            float CustomFov = 90;
            float Gravity = 2;
            float Zoomvalue = 20.f;
            int zoomKey = 0;
            int RCSyaw = 0;
            bool LongNeck = false;
            int LongNeckKey = 0;
            int RCSpitch = 0;
        }
        namespace Visuals {
            namespace World {
                int LimitDistance = 100;
                int LimitDistance2 = 2000;
                int Time = 9;
            }
            namespace Radar {
                int Radius = 100;
                int Distance = 100;
            }
        }
    }
    namespace Colors {
        namespace Aim {
            float Fov[] = { 0.7, 0.7, 0.7, 1 };
            float TargetLine[] = { 0.7, 0.7, 0.7, 1 };
        }
        namespace Visuals {
            namespace ESP {
                float Weapon[] = { 0.7, 0.7, 0.7, 1 };
                float Box[] = { 0.7, 0.7, 0.7, 1 };
                float Name[] = { 0.7, 0.7, 0.7, 1 };
                float Health[] = { 0.7, 0.7, 0.7, 1 };
                float Distance[] = { 0.7, 0.7, 0.7, 1 };
            }
            namespace World {
                float Stash[] = { 0, 0.25 , 1, 1 };
                float Hemp[] = { 0, 1 , 0, 1 };
                float AirDrop[] = { 0.4, 0 ,1, 1 };
                float CH47[] = { 1, 0 , 0, 1 };
                float Minicopter[] = { 0.45, 1 ,0, 1 };
                float Patrol[] = { 0, 1 ,1, 1 };
                float Corpse[] = { 0.45, 1 ,0, 1 };
                float Backpack[] = { 0, 1 ,1, 1 };
                namespace Ore {
                    float Stone[] = { 0.86, 0.86 , 0.86, 1 };
                    float Iron[] = { 1, 0.58 ,0, 1 };
                    float Sulfur[] = { 1, 1 , 0, 1 };
                }
            }
        }
    }
}

```

`UserMode/common.h`:

```h
#pragma once
#include <windows.h>
#include <winternl.h>
#include <process.h>
#include <tlhelp32.h>
#include <inttypes.h>
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <chrono>
#include <sstream>
#include <memory>
#include <string_view>
#include <cstdint>
#include <string>
#include <cmath>
#include <thread>
#include <cassert>
#include <xstring>
#include <dwmapi.h>
#include <vector>
#include <map>
#include <array>
#include <sstream>
#include <fstream>
#include <direct.h>

#pragma comment (lib, "d3d9.lib")

#include "Imgui/imgui.h"
#include "Imgui/imgui_impl_dx9.h"
#include "Imgui/imgui_impl_win32.h"

inline ImFont* m_pFont;
inline ImFont* m_pFont2;

```

`UserMode/skCrypt.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________
Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file
skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+
							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________
MIT License
Copyright (c) 2020 skadro
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
________________________________________________________________________________*/
```