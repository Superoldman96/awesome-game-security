Project Path: arc_gmh5225_GarHal_CSGO_hh6r4j1v

Source Tree:

```txt
arc_gmh5225_GarHal_CSGO_hh6r4j1v
├── Garhal
│   ├── Garhal.inf
│   ├── Garhal.vcxproj
│   ├── Garhal.vcxproj.filters
│   ├── communication.c
│   ├── communication.h
│   ├── data.h
│   ├── events.c
│   ├── events.h
│   ├── garhal.c
│   ├── garhal.h
│   ├── gstructs.h
│   ├── hide.c
│   ├── hide.h
│   ├── memory.c
│   ├── memory.h
│   ├── messages.h
│   ├── ntos.h
│   ├── vector.c
│   └── vector.h
├── Garhal.sln
├── GarhalController
│   ├── Aimbot.cpp
│   ├── Aimbot.hpp
│   ├── AntiAim.cpp
│   ├── AntiAim.hpp
│   ├── BSPFile.cpp
│   ├── BSPFile.hpp
│   ├── BSPFlags.hpp
│   ├── BSPParser.cpp
│   ├── BSPParser.hpp
│   ├── BSPStructure.hpp
│   ├── CInput.h
│   ├── CUserCmd.h
│   ├── ClientMode.h
│   ├── Engine.cpp
│   ├── Engine.hpp
│   ├── Entity.cpp
│   ├── Entity.hpp
│   ├── GarhalController.cpp
│   ├── GarhalController.vcxproj
│   ├── GarhalController.vcxproj.filters
│   ├── Matrix.hpp
│   ├── TraceRay.cpp
│   ├── TraceRay.hpp
│   ├── communications.hpp
│   ├── config.cpp
│   ├── config.hpp
│   ├── data.hpp
│   ├── garhal.cfg
│   ├── kernelinterface.hpp
│   ├── offsets.hpp
│   └── sdk.hpp
├── GarhalRankDisplayer
│   ├── GarhalRankDisplayer.cpp
│   ├── GarhalRankDisplayer.vcxproj
│   ├── GarhalRankDisplayer.vcxproj.filters
│   ├── communications.hpp
│   ├── data.hpp
│   ├── kernelinterface.hpp
│   └── offsets.hpp
├── LICENSE.md
└── README.md

```

`Garhal.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29920.165
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Garhal", "Garhal\Garhal.vcxproj", "{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GarhalController", "GarhalController\GarhalController.vcxproj", "{D6B514C9-9BC2-409C-82C6-594AECF81411}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GarhalRankDisplayer", "GarhalRankDisplayer\GarhalRankDisplayer.vcxproj", "{1FA067F6-A100-48E2-976A-1D0A3187247A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x64.ActiveCfg = Debug|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x64.Build.0 = Debug|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x64.Deploy.0 = Debug|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x86.ActiveCfg = Debug|Win32
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x86.Build.0 = Debug|Win32
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Debug|x86.Deploy.0 = Debug|Win32
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x64.ActiveCfg = Release|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x64.Build.0 = Release|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x64.Deploy.0 = Release|x64
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x86.ActiveCfg = Release|Win32
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x86.Build.0 = Release|Win32
		{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}.Release|x86.Deploy.0 = Release|Win32
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Debug|x64.ActiveCfg = Debug|x64
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Debug|x64.Build.0 = Debug|x64
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Debug|x86.ActiveCfg = Debug|Win32
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Debug|x86.Build.0 = Debug|Win32
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Release|x64.ActiveCfg = Release|x64
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Release|x64.Build.0 = Release|x64
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Release|x86.ActiveCfg = Release|Win32
		{D6B514C9-9BC2-409C-82C6-594AECF81411}.Release|x86.Build.0 = Release|Win32
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Debug|x64.ActiveCfg = Debug|x64
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Debug|x64.Build.0 = Debug|x64
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Debug|x86.ActiveCfg = Debug|Win32
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Debug|x86.Build.0 = Debug|Win32
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Release|x64.ActiveCfg = Release|x64
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Release|x64.Build.0 = Release|x64
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Release|x86.ActiveCfg = Release|Win32
		{1FA067F6-A100-48E2-976A-1D0A3187247A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4A5DEFDC-186A-41A4-ADD9-2D0A98F7B98C}
	EndGlobalSection
EndGlobal

```

`Garhal/Garhal.inf`:

```inf
;
; Garhal.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Garhal.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
Garhal_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Garhal.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Garhal.DeviceDesc%=Garhal_Device, Root\Garhal ; TODO: edit hw-id

[Garhal_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Garhal.sys

;-------------- Service installation
[Garhal_Device.NT.Services]
AddService = Garhal,%SPSVCINST_ASSOCSERVICE%, Garhal_Service_Inst

; -------------- Garhal driver install sections
[Garhal_Service_Inst]
DisplayName    = %Garhal.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Garhal.sys

;
;--- Garhal_Device Coinstaller installation ------
;

[Garhal_Device.NT.CoInstallers]
AddReg=Garhal_Device_CoInstaller_AddReg
CopyFiles=Garhal_Device_CoInstaller_CopyFiles

[Garhal_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Garhal_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Garhal_Device.NT.Wdf]
KmdfService =  Garhal, Garhal_wdfsect
[Garhal_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Garhal Installation Disk"
Garhal.DeviceDesc = "Garhal Device"
Garhal.SVCDESC = "Garhal Service"

```

`Garhal/Garhal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D1C93D8F-7063-41DC-AA36-F1B91FA96C56}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Garhal</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>true</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Garhal.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="communication.c" />
    <ClCompile Include="events.c" />
    <ClCompile Include="garhal.c" />
    <ClCompile Include="hide.c" />
    <ClCompile Include="memory.c" />
    <ClCompile Include="vector.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="communication.h" />
    <ClInclude Include="data.h" />
    <ClInclude Include="events.h" />
    <ClInclude Include="garhal.h" />
    <ClInclude Include="gstructs.h" />
    <ClInclude Include="hide.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="messages.h" />
    <ClInclude Include="ntos.h" />
    <ClInclude Include="vector.h" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="..\README.md">
      <Link>README.md</Link>
    </Content>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Garhal/Garhal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Garhal.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="garhal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="communication.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="events.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="data.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hide.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="messages.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="gstructs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="garhal.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="communication.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="events.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hide.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vector.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Garhal/communication.c`:

```c
#pragma warning( disable : 4100 4047 4024 4022 4201 4311 4057 4213 4189 4081 4189 4706 4214 4459 4273)

#include "data.h"
#include "messages.h"
#include "communication.h"
#include "memory.h"


NTSTATUS CreateCall(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS CloseCall(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

// IOCTL Call Handler function

NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS Status;
	ULONG BytesIO = 0;

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

	// Code received from user space
	ULONG ControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	if (ControlCode == IO_READ_REQUEST)
	{
		// Get the input buffer & format it to our struct
		PKERNEL_READ_REQUEST ReadInput = (PKERNEL_READ_REQUEST)Irp->AssociatedIrp.SystemBuffer;

		PEPROCESS Process;

		// Get our process
		if (NT_SUCCESS(PsLookupProcessByProcessId(ReadInput->ProcessId, &Process))) {

			//read from ReadInput->Address and write it to pBuff so we can use the data in our controller
			KeReadVirtualMemory(Process, ReadInput->Address, ReadInput->pBuff, ReadInput->Size);
		}

		//DebugMessageNormal("Read Params:  %lu, %#010x \n", ReadInput->ProcessId, ReadInput->Address);
		//DebugMessageNormal("Value: %lu \n", ReadOutput->Response);

		Status = STATUS_SUCCESS;
		BytesIO = sizeof(KERNEL_READ_REQUEST);
	}
	else if (ControlCode == IO_WRITE_REQUEST)
	{
		// Get the input buffer & format it to our struct
		PKERNEL_WRITE_REQUEST WriteInput = (PKERNEL_WRITE_REQUEST)Irp->AssociatedIrp.SystemBuffer;

		PEPROCESS Process;
		// Get our process
		if (NT_SUCCESS(PsLookupProcessByProcessId(WriteInput->ProcessId, &Process))) {
			// copy the value of pBuff to WriteInput->Address
			KeWriteVirtualMemory(Process, WriteInput->pBuff, WriteInput->Address, WriteInput->Size);
		}

		//DebugMessageNormal("Write Params:  %lu, %#010x \n", WriteInput->Value, WriteInput->Address);

		Status = STATUS_SUCCESS;
		BytesIO = sizeof(KERNEL_WRITE_REQUEST);
	}
	else if (ControlCode == IO_GET_ID_REQUEST)
	{
		PULONG OutPut = (PULONG)Irp->AssociatedIrp.SystemBuffer;

		if (IsManualMapped)
		{
			vector processes;
			vector_init(&processes);
			FindProcessByName("csgo.exe", &processes);

			// Did we find csgo?
			if (vector_total(&processes) > 0)
			{
				// First should be good.
				PEPROCESS proc = (PEPROCESS) vector_get(&processes, 0);
				CsgoID = (ULONG) PsGetProcessId(proc);
				
				MODULEENTRY ClientEntry = GetProcessModule(proc, L"client.dll");
				MODULEENTRY EngineEntry = GetProcessModule(proc, L"engine.dll");

				ClientAddress = ClientEntry.Address;
				EngineAddress = EngineEntry.Address;
				ClientSize = ClientEntry.Size;
				EngineSize = EngineEntry.Size;
			}
			vector_free(&processes);
		}
		
		*OutPut = CsgoID;

		DebugMessageNormal("A UserMode Application requested the ProcessID: %#010x \n", CsgoID);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(*OutPut);
	}
	else if (ControlCode == IO_GET_MODULE_REQUEST)
	{
		PULONG OutPut = (PULONG)Irp->AssociatedIrp.SystemBuffer;
		*OutPut = ClientAddress;

		DebugMessageNormal("A UserMode Application requested the ClientAddress: %#010x \n", ClientAddress);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(*OutPut);
	}
	else if (ControlCode == IO_GET_ENGINE_MODULE_REQUEST)
	{
		PULONG OutPut = (PULONG)Irp->AssociatedIrp.SystemBuffer;
		*OutPut = EngineAddress;

		DebugMessageNormal("A UserMode Application requested the EngineAddress: %#010x \n", EngineAddress);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(*OutPut);
	}
	else if (ControlCode == IO_GET_MODULE_REQUEST_LENGTH)
	{
		PULONG OutPut = (PULONG)Irp->AssociatedIrp.SystemBuffer;
		*OutPut = ClientSize;

		DebugMessageNormal("A UserMode Application requested the size of Client: %#010x \n", ClientSize);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(*OutPut);
	}
	else if (ControlCode == IO_GET_ENGINE_MODULE_REQUEST_LENGTH)
	{
		PULONG OutPut = (PULONG)Irp->AssociatedIrp.SystemBuffer;
		*OutPut = EngineSize;

		DebugMessageNormal("A UserMode Application requested the size of Engine: %#010x \n", EngineSize);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(*OutPut);
	}
	else if (ControlCode == IO_PROTECT_CONTROLLER)
	{
		ProtectController = 1;
		DebugMessageNormal("IO_PROTECT_CONTROLLER received. Controller is marked ready, and fully protected. \n");
		Status = STATUS_SUCCESS;
	}
	else if (ControlCode == IO_PROTECT_RANKREADER)
	{
		ProtectRankReader = 1;
		DebugMessageNormal("IO_PROTECT_RANKREADER received. RankReader is marked ready, and fully protected. \n");
		Status = STATUS_SUCCESS;
	}
	else
	{
		// if the code is unknown
		Status = STATUS_INVALID_PARAMETER;
	}

	// Complete the request
	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = BytesIO;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return Status;
}
```

`Garhal/communication.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntdef.h>

// Request to read virtual user memory (memory of a program) from kernel space
#define IO_READ_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0666 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to write virtual user memory (memory of a program) from kernel space
#define IO_WRITE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0667 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the process id of csgo process, from kernel space
#define IO_GET_ID_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0668 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of client.dll in csgo.exe from kernel space
#define IO_GET_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0669 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of engine.dll in csgo.exe from kernel space
#define IO_GET_ENGINE_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0670 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request size of Client.dll
#define IO_GET_MODULE_REQUEST_LENGTH CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0671 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request size of Engine.dll
#define IO_GET_ENGINE_MODULE_REQUEST_LENGTH CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0672 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Order driver to apply full protection on Controller
#define IO_PROTECT_CONTROLLER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0673 /* Our Custom Code */, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

// Order driver to apply full protection on RankReader
#define IO_PROTECT_RANKREADER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0674 /* Our Custom Code */, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

// Declare the IoControl function.
NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);

NTSTATUS CloseCall(PDEVICE_OBJECT DeviceObject, PIRP irp);

NTSTATUS CreateCall(PDEVICE_OBJECT DeviceObject, PIRP irp);


// datatype for read request
typedef struct _KERNEL_READ_REQUEST
{
	ULONG ProcessId;

	ULONG Address;
	PVOID pBuff;
	ULONG Size;

} KERNEL_READ_REQUEST, * PKERNEL_READ_REQUEST;

typedef struct _KERNEL_WRITE_REQUEST
{
	ULONG ProcessId;

	ULONG Address;
	PVOID pBuff;
	ULONG Size;

} KERNEL_WRITE_REQUEST, * PKERNEL_WRITE_REQUEST;
```

`Garhal/data.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include "vector.h"

// We store every value here.
ULONG CsgoID, ClientAddress, EngineAddress, ClientSize, EngineSize, ControllerID, RankReaderID, ProtectController, ProtectRankReader;
PDEVICE_OBJECT pDeviceObject;
UNICODE_STRING dev, dos;
vector CSRSSList;
BOOLEAN IsManualMapped;


// Constants
#define EnableProcessHiding 0 // Used to hide our process.
#define EnableDriverHiding 0 // Used to hide our driver.

#define PROCESS_QUERY_LIMITED_INFORMATION 0x1000
#define PROCESS_VM_OPERATION 0x0008
#define PROCESS_VM_READ 0x0010
#define PROCESS_VM_WRITE 0x0020
#define PROCESS_TERMINATE 0x0001

typedef struct _OB_REG_CONTEXT {
	USHORT Version;
	UNICODE_STRING Altitude;
	USHORT ulIndex;
	OB_OPERATION_REGISTRATION* OperationRegistration;
} REG_CONTEXT, * PREG_CONTEXT;
```

`Garhal/events.c`:

```c
#pragma warning( disable : 4100 4047 4024 4022 4201 4311 4057 4213 4189 4081 4189 4706 4214 4459 4273 4242 4244 4127)

#include "data.h"
#include "messages.h"
#include "events.h"
#include "hide.h"
#include "memory.h"

// Find our required PE image.
PLOAD_IMAGE_NOTIFY_ROUTINE ImageLoadCallback(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo)
{
	//DebugMessageNormal("We received a load from: %ls \n", FullImageName->Buffer);

	// Compare our string to input
	if (wcsstr(FullImageName->Buffer, L"\\csgo\\bin\\client.dll"))
	{
		DebugMessageNormal("CSGO client.dll found!\n");
		DebugMessageNormal("Loaded Name: %ls \n", FullImageName->Buffer);
		DebugMessageNormal("Loaded To Process: %d \n", (ULONG) ProcessId);

		ClientAddress = (ULONG) ImageInfo->ImageBase;
		ClientSize = (ULONG) ImageInfo->ImageSize;
		CsgoID = (ULONG) ProcessId;

		// Free, and re-init the vector every time CSGO loads up.
		vector_free(&CSRSSList);
		vector_init(&CSRSSList);

		FindProcessByName("csrss.exe", &CSRSSList);

		DebugMessageNormal("csrss.exe Count: %d\r\n", vector_total(&CSRSSList));
	}
	else if (wcsstr(FullImageName->Buffer, L"\\Counter-Strike Global Offensive\\bin\\engine.dll"))
	{
		DebugMessageNormal("CSGO Engine.dll found!\n");

		EngineAddress = (ULONG) ImageInfo->ImageBase;
		EngineSize = (ULONG) ImageInfo->ImageSize;
	}

	return STATUS_SUCCESS;
}

PCREATE_PROCESS_NOTIFY_ROUTINE_EX ProcessNotifyCallbackEx(HANDLE parentId, HANDLE processId, PPS_CREATE_NOTIFY_INFO notifyInfo)
{
	// NotifyInfo is filled when a process is created. Otherwise terminated.
	if (notifyInfo)
	{
		//DebugMessageNormal("PID = %d\r\n", processId);
		//DebugMessageNormal("Process Full Path: %ls \n", notifyInfo->ImageFileName->Buffer);
		if (wcsstr(notifyInfo->ImageFileName->Buffer, L"\\GarhalController.exe"))
		{
			DebugMessageNormal("Bomb has been planted!\n");
			ControllerID = (ULONG) processId;
			DebugMessageNormal("Controller ProcessID: %d\r\n", ControllerID);

			if (EnableProcessHiding == 1)
			{
				UINT32 intmadafaka = (UINT32) processId;

				DebugMessageNormal("Hidden APP = %d\r\n", intmadafaka);
				HideProcess(intmadafaka);
			}
		}
		else if (wcsstr(notifyInfo->ImageFileName->Buffer, L"\\GarhalRankDisplayer.exe"))
		{
			RankReaderID = (ULONG) processId;
			DebugMessageNormal("RankReaderID ProcessID: %d\r\n", RankReaderID);

			if (EnableProcessHiding == 1)
			{
				UINT32 intmadafaka = (UINT32) processId;

				DebugMessageNormal("Hidden APP = %d\r\n", intmadafaka);
				HideProcess(intmadafaka);
			}
		}
	}
	else
	{
		ULONG ProcID = (ULONG) processId;
		if (ControllerID == ProcID)
		{
			DebugMessageNormal("Controller Shutdown detected, disabling protection. %d\r\n", ControllerID);
			ControllerID = 0;
			ProtectController = 0;
		}
		else if (RankReaderID == ProcID)
		{
			DebugMessageNormal("RankReader Shutdown detected, disabling protection. %d\r\n", RankReaderID);
			RankReaderID = 0;
			ProtectRankReader = 0;
		}
		else if (CsgoID == ProcID)
		{
			DebugMessageNormal("CSGO Shutdown detected, zeroing addresses. %d\r\n", CsgoID);
			CsgoID = 0;
			ClientAddress = 0;
			EngineAddress = 0;
			ClientSize = 0;
			EngineSize = 0;
		}
	}

	return STATUS_SUCCESS;
}

// TBT 2014 https://www.unknowncheats.me/wiki/Valve_Anti-Cheat:VAC_external_tool_detection_(and_more)
// Since a recent silent update Valve is being retarded about open handles(which are caused by OpenProcess).
// You can avoid this by restricting access to your external hack and csgo by using ObRegisterCallbacks
// You should go with ObRegisterCallbacks and permit query on csgo(0x0400 PROCESS QUERY INFORMATION) / protect your external hack from all access.
// Even Mambda mentioned the same in 2016 on guidedhacking, and a 2013 reversal validates it:
// Opens a process to every handle running with query_information and vm_read , tries to get their name and do some more things that i can't see yet.
// Course of action here for my external :
// Strip handles of those values^, i don't really care about anything else. They can't get my name if they dont have the privileges to.Also they couldn't find it on file if they tried.
OB_PREOP_CALLBACK_STATUS OBRegisterCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	// Our controller or CSGO is not running yet.
	if (ControllerID == 0 || CsgoID == 0)
	{
		return OB_PREOP_SUCCESS;
	}

	PEPROCESS OpenedProcess = (PEPROCESS)OperationInformation->Object;
	ULONG OpenedProcessID = (ULONG)PsGetProcessId(OpenedProcess);
	PEPROCESS CurrentProcess = PsGetCurrentProcess();

	// Allow any driver to get the handle.
	if (OperationInformation->KernelHandle == 1 || OpenedProcess == CurrentProcess)
	{
		return OB_PREOP_SUCCESS;
	}

	// Make sure not to strip csrss's Handle, will cause BSOD
	for (int i = 0; i < vector_total(&CSRSSList); i++)
	{
		PEPROCESS CSRSS = (PEPROCESS)vector_get(&CSRSSList, i);
		ULONG procid = (ULONG)PsGetProcessId(CSRSS);
		if (procid == OpenedProcessID)
		{
			return OB_PREOP_SUCCESS;
		}
	}

	// Ensure we don't fuck with CSGO.
	if (CsgoID == OpenedProcessID)
	{
		return OB_PREOP_SUCCESS;
	}

	// If VAC is trying get information say fuck you. (Change the access completely)
	// https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
	if (OpenedProcessID == ControllerID && ProtectController == 1)
	{
		if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE) 
		{
			OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = (SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION);
			DebugMessageNormal("OB_OPERATION_HANDLE_CREATE for Controller denied.\n");
		}
		else
		{
			OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess = (SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION);
			DebugMessageNormal("OB_OPERATION_HANDLE_CREATE Duplicate for Controller denied.\n");
		}
	}
	else if (OpenedProcessID == RankReaderID && ProtectRankReader == 1)
	{
		if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
		{
			OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = (SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION);
			DebugMessageNormal("OB_OPERATION_HANDLE_CREATE for RankReader denied.\n");
		}
		else
		{
			OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess = (SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION);
			DebugMessageNormal("OB_OPERATION_HANDLE_CREATE Duplicate for RankReader denied.\n");
		}
	}

	return OB_PREOP_SUCCESS;
}
```

`Garhal/events.h`:

```h
#pragma once
#include <ntifs.h>

PLOAD_IMAGE_NOTIFY_ROUTINE ImageLoadCallback(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo);

PCREATE_PROCESS_NOTIFY_ROUTINE_EX ProcessNotifyCallbackEx(HANDLE parentId, HANDLE processId, PPS_CREATE_NOTIFY_INFO notifyInfo);

OB_PREOP_CALLBACK_STATUS OBRegisterCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation);
```

`Garhal/garhal.c`:

```c
#pragma warning( disable : 4100 4047 4024 4022 4201 4311 4057 4213 4189 4081 4189 4706 4214 4459 4273 4127 26451 4133 4244)

/*
 * GarHal CSGO Specific Kernel Driver by DreTaX.
 * Lectured by Life45
 */

#include "garhal.h"
#include "data.h"
#include "messages.h"
#include "communication.h"
#include "events.h"
#include "ntos.h"
#include "gstructs.h"

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject)
{
	DebugMessageNormal("======================================\n");
	DebugMessageNormal("Garhal CSGO External hack By DreTaX\n");
	DebugMessageNormal("Shutting down...\n");

	if (!IsManualMapped) 
	{
		PsRemoveLoadImageNotifyRoutine(ImageLoadCallback);
	}
	
	IoDeleteSymbolicLink(&dos);
	IoDeleteDevice(pDriverObject->DeviceObject);

	// Delete the processnotify routine
	PsSetCreateProcessNotifyRoutineEx(ProcessNotifyCallbackEx, TRUE);

	vector_free(&CSRSSList);

	if (OBRegisterHandle)
	{
		ObUnRegisterCallbacks(OBRegisterHandle);
		OBRegisterHandle = NULL;
	}

	DebugMessageNormal("Shutdown Complete!\n");

	return STATUS_SUCCESS;
}

// Driver Entrypoint
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)
{
	DebugMessageNormal("======================================\n");
	DebugMessageNormal("Garhal CSGO External hack By DreTaX\n");
	DebugMessageNormal("Starting...\n");

	if (!IsManualMapped) 
	{
		PsSetLoadImageNotifyRoutine(ImageLoadCallback);
	}

	RtlInitUnicodeString(&dev, L"\\Device\\garhalop");
	RtlInitUnicodeString(&dos, L"\\DosDevices\\garhalop");

	IoCreateDevice(pDriverObject, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
	IoCreateSymbolicLink(&dos, &dev);

	pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCall;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseCall;
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl;
	pDriverObject->DriverUnload = UnloadDriver;

	pDeviceObject->Flags |= DO_DIRECT_IO;
	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	NTSTATUS reg = RegisterOBCallback();
	if (reg == STATUS_SUCCESS)
	{
		DebugMessageNormal("ObRegisterCallbacks Succeeded.\n");
	}
	else
	{
		DebugMessageNormal("ObRegisterCallbacks Failed!\n");
	}

	// Set up the CreateProcess routine.
	PsSetCreateProcessNotifyRoutineEx(ProcessNotifyCallbackEx, FALSE);

	// Change in data.h to enable.
	if (EnableProcessHiding == 1)
	{
		DebugMessageNormal("Process hiding feature is enabled.\n");
		DebugMessageNormal("You may get BSOD if you have the Windows PatchGuard running. (Very frequently.)\n");
	}
	else
	{
		DebugMessageNormal("Process hiding feature is disabled.\n");
	}

	// Change in data.h to enable.
	if (EnableDriverHiding == 1)
	{
		PLDR_DATA_TABLE_ENTRY CurDriverEntry = (PLDR_DATA_TABLE_ENTRY)pDriverObject->DriverSection;
		PLDR_DATA_TABLE_ENTRY NextDriverEntry = (PLDR_DATA_TABLE_ENTRY)CurDriverEntry->InLoadOrderLinks.Flink;
		PLDR_DATA_TABLE_ENTRY PrevDriverEntry = (PLDR_DATA_TABLE_ENTRY)CurDriverEntry->InLoadOrderLinks.Blink;

		PrevDriverEntry->InLoadOrderLinks.Flink = CurDriverEntry->InLoadOrderLinks.Flink;
		NextDriverEntry->InLoadOrderLinks.Blink = CurDriverEntry->InLoadOrderLinks.Blink;

		CurDriverEntry->InLoadOrderLinks.Flink = (PLIST_ENTRY)CurDriverEntry;
		CurDriverEntry->InLoadOrderLinks.Blink = (PLIST_ENTRY)CurDriverEntry;

		DebugMessageNormal("Driver hiding feature is enabled.\n");
		DebugMessageNormal("You may get BSOD if you have the Windows PatchGuard running. (10-30mins)\n");
	}
	else
	{
		DebugMessageNormal("Driver hiding feature is disabled.\n");
	}

	DebugMessageNormal("Successfully started!\n");

	return STATUS_SUCCESS;
}

// Rename the current entry point to DriverInitialize to use this, and remove the unload call registration.
/*NTSTATUS DriverEntry(
	_In_  struct _DRIVER_OBJECT* DriverObject,
	_In_  PUNICODE_STRING RegistryPath
	)
{
	// These parameters are invalid due to nonstandard way of loading and should not be used.
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	IsManualMapped = TRUE;

	DebugMessageNormal("Garhal is swimming as a manual mapped driver, system range start is %p, code mapped at %p\n", MmSystemRangeStart, DriverEntry);


	// This isn't a standard way against better anticheats such as BE, and EAC.
	// Could give you a good example though.
	UNICODE_STRING  drvName;
	NTSTATUS status;

	RtlInitUnicodeString(&drvName, L"\\Driver\\Garhal");
	status = IoCreateDriver(&drvName, &DriverInitialize);

	if (NT_SUCCESS(status))
	{
		DebugMessageNormal("Created driver.\n");
	}

	return status;
}*/


NTSTATUS RegisterOBCallback()
{
	OB_OPERATION_REGISTRATION OBOperationRegistration;
	OB_CALLBACK_REGISTRATION OBOCallbackRegistration;
	REG_CONTEXT regContext;
	UNICODE_STRING usAltitude;
	memset(&OBOperationRegistration, 0, sizeof(OB_OPERATION_REGISTRATION));
	memset(&OBOCallbackRegistration, 0, sizeof(OB_CALLBACK_REGISTRATION));
	memset(&regContext, 0, sizeof(REG_CONTEXT));
	regContext.ulIndex = 1;
	regContext.Version = 120;
	RtlInitUnicodeString(&usAltitude, L"666");

	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if ((USHORT)ObGetFilterVersion() == OB_FLT_REGISTRATION_VERSION)
	{
		OBOperationRegistration.ObjectType = PsProcessType; // Use To Strip Handle Permissions For Threads PsThreadType
		OBOperationRegistration.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		OBOperationRegistration.PostOperation = NULL;
		OBOperationRegistration.PreOperation = OBRegisterCallback;

		OBOCallbackRegistration.Altitude = usAltitude;
		OBOCallbackRegistration.OperationRegistration = &OBOperationRegistration;
		OBOCallbackRegistration.RegistrationContext = &regContext;
		OBOCallbackRegistration.Version = OB_FLT_REGISTRATION_VERSION;
		OBOCallbackRegistration.OperationRegistrationCount = (USHORT)1;

		Status = ObRegisterCallbacks(&OBOCallbackRegistration, &OBRegisterHandle); // Register The CallBack
	}

	return Status;
}
```

`Garhal/garhal.h`:

```h
#pragma once
#include <ntifs.h>

PVOID OBRegisterHandle = NULL;

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject);

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath);

NTSTATUS RegisterOBCallback();

NTSTATUS FreeAllocatedMemory();
```

`Garhal/gstructs.h`:

```h
#pragma once

#include <ntifs.h>
#include <minwindef.h>

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	WORD LoadCount;
	WORD TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _PEB_LDR_DATA {
	BYTE       Reserved1[8];
	PVOID      Reserved2[3];
	LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;

typedef struct _MODULEENTRY
{
	ULONG Address;
	ULONG Size;
} MODULEENTRY, * PMODULEENTRY;
```

`Garhal/hide.c`:

```c
#pragma warning(disable : 4100 4047 4024 4022 4201 4311 4057 4213 4189 4081 4189 4706 4214 4459 4273 6001)

#include "hide.h"
#include <stdio.h>

PCHAR HideProcess(UINT32 pid)
{
	LPSTR result = ExAllocatePool(NonPagedPool, sizeof(ULONG) + 20);;

	// Get PID offset nt!_EPROCESS.UniqueProcessId
	ULONG PID_OFFSET = FindPIDOffset();

	// Check if offset discovery was successful 
	if (PID_OFFSET == 0) {
		return (PCHAR)"Could not find PID offset!";
	}

	// Get LIST_ENTRY offset nt!_EPROCESS.ActiveProcessLinks
	ULONG LIST_OFFSET = PID_OFFSET;


	// Check Architecture using pointer size
	INT_PTR ptr;

	// Ptr size 8 if compiled for a 64-bit machine, 4 if compiled for 32-bit machine
	LIST_OFFSET += sizeof(ptr);

	// Record offsets for user buffer
	sprintf_s(result, 2 * sizeof(ULONG) + 30, "Found offsets: %lu & %lu", PID_OFFSET, LIST_OFFSET);

	// Get current process
	PEPROCESS CurrentEPROCESS = PsGetCurrentProcess();

	// Initialize other variables
	PLIST_ENTRY CurrentList = (PLIST_ENTRY)((ULONG_PTR)CurrentEPROCESS + LIST_OFFSET);
	PUINT32 CurrentPID = (PUINT32)((ULONG_PTR)CurrentEPROCESS + PID_OFFSET);

	// Check self 
	if (*(UINT32*)CurrentPID == pid) {
		RemoveLinks(CurrentList);
		return (PCHAR)result;
	}

	// Record the starting position
	PEPROCESS StartProcess = CurrentEPROCESS;

	// Move to next item
	CurrentEPROCESS = (PEPROCESS)((ULONG_PTR)CurrentList->Flink - LIST_OFFSET);
	CurrentPID = (PUINT32)((ULONG_PTR)CurrentEPROCESS + PID_OFFSET);
	CurrentList = (PLIST_ENTRY)((ULONG_PTR)CurrentEPROCESS + LIST_OFFSET);

	// Loop until we find the right process to remove
	// Or until we circle back
	while ((ULONG_PTR)StartProcess != (ULONG_PTR)CurrentEPROCESS) {

		// Check item
		if (*(UINT32*)CurrentPID == pid) {
			RemoveLinks(CurrentList);
			return (PCHAR)result;
		}

		// Move to next item
		CurrentEPROCESS = (PEPROCESS)((ULONG_PTR)CurrentList->Flink - LIST_OFFSET);
		CurrentPID = (PUINT32)((ULONG_PTR)CurrentEPROCESS + PID_OFFSET);
		CurrentList = (PLIST_ENTRY)((ULONG_PTR)CurrentEPROCESS + LIST_OFFSET);
	}

	return (PCHAR)result;
}

void RemoveLinks(PLIST_ENTRY Current)
{
	PLIST_ENTRY Previous, Next;

	Previous = (Current->Blink);
	Next = (Current->Flink);

	// Loop over self (connect previous with next)
	Previous->Flink = Next;
	Next->Blink = Previous;

	// Re-write the current LIST_ENTRY to point to itself (avoiding BSOD)
	Current->Blink = (PLIST_ENTRY)&Current->Flink;
	Current->Flink = (PLIST_ENTRY)&Current->Flink;
}

ULONG FindPIDOffset()
{
	ULONG pid_ofs = 0; // The offset we're looking for
	int idx = 0;                // Index 
	ULONG pids[3];				// List of PIDs for our 3 processes
	PEPROCESS eprocs[3];		// Process list, will contain 3 processes

	//Select 3 process PIDs and get their EPROCESS Pointer
	for (int i = 16; idx < 3; i += 4)
	{
		if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)i, &eprocs[idx])))
		{
			pids[idx] = i;
			idx++;
		}
	}


	/*
	Go through the EPROCESS structure and look for the PID
	we can start at 0x20 because UniqueProcessId should
	not be in the first 0x20 bytes,
	also we should stop after 0x300 bytes with no success
	*/

	for (int i = 0x20; i < 0x300; i += 4)
	{
		if ((*(ULONG*)((UCHAR*)eprocs[0] + i) == pids[0])
			&& (*(ULONG*)((UCHAR*)eprocs[1] + i) == pids[1])
			&& (*(ULONG*)((UCHAR*)eprocs[2] + i) == pids[2]))
		{
			pid_ofs = i;
			break;
		}
	}

	ObDereferenceObject(eprocs[0]);
	ObDereferenceObject(eprocs[1]);
	ObDereferenceObject(eprocs[2]);


	return pid_ofs;
}
```

`Garhal/hide.h`:

```h
#pragma once
#include <ntifs.h>


void RemoveLinks(PLIST_ENTRY Current);

PCHAR HideProcess(UINT32 pid);

ULONG FindPIDOffset();
```

`Garhal/memory.c`:

```c
#pragma warning( disable : 4100 4047 4024 4022 4201 4311 4057 4213 4189 4081 4189 4706 4214 4459 4273 4457 4133)

#include "memory.h"
#include <minwindef.h>
#include <ntstatus.h>
#include <ntdef.h>
#include <stdlib.h>
#include "messages.h"
#include "ntos.h"

ULONG GetWindowsBuildNumber()
{
	// Get the Windows Version table.
	RTL_OSVERSIONINFOEXW osversion;
	osversion.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);
	RtlGetVersion(&osversion);

	return osversion.dwBuildNumber;
}

// https://docs.microsoft.com/en-us/windows/release-information/
// https://www.vergiliusproject.com/kernels/x64/Windows 10 | 2016/1903 19H1 (May 2019 Update)/_EPROCESS
int GetCorrectOffset(CHAR* Name, ULONG BuildNumber)
{
	// 1903 & 1909
	if (BuildNumber == 18362 || BuildNumber == 18363)
	{
		if (strcmp(Name, "ImageFileName") == 0)
		{
			return 0x450;
		}
		if (strcmp(Name, "ActiveThreads") == 0)
		{
			return 0x498;
		}
		if (strcmp(Name, "ActiveProcessLinks") == 0)
		{
			return 0x2F0;
		}
	}
	// 2004 & 2009 & 2104
	else if (BuildNumber == 19041 || BuildNumber == 19042 || BuildNumber == 19043)
	{
		if (strcmp(Name, "ImageFileName") == 0)
		{
			return 0x5a8;
		}
		if (strcmp(Name, "ActiveThreads") == 0)
		{
			return 0x5f0;
		}
		if (strcmp(Name, "ActiveProcessLinks") == 0)
		{
			return 0x448;
		}
	}

	return 0;
}

NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
	SIZE_T Bytes;
	if (NT_SUCCESS(MmCopyVirtualMemory(Process, SourceAddress, PsGetCurrentProcess(),
		TargetAddress, Size, KernelMode, &Bytes)))
	{
		return STATUS_SUCCESS;
	}
	return STATUS_ACCESS_DENIED;
}

NTSTATUS KeWriteVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
	SIZE_T Bytes;
	if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process,
		TargetAddress, Size, KernelMode, &Bytes)))
	{
		return STATUS_SUCCESS;
	}
	return STATUS_ACCESS_DENIED;
}

NTSTATUS FindProcessByName(CHAR* process_name, vector* ls)
{
	ULONG BuildNumber = GetWindowsBuildNumber();
	PEPROCESS sys_process = PsInitialSystemProcess;
	PEPROCESS cur_entry = sys_process;

	int ImageFileNameOffset = GetCorrectOffset("ImageFileName", BuildNumber);
	int ActiveThreadsOffset = GetCorrectOffset("ActiveThreads", BuildNumber);
	int ActiveProcessLinksOffset = GetCorrectOffset("ActiveProcessLinks", BuildNumber);

	// Verify atleast one variable so we don't cause BSOD for unsupported builds.
	if (ImageFileNameOffset == 0)
	{
		DebugMessageNormal("Warning: Unsupported Windows build. Update EPROCESS offsets. See README.md.\n");
		return STATUS_UNSUCCESSFUL;
	}

	CHAR image_name[15];

	do
	{
		RtlCopyMemory((PVOID)(&image_name), (PVOID)((uintptr_t)cur_entry + ImageFileNameOffset) /*EPROCESS->ImageFileName*/, sizeof(image_name));

		if (strstr(image_name, process_name))
		{
			DWORD active_threads;
			RtlCopyMemory((PVOID)&active_threads, (PVOID)((uintptr_t)cur_entry + ActiveThreadsOffset) /*EPROCESS->ActiveThreads*/, sizeof(active_threads));
			if (active_threads)
			{
				vector_add(ls, cur_entry);
			}
		}

		PLIST_ENTRY list = (PLIST_ENTRY)((uintptr_t)(cur_entry) + ActiveProcessLinksOffset) /*EPROCESS->ActiveProcessLinks*/;
		cur_entry = (PEPROCESS)((uintptr_t)list->Flink - ActiveProcessLinksOffset);

	} while (cur_entry != sys_process);

	return STATUS_SUCCESS;
}

MODULEENTRY GetProcessModule(PEPROCESS Process, LPCWSTR ModuleName)
{
	KAPC_STATE KAPC = { 0 };
	MODULEENTRY ret = {0, 0};

	KeStackAttachProcess(Process, &KAPC);
	__try
	{
		PPEB32 peb32 = (PPEB32) PsGetProcessWow64Process(Process);
		if (!peb32 || !peb32->Ldr)
		{
			KeUnstackDetachProcess(&KAPC);
			return ret;
		}

		for (PLIST_ENTRY32 plist_entry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)peb32->Ldr)->InLoadOrderModuleList.Flink;
			plist_entry != &((PPEB_LDR_DATA32)peb32->Ldr)->InLoadOrderModuleList;
			plist_entry = (PLIST_ENTRY32)plist_entry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY32 pentry = CONTAINING_RECORD(plist_entry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);

			if (wcscmp((PWCH) pentry->BaseDllName.Buffer, ModuleName) == 0)
			{
				ret.Address = pentry->DllBase;
				ret.Size = pentry->SizeOfImage;
				break;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DebugMessageNormal("%s: Exception, Code: 0x%X\n", __FUNCTION__, GetExceptionCode());
	}

	KeUnstackDetachProcess(&KAPC);

	return ret;
}
```

`Garhal/memory.h`:

```h
#pragma once
#include <ntifs.h>
#include "gstructs.h"
#include "vector.h"

ULONG GetWindowsBuildNumber();

int GetCorrectOffset(CHAR* Name, ULONG BuildNumber);

NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);

NTSTATUS KeWriteVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);

NTSTATUS FindProcessByName(CHAR* process_name, vector* list);

MODULEENTRY GetProcessModule(PEPROCESS Process, LPCWSTR ModuleName);
```

`Garhal/messages.h`:

```h
#pragma once

#include <ntdef.h>
#define DebugMessageNormal(x, ...) DbgPrintEx(0, 0, x, __VA_ARGS__)

```

`Garhal/ntos.h`:

```h
#pragma once

#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>


typedef unsigned long long QWORD;

NTKERNELAPI
NTSTATUS
PsCreateSystemProcess(
	OUT PHANDLE ProcessHandle,
	IN ULONG DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes
	);

typedef unsigned short WORD;


typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
	IN HANDLE ProcessId,
	IN HANDLE ThreadId,
	IN BOOLEAN Create
	);




typedef
VOID
(*PLOAD_IMAGE_NOTIFY_ROUTINE)(
	IN PUNICODE_STRING FullImageName,
	IN HANDLE ProcessId,                // pid into which image is being mapped 
	IN PIMAGE_INFO ImageInfo
	);


NTKERNELAPI
NTSTATUS
PsRemoveCreateThreadNotifyRoutine(
	IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
	);

NTKERNELAPI
NTSTATUS
PsRemoveLoadImageNotifyRoutine(
	IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
	);

NTKERNELAPI
BOOLEAN
PsIsThreadTerminating(
	IN PETHREAD Thread
	);

/*
typedef struct _CLIENT_ID {
HANDLE UniqueProcess;
HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;
*/

NTKERNELAPI
NTSTATUS
PsLookupProcessThreadByCid(
	IN PCLIENT_ID Cid,
	OUT PEPROCESS* Process,
	OUT PETHREAD* Thread
	);

// begin_ntosp 

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS* Process
	);

NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
	IN HANDLE ThreadId,
	OUT PETHREAD* Thread
	);
NTKERNELAPI
PVOID
PsGetCurrentThreadStackLimit(
	VOID
	);

NTKERNELAPI
PVOID
PsGetCurrentThreadStackBase(
	VOID
	);

NTKERNELAPI
PVOID
PsGetProcessDebugPort(
	IN PEPROCESS Process
	);

NTKERNELAPI
BOOLEAN
PsIsProcessBeingDebugged(
	IN PEPROCESS Process
	);

NTKERNELAPI
HANDLE
PsGetProcessId(
	IN PEPROCESS Process
	);

NTKERNELAPI
HANDLE
PsGetProcessInheritedFromUniqueProcessId(
	IN PEPROCESS Process
	);

NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
	);

NTKERNELAPI
PVOID
PsGetThreadTeb(
	IN PETHREAD Thread
	);

NTKERNELAPI                         //ntifs 
BOOLEAN                             //ntifs 
PsIsSystemThread(                   //ntifs 
	IN PETHREAD Thread                 //ntifs 
	);                              //ntifs 

NTKERNELAPI
NTSTATUS
PsSetProcessWin32Process(
	IN PEPROCESS Process,
	IN PVOID Win32Process,
	IN PVOID PrevWin32Process
	);

NTKERNELAPI
VOID
PsSetProcessWindowStation(
	OUT PEPROCESS Process,
	IN HANDLE Win32WindowStation
	);

NTKERNELAPI
VOID
PsSetThreadWin32Thread(
	IN OUT PETHREAD Thread,
	IN PVOID Win32Thread,
	IN PVOID PrevWin32Thread
	);



// Processor modes. 
// 
/*
typedef CCHAR KPROCESSOR_MODE;
typedef enum _MODE {
KernelMode,
UserMode,
MaximumMode
} MODE;
#define OBJECT_LOCK_COUNT 4
// Object Manager types
//
typedef struct _OBJECT_HANDLE_INFORMATION {
ULONG HandleAttributes;
ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;
// end_ntddk end_wdm end_nthal end_ntifs
typedef struct _OBJECT_DUMP_CONTROL {
PVOID Stream;
ULONG Detail;
} OB_DUMP_CONTROL, *POB_DUMP_CONTROL;
typedef VOID (*OB_DUMP_METHOD)(
IN PVOID Object,
IN POB_DUMP_CONTROL Control OPTIONAL
);
typedef enum _OB_OPEN_REASON {
ObCreateHandle,
ObOpenHandle,
ObDuplicateHandle,
ObInheritHandle,
ObMaxOpenReason
} OB_OPEN_REASON;
typedef NTSTATUS (*OB_OPEN_METHOD)(
IN OB_OPEN_REASON OpenReason,
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN ACCESS_MASK GrantedAccess,
IN ULONG HandleCount
);
typedef BOOLEAN (*OB_OKAYTOCLOSE_METHOD)(
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN HANDLE Handle,
IN KPROCESSOR_MODE PreviousMode
);
typedef VOID (*OB_CLOSE_METHOD)(
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN ACCESS_MASK GrantedAccess,
IN ULONG_PTR ProcessHandleCount,
IN ULONG_PTR SystemHandleCount
);
typedef VOID (*OB_DELETE_METHOD)(
IN  PVOID   Object
);
typedef NTSTATUS (*OB_PARSE_METHOD)(
IN PVOID ParseObject,
IN PVOID ObjectType,
IN OUT PACCESS_STATE AccessState,
IN KPROCESSOR_MODE AccessMode,
IN ULONG Attributes,
IN OUT PUNICODE_STRING CompleteName,
IN OUT PUNICODE_STRING RemainingName,
IN OUT PVOID Context OPTIONAL,
IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
OUT PVOID *Object
);
typedef NTSTATUS (*OB_SECURITY_METHOD)(
IN PVOID Object,
IN SECURITY_OPERATION_CODE OperationCode,
IN PSECURITY_INFORMATION SecurityInformation,
IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
IN OUT PULONG CapturedLength,
IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
IN POOL_TYPE PoolType,
IN PGENERIC_MAPPING GenericMapping
);
typedef NTSTATUS (*OB_QUERYNAME_METHOD)(
IN PVOID Object,
IN BOOLEAN HasObjectName,
OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
IN ULONG Length,
OUT PULONG ReturnLength,
IN KPROCESSOR_MODE Mode
);
typedef struct _OBJECT_TYPE_INITIALIZER {
USHORT Length;
BOOLEAN UseDefaultObject;
BOOLEAN CaseInsensitive;
ULONG InvalidAttributes;
GENERIC_MAPPING GenericMapping;
ULONG ValidAccessMask;
BOOLEAN SecurityRequired;
BOOLEAN MaintainHandleCount;
BOOLEAN MaintainTypeList;
POOL_TYPE PoolType;
ULONG DefaultPagedPoolCharge;
ULONG DefaultNonPagedPoolCharge;
OB_DUMP_METHOD DumpProcedure;
OB_OPEN_METHOD OpenProcedure;
OB_CLOSE_METHOD CloseProcedure;
OB_DELETE_METHOD DeleteProcedure;
OB_PARSE_METHOD ParseProcedure;
OB_SECURITY_METHOD SecurityProcedure;
OB_QUERYNAME_METHOD QueryNameProcedure;
OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;
typedef struct _OBJECT_TYPE {
ERESOURCE Mutex;
LIST_ENTRY TypeList;
UNICODE_STRING Name;            // Copy from object header for convenience
PVOID DefaultObject;
ULONG Index;
ULONG TotalNumberOfObjects;
ULONG TotalNumberOfHandles;
ULONG HighWaterNumberOfObjects;
ULONG HighWaterNumberOfHandles;
OBJECT_TYPE_INITIALIZER TypeInfo;
#ifdef POOL_TAGGING
ULONG Key;
#endif //POOL_TAGGING
ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];
} OBJECT_TYPE, *POBJECT_TYPE;
NTKERNELAPI
NTSTATUS
ObCreateObject(
IN KPROCESSOR_MODE ProbeMode,
IN POBJECT_TYPE ObjectType,
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN KPROCESSOR_MODE OwnershipMode,
INout_opt PVOID ParseContext,
IN ULONG ObjectBodySize,
IN ULONG PagedPoolCharge,
IN ULONG NonPagedPoolCharge,
OUT PVOID *Object
);
NTKERNELAPI
NTSTATUS
ObInsertObject(
IN PVOID Object,
IN PACCESS_STATE PassedAccessState,
IN ACCESS_MASK DesiredAccess,
IN ULONG ObjectPointerBias,
OUT_opt PVOID *NewObject,
OUT_opt PHANDLE Handle
);
NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN POBJECT_TYPE ObjectType,
IN KPROCESSOR_MODE AccessMode,
INout_opt PACCESS_STATE AccessState,
IN ACCESS_MASK DesiredAccess,
INout_opt PVOID ParseContext,
OUT PHANDLE Handle
);
NTKERNELAPI                                                     // ntifs
NTSTATUS                                                        // ntifs
ObOpenObjectByPointer(                                          // ntifs
IN PVOID Object,                                            // ntifs
IN ULONG HandleAttributes,                                  // ntifs
IN PACCESS_STATE PassedAccessState,                // ntifs
IN ACCESS_MASK DesiredAccess,                      // ntifs
IN POBJECT_TYPE ObjectType,                        // ntifs
IN KPROCESSOR_MODE AccessMode,                              // ntifs
OUT PHANDLE Handle                                          // ntifs
);                                                          // ntifs
NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
IN PUNICODE_STRING ObjectName,
IN ULONG Attributes,
IN PACCESS_STATE AccessState,
IN ACCESS_MASK DesiredAccess,
IN POBJECT_TYPE ObjectType,
IN KPROCESSOR_MODE AccessMode,
INout_opt PVOID ParseContext,
OUT PVOID *Object
);
NTKERNELAPI
BOOLEAN
ObFindHandleForObject(
IN PEPROCESS Process,
IN PVOID Object,
IN POBJECT_TYPE ObjectType,
IN POBJECT_HANDLE_INFORMATION MatchCriteria,
OUT PHANDLE Handle
);
// begin_ntifs begin_ntosp
NTKERNELAPI
NTSTATUS
ObQueryNameString(
IN PVOID Object,
OUT_bcount(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
IN ULONG Length,
OUT PULONG ReturnLength
);
NTKERNELAPI
NTSTATUS
ObSetHandleAttributes (
IN HANDLE Handle,
IN POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
IN KPROCESSOR_MODE PreviousMode
);
NTKERNELAPI
NTSTATUS
ObCloseHandle (
IN HANDLE Handle,
IN KPROCESSOR_MODE PreviousMode
);
*/
////////////////////////////////////////////////////////////////////////// 
//Nt?|????им??????бз??????бь?|D 

//typedef struct _KPROCESS *PKPROCESS, *PRKPROCESS, *PEPROCESS;

// begin_ntddk begin_ntifs 
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId
	);
// end_ntddk end_ntifs 

// begin_ntddk begin_ntifs 
/*
typedef enum _PROCESSINFOCLASS {
ProcessBasicInformation,
ProcessQuotaLimits,
ProcessIoCounters,
ProcessVmCounters,
ProcessTimes,
ProcessBasePriority,
ProcessRaisePriority,
ProcessDebugPort,
ProcessExceptionPort,
ProcessAccessToken,
ProcessLdtInformation,
ProcessLdtSize,
ProcessDefaultHardErrorMode,
ProcessIoPortHandlers,          // Note: this is kernel mode only
ProcessPooledUsageAndLimits,
ProcessWorkingSetWatch,
ProcessUserModeIOPL,
ProcessEnableAlignmentFaultFixup,
ProcessPriorityClass,
ProcessWx86Information,
ProcessHandleCount,
ProcessAffinityMask,
ProcessPriorityBoost,
ProcessDeviceMap,
ProcessSessionInformation,
ProcessForegroundInformation,
ProcessWow64Information,
ProcessImageFileName,
ProcessLUIDDeviceMapsEnabled,
ProcessBreakOnTermination,
ProcessDebugObjectHandle,
ProcessDebugFlags,
ProcessHandleTracing,
ProcessIoPriority,
ProcessExecuteFlags,
ProcessResourceManagement,
ProcessCookie,
ProcessImageInformation,
MaxProcessInfoClass             // MaxProcessInfoClass should always be the last enum
} PROCESSINFOCLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT  PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength
	);
// end_ntddk end_ntifs 


NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	IN PVOID ProcessInformation,
	IN ULONG ProcessInformationLength
	);


NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId
	);

// 
// Thread Information Classes 
// 
/*
typedef enum _THREADINFOCLASS {
ThreadBasicInformation,
ThreadTimes,
ThreadPriority,
ThreadBasePriority,
ThreadAffinityMask,
ThreadImpersonationToken,
ThreadDescriptorTableEntry,
ThreadEnableAlignmentFaultFixup,
ThreadEventPair_Reusable,
ThreadQuerySetWin32StartAddress,
ThreadZeroTlsCell,
ThreadPerformanceCount,
ThreadAmILastThread,
ThreadIdealProcessor,
ThreadPriorityBoost,
ThreadSetTlsArrayAddress,
ThreadIsIoPending,
ThreadHideFromDebugger,
ThreadBreakOnTermination,
ThreadSwitchLegacyState,
ThreadIsTerminated,
MaxThreadInfoClass
} THREADINFOCLASS;
// end_ntddk end_ntifs
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	OUT PVOID ThreadInformation,
	IN ULONG ThreadInformationLength,
	OUT PULONG ReturnLength
	);

// begin_ntifs 
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	IN PVOID ThreadInformation,
	IN ULONG ThreadInformationLength
	);
// end_ntifs 
/*
typedef struct _IO_STATUS_BLOCK {
union {
NTSTATUS Status;
PVOID Pointer;
};
ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
*/
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER AllocationSize,
	IN ULONG FileAttributes,
	IN ULONG ShareAccess,
	IN ULONG CreateDisposition,
	IN ULONG CreateOptions,
	IN PVOID EaBuffer,
	IN ULONG EaLength
	);

typedef
VOID
(NTAPI* PIO_APC_ROUTINE) (
	IN PVOID ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG Reserved
	);


NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG IoControlCode,
	IN PVOID InputBuffer,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer,
	IN ULONG OutputBufferLength
	);

/*
typedef enum _FILE_INFORMATION_CLASS {
// end_wdm
FileDirectoryInformation         = 1,
FileFullDirectoryInformation,   // 2
FileBothDirectoryInformation,   // 3
FileBasicInformation,           // 4  wdm
FileStandardInformation,        // 5  wdm
FileInternalInformation,        // 6
FileEaInformation,              // 7
FileAccessInformation,          // 8
FileNameInformation,            // 9
FileRenameInformation,          // 10
FileLinkInformation,            // 11
FileNamesInformation,           // 12
FileDispositionInformation,     // 13
FilePositionInformation,        // 14 wdm
FileFullEaInformation,          // 15
FileModeInformation,            // 16
FileAlignmentInformation,       // 17
FileAllInformation,             // 18
FileAllocationInformation,      // 19
FileEndOfFileInformation,       // 20 wdm
FileAlternateNameInformation,   // 21
FileStreamInformation,          // 22
FilePipeInformation,            // 23
FilePipeLocalInformation,       // 24
FilePipeRemoteInformation,      // 25
FileMailslotQueryInformation,   // 26
FileMailslotSetInformation,     // 27
FileCompressionInformation,     // 28
FileObjectIdInformation,        // 29
FileCompletionInformation,      // 30
FileMoveClusterInformation,     // 31
FileQuotaInformation,           // 32
FileReparsePointInformation,    // 33
FileNetworkOpenInformation,     // 34
FileAttributeTagInformation,    // 35
FileTrackingInformation,        // 36
FileIdBothDirectoryInformation, // 37
FileIdFullDirectoryInformation, // 38
FileValidDataLengthInformation, // 39
FileShortNameInformation,       // 40
FileMaximumInformation
// begin_wdm
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName,
	IN BOOLEAN RestartScan
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	);

/*
typedef enum _FSINFOCLASS {
FileFsVolumeInformation       = 1,
FileFsLabelInformation,      // 2
FileFsSizeInformation,       // 3
FileFsDeviceInformation,     // 4
FileFsAttributeInformation,  // 5
FileFsControlInformation,    // 6
FileFsFullSizeInformation,   // 7
FileFsObjectIdInformation,   // 8
FileFsDriverPathInformation, // 9
FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT  PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset,
	IN PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset,
	IN PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER ByteOffset,
	IN PLARGE_INTEGER Length,
	IN ULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER ByteOffset,
	IN PLARGE_INTEGER Length,
	IN ULONG Key,
	IN BOOLEAN FailImmediately,
	IN BOOLEAN ExclusiveLock
	);

typedef enum _SHUTDOWN_ACTION {
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownSystem(
	IN SHUTDOWN_ACTION Action
	);

////////////////////////////////////////////////////////////////////////// 
//Io?|????им??????бз??????бь?|D (1??a|????им???????бз?????????бз??????бь????бь?????бз??????бь?|??????им?o????????им????бз???бз?????бз??????бз????..) 
// 
// Define driver initialization routine type. 
// 
typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
	IN struct _DRIVER_OBJECT* DriverObject,
	IN PUNICODE_STRING RegistryPath
	);

NTKERNELAPI
NTSTATUS
IoCreateDriver(
	IN PUNICODE_STRING DriverName, OPTIONAL
	IN PDRIVER_INITIALIZE InitializationFunction
	);

NTKERNELAPI
VOID
IoDeleteDriver(
	IN PDRIVER_OBJECT DriverObject
	);

////////////////////////////////////////////////////////////////////////// 
//Kd?|????им??????бз??????бь?|D 
/*
NTKERNELAPI
NTSTATUS
KdDisableDebugger(
VOID
);
NTKERNELAPI
NTSTATUS
KdEnableDebugger(
VOID
);
*/

NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(_In_ PEPROCESS Process);

NTKERNELAPI
NTSTATUS
KdPowerTransition(
	IN DEVICE_POWER_STATE newDeviceState
	);

NTKERNELAPI
BOOLEAN
KdPollBreakIn(
	VOID
	);

////////////////////////////////////////////////////////////////////////// 
//Ke?|????им??????бз??????бь?|D 

NTSTATUS
NTAPI
Ke386CallBios(
	IN ULONG BiosCommand,
	IN OUT PCONTEXT BiosArguments
	);

#define IOPM_SIZE           8192 

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP* PKIO_ACCESS_MAP;

BOOLEAN
NTAPI
Ke386SetIoAccessMap(
	ULONG               MapNumber,
	PKIO_ACCESS_MAP     IoAccessMap
	);

BOOLEAN
NTAPI
Ke386QueryIoAccessMap(
	ULONG              MapNumber,
	PKIO_ACCESS_MAP    IoAccessMap
	);


NTKERNELAPI
BOOLEAN
KeAddSystemServiceTable(
	IN PULONG_PTR Base,
	IN PULONG Count OPTIONAL,
	IN ULONG Limit,
	IN PUCHAR Number,
	IN ULONG Index
	);

#define PKPROCESS PRKPROCESS 


NTKERNELAPI
VOID
KeDetachProcess(
	VOID
	);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck(
	IN ULONG BugCheckCode
	);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
	IN ULONG BugCheckCode,
	IN ULONG_PTR BugCheckParameter1,
	IN ULONG_PTR BugCheckParameter2,
	IN ULONG_PTR BugCheckParameter3,
	IN ULONG_PTR BugCheckParameter4
	);

/*
//
// Interrupt object
//
struct _KINTERRUPT;
// begin_ntddk begin_wdm begin_ntifs begin_ntosp
typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
IN struct _KINTERRUPT *Interrupt,
IN PVOID ServiceContext
);
typedef struct _KINTERRUPT {
CSHORT Type;
CSHORT Size;
LIST_ENTRY InterruptListEntry;
PKSERVICE_ROUTINE ServiceRoutine;
PVOID ServiceContext;
KSPIN_LOCK SpinLock;
ULONG TickCount;
PKSPIN_LOCK ActualLock;
PKINTERRUPT_ROUTINE DispatchAddress;
ULONG Vector;
KIRQL Irql;
KIRQL SynchronizeIrql;
BOOLEAN FloatingSave;
BOOLEAN Connected;
CCHAR Number;
BOOLEAN ShareVector;
KINTERRUPT_MODE Mode;
ULONG ServiceCount;
ULONG DispatchCount;
#if defined(_AMD64_)
PKTRAP_FRAME TrapFrame;
PVOID Reserved;
ULONG DispatchCode[DISPATCH_LENGTH];
#else
ULONG DispatchCode[DISPATCH_LENGTH];
#endif
} KINTERRUPT;
#if !defined(_X86AMD64_) && defined(_AMD64_)
C_ASSERT((FIELD_OFFSET(KINTERRUPT, DispatchCode) % 16) == 0);
C_ASSERT((sizeof(KINTERRUPT) % 16) == 0);
#endif
typedef struct _KINTERRUPT *PKINTERRUPT, *PRKINTERRUPT; // ntndis ntosp
NTKERNELAPI
BOOLEAN
KeDisconnectInterrupt (
INout PKINTERRUPT Interrupt
);
*/

NTKERNELAPI
VOID
KeEnterKernelDebugger(
	VOID
	);

NTSTATUS
NTAPI
KeI386AbiosCall(
	IN USHORT LogicalId,
	IN struct _DRIVER_OBJECT* DriverObject,
	IN PUCHAR RequestBlock,
	IN USHORT EntryPoint
	);

NTSTATUS
NTAPI
KeI386AllocateGdtSelectors(
	OUT PUSHORT SelectorArray,
	IN USHORT NumberOfSelectors
	);

NTSTATUS
NTAPI
KeI386FlatToGdtSelector(
	IN ULONG SelectorBase,
	IN USHORT Length,
	IN USHORT Selector
	);

NTSTATUS
NTAPI
KeI386ReleaseGdtSelectors(
	OUT PUSHORT SelectorArray,
	IN USHORT NumberOfSelectors
	);

// 
// GDT Entry 
// 

typedef struct _KGDTENTRY {
	USHORT  LimitLow;
	USHORT  BaseLow;
	union {
		struct {
			UCHAR   BaseMid;
			UCHAR   Flags1;     // Declare as bytes to avoid alignment 
			UCHAR   Flags2;     // Problems. 
			UCHAR   BaseHi;
		} Bytes;
		struct {
			ULONG   BaseMid : 8;
			ULONG   Type : 5;
			ULONG   Dpl : 2;
			ULONG   Pres : 1;
			ULONG   LimitHi : 4;
			ULONG   Sys : 1;
			ULONG   Reserved_0 : 1;
			ULONG   Default_Big : 1;
			ULONG   Granularity : 1;
			ULONG   BaseHi : 8;
		} Bits;
	} HighWord;
} KGDTENTRY, * PKGDTENTRY;

NTSTATUS
NTAPI
KeI386SetGdtSelector(
	ULONG       Selector,
	PKGDTENTRY  GdtValue
	);

NTSTATUS
NTAPI
KeI386GetLid(
	IN USHORT DeviceId,
	IN USHORT RelativeLid,
	IN BOOLEAN SharedLid,
	IN struct _DRIVER_OBJECT* DeviceObject,
	OUT PUSHORT LogicalId
	);


NTSTATUS
NTAPI
KeI386ReleaseLid(
	IN USHORT LogicalId,
	IN struct _DRIVER_OBJECT* DeviceObject
	);

/*
typedef enum _MODE {
KernelMode,
UserMode,
MaximumMode
} MODE;
*/



NTKERNELAPI
VOID
KeTerminateThread(
	IN KPRIORITY Increment
	);


////////////////////////////////////////////////////////////////////////// 
//Mm?|????им??????бз??????бь?|D 
NTKERNELAPI
PVOID
MmGetVirtualForPhysical(
	IN PHYSICAL_ADDRESS PhysicalAddress
	);

NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage(
	IN PVOID BaseAddress,
	IN SIZE_T NumberOfBytes,
	IN PVOID PageAddress
	);

NTKERNELAPI
NTSTATUS
MmMapViewOfSection(
	IN PVOID SectionToMap,
	IN PEPROCESS Process,
	PVOID* CapturedBase,
	IN ULONG_PTR ZeroBits,
	IN SIZE_T CommitSize,
	IN OUT PLARGE_INTEGER SectionOffset,
	IN OUT PSIZE_T CapturedViewSize,
	IN SECTION_INHERIT InheritDisposition,
	IN ULONG AllocationType,
	IN ULONG Win32Protect
	);

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection(
	IN PEPROCESS Process,
	IN PVOID BaseAddress
	);

/*
typedef enum _MM_SYSTEM_SIZE {
MmSmallSystem,
MmMediumSystem,
MmLargeSystem
} MM_SYSTEMSIZE;
*/
NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize(
	VOID
	);

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
	);

NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
LPSTR PsGetProcessImageFileName(PEPROCESS Process);


BOOLEAN KeInsertQueueApc(
	PRKAPC Apc,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	KPRIORITY Increment);

NTSTATUS ZwAllocateVirtualMemory(
	_In_    HANDLE    ProcessHandle,
	_Inout_ PVOID* BaseAddress,
	_In_    ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T   RegionSize,
	_In_    ULONG     AllocationType,
	_In_    ULONG     Protect
	);
NTSTATUS ZwFreeVirtualMemory(
	_In_    HANDLE  ProcessHandle,
	_Inout_ PVOID* BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_    ULONG   FreeType
	);

//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwDelayExecution(
	__in BOOLEAN Alertable,
	__in PLARGE_INTEGER DelayInterval
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue(
	__in PUNICODE_STRING VariableName,
	__out_bcount(ValueLength) PWSTR VariableValue,
	__in USHORT ValueLength,
	__out_opt PUSHORT ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue(
	__in PUNICODE_STRING VariableName,
	__in PUNICODE_STRING VariableValue
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx(
	__in PUNICODE_STRING VariableName,
	__in LPGUID VendorGuid,
	__out_bcount_opt(*ValueLength) PVOID Value,
	__inout PULONG ValueLength,
	__out_opt PULONG Attributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx(
	__in PUNICODE_STRING VariableName,
	__in LPGUID VendorGuid,
	__in_bcount_opt(ValueLength) PVOID Value,
	__in ULONG ValueLength,
	__in ULONG Attributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx(
	__in ULONG InformationClass,
	__out PVOID Buffer,
	__inout PULONG BufferLength
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry(
	__in ULONG Id
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries(
	__out_bcount_opt(*BufferLength) PVOID Buffer,
	__inout PULONG BufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder(
	__out_ecount_opt(*Count) PULONG Ids,
	__inout PULONG Count
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder(
	__in_ecount(Count) PULONG Ids,
	__in ULONG Count
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry(
	__in ULONG Id
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries(
	__out_bcount(*BufferLength) PVOID Buffer,
	__inout PULONG BufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder(
	__out_ecount(*Count) PULONG Ids,
	__inout PULONG Count
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder(
	__in_ecount(Count) PULONG Ids,
	__in ULONG Count
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent(
	__in HANDLE EventHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent(
	__out PHANDLE EventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in EVENT_TYPE EventType,
	__in BOOLEAN InitialState
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent(
	__out PHANDLE EventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority(
	__in HANDLE EventHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEventPair(
	__out PHANDLE EventPairHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
	__out PHANDLE EventPairHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
	__in HANDLE EventPairHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMutant(
	__out PHANDLE MutantHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in BOOLEAN InitialOwner
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenMutant(
	__out PHANDLE MutantHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseMutant(
	__in HANDLE MutantHandle,
	__out_opt PLONG PreviousCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSemaphore(
	__out PHANDLE SemaphoreHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in LONG InitialCount,
	__in LONG MaximumCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
	__out PHANDLE SemaphoreHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
	__in HANDLE SemaphoreHandle,
	__in LONG ReleaseCount,
	__out_opt PLONG PreviousCount
	);


NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemTime(
	__out PLARGE_INTEGER SystemTime
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemTime(
	__in_opt PLARGE_INTEGER SystemTime,
	__out_opt PLARGE_INTEGER PreviousTime
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution(
	__out PULONG MaximumTime,
	__out PULONG MinimumTime,
	__out PULONG CurrentTime
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimerResolution(
	__in ULONG DesiredTime,
	__in BOOLEAN SetResolution,
	__out PULONG ActualTime
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
	__out PLUID Luid
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetUuidSeed(
	__in PCHAR Seed
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
	__out PULARGE_INTEGER Time,
	__out PULONG Range,
	__out PULONG Sequence,
	__out PCHAR Seed
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProfile(
	__out PHANDLE ProfileHandle,
	__in HANDLE Process OPTIONAL,
	__in PVOID ProfileBase,
	__in SIZE_T ProfileSize,
	__in ULONG BucketSize,
	__in PULONG Buffer,
	__in ULONG BufferSize,
	__in KPROFILE_SOURCE ProfileSource,
	__in KAFFINITY Affinity
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwStartProfile(
	__in HANDLE ProfileHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwStopProfile(
	__in HANDLE ProfileHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile(
	__in ULONG Interval,
	__in KPROFILE_SOURCE Source
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile(
	__in KPROFILE_SOURCE ProfileSource,
	__out PULONG Interval
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter(
	__out PLARGE_INTEGER PerformanceCounter,
	__out_opt PLARGE_INTEGER PerformanceFrequency
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent(
	__out PHANDLE KeyedEventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG Flags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent(
	__out PHANDLE KeyedEventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent(
	__in HANDLE KeyedEventHandle,
	__in PVOID KeyValue,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent(
	__in HANDLE KeyedEventHandle,
	__in PVOID KeyValue,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);


NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
	__in NTSTATUS ErrorStatus,
	__in ULONG NumberOfParameters,
	__in ULONG UnicodeStringParameterMask,
	__in_ecount(NumberOfParameters) PULONG_PTR Parameters,
	__in ULONG ValidResponseOptions,
	__out PULONG Response
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
	__in BOOLEAN UserProfile,
	__out PLCID DefaultLocaleId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
	__in BOOLEAN UserProfile,
	__in LCID DefaultLocaleId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
	__out LANGID* InstallUILanguageId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
	__out LANGID* DefaultUILanguageId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
	__in LANGID DefaultUILanguageId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
	__in HANDLE DefaultHardErrorPort
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
	__in SHUTDOWN_ACTION Action
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
	__in PUNICODE_STRING String
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
	__out PHANDLE FileHandle,
	__in ULONG DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG ShareAccess,
	__in ULONG CreateDisposition,
	__in ULONG CreateOptions,
	__in ULONG NamedPipeType,
	__in ULONG ReadMode,
	__in ULONG CompletionMode,
	__in ULONG MaximumInstances,
	__in ULONG InboundQuota,
	__in ULONG OutboundQuota,
	__in_opt PLARGE_INTEGER DefaultTimeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
	__out PHANDLE FileHandle,
	__in ULONG DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CreateOptions,
	__in ULONG MailslotQuota,
	__in ULONG MaximumMessageSize,
	__in PLARGE_INTEGER ReadTimeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PFILE_BASIC_INFORMATION FileInformation
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PFILE_NETWORK_OPEN_INFORMATION FileInformation
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
	__out PHANDLE FileHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_opt PLARGE_INTEGER AllocationSize,
	__in ULONG FileAttributes,
	__in ULONG ShareAccess,
	__in ULONG CreateDisposition,
	__in ULONG CreateOptions,
	__in_bcount_opt(EaLength) PVOID EaBuffer,
	__in ULONG EaLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG IoControlCode,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG FsControlCode,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PLARGE_INTEGER ByteOffset,
	__in PLARGE_INTEGER Length,
	__in ULONG Key,
	__in BOOLEAN FailImmediately,
	__in BOOLEAN ExclusiveLock
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
	__out PHANDLE FileHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG ShareAccess,
	__in ULONG OpenOptions
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass,
	__in BOOLEAN ReturnSingleEntry,
	__in_opt PUNICODE_STRING FileName,
	__in BOOLEAN RestartScan
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in BOOLEAN ReturnSingleEntry,
	__in_bcount_opt(SidListLength) PVOID SidList,
	__in ULONG SidListLength,
	__in_opt PSID StartSid,
	__in BOOLEAN RestartScan
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FsInformation,
	__in ULONG Length,
	__in FS_INFORMATION_CLASS FsInformationClass
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID Buffer,
	__in ULONG Length
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID FsInformation,
	__in ULONG Length,
	__in FS_INFORMATION_CLASS FsInformationClass
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PLARGE_INTEGER ByteOffset,
	__in PLARGE_INTEGER Length,
	__in ULONG Key
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PFILE_SEGMENT_ELEMENT SegmentArray,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PFILE_SEGMENT_ELEMENT SegmentArray,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
	__in PUNICODE_STRING DriverServiceName
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
	__in PUNICODE_STRING DriverServiceName
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion(
	__out PHANDLE IoCompletionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG Count OPTIONAL
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion(
	__out PHANDLE IoCompletionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetIoCompletion(
	__in HANDLE IoCompletionHandle,
	__in PVOID KeyContext,
	__in_opt PVOID ApcContext,
	__in NTSTATUS IoStatus,
	__in ULONG_PTR IoStatusInformation
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion(
	__in HANDLE IoCompletionHandle,
	__out PVOID* KeyContext,
	__out PVOID* ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCallbackReturn(
	__in_bcount_opt(OutputLength) PVOID OutputBuffer,
	__in ULONG OutputLength,
	__in NTSTATUS Status
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState(
	__in ULONG ComponentId,
	__in ULONG Level
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState(
	__in ULONG ComponentId,
	__in ULONG Level,
	__in BOOLEAN State
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution(
	VOID
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePort(
	__out PHANDLE PortHandle,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG MaxConnectionInfoLength,
	__in ULONG MaxMessageLength,
	__in_opt ULONG MaxPoolUsage
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
	__out PHANDLE PortHandle,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG MaxConnectionInfoLength,
	__in ULONG MaxMessageLength,
	__in_opt ULONG MaxPoolUsage
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
	__in HANDLE PortHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection(
	__out PHANDLE SectionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PLARGE_INTEGER MaximumSize,
	__in ULONG SectionPageProtection,
	__in ULONG AllocationAttributes,
	__in_opt HANDLE FileHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
	__out PHANDLE SectionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
	__in HANDLE SectionHandle,
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__in ULONG_PTR ZeroBits,
	__in SIZE_T CommitSize,
	__inout_opt PLARGE_INTEGER SectionOffset,
	__inout PSIZE_T ViewSize,
	__in SECTION_INHERIT InheritDisposition,
	__in ULONG AllocationType,
	__in ULONG Win32Protect
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection(
	__in HANDLE SectionHandle,
	__inout PLARGE_INTEGER NewSectionSize
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame(
	__in PVOID File1MappedAsAnImage,
	__in PVOID File2MappedAsFile
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__out_bcount(BufferSize) PVOID Buffer,
	__in SIZE_T BufferSize,
	__out_opt PSIZE_T NumberOfBytesRead
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__in_bcount(BufferSize) CONST VOID* Buffer,
	__in SIZE_T BufferSize,
	__out_opt PSIZE_T NumberOfBytesWritten
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PSIZE_T RegionSize,
	__out PIO_STATUS_BLOCK IoStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG MapType
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG MapType
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG NewProtect,
	__out PULONG OldProtect
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress,
	__in MEMORY_INFORMATION_CLASS MemoryInformationClass,
	__out_bcount(MemoryInformationLength) PVOID MemoryInformation,
	__in SIZE_T MemoryInformationLength,
	__out_opt PSIZE_T ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
	__in PVOID VirtualAddress,
	__in ULONG_PTR NumberOfPages,
	__in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
	__in_ecount(NumberOfPages) PVOID* VirtualAddresses,
	__in ULONG_PTR NumberOfPages,
	__in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
	__in HANDLE ProcessHandle,
	__inout PULONG_PTR NumberOfPages,
	__out_ecount(*NumberOfPages) PULONG_PTR UserPfnArray
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
	__in HANDLE ProcessHandle,
	__inout PULONG_PTR NumberOfPages,
	__in_ecount(*NumberOfPages) PULONG_PTR UserPfnArray
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetWriteWatch(
	__in HANDLE ProcessHandle,
	__in ULONG Flags,
	__in PVOID BaseAddress,
	__in SIZE_T RegionSize,
	__out_ecount(*EntriesInUserAddressArray) PVOID* UserAddressArray,
	__inout PULONG_PTR EntriesInUserAddressArray,
	__out PULONG Granularity
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwResetWriteWatch(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress,
	__in SIZE_T RegionSize
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePagingFile(
	__in PUNICODE_STRING PageFileName,
	__in PLARGE_INTEGER MinimumSize,
	__in PLARGE_INTEGER MaximumSize,
	__in ULONG Priority
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__in SIZE_T Length
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer(
	VOID
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
	__in HANDLE Handle,
	__in OBJECT_INFORMATION_CLASS ObjectInformationClass,
	__out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
	__in ULONG ObjectInformationLength,
	__out_opt PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
	__in HANDLE Handle,
	__in OBJECT_INFORMATION_CLASS ObjectInformationClass,
	__in_bcount(ObjectInformationLength) PVOID ObjectInformation,
	__in ULONG ObjectInformationLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
	__in HANDLE SourceProcessHandle,
	__in HANDLE SourceHandle,
	__in_opt HANDLE TargetProcessHandle,
	__out_opt PHANDLE TargetHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Options
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
	__in HANDLE Handle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
	__in HANDLE Handle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
	__in HANDLE SignalHandle,
	__in HANDLE WaitHandle,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
	__in HANDLE Handle,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
	__in ULONG Count,
	__in_ecount(Count) HANDLE Handles[],
	__in WAIT_TYPE WaitType,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects32(
	__in ULONG Count,
	__in_ecount(Count) LONG Handles[],
	__in WAIT_TYPE WaitType,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
	__in HANDLE Handle,
	__in SECURITY_INFORMATION SecurityInformation,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
	__in HANDLE Handle,
	__in SECURITY_INFORMATION SecurityInformation,
	__out_bcount_opt(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in ULONG Length,
	__out PULONG LengthNeeded
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
	__in HANDLE Handle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
	__in HANDLE DirectoryHandle,
	__out_bcount_opt(Length) PVOID Buffer,
	__in ULONG Length,
	__in BOOLEAN ReturnSingleEntry,
	__in BOOLEAN RestartScan,
	__inout PULONG Context,
	__out_opt PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
	__out PHANDLE LinkHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in PUNICODE_STRING LinkTarget
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
	__out PHANDLE LinkHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
	__in HANDLE LinkHandle,
	__inout PUNICODE_STRING LinkTarget,
	__out_opt PULONG ReturnedLength
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
	__in POWER_INFORMATION_LEVEL InformationLevel,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
	__in EXECUTION_STATE esFlags,               // ES_xxx flags
	__out EXECUTION_STATE* PreviousFlags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
	__in LATENCY_TIME latency
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
	__in POWER_ACTION SystemAction,
	__in SYSTEM_POWER_STATE MinSystemState,
	__in ULONG Flags,                 // POWER_ACTION_xxx flags
	__in BOOLEAN Asynchronous
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
	__in POWER_ACTION SystemAction,
	__in SYSTEM_POWER_STATE MinSystemState,
	__in ULONG Flags                  // POWER_ACTION_xxx flags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
	__in HANDLE Device,
	__out DEVICE_POWER_STATE* State
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
	__in HANDLE Device
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
	__in HANDLE Device
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcess(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in HANDLE ParentProcess,
	__in BOOLEAN InheritObjectTable,
	__in_opt HANDLE SectionHandle,
	__in_opt HANDLE DebugPort,
	__in_opt HANDLE ExceptionPort
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in HANDLE ParentProcess,
	__in ULONG Flags,
	__in_opt HANDLE SectionHandle,
	__in_opt HANDLE DebugPort,
	__in_opt HANDLE ExceptionPort,
	__in ULONG JobMemberLevel
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PCLIENT_ID ClientId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
	__in_opt HANDLE ProcessHandle,
	__in NTSTATUS ExitStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
	__in HANDLE ProcessHandle,
	__in PROCESSINFOCLASS ProcessInformationClass,
	__out_bcount(ProcessInformationLength) PVOID ProcessInformation,
	__in ULONG ProcessInformationLength,
	__out_opt PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextProcess(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Flags,
	__out PHANDLE NewProcessHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextThread(
	__in HANDLE ProcessHandle,
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Flags,
	__out PHANDLE NewThreadHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
	VOID
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
	__in HANDLE ProcessHandle,
	__in PROCESSINFOCLASS ProcessInformationClass,
	__in_bcount(ProcessInformationLength) PVOID ProcessInformation,
	__in ULONG ProcessInformationLength
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread(
	__out PHANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PCLIENT_ID ClientId
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateThread(
	__in_opt HANDLE ThreadHandle,
	__in NTSTATUS ExitStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendProcess(
	__in HANDLE ProcessHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeProcess(
	__in HANDLE ProcessHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetContextThread(
	__in HANDLE ThreadHandle,
	__inout PCONTEXT ThreadContext
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetContextThread(
	__in HANDLE ThreadHandle,
	__in PCONTEXT ThreadContext
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__out_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength,
	__out_opt PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__in_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertThread(
	__in HANDLE ThreadHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
	__in HANDLE ServerThreadHandle,
	__in HANDLE ClientThreadHandle,
	__in PSECURITY_QUALITY_OF_SERVICE SecurityQos
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwTestAlert(
	VOID
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
	__in HANDLE PortHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
	__in ULONG Selector0,
	__in ULONG Entry0Low,
	__in ULONG Entry0Hi,
	__in ULONG Selector1,
	__in ULONG Entry1Low,
	__in ULONG Entry1Hi
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobObject(
	__out PHANDLE JobHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
	__out PHANDLE JobHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
	__in HANDLE JobHandle,
	__in HANDLE ProcessHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
	__in HANDLE JobHandle,
	__in NTSTATUS ExitStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwIsProcessInJob(
	__in HANDLE ProcessHandle,
	__in_opt HANDLE JobHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
	__out PHANDLE KeyHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__reserved ULONG TitleIndex,
	__in_opt PUNICODE_STRING Class,
	__in ULONG CreateOptions,
	__out_opt PULONG Disposition
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
	__in HANDLE KeyHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
	__in HANDLE KeyHandle,
	__in ULONG Index,
	__in KEY_INFORMATION_CLASS KeyInformationClass,
	__out_bcount_opt(Length) PVOID KeyInformation,
	__in ULONG Length,
	__out PULONG ResultLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
	__in HANDLE KeyHandle,
	__in ULONG Index,
	__in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	__out_bcount_opt(Length) PVOID KeyValueInformation,
	__in ULONG Length,
	__out PULONG ResultLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
	__in HANDLE KeyHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
	__in USHORT BootCondition
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
	__in HANDLE KeyHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree,
	__out_bcount_opt(BufferSize) PVOID Buffer,
	__in ULONG BufferSize,
	__in BOOLEAN Asynchronous
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
	__in HANDLE MasterKeyHandle,
	__in_opt ULONG Count,
	__in_ecount_opt(Count) OBJECT_ATTRIBUTES SlaveObjects[],
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree,
	__out_bcount_opt(BufferSize) PVOID Buffer,
	__in ULONG BufferSize,
	__in BOOLEAN Asynchronous
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey(
	__in POBJECT_ATTRIBUTES TargetKey,
	__in POBJECT_ATTRIBUTES SourceFile
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey2(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in POBJECT_ATTRIBUTES   SourceFile,
	__in ULONG                Flags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in POBJECT_ATTRIBUTES   SourceFile,
	__in ULONG                Flags,
	__in_opt HANDLE           TrustClassKey
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
	__out PHANDLE KeyHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
	__in HANDLE KeyHandle,
	__in KEY_INFORMATION_CLASS KeyInformationClass,
	__out_bcount_opt(Length) PVOID KeyInformation,
	__in ULONG Length,
	__out PULONG ResultLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName,
	__in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	__out_bcount_opt(Length) PVOID KeyValueInformation,
	__in ULONG Length,
	__out PULONG ResultLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
	__in HANDLE KeyHandle,
	__inout_ecount(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
	__in ULONG EntryCount,
	__out_bcount(*BufferLength) PVOID ValueBuffer,
	__inout PULONG BufferLength,
	__out_opt PULONG RequiredBufferLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwReplaceKey(
	__in POBJECT_ATTRIBUTES NewFile,
	__in HANDLE             TargetHandle,
	__in POBJECT_ATTRIBUTES OldFile
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRenameKey(
	__in HANDLE           KeyHandle,
	__in PUNICODE_STRING  NewName
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompactKeys(
	__in ULONG Count,
	__in_ecount(Count) HANDLE KeyArray[]
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompressKey(
	__in HANDLE Key
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRestoreKey(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle,
	__in ULONG Flags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKey(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle,
	__in ULONG  Format
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
	__in HANDLE HighPrecedenceKeyHandle,
	__in HANDLE LowPrecedenceKeyHandle,
	__in HANDLE FileHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName,
	__in_opt ULONG TitleIndex,
	__in ULONG Type,
	__in_bcount_opt(DataSize) PVOID Data,
	__in ULONG DataSize
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey(
	__in POBJECT_ATTRIBUTES TargetKey
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in ULONG                Flags
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
	__in POBJECT_ATTRIBUTES TargetKey,
	__in_opt HANDLE Event
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
	__in HANDLE KeyHandle,
	__in KEY_SET_INFORMATION_CLASS KeySetInformationClass,
	__in_bcount(KeySetInformationLength) PVOID KeySetInformation,
	__in ULONG KeySetInformationLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
	__in POBJECT_ATTRIBUTES TargetKey,
	__out PULONG  HandleCount
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in ULONG                BufferLength,
	__out_bcount(BufferLength) PVOID               Buffer,
	__out PULONG              RequiredSize
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
	__in HANDLE           KeyHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
	__inout_opt ULONG* pPrivateVer,
	__out_opt ULONG* pSafeMode
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheck(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByType(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateToken(
	__out PHANDLE TokenHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in TOKEN_TYPE TokenType,
	__in PLUID AuthenticationId,
	__in PLARGE_INTEGER ExpirationTime,
	__in PTOKEN_USER User,
	__in PTOKEN_GROUPS Groups,
	__in PTOKEN_PRIVILEGES Privileges,
	__in_opt PTOKEN_OWNER Owner,
	__in PTOKEN_PRIMARY_GROUP PrimaryGroup,
	__in_opt PTOKEN_DEFAULT_DACL DefaultDacl,
	__in PTOKEN_SOURCE TokenSource
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompareTokens(
	__in HANDLE FirstTokenHandle,
	__in HANDLE SecondTokenHandle,
	__out PBOOLEAN Equal
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in BOOLEAN OpenAsSelf,
	__out PHANDLE TokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in BOOLEAN OpenAsSelf,
	__in ULONG HandleAttributes,
	__out PHANDLE TokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__out PHANDLE TokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__out PHANDLE TokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
	__in HANDLE ExistingTokenHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in BOOLEAN EffectiveOnly,
	__in TOKEN_TYPE TokenType,
	__out PHANDLE NewTokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwFilterToken(
	__in HANDLE ExistingTokenHandle,
	__in ULONG Flags,
	__in_opt PTOKEN_GROUPS SidsToDisable,
	__in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
	__in_opt PTOKEN_GROUPS RestrictedSids,
	__out PHANDLE NewTokenHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
	__in HANDLE ThreadHandle
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken(
	__in HANDLE TokenHandle,
	__in TOKEN_INFORMATION_CLASS TokenInformationClass,
	__out_bcount_part_opt(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
	__in ULONG TokenInformationLength,
	__out PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken(
	__in HANDLE TokenHandle,
	__in TOKEN_INFORMATION_CLASS TokenInformationClass,
	__in_bcount(TokenInformationLength) PVOID TokenInformation,
	__in ULONG TokenInformationLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken(
	__in HANDLE TokenHandle,
	__in BOOLEAN DisableAllPrivileges,
	__in_opt PTOKEN_PRIVILEGES NewState,
	__in_opt ULONG BufferLength,
	__out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
	__out_opt PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken(
	__in HANDLE TokenHandle,
	__in BOOLEAN ResetToDefault,
	__in PTOKEN_GROUPS NewState,
	__in_opt ULONG BufferLength,
	__out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
	__out PULONG ReturnLength
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck(
	__in HANDLE ClientToken,
	__inout PPRIVILEGE_SET RequiredPrivileges,
	__out PBOOLEAN Result
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in ACCESS_MASK DesiredAccess,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in HANDLE ClientToken,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in ACCESS_MASK GrantedAccess,
	__in_opt PPRIVILEGE_SET Privileges,
	__in BOOLEAN ObjectCreation,
	__in BOOLEAN AccessGranted,
	__out PBOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in PPRIVILEGE_SET Privileges,
	__in BOOLEAN AccessGranted
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in BOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in BOOLEAN GenerateOnClose
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in PUNICODE_STRING ServiceName,
	__in HANDLE ClientToken,
	__in PPRIVILEGE_SET Privileges,
	__in BOOLEAN AccessGranted
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwTraceEvent(
	__in HANDLE TraceHandle,
	__in ULONG Flags,
	__in ULONG FieldSize,
	__in PVOID Fields
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwContinue(
	__in PCONTEXT ContextRecord,
	__in BOOLEAN TestAlert
	);
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseException(
	__in PEXCEPTION_RECORD ExceptionRecord,
	__in PCONTEXT ContextRecord,
	__in BOOLEAN FirstChance
	);

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
	);
```

`Garhal/vector.c`:

```c
#include <stdio.h>
#include "ntifs.h"
#include "vector.h"

void vector_init(vector* v)
{
	v->capacity = VECTOR_INIT_CAPACITY;
	v->total = 0;
	v->items = MmAllocateNonCachedMemory(sizeof(void*) * v->capacity);
}

int vector_total(vector* v)
{
	if (v == NULL)
	{
		return -1;
	}

	return v->total;
}

static void vector_resize(vector* v, int capacity)
{
	if (v == NULL || v->items == NULL)
	{
		return;
	}

	//void** items = realloc(v->items, sizeof(void*) * capacity);
	void** items = MmAllocateNonCachedMemory(sizeof(void*) * capacity);
	if (items)
	{
		// Not sure if this is the smoothest way, but It works.
		for (int i = 0; i < vector_total(v); i++)
		{
			void* currentitem = vector_get(v, i);
			items[i] = currentitem;
		}
		vector_free(v);

		v->items = items;
		v->capacity = capacity;
	}
}

void vector_add(vector* v, void* item)
{
	if (v == NULL || v->items == NULL)
	{
		return;
	}

	if (v->capacity == v->total)
	{
		vector_resize(v, v->capacity * 2);
	}
	v->items[v->total++] = item;
}

void vector_set(vector* v, int index, void* item)
{
	if (v != NULL && v->items != NULL && index >= 0 && index < v->total)
	{
		v->items[index] = item;
	}
}

void* vector_get(vector* v, int index)
{
	if (v != NULL && v->items != NULL && index >= 0 && index < v->total)
	{
		return v->items[index];
	}
	return NULL;
}

void vector_delete(vector* v, int index)
{
	if (v == NULL || v->items == NULL)
	{
		return;
	}

	if (index < 0 || index >= v->total)
	{
		return;
	}

	v->items[index] = NULL;

	for (int i = index; i < v->total - 1; i++)
	{
		v->items[i] = v->items[i + 1];
		v->items[i + 1] = NULL;
	}

	v->total--;

	if (v->total > 0 && v->total == v->capacity / 4)
	{
		vector_resize(v, v->capacity / 2);
	}
}

void vector_free(vector* v)
{
	if (v != NULL && v->items != NULL)
	{
		MmFreeNonCachedMemory(v->items, sizeof(v->items));
	}
	//free(v->items);
}
```

`Garhal/vector.h`:

```h
#pragma once

#ifndef VECTOR_H
#define VECTOR_H

#define VECTOR_INIT_CAPACITY 4

#define VECTOR_INIT(vec) vector vec; vector_init(&vec)
#define VECTOR_ADD(vec, item) vector_add(&vec, (void *) item)
#define VECTOR_SET(vec, id, item) vector_set(&vec, id, (void *) item)
#define VECTOR_GET(vec, type, id) (type) vector_get(&vec, id)
#define VECTOR_DELETE(vec, id) vector_delete(&vec, id)
#define VECTOR_TOTAL(vec) vector_total(&vec)
#define VECTOR_FREE(vec) vector_free(&vec)

typedef struct vector {
	void** items;
	int capacity;
	int total;
} vector;

void vector_init(vector*);
int vector_total(vector*);
static void vector_resize(vector*, int);
void vector_add(vector*, void*);
void vector_set(vector*, int, void*);
void* vector_get(vector*, int);
void vector_delete(vector*, int);
void vector_free(vector*);

#endif
```

`GarhalController/Aimbot.cpp`:

```cpp
#pragma warning (disable : 26451)

#include "Aimbot.hpp"
#include <chrono>
#include <cstddef>
#include <iostream>
#include "data.hpp"
#include "offsets.hpp"


Vector3 Aimbot::aimAnglesTo(Vector3& target)
{
    //Vector3 localPosition = localPlayer.getAbsolutePosition();
    Vector3 localPosition = localPlayer.getHeadPosition();
	
    Vector3 punchAngles = localPlayer.getAimPunch();

    Vector3 dPosition = localPosition - target;

    float hypotenuse = sqrt(dPosition(0) * dPosition(0) + dPosition(1) * dPosition(1));

    Vector3 a((float)(atan2f(dPosition(2), hypotenuse) * 57.295779513082f), (float)(atanf(dPosition(1) / dPosition(0)) * 57.295779513082f), 0);

    if (dPosition(0) >= 0.f)
        a(1) += 180.0f;

    Vector3 aimAngles;
    aimAngles(0) = a(0);     // up and down
    aimAngles(1) = a(1);      // left and right

    aimAngles(0) -= punchAngles(0) * 2;
    aimAngles(1) -= punchAngles(1) * 2;

    normalizeAngles(aimAngles);
    clampAngles(aimAngles);

    aimAngles(2) = 0.f;
    return aimAngles;
}

Vector3 Aimbot::angleDifferenceToEntity(Entity& localPlayer, Entity& entity)
{
    Vector3 viewAngles = getViewAngles();
    Vector3 pos;

    if (AimbotTarget == 3)
    {
        if (entity.getHealth() <= 50)
        {
            pos = entity.GetBonePosition(CHEST_BONE_ID);//target.getBonePosition(CHEST_BONE_ID);
        }
        else
        {
            pos = entity.getHeadPosition();//target.getBonePosition(boneId);
        }
    }
    else if (AimbotTarget == 2)
    {
        pos = entity.GetBonePosition(CHEST_BONE_ID);
    }
    else
    {
        pos = entity.getHeadPosition();
    }

    Vector3 aimAngles = aimAnglesTo(pos);

    Vector3 dAngle(-1, -1, 0);

    if (aimAngles(0) != aimAngles(0) || aimAngles(1) != aimAngles(1))
        return dAngle;


    dAngle(0) = abs(aimAngles(0) - viewAngles(0));
    dAngle(1) = abs(aimAngles(1) - viewAngles(1));

    return dAngle;
}

bool Aimbot::enemyIsInCrossHair()
{
    if (!localPlayer.isValidPlayer())
    {
        return false;
    }

    uint32_t crossHairId = localPlayer.getCrosshairId();
    if (crossHairId <= 0 || crossHairId > 65)
    {
        return false;
    }

    crossHairId -= 1;

    uint32_t EntityAddr = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + hazedumper::signatures::dwEntityList + 0x10 * crossHairId, sizeof(uint32_t));

    Entity target = Entity(EntityAddr);

    if (!target.isValidPlayer())
    {
        return false;
    }

    bool isEnemy = target.getTeam() != localPlayer.getTeam();

    return isEnemy;
}

Entity Aimbot::findClosestEnemyToFOV()
{
    uint32_t localPlayerTeam = localPlayer.getTeam();
    Entity closestPlayer;

    if (!localPlayer.isValidPlayer())
        return closestPlayer;

    Vector3 localPosition = localPlayer.getAbsolutePosition();

    float closest = FLT_MAX;
    for (int i = 0; i < 64; i++)
    {
        uint32_t EntityAddr = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + hazedumper::signatures::dwEntityList + i * 0x10, sizeof(uint32_t));

        if (EntityAddr == NULL)
        {
            continue;
        }

        Entity entity = Entity(EntityAddr);

        if (!entity.isValidPlayer()) 
        {
            continue;
        }

        if (entity.getTeam() == localPlayerTeam) 
        {
            continue;
        }

        Vector3 entityPosition;

        if (AimbotTarget == 3)
        {
            if (entity.getHealth() <= 50)
            {
                entityPosition = entity.GetBonePosition(CHEST_BONE_ID);
            }
            else
            {
                entityPosition = entity.getHeadPosition();
            }
        }
        else if (AimbotTarget == 2)
        {
            entityPosition = entity.GetBonePosition(CHEST_BONE_ID);
        }
        else
        {
            entityPosition = entity.getHeadPosition();
        }

    	
        if (!bspParser->is_visible(localPosition, entityPosition)) 
        {
            continue;
        }

        Vector3 dAngle = angleDifferenceToEntity(localPlayer, entity);
        float screenDifferenceToEntity = sqrt(dAngle(0) * dAngle(0) + dAngle(1) * dAngle(1));
        if (screenDifferenceToEntity >= closest) 
        {
            continue;
        }

        if (screenDifferenceToEntity >= FovRange)
        {
            //std::cout << fov << " " << screenDifferenceToEntity << std::endl;
            continue;
        }

        closest = screenDifferenceToEntity;
        closestPlayer = entity;
    }

    return closestPlayer;
}

Vector3 Aimbot::getViewAngles()
{
    int clientState = Driver.ReadVirtualMemory<int>(ProcessId, EngineAddress + hazedumper::signatures::dwClientState, sizeof(int));
	return Driver.ReadVirtualMemory<Vector3>(ProcessId, clientState + hazedumper::signatures::dwClientState_ViewAngles, sizeof(Vector3));
}


float Aimbot::getSensitivity()
{
    uint32_t sensitivityPtr = ClientAddress + hazedumper::signatures::dwSensitivityPtr;
    uint32_t sensitivity = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + hazedumper::signatures::dwSensitivity, sizeof(uint32_t));

    sensitivity ^= sensitivityPtr;

    float sens = *reinterpret_cast<float*>(&sensitivity);

    return sens;
}

const char* Aimbot::getMapDirectory()
{
    uint32_t clientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + hazedumper::signatures::dwClientState, sizeof(uint32_t));
    static std::array<char, 0x120> mapDirectory = Driver.ReadVirtualMemory<std::array<char, 0x120>>(ProcessId, clientState + hazedumper::signatures::dwClientState_MapDirectory, sizeof(std::array<char, 0x120>));
    return mapDirectory.data();
}

const char* Aimbot::getGameDirectory()
{
    static std::array<char, 0x120> gameDirectory = Driver.ReadVirtualMemory<std::array<char, 0x120>>(ProcessId, EngineAddress + hazedumper::signatures::dwGameDir, sizeof(std::array<char, 0x120>));
    return gameDirectory.data();
}

void Aimbot::setViewAngles(Vector3& viewAngles)
{
    uint32_t clientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + hazedumper::signatures::dwClientState, sizeof(uint32_t));
    Driver.WriteVirtualMemory(ProcessId, clientState + hazedumper::signatures::dwClientState_ViewAngles, viewAngles, sizeof(viewAngles));
}

void Aimbot::setSensitivity(float sens)
{
    uint32_t sensitivityPtr = ClientAddress + hazedumper::signatures::dwSensitivityPtr;
    uint32_t sensitivity = *reinterpret_cast<uint32_t*>(&sens) ^ sensitivityPtr;

    Driver.WriteVirtualMemory(ProcessId, ClientAddress + hazedumper::signatures::dwSensitivity, sensitivity, sizeof(sensitivity));
}

void Aimbot::resetSensitivity()
{
    setSensitivity(defaultSensitivity);
}

bool Aimbot::EnemyIsInCrossHair()
{
    if (!localPlayer.isValidPlayer()) 
    {
        return false;
    }

    uint32_t localPlayerTeam = localPlayer.getTeam();
    uint16_t CrosshairID = localPlayer.getCrosshairId();
    if (CrosshairID <= 0 || CrosshairID > 65)
    {
        return false;
    }

    CrosshairID -= 1;
    uint32_t crosshairentity = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + hazedumper::signatures::dwEntityList + 0x10 * CrosshairID, sizeof(uint32_t));
	if (crosshairentity == NULL)
	{
        return false;
	}
	
    Entity target(crosshairentity);

    if (!target.isValidPlayer()) 
    {
        return false;
    }

    bool isEnemy = target.getTeam() != localPlayerTeam;

    return isEnemy;
}

void Aimbot::TriggerBot()
{
    if (EnemyIsInCrossHair()) 
    {
        localPlayer.shoot();
    }
    else 
    {
        localPlayer.setForceAttack(4);
    }
}

bool Aimbot::aimAssist()
{
    const char* gameDirectory = getGameDirectory();
    const char* mapDirectory = getMapDirectory();
    bspParser->parse_map(gameDirectory, mapDirectory);

    if (!localPlayer.isValidPlayer()) 
    {
        return false;
    }

    int16_t WeaponID = localPlayer.GetCurrentWeaponID();

	if (WeaponID == 0)
	{
        return false;
	}

    // Enable AimAssist after Nth bullet except pistols & snipers.
    if (localPlayer.getShotsFired() < AimbotBullets && !IsWeaponPistol(WeaponID) && !IsWeaponSniper(WeaponID))
    {
        return false;
    }

    static Entity target = findClosestEnemyToFOV();
    static auto killTime = std::chrono::high_resolution_clock::now();
    static Vector3* lastPosition = NULL;

    Entity newTarget = findClosestEnemyToFOV();
    if (target.isValidPlayer() && !target.isInAir() && newTarget.isValidPlayer() && target.GetEntityAddress() == newTarget.GetEntityAddress())
    {
        killTime = std::chrono::high_resolution_clock::now();
        lastPosition = new Vector3();


        if (AimbotTarget == 3) 
        {
            if (target.getHealth() <= 50)
            {
                *lastPosition = target.GetBonePosition(CHEST_BONE_ID);//target.getBonePosition(CHEST_BONE_ID);
            }
            else
            {
                *lastPosition = target.getHeadPosition();//target.getBonePosition(boneId);
            }
        }
        else if (AimbotTarget == 2)
        {
            *lastPosition = target.GetBonePosition(CHEST_BONE_ID);
        }
        else
        {
            *lastPosition = target.getHeadPosition();
        }
    }

    auto now = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> timeSinceKill = now - killTime;

    // continue shooting at target even after they die for 0.2 seconds
    if (timeSinceKill.count() > 0.2f && lastPosition)
    {
        delete lastPosition;
        lastPosition = NULL;
    }

    if (lastPosition)
    {
        if (!bspParser->is_visible(localPlayer.getAbsolutePosition(), *lastPosition))
            return false;

        // block user input
        setSensitivity(0.f);

        Vector3 targetAngle = aimAnglesTo(*lastPosition);
        if (targetAngle(0) != targetAngle(0) || targetAngle(1) != targetAngle(1) || targetAngle(2) != targetAngle(2)) 
        {
            return false;
        }

        Vector3 viewAngles = getViewAngles();


        float dYawTowardsRight = viewAngles(1) - targetAngle(1);
        while (dYawTowardsRight < 0) 
        {
            dYawTowardsRight += 360.f;
        }
        while (dYawTowardsRight > 360.f) 
        {
            dYawTowardsRight -= 360.f;
        }
    	
        float dYawTowardsLeft = dYawTowardsRight - 360.f;

        Vector3 dAngles = targetAngle - viewAngles;
        if (abs(dYawTowardsRight) < abs(dYawTowardsLeft)) 
        {
            dAngles(1) = -dYawTowardsRight;
        }
        else 
        {
            dAngles(1) = -dYawTowardsLeft;
        }

        Vector3 smoothTargetAngles = viewAngles + dAngles / 5;

        normalizeAngles(smoothTargetAngles);
        clampAngles(smoothTargetAngles);

        smoothTargetAngles(2) = 0.f;
        setViewAngles(smoothTargetAngles);

        return true;
    }
	
    // find new target
    target = newTarget;
    killTime = std::chrono::high_resolution_clock::now();
    lastPosition = NULL;
    resetSensitivity();

    return false;
}

void Aimbot::aimBot()
{
    if (!localPlayer.isValidPlayer()) 
    {
        return;
    }

    Entity target = findClosestEnemyToFOV();

    if (!target.isValidPlayer()) 
    {
        return;
    }

    Vector3 pos;

    if (AimbotTarget == 3)
    {
        if (target.getHealth() <= 50)
        {
            pos = target.GetBonePosition(CHEST_BONE_ID);//target.getBonePosition(CHEST_BONE_ID);
        }
        else
        {
            pos = target.getHeadPosition();//target.getBonePosition(boneId);
        }
    }
    else if (AimbotTarget == 2)
    {
        pos = target.GetBonePosition(CHEST_BONE_ID);
    }
    else
    {
        pos = target.getHeadPosition();
    }

    Vector3 aimAngles = aimAnglesTo(pos);
    if (aimAngles(0) != aimAngles(0) || aimAngles(1) != aimAngles(1) || aimAngles(2) != aimAngles(2)) 
    {
        return;
    }

    //std::cout << aimAngles(0) << "-" << aimAngles(1) << "-" << aimAngles(2) << std::endl;
    setViewAngles(aimAngles);
}

void Aimbot::walkBot()
{
    if (!localPlayer.isValidPlayer())
    {
        return;
    }

    Vector3 viewAngles = getViewAngles();
    Vector3 velocity = localPlayer.getVelocity();
    float speed = sqrt(velocity(0) * velocity(0) + velocity(1) * velocity(1));

    if (speed < 150.f)
    {
        viewAngles(0) = 0.f;
        viewAngles(1) += 1.f;
        viewAngles(2) = 0.f;

        normalizeAngles(viewAngles);
        clampAngles(viewAngles);

        setViewAngles(viewAngles);
    }
}

void Aimbot::normalizeAngles(Vector3& angles)
{
    while (angles(0) > 89.f)
        angles(0) -= 180.f;

    while (angles(0) < -89.f)
        angles(0) += 180.f;

    while (angles(1) > 180.f)
        angles(1) -= 360.f;

    while (angles(1) < -180.f)
        angles(1) += 360.f;
}

void Aimbot::clampAngles(Vector3& angles)
{
    if (angles(0) > 89.0)
        angles(0) = 89.0;

    if (angles(0) < -89.0)
        angles(0) = -89.0;

    if (angles(1) > 180.0)
        angles(1) = 180.0;

    if (angles(1) < -180.0)
        angles(1) = -180.0;
}

Aimbot::Aimbot(hazedumper::BSPParser* bspParser)
{
    this->bspParser = bspParser;
    this->defaultSensitivity = getSensitivity();
}


Aimbot::Aimbot()
{
    this->defaultSensitivity = getSensitivity();
}

Aimbot::~Aimbot()
{

}

```

`GarhalController/Aimbot.hpp`:

```hpp
#pragma once
#include "BSPParser.hpp"
#include "data.hpp"
#include "Entity.hpp"

class Aimbot
{
private:
    hazedumper::BSPParser* bspParser;
    float defaultSensitivity;
    Entity findClosestEnemyToFOV();
    Vector3 angleDifferenceToEntity(Entity& localPlayer, Entity& entity);
    Vector3 getViewAngles();
    Vector3 aimAnglesTo(Vector3& entity);
    void normalizeAngles(Vector3& angles);
    void clampAngles(Vector3& angles);
    void setViewAngles(Vector3& viewAngles);
    void setSensitivity(float sens);
    float getSensitivity();
    bool enemyIsInCrossHair();
    const char* getMapDirectory();
    const char* getGameDirectory();
public:
    Entity localPlayer;
    bool aimAssist();
    void aimBot();
    void walkBot();
    void resetSensitivity();
    void TriggerBot();
    bool EnemyIsInCrossHair();
    Aimbot(hazedumper::BSPParser* bspParser);
    Aimbot();
    ~Aimbot();
};

```

`GarhalController/AntiAim.cpp`:

```cpp
#pragma warning (disable : 26495 4302 4311)

#include "AntiAim.hpp"
#include "offsets.hpp"


void AntiAim::SetUserCMDViewAngles(Vector3 viewAngles)
{
	Driver.WriteVirtualMemory<float>(ProcessId, cmdAngleX, viewAngles(0), sizeof(viewAngles(0)));
	Driver.WriteVirtualMemory<float>(ProcessId, cmdAngleX, viewAngles(1), sizeof(viewAngles(1)));
	Driver.WriteVirtualMemory<float>(ProcessId, cmdAngleX, viewAngles(2), sizeof(viewAngles(2)));
}

void AntiAim::SetUserCmd(UserCMD_ShellCode cmd)
{
	cmd.shouldSet = true;
	Driver.WriteVirtualMemory<UserCMD_ShellCode>(ProcessId, CMDAddress, cmd, sizeof(cmd));
}

Vector3 AntiAim::getLocalViewAngles()
{
	uint32_t clientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + hazedumper::signatures::dwClientState, sizeof(uint32_t));
	return Driver.ReadVirtualMemory<Vector3>(ProcessId, clientState + hazedumper::signatures::dwClientState_ViewAngles, sizeof(Vector3));
}

Vector3 AntiAim::getUserCMDViewAngles()
{
	Vector3 buffer;
	buffer(0) = Driver.ReadVirtualMemory<float>(ProcessId, cmdAngleX, sizeof(float));
	buffer(1) = Driver.ReadVirtualMemory<float>(ProcessId, cmdAngleY, sizeof(float));
	buffer(2) = Driver.ReadVirtualMemory<float>(ProcessId, cmdAngleZ, sizeof(float));
	return buffer;
}

// Credits: sethxi
DWORD AntiAim::GetVFunc(DWORD inst, int Index)
{
	DWORD table = Driver.ReadVirtualMemory<DWORD>(ProcessId, inst, sizeof(inst));
	DWORD func = table + sizeof(DWORD) * Index;
	return func;
}

void AntiAim::Hook(DWORD Instance, int Index, DWORD HookFunc)
{
	uintptr_t VFunc = GetVFunc(Instance, Index);
	DWORD OldProtect;
	
	VirtualProtectEx(ProcessHandle, (LPVOID)VFunc, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &OldProtect);
	Driver.WriteVirtualMemory<DWORD>(ProcessId, VFunc, HookFunc, sizeof(HookFunc));
	VirtualProtectEx(ProcessHandle, (LPVOID)VFunc, sizeof(DWORD), OldProtect, &OldProtect);
}

void AntiAim::HookCreateMove()
{
	BYTE hook[] = "\x55\x89\xE5\x8B\x55\x0C\x8B\x0D\x00\x00\x00\x00\x83\xF9\x01\x74\x02\xEB\x2A\xA1\x00\x00\x00\x00\x89\x42\x0C\xA1\x00\x00\x00\x00\x89\x42\x10\xA1\x00\x00\x00\x00\x89\x42\x14\xA1\x00\x00\x00\x00\x89\x42\x24\xA1\x00\x00\x00\x00\x89\x42\x28\xEB\x00\x5D\xC2\x08\x00";
	/*
	asm (with forward/sidemove):
	push ebp
	mov ebp,esp
	mov edx,DWORD PTR [ebp+0xc]
	mov ecx,[0x00000000]
	cmp ecx, 1
	je setCmd
	jmp done
	setCmd:
	mov eax,[0x00000000]
	mov [edx+0xc], eax
	mov eax,[0x00000000]
	mov [edx+0x10], eax
	mov eax,[0x00000000]
	mov [edx+0x14], eax
	mov eax,[0x00000000]
	mov [edx+0x24], eax
	mov eax,[0x00000000]
	mov [edx+0x28], eax
	jmp done
	done:
	pop ebp
	ret 8
	*/

	// TODO: Use shell code struct.
	cmdAngleX = (DWORD) VirtualAllocEx(ProcessHandle, NULL, sizeof(float) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	cmdAngleY = (DWORD) VirtualAllocEx(ProcessHandle, NULL, sizeof(float) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	cmdAngleZ = (DWORD) VirtualAllocEx(ProcessHandle, NULL, sizeof(float) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	shouldSetAngles = (DWORD) VirtualAllocEx(ProcessHandle, NULL, sizeof(bool) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	CMDAddress = (DWORD) VirtualAllocEx(ProcessHandle, NULL, sizeof(UserCMD_ShellCode) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	LPVOID shellCodeAddress = VirtualAllocEx(ProcessHandle, NULL, sizeof(hook) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	const float zero = 0.f;
	if (!Driver.WriteVirtualMemory<float>(ProcessId, CMDAddress, zero, sizeof(zero)))
	{
		return;
	}

	// Fill in addresses that (inside CS:GO) point towards the values we set
	*(DWORD*)(&hook[0x14]) = CMDAddress;
	*(DWORD*)(&hook[0x1C]) = CMDAddress + 0x4;
	*(DWORD*)(&hook[0x24]) = CMDAddress + 0x8;
	*(DWORD*)(&hook[0x2C]) = CMDAddress + 0xC;
	*(DWORD*)(&hook[0x34]) = CMDAddress + 0x10;
	// Should Set
	*(DWORD*)(&hook[0x8]) = CMDAddress + 0x14;

	if (!Driver.WriteVirtualMemory(ProcessId, (ULONG) shellCodeAddress, &hook[0], sizeof(hook)))
	{
		return;
	}

	DWORD gar = reinterpret_cast<DWORD>(IClientMode);
	Hook(gar, 24, (DWORD)shellCodeAddress);
}

void AntiAim::DoAntiAim()
{
	if (!GetAsyncKeyState(0x1))
	{
		ShouldSetViewAnglesThisTick = true;
		Vector3 currentViewAngles = getLocalViewAngles();
		currentViewAngles(0) = 89.f;
		SetUserCMDViewAngles(currentViewAngles);
	}
	else
	{
		ShouldSetViewAnglesThisTick = false;
	}
	Driver.WriteVirtualMemory<bool>(ProcessId, shouldSetAngles, ShouldSetViewAnglesThisTick, sizeof(bool));
}

void AntiAim::Enable()
{
	ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
}

AntiAim::AntiAim()
{
	
}

AntiAim::~AntiAim()
{
	if (ProcessHandle != NULL)
	{
		CloseHandle(ProcessHandle);
	}
}

```

`GarhalController/AntiAim.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include "data.hpp"

class AntiAim
{
public:
	AntiAim();
	~AntiAim();
	void DoAntiAim();
	void SetUserCMDViewAngles(Vector3 viewAngles);
	void Hook(DWORD Instance, int Index, DWORD HookFunc);
	void HookCreateMove();
	void SetUserCmd(UserCMD_ShellCode cmd);
	void Enable();
	Vector3 getLocalViewAngles();
	Vector3 getUserCMDViewAngles();
	DWORD GetVFunc(DWORD inst, int Index);
	
private:
	HANDLE ProcessHandle;
	bool ShouldSetViewAnglesThisTick = false;

	// Should set angle "pointer" (technically a pointer but it points to a "bool" in another address space)
	// If true, the game will rely on us to provide viewangles for the userCMD structure (if we don't, they are never changed)
	// If false, the game does the viewangles for the userCMD itself
	DWORD shouldSetAngles;
	//userCMD viewangle x "pointer"
	DWORD cmdAngleX;
	//userCMD viewangle y "pointer"
	DWORD cmdAngleY;
	//userCMD viewangle z "pointer"
	DWORD cmdAngleZ;
};

```

`GarhalController/BSPFile.cpp`:

```cpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#include "BSPFile.hpp"
#include <iostream>
using namespace hazedumper;
using namespace BSP;

BSPFile::BSPFile( const std::string& bsp_directory, const std::string& bsp_file )
{
    parse( bsp_directory, bsp_file );
}

bool BSPFile::parse( const std::string& bsp_directory, const std::string& bsp_file )
{
    if( bsp_directory.empty() || bsp_file.empty() ) {
        return false;
    }

    std::ifstream bsp_binary( bsp_directory + "\\" + bsp_file, std::ios::binary );
    if( !bsp_binary.is_open() ) {
        return false;
    }
    m_FileName = bsp_file;
    try {
        /// parse the bsp header
        bsp_binary.read( reinterpret_cast< char* >( &m_BSPHeader ), sizeof dheader_t );

        /// check bsp version/ident
        if( m_BSPHeader.m_Version < BSPVERSION ) {
            std::cout << "BSPFile::parse(): " << bsp_file << "has an unknown BSP version, trying to parse it anyway..." << std::endl;
        }
        if( m_BSPHeader.m_Ident != IDBSPHEADER ) {
            std::cout << "BSPFile::parse(): " << bsp_file << "isn't a (valid) BSP file!" << std::endl;
            return false;
        }

        parse_lump_data( bsp_binary, LUMP_VERTEXES, m_Vertexes );
        if( !parse_planes( bsp_binary ) ) {
            return false;
        }

        parse_lump_data( bsp_binary, LUMP_EDGES, m_Edges );
        parse_lump_data( bsp_binary, LUMP_SURFEDGES, m_Surfedges );
        parse_lump_data( bsp_binary, LUMP_LEAFS, m_Leaves );
        if( !parse_nodes( bsp_binary ) ) {
            return false;
        }

        parse_lump_data( bsp_binary, LUMP_FACES, m_Surfaces );
        parse_lump_data( bsp_binary, LUMP_TEXINFO, m_Texinfos );
        parse_lump_data( bsp_binary, LUMP_BRUSHES, m_Brushes );
        parse_lump_data( bsp_binary, LUMP_BRUSHSIDES, m_Brushsides );
        if( !parse_leaffaces( bsp_binary )
            || !parse_leafbrushes( bsp_binary )
            || !parse_polygons() ) {
            return false;
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse", e );
        return false;
    }

    return true;
}

bool BSPFile::parse_planes( std::ifstream& bsp_binary )
{
    try {
        std::vector< dplane_t > planes;
        parse_lump_data( bsp_binary, LUMP_PLANES, planes );

        m_Planes = std::vector< cplane_t >( planes.size() );

        int32_t plane_bits;
        for( size_t i = 0; i < planes.size(); ++i ) {
            auto& out = m_Planes.at( i );
            auto& in = planes.at( i );

            plane_bits = 0;
            for( size_t j = 0; j < 3; ++j ) {
                out.m_Normal( j ) = in.m_Normal( j );
                if( out.m_Normal( j ) < 0.f ) {
                    plane_bits |= 1 << static_cast< int32_t >( j );
                }
            }

            out.m_Distance = in.m_Distance;
            out.m_Type = static_cast< uint8_t >( in.m_Type );
            out.m_SignBits = static_cast< uint8_t >( plane_bits );
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse_planes", e );
        return false;
    }
    return true;
}

bool BSPFile::parse_nodes( std::ifstream& bsp_binary )
{
    try {
        std::vector< dnode_t > nodes;
        parse_lump_data( bsp_binary, LUMP_NODES, nodes );

        const auto num_nodes = nodes.size();
        m_Nodes = std::vector< snode_t >( num_nodes );

        for( size_t i = 0; i < num_nodes; ++i ) {
            auto& in = nodes.at( i );
            auto& out = m_Nodes.at( i );

            out.m_Mins = in.m_Mins;
            out.m_Maxs = in.m_Maxs;
            out.m_PlaneNum = in.m_Planenum;
            out.m_pPlane = m_Planes.data() + in.m_Planenum;
            out.m_Firstface = in.m_Firstface;
            out.m_Numfaces = in.m_Numfaces;

            for( size_t j = 0; j < 2; ++j ) {
                auto child_index = in.m_Children.at( j );
                out.m_Children.at( j ) = child_index;

                if( child_index >= 0 ) {
                    out.m_LeafChildren = nullptr;
                    out.m_NodeChildren = m_Nodes.data() + child_index;
                }
                else {
                    out.m_LeafChildren = m_Leaves.data() + ( -1 - child_index );
                    out.m_NodeChildren = nullptr;
                }
            }
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse_nodes", e );
        return false;
    }
    return true;
}

bool BSPFile::parse_leaffaces( std::ifstream& bsp_binary )
{
    try {
        parse_lump_data( bsp_binary, LUMP_LEAFFACES, m_Leaffaces );

        const auto num_leaffaces = m_Leaffaces.size();
        if( num_leaffaces > MAX_MAP_LEAFBRUSHES ) {
            std::cout << "BSPFile::parse_leaffaces(): map has to many leaffaces, parsed more than required.." << std::endl;
        }
        else if( !num_leaffaces ) {
            std::cout << "BSPFile::parse_leaffaces(): map has no leaffaces to parse!" << std::endl;
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse_leaffaces", e );
        return false;
    }
    return true;
}

bool BSPFile::parse_leafbrushes( std::ifstream& bsp_binary )
{
    try {
        parse_lump_data( bsp_binary, LUMP_LEAFBRUSHES, m_Leafbrushes );

        const auto num_leaffaces = m_Leaffaces.size();
        if( num_leaffaces > MAX_MAP_LEAFBRUSHES ) {
            std::cout << "BSPFile::parse_leaffaces(): map has to many leafbrushes, parsed more than required.." << std::endl;
        }
        else if( !num_leaffaces ) {
            std::cout << "BSPFile::parse_leaffaces(): map has no leafbrushes to parse!" << std::endl;
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse_leafbrushes", e );
        return false;
    }
    return true;
}

bool BSPFile::parse_polygons( void )
{
    try {
        m_Polygons = std::vector< Polygon >( m_Surfaces.size() );
        for( auto& surface : m_Surfaces ) {
            auto first_edge = surface.m_Firstedge;
            auto num_edges = surface.m_Numedges;

            if( num_edges < 3 || static_cast< size_t >( num_edges ) > MAX_SURFINFO_VERTS ) {
                continue;
            }
            if( surface.m_Texinfo <= 0 ) {
                continue;
            }

            Polygon polygon;
            Vector3 edge;
            for( auto i = 0; i < num_edges; ++i ) {
                auto edge_index = m_Surfedges.at( first_edge + i );
                if( edge_index >= 0 ) {
                    edge = m_Vertexes.at( m_Edges[ edge_index ].m_V.at( 0 ) ).m_Position;
                }
                else {
                    edge = m_Vertexes.at( m_Edges[ -edge_index ].m_V.at( 1 ) ).m_Position;
                }
                polygon.m_Verts.at( i ) = edge;
            }

            polygon.m_nVerts = static_cast< size_t >( num_edges );
            polygon.m_Plane.m_Origin = m_Planes.at( surface.m_Planenum ).m_Normal;
            polygon.m_Plane.m_Distance = m_Planes.at( surface.m_Planenum ).m_Distance;
            m_Polygons.push_back( polygon );
        }
    }
    catch( const std::exception& e ) {
        print_exception( "parse_polygons", e );
        return false;
    }
    return true;
}

void BSPFile::print_exception( const std::string& function_name, const std::exception& e ) const
{
    std::cout << "BSPFile::"
        << ( function_name.empty() ? "print_exception" : function_name ).c_str()
        << "() exception("
        << e.what()
        << ") while parsing map: "
        << m_FileName
        << std::endl;
}

```

`GarhalController/BSPFile.hpp`:

```hpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once
#pragma warning(disable : 26495)
#include "BSPStructure.hpp"
#include <fstream>
#include <vector>

namespace hazedumper {

    class BSPFile
    {
    public:
        BSPFile( void ) = default;

        /**
         * @brief      Optional constructor, parses the map.
         *
         * @param[in]  bsp_directory  The bsp directory
         * @param[in]  bsp_file       The bsp file
         */
        BSPFile( const std::string& bsp_directory, const std::string& bsp_file );

        /**
         * @brief      Parse a bsp file.
         *
         * @param[in]  bsp_directory  The bsp directory, last character must be '\'
         * @param[in]  bsp_file       The bsp file + extension(.bsp)
         *
         * @return     True if the BSP version and the ident is valid plus if all
         *             lumps got parsed, False otherwise or when an exception got
         *             throwed.
         */
        bool parse( const std::string& bsp_directory, const std::string& bsp_file );

        friend std::ostream& operator <<( std::ostream& os, const BSPFile& bsp_file )
        {
            os << "/// map: "       << bsp_file.m_FileName            << "\n"
               << "> BSP-Version: " << bsp_file.m_BSPHeader.m_Version << "\n"
               << "> Vertexes: "    << bsp_file.m_Vertexes.size()     << "\n"
               << "> Planes: "      << bsp_file.m_Edges.size()        << "\n"
               << "> Surfedges: "   << bsp_file.m_Surfedges.size()    << "\n"
               << "> Leaves: "      << bsp_file.m_Leaves.size()       << "\n"
               << "> Nodes: "       << bsp_file.m_Nodes.size()        << "\n"
               << "> Surfaces: "    << bsp_file.m_Surfaces.size()     << "\n"
               << "> Texinfos: "    << bsp_file.m_Texinfos.size()     << "\n"
               << "> Brushes: "     << bsp_file.m_Brushes.size()      << "\n"
               << "> Brushsides: "  << bsp_file.m_Brushsides.size()   << "\n"
               << "> Leaffaces: "   << bsp_file.m_Leaffaces.size()    << "\n"
               << "> Leafbrushes: " << bsp_file.m_Leafbrushes.size()  << "\n"
               << "> Polygons: "    << bsp_file.m_Polygons.size();

            return os;
        }

    private:
        /**
         * @brief      Parse map planes.
         *
         * @param      bsp_binary  The bsp binary
         *
         * @return     False if an exception got throwed, True otherwise.
         */
        bool parse_planes( std::ifstream& bsp_binary );

        /**
         * @brief      Parse map nodes.
         *
         * @param      bsp_binary  The bsp binary
         *
         * @return     False if an exception got throwed, True otherwise.
         */
        bool parse_nodes( std::ifstream& bsp_binary );

        /**
         * @brief      Parse map leaffaces.
         *
         * @param      bsp_binary  The bsp binary
         *
         * @return     False if an exception got throwed, True otherwise.
         */
        bool parse_leaffaces( std::ifstream& bsp_binary );

        /**
         * @brief      Parse map leafbrushes.
         *
         * @param      bsp_binary  The bsp binary
         *
         * @return     False if an exception got throwed, True otherwise.
         */
        bool parse_leafbrushes( std::ifstream& bsp_binary );

        /**
         * @brief      Parse map polygons.
         *
         * @return     False if an exception got throwed, True otherwise.
         */
        bool parse_polygons( void );

        /**
         * @brief      Print function specific exception.
         *
         * @param[in]  function_name  The function name
         * @param[in]  e              The exception
         */
        void print_exception( const std::string& function_name, const  std::exception& e ) const;

        /**
         * @brief      Parse specific lump data from bsp binary.
         *
         * @param      bsp_binary  The bsp binary
         * @param[in]  lump_index  The lump index
         * @param      buffer      The buffer
         *
         * @tparam     T           The lump struct declaration
         */
        template< typename T >
        void parse_lump_data( std::ifstream& bsp_binary, const BSP::eLumpIndex lump_index, std::vector< T >& buffer ) const;

    public:
        std::string                      m_FileName;
        BSP::dheader_t                   m_BSPHeader;
        std::vector< BSP::mvertex_t >    m_Vertexes;
        std::vector< BSP::cplane_t >     m_Planes;
        std::vector< BSP::dedge_t >      m_Edges;
        std::vector< int32_t >           m_Surfedges;
        std::vector< BSP::dleaf_t >      m_Leaves;
        std::vector< BSP::snode_t >      m_Nodes;
        std::vector< BSP::dface_t >      m_Surfaces;
        std::vector< BSP::texinfo_t >    m_Texinfos;
        std::vector< BSP::dbrush_t >     m_Brushes;
        std::vector< BSP::dbrushside_t > m_Brushsides;
        std::vector< uint16_t >          m_Leaffaces;
        std::vector< uint16_t >          m_Leafbrushes;
        std::vector< BSP::Polygon >      m_Polygons;
    };

    template< typename T >
    void BSPFile::parse_lump_data( std::ifstream& bsp_binary, const BSP::eLumpIndex lump_index, std::vector< T >& buffer ) const
    {
        auto& lump = m_BSPHeader.m_Lumps.at( static_cast< size_t >( lump_index ) );
        const auto lump_size = lump.m_Filelen / sizeof T;
        if( !lump_size ) {
            return;
        }

        buffer = std::vector< T >( lump_size );

        bsp_binary.seekg( lump.m_Fileofs );
        bsp_binary.read( reinterpret_cast< char* >( buffer.data() ), lump_size * sizeof T );
    }
}

```

`GarhalController/BSPFlags.hpp`:

```hpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once
#include <stdint.h>

namespace hazedumper { namespace BSP {
#define IDBSPHEADER	( ( 'P' << 24 ) + ( 'S' << 16 ) + ( 'B' << 8 ) + 'V' )

    static constexpr int32_t MAX_BRUSH_LIGHTMAP_DIM_WITHOUT_BORDER   = 32;
    static constexpr int32_t MAX_BRUSH_LIGHTMAP_DIM_INCLUDING_BORDER = 35;
    static constexpr int32_t MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER    = 128;
    static constexpr int32_t MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER  = 131;
    static constexpr int32_t MAX_LIGHTMAP_DIM_WITHOUT_BORDER         = MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER;
    static constexpr int32_t MAX_LIGHTMAP_DIM_INCLUDING_BORDER       = MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER;

    static constexpr float   DIST_EPSILON              = 0.03125f;
    static constexpr size_t  MAX_SURFINFO_VERTS        = 32;
    static constexpr int32_t BSPVERSION                = 19;
    static constexpr size_t  HEADER_LUMPS              = 64;
    static constexpr size_t  MAX_POLYGONS              = 50120;
    static constexpr size_t  MAX_MOD_KNOWN             = 512;
    static constexpr size_t  MAX_MAP_MODELS            = 1024;
    static constexpr size_t  MAX_MAP_BRUSHES           = 8192;
    static constexpr size_t  MAX_MAP_ENTITIES          = 4096;
    static constexpr size_t  MAX_MAP_ENTSTRING         = 256 * 1024;
    static constexpr size_t  MAX_MAP_NODES             = 65536;
    static constexpr size_t  MAX_MAP_TEXINFO           = 12288;
    static constexpr size_t  MAX_MAP_TEXDATA           = 2048;
    static constexpr size_t  MAX_MAP_LEAFBRUSHES       = 65536;
    static constexpr size_t  MIN_MAP_DISP_POWER        = 2;
    static constexpr size_t  MAX_MAP_DISP_POWER        = 4;
    static constexpr size_t  MAX_MAP_SURFEDGES         = 512000;
    static constexpr size_t  MAX_DISP_CORNER_NEIGHBORS = 4;

    /// NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
    static constexpr int32_t SURF_LIGHT     = 0x0001; /// value will hold the light strength
    static constexpr int32_t SURF_SLICK     = 0x0002; /// effects game physics
    static constexpr int32_t SURF_SKY       = 0x0004; /// don't draw, but add to skybox
    static constexpr int32_t SURF_WARP      = 0x0008; /// turbulent water warp
    static constexpr int32_t SURF_TRANS     = 0x0010;
    static constexpr int32_t SURF_WET       = 0x0020; /// the surface is wet
    static constexpr int32_t SURF_FLOWING   = 0x0040; /// scroll towards angle
    static constexpr int32_t SURF_NODRAW    = 0x0080; /// don't bother referencing the texture
    static constexpr int32_t SURF_Hint32_t  = 0x0100; /// make a primary bsp splitter
    static constexpr int32_t SURF_SKIP      = 0x0200; /// completely ignore, allowing non-closed brushes
    static constexpr int32_t SURF_NOLIGHT   = 0x0400; /// Don't calculate light
    static constexpr int32_t SURF_BUMPLIGHT = 0x0800; /// calculate three lightmaps for the surface for bumpmapping
    static constexpr int32_t SURF_HITBOX    = 0x8000; /// surface is part of a hitbox

    static constexpr int32_t CONTENTS_EMPTY         = 0;           /// No contents
    static constexpr int32_t CONTENTS_SOLID         = 0x1;         /// an eye is never valid in a solid
    static constexpr int32_t CONTENTS_WINDOW        = 0x2;         /// translucent, but not watery (glass)
    static constexpr int32_t CONTENTS_AUX           = 0x4;
    static constexpr int32_t CONTENTS_GRATE         = 0x8;         /// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
    static constexpr int32_t CONTENTS_SLIME         = 0x10;
    static constexpr int32_t CONTENTS_WATER         = 0x20;
    static constexpr int32_t CONTENTS_MIST          = 0x40;
    static constexpr int32_t CONTENTS_OPAQUE        = 0x80;        /// things that cannot be seen through (may be non-solid though)
    static constexpr int32_t LAST_VISIBLE_CONTENTS  = 0x80;
    static constexpr int32_t ALL_VISIBLE_CONTENTS   = LAST_VISIBLE_CONTENTS | LAST_VISIBLE_CONTENTS - 1;
    static constexpr int32_t CONTENTS_TESTFOGVOLUME = 0x100;
    static constexpr int32_t CONTENTS_UNUSED3       = 0x200;
    static constexpr int32_t CONTENTS_UNUSED4       = 0x400;
    static constexpr int32_t CONTENTS_UNUSED5       = 0x800;
    static constexpr int32_t CONTENTS_UNUSED6       = 0x1000;
    static constexpr int32_t CONTENTS_UNUSED7       = 0x2000;
    static constexpr int32_t CONTENTS_MOVEABLE      = 0x4000;      /// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
    /// remaining contents are non-visible, and don't eat brushes
    static constexpr int32_t CONTENTS_AREAPORTAL    = 0x8000;
    static constexpr int32_t CONTENTS_PLAYERCLIP    = 0x10000;
    static constexpr int32_t CONTENTS_MONSTERCLIP   = 0x20000;
    /// currents can be added to any other contents, and may be mixed
    static constexpr int32_t CONTENTS_CURRENT_0     = 0x40000;
    static constexpr int32_t CONTENTS_CURRENT_90    = 0x80000;
    static constexpr int32_t CONTENTS_CURRENT_180   = 0x100000;
    static constexpr int32_t CONTENTS_CURRENT_270   = 0x200000;
    static constexpr int32_t CONTENTS_CURRENT_UP    = 0x400000;
    static constexpr int32_t CONTENTS_CURRENT_DOWN  = 0x800000;
    static constexpr int32_t CONTENTS_ORIGIN        = 0x1000000;   /// removed before bsping an entity
    static constexpr int32_t CONTENTS_MONSTER       = 0x2000000;   /// should never be on a brush, only in game
    static constexpr int32_t CONTENTS_DEBRIS        = 0x4000000;
    static constexpr int32_t CONTENTS_DETAIL        = 0x8000000;   /// brushes to be added after vis leafs
    static constexpr int32_t CONTENTS_TRANSLUCENT   = 0x10000000;  /// int32_t set if any surface has trans
    static constexpr int32_t CONTENTS_LADDER        = 0x20000000;
    static constexpr int32_t CONTENTS_HITBOX        = 0x40000000;  /// use accurate hitboxes on trace

                                                            /// everyhting
    static constexpr int32_t MASK_ALL                   = 0xFFFFFFFF;
    /// everything that is normally solid
    static constexpr int32_t MASK_SOLID                 = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    /// everything that blocks player movement
    static constexpr int32_t MASK_PLAYERSOLID           = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    /// blocks npc movement
    static constexpr int32_t MASK_NPCSOLID              = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    /// water physics in these contents
    static constexpr int32_t MASK_WATER                 = CONTENTS_WATER | CONTENTS_MOVEABLE | CONTENTS_SLIME;
    /// everything that blocks line of sight
    static constexpr int32_t MASK_OPAQUE                = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_SLIME | CONTENTS_OPAQUE;
    /// bullets see these as solid
    static constexpr int32_t MASK_SHOT                  = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_HITBOX;
    /// non-raycasted weapons see this as solid (includes grates)
    static constexpr int32_t MASK_SHOT_HULL             = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_GRATE;
    /// everything normally solid, except monsters (world+brush only)
    static constexpr int32_t MASK_SOLID_BRUSHONLY       = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_GRATE;
    /// everything normally solid for player movement, except monsters (world+brush only)
    static constexpr int32_t MASK_PLAYERSOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_PLAYERCLIP | CONTENTS_GRATE;
    /// everything normally solid for npc movement, except monsters (world+brush only)
    static constexpr int32_t MASK_NPCSOLID_BRUSHONLY    = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
    /// just the world, used for route rebuilding
    static constexpr int32_t MASK_NPCWORLDSTATIC        = CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
    /// UNDONE: This is untested, any moving water
    static constexpr int32_t MASK_CURRENT               = CONTENTS_CURRENT_0 | CONTENTS_CURRENT_90 | CONTENTS_CURRENT_180 | CONTENTS_CURRENT_270 | CONTENTS_CURRENT_UP | CONTENTS_CURRENT_DOWN;
    static constexpr int32_t MASK_DEADSOLID             = CONTENTS_SOLID | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_GRATE;
} }

```

`GarhalController/BSPParser.cpp`:

```cpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#include "BSPParser.hpp"
#include "TraceRay.hpp"
using namespace hazedumper;

bool BSPParser::parse_map( const std::string& bsp_directory, const std::string& bsp_file )
{
    if( bsp_directory.empty() || bsp_file.empty() ) {
        return false;
    }
    if( m_LastMap == bsp_file ) {
        return true;
    }

    std::unique_lock< std::shared_timed_mutex > lock( m_mutex );
    if( m_BSPFile.parse( bsp_directory, bsp_file ) ) {
        m_LastMap = bsp_file;
        return true;
    }
    return false;
}

bool BSPParser::is_visible( const Vector3& origin, const Vector3& final )
{
    std::shared_lock< std::shared_timed_mutex > lock( m_mutex );
    return TraceRay::is_visible( origin, final, &m_BSPFile );
}

BSPFile BSPParser::get_bsp( void ) const
{
    return m_BSPFile;
}

```

`GarhalController/BSPParser.hpp`:

```hpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once
#include "BSPFile.hpp"
#include <shared_mutex>

namespace hazedumper {

    class BSPParser
    {
    public:
        BSPParser( void ) = default;

        /**
         * @brief      Parse a bsp file.
         *
         * @param[in]  bsp_directory  The bsp directory
         * @param[in]  bsp_file       The bsp file
         *
         * @return     True if the bsp file got parsed or is currently cached,
         *             False if BSPFile::parse() fails.
         */
        bool parse_map( const std::string& bsp_directory, const std::string& bsp_file );

        /**
         * @brief      Determines if visible.
         *
         * @param[in]  origin     The origin
         * @param[in]  final      The final position
         *
         * @return     True if visible, False otherwise.
         */
        bool is_visible( const Vector3& origin, const Vector3& final );

        /**
         * @brief      Gets the bsp file.
         *
         * @return     The bsp file.
         */
        BSPFile get_bsp( void ) const;

    private:
        BSPFile                 m_BSPFile;
        std::string             m_LastMap;
        std::shared_timed_mutex m_mutex;
    };
}

```

`GarhalController/BSPStructure.hpp`:

```hpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once
#include "BSPFlags.hpp"
#include "Matrix.hpp"

namespace hazedumper {
    using std::array;
    using Vector3 = Matrix< float, 3, 1 >;
}

namespace hazedumper { namespace BSP {

    enum eLumpIndex : size_t
    {
        LUMP_ENTITIES                       = 0,
        LUMP_PLANES                         = 1,
        LUMP_TEXDATA                        = 2,
        LUMP_VERTEXES                       = 3,
        LUMP_VISIBILITY                     = 4,
        LUMP_NODES                          = 5,
        LUMP_TEXINFO                        = 6,
        LUMP_FACES                          = 7,
        LUMP_LIGHTING                       = 8,
        LUMP_OCCLUSION                      = 9,
        LUMP_LEAFS                          = 10,
        LUMP_EDGES                          = 12,
        LUMP_SURFEDGES                      = 13,
        LUMP_MODELS                         = 14,
        LUMP_WORLDLIGHTS                    = 15,
        LUMP_LEAFFACES                      = 16,
        LUMP_LEAFBRUSHES                    = 17,
        LUMP_BRUSHES                        = 18,
        LUMP_BRUSHSIDES                     = 19,
        LUMP_AREAS                          = 20,
        LUMP_AREAPORTALS                    = 21,
        LUMP_PORTALS                        = 22,
        LUMP_CLUSTERS                       = 23,
        LUMP_PORTALVERTS                    = 24,
        LUMP_CLUSTERPORTALS                 = 25,
        LUMP_DISPINFO                       = 26,
        LUMP_ORIGINALFACES                  = 27,
        LUMP_PHYSCOLLIDE                    = 29,
        LUMP_VERTNORMALS                    = 30,
        LUMP_VERTNORMALINDICES              = 31,
        LUMP_DISP_LIGHTMAP_ALPHAS           = 32,
        LUMP_DISP_VERTS                     = 33,
        LUMP_DISP_LIGHTMAP_SAMPLE_POSITIONS = 34,
        LUMP_GAME_LUMP                      = 35,
        LUMP_LEAFWATERDATA                  = 36,
        LUMP_PRIMITIVES                     = 37,
        LUMP_PRIMVERTS                      = 38,
        LUMP_PRIMINDICES                    = 39,
        LUMP_PAKFILE                        = 40,
        LUMP_CLIPPORTALVERTS                = 41,
        LUMP_CUBEMAPS                       = 42,
        LUMP_TEXDATA_STRING_DATA            = 43,
        LUMP_TEXDATA_STRING_TABLE           = 44,
        LUMP_OVERLAYS                       = 45,
        LUMP_LEAFMINDISTTOWATER             = 46,
        LUMP_FACE_MACRO_TEXTURE_INFO        = 47,
        LUMP_DISP_TRIS                      = 48
    };

    class lump_t
    {
    public:
        int32_t          m_Fileofs; /// 0x0
        int32_t          m_Filelen; /// 0x4
        int32_t          m_Version; /// 0x8
        array< char, 4 > m_FourCC;  /// 0xC
    };///Size=0x10

    class dheader_t
    {
    public:
        int32_t                       m_Ident;       /// 0x000
        int32_t                       m_Version;     /// 0x004
        array< lump_t, HEADER_LUMPS > m_Lumps;       /// 0x008
        int32_t                       m_MapRevision; /// 0x408
    };///Size=0x40C

    class dplane_t
    {
    public:
        Vector3 m_Normal;   /// 0x00
        float   m_Distance; /// 0x0C
        int32_t m_Type;     /// 0x10
    };///Size=0x14

    class cplane_t
    {
    public:
        Vector3 m_Normal;     /// 0x00
        float   m_Distance;   /// 0x0C
        uint8_t m_Type;       /// 0x10
        uint8_t m_SignBits;   /// 0x11
    private:
        uint8_t m_Pad[ 0x2 ]; /// 0x12
    };///Size=0x14

    class dedge_t
    {
    public:
        array< uint16_t, 2 > m_V; /// 0x0
    };///Size=0x4

    class mvertex_t
    {
    public:
        Vector3 m_Position; /// 0x0
    };///Size=0xC

    class dleaf_t
    {
    public:
        int32_t             m_Contents;        /// 0x00
        int16_t             m_Cluster;         /// 0x04
        int16_t             m_Area : 9;        /// 0x06
        int16_t             m_Flags : 7;       /// 0x11
        array< int16_t, 3 > m_Mins;            /// 0x1A
        array< int16_t, 3 > m_Maxs;            /// 0x20
        uint16_t            m_Firstleafface;   /// 0x26
        uint16_t            m_Numleaffaces;    /// 0x28
        uint16_t            m_Firstleafbrush;  /// 0x2A
        uint16_t            m_Numleafbrushes;  /// 0x2C
        int16_t             m_LeafWaterDataID; /// 0x2E
    };///Size=0x30

    class dnode_t
    {
    public:
        int32_t             m_Planenum;   /// 0x00
        array< int32_t, 2 >	m_Children;   /// 0x04
        array< int16_t, 3 > m_Mins;       /// 0x0C
        array< int16_t, 3 > m_Maxs;       /// 0x12
        uint16_t            m_Firstface;  /// 0x18
        uint16_t            m_Numfaces;   /// 0x1A
        int16_t             m_Area;       /// 0x1C
    private:
        uint8_t             m_Pad[ 0x2 ]; /// 0x1E
    };///Size=0x20

    class snode_t
    {
    public:
        int32_t             m_PlaneNum;     /// 0x00
        cplane_t*           m_pPlane;       /// 0x04
        array< int32_t, 2 > m_Children;     /// 0x08
        dleaf_t*            m_LeafChildren; /// 0x10
        snode_t*            m_NodeChildren; /// 0x14
        array< int16_t, 3 > m_Mins;         /// 0x18
        array< int16_t, 3 > m_Maxs;         /// 0x1E
        uint16_t            m_Firstface;    /// 0x24
        uint16_t            m_Numfaces;     /// 0x26
        int16_t             m_Area;         /// 0x28
        uint8_t             m_Pad[ 0x2 ];   /// 0x2A
    };///Size=0x2C

    class dface_t
    {
    public:
        uint16_t            m_Planenum;                    /// 0x00
        uint8_t             m_Side;                        /// 0x02
        uint8_t             m_OnNode;                      /// 0x03
        int32_t             m_Firstedge;                   /// 0x04
        int16_t             m_Numedges;                    /// 0x08
        int16_t             m_Texinfo;                     /// 0x0A
        int16_t             m_Dispinfo;                    /// 0x0C
        int16_t             m_SurfaceFogVolumeID;          /// 0x0E
        array< uint8_t, 4 > m_Styles;                      /// 0x10
        int32_t             m_Lightofs;                    /// 0x18
        float               m_Area;                        /// 0x1C
        array< int32_t, 2 > m_LightmapTextureMinsInLuxels; /// 0x20
        array< int32_t, 2 > m_LightmapTextureSizeInLuxels; /// 0x28
        int32_t             m_OrigFace;                    /// 0x30
        uint16_t            m_NumPrims;                    /// 0x34
        uint16_t            m_FirstPrimID;                 /// 0x36
        uint16_t            m_SmoothingGroups;             /// 0x38
    };///Size=0x3A

    class dbrush_t
    {
    public:
        int32_t m_Firstside; /// 0x0
        int32_t m_Numsides;  /// 0x4
        int32_t m_Contents;  /// 0x8
    };///Size=0xC

    class dbrushside_t
    {
    public:
        uint16_t m_Planenum; /// 0x0
        int16_t  m_Texinfo;  /// 0x2
        int16_t  m_Dispinfo; /// 0x4
        uint8_t  m_Bevel;    /// 0x6
        uint8_t  m_Thin;     /// 0x7
    };///Size=0x8

    class texinfo_t
    {
    public:
        array< array< float, 4 >, 2 > m_TextureVecs;  /// 0x00
        array< array< float, 4 >, 2 > m_LightmapVecs; /// 0x20
        int32_t                       m_Flags;        /// 0x40
        int32_t                       m_Texdata;      /// 0x44
    };///Size=0x48

    class VPlane
    {
    public:
        Vector3 m_Origin = 0.f;
        float   m_Distance = 0.f;

    public:
        VPlane( void ) = default;
        VPlane( const Vector3& origin, const float distance ) :
            m_Origin( origin ),
            m_Distance( distance )
        {
        }

        VPlane( const VPlane& other )
        {
            *this = other;
        }

        VPlane( VPlane&& other ) noexcept
        {
            *this = other;
        }

        VPlane& operator = ( const VPlane& other )
        {
            init( other.m_Origin, other.m_Distance );
            return *this;
        }

        VPlane& operator = ( VPlane&& other ) noexcept
        {
            init( other.m_Origin, other.m_Distance );
            return *this;
        }

        float dist_to( const Vector3& location ) const
        {
            return m_Origin.dot( location ) - m_Distance;
        }

        void init( const Vector3& origin, const float distance )
        {
            m_Origin   = origin;
            m_Distance = distance;
        }
    };

    class Polygon
    {
    public:
        array< Vector3, MAX_SURFINFO_VERTS > m_Verts;
        size_t                               m_nVerts;
        VPlane                               m_Plane;
        array< VPlane, MAX_SURFINFO_VERTS >  m_EdgePlanes;
        array< Vector3, MAX_SURFINFO_VERTS > m_Vec2D;
        int32_t                              m_Skip;
    };
} }

```

`GarhalController/CInput.h`:

```h
#pragma once
#include <minwindef.h>

class CInput {
private:
    BYTE __pad0x01[0xF1];
public:
    DWORD Commands;
    DWORD VerifiedCommands;
};

```

`GarhalController/CUserCmd.h`:

```h
#pragma once
#include <minwindef.h>
#include "data.hpp"

class CUserCmd {
public:
    DWORD Vft;
    DWORD CmdNumber;
    DWORD TickCount;
    Vector3 ViewAngles;
    Vector3 AimDirection;
    FLOAT Forwardmove;
    FLOAT Sidemove;
    FLOAT Upmove;
    DWORD Buttons;
    BYTE Impulse;

private:
    BYTE __pad0x01[0x03];

public:
    DWORD WeaponSelect;
    DWORD WeaponSubtype;
    DWORD RandomSeed;
    WORD MouseDx;
    WORD MouseDy;
    BOOLEAN HasBeenPredicted;

private:
    BYTE __pad0x02[0x1B];
};
class CVerifiedUserCmd {
public:
    CUserCmd Command;
    DWORD CRC;
};
```

`GarhalController/ClientMode.h`:

```h
#pragma once

#include <cstdint>

class ClientMode
{
	
};

```

`GarhalController/Engine.cpp`:

```cpp
#include "Engine.hpp"
#include "offsets.hpp"

// hazedumper namespace
using namespace hazedumper::netvars;
using namespace hazedumper::signatures;

bool Engine::worldToScreen(const Vector3& from, Vector3& to)
{
    WorldToScreenMatrix matrix = Driver.ReadVirtualMemory<WorldToScreenMatrix>(ProcessId, ClientAddress + dwViewMatrix, sizeof(WorldToScreenMatrix));

    float w = 0.0f;

    to(0) = matrix(0, 0) * from(0) + matrix(0, 1) * from(1) + matrix(0, 2) * from(2) + matrix(0, 3);
    to(1) = matrix(1, 0) * from(0) + matrix(1, 1) * from(1) + matrix(1, 2) * from(2) + matrix(1, 3);
    w = matrix(3, 0) * from(0) + matrix(3, 1) * from(1) + matrix(3, 2) * from(2) + matrix(3, 3);

    if (w < 0.01f)
        return false;

    float wInverse = 1.0f / w;
    to(0) *= wInverse;
    to(1) *= wInverse;

    float x = SCREEN_WIDTH / 2;
    float y = SCREEN_HEIGHT / 2;

    x += 0.5 * to(0) * SCREEN_WIDTH + 0.5;
    y -= 0.5 * to(1) * SCREEN_HEIGHT + 0.5;

    to(0) = x;
    to(1) = y;

    return true;
}

bool Engine::IsInGame()
{
    uint32_t ClientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + dwClientState, sizeof(uint32_t));
    uint32_t Second = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientState + dwClientState_State, sizeof(uint32_t));
    return GetGameState(Second) == InGame;
}

GameState Engine::GetGameState(uint8_t State)
{
	switch (State)
    {
		case 0: return Lobby;
        case 1: return Loading;
        case 2: return Connecting;
        case 5: return Connected;
        case 6: return InGame;
    }
    return UnknownG;
}

Vector3 Engine::getViewAngles()
{
    uint32_t ClientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + dwClientState, sizeof(uint32_t));
    return Driver.ReadVirtualMemory<Vector3>(ProcessId, ClientState + dwClientState_ViewAngles, sizeof(Vector3));
}

void Engine::setViewAngles(Vector3& viewAngles)
{
    uint32_t clientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + dwClientState, sizeof(uint32_t));
    Driver.WriteVirtualMemory<Vector3>(ProcessId, clientState + dwClientState_ViewAngles, viewAngles, sizeof(viewAngles));
}


Engine::Engine()
{
    
}


Engine::~Engine()
{
}
```

`GarhalController/Engine.hpp`:

```hpp
#pragma once
#include "data.hpp"

class Engine
{
public:
    bool worldToScreen(const Vector3& from, Vector3& to);
    bool IsInGame();
    GameState GetGameState(uint8_t State);
    Vector3 getViewAngles();
    void setViewAngles(Vector3& viewAngles);
    Engine();
    ~Engine();
};

```

`GarhalController/Entity.cpp`:

```cpp
#pragma warning (disable : 26451)

#include "Entity.hpp"

#include <iostream>
#include <time.h>
#include "offsets.hpp"
#include "sdk.hpp"

// hazedumper namespace
using namespace hazedumper::netvars;
using namespace hazedumper::signatures;


class BoneMatrix
{
public:
	byte pad3[12];
	float x;
	byte pad1[12];
	float y;
	byte pad2[12];
	float z;
};

bool Entity::IsDormant()
{
	bool isDormant = Driver.ReadVirtualMemory<bool>(ProcessId, EntityAddress + m_bDormant, sizeof(uint8_t));
    return isDormant;
}

bool Entity::IsDefusing()
{
    bool Defusing = Driver.ReadVirtualMemory<bool>(ProcessId, EntityAddress + m_bIsDefusing, sizeof(uint8_t));
    return Defusing;
}

void Entity::SetFlashAlpha(float num)
{
    // No Flash if set to 0
    Driver.WriteVirtualMemory(ProcessId, EntityAddress + m_flFlashMaxAlpha, num, 8);
}

uint8_t Entity::getTeam()
{
	uint8_t OurTeam = Driver.ReadVirtualMemory<uint8_t>(ProcessId, EntityAddress + m_iTeamNum, sizeof(uint8_t));
    return OurTeam;
}

bool Entity::isInAir()
{
	uint32_t flags = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EntityAddress + m_fFlags, sizeof(uint32_t));
	return flags == 256 || flags == 258 || flags == 260 || flags == 262;
}

bool Entity::IsCrouching()
{
	uint32_t flags = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EntityAddress + m_fFlags, sizeof(uint32_t));
	return flags & FL_DUCKING;
}

uint8_t Entity::getHealth()
{
	uint8_t health = Driver.ReadVirtualMemory<uint8_t>(ProcessId, EntityAddress + m_iHealth, sizeof(uint8_t));
	return health;
}


void Entity::SetForceJump(uint8_t value)
{
	Driver.WriteVirtualMemory(ProcessId, ClientAddress + dwForceJump, value, sizeof(value));
}

bool Entity::isValidPlayer()
{
	int health = getHealth();
	bool isDormant = IsDormant();

	return health > 0 && health <= 100 && !isDormant;
}

Vector3 Entity::getAbsolutePosition()
{
	Vector3 position = getFeetPosition();
	//position(2) += Driver.ReadVirtualMemory<float>(ProcessId, EntityAddress + 0x10c, sizeof(float));
	return position;
}

Vector3 Entity::getFeetPosition()
{
	Vector3 position = Driver.ReadVirtualMemory<Vector3>(ProcessId, EntityAddress + m_vecOrigin, sizeof(Vector3));
	return position;
}

Vector3 Entity::getAimPunch()
{
	Vector3 aimPunch = Driver.ReadVirtualMemory<Vector3>(ProcessId, EntityAddress + m_aimPunchAngle, sizeof(Vector3));
	return aimPunch;
}

Vector3 Entity::getVelocity()
{
	Vector3 vel = Driver.ReadVirtualMemory<Vector3>(ProcessId, EntityAddress + m_vecVelocity, sizeof(Vector3));
	return vel;
}

/*Vector3 Entity::getBonePosition(uint32_t boneId)
{
	int boneBase = Driver.ReadVirtualMemory<int>(ProcessId, EntityAddress + m_dwBoneMatrix, sizeof(int));

	Vector3 bonePosition;
	bonePosition(0) = Driver.ReadVirtualMemory<float>(ProcessId, boneBase + 0x30 * boneId + 0x0C, sizeof(float));
	bonePosition(1) = Driver.ReadVirtualMemory<float>(ProcessId, boneBase + 0x30 * boneId + 0x1C, sizeof(float));
	bonePosition(2) = Driver.ReadVirtualMemory<float>(ProcessId, boneBase + 0x30 * boneId + 0x2C, sizeof(float));

	return bonePosition;
}*/

Vector3 Entity::GetBonePosition(uint32_t targetBone)
{
	DWORD boneMatrixOffset = Driver.ReadVirtualMemory<DWORD>(ProcessId, EntityAddress + m_dwBoneMatrix, sizeof(DWORD));
	BoneMatrix baoneMatrix = Driver.ReadVirtualMemory<BoneMatrix>(ProcessId, boneMatrixOffset + sizeof(BoneMatrix) * targetBone, sizeof(BoneMatrix));
	return Vector3(baoneMatrix.x, baoneMatrix.y, baoneMatrix.z);
}

Vector3 Entity::getHeadPosition()
{
	Vector3 Origin = Driver.ReadVirtualMemory<Vector3>(ProcessId, EntityAddress + m_vecOrigin, sizeof(Vector3));
	Vector3 ViewOffset = Driver.ReadVirtualMemory<Vector3>(ProcessId, EntityAddress + m_vecViewOffset, sizeof(Vector3));
	Vector3 LocalEyeOrigin = Origin + ViewOffset;
	if (this->IsCrouching())
	{
		LocalEyeOrigin(1) = LocalEyeOrigin(1) - 1.5f;
	}

	return LocalEyeOrigin;
}

uint16_t Entity::getCrosshairId()
{
	return Driver.ReadVirtualMemory<uint16_t>(ProcessId, EntityAddress + m_iCrosshairId, sizeof(uint16_t));
}

uint8_t Entity::getForceAttack()
{
	return Driver.ReadVirtualMemory<uint8_t>(ProcessId, EntityAddress + dwForceAttack, sizeof(uint8_t));
}

void Entity::setForceAttack(uint8_t value)
{
	Driver.WriteVirtualMemory(ProcessId, EntityAddress + dwForceAttack, value, sizeof(value));
}

void Entity::setForceAttack2(uint8_t value)
{
	Driver.WriteVirtualMemory(ProcessId, EntityAddress + dwForceAttack2, value, sizeof(value));
}

void Entity::shoot()
{
	if (TriggerBot && TriggerBotDelay)
	{
		srand(time(NULL));
		uint16_t rnd = rand() % (TriggerBotDelayMax - TriggerBotDelayMin + 1) + TriggerBotDelayMin;
		Sleep(rnd);
	}
	
	mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
	Sleep(1);
	mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
	/*uint8_t forceAttack = getForceAttack();
	if (forceAttack == 4) 
	{
		setForceAttack(5);
	}
	else 
	{
		setForceAttack(4);
	}*/
}

uint16_t Entity::getShotsFired()
{
	return Driver.ReadVirtualMemory<uint16_t>(ProcessId, EntityAddress + m_iShotsFired, sizeof(uint16_t));
}

uint32_t Entity::GetEntityAddress()
{
	return EntityAddress;
}

uint32_t Entity::GetGlowIndex()
{
	uint32_t GlowIndex = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EntityAddress + m_iGlowIndex, sizeof(uint32_t));
    return GlowIndex;
}

DWORD Entity::GetWeaponHandle()
{
	return Driver.ReadVirtualMemory<DWORD>(ProcessId, EntityAddress + m_hActiveWeapon, sizeof(DWORD));
}

uint16_t Entity::GetWeaponIndex()
{
	return GetWeaponHandle() & 0xFFF;
}

DWORD Entity::GetCurrentWeapon()
{
	return Driver.ReadVirtualMemory<DWORD>(ProcessId, ClientAddress + dwEntityList + (GetWeaponIndex() - 1) * 0x10, sizeof(DWORD));
}

uint16_t Entity::GetCurrentWeaponID()
{
	return Driver.ReadVirtualMemory<uint16_t>(ProcessId, GetCurrentWeapon() + m_iItemDefinitionIndex, sizeof(uint16_t));
}

void Entity::SetCorrectGlowStruct(uint8_t OurTeam, uint32_t GlowObject)
{
	int ReadTeam = this->getTeam();
	bool Defusing = this->IsDefusing();
	
	GlowStruct EGlow;
	EGlow = Driver.ReadVirtualMemory<GlowStruct>(ProcessId, GlowObject + (this->GetGlowIndex() * 0x38) + 0x4, sizeof(GlowStruct));
	EGlow.alpha = 0.5f;
	EGlow.renderWhenOccluded = true;
	EGlow.renderWhenUnOccluded = false;

	if (OurTeam != ReadTeam)
	{
		EGlow.red = 255.0f;
		EGlow.green = 0.0f;
		EGlow.blue = 0.0f;

		if (Defusing)
		{
			EGlow.green = 60.0f;
		}
	}
	else
	{
		EGlow.red = 0.0f;
		EGlow.green = 0.0f;
		EGlow.blue = 255.0f;

		if (Defusing)
		{
			EGlow.green = 60.0f;
		}
	}

	Driver.WriteVirtualMemory(ProcessId, GlowObject + (this->GetGlowIndex() * 0x38) + 0x4, EGlow, sizeof(EGlow));
}


Entity::Entity(uint32_t EntityAddress)
{
    this->EntityAddress = EntityAddress;
}

Entity::Entity()
{
}

Entity::~Entity()
{

}
```

`GarhalController/Entity.hpp`:

```hpp
#pragma once
#include "data.hpp"

class Entity
{
private:
    uint32_t EntityAddress = 0;
public:
    //Vector3 getBonePosition(uint32_t boneId);
    Vector3 getAbsolutePosition();
    Vector3 getFeetPosition();
    Vector3 getAimPunch();
    Vector3 getVelocity();
    Vector3 getHeadPosition();
    Vector3 GetBonePosition(uint32_t targetBone);

    DWORD GetWeaponHandle();
    DWORD GetCurrentWeapon();
	
    uint32_t GetEntityAddress();
    uint32_t GetGlowIndex();
    uint16_t GetCurrentWeaponID();
    uint16_t GetWeaponIndex();
    uint16_t getCrosshairId();
    uint16_t getShotsFired();
    uint8_t getHealth();
    uint8_t getForceAttack();
    uint8_t getTeam();
    void SetFlashAlpha(float num);
    void SetForceJump(uint8_t value);
    void setForceAttack(uint8_t value);
    void setForceAttack2(uint8_t value);
    void shoot();
    void SetCorrectGlowStruct(uint8_t LocalPlayerTeam, uint32_t GlowObject);
	
    bool IsDormant();
    bool IsDefusing();
    bool isInAir();
    bool isValidPlayer();
    bool IsCrouching();
    Entity();
    Entity(uint32_t EntityAddress);
    ~Entity();
};

```

`GarhalController/GarhalController.cpp`:

```cpp
#pragma comment(lib,"ntdll.lib")
#pragma warning(disable : 26451) // Bug in VS according to Stackoverflow.

#include "kernelinterface.hpp"
#include "offsets.hpp"
#include "data.hpp"
#include <iostream>
#include <TlHelp32.h>
#include "Aimbot.hpp"
#include "AntiAim.hpp"
#include "BSPParser.hpp"
#include "ClientMode.h"
#include "config.hpp"
#include "Engine.hpp"
#include "Entity.hpp"
#include <windows.h>

using namespace std;

// hazedumper namespace
using namespace hazedumper::netvars;
using namespace hazedumper::signatures;

Entity CreateEntity(int Address)
{
	if (Address > 0)
	{
		Entity entity(Address);
		return entity;
	}
	
	Entity dummy(0);
	return dummy;
}

std::string GenerateStr(const int len)
{
	std::string str;
	static const char alphanum[] =
		"0123456789"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz";

	srand((unsigned)time(NULL) * _getpid());

	for (int i = 0; i < len; ++i) 
	{
		str += alphanum[rand() % (sizeof(alphanum) - 1)];
	}


	return str;
}

vector<string> Split(string s, string delimiter)
{
	size_t pos_start = 0, pos_end, delim_len = delimiter.length();
	string token;
	vector<string> res;

	while ((pos_end = s.find(delimiter, pos_start)) != string::npos) 
	{
		token = s.substr(pos_start, pos_end - pos_start);
		pos_start = pos_end + delim_len;
		res.push_back(token);
	}

	res.push_back(s.substr(pos_start));
	return res;
}


// TODO: Implement https://guidedhacking.com/threads/external-silent-aim-proof-of-concept-no-shellcode.13595/
// https://www.unknowncheats.me/forum/counterstrike-global-offensive/144597-matchmaking-colors.html

// TODO: On close free all global values from the memory.
inline Engine engine;
inline Aimbot aim = NULL;

void TriggerBotThread()
{
	while (TriggerBot)
	{
		if (!engine.IsInGame())
		{
			Sleep(500);
			continue;
		}

		if (!aim.localPlayer.isValidPlayer())
		{
			continue;
		}

		//uint32_t LocalPlayer = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwLocalPlayer, sizeof(uint32_t));
		Entity LocalPlayerEnt = aim.localPlayer;
			
		if (TriggerBotKey == 0 || (GetAsyncKeyState(TriggerBotKey) & KEY_DOWN))
		{
			bool usable = false;
			uint16_t weaponid = LocalPlayerEnt.GetCurrentWeaponID();
			for (uint16_t wep : WeaponIDs)
			{
				if (wep == 0 || (weaponid > 0 && wep == weaponid))
				{
					usable = true;
					break;
				}
			}

			if (usable)
			{
				aim.TriggerBot();
			}
		}

		Sleep(2);
	}
}

int main(int argc, char* argv[], char* envp[])
{
	Driver = KeInterface("\\\\.\\garhalop");
	std::string random = GenerateStr(20);
	std::wstring stemp = std::wstring(random.begin(), random.end());
	LPCWSTR sw = stemp.c_str();
	SetConsoleTitle(sw);
	
	// Get address of client.dll, engine.dll, and PID.
	ProcessId = Driver.GetTargetPid();
	ClientAddress = Driver.GetClientModule();
	EngineAddress = Driver.GetEngineModule();
	ClientSize = Driver.GetClientModuleSize();
	EngineSize = Driver.GetEngineModuleSize();

	bool PrintOnce = false;

	while (ProcessId == 0 || ClientAddress == 0 || EngineAddress == 0 || ClientSize == 0 || EngineSize == 0)
	{
		if (!PrintOnce) 
		{
			std::cout << "Addresses are 0x0. Waiting for CSGO... " << std::endl;
			PrintOnce = true;
		}
		
		Sleep(1000);
		ProcessId = Driver.GetTargetPid();
		ClientAddress = Driver.GetClientModule();
		EngineAddress = Driver.GetEngineModule();
		ClientSize = Driver.GetClientModuleSize();
		EngineSize = Driver.GetEngineModuleSize();
	}

	std::cout << "Addresses look good. Starting..." << std::endl;

	hazedumper::BSPParser bspParser;

	// Read config values.
	Config config("garhal.cfg", envp);
	AimbotS = config.pInt("AimbotS");
	AimbotKey = config.pHex("AimbotKey");
	AimbotTarget = config.pInt("AimbotTarget");
	AimbotBullets = config.pInt("AimbotBullets");
	Bhop = config.pBool("Bhop");
	Wallhack = config.pBool("Wallhack");
	NoFlash = config.pBool("NoFlash");
	TriggerBot = config.pBool("TriggerBot");
	TriggerBotKey = config.pHex("TriggerBotKey");
	TriggerBotDelay = config.pBool("TriggerBotDelay");
	Radar = config.pBool("Radar");

	std::string weapons = config.pString("TriggerBotAllowed");
	vector<string> dweapons = Split(weapons, ",");
	for (string w : dweapons)
	{
		char cstr[10];
		strcpy_s(cstr, w.c_str());
		WeaponIDs.push_back(atoi(cstr));
	}

	std::string delays = config.pString("TriggerBotDelayNum");
	vector<string> ddelays = Split(delays, ",");
	for (uint8_t rand = 0; rand < ddelays.size() ; rand++)
	{
		char cstr[10];
		strcpy_s(cstr, ddelays.at(rand).c_str());
		if (rand == 0)
		{
			TriggerBotDelayMin = atoi(cstr);
		}
		else
		{
			TriggerBotDelayMax = atoi(cstr);
		}
	}

	std::cout << "GarHal made by DreTaX" << std::endl;

	std::cout << "==== Memory Addresses ====" << std::endl;
	std::cout << "ProcessID: " << ProcessId << std::endl;
	std::cout << "ClientAddress: " << std::hex << ClientAddress << std::endl;
	std::cout << "EngineAddress: " << std::hex << EngineAddress << std::endl;
	std::cout << "ClientSize: " << std::hex << ClientSize << std::endl;

	// Store address of localplayer
	uint32_t LocalPlayer = 0;

	uint32_t GlowObject = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwGlowObjectManager, sizeof(uint32_t));

	std::cout << "GlowObject: " << GlowObject << std::endl;

	std::cout << "==== Config Values ====" << std::endl;
	std::cout << "AimbotS: " << unsigned(AimbotS) << std::endl;
	std::cout << "AimbotKey: " << unsigned(AimbotKey) << std::endl;
	std::cout << "AimbotTarget: " << unsigned(AimbotTarget) << std::endl;
	std::cout << "AimbotBullets: " << unsigned(AimbotBullets) << std::endl;
	std::cout << "Bhop: " << std::boolalpha << Bhop << std::endl;
	std::cout << "Wallhack: " << std::boolalpha << Wallhack << std::endl;
	std::cout << "NoFlash: " << std::boolalpha << NoFlash << std::endl;
	std::cout << "TriggerBot: " << std::boolalpha << TriggerBot << std::endl;
	std::cout << "TriggerBotKey: " << unsigned(TriggerBotKey) << std::endl;
	std::cout << "TriggerBotDelay: " << std::boolalpha << TriggerBotDelay << std::endl;
	std::cout << "Radar: " << std::boolalpha << Radar << std::endl;

	aim = Aimbot(&bspParser);

	std::thread TriggerBotT(TriggerBotThread);

	Driver.RequestProtection();

	while (true)
	{
		if (!engine.IsInGame())
		{
			Sleep(500);
			continue;
		}

		if (Wallhack)
		{
			GlowObject = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwGlowObjectManager, sizeof(uint32_t));
		}

		LocalPlayer = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwLocalPlayer, sizeof(uint32_t));
		Entity LocalPlayerEnt = Entity(LocalPlayer);

		if (aim.localPlayer.GetEntityAddress() != LocalPlayerEnt.GetEntityAddress())
		{
			aim.localPlayer = LocalPlayerEnt;
		}
		
		uint8_t OurTeam = LocalPlayerEnt.getTeam();
		if (NoFlash) 
		{
			LocalPlayerEnt.SetFlashAlpha(0.0f);
		}

		for (short int i = 0; i < 64; i++)
		{
			uint32_t EntityAddr = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwEntityList + i * 0x10, sizeof(uint32_t));

			if (EntityAddr == NULL)
			{
				continue;
			}
			
			if (Wallhack)
			{
				Entity ent = CreateEntity(EntityAddr);
				if (ent.isValidPlayer() && !ent.IsDormant())
				{
					ent.SetCorrectGlowStruct(OurTeam, GlowObject);
				}
			}
			
			if (Radar)
			{
				Entity ent = CreateEntity(EntityAddr);
				if (ent.isValidPlayer() && !ent.IsDormant()) 
				{
					Driver.WriteVirtualMemory<bool>(ProcessId, EntityAddr + m_bSpotted, true, sizeof(bool));
				}
			}
		}


		if (Bhop) 
		{
			if (GetAsyncKeyState(VK_SPACE) & KEY_DOWN)
			{
				if (LocalPlayerEnt.isValidPlayer())
				{
					if (!LocalPlayerEnt.isInAir())
					{
						LocalPlayerEnt.SetForceJump(6);
					}
				}
			}
		}

		if (AimbotS == 1) 
		{
			if (GetAsyncKeyState(AimbotKey) & KEY_DOWN)
			{
				aim.aimAssist();
			}
			else
			{
				aim.resetSensitivity();
			}
		}
		else if (AimbotS == 2)
		{
			if (GetAsyncKeyState(AimbotKey) & KEY_DOWN)
			{
				aim.aimBot();
			}
		}

		Sleep(3);
	}

	return 0;
}
```

`GarhalController/GarhalController.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{D6B514C9-9BC2-409C-82C6-594AECF81411}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>GarhalController</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Aimbot.cpp" />
    <ClCompile Include="BSPFile.cpp" />
    <ClCompile Include="BSPParser.cpp" />
    <ClCompile Include="config.cpp" />
    <ClCompile Include="Engine.cpp" />
    <ClCompile Include="Entity.cpp" />
    <ClCompile Include="GarhalController.cpp" />
    <ClCompile Include="TraceRay.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Aimbot.hpp" />
    <ClInclude Include="BSPFile.hpp" />
    <ClInclude Include="BSPFlags.hpp" />
    <ClInclude Include="BSPParser.hpp" />
    <ClInclude Include="BSPStructure.hpp" />
    <ClInclude Include="CInput.h" />
    <ClInclude Include="ClientMode.h" />
    <ClInclude Include="communications.hpp" />
    <ClInclude Include="config.hpp" />
    <ClInclude Include="data.hpp" />
    <ClInclude Include="Engine.hpp" />
    <ClInclude Include="Entity.hpp" />
    <ClInclude Include="kernelinterface.hpp" />
    <ClInclude Include="Matrix.hpp" />
    <ClInclude Include="offsets.hpp" />
    <ClInclude Include="sdk.hpp" />
    <ClInclude Include="TraceRay.hpp" />
    <ClInclude Include="CUserCmd.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="garhal.cfg" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GarhalController/GarhalController.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="BSP">
      <UniqueIdentifier>{f752107a-2764-49b0-93eb-bfb5ca68dc23}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="GarhalController.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Engine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Aimbot.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BSPFile.cpp">
      <Filter>BSP</Filter>
    </ClCompile>
    <ClCompile Include="BSPParser.cpp">
      <Filter>BSP</Filter>
    </ClCompile>
    <ClCompile Include="TraceRay.cpp">
      <Filter>BSP</Filter>
    </ClCompile>
    <ClCompile Include="config.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="offsets.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernelinterface.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="communications.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="data.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Matrix.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Entity.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Engine.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Aimbot.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BSPFile.hpp">
      <Filter>BSP</Filter>
    </ClInclude>
    <ClInclude Include="BSPFlags.hpp">
      <Filter>BSP</Filter>
    </ClInclude>
    <ClInclude Include="BSPParser.hpp">
      <Filter>BSP</Filter>
    </ClInclude>
    <ClInclude Include="BSPStructure.hpp">
      <Filter>BSP</Filter>
    </ClInclude>
    <ClInclude Include="TraceRay.hpp">
      <Filter>BSP</Filter>
    </ClInclude>
    <ClInclude Include="config.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sdk.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ClientMode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CInput.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CUserCmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="garhal.cfg">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`GarhalController/Matrix.hpp`:

```hpp
/**
 * @author     frk, ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/frk1
 *             https://thefrk.pw
 *             https://www.unknowncheats.me/forum/members/1067779.html
 *
 *             https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once

#include <array>
#include <string>
#include <ostream>
#include <algorithm>

template < typename T, size_t T_Rows, size_t T_Cols >
class Matrix
{
public:
    using array_t = std::array< T, T_Rows* T_Cols >;
    using matrix_t = Matrix< T, T_Rows, T_Cols >;
    using col_matrix_t = Matrix< T, 1, T_Cols >;
    using row_matrix_t = Matrix< T, T_Rows, 1 >;

private:
    array_t m_cValues;

public:
    Matrix(void)
    {
        static_assert(std::is_arithmetic< T >::value, "Type T has to be arithmetic!");
        static_assert(T_Rows >= 1 && T_Cols >= 1, "Minimal row and col dimensions are 1.");
        m_cValues.fill(static_cast<T>(0));
    }

    ~Matrix(void)
    {
    }

    explicit Matrix(std::array< T, (T_Rows* T_Cols) > cValues)
        : m_cValues(cValues)
    {
        static_assert(std::is_arithmetic< T >::value, "Type T has to be arithmetic!");
    }

    template < typename... K >
    Matrix(K ... args)
    {
        static_assert(std::is_arithmetic< T >::value, "Type T has to be arithmetic!");
        m_cValues = std::array< T, T_Rows* T_Cols > { static_cast<T>(args)... };
    }

    constexpr static size_t rows(void)
    {
        return T_Rows;
    }

    constexpr static size_t cols(void)
    {
        return T_Cols;
    }

    constexpr static size_t size(void)
    {
        return T_Rows * T_Cols;
    }

    constexpr static bool isVector(void)
    {
        return T_Rows == 1 || T_Cols == 1;
    }

    bool empty(void) const
    {
        return all_of(m_cValues.begin(), m_cValues.end(), [](T i)
            {
                return i == static_cast<T>(0);
            });
    }

    col_matrix_t row(size_t iRow) const
    {
        std::array< T, T_Cols > values;

        for (size_t i = 0; i < T_Cols; ++i)
            values.at(i) = at(iRow, i);

        return col_matrix_t{ values };
    }

    row_matrix_t col(size_t iCol) const
    {
        std::array< T, T_Rows > values;

        for (size_t i = 0; i < T_Rows; ++i)
            values.at(i) = at(i, iCol);

        return row_matrix_t{ values };
    }

    void row(size_t iRow, col_matrix_t mat)
    {
        for (size_t i = 0; i < T_Cols; ++i)
            at(iRow, i) = mat(i);
    }

    void col(size_t iCol, row_matrix_t mat)
    {
        for (size_t i = 0; i < T_Rows; ++i)
            at(i, iCol) = mat(i);
    }

    T& at(size_t i)
    {
        return m_cValues.at(i);
    }

    const T& at(size_t i) const
    {
        return m_cValues.at(i);
    }

    T& at(size_t iRow, size_t iCol)
    {
        return m_cValues.at(iRow * T_Cols + iCol);
    }

    const T& at(size_t iRow, size_t iCol) const
    {
        return m_cValues.at(iRow * T_Cols + iCol);
    }

    T& operator () (size_t i)
    {
        return at(i);
    }

    const T& operator () (size_t i) const
    {
        return at(i);
    }

    T& operator () (size_t iRow, size_t iCol)
    {
        return at(iRow, iCol);
    }

    const T& operator () (size_t iRow, size_t iCol) const
    {
        return at(iRow, iCol);
    }

    matrix_t operator + (T other) const
    {
        auto buf = *this;
        buf += other;
        return buf;
    }

    matrix_t operator - (T other) const
    {
        auto buf = *this;
        buf -= other;
        return buf;
    }

    matrix_t operator * (T other) const
    {
        auto buf = *this;
        buf *= other;
        return buf;
    }

    matrix_t operator / (T other) const
    {
        auto buf = *this;
        buf /= other;
        return buf;
    }

    matrix_t& operator += (T other)
    {
        for (auto& val : m_cValues)
            val += other;

        return *this;
    }

    matrix_t& operator -= (T other)
    {
        for (auto& val : m_cValues)
            val -= other;

        return *this;
    }

    matrix_t& operator *= (T other)
    {
        for (auto& val : m_cValues)
            val *= other;

        return *this;
    }

    matrix_t& operator /= (T other)
    {
        for (auto& val : m_cValues)
            val /= other;

        return *this;
    }

    matrix_t operator + (const matrix_t& other) const
    {
        auto buf = *this;

        for (size_t i = 0; i < size(); ++i)
            buf(i) += other(i);

        return buf;
    }

    matrix_t operator - (const matrix_t& other) const
    {
        auto buf = *this;

        for (size_t i = 0; i < size(); ++i)
            buf(i) -= other(i);

        return buf;
    }

    matrix_t& operator += (const matrix_t& other)
    {
        for (size_t i = 0; i < size(); ++i)
            at(i) += other(i);

        return (*this);
    }

    bool operator == (const matrix_t& other) const
    {
        for (size_t i = 0; i < size(); ++i)
            if (at(i) != other.at(i))
                return false;

        return true;
    }

    bool operator != (const matrix_t& other) const
    {
        return !((*this) == other);
    }

    matrix_t& operator -= (const matrix_t& other)
    {
        for (size_t i = 0; i < size(); ++i)
            at(i) -= other(i);

        return (*this);
    }

    T norm(void) const
    {
        static_assert(matrix_t::isVector(), "Matrix::norm can only be used on vectors!");

        T buf = static_cast<T>(0);

        for (auto v : m_cValues)
            buf += (v * v);

        return sqrt(buf);
    }

    void normalize(void)
    {
        static_assert(matrix_t::isVector(), "Matrix::normalize can only be used on vectors!");
        (*this) /= this->norm();
    }

    matrix_t normalized(void) const
    {
        static_assert(matrix_t::isVector(), "Matrix::normalized can only be used on vectors!");

        auto buf = *this;
        buf.normalize();
        return buf;
    }

    friend std::ostream& operator <<(std::ostream& os, const matrix_t& v)
    {
        for (size_t i = 0; i < T_Rows; ++i)
        {
            for (size_t j = 0; j < T_Cols; j++)
                os << v.at(i, j) << "\t";

            os << "\n";
        }

        return os;
    }

    template < typename K, size_t OROWS, size_t OCOLS >
    T dot(const Matrix< K, OROWS, OCOLS >& other) const
    {
        static_assert(matrix_t::isVector() && Matrix< K, OROWS, OCOLS >::isVector(), "Matrix::dot can only be used on vectors!");

        T buf = static_cast<T>(0);

        for (size_t i = 0; i < (std::min)(size(), other.size()); ++i)
            buf += at(i) * other.at(i);

        return buf;
    }

    matrix_t cross(const matrix_t& other) const
    {
        static_assert(matrix_t::size() == 3, "Matrix::cross can only be called for 3 dimensional vectors!");

        return{
          at(1) * other.at(2) - at(2) * other.at(1),
          at(2) * other.at(0) - at(0) * other.at(2),
          at(0) * other.at(1) - at(1) * other.at(0),
        };
    }

    matrix_t ncross(const matrix_t& other) const
    {
        static_assert(matrix_t::size() == 3, "Matrix::ncross can only be called for 3 dimensional vectors!");

        return cross(other).normalized();
    }
};
```

`GarhalController/TraceRay.cpp`:

```cpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#include "TraceRay.hpp"
using namespace hazedumper;
using namespace BSP;

bool TraceRay::is_visible( const Vector3& origin, const Vector3& final, BSPFile* pBSPFile )
{
    if( !pBSPFile ) {
        return false;
    }

    trace_t trace;
    ray_cast( origin, final, pBSPFile, &trace );

    return !( trace.m_Fraction < 1.f ); // no collision!
}

void TraceRay::ray_cast( const Vector3& origin, const Vector3& final, BSPFile* pBSPFile, trace_t* pTrace )
{
    if( pBSPFile->m_Planes.empty() ) {
        return;
    }

    memset( pTrace, 0, sizeof trace_t );
    pTrace->m_Fraction          = 1.0f;
    pTrace->m_FractionLeftSolid = 0.f;
    ray_cast_node( pBSPFile, 0, 0.f, 1.f, origin, final, pTrace );

    if( pTrace->m_Fraction < 1.0f ) {
        for( size_t i = 0; i < 3; ++i ) {
            pTrace->m_EndPos( i ) = origin( i ) + pTrace->m_Fraction * ( final( i ) - origin( i ) );
        }
    }
    else {
        pTrace->m_EndPos = final;
    }
}

void TraceRay::ray_cast_node( BSPFile* pBSPFile, const int32_t node_index, const float start_fraction, const float end_fraction, const Vector3& origin, const Vector3& final, trace_t* pTrace )
{
    if( pTrace->m_Fraction <= start_fraction ) {
        return;
    }
    if( node_index < 0 ) {
        auto* pLeaf = &pBSPFile->m_Leaves.at( static_cast< size_t >( -node_index - 1 ) );
        for( auto i = 0; i < static_cast< int32_t >( pLeaf->m_Numleafbrushes ); ++i ) {

            auto iBrushIndex = static_cast< int32_t >( pBSPFile->m_Leafbrushes.at( pLeaf->m_Firstleafbrush + i ) );
            auto* pBrush = &pBSPFile->m_Brushes.at( iBrushIndex );
            if( !pBrush ) {
                continue;
            }
            if( !( pBrush->m_Contents & MASK_SHOT_HULL ) ) {
                continue;
            }

            ray_cast_brush( pBSPFile, pBrush, pTrace, origin, final );
            if( !pTrace->m_Fraction ) {
                return;
            }
        }
        if( pTrace->m_StartSolid ) {
            return;
        }
        if( pTrace->m_Fraction < 1.f ) {
            return;
        }
        for( auto i = 0; i < static_cast< int32_t >( pLeaf->m_Numleaffaces ); ++i ) {
            ray_cast_surface( pBSPFile, static_cast< int32_t >( pBSPFile->m_Leaffaces.at( pLeaf->m_Firstleafface + i ) ), pTrace, origin, final );
        }

        return;
    }

    auto* pNode = &pBSPFile->m_Nodes.at( static_cast< size_t >( node_index ) );
    if( !pNode ) {
        return;
    }
    auto* pPlane = pNode->m_pPlane;
    if( !pPlane ) {
        return;
    }

    float start_distance, end_distance;

    if( pPlane->m_Type < 3 ) {
        start_distance = origin( static_cast< size_t >( pPlane->m_Type ) ) - pPlane->m_Distance;
        end_distance   = final( static_cast< size_t >( pPlane->m_Type ) ) - pPlane->m_Distance;
    }
    else {
        start_distance = origin.dot( pPlane->m_Normal ) - pPlane->m_Distance;
        end_distance   = final.dot( pPlane->m_Normal ) - pPlane->m_Distance;
    }

    if( start_distance >= 0.f && end_distance >= 0.f ) {
        ray_cast_node( pBSPFile, pNode->m_Children.at( 0 ), start_fraction, end_fraction, origin, final, pTrace );
    }
    else if( start_distance < 0.f && end_distance < 0.f ) {
        ray_cast_node( pBSPFile, pNode->m_Children.at( 1 ), start_fraction, end_fraction, origin, final, pTrace );
    }
    else
    {
        int32_t side_id;
        float fraction_first, fraction_second, fraction_middle;
        Vector3 middle;

        if( start_distance < end_distance ) {
            /// Back
            side_id = 1;
            const auto inversed_distance = 1.f / ( start_distance - end_distance );

            fraction_first  = ( start_distance + FLT_EPSILON ) * inversed_distance;
            fraction_second = ( start_distance + FLT_EPSILON ) * inversed_distance;
        }
        else if( end_distance < start_distance ) {
            /// Front
            side_id = 0;
            const auto inversed_distance = 1.0f / ( start_distance - end_distance );

            fraction_first  = ( start_distance + FLT_EPSILON ) * inversed_distance;
            fraction_second = ( start_distance - FLT_EPSILON ) * inversed_distance;
        }
        else {
            /// Front
            side_id = 0;
            fraction_first  = 1.f;
            fraction_second = 0.f;
        }
        if( fraction_first < 0.f ) {
            fraction_first = 0.f;
        }
        else if( fraction_first > 1.f ) {
            fraction_first = 1.f;
        }
        if( fraction_second < 0.f ) {
            fraction_second = 0.f;
        }
        else if( fraction_second > 1.f ) {
            fraction_second = 1.f;
        }

        fraction_middle = start_fraction + ( end_fraction - start_fraction ) * fraction_first;
        for( size_t i = 0; i < 3; i++ ) {
            middle( i ) = origin( i ) + fraction_first * ( final( i ) - origin( i ) );
        }

        ray_cast_node( pBSPFile, pNode->m_Children.at( side_id ), start_fraction, fraction_middle, origin, middle, pTrace );
        fraction_middle = start_fraction + ( end_fraction - start_fraction ) * fraction_second;
        for( size_t i = 0; i < 3; i++ ) {
            middle( i ) = origin( i ) + fraction_second * ( final( i ) - origin( i ) );
        }

        ray_cast_node( pBSPFile, pNode->m_Children.at( !side_id ), fraction_middle, end_fraction, middle, final, pTrace );
    }
}

void TraceRay::ray_cast_brush( BSPFile* pBSPFile, dbrush_t *pBrush, trace_t *pTrace, const Vector3& origin, const Vector3& final )
{
    if( !pBrush->m_Numsides )
        return;

    auto fraction_to_enter = -99.f;
    auto fraction_to_leave = 1.f;
    auto starts_out        = false;
    auto ends_out          = false;
    for( auto i = 0; i < pBrush->m_Numsides; ++i ) {
        auto* pBrushSide = &pBSPFile->m_Brushsides.at( pBrush->m_Firstside + i );
        if( !pBrushSide || pBrushSide->m_Bevel ) {
            continue;
        }

        auto* pPlane = &pBSPFile->m_Planes.at( pBrushSide->m_Planenum );
        if( !pPlane ) {
            continue;
        }

        const auto start_distance = origin.dot( pPlane->m_Normal ) - pPlane->m_Distance;
        const auto end_distance   = final.dot( pPlane->m_Normal ) - pPlane->m_Distance;
        if( start_distance > 0.f ) {
            starts_out = true;
            if( end_distance > 0.f ) {
                return;
            }
        }
        else {
            if( end_distance <= 0.f ) {
                continue;
            }
            ends_out = true;
        }
        if( start_distance > end_distance ) {
            auto fraction = std::max( ( start_distance - DIST_EPSILON ), 0.f );
            fraction = fraction / ( start_distance - end_distance );
            if( fraction > fraction_to_enter ) {
                fraction_to_enter = fraction;
            }
        }
        else {
            auto fraction = ( start_distance + DIST_EPSILON ) / ( start_distance - end_distance );
            if( fraction < fraction_to_leave ) {
                fraction_to_leave = fraction;
            }
        }
    }

    if( starts_out ) {
        if( pTrace->m_FractionLeftSolid - fraction_to_enter > 0.f ) {
            starts_out = false;
        }
    }

    if( !starts_out ) {
        pTrace->m_StartSolid = true;
        pTrace->m_Contents = pBrush->m_Contents;

        if( !ends_out ) {
            pTrace->m_AllSolid = true;
            pTrace->m_Fraction = 0.f;
            pTrace->m_FractionLeftSolid = 1.f;
        }
        else {
            if( fraction_to_leave != 1.f && fraction_to_leave > pTrace->m_FractionLeftSolid ) {
                pTrace->m_FractionLeftSolid = fraction_to_leave;
                if( pTrace->m_Fraction <= fraction_to_leave ) {
                    pTrace->m_Fraction = 1.f;
                }
            }
        }
        return;
    }

    if( fraction_to_enter < fraction_to_leave ) {
        if( fraction_to_enter > -99.f && fraction_to_enter < pTrace->m_Fraction ) {
            if( fraction_to_enter < 0.f ) {
                fraction_to_enter = 0.f;
            }

            pTrace->m_Fraction = fraction_to_enter;
            pTrace->m_pBrush = pBrush;
            pTrace->m_Contents = pBrush->m_Contents;
        }
    }
}

void TraceRay::ray_cast_surface( BSPFile* pBSPFile, const int32_t surface_index, trace_t *pTrace, const Vector3& origin, const Vector3& final )
{
    auto* pPolygon = &pBSPFile->m_Polygons.at( static_cast< size_t >( surface_index ) );
    if( !pPolygon ) {
        return;
    }

    auto* pPlane    = &pPolygon->m_Plane;
    const auto dot1 = pPlane->dist_to( origin );
    const auto dot2 = pPlane->dist_to( final );

    if( dot1 > 0.f != dot2 > 0.f ) {
        if( dot1 - dot2 < DIST_EPSILON ) {
            return;
        }

        auto t = dot1 / ( dot1 - dot2 );
        if( t <= 0 ) {
            return;
        }

        size_t i;
        auto intersection = origin + ( final - origin ) * t;
        for( i = 0; i < pPolygon->m_nVerts; ++i ) {
            auto* pEdgePlane = &pPolygon->m_EdgePlanes.at( i );
            if( pEdgePlane->m_Origin.empty() ) {
                pEdgePlane->m_Origin = pPlane->m_Origin - ( pPolygon->m_Verts.at( i ) - pPolygon->m_Verts.at( ( i + 1 ) % pPolygon->m_nVerts ) );
                pEdgePlane->m_Origin.normalize();
                pEdgePlane->m_Distance = pEdgePlane->m_Origin.dot( pPolygon->m_Verts.at( i ) );
            }
            if( pEdgePlane->dist_to( intersection ) < 0.0f ) {
                break;
            }
        }
        if( i == pPolygon->m_nVerts ) {
            pTrace->m_Fraction = 0.2f;
            pTrace->m_EndPos = intersection;
        }
    }
}

```

`GarhalController/TraceRay.hpp`:

```hpp
/**
 * @author     ReactiioN
 * @date       08.03.2016
 * @visit      https://github.com/ReactiioN1337
 *             https://reactiion.pw
 *             https://www.unknowncheats.me/forum/members/264622.html
 */
#pragma once
#include "BSPFile.hpp"

namespace hazedumper {

    class trace_t
    {
    public:
        /// Determine if plane is NOT valid
        bool           m_AllSolid          = true;
        /// Determine if the start point was in a solid area
        bool           m_StartSolid        = true;
        /// Time completed, 1.0 = didn't hit anything :)
        float          m_Fraction          = 1.f;
        float          m_FractionLeftSolid = 1.f;
        /// Final trace position
        Vector3        m_EndPos            = 0.f;
        BSP::cplane_t* m_pPlane            = nullptr;
        int32_t        m_Contents          = 0;
        BSP::dbrush_t* m_pBrush            = nullptr;
        int32_t        m_nBrushSide        = 0;
    };

    class TraceRay
    {
    public:
        /**
         * @brief      Determines if visible.
         *
         * @param[in]  origin     The origin
         * @param[in]  final      The final
         * @param      pBSPFile   The bsp file
         *
         * @return     True if visible, False otherwise.
         */
        static bool is_visible( const Vector3& origin, const Vector3& final, BSPFile* pBSPFile );

        /**
         * @brief      Perform world trace.
         *
         * @param[in]  origin     The origin
         * @param[in]  final      The final point
         * @param      pBSPFile   The bsp file
         * @param      pTrace     The trace
         */
        static void ray_cast( const Vector3& origin, const Vector3& final, BSPFile* pBSPFile, trace_t* pTrace );

    protected:
        /**
         * @brief      Trace a bsp node.
         *
         * @param      pBSPFile        The bsp file
         * @param[in]  node_index      The node index
         * @param[in]  start_fraction  The start fraction
         * @param[in]  end_fraction    The end fraction
         * @param[in]  origin          The origin
         * @param[in]  final           The final point
         * @param      pTrace          The trace
         */
        static void ray_cast_node( BSPFile* pBSPFile, const int32_t node_index, const float start_fraction, const float end_fraction, const Vector3& origin, const Vector3& final, trace_t* pTrace );

        /**
         * @brief      Trace a bsp brush.
         *
         * @param      pBSPFile   The bsp file
         * @param      pBrush     The brush
         * @param      pTrace     The trace
         * @param[in]  origin     The origin
         * @param[in]  final      The final point
         */
        static void ray_cast_brush( BSPFile* pBSPFile, BSP::dbrush_t *pBrush, trace_t *pTrace, const Vector3& origin, const Vector3& final );

        /**
         * @brief      Trace a bsp surfaces.
         *
         * @param      pBSPFile       The bsp file
         * @param[in]  surface_index  The surface index
         * @param      pTrace         The trace
         * @param[in]  origin         The origin
         * @param[in]  final          The final point
         */
        static void ray_cast_surface( BSPFile* pBSPFile, const int32_t surface_index, trace_t *pTrace, const Vector3& origin, const Vector3& final );
    };
}

```

`GarhalController/communications.hpp`:

```hpp
#pragma once

#include <Windows.h>

/* IOCTL Codes needed for our driver */

// Request to read virtual user memory (memory of a program) from kernel space
#define IO_READ_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0666 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to write virtual user memory (memory of a program) from kernel space
#define IO_WRITE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0667 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the process id of csgo process, from kernel space
#define IO_GET_ID_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0668 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of client.dll in csgo.exe from kernel space
#define IO_GET_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0669 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of engine.dll in csgo.exe from kernel space
#define IO_GET_ENGINE_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0670 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request size of Client.dll
#define IO_GET_MODULE_REQUEST_LENGTH CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0671 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request size of Engine.dll
#define IO_GET_ENGINE_MODULE_REQUEST_LENGTH CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0672 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Order driver to apply full protection on Controller
#define IO_PROTECT_CONTROLLER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0673 /* Our Custom Code */, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

// Order driver to apply full protection on RankReader
#define IO_PROTECT_RANKREADER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0674 /* Our Custom Code */, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


typedef struct _KERNEL_READ_REQUEST
{
	ULONG ProcessId;

	ULONG Address;
	PVOID pBuff;
	ULONG Size;

} KERNEL_READ_REQUEST, * PKERNEL_READ_REQUEST;

typedef struct _KERNEL_WRITE_REQUEST
{
	ULONG ProcessId;

	ULONG Address;
	PVOID pBuff;
	ULONG Size;

} KERNEL_WRITE_REQUEST, * PKERNEL_WRITE_REQUEST;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
```

`GarhalController/config.cpp`:

```cpp
#include "config.hpp"

#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
using namespace std;


Config::Config(string name, string parentDebugInfo) {
	debugInfo = parentDebugInfo + ", " + name;
}

Config::Config(string configFile, char** envp) {
	while (*envp) 
	{
		string envEntry = *envp;
		size_t pos = envEntry.find('=');
		if (pos != string::npos) {
			string name = envEntry.substr(0, pos);
			string value = envEntry.substr(pos + 1, string::npos);
			envSymbols[name] = value;
		}
		++envp;
	}

	debugInfo = configFile;
	groupStack.push_front(this);

	FILE* in;
	errno_t err;
	
	err = fopen_s(&in, configFile.c_str(), "r");
	
	if (!in) {
		cerr << "cannot open input file '" << configFile << "'" << endl;
		exit(2);
	}

	char buff[1024];
	while (fgets(buff, 1024, in)) {

		string line = buff;
		if ((line.length() > 2) && (line[0] != '#') && (line.find(')') == string::npos)) {
			string name;
			string value;
			split(line, name, value, '=');

			if (value == "(") {
				Config* newGroup = new Config(name, debugInfo);
				groupStack.front()->groups[name] = newGroup;
				groupStack.push_front(newGroup);
			}
			else {
				for (list<Config*>::reverse_iterator i = groupStack.rbegin(); i != groupStack.rend(); ++i) {
					(*i)->symbolExpand(value);
				}
				envSymbolExpand(value);
				groupStack.front()->add(name, value);
			}
		}
		if ((line.length() > 0) && (line[0] != '#') && (line.find(')') != string::npos)) 
		{
			groupStack.pop_front();
		}
	}

	fclose(in);
}

Config::~Config() {
	for (map<string, Config*>::iterator i = groups.begin(); i != groups.end(); ++i) {
		delete i->second;
	}
}

void Config::add(string name, string value) {
	symbols[name] = value;
}

void Config::split(string in, string& left, string& right, char c) {
	size_t pos = in.find_first_of(c);
	if (pos == string::npos) {
		left = in;
		trim(left);
		right = "";
	}
	else if (pos <= 1) {
		left = "";
		right = in.substr(pos + 1, string::npos);
		trim(right);
	}
	else {
		left = in.substr(0, pos - 1);
		trim(left);
		right = in.substr(pos + 1, string::npos);
		trim(right);
	}
}

void Config::trim(string& s) {
	while ((s.length() > 1) && ((s[0] == ' ') || (s[0] == '\t'))) {
		s = s.substr(1, string::npos);
	}
	while ((s.length() > 1) &&
		((s[s.length() - 1] == ' ') ||
			(s[s.length() - 1] == '\t') ||
			(s[s.length() - 1] == '\n') ||
			(s[s.length() - 1] == '\r'))) {
		s = s.substr(0, s.length() - 1);
	}
	if ((s.length() > 1) && (s[0] == '"')) {
		s = s.substr(1, string::npos);
	}
	if ((s.length() > 1) && (s[s.length() - 1] == '"')) {
		s = s.substr(0, s.length() - 1);
	}
}

void Config::symbolExpand(string& s) {
	symbolExpand(symbols, s);
}

void Config::envSymbolExpand(string& s) {
	symbolExpand(envSymbols, s);
}

void Config::symbolExpand(map<string, string>& symbols, string& s) {
	bool expanded;
	do {
		expanded = false;
		for (map<string, string>::iterator i = symbols.begin(); i != symbols.end(); ++i) {
			string search = "%" + i->first + "%";
			string replace = i->second;
			size_t pos = s.find(search);
			if (pos != string::npos) {
				expanded = true;
				s.replace(pos, search.length(), replace);
			}
		}
	} while (expanded);
}

string Config::pString(string name) {
	map<string, string>::iterator i = symbols.find(name);
	if (i == symbols.end()) {
		cout << "Config option is wrong or missing! '" << name << "' (" << debugInfo << ")" << endl;
		system("pause");
		exit(4);
	}
	return i->second;
}

bool Config::pBool(string name) {
	string val = pString(name);

	std::transform(val.begin(), val.end(), val.begin(),
		[](unsigned char c) { return std::tolower(c); });

	if (val == "true")
	{
		return true;
	}

	return false;
}

double Config::pDouble(string name) {
	string val = pString(name);

	return atof(val.c_str());
}

int Config::pInt(string name) {
	string val = pString(name);

	return atoi(val.c_str());
}

int Config::pHex(string name)
{
	string val = pString(name);

	return stoi(val, 0, 16);
}
```

`GarhalController/config.hpp`:

```hpp
#ifndef IncConfig
#define IncConfig

#include <string>
#include <map>
#include <list>
using namespace std;

/*
   Config

   Parse structured config files

   Config files contains lines with name-value assignements in the form "<name> = <value>".
   Trailing and leading whitespace is stripped. Parsed config entries are stored in
   a symbol map.

   Lines beginning with '#' are a comment and ignored.

   Config files may be structured (to arbitrary depth). To start a new config sub group
   (or sub section) use a line in the form of "<name> = (".
   Subsequent entries are stured in the sub group, until a line containing ")" is found.

   Values may reuse already defined names as a variable which gets expanded during
   the parsing process. Names for expansion are searched from the current sub group
   upwards. Finally the process environment is searched, so also environment
   variables may be used as expansion symbols in the config file.

   Errors and warnings are handled by emitting logging messages (see log.h/log.cpp)
   or by calling exit() for severe errors. Depending on project needs this may be replaced
   by exeptions, error return codes, ...
 */

class Config {
public:
	/* Parse config file 'configFile'. If the process environment
	 * is provided, environment variables can be used as expansion symbols.
	 */
	Config(string configFile, char** envp = 0);

	~Config();

	// get string config entry
	string pString(string name);

	/* get boolean config entry
	 * A value of Yes/yes/YES/true/True/TRUE leads to true,
	 * all other values leads to false.
	 */
	bool pBool(string name);

	// get double config entry; value is parsed using atof()
	double pDouble(string name);

	// get int config entry; value is parsed using atoi()
	int pInt(string name);

	int pHex(string name);

	// get the symbol map (e.g. for iterating over all symbols)
	inline map<string, string>& getSymbols() {
		return symbols;
	}

	// get config sub group
	inline Config* group(string name) {
		return groups[name];
	}

	// get config sub group map (e.g. for iterating over all groups)
	inline map<string, Config*>& getGroups() {
		return groups;
	}

private:
	// private constructor for sub groups
	Config(string name, string parentDebugInfo);

	// helper functions for parsing
	void add(string name, string value);
	void split(string in, string& left, string& right, char c);
	void trim(string& s);
	void symbolExpand(string& s);
	void symbolExpand(map<string, string>& symbols, string& s);
	void envSymbolExpand(string& s);

	// config group symbol map
	map<string, string> symbols;

	// environment symbol map
	map<string, string> envSymbols;

	// config sub group map
	map<string, Config*> groups;

	// stack of config groups for parsing (only used in top config element)
	list<Config*> groupStack;

	// debug info used for logging messages
	string debugInfo;
};

#endif
```

`GarhalController/data.hpp`:

```hpp
#pragma once
#include <vector>
#include <windows.h>
#include "Matrix.hpp"
#include "kernelinterface.hpp"

using Vector3 = Matrix<float, 3, 1>;
using WorldToScreenMatrix = Matrix<float, 4, 4>;

struct GlowStruct
{
	BYTE base[4];
	float red;
	float green;
	float blue;
	float alpha;
	BYTE buffer[16];
	bool renderWhenOccluded;
	bool renderWhenUnOccluded;
	bool fullBloom;
	BYTE buffer1[5];
	int glowStyle;
};

enum GameState
{
	Lobby = 0,
	Loading = 1,
	Connecting = 2,
	Connected = 5,
	InGame = 6,
	UnknownG = -1,
};

struct UserCMD_ShellCode
{
	Vector3		m_vecViewAngles;     // 0x0C
	float		m_flForwardmove;     // 0x24
	float		m_flSidemove;        // 0x28
	bool		shouldSet;
};

enum CSGO_Weapon_ID
{
	WEAPON_UNKNOWN = 0,
	WEAPON_DEAGLE = 1,
	WEAPON_ELITE = 2,
	WEAPON_FIVESEVEN = 3,
	WEAPON_GLOCK = 4,
	WEAPON_AK47 = 7,
	WEAPON_AUG = 8,
	WEAPON_AWP = 9,
	WEAPON_FAMAS = 10,
	WEAPON_G3SG1 = 11,
	WEAPON_GALILAR = 13,
	WEAPON_M249 = 14,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10 = 17,
	WEAPON_P90 = 19,
	WEAPON_UMP45 = 24,
	WEAPON_XM1014 = 25,
	WEAPON_BIZON = 26,
	WEAPON_MAG7 = 27,
	WEAPON_NEGEV = 28,
	WEAPON_SAWEDOFF = 29,
	WEAPON_TEC9 = 30,
	WEAPON_TASER = 31,
	WEAPON_HKP2000 = 32,
	WEAPON_MP7 = 33,
	WEAPON_MP9 = 34,
	WEAPON_NOVA = 35,
	WEAPON_P250 = 36,
	WEAPON_SCAR20 = 38,
	WEAPON_SG556 = 39,
	WEAPON_SSG08 = 40,
	WEAPON_KNIFE = 42,
	WEAPON_FLASHBANG = 43,
	WEAPON_HEGRENADE = 44,
	WEAPON_SMOKEGRENADE = 45,
	WEAPON_MOLOTOV = 46,
	WEAPON_DECOY = 47,
	WEAPON_INCGRENADE = 48,
	WEAPON_C4 = 49,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER = 60,
	WEAPON_USP_SILENCER = 61,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER = 64,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT = 506,
	WEAPON_KNIFE_KARAMBIT = 507,
	WEAPON_KNIFE_M9_BAYONET = 508,
	WEAPON_KNIFE_TACTICAL = 509,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY = 515,
	WEAPON_KNIFE_PUSH = 516
};

inline bool IsWeaponNonAim(int iWeaponID)
{
	if (iWeaponID == WEAPON_KNIFE_BAYONET 
		|| iWeaponID == WEAPON_KNIFE_FLIP
		|| iWeaponID == WEAPON_KNIFE
		|| iWeaponID == WEAPON_KNIFE_T
		|| iWeaponID == WEAPON_KNIFE_GUT
		|| iWeaponID == WEAPON_KNIFE_KARAMBIT
		|| iWeaponID == WEAPON_KNIFE_M9_BAYONET
		|| iWeaponID == WEAPON_KNIFE_TACTICAL
		|| iWeaponID == WEAPON_KNIFE_FALCHION
		|| iWeaponID == WEAPON_KNIFE_SURVIVAL_BOWIE
		|| iWeaponID == WEAPON_KNIFE_BUTTERFLY
		|| iWeaponID == WEAPON_KNIFE_PUSH
		|| iWeaponID == WEAPON_FLASHBANG
		|| iWeaponID == WEAPON_HEGRENADE
		|| iWeaponID == WEAPON_SMOKEGRENADE
		|| iWeaponID == WEAPON_MOLOTOV
		|| iWeaponID == WEAPON_DECOY
		|| iWeaponID == WEAPON_INCGRENADE
		|| iWeaponID == WEAPON_C4)
	{
		return true;
	}

	return false;
}

inline bool IsWeaponPistol(int iWeaponID)
{
	return iWeaponID == WEAPON_DEAGLE
		|| iWeaponID == WEAPON_ELITE
		|| iWeaponID == WEAPON_FIVESEVEN
		|| iWeaponID == WEAPON_GLOCK
		|| iWeaponID == WEAPON_P250
		|| iWeaponID == WEAPON_USP_SILENCER
		|| iWeaponID == WEAPON_CZ75A
		|| iWeaponID == WEAPON_REVOLVER
		|| iWeaponID == WEAPON_TEC9
		|| iWeaponID == WEAPON_TASER
		|| iWeaponID == WEAPON_HKP2000;
}

inline bool IsWeaponSniper(int iWeaponID)
{
	return iWeaponID == WEAPON_AWP
		|| iWeaponID == WEAPON_SSG08;
}

#define SCREEN_WIDTH 1920
#define SCREEN_HEIGHT 1080
#define	FL_ONGROUND (1<<0)
#define IN_ATTACK		(1<<0)
#define IN_ATTACK2	(1<<11)
#define IN_RELOAD		(1<<13)
#define KEY_DOWN (0x80000000)
#define MOUSE_UP (0x100)
#define HEAD_BONE_ID ((DWORD) 8)
#define CHEST_BONE_ID ((DWORD) 37)

inline const float FovRange = 10.0f;
inline DWORD ProcessId, ClientAddress, ClientSize, EngineAddress, EngineSize, CMDAddress;
inline DWORD** IClientMode;
inline KeInterface Driver = NULL;

// Store the config values here.
inline uint8_t AimbotS = 0;
inline uint8_t AimbotTarget = 0;
inline uint8_t AimbotBullets = 0;
inline uint8_t TriggerBotDelayMin = 0;
inline uint8_t TriggerBotDelayMax = 0;
inline uint16_t AimbotKey = 0;
inline uint16_t TriggerBotKey = 0;
inline bool Bhop = false;
inline bool Wallhack = false;
inline bool NoFlash = false;
inline bool TriggerBot = false;
inline bool Radar = false;
inline bool TriggerBotDelay = false;
inline std::vector<uint16_t> WeaponIDs;

inline void FreeMemory()
{
	free(&AimbotS);
	free(&AimbotTarget);
	free(&AimbotBullets);
	free(&TriggerBotDelayMin);
	free(&TriggerBotDelayMax);
	free(&TriggerBotKey);
	free(&Bhop);
	free(&Wallhack);
	free(&NoFlash);
	free(&TriggerBot);
	free(&Radar);
	free(&WeaponIDs);

	free(&Driver);
	free(&ProcessId);
	free(&ClientAddress);
	free(&ClientSize);
	free(&EngineAddress);
	free(&EngineSize);
}

```

`GarhalController/garhal.cfg`:

```cfg
#Aimbot Type 0=Disabled, 1=Smooth, 2=Direct
AimbotS = 0
#Aimbot Key (https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes)
AimbotKey = 0x58
#Aimbot Target Head = 1, Body = 2, or both = 3? (Both = hp >= 50 -> head, below body) 0 to disable.
AimbotTarget = 0
#Aimbot Assist begins at Nth bullet. (Used when AimbotS is 1)
AimbotBullets = 3
#Use Bhop?
Bhop = true
#Enable Wallhack
Wallhack = true
#Enable NoFlash
NoFlash = true
#Enable Triggerbot
TriggerBot = false
#Key to use triggerbot, set to 0 to make It automatic. (https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes)
TriggerBotKey = 0
#TriggerBot Allowed Weapon IDs (If you enter 0 everything is allowed) Refer to data.hpp file on github.
TriggerBotAllowed = 9,40
#Enable Triggerbot delay?
TriggerBotDelay = false
#Triggerbot random delay (8,15) means we are delaying randomby between 8-15 millisecs. 0 is good to use at minimum.
TriggerBotDelayNum = 8,15
#Enable Radar mark?
Radar = false
```

`GarhalController/kernelinterface.hpp`:

```hpp
#pragma once
#pragma warning( disable : 4101 4244)

#include "communications.hpp"

// The interface handler for IOCTL. Thanks Zeromem.
class KeInterface
{
	
public:
	HANDLE hDriver; // Handle to driver

					// Initializer
	KeInterface(LPCSTR RegistryPath)
	{
		hDriver = CreateFileA(RegistryPath, GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	}

	template <typename type>
	type ReadVirtualMemory(ULONG ProcessId, ULONG ReadAddress, SIZE_T Size)
	{
		// allocate a buffer with specified type to allow our driver to write our wanted data inside this buffer
		type Buffer;

		DWORD Return, Bytes;
		KERNEL_READ_REQUEST ReadRequest;


		ReadRequest.ProcessId = ProcessId;
		ReadRequest.Address = ReadAddress;

		//send the 'address' of the buffer so our driver can know where to write the data
		ReadRequest.pBuff = &Buffer;

		ReadRequest.Size = Size;

		// send code to our driver with the arguments
		if (DeviceIoControl(hDriver, IO_READ_REQUEST, &ReadRequest, sizeof(ReadRequest), &ReadRequest, sizeof(ReadRequest), 0, 0)) 
		{
			//return our buffer
			return Buffer;
		}
		return Buffer;
	}

	template <typename type>
	bool WriteVirtualMemory(ULONG ProcessId, ULONG WriteAddress, type WriteValue, SIZE_T WriteSize)
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;
		DWORD Bytes;

		KERNEL_WRITE_REQUEST  WriteRequest;
		WriteRequest.ProcessId = ProcessId;
		WriteRequest.Address = WriteAddress;

		//send driver the 'address' of our specified type WriteValue so our driver can copy the data we want to write from this address to WriteAddress
		WriteRequest.pBuff = &WriteValue;

		WriteRequest.Size = WriteSize;

		if (DeviceIoControl(hDriver, IO_WRITE_REQUEST, &WriteRequest, sizeof(WriteRequest), 0, 0, &Bytes, NULL)) 
		{
			return true;
		}
		return false;
	}

	bool ReadSpecial(ULONG ProcessId, DWORD dwAddress, LPVOID lpBuffer, DWORD dwSize)
	{
		SIZE_T Out = NULL;

		KERNEL_READ_REQUEST ReadRequest;

		ReadRequest.ProcessId = ProcessId;
		ReadRequest.Address = dwAddress;

		ReadRequest.pBuff = &lpBuffer;

		ReadRequest.Size = dwSize;

		return (DeviceIoControl(hDriver, IO_READ_REQUEST, &ReadRequest, sizeof(ReadRequest), &ReadRequest, sizeof(ReadRequest), 0, 0) == TRUE);
	}

	bool RequestProtection()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		return DeviceIoControl(hDriver, IO_PROTECT_CONTROLLER, 0, 0, 0, 0, 0, 0);
	}

	DWORD GetTargetPid()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Id;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_ID_REQUEST, &Id, sizeof(Id),
			&Id, sizeof(Id), &Bytes, NULL)) 
		{
			return Id;
		}

		return false;
	}

	DWORD GetClientModule()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_MODULE_REQUEST, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL)) 
		{
			return Address;
		}
		return false;
	}

	DWORD GetClientModuleSize()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_MODULE_REQUEST_LENGTH, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL))
		{
			return Address;
		}
		return false;
	}


	DWORD GetEngineModule()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_ENGINE_MODULE_REQUEST, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL))
		{
			return Address;
		}
		return false;
	}

	DWORD GetEngineModuleSize()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_ENGINE_MODULE_REQUEST_LENGTH, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL))
		{
			return Address;
		}
		return false;
	}

	BOOL DataCompare(const BYTE* pData, const BYTE* pMask, const char* pszMask)
	{
		for (; *pszMask; ++pszMask, ++pData, ++pMask)
		{
			if (*pszMask == 'x' && *pData != *pMask)
			{
				return FALSE;
			}
		}
		return (*pszMask == 0);
	}

	DWORD Scan(ULONG ProcessId, DWORD dwStart, DWORD dwSize, const char* pSignature, const char* pMask)
	{
		BYTE* pRemote = new BYTE[dwSize];
		if (!ReadSpecial(ProcessId, dwStart, pRemote, dwSize))
		{
			delete[] pRemote;
			return NULL;
		}
		for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++)
		{
			if (DataCompare((const BYTE*)(pRemote + dwIndex), (const BYTE*)pSignature, pMask))
			{
				delete[] pRemote;
				return (dwStart + dwIndex);
			}
		}
		delete[] pRemote;
		return NULL;
	}
};
```

`GarhalController/offsets.hpp`:

```hpp
#pragma once
#include <cstddef>
#include <cstdint>

// 2021-05-28 13:39:49.347626700 UTC

namespace hazedumper {
	constexpr ::std::int64_t timestamp = 1622209189;
	namespace netvars {
		constexpr ::std::ptrdiff_t cs_gamerules_data = 0x0;
		constexpr ::std::ptrdiff_t m_ArmorValue = 0xB37C;
		constexpr ::std::ptrdiff_t m_Collision = 0x320;
		constexpr ::std::ptrdiff_t m_CollisionGroup = 0x474;
		constexpr ::std::ptrdiff_t m_Local = 0x2FBC;
		constexpr ::std::ptrdiff_t m_MoveType = 0x25C;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x31C4;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidLow = 0x31C0;
		constexpr ::std::ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1328;
		constexpr ::std::ptrdiff_t m_SurvivalRules = 0xD00;
		constexpr ::std::ptrdiff_t m_aimPunchAngle = 0x302C;
		constexpr ::std::ptrdiff_t m_aimPunchAngleVel = 0x3038;
		constexpr ::std::ptrdiff_t m_angEyeAnglesX = 0xB380;
		constexpr ::std::ptrdiff_t m_angEyeAnglesY = 0xB384;
		constexpr ::std::ptrdiff_t m_bBombDefused = 0x29B0;
		constexpr ::std::ptrdiff_t m_bBombPlanted = 0x9A5;
		constexpr ::std::ptrdiff_t m_bBombTicking = 0x2980;
		constexpr ::std::ptrdiff_t m_bFreezePeriod = 0x20;
		constexpr ::std::ptrdiff_t m_bGunGameImmunity = 0x3944;
		constexpr ::std::ptrdiff_t m_bHasDefuser = 0xB38C;
		constexpr ::std::ptrdiff_t m_bHasHelmet = 0xB370;
		constexpr ::std::ptrdiff_t m_bInReload = 0x32A5;
		constexpr ::std::ptrdiff_t m_bIsDefusing = 0x3930;
		constexpr ::std::ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
		constexpr ::std::ptrdiff_t m_bIsScoped = 0x3928;
		constexpr ::std::ptrdiff_t m_bIsValveDS = 0x7C;
		constexpr ::std::ptrdiff_t m_bSpotted = 0x93D;
		constexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;
		constexpr ::std::ptrdiff_t m_bStartedArming = 0x33F0;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMax = 0x9D9;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMin = 0x9D8;
		constexpr ::std::ptrdiff_t m_bUseCustomBloomScale = 0x9DA;
		constexpr ::std::ptrdiff_t m_clrRender = 0x70;
		constexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;
		constexpr ::std::ptrdiff_t m_fAccuracyPenalty = 0x3330;
		constexpr ::std::ptrdiff_t m_fFlags = 0x104;
		constexpr ::std::ptrdiff_t m_flC4Blow = 0x2990;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMax = 0x9E0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMin = 0x9DC;
		constexpr ::std::ptrdiff_t m_flCustomBloomScale = 0x9E4;
		constexpr ::std::ptrdiff_t m_flDefuseCountDown = 0x29AC;
		constexpr ::std::ptrdiff_t m_flDefuseLength = 0x29A8;
		constexpr ::std::ptrdiff_t m_flFallbackWear = 0x31D0;
		constexpr ::std::ptrdiff_t m_flFlashDuration = 0xA420;
		constexpr ::std::ptrdiff_t m_flFlashMaxAlpha = 0xA41C;
		constexpr ::std::ptrdiff_t m_flLastBoneSetupTime = 0x2924;
		constexpr ::std::ptrdiff_t m_flLowerBodyYawTarget = 0x3A90;
		constexpr ::std::ptrdiff_t m_flNextAttack = 0x2D70;
		constexpr ::std::ptrdiff_t m_flNextPrimaryAttack = 0x3238;
		constexpr ::std::ptrdiff_t m_flSimulationTime = 0x268;
		constexpr ::std::ptrdiff_t m_flTimerLength = 0x2994;
		constexpr ::std::ptrdiff_t m_hActiveWeapon = 0x2EF8;
		constexpr ::std::ptrdiff_t m_hBombDefuser = 0x29B4;
		constexpr ::std::ptrdiff_t m_hMyWeapons = 0x2DF8;
		constexpr ::std::ptrdiff_t m_hObserverTarget = 0x338C;
		constexpr ::std::ptrdiff_t m_hOwner = 0x29CC;
		constexpr ::std::ptrdiff_t m_hOwnerEntity = 0x14C;
		constexpr ::std::ptrdiff_t m_hViewModel = 0x32F8;
		constexpr ::std::ptrdiff_t m_iAccountID = 0x2FC8;
		constexpr ::std::ptrdiff_t m_iClip1 = 0x3264;
		constexpr ::std::ptrdiff_t m_iCompetitiveRanking = 0x1A84;
		constexpr ::std::ptrdiff_t m_iCompetitiveWins = 0x1B88;
		constexpr ::std::ptrdiff_t m_iCrosshairId = 0xB3E8;
		constexpr ::std::ptrdiff_t m_iDefaultFOV = 0x332C;
		constexpr ::std::ptrdiff_t m_iEntityQuality = 0x2FAC;
		constexpr ::std::ptrdiff_t m_iFOVStart = 0x31E8;
		constexpr ::std::ptrdiff_t m_iGlowIndex = 0xA438;
		constexpr ::std::ptrdiff_t m_iHealth = 0x100;
		constexpr ::std::ptrdiff_t m_iItemDefinitionIndex = 0x2FAA;
		constexpr ::std::ptrdiff_t m_iItemIDHigh = 0x2FC0;
		constexpr ::std::ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
		constexpr ::std::ptrdiff_t m_iObserverMode = 0x3378;
		constexpr ::std::ptrdiff_t m_iShotsFired = 0xA390;
		constexpr ::std::ptrdiff_t m_iState = 0x3258;
		constexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;
		constexpr ::std::ptrdiff_t m_lifeState = 0x25F;
		constexpr ::std::ptrdiff_t m_nBombSite = 0x2984;
		constexpr ::std::ptrdiff_t m_nFallbackPaintKit = 0x31C8;
		constexpr ::std::ptrdiff_t m_nFallbackSeed = 0x31CC;
		constexpr ::std::ptrdiff_t m_nFallbackStatTrak = 0x31D4;
		constexpr ::std::ptrdiff_t m_nForceBone = 0x268C;
		constexpr ::std::ptrdiff_t m_nTickBase = 0x3430;
		constexpr ::std::ptrdiff_t m_nViewModelIndex = 0x29C0;
		constexpr ::std::ptrdiff_t m_rgflCoordinateFrame = 0x444;
		constexpr ::std::ptrdiff_t m_szCustomName = 0x303C;
		constexpr ::std::ptrdiff_t m_szLastPlaceName = 0x35B4;
		constexpr ::std::ptrdiff_t m_thirdPersonViewAngles = 0x31D8;
		constexpr ::std::ptrdiff_t m_vecOrigin = 0x138;
		constexpr ::std::ptrdiff_t m_vecVelocity = 0x114;
		constexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;
		constexpr ::std::ptrdiff_t m_viewPunchAngle = 0x3020;
		constexpr ::std::ptrdiff_t m_zoomLevel = 0x33D0;
	} // namespace netvars
	namespace signatures {
		constexpr ::std::ptrdiff_t anim_overlays = 0x2980;
		constexpr ::std::ptrdiff_t clientstate_choked_commands = 0x4D30;
		constexpr ::std::ptrdiff_t clientstate_delta_ticks = 0x174;
		constexpr ::std::ptrdiff_t clientstate_last_outgoing_command = 0x4D2C;
		constexpr ::std::ptrdiff_t clientstate_net_channel = 0x9C;
		constexpr ::std::ptrdiff_t convar_name_hash_table = 0x2F0F8;
		constexpr ::std::ptrdiff_t dwClientState = 0x588FE4;
		constexpr ::std::ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
		constexpr ::std::ptrdiff_t dwClientState_IsHLTV = 0x4D48;
		constexpr ::std::ptrdiff_t dwClientState_Map = 0x28C;
		constexpr ::std::ptrdiff_t dwClientState_MapDirectory = 0x188;
		constexpr ::std::ptrdiff_t dwClientState_MaxPlayer = 0x388;
		constexpr ::std::ptrdiff_t dwClientState_PlayerInfo = 0x52C0;
		constexpr ::std::ptrdiff_t dwClientState_State = 0x108;
		constexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D90;
		constexpr ::std::ptrdiff_t dwEntityList = 0x4DA20DC;
		constexpr ::std::ptrdiff_t dwForceAttack = 0x31D2628;
		constexpr ::std::ptrdiff_t dwForceAttack2 = 0x31D2634;
		constexpr ::std::ptrdiff_t dwForceBackward = 0x31D267C;
		constexpr ::std::ptrdiff_t dwForceForward = 0x31D2658;
		constexpr ::std::ptrdiff_t dwForceJump = 0x524BECC;
		constexpr ::std::ptrdiff_t dwForceLeft = 0x31D2670;
		constexpr ::std::ptrdiff_t dwForceRight = 0x31D2694;
		constexpr ::std::ptrdiff_t dwGameDir = 0x627780;
		constexpr ::std::ptrdiff_t dwGameRulesProxy = 0x52BF1BC;
		constexpr ::std::ptrdiff_t dwGetAllClasses = 0xDB0F6C;
		constexpr ::std::ptrdiff_t dwGlobalVars = 0x588CE8;
		constexpr ::std::ptrdiff_t dwGlowObjectManager = 0x52EA570;
		constexpr ::std::ptrdiff_t dwInput = 0x51F36A0;
		constexpr ::std::ptrdiff_t dwInterfaceLinkList = 0x944D14;
		constexpr ::std::ptrdiff_t dwLocalPlayer = 0xD892CC;
		constexpr ::std::ptrdiff_t dwMouseEnable = 0xD8EE18;
		constexpr ::std::ptrdiff_t dwMouseEnablePtr = 0xD8EDE8;
		constexpr ::std::ptrdiff_t dwPlayerResource = 0x31D0990;
		constexpr ::std::ptrdiff_t dwRadarBase = 0x51D6E54;
		constexpr ::std::ptrdiff_t dwSensitivity = 0xD8ECB4;
		constexpr ::std::ptrdiff_t dwSensitivityPtr = 0xD8EC88;
		constexpr ::std::ptrdiff_t dwSetClanTag = 0x8A1B0;
		constexpr ::std::ptrdiff_t dwViewMatrix = 0x4D939F4;
		constexpr ::std::ptrdiff_t dwWeaponTable = 0x51F4160;
		constexpr ::std::ptrdiff_t dwWeaponTableIndex = 0x325C;
		constexpr ::std::ptrdiff_t dwYawPtr = 0xD8EA78;
		constexpr ::std::ptrdiff_t dwZoomSensitivityRatioPtr = 0xD93D18;
		constexpr ::std::ptrdiff_t dwbSendPackets = 0xD76DA;
		constexpr ::std::ptrdiff_t dwppDirect3DDevice9 = 0xA7050;
		constexpr ::std::ptrdiff_t find_hud_element = 0x2F49F980;
		constexpr ::std::ptrdiff_t force_update_spectator_glow = 0x3AFD6A;
		constexpr ::std::ptrdiff_t interface_engine_cvar = 0x3E9EC;
		constexpr ::std::ptrdiff_t is_c4_owner = 0x3BC9C0;
		constexpr ::std::ptrdiff_t m_bDormant = 0xED;
		constexpr ::std::ptrdiff_t m_flSpawnTime = 0xA370;
		constexpr ::std::ptrdiff_t m_pStudioHdr = 0x294C;
		constexpr ::std::ptrdiff_t m_pitchClassPtr = 0x51D70F0;
		constexpr ::std::ptrdiff_t m_yawClassPtr = 0xD8EA78;
		constexpr ::std::ptrdiff_t model_ambient_min = 0x58C05C;
		constexpr ::std::ptrdiff_t set_abs_angles = 0x1E0B80;
		constexpr ::std::ptrdiff_t set_abs_origin = 0x1E09C0;
	} // namespace signatures
} // namespace hazedumper
```

`GarhalController/sdk.hpp`:

```hpp
#pragma once
#pragma warning (disable : 4005)

#define	FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define	FL_WATERJUMP			(1<<2)	// player jumping out of water
#define FL_ONTRAIN				(1<<3) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<4)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<5) // Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<6) // Player can't move, but keeps key inputs for controlling another entity
#define	FL_CLIENT				(1<<7)	// Is a player
#define FL_FAKECLIENT			(1<<8)	// Fake client, simulated server side; don't send network messages to them
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define	FL_INWATER				(1<<9)	// In water

// NOTE if you move things up, make sure to change this value
#define PLAYER_FLAG_BITS		10

#define	FL_FLY					(1<<10)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<11)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<12)
#define	FL_NPC					(1<<13)
#define	FL_GODMODE				(1<<14)
#define	FL_NOTARGET				(1<<15)
#define	FL_AIMTARGET			(1<<16)	// set if the crosshair needs to aim onto the entity
#define	FL_PARTIALGROUND		(1<<17)	// not all corners are valid
#define FL_STATICPROP			(1<<18)	// Eetsa static prop!		
#define FL_GRAPHED				(1<<19) // worldgraph has this ent listed as something that blocks a connection
#define FL_GRENADE				(1<<20)
#define FL_STEPMOVEMENT			(1<<21)	// Changes the SV_Movestep() behavior to not do any processing
#define FL_DONTTOUCH			(1<<22)	// Doesn't generate touch functions, generates Untouch() for anything it was touching when this flag was set
#define FL_BASEVELOCITY			(1<<23)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_WORLDBRUSH			(1<<24)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_OBJECT				(1<<25) // Terrible name. This is an object that NPCs should see. Missiles, for example.
#define FL_KILLME				(1<<26)	// This entity is marked for death -- will be freed by game DLL
#define FL_ONFIRE				(1<<27)	// You know...
#define FL_DISSOLVING			(1<<28) // We're dissolving!
#define FL_TRANSRAGDOLL			(1<<29) // In the process of turning into a client side ragdoll.
#define FL_UNBLOCKABLE_BY_PLAYER (1<<30) // pusher that can't be blocked by the player


#define	FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define FL_ANIMDUCKING			(1<<2)	// Player flag -- Player is in the process of crouching or uncrouching but could be in transition
// examples:                                   Fully ducked:  FL_DUCKING &  FL_ANIMDUCKING
//           Previously fully ducked, unducking in progress:  FL_DUCKING & !FL_ANIMDUCKING
//                                           Fully unducked: !FL_DUCKING & !FL_ANIMDUCKING
//           Previously fully unducked, ducking in progress: !FL_DUCKING &  FL_ANIMDUCKING
#define	FL_WATERJUMP			(1<<3)	// player jumping out of water
#define FL_ONTRAIN				(1<<4) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<5)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<6) // Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<7) // Player can't move, but keeps key inputs for controlling another entity
#define	FL_CLIENT				(1<<8)	// Is a player
#define FL_FAKECLIENT			(1<<9)	// Fake client, simulated server side; don't send network messages to them
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define	FL_INWATER				(1<<10)	// In water

// NOTE if you move things up, make sure to change this value
#define PLAYER_FLAG_BITS		11

#define	FL_FLY					(1<<11)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<12)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<13)
#define	FL_NPC					(1<<14)
#define	FL_GODMODE				(1<<15)
#define	FL_NOTARGET				(1<<16)
#define	FL_AIMTARGET			(1<<17)	// set if the crosshair needs to aim onto the entity
#define	FL_PARTIALGROUND		(1<<18)	// not all corners are valid
#define FL_STATICPROP			(1<<19)	// Eetsa static prop!		
#define FL_GRAPHED				(1<<20) // worldgraph has this ent listed as something that blocks a connection
#define FL_GRENADE				(1<<21)
#define FL_STEPMOVEMENT			(1<<22)	// Changes the SV_Movestep() behavior to not do any processing
#define FL_DONTTOUCH			(1<<23)	// Doesn't generate touch functions, generates Untouch() for anything it was touching when this flag was set
#define FL_BASEVELOCITY			(1<<24)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_OBJECT				(1<<26) // Terrible name. This is an object that NPCs should see. Missiles, for example.
#define FL_KILLME				(1<<27)	// This entity is marked for death -- will be freed by game DLL
#define FL_ONFIRE				(1<<28)	// You know...
#define FL_DISSOLVING			(1<<29) // We're dissolving!
#define FL_TRANSRAGDOLL			(1<<30) // In the process of turning into a client side ragdoll.
#define FL_UNBLOCKABLE_BY_PLAYER (1<<31) // pusher that can't be blocked by the player
```

`GarhalRankDisplayer/GarhalRankDisplayer.cpp`:

```cpp

#include <iostream>
#include "data.hpp"
#include "offsets.hpp"

// hazedumper namespace
using namespace hazedumper::netvars;
using namespace hazedumper::signatures;

class player_info {
private:
	char __pad[0x10];
public:
	char name[32];
};

typedef struct player_info_s
{
	char _pad1[0x10];
	char name[80];//80
	char _pad2[0x64];
	char _pad3[0x17B];

} player_info_t;

int main()
{
	Driver = KeInterface("\\\\.\\garhalop");
	SetConsoleTitle(L"GarHal is the best rank reader fish ever, by DreTaX");

	// Get address of client.dll, engine.dll, and PID.
	ProcessId = Driver.GetTargetPid();
	ClientAddress = Driver.GetClientModule();
	EngineAddress = Driver.GetEngineModule();

	std::cout << "GarHal made by DreTaX" << std::endl;

	bool PrintOnce = false;

	while (ProcessId == 0 || ClientAddress == 0 || EngineAddress == 0)
	{
		if (!PrintOnce)
		{
			std::cout << "Addresses are 0x0. Waiting for CSGO... " << std::endl;
			PrintOnce = true;
		}

		Sleep(1000);
		ProcessId = Driver.GetTargetPid();
		ClientAddress = Driver.GetClientModule();
		EngineAddress = Driver.GetEngineModule();
	}

	std::cout << "Starting..." << std::endl;
	uint32_t clientState = Driver.ReadVirtualMemory<uint32_t>(ProcessId, EngineAddress + dwClientState, sizeof(uint32_t));
	uint32_t infotable = Driver.ReadVirtualMemory<uint32_t>(ProcessId, clientState + dwClientState_PlayerInfo, sizeof(uint32_t));
	uint32_t items = Driver.ReadVirtualMemory<uint32_t>(ProcessId, (infotable + 0x40) + 0xC, sizeof(uint32_t));

	uint32_t PlayerResource = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwPlayerResource, sizeof(uint32_t));
	for (short int i = 0; i < 10; i++)
	{
		uint32_t EntityAddr = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwEntityList + i * 0x10, sizeof(uint32_t));

		if (EntityAddr == NULL)
		{
			continue;
		}
		
		uint8_t Rank = Driver.ReadVirtualMemory<uint8_t>(ProcessId, PlayerResource + m_iCompetitiveRanking + (i * 0x04), sizeof(uint8_t));
		uint16_t Wins = Driver.ReadVirtualMemory<uint16_t>(ProcessId, PlayerResource + m_iCompetitiveWins + (i * 0x04), sizeof(uint16_t));
		//uint32_t RadarBase = Driver.ReadVirtualMemory<uint32_t>(ProcessId, ClientAddress + dwRadarBase, sizeof(uint32_t));
		//uint32_t Radar = Driver.ReadVirtualMemory<uint32_t>(ProcessId, RadarBase + 0x54, sizeof(uint32_t));

		//wchar_t cName = Driver.ReadVirtualMemory<wchar_t>(ProcessId, Radar + 0x300 + (0x174 * (i - 1)), 32);

		uint32_t asd = Driver.ReadVirtualMemory<uint32_t>(ProcessId, items + 0x28 + i * 0x34, sizeof(uint32_t));
		player_info_t playerinfo = Driver.ReadVirtualMemory<player_info_t>(ProcessId, asd, sizeof(player_info_t));

		
		char* player_name = playerinfo.name;
		
		const char* RankName = Ranks[Rank];

		std::cout << "===Player[" << i << "]===" << std::endl;
		std::cout << player_name << std::endl;
		std::cout << RankName << std::endl;
		std::cout << "Wins: " << Wins << std::endl;
		std::cout << std::endl;
	}

	system("pause");
	return 0;
}

```

`GarhalRankDisplayer/GarhalRankDisplayer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1FA067F6-A100-48E2-976A-1D0A3187247A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>GarhalRankDisplayer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GarhalRankDisplayer.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="communications.hpp" />
    <ClInclude Include="data.hpp" />
    <ClInclude Include="kernelinterface.hpp" />
    <ClInclude Include="offsets.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GarhalRankDisplayer/GarhalRankDisplayer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="GarhalRankDisplayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernelinterface.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="communications.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="data.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="offsets.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`GarhalRankDisplayer/communications.hpp`:

```hpp
#pragma once

#include <Windows.h>

/* IOCTL Codes needed for our driver */

// Request to read virtual user memory (memory of a program) from kernel space
#define IO_READ_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0666 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the process id of csgo process, from kernel space
#define IO_GET_ID_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0668 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of client.dll in csgo.exe from kernel space
#define IO_GET_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0669 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Request to retrieve the base address of engine.dll in csgo.exe from kernel space
#define IO_GET_ENGINE_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0670 /* Our Custom Code */, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

// Order driver to apply full protection on RankReader
#define IO_PROTECT_RANKREADER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0674 /* Our Custom Code */, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

typedef struct _KERNEL_READ_REQUEST
{
	ULONG ProcessId;

	ULONG Address;
	PVOID pBuff;
	ULONG Size;

} KERNEL_READ_REQUEST, * PKERNEL_READ_REQUEST;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
```

`GarhalRankDisplayer/data.hpp`:

```hpp
#pragma once
#include <windows.h>
#include "kernelinterface.hpp"

inline DWORD ProcessId, ClientAddress, EngineAddress;
inline KeInterface Driver = NULL;

inline const char* Ranks[] =
{
        "UnRanked",
        "Silver I",
        "Silver II",
        "Silver III",
        "Silver IV",
        "Silver Elite",
        "Silver Elite Master",

        "Gold Nova I",
        "Gold Nova II",
        "Gold Nova III",
        "Gold Nova Master",
        "Master Guardian I",
        "Master Guardian II",

        "Master Guardian Elite",
        "Distinguished Master Guardian",
        "Legendary Eagle",
        "Legendary Eagle Master",
        "Supreme Master First Class",
        "The Global Elite"
};
```

`GarhalRankDisplayer/kernelinterface.hpp`:

```hpp
#pragma once
#pragma warning( disable : 4101 4244)

#include "communications.hpp"

// The interface handler for IOCTL. Thanks Zeromem.
class KeInterface
{

public:
	HANDLE hDriver; // Handle to driver

					// Initializer
	KeInterface(LPCSTR RegistryPath)
	{
		hDriver = CreateFileA(RegistryPath, GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	}

	template <typename type>
	type ReadVirtualMemory(ULONG ProcessId, ULONG ReadAddress, SIZE_T Size)
	{
		// allocate a buffer with specified type to allow our driver to write our wanted data inside this buffer
		type Buffer;

		DWORD Return, Bytes;
		KERNEL_READ_REQUEST ReadRequest;


		ReadRequest.ProcessId = ProcessId;
		ReadRequest.Address = ReadAddress;

		//send the 'address' of the buffer so our driver can know where to write the data
		ReadRequest.pBuff = &Buffer;

		ReadRequest.Size = Size;

		// send code to our driver with the arguments
		if (DeviceIoControl(hDriver, IO_READ_REQUEST, &ReadRequest, sizeof(ReadRequest), &ReadRequest, sizeof(ReadRequest), 0, 0))
		{
			//return our buffer
			return Buffer;
		}
		return Buffer;
	}

	DWORD GetTargetPid()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Id;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_ID_REQUEST, &Id, sizeof(Id),
			&Id, sizeof(Id), &Bytes, NULL))
		{
			return Id;
		}

		return false;
	}

	DWORD GetClientModule()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_MODULE_REQUEST, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL))
		{
			return Address;
		}
		return false;
	}

	DWORD GetEngineModule()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		ULONG Address;
		DWORD Bytes;

		if (DeviceIoControl(hDriver, IO_GET_ENGINE_MODULE_REQUEST, &Address, sizeof(Address),
			&Address, sizeof(Address), &Bytes, NULL))
		{
			return Address;
		}
		return false;
	}

	bool RequestProtectionRank()
	{
		if (hDriver == INVALID_HANDLE_VALUE)
			return false;

		return DeviceIoControl(hDriver, IO_PROTECT_RANKREADER, 0, 0, 0, 0, 0, 0);
	}
};
```

`GarhalRankDisplayer/offsets.hpp`:

```hpp
#pragma once
#include <cstddef>
#include <cstdint>

// 2021-05-28 13:39:49.347626700 UTC

namespace hazedumper {
	constexpr ::std::int64_t timestamp = 1622209189;
	namespace netvars {
		constexpr ::std::ptrdiff_t cs_gamerules_data = 0x0;
		constexpr ::std::ptrdiff_t m_ArmorValue = 0xB37C;
		constexpr ::std::ptrdiff_t m_Collision = 0x320;
		constexpr ::std::ptrdiff_t m_CollisionGroup = 0x474;
		constexpr ::std::ptrdiff_t m_Local = 0x2FBC;
		constexpr ::std::ptrdiff_t m_MoveType = 0x25C;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x31C4;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidLow = 0x31C0;
		constexpr ::std::ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1328;
		constexpr ::std::ptrdiff_t m_SurvivalRules = 0xD00;
		constexpr ::std::ptrdiff_t m_aimPunchAngle = 0x302C;
		constexpr ::std::ptrdiff_t m_aimPunchAngleVel = 0x3038;
		constexpr ::std::ptrdiff_t m_angEyeAnglesX = 0xB380;
		constexpr ::std::ptrdiff_t m_angEyeAnglesY = 0xB384;
		constexpr ::std::ptrdiff_t m_bBombDefused = 0x29B0;
		constexpr ::std::ptrdiff_t m_bBombPlanted = 0x9A5;
		constexpr ::std::ptrdiff_t m_bBombTicking = 0x2980;
		constexpr ::std::ptrdiff_t m_bFreezePeriod = 0x20;
		constexpr ::std::ptrdiff_t m_bGunGameImmunity = 0x3944;
		constexpr ::std::ptrdiff_t m_bHasDefuser = 0xB38C;
		constexpr ::std::ptrdiff_t m_bHasHelmet = 0xB370;
		constexpr ::std::ptrdiff_t m_bInReload = 0x32A5;
		constexpr ::std::ptrdiff_t m_bIsDefusing = 0x3930;
		constexpr ::std::ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
		constexpr ::std::ptrdiff_t m_bIsScoped = 0x3928;
		constexpr ::std::ptrdiff_t m_bIsValveDS = 0x7C;
		constexpr ::std::ptrdiff_t m_bSpotted = 0x93D;
		constexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;
		constexpr ::std::ptrdiff_t m_bStartedArming = 0x33F0;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMax = 0x9D9;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMin = 0x9D8;
		constexpr ::std::ptrdiff_t m_bUseCustomBloomScale = 0x9DA;
		constexpr ::std::ptrdiff_t m_clrRender = 0x70;
		constexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;
		constexpr ::std::ptrdiff_t m_fAccuracyPenalty = 0x3330;
		constexpr ::std::ptrdiff_t m_fFlags = 0x104;
		constexpr ::std::ptrdiff_t m_flC4Blow = 0x2990;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMax = 0x9E0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMin = 0x9DC;
		constexpr ::std::ptrdiff_t m_flCustomBloomScale = 0x9E4;
		constexpr ::std::ptrdiff_t m_flDefuseCountDown = 0x29AC;
		constexpr ::std::ptrdiff_t m_flDefuseLength = 0x29A8;
		constexpr ::std::ptrdiff_t m_flFallbackWear = 0x31D0;
		constexpr ::std::ptrdiff_t m_flFlashDuration = 0xA420;
		constexpr ::std::ptrdiff_t m_flFlashMaxAlpha = 0xA41C;
		constexpr ::std::ptrdiff_t m_flLastBoneSetupTime = 0x2924;
		constexpr ::std::ptrdiff_t m_flLowerBodyYawTarget = 0x3A90;
		constexpr ::std::ptrdiff_t m_flNextAttack = 0x2D70;
		constexpr ::std::ptrdiff_t m_flNextPrimaryAttack = 0x3238;
		constexpr ::std::ptrdiff_t m_flSimulationTime = 0x268;
		constexpr ::std::ptrdiff_t m_flTimerLength = 0x2994;
		constexpr ::std::ptrdiff_t m_hActiveWeapon = 0x2EF8;
		constexpr ::std::ptrdiff_t m_hBombDefuser = 0x29B4;
		constexpr ::std::ptrdiff_t m_hMyWeapons = 0x2DF8;
		constexpr ::std::ptrdiff_t m_hObserverTarget = 0x338C;
		constexpr ::std::ptrdiff_t m_hOwner = 0x29CC;
		constexpr ::std::ptrdiff_t m_hOwnerEntity = 0x14C;
		constexpr ::std::ptrdiff_t m_hViewModel = 0x32F8;
		constexpr ::std::ptrdiff_t m_iAccountID = 0x2FC8;
		constexpr ::std::ptrdiff_t m_iClip1 = 0x3264;
		constexpr ::std::ptrdiff_t m_iCompetitiveRanking = 0x1A84;
		constexpr ::std::ptrdiff_t m_iCompetitiveWins = 0x1B88;
		constexpr ::std::ptrdiff_t m_iCrosshairId = 0xB3E8;
		constexpr ::std::ptrdiff_t m_iDefaultFOV = 0x332C;
		constexpr ::std::ptrdiff_t m_iEntityQuality = 0x2FAC;
		constexpr ::std::ptrdiff_t m_iFOVStart = 0x31E8;
		constexpr ::std::ptrdiff_t m_iGlowIndex = 0xA438;
		constexpr ::std::ptrdiff_t m_iHealth = 0x100;
		constexpr ::std::ptrdiff_t m_iItemDefinitionIndex = 0x2FAA;
		constexpr ::std::ptrdiff_t m_iItemIDHigh = 0x2FC0;
		constexpr ::std::ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
		constexpr ::std::ptrdiff_t m_iObserverMode = 0x3378;
		constexpr ::std::ptrdiff_t m_iShotsFired = 0xA390;
		constexpr ::std::ptrdiff_t m_iState = 0x3258;
		constexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;
		constexpr ::std::ptrdiff_t m_lifeState = 0x25F;
		constexpr ::std::ptrdiff_t m_nBombSite = 0x2984;
		constexpr ::std::ptrdiff_t m_nFallbackPaintKit = 0x31C8;
		constexpr ::std::ptrdiff_t m_nFallbackSeed = 0x31CC;
		constexpr ::std::ptrdiff_t m_nFallbackStatTrak = 0x31D4;
		constexpr ::std::ptrdiff_t m_nForceBone = 0x268C;
		constexpr ::std::ptrdiff_t m_nTickBase = 0x3430;
		constexpr ::std::ptrdiff_t m_nViewModelIndex = 0x29C0;
		constexpr ::std::ptrdiff_t m_rgflCoordinateFrame = 0x444;
		constexpr ::std::ptrdiff_t m_szCustomName = 0x303C;
		constexpr ::std::ptrdiff_t m_szLastPlaceName = 0x35B4;
		constexpr ::std::ptrdiff_t m_thirdPersonViewAngles = 0x31D8;
		constexpr ::std::ptrdiff_t m_vecOrigin = 0x138;
		constexpr ::std::ptrdiff_t m_vecVelocity = 0x114;
		constexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;
		constexpr ::std::ptrdiff_t m_viewPunchAngle = 0x3020;
		constexpr ::std::ptrdiff_t m_zoomLevel = 0x33D0;
	} // namespace netvars
	namespace signatures {
		constexpr ::std::ptrdiff_t anim_overlays = 0x2980;
		constexpr ::std::ptrdiff_t clientstate_choked_commands = 0x4D30;
		constexpr ::std::ptrdiff_t clientstate_delta_ticks = 0x174;
		constexpr ::std::ptrdiff_t clientstate_last_outgoing_command = 0x4D2C;
		constexpr ::std::ptrdiff_t clientstate_net_channel = 0x9C;
		constexpr ::std::ptrdiff_t convar_name_hash_table = 0x2F0F8;
		constexpr ::std::ptrdiff_t dwClientState = 0x588FE4;
		constexpr ::std::ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
		constexpr ::std::ptrdiff_t dwClientState_IsHLTV = 0x4D48;
		constexpr ::std::ptrdiff_t dwClientState_Map = 0x28C;
		constexpr ::std::ptrdiff_t dwClientState_MapDirectory = 0x188;
		constexpr ::std::ptrdiff_t dwClientState_MaxPlayer = 0x388;
		constexpr ::std::ptrdiff_t dwClientState_PlayerInfo = 0x52C0;
		constexpr ::std::ptrdiff_t dwClientState_State = 0x108;
		constexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D90;
		constexpr ::std::ptrdiff_t dwEntityList = 0x4DA20DC;
		constexpr ::std::ptrdiff_t dwForceAttack = 0x31D2628;
		constexpr ::std::ptrdiff_t dwForceAttack2 = 0x31D2634;
		constexpr ::std::ptrdiff_t dwForceBackward = 0x31D267C;
		constexpr ::std::ptrdiff_t dwForceForward = 0x31D2658;
		constexpr ::std::ptrdiff_t dwForceJump = 0x524BECC;
		constexpr ::std::ptrdiff_t dwForceLeft = 0x31D2670;
		constexpr ::std::ptrdiff_t dwForceRight = 0x31D2694;
		constexpr ::std::ptrdiff_t dwGameDir = 0x627780;
		constexpr ::std::ptrdiff_t dwGameRulesProxy = 0x52BF1BC;
		constexpr ::std::ptrdiff_t dwGetAllClasses = 0xDB0F6C;
		constexpr ::std::ptrdiff_t dwGlobalVars = 0x588CE8;
		constexpr ::std::ptrdiff_t dwGlowObjectManager = 0x52EA570;
		constexpr ::std::ptrdiff_t dwInput = 0x51F36A0;
		constexpr ::std::ptrdiff_t dwInterfaceLinkList = 0x944D14;
		constexpr ::std::ptrdiff_t dwLocalPlayer = 0xD892CC;
		constexpr ::std::ptrdiff_t dwMouseEnable = 0xD8EE18;
		constexpr ::std::ptrdiff_t dwMouseEnablePtr = 0xD8EDE8;
		constexpr ::std::ptrdiff_t dwPlayerResource = 0x31D0990;
		constexpr ::std::ptrdiff_t dwRadarBase = 0x51D6E54;
		constexpr ::std::ptrdiff_t dwSensitivity = 0xD8ECB4;
		constexpr ::std::ptrdiff_t dwSensitivityPtr = 0xD8EC88;
		constexpr ::std::ptrdiff_t dwSetClanTag = 0x8A1B0;
		constexpr ::std::ptrdiff_t dwViewMatrix = 0x4D939F4;
		constexpr ::std::ptrdiff_t dwWeaponTable = 0x51F4160;
		constexpr ::std::ptrdiff_t dwWeaponTableIndex = 0x325C;
		constexpr ::std::ptrdiff_t dwYawPtr = 0xD8EA78;
		constexpr ::std::ptrdiff_t dwZoomSensitivityRatioPtr = 0xD93D18;
		constexpr ::std::ptrdiff_t dwbSendPackets = 0xD76DA;
		constexpr ::std::ptrdiff_t dwppDirect3DDevice9 = 0xA7050;
		constexpr ::std::ptrdiff_t find_hud_element = 0x2F49F980;
		constexpr ::std::ptrdiff_t force_update_spectator_glow = 0x3AFD6A;
		constexpr ::std::ptrdiff_t interface_engine_cvar = 0x3E9EC;
		constexpr ::std::ptrdiff_t is_c4_owner = 0x3BC9C0;
		constexpr ::std::ptrdiff_t m_bDormant = 0xED;
		constexpr ::std::ptrdiff_t m_flSpawnTime = 0xA370;
		constexpr ::std::ptrdiff_t m_pStudioHdr = 0x294C;
		constexpr ::std::ptrdiff_t m_pitchClassPtr = 0x51D70F0;
		constexpr ::std::ptrdiff_t m_yawClassPtr = 0xD8EA78;
		constexpr ::std::ptrdiff_t model_ambient_min = 0x58C05C;
		constexpr ::std::ptrdiff_t set_abs_angles = 0x1E0B80;
		constexpr ::std::ptrdiff_t set_abs_origin = 0x1E09C0;
	} // namespace signatures
} // namespace hazedumper
```

`LICENSE.md`:

```md
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/.


Creative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.

Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.

Considerations for licensors: Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. More considerations for licensors.
Considerations for the public: By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor’s permission is not necessary for any reason–for example, because of any applicable exception or limitation to copyright–then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. More considerations for the public.
Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License

By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License ("Public License"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.

Section 1 – Definitions.

Adapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.
Copyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.
Effective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.
Exceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.
Licensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.
Licensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.
Licensor means the individual(s) or entity(ies) granting rights under this Public License.
NonCommercial means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.
Share means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.
Sui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.
You means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.
Section 2 – Scope.

License grant.
Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:
reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and
produce and reproduce, but not Share, Adapted Material for NonCommercial purposes only.
Exceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.
Term. The term of this Public License is specified in Section 6(a).
Media and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.
Downstream recipients.
Offer from the Licensor – Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.
No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.
No endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).
Other rights.

Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.
Patent and trademark rights are not licensed under this Public License.
To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.
Section 3 – License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the following conditions.

Attribution.

If You Share the Licensed Material, You must:

retain the following if it is supplied by the Licensor with the Licensed Material:
identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);
a copyright notice;
a notice that refers to this Public License;
a notice that refers to the disclaimer of warranties;
a URI or hyperlink to the Licensed Material to the extent reasonably practicable;
indicate if You modified the Licensed Material and retain an indication of any previous modifications; and
indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.
For the avoidance of doubt, You do not have permission under this Public License to Share Adapted Material.
You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.
If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.
Section 4 – Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:

for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only and provided You do not Share Adapted Material;
if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and
You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.
For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.
Section 5 – Disclaimer of Warranties and Limitation of Liability.

Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.
To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.
The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.
Section 6 – Term and Termination.

This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.
Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:

automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or
upon express reinstatement by the Licensor.
For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.
For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.
Sections 1, 5, 6, 7, and 8 survive termination of this Public License.
Section 7 – Other Terms and Conditions.

The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.
Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.
Section 8 – Interpretation.

For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.
To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.
No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.
Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.
Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.

Creative Commons may be contacted at creativecommons.org.
```

`README.md`:

```md
[![IMAGE ALT TEXT HERE](https://i.imgur.com/RCDePZO.png)](https://i.imgur.com/RCDePZO.png)
# GarHal_CSGO
A project that demonstrates how to screw with CSGO from Kernel Space.
Project comes with updated offsets, my aim was to create a project with more features achieved using a driver.
I tend to hook DirectX, and implement Kernel-level drawing into this project. This has been done by a couple of people already, I mainly wanted to do one myself. The project has a UserMode application which uses IOCTL to control the Kernel Driver. This was something that helped me understand more of how Kernel Drivers work in particular, make a clean project for myself, and go forward. 

Side note: 
No, this project has nothing to do with csgo's released source code or whatever.
This project probably has mistakes. Feel free to correct me through PRs.

#### Project discussion: https://guidedhacking.com/threads/csgo-kernel-driver-multihack.15130/

### WARNING: The project is for research purposes only and is not suitable for production environments, misusage, or commercial use. See [License](https://github.com/dretax/GarHal_CSGO/blob/master/LICENSE.md).

## Credits & Thanks
* [Life45](https://github.com/Life45) for explaining me the basic work, pushing me to do this. Best guy eva.
* @ZeroMemory for providing videos for basic stuff.
* @hrt for a (not so much working) aimbot structure.

## Features
* Driver Hiding (Kill Patchguard before use) @JKornev
* Process Hiding (Kill Patchguard before use) @landhb
* Simple glow Wallhack
* Highlights defuser
* No flash
* Aimbot
* Smooth aimbot
* TriggerBot - Supports randomized delay.
* Another simple program to Display Ranks (Work in progress)
* Displays enemies on the Radar
* Bhop
* OBRegisterCallback to limit access to the GarhalController.exe & GarhalRankDisplayer.exe (Read VAC section)

## Changelog
* **Changes on 2020.07.31**: The driver now detects process termination. Should have coded It more faster than being lazy. The controller, and rankreader sends an IOCTL code to the driver once they have been launched, and loaded. If we would do this sooner, the applications would not start up. We are now completely re-writing the access flags, and the usermode applications should be untouchable by VAC for now. The usermode applications now wait until the addresses are not zero at startup. The plan to make an anti-aimbot was dropped. A kernel driver should be all about being non-straightforward, and used carefully to draw less attention. Please continue testing, and let me know if there are any issues.

## Patchguard?
Simple explanation: It's something that doesn't like kernel manipulation, and triggers a BSOD If detects It.
Use something like [EfiGuard](https://github.com/Mattiwatti/EfiGuard) or [UPGDSED](https://github.com/hfiref0x/UPGDSED) or [Shark](https://github.com/9176324/Shark) . I prefer the two latter.
Doing so will give you sort of full "invisibility", but It's unnecessary (imo).

## VAC
As long as you do not open a handle to the game you should be fine, but of course there are ways to detect Read/Write memories.
It's just harder without a driver, and hence they haven't really done this since 2017 I hardly think they are going to.
Here is some information from 2013, and 2016:
* [Analysis from 2013 by forcon](https://www.unknowncheats.me/wiki/Valve_Anti-Cheat:VAC_external_tool_detection_(and_more))
* [Write up from Mambda](https://guidedhacking.com/threads/how-to-bypass-vac-valve-anti-cheat-info.8125/post-42854)

Both sources talk about that VAC opens handle to processes and searches all volumes with FindFirstVolumeW, FindNextVolumeW and closes handles with FindVolumeClose.

It opens every handle running with Query_Information, and VM_READ.
Denying access with ObRegisterCallbacks to protect the controller would be more than enough to get rid of this scan.

--
After some emails I have decided to clear some things up. The project doesn't open a handle, and obviously doesn't use usermode RPM/WPM. Therefore the only detectable parts should be memory writing It self, and by VAC searching for the driver / usermode application.
As stated above you can grant yourself "invisibility" (from VAC) atleast by using the implemented driver / process hiding.
The driver also protects the usermode application from VAC's process scanning. (Stated in the VAC section)
The project files could be flagged, and can get you banned If VAC detects you are running this certain program (Checking for name / hash, but It's a really bad approach from any anti-cheat)
```C
if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
```

## A little Analysis of OverWatch
I have purchased CSGO around April-May on a separate account, which you see in the sample videos.
For 80+ hours I have been cheating on that account, for about a month or so. Revisited the game in August last time. I have used wallhack, triggerbot, aimbot without holding back and received countless reports from competetive matches. At this time being the account is still not banned for CSGO. Still, do not use it on your main accounts.

## Compilation
You will need Visual Studio 2017 atleast, and amongs that the WDK. If you don't know how to compile a Kernel Driver, you will need to google a bit, or just [click here](https://guidedhacking.com/threads/windows-kernel-mode-driver-tutorial.15201/).

## Updating offsets after a game update
Don't be a loser, dump with [GH Dumper](https://guidedhacking.com/resources/guided-hacking-offset-dumper-gh-offset-dumper.51/)

Use -insecure, and dump after.

~~Visit [hazedumper](https://github.com/frk1/hazedumper) for easy usage.~~

## Supported Windows Versions
If you don't need the csrss.exe check just remove It (memory.c, but not recommended), or update the offsets manually
for different windows versions. 

Click [Here](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_EPROCESS) to view the EPROCESS offsets.
Click [Here](https://docs.microsoft.com/en-us/windows/release-health/release-information) to view the release information site.
* Windows 10 1903
* Windows 10 1909
* Windows 10 2004
* Windows 10 2009
* Windows 10 2104

## Usage
1. Start the Driver.
2. Start CSGO.
3. Place the default config where GarhalController.exe is.
4. Modify config to your needs.
5. Start GarhalController.exe.
6. Optional: If you are playing ranked, use GarhalRankDisplayer.exe to view ranks.
7. Play the game.
8. Beware of Overwatch.

## Starting Driver
Open up CMD as admin mode:
```Bash
  # Enable testmode and reboot.
  bcdedit /set testsigning on

  # Create service and start it.
  sc create garhal type= kernel binpath="C:\Users...\Desktop\garhal.sys"
  sc start garhal
  
  # Stopping the service, bohoho...
  sc stop garhal
  
  # Disabling testmode...
  bcdedit /set testsigning off
```

## Manual mapping the driver instead of testmode
1. Uncomment the commented DriverEntry function in garhal.c.
2. Rename the current one to DriverInitialize.
3. Compile the driver with /GS- (Disable the security check).
[![IMAGE ALT TEXT HERE](https://i.imgur.com/iASLlHG.png)](https://i.imgur.com/iASLlHG.png)
4. Use kdmapper or something else to load up your driver.
5. **Optional (and recommended if you are interested in kernel, rather than being a crappy user):** Clear the MmUnloadedDrivers and PIBCache yourself, get the signature of these using WinDbg for example, don't use CreateDriver, hook an IOCTL function with a trick, or do some other type of communication. I'm not releasing practices for this for now, there is plenty available. If you manage to do these tricks you are free to attack any realistic anti-cheats with more work (BY REVERSING).
6. Reboot your PC to clear out the driver entirely from the memory if you want to play different games.

## Preview
[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ADj12ykKq-o/0.jpg)](https://www.youtube.com/watch?v=ADj12ykKq-o)
[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/lEE0W2o7WDA/0.jpg)](https://youtu.be/lEE0W2o7WDA)

```