Project Path: arc_gmh5225_EC_PRO-LAN_n2u9plxk

Source Tree:

```txt
arc_gmh5225_EC_PRO-LAN_n2u9plxk
├── README.md
├── client_android
│   ├── app
│   │   ├── build.gradle
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       ├── androidTest
│   │       │   └── java
│   │       │       └── com
│   │       │           └── example
│   │       │               └── client
│   │       │                   └── ExampleInstrumentedTest.java
│   │       ├── main
│   │       │   ├── AndroidManifest.xml
│   │       │   ├── cpp
│   │       │   │   ├── CMakeLists.txt
│   │       │   │   ├── maths.cpp
│   │       │   │   ├── maths.h
│   │       │   │   ├── native-lib.cpp
│   │       │   │   ├── socket.cpp
│   │       │   │   └── socket.h
│   │       │   ├── java
│   │       │   │   └── com
│   │       │   │       └── example
│   │       │   │           └── client
│   │       │   │               └── MainActivity.java
│   │       │   └── res
│   │       │       ├── drawable
│   │       │       │   └── ic_launcher_background.xml
│   │       │       ├── drawable-v24
│   │       │       │   └── ic_launcher_foreground.xml
│   │       │       ├── layout
│   │       │       │   └── activity_main.xml
│   │       │       ├── mipmap-anydpi-v26
│   │       │       │   ├── ic_launcher.xml
│   │       │       │   └── ic_launcher_round.xml
│   │       │       ├── mipmap-hdpi
│   │       │       │   ├── ic_launcher.png
│   │       │       │   └── ic_launcher_round.png
│   │       │       ├── mipmap-mdpi
│   │       │       │   ├── ic_launcher.png
│   │       │       │   └── ic_launcher_round.png
│   │       │       ├── mipmap-xhdpi
│   │       │       │   ├── ic_launcher.png
│   │       │       │   └── ic_launcher_round.png
│   │       │       ├── mipmap-xxhdpi
│   │       │       │   ├── ic_launcher.png
│   │       │       │   └── ic_launcher_round.png
│   │       │       ├── mipmap-xxxhdpi
│   │       │       │   ├── ic_launcher.png
│   │       │       │   └── ic_launcher_round.png
│   │       │       └── values
│   │       │           ├── colors.xml
│   │       │           ├── strings.xml
│   │       │           └── styles.xml
│   │       └── test
│   │           └── java
│   │               └── com
│   │                   └── example
│   │                       └── client
│   │                           └── ExampleUnitTest.java
│   ├── build.gradle
│   ├── gradle
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle
├── client_windows
│   ├── client_windows.sln
│   ├── client_windows.vcxproj
│   ├── client_windows.vcxproj.filters
│   ├── client_windows.vcxproj.user
│   ├── config.cfg
│   ├── cs.cpp
│   ├── cs.h
│   ├── main.cpp
│   ├── maths.cpp
│   ├── maths.h
│   ├── server.cpp
│   ├── server.h
│   ├── socket.cpp
│   └── socket.h
└── server
    ├── main.c
    ├── server.sln
    ├── server.vcxproj
    ├── server.vcxproj.filters
    ├── server.vcxproj.user
    ├── socket.c
    └── socket.h

```

`README.md`:

```md
# EC_PRO-LAN



Anti-Cheats: (FACEIT, (ESEA w/ custom version)  
Early 2019 - late 2020. R.I.P. https://h0mbre.github.io/RyzenMaster_CVE/#  

# Requirements:
Windows 10 Enterprise 1607 LTSB with all updates  
AMD Ryzen CPU  
Motherboard B350-B450 (B550 client is bugged)  
Logitech GHUB installed ( for mouse input )


# Older gen ryzen processors has maybe different Version of AmdRyzenMaster driver (1.3.0.0)
you have to then replace https://github.com/ekknod/EC_PRO-LAN/blob/main/client_windows/server.cpp#L65  
with this:  
unsigned char b_amd[] = {
        0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x4D, 0x00,
        0x44, 0x00, 0x52, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
        0x65, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x56, 0x00, 0x31, 0x00,
        0x33, 0x00, 0x00, 0x00
    } ;
 


# Installation


precompiled client: https://www.unknowncheats.me/forum/downloads.php?do=file&id=31551  
copy opengl32.dll to C:\Program Files\AMD\RyzenMaster\bin  
open amdryzenmaster utility, allow firewall  
open csgo.exe  
open client_private.exe in separate PC in your LAN network. 



# Vulnerabilities
Logitech input manipulation with their macro driver (works still ESEA/FACEIT, will work as long as logitech macros)
Copying game memory with AmdRyzenMaster vulnerability  

# Why releasing?
Because someone else found same vulnerability and made it public: https://h0mbre.github.io/RyzenMaster_CVE/#  

# Youtube Video (EC_PRO LAN android client (wifi))
[![IMAGE ALT TEXT](http://i3.ytimg.com/vi/l91pJW86KEQ/maxresdefault.jpg)](https://www.youtube.com/watch?v=l91pJW86KEQ "EC_PRO lan (android client)")


# Youtube Video (EC_PRO lan raspberry pi client)
[![IMAGE ALT TEXT](http://i3.ytimg.com/vi/qrUvuK8Hxq8/maxresdefault.jpg)](https://www.youtube.com/watch?v=qrUvuK8Hxq8&feature=youtu.be "EC_PRO lan (rasberry client)")

```

`client_android/app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 29
    buildToolsVersion "29.0.2"
    defaultConfig {
        applicationId "com.example.client"
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'androidx.appcompat:appcompat:1.0.2'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

```

`client_android/app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

`client_android/app/src/androidTest/java/com/example/client/ExampleInstrumentedTest.java`:

```java
package com.example.client;

import android.content.Context;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.example.client", appContext.getPackageName());
    }
}

```

`client_android/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.client">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
```

`client_android/app/src/main/cpp/CMakeLists.txt`:

```txt
# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.4.1)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

add_library( # Sets the name of the library.
        native-lib

        # Sets the library as a shared library.
        SHARED

        # Provides a relative path to your source file(s).
        native-lib.cpp

        socket.cpp

        maths.cpp )

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # Specifies the target library.
        native-lib

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib})
```

`client_android/app/src/main/cpp/maths.cpp`:

```cpp
#include "maths.h"
#include <math.h>


#define RAD2DEG(x) ((float)(x) * (float)(180.f / 3.14159265358979323846f))
#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))


void sin_cos(float radians, float *sine, float *cosine)
{
    *sine = (float)sin(radians);
    *cosine = (float)cos(radians);
}

void angle_vec(vec3 angles, vec3 *forward)
{
    float sp, sy, cp, cy;
    sin_cos(DEG2RAD(angles.x), &sp, &cp);
    sin_cos(DEG2RAD(angles.y), &sy, &cy);
    forward->x = cp * cy;
    forward->y = cp * sy;
    forward->z = -sp;
}


float vec_dot(vec3 v0, vec3 v1)
{
    return (v0.x * v1.x + v0.y * v1.y + v0.z * v1.z);
}


float vec_length(vec3 v)
{
    return (v.x * v.x + v.y * v.y + v.z * v.z);
}


static vec3 vec_sub(vec3 p0, vec3 p1)
{
    vec3 r;

    r.x = p0.x - p1.x;
    r.y = p0.y - p1.y;
    r.z = p0.z - p1.z;
    return r;
}


float vec_length_sqrt(vec3 p0)
{
    return ( float )sqrt(p0.x * p0.x + p0.y * p0.y + p0.z * p0.z);
}


vec3 vec_delta(vec3 p0, vec3 p1)
{
    vec3  d;
    float l;

    d   = vec_sub(p0, p1);
    l   = (float)vec_length_sqrt(d);
    d.x /= l; d.y /= l; d.z /= l;
    return d;
}


float vec_distance(vec3 p0, vec3 p1)
{
    return vec_length_sqrt( vec_sub(p0, p1) ) ;
}


void vec_clamp(vec3 *v)
{
    if ( v->x > 89.0f && v->x <= 180.0f ) {
        v->x = 89.0f;
    }
    if ( v->x > 180.0f ) {
        v->x = v->x - 360.0f;
    }
    if( v->x < -89.0f ) {
        v->x = -89.0f;
    }
    v->y = fmodf(v->y + 180, 360) - 180;
    v->z = 0;
}



void vec_normalize(vec3 *vec)
{
    float radius;

    radius = 1.f / (float)(sqrt(vec->x*vec->x + vec->y*vec->y + vec->z*vec->z) + 1.192092896e-07f);
    vec->x *= radius, vec->y *= radius, vec->z *= radius;
}


vec3 vec_transform(vec3 p0, matrix3x4_t p1)
{
    vec3 v;

    v.x = (p0.x * p1[0][0] + p0.y * p1[0][1] + p0.z * p1[0][2]) + p1[0][3];
    v.y = (p0.x * p1[1][0] + p0.y * p1[1][1] + p0.z * p1[1][2]) + p1[1][3];
    v.z = (p0.x * p1[2][0] + p0.y * p1[2][1] + p0.z * p1[2][2]) + p1[2][3];
    return v;
}


vec3 vec_atd(vec3 vangle)
{
    double y[2], p[2];

    vangle.x *= (3.14159265358979323846f / 180.f);
    vangle.y *= (3.14159265358979323846f / 180.f);
    y[0]     = sin(vangle.y), y[1] = cos(vangle.y);
    p[0]     = sin(vangle.x), p[1] = cos(vangle.x);
    vangle.x = (float)(p[1] * y[1]);
    vangle.y = (float)(p[1] * y[0]);
    vangle.z = (float)-p[0];
    return vangle;
}


bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius)
{
    vec3     delta;
    uint32_t i;
    vec3     q;
    float    v;


    //
    // original maths by superdoc1234
    //
    delta = vec_delta(max, min);
    for ( i = 0; i < vec_distance(min, max); i++ ) {
        q.x = min.x + delta.x * (float)i - eye.x;
        q.y = min.y + delta.y * (float)i - eye.y;
        q.z = min.z + delta.z * (float)i - eye.z;
        if ((v = vec_dot(q, dir)) < 1.0f) {
            return 0;
        }
        v = radius * radius - (vec_length(q) - v * v);

        if ( v <= -100.f ) {
            return 0;
        }
        if (v >= 1.19209290E-07F) {
            return 1;
        }
    }
    return 0;
}


void vec_angles(vec3 forward, vec3 *angles)
{
    float tmp, yaw, pitch;

    if (forward.y == 0.f && forward.x == 0.f) {
        yaw = 0;
        if (forward.z > 0) {
            pitch = 270;
        } else {
            pitch = 90.f;
        }
    } else {
        yaw = (float)(atan2(forward.y, forward.x) * 180.f / 3.14159265358979323846f);
        if (yaw < 0) {
            yaw += 360.f;
        }
        tmp = (float)sqrt(forward.x * forward.x + forward.y * forward.y);
        pitch = (float)(atan2(-forward.z, tmp) * 180.f / 3.14159265358979323846f);
        if (pitch < 0) {
            pitch += 360.f;
        }
    }
    angles->x = pitch;
    angles->y = yaw;
    angles->z = 0.f;
}

float get_fov(vec3 vangle, vec3 angle)
{
    vec3 a0, a1;

    angle_vec(vangle, &a0);
    angle_vec(angle, &a1);
    return RAD2DEG(acos(vec_dot(a0, a1) / vec_length(a0)));
}

float get_fov_distance(vec3 vangle, vec3 angle, float distance)
{
    vec3 a0, a1;

    angle_vec(vangle, &a0);
    angle_vec(angle, &a1);
    return RAD2DEG((acos(vec_dot(a0, a1) / vec_length(a0))) * distance);
}

vec3 calc_angle(vec3 src, vec3 dst)
{
	vec3 m = dst;
	vec3 c = src;
	c.x = m.x - c.x;
	c.y = m.y - c.y;
	c.z = m.z - c.z;
	vec_normalize(&c);
	vec_angles(c, &c);
	vec_clamp(&c);
	return c;
}

void CalcAngle( float *src, float *dst, float *angles )
{
	double delta[3] = { (src[0]-dst[0]), (src[1]-dst[1]), (src[2] - dst[2]) };
	double hyp = sqrt(delta[0]*delta[0] + delta[1]*delta[1]);
	angles[0] = (float) (asinf(delta[2]/hyp) * 57.295779513082f);
	angles[1] = (float) (atanf(delta[1]/delta[0]) * 57.295779513082f);

	if(delta[0] >= 0.0)
		angles[1] += 180.0f;
}


```

`client_android/app/src/main/cpp/maths.h`:

```h
#ifndef MATHS_H
#define MATHS_H


#include <inttypes.h>

#ifndef __cplusplus
typedef int bool;
#endif

typedef struct {
	float x, y;
} vec2 ;

typedef struct {
    int x, y;
} vec2i ;

typedef struct {
	float x, y, z;
} vec3 ;
typedef float matrix3x4_t[3][4];

/* translate maths to only X, Y */


void angle_vec(vec3 angles, vec3 *forward);
float vec_dot(vec3 v0, vec3 v1);
float vec_length(vec3 v);
float vec_length_sqrt(vec3 p0);
vec3 vec_delta(vec3 p0, vec3 p1);
float vec_distance(vec3 p0, vec3 p1);
void vec_clamp(vec3 *v);
void vec_normalize(vec3 *vec);
vec3 vec_transform(vec3 p0, matrix3x4_t p1);
vec3 vec_atd(vec3 vangle);
bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius);
void vec_angles(vec3 forward, vec3 *angles);
float get_fov(vec3 vangle, vec3 angle);
float get_fov_distance(vec3 vangle, vec3 angle, float distance);
vec3 calc_angle(vec3 src, vec3 dst);
void CalcAngle( float *src, float *dst, float *angles );
#endif


```

`client_android/app/src/main/cpp/native-lib.cpp`:

```cpp
#include <jni.h>
#include <string>
#include <ctime>
#include <sys/time.h>
#include <sys/resource.h>
#include <cstdint>
#include <android/log.h>
#include <unistd.h>

#include "socket.h"
#include "maths.h"

#define LOG_TAG "dbg"
#define LOG(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

static double get_time()
{
    struct timeval t;
    struct timezone tzp;
    gettimeofday(&t, &tzp);
    return t.tv_sec + t.tv_usec*1e-6;
}

void NtSleep(int ms)
{
    usleep(ms*1000);
}


int NtRand()
{
    struct timespec info;
    clock_gettime(4, &info);
    srand(info.tv_nsec);
    return rand();
}


int check_player_pos(const char* buf, int len, int init);
int is_player_valid;
static uint64_t g_system_pml4;
static uint64_t g_system_process;
static uint64_t g_process_pml4;
static uint64_t g_process;
static uint32_t g_client_dll;
static uint32_t g_engine_dll;
static uint32_t g_vstdlib_dll;
static uint32_t g_inputsystem_dll;
static uint32_t vt_client;
static uint32_t vt_entity;
static uint32_t vt_engine;
static uint32_t vt_cvar;
static uint32_t vt_input;
static uint32_t DT_BasePlayer;
static uint32_t DT_BaseEntity;
static uint32_t DT_CSPlayer;
static uint32_t DT_BaseAnimating;
static uint32_t m_vecViewOffset;
static uint32_t m_iHealth;
static uint32_t m_nTickBase;
static uint32_t m_lifeState;
static uint32_t m_vecPunch;
static uint32_t m_vecOrigin;
static uint32_t m_iTeamNum;
static uint32_t m_hActiveWeapon;
static uint32_t m_iCrossHairID;
static uint32_t m_bHasDefuser;
static uint32_t m_bIsDefusing;
static uint32_t m_flFlashDuration;
static uint32_t m_iShotsFired;
static uint32_t m_dwBoneMatrix;
static uint32_t m_dwEntityList;
static uint32_t m_dwClientState;
static uint32_t m_dwGetLocalPlayer;
static uint32_t m_dwGetViewAngles;
static uint32_t m_dwGetMaxClients;
static uint32_t m_dwState;
static uint32_t m_bDormant = 0xED;
static uint32_t m_dwButton;
static uint32_t m_dwAnalog;
static uint32_t m_dwAnalogDelta;
static uint32_t g_local_index;
static uint32_t g_local_address;
static uint32_t g_target_address;
static uint32_t g_target_id;
static uint32_t g_mouse_1, g_mouse_5;
static vec2i    g_mouse_delta;
static vec2i    g_mouse_analog;
static int      g_crosshair_id;
static vec3     g_eyepos;
static vec3     g_vecpunch;
static int      g_shots_fired;
static int      g_current_tick, g_previous_tick;
static vec3     g_viewangles;
static int      g_target_health;
static vec3     g_target_bone;
static float    g_best_fov;
static int      g_has_target;
static bool     g_is_visible;
static int      g_valid_target_count;
static float    g_positions[40];
static int      g_defusing;
static int      esea;
static int      m_dwGetPlayerInfo;


#define JUHO_BUILD
#define JUHO_OLD_GHUB



struct tcp_entry_address {
    struct tcp_entry ehdr;
#if INTPTR_MAX == INT32_MAX
    uint32_t wow64fix;
#endif
    uint64_t address;
};

struct tcp_entry_device {
    struct tcp_entry entry;
#if INTPTR_MAX == INT32_MAX
    uint32_t wow64fix;
#endif
    uint64_t stack_address;
    char name[120];
};

struct tcp_entry_copy64 {
    struct tcp_entry ehdr;
#if INTPTR_MAX == INT32_MAX
    uint32_t wow64fix;
#endif
    uint64_t dir_entry;
    uint64_t address;
};

struct tcp_entry_copy64p {
    struct tcp_entry ehdr;
    uint16_t prev;
    uint64_t dir_entry;
    uint64_t address;
};

struct tcp_entry_copy {
    struct tcp_entry ehdr;
#if INTPTR_MAX == INT32_MAX
    uint32_t wow64fix;
#endif
    uint64_t dir_entry;
    uint64_t address;
    uint32_t length;
};

struct tcp_entry_copyp {
    struct tcp_entry ehdr;
    uint16_t prev;
    uint64_t dir_entry;
    uint64_t address;
    uint32_t length;
};

struct tcp_entry_mouse {
    struct tcp_entry ehdr;
    char button;
	char x;
	char y;
	char wheel;
	char unk1;
};

#define STACK_ADD_FUNCTION(e,d) { \
	(e)->id = 1; \
	(e)->next = 4 + sizeof(d); \
	memcpy(((char *)e + 4), d, sizeof(d)); \
	e = (struct tcp_entry *)(e + 1); \
	e = (struct tcp_entry *)((char *)e + sizeof(d)); \
}

/* we have to use this, if we dont have anything else to call in stack */
#define STACK_EMPTY_FUNCTION(e,n,i) { \
	(e)->id = (i); \
	(e)->next = (n); \
	e = (struct tcp_entry *)(e + 1); \
}

#define STACK_END_FUNCTION STACK_EMPTY_FUNCTION
#define STACK_GET_HEAP STACK_EMPTY_FUNCTION
#define STACK_ADD_SYSTEM_PROCESS STACK_EMPTY_FUNCTION
#define STACK_ADD_PML4 STACK_EMPTY_FUNCTION

#define STACK_CLEAR_FUNCTIONS(e, n) { \
	(e)->id = (2); \
	(e)->next = n; \
	e = (struct tcp_entry *)(e + 1); \
}

#define STACK_ADD_ADDRESS(e,i,n,m,x) { \
	(e)->id = (i); \
	(e)->next = (n); \
	((uint32_t*)&(((struct tcp_entry_address*)e))->address)[0] = (m); \
	((uint32_t*)&(((struct tcp_entry_address*)e))->address)[1] = (x); \
	e = (struct tcp_entry *)((struct tcp_entry_address*)e + 1); \
}

#define STACK_GET_ADDRESS(e,i,n,f) { \
	(e)->id = (i); \
	(e)->next = (n); \
	(((struct tcp_entry_address*)e))->address = (f); \
	e = (struct tcp_entry *)((struct tcp_entry_address*)e + 1); \
}

#define STACK_ADD_DEVICE(e,i,n,a,b) { \
	(e)->id = (i); \
	(e)->next = (n); \
	((struct tcp_entry_device *)e)->stack_address = (a); \
	memcpy(((struct tcp_entry_device *)e)->name, b, sizeof(b)); \
	e = (struct tcp_entry *)((struct tcp_entry_device*)e + 1); \
}

#define STACK_ADD_VM_COPY(e,n,a,d,l) { \
	(e)->id = (7); \
	(e)->next = (n); \
	((struct tcp_entry_copy *)e)->address = (a); \
	((struct tcp_entry_copy *)e)->length = (l); \
	((struct tcp_entry_copy *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy*)e + 1); \
	e = (struct tcp_entry *)((char *)e + l); \
}

#define STACK_ADD_VM_COPY_P32(e,n,p,a,d,l) { \
	(e)->id = (8); \
	(e)->next = (n); \
	((struct tcp_entry_copyp*)e)->prev = (p); \
	((struct tcp_entry_copyp*)e)->address = (a); \
	((struct tcp_entry_copyp*)e)->length = (l); \
	((struct tcp_entry_copyp*)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copyp*)e + 1); \
}

#define STACK_ADD_VM_COPY_P64(e,n,p,a,d,l) { \
	(e)->id = (9); \
	(e)->next = (n); \
	((struct tcp_entry_copyp*)e)->prev = (p); \
	((struct tcp_entry_copyp*)e)->address = (a); \
	((struct tcp_entry_copyp*)e)->length = (l); \
	((struct tcp_entry_copyp*)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copyp*)e + 1); \
}

#define STACK_ADD_VM_COPY64(e,n,a,d) { \
	(e)->id = (10); \
	(e)->next = (n); \
	((struct tcp_entry_copy64 *)e)->address = (a); \
	((struct tcp_entry_copy64 *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64*)e + 1); \
}

#define STACK_ADD_VM_COPY64_P32(e,n,p,a,d) { \
	(e)->id = (11); \
	(e)->next = (n); \
	((struct tcp_entry_copy64p *)e)->prev = (p); \
	((struct tcp_entry_copy64p *)e)->address = (a); \
	((struct tcp_entry_copy64p *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64p*)e + 1); \
}

#define STACK_ADD_VM_COPY64_P64(e,n,p,a,d) { \
	(e)->id = (12); \
	(e)->next = (n); \
	((struct tcp_entry_copy64p *)e)->prev = (p); \
	((struct tcp_entry_copy64p *)e)->address = (a); \
	((struct tcp_entry_copy64p *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64p*)e + 1); \
}

#define STACK_ADD_MOUSE(e,n,b,x,y,w) { \
	(e)->id = (13); \
	(e)->next = (n); \
	((struct tcp_entry_mouse*)e)->button = (b); \
	((struct tcp_entry_mouse*)e)->x = (x); \
	((struct tcp_entry_mouse*)e)->y = (y); \
	((struct tcp_entry_mouse*)e)->wheel = (w); \
	((struct tcp_entry_mouse*)e)->unk1 = (0); \
	e = (struct tcp_entry *)((struct tcp_entry_mouse*)e + 1); \
}

#define STACK_ADD_GPA STACK_ADD_ADDRESS

#define STACK_EXECUTE(h, e) { \
	(h)->size = 4; \
	(h)->retn = 1; \
	(h)->status = 1; \
	socket_send(h, (int)((char *)e - (char*)h)); \
	socket_recv(h, 1400); \
	e = (struct tcp_entry*)(h + 1); \
}

#define STACK_EXECUTE_NO_RETURN(h, e) { \
	(h)->size = 4; \
	(h)->retn = 0; \
	socket_send(h, (int)((char *)e - (char*)h)); \
	e = (struct tcp_entry*)(h + 1); \
}


#define STACK_ADD_VIRTUAL_FUNCTION(e, v, i) { \
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), v, g_process_pml4); \
	STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), i * 4, g_process_pml4); \
}

static char impl_upper(char c)
{
    if (c >= 97)
        c -= 32;
    return c;
}

static int impl_strcmp(const char *rcx, const char *rdx)
{
    int eax = 0;
    char r8b;
    while (1) {
        r8b = impl_upper(*(char*)(rcx + eax));
        if (r8b != impl_upper(*(char*)(rdx + eax)))
            break;
        if (r8b == 0)
            break;
        eax = eax + 1;
    }
    r8b -= *(char*)(rdx + eax);
    eax = r8b;
    return eax;
}

static int prev_tick = 0;

/* we dont have wchar_t in linux, we have to implement it */
static int impl_wcscmp(const char *rcx, const char *rdx)
{
    int eax = 0;
    char r8b;
    while (1) {
        r8b = impl_upper(*(char*)(rcx));
        if (r8b != impl_upper(*(char*)(rdx + eax)))
            break;
        if (r8b == 0)
            break;
        rcx = rcx + 1;
        eax = eax + 2;
    }
    r8b -= *(char*)(rdx + eax);
    eax = r8b;
    return eax;
}


uint32_t device_initialize(void)
{
    unsigned char b_get_proc_address[] = {
            0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xD1, 0x4C, 0x8B, 0x40, 0x18, 0x8B, 0x42, 0x08, 0x4D,
            0x8B, 0x48, 0x20, 0x85, 0xC0, 0x74, 0x0E, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x4D, 0x8B, 0x09, 0x48, 0x83, 0xE8, 0x01, 0x75,
            0xF7, 0x4D, 0x8B, 0x49, 0x20, 0x41, 0x0F, 0xB7, 0x41, 0x3C, 0x42, 0x8B, 0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x42,
            0x0C, 0x42, 0x2B, 0x44, 0x09, 0x10, 0x42, 0x8B, 0x4C, 0x09, 0x1C, 0x49, 0x03, 0xC9, 0x44, 0x8B, 0x04, 0x81, 0x41, 0x0F,
            0xB7, 0x02, 0x4D, 0x03, 0xC1, 0x4E, 0x89, 0x04, 0x10, 0x66, 0x41, 0x83, 0x02, 0x08, 0xC3
    } ;
    unsigned char b_set_system_process[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55,
            0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0xBD, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B,
            0xF2, 0x48, 0x8B, 0xF9, 0xFF, 0xD5, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x49, 0xBC, 0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00,
            0x00, 0x44, 0x8D, 0x42, 0x20, 0x41, 0xFF, 0xD4, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x49, 0xBF, 0xF0, 0x80, 0xAD, 0x71,
            0xFE, 0x7F, 0x00, 0x00, 0x4D, 0x8B, 0xCF, 0x48, 0x8B, 0xD0, 0x49, 0xBD, 0xF0, 0x60, 0xAD, 0x74, 0xFE, 0x7F, 0x00, 0x00,
            0x48, 0x8B, 0xD8, 0x41, 0x8D, 0x48, 0xF0, 0x41, 0xFF, 0xD5, 0x49, 0xBE, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00,
            0x3D, 0x04, 0x00, 0x00, 0xC0, 0x75, 0x6C, 0xA1, 0xF0, 0x80, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00,
            0x00, 0xA3, 0xF0, 0x80, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD5, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC3, 0x33, 0xD2,
            0x41, 0xFF, 0xD6, 0x41, 0x8B, 0x1F, 0xFF, 0xD5, 0x48, 0x8B, 0xC8, 0x44, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD4, 0x45,
            0x8B, 0x07, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xD8, 0x41, 0x8D, 0x49, 0x10, 0x41, 0xFF, 0xD5, 0x85, 0xC0,
            0x75, 0x21, 0x48, 0x8B, 0x43, 0x10, 0x48, 0xA3, 0xF0, 0x90, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD5, 0x48, 0x8B,
            0xC8, 0x4C, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD6, 0x66, 0x83, 0x07, 0x08, 0xEB, 0x16, 0xFF, 0xD5, 0x48, 0x8B, 0xC8,
            0x4C, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD6, 0x33, 0xC0, 0xC6, 0x47, 0x03, 0x00, 0x66, 0x89, 0x06, 0x48, 0x8B, 0x5C,
            0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5E,
            0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3
    } ;
    unsigned char b_open_device[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20,
            0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x60, 0x66, 0x83, 0x7A, 0x10, 0x00, 0x48, 0x8D, 0x6A, 0x10, 0x4C,
            0x8B, 0xFA, 0x4C, 0x8B, 0xF1, 0x48, 0x8B, 0xDD, 0x74, 0x0A, 0x48, 0x83, 0xC3, 0x02, 0x66, 0x83, 0x3B, 0x00, 0x75, 0xF6,
            0x49, 0xBC, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x41, 0xFF, 0xD4, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x48, 0xBF,
            0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x10, 0xFF, 0xD7, 0x48, 0x8B, 0xF0, 0x41, 0xFF, 0xD4,
            0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x44, 0x8D, 0x42, 0x30, 0xFF, 0xD7, 0x48, 0x89, 0x6E, 0x08, 0x49, 0x2B, 0xDF, 0x33, 0xED,
            0x48, 0x83, 0xEB, 0x10, 0x89, 0x6C, 0x24, 0x50, 0x48, 0x8B, 0xF8, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x4C, 0x8B, 0xC8, 0xC7,
            0x44, 0x24, 0x40, 0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC0, 0xC7, 0x44, 0x24, 0x38, 0x03, 0x00, 0x00, 0x00, 0xBA, 0x00,
            0x00, 0x10, 0xC0, 0x48, 0xD1, 0xFB, 0x66, 0x03, 0xDB, 0x89, 0x6C, 0x24, 0x30, 0x66, 0x89, 0x1E, 0x66, 0x83, 0xC3, 0x02,
            0x66, 0x89, 0x5E, 0x02, 0xC7, 0x00, 0x30, 0x00, 0x00, 0x00, 0x48, 0x89, 0x68, 0x08, 0x89, 0x68, 0x18, 0x48, 0x89, 0x70,
            0x10, 0x48, 0x89, 0x68, 0x20, 0x48, 0x89, 0x68, 0x28, 0x48, 0xB8, 0xD0, 0x64, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x49,
            0x8B, 0x4F, 0x08, 0xC7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0xD0, 0x8B, 0xD8,
            0x41, 0xFF, 0xD4, 0x4C, 0x8B, 0xC6, 0x48, 0x8B, 0xC8, 0x48, 0xBE, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x33,
            0xD2, 0xFF, 0xD6, 0x41, 0xFF, 0xD4, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC7, 0x33, 0xD2, 0xFF, 0xD6, 0x85, 0xDB, 0x74, 0x0B,
            0x41, 0xC7, 0x06, 0x04, 0x00, 0x01, 0x00, 0x66, 0x41, 0x89, 0x2F, 0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x20,
            0x49, 0x8B, 0x6B, 0x28, 0x49, 0x8B, 0x73, 0x30, 0x49, 0x8B, 0x7B, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41,
            0x5C, 0xC3
    } ;


/*

    unsigned char b_amd[] = {
		0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x4D, 0x00,
		0x44, 0x00, 0x52, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x56, 0x00, 0x31, 0x00,
		0x33, 0x00, 0x00, 0x00
	} ;

*/

    unsigned char b_amd[] = {
            0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x4D, 0x00,
            0x44, 0x00, 0x52, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
            0x65, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x56, 0x00, 0x31, 0x00,
            0x36, 0x00, 0x00, 0x00
    } ;




    unsigned char b_logitech[] = {
            0x5C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x52, 0x00, 0x4F, 0x00, 0x4F, 0x00, 0x54, 0x00, 0x23, 0x00, 0x53, 0x00,
            0x59, 0x00, 0x53, 0x00, 0x54, 0x00, 0x45, 0x00, 0x4D, 0x00, 0x23, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31, 0x00,
            0x23, 0x00, 0x7B, 0x00, 0x31, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x30, 0x00, 0x35, 0x00, 0x63, 0x00, 0x30, 0x00,
            0x2D, 0x00, 0x63, 0x00, 0x33, 0x00, 0x37, 0x00, 0x38, 0x00, 0x2D, 0x00, 0x34, 0x00, 0x31, 0x00, 0x62, 0x00, 0x39, 0x00,
            0x2D, 0x00, 0x39, 0x00, 0x63, 0x00, 0x65, 0x00, 0x66, 0x00, 0x2D, 0x00, 0x64, 0x00, 0x66, 0x00, 0x31, 0x00, 0x61, 0x00,
            0x62, 0x00, 0x61, 0x00, 0x38, 0x00, 0x32, 0x00, 0x62, 0x00, 0x30, 0x00, 0x31, 0x00, 0x35, 0x00, 0x7D, 0x00, 0x00, 0x00
    } ;




    unsigned char b_copy_pml4[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x48, 0xBF, 0xC9, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xBE, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x3F, 0xFF, 0xD6,
            0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x48, 0xB8, 0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0xFF,
            0xD0, 0xC7, 0x44, 0x24, 0x48, 0x14, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9,
            0xC7, 0x44, 0x24, 0x38, 0x0C, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x30, 0x33, 0xD2, 0x48, 0xC7,
            0x00, 0xA0, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xC7, 0x40, 0x08, 0x08, 0x00, 0x00, 0x00, 0x48, 0xB8, 0xC8, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x28, 0x08, 0x2F, 0x11, 0x81, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0xB8,
            0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8B, 0x43, 0x0C, 0x48, 0xA3, 0xC7, 0xDD, 0xA9, 0x79,
            0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD6, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC3, 0x48, 0xB8, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F,
            0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x50, 0x5F, 0x48,
            0xFF, 0xE0
    } ;
    unsigned char b_copy_memory[] = {
            0x48, 0x83, 0xEC, 0x58, 0x48, 0x8B, 0xC1, 0x48, 0xB9, 0x00, 0x00, 0x38, 0x1F, 0x04, 0x00, 0x00, 0x00, 0x48, 0x3B, 0xC1,
            0x0F, 0x87, 0x83, 0x00, 0x00, 0x00, 0x49, 0xB8, 0xD3, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB9, 0xC9, 0xDD,
            0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0x09, 0x48, 0xA3, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F,
            0x00, 0x00, 0x8B, 0xC2, 0xA3, 0xCF, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x8D, 0x42, 0x0C, 0x89, 0x44, 0x24, 0x48,
            0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x8B, 0xD2, 0x49, 0x03, 0xD0,
            0xC7, 0x44, 0x24, 0x38, 0x0C, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x45, 0x33, 0xC0, 0xC7, 0x44, 0x24, 0x28,
            0x08, 0x2F, 0x11, 0x81, 0x48, 0xB8, 0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x20, 0x33,
            0xD2, 0xFF, 0xD0, 0x33, 0xC9, 0x85, 0xC0, 0x0F, 0x94, 0xC1, 0x8B, 0xC1, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0x33, 0xC0, 0x48,
            0x83, 0xC4, 0x58, 0xC3
    } ;
    unsigned char b_translate[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20,
            0x48, 0x8B, 0xC2, 0x48, 0x8B, 0xDA, 0x48, 0xC1, 0xE8, 0x27, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00,
            0x48, 0xBD, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5, 0x85, 0xC0, 0x0F, 0x84,
            0xC5, 0x00, 0x00, 0x00, 0x48, 0xBF, 0xD3, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0xC1, 0xE9,
            0x1E, 0x48, 0xBE, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x81, 0xE1, 0xFF, 0x01, 0x00, 0x00, 0xBA, 0x08, 0x00,
            0x00, 0x00, 0x48, 0x8B, 0x07, 0x48, 0x23, 0xC6, 0x48, 0x8D, 0x0C, 0xC8, 0xFF, 0xD5, 0x85, 0xC0, 0x0F, 0x84, 0x8B, 0x00,
            0x00, 0x00, 0x48, 0x8B, 0x0F, 0x84, 0xC9, 0x79, 0x18, 0x48, 0xB8, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0x0F, 0x00, 0x81,
            0xE3, 0xFF, 0xFF, 0xFF, 0x3F, 0x48, 0x23, 0xC1, 0x48, 0x03, 0xC3, 0xEB, 0x6E, 0x48, 0x23, 0xCE, 0x48, 0x8B, 0xC3, 0x48,
            0xC1, 0xE8, 0x15, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5, 0x85,
            0xC0, 0x74, 0x4E, 0x48, 0x8B, 0x0F, 0x84, 0xC9, 0x79, 0x18, 0x48, 0xB8, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
            0x81, 0xE3, 0xFF, 0xFF, 0x1F, 0x00, 0x48, 0x23, 0xC1, 0x48, 0x03, 0xC3, 0xEB, 0x31, 0x48, 0x23, 0xCE, 0x48, 0x8B, 0xC3,
            0x48, 0xC1, 0xE8, 0x0C, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5,
            0x85, 0xC0, 0x74, 0x11, 0x48, 0x8B, 0x07, 0x81, 0xE3, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x23, 0xC6, 0x48, 0x03, 0xC3, 0xEB,
            0x02, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83,
            0xC4, 0x20, 0x5F, 0xC3
    } ;
    unsigned char b_vmcopy[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0x52, 0x10,
            0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48,
            0x8B, 0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6,
            0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5,
            0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9,
            0xC1, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F,
            0x00, 0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_vmcopy_p32[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x48, 0x8B, 0xFA, 0x44, 0x0F, 0xB7,
            0x01, 0x48, 0x8B, 0xD9, 0x4C, 0x2B, 0xC0, 0x41, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48, 0x8B,
            0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD,
            0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5, 0xDD,
            0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9, 0xC1,
            0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00,
            0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_vmcopy_p64[] = {
            0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x48, 0x8B, 0xFA, 0x44, 0x0F, 0xB7,
            0x01, 0x48, 0x8B, 0xD9, 0x4C, 0x2B, 0xC0, 0x49, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48, 0x8B,
            0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD,
            0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5, 0xDD,
            0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9, 0xC1,
            0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00,
            0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_vmcopy64[] = {
            0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xC2, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x48, 0x08,
            0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00,
            0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
            0x00, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9,
            0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48,
            0x83, 0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_vmcopy64_p32[] = {
            0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x4C, 0x8B, 0xCA, 0x44, 0x0F, 0xB7, 0x01, 0x48, 0x8B, 0xD9,
            0x4C, 0x2B, 0xC0, 0x41, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
            0x00, 0x48, 0x8B, 0x52, 0x10, 0x49, 0x8B, 0x49, 0x08, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x48,
            0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9, 0x79,
            0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00,
            0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9, 0x79,
            0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48, 0x83,
            0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_vmcopy64_p64[] = {
            0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x4C, 0x8B, 0xCA, 0x44, 0x0F, 0xB7, 0x01, 0x48, 0x8B, 0xD9,
            0x4C, 0x2B, 0xC0, 0x49, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
            0x00, 0x48, 0x8B, 0x52, 0x10, 0x49, 0x8B, 0x49, 0x08, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x48,
            0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9, 0x79,
            0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00,
            0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9, 0x79,
            0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48, 0x83,
            0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
    } ;
    unsigned char b_move_mouse[] = {
            0x53, 0x48, 0x83, 0xEC, 0x58, 0x33, 0xC0, 0x48, 0x83, 0xC2, 0x04, 0x48, 0x8B, 0xD9, 0x89, 0x44, 0x24, 0x48, 0x48, 0xB9,
            0xC9, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9, 0xC7, 0x44, 0x24, 0x38,
            0x05, 0x00, 0x00, 0x00, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x30, 0x45,
            0x33, 0xC0, 0x48, 0x8B, 0x09, 0x33, 0xD2, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x20, 0x2A, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20,
            0x48, 0xB8, 0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x89, 0x04, 0x19, 0x66, 0x83,
            0x03, 0x04, 0x48, 0x83, 0xC4, 0x58, 0x5B, 0xC3
    } ;
    unsigned char b_copy_i64[] = {
            0x0F, 0xB7, 0x11, 0x48, 0xA1, 0xC6, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x04, 0x0A, 0x66, 0x83, 0x01,
            0x08, 0xC3
    } ;


    unsigned char b_NtCreateFile[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x55, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };
    unsigned char b_NtDeviceIoControlFile[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };
    unsigned char b_NtQuerySystemInformation[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x36, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };

    char payload[1400];
    uint8_t status = 1;
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;

    uint64_t address_NtDeviceIoControlFile;
    uint64_t address_memcpy;
    uint64_t address_memset;
    uint64_t address_HeapAlloc;
    uint64_t address_GetProcessHeap;
    uint64_t address_HeapFree;
    uint64_t heap_memory;
    uint64_t copy_memory;
    uint64_t translate_address;

    hdr = (struct tcp_header*)(payload);
    ehdr = (struct tcp_entry*)(hdr + 1);

    STACK_GET_ADDRESS(ehdr, 0, 0, 15);
    STACK_EXECUTE(hdr, ehdr);
    if (*(uint64_t*)((char *)hdr+4) != 0)
        goto skip;

    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_FUNCTION(ehdr, b_get_proc_address);
    STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 2219); /* memcpy */
    STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 2223); /* memset */
    STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 701);  /* HeapAlloc */
    STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 2, 692);  /* GetProcessHeap */
    STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 2, 841);  /* HeapFree */
    STACK_GET_HEAP(ehdr, sizeof(struct tcp_entry), 3); /* heap memory address */
    STACK_ADD_FUNCTION(ehdr, b_NtCreateFile);
    STACK_ADD_FUNCTION(ehdr, b_NtDeviceIoControlFile);
    STACK_ADD_FUNCTION(ehdr, b_NtQuerySystemInformation);
    STACK_GET_ADDRESS(ehdr, 0, sizeof(struct tcp_entry_address), 5);
    STACK_GET_ADDRESS(ehdr, 0, sizeof(struct tcp_entry_address), 6);
    STACK_GET_ADDRESS(ehdr, 0, 0, 7);
    STACK_EXECUTE(hdr, ehdr);
    if (status != 1) {
        return 0;
    }

    address_memcpy = *(uint64_t*)((char *)hdr+4);
    address_memset = *(uint64_t*)((char *)hdr+12);
    address_HeapAlloc = *(uint64_t*)((char *)hdr+20);
    address_GetProcessHeap = *(uint64_t*)((char *)hdr+28);
    address_HeapFree = *(uint64_t*)((char *)hdr+36);
    heap_memory = *(uint64_t*)((char *)hdr+44);

    *(uint64_t*)(b_set_system_process + 0x1c + 2) = address_GetProcessHeap;
    *(uint64_t*)(b_set_system_process + 0x33 + 2) = address_HeapAlloc;
    *(uint64_t*)(b_set_system_process + 0x4a + 2) = heap_memory;
    *(uint64_t*)(b_set_system_process + 0x5a + 2) = *(uint64_t*)((char *)hdr+68);
    *(uint64_t*)(b_set_system_process + 0x6e + 2) = address_HeapFree;
    *(uint64_t*)(b_set_system_process + 0x7f + 1) = heap_memory;
    *(uint64_t*)(b_set_system_process + 0x8d + 1) = heap_memory;
    *(uint64_t*)(b_set_system_process + 0xce + 2) = heap_memory + 4096;

    *(uint64_t*)(b_open_device + 0x3c + 2) = address_GetProcessHeap;
    *(uint64_t*)(b_open_device + 0x4e + 2) = address_HeapAlloc;
    *(uint64_t*)(b_open_device + 0xd1 + 2) = *(uint64_t*)((char *)hdr+52);
    *(uint64_t*)(b_open_device + 0xf9 + 2) = address_HeapFree;

    *(uint64_t*)(b_copy_pml4 + 0x0f + 2) = (heap_memory + 4096 + 8);
    *(uint64_t*)(b_copy_pml4 + 0x19 + 2) = address_GetProcessHeap;
    *(uint64_t*)(b_copy_pml4 + 0x2d + 2) = address_HeapAlloc;
    *(uint64_t*)(b_copy_pml4 + 0x73 + 2) = heap_memory;
    *(uint64_t*)(b_copy_pml4 + 0x8a + 2) = *(uint64_t*)((char *)hdr+60);
    *(uint64_t*)(b_copy_pml4 + 0x9a + 2) = (heap_memory + 4096 + 24);
    *(uint64_t*)(b_copy_pml4 + 0xac + 2) = address_HeapFree;

    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_FUNCTION(ehdr, b_set_system_process);
    STACK_ADD_FUNCTION(ehdr, b_open_device);
    STACK_ADD_FUNCTION(ehdr, b_copy_pml4);
    STACK_ADD_SYSTEM_PROCESS(ehdr, sizeof(struct tcp_entry), 8);
    STACK_ADD_DEVICE(ehdr, 9, sizeof(struct tcp_entry_device), (uint64_t)(heap_memory + 4096 + 8), b_amd);
    STACK_ADD_DEVICE(ehdr, 9, sizeof(struct tcp_entry_device), (uint64_t)(heap_memory + 4096 + 16), b_logitech);
    STACK_ADD_PML4(ehdr, 0, 10);
    STACK_EXECUTE(hdr, ehdr);
    status = hdr->status;
    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_CLEAR_FUNCTIONS(ehdr, sizeof(struct tcp_entry));
    STACK_ADD_FUNCTION(ehdr, b_NtDeviceIoControlFile);
    STACK_GET_ADDRESS(ehdr, 0, 0, 4);
    STACK_EXECUTE(hdr, ehdr);
    if (status != 1) {
        return 0;
    }

    address_NtDeviceIoControlFile = *(uint64_t*)((char *)hdr+4);
    *(uint64_t*)(b_copy_memory + 0x1A + 2) = heap_memory + 12;
    *(uint64_t*)(b_copy_memory + 0x24 + 2) = (heap_memory + 4096 + 8);
    *(uint64_t*)(b_copy_memory + 0x34 + 2) = heap_memory;
    *(uint64_t*)(b_copy_memory + 0x40 + 1) = heap_memory + 8;
    *(uint64_t*)(b_copy_memory + 0x50 + 2) = heap_memory;
    *(uint64_t*)(b_copy_memory + 0x7C + 2) = address_NtDeviceIoControlFile;

    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_FUNCTION(ehdr, b_copy_memory);
    STACK_GET_ADDRESS(ehdr, 0, 0, 5);
    STACK_EXECUTE(hdr, ehdr);

    copy_memory = *(uint64_t*)((char *)hdr+4);
    *(uint64_t*)(b_translate + 0x28 + 2) = copy_memory;
    *(uint64_t*)(b_translate + 0x40 + 2) = heap_memory + 12;

    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_FUNCTION(ehdr, b_translate);
    STACK_GET_ADDRESS(ehdr, 0, 0, 6);
    STACK_EXECUTE(hdr, ehdr);

    translate_address = *(uint64_t*)((char *)hdr+4);

    *(uint64_t*)(b_vmcopy + 0x14 + 2) = translate_address;
    *(uint64_t*)(b_vmcopy + 0x2a + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy + 0x39 + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy + 0x4d + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy + 0x62 + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy + 0x70 + 2) = address_memset;

    *(uint64_t*)(b_vmcopy_p32 + 0x23 + 2) = translate_address;
    *(uint64_t*)(b_vmcopy_p32 + 0x3d + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy_p32 + 0x4c + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy_p32 + 0x60 + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy_p32 + 0x75 + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy_p32 + 0x83 + 2) = address_memset;

    *(uint64_t*)(b_vmcopy_p64 + 0x23 + 2) = translate_address;
    *(uint64_t*)(b_vmcopy_p64 + 0x3d + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy_p64 + 0x4c + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy_p64 + 0x60 + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy_p64 + 0x75 + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy_p64 + 0x83 + 2) = address_memset;

    *(uint64_t*)(b_vmcopy64 + 0x14 + 2) = translate_address;
    *(uint64_t*)(b_vmcopy64 + 0x28 + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy64 + 0x37 + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy64 + 0x47 + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy64 + 0x5f + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy64 + 0x69 + 2) = address_memset;

    *(uint64_t*)(b_vmcopy64_p32 + 0x1f + 2) = translate_address;
    *(uint64_t*)(b_vmcopy64_p32 + 0x3b + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy64_p32 + 0x4a + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy64_p32 + 0x5a + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy64_p32 + 0x72 + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy64_p32 + 0x7c + 2) = address_memset;

    *(uint64_t*)(b_vmcopy64_p64 + 0x1f + 2) = translate_address;
    *(uint64_t*)(b_vmcopy64_p64 + 0x3b + 2) = copy_memory;
    *(uint64_t*)(b_vmcopy64_p64 + 0x4a + 2) = heap_memory + 12;
    *(uint64_t*)(b_vmcopy64_p64 + 0x5a + 2) = address_memcpy;
    *(uint64_t*)(b_vmcopy64_p64 + 0x72 + 2) = heap_memory;
    *(uint64_t*)(b_vmcopy64_p64 + 0x7c + 2) = address_memset;

    *(uint64_t*)(b_move_mouse + 0x12 + 2) = heap_memory + 4096 + 16;
    *(uint64_t*)(b_move_mouse + 0x2c + 2) = heap_memory;
    *(uint64_t*)(b_move_mouse + 0x50 + 2) = address_NtDeviceIoControlFile;

    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy_p32);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy_p64);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy64);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy64_p32);
    STACK_ADD_FUNCTION(ehdr, b_vmcopy64_p64);
    STACK_ADD_FUNCTION(ehdr, b_move_mouse);
    *(uint64_t*)(b_copy_i64 + 0x03 + 2) = heap_memory + 4096;
    STACK_ADD_FUNCTION(ehdr, b_copy_i64);
    *(uint64_t*)(b_copy_i64 + 0x03 + 2) = heap_memory + 4096 + 24;
    STACK_ADD_FUNCTION(ehdr, b_copy_i64);
    STACK_EMPTY_FUNCTION(ehdr, 0, 1);
    STACK_EXECUTE(hdr, ehdr);
    skip:
    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_EMPTY_FUNCTION(ehdr, 0, 14);
    STACK_EXECUTE(hdr, ehdr);
    g_system_process = *(uint64_t*)((char *)hdr+4);
    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_EMPTY_FUNCTION(ehdr, 0, 15);
    STACK_EXECUTE(hdr, ehdr);
    status = hdr->status;
    g_system_pml4 = *(uint64_t*)((char *)hdr+4);

    LOG("PsInitialSystemProcess: 0x%llx\n", g_system_process);
    LOG("PML4: 0x%llx\n", g_system_pml4);
    return status;
}

uint32_t move_mouse(char button, char x, char y, char wheel)
{
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;
    hdr = (struct tcp_header*)(payload);
    ehdr = (struct tcp_entry*)(hdr + 1);

    STACK_ADD_MOUSE(ehdr, 0, button, x, y, wheel);
    STACK_EXECUTE(hdr, ehdr);
    return *(uint32_t*)((char *)hdr+4);
}



static uint32_t vm_attach_process(const char *process_name)
{
    uint64_t entry = g_system_process;
    do {
        int valid = 1;
        char payload[1400];
        struct tcp_header *hdr;
        struct tcp_entry *ehdr;
        uint8_t exitprocess;
        const char *imagename;
        uint64_t directorytablebase;
        uint64_t nextentry;

        hdr = (struct tcp_header*)(payload);
        ehdr = (struct tcp_entry*)(hdr + 1);

        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x304, g_system_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x450, g_system_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x28, g_system_pml4);
        STACK_ADD_VM_COPY64(ehdr, 0, entry + 0x2F0, g_system_pml4);
        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            break;

        exitprocess = *(uint8_t*)((char *)hdr+4);
        imagename = ((char *)hdr+4+8);
        directorytablebase = *(uint64_t*)((char *)hdr+4+8+8);
        nextentry = *(uint64_t*)((char *)hdr+4+8+8+8);
        if ((exitprocess >> 2 & 1) == 1)
            valid = 0;

        if (valid && strncasecmp(imagename, process_name, 14) == 0) {
            LOG("[*]ImageFileName: %s\n", imagename);
            LOG("[*]DirectoryTableBase: %llx\n", directorytablebase);
            g_process = entry;
            g_process_pml4 = directorytablebase;
            return 1;
        }
        entry = nextentry;
        if (entry == 0)
            break;
        entry -= 0x2F0;

    } while ( entry != g_system_process ) ;
    return 0;
}


static uint32_t vm_dump_modules(void)
{
    int counter = 0;
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;
    uint32_t a0, a1;

    hdr = (struct tcp_header*)(payload);
    ehdr = (struct tcp_entry*)(hdr + 1);

    STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), g_process + 0x428, g_system_pml4);
    STACK_ADD_VM_COPY64_P64(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), 0, g_system_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x0C, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x14, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0x04, g_process_pml4);
    STACK_EXECUTE(hdr, ehdr);
    if (hdr->status != 1)
        return 0;

    a0 = *(uint32_t*)((char *)hdr+28);
    a1 = *(uint32_t*)((char *)hdr+36);
    while (a0 != a1) {
        const char *name;
        uint32_t base;

        ehdr = (struct tcp_entry*)(hdr + 1);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x10, g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0, g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x28, g_process_pml4);
        STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 40);
        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            return 0;
        base = *(uint32_t*)((char *)hdr+4);
        a0 = *(uint32_t*)((char *)hdr+12);
        name = ((char *)hdr+28);

        if (!impl_wcscmp("client.dll", name)) {
            counter++;
            LOG("[*]client_panorama.dll: %x\n", base);
            g_client_dll = base;
        }

        if (!impl_wcscmp("engine.dll", name)) {
            counter++;
            LOG("[*]engine.dll: %x\n", base);
            g_engine_dll = base;
        }
        if (!impl_wcscmp("vstdlib.dll", name)) {
            counter++;
            LOG("[*]vstdlib.dll: %x\n", base);
            g_vstdlib_dll = base;
        }
        if (!impl_wcscmp("inputsystem.dll", name)) {
            counter++;
            LOG("[*]inputsystem.dll: %x\n", base);
            g_inputsystem_dll = base;
        }
        if (counter == 4)
            return 1;
    }
    return 0;
}


static uint64_t get_interface_factory(uint32_t base)
{
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;
    uint32_t a1[4];

    hdr = (struct tcp_header*)payload;
    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + 0x3C, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base + 0x78, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base + 0x18, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t)*2, base + 0x20, g_process_pml4);
    STACK_EXECUTE(hdr, ehdr);
    if (hdr->status != 1)
        return 0;
    a1[0] = *(uint32_t*)((char *)hdr+20);
    a1[1] = *(uint32_t*)((char *)hdr+24);
    a1[2] = *(uint32_t*)((char *)hdr+28);
    a1[3] = *(uint32_t*)((char *)hdr+32);
    while (a1[0]--) {
        const char *name;
        uint16_t ords;

        ehdr = (struct tcp_entry*)(hdr + 1);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[3] + (a1[0] * 2), g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[2] + (a1[0] * 4), g_process_pml4);
        STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), base, g_process_pml4, 16);
        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            break;
        ords = *(uint16_t*)((char *)hdr+4);
        name = ((char *)hdr+4+8+8);
        if (!strcmp("CreateInterface", name)) {
            ehdr = (struct tcp_entry*)(hdr + 1);
            STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[1] + (ords * 4), g_process_pml4);
            STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base - 0x6A, g_process_pml4);
            STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4);
            STACK_EXECUTE(hdr, ehdr);
            if (hdr->status != 1) {
                break;
            }
            return *(uint32_t*)((char *)hdr+20);
        }
    }
    return 0;
}


static uint64_t get_interface(uint32_t factory, const char *name)
{
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;

    while (factory != 0) {
        uint32_t interface_address;

        hdr = (struct tcp_header*)payload;
        ehdr = (struct tcp_entry*)(hdr + 1);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x01, g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory + 0x08, g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory + 0x04, g_process_pml4);
        STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 20);
        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            break;
        interface_address = *(uint32_t*)((char *)hdr+12);
        factory = *(uint32_t*)((char *)hdr+20);
        if (impl_strcmp(((char *)hdr+36), name) >> 4 == 3) {
            LOG("[*]%s: %x\n", name, interface_address);
            return interface_address;
        }
    }
    return 0;
}


static uint32_t vm_dump_interfaces(void)
{
    uint32_t factory;

    factory = get_interface_factory(g_client_dll);
    if (factory == 0)
        return 0;

    LOG("[*]client_panorama.dll factory: %x\n", factory);

    vt_client = get_interface(factory, "VClient");
    if (vt_client == 0)
        return 0;
    
    vt_entity = get_interface(factory, "VClientEntityList");
    if (vt_entity == 0)
        return 0;

    factory = get_interface_factory(g_engine_dll);
    if (factory == 0)
        return 0;

    LOG("[*]engine.dll factory: %x\n", factory);

    vt_engine = get_interface(factory, "VEngineClient");
    if (vt_engine == 0)
        return 0;

    factory = get_interface_factory(g_vstdlib_dll);
    if (factory == 0)
        return 0;

    LOG("[*]vstdlib.dll factory: %x\n", factory);

    vt_cvar = get_interface(factory, "VEngineCvar");
    if (vt_cvar == 0)
        return 0;

    factory = get_interface_factory(g_inputsystem_dll);
    if (factory == 0)
        return 0;

    LOG("[*]inputsystem.dll factory: %x\n", factory);

    vt_input = get_interface(factory, "InputSystemVersion");
    if (vt_input == 0)
        return 0;
    return 1;
}


uint32_t vm_dump_netvar_tables(void)
{
    int counter = 0;
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;
    uint32_t a0, a1;

    hdr = (struct tcp_header*)payload;
    ehdr = (struct tcp_entry*)(hdr + 1);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_client, 8);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 1, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4);
    STACK_EXECUTE(hdr, ehdr);
    if (hdr->status != 1)
        return 0;

    a0 = *(uint32_t*)((char *)hdr+28);
    while (a0 != 0) {
        ehdr = (struct tcp_entry*)(hdr + 1);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x10, g_process_pml4);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x0C, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), 0x0C, g_process_pml4);

        /*
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*2, 8, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*3, 16, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t)*4, 24, g_process_pml4);*/

        STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 17);


        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            return 0;

        a0 = *(uint32_t*)((char *)hdr+4);
        a1 = *(uint32_t*)((char *)hdr+12);

        //if (strcmp("DT_BasePlayer", ((char *)hdr+28)) >= 0)
            //LOG("result: %s, %d\n", ((char *)hdr+28), strcmp("DT_BasePlayer", ((char *)hdr+28)));

        //LOG( "lul: %s\n", ((char *)hdr+28) );
        if (!strcmp("DT_BasePlayer", ((char *)hdr+28)) /*|| strcmp("DT_BasePlayer", ((char *)hdr+28)) >= 30*/) {
            counter++;
            LOG("[*]%s: %x\n", "DT_BasePlayer", a1);
            DT_BasePlayer = a1;
        }
        if (!strcmp("DT_BaseEntity", ((char *)hdr+28))) {
            counter++;
            LOG("[*]%s: %x\n", "DT_BaseEntity", a1);
            DT_BaseEntity = a1;
        }
        if (!strcmp("DT_CSPlayer", ((char *)hdr+28))) {
            counter++;
            LOG("[*]%s: %x\n", "DT_CSPlayer", a1);
            DT_CSPlayer = a1;
        }
        if (!strcmp("DT_BaseAnimating", ((char *)hdr+28))) {
            counter++;
            LOG("[*]%s: %x\n", "DT_BaseAnimating", a1);
            DT_BaseAnimating = a1;
        }
        if (counter == 4)
            return 1;
    }
    return 0;
}


static uint32_t netvar_callback(uint32_t table, uint32_t (*callback)(const char *, int))
{
    uint32_t a0 = 0, a1, a3, a4, a5;
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;

    hdr = (struct tcp_header*)payload;
    ehdr = (struct tcp_entry*)(hdr + 1);

    STACK_ADD_VM_COPY64(ehdr, 0,  table + 0x4, g_process_pml4);
    STACK_EXECUTE(hdr, ehdr);
    if (hdr->status != 1)
        return 0;
    for (a1 = *(uint32_t*)((char *)hdr+4); a1--; ) {
        char n[24];

        ehdr = (struct tcp_entry*)(hdr + 1);
        STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), table, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), a1 * 60 + 0x28, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t)*2, a1 * 60, g_process_pml4);
        STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 24);
        STACK_EXECUTE(hdr, ehdr);
        if (hdr->status != 1)
            return 0;

        a4 = *(uint32_t*)((char *)hdr+12);
        a3 = *(uint32_t*)((char *)hdr+16);
        memcpy(n, ((char*)hdr + 28), 24);
        if (a4) {
            ehdr = (struct tcp_entry*)(hdr + 1);
            STACK_ADD_VM_COPY64(ehdr, 0, a4 + 0x4, g_process_pml4);
            STACK_EXECUTE(hdr, ehdr);
            if (hdr->status != 1)
                return 0;
            if (*(uint32_t*)((char*)hdr + 4)) {
                a5 = netvar_callback(a4, callback);
                if (a5 != 0)
                    a0 += a3 + a5;
            }
        }
        if (callback(n, a3 + a0) != 0)
            return 1;
    }
    return a0;
}


static uint32_t dump_baseplayer(const char *name, int offset)
{
    static int counter = 0;
    if (!strcmp("m_iHealth", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_iHealth = offset;
    }
    if (!strcmp("m_vecViewOffset[0]", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_vecViewOffset = offset;
    }
    if (!strcmp("m_lifeState", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_lifeState = offset;
    }

    if (name[0] == 'm' && name[1] == '_' && name[2] == 'n' && name[3] == 'T' &&
        name[4] == 'i' && name[5] == 'c' && name[6] == 'k') {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_nTickBase = offset;
    }
    if (!strcmp("m_Local", name)) {
        counter++;
        LOG("[*]m_vecPunch: 0x%x\n", offset);
        m_vecPunch = offset + 0x70;
    }
    if (counter == 5) {
        counter = 0;
        return 1;
    }
    return 0;
}


static uint32_t dump_baseentity(const char *name, int offset)
{
    static int counter = 0;
    if (!strcmp("m_iTeamNum", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_iTeamNum = offset;
    }
    if (!strcmp("m_vecOrigin", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_vecOrigin = offset;
    }
    if (counter == 2) {
        counter = 0;
        return 1;
    }
    return 0;
}


static uint32_t dump_csplayer(const char *name, int offset)
{
    static int counter = 0;
    if (!strcmp("m_hActiveWeapon", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_hActiveWeapon = offset;
    }
    if (!strcmp("m_iShotsFired", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_iShotsFired = offset;
    }
    if (!strcmp("m_bHasDefuser", name)) {
        counter++;
        LOG("[*]m_iCrossHairID: 0x%x\n", offset + 0x5C);
        m_iCrossHairID = offset + 0x5C;
        m_bHasDefuser = offset;
    }
    if (!strcmp("m_bIsDefusing", name)) {
        counter++;
        LOG("[*]m_bIsDefusing: 0x%x\n", offset);
        m_bIsDefusing = offset;
    }
    if (!strcmp("m_flFlashDuration", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_flFlashDuration = offset;
    }
    if (counter == 5) {
        counter = 0;
        return 1;
    }
    return 0;
}


static uint32_t dump_baseanimating(const char *name, int offset)
{
    static int counter = 0;
    if (!strcmp("m_nForceBone", name)) {
        counter++;
        LOG("[*]%s: 0x%x\n", name, offset);
        m_dwBoneMatrix = offset + 0x1C;
    }
    if (counter == 1) {
        counter = 0;
        return 1;
    }
    return 0;
}


static uint32_t vm_dump_netvars(void)
{
    if (!netvar_callback(DT_BasePlayer, dump_baseplayer))
        return 0;
    if (!netvar_callback(DT_BaseEntity, dump_baseentity))
        return 0;
    if (!netvar_callback(DT_CSPlayer, dump_csplayer))
        return 0;
    if (!netvar_callback(DT_BaseAnimating, dump_baseanimating))
        return 0;
    return 1;
}


static uint32_t vm_dump_offsets(void)
{
    char payload[1400];
    struct tcp_header *hdr;
    struct tcp_entry *ehdr;

    hdr = (struct tcp_header*)payload;
    ehdr = (struct tcp_entry*)(hdr + 1);

    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_entity, 5);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x22, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 18);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x16, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 12);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x16, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 19);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0xB2, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 20);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x07, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 26);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x07, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 15);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x21D, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 18);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x29, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 18);
    STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x09, g_process_pml4);
    STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 9);
    STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0x13, g_process_pml4);

    STACK_EXECUTE(hdr, ehdr);
    if (hdr->status != 1)
        return 0;

    m_dwEntityList = vt_entity - *(uint32_t*)((char*)hdr + 20) + 0x38;
    m_dwClientState = *(uint32_t*)((char*)hdr + 52);
    m_dwGetLocalPlayer = *(uint32_t*)((char*)hdr + 76);
    m_dwGetViewAngles = *(uint32_t*)((char*)hdr + 100);
    m_dwGetMaxClients = *(uint32_t*)((char*)hdr + 124);
    m_dwState = *(uint32_t*)((char*)hdr + 148);
    m_dwButton = *(uint32_t*)((char*)hdr + 172);
    m_dwAnalogDelta = *(uint32_t*)((char*)hdr + 196);
    m_dwAnalog = *(uint32_t*)((char*)hdr + 220);
    m_dwGetPlayerInfo = *(uint32_t*)((char*)hdr + 244);

    LOG("[*]m_dwEntityList %x\n", m_dwEntityList);
    LOG("[*]m_dwClientState %x\n", m_dwClientState);
    LOG("[*]m_dwGetLocalPlayer %x\n", m_dwGetLocalPlayer);
    LOG("[*]m_dwGetViewAngles %x\n", m_dwGetViewAngles);
    LOG("[*]m_dwGetMaxClients %x\n", m_dwGetMaxClients);
    LOG("[*]m_dwState %x\n", m_dwState);
    LOG("[*]m_dwButton %x\n", m_dwButton);
    LOG("[*]m_dwAnalogDelta %x\n", m_dwAnalogDelta);
    LOG("[*]m_dwAnalog %x\n", m_dwAnalog);

    return 1;
}


#define DEFAULT_KEY "AlpcFreeCompletionListMessage"


static int previous_connection;



int connect_server(const char *ip, uint16_t port, const char *dynamic)
{
#ifndef OG_CLIENT
    char result[30];
    char defaultkey[30] = DEFAULT_KEY;
    char next_key[30];

    memcpy(next_key, dynamic, 30);

    if (socket_open(ip, port) == 0)
        return -1;

    memcpy(decryption_key, defaultkey, 30);
    if (socket_send(next_key, 30) != 30)
        return -2;

    memcpy(decryption_key, dynamic, 30);
    if (socket_recv(result, 30) != 30)
        return -3;

    if (strcmp(result, dynamic) != 0)
        return -4;
#else
    if (socket_open(ip, port) == 0)
        return -1;

    memcpy(decryption_key, DEFAULT_KEY, 30);
#endif
    is_player_valid=0;

    return 1;
}


extern "C" JNIEXPORT jint JNICALL
Java_com_example_client_MainActivity_initClient(
        JNIEnv *env,
        jobject /* this */, jstring ip) {
    uint32_t status;

    const char *ip_address = env->GetStringUTFChars(ip, 0);

    if (previous_connection != 0) {
        socket_close();
        previous_connection = 0;
    }

    status = (uint32_t )connect_server(ip_address, 30609, "ClpWFCeeYomBlQtToDAisHMeJsQgX");

    env->ReleaseStringUTFChars(ip, ip_address);

    if (!status) {
        LOG("failed to open socket!\n");
        socket_close();
        return -1;
    }

    previous_connection = 1;

    LOG("[*]connected to server!");

    if (!device_initialize()) {
        LOG("failed to initialize device!\n");
        return -2;
    }

    LOG("[*]initialized device!");

    if (!vm_attach_process("csgo.exe")) {
        LOG("failed to find process!\n");
        return -3;
    }

    if (!vm_dump_modules()) {
        LOG("failed to dump modules!\n");
        return -4;
    }

    if (!vm_dump_interfaces()) {
        LOG("failed to dump interfaces!\n");
        return -5;
    }

    if (!vm_dump_netvar_tables()) {
        LOG("failed to dump netvar tables!\n");
        return -6;
    }

    if (!vm_dump_netvars()) {
        LOG("failed to dump netvars!\n");
        return -7;
    }

    if (!vm_dump_offsets()) {
        LOG("failed to dump offsets!\n");
        return -8;
    }

    return 0;
}


extern "C" JNIEXPORT void JNICALL
Java_com_example_client_MainActivity_closeClient(
        JNIEnv *env,
        jobject /* this */)
{
    socket_close();
}


static uint32_t vm_get_best_target();
static uint32_t get_player_information(void);
static vec3 get_target_angle(void);
static void aim_at_target(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity);
static void
aim_at_target1(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity, int bhs);

extern "C" JNIEXPORT jint JNICALL
Java_com_example_client_MainActivity_getBestTarget(
        JNIEnv *env,
        jobject /* this */,
        jint besea)
{
    esea = besea;
    return vm_get_best_target();
}


static void resetTarget()
{
    g_target_address = 0;
    g_has_target = 0;
    g_valid_target_count = 0;
}


extern "C" JNIEXPORT void JNICALL
Java_com_example_client_MainActivity_resetTarget(
        JNIEnv *env,
        jobject /* this */)
{
    resetTarget();
}


extern "C" JNIEXPORT jint JNICALL
Java_com_example_client_MainActivity_getPlayerInformation(
        JNIEnv *env,
        jobject /* this */)
{
    return get_player_information();
}


extern "C" JNIEXPORT jfloatArray JNICALL
Java_com_example_client_MainActivity_getTargetAngle(
        JNIEnv *env,
        jobject /* this */)
{
    vec3 info = get_target_angle();
    jfloatArray array = env->NewFloatArray(3);
    env->SetFloatArrayRegion(array, 0, 3, (float*)&info);
    return array;
}


extern "C" JNIEXPORT int JNICALL
Java_com_example_client_MainActivity_hasTarget(
        JNIEnv *env,
        jobject /* this */)
{
    return g_has_target;
}


extern "C" JNIEXPORT int JNICALL
Java_com_example_client_MainActivity_targetDefusing(
        JNIEnv *env,
        jobject /* this */)
{
    return g_defusing;
}

extern "C" JNIEXPORT int JNICALL
Java_com_example_client_MainActivity_getCurrentTick(
        JNIEnv *env,
        jobject /* this */)
{
    return g_current_tick;
}


extern "C" JNIEXPORT void JNICALL
Java_com_example_client_MainActivity_aimAtTarget(
        JNIEnv *env,
        jobject /* this */,
        jfloatArray target_angle,
        jfloat fov,
        jfloat smooth, jfloat preaim, jfloat sensitivity, jint bhs
        )
{
    jfloat *elem = env->GetFloatArrayElements(target_angle, 0);
    vec3 angle = *(vec3*)elem;

    if (g_mouse_5 || g_mouse_1)
        return aim_at_target1(
                g_viewangles,
                angle,
                (float)fov,
                (float)smooth,
                (float)sensitivity,
                (int)bhs);

    else

    //if (aim_type == 0)
        return aim_at_target(g_viewangles, angle, 20.0f, (float)preaim, (float)sensitivity);
    //else if (aim_type == 1)
    //    return aim_at_target1(g_viewangles, angle, (float)fov, (float)smooth);
}


static uint32_t vm_get_best_target()
{
    float best_fov = 360.0f;
    char buffer[1400];
    struct tcp_entry  *e;
    struct tcp_header *h;
    vec3 va;
    int local_team, i;
    vec3 local_pos;
    int entity_address, temp_entity = 0;
    int entity_team, entity_health, entity_lifestate;
    vec3 entity_pos;

    if (g_target_address != 0)
        return 1;

    g_has_target = 0;

    h = (struct tcp_header*)buffer;
    e = (struct tcp_entry*)(h + 1);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetLocalPlayer, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetViewAngles, g_process_pml4);
    STACK_ADD_VM_COPY64(e, 0, m_dwClientState + m_dwState, g_process_pml4);
    STACK_EXECUTE(h, e);
    if (h->status != 1) {
        return -1;
    }

    g_local_index = *(int*)((char*)h + 4);
    *(uint64_t*)&va = *(uint64_t*)((char*)h + 12);
    if (*(int*)((char*)h + 20) != 6) {
        g_previous_tick = 0;
        prev_tick = 0;
        return 0;
    }

    e = (struct tcp_entry*)(h + 1);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwEntityList + g_local_index  * 0x10, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), m_iTeamNum, g_process_pml4);
    STACK_ADD_VM_COPY64_P32(e, 0, sizeof(uint64_t)*2, m_vecOrigin, g_process_pml4);
    STACK_EXECUTE(h, e);
    if (h->status != 1)
        return 0;


    g_local_address = *(int*)((char*)h + 4);
    local_team = *(int*)((char*)h + 12);
    *(uint64_t*)&local_pos = *(uint64_t*)((char*)h + 20);


    g_positions[0] = local_pos.x;
    g_positions[1] = local_pos.y;
    g_valid_target_count++;

    

    for (i = 0; i < 20; i++) {
        float angle[3] = {0}, fov;

        e = (struct tcp_entry*)(h + 1);
        STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwEntityList + i * 0x10, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), m_iTeamNum, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*2, m_iHealth, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*3, m_lifeState, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*4, m_vecOrigin, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*5, m_bDormant, g_process_pml4);
        STACK_ADD_VM_COPY64_P32(e, 0, sizeof(uint64_t)*6, m_bIsDefusing, g_process_pml4);
        STACK_EXECUTE(h, e);

        if (h->status != 1)
            continue;

        entity_address = *(int*)((char*)h + 4);
        entity_team = *(int*)((char*)h + 12);
        entity_health = *(int*)((char*)h + 20);
        entity_lifestate = *(int*)((char*)h + 28);
        *(uint64_t*)&entity_pos = *(uint64_t*)((char*)h + 36);


        if (entity_team == local_team)
            continue;

        if (entity_health < 1)
            continue;

        if (entity_health > 100)
            continue;

        if (entity_lifestate)
            continue;

        if (*(bool*)((char*)h + 44))
            continue;

        if (*(bool*)((char*)h + 52)) {

            temp_entity = entity_address;
        }

        g_positions[g_valid_target_count + 0] = entity_pos.x;
        g_positions[g_valid_target_count + 1] = entity_pos.y;

        g_valid_target_count++;

        local_pos.z = 0;
        entity_pos.z = 0;
        CalcAngle((float*)&local_pos, (float*)&entity_pos, angle);
        vec_clamp((vec3*)&angle);
        fov = get_fov(va, *(vec3*)&angle);

        if (fov < best_fov) {
            best_fov = fov;
            g_target_address = entity_address;
            g_target_id = i;
            g_best_fov = fov;
        }
    }

    if (temp_entity != 0) {
        e = (struct tcp_entry*)(h + 1);
        STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), temp_entity + m_bIsDefusing, g_process_pml4);
        STACK_ADD_VM_COPY64(e, 0, temp_entity + m_bHasDefuser, g_process_pml4);
        STACK_EXECUTE(h, e);

        if (*(bool*)((char*)h + 4) == false) {
            g_defusing = 0;
            goto E0;
        }
        if (*(bool*)((char*)h + 12)) {
            g_defusing = 2;
        } else {
            g_defusing = 1;
        }
    } else {
        g_defusing = 0;
    }
E0:
    return 360.0f != best_fov;
}


static uint32_t get_player_information(void)
{
    char buffer[1400];
    struct tcp_entry  *e;
    struct tcp_header *h;



    h = (struct tcp_header*)buffer;
    e = (struct tcp_entry*)(h + 1);
    STACK_ADD_VM_COPY(e, sizeof(struct tcp_entry_copy) + 3*4, g_local_address + m_vecOrigin, g_process_pml4, 3*4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_vecViewOffset + 8, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_vecPunch, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_iShotsFired, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_nTickBase, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetViewAngles, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + m_iHealth, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + (((107 >> 5 ) * 4) + m_dwButton), g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + (((111 >> 5 ) * 4) + m_dwButton), g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + m_dwAnalogDelta, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + m_bDormant, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + 0x980, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + 0x64, g_process_pml4);
    STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + m_dwBoneMatrix, g_process_pml4);
    STACK_ADD_VM_COPY_P32(e, 0, sizeof(uint64_t), (0x30 * 8), g_process_pml4, 48);
    STACK_EXECUTE(h, e);
    if (h->status != 1) {
        g_has_target = 0;
        return 0;
    }
    g_eyepos = *(vec3*)((char*)h + 4);
    g_eyepos.z += *(float*)((char*)h + 16);

    *(uint64_t*)&g_vecpunch = *(uint64_t*)((char*)h + 24);
    g_shots_fired = *(uint32_t*)((char*)h + 32);
    g_current_tick = *(uint32_t*)((char*)h + 40);
    *(uint64_t*)&g_viewangles = *(uint64_t*)((char*)h + 48);
    g_target_health = *(uint32_t*)((char*)h + 56);
    g_mouse_1 = (*(uint32_t*)((char*)h + 64) >> (107 & 31)) & 1;
    g_mouse_5 = (*(uint32_t*)((char*)h + 72) >> (111 & 31)) & 1;
    *(uint64_t*)&g_mouse_delta = *(uint64_t*)((char*)h + 80);



    bool tester = *(bool*)((char*)h + 88);

    int mask = *(int*)((char*)h + 96);
    int base = *(int*)((char*)h + 104) - 1;
    g_is_visible = (mask & (1 << base)) != 0;


    g_target_bone.x = (*(matrix3x4_t*)((char*)h + 120))[0][3];
    g_target_bone.y = (*(matrix3x4_t*)((char*)h + 120))[1][3];
    g_target_bone.z = (*(matrix3x4_t*)((char*)h + 120))[2][3];

    if (g_mouse_5 && esea) {
        h = (struct tcp_header*)buffer;
        e = (struct tcp_entry*)(h + 1);
        STACK_ADD_VM_COPY64(e, /*sizeof(struct tcp_entry_copy64)*/0, g_local_address + m_iCrossHairID, g_process_pml4);
        STACK_EXECUTE(h, e);
        if (h->status != 1) {
            g_has_target = 0;
            return 0;
        }
        g_crosshair_id = *(int*)((char*)h + 4);
        if (g_crosshair_id > 0 && g_crosshair_id <= 64 && g_current_tick - prev_tick > 0) {
            prev_tick = g_current_tick;
            move_mouse(1, 0, 0, 0);
            NtSleep(NtRand() % (100-80+1) + 100);
            move_mouse(0, 0, 0, 0);
        }
    }

    if (tester || g_target_health < 1) {
        resetTarget();
        return 0;
    }

    return 1;
}


#include <math.h>
#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))

static vec3 get_target_angle(void)
{
    vec3 m = g_target_bone;
    vec3 c = g_eyepos;
    c.x = m.x - c.x;
    c.y = m.y - c.y;
    c.z = m.z - c.z;
    vec_normalize(&c);
    vec_angles(c, &c);

    if (g_shots_fired > 0) {
        c.x = c.x - g_vecpunch.x * 2.0f;
        c.y = c.y - g_vecpunch.y * 2.0f;
        c.z = c.z - g_vecpunch.z * 2.0f;
    }

    vec_clamp(&c);

    return c;
}


#include <cmath>
#include <algorithm>
static float clamp(float x, float min, float max)
{
    if (x < min) x = min;
    if (x > max) x = max;
    return x;
}


static void aim_at_target(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity)
{
    vec3 pos = g_eyepos;
    vec3 target_pos = g_target_bone;
    vec3 view_ang = vangle;

    float dist = vec_distance(pos, target_pos);
    float pitch = (float)(sin(DEG2RAD(vangle.x - angle.x)) * dist );
    float yaw = (float) (sin(DEG2RAD(vangle.y - angle.y)) * dist );
    float dist_x = fabs(yaw);
    float dist_y = fabs(pitch);

    if (get_fov(view_ang, angle) >= 45.0) {
        resetTarget();
        return;
    }



    float dist_fov = get_fov_distance(vangle, angle, dist);

    if (dist_fov >= 4500.0f) {
        resetTarget();
        return;
    }

    if (dist_x >= 60.0f || pitch <= -50.0f) {
        g_has_target = 0;
    } else {
        g_has_target = 1;
    }

    if (dist_fov >= (fov*100.0f)) {
        //g_has_target = 0;
        return;
    }




    if (!g_is_visible) {
        if (!g_mouse_1)
            return;
    }

    vec3 move_ang;
    move_ang.y = -(g_mouse_delta.x * sensitivity * 0.022f);
    move_ang.x = (g_mouse_delta.y * sensitivity * 0.022f);
    vec_clamp(&move_ang);

    vec3 view_delta;
    view_delta.x = angle.x - view_ang.x;
    view_delta.y = angle.y - view_ang.y;
    view_delta.z = angle.z - view_ang.z;
    vec_clamp(&view_delta);

    move_ang.y *= smooth;
    move_ang.x *= smooth;

    float delta_y = std::abs(move_ang.y);
    float delta_x = std::abs(move_ang.x);

    delta_x = clamp(view_delta.x, -delta_x, delta_x);
    delta_y = clamp(view_delta.y, -delta_y, delta_y);

    float y = ((delta_x / sensitivity) / 0.022f);
    float x = ((delta_y / sensitivity) / -0.022f);


    if (g_current_tick - g_previous_tick > 0) {
        g_previous_tick = g_current_tick;
        move_mouse(0, (int)x, (int)y, 0);
    }
}


static void
aim_at_target1(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity, int bhs)
{
    float x, y, sx, sy;
    float dist = vec_distance(g_eyepos, g_target_bone);
    float pitch = (float)(sin(DEG2RAD(vangle.x - angle.x)) * dist );
    float yaw = (float) (sin(DEG2RAD(vangle.y - angle.y)) * dist );
    float dist_x = fabs(yaw);
    float dist_y = fabs(pitch);
    float tmp_fov = get_fov(vangle, angle);
    float dist_fov = get_fov_distance(vangle, angle, dist);
    if (tmp_fov >= 45.0) {
        resetTarget();
        return;
    }

    if (dist_fov >= 4500.0f) {
        resetTarget();
        return;
    }

    if (dist_x >= 60.0f || pitch <= -50.0f) {
        g_has_target = 0;
    } else {
        g_has_target = 1;
    }

    if (dist_fov >= (fov*100.0f)) {
        //g_has_target = 0;
        return;
    }

    //if (dist_y >= fov) {
        //g_has_target = 0;
    //    return;
    //}






    //if (!g_is_visible)
    //    return;

    //if (!g_mouse_1 && !g_mouse_5)
    //    return;


    y = vangle.x - angle.x, x = vangle.y - angle.y;
    if (y > 89.0f) y = 89.0f; else if (y < -89.0f) y = -89.0f;
    if (x > 180.0f) x -= 360.0f; else if (x < -180.0f) x += 360.0f;

    x = ((x / sensitivity) / 0.022f);
    y = ((y / sensitivity) / -0.022f);

    if (smooth > 1.00f) {
        sx = 0.0f, sy = 0.0f;
        if (sx < x)
            sx += 1.0f + (x / smooth);
        else if (sx > x)
            sx -= 1.0f - (x / smooth);
        if (sy < y)
            sy += 1.0f + (y / smooth);
        else if (sy > y)
            sy -= 1.0f - (y / smooth);
    } else {
        sx = x, sy = y;
    }

    if (g_current_tick - g_previous_tick > 0) {

        g_previous_tick = g_current_tick;


        move_mouse(0, (int) sx, (int)sy, 0);
    }

    if (!esea && g_mouse_5 && dist_x <= 3.5 && pitch >= -5.5f && pitch <= 60.0f && g_current_tick - prev_tick > 3) {
        prev_tick = g_current_tick;
        move_mouse(1, 0, 0, 0);
        NtSleep(NtRand() % (100-80+1) + 100);
        move_mouse(0, 0, 0, 0);
    }
}


static const unsigned int crc32_table[] = {
        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
} ;

int check_player_pos(const char* buf, int len, int init)
{
    int crc = init;
    while (len--) {
        crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
        buf++;
    }
    return crc;
}


```

`client_android/app/src/main/cpp/socket.cpp`:

```cpp
#include "socket.h"
#include <string.h>

#if PLATFORM == PLATFORM_WINDOWS
#include <winsock2.h>
#pragma comment( lib, "wsock32.lib" )
typedef int64_t sock_t;
#elif PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
typedef int32_t sock_t;
#endif


static unsigned int inet_pton4(const char* src);
void RC4(void *data, int length, unsigned char *key);

char decryption_key[30];

static sock_t g_socket;
static sock_t g_client;
static sock_t get_socket_0(void) { return g_socket; }
static sock_t get_socket_1(void) { return g_client; }
static sock_t (*get_socket)(void);

int socket_open(const char *ip, uint16_t port)
{
	sock_t sock;
	int no_delay = 1;
	struct sockaddr_in address;

	if (g_socket != 0)
		return g_socket;

#if PLATFORM == PLATFORM_WINDOWS
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == -1) {
		return 0;
	}

	address.sin_family = AF_INET;
	address.sin_port = port;
	if (ip == 0) {
		address.sin_addr.s_addr = 0;
		if (bind(sock, (struct sockaddr*)&address, sizeof(address)) == -1)
			return 0;
		if (listen(sock, 1) == 0)
			return 0;
		get_socket = get_socket_1;
	} else {
		address.sin_addr.s_addr = inet_pton4(ip);
		if (connect(sock, (struct sockaddr*)&address, sizeof(address)) == -1)
			return 0;
		get_socket = get_socket_0;
	}
	if (setsockopt(sock, IPPROTO_TCP, 1, (void *)&no_delay, sizeof(no_delay)) == -1)
		return 0;

	g_socket = sock;

	return 1;
}


void socket_close(void)
{
	if (g_socket != 0) {
#if PLATFORM == PLATFORM_WINDOWS
        closesocket(g_socket);
        WSACleanup();
#else
		close(g_socket);
#endif
		g_socket = 0;
	}

	if (g_client != 0) {
#if PLATFORM == PLATFORM_WINDOWS
		closesocket(g_client);
        WSACleanup();
#else
		close(g_client);
#endif
		g_client = 0;
	}
}


int socket_recv(void *data, uint16_t size)
{
	int len = recv(get_socket(), data, size, 0);
	RC4((char *)data, len, (unsigned char *)decryption_key);
	return len;
}

/*
int socket_recv_decrypted(void *data, uint16_t size)
{
	int len = recv(get_socket(), data, size, 0);
	RC4((char *)data, len, (unsigned char *)decryption_key);
	return len;
}*/


int socket_send(void *data, uint16_t size)
{
	RC4((char*)data, size, (unsigned char *)decryption_key);
	return send(get_socket(), data, size, 0);
}

/*
int socket_send_encrypted(void *data, uint16_t size)
{
	RC4((char*)data, size, (unsigned char *)decryption_key);
	return send(get_socket(), data, size, 0);
}*/


void socket_open_client(void)
{
	socklen_t len = sizeof(struct sockaddr_in);
	struct sockaddr_in address;
	g_client = accept(g_socket, (struct sockaddr *)&address, &len);
}


void socket_close_client(void)
{
#if PLATFORM == PLATFORM_WINDOWS
	closesocket(g_client);
#else
	close(g_client);
#endif
}


static unsigned int inet_pton4(const char* src)
{
	static const char digits[] = "0123456789";
	int saw_digit, octets, ch;
#define NS_INADDRSZ	4
	unsigned char tmp[NS_INADDRSZ], * tp;

	saw_digit = 0;
	octets = 0;
	*(tp = tmp) = 0;
	while ((ch = *src++) != '\0') {
		const char* pch;

		if ((pch = strchr(digits, ch)) != NULL) {
			unsigned int n = *tp * 10 + (int)(pch - digits);

			if (saw_digit && *tp == 0)
				return (0);
			if (n > 255)
				return (0);
			*tp = n;
			if (!saw_digit) {
				if (++octets > 4)
					return (0);
				saw_digit = 1;
			}
		}
		else if (ch == '.' && saw_digit) {
			if (octets == 4)
				return (0);
			*++tp = 0;
			saw_digit = 0;
		}
		else
			return (0);
	}
	if (octets < 4)
		return (0);
	return *(unsigned int*)&tmp;
}


void RC4(void *data, int length, unsigned char *key)
{
	unsigned char T[128];
	unsigned char S[128];
	unsigned char tmp;
	int i, j = 0, x, t = 0;

	for (i = 0; i < 128; i++) {
		S[i]=i;
		T[i]= key[i % 30];
	}
	for(i = 0 ; i < 128; i++) {
		j = ( j + S[i] + T[i] ) % 128;
		tmp = S[j];
		S[j]= S[i];
		S[i] = tmp;
	}
	j = 0;
	for(x = 0 ; x < length; x++) {
		i = (i+1) % 128;
		j = (j + S[i]) % 128;
		tmp = S[j];
		S[j]= S[i];
		S[i] = tmp;
		t = (S[i] + S[j]) % 128;
		((unsigned char *)data)[x] = ((unsigned char *)data)[x]^S[t];
	}
}


```

`client_android/app/src/main/cpp/socket.h`:

```h
#ifndef SOCKET_H
#define SOCKET_H

#include <inttypes.h>

#define PLATFORM_WINDOWS  1
#define PLATFORM_MAC      2
#define PLATFORM_UNIX     3

#if defined(_WIN32)
typedef int64_t sock_t;
#define PLATFORM PLATFORM_WINDOWS
#elif defined(__APPLE__)
typedef int32_t sock_t;
#define PLATFORM PLATFORM_MAC
#else
typedef int32_t sock_t;
#define PLATFORM PLATFORM_UNIX
#endif

struct tcp_header {
    uint16_t size;
    uint8_t  retn, status;
} ;

struct tcp_entry {
    uint16_t next;
    uint16_t id;
} ;

int      socket_open(const char *ip, uint16_t port);
void     socket_close(void);
//int      socket_recv(void *data, uint16_t size);
int      socket_recv(void *data, uint16_t size);
//int      socket_send(void *data, uint16_t size);
int      socket_send(void *data, uint16_t size);
void     socket_open_client(void);
void     socket_close_client(void);
void     RC4(void *data, int length, unsigned char *key);
extern char decryption_key[30];

#endif


```

`client_android/app/src/main/java/com/example/client/MainActivity.java`:

```java
package com.example.client;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;

import android.Manifest;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.media.AudioManager;
import android.media.ToneGenerator;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.os.Looper;
import android.os.PowerManager;
import android.os.SystemClock;
import android.os.Vibrator;
import android.provider.MediaStore;
import android.util.Log;
import android.view.View;
import android.view.WindowManager;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.os.Handler;

public class MainActivity extends AppCompatActivity {

    // Used to load the 'native-lib' library on application startup.
    static {
        System.loadLibrary("native-lib");
    }

    private Handler handler = new Handler();

    private float g_strong;

    private SeekBar seekBar, seekBar2, seekBar3, seekBar4, seekBar5;
    private CheckBox bEsea, bHs;

    private Runnable runnable = new Runnable() {
        int previous_tick = 0;
        private void update()
        {

            int status = getBestTarget(bEsea.isChecked() ? 1 : 0);

            if (status == -1) {
                resetTarget();
                findViewById(R.id.main_layout).setVisibility(View.GONE);
                findViewById(R.id.ip_layout).setVisibility(View.VISIBLE);
                handler.removeCallbacks(runnable);
                closeClient();
            }

            if (status == 0) {
                resetTarget();
                previous_tick = 0;
                return;
            }

            if (getPlayerInformation() == 0) {
                resetTarget();
                return;
            }

            int def = targetDefusing();

            if (hasTarget() == 1) {
                if (getCurrentTick() - previous_tick > 14) {
                    previous_tick = getCurrentTick();
                    //((Vibrator)getSystemService(Context.VIBRATOR_SERVICE)).
                    //        vibrate(150);
                    Beep(50, seekBar3.getProgress(), ToneGenerator.TONE_CDMA_ANSWER);
                }
            }
            if (def == 1) {
                if (getCurrentTick() - previous_tick > 14) {
                    previous_tick = getCurrentTick();

                    Beep(50, seekBar3.getProgress(), ToneGenerator.TONE_CDMA_CONFIRM);
                }
            }
            else if (def == 2) {
                if (getCurrentTick() - previous_tick > 14) {
                    previous_tick = getCurrentTick();

                    Beep(50, seekBar3.getProgress(), ToneGenerator.TONE_CDMA_EMERGENCY_RINGBACK);
                }
            }

            g_strong = 31.0f - (float)seekBar.getProgress() / 100.0f;
            aimAtTarget(
                    getTargetAngle(),
                    (float)seekBar2.getProgress() / 100.0f,
                    g_strong,
                    (float)seekBar4.getProgress() / 10.0f,
                    (float)seekBar5.getProgress() / 10.0f,
                    bHs.isChecked() ? 1 : 0);
        }

        @Override
        public void run() {
            update();
            handler.postDelayed(runnable, 1);
        }
    } ;



    private void Beep(int duration, int volume, int sound)
    {
        final ToneGenerator tone = new ToneGenerator(AudioManager.STREAM_MUSIC, volume);
        tone.startTone(sound, duration);
        new Handler(Looper.getMainLooper()).postDelayed(new Runnable() {
            @Override
            public void run() {
                if (tone != null)
                tone.release();
            }
        }, duration + 50);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

        seekBar = ((SeekBar)findViewById(R.id.aim_strong));
        seekBar2 = ((SeekBar)findViewById(R.id.aim_fov));
        seekBar3 = ((SeekBar)findViewById(R.id.volume));
        seekBar4 = ((SeekBar)findViewById(R.id.preaim));
        seekBar5 = ((SeekBar)findViewById(R.id.sensitivity));
        bEsea = ((CheckBox)findViewById(R.id.incross));
        bHs = ((CheckBox)findViewById(R.id.hs));



        final TextView fov_text = (TextView)findViewById(R.id.fov_text);
        final TextView strength_text = (TextView)findViewById(R.id.strength);
        final TextView volume = (TextView)findViewById(R.id.volume_text);
        final TextView preaim = (TextView)findViewById(R.id.preaim_text);
        final TextView sensitivity = (TextView)findViewById(R.id.sensitivity_text);

        strength_text.setText("Strength: " +
                Float.toString((float)seekBar.getProgress() / 100.0f));

        fov_text.setText("Fov: " +
                (Float.toString((float)seekBar2.getProgress() / 100.0f)));

        volume.setText("Volume: " +
                Integer.toString(seekBar3.getProgress()));

        preaim.setText("PreAim: " +
                Float.toString((float)seekBar4.getProgress() / 10.0f));

        sensitivity.setText("Sensitivity: " +
                Float.toString((float)seekBar5.getProgress() / 10.0f));


        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                strength_text.setText("Strength: " +
                        Float.toString((float)progress / 100.0f));
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });

        seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                fov_text.setText("Fov: " +
                        (Float.toString((float)progress / 100.0f)));
            }
            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });

        seekBar3.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                volume.setText("Volume: " +
                        Integer.toString(progress));
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });

        seekBar4.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                preaim.setText("PreAim: " +
                        Float.toString((float)progress / 10.0f));
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });

        seekBar5.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                sensitivity.setText("Sensitivity: " +
                        Float.toString((float)progress / 10.0f));
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });

        g_strong = 31.0f - (float)seekBar.getProgress() / 100.0f;


        // Example of a call to a native method

        final Button connectButton = findViewById(R.id.connect_button);


        connectButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                EditText ipText = findViewById(R.id.ip_text);
                if (initClient(ipText.getText().toString()) != 0)
                    return;

                findViewById(R.id.ip_layout).setVisibility(View.GONE);
                findViewById(R.id.main_layout).setVisibility(View.VISIBLE);
                handler.post(runnable);
            }

        });
    }

    /*
    @Override
    protected void onDestroy()
    {
        super.onDestroy();
        handler.removeCallbacks(runnable);
        destroyClient();
    }*/

    /**
     * A native method that is implemented by the 'native-lib' native library,
     * which is packaged with this application.
     */
    public native int initClient(String ip);
    public native void closeClient();
    public native int getBestTarget(int besea);
    public native void resetTarget();
    public native int hasTarget();
    public native int targetDefusing();
    public native int getCurrentTick();
    public native int getPlayerInformation();
    public native float[] getTargetAngle();
    public native void aimAtTarget(float[] angle, float fov, float smooth,
                                   float preaim, float sensitivity, int hs);
}

```

`client_android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeWidth="1"
        android:strokeColor="#00000000">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>

```

`client_android/app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#008577"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`client_android/app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="V2.0 github.com/ekknod"></TextView>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:visibility="visible"
        android:id="@+id/ip_layout">
        <EditText
            android:id="@+id/ip_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:ems="10"
            android:inputType="textPersonName"
            android:text="192.168."
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="parent"
            app:layout_constraintVertical_bias="0.0" />

        <Button
            android:id="@+id/connect_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Connect"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="parent"
            app:layout_constraintVertical_bias="0.0" />


    </LinearLayout>

    <LinearLayout
        android:id="@+id/main_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:visibility="gone"
        android:orientation="vertical">



        <!-- <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"> -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Strength: "
            android:id="@+id/strength">
        </TextView>

        <SeekBar
            android:id="@+id/aim_strong"
            android:layout_width="match_parent"
            android:layout_height="12pt"
            android:max="3000"
            android:min="100"
            android:progress="1500"></SeekBar>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Fov: "
            android:id="@+id/fov_text">
        </TextView>

        <SeekBar
            android:id="@+id/aim_fov"
            android:layout_width="match_parent"
            android:layout_height="12pt"
            android:max="5000"
            android:min="500"
            android:progress="2000"></SeekBar>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="PreAim: "
            android:id="@+id/preaim_text">
        </TextView>

        <SeekBar
            android:id="@+id/preaim"
            android:layout_width="match_parent"
            android:layout_height="12pt"
            android:max="20"
            android:min="5"
            android:progress="9"></SeekBar>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Sensitivity: "
            android:id="@+id/sensitivity_text">
        </TextView>

        <SeekBar
            android:id="@+id/sensitivity"
            android:layout_width="match_parent"
            android:layout_height="12pt"
            android:max="40"
            android:min="5"
            android:progress="20"></SeekBar>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Volume: "
            android:id="@+id/volume_text">
        </TextView>

        <SeekBar
            android:id="@+id/volume"
            android:layout_width="match_parent"
            android:layout_height="12pt"
            android:max="100"
            android:min="0"
            android:progress="70"></SeekBar>

        <CheckBox
            android:id="@+id/incross"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="InCross"></CheckBox>

        <CheckBox
            android:id="@+id/hs"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="HS Mode"></CheckBox>
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>

```

`client_android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`client_android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`client_android/app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#008577</color>
    <color name="colorPrimaryDark">#00574B</color>
    <color name="colorAccent">#D81B60</color>
</resources>

```

`client_android/app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">Client</string>
</resources>

```

`client_android/app/src/main/res/values/styles.xml`:

```xml
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

</resources>

```

`client_android/app/src/test/java/com/example/client/ExampleUnitTest.java`:

```java
package com.example.client;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
```

`client_android/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        jcenter()
        
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.2'
        
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`client_android/gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true


```

`client_android/gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sun Nov 24 20:03:31 EET 2019
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip

```

`client_android/gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`client_android/gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`client_android/settings.gradle`:

```gradle
include ':app'
rootProject.name='Client'

```

`client_windows/client_windows.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29926.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client_windows", "client_windows.vcxproj", "{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Debug|x64.ActiveCfg = Debug|x64
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Debug|x64.Build.0 = Debug|x64
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Debug|x86.ActiveCfg = Debug|Win32
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Debug|x86.Build.0 = Debug|Win32
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Release|x64.ActiveCfg = Release|x64
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Release|x64.Build.0 = Release|x64
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Release|x86.ActiveCfg = Release|Win32
		{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E799898E-DDB2-4B0C-B465-B4AE0420CF33}
	EndGlobalSection
EndGlobal

```

`client_windows/client_windows.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{3C9F8926-3FC2-40A1-9423-24510A4DC5BE}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>clientwindows</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cs.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="maths.cpp" />
    <ClCompile Include="server.cpp" />
    <ClCompile Include="socket.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cs.h" />
    <ClInclude Include="maths.h" />
    <ClInclude Include="server.h" />
    <ClInclude Include="socket.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`client_windows/client_windows.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="socket.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="server.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="maths.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="socket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="server.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="cs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="maths.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`client_windows/client_windows.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`client_windows/config.cfg`:

```cfg
[settings]
ip=192.168.8.105
max_server_players=20
sensitivity=2.5

[aimbot]
key=108
key2=107
fov=25
smooth=10
horizontal_mode=0
aimtime=0

[triggerbot]
key=111
incross=1


```

`client_windows/cs.cpp`:

```cpp
#include "cs.h"
#include "server.h"
#include <stdio.h>

uint64_t g_process;
uint64_t g_process_pml4;

uint32_t g_client_dll;
uint32_t g_engine_dll;
uint32_t g_vstdlib_dll;
uint32_t g_inputsystem_dll;

uint32_t vt_client;
uint32_t vt_entity;
uint32_t vt_engine;
uint32_t vt_cvar;
uint32_t vt_input;

static uint32_t DT_BasePlayer;
static uint32_t DT_BaseEntity;
static uint32_t DT_CSPlayer;
static uint32_t DT_BaseAnimating;

uint32_t m_iHealth;
uint32_t m_vecViewOffset;
uint32_t m_lifeState;
uint32_t m_nTickBase;
uint32_t m_vecPunch;
uint32_t m_iTeamNum;
uint32_t m_vecOrigin;
uint32_t m_hActiveWeapon;
uint32_t m_iShotsFired;
uint32_t m_iCrossHairID;
uint32_t m_flFlashDuration;
uint32_t m_dwBoneMatrix;

uint32_t m_dwEntityList;
uint32_t m_dwClientState;
uint32_t m_dwGetLocalPlayer;
uint32_t m_dwGetViewAngles;
uint32_t m_dwGetMaxClients;
uint32_t m_dwState;
uint32_t m_dwButton;
uint32_t m_dwAnalogDelta;
uint32_t m_dwAnalog;
uint32_t m_bIsDefusing;
uint32_t m_bHasDefuser;
uint32_t m_dwGetPlayerInfo;


static uint32_t vm_attach_process(const char *process_name);
static uint32_t vm_dump_modules(void);
static uint32_t vm_dump_interfaces(void);
static uint32_t vm_dump_netvar_tables(void);
static uint32_t vm_dump_netvars(void);
static uint32_t vm_dump_offsets(void);


#ifdef _MSC_VER 
#define strncasecmp _strnicmp
#define strcasecmp _stricmp

#else
static double get_time()
{
	struct timeval t;
	struct timezone tzp;
	gettimeofday(&t, &tzp);
	return t.tv_sec + t.tv_usec*1e-6;
}
#endif



int32_t cs_initialize(void)
{


	if (g_process != 0) {
		char payload[1400];
		struct tcp_header *hdr = (struct tcp_header*)(payload);
		struct tcp_entry *ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), g_process + 0x304, g_system_pml4);
		STACK_EXECUTE(hdr, ehdr);
		if ((*(uint8_t*)((char *)hdr+4) >> 2 & 1) == 0) {
			goto skip;
		}
	}

	if (!vm_attach_process("csgo.exe")) {
		printf("failed to find target process\n");
		return 0;
	}
	

	if (!vm_dump_modules()) {
		printf("failed to dump modules\n");
		g_process = 0;
		return 0;
	}

	if (!vm_dump_interfaces()) {
		printf("failed to dump interfaces\n");
		g_process = 0;
		return 0;
	}

	if (!vm_dump_netvar_tables()) {
		printf("failed to dump netvar table\n");
		g_process = 0;
		return 0;
	}

	if (!vm_dump_netvars()) {
		printf("failed to dump netvars\n");
		g_process = 0;
		return 0;
	}

	if (!vm_dump_offsets()) {
		printf("failed to dump offsets\n");
		g_process = 0;
		return 0;
	}

skip:
	return 1;
}


static uint32_t vm_attach_process(const char *process_name)
{
	uint64_t entry = g_system_process;
	do {
		int valid = 1;
		char payload[1400];
		struct tcp_header *hdr;
		struct tcp_entry *ehdr;
		uint8_t exitprocess;
		const char *imagename;
		uint64_t directorytablebase;
		uint64_t nextentry;

		hdr = (struct tcp_header*)(payload);
		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x304, g_system_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x450, g_system_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), entry + 0x28, g_system_pml4);
		STACK_ADD_VM_COPY64(ehdr, 0, entry + 0x2F0, g_system_pml4);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			break;
		exitprocess = *(uint8_t*)((char *)hdr+4);
		imagename = ((char *)hdr+4+8);
		directorytablebase = *(uint64_t*)((char *)hdr+4+8+8);
		nextentry = *(uint64_t*)((char *)hdr+4+8+8+8);
		if ((exitprocess >> 2 & 1) == 1)
			valid = 0;
		
		if (valid && strncasecmp(imagename, process_name, 14) == 0) {
			g_process = entry;
			g_process_pml4 = directorytablebase;

			printf("[+] csgo.exe PML4: %llx\n", directorytablebase);
			return 1;
		}
		entry = nextentry;
		if (entry == 0)
			break;
		entry -= 0x2F0;

	} while ( entry != g_system_process ) ;

	return 0;
}


static char impl_upper(char c)
{
    if (c >= 97)
        c -= 32;
    return c;
}


static int impl_strcmp(const char *rcx, const char *rdx)
{
    int eax = 0;
    char r8b;
    while (1) {
        r8b = impl_upper(*(char*)(rcx + eax));
        if (r8b != impl_upper(*(char*)(rdx + eax)))
            break;
        if (r8b == 0)
            break;
        eax = eax + 1;
    }
    r8b -= *(char*)(rdx + eax);
    eax = r8b;
    return eax;
}


static int impl_wcscmp(const char *rcx, const char *rdx)
{
    int eax = 0;
    char r8b;
    while (1) {
        r8b = impl_upper(*(char*)(rcx));
        if (r8b != impl_upper(*(char*)(rdx + eax)))
            break;
        if (r8b == 0)
            break;
        rcx = rcx + 1;
        eax = eax + 2;
    }
    r8b -= *(char*)(rdx + eax);
    eax = r8b;
    return eax;
}


static uint32_t vm_dump_modules(void)
{

	int counter = 0;
	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;
	uint32_t a0, a1;

	hdr = (struct tcp_header*)(payload);
	ehdr = (struct tcp_entry*)(hdr + 1);

	STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), g_process + 0x428, g_system_pml4);
	STACK_ADD_VM_COPY64_P64(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), 0, g_system_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x0C, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x14, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0x04, g_process_pml4);
	STACK_EXECUTE(hdr, ehdr);
	if (hdr->status != 1)
		return 0;
	
	a0 = *(uint32_t*)((char *)hdr+28);
	a1 = *(uint32_t*)((char *)hdr+36);
	while (a0 != a1) {
		const char *name;
		uint32_t base;

		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x10, g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0, g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x28, g_process_pml4);
		STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 40);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			return 0;
			
		base = *(uint32_t*)((char *)hdr+4);
		a0 = *(uint32_t*)((char *)hdr+12);
		name = ((char *)hdr+28);
		if (!impl_wcscmp("client.dll", name)) {
			printf("[+] client.dll: %x\n", base);
			counter++;
			g_client_dll = base;
		}
		if (!impl_wcscmp("engine.dll", name)) {
			printf("[+] engine.dll: %x\n", base);
			counter++;
			g_engine_dll = base;
		}
		if (!impl_wcscmp("vstdlib.dll", name)) {
			printf("[+] vstdlib.dll: %x\n", base);
			counter++;
			g_vstdlib_dll = base;
		}
		if (!impl_wcscmp("inputsystem.dll", name)) {
			printf("[+] inputsystem.dll: %x\n", base);
			counter++;
			g_inputsystem_dll = base;
		}
		if (counter == 4)
			return 1;
	}

	return 0;
}


static uint32_t get_interface_factory(uint32_t base)
{

	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;
	uint32_t a1[4];

	hdr = (struct tcp_header*)payload;
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + 0x3C, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base + 0x78, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base + 0x18, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t)*2, base + 0x20, g_process_pml4);
	STACK_EXECUTE(hdr, ehdr);
	if (hdr->status != 1)
		return 0;
	a1[0] = *(uint32_t*)((char *)hdr+20);
	a1[1] = *(uint32_t*)((char *)hdr+24);
	a1[2] = *(uint32_t*)((char *)hdr+28);
	a1[3] = *(uint32_t*)((char *)hdr+32);
	while (a1[0]--) {
		const char *name;
		uint16_t ords;

		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[3] + (a1[0] * 2), g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[2] + (a1[0] * 4), g_process_pml4);
		STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), base, g_process_pml4, 16);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			break;
		
		ords = *(uint16_t*)((char *)hdr+4);
		name = ((char *)hdr+4+8+8);
		if (strcmp("CreateInterface", name))
			continue;

		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), base + a1[1] + (ords * 4), g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), base - 0x6A, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			break;
			
		return *(uint32_t*)((char *)hdr+20);
	}

	return 0;
}


static uint32_t get_interface(uint32_t factory, const char *name)
{
	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;

	while (factory != 0) {
		uint32_t interface_address;

		hdr = (struct tcp_header*)payload;
		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x01, g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory + 0x08, g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), factory + 0x04, g_process_pml4);
		STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 20);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			break;
		interface_address = *(uint32_t*)((char *)hdr+12);
		factory = *(uint32_t*)((char *)hdr+20);
		if (impl_strcmp(((char *)hdr+36), name) >> 4 == 3) {
			printf("[+] %s %x\n", name, interface_address);
			return interface_address;
		}
	}
	return 0;
}


static uint32_t vm_dump_interfaces(void)
{


	uint32_t factory;

	factory = get_interface_factory(g_client_dll);
	if (factory == 0)
		return 0;

	printf("[+] client.dll factory %lx\n", factory);

	vt_client = get_interface(factory, "VClient");
	if (vt_client == 0)
		return 0;

	vt_entity = get_interface(factory, "VClientEntityList");
	if (vt_entity == 0)
		return 0;
	
	factory = get_interface_factory(g_engine_dll);
	if (factory == 0)
		return 0;
	printf("[+] engine.dll factory %lx\n", factory);

	vt_engine = get_interface(factory, "VEngineClient");
	if (vt_engine == 0)
		return 0;

	factory = get_interface_factory(g_vstdlib_dll);
	if (factory == 0)
		return 0;

	printf("[+] vstdlib.dll factory %lx\n", factory);
	
	vt_cvar = get_interface(factory, "VEngineCvar");
	if (vt_cvar == 0)
		return 0;
		
	factory = get_interface_factory(g_inputsystem_dll);
	if (factory == 0)
		return 0;

	printf("[+] inputsystem.dll factory %lx\n", factory);
	
	vt_input = get_interface(factory, "InputSystemVersion");
	if (vt_input == 0)
		return 0;


	return 1;
}


static uint32_t vm_dump_netvar_tables(void)
{


	int counter = 0;
	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;
	uint32_t a0, a1;

	hdr = (struct tcp_header*)payload;
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_client, 8);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 1, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4);
	STACK_EXECUTE(hdr, ehdr);
	if (hdr->status != 1)
		return 0;

	a0 = *(uint32_t*)((char *)hdr+28);
	while (a0 != 0) {
		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x10, g_process_pml4);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), a0 + 0x0C, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), 0x0C, g_process_pml4);
		STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 17);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			return 0;
		a0 = *(uint32_t*)((char *)hdr+4);
		a1 = *(uint32_t*)((char *)hdr+12);

		if (!strcmp("DT_BasePlayer", ((char *)hdr+28))) {
			printf("[+] DT_BasePlayer %lx\n", a1);
			counter++;
			DT_BasePlayer = a1;
		}
		if (!strcmp("DT_BaseEntity", ((char *)hdr+28))) {
			printf("[+] DT_BaseEntity %lx\n", a1);
			counter++;
			DT_BaseEntity = a1;
		}
		if (!strcmp("DT_CSPlayer", ((char *)hdr+28))) {
			printf("[+] DT_CSPlayer %lx\n", a1);
			counter++;
			DT_CSPlayer = a1;
		}
		if (!strcmp("DT_BaseAnimating", ((char *)hdr+28))) {
			printf("[+] DT_BaseAnimating %lx\n", a1);
			counter++;
			DT_BaseAnimating = a1;
		}
		if (counter == 4)
			return 1;
	}

	return 0;
}


static uint32_t netvar_callback(uint32_t table, uint32_t (*callback)(const char *, int))
{


	uint32_t a0 = 0, a1, a3, a4, a5;
	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;

	hdr = (struct tcp_header*)payload;
	ehdr = (struct tcp_entry*)(hdr + 1);

	STACK_ADD_VM_COPY64(ehdr, 0,  table + 0x4, g_process_pml4);
	STACK_EXECUTE(hdr, ehdr);
	if (hdr->status != 1)
		return 0;
	for (a1 = *(uint32_t*)((char *)hdr+4); a1--; ) {
		char n[24];

		ehdr = (struct tcp_entry*)(hdr + 1);
		STACK_ADD_VM_COPY64(ehdr, sizeof(struct tcp_entry_copy64), table, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t), a1 * 60 + 0x28, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64p), sizeof(uint64_t)*2, a1 * 60, g_process_pml4);
		STACK_ADD_VM_COPY_P32(ehdr, 0, sizeof(uint64_t), 0, g_process_pml4, 24);
		STACK_EXECUTE(hdr, ehdr);
		if (hdr->status != 1)
			return 0;
			
		a4 = *(uint32_t*)((char *)hdr+12);
		a3 = *(uint32_t*)((char *)hdr+16);
		memcpy(n, ((char*)hdr + 28), 24);
		if (a4) {
			ehdr = (struct tcp_entry*)(hdr + 1);
			STACK_ADD_VM_COPY64(ehdr, 0, a4 + 0x4, g_process_pml4);
			STACK_EXECUTE(hdr, ehdr);
			if (hdr->status != 1)
				return 0;
			if (*(uint32_t*)((char*)hdr + 4)) {
				a5 = netvar_callback(a4, callback);
				if (a5 != 0)
					a0 += a3 + a5;
			}
		}
		if (callback(n, a3 + a0) != 0)
			return 1;
	}

	return a0;
}


static uint32_t dump_baseplayer(const char *name, int offset)
{


	static int counter = 0;
	if (!strcmp("m_iHealth", name)) {
		printf("[+] m_iHealth %lx\n", offset);
		counter++;
		m_iHealth = offset;
	}
	if (!strcmp("m_vecViewOffset[0]", name)) {
		printf("[+] m_vecViewOffset %lx\n", offset);
		counter++;
		m_vecViewOffset = offset;
	}
	if (!strcmp("m_lifeState", name)) {
		printf("[+] m_lifeState %lx\n", offset);
		counter++;
		m_lifeState = offset;
	}

	if (!strcmp("m_nTickBase", name) || strcmp("m_nTickBase", name) < -30) {
		printf("[+] m_nTickBase %lx\n", offset);
		counter++;
		m_nTickBase = offset;
	}
	if (!strcmp("m_Local", name)) {
		printf("[+] m_vecPunch %lx\n", offset + 0x70);
		counter++;
		m_vecPunch = offset + 0x70;
	}
	if (counter == 5) {
		counter = 0;
		return 1;
	}



	return 0;
}


static uint32_t dump_baseentity(const char *name, int offset)
{

	static int counter = 0;
	if (!strcmp("m_iTeamNum", name)) {
		printf("[+] m_iTeamNum %lx\n", offset);
		counter++;
		m_iTeamNum = offset;
	}
	if (!strcmp("m_vecOrigin", name)) {
		printf("[+] m_vecOrigin %lx\n", offset);
		counter++;
		m_vecOrigin = offset;
	}

	if (counter == 2) {
		counter = 0;
		return 1;
	}

	return 0;
}


static uint32_t dump_csplayer(const char *name, int offset)
{

	static int counter = 0;
	if (!strcmp("m_hActiveWeapon", name)) {
		printf("[+] m_hActiveWeapon %lx\n", offset);
		counter++;
		m_hActiveWeapon = offset;
	}
	if (!strcmp("m_iShotsFired", name)) {
		printf("[+] m_iShotsFired %lx\n", offset);
		counter++;
		m_iShotsFired = offset;
	}
	if (!strcmp("m_bHasDefuser", name)) {
		printf("[+] m_bHasDefuser %lx\n", offset);
		counter++;
		m_bHasDefuser = offset;
		m_iCrossHairID = offset + 0x5C;
	}
	if (!strcmp("m_bIsDefusing", name)) {
		printf("[+] m_bIsDefusing %lx\n", offset);
		counter++;
		m_bIsDefusing = offset;
	}
	if (!strcmp("m_flFlashDuration", name)) {
		printf("[+] m_flFlashDuration %lx\n", offset);
		counter++;
		m_flFlashDuration = offset;
	}
	if (counter == 5) {
		counter = 0;
		return 1;
	}

	return 0;
}


static uint32_t dump_baseanimating(const char *name, int offset)
{

	static int counter = 0;
	if (!strcmp("m_nForceBone", name)) {
		printf("[+] m_dwBoneMatrix %lx\n", offset + 0x1C);
		counter++;
		m_dwBoneMatrix = offset + 0x1C;
	}
	if (counter == 1) {
		counter = 0;
		return 1;
	}

	return 0;
}


static uint32_t vm_dump_netvars(void)
{


	if (!netvar_callback(DT_BasePlayer, dump_baseplayer))
		return 0;
	if (!netvar_callback(DT_BaseEntity, dump_baseentity))
		return 0;
	if (!netvar_callback(DT_CSPlayer, dump_csplayer))
		return 0;
	if (!netvar_callback(DT_BaseAnimating, dump_baseanimating))
		return 0;

	return 1;
}


static uint32_t vm_dump_offsets(void)
{


	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;

	hdr = (struct tcp_header*)payload;
	ehdr = (struct tcp_entry*)(hdr + 1);

	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_entity, 5);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x22, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 18);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x16, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 12);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x16, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 19);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0xB2, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 20);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x07, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 26);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x07, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 15);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x21D, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 18);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x29, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_input, 18);
	STACK_ADD_VM_COPY64_P32(ehdr, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), 0x09, g_process_pml4);
	STACK_ADD_VIRTUAL_FUNCTION(ehdr, vt_engine, 9);
	STACK_ADD_VM_COPY64_P32(ehdr, 0, sizeof(uint64_t), 0x13, g_process_pml4);
	STACK_EXECUTE(hdr, ehdr);
	if (hdr->status != 1)
		return 0;

	m_dwEntityList = vt_entity - *(uint32_t*)((char*)hdr + 20) + 0x38;
	m_dwClientState = *(uint32_t*)((char*)hdr + 52);
	m_dwGetLocalPlayer = *(uint32_t*)((char*)hdr + 76);
	m_dwGetViewAngles = *(uint32_t*)((char*)hdr + 100);
	m_dwGetMaxClients = *(uint32_t*)((char*)hdr + 124);
	m_dwState = *(uint32_t*)((char*)hdr + 148);
	m_dwButton = *(uint32_t*)((char*)hdr + 172);
	m_dwAnalogDelta = *(uint32_t*)((char*)hdr + 196);
	m_dwAnalog = *(uint32_t*)((char*)hdr + 220);
	m_dwGetPlayerInfo = *(uint32_t*)((char*)hdr + 244);


	printf("[+] m_dwEntityList %lx\n", m_dwEntityList);
	printf("[+] m_dwClientState %lx\n", m_dwClientState);
	printf("[+] m_dwGetLocalPlayer %lx\n", m_dwGetLocalPlayer);
	printf("[+] m_dwGetViewAngles %lx\n", m_dwGetViewAngles);
	printf("[+] m_dwGetMaxClients %lx\n", m_dwGetMaxClients);
	printf("[+] m_dwState %lx\n", m_dwState);
	printf("[+] m_dwButton %lx\n", m_dwButton);

	return 1;
}


```

`client_windows/cs.h`:

```h
#ifndef CS_H
#define CS_H

#include <inttypes.h>
#include "maths.h"

int32_t cs_initialize(void);

extern uint32_t g_client_dll;
extern uint32_t g_engine_dll;
extern uint32_t g_vstdlib_dll;
extern uint32_t g_inputsystem_dll;

extern uint32_t vt_client;
extern uint32_t vt_entity;
extern uint32_t vt_engine;
extern uint32_t vt_cvar;
extern uint32_t vt_input;


extern uint64_t g_process;
extern uint64_t g_process_pml4;
extern uint32_t m_iHealth;
extern uint32_t m_vecViewOffset;
extern uint32_t m_lifeState;
extern uint32_t m_nTickBase;
extern uint32_t m_vecPunch;
extern uint32_t m_iTeamNum;
extern uint32_t m_vecOrigin;
extern uint32_t m_hActiveWeapon;
extern uint32_t m_iShotsFired;
extern uint32_t m_iCrossHairID;
extern uint32_t m_flFlashDuration;
extern uint32_t m_dwBoneMatrix;
extern uint32_t m_dwEntityList;
extern uint32_t m_dwClientState;
extern uint32_t m_dwGetLocalPlayer;
extern uint32_t m_dwGetViewAngles;
extern uint32_t m_dwGetMaxClients;
extern uint32_t m_dwState;
extern uint32_t m_dwButton;
extern uint32_t m_dwAnalogDelta;
extern uint32_t m_dwAnalog;
extern uint32_t m_bIsDefusing;
extern uint32_t m_bHasDefuser;
extern uint32_t m_dwGetPlayerInfo;


#endif


```

`client_windows/main.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "socket.h"
#include "server.h"
#include "cs.h"
#include "maths.h"
#include <cmath>

static int tick_ms;

int g_local_index, g_target_id;
uint32_t g_previous_tick;
uint32_t g_local_address;
uint32_t g_target_address;
static vec3 g_eyepos;
static vec3 g_vecpunch;
static uint32_t g_shots_fired;
static uint32_t g_current_tick;
static vec3     g_viewangles;
static int      g_target_health;
static uint32_t g_button_0, g_button_1, g_button_2;
static vec3     g_mouse_delta, g_mouse_analog;
static vec3     g_target_bone;
static int      prev_tick;
static int      g_aimkey_0, g_aimkey_1, g_aimkey_2;
static int      tick_calculate;
char g_steamid[33]={0};
static uint32_t get_best_target(void);
static bool     get_player_information(void);
static vec3     get_target_angle(void);
static void     aimbot(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity);


static int     headonly;
static int     incross;

#if PLATFORM == PLATFORM_WINDOWS

#include <windows.h>

static int wait_thread;
int thread_args[2];
static void thread_beep()
{
	Beep(thread_args[0], thread_args[1]);
	wait_thread = 0;
}

void BEEP(int freq, int ms)
{
	if (wait_thread == 0) {
		thread_args[0] = freq;
		thread_args[1] = ms;
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)thread_beep, 0, 0, 0));
		wait_thread = 1;
	}
}


#elif PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX
void BEEP(int freq, int ms)
{
}

#include <unistd.h>

#endif





INT64 NtRand()
{
	LARGE_INTEGER counter;
#ifdef _KERNEL_MODE
	_KeQueryPerformanceCounter(&counter);

	
	return _RtlRandomEx((PULONG)&counter.QuadPart);
#else
	QueryPerformanceCounter(&counter);
	srand((unsigned int)counter.QuadPart);
	return rand();
#endif
}




#include <iostream>
#include <string>

#define DEFAULT_KEY "AlpcFreeCompletionListMessage"

int connect_server(const char *ip, uint16_t port, const char *dynamic)
{
#ifndef OG_CLIENT
    char result[30];
    char defaultkey[30] = DEFAULT_KEY;
    char next_key[30];

    memcpy(next_key, dynamic, 30);

    if (socket_open(ip, port) == 0)
        return -1;

    memcpy(decryption_key, defaultkey, 30);
    if (socket_send(next_key, 30) != 30)
        return -2;

    memcpy(decryption_key, dynamic, 30);
    if (socket_recv(result, 30) != 30)
        return -3;

    if (strcmp(result, dynamic) != 0)
        return -4;
#else
    if (socket_open(ip, port) == 0)
        return -1;

    memcpy(decryption_key, DEFAULT_KEY, 30);
#endif
    return 1;
}
int max_players, aim_time;
extern SOCKET g_socket;
int main(int argc, char **argv)
{





	float fov;
	float smooth;
	float sensitivity;
	std::string ip_address;



	char szPath[260];
	GetCurrentDirectoryA(260, szPath);
	std::string path(szPath + std::string("\\config.cfg"));


	char buffer_config[260] = { 0 };
	GetPrivateProfileStringA("settings", "ip", "192.168.8.106", buffer_config, 260, path.c_str());
	ip_address = buffer_config;
	GetPrivateProfileStringA("settings", "max_server_players", "20", buffer_config, 260, path.c_str());
	max_players = std::atoi(buffer_config);
	GetPrivateProfileStringA("aimbot", "key", "108", buffer_config, 260, path.c_str());
	g_aimkey_0 = std::atoi(buffer_config);
	GetPrivateProfileStringA("aimbot", "key2", "107", buffer_config, 260, path.c_str());
	g_aimkey_2 = std::atoi(buffer_config);
	GetPrivateProfileStringA("aimbot", "fov", "20", buffer_config, 260, path.c_str());
	fov = (float)std::atof(buffer_config) * 100.0f;
	GetPrivateProfileStringA("aimbot", "smooth", "20", buffer_config, 260, path.c_str());
	smooth = (float)std::atof(buffer_config);
	GetPrivateProfileStringA("aimbot", "horizontal_mode", "0", buffer_config, 260, path.c_str());
	headonly = std::atoi(buffer_config);
	GetPrivateProfileStringA("aimbot", "aimtime", "100", buffer_config, 260, path.c_str());
	aim_time = std::atoi(buffer_config);
	GetPrivateProfileStringA("settings", "sensitivity", "2.5", buffer_config, 260, path.c_str());
	sensitivity = (float)std::atof(buffer_config);
	GetPrivateProfileStringA("triggerbot", "key", "111", buffer_config, 260, path.c_str());
	g_aimkey_1 = std::atoi(buffer_config);
	GetPrivateProfileStringA("triggerbot", "incross", "1", buffer_config, 260, path.c_str());
	incross = std::atoi(buffer_config);


	if (!connect_server(ip_address.c_str(), 30609,"ClpWFCeeYomBlQtToDAisHMeJsQgX")) {
		std::cout << "server not found!" << std::endl;
		return 0;
	}


	if (!server_initialize()) {
		std::cout << "failed to initialize server" << std::endl;
		return 0;
	}

	if (!cs_initialize()) {
		std::cout << "failed to initialize game" << std::endl;
		return 0;
	}

	std::cout << "loaded succesfully" << std::endl;

	int prev_state = 0, prev_tick = 0;
	while (1) {
		vec3 target_angle;
		if (g_target_address == 0) {
			uint32_t result = get_best_target();
			if (result == -1)
				goto E0;

			if (result == 0)
				continue;
		}

		if (!get_player_information()) {
			g_target_address = 0;
			tick_calculate = 0;
			continue;
		}

		if (!g_target_health) {
			g_target_address = 0;
			tick_calculate = 0;
			continue;
		}

		target_angle = get_target_angle();
		aimbot(g_viewangles, target_angle, fov, smooth, sensitivity);
	}


E0:
	socket_close();
}


static uint32_t get_best_target(void)
{
	float best_fov = 360.0f;
	char buffer[1400];
	struct tcp_entry  *e;
	struct tcp_header *h;
	vec3 va;
	vec3 local_pos;
	vec3 entity_pos;
	

	h = (struct tcp_header*)buffer;
	e = (struct tcp_entry*)(h + 1);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetLocalPlayer, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetViewAngles, g_process_pml4);
	STACK_ADD_VM_COPY64(e, 0, m_dwClientState + m_dwState, g_process_pml4);
	STACK_EXECUTE(h, e);
	if (h->status != 1) {
		return -1;
	}

	g_local_index = *(int*)((char*)h + 4);
	*(uint64_t*)&va = *(uint64_t*)((char*)h + 12);
	if (*(int*)((char*)h + 20) != 6) {
		g_previous_tick = 0;
		prev_tick = 0;
		return 0;
	}

	e = (struct tcp_entry*)(h + 1);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwEntityList + g_local_index  * 0x10, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), m_iTeamNum, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*2, m_vecOrigin, g_process_pml4);
	STACK_ADD_VM_COPY64_P32(e, 0, sizeof(uint64_t)*3, m_iHealth, g_process_pml4);
	STACK_EXECUTE(h, e);
	if (h->status != 1)
		return 0;
	
	g_local_address = *(int*)((char*)h + 4);
	int local_team = *(int*)((char*)h + 12);
	*(uint64_t*)&local_pos = *(uint64_t*)((char*)h + 20);

	uint32_t temp_entity = 0;
	for (int i = 0; i < max_players; i++) {
		float angle[3], fov;

		e = (struct tcp_entry*)(h + 1);
		STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwEntityList + i * 0x10, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), m_iTeamNum, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*2, m_iHealth, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*3, m_lifeState, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*4, m_vecOrigin, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t)*5, 0xED, g_process_pml4);
		STACK_ADD_VM_COPY64_P32(e, 0, sizeof(uint64_t)*6, m_bIsDefusing, g_process_pml4);
		STACK_EXECUTE(h, e);

		if (h->status != 1)
			continue;
		
		int entity_address = *(int*)((char*)h + 4);
		int entity_team = *(int*)((char*)h + 12);
		int entity_health = *(int*)((char*)h + 20);
		int entity_lifestate = *(int*)((char*)h + 28);
		*(uint64_t*)&entity_pos = *(uint64_t*)((char*)h + 36);
	
		if (entity_team == local_team)
			continue;
	
		if (entity_health < 1)
			continue;

		if (entity_health > 100)
			continue;
		
		if (entity_lifestate)
			continue;

		if (*(bool*)((char*)h + 44))
			continue;

		if (*(bool*)((char*)h + 52)) {
			temp_entity = entity_address;
		}

		
		local_pos.z = 0;
		entity_pos.z = 0;
		CalcAngle((float*)&local_pos, (float*)&entity_pos, angle);
		vec_clamp((vec3*)&angle);
		fov = get_fov(va, *(vec3*)&angle);
		if (fov < best_fov) {
			best_fov = fov;
			g_target_address = entity_address;
			g_target_id = i;
		}
	}
	
	if (temp_entity != 0) {
		e = (struct tcp_entry*)(h + 1);
		STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), temp_entity + m_bIsDefusing, g_process_pml4);
		STACK_ADD_VM_COPY64(e, 0, temp_entity + m_bHasDefuser, g_process_pml4);
		STACK_EXECUTE(h, e);
		if (*(bool*)((char*)h + 4) == false) {
			goto E0;
		}
		if (*(bool*)((char*)h + 12)) {
		    BEEP(200, 100);
		} else {
		    BEEP(200, 300);
		}
	}
E0:
	return 360.0f != best_fov;
}




static bool get_player_information(void)
{
	char buffer[1400];
	struct tcp_entry  *e;
	struct tcp_header *h;



	h = (struct tcp_header*)buffer;
	e = (struct tcp_entry*)(h + 1);
	STACK_ADD_VM_COPY(e, sizeof(struct tcp_entry_copy) + 3*4, g_local_address + m_vecOrigin, g_process_pml4, 3*4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_vecViewOffset + 8, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_vecPunch, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_iShotsFired, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_local_address + m_nTickBase, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), m_dwClientState + m_dwGetViewAngles, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + m_iHealth, g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + (((g_aimkey_0 >> 5 ) * 4) + m_dwButton), g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + (((g_aimkey_1 >> 5 ) * 4) + m_dwButton), g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), vt_input + (((g_aimkey_2 >> 5 ) * 4) + m_dwButton), g_process_pml4);
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + 0xED, g_process_pml4);;
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), g_target_address + m_dwBoneMatrix, g_process_pml4);
	STACK_ADD_VM_COPY_P32(e, 0, sizeof(uint64_t), (0x30 * 8), g_process_pml4, 48);
	STACK_EXECUTE(h, e);
	if (h->status != 1)
		return 0;
	g_eyepos = *(vec3*)((char*)h + 4);
	g_eyepos.z += *(float*)((char*)h + 16);


	*(uint64_t*)&g_vecpunch = *(uint64_t*)((char*)h + 24);
	g_shots_fired = *(uint32_t*)((char*)h + 32);
	g_current_tick = *(uint32_t*)((char*)h + 40);
	*(uint64_t*)&g_viewangles = *(uint64_t*)((char*)h + 48);
	g_target_health = *(uint32_t*)((char*)h + 56);
	g_button_0 = (*(uint32_t*)((char*)h + 64) >> (g_aimkey_0 & 31)) & 1;
	g_button_1 = (*(uint32_t*)((char*)h + 72) >> (g_aimkey_1 & 31)) & 1;
	g_button_2 = (*(uint32_t*)((char*)h + 80) >> (g_aimkey_2 & 31)) & 1;
	bool tester = *(bool*)((char*)h + 88);
	g_target_bone.x = (*(matrix3x4_t*)((char*)h + 96+8))[0][3];
	g_target_bone.y = (*(matrix3x4_t*)((char*)h + 96+8))[1][3];
	g_target_bone.z = (*(matrix3x4_t*)((char*)h + 96+8))[2][3];

	if(g_target_health < 45) {
		tick_ms = 200;
	} else {
		tick_ms = 400;
	}


	if (g_button_1 && incross) {
		h = (struct tcp_header*)buffer;
		e = (struct tcp_entry*)(h + 1);
		STACK_ADD_VM_COPY64(e, /*sizeof(struct tcp_entry_copy64)*/0, g_local_address + m_iCrossHairID, g_process_pml4);
		STACK_EXECUTE(h, e);
		if (h->status != 1) {
			g_target_address = 0;
			tick_calculate = 0;
			return 0;
		}
		int g_crosshair_id = *(int*)((char*)h + 4);
		if (g_crosshair_id > 0 && g_crosshair_id <= 64 && g_current_tick - prev_tick > 3) {
			prev_tick = g_current_tick;
			server_move_mouse(1, 0, 0, 0);
			#if PLATFORM == PLATFORM_WINDOWS


			Sleep(NtRand() % (100-50 + 1) + 50);
			#else
			usleep(50000);
			#endif
			server_move_mouse(0, 0, 0, 0);
		}
	}
	


	if (tester || g_target_health < 1) {
		g_target_address = 0;
		tick_calculate = 0;
		return 0;
	}


	return 1;
}


static vec3 get_target_angle(void)
{
	vec3 m = g_target_bone;
	vec3 c = g_eyepos;
	c.x = m.x - c.x;
	c.y = m.y - c.y;
	c.z = m.z - c.z;
	vec_normalize(&c);
	vec_angles(c, &c);

	if (g_shots_fired > 1) {
		c.x = c.x - g_vecpunch.x * 2.0f;
		c.y = c.y - g_vecpunch.y * 2.0f;
		c.z = c.z - g_vecpunch.z * 2.0f;
	}

	vec_clamp(&c);
	return c;
}


#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))





static void aimbot(vec3 vangle, vec3 angle, float fov, float smooth, float sensitivity)
{
	float x, y, sx, sy;
	float dist = vec_distance(g_eyepos, g_target_bone);
	float pitch = (float)(sin(DEG2RAD(vangle.x - angle.x)) * dist );
	float yaw = (float) (sin(DEG2RAD(vangle.y - angle.y)) * dist );
	float dist_x = std::fabs(yaw);
	float dist_y = std::fabs(pitch);
	float tmp_fov = get_fov(vangle, angle);
	float dist_fov = get_fov_distance(vangle, angle, dist);

	if (dist_fov >= 4500.0f) {
		g_target_address = 0;
		tick_calculate = 0;
		return;
	}


	BEEP(400, tick_ms);





	if ( !g_button_0 && !g_button_2 && !g_button_1) {
		tick_calculate = 0;
		return;
	}


	if (dist_fov >= fov)
		return;

	if (aim_time && g_button_0 && dist_fov <= 550.0f)
		return;

	if (dist_fov <= 50.0f)
		return;


	y = vangle.x - angle.x, x = vangle.y - angle.y;
	if (y > 89.0f) y = 89.0f; else if (y < -89.0f) y = -89.0f;
	if (x > 180.0f) x -= 360.0f; else if (x < -180.0f) x += 360.0f;

	x = ((x / sensitivity) / 0.022f);
	y = ((y / sensitivity) / -0.022f);
	if (smooth > 1.00f) {
		sx = 0.0f, sy = 0.0f;
		if (sx < x)
			sx += 1.0f + (x / smooth);
		else if (sx > x)
			sx -= 1.0f - (x / smooth);
		if (sy < y)
			sy += 1.0f + (y / smooth);
		else if (sy > y)
			sy -= 1.0f - (y / smooth);
	} else {
		sx = x, sy = y;
	}

	if (!headonly) {
		if (pitch <= -20.0f)
			return;
		sy = 0;
	}

	if ((g_button_0 || g_button_1 || g_button_2) && g_current_tick - g_previous_tick > 0) {
		tick_calculate++;
		g_previous_tick = g_current_tick;
		server_move_mouse(0, (char) sx, (char)sy, 0);
	}

	if (!incross && g_button_1) {
		// pitch >= -20.0f
		// dist_x <= 3.5 

		if (dist_x <= 3.5f && pitch >= -5.5f) {

			DWORD required_ticks = NtRand() % (450 - 380 + 1) + 450;
			if (g_current_tick - prev_tick > required_ticks) {
				prev_tick = g_current_tick;
				server_move_mouse(1, 0, 0, 0);
				Sleep(NtRand() % (125-50 + 1) + 125);
				server_move_mouse(0, 0, 0, 0);
			}

		}

		
	}
}


static float clamp(float x, float min, float max)
{
    if (x < min) x = min;
    if (x > max) x = max;
    return x;
}


```

`client_windows/maths.cpp`:

```cpp
#include "maths.h"
#include <math.h>


#define RAD2DEG(x) ((float)(x) * (float)(180.f / 3.14159265358979323846f))
#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))


void sin_cos(float radians, float *sine, float *cosine)
{
    *sine = (float)sin(radians);
    *cosine = (float)cos(radians);
}

void angle_vec(vec3 angles, vec3 *forward)
{
    float sp, sy, cp, cy;
    sin_cos(DEG2RAD(angles.x), &sp, &cp);
    sin_cos(DEG2RAD(angles.y), &sy, &cy);
    forward->x = cp * cy;
    forward->y = cp * sy;
    forward->z = -sp;
}


float vec_dot(vec3 v0, vec3 v1)
{
    return (v0.x * v1.x + v0.y * v1.y + v0.z * v1.z);
}


float vec_length(vec3 v)
{
    return (v.x * v.x + v.y * v.y + v.z * v.z);
}


static vec3 vec_sub(vec3 p0, vec3 p1)
{
    vec3 r;

    r.x = p0.x - p1.x;
    r.y = p0.y - p1.y;
    r.z = p0.z - p1.z;
    return r;
}


float vec_length_sqrt(vec3 p0)
{
    return ( float )sqrt(p0.x * p0.x + p0.y * p0.y + p0.z * p0.z);
}


vec3 vec_delta(vec3 p0, vec3 p1)
{
    vec3  d;
    float l;

    d   = vec_sub(p0, p1);
    l   = (float)vec_length_sqrt(d);
    d.x /= l; d.y /= l; d.z /= l;
    return d;
}


float vec_distance(vec3 p0, vec3 p1)
{
    return vec_length_sqrt( vec_sub(p0, p1) ) ;
}


void vec_clamp(vec3 *v)
{
    if ( v->x > 89.0f && v->x <= 180.0f ) {
        v->x = 89.0f;
    }
    if ( v->x > 180.0f ) {
        v->x = v->x - 360.0f;
    }
    if( v->x < -89.0f ) {
        v->x = -89.0f;
    }
    v->y = fmodf(v->y + 180, 360) - 180;
    v->z = 0;
}



void vec_normalize(vec3 *vec)
{
    float radius;

    radius = 1.f / (float)(sqrt(vec->x*vec->x + vec->y*vec->y + vec->z*vec->z) + 1.192092896e-07f);
    vec->x *= radius, vec->y *= radius, vec->z *= radius;
}


vec3 vec_transform(vec3 p0, matrix3x4_t p1)
{
    vec3 v;

    v.x = (p0.x * p1[0][0] + p0.y * p1[0][1] + p0.z * p1[0][2]) + p1[0][3];
    v.y = (p0.x * p1[1][0] + p0.y * p1[1][1] + p0.z * p1[1][2]) + p1[1][3];
    v.z = (p0.x * p1[2][0] + p0.y * p1[2][1] + p0.z * p1[2][2]) + p1[2][3];
    return v;
}


vec3 vec_atd(vec3 vangle)
{
    double y[2], p[2];

    vangle.x *= (3.14159265358979323846f / 180.f);
    vangle.y *= (3.14159265358979323846f / 180.f);
    y[0]     = sin(vangle.y), y[1] = cos(vangle.y);
    p[0]     = sin(vangle.x), p[1] = cos(vangle.x);
    vangle.x = (float)(p[1] * y[1]);
    vangle.y = (float)(p[1] * y[0]);
    vangle.z = (float)-p[0];
    return vangle;
}


bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius)
{
    vec3     delta;
    uint32_t i;
    vec3     q;
    float    v;


    //
    // original maths by superdoc1234
    //
    delta = vec_delta(max, min);
    for ( i = 0; i < vec_distance(min, max); i++ ) {
        q.x = min.x + delta.x * (float)i - eye.x;
        q.y = min.y + delta.y * (float)i - eye.y;
        q.z = min.z + delta.z * (float)i - eye.z;
        if ((v = vec_dot(q, dir)) < 1.0f) {
            return 0;
        }
        v = radius * radius - (vec_length(q) - v * v);

        if ( v <= -100.f ) {
            return 0;
        }
        if (v >= 1.19209290E-07F) {
            return 1;
        }
    }
    return 0;
}


void vec_angles(vec3 forward, vec3 *angles)
{
    float tmp, yaw, pitch;

    if (forward.y == 0.f && forward.x == 0.f) {
        yaw = 0;
        if (forward.z > 0) {
            pitch = 270;
        } else {
            pitch = 90.f;
        }
    } else {
        yaw = (float)(atan2(forward.y, forward.x) * 180.f / 3.14159265358979323846f);
        if (yaw < 0) {
            yaw += 360.f;
        }
        tmp = (float)sqrt(forward.x * forward.x + forward.y * forward.y);
        pitch = (float)(atan2(-forward.z, tmp) * 180.f / 3.14159265358979323846f);
        if (pitch < 0) {
            pitch += 360.f;
        }
    }
    angles->x = pitch;
    angles->y = yaw;
    angles->z = 0.f;
}

float get_fov(vec3 vangle, vec3 angle)
{
    vec3 a0, a1;

    angle_vec(vangle, &a0);
    angle_vec(angle, &a1);
    return RAD2DEG(acos(vec_dot(a0, a1) / vec_length(a0)));
}

float get_fov_distance(vec3 vangle, vec3 angle, float distance)
{
	vec3 a0, a1;

	angle_vec(vangle, &a0);
	angle_vec(angle, &a1);
	return RAD2DEG((acos(vec_dot(a0, a1) / vec_length(a0))) * distance);
}

vec3 calc_angle(vec3 src, vec3 dst)
{
	vec3 m = dst;
	vec3 c = src;
	c.x = m.x - c.x;
	c.y = m.y - c.y;
	c.z = m.z - c.z;
	vec_normalize(&c);
	vec_angles(c, &c);
	vec_clamp(&c);
	return c;
}

void CalcAngle( float *src, float *dst, float *angles )
{
	double delta[3] = { (src[0]-dst[0]), (src[1]-dst[1]), (src[2] - dst[2]) };
	double hyp = sqrt(delta[0]*delta[0] + delta[1]*delta[1]);
	angles[0] = (float) (asinf( (float)(delta[2]/hyp) ) * 57.295779513082f);
	angles[1] = (float) (atanf( (float)(delta[1]/delta[0]) ) * 57.295779513082f);

	if(delta[0] >= 0.0)
		angles[1] += 180.0f;
}


```

`client_windows/maths.h`:

```h
#ifndef MATHS_H
#define MATHS_H


#include <inttypes.h>

#ifndef __cplusplus
typedef int bool;
#endif

typedef struct {
	float x, y;
} vec2 ;

typedef struct {
    int x, y;
} vec2i ;

typedef struct {
	float x, y, z;
} vec3 ;
typedef float matrix3x4_t[3][4];

/* translate maths to only X, Y */


void angle_vec(vec3 angles, vec3 *forward);
float vec_dot(vec3 v0, vec3 v1);
float vec_length(vec3 v);
float vec_length_sqrt(vec3 p0);
vec3 vec_delta(vec3 p0, vec3 p1);
float vec_distance(vec3 p0, vec3 p1);
void vec_clamp(vec3 *v);
void vec_normalize(vec3 *vec);
vec3 vec_transform(vec3 p0, matrix3x4_t p1);
vec3 vec_atd(vec3 vangle);
bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius);
void vec_angles(vec3 forward, vec3 *angles);
float get_fov(vec3 vangle, vec3 angle);
float get_fov_distance(vec3 vangle, vec3 angle, float distance);
vec3 calc_angle(vec3 src, vec3 dst);
void CalcAngle( float *src, float *dst, float *angles );
#endif


```

`client_windows/server.cpp`:

```cpp
#include "socket.h"
#include "server.h"
#include <stdio.h>

uint64_t g_system_process;
uint64_t g_system_pml4;




uint32_t server_initialize(void)
{
	unsigned char b_get_proc_address[] = {
		0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xD1, 0x4C, 0x8B, 0x40, 0x18, 0x8B, 0x42, 0x08, 0x4D,
		0x8B, 0x48, 0x20, 0x85, 0xC0, 0x74, 0x0E, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x4D, 0x8B, 0x09, 0x48, 0x83, 0xE8, 0x01, 0x75,
		0xF7, 0x4D, 0x8B, 0x49, 0x20, 0x41, 0x0F, 0xB7, 0x41, 0x3C, 0x42, 0x8B, 0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x42,
		0x0C, 0x42, 0x2B, 0x44, 0x09, 0x10, 0x42, 0x8B, 0x4C, 0x09, 0x1C, 0x49, 0x03, 0xC9, 0x44, 0x8B, 0x04, 0x81, 0x41, 0x0F,
		0xB7, 0x02, 0x4D, 0x03, 0xC1, 0x4E, 0x89, 0x04, 0x10, 0x66, 0x41, 0x83, 0x02, 0x08, 0xC3
	} ;
	unsigned char b_set_system_process[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55,
		0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0xBD, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B,
		0xF2, 0x48, 0x8B, 0xF9, 0xFF, 0xD5, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x49, 0xBC, 0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00,
		0x00, 0x44, 0x8D, 0x42, 0x20, 0x41, 0xFF, 0xD4, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x49, 0xBF, 0xF0, 0x80, 0xAD, 0x71,
		0xFE, 0x7F, 0x00, 0x00, 0x4D, 0x8B, 0xCF, 0x48, 0x8B, 0xD0, 0x49, 0xBD, 0xF0, 0x60, 0xAD, 0x74, 0xFE, 0x7F, 0x00, 0x00,
		0x48, 0x8B, 0xD8, 0x41, 0x8D, 0x48, 0xF0, 0x41, 0xFF, 0xD5, 0x49, 0xBE, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00,
		0x3D, 0x04, 0x00, 0x00, 0xC0, 0x75, 0x6C, 0xA1, 0xF0, 0x80, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00,
		0x00, 0xA3, 0xF0, 0x80, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD5, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC3, 0x33, 0xD2,
		0x41, 0xFF, 0xD6, 0x41, 0x8B, 0x1F, 0xFF, 0xD5, 0x48, 0x8B, 0xC8, 0x44, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD4, 0x45,
		0x8B, 0x07, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xD8, 0x41, 0x8D, 0x49, 0x10, 0x41, 0xFF, 0xD5, 0x85, 0xC0,
		0x75, 0x21, 0x48, 0x8B, 0x43, 0x10, 0x48, 0xA3, 0xF0, 0x90, 0xAD, 0x71, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD5, 0x48, 0x8B,
		0xC8, 0x4C, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD6, 0x66, 0x83, 0x07, 0x08, 0xEB, 0x16, 0xFF, 0xD5, 0x48, 0x8B, 0xC8,
		0x4C, 0x8B, 0xC3, 0x33, 0xD2, 0x41, 0xFF, 0xD6, 0x33, 0xC0, 0xC6, 0x47, 0x03, 0x00, 0x66, 0x89, 0x06, 0x48, 0x8B, 0x5C,
		0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5E,
		0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3
	} ;
	unsigned char b_open_device[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20,
		0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x60, 0x66, 0x83, 0x7A, 0x10, 0x00, 0x48, 0x8D, 0x6A, 0x10, 0x4C,
		0x8B, 0xFA, 0x4C, 0x8B, 0xF1, 0x48, 0x8B, 0xDD, 0x74, 0x0A, 0x48, 0x83, 0xC3, 0x02, 0x66, 0x83, 0x3B, 0x00, 0x75, 0xF6,
		0x49, 0xBC, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x41, 0xFF, 0xD4, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x48, 0xBF,
		0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x10, 0xFF, 0xD7, 0x48, 0x8B, 0xF0, 0x41, 0xFF, 0xD4,
		0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x44, 0x8D, 0x42, 0x30, 0xFF, 0xD7, 0x48, 0x89, 0x6E, 0x08, 0x49, 0x2B, 0xDF, 0x33, 0xED,
		0x48, 0x83, 0xEB, 0x10, 0x89, 0x6C, 0x24, 0x50, 0x48, 0x8B, 0xF8, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x4C, 0x8B, 0xC8, 0xC7,
		0x44, 0x24, 0x40, 0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC0, 0xC7, 0x44, 0x24, 0x38, 0x03, 0x00, 0x00, 0x00, 0xBA, 0x00,
		0x00, 0x10, 0xC0, 0x48, 0xD1, 0xFB, 0x66, 0x03, 0xDB, 0x89, 0x6C, 0x24, 0x30, 0x66, 0x89, 0x1E, 0x66, 0x83, 0xC3, 0x02,
		0x66, 0x89, 0x5E, 0x02, 0xC7, 0x00, 0x30, 0x00, 0x00, 0x00, 0x48, 0x89, 0x68, 0x08, 0x89, 0x68, 0x18, 0x48, 0x89, 0x70,
		0x10, 0x48, 0x89, 0x68, 0x20, 0x48, 0x89, 0x68, 0x28, 0x48, 0xB8, 0xD0, 0x64, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x49,
		0x8B, 0x4F, 0x08, 0xC7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0xD0, 0x8B, 0xD8,
		0x41, 0xFF, 0xD4, 0x4C, 0x8B, 0xC6, 0x48, 0x8B, 0xC8, 0x48, 0xBE, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x33,
		0xD2, 0xFF, 0xD6, 0x41, 0xFF, 0xD4, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC7, 0x33, 0xD2, 0xFF, 0xD6, 0x85, 0xDB, 0x74, 0x0B,
		0x41, 0xC7, 0x06, 0x04, 0x00, 0x01, 0x00, 0x66, 0x41, 0x89, 0x2F, 0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x20,
		0x49, 0x8B, 0x6B, 0x28, 0x49, 0x8B, 0x73, 0x30, 0x49, 0x8B, 0x7B, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41,
		0x5C, 0xC3
	} ;
/*
	unsigned char b_amd[] = {
		0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x4D, 0x00,
		0x44, 0x00, 0x52, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00
	} ;*/
	

	
	unsigned char b_amd[] = {
		0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x4D, 0x00,
		0x44, 0x00, 0x52, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x56, 0x00, 0x31, 0x00,
		0x36, 0x00, 0x00, 0x00
	} ;



	unsigned char b_logitech[] = {
		0x5C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x52, 0x00, 0x4F, 0x00, 0x4F, 0x00, 0x54, 0x00, 0x23, 0x00, 0x53, 0x00,
		0x59, 0x00, 0x53, 0x00, 0x54, 0x00, 0x45, 0x00, 0x4D, 0x00, 0x23, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31, 0x00,
		0x23, 0x00, 0x7B, 0x00, 0x31, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x30, 0x00, 0x35, 0x00, 0x63, 0x00, 0x30, 0x00,
		0x2D, 0x00, 0x63, 0x00, 0x33, 0x00, 0x37, 0x00, 0x38, 0x00, 0x2D, 0x00, 0x34, 0x00, 0x31, 0x00, 0x62, 0x00, 0x39, 0x00,
		0x2D, 0x00, 0x39, 0x00, 0x63, 0x00, 0x65, 0x00, 0x66, 0x00, 0x2D, 0x00, 0x64, 0x00, 0x66, 0x00, 0x31, 0x00, 0x61, 0x00,
		0x62, 0x00, 0x61, 0x00, 0x38, 0x00, 0x32, 0x00, 0x62, 0x00, 0x30, 0x00, 0x31, 0x00, 0x35, 0x00, 0x7D, 0x00, 0x00, 0x00
	} ;
	unsigned char b_copy_pml4[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x48, 0xBF, 0xC9, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xBE, 0x20, 0x6A, 0x56, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x3F, 0xFF, 0xD6,
		0x33, 0xD2, 0x48, 0x8B, 0xC8, 0x48, 0xB8, 0xC0, 0xDD, 0xA5, 0x74, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0xFF,
		0xD0, 0xC7, 0x44, 0x24, 0x48, 0x14, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9,
		0xC7, 0x44, 0x24, 0x38, 0x0C, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x30, 0x33, 0xD2, 0x48, 0xC7,
		0x00, 0xA0, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xC7, 0x40, 0x08, 0x08, 0x00, 0x00, 0x00, 0x48, 0xB8, 0xC8, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x28, 0x08, 0x2F, 0x11, 0x81, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0xB8,
		0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8B, 0x43, 0x0C, 0x48, 0xA3, 0xC7, 0xDD, 0xA9, 0x79,
		0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD6, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC3, 0x48, 0xB8, 0xF0, 0x59, 0x56, 0x74, 0xFE, 0x7F,
		0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x50, 0x5F, 0x48,
		0xFF, 0xE0
	} ;
	unsigned char b_copy_memory[] = {
		0x48, 0x83, 0xEC, 0x58, 0x48, 0x8B, 0xC1, 0x48, 0xB9, 0x00, 0x00, 0x38, 0x1F, 0x04, 0x00, 0x00, 0x00, 0x48, 0x3B, 0xC1,
		0x0F, 0x87, 0x83, 0x00, 0x00, 0x00, 0x49, 0xB8, 0xD3, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB9, 0xC9, 0xDD,
		0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0x09, 0x48, 0xA3, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F,
		0x00, 0x00, 0x8B, 0xC2, 0xA3, 0xCF, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x8D, 0x42, 0x0C, 0x89, 0x44, 0x24, 0x48,
		0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x8B, 0xD2, 0x49, 0x03, 0xD0,
		0xC7, 0x44, 0x24, 0x38, 0x0C, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x45, 0x33, 0xC0, 0xC7, 0x44, 0x24, 0x28,
		0x08, 0x2F, 0x11, 0x81, 0x48, 0xB8, 0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x20, 0x33,
		0xD2, 0xFF, 0xD0, 0x33, 0xC9, 0x85, 0xC0, 0x0F, 0x94, 0xC1, 0x8B, 0xC1, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0x33, 0xC0, 0x48,
		0x83, 0xC4, 0x58, 0xC3
	} ;
	unsigned char b_translate[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20,
		0x48, 0x8B, 0xC2, 0x48, 0x8B, 0xDA, 0x48, 0xC1, 0xE8, 0x27, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00,
		0x48, 0xBD, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5, 0x85, 0xC0, 0x0F, 0x84,
		0xC5, 0x00, 0x00, 0x00, 0x48, 0xBF, 0xD3, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0xC1, 0xE9,
		0x1E, 0x48, 0xBE, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x81, 0xE1, 0xFF, 0x01, 0x00, 0x00, 0xBA, 0x08, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x07, 0x48, 0x23, 0xC6, 0x48, 0x8D, 0x0C, 0xC8, 0xFF, 0xD5, 0x85, 0xC0, 0x0F, 0x84, 0x8B, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0x0F, 0x84, 0xC9, 0x79, 0x18, 0x48, 0xB8, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0x0F, 0x00, 0x81,
		0xE3, 0xFF, 0xFF, 0xFF, 0x3F, 0x48, 0x23, 0xC1, 0x48, 0x03, 0xC3, 0xEB, 0x6E, 0x48, 0x23, 0xCE, 0x48, 0x8B, 0xC3, 0x48,
		0xC1, 0xE8, 0x15, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5, 0x85,
		0xC0, 0x74, 0x4E, 0x48, 0x8B, 0x0F, 0x84, 0xC9, 0x79, 0x18, 0x48, 0xB8, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
		0x81, 0xE3, 0xFF, 0xFF, 0x1F, 0x00, 0x48, 0x23, 0xC1, 0x48, 0x03, 0xC3, 0xEB, 0x31, 0x48, 0x23, 0xCE, 0x48, 0x8B, 0xC3,
		0x48, 0xC1, 0xE8, 0x0C, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x25, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0xC1, 0xFF, 0xD5,
		0x85, 0xC0, 0x74, 0x11, 0x48, 0x8B, 0x07, 0x81, 0xE3, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x23, 0xC6, 0x48, 0x03, 0xC3, 0xEB,
		0x02, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83,
		0xC4, 0x20, 0x5F, 0xC3
	} ;
	unsigned char b_vmcopy[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0x52, 0x10,
		0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48,
		0x8B, 0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6,
		0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5,
		0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9,
		0xC1, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F,
		0x00, 0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_vmcopy_p32[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x48, 0x8B, 0xFA, 0x44, 0x0F, 0xB7,
		0x01, 0x48, 0x8B, 0xD9, 0x4C, 0x2B, 0xC0, 0x41, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48, 0x8B,
		0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD,
		0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5, 0xDD,
		0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9, 0xC1,
		0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00,
		0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_vmcopy_p64[] = {
		0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x48, 0x8B, 0xFA, 0x44, 0x0F, 0xB7,
		0x01, 0x48, 0x8B, 0xD9, 0x4C, 0x2B, 0xC0, 0x49, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x4F, 0x08, 0xFF, 0xD0, 0x8B, 0x57, 0x18, 0x48, 0x8B,
		0xC8, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD,
		0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC5, 0xDD,
		0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x18, 0x33, 0xD2, 0x66, 0x01, 0x03, 0x48, 0xB9, 0xC1,
		0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x44, 0x8B, 0x47, 0x18, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00,
		0x00, 0x41, 0x83, 0xC0, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_vmcopy64[] = {
		0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xC2, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0x52, 0x10, 0x48, 0x8B, 0x48, 0x08,
		0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00,
		0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
		0x00, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9,
		0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48,
		0x83, 0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_vmcopy64_p32[] = {
		0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x4C, 0x8B, 0xCA, 0x44, 0x0F, 0xB7, 0x01, 0x48, 0x8B, 0xD9,
		0x4C, 0x2B, 0xC0, 0x41, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
		0x00, 0x48, 0x8B, 0x52, 0x10, 0x49, 0x8B, 0x49, 0x08, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x48,
		0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9, 0x79,
		0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00,
		0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9, 0x79,
		0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48, 0x83,
		0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_vmcopy64_p64[] = {
		0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB7, 0x42, 0x04, 0x4C, 0x8B, 0xCA, 0x44, 0x0F, 0xB7, 0x01, 0x48, 0x8B, 0xD9,
		0x4C, 0x2B, 0xC0, 0x49, 0x8B, 0x04, 0x08, 0x48, 0x01, 0x42, 0x10, 0x48, 0xB8, 0xC7, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00,
		0x00, 0x48, 0x8B, 0x52, 0x10, 0x49, 0x8B, 0x49, 0x08, 0xFF, 0xD0, 0x48, 0x8B, 0xC8, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x48,
		0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x48, 0xBA, 0xC6, 0xDD, 0xA9, 0x79,
		0xFE, 0x7F, 0x00, 0x00, 0x88, 0x43, 0x03, 0x48, 0x03, 0xCB, 0x48, 0xB8, 0xC5, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00,
		0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x66, 0x83, 0x03, 0x08, 0x33, 0xD2, 0x48, 0xB9, 0xC1, 0xDD, 0xA9, 0x79,
		0xFE, 0x7F, 0x00, 0x00, 0x48, 0xB8, 0xC0, 0xC2, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0x44, 0x8D, 0x42, 0x14, 0x48, 0x83,
		0xC4, 0x20, 0x5B, 0x48, 0xFF, 0xE0
	} ;
	unsigned char b_move_mouse[] = {
		0x53, 0x48, 0x83, 0xEC, 0x58, 0x33, 0xC0, 0x48, 0x83, 0xC2, 0x04, 0x48, 0x8B, 0xD9, 0x89, 0x44, 0x24, 0x48, 0x48, 0xB9,
		0xC9, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9, 0xC7, 0x44, 0x24, 0x38,
		0x05, 0x00, 0x00, 0x00, 0x48, 0xB8, 0xC8, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x30, 0x45,
		0x33, 0xC0, 0x48, 0x8B, 0x09, 0x33, 0xD2, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x20, 0x2A, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20,
		0x48, 0xB8, 0x10, 0x5B, 0x9C, 0x64, 0xF8, 0x7F, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x0B, 0x89, 0x04, 0x19, 0x66, 0x83,
		0x03, 0x04, 0x48, 0x83, 0xC4, 0x58, 0x5B, 0xC3
	} ;
	unsigned char b_copy_i64[] = {
		0x0F, 0xB7, 0x11, 0x48, 0xA1, 0xC6, 0xDD, 0xA9, 0x79, 0xFE, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x04, 0x0A, 0x66, 0x83, 0x01,
		0x08, 0xC3
	} ;


	unsigned char b_NtCreateFile[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x55, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };
	unsigned char b_NtDeviceIoControlFile[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };
	unsigned char b_NtQuerySystemInformation[] = { 0x4C, 0x8B, 0xD1, 0xB8, 0x36, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };

	char payload[1400];
	uint8_t status = 1;
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;

	uint64_t address_NtDeviceIoControlFile;
	uint64_t address_memcpy;
	uint64_t address_memset;
	uint64_t address_HeapAlloc;
	uint64_t address_GetProcessHeap;
	uint64_t address_HeapFree;
	uint64_t heap_memory;
	uint64_t copy_memory;
	uint64_t translate_address;

	hdr = (struct tcp_header*)(payload);
	ehdr = (struct tcp_entry*)(hdr + 1);

	STACK_GET_ADDRESS(ehdr, 0, 0, 15);
	STACK_EXECUTE(hdr, ehdr);
	if (*(uint64_t*)((char *)hdr+4) != 0)
		goto skip;

	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_FUNCTION(ehdr, b_get_proc_address);
	STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 2219); /* memcpy */
	STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 2223); /* memset */
	STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 1, 701);  /* RtlAllocateHeap */
	STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 2, 692);  /* GetProcessHeap */
	STACK_ADD_GPA(ehdr, 4, sizeof(struct tcp_entry_address), 2, 841);  /* HeapFree */
	STACK_GET_HEAP(ehdr, sizeof(struct tcp_entry), 3); /* heap memory address */
	STACK_ADD_FUNCTION(ehdr, b_NtCreateFile);
	STACK_ADD_FUNCTION(ehdr, b_NtDeviceIoControlFile);
	STACK_ADD_FUNCTION(ehdr, b_NtQuerySystemInformation);
	STACK_GET_ADDRESS(ehdr, 0, sizeof(struct tcp_entry_address), 5);
	STACK_GET_ADDRESS(ehdr, 0, sizeof(struct tcp_entry_address), 6);
	STACK_GET_ADDRESS(ehdr, 0, 0, 7);
	STACK_EXECUTE(hdr, ehdr);

	address_memcpy = *(uint64_t*)((char *)hdr+4);
	address_memset = *(uint64_t*)((char *)hdr+12);
	address_HeapAlloc = *(uint64_t*)((char *)hdr+20);
	address_GetProcessHeap = *(uint64_t*)((char *)hdr+28);
	address_HeapFree = *(uint64_t*)((char *)hdr+36);
	heap_memory = *(uint64_t*)((char *)hdr+44);

	*(uint64_t*)(b_set_system_process + 0x1c + 2) = address_GetProcessHeap;
	*(uint64_t*)(b_set_system_process + 0x33 + 2) = address_HeapAlloc;
	*(uint64_t*)(b_set_system_process + 0x4a + 2) = heap_memory;
	*(uint64_t*)(b_set_system_process + 0x5a + 2) = *(uint64_t*)((char *)hdr+68);
	*(uint64_t*)(b_set_system_process + 0x6e + 2) = address_HeapFree;
	*(uint64_t*)(b_set_system_process + 0x7f + 1) = heap_memory;
	*(uint64_t*)(b_set_system_process + 0x8d + 1) = heap_memory;
	*(uint64_t*)(b_set_system_process + 0xce + 2) = heap_memory + 4096;

	*(uint64_t*)(b_open_device + 0x3c + 2) = address_GetProcessHeap;
	*(uint64_t*)(b_open_device + 0x4e + 2) = address_HeapAlloc;
	*(uint64_t*)(b_open_device + 0xd1 + 2) = *(uint64_t*)((char *)hdr+52);
	*(uint64_t*)(b_open_device + 0xf9 + 2) = address_HeapFree;

	*(uint64_t*)(b_copy_pml4 + 0x0f + 2) = (heap_memory + 4096 + 8);
	*(uint64_t*)(b_copy_pml4 + 0x19 + 2) = address_GetProcessHeap;
	*(uint64_t*)(b_copy_pml4 + 0x2d + 2) = address_HeapAlloc;
	*(uint64_t*)(b_copy_pml4 + 0x73 + 2) = heap_memory;
	*(uint64_t*)(b_copy_pml4 + 0x8a + 2) = *(uint64_t*)((char *)hdr+60);
	*(uint64_t*)(b_copy_pml4 + 0x9a + 2) = (heap_memory + 4096 + 24);
	*(uint64_t*)(b_copy_pml4 + 0xac + 2) = address_HeapFree;

	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_FUNCTION(ehdr, b_set_system_process);
	STACK_ADD_FUNCTION(ehdr, b_open_device);
	STACK_ADD_FUNCTION(ehdr, b_copy_pml4);
	STACK_ADD_SYSTEM_PROCESS(ehdr, sizeof(struct tcp_entry), 8);
	STACK_ADD_DEVICE(ehdr, 9, sizeof(struct tcp_entry_device), (uint64_t)(heap_memory + 4096 + 8), b_amd);
	STACK_ADD_DEVICE(ehdr, 9, sizeof(struct tcp_entry_device), (uint64_t)(heap_memory + 4096 + 16), b_logitech);
	STACK_ADD_PML4(ehdr, 0, 10);
	STACK_EXECUTE(hdr, ehdr);
	status = hdr->status;
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_CLEAR_FUNCTIONS(ehdr, sizeof(struct tcp_entry));
	STACK_ADD_FUNCTION(ehdr, b_NtDeviceIoControlFile);
	STACK_GET_ADDRESS(ehdr, 0, 0, 4);
	STACK_EXECUTE(hdr, ehdr);
	if (status != 1) {
		return 0;
	}

	address_NtDeviceIoControlFile = *(uint64_t*)((char *)hdr+4);
	*(uint64_t*)(b_copy_memory + 0x1A + 2) = heap_memory + 12;
	*(uint64_t*)(b_copy_memory + 0x24 + 2) = (heap_memory + 4096 + 8);
	*(uint64_t*)(b_copy_memory + 0x34 + 2) = heap_memory;
	*(uint64_t*)(b_copy_memory + 0x40 + 1) = heap_memory + 8;
	*(uint64_t*)(b_copy_memory + 0x50 + 2) = heap_memory;
	*(uint64_t*)(b_copy_memory + 0x7C + 2) = address_NtDeviceIoControlFile;

	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_FUNCTION(ehdr, b_copy_memory);
	STACK_GET_ADDRESS(ehdr, 0, 0, 5);
	STACK_EXECUTE(hdr, ehdr);

	copy_memory = *(uint64_t*)((char *)hdr+4);
	*(uint64_t*)(b_translate + 0x28 + 2) = copy_memory;
	*(uint64_t*)(b_translate + 0x40 + 2) = heap_memory + 12;

	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_FUNCTION(ehdr, b_translate);
	STACK_GET_ADDRESS(ehdr, 0, 0, 6);
	STACK_EXECUTE(hdr, ehdr);

	translate_address = *(uint64_t*)((char *)hdr+4);

	*(uint64_t*)(b_vmcopy + 0x14 + 2) = translate_address;
	*(uint64_t*)(b_vmcopy + 0x2a + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy + 0x39 + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy + 0x4d + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy + 0x62 + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy + 0x70 + 2) = address_memset;

	*(uint64_t*)(b_vmcopy_p32 + 0x23 + 2) = translate_address;
	*(uint64_t*)(b_vmcopy_p32 + 0x3d + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy_p32 + 0x4c + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy_p32 + 0x60 + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy_p32 + 0x75 + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy_p32 + 0x83 + 2) = address_memset;

	*(uint64_t*)(b_vmcopy_p64 + 0x23 + 2) = translate_address;
	*(uint64_t*)(b_vmcopy_p64 + 0x3d + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy_p64 + 0x4c + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy_p64 + 0x60 + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy_p64 + 0x75 + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy_p64 + 0x83 + 2) = address_memset;

	*(uint64_t*)(b_vmcopy64 + 0x14 + 2) = translate_address;
	*(uint64_t*)(b_vmcopy64 + 0x28 + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy64 + 0x37 + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy64 + 0x47 + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy64 + 0x5f + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy64 + 0x69 + 2) = address_memset;

	*(uint64_t*)(b_vmcopy64_p32 + 0x1f + 2) = translate_address;
	*(uint64_t*)(b_vmcopy64_p32 + 0x3b + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy64_p32 + 0x4a + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy64_p32 + 0x5a + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy64_p32 + 0x72 + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy64_p32 + 0x7c + 2) = address_memset;

	*(uint64_t*)(b_vmcopy64_p64 + 0x1f + 2) = translate_address;
	*(uint64_t*)(b_vmcopy64_p64 + 0x3b + 2) = copy_memory;
	*(uint64_t*)(b_vmcopy64_p64 + 0x4a + 2) = heap_memory + 12;
	*(uint64_t*)(b_vmcopy64_p64 + 0x5a + 2) = address_memcpy;
	*(uint64_t*)(b_vmcopy64_p64 + 0x72 + 2) = heap_memory;
	*(uint64_t*)(b_vmcopy64_p64 + 0x7c + 2) = address_memset;

	*(uint64_t*)(b_move_mouse + 0x12 + 2) = heap_memory + 4096 + 16;
	*(uint64_t*)(b_move_mouse + 0x2c + 2) = heap_memory;
	*(uint64_t*)(b_move_mouse + 0x50 + 2) = address_NtDeviceIoControlFile;

	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy_p32);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy_p64);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy64);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy64_p32);
	STACK_ADD_FUNCTION(ehdr, b_vmcopy64_p64);
	STACK_ADD_FUNCTION(ehdr, b_move_mouse);
	*(uint64_t*)(b_copy_i64 + 0x03 + 2) = heap_memory + 4096;
	STACK_ADD_FUNCTION(ehdr, b_copy_i64);
	*(uint64_t*)(b_copy_i64 + 0x03 + 2) = heap_memory + 4096 + 24;
	STACK_ADD_FUNCTION(ehdr, b_copy_i64);
	STACK_EMPTY_FUNCTION(ehdr, 0, 1);
	STACK_EXECUTE(hdr, ehdr);
skip:
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_EMPTY_FUNCTION(ehdr, 0, 14);
	STACK_EXECUTE(hdr, ehdr);
	g_system_process = *(uint64_t*)((char *)hdr+4);
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_EMPTY_FUNCTION(ehdr, 0, 15);
	STACK_EXECUTE(hdr, ehdr);
	status = hdr->status;
	g_system_pml4 = *(uint64_t*)((char *)hdr+4);

	printf("[+] PsInitialSystemProcess: 0x%llx\n", g_system_process);
	printf("[+] PML4: 0x%llx\n", g_system_pml4);

	return status;
}

uint32_t server_move_mouse(int8_t button, int8_t x, int8_t y, int8_t wheel)
{

	char payload[1400];
	struct tcp_header *hdr;
	struct tcp_entry *ehdr;
	hdr = (struct tcp_header*)(payload);
	ehdr = (struct tcp_entry*)(hdr + 1);
	STACK_ADD_MOUSE(ehdr, 0, button, x, y, wheel);
	STACK_EXECUTE(hdr, ehdr);

	return *(uint32_t*)((char *)hdr+4);
}

```

`client_windows/server.h`:

```h
#ifndef SERVER_H
#define SERVER_H

#include <inttypes.h>
#include <string.h>
#include "socket.h"

struct tcp_header {
	uint16_t size;
	uint8_t  retn, status;
} ;

struct tcp_entry {
	uint16_t next;
	uint16_t id;
} ;

struct tcp_entry_address {
    struct tcp_entry ehdr;
//#if INTPTR_MAX == INT32_MAX
//    uint32_t wow64fix;
//#endif
    uint64_t address;
};

struct tcp_entry_device {
    struct tcp_entry entry;
//#if INTPTR_MAX == INT32_MAX
//    uint32_t wow64fix;
//#endif
    uint64_t stack_address;
    char name[120];
};

struct tcp_entry_copy64 {
    struct tcp_entry ehdr;
//#if INTPTR_MAX == INT32_MAX
//    uint32_t wow64fix;
//#endif
    uint64_t dir_entry;
    uint64_t address;
};

struct tcp_entry_copy64p {
    struct tcp_entry ehdr;
    uint16_t prev;
    uint64_t dir_entry;
    uint64_t address;
};

struct tcp_entry_copy {
    struct tcp_entry ehdr;
//#if INTPTR_MAX == INT32_MAX
//    uint32_t wow64fix;
//#endif
    uint64_t dir_entry;
    uint64_t address;
    uint32_t length;
};

struct tcp_entry_copyp {
    struct tcp_entry ehdr;
    uint16_t prev;
    uint64_t dir_entry;
    uint64_t address;
    uint32_t length;
};

struct tcp_entry_mouse {
    struct tcp_entry ehdr;
    int8_t button;
    int8_t x;
    int8_t y;
    int8_t wheel;
    int8_t unk1;
};

#if PLATFORM != PLATFORM_WINDOWS

#define FIELD_OFFSET(type, field)    ((int)(long)&(((type *)0)->field))

#endif

#define STACK_ADD_FUNCTION(e,d) { \
	(e)->id = 1; \
	(e)->next = 4 + sizeof(d); \
	memcpy(((char *)e + 4), d, sizeof(d)); \
	e = (struct tcp_entry *)(e + 1); \
	e = (struct tcp_entry *)((char *)e + sizeof(d)); \
}

/* we have to use this, if we dont have anything else to call in stack */
#define STACK_EMPTY_FUNCTION(e,n,i) { \
	(e)->id = (i); \
	(e)->next = (n); \
	e = (struct tcp_entry *)(e + 1); \
}

#define STACK_END_FUNCTION STACK_EMPTY_FUNCTION
#define STACK_GET_HEAP STACK_EMPTY_FUNCTION
#define STACK_ADD_SYSTEM_PROCESS STACK_EMPTY_FUNCTION
#define STACK_ADD_PML4 STACK_EMPTY_FUNCTION

#define STACK_CLEAR_FUNCTIONS(e, n) { \
	(e)->id = (2); \
	(e)->next = n; \
	e = (struct tcp_entry *)(e + 1); \
}

#define STACK_ADD_ADDRESS(e,i,n,m,x) { \
	(e)->id = (i); \
	(e)->next = (n); \
	((uint32_t*)&(((struct tcp_entry_address*)e))->address)[0] = (m); \
	((uint32_t*)&(((struct tcp_entry_address*)e))->address)[1] = (x); \
	e = (struct tcp_entry *)((struct tcp_entry_address*)e + 1); \
}

#define STACK_GET_ADDRESS(e,i,n,f) { \
	(e)->id = (i); \
	(e)->next = (n); \
	(((struct tcp_entry_address*)e))->address = (f); \
	e = (struct tcp_entry *)((struct tcp_entry_address*)e + 1); \
}

#define STACK_ADD_DEVICE(e,i,n,a,b) { \
	(e)->id = (i); \
	(e)->next = (n); \
	((struct tcp_entry_device *)e)->stack_address = (a); \
	memcpy(((struct tcp_entry_device *)e)->name, b, sizeof(b)); \
	e = (struct tcp_entry *)((struct tcp_entry_device*)e + 1); \
}

#define STACK_ADD_VM_COPY(e,n,a,d,l) { \
	(e)->id = (7); \
	(e)->next = (n); \
	((struct tcp_entry_copy *)e)->address = (a); \
	((struct tcp_entry_copy *)e)->length = (l); \
	((struct tcp_entry_copy *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy*)e + 1); \
	e = (struct tcp_entry *)((char *)e + l); \
}

#define STACK_ADD_VM_COPY_P32(e,n,p,a,d,l) { \
	(e)->id = (8); \
	(e)->next = (n); \
	((struct tcp_entry_copyp*)e)->prev = (p); \
	((struct tcp_entry_copyp*)e)->address = (a); \
	((struct tcp_entry_copyp*)e)->length = (l); \
	((struct tcp_entry_copyp*)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copyp*)e + 1); \
}

#define STACK_ADD_VM_COPY_P64(e,n,p,a,d,l) { \
	(e)->id = (9); \
	(e)->next = (n); \
	((struct tcp_entry_copyp*)e)->prev = (p); \
	((struct tcp_entry_copyp*)e)->address = (a); \
	((struct tcp_entry_copyp*)e)->length = (l); \
	((struct tcp_entry_copyp*)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copyp*)e + 1); \
}

#define STACK_ADD_VM_COPY64(e,n,a,d) { \
	(e)->id = (10); \
	(e)->next = (n); \
	((struct tcp_entry_copy64 *)e)->address = (a); \
	((struct tcp_entry_copy64 *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64*)e + 1); \
}

#define STACK_ADD_VM_COPY64_P32(e,n,p,a,d) { \
	(e)->id = (11); \
	(e)->next = (n); \
	((struct tcp_entry_copy64p *)e)->prev = (p); \
	((struct tcp_entry_copy64p *)e)->address = (a); \
	((struct tcp_entry_copy64p *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64p*)e + 1); \
}

#define STACK_ADD_VM_COPY64_P64(e,n,p,a,d) { \
	(e)->id = (12); \
	(e)->next = (n); \
	((struct tcp_entry_copy64p *)e)->prev = (p); \
	((struct tcp_entry_copy64p *)e)->address = (a); \
	((struct tcp_entry_copy64p *)e)->dir_entry = (d); \
	e = (struct tcp_entry *)((struct tcp_entry_copy64p*)e + 1); \
}

#define STACK_ADD_MOUSE(e,n,b,x,y,w) { \
	(e)->id = (13); \
	(e)->next = (n); \
	((struct tcp_entry_mouse*)e)->button = (b); \
	((struct tcp_entry_mouse*)e)->x = (x); \
	((struct tcp_entry_mouse*)e)->y = (y); \
	((struct tcp_entry_mouse*)e)->wheel = (w); \
	((struct tcp_entry_mouse*)e)->unk1 = (0); \
	e = (struct tcp_entry *)((struct tcp_entry_mouse*)e + 1); \
}

#define STACK_ADD_GPA STACK_ADD_ADDRESS

#define STACK_EXECUTE(h, e) { \
	(h)->size = 4; \
	(h)->retn = 1; \
	(h)->status = 1; \
	socket_send(h, (int)((char *)e - (char*)h)); \
	socket_recv(h, 1400); \
	e = (struct tcp_entry*)(h + 1); \
}

#define STACK_EXECUTE_NO_RETURN(h, e) { \
	(h)->size = 4; \
	(h)->retn = 0; \
	socket_send(h, (int)((char *)e - (char*)h)); \
	e = (struct tcp_entry*)(h + 1); \
}


#define STACK_ADD_VIRTUAL_FUNCTION(e, v, i) { \
	STACK_ADD_VM_COPY64(e, sizeof(struct tcp_entry_copy64), v, g_process_pml4); \
	STACK_ADD_VM_COPY64_P32(e, sizeof(struct tcp_entry_copy64), sizeof(uint64_t), i * 4, g_process_pml4); \
}

uint32_t server_initialize(void);
uint32_t server_move_mouse(int8_t button, int8_t x, int8_t y, int8_t wheel);

extern uint64_t g_system_process;
extern uint64_t g_system_pml4;

#endif


```

`client_windows/socket.cpp`:

```cpp
#include "socket.h"
#include <string.h>

#if PLATFORM == PLATFORM_WINDOWS
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment( lib, "Ws2_32.lib")
typedef int64_t sock_t;
#elif PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
typedef int32_t sock_t;
#endif


static unsigned int inet_pton4(const char* src);
void RC4(void *data, int length, unsigned char *key);

char decryption_key[30];

SOCKET g_socket = INVALID_SOCKET;
static SOCKET g_client;
static SOCKET get_socket_0(void) { return g_socket; }
static SOCKET get_socket_1(void) { return g_client; }
static SOCKET (*get_socket)(void);

uint32_t socket_open(const char *ip, uint16_t port)
{
	SOCKET sock;
	int no_delay = 1;
	struct sockaddr_in address;

	if (g_socket != INVALID_SOCKET)
		return 1;

#if PLATFORM == PLATFORM_WINDOWS
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == -1) {
		return 0;
	}

	address.sin_family = AF_INET;
	address.sin_port = port;
	if (ip == 0) {
		address.sin_addr.s_addr = 0;
		if (bind(sock, (struct sockaddr*)&address, sizeof(address)) == -1)
			return 0;
		if (listen(sock, 1) == 0)
			return 0;
		get_socket = get_socket_1;
	} else {
		address.sin_addr.s_addr = inet_pton4(ip);
		if (connect(sock, (struct sockaddr*)&address, sizeof(address)) == -1)
			return 0;
		get_socket = get_socket_0;
	}
	if (setsockopt(sock, IPPROTO_TCP, 1, (const char*)&no_delay, sizeof(no_delay)) == -1)
		return 0;

	g_socket = sock;

	return 1;
}


uint32_t socket_domain_exists(const char* domain_ip, const char* port)
{
#if PLATFORM == PLATFORM_WINDOWS
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif
	struct addrinfo hints = { 0 }, * addrs;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	const int status = getaddrinfo(domain_ip, port, &hints, &addrs);
	return status == 0;
}
#include <stdio.h>

uint32_t socket_open_dns(const char* domain_ip, const char *port)
{
	int no_delay = 1;

#if PLATFORM == PLATFORM_WINDOWS
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif

	struct addrinfo hints = { 0 }, * addrs;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if (g_socket != INVALID_SOCKET)
		return 1;

	const int status = getaddrinfo(domain_ip, port, &hints, &addrs);
	if (status != 0)
		return 0;

	for (struct addrinfo* addr = addrs; addr != NULL; addr = addr->ai_next) {

		SOCKET sock = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);
		if (sock == -1)
			continue;

		if (connect(sock, addr->ai_addr, (int)addr->ai_addrlen) == -1) {
			closesocket(sock);
			continue;
		}
		get_socket = get_socket_0;
		g_socket = sock;
		break;
	}
	freeaddrinfo(addrs);

	if (g_socket == INVALID_SOCKET)
		return 0;

	if (setsockopt(g_socket, IPPROTO_TCP, 1, (const char*)&no_delay, sizeof(no_delay)) == -1)
		return 0;
	return 1;
}


void socket_close(void)
{
	if (g_socket != 0) {
#if PLATFORM == PLATFORM_WINDOWS
		closesocket(g_socket);
		WSACleanup();
#else
		close(g_socket);
#endif
		g_socket = INVALID_SOCKET;
	}

	if (g_client != 0) {
#if PLATFORM == PLATFORM_WINDOWS
		closesocket(g_client);
		WSACleanup();
#else
		close(g_client);
#endif
		g_client = INVALID_SOCKET;
	}
}


int socket_recv(void *data, int size)
{
	int len = recv(get_socket(), (char *)data, size, 0);
	RC4((char *)data, len, (unsigned char *)decryption_key);
	return len;
}


int socket_send(void *data, int size)
{
	RC4((char*)data, size, (unsigned char *)decryption_key);
	return send(get_socket(), (const char *)data, size, 0);
}


void socket_open_client(void)
{
	int len = sizeof(struct sockaddr_in);
	struct sockaddr_in address;
	g_client = accept(g_socket, (struct sockaddr *)&address, &len);
}


void socket_close_client(void)
{
#if PLATFORM == PLATFORM_WINDOWS
	closesocket(g_client);
#else
	close(g_client);
#endif
}


static unsigned int inet_pton4(const char* src)
{
	static const char digits[] = "0123456789";
	int saw_digit, octets, ch;
#define NS_INADDRSZ	4
	unsigned char tmp[NS_INADDRSZ], * tp;

	saw_digit = 0;
	octets = 0;
	*(tp = tmp) = 0;
	while ((ch = *src++) != '\0') {
		const char* pch;

		if ((pch = strchr(digits, ch)) != NULL) {
			unsigned int n = *tp * 10 + (int)(pch - digits);

			if (saw_digit && *tp == 0)
				return (0);
			if (n > 255)
				return (0);
			*tp = n;
			if (!saw_digit) {
				if (++octets > 4)
					return (0);
				saw_digit = 1;
			}
		}
		else if (ch == '.' && saw_digit) {
			if (octets == 4)
				return (0);
			*++tp = 0;
			saw_digit = 0;
		}
		else
			return (0);
	}
	if (octets < 4)
		return (0);
	return *(unsigned int*)&tmp;
}


void RC4(void *data, int length, unsigned char *key)
{
	unsigned char T[128];
	unsigned char S[128];
	unsigned char tmp;
	int i, j = 0, x, t = 0;

	for (i = 0; i < 128; i++) {
		S[i]=i;
		T[i]= key[i % 30];
	}
	for(i = 0 ; i < 128; i++) {
		j = ( j + S[i] + T[i] ) % 128;
		tmp = S[j];
		S[j]= S[i];
		S[i] = tmp;
	}
	j = 0;
	for(x = 0 ; x < length; x++) {
		i = (i+1) % 128;
		j = (j + S[i]) % 128;
		tmp = S[j];
		S[j]= S[i];
		S[i] = tmp;
		t = (S[i] + S[j]) % 128;
		((unsigned char *)data)[x] = ((unsigned char *)data)[x]^S[t];
	}
}


```

`client_windows/socket.h`:

```h
#ifndef SOCKET_H
#define SOCKET_H

#include <inttypes.h>

#define PLATFORM_WINDOWS  1
#define PLATFORM_MAC      2
#define PLATFORM_UNIX     3

#if defined(_WIN32)
typedef int64_t sock_t;
#define PLATFORM PLATFORM_WINDOWS
#elif defined(__APPLE__)
typedef int32_t sock_t;
#define PLATFORM PLATFORM_MAC
#else
typedef int32_t sock_t;
#define PLATFORM PLATFORM_UNIX
#endif


uint32_t socket_open(const char *ip, uint16_t port);
uint32_t socket_open_dns(const char* domain_ip, const char* port);
uint32_t socket_domain_exists(const char* domain_ip, const char* port);
void     socket_close(void);
int      socket_recv(void *data, int size);
int      socket_send(void *data, int size);
void     socket_open_client(void);
void     socket_close_client(void);
void     RC4(void *data, int length, unsigned char *key);
extern char decryption_key[30];

#endif


```

`server/main.c`:

```c
#include "socket.h"
#include <windows.h>
#include <intrin.h>

struct tcp_entry_address {
	struct tcp_entry ehdr;
	uint64_t address;
};

const char *g_decryption_key;
const char *get_decryption_key(void)
{
	uint64_t base = *(uint64_t*)(__readgsqword(0x60) + 0x18);
	uint64_t a0;

	base = *(uint64_t*)(base + 0x20);
	base = *(uint64_t*)(base);
	base = *(uint64_t*)(base + 0x20);

	a0 = base + *(uint16_t*)(base + 0x3C);
	a0 = base + *(uint32_t*)(a0 + 0x88);
	a0 = *(int*)(base + *(int*)(a0 + 0x20) + (4 * 4));

	return (const char*)(base + a0);
}

static char heap[8192];
static void *function_list[32];
static void *function_data;
static int  function_count, function_size;

static void function_add(struct tcp_header *hdr, struct tcp_entry *ehdr)
{
	int len = ehdr->next - 4;
	struct tcp_entry_address *entry = (struct tcp_entry_address*)ehdr;

	if (len == -4)
		return;

	VirtualAlloc(function_data, 8192, MEM_COMMIT, PAGE_READWRITE);
	memcpy(
		(void*)((char *)function_data + function_size),
		(void*)((char *)ehdr + sizeof(struct tcp_entry)),
		len);
	function_list[function_count++] = (void*)((char *)function_data + function_size);
	function_size += len;
	VirtualAlloc(function_data, 8192, MEM_COMMIT, PAGE_EXECUTE_READ);
}

static void function_clear(struct tcp_header *hdr, struct tcp_entry *ehdr)
{
	VirtualAlloc(function_data, 8192, MEM_COMMIT, PAGE_READWRITE);
	memset(function_data, 0, function_size);
	function_count = 4;
	function_size  = 0; 
	VirtualAlloc(function_data, 8192, MEM_COMMIT, PAGE_EXECUTE_READ);
}

static void function_heap(struct tcp_header *hdr, struct tcp_entry *ehdr)
{
	*(uint64_t*)((char *)hdr + hdr->size) = (uint64_t)&heap;
	hdr->size += sizeof(uint64_t);
}

static void function_address(struct tcp_header *hdr, struct tcp_entry *ehdr)
{
	struct tcp_entry_address *entry = (struct tcp_entry_address*)ehdr;
	*(uint64_t*)((char *)hdr + hdr->size) = (uint64_t)function_list[entry->address];
	hdr->size += sizeof(uint64_t);
}

static void packet_routine(char *data)
{
	struct tcp_header *hdr = (struct tcp_header *)data;
	struct tcp_entry *ehdr = (struct tcp_entry *)(data + sizeof(struct tcp_header));
	while (1) {
		uint16_t next = ehdr->next;

		((void (*)(struct tcp_header *, struct tcp_entry *))function_list[ehdr->id])(hdr, ehdr);
		if (next == 0)
			break;

		ehdr = (struct tcp_entry *)((char *)ehdr + next);
	}
	if (hdr->retn)
		socket_send(data, hdr->size);
}

#ifdef _DEBUG
int main(void)
{
	g_decryption_key = get_decryption_key();
	function_data = VirtualAlloc(0, 8192, MEM_COMMIT, PAGE_EXECUTE_READ);
	if (function_data == 0)
		return 0;
	memset(function_list, 0, sizeof(function_list));
	function_list[function_count++] = function_address;
	function_list[function_count++] = function_add;
	function_list[function_count++] = function_clear;
	function_list[function_count++] = function_heap;
	socket_open(0, 30609);
	char* buffer = malloc(1024 * 500);
	while (1) {
		key = 0;
		memcpy(decryption_key, g_decryption_key, 30);
		socket_open_client();
		while (1) {
			int bytes = socket_recv(buffer, 1024 * 500);

			if (bytes < 8)
				break;

			if (key == 0) {
				if (bytes != 30)
					break;
				memcpy(decryption_key, buffer, 30);
				socket_send(buffer, 30);
				key = 1;
				continue;
			}
			packet_routine(buffer);
		}
		socket_close_client();
	}
	free(buffer);
	VirtualFree(function_data, 8192, MEM_FREE);
}
#else

static int key;
DWORD WINAPI MainThread(LPVOID lpThreadParameter)
{
	g_decryption_key = get_decryption_key();
	function_data = VirtualAlloc(0, 8192, MEM_COMMIT, PAGE_EXECUTE_READ);
	if (function_data == 0)
		return 0;
	memset(function_list, 0, sizeof(function_list));
	function_list[function_count++] = function_address;
	function_list[function_count++] = function_add;
	function_list[function_count++] = function_clear;
	function_list[function_count++] = function_heap;
	char* buffer = malloc(1024 * 500);
	while (1) {
		key = 0;
		memcpy(decryption_key, g_decryption_key, 30);
		socket_open_client();
		while (1) {
			int bytes = socket_recv(buffer, 1024 * 500);

			if (bytes < 8)
				break;

			if (key == 0) {
				if (bytes != 30)
					break;
				memcpy(decryption_key, buffer, 30);
				socket_send(buffer, 30);
				key = 1;
				continue;
			}
			packet_routine(buffer);
		}
		socket_close_client();
	}
	free(buffer);
	VirtualFree(function_data, 8192, MEM_FREE);
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD rea, LPVOID res)
{
	BOOL status = 0;
	switch (rea) {
	case DLL_PROCESS_ATTACH:
		socket_open(0, 30609);
		status = 1;
		CloseHandle(CreateThread(0, 0, MainThread, 0, 0, 0));
		break;
	case DLL_PROCESS_DETACH:
		socket_close();
		break;
	}
	return status;
}

#endif

```

`server/server.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29509.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "server", "server.vcxproj", "{F580DB3F-496B-4E4B-BC2B-0C2349E55428}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Debug|x64.ActiveCfg = Debug|x64
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Debug|x64.Build.0 = Debug|x64
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Debug|x86.ActiveCfg = Debug|Win32
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Debug|x86.Build.0 = Debug|Win32
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Release|x64.ActiveCfg = Release|x64
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Release|x64.Build.0 = Release|x64
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Release|x86.ActiveCfg = Release|Win32
		{F580DB3F-496B-4E4B-BC2B-0C2349E55428}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {21F84320-B9BB-48E1-B2A9-682482E5C56D}
	EndGlobalSection
EndGlobal

```

`server/server.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F580DB3F-496B-4E4B-BC2B-0C2349E55428}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>server</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>opengl32</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;SERVER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;SERVER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;SERVER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;SERVER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CompileAs>CompileAsC</CompileAs>
      <ExceptionHandling>false</ExceptionHandling>
      <FloatingPointExceptions>false</FloatingPointExceptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="socket.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="socket.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`server/server.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="socket.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="socket.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`server/server.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`server/socket.c`:

```c
#include "socket.h"
#include <string.h>

#if PLATFORM == PLATFORM_WINDOWS
#include <winsock2.h>
#pragma comment( lib, "wsock32.lib" )
typedef int64_t sock_t;
#elif PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
typedef int32_t sock_t;
#endif


static unsigned int inet_pton4(const char* src);



static sock_t g_socket;
static sock_t g_client;
static sock_t get_socket_0(void) { return g_socket; }
static sock_t get_socket_1(void) { return g_client; }
static sock_t(*get_socket)(void);
char decryption_key[30];

int socket_open(const char* ip, uint16_t port)
{
	int no_delay = 1;
	struct sockaddr_in address;

#if PLATFORM == PLATFORM_WINDOWS
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif

	g_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	address.sin_family = AF_INET;
	address.sin_port = port;
	if (ip == 0) {
		address.sin_addr.s_addr = 0;
		bind(g_socket, (struct sockaddr*) & address, sizeof(address));
		listen(g_socket, 1);
		get_socket = get_socket_1;
	}
	else {
		address.sin_addr.s_addr = inet_pton4(ip);
		connect(g_socket, (struct sockaddr*) & address, sizeof(address));
		get_socket = get_socket_0;
	}
	setsockopt(g_socket, IPPROTO_TCP, 1, (void*)&no_delay, sizeof(no_delay));

	return 1;
}


void socket_close(void)
{
#if PLATFORM == PLATFORM_WINDOWS
	closesocket(g_socket);
	WSACleanup();
#else
	close(g_socket);
#endif
}


int socket_recv(void* data, int size)
{
	int len = recv(get_socket(), data, size, 0);
	RC4((char*)data, len, (unsigned char*)decryption_key);
	return len;
}


int socket_send(void* data, int size)
{
	RC4((char*)data, size, (unsigned char*)decryption_key);
	return send(get_socket(), data, size, 0);
}


void socket_open_client(void)
{
	int len = sizeof(struct sockaddr_in);
	struct sockaddr_in address;
	g_client = accept(g_socket, (struct sockaddr*) & address, &len);
}


void socket_close_client(void)
{
#if PLATFORM == PLATFORM_WINDOWS
	closesocket(g_client);
#else
	close(g_client);
#endif
}


static unsigned int inet_pton4(const char* src)
{
	static const char digits[] = "0123456789";
	int saw_digit, octets, ch;
#define NS_INADDRSZ	4
	unsigned char tmp[NS_INADDRSZ], * tp;

	saw_digit = 0;
	octets = 0;
	*(tp = tmp) = 0;
	while ((ch = *src++) != '\0') {
		const char* pch;

		if ((pch = strchr(digits, ch)) != NULL) {
			unsigned int n = *tp * 10 + (int)(pch - digits);

			if (saw_digit && *tp == 0)
				return (0);
			if (n > 255)
				return (0);
			*tp = n;
			if (!saw_digit) {
				if (++octets > 4)
					return (0);
				saw_digit = 1;
			}
		}
		else if (ch == '.' && saw_digit) {
			if (octets == 4)
				return (0);
			*++tp = 0;
			saw_digit = 0;
		}
		else
			return (0);
	}
	if (octets < 4)
		return (0);
	return *(unsigned int*)&tmp;
}

void RC4(void* data, int length, unsigned char* key)
{
	unsigned char T[128];
	unsigned char S[128];
	unsigned char tmp;
	int i, j = 0, x, t = 0;

	for (i = 0; i < 128; i++) {
		S[i] = i;
		T[i] = key[i % 30];
	}
	for (i = 0; i < 128; i++) {
		j = (j + S[i] + T[i]) % 128;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
	}
	j = 0;
	for (x = 0; x < length; x++) {
		i = (i + 1) % 128;
		j = (j + S[i]) % 128;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
		t = (S[i] + S[j]) % 128;
		((unsigned char*)data)[x] = ((unsigned char*)data)[x] ^ S[t];
	}
}


```

`server/socket.h`:

```h
#ifndef SOCKET_H
#define SOCKET_H

#include <inttypes.h>

#define PLATFORM_WINDOWS  1
#define PLATFORM_MAC      2
#define PLATFORM_UNIX     3

#if defined(_WIN32)
typedef int64_t sock_t;
#define PLATFORM PLATFORM_WINDOWS
#elif defined(__APPLE__)
typedef int32_t sock_t;
#define PLATFORM PLATFORM_MAC
#else
typedef int32_t sock_t;
#define PLATFORM PLATFORM_UNIX
#endif

struct tcp_header {
	uint16_t size;
	uint8_t  retn, status;
}; /* size, 4bytes */

struct tcp_entry {
	uint16_t next;
	uint16_t id;
}; /* size, 4bytes */


int  socket_open(const char* ip, uint16_t port);
void socket_close(void);
int  socket_recv(void* data, int size);
int  socket_send(void* data, int size);
void socket_open_client(void);
void socket_close_client(void);
void RC4(void* data, int length, unsigned char* key);
extern char decryption_key[30];

#endif


```