Project Path: arc_gmh5225_modmap_2we81czq

Source Tree:

```txt
arc_gmh5225_modmap_2we81czq
├── README.md
├── driver
│   ├── core.c
│   ├── core.h
│   ├── driver.inf
│   ├── driver.vcxproj
│   ├── driver.vcxproj.filters
│   ├── main.c
│   ├── stdafx.h
│   ├── util.c
│   └── util.h
└── modmap
    ├── comm.cpp
    ├── comm.h
    ├── hijack.cpp
    ├── hijack.h
    ├── main.cpp
    ├── map.cpp
    ├── map.h
    ├── modmap.vcxproj
    ├── modmap.vcxproj.filters
    └── stdafx.h

```

`README.md`:

```md
# Module Extending Manual Mapper

DLL manual mapper that will forcefully extend the size of a pre-existing module and map itself there.

## Procedure

1. Pick a module.
2. If there will be no conflicts, forcefully allocate memory immediately after the module's end.
3. Extend the size of the module in its LDR entry to match.
4. Map the DLL into this created region.

## Usage

1. Load the driver
2.  `modmap <PROCESS> <TARGETMODULE> <DLL>`
    - For example: `modmap fortniteclient-win64-shipping.exe d3d11.dll example.dll`

## Note

This was only tested on Windows 10 1803, 1809, 1903, 1909 and is intended for a x64 target process and DLL.
```

`driver/core.c`:

```c
#include "stdafx.h"

extern PMMVAD(*MiAllocateVad)(UINT_PTR start, UINT_PTR end, LOGICAL deletable);
extern NTSTATUS(*MiInsertVadCharges)(PMMVAD vad, PEPROCESS process);
extern VOID(*MiInsertVad)(PMMVAD vad, PEPROCESS process);

PLDR_DATA_TABLE_ENTRY GetModuleByName(PEPROCESS process, PWCHAR moduleName) {
	UNICODE_STRING moduleNameStr = { 0 };
	RtlInitUnicodeString(&moduleNameStr, moduleName);

	PLIST_ENTRY list = &(PsGetProcessPeb(process)->Ldr->InLoadOrderModuleList);
	for (PLIST_ENTRY entry = list->Flink; entry != list; ) {
		PLDR_DATA_TABLE_ENTRY module = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (RtlCompareUnicodeString(&module->BaseDllName, &moduleNameStr, TRUE) == 0) {
			return module;
		}

		entry = module->InLoadOrderLinks.Flink;
	}

	return NULL;
}

NTSTATUS CoreExtend(PREQUEST_EXTEND args) {
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (!NT_SUCCESS(status)) {
		return status;
	}

	KeAttachProcess(process);

	PLDR_DATA_TABLE_ENTRY module = GetModuleByName(process, args->Module);
	if (!module) {
		status = STATUS_NOT_FOUND;
		goto cleanup;
	}

	UINT_PTR start = (UINT_PTR)module->DllBase + module->SizeOfImage;
	UINT_PTR end = start + args->Size - 1;

	MEMORY_BASIC_INFORMATION info = { 0 };
	status = ZwQueryVirtualMemory(NtCurrentProcess(), (PVOID)start, MemoryBasicInformation, &info, sizeof(info), NULL);
	if (!NT_SUCCESS(status)) {
		goto cleanup;
	}

	if (info.State != MEM_FREE || info.BaseAddress != (PVOID)start || info.RegionSize < args->Size) {
		status = STATUS_INVALID_ADDRESS;
		goto cleanup;
	}

	PMMVAD vad = MiAllocateVad(start, end, TRUE);
	if (!vad) {
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto cleanup;
	}

	static RTL_OSVERSIONINFOW version = { sizeof(RTL_OSVERSIONINFOW) };
	if (!version.dwBuildNumber) {
		RtlGetVersion(&version);
	}

	if (version.dwBuildNumber < 18362) {
		PMMVAD_FLAGS flags = (PMMVAD_FLAGS)&vad->u1.LongFlags;
		flags->Protection = MM_EXECUTE_READWRITE;
		flags->NoChange = 0;
	} else {
		PMMVAD_FLAGS_19H flags = (PMMVAD_FLAGS_19H)&vad->u1.LongFlags;
		flags->Protection = MM_EXECUTE_READWRITE;
		flags->NoChange = 0;
	}

	if (!NT_SUCCESS(status = MiInsertVadCharges(vad, process))) {
		ExFreePool(vad);
		goto cleanup;
	}

	// We should call MiLockVad but /shrug
	MiInsertVad(vad, process);
	module->SizeOfImage += args->Size;

cleanup:
	KeDetachProcess();
	ObDereferenceObject(process);
	return status;
}

NTSTATUS CoreWrite(PREQUEST_WRITE args) {
	if (((PBYTE)args->Src + args->Size < (PBYTE)args->Src) ||
		((PBYTE)args->Dest + args->Size < (PBYTE)args->Dest) ||
		((PVOID)((PBYTE)args->Src + args->Size) > MM_HIGHEST_USER_ADDRESS) ||
		((PVOID)((PBYTE)args->Dest + args->Size) > MM_HIGHEST_USER_ADDRESS)) {

		return STATUS_ACCESS_VIOLATION;
	}

	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		SIZE_T outSize = 0;
		status = MmCopyVirtualMemory(PsGetCurrentProcess(), args->Src, process, args->Dest, (SIZE_T)args->Size, KernelMode, &outSize);
		ObDereferenceObject(process);
	}

	return status;
}

NTSTATUS CoreRead(PREQUEST_READ args) {
	if (((PBYTE)args->Src + args->Size < (PBYTE)args->Src) ||
		((PBYTE)args->Dest + args->Size < (PBYTE)args->Dest) ||
		((PVOID)((PBYTE)args->Src + args->Size) > MM_HIGHEST_USER_ADDRESS) ||
		((PVOID)((PBYTE)args->Dest + args->Size) > MM_HIGHEST_USER_ADDRESS)) {

		return STATUS_ACCESS_VIOLATION;
	}

	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		SIZE_T outSize = 0;
		status = MmCopyVirtualMemory(process, args->Src, PsGetCurrentProcess(), args->Dest, (SIZE_T)args->Size, KernelMode, &outSize);
		ObDereferenceObject(process);
	}

	return status;
}

NTSTATUS CoreProtect(PREQUEST_PROTECT args) {
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		DWORD protect = 0;
		if (SafeCopy(&protect, args->InOutProtect, sizeof(protect))) {
			SIZE_T size = args->Size;

			KeAttachProcess(process);
			status = ZwProtectVirtualMemory(NtCurrentProcess(), &args->Address, &size, protect, &protect);
			KeDetachProcess();

			SafeCopy(args->InOutProtect, &protect, sizeof(protect));
		} else {
			status = STATUS_ACCESS_VIOLATION;
		}
		
		ObDereferenceObject(process);
	}

	return status;
}

NTSTATUS CoreAlloc(PREQUEST_ALLOC args) {
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		PVOID address = NULL;
		SIZE_T size = args->Size;

		KeAttachProcess(process);
		ZwAllocateVirtualMemory(NtCurrentProcess(), &address, 0, &size, MEM_COMMIT | MEM_RESERVE, args->Protect);
		KeDetachProcess();

		SafeCopy(args->OutAddress, &address, sizeof(address));

		ObDereferenceObject(process);
	}

	return status;
}

NTSTATUS CoreFree(PREQUEST_FREE args) {
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		SIZE_T size = 0;

		KeAttachProcess(process);
		ZwFreeVirtualMemory(NtCurrentProcess(), &args->Address, &size, MEM_RELEASE);
		KeDetachProcess();

		ObDereferenceObject(process);
	}

	return status;
}

NTSTATUS CoreModule(PREQUEST_MODULE args) {
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		PVOID base = NULL;
		DWORD size = 0;

		KeAttachProcess(process);

		PLDR_DATA_TABLE_ENTRY module = GetModuleByName(process, args->Module);
		if (module) {
			base = module->DllBase;
			size = module->SizeOfImage;
		} else {
			status = STATUS_NOT_FOUND;
		}

		KeDetachProcess();

		if (NT_SUCCESS(status)) {
			SafeCopy(args->OutAddress, &base, sizeof(base));
			SafeCopy(args->OutSize, &size, sizeof(size));
		}

		ObDereferenceObject(process);
	}

	return status;
}
```

`driver/core.h`:

```h
#pragma once

#define DATA_UNIQUE (0x1234)

typedef enum _REQUEST_TYPE {
	RequestTypeExtend,
	RequestTypeWrite,
	RequestTypeRead,
	RequestTypeProtect,
	RequestTypeAlloc,
	RequestTypeFree,
	RequestTypeModule,
} REQUEST_TYPE;

typedef struct _REQUEST_DATA {
	DWORD Unique;
	REQUEST_TYPE Type;
	PVOID Arguments;
} REQUEST_DATA, *PREQUEST_DATA;

typedef struct _REQUEST_EXTEND {
	DWORD ProcessId;
	WCHAR Module[0xFF];
	DWORD Size;
} REQUEST_EXTEND, *PREQUEST_EXTEND;

typedef struct _REQUEST_WRITE {
	DWORD ProcessId;
	PVOID Dest;
	PVOID Src;
	DWORD Size;
} REQUEST_WRITE, *PREQUEST_WRITE;

typedef struct _REQUEST_READ {
	DWORD ProcessId;
	PVOID Dest;
	PVOID Src;
	DWORD Size;
} REQUEST_READ, *PREQUEST_READ;

typedef struct _REQUEST_PROTECT {
	DWORD ProcessId;
	PVOID Address;
	DWORD Size;
	PDWORD InOutProtect;
} REQUEST_PROTECT, *PREQUEST_PROTECT;

typedef struct _REQUEST_ALLOC {
	DWORD ProcessId;
	PVOID OutAddress;
	DWORD Size;
	DWORD Protect;
} REQUEST_ALLOC, *PREQUEST_ALLOC;

typedef struct _REQUEST_FREE {
	DWORD ProcessId;
	PVOID Address;
} REQUEST_FREE, *PREQUEST_FREE;

typedef struct _REQUEST_MODULE {
	DWORD ProcessId;
	WCHAR Module[0xFF];
	PVOID *OutAddress;
	PDWORD OutSize;
} REQUEST_MODULE, *PREQUEST_MODULE;

NTSTATUS CoreExtend(PREQUEST_EXTEND args);
NTSTATUS CoreWrite(PREQUEST_WRITE args);
NTSTATUS CoreRead(PREQUEST_READ args);
NTSTATUS CoreProtect(PREQUEST_PROTECT args);
NTSTATUS CoreAlloc(PREQUEST_ALLOC args);
NTSTATUS CoreFree(PREQUEST_FREE args);
NTSTATUS CoreModule(PREQUEST_MODULE args);

```

`driver/driver.inf`:

```inf
;
; driver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=driver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
driver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
driver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%driver.DeviceDesc%=driver_Device, Root\driver ; TODO: edit hw-id

[driver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
driver.sys

;-------------- Service installation
[driver_Device.NT.Services]
AddService = driver,%SPSVCINST_ASSOCSERVICE%, driver_Service_Inst

; -------------- driver driver install sections
[driver_Service_Inst]
DisplayName    = %driver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\driver.sys

;
;--- driver_Device Coinstaller installation ------
;

[driver_Device.NT.CoInstallers]
AddReg=driver_Device_CoInstaller_AddReg
CopyFiles=driver_Device_CoInstaller_CopyFiles

[driver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[driver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[driver_Device.NT.Wdf]
KmdfService =  driver, driver_wdfsect
[driver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "driver Installation Disk"
driver.DeviceDesc = "driver Device"
driver.SVCDESC = "driver Service"

```

`driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3800BCCA-5E44-4F4D-BC9F-A2D52B0B97F6}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>driver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driver/driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`driver/main.c`:

```c
#include "stdafx.h"

INT64(NTAPI *EnumerateDebuggingDevicesOriginal)(PVOID, PVOID);

PMMVAD(*MiAllocateVad)(UINT_PTR start, UINT_PTR end, LOGICAL deletable);
NTSTATUS(*MiInsertVadCharges)(PMMVAD vad, PEPROCESS process);
VOID(*MiInsertVad)(PMMVAD vad, PEPROCESS process);

INT64 NTAPI EnumerateDebuggingDevicesHook(PREQUEST_DATA data, PINT64 status) {
	if (ExGetPreviousMode() != UserMode || !data) {
		return EnumerateDebuggingDevicesOriginal(data, status);
	}

	// Can't use inline SEH for safe dereferences cause PG
	REQUEST_DATA safeData = { 0 };
	if (!SafeCopy(&safeData, data, sizeof(safeData)) || safeData.Unique != DATA_UNIQUE) {
		return EnumerateDebuggingDevicesOriginal(data, status);
	}
	
	switch (safeData.Type) {
		HANDLE_REQUEST(Extend, REQUEST_EXTEND);
		HANDLE_REQUEST(Write, REQUEST_WRITE);
		HANDLE_REQUEST(Read, REQUEST_READ);
		HANDLE_REQUEST(Protect, REQUEST_PROTECT);
		HANDLE_REQUEST(Alloc, REQUEST_ALLOC);
		HANDLE_REQUEST(Free, REQUEST_FREE);
		HANDLE_REQUEST(Module, REQUEST_MODULE);
	}

	*status = STATUS_NOT_IMPLEMENTED;
	return 0;
}

NTSTATUS Main() {
	PCHAR base = GetKernelBase();
	if (!base) {
		printf("! failed to get ntoskrnl base !\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	// MiAllocateVad (yes I'm this lazy)
	PBYTE addr = (PBYTE)FindPatternImage(base, "\x41\xB8\x00\x00\x00\x00\x48\x8B\xD6\x49\x8B\xCE\xE8\x00\x00\x00\x00\x48\x8B\xD8", "xx????xxxxxxx????xxx");
	if (!addr) {
		printf("! failed to find MiAllocateVad !\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	*(PVOID *)&MiAllocateVad = RELATIVE_ADDR(addr + 12, 5);

	// MiInsertVadCharges
	addr = FindPatternImage(base, "\xE8\x00\x00\x00\x00\x8B\xF8\x85\xC0\x78\x31", "x????xxxxxx");
	if (!addr) {
		printf("! failed to find MiInsertVadCharges !\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	*(PVOID *)&MiInsertVadCharges = RELATIVE_ADDR(addr, 5);

	// MiInsertVad
	addr = FindPatternImage(base, "\x48\x2B\xD1\x48\xFF\xC0\x48\x03\xC2", "xxxxxxxxx");
	if (!addr) {
		printf("! failed to find MiInsertVad !\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	for (; *addr != 0xE8 || *(addr + 5) != 0x8B; ++addr);
	*(PVOID *)&MiInsertVad = RELATIVE_ADDR(addr, 5);

	// Intended be manually mapped
	addr = FindPatternImage(base, "\x48\x8B\x05\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x8B\xC8\x85\xC0\x78\x40", "xxx????x????xxxxxx");
	if (!addr) {
		printf("! failed to find xKdEnumerateDebuggingDevices  !\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	*(PVOID *)&EnumerateDebuggingDevicesOriginal = InterlockedExchangePointer(RELATIVE_ADDR(addr, 7), (PVOID)EnumerateDebuggingDevicesHook);

	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING registryPath) {
	UNREFERENCED_PARAMETER(driver);
	UNREFERENCED_PARAMETER(registryPath);

	return Main();
}
```

`driver/stdafx.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <minwindef.h>

#define printf(fmt, ...) DbgPrint("[dbg] "fmt, ##__VA_ARGS__)
#define HANDLE_REQUEST(name, args) \
    case RequestType##name: {                                     \
        args safe = { 0 };                                        \
        if (!SafeCopy(&safe, safeData.Arguments, sizeof(args))) { \
            *status = STATUS_ACCESS_VIOLATION;                    \
            return 0;                                             \
        }                                                         \
        *status = Core##name(&safe);                              \
        return 0;                                                 \
    }

#include "util.h"
#include "core.h"
```

`driver/util.c`:

```c
#include "stdafx.h"

BOOL SafeCopy(PVOID dest, PVOID src, SIZE_T size) {
	SIZE_T returnSize = 0;
	if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), src, PsGetCurrentProcess(), dest, size, KernelMode, &returnSize)) && returnSize == size) {
		return TRUE;
	}

	return FALSE;
}

BOOL CheckMask(PCHAR base, PCHAR pattern, PCHAR mask) {
	for (; *mask; ++base, ++pattern, ++mask) {
		if (*mask == 'x' && *base != *pattern) {
			return FALSE;
		}
	}

	return TRUE;
}

PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask) {
	length -= (DWORD)strlen(mask);
	for (DWORD i = 0; i <= length; ++i) {
		PVOID addr = &base[i];
		if (CheckMask(addr, pattern, mask)) {
			return addr;
		}
	}

	return 0;
}

PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask) {
	PVOID match = 0;

	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (*(PINT)section->Name == 'EGAP' || memcmp(section->Name, ".text", 5) == 0) {
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match) {
				break;
			}
		}
	}

	return match;
}

PVOID GetKernelBase() {
	PVOID addr = 0;

	ULONG size = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &size);
	if (STATUS_INFO_LENGTH_MISMATCH != status) {
		return addr;
	}

	PSYSTEM_MODULE_INFORMATION modules = ExAllocatePool(NonPagedPool, size);
	if (!modules) {
		return addr;
	}

	if (!NT_SUCCESS(status = ZwQuerySystemInformation(SystemModuleInformation, modules, size, 0))) {
		ExFreePool(modules);
		return addr;
	}

	if (modules->NumberOfModules > 0) {
		addr = modules->Modules[0].ImageBase;
	}

	ExFreePool(modules);
	return addr;
}
```

`driver/util.h`:

```h
#pragma once

#define RELATIVE_ADDR(addr, size) ((PVOID)((PBYTE)(addr) + *(PINT)((PBYTE)(addr) + ((size) - (INT)sizeof(INT))) + (size)))

BOOL SafeCopy(PVOID dest, PVOID src, SIZE_T size);
PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask);
PVOID GetKernelBase();

NTKERNELAPI PPEB NTAPI PsGetProcessPeb(PEPROCESS Process);
NTKERNELAPI NTSTATUS NTAPI PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS *Process);
NTKERNELAPI NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);

NTSYSCALLAPI NTSTATUS NTAPI ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
NTSYSCALLAPI NTSTATUS NTAPI ZwProtectVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, PSIZE_T RegionSize, ULONG NewAccessProtection, PULONG OldAccessProtection);

#define MM_EXECUTE_READWRITE (6)

#pragma warning(disable : 4214)
#pragma warning(disable : 4201)
typedef struct _MMVAD_FLAGS_19H {
	ULONG Lock : 1;
	ULONG LockContended : 1;
	ULONG DeleteInProgress : 1;
	ULONG NoChange : 1;
	ULONG VadType : 3;
	ULONG Protection : 5;
	ULONG PreferredNode : 6;
	ULONG PageSize : 2;
	ULONG PrivateMemory : 1;
} MMVAD_FLAGS_19H, *PMMVAD_FLAGS_19H;

typedef struct _MMVAD_FLAGS {
	ULONG VadType : 3;
	ULONG Protection : 5;
	ULONG PreferredNode : 6;
	ULONG PrivateMemory : 1;
	ULONG PrivateFixup : 1;
	ULONG Graphics : 1;
	ULONG Enclave : 1;
	ULONG PageSize64K : 1;
	ULONG ShadowStack : 1;
	ULONG Spare : 6;
	ULONG HotPatchAllowed : 1;
	ULONG NoChange : 1;
	ULONG ManySubsections : 1;
	ULONG DeleteInProgress : 1;
	ULONG LockContended : 1;
	ULONG Lock : 1;
} MMVAD_FLAGS, *PMMVAD_FLAGS;

typedef struct _MMVAD_SHORT {
	union {
		struct _MMVAD_SHORT *NextVad;
		RTL_BALANCED_NODE VadNode;
	};

	ULONG StartingVpn;
	ULONG EndingVpn;
	UCHAR StartingVpnHigh;
	UCHAR EndingVpnHigh;
	UCHAR CommitChargeHigh;
	UCHAR SpareNT64VadUChar;
	LONG ReferenceCount;
	EX_PUSH_LOCK PushLock;

	union {
		ULONG LongFlags;
	} u1;
} MMVAD, *PMMVAD;

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, *PPEB;

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	BYTE Reserved1[48];
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved2;
	ULONG HandleCount;
	ULONG SessionId;
	PVOID Reserved3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG Reserved4;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	PVOID Reserved5;
	SIZE_T QuotaPagedPoolUsage;
	PVOID Reserved6;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_MODULE {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG NumberOfModules;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	SystemSupportedProcessArchitectures = 0xb5,
} SYSTEM_INFORMATION_CLASS;
```

`modmap/comm.cpp`:

```cpp
#include "stdafx.h"

PVOID(NTAPI *NtConvertBetweenAuxiliaryCounterAndPerformanceCounter)(PVOID, PVOID, PVOID, PVOID);

namespace Comm {
	BOOL Setup() {
		auto module = LoadLibrary(L"ntdll.dll");
		if (!module) {
			errorf("Failed to get a handle for NTDLL\n");
			return FALSE;
		}

		*reinterpret_cast<PVOID *>(&NtConvertBetweenAuxiliaryCounterAndPerformanceCounter) = GetProcAddress(module, "NtConvertBetweenAuxiliaryCounterAndPerformanceCounter");
		if (!NtConvertBetweenAuxiliaryCounterAndPerformanceCounter) {
			errorf("Failed to find \"NtConvertBetweenAuxiliaryCounterAndPerformanceCounter\"\n");
			return FALSE;
		}

		return TRUE;
	}

	NTSTATUS SendRequest(REQUEST_TYPE type, PVOID args, SIZE_T argsSize) {
		REQUEST_DATA request = { 0 };
		request.Unique = DATA_UNIQUE;
		request.Type = type;
		request.Arguments = args;

		auto requestPtr = &request;

		auto status = 0ULL;
		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
		return static_cast<NTSTATUS>(status);
	}

	Process::Process(LPCWSTR processName) {
		auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (snapshot == INVALID_HANDLE_VALUE) {
			return;
		}

		PROCESSENTRY32 entry = { 0 };
		entry.dwSize = sizeof(entry);
		if (Process32First(snapshot, &entry)) {
			do {
				if (_wcsicmp(entry.szExeFile, processName) == 0) {
					this->ProcessId = entry.th32ProcessID;
					break;
				}
			} while (Process32Next(snapshot, &entry));
		}

		CloseHandle(snapshot);
	}

	BOOLEAN Process::Valid() {
		return this->ProcessId != 0;
	}

	NTSTATUS Process::Extend(LPCWSTR moduleName, DWORD size) {
		REQUEST_EXTEND req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Size = size;
		wcscpy_s(req.Module, sizeof(req.Module) / sizeof(req.Module[0]), moduleName);

		return SendRequest(REQUEST_TYPE::EXTEND, &req, sizeof(req));
	}

	NTSTATUS Process::Write(PVOID dest, PVOID src, DWORD size) {
		REQUEST_WRITE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Dest = dest;
		req.Src = src;
		req.Size = size;

		return SendRequest(REQUEST_TYPE::WRITE, &req, sizeof(req));
	}

	NTSTATUS Process::Read(PVOID dest, PVOID src, DWORD size) {
		REQUEST_READ req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Dest = dest;
		req.Src = src;
		req.Size = size;

		return SendRequest(REQUEST_TYPE::READ, &req, sizeof(req));
	}

	NTSTATUS Process::Protect(PVOID address, DWORD size, PDWORD inOutProtect) {
		REQUEST_PROTECT req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Address = address;
		req.Size = size;
		req.InOutProtect = inOutProtect;

		return SendRequest(REQUEST_TYPE::PROTECT, &req, sizeof(req));
	}

	PVOID Process::Alloc(DWORD size, DWORD protect) {
		PVOID outAddress = NULL;

		REQUEST_ALLOC req = { 0 };
		req.ProcessId = this->ProcessId;
		req.OutAddress = &outAddress;
		req.Size = size;
		req.Protect = protect;

		SendRequest(REQUEST_TYPE::ALLOC, &req, sizeof(req));

		return outAddress;
	}

	NTSTATUS Process::Free(PVOID address) {
		REQUEST_FREE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Address = address;

		return SendRequest(REQUEST_TYPE::FREE, &req, sizeof(req));
	}

	NTSTATUS Process::Module(LPCWSTR moduleName, PBYTE *base, PDWORD size) {
		REQUEST_MODULE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.OutAddress = base;
		req.OutSize = size;
		wcscpy_s(req.Module, sizeof(req.Module) / sizeof(req.Module[0]), moduleName);

		return SendRequest(REQUEST_TYPE::MODULE, &req, sizeof(req));
	}
}

```

`modmap/comm.h`:

```h
#pragma once

namespace Comm {
	const auto DATA_UNIQUE = 0x1234UL;

	enum class REQUEST_TYPE {
		EXTEND,
		WRITE,
		READ,
		PROTECT,
		ALLOC,
		FREE,
		MODULE,
	};

	typedef struct _REQUEST_DATA {
		DWORD Unique;
		REQUEST_TYPE Type;
		PVOID Arguments;
	} REQUEST_DATA, *PREQUEST_DATA;

	typedef struct _REQUEST_EXTEND {
		DWORD ProcessId;
		WCHAR Module[0xFF];
		DWORD Size;
	} REQUEST_EXTEND, *PREQUEST_EXTEND;

	typedef struct _REQUEST_WRITE {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
	} REQUEST_WRITE, *PREQUEST_WRITE;

	typedef struct _REQUEST_READ {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
	} REQUEST_READ, *PREQUEST_READ;

	typedef struct _REQUEST_PROTECT {
		DWORD ProcessId;
		PVOID Address;
		DWORD Size;
		PDWORD InOutProtect;
	} REQUEST_PROTECT, *PREQUEST_PROTECT;

	typedef struct _REQUEST_ALLOC {
		DWORD ProcessId;
		PVOID OutAddress;
		DWORD Size;
		DWORD Protect;
	} REQUEST_ALLOC, *PREQUEST_ALLOC;

	typedef struct _REQUEST_FREE {
		DWORD ProcessId;
		PVOID Address;
	} REQUEST_FREE, *PREQUEST_FREE;

	typedef struct _REQUEST_MODULE {
		DWORD ProcessId;
		WCHAR Module[0xFF];
		PBYTE *OutAddress;
		PDWORD OutSize;
	} REQUEST_MODULE, *PREQUEST_MODULE;

	BOOL Setup();

	class Process {
	private:
		DWORD ProcessId = 0;

	public:
		Process(DWORD processId) : ProcessId{ processId } {}
		Process(LPCWSTR processName);

		BOOLEAN Valid();
		NTSTATUS Extend(LPCWSTR module, DWORD size);
		NTSTATUS Write(PVOID dest, PVOID src, DWORD size);
		NTSTATUS Read(PVOID dest, PVOID src, DWORD size);
		NTSTATUS Protect(PVOID address, DWORD size, PDWORD inOutProtect);
		PVOID Alloc(DWORD size, DWORD protect);
		NTSTATUS Free(PVOID address);
		NTSTATUS Module(LPCWSTR moduleName, PBYTE *base, PDWORD size);
	};
}
```

`modmap/hijack.cpp`:

```cpp
#include "stdafx.h"

namespace Hijack {
	BOOLEAN HijackViaHook(Comm::Process &process, PVOID entry, LPCWSTR moduleName, LPCSTR functionName) {
		printf("\n[-] hijacking execution via hook\n");

		PBYTE remoteModuleBase = NULL;
		DWORD remoteModuleSize = 0;
		if (process.Module(moduleName, &remoteModuleBase, &remoteModuleSize) != ERROR_SUCCESS) {
			errorf("failed to find module %ws in process\n", moduleName);
			return FALSE;
		}

		auto module = LoadLibrary(moduleName);
		if (!module) {
			errorf("failed to load module %ws\n", moduleName);
			return FALSE;
		}

		auto function = reinterpret_cast<PBYTE>(GetProcAddress(module, functionName));
		if (!function) {
			errorf("failed to find function %ws:%s\n", moduleName, functionName);
			return FALSE;
		}

		auto remoteFunction = remoteModuleBase + (function - reinterpret_cast<PBYTE>(module));

		BYTE shellcode[] = { 0x00, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x10, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x50, 0x08, 0x48, 0x83, 0xEC, 0x28, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x02, 0x00, 0x00, 0x00, 0xEB, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0x48, 0x31, 0xC0, 0xC6, 0x05, 0xAE, 0xFF, 0xFF, 0xFF, 0x01, 0xC3 };
		*reinterpret_cast<PVOID *>(&shellcode[3]) = remoteFunction;
		process.Read(&shellcode[13], remoteFunction, sizeof(ULONG64));
		process.Read(&shellcode[26], remoteFunction + sizeof(ULONG64), sizeof(ULONG64));
		*reinterpret_cast<PVOID *>(&shellcode[60]) = entry;

		auto mappedShellcode = reinterpret_cast<PBYTE>(process.Alloc(sizeof(shellcode), PAGE_EXECUTE_READWRITE));
		if (!mappedShellcode) {
			errorf("failed to allocate virtual memory for hook hijack shellcode\n");
			return FALSE;
		}

		process.Write(mappedShellcode, shellcode, sizeof(shellcode));

		BYTE jump[14] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 };
		*reinterpret_cast<PVOID *>(&jump[6]) = mappedShellcode + 1;

		DWORD protect = PAGE_EXECUTE_READWRITE;
		process.Protect(remoteFunction, 2 * sizeof(ULONG64), &protect);

		process.Write(remoteFunction, jump, sizeof(jump));

		printf("[+] waiting for shellcode to execute...\n");
		for (auto functionBytes = 0ULL;; Sleep(1)) {
			if (process.Read(&functionBytes, remoteFunction + 6, sizeof(functionBytes)) != ERROR_SUCCESS) {
				errorf("failed to read function bytes at %p\n", remoteFunction + 6);
				return FALSE;
			}

			if (functionBytes != *reinterpret_cast<PULONG64>(&jump[6])) {
				break;
			}
		}

		process.Protect(remoteFunction, sizeof(jump), &protect);

		for (BYTE status = 0;; Sleep(1)) {
			if (process.Read(&status, mappedShellcode, sizeof(status)) != ERROR_SUCCESS) {
				errorf("failed to read shellcode status at %p\n", mappedShellcode);
				return FALSE;
			}

			if (status) {
				break;
			}
		}

		process.Free(mappedShellcode);

		printf("[+] executed\n");

		return TRUE;
	}
}
```

`modmap/hijack.h`:

```h
#pragma once

namespace Hijack {
	BOOLEAN HijackViaHook(Comm::Process &process, PVOID entry, LPCWSTR moduleName, LPCSTR functionName);
}
```

`modmap/main.cpp`:

```cpp
#include "stdafx.h"

INT main(INT argc, LPCSTR *argv) {
	if (argc < 4) {
		printf("usage: modmap <PROCESS> <TARGETMODULE> <DLL>\n");
		return 1;
	}

	if (!Comm::Setup()) {
		return 1;
	}

	Comm::Process process(StrToWStr(argv[1]));
	if (!process.Valid()) {
		errorf("process not found\n");
		return 1;
	}

	auto entry = Map::ExtendMap(process, StrToWStr(argv[3]), StrToWStr(argv[2]));
	if (!entry) {
		return 1;
	}

	printf("\n[-] entry point: %p\n", entry);

	if (!Hijack::HijackViaHook(process, entry, L"user32.dll", "PeekMessageW")) {
		return 1;
	}
	
	return 0;
}
```

`modmap/map.cpp`:

```cpp
#include "stdafx.h"

// CBA to make this cleaner
namespace Map {
	PIMAGE_SECTION_HEADER TranslateRawSection(PIMAGE_NT_HEADERS nt, DWORD rva) {
		auto section = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
			if (rva >= section->VirtualAddress && rva < section->VirtualAddress + section->Misc.VirtualSize) {
				return section;
			}
		}

		return NULL;
	}

	PVOID TranslateRaw(PBYTE base, PIMAGE_NT_HEADERS nt, DWORD rva) {
		auto section = TranslateRawSection(nt, rva);
		if (!section) {
			return NULL;
		}

		return base + section->PointerToRawData + (rva - section->VirtualAddress);
	}

	BOOLEAN ResolveImports(Comm::Process &process, PBYTE base, PIMAGE_NT_HEADERS nt) {
		auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		if (!rva) {
			return TRUE;
		}

		auto importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(TranslateRaw(base, nt, rva));
		if (!importDescriptor) {
			return TRUE;
		}

		for (; importDescriptor->FirstThunk; ++importDescriptor) {
			auto moduleName = reinterpret_cast<PCHAR>(TranslateRaw(base, nt, importDescriptor->Name));
			if (!moduleName) {
				break;
			}

			auto module = LoadLibraryA(moduleName);
			if (!module) {
				errorf("failed to load module: %s\n", moduleName);
				return FALSE;
			}

			PBYTE processModuleBase = NULL;
			DWORD processModuleSize = 0;
			if (process.Module(StrToWStr(moduleName), &processModuleBase, &processModuleSize) != ERROR_SUCCESS) {
				errorf("target process does not have %s loaded\n", moduleName);
				return FALSE;
			}

			for (auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(TranslateRaw(base, nt, importDescriptor->FirstThunk)); thunk->u1.AddressOfData; ++thunk) {
				auto importByName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(TranslateRaw(base, nt, static_cast<DWORD>(thunk->u1.AddressOfData)));
				thunk->u1.Function = reinterpret_cast<UINT_PTR>(processModuleBase + (reinterpret_cast<PBYTE>(GetProcAddress(module, importByName->Name)) - reinterpret_cast<PBYTE>(module)));
			}
		}

		return TRUE;
	}

	VOID ResolveRelocations(PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		auto &baseRelocDir = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (!baseRelocDir.VirtualAddress) {
			return;
		}

		auto reloc = reinterpret_cast<PIMAGE_BASE_RELOCATION>(TranslateRaw(base, nt, baseRelocDir.VirtualAddress));
		if (!reloc) {
			return;
		}

		for (auto currentSize = 0UL; currentSize < baseRelocDir.Size; ) {
			auto relocCount = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			auto relocData = reinterpret_cast<PWORD>(reinterpret_cast<PBYTE>(reloc) + sizeof(IMAGE_BASE_RELOCATION));
			auto relocBase = reinterpret_cast<PBYTE>(TranslateRaw(base, nt, reloc->VirtualAddress));

			for (auto i = 0UL; i < relocCount; ++i, ++relocData) {
				auto data = *relocData;
				auto type = data >> 12;
				auto offset = data & 0xFFF;

				if (type == IMAGE_REL_BASED_DIR64) {
					*reinterpret_cast<PBYTE *>(relocBase + offset) += (mapped - reinterpret_cast<PBYTE>(nt->OptionalHeader.ImageBase));
				}
			}

			currentSize += reloc->SizeOfBlock;
			reloc = reinterpret_cast<PIMAGE_BASE_RELOCATION>(relocData);
		}
	}

	BOOLEAN MapHeaders(Comm::Process &process, PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		return process.Write(mapped, base, sizeof(nt->Signature) + sizeof(nt->FileHeader) + nt->FileHeader.SizeOfOptionalHeader) == ERROR_SUCCESS;
	}

	BOOLEAN MapSections(Comm::Process &process, PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		auto section = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
			auto sectionSize = min(section->SizeOfRawData, section->Misc.VirtualSize);
			if (!sectionSize) {
				continue;
			}

			auto mappedSection = mapped + section->VirtualAddress;
			if (process.Write(mappedSection, base + section->PointerToRawData, sectionSize) != ERROR_SUCCESS) {
				errorf("failed to map section %s at %p (%x)\n", section->Name, mappedSection, sectionSize);
				return FALSE;
			}
		}

		return TRUE;
	}

	PBYTE ExtendModule(Comm::Process &process, PIMAGE_NT_HEADERS nt, LPCWSTR module) {
		PBYTE moduleBase = NULL;
		DWORD moduleSize = 0;

		printf("[-] extending %ws\n", module);

		auto status = process.Module(module, &moduleBase, &moduleSize);
		if (status != ERROR_SUCCESS || !moduleBase) {
			errorf("failed to find module %ws (%X)\n", module, status);
			return NULL;
		}

		status = process.Extend(module, nt->OptionalHeader.SizeOfImage);
		if (status != ERROR_SUCCESS) {
			errorf("module %ws does not having enough free trailing memory (%X)\n", module, status);
			return NULL;
		}

		printf("[+] extended %ws to %x\n", module, moduleSize + nt->OptionalHeader.SizeOfImage);
		return moduleBase + moduleSize;
	}

	PVOID ExtendMap(Comm::Process &process, PBYTE base, LPCWSTR module) {
		auto dos = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		if (dos->e_magic != IMAGE_DOS_SIGNATURE) {
			errorf("invalid DOS signature\n");
			return NULL;
		}

		auto nt = reinterpret_cast<PIMAGE_NT_HEADERS>(base + dos->e_lfanew);
		if (nt->Signature != IMAGE_NT_SIGNATURE) {
			errorf("invalid NT signature\n");
			return NULL;
		}

		nt->Signature = dos->e_magic = 0;

		auto mapped = ExtendModule(process, nt, module);
		if (!mapped) {
			return NULL;
		}

		printf("[+] mapped base: %p\n", mapped);

		if (!ResolveImports(process, base, nt)) {
			return NULL;
		}

		ResolveRelocations(base, nt, mapped);

		if (!MapHeaders(process, base, nt, mapped)) {
			errorf("failed to map headers\n");
			return NULL;
		}

		if (!MapSections(process, base, nt, mapped)) {
			return NULL;
		}

		return mapped + nt->OptionalHeader.AddressOfEntryPoint;
	}

	PVOID ExtendMap(Comm::Process &process, LPCWSTR filePath, LPCWSTR module) {
		std::ifstream file(filePath, std::ios::ate | std::ios::binary);
		if (!file) {
			errorf("failed to open file: \"%ws\"\n", filePath);
			return NULL;
		}

		auto size = file.tellg();
		auto buffer = new BYTE[size];

		file.seekg(0, std::ios::beg);
		file.read(reinterpret_cast<PCHAR>(buffer), size);
		file.close();

		auto entryPoint = ExtendMap(process, buffer, module);

		delete[] buffer;

		return entryPoint;
	}
}
```

`modmap/map.h`:

```h
#pragma once

namespace Map {
	PVOID ExtendMap(Comm::Process &process, LPCWSTR filePath, LPCWSTR module);
}
```

`modmap/modmap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{9411C8F3-39EF-494E-9AD1-4EDBB859371F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>modmap</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="comm.cpp" />
    <ClCompile Include="hijack.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="map.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="comm.h" />
    <ClInclude Include="hijack.h" />
    <ClInclude Include="map.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`modmap/modmap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="comm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="map.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hijack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="comm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="map.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hijack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`modmap/stdafx.h`:

```h
#pragma once

#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>

#include <fstream>

#define errorf(fmt, ...) fprintf(stderr, "\n[error at %s:%d] " fmt, __FILE__, __LINE__, ##__VA_ARGS__)
#define StrToWStr(s) (std::wstring(s, &s[strlen(s)]).c_str())

#include "comm.h"
#include "map.h"
#include "hijack.h"
```