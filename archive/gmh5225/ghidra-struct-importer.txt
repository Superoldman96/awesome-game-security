Project Path: arc_gmh5225_ghidra-struct-importer_jsg7mt1b

Source Tree:

```txt
arc_gmh5225_ghidra-struct-importer_jsg7mt1b
├── ImportCStruct.java
├── LICENSE.TXT
├── README.md
├── example_screenshot.png
└── structimporter
    ├── NameConflictHandler.java
    └── ParseStructDialog.java

```

`ImportCStruct.java`:

```java
//
//@author Jan Mothes
//@category Data Types
//@menupath
//@toolbar

import ghidra.app.script.GhidraScript;
import structimporter.ParseStructDialog;

public class ImportCStruct extends GhidraScript {
	@Override
	protected void run() throws Exception {
		var dialog = new ParseStructDialog(this);
        state.getTool().showDialog(dialog);
	}
}

```

`LICENSE.TXT`:

```TXT
MIT License

Copyright (c) 2022 Florian Magin
Copyright (c) 2022 Jan Mothes

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Ghidra Struct Importer

Allows parsing single C structs that can have dependencies on arbitrary already defined types, circumventing the problem that "Parse C Source" only works if all dependencies of the included header files have been resolved in the same or other included header files.

Based on https://github.com/fmagin/ghidra_scripts/blob/master/ParseDataType.java

### Compatibility

- Compatible with Ghidra 10.3 or higher since version 0.2.0
- For Ghidra 10.2 you must use verson 0.1.0 (since it contains a workaround for [this issue](https://github.com/NationalSecurityAgency/ghidra/issues/4903))
- Lower version are untested

### How to install
- [Releases](https://github.com/Katharsas/ghidra-struct-importer/releases) -> Select Release -> Source Code (..) -> Download -> Extract anywhere
- Open Ghidra project
- Window -> Script Manager -> Button 'Manage script directories'
- Add (Display file chooser) -> Select extracted folder that contains README.md
- Window -> Script Manager -> Data Types -> ImportCStruct.java -> Run Script (or assign a key)

### Screenshot
![Screenshot](https://github.com/Katharsas/ghidra-struct-importer/blob/main/example_screenshot.png)

```

`structimporter/NameConflictHandler.java`:

```java
package structimporter;
import javax.swing.JButton;
import javax.swing.JTextArea;

import docking.DialogComponentProvider;
import ghidra.app.script.GhidraState;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictHandler;

class NameConflictHandler extends DataTypeConflictHandler {
	
	static class PoorMansMultilineLabel extends JTextArea {
		public PoorMansMultilineLabel(String text) {
			super(text);
			this.setWrapStyleWord(true);
			this.setLineWrap(true);
			this.setEditable(false);
		}
	}
	
    static class NameConflictDialog extends DialogComponentProvider {
    	public ConflictResult result = null;
		private NameConflictDialog(DataType addedDataType, DataType existingDataType) {
			super("Datatype Name Conflict", true, true, true, true);
			this.setPreferredSize(400, 150);
			this.addOKButton();
			addReplaceButton();
			var dataTypeName = existingDataType.getDisplayName();
			var categoryName = existingDataType.getCategoryPath().getPath();
			var hasCategory = !existingDataType.getCategoryPath().isRoot();
			var textArea = new PoorMansMultilineLabel(
					"Datatype '" + dataTypeName + (hasCategory ? ("' in '" +  categoryName) : "") + "' exists already! "
					+ "Press 'ok' to skip.");
			this.addWorkPanel(textArea);
		}
		private void addReplaceButton() {
			var replaceButton = new JButton("Replace existing");
			replaceButton.addActionListener(e -> {
				result = ConflictResult.REPLACE_EXISTING;
				this.close();
			});
			this.addButton(replaceButton);
		}
		@Override
		protected void okCallback() {
			result = ConflictResult.USE_EXISTING;
			this.close();
		}
    }
	
	// Ghidra's resolution code will call this conflictHandler twice, if it is not equivalent,
	// and we don't want want to show our user choice dialog twice. so we need to buffer the first result.
	private ConflictResult bufferedResult = null;
	
	private GhidraState state;
	
	public NameConflictHandler(GhidraState state) {
		this.state = state;
	}
	
	@Override
	public ConflictResult resolveConflict(DataType addedDataType, DataType existingDataType) {
		if (bufferedResult == null) {
			var dialog = new NameConflictDialog(addedDataType, existingDataType);
	        state.getTool().showDialog(dialog);
	        bufferedResult = dialog.result;
		}
        return bufferedResult;
	}
	
	@Override
	public boolean shouldUpdate(DataType sourceDataType, DataType localDataType) {
		return false;
	}
	
	@Override
	public DataTypeConflictHandler getSubsequentHandler() {
		return this;
	}
}
```

`structimporter/ParseStructDialog.java`:

```java
package structimporter;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTextArea;

import org.apache.commons.lang3.exception.ExceptionUtils;

import docking.DialogComponentProvider;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;
import ghidra.app.script.GhidraScript;
import ghidra.app.util.cparser.C.CParser;
import ghidra.app.util.cparser.C.ParseException;
import ghidra.program.model.data.Category;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.util.exception.DuplicateNameException;

public class ParseStructDialog extends DialogComponentProvider {
    
    static class CategoryTreeNode extends GTreeNode {
    	public final Category cat;
		public CategoryTreeNode(Category cat) {
			this.cat = cat;
		}
		@Override
		public String getName() {
			return cat.getName();
		}
		@Override
		public Icon getIcon(boolean expanded) {
			return null;
		}
		@Override
		public String getToolTip() {
			return cat.getCategoryPathName();
		}
		@Override
		public boolean isLeaf() {
			return cat.getCategories().length <= 0;
		}
    }
    	
    private final DataTypeManager programDtm;
    private final List<DataType> parsedTypes;
    
    private GTree categoryTree;
    private JPanel parsedTypesPanel;
    
    private JTextArea textInput;
    private JTextArea typeOutput;

    private JButton parseButton;
    
    private List<Runnable> whenShown;
    private NameConflictHandler conflictHandler;
    

    public ParseStructDialog(GhidraScript scriptContext) {
        super("Parse Data Type", false, true, true, true);
        setPreferredSize(600, 500);

        parsedTypes = new ArrayList<>();
        whenShown = new ArrayList<>();
        
        // Parser Setup
        programDtm = scriptContext.getCurrentProgram().getDataTypeManager();
        conflictHandler = new NameConflictHandler(scriptContext.getState());
        
        // GUI SETUP
        this.addCancelButton();
        this.parseButton = new JButton("Parse");
        this.parseButton.addActionListener(event -> { this.parseType();});
        this.parseButton.setToolTipText("Parse the struct and preview the result");

        this.addButton(parseButton);

        this.addApplyButton();
        this.setApplyToolTip("Add list of parsed types");
        this.setApplyEnabled(false);

        var categorySelectorGui = buildCategorySelectorGui();
        var textInputGui = buildDataTypesGui();
        
        var splitter = new JSplitPane(JSplitPane.VERTICAL_SPLIT, categorySelectorGui, textInputGui);

        addWorkPanel(splitter);
        whenShown.add(() -> {
        	splitter.setDividerLocation(0.3);
        });
    }
    
    @Override
    protected void dialogShown() {
    	super.dialogShown();
    	for (var runnable : whenShown) {
    		runnable.run();
    	}
    }
    
    private GTreeNode buildCatTree(Category cat) {
    	var node = new CategoryTreeNode(cat);
    	for (var child : cat.getCategories()) {
        	var childNode = buildCatTree(child);
        	node.addNode(childNode);
        }
    	return node;
    }
    
    private JComponent buildCategorySelectorGui() {
    	// category tree
        var label = new JLabel("Select category for imported structs:");
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
    	
        var rootCat = programDtm.getRootCategory();
        var rootNode = buildCatTree(rootCat);
        var tree = new GTree(rootNode);
        tree.addSelectionPath(rootNode.getTreePath());
        
        this.categoryTree = tree;
        
        var container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.add(label);
        container.add(tree);
        return container;
    }
    
    private JComponent buildDataTypeListGui() {
    	var container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        
        this.parsedTypesPanel = container;
        
        return container;
    }
    
    private JComponent buildDataTypeInputGui() {
    	var selector = buildDataTypeListGui();
    	
    	textInput = new JTextArea(12, 50);
        textInput.setWrapStyleWord(true);
        textInput.setLineWrap(true);
    	
    	var container = new JPanel(new BorderLayout());
        container.add(selector, BorderLayout.NORTH);
        container.add(new JScrollPane(textInput), BorderLayout.CENTER);
        
        return container;
    }
    
    private JComponent buildDataTypesGui() {
    	var typeInput = buildDataTypeInputGui();
    	typeInput.setMinimumSize(new Dimension(0, 0));// for splitpane
    	
        typeOutput = new JTextArea(12, 50);
        typeOutput.setWrapStyleWord(true);
        typeOutput.setLineWrap(true);
        typeOutput.setEditable(false);
        typeOutput.setMinimumSize(new Dimension(0, 0));// for splitpane

        var splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, typeInput, new JScrollPane(typeOutput));
        whenShown.add(() -> {
        	splitter.setDividerLocation(0.5);
        });
        return splitter;
    }

    private void parseType() {
        var text = this.textInput.getText();
        var parser = new CParser(programDtm);
        
        try {
        	parser.parse(text);
        } catch (ParseException e) {
        	var stackTrace = ExceptionUtils.getStackTrace(e);
            typeOutput.setText(e.toString() + "\n\n" + stackTrace);
            return;
        }
        
        var parsed = new HashMap<String, DataType>();
        parsed.putAll(parser.getTypes());
        parsed.putAll(parser.getComposites());
        parsed.putAll(parser.getEnums());

        if (parsed.isEmpty()) {
        	typeOutput.setText("No type was found in the provided source!");
        	return;
        }
        
        var selectedNode = (CategoryTreeNode) categoryTree.getSelectionModel().getLeadSelectionPath().getLastPathComponent();
        var selectedCategoryPath = selectedNode.cat.getCategoryPath();
        
        for (var type : parsed.values()) {
        	try {
				type.setCategoryPath(selectedCategoryPath);
			} catch (DuplicateNameException e) {
				typeOutput.setText(e.toString());
				continue;
			}
        	createDataTypeListEntry(type);
        	typeOutput.setText(type.toString());
        	parsedTypes.add(type);
        	this.setApplyEnabled(true);
        }
    }
    
    private void createDataTypeListEntry(DataType type) {
    	var container = new JPanel(new BorderLayout());
    	
    	var category = programDtm.getRootCategory().getName() + "/" + type.getCategoryPath().getName();
    	var label = new JLabel(" " + type.getName() + " (" + category + ")");
    	var showButton = new JButton("show");
    	showButton.addActionListener(event -> {
    		typeOutput.setText(type.toString());
    	});
    	var removeButton = new JButton("remove");
    	removeButton.addActionListener(event -> {
    		var index = parsedTypes.indexOf(type);
    		parsedTypes.remove(index);
    		if (parsedTypes.isEmpty()) {
    			this.setApplyEnabled(false);
    		}
    		parsedTypesPanel.remove(index);
    		parsedTypesPanel.revalidate();
    	});
    	
    	var buttonContainer = new JPanel(new BorderLayout());
    	buttonContainer.add(showButton, BorderLayout.WEST);
    	buttonContainer.add(removeButton, BorderLayout.EAST);
        
        container.add(label, BorderLayout.CENTER);
        container.add(buttonContainer, BorderLayout.EAST);
    	
    	parsedTypesPanel.add(container);
    	parsedTypesPanel.revalidate();
    }

    @Override
    protected void applyCallback() {
        int transaction_id = programDtm.startTransaction("Parsed");
        for (var type : parsedTypes) {
        	programDtm.addDataType(type, conflictHandler);
        }
        programDtm.endTransaction(transaction_id, true);
        this.close();
    }
}

```