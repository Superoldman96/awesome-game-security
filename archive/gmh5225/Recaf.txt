Project Path: arc_gmh5225_Recaf_g_8bb_o0

Source Tree:

```txt
arc_gmh5225_Recaf_g_8bb_o0
├── CONTRIBUTING.md
├── LICENSE
├── PRIMER.md
├── PULL_REQUEST_TEMPLATE.md
├── README.md
├── build
├── build.cmd
├── checkstyle-suppressions.xml
├── checkstyle.xml
├── docs
│   ├── css
│   │   ├── assets
│   │   │   ├── download.svg
│   │   │   ├── header-bg-blur.jpg
│   │   │   ├── header-bg.png
│   │   │   └── logo.png
│   │   ├── banner.css
│   │   ├── code.css
│   │   ├── common.css
│   │   ├── docs.css
│   │   ├── font
│   │   │   └── roboto300.css
│   │   ├── menu.css
│   │   ├── pure
│   │   │   ├── grids-responsive-min.css
│   │   │   └── pure-min.css
│   │   ├── scroll.css
│   │   └── table.css
│   ├── doc-advanced-plugin.html
│   ├── doc-advanced-scripting.html
│   ├── doc-advanced-theme.html
│   ├── doc-edit-assembler-errors.html
│   ├── doc-edit-assembler.html
│   ├── doc-edit-mode-decompile.html
│   ├── doc-edit-mode-hex.html
│   ├── doc-edit-mode-table.html
│   ├── doc-edit-modes.html
│   ├── doc-instructions.html
│   ├── doc-intro-config.html
│   ├── doc-intro-workspace.html
│   ├── doc-search-dec-member.html
│   ├── doc-search-instruction.html
│   ├── doc-search-ref-class.html
│   ├── doc-search-ref-member.html
│   ├── doc-search-string.html
│   ├── doc-search-value.html
│   ├── doc-setup-11.html
│   ├── doc-setup-8.html
│   ├── doc-setup-get.html
│   ├── documentation.html
│   ├── favicon.ico
│   ├── index.html
│   ├── js
│   │   ├── jquery.min.js
│   │   └── scroll.js
│   └── screenshots
│       ├── assembler-access.mp4
│       ├── assembler-example-locals.png
│       ├── assembler-example.png
│       ├── assembler-field.png
│       ├── assembler-method.png
│       ├── changing-modes.gif
│       ├── cli-demo.mp4
│       ├── config-location.png
│       ├── config.png
│       ├── javadoc.png
│       ├── main-anim.gif
│       ├── main.png
│       ├── mode-decompile.png
│       ├── mode-hex.png
│       ├── mode-table.png
│       ├── save-glow.gif
│       ├── search-class.png
│       ├── search-instructions.png
│       ├── search-member-declaration.png
│       ├── search-member-reference.png
│       ├── search-string.png
│       ├── search-value.png
│       ├── setup-help.png
│       ├── setup-info.png
│       ├── template-plugin.png
│       ├── workspace-add.png
│       ├── workspace-dropdown.png
│       └── workspace-search.gif
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   ├── java
    │   │   │   └── lang
    │   │   │       ├── Module.java
    │   │   │       ├── ModuleLayer.java
    │   │   │       └── module
    │   │   │           ├── ModuleFinder.java
    │   │   │           ├── ModuleReader.java
    │   │   │           └── ModuleReference.java
    │   │   └── me
    │   │       └── coley
    │   │           └── recaf
    │   │               ├── Agent.java
    │   │               ├── Recaf.java
    │   │               ├── command
    │   │               │   ├── ControllerCommand.java
    │   │               │   ├── MetaCommand.java
    │   │               │   ├── completion
    │   │               │   │   ├── ArchiveFileCompletions.java
    │   │               │   │   ├── FileCompletions.java
    │   │               │   │   ├── JavaFileCompletions.java
    │   │               │   │   ├── WorkspaceFileCompletions.java
    │   │               │   │   └── WorkspaceNameCompletions.java
    │   │               │   └── impl
    │   │               │       ├── Assemble.java
    │   │               │       ├── Decompile.java
    │   │               │       ├── Disassemble.java
    │   │               │       ├── Export.java
    │   │               │       ├── Help.java
    │   │               │       ├── Initializer.java
    │   │               │       ├── LoadWorkspace.java
    │   │               │       ├── Quit.java
    │   │               │       ├── Remap.java
    │   │               │       ├── Run.java
    │   │               │       ├── Search.java
    │   │               │       ├── Wait.java
    │   │               │       └── WorkspaceInfo.java
    │   │               ├── compiler
    │   │               │   ├── JavacCompiler.java
    │   │               │   ├── JavacOptions.java
    │   │               │   ├── JavacTargetVersion.java
    │   │               │   ├── JavassistASMTranslator.java
    │   │               │   ├── JavassistCodeGen.java
    │   │               │   ├── JavassistCompilationResult.java
    │   │               │   ├── JavassistCompiler.java
    │   │               │   ├── JavassistExpressionJavac.java
    │   │               │   ├── JavassistMemberResolver.java
    │   │               │   ├── JavassistMethodTranslator.java
    │   │               │   ├── JavassistTypeChecker.java
    │   │               │   ├── ResourceVirtualJavaFileObject.java
    │   │               │   └── VirtualJavaFileObject.java
    │   │               ├── config
    │   │               │   ├── Conf.java
    │   │               │   ├── ConfAssembler.java
    │   │               │   ├── ConfBackend.java
    │   │               │   ├── ConfDecompile.java
    │   │               │   ├── ConfDisplay.java
    │   │               │   ├── ConfKeybinding.java
    │   │               │   ├── ConfUpdate.java
    │   │               │   ├── Config.java
    │   │               │   ├── ConfigManager.java
    │   │               │   ├── Configurable.java
    │   │               │   └── FieldWrapper.java
    │   │               ├── control
    │   │               │   ├── Controller.java
    │   │               │   ├── gui
    │   │               │   │   ├── GuiController.java
    │   │               │   │   └── WindowManager.java
    │   │               │   └── headless
    │   │               │       ├── HeadlessController.java
    │   │               │       ├── JLineAdapter.java
    │   │               │       ├── JLineEditor.java
    │   │               │       └── SubContainerGenerator.java
    │   │               ├── decompile
    │   │               │   ├── DecompileImpl.java
    │   │               │   ├── Decompiler.java
    │   │               │   ├── cfr
    │   │               │   │   ├── CfrDecompiler.java
    │   │               │   │   ├── ClassSource.java
    │   │               │   │   └── SinkFactoryImpl.java
    │   │               │   ├── fernflower
    │   │               │   │   ├── DummyCollector.java
    │   │               │   │   ├── FernFlowerAccessor.java
    │   │               │   │   ├── FernFlowerDecompiler.java
    │   │               │   │   ├── FernFlowerLogger.java
    │   │               │   │   └── StructContextDecorator.java
    │   │               │   └── procyon
    │   │               │       ├── ComposedTypeLoader.java
    │   │               │       ├── ProcyonDecompiler.java
    │   │               │       └── RecafTypeLoader.java
    │   │               ├── graph
    │   │               │   ├── ClassDfsSearch.java
    │   │               │   ├── ClassVertex.java
    │   │               │   ├── DepthFirstSearch.java
    │   │               │   ├── DirectedEdge.java
    │   │               │   ├── Edge.java
    │   │               │   ├── ExhaustiveSearch.java
    │   │               │   ├── Graph.java
    │   │               │   ├── Search.java
    │   │               │   ├── SearchResult.java
    │   │               │   ├── Vertex.java
    │   │               │   ├── WorkspaceGraph.java
    │   │               │   ├── flow
    │   │               │   │   ├── FlowBuilder.java
    │   │               │   │   ├── FlowGraph.java
    │   │               │   │   ├── FlowReference.java
    │   │               │   │   ├── FlowVertex.java
    │   │               │   │   └── OutboundCollector.java
    │   │               │   └── inheritance
    │   │               │       ├── ClassHierarchyBuilder.java
    │   │               │       ├── HierarchyGraph.java
    │   │               │       └── HierarchyVertex.java
    │   │               ├── mapping
    │   │               │   ├── AsmMappingUtils.java
    │   │               │   ├── Correlation.java
    │   │               │   ├── CorrelationResult.java
    │   │               │   ├── EnigmaMappings.java
    │   │               │   ├── FileMappings.java
    │   │               │   ├── JadxMappings.java
    │   │               │   ├── LenientClassRemapper.java
    │   │               │   ├── MappingImpl.java
    │   │               │   ├── Mappings.java
    │   │               │   ├── ProguardMappings.java
    │   │               │   ├── SimpleMappings.java
    │   │               │   ├── SimpleRecordingRemapper.java
    │   │               │   ├── SrgMappings.java
    │   │               │   ├── TSrgMappings.java
    │   │               │   ├── TinyV1Mappings.java
    │   │               │   └── TinyV2Mappings.java
    │   │               ├── metadata
    │   │               │   └── Comments.java
    │   │               ├── parse
    │   │               │   ├── bytecode
    │   │               │   │   ├── AbstractParser.java
    │   │               │   │   ├── Assembler.java
    │   │               │   │   ├── Disassembler.java
    │   │               │   │   ├── FieldAssembler.java
    │   │               │   │   ├── MethodAnalyzer.java
    │   │               │   │   ├── MethodAssembler.java
    │   │               │   │   ├── MethodCompilation.java
    │   │               │   │   ├── MethodVerifier.java
    │   │               │   │   ├── Parse.java
    │   │               │   │   ├── ParseResult.java
    │   │               │   │   ├── VariableGenerator.java
    │   │               │   │   ├── VariableNameCache.java
    │   │               │   │   ├── ast
    │   │               │   │   │   ├── AST.java
    │   │               │   │   │   ├── AliasAST.java
    │   │               │   │   │   ├── CommentAST.java
    │   │               │   │   │   ├── Compilable.java
    │   │               │   │   │   ├── DefaultValueAST.java
    │   │               │   │   │   ├── DefinitionAST.java
    │   │               │   │   │   ├── DefinitionArgAST.java
    │   │               │   │   │   ├── DefinitionModifierAST.java
    │   │               │   │   │   ├── DescAST.java
    │   │               │   │   │   ├── ExpressionAST.java
    │   │               │   │   │   ├── FieldDefinitionAST.java
    │   │               │   │   │   ├── FieldInsnAST.java
    │   │               │   │   │   ├── FlowController.java
    │   │               │   │   │   ├── HandleAST.java
    │   │               │   │   │   ├── IincInsnAST.java
    │   │               │   │   │   ├── InsnAST.java
    │   │               │   │   │   ├── Instruction.java
    │   │               │   │   │   ├── IntInsnAST.java
    │   │               │   │   │   ├── InvokeDynamicAST.java
    │   │               │   │   │   ├── JumpInsnAST.java
    │   │               │   │   │   ├── LabelAST.java
    │   │               │   │   │   ├── LdcInsnAST.java
    │   │               │   │   │   ├── LineInsnAST.java
    │   │               │   │   │   ├── LookupSwitchInsnAST.java
    │   │               │   │   │   ├── MethodDefinitionAST.java
    │   │               │   │   │   ├── MethodInsnAST.java
    │   │               │   │   │   ├── MultiArrayInsnAST.java
    │   │               │   │   │   ├── NameAST.java
    │   │               │   │   │   ├── NumberAST.java
    │   │               │   │   │   ├── OpcodeAST.java
    │   │               │   │   │   ├── RootAST.java
    │   │               │   │   │   ├── SignatureAST.java
    │   │               │   │   │   ├── StringAST.java
    │   │               │   │   │   ├── TableSwitchInsnAST.java
    │   │               │   │   │   ├── TagAST.java
    │   │               │   │   │   ├── ThrowsAST.java
    │   │               │   │   │   ├── TryCatchAST.java
    │   │               │   │   │   ├── TypeAST.java
    │   │               │   │   │   ├── TypeInsnAST.java
    │   │               │   │   │   ├── VarInsnAST.java
    │   │               │   │   │   └── VariableReference.java
    │   │               │   │   ├── exception
    │   │               │   │   │   ├── ASTParseException.java
    │   │               │   │   │   ├── AssemblerException.java
    │   │               │   │   │   └── VerifierException.java
    │   │               │   │   └── parser
    │   │               │   │       ├── AliasDeclarationParser.java
    │   │               │   │       ├── ArgParser.java
    │   │               │   │       ├── CommentParser.java
    │   │               │   │       ├── DefaultValueParser.java
    │   │               │   │       ├── DefinitionParser.java
    │   │               │   │       ├── DescParser.java
    │   │               │   │       ├── DoubleParser.java
    │   │               │   │       ├── ExpressionParser.java
    │   │               │   │       ├── FieldDefinitionParser.java
    │   │               │   │       ├── FieldInsnParser.java
    │   │               │   │       ├── FloatParser.java
    │   │               │   │       ├── HandleParser.java
    │   │               │   │       ├── IincInsnParser.java
    │   │               │   │       ├── InsnParser.java
    │   │               │   │       ├── IntInsnParser.java
    │   │               │   │       ├── IntParser.java
    │   │               │   │       ├── InvokeDynamicParser.java
    │   │               │   │       ├── JumpInsnParser.java
    │   │               │   │       ├── LabelParser.java
    │   │               │   │       ├── LdcInsnParser.java
    │   │               │   │       ├── LineInsnParser.java
    │   │               │   │       ├── LongParser.java
    │   │               │   │       ├── LookupSwitchInsnParser.java
    │   │               │   │       ├── MethodDefinitionParser.java
    │   │               │   │       ├── MethodInsnParser.java
    │   │               │   │       ├── ModifierParser.java
    │   │               │   │       ├── MultiArrayParser.java
    │   │               │   │       ├── NameParser.java
    │   │               │   │       ├── NumericParser.java
    │   │               │   │       ├── OpcodeParser.java
    │   │               │   │       ├── SignatureParser.java
    │   │               │   │       ├── StringParser.java
    │   │               │   │       ├── TableSwitchInsnParser.java
    │   │               │   │       ├── TagParser.java
    │   │               │   │       ├── ThrowsParser.java
    │   │               │   │       ├── TryCatchParser.java
    │   │               │   │       ├── TypeInsnParser.java
    │   │               │   │       ├── TypeParser.java
    │   │               │   │       └── VarInsnParser.java
    │   │               │   ├── javadoc
    │   │               │   │   ├── DocField.java
    │   │               │   │   ├── DocMember.java
    │   │               │   │   ├── DocMethod.java
    │   │               │   │   ├── DocParameter.java
    │   │               │   │   ├── DocumentationParseException.java
    │   │               │   │   ├── FormattingVisitor.java
    │   │               │   │   └── Javadocs.java
    │   │               │   └── source
    │   │               │       ├── SourceCode.java
    │   │               │       ├── SourceCodeException.java
    │   │               │       ├── WorkspaceClassPath.java
    │   │               │       └── WorkspaceTypeResolver.java
    │   │               ├── plugin
    │   │               │   ├── PluginFolderSource.java
    │   │               │   ├── PluginKeybinds.java
    │   │               │   ├── PluginLoadException.java
    │   │               │   ├── PluginsManager.java
    │   │               │   └── api
    │   │               │       ├── AttachPlugin.java
    │   │               │       ├── BasePlugin.java
    │   │               │       ├── ClassVisitorPlugin.java
    │   │               │       ├── CommandPlugin.java
    │   │               │       ├── ConfigurablePlugin.java
    │   │               │       ├── ContextMenuInjectorPlugin.java
    │   │               │       ├── EntryLoaderProviderPlugin.java
    │   │               │       ├── ExitPlugin.java
    │   │               │       ├── ExportInterceptorPlugin.java
    │   │               │       ├── InternalApi.java
    │   │               │       ├── InternalPlugin.java
    │   │               │       ├── KeybindProviderPlugin.java
    │   │               │       ├── LoadInterceptorPlugin.java
    │   │               │       ├── MenuProviderPlugin.java
    │   │               │       ├── StartupPlugin.java
    │   │               │       └── WorkspacePlugin.java
    │   │               ├── search
    │   │               │   ├── ClassInheritanceQuery.java
    │   │               │   ├── ClassNameQuery.java
    │   │               │   ├── ClassReferenceQuery.java
    │   │               │   ├── ClassResult.java
    │   │               │   ├── Context.java
    │   │               │   ├── InsnResult.java
    │   │               │   ├── InsnTextQuery.java
    │   │               │   ├── MemberDefinitionQuery.java
    │   │               │   ├── MemberReferenceQuery.java
    │   │               │   ├── MemberResult.java
    │   │               │   ├── Query.java
    │   │               │   ├── QueryType.java
    │   │               │   ├── SearchAnnotationVisitor.java
    │   │               │   ├── SearchBuilder.java
    │   │               │   ├── SearchClassVisitor.java
    │   │               │   ├── SearchCollector.java
    │   │               │   ├── SearchFieldVisitor.java
    │   │               │   ├── SearchMethodVisitor.java
    │   │               │   ├── SearchResult.java
    │   │               │   ├── StringMatchMode.java
    │   │               │   ├── StringQuery.java
    │   │               │   ├── StringResult.java
    │   │               │   ├── ValueQuery.java
    │   │               │   └── ValueResult.java
    │   │               ├── ui
    │   │               │   ├── ContextBuilder.java
    │   │               │   ├── MainMenu.java
    │   │               │   ├── MainWindow.java
    │   │               │   ├── Themes.java
    │   │               │   └── controls
    │   │               │       ├── ActionButton.java
    │   │               │       ├── ActionMenu.java
    │   │               │       ├── ActionMenuItem.java
    │   │               │       ├── ActionTextArea.java
    │   │               │       ├── ActionTextField.java
    │   │               │       ├── ClassEditor.java
    │   │               │       ├── EnumComboBox.java
    │   │               │       ├── ExceptionAlert.java
    │   │               │       ├── FontComboBox.java
    │   │               │       ├── FontSlider.java
    │   │               │       ├── HexEditor.java
    │   │               │       ├── IconView.java
    │   │               │       ├── KeybindField.java
    │   │               │       ├── LanguageCombo.java
    │   │               │       ├── NullableText.java
    │   │               │       ├── NumberSlider.java
    │   │               │       ├── NumericText.java
    │   │               │       ├── PackageSelector.java
    │   │               │       ├── RenamingTextField.java
    │   │               │       ├── ResourceComboBox.java
    │   │               │       ├── ResourceSelectionCell.java
    │   │               │       ├── SearchBar.java
    │   │               │       ├── SplitableTabPane.java
    │   │               │       ├── StyleCombo.java
    │   │               │       ├── SubLabeled.java
    │   │               │       ├── TableViewExtra.java
    │   │               │       ├── ThemeCombo.java
    │   │               │       ├── TimestampLabel.java
    │   │               │       ├── Toggle.java
    │   │               │       ├── ViewportTabs.java
    │   │               │       ├── WorkspaceNavigator.java
    │   │               │       ├── node
    │   │               │       │   └── ClassNodeEditorPane.java
    │   │               │       ├── pane
    │   │               │       │   ├── AttachPane.java
    │   │               │       │   ├── ColumnPane.java
    │   │               │       │   ├── ConfigPane.java
    │   │               │       │   ├── ConfigTabs.java
    │   │               │       │   ├── ContactInfoPane.java
    │   │               │       │   ├── HistoryPane.java
    │   │               │       │   ├── JvmCreationPane.java
    │   │               │       │   ├── PluginManagerPane.java
    │   │               │       │   ├── SearchPane.java
    │   │               │       │   ├── SysInfoPane.java
    │   │               │       │   └── UpdatePane.java
    │   │               │       ├── popup
    │   │               │       │   ├── DragPopup.java
    │   │               │       │   ├── SuggestionWindow.java
    │   │               │       │   ├── UpdateWindow.java
    │   │               │       │   └── YesNoWindow.java
    │   │               │       ├── text
    │   │               │       │   ├── BytecodeContextHandling.java
    │   │               │       │   ├── BytecodeEditorPane.java
    │   │               │       │   ├── BytecodeErrorHandling.java
    │   │               │       │   ├── BytecodeLocalHelper.java
    │   │               │       │   ├── BytecodeMemberInserterPane.java
    │   │               │       │   ├── BytecodeStackHelper.java
    │   │               │       │   ├── BytecodeSuggestHandler.java
    │   │               │       │   ├── ContextHandling.java
    │   │               │       │   ├── CssContextHandling.java
    │   │               │       │   ├── CssErrorHandling.java
    │   │               │       │   ├── CssThemeEditorPane.java
    │   │               │       │   ├── EditorPane.java
    │   │               │       │   ├── ErrorCell.java
    │   │               │       │   ├── ErrorHandling.java
    │   │               │       │   ├── ErrorList.java
    │   │               │       │   ├── JavaContextHandling.java
    │   │               │       │   ├── JavaDocHandling.java
    │   │               │       │   ├── JavaDocWindow.java
    │   │               │       │   ├── JavaEditorPane.java
    │   │               │       │   ├── JavaErrorHandling.java
    │   │               │       │   ├── model
    │   │               │       │   │   ├── Language.java
    │   │               │       │   │   ├── LanguageStyler.java
    │   │               │       │   │   ├── Languages.java
    │   │               │       │   │   └── Rule.java
    │   │               │       │   └── selection
    │   │               │       │       ├── ClassSelection.java
    │   │               │       │       ├── JumpSelection.java
    │   │               │       │       ├── LabelSelection.java
    │   │               │       │       ├── MemberSelection.java
    │   │               │       │       ├── SwitchSelection.java
    │   │               │       │       └── VariableSelection.java
    │   │               │       ├── tree
    │   │               │       │   ├── AnnoItem.java
    │   │               │       │   ├── BaseItem.java
    │   │               │       │   ├── CatchItem.java
    │   │               │       │   ├── ClassFolderItem.java
    │   │               │       │   ├── ClassItem.java
    │   │               │       │   ├── DirectoryItem.java
    │   │               │       │   ├── FileFolderItem.java
    │   │               │       │   ├── FileItem.java
    │   │               │       │   ├── FilterableTreeItem.java
    │   │               │       │   ├── InsnItem.java
    │   │               │       │   ├── JavaResourceCell.java
    │   │               │       │   ├── JavaResourceTree.java
    │   │               │       │   ├── LocalItem.java
    │   │               │       │   ├── MemberItem.java
    │   │               │       │   ├── MiscItem.java
    │   │               │       │   ├── PackageItem.java
    │   │               │       │   ├── RootItem.java
    │   │               │       │   └── SearchRootItem.java
    │   │               │       └── view
    │   │               │           ├── BytecodeViewport.java
    │   │               │           ├── ClassViewport.java
    │   │               │           ├── EditorViewport.java
    │   │               │           └── FileViewport.java
    │   │               ├── util
    │   │               │   ├── AccessFlag.java
    │   │               │   ├── AutoCompleteUtil.java
    │   │               │   ├── ClassUtil.java
    │   │               │   ├── ClasspathUtil.java
    │   │               │   ├── CollectionUtil.java
    │   │               │   ├── DefineUtil.java
    │   │               │   ├── EscapeUtil.java
    │   │               │   ├── IOUtil.java
    │   │               │   ├── IllegalBytecodePatcherUtil.java
    │   │               │   ├── InsnUtil.java
    │   │               │   ├── InternalElement.java
    │   │               │   ├── Java9Util.java
    │   │               │   ├── JavaParserRecovery.java
    │   │               │   ├── JavaParserUtil.java
    │   │               │   ├── LangUtil.java
    │   │               │   ├── Log.java
    │   │               │   ├── MavenUtil.java
    │   │               │   ├── Natives.java
    │   │               │   ├── NetworkUtil.java
    │   │               │   ├── OSUtil.java
    │   │               │   ├── OpcodeUtil.java
    │   │               │   ├── ProcessUtil.java
    │   │               │   ├── RecafClassLoader.java
    │   │               │   ├── ReflectUtil.java
    │   │               │   ├── RegexUtil.java
    │   │               │   ├── Resource.java
    │   │               │   ├── ShortcutUtil.java
    │   │               │   ├── StringUtil.java
    │   │               │   ├── ThreadUtil.java
    │   │               │   ├── TypeUtil.java
    │   │               │   ├── UiUtil.java
    │   │               │   ├── VMUtil.java
    │   │               │   ├── self
    │   │               │   │   ├── SelfDependencyPatcher.java
    │   │               │   │   ├── SelfReferenceUtil.java
    │   │               │   │   ├── SelfUpdater.java
    │   │               │   │   └── UpdateTaskStarter.java
    │   │               │   └── struct
    │   │               │       ├── Errorable.java
    │   │               │       ├── Expireable.java
    │   │               │       ├── InternalBiConsumer.java
    │   │               │       ├── InternalConsumer.java
    │   │               │       ├── LineException.java
    │   │               │       ├── ListeningMap.java
    │   │               │       ├── Pair.java
    │   │               │       └── ThreadAction.java
    │   │               └── workspace
    │   │                   ├── ArchiveResource.java
    │   │                   ├── ClassResource.java
    │   │                   ├── DeferringResource.java
    │   │                   ├── DirectoryResource.java
    │   │                   ├── EmptyResource.java
    │   │                   ├── EntryLoader.java
    │   │                   ├── FileSystemResource.java
    │   │                   ├── FileSystemResourceLocation.java
    │   │                   ├── History.java
    │   │                   ├── InstrumentationResource.java
    │   │                   ├── JarResource.java
    │   │                   ├── JavaResource.java
    │   │                   ├── LazyClasspathResource.java
    │   │                   ├── LiteralResourceLocation.java
    │   │                   ├── MavenResource.java
    │   │                   ├── PhantomResource.java
    │   │                   ├── ResourceKind.java
    │   │                   ├── ResourceLocation.java
    │   │                   ├── UrlResource.java
    │   │                   ├── WarResource.java
    │   │                   ├── Workspace.java
    │   │                   ├── WorkspaceClassWriter.java
    │   │                   └── WorkspaceIO.java
    │   └── resources
    │       ├── icons
    │       │   ├── binary.png
    │       │   ├── class
    │       │   │   ├── annotation.png
    │       │   │   ├── class.png
    │       │   │   ├── enum.png
    │       │   │   ├── interface.png
    │       │   │   └── package-flat.png
    │       │   ├── data.png
    │       │   ├── discord.png
    │       │   ├── error.png
    │       │   ├── find-light.png
    │       │   ├── find.png
    │       │   ├── folder-package.png
    │       │   ├── folder-resource.png
    │       │   ├── folder-source.png
    │       │   ├── folder.png
    │       │   ├── github.png
    │       │   ├── image.png
    │       │   ├── jar.png
    │       │   ├── link.png
    │       │   ├── logo-full.png
    │       │   ├── logo.png
    │       │   ├── modifier
    │       │   │   ├── abstract.png
    │       │   │   ├── field_default.png
    │       │   │   ├── field_private.png
    │       │   │   ├── field_protected.png
    │       │   │   ├── field_public.png
    │       │   │   ├── final.png
    │       │   │   ├── method_default.png
    │       │   │   ├── method_private.png
    │       │   │   ├── method_protected.png
    │       │   │   ├── method_public.png
    │       │   │   ├── native.png
    │       │   │   ├── static.png
    │       │   │   └── synthetic.png
    │       │   ├── object.png
    │       │   ├── primitive.png
    │       │   ├── result.png
    │       │   ├── stack.png
    │       │   ├── text-code.png
    │       │   ├── text.png
    │       │   ├── uninitialized.png
    │       │   └── variable.png
    │       ├── languages
    │       │   ├── bytecode.json
    │       │   ├── css.json
    │       │   ├── java.json
    │       │   ├── json.json
    │       │   ├── mf.json
    │       │   ├── properties.json
    │       │   └── xml.json
    │       ├── logback.xml
    │       ├── style
    │       │   ├── base.css
    │       │   ├── text-dark.css
    │       │   ├── text-default.css
    │       │   ├── ui-dark.css
    │       │   └── ui-default.css
    │       └── translations
    │           ├── en.json
    │           ├── fr.json
    │           └── zh-cn.json
    └── test
        ├── java
        │   └── me
        │       └── coley
        │           └── recaf
        │               ├── AssemblyAstTest.java
        │               ├── AssemblyCasesTest.java
        │               ├── Base.java
        │               ├── CompilerTest.java
        │               ├── CorrelationTest.java
        │               ├── DecompileTest.java
        │               ├── ExpressionCompilerTest.java
        │               ├── FlowGraphTest.java
        │               ├── GraphTest.java
        │               ├── HeadlessTest.java
        │               ├── HierarchyGraphTest.java
        │               ├── HistoryTest.java
        │               ├── JavadocsTest.java
        │               ├── RemappingTest.java
        │               ├── ResourceInputTest.java
        │               ├── ResourceUpdateTest.java
        │               ├── SearchTest.java
        │               ├── SourceCodeTest.java
        │               ├── StylerTest.java
        │               ├── mapping
        │               │   └── AsmMappingUtilsTest.java
        │               └── util
        │                   └── TestUtils.java
        └── resources
            ├── Hello.class
            ├── Hello.java
            ├── InnerTest.jar
            ├── Manifest.jar
            ├── Point.class
            ├── Point.java
            ├── calc-docs-12.zip
            ├── calc-docs-8.zip
            ├── calc-modified.jar
            ├── calc-renamed.jar
            ├── calc.jar
            ├── calls.jar
            ├── inherit-class-map.txt
            ├── inherit-method-map-enigma.txt
            ├── inherit-method-map-jadx.txt
            ├── inherit-method-map-proguard.txt
            ├── inherit-method-map-tiny-1.txt
            ├── inherit-method-map-tiny-2.txt
            ├── inherit-method-map-tsrg.txt
            ├── inherit-method-map.txt
            ├── inherit-proguard.jar
            ├── inherit.jar
            ├── manifest-map.txt
            └── tinylog.properties

```

`CONTRIBUTING.md`:

```md
# Contributing to Recaf

The following is a series of guidelines for contributing to Recaf. 
They're not _"rules"_ per say, rather they're more like goals to strive towards. 
Regardless of how closely you adhere to the following guidelines I really appreciate you taking the time to contribute, it means a lot :+1:

**Table of Contents**

 * [What if I am not a programmer?](#what-if-i-am-not-a-programmer)
 * [What should I know before I get started?](#what-should-i-know-before-getting-started)
 * [Is there a todo list?](#is-there-a-todo-list)
 * [Reporting Bugs](#reporting-bugs)
 * [Suggesting Features](#suggesting-features)
 * [Coding Guidelines](#coding-guidelines)
 * [Pull Requests](#pull-requests)
 * [Commit messages](#commit-messages)
 
**TLDR?**

Follow the style of the rest of the code. 
Comment your code where it makes sense. 
Make sure the unit tests pass before submitting a pull request. Follow the [commit message rules](#commit-messages).

## What if I am not a programmer?

[There is plenty to contribute that isn't based in code.](https://www.youtube.com/watch?v=GAqfMNB-YBU&t=603)

Check out the [non-technical board](https://github.com/Col-E/Recaf/projects/3) for further directions and ways to contribute.

## What should I know before getting started?

It depends on what changes you are making. 
For instance, changing the user-interface requires no reverse-engineering prior knowledge. 

When contributing features / fixes to components that revolve around the class file, see the recommended reading document: [PRIMER.md](PRIMER.md)

## Is there a todo list?

There's multiple places where _"TODO"_ items may be:

 * [Issues](https://github.com/Col-E/Recaf/issues)
 * [Project board](https://github.com/Col-E/Recaf/projects)

Additionally you can check for `// TODO:` messages in the source code. 
Not everything is given its own issue or project goal. 
Most IDE's have a feature to show all of these messages. 
These are typically smaller scale items than what appear on the issues/project board.

## Reporting Bugs

When creating an issue select the `Bug report` button. 
This will provide a template that you can fill in the details for your bug. 
Please include as much information as possible. 
This can include:

 * Clear and descriptive title
 * Log files
 * Steps to reproduce the bug 
 * An explanation of what you _\*expected\*_ to happen
 * The file being analyzed _(Do not share anything you do not own the rights to)_ 

## Suggesting Features

When creating an issue select the `Feature request` button. 
This will provide a template that you can fill in the details for your feature idea. 
Be as descriptive as possible with your idea. 

**Note**: Not all ideas may be within Recaf's scope. In this case it should be implemented using the plugin api. 
You can check out the template plugin project along with plugin documentation here: [Recaf-plugin-workspace](https://github.com/Col-E/Recaf-plugin-workspace)

## Coding Guidelines

Recaf uses Checkstyle to enforce a modified varient of the [Google Java guidelines](https://google.github.io/styleguide/javaguide.html). 
The default formatting of IntelliJ or Eclipse should work just fine. 
Don't auto-format entire classes at a time though. 
Only format code that you are modifying. 
This keeps the commits small and localized to the changes you're creating, making it easier for others to understand the intent behind each commit.

Aside from format enforcement there are also some code-complexity checks that prevent methods from being too large or having too much control flow. 
This is intended to cut down giant methods into smaller and more understandable chunks.

## Pull Requests

Before making a pull request make sure that your changes successfully compile and pass the unit tests. 
You can do so by running the following maven command: `mvn clean test`

When creating a pull request please consider the following when filling in the template:

 * Clear and descriptive title
 * A clear description of what changes are included in the pull

## Commit messages
This project follows the [Semantic Versioning](https://semver.org/) specification, which is completely automated through the Continuous Integration and [semantic-release](https://github.com/semantic-release/semantic-release). 
To make this possible, it is crucial to use the [Angular Commit Message Conventions](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines) in all of your commits, to allow the system to categorize your changes and take appropriate actions.

### Examples
* **feat**: A new feature
* **fix**: A bug fix
* **docs**: Documentation only changes
* **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing
  semi-colons, etc)
* **refactor**: A code change that neither fixes a bug nor adds a feature
* **perf**: A code change that improves performance
* **test**: Adding missing or correcting existing tests
* **chore**: Changes to the build process or auxiliary tools and libraries such as documentation
  generation
```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2017-2021 Matthew Coley

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`PRIMER.md`:

```md
# What should I know before getting started?

## JVM / Class file format

### General concepts

A basic understanding of the JVM / class file format is _highly_ reccomended before contributing. 
Here are some articles that should bring you up to speed:

 * [JVM Architecture 101: Get to Know Your Virtual Machine](https://blog.overops.com/jvm-architecture-101-get-to-know-your-virtual-machine/)
 * [JVM Internals](https://blog.jamesdbloom.com/JVMInternals.html)
 * [Java Code To Byte Code](https://blog.jamesdbloom.com/JavaCodeToByteCode_PartOne.html)

### Terminology

**Qualified name**: Package separators using the `.` character. 
These are names used by runtime functions like `Class.forName(name)`.

For example: 

 * `java.lang.String`
 * `com.example.MyClass.InnerClass`

**Internal name**: Package separators using the `/` character. 
Inner classes specified with the `$` character. 
These are names how classes are specified internally in the class file.

For example: 

 * `java/lang/String`
 * `com/example/MyClass$InnerClass`

Primitives *(Not the boxed types)* use single characters:

| Primitive | Internal |
|-----------|----------|
| `long`    | `J`      |
| `int`     | `I`      |
| `short`   | `S`      |
| `byte`    | `B`      |
| `boolean` | `Z`      |
| `float`   | `F`      |
| `double`  | `D`      |
| `void`    | `V`      |

**Descriptor**: Used to describe field and method types. 
These are essentially the same as internal names, but class names are wrapped in a prefix (`L`) and suffix character (`;`).

For example: 

 * `Ljava/lang/String;`
 * `I` _(primitives stay the same)_
 
Method descriptors are formatted like so:
 
 * `double method(int i, String s)` = `(ILjava/lang/String;)D`
 * `void method()` = `()V`
 
Arrays are prefixed with a `[` for each level of the array.

 * `int[]` = `[I`
 * `String[][]` = `[[Ljava/lang/String;`
 
### Quirks

`double` and `long` typed variables take up two slots _(On the stack and in the local variable table)_.
For example, declaring two doubles in a static method will use slots 0, then 2. 
Slots 0-3 are all in-use. 

```

`PULL_REQUEST_TEMPLATE.md`:

```md
## What's new

* Summary of additions

## What's fixed

* Summary of bugs fixed

```

`README.md`:

```md
# Recaf [![Discord](https://img.shields.io/discord/443258489146572810.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/Bya5HaA) [![Build Status](https://cloud.drone.io/api/badges/Col-E/Recaf/status.svg)](https://cloud.drone.io/Col-E/Recaf) ![downloads](https://img.shields.io/github/downloads/Col-E/Recaf/total.svg) [![Contributions welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](CONTRIBUTING.md)

![screenshot of recaf](docs/screenshots/main-anim.gif)

An easy to use modern Java bytecode editor that abstracts away the complexities of Java programs.
Recaf abstracts away:

* Constant pool
* Stack frames
* Wide instructions
* And more!

Don't know bytecode? That's ok because Recaf supports [recompiling decompiled code](https://col-e.github.io/Recaf-documentation/use-edit-via-decompile.html) and inserting [single line Java statements into the bytecode](https://col-e.github.io/Recaf-documentation/use-assembler.html).

For more information: _[Read the documentation](https://col-e.github.io/Recaf-documentation/)_

## Download

See the [releases](https://github.com/Col-E/Recaf/releases) page for the latest build.

## Preface

If you're just getting started with reverse-engineering in Java, read [primer guide](PRIMER.md). Then check the documentation pages.

## Contributing 

**Are you a developer?**

Check out the [open issues](https://github.com/Col-E/Recaf/issues), [project boards](https://github.com/Col-E/Recaf/projects), and many scattered `TODO` messages throughout the source code. There's plenty to do.

**Not a developer?** 

You can help by reporting bugs, making suggestions, providing translations, and sharing this project.

> More information can be found in the [contribution guide](CONTRIBUTING.md).

## Setting up the project

Clone the repository via `git clone https://github.com/Col-E/Recaf.git`

Open the project in an IDE or generate the build with maven.

**IDE**:
  1. Import the project from the `pom.xml`
      * [IntelliJ](https://www.jetbrains.com/help/idea/maven-support.html#maven_import_project_start)
      * [Eclipse](https://stackoverflow.com/a/36242422) - _(Warning: Eclipse's custom compiler cannot compile Recaf because of incorrect generics parsing)_
  2. Create a run configuration with the main class `me.coley.recaf.Recaf`
  
**Without IDE**:
  1. Execute `build`
      * Follow the prompt in the script to build the project.
  2. Run the generated build: `java -jar target/recaf-{version}-jar-with-dependencies.jar`

For additional information, join the [Discord server _(https://discord.gg/Bya5HaA)_](https://discord.gg/Bya5HaA)

```

`build`:

```
#!/bin/bash
set -e
echo '==========================='
echo 'Build Modes'
echo '------'
echo ' 1. Build with tests (Slow)'
echo ' 2. Build with no tests (Fast)'
echo '------'
echo ' 3. Exit'
echo '==========================='
echo -n 'Enter build mode: '
read mode
if [[ $mode == '1' ]]; then
  ./mvnw clean package;
elif [[ $mode == '2' ]]; then
  ./mvnw clean package -Dmaven.test.skip -Dcheckstyle.skip;
fi;
```

`build.cmd`:

```cmd
@ECHO OFF
ECHO ===========================
ECHO Build Modes
ECHO ------
ECHO  1. Build with tests (Slow)
ECHO  2. Build with no tests (Fast)
ECHO ------
ECHO  3. Exit
ECHO ===========================
SET /P MODE=Mode:
IF %MODE%==1 GOTO FULL
IF %MODE%==2 GOTO FAST
:FULL
call mvnw clean package
GOTO END
:FAST
call mvnw clean package -Dmaven.test.skip -Dcheckstyle.skip
GOTO END
:END
```

`checkstyle-suppressions.xml`:

```xml
<?xml version="1.0"?>
<!DOCTYPE suppressions PUBLIC
		"-//Checkstyle//DTD SuppressionFilter Configuration 1.0//EN"
		"https://checkstyle.org/dtds/suppressions_1_0.dtd">
<suppressions>
	<!-- Too many closely related types, referenced/instantiated.
	 	 Unavoidable due to architecture.
	 	 Refactoring would make the design less legible / maintainable.
	 -->
	<suppress checks="CyclomaticComplexity"
			  files="JavacTargetVersion.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="Disassembler.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="Disassembler.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="MethodAssembler.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="MethodAssembler.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="JavassistMethodTranslator.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="JavaParserUtil.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="JavaParserUtil.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="JavaParserRecovery.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="SimpleRecordingRemapper.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="Variables.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="MethodAssembler.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="JavassistASMTranslator.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="Parse.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="InvokeDynamicParser.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="LdcInsnParser.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="SearchRootItem.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="SearchRootItem.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="SplitableTabPane.java"
			  lines="0-9999"/>

	<suppress checks="ClassFanOutComplexity"
			  files="ContextBuilder.java"
			  lines="0-9999"/>

	<suppress checks="CyclomaticComplexity"
			  files="BytecodeContextHandling.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="BytecodeContextHandling.java"
			  lines="0-9999"/>

	<suppress checks="ClassDataAbstractionCoupling"
			  files="MainMenu.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="MainMenu.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="SearchPane.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="SearchPane.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="ClassNodeEditorPane.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="ClassNodeEditorPane.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="ClassNodeEditorPane.java"
			  lines="0-9999"/>
	<suppress checks="Indentation"
			  files="ClassNodeEditorPane.java"
			  lines="0-9999"/>

	<suppress checks="CyclomaticComplexity"
			  files="VMWrap.java"
			  lines="0-9999"/>
	<suppress checks="ClassFanOutComplexity"
			  files="VMWrap.java"
			  lines="0-9999"/>

	<suppress checks="CyclomaticComplexity"
			  files="LoadWorkspace.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="WorkspaceIO.java"
			  lines="0-9999"/>
	<suppress checks="CyclomaticComplexity"
			  files="Configurable.java"
			  lines="0-9999"/>

	<suppress checks="BooleanExpressionComplexity"
			  files="ClassUtil.java"
			  lines="0-9999"/>

	<suppress checks="CyclomaticComplexity"
			  files="IllegalBytecodePatcherUtil.java"
			  lines="0-9999"/>

	<suppress checks="ClassDataAbstractionCoupling"
			  files="FernFlowerAccessor.java"
			  lines="0-9999"/>

	<suppress checks="ClassFanOutComplexity"
			  files="UiUtil.java"
			  lines="0-9999"/>
	<suppress checks="ClassDataAbstractionCoupling"
			  files="UiUtil.java"
			  lines="0-9999"/>
</suppressions>

```

`checkstyle.xml`:

```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
		"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
		"https://checkstyle.org/dtds/configuration_1_3.dtd">
<module name = "Checker">
	<property name="charset" value="UTF-8"/>
	<property name="severity" value="warning"/>
	<property name="fileExtensions" value="java"/>
	<property name="tabWidth" value="4"/>
	<module name="TreeWalker">
		<module name="SuppressionCommentFilter"/>
		<module name="OuterTypeFilename"/>
		<module name="EmptyBlock">
			<property name="option" value="TEXT"/>
			<property name="tokens"
					  value="LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH"/>
		</module>
		<module name="ArrayTypeStyle"/>
		<module name="MissingSwitchDefault"/>
		<!-- <module name="FallThrough"/> -->
		<module name="ModifierOrder"/>
		<module name="EmptyLineSeparator">
			<property name="allowNoEmptyLineBetweenFields" value="true"/>
		</module>
		<module name="SeparatorWrap">
			<property name="id" value="SeparatorWrapDot"/>
			<property name="tokens" value="DOT"/>
			<property name="option" value="nl"/>
		</module>
		<module name="SeparatorWrap">
			<property name="id" value="SeparatorWrapComma"/>
			<property name="tokens" value="COMMA"/>
			<property name="option" value="EOL"/>
		</module>
		<module name="SeparatorWrap">
			<!-- ELLIPSIS is EOL until https://github.com/google/styleguide/issues/258 -->
			<property name="id" value="SeparatorWrapEllipsis"/>
			<property name="tokens" value="ELLIPSIS"/>
			<property name="option" value="EOL"/>
		</module>
		<module name="SeparatorWrap">
			<!-- ARRAY_DECLARATOR is EOL until https://github.com/google/styleguide/issues/259 -->
			<property name="id" value="SeparatorWrapArrayDeclarator"/>
			<property name="tokens" value="ARRAY_DECLARATOR"/>
			<property name="option" value="EOL"/>
		</module>
		<module name="SeparatorWrap">
			<property name="id" value="SeparatorWrapMethodRef"/>
			<property name="tokens" value="METHOD_REF"/>
			<property name="option" value="nl"/>
		</module>
		<module name="PackageName">
			<property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
			<message key="name.invalidPattern"
					 value="Package name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="TypeName">
			<message key="name.invalidPattern"
					 value="Type name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="MemberName">
			<property name="format" value="^[a-z][a-z0-9]?[a-zA-Z0-9]*$"/>
			<message key="name.invalidPattern"
					 value="Member name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="ParameterName">
			<property name="format" value="^[a-z]([a-z0-9]?[a-zA-Z0-9]*)?$"/>
			<message key="name.invalidPattern"
					 value="Parameter name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="LambdaParameterName">
			<property name="format" value="^[a-z]([a-z0-9]?[a-zA-Z0-9]*)?$"/>
			<message key="name.invalidPattern"
					 value="Lambda parameter name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="CatchParameterName">
			<property name="format" value="^[a-z]([a-z0-9]?[a-zA-Z0-9]*)?$"/>
			<message key="name.invalidPattern"
					 value="Catch parameter name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="LocalVariableName">
			<property name="tokens" value="VARIABLE_DEF"/>
			<property name="format" value="^[a-z]([a-z0-9]?[a-zA-Z0-9]*)?$"/>
			<message key="name.invalidPattern"
					 value="Local variable name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="ClassTypeParameterName">
			<property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*$)"/>
			<message key="name.invalidPattern"
					 value="Class type name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="MethodTypeParameterName">
			<property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)"/>
			<message key="name.invalidPattern"
					 value="Method type name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="InterfaceTypeParameterName">
			<property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)"/>
			<message key="name.invalidPattern"
					 value="Interface type name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="NoFinalizer"/>
		<module name="Indentation">
			<property name="basicOffset" value="4"/>
			<property name="braceAdjustment" value="0"/>
			<property name="caseIndent" value="4"/>
			<property name="throwsIndent" value="4"/>
			<property name="lineWrappingIndentation" value="4"/>
			<property name="arrayInitIndent" value="4"/>
		</module>
		<module name="OverloadMethodsDeclarationOrder"/>
		<module name="MethodParamPad"/>
		<module name="NoWhitespaceBefore">
			<property name="tokens"
					  value="COMMA, SEMI, POST_INC, POST_DEC, DOT, ELLIPSIS, METHOD_REF"/>
			<property name="allowLineBreaks" value="true"/>
		</module>
		<module name="ParenPad"/>
		<module name="AnnotationLocation">
			<property name="id" value="AnnotationLocationMostCases"/>
			<property name="tokens"
					  value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF"/>
		</module>
		<module name="AnnotationLocation">
			<property name="id" value="AnnotationLocationVariables"/>
			<property name="tokens" value="VARIABLE_DEF"/>
			<property name="allowSamelineMultipleAnnotations" value="true"/>
		</module>
		<module name="NonEmptyAtclauseDescription"/>
		<module name="AtclauseOrder">
			<property name="tagOrder" value="@param, @return, @throws, @deprecated"/>
			<property name="target"
					  value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF"/>
		</module>
		<module name="InvalidJavadocPosition"/>
		<module name="JavadocBlockTagLocation"/>
		<module name="JavadocContentLocationCheck"/>
		<module name="JavadocParagraph"/>
		<module name="JavadocType"/>
		<module name="SingleLineJavadoc">
			<property name="ignoreInlineTags" value="false"/>
		</module>
		<module name="JavadocMethod">
			<property name="scope" value="public"/>
			<property name="validateThrows" value="false"/>
			<property name="allowedAnnotations" value="Override, Test"/>
		</module>
		<module name="MissingJavadocMethod"/>
		<module name="MissingJavadocType"/>
		<!-- <module name="MissingJavadocMethod">
			<property name="scope" value="private"/>
			<property name="minLineCount" value="1"/>
			<property name="allowedAnnotations" value="Override, Test"/>
		</module> -->
		<module name="MethodName">
			<property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9_]*$"/>
			<message key="name.invalidPattern"
					 value="Method name ''{0}'' must match pattern ''{1}''."/>
		</module>
		<module name="EmptyCatchBlock">
			<property name="exceptionVariableName" value="expected"/>
		</module>
		<module name="CommentsIndentation"/>
		<!-- Code complexity -->
		<module name="BooleanExpressionComplexity"/>
		<module name="ClassDataAbstractionCoupling">
			<!-- Number of instantiations -->
			<property name="max" value="8"/>
			<!-- Sets of excluded classes based on general use case -->
			<property name="excludedClasses" value="boolean, byte, char, double, float, int, long, short, void"/>
			<property name="excludedClasses" value="Boolean, Byte, Character, Double, Float, Integer, Long, Short, Void"/>
			<property name="excludedClasses" value="Object, Class, String, StringBuffer, StringBuilder"/>
			<property name="excludedClasses" value="ArrayIndexOutOfBoundsException, Exception, RuntimeException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NullPointerException, Throwable, SecurityException, UnsupportedOperationException"/>
			<property name="excludedClasses" value="List, ArrayList, Deque, Queue, LinkedList, Set, HashSet, SortedSet, TreeSet, Map, HashMap, SortedMap, TreeMap, Pair"/>
			<property name="excludedClasses" value="File, FileUtils, Path, Paths, URL"/>
			<property name="excludedClasses" value="ClassReader, ClassWriter, ClassVisitor, Opcodes"/>
			<property name="excludedClasses" value="ActionMenu, ActionMenuItem, IconView, BorderPane, ListView, Label, TextField"/>
			<property name="excludedPackages" value="javafx.scene, javafx.scene.control, javafx.scene.layout, javafx.stage, javafx.application"/>
		</module>
		<module name="ClassFanOutComplexity">
			<!-- Number of type references -->
			<property name="max" value="20"/>
			<!-- Sets of excluded classes based on general use case -->
			<property name="excludedClasses" value="boolean, byte, char, double, float, int, long, short, void"/>
			<property name="excludedClasses" value="Boolean, Byte, Character, Double, Float, Integer, Long, Short, Void"/>
			<property name="excludedClasses" value="Object, Class, String, StringBuffer, StringBuilder"/>
			<property name="excludedClasses" value="ArrayIndexOutOfBoundsException, Exception, RuntimeException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NullPointerException, Throwable, SecurityException, UnsupportedOperationException"/>
			<property name="excludedClasses" value="List, ArrayList, Deque, Queue, LinkedList, Set, HashSet, SortedSet, TreeSet, Map, HashMap, SortedMap, TreeMap"/>
			<property name="excludedClasses" value="File, FileUtils, Path, Paths, URL"/>
			<property name="excludedClasses" value="ActionMenu, ActionMenuItem, IconView"/>
			<property name="excludedPackages" value="javafx.scene, javafx.scene.control, javafx.scene.layout, javafx.stage, javafx.application, javafx.scene.input"/>
			<!-- JavaParser is so overly-verbose with its types that its impossible to use it without flagging CFOC without a filter like this -->
			<property name="excludedPackages" value="com.github.javaparser, com.github.javaparser.ast, com.github.javaparser.ast.body, com.github.javaparser.ast.type"/>
			<property name="excludedPackages" value="com.github.javaparser.resolution, com.github.javaparser.resolution.declarations, com.github.javaparser.resolution.types"/>
			<!-- Same situation with the AST parsing -->
			<property name="excludedPackages" value="me.coley.recaf.parse.bytecode.ast, me.coley.recaf.parse.bytecode.parser"/>
		</module>
		<module name="CyclomaticComplexity">
			<!-- Number of possible paths through the source -->
			<property name="max" value="15"/>
		</module>
		<module name="OneStatementPerLine"/>
		<module name="OneTopLevelClass"/>
		<module name="UnusedImports"/>
	</module>
	<module name="LineLength">
		<property name="max" value="120"/>
		<property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
	</module>
	<module name="FileLength">
		<property name="max" value="1500"/>
	</module>
</module>

```

`docs/css/assets/download.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="48px" height="48px">
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
</svg>
```

`docs/css/banner.css`:

```css
.banner-wrapper {
    border-bottom: 1px solid black;
}
.banner {
    background: transparent url('assets/header-bg-blur.jpg') 0 0 no-repeat fixed;
    text-align: center;
    background-size: cover;
    height: 400px;
    width: 100%;
    display: table;
    border-bottom: 1px solid rgb(66, 66, 66);
}

.banner-head {
    display: table-cell;
    vertical-align: middle;
    margin-bottom: 0;
    color: white;
    font-weight: 500;
    text-shadow: 0 1px 1px black;
}
.banner-head > .banner-beam > h1 {
    font-size: 6em;
    line-height: 0;
    text-shadow: 6px 6px black;
}
.banner-head > .banner-beam > p {
    font-size: 1.5em;
    text-shadow: 2px 2px black;
}
.banner-beam {
    background-color: rgba(0,0,0,0.35);
    border-top: 1px solid black;
    border-bottom: 1px solid black;
}

#download {
    padding: 1em;
    margin-top: 4em;
}
#download::before {
	/* Border inside section bottom */
	content: '';
	background-image: url('assets/download.svg');
    background-repeat: no-repeat;
    background-position: top 9px left 9px;
/* A very specific positioning hack, but it works */
    position: relative;
    display: inline-block;
    width: 50px;
    height: 50px;
    top: -4px;
    margin: -16px;
    margin-left: -25px;
    padding-right: 20px;
    	
}

/* ===== TABLET MEDIA QUERIES ===== */
@media(max-width: 767px) {
    #download {
        display: none;
    }
    
    .banner-head > .banner-beam > h1 {
        font-size: 4em;
    }
}

/* ===== PHONE MEDIA QUERIES ===== */
@media(max-width: 480px) {
    #download {
        display: none;
    }
    
    .banner-head > .banner-beam > h1 {
        font-size: 3em;
    }
}

```

`docs/css/code.css`:

```css
/* Inline code element/span */
.code,
code {
	font-family: monospace;
	background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
	border: 1px solid rgba(0, 0, 0, 0.8);
	counter-reset: line;
    padding: 1px;
    padding-left: 3px;
    padding-right: 3px;
}
/* ============================= */
/* ======== CODE BLOCK ========= */
/* ============================= */
pre {
    border-radius: 5px;
    padding: 1em;
	font-family: monospace;
	background: rgba(0, 0, 0, 0.5);
	border: 1px solid rgba(0, 0, 0, 0.9);
	counter-reset: ln;
	margin-left: 2px;
	margin-right: 2px;
	overflow: auto;
}
pre * { 
	font-family: monospace;
}
/* show line numbers */
pre .line { 
	display: inline-block;
	/* 40 + 10 = 50, 40 is from "line::before" */
	width: 50px;
}
pre .line::before {
	counter-increment: ln;
	content: counter(ln);
	display: inline-block;
	color: rgb(200, 200, 200); 
	font-weight: normal; 
	font-style: normal; 
	border-right: 1px solid rgb(45, 45, 45);
	padding: 0 15;
	margin: 0 10 0 0;
	width: 40px;
	text-align: center;
}
/* code style for element types */
pre .keyword { 
	color: rgb(80, 130, 225);
	font-weight: bold;
	text-shadow: none;
}
pre .string { 
	color: rgb(60, 190, 150); 
	font-style: italic;
}
pre .const {
	color: rgb(175, 145, 235); 
}
pre .annotation {
	color: rgb(120, 130, 150); 
}
pre .error {
	color: rgb(255, 40, 40); 
}
pre .comment-line,
pre .comment-multi {
	color: rgb(100, 165, 165); 
	font-style: italic;
}
pre .comment-javadoc { 
	color: rgb(115, 165, 200); 
	font-style: italic;
}
```

`docs/css/common.css`:

```css
body {
    background: rgb(35, 35, 35);
    color: rgb(220, 220, 220);
    font-family: Roboto, sans-serif;
}
p {
    line-height: 1.3em;
}
h1,
h2 {
    color: rgb(220, 240, 255);
}
del {
    opacity: 0.4;
}
img {
    max-width: 100%;
}
blockquote {
    margin-left: 0;
    background-color: rgb(32, 42, 49);
    border-left: solid 4px rgb(70, 145, 210);
    overflow: hidden;
    padding: 0.8em;
}
blockquote strong,
blockquote b {
    color: rgb(160, 210, 255);
}
a {
    color: rgb(70, 145, 210);
}
a:visited {
    color: rgb(100, 135, 165);
}
a:hover {
    color: rgb(95, 175, 240);
}
video {
    max-width: 100%;
    max-height: 500px;
}
.inline {
    display: inline;
}
.leftmargin {
    margin-left: 8px;
    text-decoration: none;
}
.logo {
    position: relative;
    height: 60px;
    width: 60px;
    background: url('assets/logo.png');
    background-repeat: no-repeat;
    background-size: contain;
	float: left;
}
article {
    margin: 1em;
}
.l-content {
    margin: 0 auto;
}
.l-box {
    padding: 0.5em 2em;
}

.pure-button {
    color: white;
    background: rgba(50, 110, 145, 0.7);
    border: 1px solid rgb(0, 0, 0, 0.6);
    box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.6);
	/* Animate hover bg-color 'glow' */
	-webkit-transition: background 0.2s;
    transition: background 0.2s;
}
.pure-button-hover,
.pure-button:hover,
.pure-button:focus {
    background: rgba(85, 180, 240, 0.7);
}
/* ===== PHONE/TABLET MEDIA QUERIES ===== */
@media(max-width: 767px) {
    video {
        width: 100%;
    }   
}
```

`docs/css/docs.css`:

```css
html,
body {
    height: 100%;
    overflow: hidden;
}
.column {
    height: 100%;
}
.aligner {
    white-space: nowrap;
    width: 100%;
    display: table;
    vertical-align: top;
}
.aligner img{
    max-width: 100%;
    max-height: 100%;
    display: table-cell;
}
article {
    margin: 0;
    display: flex;
    flex-flow: column wrap;
    height: calc(100% - 65px);
}
#sidebar {
    height: 100%;
    overflow-y: auto;
    order: 1;
    min-width: 170px;
    background: rgb(28, 28, 28);
    scrollbar-color: rgb(66, 66, 66) rgb(28, 28, 28);
    scrollbar-width: thin;
}
#sidebar .pure-menu {
    min-width: 170px;
    height: 100%;
    border-right: 1px solid black;
    border-bottom: none;
}
#sidebar .pure-menu:after {
    pointer-events: none;
    display: none;
    border: none;
}
#sidebar .pure-menu-item {
    color: rgb(222, 222, 222);
    
}
#sidebar .pure-menu-link {
    color: rgb(70, 145, 210);
}
#sidebar .pure-menu-link,
#sidebar .pure-menu-link:visited {
    padding: 0.25em 1em;
}
#sidebar .parent-menu {
    padding: 0.25em 1em;
}
#sidebar .pure-menu-sub-list .pure-menu-link {
    margin-left: -0.75em;
}
#sidebar hr {
    margin: 0.25em;
    width: calc(100% - 4em);
    position: relative;
    right: 1em;
    border: 0;
    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}
#sidebar hr::after {
    border: 0;
    content: '';
    position: relative;
    display: block;
    width: 100%;
    margin: 0;
    height: 1px;
    background-image: linear-gradient(to right, rgba(80, 80, 80, 0), rgba(80, 80, 80, 0.75), rgba(80, 80, 80, 0)); 
}
#content hr {
    border-top: 1px solid rgb(66, 66, 66);
    border-bottom: 1px solid black;
    position: relative;
}
#content .pure-table {
    width: calc(100% - 2px);
}
#content {
    width: calc(100% - 14.5em);
    border-left: 1px solid rgb(66, 66, 66);
    order: 2;
    margin: 0;
    padding-left: 1em;
    padding-right: 1em;
    overflow-y: auto;
    scrollbar-color: rgb(66, 66, 66) rgb(28, 28, 28);
    scrollbar-width: thin;
}
#spacing-hack {
    line-height: 5em;
}
/* ===== PHONE/TABLET MEDIA QUERIES ===== */
@media(max-width: 767px) {
    html, body {
        overflow: auto;
    }
    .column {
        height: 100%;
    }
    article {
        margin: 0;
        display: block;
        flex-flow: none;
        height: auto;
        width: 100%;
    }
    #sidebar {
        display: none;
    }
    #content {
        border-left: none;
        width: calc(100% - 2em);
        height: 100%;
        overflow-x: visible;
    }
    #spacing-hack {
        display: none;
    }
}

```

`docs/css/font/roboto300.css`:

```css
/* cyrillic-ext */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fCRc4EsA.woff2) format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
/* cyrillic */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fABc4EsA.woff2) format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fCBc4EsA.woff2) format('woff2');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fBxc4EsA.woff2) format('woff2');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fCxc4EsA.woff2) format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fChc4EsA.woff2) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: local('Roboto Light'), local('Roboto-Light'), url(https://fonts.gstatic.com/s/roboto/v20/KFOlCnqEu92Fr1MmSU5fBBc4.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

```

`docs/css/menu.css`:

```css
.pure-menu {
    background: rgb(28, 28, 28);
    border-bottom: 1px solid rgb(66, 66, 66);
    text-shadow: 1px 1px black;
}
.pure-menu:after {
    display: block;
    content: '';
    border-top: 1px solid black;
    width: 100%;
}
.pure-menu-link,
.pure-menu-link:visited {
    padding: 1.35em 1em;
    font-size: 1em;
    text-decoration: none;
	color: rgb(222, 222, 222);
	/* Animate hover bg-color 'glow' */
	-webkit-transition: background 0.2s;
    transition: background 0.2s;
	background: rgba(230,235,255,0);
}
.pure-menu-selected > .pure-menu-link,
.pure-menu-selected > .pure-menu-link:visited {
    color: rgb(145, 197, 242);
}
.pure-menu-active > .pure-menu-link,
.pure-menu-link:hover,
.pure-menu-link:focus {
    background-color: rgb(34, 34, 34);
}
.pure-menu .logo {
    margin-right: 0.4em;
}
.pure-menu-sub-list > li:before {
    padding-left: 1em;
    margin-left: -2em;
    top: 0.25em;
    position: relative;
    display: inline;
    float: left;
    content: '•';
}
.pure-menu-sub-list > .pure-menu-sub-list > li {
    padding-left: 1em;
    margin-left: -2em;
}
@media(max-width: 767px) {
    .pure-menu-link,
    .pure-menu-link:visited {
        padding: 1.35em 0.5em;
    }
}
```

`docs/css/pure/grids-responsive-min.css`:

```css
/*!
Pure v2.0.3
Copyright 2013 Yahoo!
Licensed under the BSD License.
https://github.com/pure-css/pure/blob/master/LICENSE.md
*/
@media screen and (min-width:35.5em){.pure-u-sm-1,.pure-u-sm-1-1,.pure-u-sm-1-12,.pure-u-sm-1-2,.pure-u-sm-1-24,.pure-u-sm-1-3,.pure-u-sm-1-4,.pure-u-sm-1-5,.pure-u-sm-1-6,.pure-u-sm-1-8,.pure-u-sm-10-24,.pure-u-sm-11-12,.pure-u-sm-11-24,.pure-u-sm-12-24,.pure-u-sm-13-24,.pure-u-sm-14-24,.pure-u-sm-15-24,.pure-u-sm-16-24,.pure-u-sm-17-24,.pure-u-sm-18-24,.pure-u-sm-19-24,.pure-u-sm-2-24,.pure-u-sm-2-3,.pure-u-sm-2-5,.pure-u-sm-20-24,.pure-u-sm-21-24,.pure-u-sm-22-24,.pure-u-sm-23-24,.pure-u-sm-24-24,.pure-u-sm-3-24,.pure-u-sm-3-4,.pure-u-sm-3-5,.pure-u-sm-3-8,.pure-u-sm-4-24,.pure-u-sm-4-5,.pure-u-sm-5-12,.pure-u-sm-5-24,.pure-u-sm-5-5,.pure-u-sm-5-6,.pure-u-sm-5-8,.pure-u-sm-6-24,.pure-u-sm-7-12,.pure-u-sm-7-24,.pure-u-sm-7-8,.pure-u-sm-8-24,.pure-u-sm-9-24{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-u-sm-1-24{width:4.1667%}.pure-u-sm-1-12,.pure-u-sm-2-24{width:8.3333%}.pure-u-sm-1-8,.pure-u-sm-3-24{width:12.5%}.pure-u-sm-1-6,.pure-u-sm-4-24{width:16.6667%}.pure-u-sm-1-5{width:20%}.pure-u-sm-5-24{width:20.8333%}.pure-u-sm-1-4,.pure-u-sm-6-24{width:25%}.pure-u-sm-7-24{width:29.1667%}.pure-u-sm-1-3,.pure-u-sm-8-24{width:33.3333%}.pure-u-sm-3-8,.pure-u-sm-9-24{width:37.5%}.pure-u-sm-2-5{width:40%}.pure-u-sm-10-24,.pure-u-sm-5-12{width:41.6667%}.pure-u-sm-11-24{width:45.8333%}.pure-u-sm-1-2,.pure-u-sm-12-24{width:50%}.pure-u-sm-13-24{width:54.1667%}.pure-u-sm-14-24,.pure-u-sm-7-12{width:58.3333%}.pure-u-sm-3-5{width:60%}.pure-u-sm-15-24,.pure-u-sm-5-8{width:62.5%}.pure-u-sm-16-24,.pure-u-sm-2-3{width:66.6667%}.pure-u-sm-17-24{width:70.8333%}.pure-u-sm-18-24,.pure-u-sm-3-4{width:75%}.pure-u-sm-19-24{width:79.1667%}.pure-u-sm-4-5{width:80%}.pure-u-sm-20-24,.pure-u-sm-5-6{width:83.3333%}.pure-u-sm-21-24,.pure-u-sm-7-8{width:87.5%}.pure-u-sm-11-12,.pure-u-sm-22-24{width:91.6667%}.pure-u-sm-23-24{width:95.8333%}.pure-u-sm-1,.pure-u-sm-1-1,.pure-u-sm-24-24,.pure-u-sm-5-5{width:100%}}@media screen and (min-width:48em){.pure-u-md-1,.pure-u-md-1-1,.pure-u-md-1-12,.pure-u-md-1-2,.pure-u-md-1-24,.pure-u-md-1-3,.pure-u-md-1-4,.pure-u-md-1-5,.pure-u-md-1-6,.pure-u-md-1-8,.pure-u-md-10-24,.pure-u-md-11-12,.pure-u-md-11-24,.pure-u-md-12-24,.pure-u-md-13-24,.pure-u-md-14-24,.pure-u-md-15-24,.pure-u-md-16-24,.pure-u-md-17-24,.pure-u-md-18-24,.pure-u-md-19-24,.pure-u-md-2-24,.pure-u-md-2-3,.pure-u-md-2-5,.pure-u-md-20-24,.pure-u-md-21-24,.pure-u-md-22-24,.pure-u-md-23-24,.pure-u-md-24-24,.pure-u-md-3-24,.pure-u-md-3-4,.pure-u-md-3-5,.pure-u-md-3-8,.pure-u-md-4-24,.pure-u-md-4-5,.pure-u-md-5-12,.pure-u-md-5-24,.pure-u-md-5-5,.pure-u-md-5-6,.pure-u-md-5-8,.pure-u-md-6-24,.pure-u-md-7-12,.pure-u-md-7-24,.pure-u-md-7-8,.pure-u-md-8-24,.pure-u-md-9-24{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-u-md-1-24{width:4.1667%}.pure-u-md-1-12,.pure-u-md-2-24{width:8.3333%}.pure-u-md-1-8,.pure-u-md-3-24{width:12.5%}.pure-u-md-1-6,.pure-u-md-4-24{width:16.6667%}.pure-u-md-1-5{width:20%}.pure-u-md-5-24{width:20.8333%}.pure-u-md-1-4,.pure-u-md-6-24{width:25%}.pure-u-md-7-24{width:29.1667%}.pure-u-md-1-3,.pure-u-md-8-24{width:33.3333%}.pure-u-md-3-8,.pure-u-md-9-24{width:37.5%}.pure-u-md-2-5{width:40%}.pure-u-md-10-24,.pure-u-md-5-12{width:41.6667%}.pure-u-md-11-24{width:45.8333%}.pure-u-md-1-2,.pure-u-md-12-24{width:50%}.pure-u-md-13-24{width:54.1667%}.pure-u-md-14-24,.pure-u-md-7-12{width:58.3333%}.pure-u-md-3-5{width:60%}.pure-u-md-15-24,.pure-u-md-5-8{width:62.5%}.pure-u-md-16-24,.pure-u-md-2-3{width:66.6667%}.pure-u-md-17-24{width:70.8333%}.pure-u-md-18-24,.pure-u-md-3-4{width:75%}.pure-u-md-19-24{width:79.1667%}.pure-u-md-4-5{width:80%}.pure-u-md-20-24,.pure-u-md-5-6{width:83.3333%}.pure-u-md-21-24,.pure-u-md-7-8{width:87.5%}.pure-u-md-11-12,.pure-u-md-22-24{width:91.6667%}.pure-u-md-23-24{width:95.8333%}.pure-u-md-1,.pure-u-md-1-1,.pure-u-md-24-24,.pure-u-md-5-5{width:100%}}@media screen and (min-width:64em){.pure-u-lg-1,.pure-u-lg-1-1,.pure-u-lg-1-12,.pure-u-lg-1-2,.pure-u-lg-1-24,.pure-u-lg-1-3,.pure-u-lg-1-4,.pure-u-lg-1-5,.pure-u-lg-1-6,.pure-u-lg-1-8,.pure-u-lg-10-24,.pure-u-lg-11-12,.pure-u-lg-11-24,.pure-u-lg-12-24,.pure-u-lg-13-24,.pure-u-lg-14-24,.pure-u-lg-15-24,.pure-u-lg-16-24,.pure-u-lg-17-24,.pure-u-lg-18-24,.pure-u-lg-19-24,.pure-u-lg-2-24,.pure-u-lg-2-3,.pure-u-lg-2-5,.pure-u-lg-20-24,.pure-u-lg-21-24,.pure-u-lg-22-24,.pure-u-lg-23-24,.pure-u-lg-24-24,.pure-u-lg-3-24,.pure-u-lg-3-4,.pure-u-lg-3-5,.pure-u-lg-3-8,.pure-u-lg-4-24,.pure-u-lg-4-5,.pure-u-lg-5-12,.pure-u-lg-5-24,.pure-u-lg-5-5,.pure-u-lg-5-6,.pure-u-lg-5-8,.pure-u-lg-6-24,.pure-u-lg-7-12,.pure-u-lg-7-24,.pure-u-lg-7-8,.pure-u-lg-8-24,.pure-u-lg-9-24{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-u-lg-1-24{width:4.1667%}.pure-u-lg-1-12,.pure-u-lg-2-24{width:8.3333%}.pure-u-lg-1-8,.pure-u-lg-3-24{width:12.5%}.pure-u-lg-1-6,.pure-u-lg-4-24{width:16.6667%}.pure-u-lg-1-5{width:20%}.pure-u-lg-5-24{width:20.8333%}.pure-u-lg-1-4,.pure-u-lg-6-24{width:25%}.pure-u-lg-7-24{width:29.1667%}.pure-u-lg-1-3,.pure-u-lg-8-24{width:33.3333%}.pure-u-lg-3-8,.pure-u-lg-9-24{width:37.5%}.pure-u-lg-2-5{width:40%}.pure-u-lg-10-24,.pure-u-lg-5-12{width:41.6667%}.pure-u-lg-11-24{width:45.8333%}.pure-u-lg-1-2,.pure-u-lg-12-24{width:50%}.pure-u-lg-13-24{width:54.1667%}.pure-u-lg-14-24,.pure-u-lg-7-12{width:58.3333%}.pure-u-lg-3-5{width:60%}.pure-u-lg-15-24,.pure-u-lg-5-8{width:62.5%}.pure-u-lg-16-24,.pure-u-lg-2-3{width:66.6667%}.pure-u-lg-17-24{width:70.8333%}.pure-u-lg-18-24,.pure-u-lg-3-4{width:75%}.pure-u-lg-19-24{width:79.1667%}.pure-u-lg-4-5{width:80%}.pure-u-lg-20-24,.pure-u-lg-5-6{width:83.3333%}.pure-u-lg-21-24,.pure-u-lg-7-8{width:87.5%}.pure-u-lg-11-12,.pure-u-lg-22-24{width:91.6667%}.pure-u-lg-23-24{width:95.8333%}.pure-u-lg-1,.pure-u-lg-1-1,.pure-u-lg-24-24,.pure-u-lg-5-5{width:100%}}@media screen and (min-width:80em){.pure-u-xl-1,.pure-u-xl-1-1,.pure-u-xl-1-12,.pure-u-xl-1-2,.pure-u-xl-1-24,.pure-u-xl-1-3,.pure-u-xl-1-4,.pure-u-xl-1-5,.pure-u-xl-1-6,.pure-u-xl-1-8,.pure-u-xl-10-24,.pure-u-xl-11-12,.pure-u-xl-11-24,.pure-u-xl-12-24,.pure-u-xl-13-24,.pure-u-xl-14-24,.pure-u-xl-15-24,.pure-u-xl-16-24,.pure-u-xl-17-24,.pure-u-xl-18-24,.pure-u-xl-19-24,.pure-u-xl-2-24,.pure-u-xl-2-3,.pure-u-xl-2-5,.pure-u-xl-20-24,.pure-u-xl-21-24,.pure-u-xl-22-24,.pure-u-xl-23-24,.pure-u-xl-24-24,.pure-u-xl-3-24,.pure-u-xl-3-4,.pure-u-xl-3-5,.pure-u-xl-3-8,.pure-u-xl-4-24,.pure-u-xl-4-5,.pure-u-xl-5-12,.pure-u-xl-5-24,.pure-u-xl-5-5,.pure-u-xl-5-6,.pure-u-xl-5-8,.pure-u-xl-6-24,.pure-u-xl-7-12,.pure-u-xl-7-24,.pure-u-xl-7-8,.pure-u-xl-8-24,.pure-u-xl-9-24{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-u-xl-1-24{width:4.1667%}.pure-u-xl-1-12,.pure-u-xl-2-24{width:8.3333%}.pure-u-xl-1-8,.pure-u-xl-3-24{width:12.5%}.pure-u-xl-1-6,.pure-u-xl-4-24{width:16.6667%}.pure-u-xl-1-5{width:20%}.pure-u-xl-5-24{width:20.8333%}.pure-u-xl-1-4,.pure-u-xl-6-24{width:25%}.pure-u-xl-7-24{width:29.1667%}.pure-u-xl-1-3,.pure-u-xl-8-24{width:33.3333%}.pure-u-xl-3-8,.pure-u-xl-9-24{width:37.5%}.pure-u-xl-2-5{width:40%}.pure-u-xl-10-24,.pure-u-xl-5-12{width:41.6667%}.pure-u-xl-11-24{width:45.8333%}.pure-u-xl-1-2,.pure-u-xl-12-24{width:50%}.pure-u-xl-13-24{width:54.1667%}.pure-u-xl-14-24,.pure-u-xl-7-12{width:58.3333%}.pure-u-xl-3-5{width:60%}.pure-u-xl-15-24,.pure-u-xl-5-8{width:62.5%}.pure-u-xl-16-24,.pure-u-xl-2-3{width:66.6667%}.pure-u-xl-17-24{width:70.8333%}.pure-u-xl-18-24,.pure-u-xl-3-4{width:75%}.pure-u-xl-19-24{width:79.1667%}.pure-u-xl-4-5{width:80%}.pure-u-xl-20-24,.pure-u-xl-5-6{width:83.3333%}.pure-u-xl-21-24,.pure-u-xl-7-8{width:87.5%}.pure-u-xl-11-12,.pure-u-xl-22-24{width:91.6667%}.pure-u-xl-23-24{width:95.8333%}.pure-u-xl-1,.pure-u-xl-1-1,.pure-u-xl-24-24,.pure-u-xl-5-5{width:100%}}
```

`docs/css/pure/pure-min.css`:

```css
/*!
Pure v2.0.3
Copyright 2013 Yahoo!
Licensed under the BSD License.
https://github.com/pure-css/pure/blob/master/LICENSE.md
*/
/*!
normalize.css v | MIT License | git.io/normalize
Copyright (c) Nicolas Gallagher and Jonathan Neal
*/
/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */
html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}html{font-family:sans-serif}.hidden,[hidden]{display:none!important}.pure-img{max-width:100%;height:auto;display:block}.pure-g{letter-spacing:-.31em;text-rendering:optimizespeed;font-family:FreeSans,Arimo,"Droid Sans",Helvetica,Arial,sans-serif;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-line-pack:start;align-content:flex-start}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){table .pure-g{display:block}}.opera-only :-o-prefocus,.pure-g{word-spacing:-.43em}.pure-u{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-g [class*=pure-u]{font-family:sans-serif}.pure-u-1,.pure-u-1-1,.pure-u-1-12,.pure-u-1-2,.pure-u-1-24,.pure-u-1-3,.pure-u-1-4,.pure-u-1-5,.pure-u-1-6,.pure-u-1-8,.pure-u-10-24,.pure-u-11-12,.pure-u-11-24,.pure-u-12-24,.pure-u-13-24,.pure-u-14-24,.pure-u-15-24,.pure-u-16-24,.pure-u-17-24,.pure-u-18-24,.pure-u-19-24,.pure-u-2-24,.pure-u-2-3,.pure-u-2-5,.pure-u-20-24,.pure-u-21-24,.pure-u-22-24,.pure-u-23-24,.pure-u-24-24,.pure-u-3-24,.pure-u-3-4,.pure-u-3-5,.pure-u-3-8,.pure-u-4-24,.pure-u-4-5,.pure-u-5-12,.pure-u-5-24,.pure-u-5-5,.pure-u-5-6,.pure-u-5-8,.pure-u-6-24,.pure-u-7-12,.pure-u-7-24,.pure-u-7-8,.pure-u-8-24,.pure-u-9-24{display:inline-block;letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-u-1-24{width:4.1667%}.pure-u-1-12,.pure-u-2-24{width:8.3333%}.pure-u-1-8,.pure-u-3-24{width:12.5%}.pure-u-1-6,.pure-u-4-24{width:16.6667%}.pure-u-1-5{width:20%}.pure-u-5-24{width:20.8333%}.pure-u-1-4,.pure-u-6-24{width:25%}.pure-u-7-24{width:29.1667%}.pure-u-1-3,.pure-u-8-24{width:33.3333%}.pure-u-3-8,.pure-u-9-24{width:37.5%}.pure-u-2-5{width:40%}.pure-u-10-24,.pure-u-5-12{width:41.6667%}.pure-u-11-24{width:45.8333%}.pure-u-1-2,.pure-u-12-24{width:50%}.pure-u-13-24{width:54.1667%}.pure-u-14-24,.pure-u-7-12{width:58.3333%}.pure-u-3-5{width:60%}.pure-u-15-24,.pure-u-5-8{width:62.5%}.pure-u-16-24,.pure-u-2-3{width:66.6667%}.pure-u-17-24{width:70.8333%}.pure-u-18-24,.pure-u-3-4{width:75%}.pure-u-19-24{width:79.1667%}.pure-u-4-5{width:80%}.pure-u-20-24,.pure-u-5-6{width:83.3333%}.pure-u-21-24,.pure-u-7-8{width:87.5%}.pure-u-11-12,.pure-u-22-24{width:91.6667%}.pure-u-23-24{width:95.8333%}.pure-u-1,.pure-u-1-1,.pure-u-24-24,.pure-u-5-5{width:100%}.pure-button{display:inline-block;line-height:normal;white-space:nowrap;vertical-align:middle;text-align:center;cursor:pointer;-webkit-user-drag:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-sizing:border-box;box-sizing:border-box}.pure-button::-moz-focus-inner{padding:0;border:0}.pure-button-group{letter-spacing:-.31em;text-rendering:optimizespeed}.opera-only :-o-prefocus,.pure-button-group{word-spacing:-.43em}.pure-button-group .pure-button{letter-spacing:normal;word-spacing:normal;vertical-align:top;text-rendering:auto}.pure-button{font-family:inherit;font-size:100%;padding:.5em 1em;color:rgba(0,0,0,.8);border:none transparent;background-color:#e6e6e6;text-decoration:none;border-radius:2px}.pure-button-hover,.pure-button:focus,.pure-button:hover{background-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(40%,rgba(0,0,0,.05)),to(rgba(0,0,0,.1)));background-image:linear-gradient(transparent,rgba(0,0,0,.05) 40%,rgba(0,0,0,.1))}.pure-button:focus{outline:0}.pure-button-active,.pure-button:active{-webkit-box-shadow:0 0 0 1px rgba(0,0,0,.15) inset,0 0 6px rgba(0,0,0,.2) inset;box-shadow:0 0 0 1px rgba(0,0,0,.15) inset,0 0 6px rgba(0,0,0,.2) inset;border-color:#000}.pure-button-disabled,.pure-button-disabled:active,.pure-button-disabled:focus,.pure-button-disabled:hover,.pure-button[disabled]{border:none;background-image:none;opacity:.4;cursor:not-allowed;-webkit-box-shadow:none;box-shadow:none;pointer-events:none}.pure-button-hidden{display:none}.pure-button-primary,.pure-button-selected,a.pure-button-primary,a.pure-button-selected{background-color:#0078e7;color:#fff}.pure-button-group .pure-button{margin:0;border-radius:0;border-right:1px solid rgba(0,0,0,.2)}.pure-button-group .pure-button:first-child{border-top-left-radius:2px;border-bottom-left-radius:2px}.pure-button-group .pure-button:last-child{border-top-right-radius:2px;border-bottom-right-radius:2px;border-right:none}.pure-form input[type=color],.pure-form input[type=date],.pure-form input[type=datetime-local],.pure-form input[type=datetime],.pure-form input[type=email],.pure-form input[type=month],.pure-form input[type=number],.pure-form input[type=password],.pure-form input[type=search],.pure-form input[type=tel],.pure-form input[type=text],.pure-form input[type=time],.pure-form input[type=url],.pure-form input[type=week],.pure-form select,.pure-form textarea{padding:.5em .6em;display:inline-block;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 3px #ddd;box-shadow:inset 0 1px 3px #ddd;border-radius:4px;vertical-align:middle;-webkit-box-sizing:border-box;box-sizing:border-box}.pure-form input:not([type]){padding:.5em .6em;display:inline-block;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 3px #ddd;box-shadow:inset 0 1px 3px #ddd;border-radius:4px;-webkit-box-sizing:border-box;box-sizing:border-box}.pure-form input[type=color]{padding:.2em .5em}.pure-form input[type=color]:focus,.pure-form input[type=date]:focus,.pure-form input[type=datetime-local]:focus,.pure-form input[type=datetime]:focus,.pure-form input[type=email]:focus,.pure-form input[type=month]:focus,.pure-form input[type=number]:focus,.pure-form input[type=password]:focus,.pure-form input[type=search]:focus,.pure-form input[type=tel]:focus,.pure-form input[type=text]:focus,.pure-form input[type=time]:focus,.pure-form input[type=url]:focus,.pure-form input[type=week]:focus,.pure-form select:focus,.pure-form textarea:focus{outline:0;border-color:#129fea}.pure-form input:not([type]):focus{outline:0;border-color:#129fea}.pure-form input[type=checkbox]:focus,.pure-form input[type=file]:focus,.pure-form input[type=radio]:focus{outline:thin solid #129fea;outline:1px auto #129fea}.pure-form .pure-checkbox,.pure-form .pure-radio{margin:.5em 0;display:block}.pure-form input[type=color][disabled],.pure-form input[type=date][disabled],.pure-form input[type=datetime-local][disabled],.pure-form input[type=datetime][disabled],.pure-form input[type=email][disabled],.pure-form input[type=month][disabled],.pure-form input[type=number][disabled],.pure-form input[type=password][disabled],.pure-form input[type=search][disabled],.pure-form input[type=tel][disabled],.pure-form input[type=text][disabled],.pure-form input[type=time][disabled],.pure-form input[type=url][disabled],.pure-form input[type=week][disabled],.pure-form select[disabled],.pure-form textarea[disabled]{cursor:not-allowed;background-color:#eaeded;color:#cad2d3}.pure-form input:not([type])[disabled]{cursor:not-allowed;background-color:#eaeded;color:#cad2d3}.pure-form input[readonly],.pure-form select[readonly],.pure-form textarea[readonly]{background-color:#eee;color:#777;border-color:#ccc}.pure-form input:focus:invalid,.pure-form select:focus:invalid,.pure-form textarea:focus:invalid{color:#b94a48;border-color:#e9322d}.pure-form input[type=checkbox]:focus:invalid:focus,.pure-form input[type=file]:focus:invalid:focus,.pure-form input[type=radio]:focus:invalid:focus{outline-color:#e9322d}.pure-form select{height:2.25em;border:1px solid #ccc;background-color:#fff}.pure-form select[multiple]{height:auto}.pure-form label{margin:.5em 0 .2em}.pure-form fieldset{margin:0;padding:.35em 0 .75em;border:0}.pure-form legend{display:block;width:100%;padding:.3em 0;margin-bottom:.3em;color:#333;border-bottom:1px solid #e5e5e5}.pure-form-stacked input[type=color],.pure-form-stacked input[type=date],.pure-form-stacked input[type=datetime-local],.pure-form-stacked input[type=datetime],.pure-form-stacked input[type=email],.pure-form-stacked input[type=file],.pure-form-stacked input[type=month],.pure-form-stacked input[type=number],.pure-form-stacked input[type=password],.pure-form-stacked input[type=search],.pure-form-stacked input[type=tel],.pure-form-stacked input[type=text],.pure-form-stacked input[type=time],.pure-form-stacked input[type=url],.pure-form-stacked input[type=week],.pure-form-stacked label,.pure-form-stacked select,.pure-form-stacked textarea{display:block;margin:.25em 0}.pure-form-stacked input:not([type]){display:block;margin:.25em 0}.pure-form-aligned input,.pure-form-aligned select,.pure-form-aligned textarea,.pure-form-message-inline{display:inline-block;vertical-align:middle}.pure-form-aligned textarea{vertical-align:top}.pure-form-aligned .pure-control-group{margin-bottom:.5em}.pure-form-aligned .pure-control-group label{text-align:right;display:inline-block;vertical-align:middle;width:10em;margin:0 1em 0 0}.pure-form-aligned .pure-controls{margin:1.5em 0 0 11em}.pure-form .pure-input-rounded,.pure-form input.pure-input-rounded{border-radius:2em;padding:.5em 1em}.pure-form .pure-group fieldset{margin-bottom:10px}.pure-form .pure-group input,.pure-form .pure-group textarea{display:block;padding:10px;margin:0 0 -1px;border-radius:0;position:relative;top:-1px}.pure-form .pure-group input:focus,.pure-form .pure-group textarea:focus{z-index:3}.pure-form .pure-group input:first-child,.pure-form .pure-group textarea:first-child{top:1px;border-radius:4px 4px 0 0;margin:0}.pure-form .pure-group input:first-child:last-child,.pure-form .pure-group textarea:first-child:last-child{top:1px;border-radius:4px;margin:0}.pure-form .pure-group input:last-child,.pure-form .pure-group textarea:last-child{top:-2px;border-radius:0 0 4px 4px;margin:0}.pure-form .pure-group button{margin:.35em 0}.pure-form .pure-input-1{width:100%}.pure-form .pure-input-3-4{width:75%}.pure-form .pure-input-2-3{width:66%}.pure-form .pure-input-1-2{width:50%}.pure-form .pure-input-1-3{width:33%}.pure-form .pure-input-1-4{width:25%}.pure-form-message-inline{display:inline-block;padding-left:.3em;color:#666;vertical-align:middle;font-size:.875em}.pure-form-message{display:block;color:#666;font-size:.875em}@media only screen and (max-width :480px){.pure-form button[type=submit]{margin:.7em 0 0}.pure-form input:not([type]),.pure-form input[type=color],.pure-form input[type=date],.pure-form input[type=datetime-local],.pure-form input[type=datetime],.pure-form input[type=email],.pure-form input[type=month],.pure-form input[type=number],.pure-form input[type=password],.pure-form input[type=search],.pure-form input[type=tel],.pure-form input[type=text],.pure-form input[type=time],.pure-form input[type=url],.pure-form input[type=week],.pure-form label{margin-bottom:.3em;display:block}.pure-group input:not([type]),.pure-group input[type=color],.pure-group input[type=date],.pure-group input[type=datetime-local],.pure-group input[type=datetime],.pure-group input[type=email],.pure-group input[type=month],.pure-group input[type=number],.pure-group input[type=password],.pure-group input[type=search],.pure-group input[type=tel],.pure-group input[type=text],.pure-group input[type=time],.pure-group input[type=url],.pure-group input[type=week]{margin-bottom:0}.pure-form-aligned .pure-control-group label{margin-bottom:.3em;text-align:left;display:block;width:100%}.pure-form-aligned .pure-controls{margin:1.5em 0 0 0}.pure-form-message,.pure-form-message-inline{display:block;font-size:.75em;padding:.2em 0 .8em}}.pure-menu{-webkit-box-sizing:border-box;box-sizing:border-box}.pure-menu-fixed{position:fixed;left:0;top:0;z-index:3}.pure-menu-item,.pure-menu-list{position:relative}.pure-menu-list{list-style:none;margin:0;padding:0}.pure-menu-item{padding:0;margin:0;height:100%}.pure-menu-heading,.pure-menu-link{display:block;text-decoration:none;white-space:nowrap}.pure-menu-horizontal{width:100%;white-space:nowrap}.pure-menu-horizontal .pure-menu-list{display:inline-block}.pure-menu-horizontal .pure-menu-heading,.pure-menu-horizontal .pure-menu-item,.pure-menu-horizontal .pure-menu-separator{display:inline-block;vertical-align:middle}.pure-menu-item .pure-menu-item{display:block}.pure-menu-children{display:none;position:absolute;left:100%;top:0;margin:0;padding:0;z-index:3}.pure-menu-horizontal .pure-menu-children{left:0;top:auto;width:inherit}.pure-menu-active>.pure-menu-children,.pure-menu-allow-hover:hover>.pure-menu-children{display:block;position:absolute}.pure-menu-has-children>.pure-menu-link:after{padding-left:.5em;content:"\25B8";font-size:small}.pure-menu-horizontal .pure-menu-has-children>.pure-menu-link:after{content:"\25BE"}.pure-menu-scrollable{overflow-y:scroll;overflow-x:hidden}.pure-menu-scrollable .pure-menu-list{display:block}.pure-menu-horizontal.pure-menu-scrollable .pure-menu-list{display:inline-block}.pure-menu-horizontal.pure-menu-scrollable{white-space:nowrap;overflow-y:hidden;overflow-x:auto;padding:.5em 0}.pure-menu-horizontal .pure-menu-children .pure-menu-separator,.pure-menu-separator{background-color:#ccc;height:1px;margin:.3em 0}.pure-menu-horizontal .pure-menu-separator{width:1px;height:1.3em;margin:0 .3em}.pure-menu-horizontal .pure-menu-children .pure-menu-separator{display:block;width:auto}.pure-menu-heading{text-transform:uppercase;color:#565d64}.pure-menu-link{color:#777}.pure-menu-children{background-color:#fff}.pure-menu-disabled,.pure-menu-heading,.pure-menu-link{padding:.5em 1em}.pure-menu-disabled{opacity:.5}.pure-menu-disabled .pure-menu-link:hover{background-color:transparent}.pure-menu-active>.pure-menu-link,.pure-menu-link:focus,.pure-menu-link:hover{background-color:#eee}.pure-menu-selected>.pure-menu-link,.pure-menu-selected>.pure-menu-link:visited{color:#000}.pure-table{border-collapse:collapse;border-spacing:0;empty-cells:show;border:1px solid #cbcbcb}.pure-table caption{color:#000;font:italic 85%/1 arial,sans-serif;padding:1em 0;text-align:center}.pure-table td,.pure-table th{border-left:1px solid #cbcbcb;border-width:0 0 0 1px;font-size:inherit;margin:0;overflow:visible;padding:.5em 1em}.pure-table thead{background-color:#e0e0e0;color:#000;text-align:left;vertical-align:bottom}.pure-table td{background-color:transparent}.pure-table-odd td{background-color:#f2f2f2}.pure-table-striped tr:nth-child(2n-1) td{background-color:#f2f2f2}.pure-table-bordered td{border-bottom:1px solid #cbcbcb}.pure-table-bordered tbody>tr:last-child>td{border-bottom-width:0}.pure-table-horizontal td,.pure-table-horizontal th{border-width:0 0 1px 0;border-bottom:1px solid #cbcbcb}.pure-table-horizontal tbody>tr:last-child>td{border-bottom-width:0}
```

`docs/css/scroll.css`:

```css
/* Chrome scrollbars */
*::-webkit-scrollbar {
    width: 6px;
}
*::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgb(28, 28, 28);
}
*::-webkit-scrollbar-thumb {
    background-color: rgb(66, 66, 66);
}

/* Firefox scrollbars */
#content {
    scrollbar-color: rgb(66, 66, 66) rgb(28, 28, 28);
    scrollbar-width: thin;
}
#sidebar {
    scrollbar-color: rgb(66, 66, 66) rgb(28, 28, 28);
    scrollbar-width: thin;
}
```

`docs/css/table.css`:

```css
.pure-table {
    border: 1px solid rgb(56, 56, 56);
}
.pure-table caption {
    color: #000;
}
.pure-table td,
.pure-table th {
    border-left: 1px solid rgb(56, 56, 56);
}
.pure-table thead {
    background-color: rgb(150, 150, 150);
    color: black;
    text-align: left;
    vertical-align: bottom;
}
.pure-table tr:nth-child(2n-1) td {
    background-color: rgba(0, 0, 0, 0.1);
}
.pure-table-horizontal td,
.pure-table-horizontal th {
    border-width: 0 0 1px 0;
    border-bottom: 1px solid rgb(56, 56, 56);
}
.example-small {
    width: auto;
}
.code-table {
    margin-top: 5px;
}
.code-table td {
    font-family: monospace;
}
```

`docs/doc-advanced-plugin.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="plugin-api">Plugin API</h1>
        <h2 id="installing-plugins">Installing plugins</h2>
        <p>To install a plugin for Recaf, drop it into the <em>&quot;plugins&quot;</em> directory inside Recaf&#39;s settings directory. When you launch Recaf check to see if the plugin has been loaded by looking for it in the plugin manager <em>(&quot;Plugins &gt; Manage plugins&quot;)</em>. If the plugin is missing, check the log output for errors and contact the plugin author with a bug report.</p>
        <h2 id="current-plugins">Current plugins</h2>
        <p>This section is currently incomplete. For now you can find all the current plugins hosted in the <a href="https://discord.gg/Bya5HaA">Recaf Discord server</a>.</p>
        <h2 id="developing-plugins">Developing plugins</h2>
        <p>Recaf comes with a plugin system. You can create your own easily by setting up a workspace using this template project: <a href="https://github.com/Col-E/Recaf-plugin-workspace">Recaf-plugin-workspace</a>
        The plugin api interfaces are located in <code>me.coley.recaf.plugin.api</code> package. Your plugin must implement one of the following interfaces:</p>
        <p><strong>BasePlugin</strong></p>
        <ul>
        <li>No unique behavior.</li>
        </ul>
        <p><strong>CommandPlugin</strong></p>
        <ul>
            <li>Allows adding new commands to Recaf’s command-line mode.</li>
            <li>Commands are generated using <a href="https://picocli.info/">picocli</a> annotations. Simply annotate your class as described on <a href="https://picocli.info/">picocli’s website</a> and the command will be automatically recognized.</li>
        </ul>
        <p><strong>ConfigurablePlugin</strong></p>
        <ul>
            <li>Allows plugins to keep persistent config values. Each plugin is granted its own tab in the config window.<ul>
            <li>Annotate config fields with <code>@Conf(value=&quot;Title&quot;, noTranslate=true)</code></li>
            <li>Specify the config tab name by implementing getConfigTabTitle()</li>
            <li>Optional:
            <ul>
                <li>Specify custom serialization/deserialization for fields using <code>supported(Class)</code>, <code>loadType(FieldWrapper, Class, JsonValue)</code>, <code>saveType(FieldWrapper, Object, JsonObject)</code></li>
                <li>Specify custom UI components for displaying fields using <code>addFieldEditors(Map)</code>
                <ul>
                    <li>By default, any <code>boolean</code>, <code>enum</code>, or <code>Binding</code> <em>(Recaf keybind type)</em> field will automatically have editor controls specified.</li>
                </ul>
                </li>
            </ul>
            </li>
            </ul>
            </li>
        </ul>
        <p><strong>ContextMenuInjectorPlugin</strong></p>
        <ul>
            <li>Allows modifying any of the context-menus shown in Recaf.</li>
        </ul>
        <p><strong>EntryLoaderProviderPlugin</strong></p>
        <ul>
            <li>Allows the usage of custom archive entry handlers.
            <ul>
                <li>Entry loaders are fed the raw <code>byte[]</code> of all files in an archive.</li>
            </ul>
            </li>
        </ul>
        <p><strong>ExportInterceptorPlugin</strong></p>
        <ul>
            <li>Allows the contents of exported files to be modified before being written to the destination.</li>
        </ul>
        <p><strong>KeybindProviderPlugin</strong></p>
        <ul>
            <li>Allows plugins to specify custom keybinds globally, for class-views, and for file-views.</li>
        </ul>
        <p><strong>LoadInterceptorPlugin</strong></p>
        <ul>
            <li>Allows the contents of imported files to be modified before being loaded into a Recaf resource.
            <ul>
                <li>This is different from the <code>EntryLoaderProviderPlugin</code> since there is no per-resource context of loaded items.</li>
            </ul>
            </li>
        </ul>
        <p><strong>MenuProviderPlugin</strong></p>
        <ul>
            <li>Allows the plugin to create a custom menu item to be shown under the plugins menu.</li>
        </ul>
        <p><strong>StartupPlugin</strong></p>
        <ul>
            <li>Allows the plugin to notified when Recaf starts up.
            <ul>
                <li>The plugin is also given access to the controller instance.</li>
            </ul>
            </li>
        </ul>
        <p><strong>WorkspacePlugin</strong></p>
        <ul>
            <li>Allows the plugin to notified when Recaf opens new workspaces and closes old ones.</li>
        </ul>
        <h2 id="compiling-the-custom-plugin">Compiling the custom plugin</h2>
        <p>After creating your plugin compile it using <code>mvn clean package</code>. This will generate a jar file in the target directory. Copy this into Recaf’s plugin directory.</p>
        <center><img src="screenshots/template-plugin.png"></center>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-advanced-scripting.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="scripting">Scripting</h1>
        <p>Recaf can be used as a command line application. Running it with the argument <code>--cli</code> will enable an interactive mode. Here is a demonstration:</p>
        <center><video controls><source src="screenshots/cli-demo.mp4" type="video/mp4"></video></center>
        <p>Using the <code>help</code> command will show the current list of all commands. Each should have automatic tab completion for all arguments of known data-types.</p>
        <p>In order to <em>&quot;script&quot;</em> in Recaf, you can write these commands line-by-line to a text file, then run Recaf with the command line argument <code>--script &lt;file&gt;</code>. This will execute each line of the file then terminate the program. Here is an outline of how to use command scripting to process a jar file with some mappings file:</p>
        <pre>
<span class="keyword">loadworkspace</span> &lt;file-name&gt;
<span class="keyword">remap</span> &lt;mapping-type&gt; &lt;other-options&gt; &lt;mapping-file&gt;
<span class="keyword">export</span> &lt;output-file&gt;</pre>
        <p>And here it is filled in with an example:</p>
        <pre>
<span class="keyword">loadworkspace</span> 20w21a.jar
<span class="keyword">remap</span> PROGUARD client.txt
<span class="keyword">export</span> 20w21a-clean.jar</pre>
        <blockquote>
        <p><strong>Note</strong>: The plugin api allows users to register their own custom commands. This allows you to create your own commands using any utility available in the Recaf source code.</p>
        </blockquote>

        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-advanced-theme.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="themes">Themes</h1>
        <p>Recaf comes with 2 themes; a flat dark style and the default JavaFx modena style. Each theme is split into two parts:</p>
        <ul>
        <li><strong>Window</strong>: Standard JavaFX style</li>
        <li><strong>Text</strong>: Style specific to code-editing</li>
        </ul>
        <h2 id="adding-custom-themes">Adding custom themes</h2>
        <p>To add your own themes navigate to the Recaf config directory <em>(See: <a href="doc-intro-config.html">Config</a>)</em>. In this directory are there is a <em>&quot;style&quot;</em> sub-directory. In the style directory you can add window and text styles by creating <code>ui-THEME_NAME.css</code> and <code>text-THEME_NAME.css</code> respectively. You may want to copy an existing theme from the Recaf source code as a basis to work off of.</p>
        <h2 id="using-the-theme-editor">Using the theme editor</h2>
        <p>The theme editor is a heavy work-in-progress. To open it, install the theme plugin <em>(Released in the <a href="https://discord.gg/Bya5HaA">Recaf Discord server</a>)</em> then launch Recaf. Under the plugins menu you will find a menu item for the theme editor, which will open the editor window. When working in this editor the theme file <code>ui-custom.css</code> is written to after each modification. Additionally, the UI styles are reloaded after modifications so that it can be reloaded dynamically. To see the changes live, make sure you set the window theme to <em>&quot;Custom&quot;</em>.</p>
        <blockquote>
        <p><strong>See also</strong>: <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">JavaFX CSS Reference Guide</a></p>
        </blockquote>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-assembler-errors.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="assembler-modifying-fields-and-methods">Assembler: Understanding assembler errors</h1>
        <p>Lets take a look at a basic method. First as source code, then with the assembler.</p>
<pre><span class="line"></span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
<span class="line"></span>    String line;
<span class="line"></span>    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);
<span class="line"></span>    <span class="keyword">while</span> ((line = scanner.nextLine()).length() &gt; <span class="const">0</span>) {
<span class="line"></span>        System.out.println(<span class="string">&quot;COMPUTED: &quot;</span> + Calculator.evaluate(line));
<span class="line"></span>    }
<span class="line"></span>}
</pre>
        <p>We have two variables here. The main method’s arguments <span class="code">array</span> is unused. Then we have nextLine which is simply set to whatever the user types in. Each time the user inputs a non-empty string we evaluate the text in <span class="code">nextLine</span> then print it out with the prefix <span class="code">"COMPUTED: "</span>. Simple enough, now lets take a look at it in the assembler. I’ve added some comments to better illustrate what portions of the bytecode relate to parts of the source code.</p>
<pre><span class="line"></span><span class="keyword">DEFINE</span> <span class="keyword">PUBLIC</span> <span class="keyword">STATIC</span> main([Ljava/lang/String; args)V
<span class="line"></span><span class="comment-line">// Scanner scanner = new Scanner(System.in)</span>
<span class="line"></span>A:
<span class="line"></span><span class="keyword">NEW</span> java/util/Scanner
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="keyword">GETSTATIC</span> java/lang/System.in Ljava/io/InputStream;
<span class="line"></span><span class="keyword">INVOKESPECIAL</span> java/util/Scanner.&lt;init&gt;(Ljava/io/InputStream;)V
<span class="line"></span><span class="keyword">ASTORE</span> scanner
<span class="line"></span><span class="comment-line">// line = scanner.nextLine()</span>
<span class="line"></span>B:
<span class="line"></span><span class="keyword">ALOAD</span> scanner
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/util/Scanner.nextLine()Ljava/lang/String;
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="keyword">ASTORE</span> line
<span class="line"></span><span class="comment-line">// (line).length() &gt; 0    (break loop if line &lt;= 0)</span>
<span class="line"></span>C:
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/String.length()I
<span class="line"></span><span class="keyword">IFLE</span> E
<span class="line"></span><span class="comment-line">// System.out.println(&quot;COMPUTED: &quot; + Calculator.evaluate(line))</span>
<span class="line"></span>D:
<span class="line"></span><span class="keyword">GETSTATIC</span> java/lang/System.out Ljava/io/PrintStream;
<span class="line"></span><span class="keyword">NEW</span> java/lang/StringBuilder
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="keyword">INVOKESPECIAL</span> java/lang/StringBuilder.&lt;init&gt;()V
<span class="line"></span><span class="keyword">LDC</span> <span class="string">&quot;COMPUTED: &quot;</span>
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;
<span class="line"></span><span class="keyword">ALOAD</span> line
<span class="line"></span><span class="keyword">INVOKESTATIC</span> calc/Calculator.evaluate(Ljava/lang/String;)D
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.append(D)Ljava/lang/StringBuilder;
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.toString()Ljava/lang/String;
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/io/PrintStream.println(Ljava/lang/String;)V
<span class="line"></span><span class="keyword">GOTO</span> B
<span class="line"></span>E:
<span class="line"></span><span class="keyword">RETURN</span>
</pre>
        <p>Perfectly valid bytecode here. Now Lets introduce different errors and see what messages we get back.</p>
        
        
        <h2 id="cannot-pop-operand-off-an-empty-stack">Cannot pop operand off an empty stack</h2>
        <p>Here is a modification to the above code around label <span class="code">C</span> that removes the calling context from the call to <span class="code">line.length()</span></p>
        <p>This will result in an attempt to pop the calling context off the stack, which is empty, causing the error.</p>
<pre><span class="line"></span>C:
<span class="line"></span><span class="comment-line">// String is on the stack</span>
<span class="line"></span><span class="keyword">POP</span>
<span class="line"></span><span class="comment-line">// The String has been removed frrom the stack, so now the stack is empty</span>
<span class="line"></span><span class="error">INVOKEVIRTUAL java/lang/String.length()I</span>
<span class="line"></span><span class="keyword">IFLE</span> E
</pre>
        
        <h2 id="copying-an-uninitialized-value-should-not-occur">Copying an uninitialized value should not occur</h2>
        <p>Here is a modification to the above code that introduces a typo when using the variable <span class="code">line</span>. Instead it will be referenced as <span class="code">loon</span>. This is a more tricky case to detect at times since:</p>
        <ul>
            <li>Finding typos is hard because you never intend to spell things wrong in the first place.</li>
            <li>Depending on where the typo is, the error <i>may not show up</i> but instead the logic will not represent what you intended to write.</li>
        </ul>
        <p>This will result in an attempt to resolve two separate variables since they do not share the same name, causing the error.</p>
<pre><span class="line"></span>B:
<span class="line"></span><span class="keyword">ALOAD</span> scanner
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/util/Scanner.nextLine()Ljava/lang/String;
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="comment-line">// Here the variable is refered to as "line"</span>
<span class="line"></span><span class="keyword">ASTORE</span> line
<span class="line"></span>C:
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/String.length()I
<span class="line"></span><span class="keyword">IFLE</span> E
<span class="line"></span>D:
<span class="line"></span><span class="keyword">GETSTATIC</span> java/lang/System.out Ljava/io/PrintStream;
<span class="line"></span><span class="keyword">NEW</span> java/lang/StringBuilder
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="keyword">INVOKESPECIAL</span> java/lang/StringBuilder.&lt;init&gt;()V
<span class="line"></span><span class="keyword">LDC</span> <span class="string">&quot;COMPUTED: &quot;</span>
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;
<span class="line"></span><span class="comment-line">// Here the variable is refered to as "loon" which has never been specified before</span>
<span class="line"></span><span class="comment-line">// Since the variable has never had its value set, this code is illegal</span>
<span class="line"></span><span class="comment-line">// (NULL is not a default for object-type variables, but 0 is for primitives)</span>
<span class="line"></span><span class="keyword">ALOAD</span> loon
<span class="line"></span><span class="error">INVOKESTATIC calc/Calculator.evaluate(Ljava/lang/String;)D</span>
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.append(D)Ljava/lang/StringBuilder;
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/lang/StringBuilder.toString()Ljava/lang/String;
<span class="line"></span><span class="keyword">INVOKEVIRTUAL</span> java/io/PrintStream.println(Ljava/lang/String;)V
<span class="line"></span><span class="keyword">GOTO</span> B
<span class="line"></span>E:
<span class="line"></span><span class="keyword">RETURN</span>
</pre>
        <p>The solution here is to double check for typos.</p>
        <p class="faint">However there are cases with heavy obfuscation where Recaf may get confused. Please open bug reports with examples of this when they occur.</p>
        
        <!-- TODO: Update this when phantom references are supported -->
        <h2 id="argument-type-was-uninitialized-expected-something-else">Argument type was &quot;Apple&quot; expected &quot;Orange&quot;</h2>
        <p>Here is a modification to the above code that replaces <span class="code">java/util/Scanner</span> with <span class="code">example/ExtendedScanner</span>. In our example let us assume that <span class="code">example/ExtendedScanner</span> is a class that extends <span class="code">java/util/Scanner</span>. Let us also assume that we do not have <span class="code">example/ExtendedScanner</span> loaded into Recaf in any of the workspace's resources.</p>
        <p>This will result in an attempt to resolve the type hierarchy between <span class="code">java/util/Scanner</span> and <span class="code">example/ExtendedScanner</span>. Since we do not have <span class="code">example/ExtendedScanner</span> loaded into Recaf, we are unable to prove that it extends <span class="code">java/util/Scanner</span>. Thus the assembler will default to assuming the class extends <span class="code">java/lang/Object</span>. Calling any non-object method will result in a type conflict, causing the error.</p>
<pre><span class="line"></span>A:
<span class="line"></span><span class="keyword">NEW</span> example/ExtendedScanner
<span class="line"></span><span class="keyword">DUP</span>
<span class="line"></span><span class="keyword">GETSTATIC</span> java/lang/System.in Ljava/io/InputStream;
<span class="line"></span><span class="keyword">INVOKESPECIAL</span> example/ExtendedScanner.&lt;init&gt;(Ljava/io/InputStream;)V
<span class="line"></span><span class="keyword">ASTORE</span> scanner
<span class="line"></span><span class="comment-line">// ExtendedScanner extends Scanner... We as people know this, but Recaf does not.</span>
<span class="line"></span>B:
<span class="line"></span><span class="keyword">ALOAD</span> scanner
<span class="line"></span><span class="error">INVOKEVIRTUAL java/util/Scanner.nextLine()Ljava/lang/String;</span>
</pre>
        <p>The solution here is to add the code that contains <span class="code">example/ExtendedScanner</span> to the workspace.</p>
        
        <h2 id="cannot-call-method-on-null-reference">Cannot call method on null reference</h2>
        <p>Here is a modification to the above code that replaces the instantiation of the <span class="code">java/util/Scanner</span> with a single <span class="code">null</span>.</p>
        <p>This will cause the method call on the scanner object to call on a provable <span class="code">null</span> value, causing the error.</p>
<pre><span class="line"></span>A:
<span class="line"></span><span class="keyword">ACONST_NULL</span>
<span class="line"></span><span class="keyword">ASTORE</span> scanner
<span class="line"></span><span class="comment-line">// This will effectively translate to:</span>
<span class="line"></span><span class="comment-line">// null.nextLine()</span>
<span class="line"></span>B:
<span class="line"></span><span class="keyword">ALOAD</span> scanner
<span class="line"></span><span class="error">INVOKEVIRTUAL java/util/Scanner.nextLine()Ljava/lang/String;</span>
</pre>
        <p>The solution here is to make sure you track where <span class="code">null</span> is pushed onto the stack via <span class="code">ACONST_NULL</span>.</p>
        
        
        <h2 id="expected-type-mismatch">Expected type: Lcom/example/Something;</h2>
        <p>This can occur in a few situations, but the cause is the same. The usage of some type indicates it should be the given type shown in the error, but whatever was present on the stack was a different type.</p>
        
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-assembler.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="assembler-modifying-fields-and-methods">Assembler: Modifying fields and methods</h1>
        <h2 id="how-to-access">How do you access the assembler?</h2>
        <center><video controls><source src="screenshots/assembler-access.mp4" type="video/mp4"></video></center>
        <p>When you right click a field or method definition in Recaf selecting <em>&quot;Edit with assembler&quot;</em> will open the assembler window. Fields and methods both use the same assembler system, but each use a different syntax for defining field or method specific properties.</p>
        <h2 id="method-assembler">Method Assembler</h2>
        <center><img src="screenshots/assembler-method.png"></center>
        <p>The method assembler lets you edit methods as text.</p>
        <p><strong>Features</strong></p>
        <ul>
            <li>Tab completion
            <ul>
                <li>Keywords (instruction opcodes)</li>
                <li>Instruction specific content (class types, field declarations, method declarations).</li>
            </ul>
            </li>
            <br><li>Code verification and analysis. After each keypress the code is analyzed for errors. Any error is shown both on the line number that caused it and in the bottom of the window in a list (clicking on list items will jump to the error line). In most cases the error is on the line that it says it is on. For more information on errors, see the post on understanding errors [click here for that].</li>
            <br><li>Named variables
            <ul>
                <li>The code analysis process allows referencing variables by names rather than indices.</li>
                <li>Classes that contain debug information will automatically disassemble variable instructions using variable names. If no debug information is found then the disassembler will fall back to using indices.</li>
            </ul>
            </li>
            <br><li>Right click context actions
            <ul>
                <li><strong>Labels</strong>: Navigate to the instructions that reference the label</li>
                <li><strong>Jumps</strong>: Navigate to the jump destination</li>
                <li><strong>Switches</strong>: Navigate to the switch case labels</li>
                <li><strong>Variables</strong>: Navigate to other variable instructions that refer to the same variable name/index</li>
                <li><strong>Class references</strong>: Show context menu for referenced class</li>
                <li><strong>Field references</strong>: Show context menu for referenced field</li>
                <li><strong>Method references</strong>: Show context menu for referenced method</li>
            </ul>
            </li>
        </ul>
        <h2 id="example">Example</h2>
        <p>Given the following Java code, lets take a look at the assembler</p>
<pre><span class="line"></span><span class="annotation">@Override</span>
<span class="line"></span><span class="keyword">public</span> <span class="keyword">double</span> accept(String expression) {
<span class="line"></span>    String matched = MatchUtil.match(<span class="string">&quot;^[-]?[0-9.]+[+-][-]?[0-9.]+&quot;</span>, expression);
<span class="line"></span>    String op = MatchUtil.findFirst(matched, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>);
<span class="line"></span>    <span class="keyword">int</span> index = matched.indexOf(op);
<span class="line"></span>    String left = matched.substring(<span class="constant">0</span>, index);
<span class="line"></span>    String right = matched.substring(index + <span class="constant">1</span>, matched.length());
<span class="line"></span>    expression = expression.replace(matched, String.valueOf(<span class="keyword">switch</span> (op) {
<span class="line"></span>        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> -&gt; <span class="keyword">this</span>.evaluate(left) + <span class="keyword">this</span>.evaluate(right);
<span class="line"></span>        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> -&gt; <span class="keyword">this</span>.evaluate(left) - <span class="keyword">this</span>.evaluate(right);
<span class="line"></span>        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();
<span class="line"></span>    }));
<span class="line"></span>    <span class="keyword">return</span> <span class="keyword">this</span>.evaluate(expression);
<span class="line"></span>}
</pre>
        <table class="aligner">
            <tr>
                <td><span class="helper"/><img src="screenshots/assembler-example.png"></td>
                <td><span class="helper"/><img src="screenshots/assembler-example-locals.png"></td>
            </tr>
        </table>
        <h3 id="analysis">Analysis</h3>
        <p>The screenshot on the left shows the <em>Analysis</em> tab of the assembler window. This tab is shows information about the current line you have your cursor on. In the picture I have selected a line to make it more visible. There are two columns...</p>
        <p>The left column shows the value of variables at the given point. For primitive types and strings the exact value is simulated when possible.</p>
        <p>The right column shows the stack at the given point. The most recent items of the stack appear on the bottom of the list. In this case we can see that three strings are on the stack. The top of the stack contains <code>-</code> and just below it is <code>+</code>. Below that is an unknown string, loaded from the <code>matched</code> variable.</p>
        <h3 id="locals">Locals</h3>
        <p>The screenshot on the right shows a table displaying the current local variables. Unlike the analysis tab this does not show the value in the variable, just information about the variable. </p>
        <ul>
        <li>Index: The variable&#39;s local index</li>
        <li>Start/End: The labels in the method that indicate the scope of the variable</li>
        <li>Name: The variable&#39;s name as it was in the source code</li>
        <li>Descriptor: The variable&#39;s type</li>
        </ul>
        <p>You can immediately jump to any instruction that references a variable by right clicking on it in the table. This brings up the referrer menu.</p>
        <blockquote>
        <p><strong>See also</strong>:</p>
        <ul>
            <li><a href="doc-edit-assembler-errors.html"><em>&quot;Understanding assembler errors&quot;</em></a></li>
            <li><a href="doc-instructions.html"><em>&quot;Recaf's simplified bytecode format&quot;</em></a></li>    
        </ul>
        </blockquote>
        
        
        
        <h2 id="field-assembler">Field Assembler</h2>
        <center><img src="screenshots/assembler-field.png"></center>
        <p>The field assembler lets you edit fields as text.</p>
        <ul>
            <li>The field assembler does not have any specific features at the moment.</li>
        </ul>
        
        
        
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-mode-decompile.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="decompile">Decompile</h1>
        <p>The decompile view mode is typically the most effective way to display classes. It works by decompiling the class and using the <a href="https://github.com/javaparser/javaparser">JavaParser library</a> to analyze the decompiled code. When you right click on some text JavaParser can figure out what you have selected, be it a class, field, or method. With this knowledge Recaf will show you a context menu with relevant options. For field and method definitions this will allow you to bring up the assembler window for the selected field or method. If you select a reference to a field or method and not the definition itself then the option to jump to its definition will be presented instead.</p>
        <center><img src="screenshots/mode-decompile.png"></center>
        <p>This view mode is designed to be the most easy to use and familiar of the options since it presents the class in a familiar source-like fashion. Additionally this mode will allow you to compile the decompiled code if the code is compliant with the installed Java compiler on your system. If no Java compiler is found you will not be able to recompile code this way, but the assembler will always be there for you. Please be aware that this is a direct call to <span class="code">javac</span> so any compile errors you have that show up when you attempt to save are compiler errors, not Recaf errors. There are plenty of edge cases that may cause compiling to fail that are not immediately obvious. Please double check what you are compiling.</p>
        <p>Recaf provides support for the following decompilers:</p>
        <ul>
        <li><a href="https://github.com/leibnitz27/cfr">CFR</a></li>
        <li><a href="https://github.com/fesh0r/fernflower">FernFlower</a></li>
        <li><a href="https://bitbucket.org/mstrobel/procyon/src/default/">Procyon</a></li>
        </ul>
        <p>The primary decompiler that will be used in this mode can be changed in the config window’s decompile tab. Different decompilers format the code slightly differently and may handle certain classes better than others. If at first one decompiler fails to fully reconstruct the code into something that is parseable, try another decompiler. If you are looking at an obfuscated class then it is likely that the decompilers will not be able to fully interpret the code. In this case you should switch to table mode which in the next section.</p>
        <blockquote>
        <p><strong>Note</strong>: While the ability to recompile code is made available to you, it is not the recommended way to make changes in complex programs. Decompilers do not always result in code that has the same behavior/semantics as the original code. Decompile mode is intended to make <em>navigation</em> easier. It is not intended to be a glorified compiler front-end.</p>
        </blockquote>
        <p><strong>Pros</strong>:</p>
        <ul>
        <li>Easy to understand for beginners since everything is laid out in a familiar way.<ul>
        <li>Right click text for context-sensitive menus, allowing access to editing and navigation functions.</li>
        </ul>
        </li>
        <li>Easy to make changes by recompiling decompiled code.<ul>
        <li>Hit the save keybind <em>(<code>Control + S</code>)</em> to recompile the decompiled code.</li>
        <li>Requires all referenced classes to be accessible in the workspace. </li>
        </ul>
        </li>
        </ul>
        <p><strong>Cons</strong>:</p>
        <ul>
        <li>Does not handle obfuscated code well. JavaParser does not work if the code isn’t <em>&quot;valid&quot;</em>. Thus Recaf will have no way to understand what you are selecting and will not show context menus.</li>
        </ul>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-mode-hex.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="hex">Hex</h1>
        <p>The hex mode is a very basic hex editor implementation. This will allow for precision editing of files. There is no contextual actions here, its just pure hex editing.</p>
        <center><img src="screenshots/mode-hex.png"></center>
        <p><strong>Pros</strong>:</p>
        <ul>
        <li>True lossless/precision editing.<ul>
        <li>In other modes, making changes will reorganize the class file&#39;s constant pool due to the usage of the <a href="https://asm.ow2.io/javadoc/org/objectweb/asm/ClassWriter.html#COMPUTE_FRAMES">ASM bytecode library</a>.</li>
        </ul>
        </li>
        <li>Works regardless of obfuscation.</li>
        </ul>
        <p><strong>Cons</strong>:</p>
        <ul>
            <li>Difficult if you are not familiar with hex editors and the <a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html">class file format</a>.<ul>
                <li>You can interactively learn the format by using <a href="https://ide.kaitai.io/">Kaitai struct&#39;s web IDE</a>
                <ul>
                    <li>Select <code>kaitai.io/formats/executable/java_class.ksy</code></li>
                    <li>At the bottom left corner, click the upload button and select a class file to analyze.</li>
                </ul>
                </li>
            </ul>
            </li>
        </ul>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-mode-table.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="table">Table</h1>
        <p>The table view mode is designed as a foolproof display mode that will always work even in cases where the class is heavily obfuscated. Right clicking on table rows of both fields and methods behaves like clicking on the respective definitions in the decompile view mode.</p>
        <center><img src="screenshots/mode-table.png"></center>
        <p><strong>Pros</strong>:</p>
        <ul>
        <li>Works regardless of obfuscation.</li>
        </ul>
        <p><strong>Cons</strong>:</p>
        <ul>
        <li>Not as intuitive as decompile mode since you cannot see the method&#39;s logic.</li>
        <li>Not fully implemented <em>(Missing: Editing class-level attributes)</em></li>
        </ul>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-edit-modes.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="class-editing-modes">Class editing modes</h1>
        <p>When opening class files in Recaf, you have 3 different display modes. For all modes you can save your changes with <code>Control + S</code> <em>(Binds are modifiable in the config window)</em>. When the save was a success the edges of the editor window will flash green. Make sure you see a green flash to verify your changes are saved before you export your file. For additional information check the documentation pages of each class mode, listed below.</p>
        <center><img src="screenshots/save-glow.gif"></center>
        <p><strong>Class modes</strong></p>
        <ul>
        <li><a href="doc-edit-mode-decompile.html">Decompile</a></li>
        <li><a href="doc-edit-mode-table.html">Table</a></li>
        <li><a href="doc-edit-mode-hex.html">Hex</a></li>
        </ul>
        <h2 id="changing-the-mode">Changing the mode</h2>
        <p>The default mode is set to <em>Decompile</em>. There are cases where this is less than optimal. In order to change the class display mode there are two approaches:</p>
        <p><strong>1. Change the config</strong></p>
        <p>To permanently change the mode you can open the config window by selecting <em>&quot;Config&quot;</em> on the menu bar. In the display tab change the <em>&quot;Class mode&quot;</em> to something else. </p>
        <p>Any new class that is opened will use this new mode. Tabs that are already open are not changed.</p>
        <p><strong>2. Change the tab&#39;s config</strong></p>
        <p>To change the mode for only the one class, you can right click on the tab title and change the mode in addition to changing the decompiler. </p>
        <p>Any new class that is opened will still use whatever is specified in the config. This only changes the config for the current tab.</p>
        <p><strong>Demo</strong></p>
        <center><img src="screenshots/changing-modes.gif"></center>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-instructions.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/docs.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/table.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1>Instruction Set</h1>
        <p>This is a listing of the <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instructions</a> ordered by the underlying bytecode library <i>(<a href="https://asm.ow2.io/">ASM</a>)</i> grouping. For instance, <code>ifeq</code> and <code>goto</code> belong to the <code>Jump</code> group. Most of the groupings should make sense and seeing one or two of the instructions should key you into which other ones are also in the group. What differs this list from the <a href="https://docs.oracle.com/javase/specs/jvms/se12/html/jvms-6.html">official instruction specification </a> is that the descriptions have been modified to fit how Recaf represents them.</p>
		<!--
        <p>For instance take <code>ifeq</code></p>
        <center>
			<h1>Raw representation</h1>
			<table class="pure-table example-small">
				<thead>
					<tr>
						<th>Opcode</th>
						<th>Stack: [before]→[after]</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="center">ifeq <i><ul><li>branchbyte1</li><li>branchbyte2</li></ul></i></td>
						<td class="center">value →</td>
						<td class="center">If <code>value == 0</code> jump to the destination denoted by <code>(branchbyte1 &lt;&lt; 8) | branchbyte2</code> where <code>branchbyte1, branchbyte2</code> are the following bytes after the <code>ifeq</code> opcode.</td>
					</tr>
				</tbody>
			</table>
			<h1>Recaf representation</h1>
			<table class="pure-table example-small">
				<thead>
					<tr>
						<th>Opcode</th>
						<th>Stack: [before]→[after]</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="center">ifeq <i><ul><li>label</li></ul></i></td>
						<td class="center">value →</td>
						<td class="center">if <code>value == 0</code>, jump to <code>label</code></td>
				</tr>
				</tbody>
			</table>
		</center>
		<br>
		<p>In the raw example contents of the opcode such as the jump instructions opcode offset <i>(for when the jump succeeds, the index in the method to jump to)</i> are read from bytes following the opcode. In ASM its simply a field you can get <i>(label)</i>. Offsets are also converted to a utility class <code>org.objectweb.asm.tree.LabelNode</code>. Recaf aliases these labels to simple names.</p>
		 -->
        <h2 id="toc">Table of Contents</h2>
		<ul>
			<a href="#insn"><li>Insn</li></a>
			<a href="#int"><li>Integer</li></a>
			<a href="#var"><li>Variable</li></a>
			<a href="#type"><li>Type</li></a>
			<a href="#field"><li>Field</li></a>
			<a href="#method"><li>Method</li></a>
			<a href="#indy"><li>InvokeDynamic</li></a>
			<a href="#jump"><li>Jump</li></a>
			<a href="#ldc"><li>Ldc</li></a>
			<a href="#array"><li>MultiANewArray</li></a>
			<a href="#switch"><li>Switch</li></a>
			<a href="#label"><li>Label</li></a>
			<a href="#line"><li>Line</li></a>
			<!-- <a href="#frame"><li>Frame</li></a> -->
		</ul>
		<hr>
		<h1 id="insn" class="inline">Insn</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<!-- constants -->
				<tr>
					<td class="center">aconst_null</td>
					<td class="center">→ null</td>
					<td class="center">push a <code>null</code> reference onto the stack</td>
				</tr>
				<tr>
					<td class="center">dconst_0</td>
					<td class="center">→ 0.0</td>
					<td class="center">push the constant <code>0.0</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">dconst_1</td>
					<td class="center">→ 1.0</td>
					<td class="center">push the constant <code>1.0</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">fconst_0</td>
					<td class="center">→ 0.0f</td>
					<td class="center">push <code>0.0f</code> on the stack</td>
				</tr>
				<tr>
					<td class="center">fconst_1</td>
					<td class="center">→ 1.0f</td>
					<td class="center">push <code>1.0f</code> on the stack</td>
				</tr>
				<tr>
					<td class="center">fconst_2</td>
					<td class="center">→ 2.0f</td>
					<td class="center">push <code>2.0f</code> on the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_m1</td>
					<td class="center">→ -1</td>
					<td class="center">load the <code>int</code> value <code>−1</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_0</td>
					<td class="center">→ 0</td>
					<td class="center">load the <code>int</code> value <code>0</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_1</td>
					<td class="center">→ 1</td>
					<td class="center">load the <code>int</code> value <code>1</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_2</td>
					<td class="center">→ 2</td>
					<td class="center">load the <code>int</code> value <code>2</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_3</td>
					<td class="center">→ 3</td>
					<td class="center">load the <code>int</code> value <code>3</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_4</td>
					<td class="center">→ 4</td>
					<td class="center">load the <code>int</code> value <code>4</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">iconst_5</td>
					<td class="center">→ 5</td>
					<td class="center">load the <code>int</code> value <code>5</code> onto the stack</td>
				</tr>
				<tr>
					<td class="center">lconst_0</td>
					<td class="center">→ 0L</td>
					<td class="center">
						push <code>0L</code> onto the stack
					</td>
				</tr>
				<tr>
					<td class="center">lconst_1</td>
					<td class="center">→ 1L</td>
					<td class="center">
						push <code>1L</code> onto the stack
					</td>
				</tr>
				<!-- array -->
				<tr>
					<td class="center">arraylength</td>
					<td class="center">arrayref → length</td>
					<td class="center">get the length of an array</td>
				</tr>
				<tr>
					<td class="center">aaload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load onto the stack a reference from an array</td>
				</tr>
				<tr>
					<td class="center">aastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store into a reference in an array</td>
				</tr>			
				<tr>
					<td class="center">baload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load a <code>byte</code> or Boolean value from an array</td>
				</tr>
				<tr>
					<td class="center">bastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store a <code>byte</code> or Boolean value into an array</td>
				</tr>
				<tr>
					<td class="center">caload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load a <code>char</code> from an array</td>
				</tr>
				<tr>
					<td class="center">castore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store a <code>char</code> into an array</td>
				</tr>
				<tr>
					<td class="center">daload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load a <code>double</code> from an array</td>
				</tr>
				<tr>
					<td class="center">dastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store a <code>double</code> into an array</td>
				</tr>
				<tr>
					<td class="center">faload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load a <code>float</code> from an array</td>
				</tr>
				<tr>
					<td class="center">fastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store a <code>float</code> in an array</td>
				</tr>
				<tr>
					<td class="center">iaload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load an <code>int</code> from an array</td>
				</tr>
				<tr>
					<td class="center">iastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store an <code>int</code> into an array</td>
				</tr>
				<tr>
					<td class="center">laload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load a <code>long</code> from an array</td>
				</tr>
				<tr>
					<td class="center">lastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store a <code>long</code> to an array</td>
				</tr>
				<tr>
					<td class="center">saload</td>
					<td class="center">arrayref, index → value</td>
					<td class="center">load <code>short</code> from array</td>
				</tr>
				<tr>
					<td class="center">sastore</td>
					<td class="center">arrayref, index, value →</td>
					<td class="center">store <code>short</code> to array</td>
				</tr>
				<!-- converts -->
				<tr>
					<td class="center">d2f</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>double</code> to <code>float</code></td>
				</tr>
				<tr>
					<td class="center">d2i</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>double</code> to <code>int</code></td>
				</tr>
				<tr>
					<td class="center">d2l</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>double</code> to <code>long</code></td>
				</tr>
				<tr>
					<td class="center">f2d</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>float</code> to <code>double</code></td>
				</tr>
				<tr>
					<td class="center">f2i</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>float</code> to <code>int</code></td>
				</tr>
				<tr>
					<td class="center">f2l</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>float</code> to <code>long</code></td>
				</tr>
				<tr>
					<td class="center">i2b</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>byte</code></td>
				</tr>
				<tr>
					<td class="center">i2c</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>char</code></td>
				</tr>
				<tr>
					<td class="center">i2d</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>double</code></td>
				</tr>
				<tr>
					<td class="center">i2f</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>float</code></td>
				</tr>
				<tr>
					<td class="center">i2l</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>long</code></td>
				</tr>
				<tr>
					<td class="center">i2s</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>int</code> to <code>short</code></td>
				</tr>
				<tr>
					<td class="center">l2d</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>long</code> to <code>double</code></td>
				</tr>
				<tr>
					<td class="center">l2f</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>long</code> to <code>float</code></td>
				</tr>
				<tr>
					<td class="center">l2i</td>
					<td class="center">value → result</td>
					<td class="center">convert:  <code>long</code> to <code>int</code></td>
				</tr>
				<!-- return -->
				<tr>
					<td class="center">areturn</td>
					<td class="center">objectref → [empty]</td>
					<td class="center">return a reference from a method</td>
				</tr>
				<tr>
					<td class="center">dreturn</td>
					<td class="center">value → [empty]</td>
					<td class="center">return a <code>double</code> from a method</td>
				</tr>
				<tr>
					<td class="center">freturn</td>
					<td class="center">value → [empty]</td>
					<td class="center">return a <code>float</code></td>
				</tr>
				<tr>
					<td class="center">ireturn</td>
					<td class="center">value → [empty]</td>
					<td class="center">return an <code>int</code> from a method</td>
				</tr>
				<tr>
					<td class="center">lreturn</td>
					<td class="center">value → [empty]</td>
					<td class="center">return a <code>long</code> value</td>
				</tr>
				<tr>
					<td class="center">return</td>
					<td class="center">→ [empty]</td>
					<td class="center">return <code>void</code> from method</td>
				</tr>
				<!-- math -->
				<tr>
					<td class="center">dadd</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">add two <code>double</code> values<code>value2 + value1</code></td>
				</tr>
				<tr>
					<td class="center">ddiv</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">divide two <code>double</code> values<code>value2 / value1</code></td>
				</tr>			
				<tr>
					<td class="center">dmul</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">multiply two <code>double</code> values<code>value2 * value1</code></td>
				</tr>
				<tr>
					<td class="center">drem</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">get the remainder from a division between two <code>double</code> values<code>(value2 - ((value1 / value2) * value2))</code></td>
				</tr>
				<tr>
					<td class="center">dsub</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">subtract a <code>double</code> from another<code>value2 - value1</code></td>
				</tr>
				<tr>
					<td class="center">fadd</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">add two <code>float</code> values<code>value2 + value1</code></td>
				</tr>
				<tr>
					<td class="center">fdiv</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">divide two <code>float</code> values<code>value2 / value1</code></td>
				</tr>
				<tr>
					<td class="center">fmul</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">multiply two <code>float</code> values<code>value2 * value1</code></td>
				</tr>
				<tr>
					<td class="center">frem</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">get the remainder from a division between two <code>float</code> values<code>(value2 - ((value1 / value2) * value2))</code></td>
				</tr>
				<tr>
					<td class="center">fsub</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">subtract two <code>float</code> values<code>value2 - value1</code></td>
				</tr>
				<tr>
					<td class="center">iadd</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">add two <code>int</code> values<code>value2 + value1</code></td>
				</tr>
				<tr>
					<td class="center">idiv</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">divide two <code>int</code> values<code>value2 / value1</code></td>
				</tr>
				<tr>
					<td class="center">imul</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">multiply two <code>int</code> values<code>value2 * value1</code></td>
				</tr>
				<tr>
					<td class="center">irem</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">logical <code>int</code> remainder<code>(value2 - ((value1 / value2) * value2))</code></td>
				</tr>
				<tr>
					<td class="center">isub</td>
					<td class="center">value1, value2 → result</td>
					<td class="center"><code>int</code> subtract<code>value2 - value1</code></td>
				</tr>
				<tr>
					<td class="center">iand</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">perform a bitwise AND on two <code>int</code> values<code>value2 &amp; value1</code></td>
				</tr>
				<tr>
					<td class="center">ior</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise <code>int</code> OR<code>value2 | value1</code></td>
				</tr>
				<tr>
					<td class="center">ixor</td>
					<td class="center">value1, value2 → result</td>
					<td class="center"><code>int</code> xor<code>value2 ^ value1</code></td>
				</tr>
				<tr>
					<td class="center">ishl</td>
					<td class="center">value1, value2 → result</td>
					<td class="center"><code>int</code> shift left<code>value2 &lt;&lt; value1</code></td>
				</tr>
				<tr>
					<td class="center">ishr</td>
					<td class="center">value1, value2 → result</td>
					<td class="center"><code>int</code> arithmetic shift right<code>value2 &gt;&gt; value1</code></td>
				</tr>
				<tr>
					<td class="center">iushr</td>
					<td class="center">value1, value2 → result</td>
					<td class="center"><code>int</code> logical shift right<code>value2 &gt;&gt;&gt; value1</code></td>
				</tr>
				<tr>
					<td class="center">ladd</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">add two <code>long</code> values<code>value2 + value1</code></td>
				</tr>
				<tr>
					<td class="center">ldiv</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">divide two <code>long</code> values<code>value2 / value1</code></td>
				</tr>
				<tr>
					<td class="center">lmul</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">multiply two <code>long</code> values<code>value2 * value1</code></td>
				</tr>
				<tr>
					<td class="center">lrem</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">remainder of division of two <code>long</code> values<code>(value2 - ((value1 / value2) * value2))</code></td>
				</tr>
				<tr>
					<td class="center">lsub</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">subtract two <code>long</code> values<code>value2 - value1</code></td>
				</tr>
				<tr>
					<td class="center">lshl</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise shift left of a <code>long</code> <code>value1</code> by <code>int</code> <code>value2</code> positions<code>value2 &lt;&lt; value1</code></td>
				</tr>
				<tr>
					<td class="center">lshr</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise shift right of a <code>long</code> <code>value1</code> by <code>int</code> <code>value2</code> positions<code>value2 &gt;&gt; value1</code></td>
				</tr>
				<tr>
					<td class="center">lushr</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise shift right of a <code>long</code> <code>value1</code> by <code>int</code> <code>value2</code> positions, unsigned<code>value2 &gt;&gt;&gt; value1</code></td>
				</tr>
				<tr>
					<td class="center">land</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise AND of two <code>long</code> values<code>value2 ^ value1</code></td>
				</tr>
				<tr>
					<td class="center">lor</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise OR of two <code>long</code> values<code>value2 | value1</code></td>
				</tr>
				<tr>
					<td class="center">lxor</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">bitwise XOR of two <code>long</code> values<code>value2 ^ value1</code></td>
				</tr>
				<tr>
					<td class="center">dneg</td>
					<td class="center">value → result</td>
					<td class="center">negate a <code>double</code><code>-value</code></td>
				</tr>
				<tr>
					<td class="center">fneg</td>
					<td class="center">value → result</td>
					<td class="center">negate a <code>float</code><code>-value</code></td>
				</tr>
				<tr>
					<td class="center">ineg</td>
					<td class="center">value → result</td>
					<td class="center">negate <code>int</code><code>-value</code></td>
				</tr>
				<tr>
					<td class="center">lneg</td>
					<td class="center">value → result</td>
					<td class="center">negate a <code>long</code><code>-value</code></td>
				</tr>
				<!-- compare -->
				<tr>
					<td class="center">dcmpg</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">compare two <code>double</code> values
					<table class="pure-table code-table">
						<tr>
							<th>Comparison</th>
							<th>Value</th>
						</tr>
						<tr>
							<td>value1 == NaN ||<br> value2 == NaN</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 &gt; value2</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 == value2</td>
							<td>0</td>
						</tr>
						<tr>
							<td>value1 &lt; value2</td>
							<td>-1</td>
						</tr>
					</table>
					</td>
				</tr>
				<tr>
					<td class="center">dcmpl</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">compare two <code>double</code> values
					<table class="pure-table code-table">
						<tr>
							<th>Comparison</th>
							<th>Value</th>
						</tr>
						<tr>
							<td>value1 == NaN ||<br> value2 == NaN</td>
							<td>-1</td>
						</tr>
						<tr>
							<td>value1 &gt; value2</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 == value2</td>
							<td>0</td>
						</tr>
						<tr>
							<td>value1 &lt; value2</td>
							<td>-1</td>
						</tr>
					</table>
					</td>
				</tr>
				<tr>
					<td class="center">fcmpg</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">compare two <code>float</code> values
					<table class="pure-table code-table">
						<tr>
							<th>Comparison</th>
							<th>Value</th>
						</tr>
						<tr>
							<td>value1 == NaN ||<br> value2 == NaN</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 &gt; value2</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 == value2</td>
							<td>0</td>
						</tr>
						<tr>
							<td>value1 &lt; value2</td>
							<td>-1</td>
						</tr>
					</table>
					</td>
				</tr>
				<tr>
					<td class="center">fcmpl</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">compare two <code>float</code> values
					<table class="pure-table code-table">
						<tr>
							<th>Comparison</th>
							<th>Value</th>
						</tr>
						<tr>
							<td>value1 == NaN ||<br> value2 == NaN</td>
							<td>-1</td>
						</tr>
						<tr>
							<td>value1 &gt; value2</td>
							<td>1</td>
						</tr>
						<tr>
							<td>value1 == value2</td>
							<td>0</td>
						</tr>
						<tr>
							<td>value1 &lt; value2</td>
							<td>-1</td>
						</tr>
					</table></td>
				</tr>
				<tr>
					<td class="center">lcmp</td>
					<td class="center">value1, value2 → result</td>
					<td class="center">compare two <code>long</code> values
					<table class="pure-table code-table">
						<tr>
							<th>Comparison</th>
							<th>Value</th>
						</tr>
						<tr>
							<td>value1 == value2</td>
							<td>0</td>
						</tr>
						<tr>
							<td>value1 &gt; value2</td>
							<td>1</td>
						</tr>
						<tr>
							<td>else</td>
							<td>-1</td>
						</tr>
					</table></td>
				</tr>
				<!-- stack -->
				<tr>
					<td class="center">athrow</td>
					<td class="center">objectref → [empty], objectref</td>
					<td class="center">throws an error or exception <i>(notice that the rest of the stack is cleared, leaving only a reference to the <code>Throwable</code>)</i></td>
				</tr>
				<tr>
					<td class="center">dup</td>
					<td class="center">value → value, value</td>
					<td class="center">duplicate the value on top of the stack</td>
				</tr>
				<tr>
					<td class="center">dup_x1</td>
					<td class="center">value2, value1 → value1, value2, value1</td>
					<td class="center">insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type <code>double</code> or <code>long</code>.</td>
				</tr>
				<tr>
					<td class="center">dup_x2</td>
					<td class="center">value3, value2, value1 → value1, value3, value2, value1</td>
					<td class="center">insert a copy of the top value into the stack two (if value2 is <code>double</code> or <code>long</code> it takes up the entry of value3, too) or three values (if value2 is neither <code>double</code> nor <code>long</code>) from the top</td>
				</tr>
				<tr>
					<td class="center">dup2</td>
					<td class="center">{value2, value1} → {value2, value1}, {value2, value1}</td>
					<td class="center">duplicate top two stack words (two values, if value1 is not <code>double</code> nor <code>long</code>; a single value, if value1 is <code>double</code> or <code>long</code>)</td>
				</tr>
				<tr>
					<td class="center">dup2_x1</td>
					<td class="center">value3, {value2, value1} → {value2, value1}, value3, {value2, value1}</td>
					<td class="center">duplicate two words and insert beneath third word (see explanation above)</td>
				</tr>
				<tr>
					<td class="center">dup2_x2</td>
					<td class="center">{value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1}</td>
					<td class="center">duplicate two words and insert beneath fourth word</td>
				</tr>
				<tr>
					<td class="center">pop</td>
					<td class="center">value →</td>
					<td class="center">discard the top value on the stack</td>
				</tr>
				<tr>
					<td class="center">pop2</td>
					<td class="center">{value2, value1} →</td>
					<td class="center">discard the top two values on the stack (or one value, if it is a <code>double</code> or <code>long</code>)</td>
				</tr>
				<tr>
					<td class="center">swap</td>
					<td class="center">value2, value1 → value1, value2</td>
					<td class="center">swaps two top words on the stack (note that value1 and value2 must not be <code>double</code> or <code>long</code>)</td>
				</tr>
				<tr>
					<td class="center">monitorenter</td>
					<td class="center">objectref →</td>
					<td class="center">enter monitor for object ("grab the lock" – start of synchronized() section)</td>
				</tr>
				<tr>
					<td class="center">monitorexit</td>
					<td class="center">objectref →</td>
					<td class="center">exit monitor for object ("release the lock" – end of synchronized() section)</td>
				</tr>
				<tr>
					<td class="center">nop</td>
					<td class="center">[No change]</td>
					<td class="center">do nothing</td>
				</tr>
			</tbody>
		</table>
		<h1 id="int" class="inline">Integer</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">bipush <i><ul><li>value</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">push a <code>byte</code> onto the stack as an integer <code>value</code></td>
				</tr>
				<tr>
					<td class="center">sipush <i><ul><li>value</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">push a <code>short</code> onto the stack as an integer <code>value</code></td>
				</tr>
				<tr>
					<td class="center">newarray <i><ul><li>descriptor</li></ul></i></td>
					<td class="center">count → arrayref</td>
					<td class="center">create new array with <code>count</code> elements of primitive type identified by <code>descriptor</code>
					<table class="pure-table code-table">
						<tr>
							<th>Type</th>
                            <th>Descriptor alias</th>
						</tr>
						<tr>
							<td>boolean</td>
							<td>Z</td>
						</tr>
						<tr>
							<td>char</td>
							<td>C</td>
						</tr>
						<tr>
							<td>float</td>
							<td>F</td>
						</tr>
						<tr>
							<td>double</td>
							<td>D</td>
						</tr>
						<tr>
							<td>byte</td>
							<td>B</td>
						</tr>
						<tr>
							<td>short</td>
							<td>S</td>
						</tr>
						<tr>
							<td>int</td>
							<td>I</td>
						</tr>
						<tr>
							<td>long</td>
							<td>J</td>
						</tr>
					</table>
					</td>
				</tr>
			</tbody>
		</table>
		<h1 id="var" class="inline">Variable</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">iload <i><ul><li>index</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">load an <code>int</code> <code>value</code> from a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">lload <i><ul><li>index</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">load a <code>long</code> value from a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">fload <i><ul><li>index</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">load a <code>float</code> <code>value</code> from a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">dload <i><ul><li>index</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">load a <code>double</code> <code>value</code> from a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">aload <i><ul><li>index</li></ul></i></td>
					<td class="center">→ objectref</td>
					<td class="center">load a reference onto the stack from a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">istore <i><ul><li>index</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">store <code>int</code> <code>value</code> into variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">lstore <i><ul><li>index</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">store a <code>long</code> <code>value</code> in a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">fstore <i><ul><li>index</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">store a <code>float</code> <code>value</code> into a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">dstore <i><ul><li>index</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">store a <code>double</code> <code>value</code> into a local variable <code>index</code></td>
				</tr>
				<tr>
					<td class="center">astore <i><ul><li>index</li></ul></i></td>
					<td class="center">objectref →</td>
					<td class="center">store a reference into a local variable <code>index</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="type" class="inline">Type</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">new <i><ul><li>type</li></ul></i></td>
					<td class="center">→ objectref</td>
					<td class="center">create new object of <code>type</code></td>
				</tr>
				<tr>
					<td class="center">anewarray <i><ul><li>type</li></ul></i></td>
					<td class="center">count → arrayref</td>
					<td class="center">create a new array of references of length <code>count</code> and component type identified by <code>type</code></td>
				</tr>
				<tr>
					<td class="center">checkcast <i><ul><li>type</li></ul></i></td>
					<td class="center">objectref → objectref</td>
					<td class="center">checks whether an <code>objectref</code> is of a certain specified <code>type</code></td>
				</tr>
				<tr>
					<td class="center">instanceof <i><ul><li>type</li></ul></i></td>
					<td class="center">objectref → result</td>
					<td class="center">determines if an object <code>objectref</code> is of a given <code>type</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="field" class="inline">Field</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">getfield <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">objectref → value</td>
					<td class="center">get an instance field defined by the <code>owner</code> class and the field's <code>name</code> and <code>desc</code></td>
				</tr>
				<tr>
					<td class="center">getstatic <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">get a static field defined by the <code>owner</code> class and the field's <code>name</code> and <code>desc</code></td>
				</tr>
				<tr>
					<td class="center">putfield <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">objectref, value →</td>
					<td class="center">set an instance field defined by the <code>owner</code> class and the field's <code>name</code> and <code>desc</code></td>
				</tr>
				<tr>
					<td class="center">putstatic <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">set a static field defined by the <code>owner</code> class and the field's <code>name</code> and <code>desc</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="method" class="inline">Method</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">invokeinterface <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">objectref, [arg1, arg2, ...] → result</td>
					<td class="center">invokes an interface method defined by the <code>owner</code> class and the method's <code>name</code> and <code>desc</code> on object <code>objectref</code> and puts the result on the stack (might be void)</td>
				</tr>
				<tr>
					<td class="center">invokespecial <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">objectref, [arg1, arg2, ...] → result</td>
					<td class="center">invokes an instance method defined by the <code>owner</code> class and the method's <code>name</code> and <code>desc</code> on object <code>objectref</code> and puts the result on the stack (might be void)</td>
				</tr>
				<tr>
					<td class="center">invokestatic <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">[arg1, arg2, ...] → result</td>
					<td class="center">invokes a static method defined by the <code>owner</code> class and the method's <code>name</code> and <code>desc</code> and puts the result on the stack (might be void)</td>
				</tr>
				<tr>
					<td class="center">invokevirtual <i><ul><li>owner</li><li>name</li><li>desc</li></ul></i></td>
					<td class="center">objectref, [arg1, arg2, ...] → result</td>
					<td class="center">invokes a virtual method defined by the <code>owner</code> class and the method's <code>name</code> and <code>desc</code> on object <code>objectref</code> and puts the result on the stack (might be void)</td>
				</tr>
			</tbody>
		</table>
		<h1 id="indy" class="inline">InvokeDynamic</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">invokedynamic <i>
					<ul>
					<li>definition</li>
					<ul>
						<li>name, desc</li>
					</ul>
					<li>bootstrap handle</li>
					<ul>
						<li>owner, name, desc</li>
					</ul>
					<li>bootstrap arguments[]</li>
					</ul></i></td>
					<td class="center">[arg1, arg2 ...] → result</td>
					<!-- TODO: Better explain how ASM structures the opcode -->
					<td class="center">invokes a dynamic method and puts the result on the stack <i>(might be void)</i>;<br>The <code>callsite</code> handles the dynamic invocation</td>
				</tr>
			</tbody>
		</table>
		<h1 id="jump" class="inline">Jump</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">goto <i><ul><li>label</li></ul></i></td>
					<td class="center">[no change]</td>
					<td class="center">jump to <code>label</code></td>
				</tr>
				<!--			
				<tr>
					<td class="center">jsr</td>
					<td class="center">→ address</td>
					<td class="center">jump to subroutine at <code>branchoffset</code> (signed <code>short</code> constructed from unsigned bytes <span class="monospaced" style="font-family: monospace, monospace;">branchbyte1 &lt;&lt; 8 + branchbyte2</code>) and place the return address on the stack</td>
				</tr>
				-->
				<tr>
					<td class="center">if_acmpeq <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if references <code>value1 == value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_acmpne <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if references <code>value1 != value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmpeq <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 == value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmpge <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 &gt;= value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmpgt <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 &gt; value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmple <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 &lt;= value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmplt <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 &lt; value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">if_icmpne <i><ul><li>label</li></ul></i></td>
					<td class="center">value1, value2 →</td>
					<td class="center">if ints <code>value1 != value2</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifeq <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value == 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifge <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value &gt;= 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifgt <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value &gt; 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifle <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value &lt;= 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">iflt <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value &lt; 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifne <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value != 0</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifnonnull <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value != null</code>, jump to <code>label</code></td>
				</tr>
				<tr>
					<td class="center">ifnull <i><ul><li>label</li></ul></i></td>
					<td class="center">value →</td>
					<td class="center">if <code>value == null</code>, jump to <code>label</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="ldc" class="inline">Ldc</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">ldc <i><ul><li>value</li></ul></i></td>
					<td class="center">→ value</td>
					<td class="center">push a constant <code>value</code> (String, int, float, Class, or Handle) onto the stack</td>
				</tr>
			</tbody>
		</table>
		<h1 id="iinc" class="inline">Increment <i>(Variable)</i></h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">iinc <i><ul><li>index</li><li>amount</li></ul></i></td>
					<td class="center">[No change]</td>
					<td class="center">increment local variable <code>index</code> by a given <code>amount</code> (byte)</td>
				</tr>
			</tbody>
		</table>
		<h1 id="array" class="inline">MultiANewArray</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">multianewarray <i><ul><li>desc</li><li>dims</li></ul></i></td>
					<td class="center">count1, [count2,...] → arrayref</td>
					<td class="center">create a new array of <code>dims</code> dimensions of type identified by <code>desc</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="switch" class="inline">Switch</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">lookupswitch</td>
					<td class="center">key →</td>
					<!-- TODO: Better ASM tie-in -->
					<td class="center">a target address is looked up from a table using a key and execution continues from the instruction at that address</td>
				</tr>
				<tr>
					<td class="center">tableswitch</td>
					<td class="center">index →</td>
					<td class="center">continue execution from an address in the table at offset <code>index</code></td>
				</tr>
			</tbody>
		</table>
		<h1 id="label" class="inline">Label</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">label</td>
					<td class="center">[No change]</td>
					<td class="center">marker in bytecode for the beginning of a block of opcodes; referenced by jump and switch insns.</td>
				</tr>
			</tbody>
		</table>
		<h1 id="line" class="inline">Line</h1><a href="#toc" class="inline leftmargin"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="center">line <i><ul><li>value</li></ul></i></td>
					<td class="center">[No change]</td>
					<td class="center">marker for where the next opcode denotes the beginning of a given <code>line</code> in the original source.</td>
				</tr>
			</tbody>
		</table>
		<!--
		<h1 id="frame" class="inline">Frame</h1><a href="#toc" class="inline"><i>(top)</i></a>
		<table class="pure-table">
			<thead>
				<tr>
					<th>Opcode</th>
					<th>Stack: [before]→[after]</th>
					<th>Description</th>
				</tr>
			</thead>
			<tbody>
				<!--
				<tr>
					<td class="center">breakpoint</td>
					<td class="center"></td>
					<td class="center">reserved for breakpoints in Java debuggers; should not appear in any class file</td>
				</tr>
				<tr>
					<td class="center">impdep1</td>
					<td class="center"></td>
					<td class="center">reserved for implementation-dependent operations within debuggers; should not appear in any class file</td>
				</tr>
				<tr>
					<td class="center">impdep2</td>
					<td class="center"></td>
					<td class="center">reserved for implementation-dependent operations within debuggers; should not appear in any class file</td>
				</tr>
			</tbody>
		</table>
		-->
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-intro-config.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="config">Config</h1>
        <p>Recaf&#39;s application settings can be changed by clicking the <em>&quot;Config&quot;</em> item in the main menu. There are multiple categories of config values. Each category contains one or more values that are displayed as a name, description, and value. The descriptions under each item should be descriptive enough to understand their function.</p>
        <center><img src="screenshots/config.png"></center>
        <h2 id="where-is-config-stored-">Where is config stored?</h2>
        <p>Config values, along with other related files for Recaf, are stored in different locations depending on your operating system.</p>
        <ul>
        <li>Windows: <code>%APPDATA%/Recaf</code></li>
        <li>Mac: <code>$HOME/Library/Preferences/Recaf</code></li>
        <li>Linux: <code>$XDG_CONFIG_HOME/Recaf</code> <ul>
        <li><code>$HOME/.config/Recaf</code> if <code>$XDG_CONFIG_HOME</code> is not set</li>
        </ul>
        </li>
        </ul>
        <blockquote>
        <p><strong>Note</strong>: You can check where this location is in the system information window, under <em>&quot;Help &gt; System information&quot;</em></p>
        <center><img src="screenshots/config-location.png"></center>
        </blockquote>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-intro-workspace.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <link rel="stylesheet" href="css/table.css">
    <script src="js/jquery.min.js"></script>
    <style>
.box {
  border: 1px solid rgb(56, 56, 56);
  background-color: rgba(0, 0, 0, 0.1);
}
.box .head {
  background-color: rgb(150, 150, 150);
  padding: 8px;
  min-height: 38px;
  text-align: center;
  vertical-align: middle;
  font-weight: bold;
}
.box p {
  margin: 10px;
}

/* Used on the workspace page */
#diagram {
  width: 100%;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  align-content: stretch;
  align-items: stretch;
}

#diagram>.box {
  flex: 0 1 23%;
}

@media(max-width: 767px) {
  #diagram {}

  #diagram>.box {
    flex: 0 1 100%;
  }
}
    </style>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="workspaces">Workspaces</h1>
        <p>Recaf operates in workspaces. Each workspace can have one or more files loaded at a time. The first file loaded will be marked as the primary resource. All following files are secondary resources. In addition to these two resources, there are two additional back-end resources that add functionality to Recaf.</p>
        <div id="diagram">
            <div class="box">
                <div class="head">Primary Resource</div>
                <ul><li>Classes</li><li>Resources</li></ul>
                <p>A primary resource contains all the class files and resources of the input to be modified.</p>
            </div>
            <div class="box">
                <div class="head">Secondary Resource(s)</div>
                <ul><li>Classes</li><li>Resources</li></ul>
                <p>A secondary resource contains supporting class files and resources. They are for reference purposes and are used to bolster things like ease of navigation, recompilation, and proper stack-frame generation. Multiple secondary resources may exist in a workspace.</p>
            </div>
            <div class="box">
                <div class="head">Classpath Resource</div>
                <ul><li>Classes</li></ul>
                <p>The classpath resource is a hidden resource common to all workspaces. It allows Recaf to read class files directly from memory.</p>
            </div>
            <div class="box">
                <div class="head">Phantom Resource</div>
                <ul><li>Classes</li></ul>
                <p>The phantom resource is used to store temporary class files that are generated to bolster things like recompilation and proper stack-frame generation.</p>
                <p>If the phantom generation process fails, you may have to provide libraries as backing resources to use some features. But overall it should not be too big of a deal.</p>
                <blockquote>
                <p><strong>Note</strong>: This is regenerated each time a new workspace is created and runs in the background until completion.<br> It currently does not handle cases where generated methods belong to method hierarchies that get renamed.</p>
                </blockquote>
            </div>
        </div>
        <p>The primary resource is the file that will be modified. Recaf&#39;s primary functionality <em>(editing, searching, etc)</em> uses only this file. </p>
        <p>Secondary resources may be used as supporting libraries or for reference purposes. Classes in secondary resources are still navigable like those in the primary resource, however they are <em>read-only</em>. They cannot be modified. </p>
        <blockquote>
        <p><strong>Note</strong>: Secondary resources will be used as compiler classpath items when recompiling code in the primary resource.</p>
        </blockquote>
        <p>Supported file types include:</p>
        <ul>
        <li>Class files</li>
        <li>Jar files</li>
        <li>War files</li>
        </ul>
        <blockquote>
        <p><strong>Note</strong>: You can also attach to currently running Java programs by opening the <i>"Attach"</i> menu.</p>
        </blockquote>
        <h2 id="creating-a-workspace">Creating a workspace</h2>
        <p>You can create a new workspace by selecting <em>&quot;File &gt; Load&quot;</em>. This will show a file prompt where you can select the primary resource. Alternatively you can drag-and-drop a file onto the left-most panel. </p>
        <p>Once the workspace is created with the primary resource you can add additional secondary resources with <em>&quot;File &gt; Add library&quot;</em>.</p>
        <center><img src="screenshots/workspace-dropdown.png"></center>
        <p>All resources can have sources and JavaDocs attached as references. Right click on the resource and select which item you would like to attach. After attaching JavaDocs you can hover over a method to show a documentation popup.</p>
        <table class="aligner">
            <tr>
                <td><span class="helper"/><img src="screenshots/workspace-add.png"></td>
                <td><span class="helper"/><img src="screenshots/javadoc.png"></td>
            </tr>
        </table>
        <blockquote>
        <p><strong>Note</strong>: You can supply a file to Recaf to load initially on startup using the command line argument <code>--input &lt;path/to/file&gt;</code></p>
        </blockquote>
        <h2 id="navigating-the-workspace">Navigating the workspace</h2>
        <p>Considering the fact that Recaf supports multiple resources in a workspace there needs to be a way to navigate to the files of each resource. This is done by inserting a dropdown menu at the top of the navigation tree. In this menu the primary resource will be listed at the top and all additional libraries will be added below it. Selecting one of these items will replace the tree with the contents of that file. </p>
        <p>Each resource&#39;s navigation tree is persistent. This means that when a directory is opened it will stay open even after switching to another resource. When you switch back the tree will be just as it was before.</p>
        <p>In order to quickly navigate to files it would be useful for there to be a filter. At the bottom of the navigation tree is a filter box. The content of the filter will show all tree items that contain the given path. For example <code>java/lang/String</code> and <code>String</code> will show the <code>String</code> class in the navigation tree <em>(Along with <code>StringBuilder</code> since it contains <code>String</code>)</em>.</p>
        <center><img src="screenshots/workspace-search.gif"></center>
        <h2 id="saving-a-file">Saving a file</h2>
        <p>As covered in the <a href="doc-edit-modes.html">editing mode documentation</a> changes are first saved locally inside of Recaf when you hit the save keybind <em>(<code>Control + S</code>)</em>. This does not update the actual file on the system. In order to apply the changes you made you need to export the program after saving each change. To do this  select <em>&quot;File &gt; Export program&quot;</em> from the menu bar. This will prompt you to give a file location to save the file to.</p>
        <h2 id="saving-a-workspace">Saving a workspace</h2>
        <p>If you want to save the configured workspace you may use <em>&quot;File &gt; Export workspace&quot;</em>. This will prompt you to give a file location to save the workspace to. This will create a JSON file that holds references to each resource in the workspace. This JSON file can be used when loading a file <em>(from either the menu prompt, or by drag-and-drop)</em> to open all items in the workspace at once.</p>
        <blockquote>
        <p><strong>Note</strong>: Workspaces that use runtime components such as the attach function to connect to live processes cannot be exported to a JSON.</p>
        </blockquote>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-dec-member.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-member-declarations">Searching for member declarations</h1>
        <p>To open member declaration search, select <em>&quot;Search &gt; Member declarations&quot;</em>. This will open a member declaration search window.</p>
        <center><img src="screenshots/search-member-declaration.png"></center>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Not all fields are required for every search type</strong></p>
        <p>This is especially useful with this search mode. For example:</p>
        <ul>
        <li>Searching with only the owner specified will show all defined types of the class to the owner class&#39;s fields and methods.</li>
        <li>Searching only a name/descriptor of a field/method will show all classes that define that method.</li>
        </ul>
        <p><strong>2. Skip packages that you know you don&#39;t need to search for faster searches</strong></p>
        <p>While the search implementation is fast you may still want to exclude packages that you know for sure do not have meaningful results to cut down on search time.</p>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-instruction.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-instructions">Searching for instructions</h1>
        <p>To open instruction search, select <em>&quot;Search &gt; Instructions&quot;</em>. This will open a instructions search window.</p>
        <center><img src="screenshots/search-instructions.png"></center>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Each line in the <i>&quot;Text lines&quot;</i> input is searched per-line</strong></p>
        <p>This will allow you to run per-instruction pattern matching, or simply opcode patterns.</p>
        <p><strong>2. Skip packages that you know you don&#39;t need to search for faster searches</strong></p>
        <p>While the search implementation is fast you may still want to exclude packages that you know for sure do not have meaningful results to cut down on search time.</p>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-ref-class.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-class-references">Searching for class references</h1>
        <p>To open class reference search, select <em>&quot;Search &gt; Class references&quot;</em>. This will open a class reference search window.</p>
        <center><img src="screenshots/search-class.png"></center>
        <p>Class references <strong>include</strong>:</p>
        <ul>
            <li>Type instructions like, <code>NEW</code>, <code>CHECKCAST</code>, <code>INSTANCEOF</code></li>
            <li>Local variable definitions of the specified type</li>
        </ul>
        <p>Class references <strong>do not include</strong>:</p>
        <ul>
            <li>References to fields and methods of the specified type</li>
        </ul>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Skip packages that you know you don&#39;t need to search for faster searches</strong></p>
        <p>While the search implementation is fast you may still want to exclude packages that you know for sure do not have meaningful results to cut down on search time.</p>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-ref-member.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-member-references">Searching for member references</h1>
        <p>To open member reference search, select <em>&quot;Search &gt; Member references&quot;</em>. This will open a member reference search window.</p>
        <center><img src="screenshots/search-member-reference.png"></center>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Not all fields are required for every search type</strong></p>
        <p>This is especially useful with this search mode. For example:</p>
        <ul>
        <li>Searching with only the owner specified will show all references to the owner class&#39;s fields and methods.<ul>
        <li>Adding a <code>(</code> to the descriptor portion will filter out all field references since <code>(</code> is the first character of all method descriptors.</li>
        </ul>
        </li>
        <li>Searching only a name/descriptor of a method will show all references to that method regardless of which class implements it.</li>
        <li>Searching with a package name like <code>com/example/</code> will show every reference to every item in the package.</li>
        </ul>
        <p><strong>2. Skip packages that you know you don&#39;t need to search for faster searches</strong></p>
        <p>While the search implementation is fast you may still want to exclude packages that you know for sure do not have meaningful results to cut down on search time.</p>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-string.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-strings">Searching for strings</h1>
        <p>To open string search, select <em>&quot;Search &gt; Strings&quot;</em>. This will open a string search window.</p>
        <center><img src="screenshots/search-string.png"></center>
        <blockquote>
        <p><strong>Note</strong>: In all search types, you will be able to change the string matching mode, and skipped packages</p>
        </blockquote>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Don&#39;t forget about regex</strong></p>
        <p>It can be a very powerful tool. In Recaf, the entire string must be matched by the regex pattern to be returned as a result. </p>
        <p><strong>Examples</strong>:</p>
        <ul>
        <li>URL: <code>(www|http(s)?:|ftp:)+[^\s]+[\w]</code></li>
        <li>IP: <code>(\d{1,3}\.){3}\d{1,3}</code></li>
        <li>More examples at <a href="https://www.regular-expressions.info/examples.html">regular-expressions.info</a></li>
        <li>Check out <a href="https://regex101.com/">regex101.com</a> to craft your own patterns with useful guidelines</li>
        </ul>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-search-value.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="searching-for-values">Searching for values</h1>
        <p>To open value search, select <em>&quot;Search &gt; Values&quot;</em>. This will open a value search window.</p>
        <center><img src="screenshots/search-value.png"></center>
        <h2 id="tips">Tips</h2>
        <p><strong>1. Remember to be specific with your value type</strong></p>
        <p>Searching for <code>1</code>, <code>1.0</code>, <code>1F</code> and <code>1L</code> all search for different types. When in doubt, add the extension of your intended type.</p>
        <ul>
        <li>Default type is <code>int</code></li>
        <li>If a decimal is used, type is <code>double</code></li>
        <li>If a <code>F</code> or <code>f</code> is the last character, type is <code>float</code></li>
        <li>If a <code>L</code> or <code>l</code> is the last character, type is <code>long</code></li>
        </ul>
        <p><strong>2. Skip packages that you know you don&#39;t need to search for faster searches</strong></p>
        <p>While the search implementation is fast you may still want to exclude packages that you know for sure do not have meaningful results to cut down on search time.</p>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-setup-11.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="java-11-setup">Java 11+ setup</h1>
        <p>No additional work is required after downloading Recaf.</p>
        <blockquote>
            <p><b>Note</b>: Recaf automatically fetches JavaFX from Maven Central.</p>
            <p>Additionally since all releases of Java 11+ <a href="https://dzone.com/articles/no-more-jre-packaging-no-big-deal-1">only exist as JDK's</a> all JDK tools can be automatically discovered.</p>
        </blockquote>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-setup-8.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="java-8-setup">Java 8 setup</h1>
        <h2 id="javafx">JavaFX</h2>
        <p>Recaf&#39;s UI is built using JavaFX. Please ensure your installed version of Java 8 bundles JavaFX. Known supported vendors are:</p>
        <ul>
        <li><a href="https://aws.amazon.com/corretto/">Amazon Corretto</a></li>
        <li><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html">Oracle</a> - <i>Be wary of Oracle&#39;s new license before installing.</i></li>
        </ul>
        <blockquote>
        <p><b>Note</b>: Recaf can automatically fetch JavaFX when using Java 11+. The reason why this is unsupported in Java 8 is because <a href="https://www.infoworld.com/article/3305073/removed-from-jdk-11-javafx-11-arrives-as-a-standalone-module.html">JavaFX&#39;s binaries only became independently released after Java 11</a>. Pulling these future versions is incompatible with Java 8.</p>
        </blockquote>
        <h2 id="features">Features</h2>
        <p>Some features of Recaf depend on the Java Development Kit <em>(JDK)</em>. The JDK provides additional libraries and tools that are not present in standard Java Runtime Envrionments <em>(JRE)</em>. Because of these dependencies it is <em>highly recommended</em> you have a JDK installed and have it set as your primary version of Java. </p>
        <p>Recaf imports the following libraries from the JDK: </p>
        <ul>
        <li><code>/lib/tools.jar</code> - compiler, instrumentation</li>
        <li><del><code>/lib/sa-jdi.jar</code> - debugging</del></li>
        </ul>
        <p>These libraries should be automatically discovered by Recaf if they are in the expected directories. You can validate the libraries are loaded by checking the <em>&quot;System information&quot;</em> window, located in the <em>&quot;Help&quot;</em> menu. The information window will have rows including items such as <i>"supports compiler"</i> and <i>"supports attach"</i>. These should both be marked as <code>true</code> if everything has loaded properly.</p>
        <table class="aligner">
            <tr>
                <td><span class="helper"/><img src="screenshots/setup-help.png"></td>
                <td><span class="helper"/><img src="screenshots/setup-info.png"></td>
            </tr>
        </table>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/doc-setup-get.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/code.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column">
        <h1 id="getting-recaf">Getting Recaf</h1>
        <h2 id="prerequisites">Prerequisites</h2>
        <p>Recaf&#39;s only pre-requisite is that you have Java installed. However your version of Java may affect feature availability. See the following documentation guides for more information:</p>
        <ul>
        <li><a href="doc-setup-8.html">Java 8</a></li>
        <li>Java 9-10 - <i>Unsupported, update to Java 11</i></li>
        <li><a href="doc-setup-11.html">Java 11+</a></li>
        </ul>
        <h2 id="getting-the-executable">Getting the executable</h2>
        <p>Recaf is distributed as an executable jar file. You can get the latest release in the following ways:</p>
        <ol>
        <li>Visiting the project&#39;s <a href="https://github.com/Col-E/Recaf/releases">release&#39;s section on GitHub</a> and downloading the latest <code>recaf-2.X.X-J8-jar-with-dependencies.jar</code></li>
        <li>Downloading or cloning the project then running the build script <i>(<code>build</code>/<code>build.sh</code>)</i></li>
        </ol>
        <p>The jar file should behave like any standard executable. Double click to run, or execute it manually from the terminal using <code>java -jar recaf-bla-bla-bla.jar</code>. </p>
        <blockquote>
        <p><b>Note</b>: If click-to-run does not work, try the terminal command. You may not have the file extension registered properly.</p>
        <ul>
            <li><a href="https://superuser.com/questions/1194758/unable-to-run-jar-files-by-double-clicking-them-on-windows-7">Windows</a></li>
            <li><a href="https://askubuntu.com/questions/192914/how-run-a-jar-file-with-a-double-click">Linux</a></li>
        </ul>
        <p>If Recaf does not run when using the terminal command, copy any output in the terminal and <a href="https://github.com/Col-E/Recaf/issues/new?template=bug_report.md">create a bug report</a>.</p>
        </blockquote>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/documentation.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/docs.css">
    <script src="js/jquery.min.js"></script>
	<meta http-equiv="refresh" content="0; URL=https://col-e.github.io/Recaf-documentation/" />
</head>
<body id="root">
<header class="pure-menu pure-menu-horizontal">
    <a href="index.html"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item pure-menu-selected"><a href="documentation.html" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="features.html" class="pure-menu-link">Features</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<article>
    <div id="sidebar" class="column">
        <div class="pure-menu">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><span class="parent-menu">Setup</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-setup-get.html" class="pure-menu-link">Getting Recaf</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-8.html" class="pure-menu-link">Java 8</a></li>
                        <li class="pure-menu-item"><a href="doc-setup-11.html" class="pure-menu-link">Java 11+</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Introduction</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-intro-workspace.html" class="pure-menu-link">Workspaces</a></li>
                        <li class="pure-menu-item"><a href="doc-intro-config.html" class="pure-menu-link">Config</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Searching</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-search-string.html" class="pure-menu-link">Strings</a></li>
                        <li class="pure-menu-item"><a href="doc-search-value.html" class="pure-menu-link">Values</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-class.html" class="pure-menu-link">Class references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-ref-member.html" class="pure-menu-link">Member references</a></li>
                        <li class="pure-menu-item"><a href="doc-search-dec-member.html" class="pure-menu-link">Member declarations</a></li>
                        <li class="pure-menu-item"><a href="doc-search-instruction.html" class="pure-menu-link">Instructions</a></li>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Editing</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-edit-modes.html" class="pure-menu-link">Class modes</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-decompile.html" class="pure-menu-link">Decompile mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-table.html" class="pure-menu-link">Table mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-mode-hex.html" class="pure-menu-link">Hex mode</a></li>
                        <li class="pure-menu-item"><a href="doc-edit-assembler.html" class="pure-menu-link">Assembler</a></li>
                        <ul class="pure-menu-sub-list">
                            <li class="pure-menu-item"><a href="doc-edit-assembler-errors.html" class="pure-menu-link">Errors</a></li>
                        </ul>
                    </ul>
                </li>
                <li class="pure-menu-item"><span class="parent-menu">Advanced</span>
                    <ul class="pure-menu-sub-list">
                        <li class="pure-menu-item"><a href="doc-advanced-theme.html" class="pure-menu-link">Themes</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-plugin.html" class="pure-menu-link">Plugins</a></li>
                        <li class="pure-menu-item"><a href="doc-advanced-scripting.html" class="pure-menu-link">Scripting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="content" class="column" ss-container>
        <h1>Documentation home</h1>
        <p>To see specific documentation for a topic, select an item from the table of contents.</p>
        <hr>
        <h2>Table of Contents</h2>
        <ul>
            <li>Setup
                <ul>
                    <li><a href="doc-setup-get.html">Getting Recaf</a></li>
                    <li><a href="doc-setup-8.html">Java 8</a></li>
                    <li><a href="doc-setup-11.html">Java 11+</a></li>
                </ul>
            </li>
            <li>Introduction
                <ul>
                    <li><a href="doc-intro-workspace.html">Workspaces</a></li>
                    <li><a href="doc-intro-config.html">Config</a></li>
                </ul>
            </li>
            <li>Searching
                <ul>
                    <li><a href="doc-search-string.html">Strings</a></li>
                    <li><a href="doc-search-value.html">Values</a></li>
                    <li><a href="doc-search-ref-class.html">Class references</a></li>
                    <li><a href="doc-search-ref-member.html">Member references</a></li>
                    <li><a href="doc-search-dec-member.html">Member declarations</a></li>
                    <li><a href="doc-search-instruction.html">Instructions</a></li>
                </ul>
            </li>
            <li>Editing
                <ul>
                   <li><a href="doc-edit-modes.html">Class modes</a></li>
                   <li><a href="doc-edit-mode-decompile.html">Decompile mode</a></li>
                   <li><a href="doc-edit-mode-table.html">Table mode</a></li>
                   <li><a href="doc-edit-mode-hex.html">Hex mode</a></li>
                   <li><a href="doc-edit-assembler.html">Assembler</a></li>
                    <ul>
                        <li><a href="doc-edit-assembler-errors.html">Errors</a></li>
                    </ul>
                </ul>
            </li>
            <li>Advanced
                <ul>
                    <li><a href="doc-advanced-theme.html">Themes</a></li>
                    <li><a href="doc-advanced-plugin.html">Plugins</a></li>
                    <li><a href="doc-advanced-scripting.html">Scripting</a></li>
                </ul>
            </li>
        </ul>
        <br id="spacing-hack">
    </div>
</article> 
</body>
</html>

```

`docs/index.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>Recaf - modern bytecode editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Recaf is a modern java bytecode editor using Objectweb's ASM and JavaFX.">
	<meta name="keywords" content="java,bytecode,editor,recaf,reverse engineering">
	<link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <link rel="stylesheet" href="css/font/roboto300.css">
    <link rel="stylesheet" href="css/pure/pure-min.css">
    <link rel="stylesheet" href="css/pure/grids-responsive-min.css">
    <link rel="stylesheet" href="css/scroll.css">
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/menu.css">
    <link rel="stylesheet" href="css/banner.css">
</head>
<body>
<header class="pure-menu pure-menu-horizontal">
    <a href="#"><div class="logo"></div></a>
    <nav>
        <ul class="pure-menu-list">
            <li class="pure-menu-item"><a href="https://col-e.github.io/Recaf-documentation/" class="pure-menu-link">Documentation</a></li>
            <li class="pure-menu-item"><a href="https://github.com/Col-E/Recaf" class="pure-menu-link">Github</a></li>
        </ul>
    </nav>
</header>
<div class="banner-wrapper">
    <div class="banner">
        <div class="banner-head">
            <div class="banner-beam">
                <h1>Recaf</h1>
                <p>A modern bytecode editor</p>
            </div>
            <!-- Ease of access download button -->
            <a class="pure-button" href="#" id="download">Download</a>
			<script src="js/jquery.min.js"></script>
			<script language="javascript" type="text/javascript">
			function setup() {
				var btn = $("#download");
				// Don't bother on mobile layout
				if (!btn.is(":visible")) {
					// Don't allow resizing the viewport to show the button.
					btn.css("display", "none");
					return;
				}
				// For desktop viewports, setup download button.
				$.getJSON("https://api.github.com/repos/Col-E/Recaf/releases/latest").done(function (json) {
					// Setup button text
					var tagName = json.tag_name;
					var btntxt = "Download Recaf-" + tagName;
					btn.html(btntxt);
					// Setup link URL
					var downloadURL = json.assets[0].browser_download_url;
					btn.attr("href", downloadURL);
			   }); 
			}
			setup();
			</script>
        </div>
    </div>
</div>
<article>
    <div id="content">
        <h3>What is Recaf?</h3>
        <p>Recaf is an open-source Java bytecode editor that simplifies the process of editing compiled Java applications. To make things easier Recaf abstracts away much of the internal class file format. Difficult tasks such as updating stack-frames are done automatically. Along with additional features to assist in the process of editing classes, Recaf is the most feature-rich free bytecode editor available.</p>
        
        <h3>Useful Information</h3>
        <p>While Recaf makes bytecode editing a more simple process it does not mean you should dive head-first into editing compiled Java applications without understanding some basic programming concepts and the Java class file architecture. Here are some references for these topics:</p>
        <ul>
            <li><a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html">Specification: Chapter 2. The Structure of the Java Virtual Machine</a></li>
            <li><a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html">Specification: Chapter 4. The class File Format </a></li>
            <li><a href="https://blog.takipi.com/jvm-architecture-101-get-to-know-your-virtual-machine/">JVM Architecture 101: Get to Know Your Virtual Machine</a></li>
            <li>Java instructions:
                <ul>
                    <li><a href="doc-instructions.html">Recaf's simplified instruction format</a></li>
                    <li><a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-6.html">Standard Java instructions</a></li>
                </ul>
            </li>
        </ul>
        <h3>Download &amp; Building</h3>
        <p>Downloadable jar binaries are provided through Github's <a href="https://github.com/Col-E/Recaf/releases">release page</a>.<br>Alternatively you can build from the source by cloning <i>(or downloading)</i> the repository and using maven to build the executable.</p>
        <h3>Requirements</h3>
        <p>Recaf requires Java 8 to run but it is recommended you use Java 11 or higher. Some features require additional setup in Java 8 whereas the process is automatic in Java 11 and above</p>
        <h3>Usage Guide &amp; More Information</h3>
        <ul>
            <li><a href="documentation.html">Documentation &amp; usage</a></li>
        </ul>	
        <h3>Contact &amp; Support</h3>
        <p>For reporting bugs and suggesting new features please use the github repo's <a href="https://github.com/Col-E/Recaf/issues">issue page</a> and submit a new issue. For other inquiries, or if you'd just like to chat, join the discord server here: <a href="https://discord.gg/Bya5HaA">discord.gg/Bya5HaA</a></p>
    </div>
</article> 
</body>
</html>

```

`docs/js/jquery.min.js`:

```js
/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.3",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},eb=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fb){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function gb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+rb(o[l]);w=ab.test(a)&&pb(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function hb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ib(a){return a[u]=!0,a}function jb(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function kb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function lb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function nb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function ob(a){return ib(function(b){return b=+b,ib(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pb(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=gb.support={},f=gb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=gb.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",eb,!1):e.attachEvent&&e.attachEvent("onunload",eb)),p=!f(g),c.attributes=jb(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=jb(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=jb(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(jb(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),jb(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&jb(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return lb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?lb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},gb.matches=function(a,b){return gb(a,null,null,b)},gb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return gb(b,n,null,[a]).length>0},gb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},gb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},gb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},gb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=gb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=gb.selectors={cacheLength:50,createPseudo:ib,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||gb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&gb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=gb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||gb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ib(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ib(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ib(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ib(function(a){return function(b){return gb(a,b).length>0}}),contains:ib(function(a){return a=a.replace(cb,db),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ib(function(a){return W.test(a||"")||gb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:ob(function(){return[0]}),last:ob(function(a,b){return[b-1]}),eq:ob(function(a,b,c){return[0>c?c+b:c]}),even:ob(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:ob(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:ob(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:ob(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=mb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=nb(b);function qb(){}qb.prototype=d.filters=d.pseudos,d.setFilters=new qb,g=gb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?gb.error(a):z(a,i).slice(0)};function rb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function tb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ub(a,b,c){for(var d=0,e=b.length;e>d;d++)gb(a,b[d],c);return c}function vb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wb(a,b,c,d,e,f){return d&&!d[u]&&(d=wb(d)),e&&!e[u]&&(e=wb(e,f)),ib(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ub(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:vb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=vb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=vb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sb(function(a){return a===b},h,!0),l=sb(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sb(tb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wb(i>1&&tb(m),i>1&&rb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xb(a.slice(i,e)),f>e&&xb(a=a.slice(e)),f>e&&rb(a))}m.push(c)}return tb(m)}function yb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=vb(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&gb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ib(f):f}return h=gb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,yb(e,d)),f.selector=a}return f},i=gb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&pb(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&rb(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&pb(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=jb(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),jb(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||kb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&jb(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||kb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),jb(function(a){return null==a.getAttribute("disabled")})||kb(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),gb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)
},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec=/#.*$/,fc=/([?&])_=[^&]*/,gc=/^(.*?):[ \t]*([^\r\n]*)$/gm,hc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ic=/^(?:GET|HEAD)$/,jc=/^\/\//,kc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lc={},mc={},nc="*/".concat("*"),oc=a.location.href,pc=kc.exec(oc.toLowerCase())||[];function qc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rc(a,b,c,d){var e={},f=a===mc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function uc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:oc,type:"GET",isLocal:hc.test(pc[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sc(sc(a,n.ajaxSettings),b):sc(n.ajaxSettings,a)},ajaxPrefilter:qc(lc),ajaxTransport:qc(mc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gc.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||oc)+"").replace(ec,"").replace(jc,pc[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pc[1]&&h[2]===pc[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pc[3]||("http:"===pc[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rc(lc,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ic.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fc.test(d)?d.replace(fc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rc(mc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tc(k,v,f)),u=uc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vc=/%20/g,wc=/\[\]$/,xc=/\r?\n/g,yc=/^(?:submit|button|image|reset|file)$/i,zc=/^(?:input|select|textarea|keygen)/i;function Ac(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wc.test(a)?d(a,e):Ac(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ac(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ac(c,a[c],b,e);return d.join("&").replace(vc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zc.test(this.nodeName)&&!yc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xc,"\r\n")}}):{name:b.name,value:c.replace(xc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bc=0,Cc={},Dc={0:200,1223:204},Ec=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cc)Cc[a]()}),k.cors=!!Ec&&"withCredentials"in Ec,k.ajax=Ec=!!Ec,n.ajaxTransport(function(a){var b;return k.cors||Ec&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Dc[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fc=[],Gc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hc=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hc)return Hc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ic=a.document.documentElement;function Jc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ic;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ic})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kc=a.jQuery,Lc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lc),b&&a.jQuery===n&&(a.jQuery=Kc),n},typeof b===U&&(a.jQuery=a.$=n),n});

```

`docs/js/scroll.js`:

```js
function smoothen() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            document.querySelector(this.getAttribute('href')).scrollIntoView({
                behavior: 'smooth'
            });
        });
    });
}
```

`mvnw`:

```
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Maven Start Up Batch script
#
# Required ENV vars:
# ------------------
#   JAVA_HOME - location of a JDK home dir
#
# Optional ENV vars
# -----------------
#   M2_HOME - location of maven2's installed home dir
#   MAVEN_OPTS - parameters passed to the Java VM when running Maven
#     e.g. to debug Maven itself, use
#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files
# ----------------------------------------------------------------------------

if [ -z "$MAVEN_SKIP_RC" ] ; then

  if [ -f /usr/local/etc/mavenrc ] ; then
    . /usr/local/etc/mavenrc
  fi

  if [ -f /etc/mavenrc ] ; then
    . /etc/mavenrc
  fi

  if [ -f "$HOME/.mavenrc" ] ; then
    . "$HOME/.mavenrc"
  fi

fi

# OS specific support.  $var _must_ be set to either true or false.
cygwin=false;
darwin=false;
mingw=false
case "`uname`" in
  CYGWIN*) cygwin=true ;;
  MINGW*) mingw=true;;
  Darwin*) darwin=true
    # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home
    # See https://developer.apple.com/library/mac/qa/qa1170/_index.html
    if [ -z "$JAVA_HOME" ]; then
      if [ -x "/usr/libexec/java_home" ]; then
        export JAVA_HOME="`/usr/libexec/java_home`"
      else
        export JAVA_HOME="/Library/Java/Home"
      fi
    fi
    ;;
esac

if [ -z "$JAVA_HOME" ] ; then
  if [ -r /etc/gentoo-release ] ; then
    JAVA_HOME=`java-config --jre-home`
  fi
fi

if [ -z "$M2_HOME" ] ; then
  ## resolve links - $0 may be a link to maven's home
  PRG="$0"

  # need this for relative symlinks
  while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
      PRG="$link"
    else
      PRG="`dirname "$PRG"`/$link"
    fi
  done

  saveddir=`pwd`

  M2_HOME=`dirname "$PRG"`/..

  # make it fully qualified
  M2_HOME=`cd "$M2_HOME" && pwd`

  cd "$saveddir"
  # echo Using m2 at $M2_HOME
fi

# For Cygwin, ensure paths are in UNIX format before anything is touched
if $cygwin ; then
  [ -n "$M2_HOME" ] &&
    M2_HOME=`cygpath --unix "$M2_HOME"`
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
  [ -n "$CLASSPATH" ] &&
    CLASSPATH=`cygpath --path --unix "$CLASSPATH"`
fi

# For Mingw, ensure paths are in UNIX format before anything is touched
if $mingw ; then
  [ -n "$M2_HOME" ] &&
    M2_HOME="`(cd "$M2_HOME"; pwd)`"
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
fi

if [ -z "$JAVA_HOME" ]; then
  javaExecutable="`which javac`"
  if [ -n "$javaExecutable" ] && ! [ "`expr \"$javaExecutable\" : '\([^ ]*\)'`" = "no" ]; then
    # readlink(1) is not available as standard on Solaris 10.
    readLink=`which readlink`
    if [ ! `expr "$readLink" : '\([^ ]*\)'` = "no" ]; then
      if $darwin ; then
        javaHome="`dirname \"$javaExecutable\"`"
        javaExecutable="`cd \"$javaHome\" && pwd -P`/javac"
      else
        javaExecutable="`readlink -f \"$javaExecutable\"`"
      fi
      javaHome="`dirname \"$javaExecutable\"`"
      javaHome=`expr "$javaHome" : '\(.*\)/bin'`
      JAVA_HOME="$javaHome"
      export JAVA_HOME
    fi
  fi
fi

if [ -z "$JAVACMD" ] ; then
  if [ -n "$JAVA_HOME"  ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
    else
      JAVACMD="$JAVA_HOME/bin/java"
    fi
  else
    JAVACMD="`\\unset -f command; \\command -v java`"
  fi
fi

if [ ! -x "$JAVACMD" ] ; then
  echo "Error: JAVA_HOME is not defined correctly." >&2
  echo "  We cannot execute $JAVACMD" >&2
  exit 1
fi

if [ -z "$JAVA_HOME" ] ; then
  echo "Warning: JAVA_HOME environment variable is not set."
fi

CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher

# traverses directory structure from process work directory to filesystem root
# first directory with .mvn subdirectory is considered project base directory
find_maven_basedir() {

  if [ -z "$1" ]
  then
    echo "Path not specified to find_maven_basedir"
    return 1
  fi

  basedir="$1"
  wdir="$1"
  while [ "$wdir" != '/' ] ; do
    if [ -d "$wdir"/.mvn ] ; then
      basedir=$wdir
      break
    fi
    # workaround for JBEAP-8937 (on Solaris 10/Sparc)
    if [ -d "${wdir}" ]; then
      wdir=`cd "$wdir/.."; pwd`
    fi
    # end of workaround
  done
  echo "${basedir}"
}

# concatenates all lines of a file
concat_lines() {
  if [ -f "$1" ]; then
    echo "$(tr -s '\n' ' ' < "$1")"
  fi
}

BASE_DIR=`find_maven_basedir "$(pwd)"`
if [ -z "$BASE_DIR" ]; then
  exit 1;
fi

##########################################################################################
# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
# This allows using the maven wrapper in projects that prohibit checking in binary data.
##########################################################################################
if [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Found .mvn/wrapper/maven-wrapper.jar"
    fi
else
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Couldn't find .mvn/wrapper/maven-wrapper.jar, downloading it ..."
    fi
    if [ -n "$MVNW_REPOURL" ]; then
      jarUrl="$MVNW_REPOURL/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    else
      jarUrl="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    fi
    while IFS="=" read key value; do
      case "$key" in (wrapperUrl) jarUrl="$value"; break ;;
      esac
    done < "$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Downloading from: $jarUrl"
    fi
    wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"
    if $cygwin; then
      wrapperJarPath=`cygpath --path --windows "$wrapperJarPath"`
    fi

    if command -v wget > /dev/null; then
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Found wget ... using wget"
        fi
        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
            wget "$jarUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
        else
            wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
        fi
    elif command -v curl > /dev/null; then
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Found curl ... using curl"
        fi
        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
            curl -o "$wrapperJarPath" "$jarUrl" -f
        else
            curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f
        fi

    else
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Falling back to using Java to download"
        fi
        javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"
        # For Cygwin, switch paths to Windows format before running javac
        if $cygwin; then
          javaClass=`cygpath --path --windows "$javaClass"`
        fi
        if [ -e "$javaClass" ]; then
            if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then
                if [ "$MVNW_VERBOSE" = true ]; then
                  echo " - Compiling MavenWrapperDownloader.java ..."
                fi
                # Compiling the Java class
                ("$JAVA_HOME/bin/javac" "$javaClass")
            fi
            if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then
                # Running the downloader
                if [ "$MVNW_VERBOSE" = true ]; then
                  echo " - Running MavenWrapperDownloader.java ..."
                fi
                ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")
            fi
        fi
    fi
fi
##########################################################################################
# End of extension
##########################################################################################

export MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}
if [ "$MVNW_VERBOSE" = true ]; then
  echo $MAVEN_PROJECTBASEDIR
fi
MAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"

# For Cygwin, switch paths to Windows format before running java
if $cygwin; then
  [ -n "$M2_HOME" ] &&
    M2_HOME=`cygpath --path --windows "$M2_HOME"`
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME=`cygpath --path --windows "$JAVA_HOME"`
  [ -n "$CLASSPATH" ] &&
    CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
  [ -n "$MAVEN_PROJECTBASEDIR" ] &&
    MAVEN_PROJECTBASEDIR=`cygpath --path --windows "$MAVEN_PROJECTBASEDIR"`
fi

# Provide a "standardized" way to retrieve the CLI args that will
# work with both Windows and non-Windows executions.
MAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"
export MAVEN_CMD_LINE_ARGS

WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain

exec "$JAVACMD" \
  $MAVEN_OPTS \
  $MAVEN_DEBUG_OPTS \
  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \
  "-Dmaven.home=${M2_HOME}" \
  "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \
  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"

```

`mvnw.cmd`:

```cmd
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Maven Start Up Batch script
@REM
@REM Required ENV vars:
@REM JAVA_HOME - location of a JDK home dir
@REM
@REM Optional ENV vars
@REM M2_HOME - location of maven2's installed home dir
@REM MAVEN_BATCH_ECHO - set to 'on' to enable the echoing of the batch commands
@REM MAVEN_BATCH_PAUSE - set to 'on' to wait for a keystroke before ending
@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven
@REM     e.g. to debug Maven itself, use
@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files
@REM ----------------------------------------------------------------------------

@REM Begin all REM lines with '@' in case MAVEN_BATCH_ECHO is 'on'
@echo off
@REM set title of command window
title %0
@REM enable echoing by setting MAVEN_BATCH_ECHO to 'on'
@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%

@REM set %HOME% to equivalent of $HOME
if "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")

@REM Execute a user defined script before this one
if not "%MAVEN_SKIP_RC%" == "" goto skipRcPre
@REM check for pre script, once with legacy .bat ending and once with .cmd ending
if exist "%USERPROFILE%\mavenrc_pre.bat" call "%USERPROFILE%\mavenrc_pre.bat" %*
if exist "%USERPROFILE%\mavenrc_pre.cmd" call "%USERPROFILE%\mavenrc_pre.cmd" %*
:skipRcPre

@setlocal

set ERROR_CODE=0

@REM To isolate internal variables from possible post scripts, we use another setlocal
@setlocal

@REM ==== START VALIDATION ====
if not "%JAVA_HOME%" == "" goto OkJHome

echo.
echo Error: JAVA_HOME not found in your environment. >&2
echo Please set the JAVA_HOME variable in your environment to match the >&2
echo location of your Java installation. >&2
echo.
goto error

:OkJHome
if exist "%JAVA_HOME%\bin\java.exe" goto init

echo.
echo Error: JAVA_HOME is set to an invalid directory. >&2
echo JAVA_HOME = "%JAVA_HOME%" >&2
echo Please set the JAVA_HOME variable in your environment to match the >&2
echo location of your Java installation. >&2
echo.
goto error

@REM ==== END VALIDATION ====

:init

@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".
@REM Fallback to current working directory if not found.

set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%
IF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir

set EXEC_DIR=%CD%
set WDIR=%EXEC_DIR%
:findBaseDir
IF EXIST "%WDIR%"\.mvn goto baseDirFound
cd ..
IF "%WDIR%"=="%CD%" goto baseDirNotFound
set WDIR=%CD%
goto findBaseDir

:baseDirFound
set MAVEN_PROJECTBASEDIR=%WDIR%
cd "%EXEC_DIR%"
goto endDetectBaseDir

:baseDirNotFound
set MAVEN_PROJECTBASEDIR=%EXEC_DIR%
cd "%EXEC_DIR%"

:endDetectBaseDir

IF NOT EXIST "%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config" goto endReadAdditionalConfig

@setlocal EnableExtensions EnableDelayedExpansion
for /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a
@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%

:endReadAdditionalConfig

SET MAVEN_JAVA_EXE="%JAVA_HOME%\bin\java.exe"
set WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.jar"
set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain

set DOWNLOAD_URL="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"

FOR /F "usebackq tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.properties") DO (
    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B
)

@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
@REM This allows using the maven wrapper in projects that prohibit checking in binary data.
if exist %WRAPPER_JAR% (
    if "%MVNW_VERBOSE%" == "true" (
        echo Found %WRAPPER_JAR%
    )
) else (
    if not "%MVNW_REPOURL%" == "" (
        SET DOWNLOAD_URL="%MVNW_REPOURL%/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    )
    if "%MVNW_VERBOSE%" == "true" (
        echo Couldn't find %WRAPPER_JAR%, downloading it ...
        echo Downloading from: %DOWNLOAD_URL%
    )

    powershell -Command "&{"^
		"$webclient = new-object System.Net.WebClient;"^
		"if (-not ([string]::IsNullOrEmpty('%MVNW_USERNAME%') -and [string]::IsNullOrEmpty('%MVNW_PASSWORD%'))) {"^
		"$webclient.Credentials = new-object System.Net.NetworkCredential('%MVNW_USERNAME%', '%MVNW_PASSWORD%');"^
		"}"^
		"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile('%DOWNLOAD_URL%', '%WRAPPER_JAR%')"^
		"}"
    if "%MVNW_VERBOSE%" == "true" (
        echo Finished downloading %WRAPPER_JAR%
    )
)
@REM End of extension

@REM Provide a "standardized" way to retrieve the CLI args that will
@REM work with both Windows and non-Windows executions.
set MAVEN_CMD_LINE_ARGS=%*

%MAVEN_JAVA_EXE% ^
  %JVM_CONFIG_MAVEN_PROPS% ^
  %MAVEN_OPTS% ^
  %MAVEN_DEBUG_OPTS% ^
  -classpath %WRAPPER_JAR% ^
  "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" ^
  %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*
if ERRORLEVEL 1 goto error
goto end

:error
set ERROR_CODE=1

:end
@endlocal & set ERROR_CODE=%ERROR_CODE%

if not "%MAVEN_SKIP_RC%"=="" goto skipRcPost
@REM check for post script, once with legacy .bat ending and once with .cmd ending
if exist "%USERPROFILE%\mavenrc_post.bat" call "%USERPROFILE%\mavenrc_post.bat"
if exist "%USERPROFILE%\mavenrc_post.cmd" call "%USERPROFILE%\mavenrc_post.cmd"
:skipRcPost

@REM pause the script if MAVEN_BATCH_PAUSE is set to 'on'
if "%MAVEN_BATCH_PAUSE%"=="on" pause

if "%MAVEN_TERMINATE_CMD%"=="on" exit %ERROR_CODE%

cmd /C exit /B %ERROR_CODE%

```

`pom.xml`:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>me.coley</groupId>
	<artifactId>recaf</artifactId>
	<url>https://github.com/Col-E/Recaf/</url>
	<version>2.21.13</version>
	<name>Recaf</name>
	<description>A modern java bytecode editor</description>
	<!-- Variables -->
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<asm.version>9.2</asm.version>
		<analysis.version>1.6.0</analysis.version>
		<dude.version>1.9.6</dude.version>
		<cfr.version>0.152</cfr.version>
		<ff.version>1.5.498.29</ff.version>
		<procyon.version>0.6.0</procyon.version>
		<junit.version>5.8.2</junit.version>
		<pico.version>4.6.3</pico.version>
		<jline.version>3.21.0</jline.version>
		<jp.version>3.24.2</jp.version>
		<jfx.version>18</jfx.version>
		<spotbugs.version>4.0.0</spotbugs.version>
		<spotbugs-mvn.version>3.1.12.2</spotbugs-mvn.version>
	</properties>
	<!-- Additional repo's -->
	<repositories>
		<!-- 3rd party repo, Forge -->
		<repository>
			<id>forge</id>
			<url>https://files.minecraftforge.net/maven</url>
		</repository>
		<!-- 3rd party repo, analyzer -->
		<repository>
			<id>jitpack.io</id>
			<url>https://jitpack.io</url>
		</repository>
		<!-- 3rd party repo, mirror -->
		<repository>
			<id>mirrors</id>
			<url>https://github.com/Col-E/jdk-tools-mirror/raw/master/repository/</url>
		</repository>
	</repositories>
	<!-- Dependencies, not jdk version specific -->
	<dependencies>
	<!-- Functionality -->
		<!--
		ASM: The "all" distribution is not updated as frequently
		and debug information is now included in these partial releases.
		* https://mvnrepository.com/artifact/org.ow2.asm/asm
		* https://mvnrepository.com/artifact/org.ow2.asm/asm-tree
		* https://mvnrepository.com/artifact/org.ow2.asm/asm-commons
		* https://mvnrepository.com/artifact/org.ow2.asm/asm-util
		* https://mvnrepository.com/artifact/org.ow2.asm/asm-analysis
		-->
		<dependency>
			<groupId>org.ow2.asm</groupId>
			<artifactId>asm</artifactId>
			<version>${asm.version}</version>
		</dependency>
		<dependency>
			<groupId>org.ow2.asm</groupId>
			<artifactId>asm-tree</artifactId>
			<version>${asm.version}</version>
		</dependency>
		<dependency>
			<groupId>org.ow2.asm</groupId>
			<artifactId>asm-util</artifactId>
			<version>${asm.version}</version>
		</dependency>
		<dependency>
			<groupId>org.ow2.asm</groupId>
			<artifactId>asm-commons</artifactId>
			<version>${asm.version}</version>
		</dependency>
		<dependency>
			<groupId>org.ow2.asm</groupId>
			<artifactId>asm-analysis</artifactId>
			<version>${asm.version}</version>
		</dependency>
		<dependency>
			<groupId>com.github.Col-E</groupId>
			<artifactId>SimAnalyzer</artifactId>
			<version>${analysis.version}</version>
		</dependency>
		<dependency>
			<groupId>com.github.Col-E</groupId>
			<artifactId>CAFED00D</artifactId>
			<version>${dude.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.clyze/jphantom -->
		<!-- Temporary mirror on Jitpack -->
		<dependency>
			<groupId>com.github.Col-E</groupId>
			<artifactId>jphantom</artifactId>
			<version>1.4.3</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.github.javaparser/javaparser-core -->
		<dependency>
			<groupId>com.github.javaparser</groupId>
			<artifactId>javaparser-core</artifactId>
			<version>${jp.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.github.javaparser/javaparser-symbol-solver-core -->
		<dependency>
			<groupId>com.github.javaparser</groupId>
			<artifactId>javaparser-symbol-solver-core</artifactId>
			<version>${jp.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.benf/cfr -->
		<dependency>
			<groupId>org.benf</groupId>
			<artifactId>cfr</artifactId>
			<version>${cfr.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.bitbucket.mstrobel/procyon-core -->
		<dependency>
			<groupId>org.bitbucket.mstrobel</groupId>
			<artifactId>procyon-core</artifactId>
			<version>${procyon.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.bitbucket.mstrobel/procyon-compilertools -->
		<dependency>
			<groupId>org.bitbucket.mstrobel</groupId>
			<artifactId>procyon-compilertools</artifactId>
			<version>${procyon.version}</version>
		</dependency>
		<!-- http://files.minecraftforge.net/maven/net/minecraftforge/fernflower/ -->
		<dependency>
			<groupId>net.minecraftforge</groupId>
			<artifactId>forgeflower</artifactId>
			<version>${ff.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.google.guava/guava -->
		<dependency>
			<groupId>com.google.guava</groupId>
			<artifactId>guava</artifactId>
			<version>31.1-jre</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.eclipsesource.minimal-json/minimal-json -->
		<dependency>
			<groupId>com.eclipsesource.minimal-json</groupId>
			<artifactId>minimal-json</artifactId>
			<version>0.9.5</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/io.github.soc/directories -->
		<dependency>
			<groupId>io.github.soc</groupId>
			<artifactId>directories</artifactId>
			<version>12</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.jsoup/jsoup -->
		<dependency>
			<groupId>org.jsoup</groupId>
			<artifactId>jsoup</artifactId>
			<version>1.14.3</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.plugface/plugface-core -->
		<dependency>
			<groupId>org.plugface</groupId>
			<artifactId>plugface-core</artifactId>
			<version>0.7.1</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/net.sourceforge.jregex/jregex -->
		<dependency>
			<groupId>net.sourceforge.jregex</groupId>
			<artifactId>jregex</artifactId>
			<version>1.2_01</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/com.atlassian.commonmark/commonmark -->
		<dependency>
			<groupId>org.commonmark</groupId>
			<artifactId>commonmark</artifactId>
			<version>0.18.2</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/net.sourceforge.cssparser/cssparser -->
		<dependency>
			<groupId>net.sourceforge.cssparser</groupId>
			<artifactId>cssparser</artifactId>
			<version>0.9.29</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.11.0</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.15</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/info.picocli/picocli -->
		<dependency>
			<groupId>info.picocli</groupId>
			<artifactId>picocli</artifactId>
			<version>${pico.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.jline/jline-terminal-jansi -->
		<dependency>
			<groupId>org.jline</groupId>
			<artifactId>jline-terminal-jna</artifactId>
			<version>${jline.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.jline/jline-builtins -->
		<dependency>
			<groupId>org.jline</groupId>
			<artifactId>jline-builtins</artifactId>
			<version>${jline.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/info.picocli/picocli-shell-jline3 -->
		<dependency>
			<groupId>info.picocli</groupId>
			<artifactId>picocli-shell-jline3</artifactId>
			<version>${pico.version}</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
			<version>1.2.10</version>
		</dependency>
		<!-- Tools -->
		<dependency>
			<groupId>com.sun</groupId>
			<artifactId>tools</artifactId>
			<version>8.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>com.sun</groupId>
			<artifactId>sa-jdi</artifactId>
			<version>8.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.openjfx/javafx-base -->
		<dependency>
			<groupId>org.openjfx</groupId>
			<artifactId>javafx-base</artifactId>
			<version>${jfx.version}</version>
			<scope>provided</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.openjfx/javafx-graphics -->
		<dependency>
			<groupId>org.openjfx</groupId>
			<artifactId>javafx-graphics</artifactId>
			<version>${jfx.version}</version>
			<scope>provided</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.openjfx/javafx-controls -->
		<dependency>
			<groupId>org.openjfx</groupId>
			<artifactId>javafx-controls</artifactId>
			<version>${jfx.version}</version>
			<scope>provided</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.openjfx/javafx-media -->
		<dependency>
			<groupId>org.openjfx</groupId>
			<artifactId>javafx-media</artifactId>
			<version>${jfx.version}</version>
			<scope>provided</scope>
		</dependency>
		<!--- Testing -->
		<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-api</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-engine</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-params</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.junit.platform/junit-platform-surefire-provider -->
		<dependency>
			<groupId>org.junit.platform</groupId>
			<artifactId>junit-platform-surefire-provider</artifactId>
			<version>1.3.2</version>
			<scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.hamcrest/hamcrest -->
		<dependency>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest</artifactId>
			<version>2.2</version>
			<scope>test</scope>
		</dependency>
	<!--- User interface -->
		<!-- https://mvnrepository.com/artifact/org.fxmisc.richtext/richtextfx -->
		<dependency>
			<groupId>org.fxmisc.richtext</groupId>
			<artifactId>richtextfx</artifactId>
			<!-- Newer versions depend on Flowless 0.6.5+ which requires Java 9, do not upgrade -->
			<version>0.10.6</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.fxmisc.wellbehaved/wellbehavedfx -->
		<dependency>
			<groupId>org.fxmisc.wellbehaved</groupId>
			<artifactId>wellbehavedfx</artifactId>
			<version>0.3.3</version>
		</dependency>
	</dependencies>
	<build>
		<resources>
			<resource>
				<directory>src/main/resources</directory>
				<excludes>
					<exclude>**/*.psd</exclude>
				</excludes>
			</resource>
		</resources>
		<plugins>
			<!-- Compiler version -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.9.0</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<compilerArgs>
						<arg>-Xlint:unchecked</arg>
					</compilerArgs>
				</configuration>
			</plugin>
			<!-- Maven version enforcement -->
			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>versions-maven-plugin</artifactId>
				<version>2.7</version>
				<configuration>
					<generateBackupPoms>false</generateBackupPoms>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-enforcer-plugin</artifactId>
				<version>3.0.0-M3</version>
				<executions>
					<execution>
					<id>enforce-maven</id>
					<goals>
						<goal>enforce</goal>
					</goals>
					<configuration>
						<rules>
						<requireMavenVersion>
							<version>3.1.0</version>
						</requireMavenVersion>
						</rules>
					</configuration>
					</execution>
				</executions>
			</plugin>
			<!-- Testing -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.0.0-M4</version>
				<configuration>
					<reuseForks>false</reuseForks>
					<forkCount>1</forkCount>
				</configuration>
			</plugin>
			<!-- Packaging -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>
				<version>3.3.0</version>
				<executions>
					<execution>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<archive>
						<manifest>
							<mainClass>me.coley.recaf.Recaf</mainClass>
						</manifest>
						<manifestEntries>
							<Premain-Class>me.coley.recaf.Agent</Premain-Class>
							<Agent-Class>me.coley.recaf.Agent</Agent-Class>
							<Can-Redefine-Classes>true</Can-Redefine-Classes>
							<Can-Retransform-Classes>true</Can-Retransform-Classes>
							<!-- JDK 9+ compat for RichTextFX -->
							<Add-Exports>javafx.graphics/com.sun.javafx.geom javafx.graphics/com.sun.javafx.text javafx.graphics/com.sun.javafx.scene.text</Add-Exports>
							<Add-Opens>javafx.graphics/javafx.scene.text javafx.graphics/com.sun.javafx.text</Add-Opens>
						</manifestEntries>
					</archive>
					<descriptorRefs>
						<descriptorRef>jar-with-dependencies</descriptorRef>
					</descriptorRefs>
					<finalName>${project.artifactId}-${project.version}-J8</finalName>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-source-plugin</artifactId>
				<version>3.2.1</version>
				<executions>
					<execution>
						<id>attach-sources</id>
						<goals>
							<goal>jar</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
			<!--
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-shade-plugin</artifactId>
				<version>3.2.2</version>
				<executions>
					<execution>
						<phase>package</phase>
						<goals>
							<goal>shade</goal>
						</goals>
						<configuration>
							<relocations>
								<relocation>
									<pattern>org.objectweb</pattern>
									<shadedPattern>lib.org.objectweb</shadedPattern>
								</relocation>
								<relocation>
									<pattern>javassit</pattern>
									<shadedPattern>lib.javassit</shadedPattern>
								</relocation>
							</relocations>
						</configuration>
					</execution>
				</executions>
			</plugin>
			-->
			<!--
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-javadoc-plugin</artifactId>
				<version>3.2.0</version>
				<executions>
					<execution>
						<id>attach-javadocs</id>
						<goals>
							<goal>jar</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
			-->
			<!-- Style enforcement -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-checkstyle-plugin</artifactId>
				<version>3.1.1</version>
				<executions>
					<execution>
						<phase>process-sources</phase>
						<goals>
							<goal>check</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<configLocation>checkstyle.xml</configLocation>
					<suppressionsLocation>checkstyle-suppressions.xml</suppressionsLocation>
					<suppressionsFileExpression>checkstyle.suppressions.file</suppressionsFileExpression>
					<consoleOutput>true</consoleOutput>
					<failsOnError>true</failsOnError>
					<failOnViolation>true</failOnViolation>
					<violationSeverity>warning</violationSeverity>
					<linkXRef>false</linkXRef>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-jar-plugin</artifactId>
				<version>3.2.0</version>
				<configuration>
					<excludes>
						<exclude>java/**</exclude>
					</excludes>
				</configuration>
			</plugin>
            <!-- Bug/quality enforcement
                 mvn spotbugs:spotbugs - create report
                 mvn spotbugs:gui - show gui
            -->
			<!-- Disabled due to complaints by users of it not resolving
			<plugin>
				<groupId>com.github.spotbugs</groupId>
				<artifactId>spotbugs-maven-plugin</artifactId>
				<version>${spotbugs-mvn.version}</version>
				<dependencies>
					<dependency>
						<groupId>com.github.spotbugs</groupId>
						<artifactId>spotbugs</artifactId>
						<version>${spotbugs.version}</version>
					</dependency>
				</dependencies>
			</plugin>
			-->
		</plugins>
	</build>
</project>

```

`src/main/java/java/lang/Module.java`:

```java
package java.lang;

import java.util.Set;

/**
 * Dummy java compatibility class
 *
 * @author Matt
 */
public abstract class Module {

  //CHECKSTYLE:OFF
  public ModuleLayer getLayer() { throw new UnsupportedOperationException(); }
  public Set<String> getPackages() { throw new UnsupportedOperationException(); }
  //CHECKSTYLE:ON
}

```

`src/main/java/java/lang/ModuleLayer.java`:

```java
package java.lang;

import java.util.Set;

/**
 * Dummy java compatibility class
 *
 * @author xxDark
 */
public abstract class ModuleLayer {

  //CHECKSTYLE:OFF
  public Set<Module> modules() {
    throw new UnsupportedOperationException();
  }
  public static ModuleLayer boot() {
    throw new UnsupportedOperationException();
  }
  //CHECKSTYLE:ON
}

```

`src/main/java/java/lang/module/ModuleFinder.java`:

```java
package java.lang.module;

import java.util.Set;

/**
 * Dummy java compatibility class
 *
 * @author xxDark
 */
public interface ModuleFinder {
    //CHECKSTYLE:OFF
    static ModuleFinder ofSystem() {
        throw new UnsupportedOperationException();
    }
    Set<ModuleReference> findAll();
    //CHECKSTYLE:ON
}

```

`src/main/java/java/lang/module/ModuleReader.java`:

```java
package java.lang.module;

import java.io.Closeable;
import java.io.IOException;
import java.util.stream.Stream;

/**
 * Dummy java compatibility class
 *
 * @author xxDark
 */
public interface ModuleReader extends Closeable {
    //CHECKSTYLE:OFF
    Stream<String> list() throws IOException;
    @Override
    void close() throws IOException;
    //CHECKSTYLE:ON
}

```

`src/main/java/java/lang/module/ModuleReference.java`:

```java
package java.lang.module;

import java.io.IOException;

/**
 * Dummy java compatibility class
 *
 * @author xxDark
 */
public abstract class ModuleReference {
    //CHECKSTYLE:OFF
    public abstract ModuleReader open() throws IOException;
    //CHECKSTYLE:ON
}

```

`src/main/java/me/coley/recaf/Agent.java`:

```java
package me.coley.recaf;

import me.coley.recaf.util.RecafClassLoader;

import java.lang.instrument.Instrumentation;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;

/**
 * Recaf loader.
 *
 * @author xxDark
 */
public final class Agent {
    /**
     * Start Recaf as a launch-argument Java agent.
     *
     * @param agentArgs
     * 		Agent arguments to pass to Recaf.
     * @param inst
     * 		Instrumentation instance.
     *
     * @throws Exception if any error occur.
     */
    public static void premain(String agentArgs, Instrumentation inst) throws Exception {
        agent(agentArgs, inst);
    }

    /**
     * Start Recaf as a dynamically attached Java agent.
     *
     * @param agentArgs
     * 		Agent arguments to pass to Recaf.
     * @param inst
     * 		Instrumentation instance.
     *
     * @throws Exception if any error occur.
     */
    public static void agentmain(String agentArgs, Instrumentation inst) throws Exception {
        agent(agentArgs, inst);
    }

    private static void agent(String args, Instrumentation inst) throws Exception {
        // Can't use any API here.
        URL source = Agent.class.getProtectionDomain().getCodeSource().getLocation();
        URLClassLoader loader = new RecafClassLoader(new URL[]{source});
        Class<?> recaf = loader.loadClass("me.coley.recaf.Recaf");
        Method m = recaf.getDeclaredMethod("agent", String.class, Instrumentation.class);
        m.setAccessible(true);
        m.invoke(null,  args, inst);
    }
}

```

`src/main/java/me/coley/recaf/Recaf.java`:

```java
package me.coley.recaf;

import io.github.soc.directories.BaseDirectories;
import me.coley.recaf.command.impl.Initializer;
import me.coley.recaf.control.Controller;
import me.coley.recaf.control.headless.HeadlessController;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.EntryLoaderProviderPlugin;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.Natives;
import me.coley.recaf.util.OSUtil;
import me.coley.recaf.util.VMUtil;
import me.coley.recaf.util.self.SelfDependencyPatcher;
import me.coley.recaf.util.self.SelfUpdater;
import me.coley.recaf.workspace.InstrumentationResource;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.Opcodes;
import picocli.CommandLine;

import java.lang.instrument.Instrumentation;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Locale;

import static me.coley.recaf.util.Log.*;

/**
 * Entry point &amp; version constant.
 *
 * @author Matt
 */
public class Recaf {
	public static final String VERSION = "2.21.13";
	public static final String DOC_URL = "https://col-e.github.io/Recaf-documentation/";
	public static final int ASM_VERSION = Opcodes.ASM9;
	private static Controller currentController;
	private static Workspace currentWorkspace;
	private static boolean initialized;
	private static boolean headless;
	private static Path configDir;

	/**
	 * Start Recaf.
	 *
	 * @param args
	 * 		Optional args.
	 */
	public static void main(String[] args) {
		Natives.loadAttach().ifPresent(t -> error(t, "Failed to load attach library."));
		init();
		launch(args);
	}

	private static void agent(String args, Instrumentation inst) {
		InstrumentationResource.instrumentation = inst;
		if (Recaf.class.getClassLoader() == ClassLoader.getSystemClassLoader()) {
			warn("Recaf was attached and loaded into system class loader," +
					" that is not a good thing!");
		}

		init();
		VMUtil.patchInstrumentation(inst);
		// Log that we are an agent
		info("Starting as agent...");
		// Add instrument launch arg
		if(args == null || args.trim().isEmpty())
			args = "--instrument";
		else if(!args.contains("--instrument"))
			args = args + ",--instrument";
		// Set instance
		// Start Recaf
		launch(args.split("[=,]"));
	}

	/**
	 * Run pre-launch initialization tasks.
	 */
	private static void init() {
		if (!initialized) {
			// Bypass JDK restrictions.
			VMUtil.patch();
			// Patch in dependencies
			SelfDependencyPatcher.ensureJavafxSupport();
			// Fix title bar not displaying in GTK systems
			System.setProperty("jdk.gtk.version", "2");
			// Fix for this dumb "feature" - https://mattryall.net/blog/the-infamous-turkish-locale-bug
			Locale.setDefault(Locale.US);
			// Show version & start
			info("Recaf-{}", VERSION);
			info("- Java: {} ({})", System.getProperty("java.version"), System.getProperty("java.vm.name"));
			initialized = true;
		}
	}

	/**
	 * Launch Recaf
	 */
	private static void launch(String[] args) {
		// Setup initializer, this loads command line arguments
		Initializer initializer = new Initializer();
		CommandLine commandLine = new CommandLine(initializer);
		commandLine.execute(args);
		if (commandLine.getUnmatchedArguments().size() > 0)
			return;

		headless = initializer.cli;
		loadPlugins();
		// Do version check
		SelfUpdater.setController(initializer.getController());
		SelfUpdater.setArgs(args);
		SelfUpdater.checkForUpdates();
		// Start the initializer's controller, starting Recaf
		initializer.startController();
	}

	/**
	 * Load plugins.
	 */
	private static void loadPlugins() {
		try {
			PluginsManager manager = PluginsManager.getInstance();
			manager.load();
			// Check for loaders, set the current loader to the first one found
			Collection<EntryLoaderProviderPlugin> loaders = manager.ofType(EntryLoaderProviderPlugin.class);
			if (!loaders.isEmpty())
				manager.setEntryLoader(loaders.iterator().next().create());
		} catch(NoClassDefFoundError noDef) {
			Log.error("An error occurred loading the plugins, failed class lookup: " +
					noDef.getMessage() + "\n - Is the plugin outdated?");
		} catch(Throwable t) {
			Log.error(t, "An error occurred loading the plugins");
		}
	}

	/**
	 * @param currentWorkspace
	 * 		New workspace.
	 */
	public static void setCurrentWorkspace(Workspace currentWorkspace) {
		Recaf.currentWorkspace = currentWorkspace;
	}

	/**
	 * Try not to use this too often. It would be best to be passed an instance of the workspace
	 * so things do not become statically dependent.
	 *
	 * @return Current workspace.
	 */
	public static Workspace getCurrentWorkspace() {
		return currentWorkspace;
	}

	/**
	 * @param controller
	 * 		New controller.
	 */
	public static void setController(Controller controller) {
		if (currentController != null)
			throw new IllegalStateException("Controller already set!");
		headless = controller instanceof HeadlessController;
		currentController = controller;
	}

	/**
	 * @return Recaf controller.
	 */
	public static Controller getController() {
		return currentController;
	}

	/**
	 * @return {@code true} when Recaf is running in headless mode.
	 */
	public static boolean isHeadless() {
		return headless;
	}

	/**
	 * @return Recaf's storage directory.
	 */
	public static Path getDirectory() {
		Path configDir = Recaf.configDir;
		if (configDir == null) {
			try {
				configDir = Recaf.configDir = Paths.get(BaseDirectories.get().configDir)
						.resolve("Recaf");
			} catch (Throwable t) {
				// BaseDirectories library has a powershell problem...
				// This should only affect windows
				if (OSUtil.getOSType() == OSUtil.WINDOWS) {
					configDir = Paths.get(System.getenv("APPDATA"), "Recaf");
				} else {
					throw new IllegalStateException("Failed to initialize Recaf directory");
				}
			}
		}
		return configDir;
	}

	/**
	 * @param subfolder
	 * 		Subfolder name.
	 *
	 * @return Subfolder in Recaf's storage directory.
	 */
	public static Path getDirectory(String subfolder) {
		return getDirectory().resolve(subfolder);
	}

	static {
		// Early set title window for Mac OS users
		System.setProperty("apple.awt.application.name", "Recaf");
	}
}

```

`src/main/java/me/coley/recaf/command/ControllerCommand.java`:

```java
package me.coley.recaf.command;

import me.coley.recaf.control.Controller;
import me.coley.recaf.workspace.Workspace;

/**
 * Base for commands that depend on the current workspace in a controller.
 *
 * @author Matt
 */
public abstract class ControllerCommand {
	private Controller controller;

	/**
	 * Set the command's controller.
	 *
	 * @param controller
	 * 		Controller with the workspace to operate on.
	 */
	public void setController(Controller controller) {
		this.controller = controller;
	}

	/**
	 * Ensures the command can run, throwing an exception otherwise.
	 */
	public void verify() {
		if (controller == null || controller.getWorkspace() == null)
			throw new IllegalStateException("Command required controller/workspace to run, but was not given any!");
	}

	/**
	 * @return Controller with the workspace to operate on.
	 */
	protected Controller getController() {
		return controller;
	}

	/**
	 * @return Workspace to operate on.
	 */
	protected Workspace getWorkspace() {
		return getController().getWorkspace();
	}
}

```

`src/main/java/me/coley/recaf/command/MetaCommand.java`:

```java
package me.coley.recaf.command;

import picocli.CommandLine;

/**
 * Command that requires the CommandLine context.
 *
 * @author Matt
 */
public abstract class MetaCommand {
	protected CommandLine context;

	/**
	 * @param context
	 * 		CommandLine context
	 */
	public void setContext(CommandLine context) {
		this.context = context;
	}
}

```

`src/main/java/me/coley/recaf/command/completion/ArchiveFileCompletions.java`:

```java
package me.coley.recaf.command.completion;

/**
 * Picocli completion for archives.
 *
 * @author Matt
 */
public class ArchiveFileCompletions extends FileCompletions {

	/**
	 * Picocli completion for archives.
	 */
	public ArchiveFileCompletions() {
		super(pathNamePattern(".+\\.(zip|jar)"));
	}
}

```

`src/main/java/me/coley/recaf/command/completion/FileCompletions.java`:

```java
package me.coley.recaf.command.completion;

import me.coley.recaf.util.RegexUtil;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Picocli completion for files.
 *
 * @author Matt
 */
public class FileCompletions implements Iterable<String> {
	private final Path currentDir;
	private final Predicate<Path> filter;

	/**
	 * Picocli completion for files.
	 */
	public FileCompletions() {
		this(p -> true);
	}

	/**
	 * Picocli completion for files.
	 *
	 * @param filter File inclusion filter.
	 */
	public FileCompletions(Predicate<Path> filter) {
		this(Paths.get(System.getProperty("user.dir")), filter);
	}

	/**
	 * Picocli completion for files.
	 *
	 * @param path Path to use.
	 * @param filter File inclusion filter.
	 */
	public FileCompletions(Path path, Predicate<Path> filter) {
		this.currentDir = path;
		this.filter = filter;
	}

	protected Collection<Path> files() {
		try {
			return Files.list(currentDir).collect(Collectors.toList());
		} catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}

	@Override
	public Iterator<String> iterator() {
		return files().stream().filter(filter).map(Path::getFileName).map(Path::toString).iterator();
	}

	/**
	 * Creates new path inclusion filter
	 * by it's name
	 *
	 * @param pattern path name pattern
	 * @return new filter
	 */
	protected static Predicate<Path> pathNamePattern(String pattern) {
		return f -> RegexUtil.matches(pattern, f.getFileName().toString().toLowerCase());
	}
}

```

`src/main/java/me/coley/recaf/command/completion/JavaFileCompletions.java`:

```java
package me.coley.recaf.command.completion;

/**
 * Picocli completion for java program files.
 *
 * @author Matt
 */
public class JavaFileCompletions extends FileCompletions {

	/**
	 * Picocli completion for java program files.
	 */
	public JavaFileCompletions() {
		super(pathNamePattern(".+\\.(class|jar)"));
	}
}

```

`src/main/java/me/coley/recaf/command/completion/WorkspaceFileCompletions.java`:

```java
package me.coley.recaf.command.completion;

/**
 * Picocli completion for supported workspace files.
 *
 * @author Matt
 */
public class WorkspaceFileCompletions extends FileCompletions {
	/**
	 * Picocli completion for supported workspace files.
	 */
	public WorkspaceFileCompletions() {
		super(pathNamePattern(".+\\.(class|jar|json)"));
	}
}

```

`src/main/java/me/coley/recaf/command/completion/WorkspaceNameCompletions.java`:

```java
package me.coley.recaf.command.completion;

import me.coley.recaf.Recaf;
import me.coley.recaf.workspace.Workspace;

import java.util.*;

/**
 * Picocli completion for names loaded in the current workspace.
 *
 * @author Matt
 */
public class WorkspaceNameCompletions implements Iterable<String> {
	@Override
	public Iterator<String> iterator() {
		Workspace workspace = Recaf.getCurrentWorkspace();
		if (workspace == null)
			return Collections.emptyIterator();
		return workspace.getClassNames().stream().sorted().iterator();
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Assemble.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.completion.WorkspaceNameCompletions;
import me.coley.recaf.metadata.Comments;
import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.util.ClassUtil;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import picocli.CommandLine;
import me.coley.recaf.workspace.Workspace;
import me.coley.recaf.Recaf;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ClassVisitorPlugin;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.Callable;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Command for assembling a method.
 *
 * @author Matt
 */
@CommandLine.Command(name = "assemble", description = "Assemble a method.")
public class Assemble extends ControllerCommand implements Callable<Assemble.Result> {
	@CommandLine.Parameters(index = "0",  description = "The class containing the method",
			completionCandidates = WorkspaceNameCompletions.class)
	public String className;
	@CommandLine.Parameters(index = "1",  description = "Method definition, name and descriptor. " +
			"For example 'method()V'", completionCandidates = WorkspaceNameCompletions.class)
	public String methodDef;
	@CommandLine.Parameters(index = "2", description = "File to load bytecode from")
	public File input;
	@CommandLine.Option(names = { "--debug" }, description = "Compile with debug info.", defaultValue = "true")
	public boolean debug = true;

	/**
	 * @return Assembly wrapper.
	 *
	 * @throws Exception
	 * 		<ul><li>IllegalStateException, cannot find class/method</li></ul>
	 * 		<ul><li>LineParseException, cannot compile bytecode</li></ul>
	 */
	@Override
	public Result call() throws Exception {
		if(className == null || className.isEmpty())
			throw new IllegalStateException("No class specified");
		if(!getWorkspace().getPrimary().getClasses().containsKey(className))
			throw new IllegalStateException("No class by the name '" + className +
					"' exists in the primary resource");
		int descStart = methodDef.indexOf("(");
		if (descStart == -1)
			throw new IllegalStateException("Invalid method def '" + methodDef + "'");
		// Get info - need method access
		ClassReader reader = getWorkspace().getClassReader(className);
		ClassNode node = ClassUtil.getNode(reader, ClassReader.SKIP_FRAMES);
		String name = methodDef.substring(0, descStart);
		String desc = methodDef.substring(descStart);
		MethodNode method = null;
		int methodIndex = -1;
		for (int i = 0; i < node.methods.size(); i++) {
			MethodNode mn = node.methods.get(i);
			if(mn.name.equals(name) && mn.desc.equals(desc)) {
				method = mn;
				methodIndex = i;
				break;
			}
		}
		if (method == null)
			throw new IllegalStateException("No method '" + methodDef + "' found in '" + className + "'");
		// Assemble method
		String code;
		try {
			code = FileUtils.readFileToString(input, UTF_8);
		} catch(IOException ex) {
			throw new IllegalStateException("Could not read from '" + input + "'");
		}
		ParseResult<RootAST> result = Parse.parse(code);
		MethodAssembler assembler = new MethodAssembler(className, getController());
		MethodNode generated = assembler.compile(result);
		// Replace method
		MethodNode old = node.methods.get(methodIndex);
		Comments.removeComments(old);
		ClassUtil.copyMethodMetadata(old, generated);
		node.methods.set(methodIndex, generated);
		//Finalize changes
		Workspace workspace = Recaf.getCurrentWorkspace();
		ClassWriter cw = workspace.createWriter(ClassWriter.COMPUTE_FRAMES);
		ClassVisitor visitor = cw;
		for (ClassVisitorPlugin visitorPlugin : PluginsManager.getInstance()
				.ofType(ClassVisitorPlugin.class)) {
			visitor = visitorPlugin.intercept(visitor);
		}
		node.accept(visitor);
		byte[] value = cw.toByteArray();
		workspace.getPrimary().getClasses().put(node.name, value);		
		// Return wrapper
		return new Result(node, generated);
	}

	/**
	 * Assemble command result wrapper.
	 */
	public static class Result {
		private final ClassNode owner;
		private final MethodNode method;

		private Result(ClassNode owner, MethodNode method) {
			this.owner =owner;
			this.method = method;
		}

		/**
		 * @return Class that holds the method.
		 */
		public ClassNode getOwner() {
			return owner;
		}

		/**
		 * @return The assembled method.
		 */
		public MethodNode getMethod() {
			return method;
		}
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Decompile.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.completion.WorkspaceNameCompletions;
import me.coley.recaf.decompile.DecompileImpl;
import me.coley.recaf.decompile.Decompiler;
import picocli.CommandLine;

import java.util.*;
import java.util.concurrent.Callable;

/**
 * Command for decompiling a class in the workspace.
 *
 * @author Matt
 */
@CommandLine.Command(name = "decompile", description = "Decompile a class in the workspace.")
public class Decompile extends ControllerCommand implements Callable<String> {
	@CommandLine.Option(names = {"--decompiler"}, description = "The decompiler implementation to use.",
			defaultValue = "CFR")
	public DecompileImpl decompiler = DecompileImpl.CFR;
	@CommandLine.Parameters(index = "0",  description = "The class to decompile",
			completionCandidates = WorkspaceNameCompletions.class)
	public String className;
	@CommandLine.Option(names = { "--options" },  description = "List of options to pass.", arity = "0..*")
	public Map<String, String> options = new HashMap<>();

	/**
	 * @return n/a
	 *
	 * @throws Exception
	 * 		<ul><li>IllegalStateException, cannot find class</li><li>Other, decompiler
	 * 		error</li></ul>
	 */
	@Override
	@SuppressWarnings("unchecked")
	public String call() throws Exception {
		if(className == null || className.isEmpty())
			throw new IllegalStateException("No class specified to decompile");
		if(!getWorkspace().hasClass(className))
			throw new IllegalStateException("No class by the name '" + className +
					"' exists in the workspace");
		String prefix = (getController().config().decompile().showName ?
				"// Decompiled with: " + decompiler.getNameAndVersion() + "\n" : "");
		Decompiler<?> impl = decompiler.create(getController());
		impl.getOptions().putAll((Map) options);
		return prefix + impl.decompile(className);
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Disassemble.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.completion.WorkspaceNameCompletions;
import me.coley.recaf.parse.bytecode.Disassembler;
import me.coley.recaf.util.ClassUtil;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import picocli.CommandLine;

import java.io.File;
import java.util.concurrent.Callable;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Command for disassembling a method.
 *
 * @author Matt
 */
@CommandLine.Command(name = "disassemble", description = "Disassemble a method.")
public class Disassemble extends ControllerCommand implements Callable<Disassemble.Result> {
	@CommandLine.Parameters(index = "0",  description = "The class containing the method",
			completionCandidates = WorkspaceNameCompletions.class)
	public String className;
	@CommandLine.Parameters(index = "1",  description = "Method definition, name and descriptor. " +
			"For example 'method()V'", completionCandidates = WorkspaceNameCompletions.class)
	public String methodDef;
	@CommandLine.Option(names = { "--destination" }, description = "File to write disassembled code to.")
	public File destination;

	/**
	 * @return Disassembly wrapper.
	 *
	 * @throws Exception
	 * 		<ul><li>IllegalStateException, cannot find class/method</li></ul>
	 */
	@Override
	public Result call() throws Exception {
		if(className == null || className.isEmpty())
			throw new IllegalStateException("No class specified");
		if(!getWorkspace().getPrimary().getClasses().containsKey(className))
			throw new IllegalStateException("No class by the name '" + className +
					"' exists in the primary resource");
		int descStart = methodDef.indexOf("(");
		if (descStart == -1)
			throw new IllegalStateException("Invalid method def '" + methodDef + "'");
		// Get method
		ClassReader reader = getWorkspace().getClassReader(className);
		ClassNode node = ClassUtil.getNode(reader, ClassReader.SKIP_FRAMES);
		String name = methodDef.substring(0, descStart);
		String desc = methodDef.substring(descStart);
		MethodNode method = null;
		for (MethodNode mn : node.methods)
			if(mn.name.equals(name) && mn.desc.equals(desc)) {
				method = mn;
				break;
			}
		if (method == null)
			throw new IllegalStateException("No method '" + methodDef + "' found in '" + className + "'");
		// Disassemble
		Result result = new Result(node, method, destination);
		if (destination != null)
			FileUtils.write(destination, result.disassembled, UTF_8);
		return result;
	}

	/**
	 * Disassemble command result wrapper.
	 */
	public static class Result {
		private final ClassNode owner;
		private final MethodNode method;
		private final String disassembled;
		private final File destination;

		private Result(ClassNode owner, MethodNode method, File destination) {
			this.owner =owner;
			this.method = method;
			this.destination = destination;
			Disassembler disassembler = new Disassembler();
			disassembled = disassembler.disassemble(method);
		}

		/**
		 * @return Class that holds the method.
		 */
		public ClassNode getOwner() {
			return owner;
		}

		/**
		 * @return The method that's been disassembled.
		 */
		public MethodNode getMethod() {
			return method;
		}

		/**
		 * @return The disassembled method code.
		 */
		public String getDisassembled() {
			return disassembled;
		}

		/**
		 * @return The file to store the disassembled code in.
		 */
		public File getDestination() {
			return destination;
		}
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Export.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ExportInterceptorPlugin;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.VMUtil;
import me.coley.recaf.workspace.ClassResource;
import me.coley.recaf.workspace.DirectoryResource;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.WarResource;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.ClassReader;
import picocli.CommandLine;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static me.coley.recaf.util.CollectionUtil.copySet;
import static me.coley.recaf.util.Log.info;

/**
 * Command for outputting workspace resources.
 *
 * @author Matt
 */
@CommandLine.Command(name = "export", description = "Export workspace to a class/jar.")
public class Export extends ControllerCommand implements Callable<Void> {
	@CommandLine.Parameters(index = "0",  description = "The output file.")
	public File output;
	@CommandLine.Option(names = { "--shadelibs" }, description = "Add library files to export.")
	public boolean shadeLibs;
	@CommandLine.Option(names = { "--compression" }, description = "Enable compression.")
	public boolean compress = true;

	/**
	 * @return n/a
	 *
	 * @throws Exception
	 * 		<ul><li>IOException, cannot write to output</li></ul>
	 */
	@Override
	public Void call() throws Exception {
		// Ensure parent directory exists
		File parentDir = output.getParentFile();
		if (parentDir != null && !parentDir.isDirectory() && !parentDir.mkdirs())
			throw new IOException("Failed to create parent directory for: " + output);
		JavaResource primary = getWorkspace().getPrimary();
		// Handle class exports
		boolean noShadeContent = !shadeLibs || getWorkspace().getLibraries().isEmpty();
		if (primary instanceof ClassResource && noShadeContent) {
			byte[] clazz = primary.getClasses().values().iterator().next();
			for (ExportInterceptorPlugin interceptor : PluginsManager.getInstance()
					.ofType(ExportInterceptorPlugin.class)) {
				clazz = interceptor.intercept(new ClassReader(clazz).getClassName(), clazz);
			}
			FileUtils.writeByteArrayToFile(output, clazz);
			info("Saved to {}", output.getName());
			return null;
		}
		// Collect content to put into export archive
		Map<String, byte[]> outContent = new TreeMap<>();
		if (shadeLibs)
			getWorkspace().getLibraries().forEach(lib -> put(outContent, lib));
		put(outContent, primary);
		// Calculate modified classes
		Set<String> modifiedClasses = new HashSet<>();
		Set<String> modifiedResources = new HashSet<>();
		modifiedClasses.addAll(primary.getDirtyClasses());
		modifiedClasses.addAll(primary.getClassHistory().entrySet().stream()
				.filter(e -> e.getValue().size() > 1)
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet()));
		modifiedResources.addAll(primary.getFileHistory().entrySet().stream()
				.filter(e -> e.getValue().size() > 1)
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet()));
		// Write to archive
		if (output.isDirectory() && primary instanceof DirectoryResource)
			writeDirectory(output, outContent);
		else
			writeArchive(compress, output, outContent);
		info("Saved to {}.\n - Modified classes: {}\n - Modified resources: {}",
				output.getName(), modifiedClasses.size(), modifiedResources.size());
		return null;
	}

	/**
	 * Writes a map to a directory.
	 *
	 * @param output
	 * 		File location of root directory.
	 * @param content
	 * 		Contents to write to location.
	 *
	 * @throws IOException
	 * 		When a file cannot be written to.
	 */
	public static void writeDirectory(File output, Map<String, byte[]> content) throws IOException {
		for (Map.Entry<String, byte[]> entry : content.entrySet()) {
			String name = entry.getKey();
			byte[] out = entry.getValue();
			for (ExportInterceptorPlugin interceptor : PluginsManager.getInstance()
					.ofType(ExportInterceptorPlugin.class)) {
				out = interceptor.intercept(name, out);
			}
			Path path = Paths.get(output.getAbsolutePath(), name);
			Files.createDirectories(path.getParent());
			Files.write(path, out);
		}
	}

	/**
	 * Writes a map to an archive.
	 *
	 * @param compress
	 * 		Enable zip compression.
	 * @param output
	 * 		File location of jar.
	 * @param content
	 * 		Contents to write to location.
	 *
	 * @throws IOException
	 * 		When the jar file cannot be written to.
	 */
	public static void writeArchive(boolean compress, File output, Map<String, byte[]> content) throws IOException {
		String extension = IOUtil.getExtension(output.toPath());
		// Use buffered streams, reduce overall file write operations
		OutputStream os = new BufferedOutputStream(Files.newOutputStream(output.toPath()), 1048576);
		try (ZipOutputStream jos = ("zip".equals(extension)) ? new ZipOutputStream(os) :
				/* Let's assume it's a jar */ new JarOutputStream(os)) {
			VMUtil.patchZipOutput(jos);
			PluginsManager pluginsManager = PluginsManager.getInstance();
			Set<String> dirsVisited = new HashSet<>();
			// Contents is iterated in sorted order (because 'archiveContent' is TreeMap).
			// This allows us to insert directory entries before file entries of that directory occur.
			CRC32 crc = new CRC32();
			for (Map.Entry<String, byte[]> entry : content.entrySet()) {
				String key = entry.getKey();
				byte[] out = entry.getValue();
				for (ExportInterceptorPlugin interceptor : pluginsManager.ofType(ExportInterceptorPlugin.class)) {
					out = interceptor.intercept(key, out);
				}
				// Write directories for upcoming entries if necessary
				// - Ugly, but does the job.
				if (key.contains("/")) {
					// Record directories
					String parent = key;
					List<String> toAdd = new ArrayList<>();
					do {
						parent = parent.substring(0, parent.lastIndexOf('/'));
						if (dirsVisited.add(parent)) {
							toAdd.add(0, parent + '/');
						} else break;
					} while (parent.contains("/"));
					// Put directories in order of depth
					for (String dir : toAdd) {
						jos.putNextEntry(new JarEntry(dir));
						jos.closeEntry();
					}
				}
				// Write entry content
				crc.reset();
				crc.update(out, 0, out.length);
				JarEntry outEntry = new JarEntry(key);
				outEntry.setMethod(compress ? ZipEntry.DEFLATED : ZipEntry.STORED);
				if (!compress) {
					outEntry.setSize(out.length);
					outEntry.setCompressedSize(out.length);
				}
				outEntry.setCrc(crc.getValue());
				jos.putNextEntry(outEntry);
				jos.write(out);
				jos.closeEntry();
			}
		}
	}

	private void put(Map<String, byte[]> content, JavaResource res) {
		content.putAll(res.getFiles());
		for(Map.Entry<String, byte[]> e : copySet(res.getClasses().entrySet())) {
			String name = e.getKey() + ".class";
			// War files have a required prefix
			if(res instanceof WarResource)
				name = WarResource.WAR_CLASS_PREFIX + name;
			content.put(name, e.getValue());
		}
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Help.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.MetaCommand;
import picocli.CommandLine;

import java.util.*;
import java.util.concurrent.Callable;

import static me.coley.recaf.util.Log.*;

/**
 * Command for quitting Recaf.
 *
 * @author Matt
 */
@CommandLine.Command(name = "help", description = "Prints usage for the specified command", helpCommand = true)
public class Help extends MetaCommand implements Callable<Void> {
	@CommandLine.Parameters(index = "0",  description = "The command to show usage for.", arity = "0..1")
	public String command;
	@CommandLine.Parameters(index = "1",  description = "The sub command name.", arity = "0..1", hidden = true)
	public String subcommand;

	/**
	 * @return n/a
	 *
	 * @throws Exception
	 * 		<ul><li>IllegalStateException, help command missing cli context</li></ul>
	 */
	@Override
	public Void call() throws Exception {
		// Get root command
		String key = command;
		CommandLine cmd = context.getSubcommands().get(key);
		// Check if subcommand is specified
		if (cmd != null && subcommand != null) {
			key += " " + subcommand;
			cmd = cmd.getSubcommands().get(subcommand);
		}
		// Check if fetched command exists, if so print usage
		// Otherwise list all commands
		if (cmd != null)
			cmd.usage(context.getOut());
		else {
			StringBuilder sb = new StringBuilder();
			if (command != null)
				sb.append("No such command: '").append(key).append("'\n");
			else
				sb.append("Specify a command to see it's usage.\n");
			sb.append("The existing commands are:");
			// Sort commands alphabetically
			List<CommandLine> list = new ArrayList<>(context.getSubcommands().values());
			list.sort(Comparator.comparing(CommandLine::getCommandName));
			for (CommandLine com : list)
				sb.append("\n - ").append(com.getCommandName());
			info(sb.toString());
		}
		return null;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Initializer.java`:

```java
package me.coley.recaf.command.impl;

import javafx.scene.control.Alert;
import javafx.scene.control.ButtonBar;
import javafx.scene.control.ButtonType;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.Controller;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.control.headless.HeadlessController;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.util.self.SelfUpdater;
import me.coley.recaf.workspace.InstrumentationResource;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.net.URI;
import java.nio.file.Path;
import java.util.Optional;
import java.util.Scanner;

/**
 * Command line initializer for Recaf, invoked from the main method.
 * Sets up the controller to use then starts it.
 *
 * @author Matt
 */
@Command(
		name = "Recaf",
		version = Recaf.VERSION,
		description = "Recaf: A modern java bytecode editor.",
		mixinStandardHelpOptions = true)
public class Initializer implements Runnable {
	@Option(names = {"--input" }, description = "The input file to load. " +
			"Supported types are: class, jar, json")
	public Path input;
	@Option(names = {"--script" }, description = "Script file to load for cli usage")
	public Path script;
	@Option(names = { "--cli" }, description = "Run Recaf via CLI")
	public boolean cli;
	@Option(names = { "--instrument" }, description = "Indicates Recaf has been invoked as an agent")
	public boolean instrument;
	@Option(names = { "--noupdate" }, description = "Disable update checking entirely")
	public boolean noUpdates;
	//
	private Controller controller;

	@Override
	public void run() {
		// Disable update check
		if (noUpdates)
			SelfUpdater.disable();
		// Setup controller
		boolean headless = isHeadless();
		if (headless)
			controller = new HeadlessController(input, script);
		else
			controller = new GuiController(input);
		controller.setup();
		Recaf.setController(controller);
		if (instrument)
			InstrumentationResource.setup(controller);
		else if (controller.config().backend().firstTime && script == null)
			promptFirstTime();
	}

	/**
	 * Start the controller.
	 */
	public void startController() {
		controller.run();
	}

	/**
	 * Show documentation nag.
	 */
	private void promptFirstTime() {
		// Unmark value
		controller.config().backend().firstTime = false;
		// Determine how to show prompt
		if (isHeadless()) {
			Log.info(LangUtil.translate("misc.firsttime.cli"));
			String line = new Scanner(System.in).nextLine();
			if (line != null) {
				line = line.trim().toLowerCase();
				if (line.contains("ok") | line.contains("y"))
					openDoc();
			}
		} else {
			// Wait a bit so the platform gets loaded, then show an alert dialog
			ThreadUtil.runJfxDelayed(2000, () -> {
				ButtonType btnYes = new ButtonType(LangUtil.translate("misc.yes"), ButtonBar.ButtonData.YES);
				ButtonType btnNo = new ButtonType(LangUtil.translate("misc.no"), ButtonBar.ButtonData.NO);
				Alert alert = new Alert(Alert.AlertType.INFORMATION,
						LangUtil.translate("misc.firsttime.gui"), btnYes, btnNo);
				alert.setTitle(LangUtil.translate("misc.firsttime.gui.title"));
				Optional<ButtonType> result = alert.showAndWait();
				if (result.isPresent() && result.get().equals(btnYes))
					openDoc();
			});
		}
	}

	private void openDoc() {
		try {
			UiUtil.showDocument(URI.create(Recaf.DOC_URL));
		} catch(Exception ex) {
			Log.error(ex, "Failed to open documentation url");
		}
	}

	/**
	 * @return {@code true} when Recaf should not allocate a UI.
	 */
	private boolean isHeadless() {
		return cli || script != null;
	}

	/**
	 * @return The controller to execute Recaf with.
	 */
	public Controller getController() {
		return controller;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/LoadWorkspace.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.completion.*;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.ShortcutUtil;
import me.coley.recaf.workspace.*;
import picocli.CommandLine;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.concurrent.Callable;

import static me.coley.recaf.util.Log.*;

/**
 * Command for loading the a workspace from a file.
 *
 * @author Matt
 */
@CommandLine.Command(name = "loadworkspace", description = "Loads a workspace from a resource or workspace config.")
public class LoadWorkspace implements Callable<Workspace> {
	@CommandLine.Parameters(index = "0",  description = "The file to load. " +
			"Supported types are: class, jar, json", completionCandidates = WorkspaceFileCompletions.class)
	public Path input;
	@CommandLine.Option(names = { "--sources" },  description = "Archive containing sources of the resource.",
			completionCandidates = ArchiveFileCompletions.class)
	public Path sources;
	@CommandLine.Option(names = { "--docs" },  description = "Archive containing javadocs of the resource.",
			completionCandidates = ArchiveFileCompletions.class)
	public Path javadoc;
	@CommandLine.Option(names = { "--lazy" },  description = "Don't immediately load the workspace content.")
	public boolean lazy;
	@CommandLine.Option(names = "--skip")
	public List<String> skippedPrefixes;
	private String status = "...";

	@Override
	public Workspace call() throws Exception {
		status = LangUtil.translate("ui.load.resolve");
		String name = input.getFileName().toString().toLowerCase();
		// Handle symbolic links
		int symLevel = 0;
		if (ShortcutUtil.isPotentialValidLink(input)) {
			input = Paths.get(new ShortcutUtil(input).getRealFilename());
			name = input.getFileName().toString().toLowerCase();
		}
		while (Files.isSymbolicLink(input) && symLevel < 5) {
			input = Files.readSymbolicLink(input);
			symLevel++;
		}
		String ext;
		if (Files.isDirectory(input)) {
			ext = "dir";
		} else {
			ext = IOUtil.detectExtension(input);
		}
		JavaResource resource;
		switch(ext) {
			case "class":
				status = LangUtil.translate("ui.load.initialize.resource");
				resource = new ClassResource(input);
				break;
			case "zip":
			case "jar":
				status = LangUtil.translate("ui.load.initialize.resource");
				resource = new JarResource(input);
				break;
			case "war":
				status = LangUtil.translate("ui.load.initialize.resource");
				resource = new WarResource(input);
				break;
			case "dir":
				status = LangUtil.translate("ui.load.initialize.resource");
				resource = new DirectoryResource(input);
				break;
			case "json":
				status = LangUtil.translate("ui.load.initialize.workspace");
				// Represents an already existing workspace, so we can parse and return that here
				Workspace workspace = null;
				try {
					workspace = WorkspaceIO.fromJson(input);
				} catch(Exception ex) {
					throw new IllegalArgumentException("Failed to parse workspace config '" + name + "'", ex);
				}
				workspace.analyzePhantoms();
				// Initial load classes & files
				if (!lazy) {
					status = LangUtil.translate("ui.load.loading");
					workspace.getPrimary().getClasses();
					workspace.getPrimary().getFiles();
				}
				info("Loaded workspace from: {}", input.getFileName());
				return workspace;
			default:
				throw new IllegalArgumentException("Unsupported file type '" + ext + "'");
		}
		//
		if (skippedPrefixes != null)
			resource.setSkippedPrefixes(skippedPrefixes);
		// Initial load classes & files
		if (!lazy) {
			status = LangUtil.translate("ui.load.loading");
			resource.setPrimary(true);
			resource.getClasses();
			resource.getFiles();
		}
		// Load sources/javadoc if present
		status = LangUtil.translate("ui.load.srcdocs");
		if (sources != null && Files.exists(sources))
			resource.setClassSources(sources);
		if (javadoc != null && Files.exists(javadoc))
			resource.setClassDocs(javadoc);
		// Create workspace
		Workspace workspace = new Workspace(resource);
		workspace.analyzePhantoms();
		status = LangUtil.translate("ui.load.done");
		info("Loaded workspace from: {}", input.getFileName());
		return workspace;
	}

	/**
	 * Used for UI progress reporting.
	 *
	 * @return Current load status.
	 */
	public String getStatus() {
		return status;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Quit.java`:

```java
package me.coley.recaf.command.impl;

import picocli.CommandLine;

import java.util.concurrent.Callable;

/**
 * Command for quitting Recaf.
 *
 * @author Matt
 */
@CommandLine.Command(name = "quit", description = "Closes Recaf")
public class Quit implements Callable<Void> {
	@CommandLine.Option(names = { "--force" },  description = "Immediately/forcefully exit.")
	public boolean force;

	@Override
	public Void call() throws Exception {
		// Hard exit
		if (force)
			System.exit(0);
		// Handled externally
		return null;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Remap.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.completion.FileCompletions;
import me.coley.recaf.mapping.MappingImpl;
import me.coley.recaf.mapping.Mappings;
import me.coley.recaf.workspace.JavaResource;
import org.objectweb.asm.ClassReader;
import picocli.CommandLine;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

import static me.coley.recaf.util.Log.info;
import static me.coley.recaf.util.Log.debug;

/**
 * Command for applying mappings.
 *
 * @author Matt
 */
@CommandLine.Command(name = "remap", description = "Apply mappings to the workspace.")
public class Remap extends ControllerCommand implements Callable<Void> {
	@CommandLine.Parameters(index = "0",  description = "The mapping type.", arity = "0..1")
	public MappingImpl mapper = MappingImpl.SIMPLE;
	@CommandLine.Parameters(index = "1",  description = "The mapping file.",
			completionCandidates = FileCompletions.class)
	public Path mapFile;
	@CommandLine.Option(names = "--noDebug", description = "Clear debug info (variable names/generics).")
	public boolean noDebug;
	@CommandLine.Option(names = "--allowLookup",
			description = "Allow hierarchy lookups for inheritance supported mapping. " +
					"Disable for faster mapping if hierarchy is accounted for in the mapping file.",
			defaultValue = "true")
	public boolean lookup = true;

	/**
	 * @return n/a
	 *
	 * @throws Exception
	 * 		<ul><li>IllegalStateException, Invalid map file given</li></ul>
	 */
	@Override
	public Void call() throws Exception {
		if(mapFile == null || !Files.exists(mapFile))
			throw new IllegalStateException("No mapping file provided!");
		// Apply
		Mappings mappings = mapper.create(mapFile, getWorkspace());
		mappings.setClearDebugInfo(noDebug);
		mappings.setCheckFieldHierarchy(lookup);
		mappings.setCheckMethodHierarchy(lookup);

		JavaResource primary = getWorkspace().getPrimary();
		Map<String, byte[]> mapped = mappings.accept(primary);

		byte[] manifestBytes = primary.getFiles().get("META-INF/MANIFEST.MF");
		if (manifestBytes != null) {
			Manifest manifest = new Manifest(new ByteArrayInputStream(manifestBytes));
			Attributes attr = manifest.getMainAttributes();
			if (!attr.isEmpty()) {
				String mainClass = attr.getValue("Main-Class").replaceAll("\\.", "/");
				if (mapped.containsKey(mainClass)) {
					String mappedName = new ClassReader(mapped.get(mainClass))
							.getClassName().replaceAll("/", "\\.");
					debug("Remapping Main-Class attribute in MANIFEST.MF from '{}' to '{}'", mainClass, mappedName);
					attr.putValue("Main-Class", mappedName);
					ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
					manifest.write(outputStream);
					primary.getFiles().put("META-INF/MANIFEST.MF", outputStream.toByteArray());
					outputStream.close();
				}
			}
		}

		// Log
		StringBuilder sb = new StringBuilder("Classes updated: " + mapped.size());
		mapped.forEach((old, value) -> {
			ClassReader reader = new ClassReader(value);
			String rename = reader.getClassName();
			if (!old.equals(rename))
				sb.append("\n - ").append(old).append(" => ").append(rename);
		});
		info(sb.toString());
		return null;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Run.java`:

```java
package me.coley.recaf.command.impl;

import picocli.CommandLine;

import java.util.concurrent.Callable;

/**
 * Command for executing external commands from Recaf.
 * Useful for scripting when dealing with external tools.
 *
 * @author Matt
 */
@CommandLine.Command(name = "run", description = "Run an external command.")
public class Run implements Callable<Process> {
	@CommandLine.Parameters(index = "0",  description = "Command to run.")
	public String command;
	@CommandLine.Option(names = { "--waitComplete" },  description = "Wait until the command process finishes.")
	public boolean waitUntilCompletion;

	/**
	 * @return Externally run process.
	 *
	 * @throws Exception
	 * 		<ul><li>IOException, misc process i/o error</li></ul>
	 * 		<ul><li>SecurityException, not allowed to run 'exec'</li></ul>
	 */
	@Override
	public Process call() throws Exception {
		if (command == null || command.isEmpty())
			throw new IllegalArgumentException("No command has been given!");
		Process process = Runtime.getRuntime().exec(command);
		while(waitUntilCompletion && process.isAlive())
			Thread.sleep(100);
		return process;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Search.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.MetaCommand;
import me.coley.recaf.command.completion.WorkspaceNameCompletions;
import me.coley.recaf.search.*;
import picocli.CommandLine;

import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.Callable;
import java.util.stream.Collectors;

import static me.coley.recaf.util.Log.*;

/**
 * Unused command, see sub-commands.
 *
 * @author Matt
 */
@CommandLine.Command(name = "search", description = "Base search command.",
		subcommands = {
				Search.ClassName.class,
				Search.ClassInheritance.class,
				Search.Member.class,
				Search.ClassUsage.class,
				Search.MemberUsage.class,
				Search.Text.class,
				Search.Value.class,
				Search.Disass.class
		}
)
public class Search extends MetaCommand implements Callable<Void> {
	@Override
	public Void call() throws Exception {
		StringBuilder sb = new StringBuilder();
		sb.append("Sub-commands for search:");
		for (CommandLine sub : context.getSubcommands().values()) {
			String name =  sub.getCommandName();
			String[] descs = sub.getCommandSpec().usageMessage().description();
			String desc = descs.length > 0 ? descs[0] : "?";
			String args = sub.getCommandSpec().args().stream()
					.map(CommandLine.Model.ArgSpec::paramLabel).collect(Collectors.joining(" "));
			sb.append("\n - ").append(name).append(" ").append(args).append("\n\t").append(desc);
		}
		error(sb.toString());
		return null;
	}

	/**
	 * Command for searching for class declarations.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "class", description = "Find class definitions.")
	public static class ClassName extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The string matching mode.")
		public StringMatchMode mode;
		@CommandLine.Parameters(index = "1",  description = "The name to search for.",
				completionCandidates = WorkspaceNameCompletions.class)
		public String name;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.skipDebug().skipCode()
					.query(new ClassNameQuery(name, mode))
					.build();
		}
	}

	/**
	 * Command for searching for class inheritance.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "classtree", description = "Find classes extending the given name.")
	public static class ClassInheritance extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The class name to search for.",
				completionCandidates = WorkspaceNameCompletions.class)
		public String name;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.skipDebug().skipCode()
					.query(new ClassInheritanceQuery(getWorkspace(), name))
					.build();
		}
	}

	/**
	 * Command for searching for member declarations.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "member", description = "Find member definitions.")
	public static class Member extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The string matching mode.")
		public StringMatchMode mode;
		@CommandLine.Parameters(index = "1",  description = "The class containing the member.",
				completionCandidates = WorkspaceNameCompletions.class)
		public String owner;
		@CommandLine.Parameters(index = "2",  description = "The member name.")
		public String name;
		@CommandLine.Parameters(index = "3",  description = "The member descriptor.")
		public String desc;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.skipDebug().skipCode()
					.query(new MemberDefinitionQuery(owner, name, desc, mode))
					.build();
		}
	}

	/**
	 * Command for searching for member references.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "cref", description = "Find class references.")
	public static class ClassUsage extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The class name.",
				completionCandidates = WorkspaceNameCompletions.class)
		public String name;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.query(new ClassReferenceQuery(name))
					.build();
		}
	}

	/**
	 * Command for searching for member references.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "mref", description = "Find member references.")
	public static class MemberUsage extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The string matching mode.")
		public StringMatchMode mode;
		@CommandLine.Option(names = "--owner", description = "The class name.",
				completionCandidates = WorkspaceNameCompletions.class)
		public String owner;
		@CommandLine.Option(names = "--name", description = "The member name.")
		public String name;
		@CommandLine.Option(names = "--desc", description = "The member descriptor.")
		public String desc;

		@Override
		public SearchCollector call() throws Exception {
			if(owner == null && name == null && desc == null) {
				error("Please give at least one parameter.");
				return new SearchCollector(getWorkspace(), Collections.emptyList());
			}
			return SearchBuilder.in(getWorkspace())
					.skipDebug()
					.query(new MemberReferenceQuery(owner, name, desc, mode))
					.build();
		}
	}

	/**
	 * Command for searching for string constants.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "string", description = "Find strings.")
	public static class Text extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The string matching mode.")
		public StringMatchMode mode;
		@CommandLine.Parameters(index = "1", description = "The text to match.")
		public String text;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.skipDebug()
					.query(new StringQuery(text, mode))
					.build();
		}
	}

	/**
	 * Command for searching for value constants.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "value", description = "Find value constants.")
	public static class Value extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The value to search for.")
		public Number value;

		@Override
		public SearchCollector call() throws Exception {
			return SearchBuilder.in(getWorkspace())
					.skipDebug()
					.query(new ValueQuery(value))
					.build();
		}
	}

	/**
	 * Command for searching for disassembled method code.
	 *
	 * @author Matt
	 */
	@CommandLine.Command(name = "code", description = "Find code matches.")
	public static class Disass extends ControllerCommand implements Callable<SearchCollector> {
		@CommandLine.Parameters(index = "0",  description = "The string matching mode.")
		public StringMatchMode mode;
		@CommandLine.Parameters(index = "1", description = "The lines of code to match, separated by ':'.")
		public String text;

		@Override
		public SearchCollector call() throws Exception {
			// Skip debug is used here so that variable names don't interfere with searching.
			// Using pure indices instead like "ALOAD 4" instead of "ALOAD varName"
			// ... Although it will still always o "ALOAD this" where possible
			return SearchBuilder.in(getWorkspace())
					.skipDebug()
					.query(new InsnTextQuery(Arrays.asList(text.split(":")), mode))
					.build();
		}
	}
}

```

`src/main/java/me/coley/recaf/command/impl/Wait.java`:

```java
package me.coley.recaf.command.impl;

import picocli.CommandLine;

import java.util.concurrent.Callable;

/**
 * Command for delaying Recaf.
 * Useful for scripting when dealing with external tools.
 *
 * @author Matt
 */
@CommandLine.Command(name = "wait", description = "Delays Recaf")
public class Wait implements Callable<Void> {
	@CommandLine.Parameters(index = "0",  description = "Milliseconds to wait for.")
	public long millis;

	@Override
	public Void call() throws Exception {
		Thread.sleep(millis);
		return null;
	}
}

```

`src/main/java/me/coley/recaf/command/impl/WorkspaceInfo.java`:

```java
package me.coley.recaf.command.impl;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.workspace.*;
import picocli.CommandLine;

import java.util.concurrent.Callable;
import java.util.stream.Collectors;

import static me.coley.recaf.util.Log.*;

/**
 * Command for loading the a workspace from a file.
 *
 * @author Matt
 */
@CommandLine.Command(name = "workspaceinfo", description = "Print information about the current workspace.")
public class WorkspaceInfo extends ControllerCommand implements Callable<Void> {

	@Override
	public Void call() throws Exception {
		StringBuilder sb = new StringBuilder();
		// Print primary resource
		JavaResource primary = getWorkspace().getPrimary();
		append(sb, primary);
		// Print library resources
		int count = getWorkspace().getLibraries().size();
		sb.append("\nLibraries: ").append(count);
		if (count > 0) {
			sb.append("\n\n");
			for (JavaResource res : getWorkspace().getLibraries()) {
				append(sb, primary);
				sb.append("\n");
			}
		}
		info(sb.toString());
		return null;
	}

	private void append(StringBuilder sb, JavaResource resource) {
		sb.append(resource.getKind().name()).append(" : ");
		switch(resource.getKind()) {
			case CLASS:
			case JAR:
			case WAR:
			case DIRECTORY:
				sb.append(((FileSystemResource)resource).getPath().normalize());
				break;
			case MAVEN:
				sb.append(((MavenResource)resource).getCoords());
				break;
			case URL:
				sb.append(((UrlResource)resource).getUrl());
				break;
			case INSTRUMENTATION:
				sb.append("Instrumentation");
				break;
			case DEBUGGER:
				sb.append("Debugger");
				break;
			default:
				throw new IllegalStateException("Unknown resource kind: " + resource.getKind().name());
		}
		sb.append("\n- classes: ").append(resource.getClasses().size());
		for (String name : resource.getClasses().keySet().stream().sorted().collect(Collectors.toList()))
			sb.append("\n\t- ").append(name);
		sb.append("\n- files: ").append(resource.getFiles().size());
		for (String name : resource.getFiles().keySet().stream().sorted().collect(Collectors.toList()))
			sb.append("\n\t- ").append(name);
		sb.append("\n");
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavacCompiler.java`:

```java
package me.coley.recaf.compiler;

import com.google.common.collect.Sets;
import me.coley.recaf.Recaf;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.Resource;
import me.coley.recaf.util.VMUtil;
import me.coley.recaf.workspace.JavaResource;

import javax.tools.*;
import javax.tools.JavaFileObject.Kind;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * In memory java-to-bytecode compiler.
 *
 * @author Matt
 */
public class JavacCompiler {
	private List<String> pathItems;
	private final Map<String, VirtualJavaFileObject> unitMap = new HashMap<>();
	private final JavacOptions options = new JavacOptions();
	private final List<JavaResource> classpath = new ArrayList<>();
	private DiagnosticListener<VirtualJavaFileObject> listener;

	/**
	 * @return Success of compilation. Use {@link #setCompileListener(DiagnosticListener)}
	 * to receive information about failures.
	 */
	@SuppressWarnings("unchecked")
	public boolean compile() {
		JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
		if (javac == null)
			throw new IllegalStateException("No Java compiler is installed. Please use a JDK context when running.");
		// file manager, used so that the unit map can have their definitions updated
		// after compilation.
		DiagnosticListener<? super JavaFileObject> lll = (DiagnosticListener<? super JavaFileObject>) (Object) listener;
		JavaFileManager fmFallback = javac.getStandardFileManager(lll, Locale.getDefault(), UTF_8);
		JavaFileManager fm = new VirtualFileManager(fmFallback);
		// Add options
		List<String> args = new ArrayList<>();
		args.addAll(Arrays.asList("-classpath", getClassPathText()));
		if (VMUtil.getVmVersion() >= 9) {
			// For Java 9 and later, use release instead of the source/target pair
			args.addAll(Arrays.asList("--release", String.valueOf(this.options.getTarget().version())));
		} else {
			args.addAll(Arrays.asList("-source", this.options.getTarget().toString()));
			args.addAll(Arrays.asList("-target", this.options.getTarget().toString()));
		}
		args.add(this.options.toOption());
		// create task
		try {
			JavaCompiler.CompilationTask task = javac.getTask(null, fm, lll, args, null, unitMap.values());
			Boolean b = task.call();
			return b != null && b;
		} catch (RuntimeException e) {
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * @return Generated classpath.
	 */
	private String getClassPathText() {
		// ensure the default path is included
		String pathDefault = System.getProperty("java.class.path");
		StringBuilder sb = new StringBuilder(pathDefault);
		char separator = File.pathSeparatorChar;
		// add extra dependencies
		if (pathItems != null) {
			for (String path : pathItems)
				sb.append(separator).append(path);
		}

		try {
			Stream<Path> paths = Files.walk(getCompilerClasspathDirectory());
			paths.filter(p -> p.toString().toLowerCase().endsWith(".jar"))
					.filter(p -> p.toFile().length() < 10_000_000)
					.forEach(p -> sb.append(separator).append(IOUtil.toString(p)));
		} catch (IOException e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	/**
	 * @return Directory to contain additional classpath items.
	 */
	public static Path getCompilerClasspathDirectory() {
		Path path = Recaf.getDirectory("classpath").resolve("compiler");
		if (!Files.exists(path)) {
			try {
				Files.createDirectories(path);
			} catch (IOException ex) {
				// Shouldn't occur
				Log.error("Failed to create compiler ext directory", ex);
				throw new IllegalStateException(ex);
			}
		}
		return path;
	}

	/**
	 * Add class to compilation process.
	 *
	 * @param className
	 * 		Name of class to compile.
	 * @param content
	 * 		Source code of class.
	 */
	public void addUnit(String className, String content) {
		unitMap.put(className, new VirtualJavaFileObject(className, content));
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Bytecode of class.
	 */
	public byte[] getUnitCode(String name) {
		VirtualJavaFileObject file = unitMap.get(name);
		if (file == null)
			return null;
		return file.getBytecode();
	}

	/**
	 * @return Map of class names to bytecode.
	 */
	public Map<String, byte[]> getUnits() {
		return unitMap.entrySet().stream()
				.collect(Collectors.toMap(Map.Entry::getKey, v -> v.getValue().getBytecode()));
	}

	/**
	 * @return Compiler options.
	 */
	public JavacOptions options() {
		return options;
	}

	/**
	 * @param pathItems
	 * 		Items to use for the classpath in compilation.
	 */
	public void setClassPath(List<String> pathItems) {
		this.pathItems = pathItems;
	}

	/**
	 * @param listener
	 * 		Listener that receives compiler error information.
	 */
	public void setCompileListener(DiagnosticListener<VirtualJavaFileObject> listener) {
		this.listener = listener;
	}

	/**
	 * Registers resources as a classpath items.
	 *
	 * @param resources
	 * 		Resources to include.
	 */
	public void addToClassPath(Iterable<? extends JavaResource> resources) {
		List<JavaResource> classpath = this.classpath;
		resources.forEach(classpath::add);
	}

	/**
	 * Registers {@link Resource} as a classpath item.
	 *
	 * @param resource
	 * 		Resource to include.
	 */
	public void addToClassPath(JavaResource resource) {
		classpath.add(resource);
	}

	/**
	 * File manager extension for handling updates to java file object's output stream.
	 * Additionally, registers inner classes as new files.
	 */
	private final class VirtualFileManager extends ForwardingJavaFileManager<JavaFileManager> {

		private VirtualFileManager(JavaFileManager fallback) {
			super(fallback);
		}

		@Override
		public Iterable<JavaFileObject> list(Location location, String packageName,
											 Set<Kind> kinds, boolean recurse) throws IOException {
			Iterable<JavaFileObject> list = super.list(location, packageName, kinds, recurse);
			if ("CLASS_PATH".equals(location.getName()) && kinds.contains(Kind.CLASS)) {
				String formatted = packageName.isEmpty() ? "" : packageName.replace('.', '/') + '/';
				Set<JavaFileObject> result = Sets.newHashSet(list);
				Predicate<String> check;
				if (recurse) {
					check = s -> s.startsWith(formatted);
				} else {
					check = s -> s.startsWith(formatted)
							&& s.indexOf('/', formatted.length()) == -1;
				}
				classpath.stream()
						.flatMap(x -> x.getClasses().entrySet().stream())
						.filter(e -> check.test(e.getKey()))
						.forEach(x -> result.add(new ResourceVirtualJavaFileObject(x.getKey(),
								x.getValue(), Kind.CLASS)));
				return result;
			}
			return list;
		}

		@Override
		public String inferBinaryName(Location location, JavaFileObject file) {
			if (file instanceof ResourceVirtualJavaFileObject && file.getKind() == Kind.CLASS) {
				return ((ResourceVirtualJavaFileObject) file).getResourceName().replace('/', '.');
			}
			return super.inferBinaryName(location, file);
		}

		@Override
		public JavaFileObject getJavaFileForOutput(Location location, String name, Kind
				kind, FileObject sibling) throws IOException {
			String internal = name.replace('.', '/');
			VirtualJavaFileObject obj = unitMap.get(internal);
			// Unknown class, assumed to be an inner class.
			// add to the unit map so it can be fetched.
			if (obj == null) {
				obj = new VirtualJavaFileObject(internal, null);
				unitMap.put(internal, obj);
			}
			return obj;
		}
	}
}
```

`src/main/java/me/coley/recaf/compiler/JavacOptions.java`:

```java
package me.coley.recaf.compiler;

/**
 * Compiler options.
 *
 * @author Matt
 */
public class JavacOptions {
	/**
	 * Include variable data in compilation.
	 */
	public boolean variables;
	/**
	 * Include line numbers in compilation.
	 */
	public boolean lineNumbers;
	/**
	 * Include source file name in compilation.
	 */
	public boolean sourceName;
	/**
	 * Class version to target.
	 */
	private JavacTargetVersion target = JavacTargetVersion.V8;

	/**
	 * @return Class version to target.
	 */
	public JavacTargetVersion getTarget() {
		return target;
	}

	/**
	 * @param target
	 * 		Targeted version.
	 */
	public void setTarget(JavacTargetVersion target) {
		this.target = target;
	}

	/**
	 * @return Javac argument format.
	 */
	public String toOption() {
		// generate options
		String options = getOptions();
		if(options.length() > 0) {
			return "-g:" + options;
		}
		// default to none
		return "-g:none";
	}

	private String getOptions() {
		StringBuilder s = new StringBuilder();
		if(variables)
			s.append("vars,");
		if(lineNumbers)
			s.append("lines,");
		if(sourceName)
			s.append("source");
		// substr off dangling comma
		String value = s.toString();
		if(value.endsWith(",")) {
			value = s.substring(0, value.length() - 1);
		}
		return value;
	}
}
```

`src/main/java/me/coley/recaf/compiler/JavacTargetVersion.java`:

```java
package me.coley.recaf.compiler;

import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.VMUtil;
import org.objectweb.asm.Opcodes;

import java.lang.reflect.Field;

/**
 * Wrapper for <i>-target</i> option.
 *
 * @author Matt
 */
public enum JavacTargetVersion {
	V4("1.4"),
	V5("1.5"),
	V6("1.6"),
	V7("1.7"),
	V8("1.8"),
	V9("9"),
	V10("10"),
	V11("11"),
	V12("12"),
	V13("13"),
	V14("14"),
	V15("15"),
	V16("16"),
	V17("17"),
	V18("18"),
	;

	/**
	 * Value to pass as a compiler argument.
	 */
	private final String opt;

	JavacTargetVersion(String opt) {
		this.opt = opt;
	}

	/**
	 * @return VM version.
	 */
	public int version() {
		return 4 + ordinal();
	}

	/**
	 * @param version
	 * 		Major version constant.
	 *
	 * @return version from class file major version.
	 */
	public static JavacTargetVersion fromClassMajor(int version) {
		switch(version) {
			case Opcodes.V1_4:
				return V4;
			case Opcodes.V1_5:
				return V5;
			case Opcodes.V1_6:
				return V6;
			case Opcodes.V1_7:
				return V7;
			case Opcodes.V1_8:
				return V8;
			case Opcodes.V9:
				return V9;
			case Opcodes.V10:
				return V10;
			case Opcodes.V11:
				return V11;
			case Opcodes.V12:
				return V12;
			case Opcodes.V13:
				return V13;
			case Opcodes.V14:
				return V14;
			case Opcodes.V15:
				return V15;
			case Opcodes.V16:
				return V16;
			case Opcodes.V17:
				return V17;
			case Opcodes.V18:
				return V18;
			default:
				return V8;
		}
	}

	/**
	 * @return Minimum version supported by Javac.
	 */
	public static JavacTargetVersion getMinJavacSupport() {
		try {
			Class<?> cls = Class.forName("com.sun.tools.javac.jvm.Target");
			Field min = cls.getDeclaredField("MIN");
			min.setAccessible(true);
			Object minTargetInstance = min.get(null);
			Field version = cls.getDeclaredField("majorVersion");
			version.setAccessible(true);
			return fromClassMajor(version.getInt(minTargetInstance));
		} catch (Exception ex) {
			Log.error(ex, "Failed to find javac minimum supported version, defaulting to Java 7");
		}
		return V7;
	}

	/**
	 * @return Maximum version supported by Javac.
	 */
	public static JavacTargetVersion getMaxJavacSupport() {
		try {
			return fromClassMajor(VMUtil.getVmVersion() + ClassUtil.VERSION_OFFSET);
		} catch (Exception ex) {
			Log.error("Failed to find javac maximum supported version, defaulting to Java 8 (52)");
		}
		return V8;
	}

	@Override
	public String toString() {
		return opt;
	}
}
```

`src/main/java/me/coley/recaf/compiler/JavassistASMTranslator.java`:

```java
package me.coley.recaf.compiler;

import javassist.CtBehavior;
import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.*;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * An implementation of {@link JavassistMethodTranslator} for ASM.
 *
 * @author Matt
 */
public class JavassistASMTranslator extends JavassistMethodTranslator {
	private final InsnList list = new InsnListNullFix();
	private final Map<Integer, LabelNode> offsetToLabel = new HashMap<>();

	@Override
	public void visitBranchDestination(int offset) {
		LabelNode l = getLabel(offset);
		list.add(l);
	}

	@Override
	public void visitJump(int opcode, int offset) {
		LabelNode l = getLabel(offset);
		list.add(new JumpInsnNode(opcode, l));
	}

	@Override
	public void visitMultiANewArray(int opcode, String type, int dimensions) {
		list.add(new MultiANewArrayInsnNode(type, dimensions));
	}

	@Override
	public void visitLdc(int opcode, Object value) {
		list.add(new LdcInsnNode(value));
	}

	@Override
	public void visitIinc(int opcode, int index, int incr) {
		list.add(new IincInsnNode(index, incr));
	}

	@Override
	public void visitVar(int opcode, int index) {
		list.add(new VarInsnNode(OpcodeUtil.deindexVarOp(opcode), index));
	}

	@Override
	public void visitMethod(int opcode, String owner, String name, String desc) {
		list.add(new MethodInsnNode(opcode, owner, name, desc));
	}

	@Override
	public void visitField(int opcode, String owner, String name, String desc) {
		list.add(new FieldInsnNode(opcode, owner, name, desc));
	}

	@Override
	public void visitInt(int opcode, int value) {
		list.add(new IntInsnNode(opcode, value));
	}

	@Override
	public void visitType(int opcode, String type) {
		list.add(new TypeInsnNode(opcode, type));
	}

	@Override
	public void visitInsn(int opcode) {
		list.add(new InsnNode(opcode));
	}

	private LabelNode getLabel(int offset) {
		return offsetToLabel.computeIfAbsent(offset, k -> new LabelNode());
	}

	/**
	 * @return Translated instructions.
	 */
	public InsnList getInstructions() {
		return list;
	}

	/**
	 * @param method
	 * 		Base Javassist method to copy method definition info from.
	 *
	 * @return ASM node representation of translated method.
	 */
	public MethodNode toAsmMethod(CtBehavior method) {
		MethodNode m = new MethodNode(method.getModifiers(), method.getName(), method.getSignature(), null, null);
		m.instructions = list;
		return m;
	}

	/**
	 * An extension of {@link InsnList} that fixes an odd bug with the Javassist generated code.
	 * For some reason, some {@code null} values are added at the end of the list's array cache.
	 * This cuts off those invalid entries.
	 *
	 * @author Matt
	 */
	private static class InsnListNullFix extends InsnList {
		@Override
		public AbstractInsnNode[] toArray() {
			AbstractInsnNode[] array = super.toArray();
			int newLength = array.length;
			while (array[newLength - 1] == null)
				newLength--;
			return Arrays.copyOf(array, newLength);
		}
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistCodeGen.java`:

```java
package me.coley.recaf.compiler;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.bytecode.Bytecode;
import javassist.compiler.JvstCodeGen;
import me.coley.recaf.workspace.Workspace;

/**
 * Modified code generator for Javassist to pull information from Recaf.
 *
 * @author Matt
 */
public class JavassistCodeGen extends JvstCodeGen {
	/**
	 * @param workspace
	 * 		Workspace to pull class information from.
	 * @param bytecode
	 * 		Target generated bytecode wrapper.
	 * @param declaringClass
	 * 		Class containing the method our expression resides in.
	 * @param classPool
	 * 		Class pool to use.
	 */
	public JavassistCodeGen(Workspace workspace, Bytecode bytecode, CtClass declaringClass, ClassPool classPool) {
		super(bytecode, declaringClass, classPool);
		setTypeChecker(new JavassistTypeChecker(workspace, declaringClass, classPool, this));
		resolver = new JavassistMemberResolver(workspace, classPool);
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistCompilationResult.java`:

```java
package me.coley.recaf.compiler;

import javassist.bytecode.Bytecode;
import javassist.compiler.SymbolTable;

/**
 * Compilation results.
 *
 * @author Matt
 */
public class JavassistCompilationResult {
	private final Bytecode bytecode;
	private final SymbolTable symbols;

	/**
	 * @param bytecode
	 * 		Generated bytecode.
	 * @param symbols
	 * 		Generated symbols, if any.
	 */
	public JavassistCompilationResult(Bytecode bytecode, SymbolTable symbols) {
		this.bytecode = bytecode;
		this.symbols = symbols;
	}

	/**
	 * @return Generated bytecode.
	 */
	public Bytecode getBytecode() {
		return bytecode;
	}

	/**
	 * @return Generated symbols, if any.
	 */
	public SymbolTable getSymbols() {
		return symbols;
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistCompiler.java`:

```java
package me.coley.recaf.compiler;

import javassist.*;
import javassist.bytecode.LocalVariableAttribute;
import javassist.compiler.*;
import me.coley.recaf.parse.bytecode.VariableNameCache;
import org.objectweb.asm.tree.LocalVariableNode;

import java.util.List;

/**
 * Javassist compiler utility.
 *
 * @author Matt
 */
public class JavassistCompiler {

	/**
	 * Compile an independent method body.
	 *
	 * @param declaring
	 * 		Declaring type that contains the method.
	 * @param src
	 * 		Source of the method declaration.
	 *
	 * @return Compiled method.
	 *
	 * @throws CannotCompileException
	 * 		When a compilation error occurred.
	 */
	public static CtMethod compileMethod(CtClass declaring, String src) throws CannotCompileException {
		try {
			Javac compiler = new Javac(declaring);
			CtMember obj = compiler.compile(src);
			if (obj instanceof CtMethod)
				return (CtMethod) obj;
		} catch (CompileError e) {
			throw new CannotCompileException(e);
		}
		throw new CannotCompileException("Not a method");
	}

	/**
	 * Compile an independent method body.
	 *
	 * @param declaring
	 * 		Declaring type that contains the method.
	 * @param containerMethod
	 * 		Declaring method that will contain the expression.
	 * @param expression
	 * 		Source of the expression.
	 * @param existingVars
	 * 		Variable information to populate.
	 * @param varCache
	 * Variable name and index information.
	 *
	 * @return Compiled expression.
	 *
	 * @throws CannotCompileException
	 * 		When a compilation error occurred.
	 */
	public static JavassistCompilationResult compileExpression(CtClass declaring, CtBehavior containerMethod,
															   String expression, List<LocalVariableNode> existingVars,
															   VariableNameCache varCache)
			throws CannotCompileException {
		try {
			JavassistExpressionJavac compiler = new JavassistExpressionJavac(declaring, varCache);
			populateVariables(compiler, existingVars);
			populateVariables(compiler, containerMethod);
			compiler.compileStmnt(expression);
			return new JavassistCompilationResult(compiler.getGeneratedBytecode(), compiler.getLastCompiledSymbols());
		} catch (CompileError e) {
			throw new CannotCompileException(e);
		}
	}

	private static void populateVariables(JavassistExpressionJavac compiler, List<LocalVariableNode> variables) {
		JvstCodeGen gen = compiler.getGen();
		SymbolTable symbolTable = compiler.getRootSTable();
		for (LocalVariableNode variable : variables) {
			try {
				gen.recordVariable(variable.desc, variable.name, variable.index, symbolTable);
			} catch (CompileError ignored) {
				// ignored
			}
		}
	}

	private static void populateVariables(JavassistExpressionJavac compiler, CtBehavior containerMethod) {
		LocalVariableAttribute variables = (LocalVariableAttribute)
				containerMethod.getMethodInfo().getCodeAttribute().getAttribute(LocalVariableAttribute.tag);
		if (variables != null) {
			JvstCodeGen gen = compiler.getGen();
			SymbolTable symbolTable = compiler.getRootSTable();
			for (int i = 0; i < variables.tableLength(); i++) {
				int index = variables.index(i);
				String signature = variables.signature(i);
				String name = variables.variableName(i);
				try {
					gen.recordVariable(signature, name, index, symbolTable);
				} catch (CompileError ignored) {
					// ignored
				}
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistExpressionJavac.java`:

```java
package me.coley.recaf.compiler;

import javassist.CtClass;
import javassist.bytecode.Bytecode;
import javassist.compiler.*;
import javassist.compiler.ast.Declarator;
import javassist.compiler.ast.Stmnt;
import me.coley.recaf.Recaf;
import me.coley.recaf.parse.bytecode.VariableNameCache;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.Type;

import java.lang.reflect.Field;

/**
 * An extension of Javassist's {@link Javac} that exposes some internal structures
 * needed to properly inject local variable information.
 *
 * @author Matt
 */
class JavassistExpressionJavac extends Javac {
	private static final Field fGen;
	private static final Field fSTable;
	private static final Field fBytecode;
	private final VariableNameCache varCache;
	private final CtClass declaringClass;
	private final JvstCodeGen gen;
	private SymbolTable lastCompiledSymbols;

	/**
	 * @param declaringClass
	 * 		Type that contains the declared method body/expression.
	 * @param varCache
	 * 		Variable name cache of the declared method.
	 */
	public JavassistExpressionJavac(CtClass declaringClass, VariableNameCache varCache) {
		super(declaringClass);
		this.declaringClass = declaringClass;
		this.varCache = varCache;
		gen = hookCodeGen();
	}

	@Override
	public void compileStmnt(String src) throws CompileError {
		Parser p = new Parser(new Lex(src));
		lastCompiledSymbols = new SymbolTable(getRootSTable());
		while (p.hasMore()) {
			Stmnt s = p.parseStatement(lastCompiledSymbols);
			// Patch the index so the following "accept" call doesn't generate with the wrong var index
			if (varCache != null && s.getLeft() instanceof Declarator)
				patchDeclarator(varCache, (Declarator) s.getLeft());
			// Generate bytecode
			if (s != null)
				s.accept(getGen());
		}
	}

	/**
	 * Updates the generated AST of the variable declarator to use the correct local variable index.
	 *
	 * @param varCache
	 * 		Cache of variable names and indices.
	 * @param dec
	 * 		Declarator to patch.
	 */
	private void patchDeclarator(VariableNameCache varCache, Declarator dec) {
		String name = dec.getLeft().toString();
		// Update variable index if it exists already
		try {
			int index = varCache.getIndex(name);
			dec.setLocalVar(index);
			return;
		} catch (Exception ignored) {
			// ignored
		}
		// Otherwise define it
		String desc = dec.getClassName();
		if (desc == null) {
			switch (dec.getType()) {
				case TokenId.BOOLEAN:
				case TokenId.BYTE:
				case TokenId.SHORT:
				case TokenId.INT:
					desc = "I";
					break;
				case TokenId.CHAR:
					desc = "C";
					break;
				case TokenId.FLOAT:
					desc = "F";
					break;
				case TokenId.DOUBLE:
					desc = "D";
					break;
				case TokenId.LONG:
					desc = "J";
					break;
				default:
					throw new IllegalArgumentException("Unknown primitive type for expression defined var");
			}
		}
		Type type = Type.getType(desc);
		int index = varCache.getAndIncrementNext(name, type);
		dec.setLocalVar(index);
		dec.setClassName(type.getClassName());
		setMaxLocals(index);
	}

	/**
	 * @return Modified code gen to pull information from Recaf.
	 */
	private JvstCodeGen hookCodeGen() {
		try {
			Workspace workspace = Recaf.getCurrentWorkspace();
			JvstCodeGen internalCodeGen = new JavassistCodeGen(workspace, getBytecode(), declaringClass,
					declaringClass.getClassPool());
			fGen.set(this, internalCodeGen);
			return internalCodeGen;
		} catch (IllegalAccessException ex) {
			throw new IllegalStateException(ex);
		}
	}

	/**
	 * @return Code generator.
	 */
	public JvstCodeGen getGen() {
		return gen;
	}

	/**
	 * @return Generated bytecode.
	 */
	public Bytecode getGeneratedBytecode() {
		try {
			return (Bytecode) fBytecode.get(getGen());
		} catch (IllegalAccessException ex) {
			throw new IllegalStateException(ex);
		}
	}

	/**
	 * @return Symbol table used in AST analysis.
	 */
	public SymbolTable getRootSTable() {
		try {
			return (SymbolTable) fSTable.get(this);
		} catch (IllegalAccessException ex) {
			throw new IllegalStateException(ex);
		}
	}

	/**
	 * @return Symbol table containing new symbols from the passed body/expression.
	 */
	public SymbolTable getLastCompiledSymbols() {
		return lastCompiledSymbols;
	}

	static {
		try {
			fGen = Javac.class.getDeclaredField("gen");
			fGen.setAccessible(true);
			fSTable = Javac.class.getDeclaredField("stable");
			fSTable.setAccessible(true);
			fBytecode = CodeGen.class.getDeclaredField("bytecode");
			fBytecode.setAccessible(true);
		} catch (ReflectiveOperationException ex) {
			throw new IllegalStateException(ex);
		}
	}

}

```

`src/main/java/me/coley/recaf/compiler/JavassistMemberResolver.java`:

```java
package me.coley.recaf.compiler;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.compiler.CompileError;
import javassist.compiler.MemberResolver;
import me.coley.recaf.workspace.Workspace;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

/**
 * Modified member resolver for Javassist to pull information from Recaf.
 *
 * @author Matt
 */
public class JavassistMemberResolver extends MemberResolver {
	private final Workspace workspace;

	/**
	 * @param workspace
	 * 		Workspace to pull class information from.
	 * @param classPool
	 * 		Class pool to use.
	 */
	public JavassistMemberResolver(Workspace workspace, ClassPool classPool) {
		super(classPool);
		this.workspace = workspace;
	}

	@Override
	public CtClass lookupClass(String name, boolean notCheckInner) throws CompileError {
		try {
			return super.lookupClass(name, notCheckInner);
		} catch (CompileError error) {
			return lookupWorkspaceClass(name.replace('.', '/'));
		}
	}

	private CtClass lookupWorkspaceClass(String name) throws CompileError {
		try {
			byte[] clazz = workspace.getRawClass(name);
			if (clazz == null)
				throw new IllegalArgumentException("Class does not exist in workspace");
			InputStream is = new ByteArrayInputStream(clazz);
			return getClassPool().makeClass(is);
		} catch (Exception ignored) {
			// If the class does not exist its ok to fail.
			String msg = ignored.getMessage();
			if (msg == null)
				msg = "'" + name + "' could not be found in workspace.\n" +
						"Add it as a library or enable class generation in the config.";
			throw new CompileError(msg);
		}
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistMethodTranslator.java`:

```java
package me.coley.recaf.compiler;

import javassist.*;
import javassist.bytecode.*;
import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.*;

import java.util.HashSet;
import java.util.Set;

/**
 * Allows translation of generated bytecode from Javassist by exposing each generated instruction in a visitor pattern.
 *
 * @author Matt
 */
public class JavassistMethodTranslator {
	private final Set<Integer> labelOffsets = new HashSet<>();

	/**
	 * Translates the given code depending on the implementation.
	 *
	 * @param clazz
	 * 		Owner type of code being written.
	 * @param code
	 * 		Code to translate.
	 *
	 * @throws CannotCompileException
	 * 		When the code cannot be compiled due to syntax or resolution errors.
	 * @throws BadBytecode
	 * 		When the code generated is malformed.
	 */
	public void visit(CtClass clazz, CodeAttribute code) throws CannotCompileException, BadBytecode {
		populateControlFlowTargets(code);
		iterateCode(clazz, code.iterator());
	}

	private void populateControlFlowTargets(CodeAttribute code) throws BadBytecode {
		labelOffsets.add(0);
		CodeIterator iterator  = code.iterator();
		while (iterator.hasNext())
			populateLabels(iterator);
		labelOffsets.add(code.getCodeLength());
	}

	private void iterateCode(CtClass clazz, CodeIterator iterator) throws CannotCompileException, BadBytecode {
		visitBranchDestination(0);
		while (iterator.hasNext())
			handleNextInsn(clazz, iterator);
		visitBranchDestination(iterator.getCodeLength());
	}

	private void populateLabels(CodeIterator iterator) throws BadBytecode {
		int pos = iterator.next();
		int c = iterator.byteAt(pos);
		int type;
		try {
			type = OpcodeUtil.opcodeToType(c);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + c);
		}
		if (type == AbstractInsnNode.JUMP_INSN) {
			int offset = getJumpOffset(c, pos, iterator);
			labelOffsets.add(offset);
		}
	}

	private void handleNextInsn(CtClass clazz, CodeIterator iterator)
			throws CannotCompileException, BadBytecode {
		int pos = iterator.next();
		if (labelOffsets.contains(pos))
			visitBranchDestination(pos);
		int c = iterator.byteAt(pos);
		ConstPool cp = clazz.getClassFile().getConstPool();
		int type;
		try {
			type = OpcodeUtil.opcodeToType(c);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + c);
		}
		switch (type) {
			case AbstractInsnNode.INSN:
				visitInsn(c);
				break;
			case AbstractInsnNode.INT_INSN: {
				int value;
				if (c == Opcode.BIPUSH || c == Opcode.NEWARRAY) {
					value = iterator.byteAt(pos + 1);
				} else if (c == Opcode.SIPUSH) {
					value = iterator.s16bitAt(pos + 1);
				} else {
					throw new BadBytecode("Unknown int insn: " + c);
				}
				visitInt(c, value);
				break;
			}
			case AbstractInsnNode.VAR_INSN: {
				int index;
				if (OpcodeUtil.deindexVarOp(c) != c) {
					index = OpcodeUtil.indexFromVarOp(c);
				} else {
					index = iterator.byteAt(pos + 1);
				}
				visitVar(c, index);
				break;
			}
			case AbstractInsnNode.TYPE_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String name = Descriptor.toJvmName(cp.getClassInfo(index));
				visitType(c, name);
				break;
			}
			case AbstractInsnNode.FIELD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String owner = Descriptor.toJvmName(cp.getFieldrefClassName(index));
				String name = cp.getFieldrefName(index);
				String signature = cp.getFieldrefType(index);
				visitField(c, owner, name, signature);
				break;
			}
			case AbstractInsnNode.METHOD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int nameType;
				if (c == Opcode.INVOKEINTERFACE)
					nameType = cp.getInterfaceMethodrefNameAndType(index);
				else
					nameType = cp.getMethodrefNameAndType(index);
				String owner = Descriptor.toJvmName(cp.getMethodrefClassName(index));
				String name = cp.getUtf8Info(cp.getNameAndTypeName(nameType));
				String signature = cp.getUtf8Info(cp.getNameAndTypeDescriptor(nameType));
				visitMethod(c, owner, name, signature);
				break;
			}
			case AbstractInsnNode.IINC_INSN: {
				int index = iterator.byteAt(pos + 1);
				int incr = iterator.signedByteAt(pos + 2);
				visitIinc(c, index, incr);
				break;
			}
			case AbstractInsnNode.LDC_INSN: {
				int index;
				if (c == Opcode.LDC)
					index = iterator.byteAt(pos + 1);
				else
					index = iterator.u16bitAt(pos + 1);
				Object value = cp.getLdcValue(index);
				visitLdc(c, value);
				break;
			}
			case AbstractInsnNode.MULTIANEWARRAY_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int dimensions = iterator.byteAt(pos + 3);
				String elementType = cp.getClassInfo(index);
				visitMultiANewArray(c, elementType, dimensions);
				break;
			}
			case AbstractInsnNode.INVOKE_DYNAMIC_INSN:
				// I don't think Javassist is even capable of outputting INDY
				throw new CannotCompileException("Invoke dynamic instructions not supported");
			case AbstractInsnNode.JUMP_INSN:
				int offset = getJumpOffset(c, pos, iterator);
				visitJump(c, offset);
				break;
			case AbstractInsnNode.LOOKUPSWITCH_INSN:
			case AbstractInsnNode.TABLESWITCH_INSN:
				throw new CannotCompileException("Control flow instructions not supported");
			default:
				throw new CannotCompileException("Unhandled instruction type for opcode: " + c);
		}
	}

	private int getJumpOffset(int c, int pos, CodeIterator iterator) {
		if (c == Opcode.GOTO_W)
			return pos + iterator.s32bitAt(pos + 1);
		else
			return pos + iterator.u16bitAt(pos + 1);
	}

	/// ================== Below are stubs for children to implement ================== ///

	/**
	 * Visit a control flow destination.
	 *
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitBranchDestination(int offset) {
	}

	/**
	 * Visit a jump instruction.
	 *
	 * @param opcode
	 * 		Jump instruction opcode.
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitJump(int opcode, int offset) {
	}

	/**
	 * Visit an {@code MULTIANEWARRAY} instruction.
	 *
	 * @param opcode
	 *        {@code MULTIANEWARRAY}
	 * @param type
	 * 		Object type.
	 * @param dimensions
	 * 		Number of dimentsions.
	 */
	public void visitMultiANewArray(int opcode, String type, int dimensions) {
	}

	/**
	 * Visit a load-constant instruction.
	 *
	 * @param opcode
	 *        {@code LDC}
	 * @param value
	 * 		Value to push.
	 */
	public void visitLdc(int opcode, Object value) {
	}

	/**
	 * Visit an integer increment instruction.
	 *
	 * @param opcode
	 *        {@code IINC}
	 * @param index
	 * 		Variable index to increment.
	 * @param incr
	 * 		Value to increment by.
	 */
	public void visitIinc(int opcode, int index, int incr) {
	}

	/**
	 * Visit a variable instruction.
	 *
	 * @param opcode
	 * 		Variable instruction opcode. It is not adjusted to conform to ASM
	 * 		<i>(Use {@link OpcodeUtil#deindexVarOp(int)} for that)</i>.
	 * @param index
	 * 		Index of the local variable.
	 */
	public void visitVar(int opcode, int index) {
	}

	/**
	 * Visit a method invocation instruction.
	 *
	 * @param opcode
	 * 		Method invocation opcode.
	 * @param owner
	 * 		Declaring type of method.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 */
	public void visitMethod(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit a field reference instruction.
	 *
	 * @param opcode
	 * 		Field reference opcode.
	 * @param owner
	 * 		Declaring type of field.
	 * @param name
	 * 		Field name.
	 * @param desc
	 * 		Field descriptor.
	 */
	public void visitField(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit an integer push instruction.
	 *
	 * @param opcode
	 * 		Integer push opcode.
	 * @param value
	 * 		Value to push onto the stack.
	 */
	public void visitInt(int opcode, int value) {
	}

	/**
	 * Visit a type instruction.
	 *
	 * @param opcode
	 * 		Type opcode.
	 * @param type
	 * 		Type of the instruction.
	 */
	public void visitType(int opcode, String type) {
	}

	/**
	 * Visit a no-arg instruction.
	 *
	 * @param opcode
	 * 		Instruction opcode.
	 */
	public void visitInsn(int opcode) {
	}
}

```

`src/main/java/me/coley/recaf/compiler/JavassistTypeChecker.java`:

```java
package me.coley.recaf.compiler;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.compiler.JvstTypeChecker;
import me.coley.recaf.workspace.Workspace;

/**
 * Modified type checker for Javassist to pull information from Recaf.
 *
 * @author Matt
 */
public class JavassistTypeChecker extends JvstTypeChecker {
	/**
	 * @param workspace
	 * 		Workspace to pull class information from.
	 * @param declaringClass
	 * 		Class containing the method our expression resides in.
	 * @param classPool
	 * 		Class pool to use.
	 * @param javassistCodeGen
	 * 		Parent code generator context.
	 */
	public JavassistTypeChecker(Workspace workspace, CtClass declaringClass, ClassPool classPool,
								JavassistCodeGen javassistCodeGen) {
		super(declaringClass, classPool, javassistCodeGen);
		this.resolver = new JavassistMemberResolver(workspace, classPool);
	}
}

```

`src/main/java/me/coley/recaf/compiler/ResourceVirtualJavaFileObject.java`:

```java
package me.coley.recaf.compiler;

import javax.tools.SimpleJavaFileObject;
import java.io.*;
import java.net.URI;

/**
 * Java file extension that exposes
 * workspace resource for classpath.
 *
 * @author xDark
 */
public class ResourceVirtualJavaFileObject extends SimpleJavaFileObject {

	/**
	 * Resource name
	 */
	private final String resourceName;

	/**
	 * Resource content.
	 */
	private final byte[] content;

	/**
	 * @param resourceName
	 * 		Name of the resource.
	 * @param content
	 * 		Class source content.
	 * @param resourceKind
	 * 		Kind of the resource.
	 */
	public ResourceVirtualJavaFileObject(String resourceName, byte[] content, Kind resourceKind) {
		super(URI.create("memory://" + resourceName + resourceKind.extension),
				resourceKind);
		this.resourceName = resourceName;
		this.content = content;
	}

	/**
	 * Returns resource name.
	 * @return resource name.
	 */
	public String getResourceName() {
		return resourceName;
	}

	@Override
	public InputStream openInputStream() throws IOException {
		return new ByteArrayInputStream(content);
	}
}
```

`src/main/java/me/coley/recaf/compiler/VirtualJavaFileObject.java`:

```java
package me.coley.recaf.compiler;

import javax.tools.SimpleJavaFileObject;
import java.io.*;
import java.net.URI;

/**
 * Java file extension that keeps track of the compiled bytecode.
 *
 * @author Matt
 */
public class VirtualJavaFileObject extends SimpleJavaFileObject {
	/**
	 * Output to contain compiled bytcode.
	 */
	private final ByteArrayOutputStream baos = new ByteArrayOutputStream();
	/**
	 * Content of source file to compile.
	 */
	private final String content;

	/**
	 * @param className
	 * 		Name of class.
	 * @param content
	 * 		Class source content.
	 */
	public VirtualJavaFileObject(String className, String content) {
		super(URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension),
				Kind.SOURCE);
		this.content = content;
	}

	/**
	 * @return Compiled bytecode of class.
	 */
	public byte[] getBytecode() {
		return baos.toByteArray();
	}

	/**
	 * @return Class source code.
	 */
	public String getSource() {
		return content;
	}

	@Override
	public final OutputStream openOutputStream() throws IOException {
		return baos;
	}

	@Override
	public CharSequence getCharContent(boolean ignoreEncodingErrors) {
		return content;
	}
}
```

`src/main/java/me/coley/recaf/config/Conf.java`:

```java
package me.coley.recaf.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for giving configuration data to a field.
 * 
 * @author Matt
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Conf {
	/**
	 * @return Translation key base used for fetching name and descriptions.
	 */
	String value();

	/**
	 * @return Hide from UI.
	 */
	boolean hide() default false;

	/**
	 * @return If field should not be translated.
	 */
	boolean noTranslate() default false;
}
```

`src/main/java/me/coley/recaf/config/ConfAssembler.java`:

```java
package me.coley.recaf.config;

/**
 * Assembler configuration.
 *
 * @author Matt
 */
public class ConfAssembler extends Config {
	/**
	 * Verify method bytecode. This also allows better variable type analysis.
	 */
	@Conf("assembler.verify")
	public boolean verify = true;
	/**
	 * Save variable debug information in the assembled method.
	 */
	@Conf("assembler.variables")
	public boolean variables = true;
	/**
	 * Use existing variable debug information instead of recalculating indices and types.
	 */
	@Conf("assembler.useexistingdata")
	public boolean useExistingData = true;
	/**
	 * Strip debug from class before it is sent to the disassembler.
	 * Useful when garbage data is inserted into debug attributes.
	 */
	@Conf("assembler.stripdebug")
	public boolean stripDebug;
	/**
	 * Check to determine if phantom classes should be generated.
	 */
	@Conf("assembler.phantoms")
	public boolean phantoms = true;

	ConfAssembler() {
		super("assembler");
	}
}

```

`src/main/java/me/coley/recaf/config/ConfBackend.java`:

```java
package me.coley.recaf.config;

import me.coley.recaf.util.IOUtil;

import java.io.File;
import java.nio.file.Path;
import java.util.*;

/**
 * Private configuration that are intended for user-access.
 *
 * @author Matt
 */
public class ConfBackend extends Config {
	private static final String CURRENT_DIR = System.getProperty("user.dir");
	/**
	 * Recently opened files <i>(from primary resources)</i> - absolute paths.
	 */
	@Conf("backend.recents")
	public List<String> recentFiles = new ArrayList<>();
	/**
	 * Recent path used by the load dialog.
	 */
	@Conf("backend.recentopen")
	public String recentLoad = CURRENT_DIR;
	/**
	 * Recent path used by the save-application dialog.
	 */
	@Conf("backend.recentsave.app")
	public String recentSaveApp = CURRENT_DIR;
	/**
	 * Recent path used by the save-workspace dialog.
	 */
	@Conf("backend.recentsave.workspace")
	public String recentSaveWorkspace = CURRENT_DIR;
	/**
	 * Recent path used by the save-map dialog.
	 */
	@Conf("backend.recentsave.map")
	public String recentSaveMap = CURRENT_DIR;
	/**
	 * Check to determine if user should be told to read the documentation.
	 */
	@Conf("backend.firsttime")
	public boolean firstTime = true;
	/**
	 * Enable compression on output.
	 */
	@Conf("backend.compressexport")
	public boolean compress = true;

	ConfBackend() {
		super("backend");
	}

	/**
	 * @return Copy of recently opened files. {@link #recentFiles}.
	 */
	public List<String> getRecentFiles() {
		return new ArrayList<>(recentFiles);
	}

	@Override
	public void onLoad() {
		// Remove duplicates
		Set<String> temp = new LinkedHashSet<>(recentFiles);
		recentFiles.clear();
		recentFiles.addAll(temp);
	}

	/**
	 * Update {@link #getRecentLoadDir() recent load directory} and {@link #getRecentFiles()
	 * recent files list}.
	 *
	 * @param path
	 * 		Path loaded.
	 * @param maxRecentFiles
	 * 		Maximum recent files to support.
	 */
	public void onLoad(Path path, int maxRecentFiles) {
		String stringPath = IOUtil.toString(path);
		recentLoad = stringPath;
		// Update path in list
		recentFiles.remove(stringPath);
		recentFiles.add(0, stringPath);
		// Prune list if it hits max size
		if(recentFiles.size() > maxRecentFiles)
			recentFiles.remove(recentFiles.size() - 1);
	}

	/**
	 * @return Directory to use for import file-chooser.
	 * Based on the most recent file opened.
	 */
	public File getRecentLoadDir() {
		return getDir(recentLoad);
	}

	/**
	 * @return Directory to use for save-application file-chooser.
	 * Based on the most recent file exported.
	 */
	public File getRecentSaveAppDir() {
		return getDir(recentSaveApp);
	}

	/**
	 * @return Directory to use for save-workspace file-chooser.
	 * Based on the most recent file exported.
	 */
	public File getRecentSaveWorkspaceDir() {
		return getDir(recentSaveWorkspace);
	}

	/**
	 * @return Directory to use for save-map file-chooser.
	 * Based on the most recent file exported.
	 */
	public File getRecentSaveMapDir() {
		return getDir(recentSaveMap);
	}

	private File getDir(String root) {
		File recent = new File(root);
		if(recent.exists()) {
			if(recent.isDirectory())
				return recent;
			File parent = recent.getParentFile();
			if(parent != null)
				return parent;
		}
		return new File(CURRENT_DIR);
	}

}

```

`src/main/java/me/coley/recaf/config/ConfDecompile.java`:

```java
package me.coley.recaf.config;

import me.coley.recaf.decompile.DecompileImpl;

/**
 * Decompile configuration.
 *
 * @author Matt
 */
public class ConfDecompile extends Config {
	/**
	 * Decompiler to use.
	 */
	@Conf("decompile.decompiler")
	public DecompileImpl decompiler = DecompileImpl.CFR;

	// ============================ COMMON OPTIONS ============================ //

	/**
	 * Show synthetic members. Most decompilers will change formatting semantics as well with
	 * this, yielding less legible output.
	 */
	@Conf("decompile.showsynthetics")
	public boolean showSynthetic;

	/**
	 * Strip debug from class before it is sent to the decompiler.
	 * Useful when garbage data is inserted into debug attributes.
	 */
	@Conf("decompile.stripdebug")
	public boolean stripDebug;

	/**
	 * Determine if the decompiler name/version should be output.
	 */
	@Conf("decompile.showname")
	public boolean showName = true;

	/**
	 * Time to wait before aborting the decompile process.
	 */
	@Conf("decompile.timeout")
	public long timeout = 9000;

	// ============================ CFR OPTIONS ============================ //

	// TODO: Add cfr options

	// ========================= FERNFLOWER OPTIONS ======================== //

	// TODO: Add ff options

	// ========================= PROCYON OPTIONS ======================== //

	// TODO: Add procyon options

	ConfDecompile() {
		super("decompiler");
	}
}

```

`src/main/java/me/coley/recaf/config/ConfDisplay.java`:

```java
package me.coley.recaf.config;

import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.view.FileViewport;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Resource;
import static me.coley.recaf.util.Resource.internal;

/**
 * Display configuration.
 *
 * @author Matt
 */
public class ConfDisplay extends Config {
	/**
	 * Display mode for classes.
	 */
	@Conf("display.classmode")
	public ClassViewport.ClassMode classEditorMode = ClassViewport.ClassMode.DECOMPILE;
	/**
	 * Display mode for files.
	 */
	@Conf("display.filemode")
	public FileViewport.FileMode fileEditorMode = FileViewport.FileMode.AUTOMATIC;
	/**
	 * UI language.
	 */
	@Conf("display.language")
	public Resource language = internal("translations/" + LangUtil.DEFAULT_LANGUAGE + ".json");
	/**
	 * Stylesheet group to use for application styling.
	 */
	@Conf("display.appstyle")
	public Resource appStyle = internal("style/ui-dark.css");
	/**
	 * Theme for decompiler/text view.
	 */
	@Conf("display.textstyle")
	public Resource textStyle = internal("style/text-dark.css");
	/**
	 * Font size for UI text.
	 */
	@Conf("display.uifontsize")
	public double uiFontSize = 12;
	/**
	 * Font size for monospaced text.
	 */
	@Conf("display.monofontsize")
	public double monoFontSize = 12;
	/**
	 * Font family for UI text.
	 */
	@Conf("display.uifont")
	public String uiFont = "Arial";
	/**
	 * Font family for monospaced text.
	 */
	@Conf("display.monofont")
	public String monoFont = "monospaced";
	/**
	 * Force word wrapping even when it is not recommended.
	 */
	@Conf("display.forceWordWrap")
	public boolean forceWordWrap;
	/**
	 * Give suggestions when a class-view has errors.
	 */
	@Conf("display.suggest.classerrors")
	public boolean suggestClassWithErrors = true;
	/**
	 * Number of recent files allowed to be stored in {@link ConfBackend#recentFiles}.
	 */
	@Conf("display.maxrecent")
	public long maxRecentFiles = 6;
	/**
	 * Use system menubar on macOS.
	 */
	@Conf("display.usesystemmenubar")
	public boolean useSystemMenubar;
	/**
	 * Maximum depth of a directory structure to display before it gets truncated.
	 */
	@Conf("display.maxtreedepth")
	public int maxTreeDepth = 30;

	ConfDisplay() {
		super("display");
	}

	@Override
	public void onLoad() {
		LangUtil.load(language);
	}

	/**
	 * @return Number of recent files allowed to be stored in {@link ConfBackend#recentFiles}.
	 */
	public int getMaxRecent() {
		return (int) maxRecentFiles;
	}
}

```

`src/main/java/me/coley/recaf/config/ConfKeybinding.java`:

```java
package me.coley.recaf.config;

import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.PluginKeybinds;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.OSUtil;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Keybind configuration.
 *
 * @author Matt
 */
public class ConfKeybinding extends Config {
	/**
	 * Save current application to file.
	 */
	@Conf("binding.saveapp")
	public Binding saveApp = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.E),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.E))
	).buildKeyBindingForCurrentOS();
	/**
	 * Save current work.
	 */
	@Conf("binding.save")
	public Binding save = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.S),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.S))
	).buildKeyBindingForCurrentOS();
	/**
	 * Undo last change.
	 */
	@Conf("binding.undo")
	public Binding undo = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.U),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.U))
	).buildKeyBindingForCurrentOS();
	/**
	 * Open find search.
	 */
	@Conf("binding.find")
	public Binding find = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.F),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.F))
	).buildKeyBindingForCurrentOS();
	/**
	 * Close top-most window <i>(Except the main window)</i>
	 */
	@Conf("binding.close.window")
	public Binding closeWindow = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.ESCAPE),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.ESCAPE))
	).buildKeyBindingForCurrentOS();
	/**
	 * Close current file/class tab.
	 */
	@Conf("binding.close.tab")
	public Binding closeTab = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.W),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.W))
	).buildKeyBindingForCurrentOS();
	/**
	 * Goto the selected item's definition.
	 */
	@Conf("binding.gotodef")
	public Binding gotoDef = Binding.from(KeyCode.F3);
	/**
	 * Goto the selected item's definition.
	 */
	@Conf("binding.rename")
	public Binding rename = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.R),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.R))
	).buildKeyBindingForCurrentOS();
	/**
	 * Swap to the next view mode for the class viewport
	 */
	@Conf("binding.swapview")
	public Binding swapview = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.Q), // META + Q on Mac closes the window so probably not a great idea
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.A))
	).buildKeyBindingForCurrentOS();
	/**
	 * Increase editor font size.
	 */
	@Conf("binding.incfontsize")
	public Binding incFontSize = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.EQUALS),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.EQUALS))
	).buildKeyBindingForCurrentOS();
	/**
	 * Decrease editor font size.
	 */
	@Conf("binding.decfontsize")
	public Binding decFontSize = BindingCreator.from(
			Binding.from(KeyCode.CONTROL, KeyCode.MINUS),
			BindingCreator.OSBinding.from(OSUtil.MAC, Binding.from(KeyCode.META, KeyCode.MINUS))
	).buildKeyBindingForCurrentOS();

	/**
	 * Track if the user is updating a keybind, so if when they are and they hit a key that is bound,
	 * its behavior does not execute.
	 */
	private boolean isEditingBind;

	ConfKeybinding() {
		super("keybinding");
	}

	@Override
	public boolean supported(Class<?> type) {
		return type.equals(Binding.class);
	}

	/**
	 * @param isEditingBind
	 * 		New editing state.
	 */
	public void setIsUpdating(boolean isEditingBind) {
		this.isEditingBind = isEditingBind;
	}

	/**
	 * Register window-level keybinds.
	 *
	 * @param controller
	 * 		Controller to call actions on.
	 * @param stage
	 * 		Window to register keys on.
	 * @param scene
	 * 		Scene in the window.
	 */
	public void registerWindowKeys(GuiController controller, Stage stage, Scene scene) {
		scene.setOnKeyReleased(e -> handleWindowKeyEvents(e, controller, stage, false));
	}

	/**
	 * Register window-level keybinds.
	 *
	 * @param controller
	 * 		Controller to call actions on.
	 * @param stage
	 * 		Window to register keys on.
	 * @param scene
	 * 		Scene in the window.
	 */
	public void registerMainWindowKeys(GuiController controller, Stage stage, Scene scene) {
		scene.setOnKeyReleased(e -> handleWindowKeyEvents(e, controller, stage, true));
	}

	private void handleWindowKeyEvents(KeyEvent e, GuiController controller, Stage stage, boolean main) {
		// Ignore bind behaviors while editing them
		if (isEditingBind)
			return;
		if(!main && closeWindow.match(e) && !isEditingBind)
			stage.close();
		if(saveApp.match(e))
			controller.windows().getMainWindow().saveApplication();
		else {
			// Custom bind support
			PluginKeybinds.getInstance().getGlobalBinds().forEach((bind, action) -> {
				try {
					if (bind.match(e))
						action.run();
				} catch(Throwable t) {
					Log.error(t, "Failed executing global keybind action");
				}
			});
		}
	}

	/**
	 * Wrapper to act as bind utility.
	 *
	 * @author Matt Coley
	 */
	public static class Binding extends ArrayList<String> {
		/**
		 * @param string
		 * 		Series of keys for a keybind, split by '+'.
		 * @param mask
		 * 		Optional mask to include.
		 *
		 * @return Binding from keys + mask.
		 */
		public static Binding from(String string, KeyCode mask) {
			String[] codes = string.split("\\+");
			Stream<String> stream = Arrays.stream(codes);
			if (mask != null)
				stream = Stream.concat(Stream.of(mask.getName()), stream);
			return stream.map(String::toLowerCase).collect(Collectors.toCollection(Binding::new));
		}

		/**
		 * @param event
		 * 		Key event.
		 *
		 * @return Binding from keys of the event.
		 */
		public static Binding from(KeyEvent event) {
			return from(namesOf(event));
		}

		/**
		 * @param codes
		 * 		Series of JFX KeyCodes for a keybind. Unlike {@link #from(String, KeyCode)}
		 * 		it is implied that the mask is given in this series, if one is intended.
		 *
		 * @return Binding from keys.
		 */
		public static Binding from(KeyCode... codes) {
			return Arrays.stream(codes).map(KeyCode::getName)
					.map(String::toLowerCase)
					.collect(Collectors.toCollection(Binding::new));
		}

		/**
		 * @param codes
		 * 		Series of keys for a keybind.
		 *
		 * @return Binding from keys.
		 */
		public static Binding from(Collection<String> codes) {
			return codes.stream()
						.map(String::toLowerCase)
						.sorted((a, b) -> (a.length() > b.length()) ? -1 : a.compareTo(b))
						.collect(Collectors.toCollection(Binding::new));
		}

		@Override
		public String toString() {
			return String.join("+", this);
		}

		/**
		 * @param event
		 * 		JFX key event.
		 *
		 * @return {@code true} if the event matches the current bind.
		 */
		public boolean match(KeyEvent event) {
			if (size() == 1)
				// Simple 1-key check
				return event.getCode().getName().equalsIgnoreCase(get(0));
			else if (size() > 1) {
				// Checking binds with masks
				Set<String> bindSet = new HashSet<>(this);
				Set<String> eventSet = namesOf(event);
				return bindSet.equals(eventSet);
			} else
				throw new IllegalStateException("Keybind must have have at least 1 key!");
		}

		private static Set<String> namesOf(KeyEvent event) {
			Set<String> eventSet = new HashSet<>();
			eventSet.add(event.getCode().getName().toLowerCase());
			if (event.isControlDown())
				eventSet.add("ctrl");
			else if (event.isAltDown())
				eventSet.add("alt");
			else if (event.isShiftDown())
				eventSet.add("shift");
            else if (event.isMetaDown())
                eventSet.add("meta");
			return eventSet;
		}
	}

	/**
	 * Keybinding creator for creating different binding in different OS's.
	 *
	 * @author TimmyOVO
	 */
	public static final class BindingCreator {
		private final Binding defaultBinding;
		private final Map<OSUtil, Binding> bindings;

		private BindingCreator(Binding defaultBinding, OSBinding... osBindings) {
			this.defaultBinding = defaultBinding;
			this.bindings = Arrays.stream(OSUtil.values())
					.collect(Collectors.toMap(os -> os, os -> defaultBinding));
			this.bindings.putAll(
					Arrays.stream(osBindings)
							.collect(Collectors.toMap(
									osBinding -> osBinding.os,
									osBinding -> osBinding.binding
							))
			);
		}

		/**
		 * Build a KeybindingCreator to include all os specified keybinding.
		 *
		 * @param defaultBinding defaultBinding
		 *                       If osBindings is empty, all os's keybinding will be the same.
		 * @param osBindings     os specified keybinding.
		 * @return A KeybindingCreator instance.
		 */
		public static BindingCreator from(Binding defaultBinding, OSBinding... osBindings) {
			return new BindingCreator(defaultBinding, osBindings);
		}

		/**
		 * Match keybinding for current using os.
		 *
		 * @return A Binding instance.
		 */
		public Binding buildKeyBindingForCurrentOS() {
			return bindings.getOrDefault(OSUtil.getOSType(), defaultBinding);
		}

		/**
		 * OS specified keybinding wrapper.
		 */
		public static class OSBinding {
			public OSUtil os;
			public Binding binding;

			private OSBinding(OSUtil os, Binding binding) {
				this.os = os;
				this.binding = binding;
			}

			/**
			 * Build a key binding instance for specified os.
			 *
			 * @param os      the os to be specified
			 * @param binding key binding
			 * @return the instance of OSBinding.
			 */
			public static OSBinding from(OSUtil os, Binding binding) {
				return new OSBinding(os, binding);
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/config/ConfUpdate.java`:

```java
package me.coley.recaf.config;

import com.eclipsesource.json.JsonObject;
import com.eclipsesource.json.JsonValue;
import me.coley.recaf.util.LangUtil;

import java.util.concurrent.TimeUnit;

/**
 * Private configuration that are intended for user-access.
 *
 * @author Matt
 */
public class ConfUpdate extends Config {
	/**
	 * Enable update checking.
	 */
	@Conf("update.active")
	public boolean active = true;
	/**
	 * Time since last check.
	 */
	@Conf("update.lastcheck")
	public long lastCheck;
	/**
	 * Frequency of checks.
	 */
	@Conf("update.frequency")
	public Frequency frequency = Frequency.DAILY;

	ConfUpdate() {
		super("update");
	}

	@Override
	public void loadType(FieldWrapper field, Class<?> type, JsonValue value) {
		if (type.equals(Frequency.class)) {
			field.set(Frequency.valueOf(value.asString()));
		}
	}

	@Override
	public void saveType(FieldWrapper field, Class<?> type, Object value, JsonObject json) {
		if (type.equals(Frequency.class)) {
			String name = field.key();
			json.add(name, ((Frequency) value).name());
		}
	}

	@Override
	public boolean supported(Class<?> type) {
		return type.equals(Frequency.class);
	}

	/**
	 * @return {@code true} if the requirements are not met to check for an update.
	 */
	public boolean shouldSkip() {
		return !active || !frequency.check(lastCheck);
	}

	/**
	 * Frequency of updates to check.
	 */
	public enum Frequency {
		ALWAYS(0), DAILY(TimeUnit.DAYS.toMillis(1)), WEEKLY(TimeUnit.DAYS.toMillis(7));

		private final long time;

		Frequency(long time) {
			this.time = time;
		}

		/**
		 * @param lastCheck
		 * 		Last checked time.
		 *
		 * @return {@code true} if the time since the last check is beyond the frequency threshold.
		 */
		public boolean check(long lastCheck) {
			return System.currentTimeMillis() - lastCheck > time;
		}

		@Override
		public String toString() {
			return LangUtil.translate("update.frequency." + name().toLowerCase());
		}
	}
}

```

`src/main/java/me/coley/recaf/config/Config.java`:

```java
package me.coley.recaf.config;

/**
 * Config base.
 *
 * @author Matt
 */
public abstract class Config implements Configurable{
	private final String name;

	/**
	 * @param name
	 * 		Group name.
	 */
	Config(String name) {
		this.name = name;
	}

	/**
	 * @return Group name.
	 */
	public String getName() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/config/ConfigManager.java`:

```java
package me.coley.recaf.config;

import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ConfigurablePlugin;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import static me.coley.recaf.util.Log.*;

/**
 * Config manager.
 *
 * @author Matt
 */
public class ConfigManager {
	private static final String KEY_DISPLAY = "display";
	private static final String KEY_KEYBINDING = "keybinding";
	private static final String KEY_DECOMPILE = "decompile";
	private static final String KEY_ASSEMBLER = "assembler";
	private static final String KEY_UPDATE = "update";
	private static final String KEY_BACKEND = "backend";
	private final Map<String, Config> configs = new HashMap<>();
	private final Map<String, ConfigurablePlugin> pluginConfigs = new HashMap<>();
	private final Path configDirectory;

	/**
	 * Creates new configuration manager instance
	 *
	 * @param configDirectory
	 *     directory where configuration files are stored
	 */
	public ConfigManager(Path configDirectory) {
		this.configDirectory = Objects.requireNonNull(configDirectory, "configDirectory");
	}

	/**
	 * Setup config instances.
	 *
	 * @throws IOException
	 *     if any I/O error occurs
	 */
	public void initialize() throws IOException {
		// Setup each instance
		configs.put(KEY_DISPLAY, new ConfDisplay());
		configs.put(KEY_KEYBINDING, new ConfKeybinding());
		configs.put(KEY_DECOMPILE, new ConfDecompile());
		configs.put(KEY_ASSEMBLER, new ConfAssembler());
		configs.put(KEY_UPDATE, new ConfUpdate());
		configs.put(KEY_BACKEND, new ConfBackend());
		// Plugin instances
		PluginsManager.getInstance().ofType(ConfigurablePlugin.class)
				.forEach(plugin -> pluginConfigs.put(getPluginConfigName(plugin), plugin));
		if (!Files.isDirectory(configDirectory)) {
			Files.createDirectories(configDirectory);
		} else {
			// Load initial values
			load();
		}
	}
	// =============================================================- //

	/**
	 * @return Display configuration.
	 */
	public ConfDisplay display() {
		return (ConfDisplay) configs.get(KEY_DISPLAY);
	}

	/**
	 * @return Keybinding configuration.
	 */
	public ConfKeybinding keys() {
		return (ConfKeybinding) configs.get(KEY_KEYBINDING);
	}

	/**
	 * @return Decompiler configuration.
	 */
	public ConfDecompile decompile() {
		return (ConfDecompile) configs.get(KEY_DECOMPILE);
	}

	/**
	 * @return Assembler configuration.
	 */
	public ConfAssembler assembler() {
		return (ConfAssembler) configs.get(KEY_ASSEMBLER);
	}

	/**
	 * @return Updates configuration.
	 */
	public ConfUpdate update() {
		return (ConfUpdate) configs.get(KEY_UPDATE);
	}

	/**
	 * @return Private configuration.
	 */
	public ConfBackend backend() {
		return (ConfBackend) configs.get(KEY_BACKEND);
	}

	// ============================================================== //

	private void load() {
		trace("Loading configuration");
		for (Configurable c : getConfigs()) {
			Path path = c instanceof Config ?
					resolveConfigPath((Config) c) : resolvePluginConfigPath((ConfigurablePlugin) c);
			try {
				if(Files.exists(path))
					c.load(path);
			} catch(Throwable t) {
				error(t, "Failed to load config: {}", path);
			}
		}
	}

	/**
	 * Saves configuration files.
	 */
	public void save() {
		trace("Saving configuration");
		for (Configurable c : getConfigs()) {
			Path path = c instanceof Config ?
					resolveConfigPath((Config) c) : resolvePluginConfigPath((ConfigurablePlugin) c);
			try {
				c.save(path);
			} catch(IOException ex) {
				error(ex, "Failed to save config: {}", path);
			}
		}
	}

	private Collection<Configurable> getConfigs() {
		Set<Configurable> set = new HashSet<>();
		set.addAll(configs.values());
		set.addAll(pluginConfigs.values());
		return set;
	}

	private Path resolveConfigPath(Config config) {
		return configDirectory.resolve(config.getName() + ".json");
	}

	private Path resolvePluginConfigPath(ConfigurablePlugin plugin) {
		return configDirectory.resolve("plugins").resolve(getPluginConfigName(plugin) + ".json");
	}

	private static String getPluginConfigName(ConfigurablePlugin plugin) {
		return plugin.getName().toLowerCase().replaceAll("\\s+", "_");
	}
}

```

`src/main/java/me/coley/recaf/config/Configurable.java`:

```java
package me.coley.recaf.config;

import com.eclipsesource.json.Json;
import com.eclipsesource.json.JsonArray;
import com.eclipsesource.json.JsonObject;
import com.eclipsesource.json.JsonValue;
import com.eclipsesource.json.WriterConfig;
import me.coley.recaf.util.Resource;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import static me.coley.recaf.util.Log.error;
import static me.coley.recaf.util.Log.warn;

/**
 * A class that has configurable fields that are resolved at runtime.
 *
 * @author Matt
 */
public interface Configurable {
	/**
	 * @param path
	 * 		Path to json file of config.
	 *
	 * @throws IOException
	 * 		When the file cannot be read.
	 */
	@SuppressWarnings({"unchecked", "rawtypes"})
	default void load(Path path) throws IOException {
		JsonObject json = Json.parse(FileUtils.readFileToString(path.toFile(), StandardCharsets.UTF_8)).asObject();
		for(FieldWrapper field : getConfigFields()) {
			String name = field.key();
			if(name == null)
				continue;
			final JsonValue value = json.get(name);
			if(value != null) {
				try {
					Class<?> type = field.type();
					if(type.equals(Boolean.TYPE))
						field.set(value.asBoolean());
					else if(type.equals(Integer.TYPE))
						field.set(value.asInt());
					else if(type.equals(Long.TYPE))
						field.set(value.asLong());
					else if(type.equals(Float.TYPE))
						field.set(value.asFloat());
					else if(type.equals(Double.TYPE))
						field.set(value.asDouble());
					else if(type.equals(String.class))
						field.set(value.asString());
					else if(type.isEnum())
						field.set(Enum.valueOf((Class<? extends Enum>) (Class<?>) field.type(), value.asString()));
					else if(type.equals(Resource.class)) {
						JsonObject object = value.asObject();
						String resPath = object.getString("path", null);
						if(object.getBoolean("internal", true))
							field.set(Resource.internal(resPath));
						else
							field.set(Resource.external(resPath));
					} else if(type.equals(List.class)) {
						List<Object> list = new ArrayList<>();
						JsonArray array = value.asArray();
						// We're gonna assume our lists just hold strings
						array.forEach(v -> {
							if(v.isString())
								list.add(v.asString());
							else
								warn("Didn't properly load config for {}, expected all string arguments", name);
						});
						field.set(list);
					} else if(supported(type))
						loadType(field, type, value);
					else
						warn("Didn't load config for {}, unsure how to serialize.", name);
				} catch(Exception ex) {
					error(ex, "Skipping bad option: {} - {}", path.getFileName(), name);
				}
			}
		}
		onLoad();
	}

	/**
	 * @param path
	 * 		Path to json file of config.
	 *
	 * @throws IOException
	 * 		When the file cannot be written to.
	 */
	@SuppressWarnings("rawtypes")
	default void save(Path path) throws IOException {
		JsonObject json = Json.object();
		for(FieldWrapper field : getConfigFields()) {
			String name = field.key();
			if(name == null)
				continue;
			Object value = field.get();
			if (value == null)
				continue;
			Class<?> type = field.type();
			if(type.equals(Boolean.TYPE))
				json.set(name, (boolean) value);
			else if(type.equals(Integer.TYPE))
				json.set(name, (int) value);
			else if(type.equals(Long.TYPE))
				json.set(name, (long) value);
			else if(type.equals(Float.TYPE))
				json.set(name, (float) value);
			else if(type.equals(Double.TYPE))
				json.set(name, (double) value);
			else if(type.equals(String.class))
				json.set(name, (String) value);
			else if(type.isEnum())
				json.set(name, ((Enum) value).name());
			else if(type.equals(Resource.class)) {
				Resource resource = (Resource) value;
				JsonObject object = new JsonObject();
				object.set("path", resource.getPath());
				object.set("internal", resource.isInternal());
				json.set(name, object);
			} else if(type.equals(List.class)) {
				JsonArray array = Json.array();
				List<?> list = field.get();
				// Don't write if empty/null
				if (list == null || list.isEmpty())
					continue;
				// We're gonna assume our lists just hold strings
				// TODO: Proper generic list writing
				list.forEach(v -> array.add(v.toString()));
				json.set(name, array);
			} else if(supported(type))
				saveType(field, type, value, json);
			else
				warn("Didn't write config for {}, unsure how to serialize type {}.", name, type.getName());
		}
		StringWriter w = new StringWriter();
		json.writeTo(w, WriterConfig.PRETTY_PRINT);
		FileUtils.write(path.toFile(), w.toString(), StandardCharsets.UTF_8);
	}

	/**
	 * @param type
	 * 		Some type.
	 *
	 * @return Config implementation supports serialization of the type.
	 */
	default boolean supported(Class<?> type) {
		if (type.equals(ConfKeybinding.Binding.class))
			return true;
		return false;
	}

	/**
	 * @param field
	 * 		Field accessor.
	 * @param type
	 * 		Field type.
	 * @param value
	 * 		Serialized representation.
	 */
	default void loadType(FieldWrapper field, Class<?> type, JsonValue value) {
		if (type.equals(ConfKeybinding.Binding.class)) {
			List<String> list = new ArrayList<>();
			JsonArray array = value.asArray();
			String name = field.key();
			array.forEach(v -> {
				if(v.isString())
					list.add(v.asString());
				else
					warn("Didn't properly load config for {}, expected all string arguments", name);
			});
			field.set(ConfKeybinding.Binding.from(list));
		}
	}

	/**
	 * @param field
	 * 		Field accessor.
	 * @param type
	 * 		Field type.
	 * @param value
	 * 		Field value.
	 * @param json
	 * 		Json to write value to.
	 */
	default void saveType(FieldWrapper field, Class<?> type, Object value, JsonObject json) {
		if (type.equals(ConfKeybinding.Binding.class)) {
			JsonArray array = Json.array();
			ConfKeybinding.Binding list = field.get();
			// Don't write if empty/null
			if (list == null || list.isEmpty())
				return;
			// Write keys
			list.forEach(array::add);
			json.set(field.key(), array);
		}
	}

	/**
	 * Called on a successful load.
	 */
	default void onLoad() {}

	/**
	 * @return Configurable fields.
	 */
	default List<FieldWrapper> getConfigFields() {
		List<FieldWrapper> fields = new ArrayList<>();
		for (Field field : getClass().getDeclaredFields()){
			Conf conf = field.getAnnotation(Conf.class);
			if (conf == null)
				continue;
			field.setAccessible(true);
			fields.add(new FieldWrapper(this, field, conf));
		}
		return fields;
	}
}

```

`src/main/java/me/coley/recaf/config/FieldWrapper.java`:

```java
package me.coley.recaf.config;

import me.coley.recaf.util.LangUtil;

import java.lang.reflect.Field;

import static me.coley.recaf.util.Log.*;

/**
 * Config field wrapper.
 *
 * @author Matt
 */
public class FieldWrapper {
	private final Configurable instance;
	private final Field field;
	private final Conf conf;

	/**
	 * @param instance
	 * 		Configurable object instance.
	 * @param field
	 * 		Field of configurable value.
	 * @param conf
	 * 		Annotation on field.
	 */
	public FieldWrapper(Configurable instance, Field field, Conf conf) {
		this.instance = instance;
		this.field = field;
		this.conf = conf;
	}

	/**
	 * @return Translation key.
	 */
	public final String key() {
		return conf.value();
	}

	/**
	 * @return {@code true} when the config key is translatable.
	 */
	public final boolean isTranslatable() {
		return !conf.noTranslate();
	}

	/**
	 * @return Translated name.
	 */
	public final String name() {
		return LangUtil.translate(key() + ".name");
	}

	/**
	 * @return Translated description.
	 */
	public final String description() {
		return LangUtil.translate(key() + ".desc");
	}

	/**
	 * @return {@code true} if the field is not intended to be shown.
	 */
	public final boolean hidden() {
		return conf.hide();
	}

	/**
	 * @param <T>
	 * 		Generic type of class.
	 *
	 * @return Declared type of the field.
	 */
	@SuppressWarnings("unchecked")
	public final <T> Class<T> type() {
		return (Class<T>) field.getType();
	}

	/**
	 * @param <T>
	 * 		Field value type.
	 *
	 * @return Field value.
	 */
	@SuppressWarnings("unchecked")
	public final <T> T get() {
		try {
			return (T) field.get(instance);
		} catch(IllegalAccessException ex) {
			error(ex, "Failed to fetch field value: {}", key());
			return null;
		}
	}

	/**
	 * @param value
	 * 		Value to set.
	 */
	public final void set(Object value) {
		try {
			field.set(instance, value);
		} catch(IllegalAccessException ex) {
			error(ex, "Failed to set field value: {}", key());
		}
	}
}

```

`src/main/java/me/coley/recaf/control/Controller.java`:

```java
package me.coley.recaf.control;

import me.coley.recaf.Recaf;
import me.coley.recaf.command.impl.*;
import me.coley.recaf.config.ConfigManager;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.CommandPlugin;
import me.coley.recaf.plugin.api.ExitPlugin;
import me.coley.recaf.plugin.api.StartupPlugin;
import me.coley.recaf.plugin.api.WorkspacePlugin;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.workspace.InstrumentationResource;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.function.Supplier;

import static me.coley.recaf.util.Log.*;

/**
 * Base controller to work off of/invoke commands on.
 *
 * @author Matt
 */
public abstract class Controller implements Runnable {
	private final Map<Class<?>, Supplier<Callable<?>>> actions = new HashMap<>();
	private final ConfigManager configs = new ConfigManager(Recaf.getDirectory("config"));
	private Workspace workspace;
	protected Path initialWorkspace;


	/**
	 * @param workspace
	 * 		Initial workspace path. Can point to a file to load <i>(class, jar)</i> or a workspace
	 * 		configuration <i>(json)</i>.
	 */
	public Controller(Path workspace) {
		this.initialWorkspace = workspace;
	}

	/**
	 * @param workspace Workspace to set.
	 */
	public void setWorkspace(Workspace workspace) {
		Collection<WorkspacePlugin> plugins = PluginsManager.getInstance().ofType(WorkspacePlugin.class);
		Workspace old = this.workspace;
		if (old != null) {
			plugins.forEach(plugin -> plugin.onClosed(old));
		}
		this.workspace = workspace;
		Recaf.setCurrentWorkspace(workspace);
		plugins.forEach(plugin -> plugin.onOpened(workspace));
	}

	/**
	 * @return Current workspace.
	 */
	public final Workspace getWorkspace() {
		return workspace;
	}

	/**
	 * @return Config manager.
	 */
	public ConfigManager config() {
		return configs;
	}

	@Override
	public void run() {
		// Load workspace
		try {
			loadInitialWorkspace();
		} catch(Exception ex) {
			error(ex, "Error loading workspace from file: " + initialWorkspace);
		}
		// Call startup plugins
		PluginsManager.getInstance().ofType(StartupPlugin.class).forEach(plugin -> plugin.onStart(this));
	}

	/**
	 * Try to load the passed initial workspace
	 *
	 * @throws Exception
	 * 		When the load action could not be completed.
	 */
	protected final void loadInitialWorkspace() throws Exception {
		// Check if a workspace to load even exists
		if (initialWorkspace == null)
			return;
		// Attempt to load it
		LoadWorkspace load = get(LoadWorkspace.class);
		load.input = initialWorkspace;
		setWorkspace(load.call());
	}

	/**
	 * @param key
	 * 		The class of the callable to load.
	 * @param <R>
	 * 		Return type of callable.
	 * @param <T>
	 * 		Callable implementation.
	 *
	 * @return New callable instance.
	 */
	@SuppressWarnings("unchecked")
	public <R, T extends Callable<R>> T get(Class<?> key) {
		return (T) actions.get(key).get();
	}

	/**
	 * Setup config and commands.
	 *
	 * @return {@code true} if successful.
	 */
	public boolean setup() {
		// Load config
		boolean success = true;
		try {
			config().initialize();
		} catch (IOException ex) {
			error(ex, "Error initializing ConfigManager");
			success = false;
		}
		// Register commands
		register(LoadWorkspace.class);
		register(WorkspaceInfo.class);
		register(Disassemble.class);
		register(Decompile.class);
		register(Assemble.class);
		register(Export.class);
		register(Search.class);
		register(Remap.class);
		register(Help.class);
		register(Quit.class);
		register(Wait.class);
		register(Run.class);
		// Load command plugins
		PluginsManager.getInstance().ofType(CommandPlugin.class)
				.forEach(commandPlugin -> register(commandPlugin.getClass()));
		return success;
	}

	/**
	 * Register a command class so it can be invoked by the controller.
	 *
	 * @param clazz
	 * 		Command class.
	 * @param <R>
	 * 		Return type of callable.
	 * @param <T>
	 * 		Callable implementation.
	 */
	@SuppressWarnings("unchecked")
	protected <R, T extends Callable<R>> void register(Class<T> clazz) {
		actions.put(clazz, () -> {
			try {
				return clazz.newInstance();
			} catch (Exception e) {
				throw new IllegalStateException("Failed to generate callable instance of: " +
						clazz.getName());
			}
		});
		for (Class<?> subclass : clazz.getDeclaredClasses()) {
			try {
				Class<T> cubcast = (Class<T>) subclass;
				actions.put(cubcast, () -> {
					try {
						return cubcast.newInstance();
					} catch(Exception e) {
						throw new IllegalStateException("Failed to generate callable instance of: " +
								cubcast.getName());
					}
				});
			} catch(ClassCastException ex) {
				error("Failed to setup subcommand: " + subclass.getName());
				throw new IllegalStateException("Failed to setup subcommand: " + subclass.getName(), ex);
			}
		}
	}

	/**
	 * Close Recaf.
	 */
	public void exit() {
		info("Shutting down");
		PluginsManager.getInstance()
				.ofType(ExitPlugin.class)
				.forEach(plugin -> plugin.onExit(this));
		config().save();
		ThreadUtil.shutdown();
		if (!InstrumentationResource.isActive()) {
			System.exit(0);
		}
	}
}

```

`src/main/java/me/coley/recaf/control/gui/GuiController.java`:

```java
package me.coley.recaf.control.gui;

import javafx.concurrent.Task;
import me.coley.recaf.command.impl.LoadWorkspace;
import me.coley.recaf.control.Controller;
import me.coley.recaf.plugin.PluginKeybinds;
import me.coley.recaf.ui.MainWindow;
import me.coley.recaf.ui.controls.ExceptionAlert;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.workspace.Workspace;

import java.nio.file.Path;
import java.util.concurrent.ScheduledFuture;
import java.util.function.Consumer;

import static me.coley.recaf.util.Log.*;

/**
 * Gui controller.
 *
 * @author Matt
 */
public class GuiController extends Controller {
	private WindowManager windows;

	/**
	 * @param workspace
	 * 		Initial workspace path. Can point to a file to load <i>(class, jar)</i> or a workspace
	 * 		configuration <i>(json)</i>.
	 */
	public GuiController(Path workspace) {
		super(workspace);
	}

	@Override
	public boolean setup() {
		boolean succeed = super.setup();
		windows = new WindowManager(this);
		return succeed;
	}

	@Override
	public void run() {
		windows.setMainWindow(MainWindow.get(this));
		super.run();
		PluginKeybinds.getInstance().setup();
	}


	/**
	 * Asynchronously load a workspace from the given file.
	 *
	 * @param path
	 * 		Path to workspace file.
	 * @param action
	 * 		Additional action to run with success/fail result.
	 */
	public void loadWorkspace(Path path, Consumer<Boolean> action) {
		Task<?> loadTask = loadWorkspace(path);
		MainWindow main = windows.getMainWindow();
		loadTask.messageProperty().addListener((n, o, v) -> main.status(v));
		loadTask.setOnRunning(e -> {
			// Clear current items since we want to load a new workspace
			main.clear();
			main.disable(true);
		});
		loadTask.setOnSucceeded(e -> {
			// Load success
			main.disable(false);
			if (action != null)
				action.accept(true);
			// Update recently loaded
			config().backend().onLoad(path, config().display().getMaxRecent());
			main.getMenubar().updateRecent();
		});
		loadTask.setOnFailed(e -> {
			// Log failure reason
			Throwable t = e.getSource().getException();
			if (t != null) {
				error(t, "Failed to open file: {}", path.getFileName());
				ExceptionAlert.show(t, "Failed to open file: " + path.getFileName());
			}
			// Load failure
			main.status("Failed to open file:\n" + path.getFileName());
			main.disable(false);
			if (action != null)
				action.accept(false);
		});
		ThreadUtil.run(loadTask);
	}

	/**
	 * @param path
	 * 		Path to workspace file to open.
	 *
	 * @return Task to load the given workspace.
	 */
	private Task<?> loadWorkspace(Path path) {
		return new Task<Void>() {
			@Override
			protected Void call() throws Exception {
				LoadWorkspace loader = new LoadWorkspace();
				loader.input = path;
				// This ugly garbage handles updating the UI with the progress message
				// and how long that message has been shown for in seconds/millis
				long updateInterval = 16;
				long start = System.currentTimeMillis();
				ScheduledFuture<?> future = ThreadUtil.runRepeated(updateInterval, () -> {
					long time = System.currentTimeMillis() - start;
					updateMessage(loader.getStatus() +
							String.format("\n- Elapsed: %02d.%02d", time / 1000, (time % 1000)));
				});
				// Start the load process
				setWorkspace(loader.call());
				windows.getMainWindow().clearTabViewports();
				config().backend().onLoad(path, config().display().getMaxRecent());
				// Stop message updates
				future.cancel(true);
				return null;
			}
		};
	}

	/**
	 * @param workspace
	 * 		Workspace to set.
	 */
	@Override
	public void setWorkspace(Workspace workspace) {
		super.setWorkspace(workspace);
		MainWindow mainWindow = windows().getMainWindow();
		// Update title with primary input name
		mainWindow.setTitle("Recaf | " + workspace.getPrimary().getShortName());
	}

	/**
	 * @return Window manager.
	 */
	public WindowManager windows() {
		return windows;
	}
}

```

`src/main/java/me/coley/recaf/control/gui/WindowManager.java`:

```java
package me.coley.recaf.control.gui;

import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.stage.Screen;
import javafx.stage.Stage;
import me.coley.recaf.ui.MainWindow;
import me.coley.recaf.util.Resource;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import static me.coley.recaf.util.ClasspathUtil.*;
import static me.coley.recaf.ui.controls.FontSlider.addFontSizeStyleSheet;
import static me.coley.recaf.ui.controls.FontComboBox.addMonoFontStyleSheet;


/**
 * Window manager.
 *
 * @author Matt
 */
public class WindowManager {
	private final GuiController controller;
	private final Set<Stage> windows = new LinkedHashSet<>();
	private MainWindow mainWindow;
	private Stage configWindow;
	private Stage themeEditorWindow;
	private Stage attachWindow;
	private Stage jvmCreatorWindow;
	private Stage historyWindow;
	private Stage informationWindow;
	private Stage contactWindow;
	private Stage pluginsWindow;

	WindowManager(GuiController controller) {
		this.controller = controller;
	}

	/**
	 * Create an auto-sized scene for the given content.
	 *
	 * @param title
	 * 		Window title.
	 * @param content
	 * 		Content to fill scene.
	 *
	 * @return Scene with content.
	 */
	public Stage window(String title, Parent content) {
		return window(title, content, -1, -1);
	}

	/**
	 * Create a window with a given size.
	 *
	 * @param title
	 * 		Window title.
	 * @param content
	 * 		Content to fill scene.
	 * @param width
	 * 		Scene width.
	 * @param height
	 * 		Scene height.
	 *
	 * @return Window with content of the given size.
	 */
	public Stage window(String title, Parent content, int width, int height) {
		// Create sized scene
		Scene scene;
		if (width > 0 && height > 0)
			scene = new Scene(content, width, height);
		else
			scene = new Scene(content);
		// Add style-sheets
		reapplyStyle(scene);
		// Create window
		Stage stage = new Stage();
		stage.setScene(scene);
		stage.getIcons().add(new Image(resource("icons/logo.png")));
		stage.setTitle(title);
		controller.config().keys().registerWindowKeys(controller, stage, scene);
		// Active window handling
		stage.setOnShown(e -> {
			stage.requestFocus();
			windows.add(stage);
		});
		stage.setOnCloseRequest(e -> {
			windows.remove(stage);
		});
		// Set window owner to main window
		if (mainWindow != null && Screen.getScreens().size() > 1) {
			stage.initOwner(mainWindow.getStage());
			stage.setAlwaysOnTop(false);
		}
		return stage;
	}

	/**
	 * Applies the current style to all scenes.
	 */
	public void reapplyStyles() {
		List<Stage> windows = new ArrayList<>(getWindows());
		windows.add(getMainWindow().getStage());
		windows.add(getConfigWindow());
		windows.add(getAttachWindow());
		windows.add(getThemeEditorWindow());
		windows.forEach(s -> {
			if(s != null)
				reapplyStyle(s.getScene());
		});
	}

	/**
	 * Applies the current style to the given scene.
	 *
	 * @param scene
	 * 		Scene to reapply styles to.
	 */
	public void reapplyStyle(Scene scene) {
		Resource appStyle = controller.config().display().appStyle;
		Resource textStyle = controller.config().display().textStyle;
		Resource[] fallbacks = new Resource[]{
			Resource.internal("/style/base.css"),
			Resource.internal("/style/ui-default.css"),
			Resource.internal("/style/text-default.css")};
		Resource[] paths = new Resource[]{
			fallbacks[0],
			appStyle,
			textStyle
		};
		// Clear, then reapply sheets
		scene.getStylesheets().clear();
		for(int i = 0; i < paths.length; i++) {
			Resource resource = paths[i];
			if(resource.isInternal()) {
				// Load internal stylesheet
				String path = resource.getPath();
				if(resourceExists(path))
					scene.getStylesheets().add(path);
				else
					scene.getStylesheets().add(fallbacks[i].getPath());
			} else {
				// Load external stylesheet
				try {
					URL url = resource.getURL();
					if(new File(url.getFile()).exists())
						scene.getStylesheets().add(url.toString());
					else
						throw new IOException("Failed to load CSS: " + url);
				} catch(IOException ex) {
					scene.getStylesheets().add(fallbacks[i].getPath());
				}
			}
		}
		addFontSizeStyleSheet(scene);
		addMonoFontStyleSheet(scene);
	}

	/**
	 * @return Active windows, excluding the {@link #getMainWindow() main window}.
	 */
	public Set<Stage> getWindows() {
		return windows;
	}


	/**
	 * @param window
	 * 		Main Recaf window.
	 */
	public void setMainWindow(MainWindow window) {
		this.mainWindow = window;
	}

	/**
	 * @return Main Recaf window.
	 */
	public MainWindow getMainWindow() {
		return mainWindow;
	}

	/**
	 * @return Theme editor window.
	 */
	public Stage getThemeEditorWindow() {
		return themeEditorWindow;
	}

	/**
	 * @param window
	 * 		Theme editor window
	 */
	public void setThemeEditorWindow(Stage window) {
		this.themeEditorWindow = window;
	}

	/**
	 * @return Config window.
	 */
	public Stage getConfigWindow() {
		return configWindow;
	}

	/**
	 * @param window
	 * 		Config window
	 */
	public void setConfigWindow(Stage window) {
		this.configWindow = window;
	}

	/**
	 * @param window
	 * 		Attach window.
	 */
	public void setAttachWindow(Stage window) {
		this.attachWindow = window;
	}

	/**
	 * @return Attach window.
	 */
	public Stage getAttachWindow() {
		return attachWindow;
	}

	/**
	 * @param window
	 * 		JVM creator window.
	 */
	public void setJvmCreatorWindow(Stage window) {
		this.jvmCreatorWindow = window;
	}

	/**
	 * @return JVM creator window.
	 */
	public Stage getJvmCreatorWindow() {
		return jvmCreatorWindow;
	}

	/**
	 * @param window
	 * 		History window.
	 */
	public void setHistoryWindow(Stage window) {
		this.historyWindow = window;
	}

	/**
	 * @return History window.
	 */
	public Stage getHistoryWindow() {
		return historyWindow;
	}

	/**
	 * @return Information window.
	 */
	public Stage getInformationWindow() {
		return informationWindow;
	}

	/**
	 * @param window
	 * 		Information window.
	 */
	public void setInformationWindow(Stage window) {
		this.informationWindow = window;
	}

	/**
	 * @return Contact window.
	 */
	public Stage getContactWindow() {
		return contactWindow;
	}

	/**
	 * @param window
	 * 		Contact window.
	 */
	public void setContactWindow(Stage window) {
		this.contactWindow = window;
	}

	/**
	 * @return Plugin manager window.
	 */
	public Stage getPluginsWindow() {
		return pluginsWindow;
	}

	/**
	 * @param window
	 * 		Plugin manager window.
	 */
	public void setPluginsWindow(Stage window) {
		this.pluginsWindow = window;
	}
}

```

`src/main/java/me/coley/recaf/control/headless/HeadlessController.java`:

```java
package me.coley.recaf.control.headless;

import me.coley.recaf.command.ControllerCommand;
import me.coley.recaf.command.MetaCommand;
import me.coley.recaf.command.impl.*;
import me.coley.recaf.control.Controller;
import me.coley.recaf.parse.bytecode.parser.NumericParser;
import me.coley.recaf.search.SearchCollector;
import me.coley.recaf.search.SearchResult;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.RegexUtil;
import picocli.CommandLine;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.function.Consumer;

import static me.coley.recaf.util.Log.*;

/**
 * Command line controller.
 *
 * @author Matt
 */
public class HeadlessController extends Controller {
	private final Map<String, Class<?>> lookup = new HashMap<>();
	private final Map<Class<?>, Consumer<?>> handlers = new HashMap<>();
	private final Path script;
	private boolean running = true;
	private JLineAdapter jline;

	/**
	 * @param workspace
	 * 		Initial workspace path. Can point to a file to load <i>(class, jar)</i> or a workspace
	 * 		configuration <i>(json)</i>.
	 * @param script
	 * 		Script to run. May be {@code null}. If not {@code null} the commands will be executed
	 * 		then Recaf will terminate.
	 */
	public HeadlessController(Path workspace, Path script) {
		super(workspace);
		this.script = script;
	}

	@Override
	public void run() {
		super.run();
		// Start
		if(script != null) {
			// Script means no user input
			if(getWorkspace() == null)
				throw new IllegalArgumentException("No workspace was provided");
			//Parse script
			List<String> lines;
			try {
				lines = Files.readAllLines(script, StandardCharsets.UTF_8);
			} catch(IOException ex) {
				throw new IllegalArgumentException("Script file could not be read: " + script, ex);
			}
			// Run script
			for(String line : lines)
				handle(line);
		} else {
			// Interactive input
			try {
				jline = new JLineAdapter(this, this::handle);
				jline.loop();
			} catch(IOException ex) {
				throw new IllegalStateException("Failed to initialize terminal");
			}
		}
	}

	/**
	 * Handle user input string.
	 *
	 * @param in
	 * 		Line of input.
	 */
	private void handle(String in) {
		debug("Command: " + in);
		// Fetch command class
		int argsOffset = 1;
		// Split by
		String[] split = RegexUtil.wordSplit(in);
		if (split.length == 0)
			return;
		String name = split[0];
		Class<?> key = getClass(name);
		if (key == null) {
			error("No such command: '" + name + "'");
			return;
		}
		// Check for subcommand
		if(key.getDeclaredClasses().length > 0 && split.length > 1) {
			String tmpName = name + " " + split[argsOffset];
			Class<?> tmpKey = getClass(tmpName);
			if(tmpKey != null) {
				key = tmpKey;
				argsOffset++;
			}
		}
		Callable<?> command = get(key);
		String[] args = Arrays.copyOfRange(split, argsOffset, split.length);
		// Picocli command handling
		CommandLine cmd = new CommandLine(command);
		cmd.registerConverter(Number.class, s -> new NumericParser().visit(0, s).getValue());
		try {
			// Verify command can execute
			if (command instanceof ControllerCommand) {
				ControllerCommand wsCommand = (ControllerCommand)command;
				wsCommand.setController(this);
				wsCommand.verify();
			}
			// Have picocli auto-populate annotated fields.
			cmd.parseArgs(args);
			// Meta commands should be fed command info after field population for some reason... odd
			if (command instanceof MetaCommand)
				((MetaCommand) command).setContext(cmd);
			// Give help command access to all other commands
			if (command instanceof Help)
				for (Map.Entry<String, Class<?>> subCommEntry : lookup.entrySet())
					if (!subCommEntry.getKey().contains(" "))
						cmd.addSubcommand(new CommandLine(get(subCommEntry.getValue())));
			// Invoke the command
			cmd.setExecutionResult(command.call());
			// Handle result
			if (handlers.containsKey(key))
				handlers.get(key).accept(cmd.getExecutionResult());
		} catch (CommandLine.ParameterException ex) {
			// Raised from invalid user input, show usage and error.
			error(ex.getMessage() + "\nSee 'help " + name + "' for usage.");
			//ex.printStackTrace();
		} catch (Exception ex) {
			// Raised from callable command
			error(ex, "Command '{}' threw an exception", name);
		}
	}

	/**
	 * @return Interactive terminal session is still active.
	 */
	public boolean isRunning() {
		return running;
	}

	/**
	 * @return Map of command names to their classes.
	 */
	public Map<String, Class<?>> getLookup() {
		return lookup;
	}

	/**
	 * @param name
	 * 		Command name.
	 * @param <R>
	 * 		Return type of callable.
	 * @param <T>
	 * 		Callable implementation.
	 *
	 * @return Class of command.
	 */
	@SuppressWarnings("unchecked")
	private <R, T extends Callable<R>> Class<T> getClass(String name) {
		return (Class<T>) lookup.get(name);
	}

	@Override
	protected <R, T extends Callable<R>> void register(Class<T> clazz) {
		super.register(clazz);
		// Add name lookup
		CommandLine.Command comm =  clazz.getDeclaredAnnotation(CommandLine.Command.class);
		if (comm == null)
			throw new IllegalStateException("Callable class does not have required command annotation: " +
					clazz.getName());
		String name = comm.name();
		lookup.put(name, clazz);
		// Add name lookup for sub-commands
		for(Class<?> subclass : comm.subcommands()) {
			comm = subclass.getDeclaredAnnotation(CommandLine.Command.class);
			if(comm == null)
				throw new IllegalStateException("Callable class does not have required command annotation: " +
						subclass.getName());
			String subname = comm.name();
			lookup.put(name + " " + subname, subclass);
		}
	}

	/**
	 * @param clazz
	 * 		Command class.
	 * @param consumer
	 * 		Consumer that handles the return value of the command.
	 * @param <R>
	 * 		Return type of callable.
	 * @param <T>
	 * 		Callable implementation.
	 */
	private <R, T extends Callable<R>> void registerHandler(Class<T> clazz, Consumer<R> consumer) {
		handlers.put(clazz, consumer);
	}

	@Override
	public boolean setup() {
		boolean success = super.setup();
		//
		Consumer<SearchCollector> printResults = r -> {
			for (SearchResult res : r.getAllResults())
				info("{}\n{}", res.getContext(), res.toString());
		};
		//
		registerHandler(Disassemble.class, v -> {
			// Interactive if JLine is active and no external output is given
			// - Intent is that external output implies potential external scripting
			if (jline == null || v.getDestination() != null)
				info(v.getDisassembled());
			else
				jline.handleDisassemble(v);
		});
		registerHandler(LoadWorkspace.class, this::setWorkspace);
		registerHandler(Decompile.class, Log::info);
		registerHandler(Search.ClassInheritance.class, printResults);
		registerHandler(Search.ClassName.class, printResults);
		registerHandler(Search.Member.class, printResults);
		registerHandler(Search.ClassUsage.class, printResults);
		registerHandler(Search.MemberUsage.class, printResults);
		registerHandler(Search.Text.class, printResults);
		registerHandler(Search.Value.class, printResults);
		registerHandler(Search.Disass.class, printResults);
		registerHandler(Quit.class, v -> running = false);
		return success;
	}
}

```

`src/main/java/me/coley/recaf/control/headless/JLineAdapter.java`:

```java
package me.coley.recaf.control.headless;

import me.coley.recaf.command.impl.Disassemble;
import me.coley.recaf.command.impl.LoadWorkspace;
import org.jline.reader.*;
import org.jline.reader.impl.DefaultParser;
import org.jline.terminal.Terminal;
import org.jline.terminal.TerminalBuilder;
import org.objectweb.asm.*;
import picocli.CommandLine;
import picocli.shell.jline3.PicocliJLineCompleter;

import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.function.Consumer;
import java.util.logging.*;
import java.util.stream.Collectors;

import static me.coley.recaf.util.Log.*;

/**
 * JLine tie-in for the headless controller. Allows tab-completion on supported terminals.
 *
 * @author Matt
 */
public class JLineAdapter implements Opcodes {
	private HeadlessController controller;
	private final Consumer<String> handler;
	private Terminal terminal;
	private LineReader reader;

	/**
	 * @param controller
	 * 		Controller context.
	 * @param handler
	 * 		Command input handler.
	 *
	 * @throws IOException
	 * 		Thrown when the terminal cannot be built.
	 */
	JLineAdapter(HeadlessController controller, Consumer<String> handler)throws IOException {
		this.controller = controller;
		this.handler = handler;
		setupJLine();
		checkWorkspace();
	}

	private void setupJLine() throws IOException {
		terminal = TerminalBuilder.builder().build();
		reader = setupCompletionReader(terminal, controller.getLookup());
	}

	private void checkWorkspace() {
		// Ensure a workspace is open
		if(controller.getWorkspace() == null) {
			info("Please input the path to a java program (class, jar) " + "or workspace " +
					"file (json).\nSee documentation below:\n");
			usage(controller.get(LoadWorkspace.class));
		}
	}

	/**
	 * Handle input with JLine.
	 */
	void loop() {
		// Prompt & run commands from user input
		while(controller.isRunning()) {
			try {
				String line = reader.readLine("\n$ ", null, (MaskingCallback) null, null);
				ParsedLine pl = reader.getParser().parse(line, 0);
				handler.accept(pl.line());
			} catch(UserInterruptException e) {
				// Ignore
			} catch(EndOfFileException e) {
				return;
			}
		}
	}

	/**
	 * Print usage of command.
	 *
	 * @param command
	 * 		Command to show usage of.
	 */
	private void usage(Callable<?> command) {
		CommandLine cmd = new CommandLine(command);
		cmd.usage(cmd.getOut());
	}

	/**
	 * @param terminal
	 * 		Terminal to add tab-completion to.
	 * @param lookup
	 * 		Map containing commands.
	 *
	 * @return Reader with tab-completion.
	 */
	private static LineReader setupCompletionReader(Terminal terminal, Map<String, Class<?>> lookup) {
		// Filter root level commands
		Collection<Class<?>> commands =	lookup.entrySet().stream()
				.filter(e -> !e.getKey().contains(" "))
				.map(Map.Entry::getValue)
				.collect(Collectors.toList());
		// Pass dummy to pico for tab-completion
		CommandLine cmd = new CommandLine(SubContainerGenerator.generate(commands));
		return LineReaderBuilder.builder()
				.terminal(terminal)
				.completer(new PicocliJLineCompleter(cmd.getCommandSpec()))
				.parser(new DefaultParser())
				.build();
	}

	/**
	 * Use the JLine nano tool to modify the disassembled code.
	 *
	 * @param result
	 * 		Disassemble output wrapper.
	 */
	void handleDisassemble(Disassemble.Result result) {
		JLineEditor editor = new JLineEditor(terminal);
		editor.open(result);
	}

	static {
		// Disable native JLine logging
		java.util.logging.Logger.getLogger("org.jline").setLevel(Level.OFF);
	}
}

```

`src/main/java/me/coley/recaf/control/headless/JLineEditor.java`:

```java
package me.coley.recaf.control.headless;

import me.coley.recaf.Recaf;
import me.coley.recaf.command.impl.Disassemble;
import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ClassVisitorPlugin;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;
import org.apache.commons.io.FileUtils;
import org.jline.builtins.Nano;
import org.jline.terminal.Terminal;
import org.jline.utils.InfoCmp;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.*;

import java.io.File;
import java.io.IOException;

import static java.nio.charset.StandardCharsets.UTF_8;
import static me.coley.recaf.util.Log.*;

/**
 * A utility using JLine to interactively editing varied content.
 *
 * @author Matt
 */
public class JLineEditor {
	private final Terminal terminal;

	/**
	 * Create a editor with the JLine terminal.
	 *
	 * @param terminal Terminal to work off of.
	 */
	public JLineEditor(Terminal terminal) {
		this.terminal = terminal;
	}

	/**
	 * Open an editor with the given title / file to load from. Blocks until the editor is closed.
	 *
	 * @param title
	 * 		Editor title.
	 * @param file
	 * 		File containing content to read/write to.
	 *
	 * @throws IOException
	 * 		Thrown if the file cannot be opened.
	 */
	private void openEditor(String title, File file) throws IOException {
		Nano nano = new Nano(terminal, file);
		nano.title = title;
		nano.open(file.getAbsolutePath());
		nano.run();
		terminal.puts(InfoCmp.Capability.clear_screen);
		terminal.flush();
	}

	/**
	 * Open and handle editing disassembled method code.
	 *
	 * @param wrapper
	 * 		Disassembly results.
	 */
	public void open(Disassemble.Result wrapper) {
		try {
			MethodNode mn = wrapper.getMethod();
			ClassNode cn = wrapper.getOwner();
			// Write disassembled text to file
			File tmp = File.createTempFile("recaf", "disass");
			FileUtils.write(tmp, wrapper.getDisassembled(), UTF_8);
			long last = tmp.lastModified();
			// Open editor
			openEditor("Assembler", tmp);
			// Check if any edits occured.
			if (tmp.lastModified() == last)
				return;
			// Assemble modified code
			String code = FileUtils.readFileToString(tmp, UTF_8);
			ParseResult<RootAST> result = Parse.parse(code);
			MethodAssembler assembler = new MethodAssembler(cn.name, Recaf.getController());
			MethodNode generated = assembler.compile(result);
			// Replace method
			int index = cn.methods.indexOf(mn);
			if(index >= 0) {
				MethodNode old = cn.methods.get(index);
				ClassUtil.copyMethodMetadata(old, generated);
				cn.methods.set(index, generated);
			}
			else
				throw new IllegalStateException("Failed to replace method, " +
						"modified method no longer exists in the class?");
			Workspace workspace = Recaf.getCurrentWorkspace();
			ClassWriter cw = workspace.createWriter(ClassWriter.COMPUTE_FRAMES);
			ClassVisitor visitor = cw;
			for (ClassVisitorPlugin visitorPlugin : PluginsManager.getInstance()
					.ofType(ClassVisitorPlugin.class)) {
				visitor = visitorPlugin.intercept(visitor);
			}
			cn.accept(visitor);
			byte[] value = cw.toByteArray();
			workspace.getPrimary().getClasses().put(cn.name, value);
			// Cleanup temp
			tmp.delete();
			info("Updated {}.{}{}", cn.name, mn.name, mn.desc);
		} catch(AssemblerException ex) {
			if (ex.getLine() >= 0)
				error(ex, "Line: " + ex.getLine() + " - " +  ex.getMessage());
			else
				error(ex, ex.getMessage());
		} catch(IOException ex) {
			error(ex, "IO error");
		}
	}
}

```

`src/main/java/me/coley/recaf/control/headless/SubContainerGenerator.java`:

```java
package me.coley.recaf.control.headless;

import me.coley.recaf.util.DefineUtil;
import org.objectweb.asm.*;
import picocli.shell.jline3.PicocliJLineCompleter;

import java.util.Collection;

/**
 * Generator that creates a class containing subcommands for picocli.
 * Useful for tab-completion.
 *
 * @author Matt
 */
public class SubContainerGenerator implements Opcodes {
	/**
	 * @param commands
	 * 		List of sub-commands to support in the generated command.
	 *
	 * @return A picocli command instance that contains lists all the given commands as static
	 * sub-command references.
	 */
	public static Object generate(Collection<Class<?>> commands) {
		// Create a dummy command class that has all classes as subcommands
		byte[] code = createDummyCommand(commands);
		// Make an isntance of the dummy command
		try {
			return DefineUtil.create("me.coley.recaf.command.JLineCompat", code);
		} catch(Exception ex) {
			throw new IllegalStateException("Failed to generate JLine compatibility class!", ex);
		}
	}

	/**
	 * @param commands
	 * 		Collection of sub-commands to add to the generated class.
	 *
	 * @return A generated class used for the {@link PicocliJLineCompleter}
	 */
	private static byte[] createDummyCommand(Collection<Class<?>> commands) {
		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
		MethodVisitor mv;
		AnnotationVisitor avCommand;
		// Extend runnable to support picocli signature.
		cw.visit(52, ACC_PUBLIC + ACC_SUPER, "me/coley/recaf/command/JLineCompat", null, "java" +
				"/lang/Object", new String[]{"java/lang/Runnable"});
		// Setup the annotation
		avCommand = cw.visitAnnotation("Lpicocli/CommandLine$Command;", true);
		// Hidden so we don't see this generated class.
		// - Would be bad for tab completion
		avCommand.visit("hidden", Boolean.TRUE);
		avCommand.visit("name", "shell");
		AnnotationVisitor avDesc = avCommand.visitArray("description");
		avDesc.visit(null, "CLI implementation");
		avDesc.visitEnd();
		// Add our subcommands
		AnnotationVisitor avSubCommands = avCommand.visitArray("subcommands");
		for(Class<?> c : commands)
			avSubCommands.visit(null, Type.getType("L" + c.getName().replace(".", "/") + ";"));
		avSubCommands.visitEnd();
		avCommand.visitEnd();
		//
		cw.visitInnerClass("picocli/CommandLine$Command", "picocli/CommandLine", "Command",
				ACC_PUBLIC + ACC_STATIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE);
		// Create constructor
		mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
		mv.visitCode();
		mv.visitVarInsn(ALOAD, 0);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		mv.visitInsn(RETURN);
		mv.visitMaxs(1, 1);
		mv.visitEnd();
		// Create Runnable.run()
		mv = cw.visitMethod(ACC_PUBLIC, "run", "()V", null, null);
		mv.visitCode();
		mv.visitInsn(RETURN);
		mv.visitMaxs(2, 1);
		mv.visitEnd();
		cw.visitEnd();
		return cw.toByteArray();
	}
}

```

`src/main/java/me/coley/recaf/decompile/DecompileImpl.java`:

```java
package me.coley.recaf.decompile;

import com.strobel.Procyon;
import me.coley.recaf.control.Controller;
import me.coley.recaf.decompile.cfr.CfrDecompiler;
import me.coley.recaf.decompile.fernflower.FernFlowerDecompiler;
import me.coley.recaf.decompile.procyon.ProcyonDecompiler;
import me.coley.recaf.util.StringUtil;
import org.benf.cfr.reader.util.CfrVersionInfo;

import java.util.function.Function;

/**
 * Enumeration of implemented decompilers.
 *
 * @author Matt
 */
public enum DecompileImpl {
	CFR(CfrDecompiler::new),
	FERNFLOWER(FernFlowerDecompiler::new),
	PROCYON(ProcyonDecompiler::new);

	private final Function<Controller, Decompiler> supplier;

	DecompileImpl(Function<Controller, Decompiler> supplier) {
		this.supplier = supplier;
	}

	/**
	 * @param controller
	 * 		Controller to use.
	 *
	 * @return New decompiler instance of the type.
	 */
	public Decompiler create(Controller controller) {
		return supplier.apply(controller);
	}

	@Override
	public String toString() {
		switch(this) {
			case CFR:
				return "CFR";
			case FERNFLOWER:
				return "FernFlower";
			case PROCYON:
				return "Procyon";
			default:
				return StringUtil.toString(this);
		}
	}

	/**
	 * @return String representation of the decompiler with version number included.
	 */
	public String getNameAndVersion() {
		switch(this) {
			case CFR:
				return "CFR " + CfrVersionInfo.VERSION;
			case FERNFLOWER:
				return "FernFlower"; // Fernflower does not have an easily accessible version number...
			case PROCYON:
				return "Procyon " + Procyon.version();
			default:
				return StringUtil.toString(this);
		}
	}
}

```

`src/main/java/me/coley/recaf/decompile/Decompiler.java`:

```java
package me.coley.recaf.decompile;

import me.coley.recaf.control.Controller;

import java.util.*;

/**
 * Decompiler base.
 *
 * @param <OptionType>
 * 		Type used by decompiler implementation for options.
 *
 * @author Matt.
 */
public abstract class Decompiler<OptionType> {
	private final Controller controller;
	private final Map<String, OptionType> defaultOptions;
	private Map<String, OptionType> options;

	/**
	 * Initialize the decompiler wrapper.
	 *
	 * @param controller
	 * 		Controller with configuration to pull from and the workspace to pull classes from.
	 */
	public Decompiler(Controller controller) {
		this.controller = controller;
		this.defaultOptions = Collections.unmodifiableMap(generateDefaultOptions());
		this.options = new HashMap<>(defaultOptions);
	}

	/**
	 * @return Controller with configuration to pull from and the workspace to pull classes from.
	 */
	protected Controller getController() {
		return controller;
	}

	/**
	 * @return Map of the current options.
	 */
	public Map<String, OptionType> getOptions() {
		return options;
	}

	/**
	 * @param options
	 * 		Map of the options to use.
	 */
	public void setOptions(Map<String, OptionType> options) {
		this.options = options;
	}

	/**
	 * @return Map of the default decompiler options.
	 */
	public Map<String, OptionType> getDefaultOptions() {
		return defaultOptions;
	}

	/**
	 * @return Map of the default decompiler options.
	 */
	protected abstract Map<String, OptionType> generateDefaultOptions();

	/**
	 * @param name
	 * 		Name of the class to decompile.
	 *
	 * @return Decompiled text of the class.
	 */
	public abstract String decompile(String name);
}
```

`src/main/java/me/coley/recaf/decompile/cfr/CfrDecompiler.java`:

```java
package me.coley.recaf.decompile.cfr;

import me.coley.recaf.config.ConfDecompile;
import me.coley.recaf.control.Controller;
import me.coley.recaf.decompile.Decompiler;
import me.coley.recaf.util.AccessFlag;
import org.benf.cfr.reader.api.CfrDriver;
import org.benf.cfr.reader.util.getopt.OptionDecoderParam;
import org.benf.cfr.reader.util.getopt.OptionsImpl;
import org.benf.cfr.reader.util.getopt.PermittedOptionProvider;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * CFR decompiler implementation.
 *
 * @author Matt
 */
public class CfrDecompiler extends Decompiler<String> {
	/**
	 * Initialize the decompiler wrapper.
	 *
	 * @param controller
	 * 		Controller with configuration to pull from and the workspace to pull classes from.
	 */
	public CfrDecompiler(Controller controller) {
		super(controller);
	}

	@Override
	protected Map<String, String> generateDefaultOptions() {
		Map<String, String> map = new HashMap<>();
		for (PermittedOptionProvider.ArgumentParam<?, ?> param : OptionsImpl.getFactory()
				.getArguments()) {
			String defaultValue = getOptValue(param);
			if (defaultValue != null) {
				// For options that depend on other options or class file specifics, ignore them
				if (defaultValue.contains("Value of option") || defaultValue.contains("if class"))
					continue;
				// Only populate boolean options
				if (defaultValue.equals("true") || defaultValue.equals("false"))
					map.put(param.getName(), defaultValue);
				// There are only a few non-boolean options, and even supplying 'recpass'
				// causes some issues in edge cases (https://github.com/leibnitz27/cfr/issues/253)
			}
		}
		ConfDecompile config = getController().config().decompile();
		if (config.showSynthetic) {
			// CFR doesn't have options against intentional marking of ACC_SYNTHETIC by obfuscators :/
			// This will only show ACC_BRIDGE but not ACC_SYNTHETIC
			map.put("hidebridgemethods", "false");
			// And this, will only show ACC_SYNTHETIC in certain cases so it isn't that useful
			// map.put("removeinnerclasssynthetics", "true");
		}
		return map;
	}

	@Override
	public String decompile(String name) {
		ClassSource source = new ClassSource(getController());
		SinkFactoryImpl sink = new SinkFactoryImpl();
		CfrDriver driver = new CfrDriver.Builder()
				.withClassFileSource(source)
				.withOutputSink(sink)
				.withOptions(getOptions())
				.build();
		driver.analyse(Collections.singletonList(name));
		String decompile = sink.getDecompilation();
		if (decompile == null)
			return "// ERROR: Failed to decompile '" + name + "'";
		return clean(decompile, name);
	}

	/**
	 * Remove watermark &amp; oddities from decompilation output.
	 *
	 * @param decompilationText
	 * 		Decompilation text.
	 * @param className
	 * 		Class name.
	 *
	 * @return Decompilation without watermark.
	 */
	private String clean(String decompilationText, String className) {
		// Get rid of header comment
		if (decompilationText.startsWith("/*\n * Decompiled with CFR"))
			decompilationText = decompilationText.substring(decompilationText.indexOf("*/") + 3);
		// JavaParser does NOT like inline comments like this.
		decompilationText = decompilationText.replace("/* synthetic */ ", "");
		decompilationText = decompilationText.replace("/* bridge */ ", "");
		decompilationText = decompilationText.replace("/* enum */ ", "");
		decompilationText = decompilationText.replace(" - consider using --renameillegalidents true",
				" - recommend switching to table mode");

		// Fix inner class names being busted in decompilation text, needs to be "Inner$1"
		// instead of "Inner.1", as generated by CFR
		String classSimpleName = className.contains("/") ?
				className.substring(className.lastIndexOf('/') + 1) : className;
		if (classSimpleName.contains("$")) {
			String incorrectlyDecompiledClassSimpleName = classSimpleName.replace('$', '.');

			int indexOfincorrectlyDecompiledClassSimpleName =
					decompilationText.indexOf(incorrectlyDecompiledClassSimpleName);
			if (indexOfincorrectlyDecompiledClassSimpleName == -1) {
				// Generated CFR output does not match expectations.
				// Don't attempt to fix up matters and lets this pass through
				// with an indication that we encountered this challenge.
				// One example of this happening is in
				//   https://mvnrepository.com/artifact/com.google.code.gson/gson/2.2.4
				// with (true) class com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl
				// being decompiled by CFR to com.google.gson.internal.$Gson$Types.GenericArrayTypeImpl
				// Note that singular dot in there generated by CFR.
				decompilationText = "// ERROR: Unable to apply inner class name fixup" + System.lineSeparator()
						+ decompilationText;
				return decompilationText;
			}

			decompilationText = decompilationText.replace(incorrectlyDecompiledClassSimpleName, classSimpleName);

			String startText = decompilationText.substring(0, decompilationText.indexOf(classSimpleName));
			String startTextCopy = startText;
			Set<AccessFlag> allowed = AccessFlag.getApplicableFlags(AccessFlag.Type.CLASS);
			for (AccessFlag acc : AccessFlag.values()) {
				if (allowed.contains(acc))
					continue;
				if (startText.contains(acc.getName() + " ")) {
					startText = startText.replace(startText,
							startText.replace(acc.getCodeFriendlyName() + " ", ""));
				}
			}
			decompilationText = decompilationText.replace(startTextCopy, startText);
		}
		return decompilationText;
	}

	/**
	 * Fetch default value from configuration parameter.
	 *
	 * @param param
	 * 		Parameter.
	 *
	 * @return Default value as string, may be {@code null}.
	 */
	private String getOptValue(PermittedOptionProvider.ArgumentParam<?, ?> param) {
		try {
			Field fn = PermittedOptionProvider.ArgumentParam.class.getDeclaredField("fn");
			fn.setAccessible(true);
			OptionDecoderParam<?, ?> decoder = (OptionDecoderParam<?, ?>) fn.get(param);
			return decoder.getDefaultValue();
		} catch (ReflectiveOperationException ex) {
			throw new IllegalStateException("Failed to fetch default value from Cfr parameter, did" +
					" the backend change?");
		}
	}
}

```

`src/main/java/me/coley/recaf/decompile/cfr/ClassSource.java`:

```java
package me.coley.recaf.decompile.cfr;

import me.coley.recaf.control.Controller;
import me.coley.recaf.util.ClassUtil;
import org.benf.cfr.reader.api.ClassFileSource;
import org.benf.cfr.reader.bytecode.analysis.parse.utils.Pair;

import java.util.*;

/**
 * CFR class source. Provides access to workspace clases.
 *
 * @author Matt
 */
public class ClassSource implements ClassFileSource {
	private final Controller controller;

	/**
	 * Constructs a CFR class source.
	 *
	 * @param controller
	 * 		Controller with workspace to pull classes from.
	 */
	public ClassSource(Controller controller) {
		this.controller = controller;
	}

	@Override
	public void informAnalysisRelativePathDetail(String usePath, String specPath) {}

	@Override
	public Collection<String> addJar(String jarPath) {
		return Collections.emptySet();
	}

	@Override
	public String getPossiblyRenamedPath(String path) {
		return path;
	}

	@Override
	@SuppressWarnings("deprecation")
	public Pair<byte[], String> getClassFileContent(String inputPath) {
		String className = inputPath.substring(0, inputPath.indexOf(".class"));
		byte[] code = controller.getWorkspace().getRawClass(className);
		// Strip debug if config says so
		if (controller.config().decompile().stripDebug)
			code = ClassUtil.stripDebugForDecompile(code);
		// Fetch code from runtime if not in workspace
		if (code == null) {
			code = Objects.requireNonNull(ClassUtil.fromRuntime(className),
					"Failed to load class from runtime: " + className).b;
		}
		return new Pair<>(code, inputPath);
	}
}

```

`src/main/java/me/coley/recaf/decompile/cfr/SinkFactoryImpl.java`:

```java
package me.coley.recaf.decompile.cfr;

import org.benf.cfr.reader.api.OutputSinkFactory;

import java.util.*;

import static me.coley.recaf.util.Log.*;

/**
 * Cfr logging/output sinker.
 *
 * @author Matt
 */
public class SinkFactoryImpl implements OutputSinkFactory {
	private String decompile;

	@Override
	public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> collection) {
		return Arrays.asList(SinkClass.values());
	}

	@Override
	public <T> Sink<T> getSink(SinkType sinkType, SinkClass sinkClass) {
		switch(sinkType) {
			case JAVA:
				return this::setDecompilation;
			case EXCEPTION:
				return t -> error("CFR: {}", t);
			case SUMMARY:
			case PROGRESS:
			default:
				return t -> {};
		}
	}

	private <T> void setDecompilation(T value) {
		decompile = value.toString();
	}

	/**
	 * @return Decompiled class content.
	 */
	public String getDecompilation() {
		return decompile;
	}
}

```

`src/main/java/me/coley/recaf/decompile/fernflower/DummyCollector.java`:

```java
package me.coley.recaf.decompile.fernflower;

import org.jetbrains.java.decompiler.main.extern.IResultSaver;

import java.util.jar.Manifest;

/**
 * Due to our modified usage of FernFlower this is needed just to satisfy some backend references.
 *
 * @author Matt
 */
public class DummyCollector implements IResultSaver {

	@Override
	public void saveFolder(String s) {}

	@Override
	public void copyFile(String s, String s1, String s2) {}

	@Override
	public void saveClassFile(String s, String s1, String s2, String s3, int[] ints) {}

	@Override
	public void createArchive(String s, String s1, Manifest manifest) {}

	@Override
	public void saveDirEntry(String s, String s1, String s2) {}

	@Override
	public void copyEntry(String s, String s1, String s2, String s3) {}

	@Override
	public void closeArchive(String s, String s1) {}
}

```

`src/main/java/me/coley/recaf/decompile/fernflower/FernFlowerAccessor.java`:

```java
package me.coley.recaf.decompile.fernflower;

import me.coley.recaf.workspace.Workspace;
import org.jetbrains.java.decompiler.main.ClassesProcessor;
import org.jetbrains.java.decompiler.main.DecompilerContext;
import org.jetbrains.java.decompiler.main.IdentityRenamerFactory;
import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;
import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
import org.jetbrains.java.decompiler.main.extern.IResultSaver;
import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
import org.jetbrains.java.decompiler.struct.IDecompiledData;
import org.jetbrains.java.decompiler.struct.StructClass;
import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
import org.jetbrains.java.decompiler.util.TextBuffer;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Locale;
import java.util.Map;

/**
 * FernFlower accessor. Modified from {@link org.jetbrains.java.decompiler.main.Fernflower} to
 * allow fileless decompilation.
 *
 * @author Matt
 */
public class FernFlowerAccessor implements IDecompiledData {
	private final StructContextDecorator structContext;
	private final ClassesProcessor classProcessor;

	/**
	 * Constructs a FernFlower decompiler instance.
	 *
	 * @param provider
	 * 		Class file provider.
	 * @param saver
	 * 		Decompilation output saver <i>(Unused/noop)</i>
	 * @param properties
	 * 		FernFlower options.
	 * @param logger
	 * 		FernFlower logger instance.
	 */
	public FernFlowerAccessor(IBytecodeProvider provider, IResultSaver saver, Map<String, Object>
			properties, IFernflowerLogger logger) {
		String level = (String) properties.get(IFernflowerPreferences.LOG_LEVEL);
		if (level != null) {
			logger.setSeverity(IFernflowerLogger.Severity.valueOf(level.toUpperCase(Locale.ENGLISH)));
		}
		structContext = new StructContextDecorator(saver, this, new LazyLoader(provider));
		classProcessor = new ClassesProcessor(structContext);
		int threadCount = 1;
		DecompilerContext context = new DecompilerContext(
				properties, threadCount, logger, structContext, classProcessor,
				new PoolInterceptor(), new IdentityRenamerFactory());
		DecompilerContext.setCurrentContext(context);
	}

	/**
	 * @param workspace
	 * 		Recaf workspace to pull classes from.
	 *
	 * @throws IOException
	 * 		Thrown if a class cannot be read.
	 * @throws ReflectiveOperationException
	 * 		Thrown if the parent loader could not be fetched.
	 * @throws IndexOutOfBoundsException
	 * 		Thrown if FernFlower can't read the class.
	 * 		<i>(IE: It fails on newer Java class files)</i>
	 */
	public void addWorkspace(Workspace workspace) throws IOException, ReflectiveOperationException {
		structContext.addWorkspace(workspace);
	}

	/**
	 * Analyze classes in the workspace.
	 */
	public void analyze() throws IOException, InterruptedException {
		classProcessor.loadClasses(null);
		// The threading model with FF makes no damn sense and there is NO documentaiton.
		// Uuggggghhhhhhh....
		// Sorry, you get shit performance on a single thread until I find some docs.
		/*
		DecompilerContext root = DecompilerContext.getCurrentContext();
		ExecutorService pool = Executors.newWorkStealingPool();
		for (StructClass cl : structContext.getClasses().values())
			pool.submit(() -> {
				try {
					DecompilerContext.cloneContext(root);
					classProcessor.processClass(cl);
				} catch (Throwable t) {
					t.printStackTrace();
				}
			});
		pool.shutdown();
		pool.awaitTermination(10, TimeUnit.SECONDS);
		 */
		for (StructClass cl : structContext.getClasses().values())
			try {
				classProcessor.processClass(cl);
			} catch (Throwable t) {
				t.printStackTrace();
			}
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Decompilation of the class.
	 */
	public String decompile(String name) {
		StructClass clazz = structContext.getClass(name);
		if (clazz == null)
			throw new IllegalArgumentException("FernFlower could not find \"" + name + "\"");
		return getClassContent(clazz);
	}

	@Override
	public String getClassEntryName(StructClass cl, String entryName) {
		ClassesProcessor.ClassNode node = classProcessor.getMapRootClasses().get(cl.qualifiedName);
		if (node.type != ClassesProcessor.ClassNode.CLASS_ROOT) {
			return null;
		} else {
			return entryName.substring(0, entryName.lastIndexOf(".class")) + ".java";
		}
	}

	@Override
	public boolean processClass(StructClass structClass) {
		try {
			classProcessor.processClass(structClass);
			return true;
		} catch (IOException e) {
			return false;
		}
	}

	@Override
	public String getClassContent(StructClass cl) {
		TextBuffer buffer;
		synchronized (this) {
			// FernFlower does some wonky thread-local behavior.... just.... ugh, why?
			buffer = new TextBuffer(ClassesProcessor.AVERAGE_CLASS_SIZE);
		}
		String name = cl.qualifiedName;
		try {
			Object banner = DecompilerContext.getProperty(IFernflowerPreferences.BANNER);
			if (banner != null && !banner.toString().trim().isEmpty())
				buffer.append(banner.toString() + "\n");
			ClassesProcessor.ClassNode node = classProcessor.getMapRootClasses().get(name);
			// Why are we changing the node type?
			// Because the ClassesProcessor ignores classes with non-root types.
			//
			// Treat standard inner classes as root classes.
			if (node.type == ClassesProcessor.ClassNode.CLASS_MEMBER)
				node.type = ClassesProcessor.ClassNode.CLASS_ROOT;
			// Treat anonymous classes as root classes.
			// - Apply name so it doesn't output "public class null extends whatever"
			if (node.type == ClassesProcessor.ClassNode.CLASS_ANONYMOUS) {
				node.type = ClassesProcessor.ClassNode.CLASS_ROOT;
				node.simpleName = name.substring(name.lastIndexOf("/") + 1);
			}
			classProcessor.writeClass(cl, buffer);
		} catch (Throwable t) {
			DecompilerContext.getLogger().writeMessage("Class " + name + " couldn't be fully decompiled.", t);
			// Put exception into output so users know it failed.
			StringWriter sw = new StringWriter();
			PrintWriter pw = new PrintWriter(sw);
			t.printStackTrace(pw);
			buffer.append("/*\n" + sw.toString() + "\n*/");
		}
		return buffer.toString();
	}
}
```

`src/main/java/me/coley/recaf/decompile/fernflower/FernFlowerDecompiler.java`:

```java
package me.coley.recaf.decompile.fernflower;

import me.coley.recaf.config.ConfDecompile;
import me.coley.recaf.control.Controller;
import me.coley.recaf.decompile.Decompiler;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;
import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;
import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;

import java.io.*;
import java.util.*;

/**
 * FernFlower decompiler implementation.
 *
 * @author Matt
 */
public class FernFlowerDecompiler extends Decompiler<Object> {
	private static final FernFlowerLogger LOGGER = new FernFlowerLogger();
	private static final DummyCollector DUMMY_COLLECTOR = new DummyCollector();
	private FernFlowerAccessor decompiler;
	private Workspace lastWorkspace;

	/**
	 * Initialize the decompiler wrapper.
	 *
	 * @param controller
	 * 		Controller with configuration to pull from and the workspace to pull classes from.
	 */
	public FernFlowerDecompiler(Controller controller) {
		super(controller);
		// Initial setup for the given controller
		if (controller.getWorkspace() != null)
			setup(controller.getWorkspace());
	}

	@Override
	protected Map<String, Object> generateDefaultOptions() {
		Map<String, Object> map = new HashMap<>(IFernflowerPreferences.getDefaults());
		map.put("ind", "    ");
		ConfDecompile config = getController().config().decompile();
		if (config.showSynthetic) {
			// FernFlower doesn't have options against intentional marking of ACC_SYNTHETIC by obfuscators :/
			// This will only show ACC_BRIDGE but not ACC_SYNTHETIC
			map.put("rbr", "0"); // hide bridge methods
			map.put("rsy", "0"); // hide synthetic class members
		}
		if (!config.stripDebug) {
			map.put("dgs", "1"); // decompile generics
		}
		return map;
	}

	@Override
	public String decompile(String name) {
		Workspace workspace = getController().getWorkspace();
		// Rerun setup if the workspace has changed.
		// This is required because FernFlower builds a cache of all classes as a custom node structure...
		if (workspace != lastWorkspace)
			setup(workspace);
		// Dump class content
		return decompiler.decompile(name);
	}

	/**
	 * Initialize FernFlower with the given workspace.
	 *
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	private void setup(Workspace workspace) {
		IBytecodeProvider provider = (externalPath, internalPath) -> {
			if(internalPath != null) {
				String className = internalPath.substring(0, internalPath.indexOf(".class"));
				ConfDecompile config = getController().config().decompile();
				byte[] code = workspace.getRawClass(className);
				if (config.stripDebug)
					code = ClassUtil.stripDebugForDecompile(code);
				return code;
			}
			throw new IllegalStateException("Provider should only receive internal names."+
					"Got external name: " + externalPath);
		};
		decompiler = new FernFlowerAccessor(provider, DUMMY_COLLECTOR, getOptions(), LOGGER);
		try {
			decompiler.addWorkspace(workspace);
			decompiler.analyze();
		} catch(IOException ex) {
			throw new IllegalStateException("Failed to load inputs for FernFlower!", ex);
		} catch(ReflectiveOperationException ex) {
			throw new IllegalStateException("Failed to setup FernFlower!", ex);
		} catch(IndexOutOfBoundsException ex) {
			throw new IllegalStateException("FernFlower internal error", ex);
		} catch(Exception ex) {
			throw new IllegalStateException(ex);
		}
		lastWorkspace = workspace;
	}
}

```

`src/main/java/me/coley/recaf/decompile/fernflower/FernFlowerLogger.java`:

```java
package me.coley.recaf.decompile.fernflower;

import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;

import static me.coley.recaf.util.Log.*;

/**
 * FernFlower logger implementation.
 *
 * @author Matt
 */
public class FernFlowerLogger extends IFernflowerLogger {
	@Override
	public void writeMessage(String message, Severity severity) {
		if(!accepts(severity))
			return;
		switch(severity) {
			case TRACE:
				trace(message);
				break;
			case INFO:
				info(message);
				break;
			case WARN:
				warn(message);
				break;
			case ERROR:
				error(message);
				break;
			default:
				break;
		}
	}

	@Override
	public void writeMessage(String message, Severity severity, Throwable throwable) {
		writeMessage(message, severity);
		error(throwable, message);
	}
}

```

`src/main/java/me/coley/recaf/decompile/fernflower/StructContextDecorator.java`:

```java
package me.coley.recaf.decompile.fernflower;

import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;
import org.jetbrains.java.decompiler.main.extern.IResultSaver;
import org.jetbrains.java.decompiler.struct.IDecompiledData;
import org.jetbrains.java.decompiler.struct.StructContext;
import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;

import java.io.IOException;
import java.util.Map;

import static me.coley.recaf.util.CollectionUtil.copySet;

/**
 * Decorator for StructContext to support Recaf workspaces.
 *
 * @author Matt
 */
public class StructContextDecorator extends StructContext {
	/**
	 * Constructs a StructContext.
	 *
	 * @param saver
	 * 		Result saver <i>(Unused/noop)</i>
	 * @param data
	 * 		Data instance, should be an instance of
	 *        {@link me.coley.recaf.decompile.fernflower.FernFlowerAccessor}.
	 * @param loader
	 * 		LazyLoader to hold links to class resources.
	 */
	public StructContextDecorator(IResultSaver saver, IDecompiledData data, LazyLoader loader) {
		super(saver, data, loader);
	}

	/**
	 * @param workspace
	 * 		Recaf workspace to pull classes from.
	 *
	 * @throws IOException
	 * 		Thrown if a class cannot be read.
	 * @throws IndexOutOfBoundsException
	 * 		Thrown if FernFlower can't read the class.
	 * 		<i>(IE: It fails on newer Java class files)</i>
	 */
	public void addWorkspace(Workspace workspace) throws IOException {
		// Add primary resource classes
		addResource(workspace.getPrimary());
		for (JavaResource resource : workspace.getLibraries())
			addResource(resource);
	}

	private void addResource(JavaResource resource) throws IOException {
		// Iterate resource class entries
		for (Map.Entry<String, byte[]> entry : copySet(resource.getClasses().entrySet())) {
			String name = entry.getKey();
			String simpleName = name.substring(name.lastIndexOf('/') + 1);
			byte[] code = entry.getValue();
			addData(name, simpleName, code, true);
		}
	}
}

```

`src/main/java/me/coley/recaf/decompile/procyon/ComposedTypeLoader.java`:

```java
package me.coley.recaf.decompile.procyon;

import com.strobel.assembler.metadata.Buffer;
import com.strobel.assembler.metadata.ITypeLoader;

import java.util.Collection;

/**
 * Composed type loader that iterates through array of available loaders
 *
 * @author xxDark
 */
final class ComposedTypeLoader implements ITypeLoader {
    private final Collection<ITypeLoader> loaders;

    ComposedTypeLoader(Collection<ITypeLoader> loaders) {
        this.loaders = loaders;
    }

    @Override
    public boolean tryLoadType(String s, Buffer buffer) {
        for (ITypeLoader loader : this.loaders) {
            if (loader.tryLoadType(s, buffer)) return true;
            buffer.reset();
        }
        return false;
    }
}

```

`src/main/java/me/coley/recaf/decompile/procyon/ProcyonDecompiler.java`:

```java
package me.coley.recaf.decompile.procyon;

import com.strobel.assembler.InputTypeLoader;
import com.strobel.assembler.metadata.ITypeLoader;
import com.strobel.assembler.metadata.MetadataSystem;
import com.strobel.assembler.metadata.TypeReference;
import com.strobel.decompiler.DecompilationOptions;
import com.strobel.decompiler.DecompilerSettings;
import com.strobel.decompiler.PlainTextOutput;
import com.strobel.decompiler.languages.java.JavaFormattingOptions;
import me.coley.recaf.config.ConfDecompile;
import me.coley.recaf.control.Controller;
import me.coley.recaf.decompile.Decompiler;

import java.io.StringWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Procyon decompiler implementation.
 *
 * @author xxDark
 */
public final class ProcyonDecompiler extends Decompiler<Boolean> {
    /**
     * Initialize the decompiler wrapper.
     *
     * @param controller
     * 		Controller with configuration to pull from and the workspace to pull classes from.
     */
    public ProcyonDecompiler(Controller controller) {
        super(controller);
    }

    @Override
    protected Map<String, Boolean> generateDefaultOptions() {
        ConfDecompile config = getController().config().decompile();
        Map<String, Boolean> options = new HashMap<>(17);
        options.put("merge-variables", false);
        options.put("force-explicit-imports", false);
        options.put("collapse-imports", false);
        options.put("force-explicit-type-arguments", false);
        options.put("retain-redundant-casts", false);
        options.put("flatten-switch-blocks", false);
        options.put("show-synthetic-members", config.showSynthetic);
        options.put("verbose", false);
        options.put("unoptimized", false);
        options.put("exclude-nested-types", false);
        options.put("show-debug-line-numbers", false);
        options.put("retain-pointless-switches", false);
        options.put("unicode-output", true);
        options.put("eager-methods-loading", true);
        options.put("simplify-member-references", false);
        options.put("force-fully-qualified-references", false);
        options.put("disable-for-each-transforms", false);
        return options;
    }

    @Override
    public String decompile(String name) {
        ITypeLoader loader = new ComposedTypeLoader(Arrays.asList(
                new RecafTypeLoader(getController()), new InputTypeLoader()
        ));
        Map<String, Boolean> options = getOptions();
        DecompilerSettings settings = new DecompilerSettings();
        settings.setFlattenSwitchBlocks(options.get("flatten-switch-blocks"));
        settings.setForceExplicitImports(!options.get("collapse-imports"));
        settings.setForceExplicitTypeArguments(options.get("force-explicit-type-arguments"));
        settings.setRetainRedundantCasts(options.get("retain-redundant-casts"));
        settings.setShowSyntheticMembers(options.get("show-synthetic-members"));
        settings.setExcludeNestedTypes(options.get("exclude-nested-types"));
        settings.setRetainPointlessSwitches(options.get("retain-pointless-switches"));
        settings.setUnicodeOutputEnabled(options.get("unicode-output"));
        settings.setMergeVariables(options.get("merge-variables"));
        settings.setShowDebugLineNumbers(options.get("show-debug-line-numbers"));
        settings.setSimplifyMemberReferences(options.get("simplify-member-references"));
        settings.setForceFullyQualifiedReferences(options.get("force-fully-qualified-references"));
        settings.setDisableForEachTransforms(options.get("disable-for-each-transforms"));
        settings.setTypeLoader(loader);
        settings.setJavaFormattingOptions(JavaFormattingOptions.createDefault());
        MetadataSystem system = new MetadataSystem(loader);
        system.setEagerMethodLoadingEnabled(options.get("eager-methods-loading"));
        TypeReference ref = system.lookupType(name);
        DecompilationOptions decompilationOptions = new DecompilationOptions();
        decompilationOptions.setSettings(settings);
        decompilationOptions.setFullDecompilation(true);
        StringWriter writer = new StringWriter();
        settings.getLanguage().decompileType(ref.resolve(), new PlainTextOutput(writer), decompilationOptions);
        return writer.toString();
    }
}

```

`src/main/java/me/coley/recaf/decompile/procyon/RecafTypeLoader.java`:

```java
package me.coley.recaf.decompile.procyon;

import com.strobel.assembler.metadata.Buffer;
import com.strobel.assembler.metadata.ITypeLoader;
import me.coley.recaf.control.Controller;
import me.coley.recaf.util.ClassUtil;

/**
 * Type loader that lookup classes from current workspace
 *
 * @author xxDark
 */
final class RecafTypeLoader implements ITypeLoader {
    private final Controller controller;

    RecafTypeLoader(Controller controller) {
        this.controller = controller;
    }

    @Override
    public boolean tryLoadType(String name, Buffer buffer) {
        byte[] code = controller.getWorkspace().getRawClass(name);
        if (controller.config().decompile().stripDebug)
            code = ClassUtil.stripDebugForDecompile(code);
        if (code == null) return false;
        buffer.position(0);
        buffer.putByteArray(code, 0, code.length);
        buffer.position(0);
        return true;
    }
}

```

`src/main/java/me/coley/recaf/graph/ClassDfsSearch.java`:

```java
package me.coley.recaf.graph;

import org.objectweb.asm.ClassReader;

import java.util.stream.Stream;

/**
 * Search implementation that does not iterate over any edges originating from the "Object" class.
 *
 * @author Matt
 */
public class ClassDfsSearch extends DepthFirstSearch<ClassReader> {
	private final Type edgeType;

	/**
	 * @param edgeType
	 * 		Kind of edge traversal to use. Options are:
	 * 		<ul>
	 * 		<li><b>Children</b> - For checking if the vertex is a parent of the target vertex.</li>
	 * 		<li><b>Parents</b> - For checking if the vertex is a child of the target vertex.</li>
	 * 		<li><b>All</b> - For scanning the entire class hierarchy <i>(Classes connected via
	 * 		inheritence of classes excluding "Object")</i> regardless of inheritence direction
	 * 		.</li>
	 * 		</ul>
	 */
	public ClassDfsSearch(Type edgeType) {
		this.edgeType = edgeType;
	}

	@Override
	protected Stream<Edge<ClassReader>> edges(Vertex<ClassReader> vertex) {
		if (cancel(vertex))
			return Stream.empty();
		switch(edgeType) {
			case CHILDREN:
				return vertex.getApplicableEdges(true);
			case PARENTS:
				return vertex.getApplicableEdges(false);
			case ALL:
			default:
				return vertex.getEdges().stream();
		}
	}

	/**
	 * @param vertex
	 * 		Vertex being looked at in the search.
	 *
	 * @return {@code true} if the search should terminate here. {@code false} to allow iteration
	 * of this vertex's edges.
	 */
	protected boolean cancel(Vertex<ClassReader> vertex) {
		// We do NOT want ANY edges pointing away from Object.
		return vertex.toString().equals("java/lang/Object");
	}

	/**
	 * Type of edges to visit in search.
	 */
	public enum Type {
		CHILDREN, PARENTS, ALL
	}
}

```

`src/main/java/me/coley/recaf/graph/ClassVertex.java`:

```java
package me.coley.recaf.graph;

import me.coley.recaf.util.ClassUtil;
import org.objectweb.asm.ClassReader;

import java.util.Objects;
import java.util.stream.Stream;

/**
 * Graph vertex with a {@link org.objectweb.asm.ClassReader} as the data.
 *
 * @param <G>
 * 		The type of graph holding the vertex.
 *
 * @author Matt
 */
public abstract class ClassVertex<G extends WorkspaceGraph> extends Vertex<ClassReader> {
	protected final G graph;
	private ClassReader clazz;

	/**
	 * Constructs a class vertex from the containing graph and class reader.
	 *
	 * @param graph
	 * 		The containing graph.
	 * @param clazz
	 * 		The vertex data.
	 */
	public ClassVertex(G graph, ClassReader clazz) {
		this.clazz = clazz;
		this.graph = graph;
	}

	/**
	 * @return Name of class stored by the vertex.
	 */
	public String getClassName() {
		return clazz.getClassName();
	}

	@Override
	public ClassReader getData() {
		return clazz;
	}

	@Override
	public void setData(ClassReader clazz) {
		this.clazz = clazz;
	}

	@Override
	public int hashCode() {
		return getData().getClassName().hashCode();
	}

	@Override
	public boolean equals(Object other) {
		if(other == null)
			throw new IllegalStateException("ClassVertex should not be compared to null");
		if(this == other)
			return true;
		if(other instanceof ClassVertex) {
			ClassVertex otherVertex = (ClassVertex) other;
			return getData().getClassName().equals(otherVertex.getData().getClassName());
		}
		return false;
	}

	@Override
	public String toString() {
		return getClassName();
	}

	// ============================== UTILITY =================================== //

	/**
	 * @param names
	 * 		Stream of names of classes.
	 *
	 * @return Mapped stream where names are replaced with instances.
	 * If a name has no instance mapping, it is discarded.
	 */
	protected Stream<ClassReader> getReadersFromNames(Stream<String> names) {
		return names.map(name -> {
			// Try loading from workspace
			ClassReader reader = graph.getWorkspace().getClassReader(name);
			if(reader != null)
				return reader;
			// Try loading from runtime
			return ClassUtil.fromRuntime(name);
		}).filter(Objects::nonNull);
	}
}

```

`src/main/java/me/coley/recaf/graph/DepthFirstSearch.java`:

```java
package me.coley.recaf.graph;

import java.util.*;
import java.util.stream.Stream;

/**
 * Depth-first search implementation for traversing a graph.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public class DepthFirstSearch<T> implements Search<T> {
	private final Set<Vertex<T>> visted = new HashSet<>();

	@Override
	public Set<Vertex<T>> visited() {
		return visted;
	}

	@Override
	public SearchResult<T> find(Vertex<T> vertex, Vertex<T> target) {
		return find(vertex, target, new ArrayList<>());
	}

	private SearchResult<T> find(Vertex<T> vertex, Vertex<T> target, List<Vertex<T>> path) {
		// Verify parameters
		if (vertex == null)
			throw new IllegalArgumentException("Cannot search with a null initial vertex!");
		if (target == null)
			throw new IllegalArgumentException("Cannot search with a null target vertex!");
		// Skip already visited vertices
		if(shouldSkip(vertex))
			return null;
		// Mark as visited
		onVisit(path, vertex);
		// Update path
		path.add(vertex);
		// Check for match
		if(vertex.equals(target))
			return createResult(path);
		// Iterate over edges
		Optional<SearchResult<T>> res = edges(vertex)
				.map(edge -> find(edge.getOther(vertex), target, new ArrayList<>(path)))
				.filter(Objects::nonNull)
				.findFirst();
		// Result found?
		return res.orElse(null);
	}

	/**
	 * @param vertex
	 * 		Analyzed vertex.
	 *
	 * @return {@code true} if the search should continue using the given vertex's edges. {@code
	 * false} to ignore this vertex's edges.
	 */
	protected boolean shouldSkip(Vertex<T> vertex) {
		return visited().contains(vertex);
	}

	/**
	 * Called when the given vertex is visited.
	 *
	 * @param currentPath
	 * 		Current path.
	 * @param vertex
	 * 		Vertex visted.
	 */
	protected void onVisit(List<Vertex<T>> currentPath, Vertex<T> vertex) {
		visited().add(vertex);
	}

	/**
	 * @param vertex
	 * 		Vertex to fetch edges from.
	 *
	 * @return Directed edges of the given vertex where the vertex is the parent.
	 */
	protected Stream<Edge<T>> edges(Vertex<T> vertex) {
		return vertex.getApplicableEdges(true);
	}

	/**
	 * @param path
	 * 		Path visited to complete the search.
	 *
	 * @return Result wrapper of the path.
	 */
	protected SearchResult<T> createResult(List<Vertex<T>> path) {
		return new SearchResult<>(path);
	}
}

```

`src/main/java/me/coley/recaf/graph/DirectedEdge.java`:

```java
package me.coley.recaf.graph;

import me.coley.recaf.util.struct.Pair;

/**
 * Graph directed-edge.
 * <pre>
 *     Parent -&gt; Child.
 * </pre>
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public class DirectedEdge<T> implements Edge<T> {
	private final Vertex<T> parent;
	private final Vertex<T> child;

	/**
	 * Constructs a directed edge.
	 *
	 * @param parent
	 * 		The parent vertex of the edge.
	 * @param child
	 * 		The child vertex of the edge.
	 */
	public DirectedEdge(Vertex<T> parent, Vertex<T> child) {
		this.parent = parent;
		this.child = child;
	}

	/**
	 * @return Pair of the vertices.
	 */
	public Pair<Vertex<T>, Vertex<T>> verticies() {
		return new Pair<>(getParent(), getChild());
	}

	/**
	 * @return Parent vertex.
	 */
	public Vertex<T> getParent() {
		return parent;
	}

	/**
	 * @return Child vertex.
	 */
	public Vertex<T> getChild() {
		return child;
	}
}

```

`src/main/java/me/coley/recaf/graph/Edge.java`:

```java
package me.coley.recaf.graph;

import me.coley.recaf.util.struct.Pair;

/**
 * Graph edge.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public interface Edge<T> {
	/**
	 * @return Pair of verticies in the edge.
	 */
	Pair<Vertex<T>, Vertex<T>> verticies();

	/**
	 * @param notThis
	 * 		One vertex in the pair.
	 *
	 * @return The other vertex of the pair, not the one given.
	 */
	default Vertex<T> getOther(Vertex<T> notThis) {
		Pair<Vertex<T>, Vertex<T>> pair = verticies();
		if(notThis.equals(pair.getKey()))
			return pair.getValue();
		else if(notThis.equals(pair.getValue()))
			return pair.getKey();
		throw new IllegalStateException("Vertex not in pair");
	}
}

```

`src/main/java/me/coley/recaf/graph/ExhaustiveSearch.java`:

```java
package me.coley.recaf.graph;

import java.util.Set;
import java.util.stream.Collectors;

/**
 * @param <V>
 * 		Vertex type.
 * @param <T>
 * 		Vertex value type.
 */
public interface ExhaustiveSearch<V extends Vertex<T>, T> extends Search<T> {
	/**
	 * The absolute smallest possible dummy class.
	 */
	byte[] DUMMY_CLASS_BYTECODE = new byte[]{-54, -2, -70, -66, 0, 0, 0, 52, 0, 5, 1, 0, 1, 97, 7,
		0, 1, 1, 0, 1, 98, 7, 0, 3, 0, 33, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0};

	/**
	 * @param vertex
	 * 		Initial vertex to build from.
	 *
	 * @return Set containing all all vertices with classes in the inheritance hierarchy.
	 */
	@SuppressWarnings("unchecked")
	default Set<V> build(Vertex<T> vertex) {
		// Start a search to populate the visted vertex set.
		// Set the target to some dummy value so the search is exhaustive.
		find(vertex, dummy());
		return visited().stream()
				.map(v -> (V) v)
				.collect(Collectors.toSet());
	}

	/**
	 * @return Dummy vertex used as a target.
	 * Forces an exhaustive search since it can never be matched.
	 */
	Vertex<T> dummy();
}

```

`src/main/java/me/coley/recaf/graph/Graph.java`:

```java
package me.coley.recaf.graph;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import static java.util.function.Function.identity;

/**
 * Base graph, intended for creation of <i>generative</i> graphs <i>(Where vertices and edges are
 * dynamically created/requested)</i>.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 * @param <V>
 * 		Vertex class type.
 *
 * @author Matt
 */
public interface Graph<T, V extends Vertex<T>> {
	/**
	 * @return Set of vertices in the graph.
	 */
	Set<V> vertices();

	/**
	 * @return Set of values contained by the {@link #vertices()}.
	 */
	default Set<T> verticesValues() {
		return vertices().stream()
				.map(Vertex::getData)
				.collect(Collectors.toSet());
	}

	/**
	 * @return A map of {@link #verticesValues() vertex values} to their
	 * {@link #vertices() vertices}.
	 */
	default Map<T, V> verticesMap() {
		return vertices().stream()
				.collect(Collectors.toMap(Vertex::getData, identity()));
	}

	/**
	 * @param key
	 * 		Some key.
	 *
	 * @return A vertex instance associated with it's contained data.
	 */
	default V getVertex(T key) {
		return verticesMap().get(key);
	}

	/**
	 * An alternative to {@link #getVertex(Object)} which does not use the generative method
	 * {@link #verticesMap()}. This allows for much faster lookup-times.
	 * <br>
	 * By default this is not implemented. It may optionally be implemented by children.
	 *
	 * @param key
	 * 		Some key.
	 *
	 * @return A vertex instance associated with it's contained data.
	 */
	default V getVertexFast(T key) {
		throw new UnsupportedOperationException();
	}

	/**
	 * @param vertex
	 * 		Vertex to check for.
	 *
	 * @return {@code true} if the {@link #vertices() vertex set} contains the given vertex.
	 */
	default boolean containsVertex(V vertex) {
		return vertices().contains(vertex);
	}

	/**
	 * @param key
	 * 		Key value to check for.
	 *
	 * @return {@code true} if the {@link #vertices() vertex set} contains the given value.
	 */
	default boolean containsVertex(T key) {
		return verticesValues().contains(key);
	}
}

```

`src/main/java/me/coley/recaf/graph/Search.java`:

```java
package me.coley.recaf.graph;

import java.util.Set;

/**
 * Base search layout.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public interface Search<T> {
	/**
	 * @return Set of visited verticies.
	 */
	Set<Vertex<T>> visited();

	/**
	 * @param vertex
	 * 		Vertex currently in-use for the search.
	 * @param target
	 * 		Intended target to find.
	 *
	 * @return Result summarizing how the vertices are related. If there is no relation returns
	 * {@code null}.
	 */
	SearchResult<T> find(Vertex<T> vertex, Vertex<T> target);
}

```

`src/main/java/me/coley/recaf/graph/SearchResult.java`:

```java
package me.coley.recaf.graph;

import java.util.List;

/**
 * Search result data.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public class SearchResult<T> {
	private final List<Vertex<T>> path;

	/**
	 * Constructs a search result from the given path.
	 *
	 * @param path
	 * 		List of vertices traveled to complete the path.
	 */
	public SearchResult(List<Vertex<T>> path) {
		this.path = path;
	}

	/**
	 * @return Path taken to get from the initial node to the target.
	 */
	public List<Vertex<T>> getPath() {
		return path;
	}
}

```

`src/main/java/me/coley/recaf/graph/Vertex.java`:

```java
package me.coley.recaf.graph;

import java.util.Set;
import java.util.stream.Stream;

/**
 * Graph vertex.
 *
 * @param <T>
 * 		Type of data contained by the graph.
 *
 * @author Matt
 */
public abstract class Vertex<T> {
	/**
	 * @return Contained data.
	 */
	public abstract T getData();

	/**
	 * @param data
	 * 		New data to contain.
	 */
	public abstract void setData(T data);

	/**
	 * @return Hash of {@link #getData() data}.
	 */
	public abstract int hashCode();

	/**
	 * @param other
	 * 		Other item to check.
	 *
	 * @return {@code true} if this vertex's {@link #getData() data} matches the given object.
	 */
	public abstract boolean equals(Object other);

	/**
	 * @return Collection of edges connected to this vertex.
	 */
	public abstract Set<Edge<T>> getEdges();

	/**
	 * @return Edges that are not directed.
	 */
	public Stream<Edge<T>> getUndirectedEdges() {
		return getEdges().stream()
				.filter(e -> !(e instanceof DirectedEdge));
	}

	/**
	 * @param isParent
	 * 		Flag for if the current vertex is the parent in the directed edge relation.
	 *
	 * @return Edges where the current vertex is a parent or is a child depending on the given flag.
	 */
	public Stream<DirectedEdge<T>> getDirectedEdges(boolean isParent) {
		return getEdges().stream()
				.filter(e -> e instanceof DirectedEdge)
				.map(e -> (DirectedEdge<T>) e)
				.filter(di -> isParent ? equals(di.getParent()) : equals(di.getChild()));
	}

	/**
	 * @return Vertices that are direct descendants of this vertex in a directed graph.
	 */
	public Stream<Vertex<T>> getDirectedChildren() {
		return getDirectedEdges(true)
				.map(DirectedEdge::getChild);
	}

	/**
	 * @return Vertices that are direct descendants of this vertex in a directed graph.
	 */
	public Stream<Vertex<T>> getDirectedParents() {
		return getDirectedEdges(false)
				.map(DirectedEdge::getParent);
	}

	/**
	 * @param includeSelf
	 * 		Flag for if the current vertex is to be included in the results.
	 *
	 * @return Vertices that are descendants of this vertex in a directed graph.
	 */
	public Stream<Vertex<T>> getAllDirectedChildren(boolean includeSelf) {
		return includeSelf ?
				Stream.concat(Stream.of(this), getAllDirectedChildren()) : getAllDirectedChildren();
	}

	/**
	 * @return Vertices that are descendants of this vertex in a directed graph.
	 */
	private Stream<Vertex<T>> getAllDirectedChildren() {
		return Stream.concat(getDirectedChildren(),
				getDirectedChildren().flatMap(Vertex::getAllDirectedChildren));
	}


	/**
	 * @param includeSelf
	 * 		Flag for if the current vertex is to be included in the results.
	 *
	 * @return Vertices that this vertex inherits from in a directed graph.
	 */
	public Stream<Vertex<T>> getAllDirectedParents(boolean includeSelf) {
		return includeSelf ?
				Stream.concat(Stream.of(this), getAllDirectedParents()) : getAllDirectedParents();
	}

	/**
	 * @return Vertices that this vertex inherits from in a directed graph.
	 */
	private Stream<Vertex<T>> getAllDirectedParents() {
		return Stream.concat(getDirectedParents(),
				getDirectedParents().flatMap(Vertex::getAllDirectedParents));
	}

	/**
	 * @param isParent
	 * 		Flag for if the current vertex is the parent in directed edge relations.
	 *
	 * @return Edges where the relation is undirected, or if directed that the current vertex is a
	 * parent or is a child depending on the given flag.
	 */
	public Stream<Edge<T>> getApplicableEdges(boolean isParent) {
		return Stream.concat(getUndirectedEdges(), getDirectedEdges(isParent));
	}

	/**
	 * @return {@code true} if the vertex has no directed parent edges.
	 */
	public boolean isRoot() {
		return getDirectedParents().count() == 0;
	}

	/**
	 * @return {@code true} if the vertex has no directed children edges.
	 */
	public boolean isLeaf() {
		return getDirectedChildren().count() == 0;
	}

	/**
	 * @return {@code this} if the current vertex is a root. Otherwise a set of roots in the graph
	 * this vertex resides in.
	 */
	public Stream<Vertex<T>> getAllRoots() {
		return getAllDirectedParents(true).filter(Vertex::isRoot);
	}

	/**
	 * @return {@code this} if the current vertex is a leaf. Otherwise a set of leaves in the graph
	 * this vertex resides in.
	 */
	public Stream<Vertex<T>> getAllLeaves() {
		return getAllDirectedChildren(true).filter(Vertex::isLeaf);
	}
}

```

`src/main/java/me/coley/recaf/graph/WorkspaceGraph.java`:

```java
package me.coley.recaf.graph;

import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;

import java.util.Set;
import java.util.stream.Collectors;

/**
 * Graph implementation based off of Recaf workspaces as providers for vertex data.
 *
 * @param <V>
 * 		Type of vertex data.
 *
 * @author Matt
 */
public abstract class WorkspaceGraph<V extends Vertex<ClassReader>> implements Graph<ClassReader, V> {
	/**
	 * Workspace to use for generating vertices from.
	 */
	private final Workspace workspace;

	/**
	 * Constructs a graph from the given workspace.
	 *
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	public WorkspaceGraph(Workspace workspace) {
		this.workspace = workspace;
	}

	@Override
	public Set<V> vertices() {
		return getWorkspace().getPrimaryClassReaders().stream()
					.map(this::getVertex)
					.collect(Collectors.toSet());
	}

	/**
	 * @return Input associated with the current hierarchy map.
	 */
	public Workspace getWorkspace() {
		return workspace;
	}

	@Override
	public V getVertex(ClassReader key) {
		throw new UnsupportedOperationException("'getVertex' must be implemented by" +
				" children of WorkspaceGraph");
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Class vertex of matching class.
	 */
	public V getVertex(String name) {
		if (getWorkspace().hasClass(name)) {
			ClassReader key = getWorkspace().getClassReader(name);
			return getVertexFast(key);
		}
		return null;
	}
}

```

`src/main/java/me/coley/recaf/graph/flow/FlowBuilder.java`:

```java
package me.coley.recaf.graph.flow;

import me.coley.recaf.graph.*;
import org.objectweb.asm.*;

import java.util.*;

/**
 * Search implementation that builds an call graph.
 *
 * @author Matt
 */
public class FlowBuilder extends ClassDfsSearch implements ExhaustiveSearch<FlowVertex, ClassReader> {
	private final Map<String, Flow> vertices = new HashMap<>();
	private int currentId;

	/**
	 * Constructs a method call flow builder.
	 */
	public FlowBuilder() {
		super(Type.CHILDREN);
	}

	@Override
	public void onVisit(List<Vertex<ClassReader>> path, Vertex<ClassReader> vertex) {
		super.onVisit(path, vertex);
		Flow parent = null;
		if (path.size() > 0) {
			String last = path.get(path.size() -1).toString();
			parent = vertices.get(last);
		}
		String key = vertex.toString();
		Flow general = vertices.get(key);
		if(general == null) {
			general = new Flow(currentId++, (FlowVertex) vertex);
			vertices.put(key, general);
		}
		if(parent != null) {
			parent.children.add(general);
			general.parents.add(parent);
		}
	}

	@Override
	protected boolean shouldSkip(Vertex<ClassReader> vertex) {
		return super.shouldSkip(vertex);
	}

	@Override
	public Vertex<ClassReader> dummy() {
		return new FlowVertex(null, new ClassReader(DUMMY_CLASS_BYTECODE), "<clinit>", "()V") {
			@Override
			public Set<Edge<ClassReader>> getEdges() {
				return Collections.emptySet();
			}

			@Override
			public int hashCode() {
				return -1;
			}

			@Override
			public boolean equals(Object other) {
				if(other instanceof FlowVertex)
					return hashCode() == other.hashCode();
				return false;
			}

			@Override
			public String toString() {
				return "[[Dummy]]";
			}
		};
	}

	/**
	 * @return Map of visited vertices. Keys are the visited
	 * {@link me.coley.recaf.graph.flow.FlowVertex} string representations.
	 */
	public Map<String, Flow> getVertices() {
		return vertices;
	}

	/**
	 * {@link FlowVertex} wrapper &amp; minimal static control flow vertex.
	 */
	public static class Flow implements Comparable<Flow> {
		private final List<Flow> parents = new ArrayList<>();
		private final List<Flow> children = new ArrayList<>();
		private final FlowVertex value;
		private final int id;

		/**
		 * Constructs a general vertex.
		 *
		 * @param id
		 * 		Vertex identifier.
		 * @param value
		 * 		Vertex value.
		 */
		public Flow(int id, FlowVertex value) {
			this.value = value;
			this.id = id;
		}

		/**
		 * @param other
		 * 		Another flow vertex belonging to a separate resource.
		 *
		 * @return The set of vertices attached to the base flow that do not have
		 * mappings to the vertices connected to the target flow. An empty set indicates
		 * the flow vertices model the same structure / call-graph.
		 */
		public Set<Flow> getDifference(Flow other) {
			return getDifference(new LinkedHashSet<>(), this, other);
		}

		private static Set<Flow> getDifference(Set<Flow> set, Flow vert1, Flow vert2) {
			if(vert1.children.size() != vert2.children.size()) {
				set.add(vert1);
				return set;
			} else {
				for(int i = 0; i < vert1.children.size() && set.isEmpty(); i++)
					getDifference(set, vert1.children.get(i), vert2.children.get(i));
				return set;
			}
		}

		/**
		 * Sorts children of the current flow vertex.
		 */
		public void sort() {
			Collections.sort(children);
		}

		/**
		 * <b>Ensure data is {@link #sort() sorted} before comparing!</b>
		 *
		 * @param other
		 * 		Another flow vertex to compare against.
		 *
		 * @return Comparison ordering favoring vertices containing larger children sets.
		 */
		@Override
		public int compareTo(Flow other) {
			if(children.size() != other.children.size()) {
				// sort larger items first
				return Integer.compare(children.size(), other.children.size());
			} else {
				// compare the children if this layer is equal
				for(int i = 0; i < children.size(); i++) {
					int result = children.get(i).compareTo(other.children.get(i));
					if(result != 0)
						return result;
				}
				return 0;
			}
		}

		/**
		 * @return Child vertices with edges connecting to the current flow vertex.
		 */
		public List<Flow> getChildren() {
			return children;
		}

		/**
		 * @return Parent vertices with edges connecting to the current flow vertex.
		 */
		public List<Flow> getParents() {
			return parents;
		}

		@Override
		public String toString() {
			return id + ":" + value;
		}

		/**
		 * @return Wrapped generative graph node.
		 */
		public FlowVertex getValue() {
			return value;
		}
	}
}
```

`src/main/java/me/coley/recaf/graph/flow/FlowGraph.java`:

```java
package me.coley.recaf.graph.flow;

import me.coley.recaf.graph.WorkspaceGraph;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;

/**
 * Graph model to represent the method call graph starting at some specified method <i>(Modled by
 * {@link me.coley.recaf.graph.flow.FlowVertex})</i>.
 *
 * @author Matt
 */
public class FlowGraph extends WorkspaceGraph<FlowVertex> {
	/**
	 * Constructs a flow graph from the given workspace.
	 *
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	public FlowGraph(Workspace workspace) {
		super(workspace);
	}

	/**
	 * @param owner
	 * 		Class name.
	 * @param name
	 * 		Name of method in class.
	 * @param descriptor
	 * 		Descriptor of method in class.
	 *
	 * @return FlowVertex outlining the given method.
	 */
	public FlowVertex getVertex(String owner, String name, String descriptor) {
		if(getWorkspace().hasClass(owner)) {
			ClassReader reader = getWorkspace().getClassReader(owner);
			return getVertex(reader, name, descriptor);
		}
		return null;
	}

	/**
	 * @param reader
	 * 		Class reader of the class containing the given method.
	 * @param name
	 * 		Name of method in class.
	 * @param descriptor
	 * 		Descriptor of method in class.
	 *
	 * @return FlowVertex outlining the given method.
	 */
	public FlowVertex getVertex(ClassReader reader, String name, String descriptor) {
		return new FlowVertex(this, reader, name, descriptor);
	}

	@Override
	public FlowVertex getVertex(ClassReader key) {
		throw new UnsupportedOperationException("'getVertex' is not supported by FlowGraph, see documentation");
	}
}

```

`src/main/java/me/coley/recaf/graph/flow/FlowReference.java`:

```java
package me.coley.recaf.graph.flow;

import java.util.Objects;

/**
 * Method call outline.
 *
 * @author Matt
 */
public class FlowReference {
	private final FlowVertex vertex;
	private final String name;
	private final String desc;

	/**
	 * Constructs a method call reference for flow graphing.
	 *
	 * @param vertex
	 * 		Vertex of the class containing the called method.
	 * @param name
	 * 		Name of the method called.
	 * @param desc
	 * 		Descriptor of the method called.
	 */
	public FlowReference(FlowVertex vertex, String name, String desc) {
		this.vertex = vertex;
		this.name = name;
		this.desc = desc;
	}

	/**
	 * @return Vertex of the class containing the called method.
	 */
	public FlowVertex getVertex() {
		return vertex;
	}

	/**
	 * @return Name of the method called.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Descriptor of the method called.
	 */
	public String getDesc() {
		return desc;
	}

	@Override
	public String toString() {
		return vertex.getData().getClassName() + "." + name + desc;
	}

	@Override
	public int hashCode() {
		return Objects.hash(vertex.getData().getClassName(), name, desc);
	}

	@Override
	public boolean equals(Object other) {
		if (this == other)
			return true;
		if (other instanceof FlowReference) {
			FlowReference frOther = (FlowReference) other;
			return vertex.equals(frOther.vertex) &&
						name.equals(frOther.name) &&
						desc.equals(frOther.desc);
		}
		return false;
	}
}
```

`src/main/java/me/coley/recaf/graph/flow/FlowVertex.java`:

```java
package me.coley.recaf.graph.flow;

import me.coley.recaf.graph.*;
import org.objectweb.asm.*;

import java.util.*;
import java.util.stream.Collectors;

import static org.objectweb.asm.ClassReader.*;

/**
 * ClassVertex implementation with outbound method calls as the edge source.
 *
 * @author Matt
 */
public class FlowVertex extends ClassVertex<FlowGraph> {
	private final String name;
	private final String desc;

	/**
	 * Constructs a flow vertex from the containing graph and class reader.<br>
	 * The vertex contains method data, thus outlines a method.
	 *
	 * @param graph
	 * 		The containing graph.
	 * @param clazz
	 * 		The vertex data.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 */
	public FlowVertex(FlowGraph graph, ClassReader clazz, String name, String desc) {
		super(graph, clazz);
		this.name = name;
		this.desc = desc;
	}

	@Override
	public Set<Edge<ClassReader>> getEdges() {
		// Due to the generative nature of the graphing api, we can only track outbound calls from
		// the context of a single vertex.
		return getOutbound().stream()
				.map(FlowReference::getVertex)
				.map(vert -> new DirectedEdge<>(this, vert))
				.collect(Collectors.toCollection(LinkedHashSet::new));
	}

	private Set<FlowReference> getOutbound() {
		// Only search if the method has been specified
		if (name == null || desc == null)
			return Collections.emptySet();
		// Collect & return references.
		OutboundCollector collector = new OutboundCollector(graph, name, desc);
		getData().accept(collector, SKIP_DEBUG | SKIP_FRAMES);
		return collector.getOutbound();
	}

	/**
	 * @return Name of the class containing the method represented.
	 */
	public String getOwner() {
		return getData().getClassName();
	}

	/**
	 * @return Method name of the vertex.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Method descriptor of the vertex.
	 */
	public String getDesc() {
		return desc;
	}

	@Override
	public String toString() {
		return getData().getClassName() + "." + name + desc;
	}

	@Override
	public int hashCode() {
		return Objects.hash(getData().getClassName(), name, desc);
	}

	@Override
	public boolean equals(Object other) {
		if (this == other)
			return true;
		if (other instanceof FlowVertex) {
			FlowVertex fvOther = (FlowVertex) other;
			String owner = getData().getClassName();
			String frOwner = fvOther.getData().getClassName();
			return owner.equals(frOwner) &&
					name.equals(fvOther.name) &&
					desc.equals(fvOther.desc);
		}
		return false;
	}
}

```

`src/main/java/me/coley/recaf/graph/flow/OutboundCollector.java`:

```java
package me.coley.recaf.graph.flow;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;

import java.util.*;

/**
 * ClassVisitor that collects outbound calls from a given host method.
 *
 * @author Matt
 */
public class OutboundCollector extends ClassVisitor {
	private final FlowGraph graph;
	// Host method definition
	private final String hostName;
	private final String hostDesc;
	// Collection of calls, using a insertion-order set for ordered iteration in later usages.
	private final Set<FlowReference> outbound = new LinkedHashSet<>();

	/**
	 * Constructs an outbound method collector.
	 *
	 * @param graph
	 * 		Graph to pull data from.
	 * @param hostName
	 * 		Name of method to search for outbound calls in.
	 * @param hostDesc
	 * 		Descriptor of method to search for outbound calls in.
	 */
	public OutboundCollector(FlowGraph graph, String hostName, String hostDesc) {
		super(Recaf.ASM_VERSION);
		this.graph = graph;
		this.hostName = hostName;
		this.hostDesc = hostDesc;
	}

	@Override
	public MethodVisitor visitMethod(int acc, String name, String desc, String sig, String[] exc) {
		// Only visit/parse if the visited method is the host method
		if (name.equals(hostName) && desc.equals(hostDesc))
			return new MethodVisitor(api) {
				@Override
				public void visitMethodInsn(int op, String owner, String name, String desc, boolean itf) {
					// Get vertex containing the method & add reference
					FlowVertex vertex = graph.getVertex(owner, name, desc);
					// If the vertex cannot be loaded it's assumed to be a core class.
					// If the user has their workspace setup (with libraries) this will be
					// the only null case.
					if (vertex != null)
						outbound.add(new FlowReference(vertex, name, desc));
				}
			};
		return null;
	}

	/**
	 * @return Set of outbound method calls from the current host method.
	 */
	public Set<FlowReference> getOutbound() {
		return outbound;
	}
}

```

`src/main/java/me/coley/recaf/graph/inheritance/ClassHierarchyBuilder.java`:

```java
package me.coley.recaf.graph.inheritance;

import me.coley.recaf.graph.*;
import org.objectweb.asm.ClassReader;

import java.util.Collections;
import java.util.Set;

/**
 * Search implementation that builds an inheritance hierarchy when given some class in the hierarchy.
 *
 * @author Matt
 */
public class ClassHierarchyBuilder extends ClassDfsSearch implements ExhaustiveSearch<HierarchyVertex, ClassReader> {
	/**
	 * Constructs a class hierarchy builder.
	 */
	public ClassHierarchyBuilder() {
		this(ClassDfsSearch.Type.ALL);
	}

	/**
	 * Constructs a class hierarchy builder.
	 *
	 * @param type
	 * 		Allowed edge type.
	 */
	public ClassHierarchyBuilder(ClassDfsSearch.Type type) {
		super(type);
	}

	@Override
	public Vertex<ClassReader> dummy() {
		return new HierarchyVertex(null, new ClassReader(DUMMY_CLASS_BYTECODE)) {
			@Override
			public Set<Edge<ClassReader>> getEdges() {
				return Collections.emptySet();
			}

			@Override
			public int hashCode() {
				return -1;
			}

			@Override
			public boolean equals(Object other) {
				if(other instanceof HierarchyVertex)
					return hashCode() == other.hashCode();
				return this == other;
			}

			@Override
			public String toString() {
				return "[[Dummy]]";
			}
		};
	}
}

```

`src/main/java/me/coley/recaf/graph/inheritance/HierarchyGraph.java`:

```java
package me.coley.recaf.graph.inheritance;

import me.coley.recaf.graph.*;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Stream.*;

/**
 * Graph model to represent the class inheritance of a loaded input. <br>
 * The graph is generative, meaning the graph's vertices and edges are dynamically generated when
 * requested. The relations are not stored due to their modifiable nature.
 *
 * @author Matt
 */
public class HierarchyGraph extends WorkspaceGraph<HierarchyVertex> {
	/**
	 * Map of parent to children names.
	 */
	private final Map<String, Set<String>> descendents = new HashMap<>();

	/**
	 * Constructs a hierarchy graph from the given workspace.
	 *
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	public HierarchyGraph(Workspace workspace) {
		super(workspace);
		refresh();
	}

	@Override
	public HierarchyVertex getVertex(ClassReader key) {
		return getVertexFast(key);
	}

	@Override
	public HierarchyVertex getVertexFast(ClassReader key) {
		return new HierarchyVertex(this, key);
	}

	/**
	 * @param name
	 * 		Class name of a class belonging to some inheritance hierarchy.
	 *
	 * @return Inheritance hierarchy containing the given class.
	 */
	public Set<HierarchyVertex> getHierarchy(String name) {
		return getHierarchy(getVertex(name));
	}

	/**
	 * @param vertex
	 * 		Class vertex that belongs to some inheritance hierarchy.
	 *
	 * @return Inheritance hierarchy containing the given class.
	 */
	public Set<HierarchyVertex> getHierarchy(HierarchyVertex vertex) {
		if(vertex == null)
			return Collections.emptySet();
		ClassHierarchyBuilder builder = new ClassHierarchyBuilder();
		return builder.build(vertex);
	}

	/**
	 * @param name
	 * 		Class name of a class belonging to some inheritance hierarchy.
	 *
	 * @return Inheritance hierarchy containing the given class.
	 */
	public Set<String> getHierarchyNames(String name) {
		return getHierarchyNames(getVertex(name));
	}

	/**
	 * @param vertex
	 * 		Class vertex that belongs to some inheritance hierarchy.
	 *
	 * @return Inheritance hierarchy containing the given class.
	 */
	public Set<String> getHierarchyNames(HierarchyVertex vertex) {
		return getHierarchy(vertex).stream().map(v -> v.getData().getClassName()).collect(Collectors.toSet());
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Direct descendants of the class.
	 */
	public Stream<String> getDescendants(String name) {
		if (descendents.containsKey(name))
			return descendents.get(name).stream();
		// Empty stream
		return empty();
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return All descendants of the class.
	 */
	public Stream<String> getAllDescendants(String name) {
		Set<String> descendentNames = descendents.get(name);
		if (descendentNames == null)
			return empty();
		return concat(descendentNames.stream(),
				descendentNames.stream().flatMap(this::getAllDescendants));
	}

	/**
	 * @param name
	 * 		Class name.
	 * @param breakCheck
	 * 		Condition to stop scanning for descendants.
	 *
	 * @return All descendants of the class, up until a point specified by the check condition.
	 */
	public Stream<String> getAllDescendantsWithBreakCondition(String name, Predicate<String> breakCheck) {
		Set<String> descendentNames = descendents.get(name);
		if (descendentNames == null)
			return empty();
		descendentNames.removeIf(breakCheck);
		return concat(descendentNames.stream(),
				descendentNames.stream().flatMap(d -> getAllDescendantsWithBreakCondition(d, breakCheck)));
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Direct parents of the class.
	 */
	public Stream<String> getParents(String name) {
		HierarchyVertex vert = getVertex(name);
		if (vert != null)
			return getParents(vert);
		// Empty stream
		return empty();
	}

	/**
	 * @param vertex
	 * 		Class vertex.
	 *
	 * @return Direct parents of the class.
	 */
	public Stream<String> getParents(HierarchyVertex vertex) {
		return concat(
				of(vertex.getData().getSuperName()),
				of(vertex.getData().getInterfaces()));
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return All parents of the class.
	 */
	public Stream<String> getAllParents(String name) {
		return (getParents(name).map(this::getAllParents)
				.reduce(getParents(name), Stream::concat));
	}

	/**
	 * @param first
	 * 		First class name.
	 * @param second
	 * 		Second class name.
	 *
	 * @return Common parent of the classes.
	 */
	public String getCommon(String first, String second) {
		// Full upwards hierarchy for the first
		Set<String> firstParents = getAllParents(first).collect(Collectors.toSet());
		firstParents.add(first);
		// Base case
		if (firstParents.contains(second))
			return second;
		// Iterate over second's parents via breadth-first-search
		Queue<String> queue = new LinkedList<>();
		queue.add(second);
		do {
			// Item to fetch parents of
			String next = queue.poll();
			if (next == null || next.equals("java/lang/Object"))
				break;
			for (String parent : getParents(next).collect(Collectors.toSet())) {
				// Parent in the set of visited classes? Then its valid.
				if(firstParents.contains(parent))
					return parent;
				// Queue up the parent
				if (!parent.equals("java/lang/Object"))
					queue.add(parent);
			}
		} while(!queue.isEmpty());
		// Fallback option
		return "java/lang/Object";
	}

	/**
	 * Check if the given method in a class is linked to a locked library method.
	 *
	 * @param owner
	 * 		Class the method resides in.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 *
	 * @return {@code true} if any class in the hierarchy of the owner is a library class and
	 * defines the given method,
	 */
	public boolean isLibrary(String owner, String name, String desc) {
		// Get classes that are considered "library" classes (not included in Input)
		Stream<HierarchyVertex> hierarchy = getHierarchy(owner).stream();
		Stream<HierarchyVertex> libClasses = hierarchy.filter(vertex -> !getWorkspace()
				.getPrimaryClassNames().contains(vertex.getClassName()));
		// Check if the library classes have a matching method.
		return libClasses
					.map(ClassVertex::getData)
					.flatMap(cr -> ClassUtil.getMethodDefs(cr).stream())
					.anyMatch(method -> name.equals(method.getKey()) && desc.equals(method.getValue()));
	}

	/**
	 * Check if two methods are linked.
	 * It is assumed that the member definitions <i>(name + desc)</i> exist in their respective owner classes.
	 *
	 * @param owner1
	 * 		First method's defining class.
	 * @param name1
	 * 		First method's name.
	 * @param desc1
	 * 		First method's descriptor.
	 * @param owner2
	 * 		Second method's defining class.
	 * @param name2
	 * 		Second method's name.
	 * @param desc2
	 * 		Second method's descriptor.
	 *
	 * @return {@code true} if the two methods belong to the same hierarchy.
	 */
	public boolean areLinked(String owner1, String name1, String desc1, String owner2, String name2, String desc2) {
		// Obviously mis-matching definitions are not linked
		if (!name1.equals(name2) || !desc1.equals(desc2))
			return false;
		// Check if owner2 is in the same hierarchy as owner1.
		return areLinked(owner1, owner2);
	}

	/**
	 * @param name1
	 * 		Some class name.
	 * @param name2
	 * 		Another class name.
	 *
	 * @return {@code true} if the classes belong to the same hierarchy.
	 */
	public boolean areLinked(String name1, String name2) {
		// Check if name2 is in the same hierarchy as name1.
		return getHierarchy(name1).stream()
				.anyMatch(vertex -> name2.equals(vertex.getClassName()));
	}

	// ============================== UTILITY =================================== //

	/**
	 * Populate {@link #descendents} map.
	 */
	public void refresh() {
		// TODO: Call this when the inheritance tree is modified.
		//  - Already called by mappings
		//  - But later if user changes a class name WITHOUT remappping this needs to be called too
		descendents.clear();
		for (ClassReader reader : getWorkspace().getPrimaryClassReaders()) {
			String superName = reader.getSuperName();
			if (superName == null || !superName.equals("java/lang/Object"))
				descendents.computeIfAbsent(superName, k -> new HashSet<>()).add(reader.getClassName());
			for (String inter : reader.getInterfaces()) {
				descendents.computeIfAbsent(inter, k -> new HashSet<>()).add(reader.getClassName());
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/graph/inheritance/HierarchyVertex.java`:

```java
package me.coley.recaf.graph.inheritance;

import me.coley.recaf.graph.*;
import org.objectweb.asm.ClassReader;

import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * ClassVertex implementation with the inheritance tree used as the edge source.
 *
 * @author Matt
 */
public class HierarchyVertex extends ClassVertex<HierarchyGraph> {
	/**
	 * Constructs a hierarchy vertex from the containing hierarchy and class reader.
	 *
	 * @param graph
	 * 		The containing hierarchy.
	 * @param clazz
	 * 		The vertex data.
	 */
	public HierarchyVertex(HierarchyGraph graph, ClassReader clazz) {
		super(graph, clazz);
	}

	@Override
	public Set<Edge<ClassReader>> getEdges() {
		// Get names of parents/children
		Stream<String> parents = graph.getParents(getData().getClassName());
		Stream<String> children = graph.getDescendants(getData().getClassName());
		// Get values of parents/children
		Stream<ClassReader> parentValues = getReadersFromNames(parents);
		Stream<ClassReader> childrenValues = getReadersFromNames(children);
		// Get edges of parents/children
		Stream<Edge<ClassReader>> parentEdges = parentValues.map(node -> {
			HierarchyVertex other = graph.getVertex(node.getClassName());
			if(other == null) {
				other = new HierarchyVertex(graph, node);
			}
			return new DirectedEdge<>(other, HierarchyVertex.this);
		});
		Stream<Edge<ClassReader>> childrenEdges = childrenValues.map(node -> {
			HierarchyVertex other = graph.getVertex(node.getClassName());
			return new DirectedEdge<>(HierarchyVertex.this, other);
		});
		// Concat edges and return as set.
		return Stream.concat(parentEdges, childrenEdges).collect(Collectors.toSet());
	}
}

```

`src/main/java/me/coley/recaf/mapping/AsmMappingUtils.java`:

```java
package me.coley.recaf.mapping;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import me.coley.recaf.util.CollectionUtil;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Util class to work with ASM mappings based on String operations, such as extracting portions of ASM mapping keys or
 * folding new mappings onto an existing mapping.
 *
 * @author Marius Renner
 */
public class AsmMappingUtils {
    private AsmMappingUtils() {
        // static class
    }

    /**
     * Extracts the fully qualified class name portion from a mapping key in ASM format.
     * (See {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)}) for format information.
     *
     * @param asmKey ASM mapping key to extract the fully qualified class name from.
     * @return Fully qualified class name of the given ASM mapping key or {@code null} if this is not applicable.
     */
    public static String getClassNameFromAsmKey(String asmKey) {
        // Don't map constructors/static-initializers
        if (asmKey.contains("<"))
            return null;

        boolean isMember = asmKey.contains(".");
        if (!isMember) {
            // This is a class, just return the original mapping key
            return asmKey;
        }

        // Check if the key indicates an invoke-dynamic call
        // Don't return anything for invokdynamic
        boolean isInvokeDynamic = asmKey.charAt(0) == '.';
        if (isInvokeDynamic)
            return null;

        int dotIndex = asmKey.indexOf('.');
        return asmKey.substring(0, dotIndex);
    }

    /**
     * Applies a new mapping in ASM format (See {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)})
     * to an existing mapping in ASM format. This will handle transitive renames ({@code a -> b -> c} by compressing
     * them down to their ultimate result ({@code a -> c}).
     * When this method is used for every update of the mappings, the resulting mapping can be applied to the original
     * class files to achieve the same result again.
     *
     * <p>Note that the exiting mapping is modified by this method!
     *
     * @param existing   Existing ASM mapping to be updated with the additional mappings.
     * @param additional Additional ASM mappings to update the original mapping with.
     */
    public static void applyMappingToExisting(Map<String, String> existing, Map<String, String> additional) {
        Map<String, String> keyToKeyMapping = transformAsmMappingValuesToKeyFormat(existing);
        Multimap<String, String> inverseMapping =
                Multimaps.invertFrom(Multimaps.forMap(keyToKeyMapping), ArrayListMultimap.create());

        Map<String, String> preimageAwareUpdates = new HashMap<>();
        for (Map.Entry<String, String> entry : additional.entrySet()) {
            String key = entry.getKey();
            final String value = entry.getValue();
            entry = null; // don't use the original entry anymore as we might modify the key

            boolean isMember = key.contains(".");
            if (isMember) {
                /* With members we need to take special care:
                   The user might have renamed com/example/MyClass to com/example/MyAwesomeClass before and now renamed
                   com/example/MyAwesomeClass.MY_CONSTANT to com/example/MyAwesomeClass.MY_AWESOME_CONSTANT.
                   In this case we want to create the mapping "com/example/MyClass.MY_CONSTANT MY_AWESOME_CONSTANT". */
                String className = getClassNameFromAsmKey(key);
                Collection<String> classPreimages = inverseMapping.get(className);
                if (classPreimages.size() > 1) {
                    throw new IllegalStateException("Reverse mapping of class" + className + " while reverse mapping "
                            + key + " gave more than 1 result: " + String.join(", " + classPreimages));
                }
                // if we have a preimage for the class, apply the mapping to that preimage class name
                // otherwise use given name
                String targetClassName = classPreimages.isEmpty() ? className : classPreimages.iterator().next();
                String memberInfo = key.substring(key.indexOf('.') + 1);
                if (memberInfo.contains(" ")) {
                    int x = memberInfo.indexOf(" ");
                    String fieldName = memberInfo.substring(0, x);
                    String fieldDesc = memberInfo.substring(x + 1);
                    key = targetClassName + "." + fieldName + " " + mapDesc(existing, fieldDesc);
                } else if (memberInfo.contains("(")) {
                    int x = memberInfo.indexOf("(");
                    String methodName = memberInfo.substring(0, x);
                    String methodDesc = memberInfo.substring(x);
                    key = targetClassName + "." + methodName + mapDesc(existing, methodDesc);
                } else {
                    key = targetClassName + "." + memberInfo;
                }
            }

            // check if this class/member has been mapped before and transform the mapping accordingly
            Collection<String> preimages = inverseMapping.get(key);
            if (preimages.size() > 1) {
                throw new IllegalStateException("Reverse mapping of " + key
                        + " gave more than 1 result: " + String.join(", " + preimages));
            }
            if (preimages.size() == 1) {
                preimageAwareUpdates.put(preimages.iterator().next(), value);
            } else {
                preimageAwareUpdates.put(key, value);
            }
        }

        existing.putAll(preimageAwareUpdates);
    }

    /**
     * @param existing
     * 		Current aggregate mappings.
     * @param desc
     * 		Descriptor to map.
     *
     * @return Mapped descriptor.
     */
    private static String mapDesc(Map<String, String> existing, String desc) {
        SimpleRecordingRemapper remapper = new SimpleRecordingRemapper(
                CollectionUtil.invert(existing), false, false, false, null);
        return desc.charAt(0) == '(' ?
                remapper.mapMethodDesc(desc) :
                remapper.mapDesc(desc);
    }

    /**
     * Transforms a given mapping in ASM format (See
     * {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)}) to a mapping where the values are in the
     * key format of ASM mappings. This allows using the new value as keys for another transformation step.
     *
     * <p>For example the mapping {@code calc/MyCalculator.MAX_DEPTH -> MAX_DEPTH_LEVEL} will be transformed to
     * {@code calc/MyCalculator.MAX_DEPTH -> calc/Calculator.MAX_DEPTH_LEVEL}
     *
     * @param mapping ASM mapping to transform.
     * @return Transformed mapping where the value would be a valid key for another ASM transformation step.
     */
    public static Map<String, String> transformAsmMappingValuesToKeyFormat(Map<String, String> mapping) {
        return mapping.entrySet().stream()
                .map(AsmMappingUtils::transformSingleAsmMappingToKeyFormat)
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private static Map.Entry<String, String> transformSingleAsmMappingToKeyFormat(Map.Entry<String, String> mapping) {
        // Heavily inspired by SimpleRecordingRemapper.map()
        String key = mapping.getKey();
        String value = mapping.getValue();

        // Don't map constructors/static-initializers
        if (key.contains("<"))
            return null;

        boolean isMember = key.contains(".");
        if (!isMember) {
            // This is a class, just return the original mapping as its value is the applied value
            return mapping;
        }

        // Don't map invokedynamic calls
        boolean isInvokeDynamic = key.charAt(0) == '.';
        if (isInvokeDynamic)
            return null;

        int braceIndex = key.indexOf('(');
        boolean isMethod = braceIndex != -1;
        int dotIndex = key.indexOf('.');
        String className = key.substring(0, dotIndex);
        if (!isMethod) {
            String newName = className + "." + value;
            return new AbstractMap.SimpleEntry<>(key, newName);
        }

        String descriptor = key.substring(braceIndex);
        String newName = className + "." + value + descriptor;
        return new AbstractMap.SimpleEntry<>(key, newName);
    }
}

```

`src/main/java/me/coley/recaf/mapping/Correlation.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.Recaf;
import me.coley.recaf.graph.flow.*;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.*;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.function.Function.identity;

/**
 * Utility for analyzing the similarity between two resources.
 *
 * @author Matt
 */
public class Correlation {
	private final Workspace workspace;
	private final JavaResource base;
	private final JavaResource target;

	/**
	 * Constructs a correlation mapper between two resources.
	 *
	 * @param workspace
	 *  The workspace containing the resources.
	 * @param base
	 * 		The base comparison resource.
	 * @param target
	 * 		The target resource analyzed for similarities against the base.
	 */
	public Correlation(Workspace workspace, JavaResource base, JavaResource target) {
		this.workspace = workspace;
		this.base = base;
		this.target = target;
	}

	/**
	 * @return Set of {@link me.coley.recaf.mapping.CorrelationResult} for each common entry point
	 * <i>(Main method)</i> discovered among the base and target sources.
	 */
	public Set<CorrelationResult> analyze() {
		// Collect entry points "main(String[])"
		Set<FlowVertex> baseEntryPoints = getEntryPoints(base);
		Set<FlowVertex> targetEntryPoints = getEntryPoints(target);
		if (baseEntryPoints.size() != targetEntryPoints.size())
			throw new IllegalArgumentException("Base and target resources must have the same number " +
					"of entry points! Found " + baseEntryPoints.size() + " and " +
					targetEntryPoints.size() + " respectively");
		if (baseEntryPoints.isEmpty())
			throw new IllegalArgumentException("No entry points found in either resource!");
		return analyze(baseEntryPoints, targetEntryPoints);
	}

	/**
	 * @param baseEntry
	 * 		Entry point in the base resource.
	 * @param targetEntry
	 * 		Entry point in the target resource, assumed to outline the same data flow.
	 *
	 * @return {@link me.coley.recaf.mapping.CorrelationResult} for the common entry point given.
	 */
	public CorrelationResult analyze(FlowVertex baseEntry, FlowVertex targetEntry) {
		Set<CorrelationResult> results = analyze(Collections.singleton(baseEntry),
				Collections.singleton(targetEntry));
		if (results.size() != 1)
			throw new IllegalStateException("Analyzed a single entry point, but returned "
					+ results.size() + " results");
		return results.iterator().next();
	}

	/**
	 * @param baseEntries
	 * 		Entry points in the base resource.
	 * @param targetEntries
	 * 		Entry points in the target resource, assumed to outline the same data flow.
	 *
	 * @return Set of {@link me.coley.recaf.mapping.CorrelationResult} for each common entry point.
	 */
	public Set<CorrelationResult> analyze(Set<FlowVertex> baseEntries, Set<FlowVertex> targetEntries) {
		// Map CFG vertex to simplified vertex builder
		Function<FlowVertex, FlowBuilder> mapper = vertex -> {
			FlowBuilder builder = new FlowBuilder();
			builder.build(vertex);
			return builder;
		};
		// Collect simplified, non-generative graph layouts
		List<FlowBuilder.Flow> baseRoots = baseEntries.stream()
				.collect(Collectors.toMap(identity(), mapper))
				.entrySet().stream()
				.map(e -> e.getValue().getVertices().get(e.getKey().toString()))
				.collect(Collectors.toList());
		List<FlowBuilder.Flow> targetRoots = targetEntries.stream()
				.collect(Collectors.toMap(identity(), mapper))
				.entrySet().stream()
				.map(e -> e.getValue().getVertices().get(e.getKey().toString()))
				.collect(Collectors.toList());
		Collections.sort(baseRoots);
		Collections.sort(targetRoots);
		// Compare and collect results
		Set<CorrelationResult> results = new HashSet<>();
		for(int i = 0; i < baseRoots.size(); i++) {
			FlowBuilder.Flow baseFlow = baseRoots.get(i);
			FlowBuilder.Flow targetFlow = targetRoots.get(i);
			baseFlow.sort();
			targetFlow.sort();
			// Difference on demand in result structure
			results.add(new CorrelationResult(workspace, base, target, baseFlow, targetFlow));
		}
		return results;
	}

	private Set<FlowVertex> getEntryPoints(JavaResource resource) {
		FlowGraph flow = workspace.getFlowGraph();
		Function<ClassReader, FlowVertex> readerToVert =
				reader -> flow.getVertex(reader, "main", "([Ljava/lang/String;)V");
		return resource.getClasses().values().stream()
				.map(ClassReader::new)
				.filter(Correlation::containsEntry)
				.map(readerToVert)
				.collect(Collectors.toSet());
	}

	private static boolean containsEntry(ClassReader reader) {
		boolean[] contains = {false};
		ClassVisitor cv = new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public MethodVisitor visitMethod(int access, String name, String descriptor,
											 String signature, String[] exceptions) {
				if(name.equals("main") && descriptor.equals("([Ljava/lang/String;)V"))
					contains[0] = true;
				return null;
			}
		};
		reader.accept(cv, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE);
		return contains[0];
	}
}

```

`src/main/java/me/coley/recaf/mapping/CorrelationResult.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.graph.flow.FlowBuilder;
import me.coley.recaf.graph.flow.FlowVertex;
import me.coley.recaf.graph.inheritance.HierarchyGraph;
import me.coley.recaf.graph.inheritance.HierarchyVertex;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;

import java.util.*;

/**
 * Correlation analysis result for some entry point. The {@link #getBase() base} represents the
 * entry point in the reference program. The {@link #getTarget() target} represents the entry point in
 * another program, assumed to be the same but with renamed identifiers.
 *
 * @author Matt
 */
public class CorrelationResult {
	private final Workspace workspace;
	private final JavaResource baseResource;
	private final JavaResource targetResource;
	private final FlowBuilder.Flow base;
	private final FlowBuilder.Flow target;
	private Set<FlowBuilder.Flow> difference;

	/**
	 * Constructs a correlation result.
	 *
	 * @param workspace
	 * 		The workspace to reference.
	 * @param baseResource
	 * 		Resource for base references.
	 * @param targetResource
	 * 		Resource for target references.
	 * @param base
	 * 		Simplified flow graph of an entry point in the base resource.
	 * @param target
	 * 		Simplfiied flow graph of an entry point in the target resource.
	 */
	public CorrelationResult(Workspace workspace, JavaResource baseResource, JavaResource targetResource,
							 FlowBuilder.Flow base, FlowBuilder.Flow target) {
		this.workspace = workspace;
		this.baseResource = baseResource;
		this.targetResource = targetResource;
		this.base = base;
		this.target = target;
	}

	/**
	 * @return Simplified flow graph of an entry point in the target resource.
	 */
	public FlowBuilder.Flow getBase() {
		return base;
	}

	/**
	 * @return Simplified flow graph of an entry point in the target resource.
	 */
	public FlowBuilder.Flow getTarget() {
		return target;
	}

	/**
	 * @return The set of vertices attached to the base flow that do not have
	 * mappings to the vertices connected to the target flow. An empty set indicates
	 * the flow vertices model the same structure / call-graph.
	 */
	public Set<FlowBuilder.Flow> getDifference() {
		if (difference == null)
			difference = base.getDifference(target);
		return difference;
	}

	/**
	 * Generates ASM formatted mappings based on the assumed equality of control flow among the
	 * {@link #getBase() base} and {@link #getTarget() target} call graphs.
	 * <br>
	 * See the
	 * {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)} docs for more
	 * information.
	 *
	 * @return ASM formatted mappings.
	 */
	public Map<String, String> getMappings() {
		Map<String, String> map = new HashMap<>();
		map(map, getDifference(), getBase(), getTarget());
		return map;
	}

	private void map(Map<String, String> map, Set<FlowBuilder.Flow> diff,
					 FlowBuilder.Flow baseFlow, FlowBuilder.Flow targetFlow) {
		// Abandon if the base flow is in the difference set.
		// All further mappings cannot be trusted, so we return.
		if(diff.contains(baseFlow))
			return;
		// base values
		FlowVertex baseVal = baseFlow.getValue();
		String baseOwner = baseVal.getOwner();
		String baseName = baseVal.getName();
		// target values
		FlowVertex targetVal = targetFlow.getValue();
		String targetOwner = targetVal.getOwner();
		String targetName = targetVal.getName();
		String targetDesc = targetVal.getDesc();
		// generate mappings
		if (!baseOwner.equals(targetOwner))
			map.put(targetOwner, baseOwner);
		if(!baseName.equals(targetName)) {
			// Update the entire hierarchy if the entry does not exist
			String key = targetOwner + "." + targetName + targetDesc;
			if(!map.containsKey(key)) {
				HierarchyGraph hierarchyGraph = workspace.getHierarchyGraph();
				// Creating the classloader from the resource instead of the workspace is INTENTIONAL
				// For overlapping names the workspace will always defer to the primary resource.
				HierarchyVertex targetVert = hierarchyGraph.getVertex(
						new ClassReader(targetResource.getClasses().get(targetOwner)));
				Set<HierarchyVertex> hierarchy = hierarchyGraph.getHierarchy(targetVert);
				for(HierarchyVertex vertex : hierarchy) {
					if(!ClassUtil.containsMethod(vertex.getData(), targetName, targetDesc))
						continue;
					map.put(vertex.getData().getClassName() + "." + targetName + targetDesc, baseName);
				}
			}
		}
		// TODO: since we're sure the flows/classes are the same why not just map out all properties?
		/*
		// TODO: generate additional mappings from matching method descriptors
		Type baseType = Type.getMethodType(baseDesc);
		Type targetType = Type.getMethodType(targetDesc);
		if (baseType.getReturnType().getSort() == Type.OBJECT) {
			map.put(baseType.getReturnType().getInternalName(),
					targetType.getReturnType().getInternalName());
		}
		*/
		// map children in flow
		for (int i = 0; i < baseFlow.getChildren().size(); i++) {
			map(map, diff, baseFlow.getChildren().get(i), targetFlow.getChildren().get(i));
		}
	}
}
```

`src/main/java/me/coley/recaf/mapping/EnigmaMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

import static me.coley.recaf.util.Log.*;

/**
 * Enigma mappings file implementation.
 *
 * @author Matt
 */
public class EnigmaMappings extends FileMappings {
	private static final String FAIL = "Invalid Enigma mappings, ";

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing enigma styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	EnigmaMappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}
	
	private static String removeNonePackage(String text){
		return text.replaceAll("(?:^|(?<=L))none/", "");
	}

	@Override
	protected Map<String, String> parse(String text) {
		Map<String, String> map = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		int line = 0;
		Stack<String> currentClass = new Stack<>();
		for(String lineStr : lines) {
			line++;
			String lineStrTrim = lineStr.trim();
			int strIndent = lineStr.indexOf(lineStrTrim) + 1;
			String[] args = lineStrTrim.split(" ");
			String type = args[0];
			try {
				switch(type) {
					case "CLASS":
						if (lineStr.matches("\\s+.+")) {
							// Check for indentation, implies the class is an inner
							currentClass.add(removeNonePackage(args[1]));
						} else {
							// Root level class
							currentClass.clear();
							currentClass.add(removeNonePackage(args[1]));
						}
						// Not all classes need to be renamed if they have child elements that are renamed
						if (args.length >= 3) {
							String renamedClass = removeNonePackage(args[2]);
							map.put(currentClass.peek(), renamedClass);
						}
						break;
					case "FIELD":
						// Check if no longer within inner-class scope
						if (strIndent < currentClass.size()) {
							currentClass.pop();
						}
						// Parse field
						if (currentClass.empty())
							throw new IllegalArgumentException(FAIL + "could not map field, no class context");
						String currentField = removeNonePackage(args[1]);
						String renamedField = removeNonePackage(args[2]);
						map.put(currentClass.peek() + "." + currentField, renamedField);
						break;
					case "METHOD":
						// Check if no longer within inner-class scope
						if (strIndent < currentClass.size()) {
							currentClass.pop();
						}
						// Parse method
						if (currentClass.empty())
							throw new IllegalArgumentException(FAIL + "could not map method, no class context");
						String currentMethod = args[1];
						if (currentMethod.equals("<init>"))
							continue;
						// Not all methods need to be renamed if they have child arg elements that are renamed
						if (args.length >= 4) {
							String renamedMethod = args[2];
							String methodType = args[3];
							map.put(currentClass.peek() + "." + currentMethod + methodType, renamedMethod);
						}
						break;
					case "ARG":
						// Do nothing, mapper does not support arg names
						break;
					default:
						trace("Unknown Engima mappings line type: \"{}\" @line {}", type, line);
						break;
				}
			} catch(IndexOutOfBoundsException ex) {
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
			}
		}
		return map;
	}
}

```

`src/main/java/me/coley/recaf/mapping/FileMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.workspace.Workspace;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Map;

/**
 * Extended base for mappings that load mappings from a given file.
 * Implementations will create file-loading logic for different mapping types.
 *
 * @author Matt
 */
public abstract class FileMappings extends Mappings {
	/**
	 * @param path
	 * 		A path to a text file containing mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	public FileMappings(Path path, Workspace workspace) throws IOException {
		this(path, workspace, true);
	}

	/**
	 * @param path
	 * 		A path to a text file containing mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 * @param readNow
	 * 		Flag to indicate reading now. Typically {@code true}.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	protected FileMappings(Path path, Workspace workspace, boolean readNow) throws IOException {
		super(workspace);
		if (readNow) {
			read(path.toFile());
		}
	}

	/**
	 * @param file
	 * 		Text file containing mappings.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	protected void read(File file) throws IOException {
		String text = FileUtils.readFileToString(file, "UTF-8");
		setMappings(parse(text));
	}

	/**
	 * Parses the mappings into the standard ASM format. See the
	 * {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)} docs for more
	 * information.
	 *
	 * @param text
	 * 		Text of the mappings.
	 *
	 * @return ASM formatted mappings.
	 */
	protected abstract Map<String, String> parse(String text);
}

```

`src/main/java/me/coley/recaf/mapping/JadxMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

/**
 * JADX deobfuscation mapping file implementation.
 *
 * @author Matt
 */
public class JadxMappings extends FileMappings {
	private static final String FAIL = "Invalid JADX mappings, ";

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing JADX styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	JadxMappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}

	@Override
	protected Map<String, String> parse(String text) {
		// Example:
		// c android.support.a.b.a = C0005a
		// f android.support.a.b.a.a:Ljava/lang/Object; = f3a
		// m android.support.a.a.a.a(Landroid/app/Activity;[Ljava/lang/String;I)V = m0a
		Map<String, String> map = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		int line = 0;
		for (String lineStr : lines) {
			line++;
			String[] args = lineStr.trim().split("[\\s=:]+");
			String type = args[0];
			try {
				switch (type) {
					case "c":
						// 1: class-name
						// 2: renameed class (does not include package)
						// Replace "." in class name
						String original = args[1].replace('.', '/');
						// The new value is always in the same package.
						// Only the class is renamed, not the package.
						map.put(original, original.substring(0, original.lastIndexOf('/') + 1) + args[2]);
						break;
					case "f":
						// 1: class-name.field-name
						// 2: field-type
						// 3: renamed
						// Replace all "." except last one
						map.put(args[1].replaceAll("\\.(?=.+\\..+$)", "/"), args[3]);
						break;
					case "m":
						// 1: class-name.method-name + method-desc
						// 2: renamed
						// Replace all "." except last one
						map.put(args[1].replaceAll("\\.(?=.+\\..+$)", "/"), args[2]);
						break;
					default:
						break;

				}
			} catch (IndexOutOfBoundsException ex) {
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
			}
		}
		return map;
	}
}

```

`src/main/java/me/coley/recaf/mapping/LenientClassRemapper.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.ClassRemapper;
import org.objectweb.asm.signature.SignatureReader;
import org.objectweb.asm.signature.SignatureVisitor;

/**
 * ClassRemapper extension that is crash-lenient. Bogus data that normally crashes ASM will be ignored.
 *
 * @author Matt
 */
public class LenientClassRemapper extends ClassRemapper {
	/**
	 * @param visitor
	 * 		Delegated class visitor.
	 * @param mapper
	 * 		Remapper of types.
	 */
	public LenientClassRemapper(ClassVisitor visitor, SimpleRecordingRemapper mapper) {
		super(visitor, mapper);
	}

	@Override
	public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
		if (isBogus(signature))
			signature = null;
		super.visit(version, access, name, signature, superName, interfaces);
	}

	@Override
	public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {
		if (isBogus(signature))
			signature = null;
		return super.visitRecordComponent(name, descriptor, signature);
	}

	@Override
	public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
		if (isBogus(signature))
			signature = null;
		return super.visitField(access, name, descriptor, signature, value);
	}

	@Override
	public MethodVisitor visitMethod(int access, String name, String descriptor,
									 String signature, String[] exceptions) {
		if (isBogus(signature))
			signature = null;
		return super.visitMethod(access, name, descriptor, signature, exceptions);
	}

	private static boolean isBogus(String signature) {
		try {
			new SignatureReader(signature).accept(new SignatureVisitor(Recaf.ASM_VERSION) {});
			return false;
		} catch (Exception ex) {
			return true;
		}
	}
}

```

`src/main/java/me/coley/recaf/mapping/MappingImpl.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;

/**
 * Enumeration of implemented mapping parsers.
 *
 * @author Matt
 */
public enum MappingImpl {
	SIMPLE("Simple"),
	ENIGMA("Enigma"),
	PROGUARD("Proguard"),
	SRG("SRG"),
	TSRG("TSRG"),
	TINY("Tiny V1"),
	TINY2("Tiny V2"),
	JADX("JADX");

	private final String display;

	MappingImpl(String display) {
		this.display = display;
	}

	/**
	 * @return Display string.
	 */
	public String getDisplay() {
		return display;
	}

	/**
	 * @param path
	 * 		A path to a file containing mappings.
	 * @param workspace
	 * 		Workspace to use for hierarchy lookups.
	 *
	 * @return New mappings  instance of the type.
	 *
	 * @throws IOException
	 * 		When the mappings file could not be loaded.
	 */
	public Mappings create(Path path, Workspace workspace) throws IOException {
		Mappings mappings;
		switch(this) {
			case SIMPLE:
				mappings = new SimpleMappings(path, workspace);
				break;
			case ENIGMA:
				mappings = new EnigmaMappings(path, workspace);
				break;
			case PROGUARD:
				mappings = new ProguardMappings(path, workspace);
				break;
			case SRG:
				mappings = new SrgMappings(path, workspace);
				break;
			case TSRG:
				mappings = new TSrgMappings(path, workspace);
				break;
			case TINY:
				mappings = new TinyV1Mappings(path, workspace);
				break;
			case TINY2:
				mappings = new TinyV2Mappings(path, workspace, TinyV2Mappings.TinyV2SubType.OBF_TO_CLEAN);
				break;
			case JADX:
				mappings = new JadxMappings(path, workspace);
				break;
			default:
				throw new IllegalStateException("Unsupported mapping implementation?");
		}
		return mappings;
	}
}

```

`src/main/java/me/coley/recaf/mapping/Mappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ClassVisitorPlugin;
import me.coley.recaf.workspace.*;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.commons.ClassRemapper;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Base for mapppings.
 *
 * @author Matt
 */
public class Mappings {
	private Map<String, String> mappings;
	private Map<String, String> reverseClassMappings;
	private Workspace workspace;
	private boolean checkFieldHierarchy;
	private boolean checkMethodHierarchy;
	private boolean checkWonkyOuterRelation;
	private boolean clearDebugInfo;

	/**
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 */
	public Mappings(Workspace workspace) {
		this.workspace = workspace;
	}

	/**
	 * See the
	 * {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)} docs for more
	 * information.
	 *
	 * @return ASM formatted mappings.
	 */
	public Map<String, String> getMappings() {
		return mappings;
	}

	/**
	 * Set the {@link #getMappings() mappings}.
	 * @param mappings Mappings to use.
	 */
	public void setMappings(Map<String, String> mappings) {
		this.mappings = mappings;
		// Save inverted class name mappings for class-writing (requires ancestor analysis)
		// - Allows us to not have to recompile in ancestral order
		reverseClassMappings = mappings.entrySet()
				.stream()
				.filter(e -> !e.getKey().contains("."))
				.collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));
	}

	/**
	 * The inverted mappings of {@link #getMappings()}.
	 *
	 * @return Inverted ASM formatted mappings.
	 */
	public Map<String, String> getReverseClassMappings() {
		return reverseClassMappings;
	}

	/**
	 * In some cases automated mappings can reference fields in super-classes but specify the
	 * implementing class as the field's owner. Enabling this flag will allow the mapper to check
	 * against super-classes when mapping these cases.
	 *
	 * @return Flag for if parent classes should be checked for containing fields.
	 */
	public boolean doCheckFieldHierarchy() {
		return checkFieldHierarchy;
	}

	/**
	 * In many cases automated mappings can reference methods declared in super-classes but
	 * specify the implementing class as the method's owner. Enabling this flag will allow the
	 * mapper to check against super-classes when mapping these cases.
	 *
	 * @return Flag for if parent classes should be checked for containing methods.
	 */
	public boolean doCheckMethodHierarchy() {
		return checkMethodHierarchy;
	}

	/**
	 * In some obfuscated classes, an inner class can have a name that shows no relationship to the outer class.
	 * When such classes still contain a reference to the outer class in the {@code InnerClassesAttribute} but
	 * no useful data in the {@link org.objectweb.asm.tree.ClassNode#outerClass}, we can sometimes use the inner
	 * class attribute to resolve what the true outer class name is.
	 *
	 * @return Flag for if outer class resolving should account for wonky renaming.
	 */
	public boolean doCheckWonkyOuterRelation() {
		return checkWonkyOuterRelation;
	}

	/**
	 * @param checkFieldHierarchy Flag for if parent classes should be checked for containing fields.
	 */
	public void setCheckFieldHierarchy(boolean checkFieldHierarchy) {
		this.checkFieldHierarchy = checkFieldHierarchy;
	}

	/**
	 * @param checkMethodHierarchy Flag for if parent classes should be checked for containing methods.
	 */
	public void setCheckMethodHierarchy(boolean checkMethodHierarchy) {
		this.checkMethodHierarchy = checkMethodHierarchy;
	}

	/**
	 * @param checkWonkyOuterRelation Flag for if outer class resolving should account for wonky renaming.
	 */
	public void setCheckWonkyOuterRelation(boolean checkWonkyOuterRelation) {
		this.checkWonkyOuterRelation = checkWonkyOuterRelation;
	}

	/**
	 * Useful for clearing intentionally bad debug info like bad variable names &amp; signatures.
	 *
	 * @return Flag for removing debug information.
	 */
	public boolean doClearDebugInfo() {
		return clearDebugInfo;
	}

	/**
	 * @param clearDebugInfo
	 * 		Flag for removing debug information.
	 */
	public void setClearDebugInfo(boolean clearDebugInfo) {
		this.clearDebugInfo = clearDebugInfo;
	}

	/**
	 * Applies mappings to all classes in the given resource. Return value is the map of updated
	 * classes.
	 *
	 * @param resource
	 * 		Resource containing classes.
	 *
	 * @return Map of updated classes. Keys of the old names, values of the updated code.
	 */
	public Map<String, byte[]> accept(JavaResource resource) {
		// Collect: <OldName, NewBytecode>
		Map<String, byte[]> updated = new HashMap<>();
		for(Map.Entry<String, byte[]> e : resource.getClasses().entrySet()) {
			byte[] old = e.getValue();
			ClassReader cr = new ClassReader(old);
			accept(updated, cr);
		}
		// Update the resource's classes map
		for(Map.Entry<String, byte[]> e : updated.entrySet()) {
			String oldKey = e.getKey();
			String newKey = new ClassReader(e.getValue()).getClassName();
			if (!oldKey.equals(newKey))
				resource.getClasses().remove(oldKey);
			resource.getClasses().put(newKey, e.getValue());
		}
		// Tell the workspace we've finished renaming classes
		workspace.onPrimaryDefinitionChanges(updated.keySet());
		// Update hierarchy graph
		workspace.getHierarchyGraph().refresh();
		// Update saved mappings
		workspace.updateAggregateMappings(getMappings(), updated.keySet());
		return updated;
	}

	/**
	 * Applies mappings to the given class and puts the modified bytecode in the map.
	 *
	 * @param updated
	 * 		Map to collect updated values in.
	 * @param cr
	 * 		Class bytecode reader.
	 */
	private void accept(Map<String, byte[]> updated, ClassReader cr) {
		try {
			accept(updated, cr, ClassReader.SKIP_FRAMES, ClassWriter.COMPUTE_FRAMES);
		} catch(IllegalArgumentException ex) {
			// ASM throws: "JSR/RET are not supported with computeFrames option"
			if (ex.getMessage() != null && ex.getMessage().contains("JSR/RET")) {
				accept(updated, cr, ClassReader.EXPAND_FRAMES, ClassWriter.COMPUTE_MAXS);
			}
		}
	}

	private void accept(Map<String, byte[]> updated, ClassReader cr, int readFlags, int writeFlags) {
		String name = cr.getClassName();
		// Apply with mapper
		SimpleRecordingRemapper mapper = new SimpleRecordingRemapper(getMappings(),
				checkFieldHierarchy, checkMethodHierarchy, checkWonkyOuterRelation, workspace);
		WorkspaceClassWriter cw = workspace.createWriter(writeFlags);
		cw.setMappings(getMappings(), reverseClassMappings);
		ClassVisitor visitor = cw;
		for (ClassVisitorPlugin visitorPlugin : PluginsManager.getInstance()
				.ofType(ClassVisitorPlugin.class)) {
			visitor = visitorPlugin.intercept(visitor);
		}
		ClassRemapper adapter = new LenientClassRemapper(visitor, mapper);
		if (clearDebugInfo)
			readFlags |= ClassReader.SKIP_DEBUG;
		cr.accept(adapter, readFlags);
		// Only return the modified class if any references to the mappings were found.
		if (mapper.isDirty())
			updated.put(name, cw.toByteArray());
	}
}

```

`src/main/java/me/coley/recaf/mapping/ProguardMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

/**
 * Proguard mappings file implementation. <br>
 * Unlike the other mapping formats the intent of this mapper is to <i>undo</i> Proguard mappings,
 * not applying them. This is because unlike the other mapping types, the proguard mappings go from
 * clean names to obfuscated names. Not obfuscated to clean.
 *
 * @author Matt
 */
public class ProguardMappings extends FileMappings {
	private static final String FAIL = "Invalid Proguard mappings, ";
	private static final String NAME_LINE = "^.+:";
	private static final String SPLITTER = "( |->)+";
	private Map<String, String> obfToClean = new HashMap<>();
	private Map<String, String> cleanToObf = new HashMap<>();

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing proguard styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	ProguardMappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}

	@Override
	protected Map<String, String> parse(String text) {
		obfToClean = new HashMap<>();
		cleanToObf = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		collectNames(lines);
		parseMembers(lines);
		return obfToClean;
	}

	private void collectNames(String[] lines) {
		int line = 0;
		for(String lineStr : lines) {
			line++;
			// Skip comments line
			if(lineStr.startsWith("#"))
				continue;
			// Only look at name lines
			if(lineStr.matches(NAME_LINE)) {
				try {
					String[] split = lineStr.split("( |->)+");
					String clean = internalize(split[0]);
					String obf = internalize(split[1]);
					obf = obf.substring(0, obf.indexOf(':'));
					obfToClean.put(obf, clean);
					cleanToObf.put(clean, obf);
				} catch(IndexOutOfBoundsException ex) {
					throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
				}
			}
		}
	}

	private void parseMembers(String[] lines) {
		int line = 0;
		String currentObf = null;
		for(String lineStr : lines) {
			line++;
			// Skip comments line
			if(lineStr.startsWith("#"))
				continue;
			// Mark current class
			if(lineStr.matches(NAME_LINE)) {
				currentObf = internalize(lineStr.substring(lineStr.lastIndexOf(' ') + 1, lineStr.indexOf(':')));
				continue;
			}
			if(currentObf == null)
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line + ", no class context");
			// Handle members
			if(!lineStr.contains("(")) {
				// Field
				// <type> <clean-name> -> <obf-name>
				String[] split = lineStr.trim().split(SPLITTER);
				String clean = split[1];
				String obf = split[2];
				/*
				String type = split[0];
				if (!isPrimitive(type))
					type = "L" + internalize(type) + ";";
				else
					type = internalize(type);
				*/
				obfToClean.put(currentObf + "." + obf, clean);
			} else {
				// Skip constructors
				if (lineStr.contains("init>"))
					continue;
				// Method 64:168:void updateStream() -> i
				// <start>:<finish>:<ret-type> <name><qualified-desc> -> <obf-name>
				// <ret-type> <name::qualified-desc> -> <obf-name>
				String[] split = null;
				if (lineStr.contains(":"))
					split = lineStr.substring(lineStr.lastIndexOf(":") + 1).trim().split(SPLITTER);
				else
					split = lineStr.trim().split(SPLITTER);
				// Return type
				// - Internalize the type (void -> V, or com.Type -> com/Type))
				// - Map to obf if the type is not primitive
				String proRet = split[0];
				String cleanRet = internalize(proRet);
				String obfRet = isPrimitive(proRet) ? cleanRet :
						"L" + cleanToObf.getOrDefault(cleanRet, cleanRet) + ";";
				// Parse the desc
				// name(name,name)
				String cleanDefintion = split[1];
				String clean = cleanDefintion.substring(0, cleanDefintion.indexOf('('));
				String[] progaurdArgs = cleanDefintion
						.substring(cleanDefintion.indexOf('(') + 1, cleanDefintion.length() - 1)
						.split(",");
				if (progaurdArgs.length == 1 && progaurdArgs[0].isEmpty())
					progaurdArgs = new String[0];
				for (int i = 0; i < progaurdArgs.length; i++) {
					String type = progaurdArgs[i];
					// Swap clean name with obf name (already internalized)
					String typeObf = cleanToObf.get(type.replace(".", "/"));
					if (typeObf != null) {
						progaurdArgs[i] = "L" + typeObf + ";";
						continue;
					}
					// Internalize the type
					if (isPrimitive(type))
						progaurdArgs[i] = internalize(progaurdArgs[i]);
					else
						progaurdArgs[i] = "L" + internalize(progaurdArgs[i]) + ";";
				}
				String obf = split[2];
				String obfDesc = "(" + String.join("", progaurdArgs) + ")" + obfRet;
				String obfKey = currentObf + "." + obf + obfDesc;
				obfToClean.put(obfKey, clean);
			}
		}
	}

	private String internalize(String name) {
		switch(name) {
			case "int":
				return "I";
			case "float":
				return "F";
			case "double":
				return "D";
			case "long":
				return "J";
			case "boolean":
				return "Z";
			case "short":
				return "S";
			case "byte":
				return "B";
			case "void":
				return "V";
			default:
				return name.replace('.', '/');
		}
	}

	private boolean isPrimitive(String name) {
		switch(name) {
			case "int":
			case "float":
			case "double":
			case "long":
			case "boolean":
			case "short":
			case "byte":
			case "void":
				return true;
			default:
				return false;
		}
	}
}

```

`src/main/java/me/coley/recaf/mapping/SimpleMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import static me.coley.recaf.util.StringUtil.splitNewline;
import static me.coley.recaf.util.EscapeUtil.*;

/**
 * Simple mappings file implementation where the old/new names are split by a space.
 * The input format of the mappings is based on the format outlined by
 * {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)}.
 * <br>
 * Differences include:
 * <ul>
 *     <li>Support for {@code #comment} lines</li>
 *     <li>Support for unicode escape sequences ({@code \\uXXXX})</li>
 *     <li>Support for fields specified by their name <i>and descriptor</i></li>
 * </ul>
 *
 * @author Matt
 */
public class SimpleMappings extends FileMappings {
	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing asm styled mappings.
	 * 		See {@link org.objectweb.asm.commons.SimpleRemapper#SimpleRemapper(Map)}.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	SimpleMappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}

	@Override
	protected Map<String, String> parse(String text) {
		String[] lines = splitNewline(text);
		Map<String, String> map = new HashMap<>(lines.length);
		// # Comment
		// BaseClass TargetClass
		// BaseClass.baseField targetField
		// BaseClass.baseField baseDesc targetField
		// BaseClass.baseMethod(BaseMethodDesc) targetMethod
		for (String line : lines) {
			// Skip comments and empty lines
			if (line.trim().startsWith("#") || line.trim().isEmpty())
				continue;
			String[] args = line.split(" ");
			String baseName = unescape(args[0]);
			if (args.length > 2) {
				// Descriptor qualified field format
				String baseDesc = unescape(args[1]);
				String targetName = unescape(args[2]);
				map.put(baseName + " " + baseDesc, targetName);
			} else {
				// Any other format
				String targetName = unescape(args[1]);
				map.put(baseName, targetName);
			}
		}
		return map;
	}
}

```

`src/main/java/me/coley/recaf/mapping/SimpleRecordingRemapper.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.commons.SimpleRemapper;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InnerClassNode;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * An extension of the SimpleRemapper that logs if a class has been modified in the renaming
 * process.
 *
 * @author Matt
 */
public class SimpleRecordingRemapper extends SimpleRemapper {
	private final boolean checkFieldHierarchy;
	private final boolean checkMethodHierarchy;
	private final boolean checkWonkyOuterRelation;
	private final Workspace workspace;
	private boolean dirty;

	/**
	 * Constructs a recording remapper.
	 *
	 * @param mapping
	 * 		Map of asm styled mappings. See
	 *        {@link SimpleRemapper#SimpleRemapper(Map)}.
	 * @param checkFieldHierarchy
	 * 		Flag for checking for field keys using super-classes.
	 * @param checkMethodHierarchy
	 * 		Flag for checking for method keys using super-classes.
	 * @param checkWonkyOuterRelation
	 * 		Flag for if outer class resolving should account for wonky renaming.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 */
	public SimpleRecordingRemapper(Map<String, String> mapping, boolean checkFieldHierarchy,
								   boolean checkMethodHierarchy, boolean checkWonkyOuterRelation,
								   Workspace workspace) {
		super(mapping);
		this.checkFieldHierarchy = checkFieldHierarchy;
		this.checkMethodHierarchy = checkMethodHierarchy;
		this.checkWonkyOuterRelation = checkWonkyOuterRelation;
		this.workspace = workspace;
	}

	/**
	 * If a class contains no references to anything in the mappings there will be no reason to
	 * update it within Recaf, so we record if any changes were made. If no changes are made we
	 * can disregard the remapped output.
	 *
	 * @return {@code true} if the class has been modified in the remapping process.
	 */
	public boolean isDirty() {
		return dirty;
	}

	@Override
	public String mapFieldName(String owner, String name, String descriptor) {
		// Standard format
		String remappedName = map(owner + '.' + name);
		// Check if we are also using descriptors in keys, in cases where name overloading occurs
		if (remappedName == null)
			remappedName = map(owner + '.' + name + ' ' + descriptor);
		return remappedName == null ? name : remappedName;
	}

	@Override
	public String map(final String key) {
		// Don't map constructors/static-initializers
		if (key.contains("<"))
			return null;
		// Get mapped value from key
		String mapped = super.map(key);
		// No direct key mapping found?
		if (mapped == null) {
			boolean member = key.contains(".");
			// Check if the key indicates if the value is a member (field/method)
			if (member) {
				// Check if the key indicates an invoke-dynamic call
				// Don't do any parent checking if its an invoke-dynamic.
				if (key.charAt(0) == '.')
					return null;
				// No direct mapping for this member is found, perhaps it was mapped in a super-class
				boolean method = key.contains("(");
				String memberDef = key.substring(key.indexOf(".") + 1);
				// Normally we would check the whole hierarchy, but the mappings should at least be
				// correct enough for this to work.
				if ((!method && checkFieldHierarchy) || (method && checkMethodHierarchy)) {
					for (String parent : getParents(key)) {
						// Attempt to map with parent name
						mapped = map(parent + "." + memberDef);
						// If found, break so we can return the discovered mapping.
						if (mapped != null)
							break;
					}
				}
			} else {
				// Not a member, so this is a class definition.
				// Is this an inner class? If so ensure the qualified outer name is mapped
				int index = key.lastIndexOf("$");
				if(index > 1) {
					// key is an inner class
					String outer = key.substring(0, index);
					String inner = key.substring(index);
					String mappedOuter = map(outer);
					if(mappedOuter != null)
						return mappedOuter + inner;
				} else if (checkWonkyOuterRelation && workspace.getPrimary().getClasses().containsKey(key)){
					// Check if the class is just obfuscated and does not respect the "outer$inner" pattern.
					String outer = getUnmatchedOuter(key);
					if (outer != null) {
						// key is an inner class
						String inner = key.substring(key.lastIndexOf('/') + 1);
						String mappedOuter = map(outer);
						if (mappedOuter != null)
							return mappedOuter + inner;
					}
				}
			}
		}
		// Mark as dirty if mappings found
		if(mapped != null)
			dirty = true;
		return mapped;
	}

	/**
	 * Sometimes obfuscators rename inner classes and do not retain the {@code outer$inner} pattern.
	 * So we need to check for that here.
	 *
	 * @param name Class name to check for outers.
	 * @return Name of outer class or {@code null} if no outer exists.
	 */
	private String getUnmatchedOuter(String name) {
		ClassReader cr = workspace.getClassReader(name);
		if (cr == null)
			return null;
		ClassNode node = ClassUtil.getNode(cr, ClassReader.SKIP_CODE);
		// Check for outer name attr
		if (node.outerClass != null && !node.name.equals(node.outerClass))
			return node.outerClass;
		// Check if internal name of inner matches,
		// then use outer name if its not exactly the same as the given name.
		for (InnerClassNode inner : node.innerClasses) {
			if (inner.name.equals(name) && inner.outerName != null && !inner.outerName.equals(name))
				return inner.outerName;
		}
		return null;
	}

	/**
	 * @param key
	 * 		Mapping key.
	 *
	 * @return Stream of super classes.
	 */
	private Set<String> getParents(String key) {
		// Get class from key
		String className = key.contains(".") ? key.substring(0, key.indexOf(".")) : key;
		// Get parents in hierarchy
		return workspace.getHierarchyGraph().getParents(className)
				.collect(Collectors.toSet());
	}
}

```

`src/main/java/me/coley/recaf/mapping/SrgMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import static me.coley.recaf.util.Log.trace;

/**
 * SRG mappings file implementation.
 *
 * @author Matt
 */
public class SrgMappings extends FileMappings {
	private static final String FAIL = "Invalid SRG mappings, ";

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing SRG styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	SrgMappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}

	@Override
	protected Map<String, String> parse(String text) {
		Map<String, String> map = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		int line = 0;
		for(String lineStr : lines) {
			line++;
			String[] args = lineStr.trim().split(" ");
			String type = args[0];
			try {
				switch(type) {
					case "CL:":
						String obfClass = args[1];
						String renamedClass = args[2];
						map.put(obfClass, renamedClass);
						break;
					case "FD:": {
						String obfKey = args[1];
						int splitPos = obfKey.lastIndexOf('/');
						String obfOwner = obfKey.substring(0, splitPos);
						String obfName = obfKey.substring(splitPos + 1);
						String renamedKey = args[2];
						splitPos = renamedKey.lastIndexOf('/');
						String renamedName = renamedKey.substring(splitPos + 1);
						map.put(obfOwner + "." + obfName, renamedName);
						break;
					}
					case "MD:": {
						String obfKey = args[1];
						int splitPos = obfKey.lastIndexOf('/');
						String obfOwner = obfKey.substring(0, splitPos);
						String obfName = obfKey.substring(splitPos + 1);
						String obfDesc = args[2];
						String renamedKey = args[3];
						splitPos = renamedKey.lastIndexOf('/');
						String renamedName = renamedKey.substring(splitPos + 1);
						map.put(obfOwner + "." + obfName + obfDesc, renamedName);
						break;
					}
					default:
						trace("Unknown SRG mappings line type: \"{}\" @line {}", type, line);
						break;
				}
			} catch(IndexOutOfBoundsException ex) {
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
			}
		}
		return map;
	}
}

```

`src/main/java/me/coley/recaf/mapping/TSrgMappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

/**
 * TSRG mappings file implementation.
 *
 * @author Filip (1fxe)
 */
public class TSrgMappings extends FileMappings {
    private static final String FAIL = "Invalid TSrg mappings, ";

    /**
     * Constructs mappings from a given file.
     *
     * @param path      A path to a file containing TSrg styled mappings.
     * @param workspace Workspace to pull names from when using hierarchy lookups.
     * @throws IOException Thrown if the file could not be read.
     */
    TSrgMappings(Path path, Workspace workspace) throws IOException {
        super(path, workspace);
    }

    @Override
    protected Map<String, String> parse(String text) {
        String[] lines = StringUtil.splitNewline(text);
        Map<String, String> map = new HashMap<>(lines.length);
        int line = 0;
        String obfOwner = null;
        for (String lineStr : lines) {
            line++;
            String[] args = lineStr.trim().split(" ");
            try {
                // Fields and Methods start with a tab
                // class/Name new/Name
                //      fieldName newFieldName
                //      methodName methodDesc newMethodName
                if (!lineStr.startsWith("\t")) {
                    obfOwner = args[0];
                    String renamedClass = args[1];
                    map.put(obfOwner, renamedClass);
                } else {
                    if (args.length == 2) { // Field
                        String obfName = args[0];
                        String renamedName = args[1];
                        map.put(obfOwner + "." + obfName, renamedName);
                    } else if (args.length == 3) { // Method
                        String obfName = args[0];
                        String obfDesc = args[1];
                        String renamedName = args[2];
                        map.put(obfOwner + "." + obfName + obfDesc, renamedName);
                    }
                }
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
            }
        }
        return map;
    }
}

```

`src/main/java/me/coley/recaf/mapping/TinyV1Mappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import static me.coley.recaf.util.Log.trace;

/**
 * Tiny-V1 mappings file implementation.
 *
 * @author Matt
 */
public class TinyV1Mappings extends FileMappings {
	private static final String FAIL = "Invalid Tiny-V1 mappings, ";

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing Tiny-V1 styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	TinyV1Mappings(Path path, Workspace workspace) throws IOException {
		super(path, workspace);
	}

	@Override
	protected Map<String, String> parse(String text) {
		Map<String, String> map = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		int line = 0;
		for(String lineStr : lines) {
			line++;
			// Skip initial header
			if (lineStr.startsWith("v1\t"))
				continue;
			String[] args = lineStr.trim().split("\t");
			String type = args[0];
			try {
				switch(type) {
					case "CLASS":
						String obfClass = args[1];
						String renamedClass = args[2];
						map.put(obfClass, renamedClass);
						break;
					case "FIELD": {
						String obfOwner = args[1];
						String obfName =  args[3];
						String renamed = args[4];
						map.put(obfOwner + "." + obfName, renamed);
						break;
					}
					case "METHOD": {
						String obfOwner = args[1];
						String obfDesc =  args[2];
						String obfName =  args[3];
						String renamed = args[4];
						map.put(obfOwner + "." + obfName + obfDesc, renamed);
						break;
					}
					default:
						trace("Unknown Tiny-V1 mappings line type: \"{}\" @line {}", type, line);
						break;
				}
			} catch(IndexOutOfBoundsException ex) {
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
			}
		}
		return map;
	}
}

```

`src/main/java/me/coley/recaf/mapping/TinyV2Mappings.java`:

```java
package me.coley.recaf.mapping;

import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import static me.coley.recaf.util.Log.trace;

/**
 * Tiny-V2 mappings file implementation.
 * <br>
 * <a href="https://github.com/FabricMC/tiny-remapper/issues/9">[Specification of format]</a>
 *
 * @author Matt
 */
public class TinyV2Mappings extends FileMappings {
	private static final String FAIL = "Invalid Tiny-V2 mappings, ";
	private final TinyV2SubType subType;

	/**
	 * Constructs mappings from a given file.
	 *
	 * @param path
	 * 		A path to a file containing Tiny-V2 styled mappings.
	 * @param workspace
	 * 		Workspace to pull names from when using hierarchy lookups.
	 * @param subType
	 * 		Tiny V2 direction type for mapping.
	 *
	 * @throws IOException
	 * 		Thrown if the file could not be read.
	 */
	public TinyV2Mappings(Path path, Workspace workspace, TinyV2SubType subType) throws IOException {
		super(path, workspace, false);
		this.subType = subType;
		read(path.toFile());
	}

	@Override
	protected Map<String, String> parse(String text) {
		Map<String, String> map = new HashMap<>();
		String[] lines = StringUtil.splitNewline(text);
		int line = 0;
		String currentClass = null;
		for(String lineStr : lines) {
			line++;
			// Skip initial header
			if (lineStr.startsWith("tiny\t"))
				continue;
			String lineStrTrim = lineStr.trim();
			int strIndent = lineStr.indexOf(lineStrTrim);
			String[] args = lineStrTrim.split("\t");
			String type = args[0];
			try {
				// A note on the "intermediate" values... I have seen cases of the format where this column
				// does not exist... so the fix here will be to check for the number of columns. If there are
				// enough, we assume it contains the intermediate in the middle. Otherwise, there is none.
				switch(type) {
					case "c":
						// TinyV2 reuses "c" for "comment" too
						// These are indented to indicate they belong to members/types, so skip em.
						if (strIndent > 0)
							continue;
						// [1] = current
						// [2*] = intermediate
						// [3] = renamed
						int[] clsRenameIndices = subType.getFromXToYOffsets(Context.CLASS, args.length);
						currentClass = args[clsRenameIndices[0]];
						String renamedClass = args[clsRenameIndices[1]];
						map.put(currentClass, renamedClass);
						break;
					case "f":
						if (currentClass == null)
							throw new IllegalArgumentException(FAIL + "could not map field, no class context");
						// [1] = desc
						// [2] = current
						// [3*] = intermediate
						// [4] = renamed
						int[] fldRenameIndices = subType.getFromXToYOffsets(Context.FIELD, args.length);
						String currentField = args[fldRenameIndices[0]];
						String renamedField = args[fldRenameIndices[1]];
						map.put(currentClass + "." + currentField, renamedField);
						break;
					case "m":
						if (currentClass == null)
							throw new IllegalArgumentException(FAIL + "could not map method, no class context");
						// [1] = desc
						// [2] = current
						// [3*] = intermediate
						// [4] = renamed
						int[] mtdRenameIndices = subType.getFromXToYOffsets(Context.METHOD, args.length);
						String methodType = args[1];
						String currentMethod = args[mtdRenameIndices[0]];
						String renamedMethod = args[mtdRenameIndices[1]];
						map.put(currentClass + "." + currentMethod + methodType, renamedMethod);
						break;
					default:
						trace("Unknown Tiny-V2 mappings line type: \"{}\" @line {}", type, line);
						break;
				}
			} catch(IndexOutOfBoundsException ex) {
				throw new IllegalArgumentException(FAIL + "failed parsing line " + line, ex);
			}
		}
		return map;
	}

	/**
	 * Subtype for TinyV2 handling.
	 *
	 * @author Matt
	 */
	public enum TinyV2SubType {
		OBF_TO_CLEAN("Obfuscated to named"),
		OBF_TO_INTERMEDIATE("Obfuscated to intermediate"),
		INTERMEDIATE_TO_CLEAN("Intermediate to named"),
		INTERMEDIATE_TO_OBF("Intermediate to obfuscated"),
		CLEAN_TO_INTERMEDIATE("Named to intermediate"),
		CLEAN_TO_OBF("Named to obfuscated");

		private final String display;

		TinyV2SubType(String display) {
			this.display = display;
		}

		@Override
		public String toString() {
			return display;
		}

		/**
		 * @param ctx
		 * 		Mapping context, class, field, or method.
		 * @param columns
		 * 		The number of columns in the row.
		 * 		Used to determine if the input matches the specs
		 * 		<i>(And if not, limit the return value to be inside the range of columns)</i>.
		 *
		 * @return Pair of integers for the before name and after name indices.
		 */
		public int[] getFromXToYOffsets(Context ctx, int columns) {
			int base = ctx == Context.CLASS ? 1 : 2;
			// Get offsets from base for sort of context
			int from = -1;
			int to = -1;
			switch (this) {
				case OBF_TO_INTERMEDIATE:
					from = 0;
					to = 1;
					break;
				case OBF_TO_CLEAN:
					from = 0;
					to = 2;
					break;
				case INTERMEDIATE_TO_CLEAN:
					from = 1;
					to = 2;
					break;
				case INTERMEDIATE_TO_OBF:
					from = 1;
					to = 1;
					break;
				case CLEAN_TO_OBF:
					from = 2;
					to = 0;
					break;
				case CLEAN_TO_INTERMEDIATE:
					from = 1;
					to = 0;
					break;
				default:
					throw new IllegalStateException();
			}
			// Cap indices if no intermediate column exists
			if (!hasIntermediateColumn(ctx, columns)) {
				from = Math.min(1, from);
				to = Math.min(1, to);
			}
			return new int[]{base+from, base+to};
		}

		private boolean hasIntermediateColumn(Context ctx, int columns) {
			switch (ctx){
				case CLASS:
					return columns >= 4;
				case FIELD:
				case METHOD:
					return columns >= 5;
				default:
					throw new IllegalStateException();
			}
		}
	}

	private enum Context {
		CLASS, FIELD, METHOD;
	}
}

```

`src/main/java/me/coley/recaf/metadata/Comments.java`:

```java
package me.coley.recaf.metadata;

import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * Comments metadata handler.
 *
 * @author Matt
 */
public class Comments {
	public static final String TYPE = "Lme/coley/recaf/metadata/InsnComment;";
	public static final String KEY_PREFIX = "At_";
	private final Map<Integer, String> indexToComment = new TreeMap<>();

	/**
	 * Create an empty comments handler.
	 */
	public Comments() {
	}

	/**
	 * Create a comments handler that populates existing entries from the given method.
	 *
	 * @param method
	 * 		Method with comments.
	 */
	public Comments(MethodNode method) {
		parse(method);
	}

	private void parse(MethodNode method) {
		if (method.visibleAnnotations == null) return;
		List<AnnotationNode> invalidAnnos = new ArrayList<>();
		for (AnnotationNode anno : method.visibleAnnotations) {
			if (anno.desc.equals(Comments.TYPE) && anno.values.size() % 2 == 0) {
				for (int i = 0; i < anno.values.size(); i += 2) {
					Object keyInfo = anno.values.get(i);
					Object comment = anno.values.get(i + 1);
					// Skip malformed comments.
					boolean validTypes = keyInfo instanceof String && comment instanceof String;
					if (!validTypes || keyInfo.toString().length() <= KEY_PREFIX.length()) {
						invalidAnnos.add(anno);
						continue;
					}
					String key = ((String)keyInfo).substring(Comments.KEY_PREFIX.length());
					if (key.matches("\\d+"))
						indexToComment.put(Integer.parseInt(key), (String) comment);
				}
			}
		}
		// Prune invalid annos
		method.visibleAnnotations.removeIf(invalidAnnos::contains);
	}

	/**
	 * Adds a comment at the current instruction offset.
	 *
	 * @param index
	 * 		Method instruction index to insert the comment at.
	 * @param comment
	 * 		Comment string to add.
	 */
	public void addComment(int index, String comment) {
		String existing = indexToComment.get(index);
		if (existing != null) {
			comment = existing + "\n" + comment;
		}
		indexToComment.put(index, comment);
	}

	/**
	 * Write comments to the method.
	 *
	 * @param method
	 * 		Method to write to.
	 */
	public void applyTo(MethodNode method) {
		if (method.visibleAnnotations == null)
			method.visibleAnnotations = new ArrayList<>();
		// Remove old comments
		removeComments(method);
		// Add new comments
		indexToComment.forEach((index, comment) -> {
			AnnotationNode commentNode = new AnnotationNode(Comments.TYPE);
			commentNode.visit(Comments.KEY_PREFIX + index, comment);
			method.visibleAnnotations.add(commentNode);
		});
	}

	/**
	 * @param offset
	 * 		Instruction offset.
	 *
	 * @return Comment at offset.
	 */
	public String get(int offset) {
		return indexToComment.get(offset);
	}

	/**
	 * Removes comments from the given method.
	 *
	 * @param method
	 * 		Method that may contain comments.
	 */
	public static void removeComments(MethodNode method) {
		if (method.visibleAnnotations == null)
			return;
		method.visibleAnnotations.removeIf(node -> node.desc.equals(Comments.TYPE));
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/AbstractParser.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.*;

/**
 * Base parser.
 *
 * @param <T>
 * 		Node type to parse.
 *
 * @author Matt
 */
public abstract class AbstractParser<T extends AST> {
	protected final AbstractParser parent;
	private int offset;

	/**
	 * Create parser with no parent context.
	 */
	public AbstractParser() {
		this(null);
	}

	/**
	 * Create parser with parent context.
	 *
	 * @param parent
	 * 		Parent parser.
	 */
	public AbstractParser(AbstractParser parent) {
		this.parent = parent;
	}

	/**
	 * @param lineNo
	 * 		Line number.
	 * @param text
	 * 		Text to complete.
	 *
	 * @return AST node.
	 *
	 * @throws ASTParseException
	 * 		When the line did not follow the expected format.
	 */
	public abstract T visit(int lineNo, String text) throws ASTParseException;

	/**
	 * @param lastParse
	 * 		Previously generated AST, used for hints and look-ups if not {@code null}.
	 * @param text
	 * 		Text to complete.
	 *
	 * @return Suggestions for given text.
	 */
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		return Collections.emptyList();
	}

	/**
	 * Used when there are multiple parsers per line and each's parsing content is not the full
	 * text of the line.
	 *
	 * @return Offset to add to start position of generated AST nodes in
	 * {@link #visit(int, String)}.
	 */
	public int getOffset() {
		return offset;
	}

	/**
	 * @param offset
	 * 		Offset to add to start position of generated AST nodes in {@link #visit(int, String)}.
	 */
	public void setOffset(int offset) {
		this.offset = offset;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/Assembler.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * Common assembler.
 *
 * @param <T>
 * 		Output type.
 *
 * @author Matt
 */
public interface Assembler<T> {
	/**
	 * @param result
	 * 		AST parse result.
	 *
	 * @return Compiled value.
	 *
	 * @throws AssemblerException
	 * 		<ul>
	 * 						<li>When the given AST contains errors</li>
	 * 						<li>When the given AST is missing a definition</li>
	 * 						</ul>
	 */
	T compile(ParseResult<RootAST> result) throws AssemblerException;
}

```

`src/main/java/me/coley/recaf/parse/bytecode/Disassembler.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.metadata.Comments;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.parser.HandleParser;
import me.coley.recaf.util.*;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

import java.util.*;
import java.util.stream.Collectors;

import static org.objectweb.asm.tree.AbstractInsnNode.*;

/**
 * Method instruction disassembler.
 *
 * @author Matt
 */
public class Disassembler {
	private final Map<LabelNode, String> labelToName = new HashMap<>();
	private final List<String> out = new ArrayList<>();
	private final Set<Integer> paramVariables = new HashSet<>();
	private Comments comments;
	private MethodNode method;
	private boolean useIndyAlias = true;
	private boolean doInsertIndyAlias;

	/**
	 * @param method
	 * 		Method to disassemble.
	 *
	 * @return Text of method instructions.
	 */
	public String disassemble(MethodNode method) {
		setup(method);
		visit(method);
		return String.join("\n", out);
	}

	/**
	 * @param field
	 * 		Field to disassemble.
	 *
	 * @return Text of field definition.
	 */
	public String disassemble(FieldNode field) {
		visit(field);
		return String.join("\n", out);
	}


	/**
	 * @param useIndyAlias
	 * 		Flag to determine if lambda handles should be simplified where possible.
	 */
	public void setUseIndyAlias(boolean useIndyAlias) {
		this.useIndyAlias = useIndyAlias;
	}

	private void setup(MethodNode value) {
		this.method = value;
		comments = new Comments(value);
		// Ensure there is a label before the first variable instruction and after the last usage.
		enforceLabelRanges(value);
		// Validate each named variable has the same type.
		splitSameIndexedVariablesOfDiffNames(value);
		// Validate each named variable has the same type.
		splitSameNamedVariablesOfDiffTypes(value);
		// Input validation
		if (value.instructions == null)
			throw new IllegalArgumentException("Method instructions list is null!");
		// Generate initial names for the labels
		int i = 0;
		String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		for(AbstractInsnNode insn : value.instructions.toArray())
			if(insn instanceof LabelNode) {
				LabelNode lbl = (LabelNode) insn;
				labelToName.put(lbl, StringUtil.generateName(alphabet, i++));
			} else if (insn instanceof InvokeDynamicInsnNode) {
				InvokeDynamicInsnNode indy = (InvokeDynamicInsnNode) insn;
				if(useIndyAlias && HandleParser.DEFAULT_HANDLE.equals(indy.bsm))
					doInsertIndyAlias = true;
			}
		// Generate variable names
		if(!AccessFlag.isStatic(value.access))
			paramVariables.add(0);
		// Rename labels for catch ranges
		if (value.tryCatchBlocks == null)
			return;
		i = 1;
		int blocks = value.tryCatchBlocks.size();
		for (TryCatchBlockNode block : value.tryCatchBlocks)
			if (blocks > 1) {
				labelToName.put(block.start, "EX_START_" + i);
				labelToName.put(block.end, "EX_END_" + i);
				labelToName.put(block.handler, "EX_HANDLER_" + i);
				i++;
			} else {
				labelToName.put(block.start, "EX_START");
				labelToName.put(block.end, "EX_END");
				labelToName.put(block.handler, "EX_HANDLER");
			}
	}

	private void visit(MethodNode value) {
		// Visit definition
		MethodDefinitionAST def = new MethodDefinitionAST(0, 0,
				new NameAST(0, 0, value.name),
				new DescAST(0, 0, Type.getMethodType(value.desc).getReturnType().getDescriptor()));
		for (AccessFlag flag : AccessFlag.values())
			if (flag.getTypes().contains(AccessFlag.Type.METHOD) && (value.access & flag.getMask()) == flag.getMask())
				def.getModifiers().add(new DefinitionModifierAST(0, 0, flag.getName().toUpperCase()));
		Type[] argTypes = Type.getMethodType(value.desc).getArgumentTypes();
		int paramVar = AccessFlag.isStatic(value.access) ? 0 : 1;
		for (Type arg : argTypes) {
			String name = firstVarByIndex(paramVar);
			if (name == null)
				name = String.valueOf(paramVar);
			def.addArgument(new DefinitionArgAST(0, 0,
					new DescAST(0,0,arg.getDescriptor()),
					new NameAST(0,0,name)));
			paramVar += arg.getSize();
		}
		out.add(def.print());
		// Visit signature
		if (value.signature != null)
			out.add("SIGNATURE " + value.signature);
		// Visit aliases
		if(doInsertIndyAlias) {
			StringBuilder line = new StringBuilder("ALIAS H_META \"");
			visitHandle(line, HandleParser.DEFAULT_HANDLE, true);
			line.append('"');
			out.add(line.toString());
		}
		// Visit exceptions
		if(value.exceptions != null)
			for(String type : value.exceptions)
				out.add("THROWS " + type);
		// Visit try-catches
		if (value.tryCatchBlocks != null)
			for (TryCatchBlockNode block : value.tryCatchBlocks) {
				String start = labelToName.get(block.start);
				String end = labelToName.get(block.end);
				String handler = labelToName.get(block.handler);
				if (block.type != null)
					out.add(String.format("TRY %s %s CATCH(%s) %s", start, end, block.type, handler));
				else
					out.add(String.format("TRY %s %s CATCH(*) %s", start, end, handler));
			}
		// Visit instructions
		int offset = 0;
		for (AbstractInsnNode insn : value.instructions.toArray()) {
			// Prepend comments if found
			appendComment(offset);
			// Append instruction
			appendLine(insn);
			offset++;
		}
		// Append final comment if found
		appendComment(offset);
	}

	private void visit(FieldNode value) {
		// Visit definition
		FieldDefinitionAST def = new FieldDefinitionAST(0, 0,
				new NameAST(0, 0, value.name),
				new DescAST(0, 0, value.desc));
		for (AccessFlag flag : AccessFlag.values())
			if (flag.getTypes().contains(AccessFlag.Type.FIELD) && (value.access & flag.getMask()) == flag.getMask())
				def.getModifiers().add(new DefinitionModifierAST(0, 0, flag.getName().toUpperCase()));
		out.add(def.print());
		// Visit signature
		if (value.signature != null)
			out.add("SIGNATURE " + value.signature);
		// Visit default-value
		if(value.value != null) {
			StringBuilder line = new StringBuilder("VALUE ");
			Object o = value.value;
			if(o instanceof String) {
				String str = o.toString();
				str = str.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
				line.append('"').append(str).append('"');
			} else if(o instanceof Long)
				line.append(o).append('L');
			else if (o instanceof Double) {
				line.append(o);
				if (!(o.equals(Double.POSITIVE_INFINITY) || o.equals(Double.NEGATIVE_INFINITY)
						|| o.equals(Double.NaN)))
					line.append('D');
			} else if (o instanceof Float) {
				// Float has the same edge case items as double, but we want to denote them with
				// "F" suffix.
				line.append(o).append('F');
			} else
				line.append(o);
			out.add(line.toString());
		}
	}

	private void appendLine(AbstractInsnNode insn) {
		StringBuilder line = new StringBuilder(OpcodeUtil.opcodeToName(insn.getOpcode()));
		switch(insn.getType()) {
			case INSN:
				break;
			case INT_INSN:
				visitIntInsn(line, (IntInsnNode) insn);
				break;
			case VAR_INSN:
				visitVarInsn(line, (VarInsnNode) insn);
				break;
			case TYPE_INSN:
				visitTypeInsn(line, (TypeInsnNode) insn);
				break;
			case FIELD_INSN:
				visitFieldInsn(line, (FieldInsnNode) insn);
				break;
			case METHOD_INSN:
				visitMethodInsn(line, (MethodInsnNode) insn);
				break;
			case JUMP_INSN:
				visitJumpInsn(line, (JumpInsnNode) insn);
				break;
			case LABEL:
				visitLabel(line, (LabelNode) insn);
				break;
			case LDC_INSN:
				visitLdcInsn(line, (LdcInsnNode) insn);
				break;
			case IINC_INSN:
				visitIincInsn(line, (IincInsnNode) insn);
				break;
			case TABLESWITCH_INSN:
				visitTableSwitchInsn(line, (TableSwitchInsnNode) insn);
				break;
			case LOOKUPSWITCH_INSN:
				visitLookupSwitchInsn(line, (LookupSwitchInsnNode) insn);
				break;
			case MULTIANEWARRAY_INSN:
				visitMultiANewArrayInsn(line, (MultiANewArrayInsnNode) insn);
				break;
			case LINE:
				visitLine(line, (LineNumberNode) insn);
				break;
			case INVOKE_DYNAMIC_INSN:
				visitIndyInsn(line, (InvokeDynamicInsnNode) insn);
				break;
			case FRAME:
				// Do nothing
				break;
			default:
				throw new IllegalStateException("Unknown instruction type: " + insn.getType());
		}
		out.add(line.toString());
	}

	private void appendComment(int offset) {
		String prefix = "// ";
		String comment = comments.get(offset);
		if (comment != null)
			out.add(prefix + String.join("\n" + prefix, comment.split("\n")));
	}

	private void visitIntInsn(StringBuilder line, IntInsnNode insn) {
		if (insn.getOpcode() == Opcodes.NEWARRAY) {
			line.append(' ').append(TypeUtil.newArrayArgToType(insn.operand).getDescriptor());
		} else {
			line.append(' ').append(insn.operand);
		}
	}

	private void visitVarInsn(StringBuilder line, VarInsnNode insn) {
		String name = varInsnToName(insn);
		line.append(' ').append(name);
	}

	private void visitTypeInsn(StringBuilder line, TypeInsnNode insn) {
		// TypeInsnNode demands the descriptor be an internal name....
		// Sometimes its not though.
		Type type = insn.desc.contains(";") ?
				Type.getType(insn.desc) : Type.getObjectType(insn.desc);
		String name = EscapeUtil.escape(type.getInternalName());
		line.append(' ').append(name);
	}

	private void visitFieldInsn(StringBuilder line, FieldInsnNode insn) {
		String owner = EscapeUtil.escape(insn.owner);
		String name = EscapeUtil.escape(insn.name);
		String desc = EscapeUtil.escape(insn.desc);
		line.append(' ').append(owner).append('.').append(name).append(' ').append(desc);
	}

	private void visitMethodInsn(StringBuilder line, MethodInsnNode insn) {
		String owner = EscapeUtil.escapeCommon(insn.owner);
		String name = EscapeUtil.escapeCommon(insn.name);
		String desc = EscapeUtil.escapeCommon(insn.desc);
		line.append(' ').append(owner).append('.').append(name).append(desc);
	}

	private void visitJumpInsn(StringBuilder line, JumpInsnNode insn) {
		String name = name(insn.label);
		line.append(' ').append(name);
	}

	private void visitLabel(StringBuilder line, LabelNode insn) {
		// insert modified opcode
		line.delete(0, line.length());
		// append name
		String name = name(insn);
		line.append(name).append(":");
	}

	private void visitLdcInsn(StringBuilder line, LdcInsnNode insn) {
		line.append(' ');
		if(insn.cst instanceof String) {
			String str = insn.cst.toString();
			str = EscapeUtil.escape(str);
			line.append('"').append(str).append('"');
		} else if (insn.cst instanceof Long)
			line.append(insn.cst).append('L');
		else if (insn.cst instanceof Double) {
			Double d = (Double) insn.cst;
			line.append(d);
			if (!(d.equals(Double.POSITIVE_INFINITY) || d.equals(Double.NEGATIVE_INFINITY) || d.equals(Double.NaN)))
				line.append('D');
		}
		else if (insn.cst instanceof Float)
			line.append(insn.cst).append('F');
		else if (insn.cst instanceof Handle)
			visitHandle(line, (Handle) insn.cst, false);
		else
			line.append(insn.cst);
	}

	private void visitIincInsn(StringBuilder line, IincInsnNode insn) {
		String name = varInsnToName(insn);
		line.append(' ').append(name).append(' ').append(insn.incr);
	}

	private void visitTableSwitchInsn(StringBuilder line, TableSwitchInsnNode insn) {
		line.append(" range[").append(insn.min).append(':').append(insn.max).append(']');
		line.append(" labels[");
		for(int i = 0; i < insn.labels.size(); i++) {
			String name = name(insn.labels.get(i));
			line.append(name);
			if(i < insn.labels.size() - 1)
				line.append(", ");
		}
		String name = name(insn.dflt);
		line.append("] default[").append(name).append(']');
	}

	private void visitLookupSwitchInsn(StringBuilder line, LookupSwitchInsnNode insn) {
		line.append(" mapping[");
		for(int i = 0; i < insn.keys.size(); i++) {
			String name = name(insn.labels.get(i));
			line.append(insn.keys.get(i)).append('=').append(name);
			if(i < insn.keys.size() - 1)
				line.append(", ");
		}
		String name = name(insn.dflt);
		line.append("] default[").append(name).append(']');
	}

	private void visitMultiANewArrayInsn(StringBuilder line, MultiANewArrayInsnNode insn) {
		line.append(' ').append(insn.desc).append(' ').append(insn.dims);
	}

	private void visitLine(StringBuilder line, LineNumberNode insn) {
		// insert modified opcode
		line.delete(0, line.length());
		line.append("LINE ");
		// append line info
		String name = name(insn.start);
		line.append(name).append(' ').append(insn.line);
	}

	private void visitIndyInsn(StringBuilder line, InvokeDynamicInsnNode insn) {
		// append nsmr & desc
		String name = EscapeUtil.escape(insn.name);
		String desc = EscapeUtil.escape(insn.desc);
		line.append(' ').append(name).append(' ').append(desc).append(' ');
		// append handle
		visitHandle(line, insn.bsm, false);
		// append args
		line.append(" args[");
		for(int i = 0; i < insn.bsmArgs.length; i++) {
			Object arg = insn.bsmArgs[i];
			if (arg instanceof Integer)
				line.append(arg);
			else if (arg instanceof Float)
				line.append(arg).append('F');
			else if (arg instanceof Long)
				line.append(arg).append('L');
			else if (arg instanceof Double)
				line.append(arg).append('D');
			else if (arg instanceof Type)
				line.append(arg);
			else if (arg instanceof Handle)
				visitHandle(line, (Handle) arg, false);
			else if (arg instanceof String)
				line.append("\"" + EscapeUtil.escape((String)arg) +"\"");
			if(i < insn.bsmArgs.length - 1)
				line.append(", ");
		}
		line.append(']');
	}

	private void visitHandle(StringBuilder line, Handle handle, boolean dontAlias) {
		if(!dontAlias && useIndyAlias && HandleParser.DEFAULT_HANDLE.equals(handle)) {
			line.append("${" + HandleParser.DEFAULT_HANDLE_ALIAS + "}");
			return;
		}
		String owner = EscapeUtil.escape(handle.getOwner());
		String name = EscapeUtil.escape(handle.getName());
		String desc = EscapeUtil.escape(handle.getDesc());
		line.append("handle[");
		line.append(OpcodeUtil.tagToName(handle.getTag()));
		line.append(' ').append(owner);
		line.append('.').append(name);
		if (handle.getTag() >= Opcodes.H_GETFIELD && handle.getTag() <= Opcodes.H_PUTSTATIC)
			line.append(' ');
		line.append(desc);
		line.append(']');
	}

	// ======================================================================= //

	/**
	 * @param insn
	 * 		Instruction to disassemble.
	 *
	 * @return Text of instruction.
	 */
	public static String insn(AbstractInsnNode insn) {
		Disassembler d = new Disassembler();
		// Populate label names if necessary for the given instruction type
		int type = insn.getType();
		boolean dbg = type == LABEL || type == LINE;
		boolean ref = type == JUMP_INSN  || type == LOOKUPSWITCH_INSN || type == TABLESWITCH_INSN;
		if (dbg || ref) {
			int i = 0;
			String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
			AbstractInsnNode tmp = InsnUtil.getFirst(insn);
			while(tmp != null) {
				if(insn instanceof LabelNode) {
					LabelNode lbl = (LabelNode) insn;
					d.labelToName.put(lbl, StringUtil.generateName(alphabet, i++));
				}
				tmp = tmp.getNext();
			}
		}
		// Disassemble the single insn
		d.appendLine(insn);
		return d.out.get(0);
	}

	// ======================================================================= //

	/**
	 * @param insn
	 * 		Variable instruction.
	 *
	 * @return {@code null} if no variable with the index exists. Otherwise, the variable's name.
	 */
	private String varInsnToName(AbstractInsnNode insn) {
		int varIndex = ((insn instanceof VarInsnNode) ?
				((VarInsnNode) insn).var : ((IincInsnNode) insn).var);
		if (method != null && method.localVariables != null) {
			int insnPos = InsnUtil.index(insn);
			List<LocalVariableNode> list =  method.localVariables.stream()
					.filter(v -> varIndex == v.index)
					.collect(Collectors.toList());
			String name = list.stream()
					.filter(v -> insnPos >= InsnUtil.index(v.start) - 1 && insnPos <= InsnUtil.index(v.end) + 1)
					.map(v -> v.name)
					.findFirst().orElse(String.valueOf(varIndex));
			// Override slot-0 for non-static methods to ALWAYS be 'this' just in case
			// an obfuscator has renamed the variable
			if (!AccessFlag.isStatic(method.access) && varIndex == 0)
				name = "this";
			return name;
		}
		return String.valueOf(varIndex);
	}

	/**
	 * @param index
	 * 		Index to search by.
	 *
	 * @return Name of first variable matching the index.
	 */
	private String firstVarByIndex(int index) {
		if (method != null && method.localVariables != null) {
			return method.localVariables.stream()
					.filter(v -> v.index == index)
					.min(Comparator.comparingInt(a -> InsnUtil.index(a.start)))
					.map(v -> v.name)
					.orElse(String.valueOf(index));
		}
		return String.valueOf(index);
	}

	/**
	 * Updates a method so that all variable instructions have a label before and after them.
	 * This allows the assembler to regenerate proper variable ranges.
	 *
	 * @param value
	 * 		Method to update.
	 */
	private static void enforceLabelRanges(MethodNode value) {
		AbstractInsnNode[] insns = value.instructions.toArray();
		// Iterate forwards to validate start ranges
		boolean varFound = false;
		boolean labelFound = false;
		for (int i = 0; i < insns.length; i++) {
			AbstractInsnNode ain = insns[i];
			// Check if we can abandon the search
			if (!varFound && labelFound) {
				break;
			}
			// Insert label if none exist before the variable instruction
			else if (varFound) {
				value.instructions.insert(new LabelNode());
				break;
			}
			// Update found items
			if (ain.getType() == LABEL)
				labelFound = true;
			else if (ain.getType() == VAR_INSN)
				varFound = true;
		}
		// Iterate backwards to validate end ranges
		varFound = false;
		labelFound = false;
		for (int i = insns.length - 1; i >= 0; i--) {
			AbstractInsnNode ain = insns[i];
			// Check if we can abandon the search
			if (!varFound && labelFound) {
				break;
			}
			// Insert label if none exist after the variable instruction
			else if (varFound) {
				value.instructions.add(new LabelNode());
				break;
			}
			// Update found items
			if (ain.getType() == LABEL)
				labelFound = true;
			else if (ain.getType() == VAR_INSN)
				varFound = true;
		}
		// If we have a VERY short method we may have to do an extra check
		if (varFound && !labelFound) {
			value.instructions.add(new LabelNode());
		}
	}

	/**
	 * Renames variables that share the same name but different types.
	 * This is done to prevent type conflicts of variables by the same name in
	 * obfuscated code.
	 * <br>
	 * There are cases where the same-type variables of the same name should
	 * be kept. For example, a method with multiple try-catch blocks and all
	 * exception variables are named <i>"e"</i>.
	 *
	 * @param node
	 * 		Method to update.
	 */
	public static void splitSameNamedVariablesOfDiffTypes(MethodNode node) {
		if (node.localVariables == null)
			return;
		Map<Integer, LocalVariableNode> indexToVar = new HashMap<>();
		Map<Integer, String> indexToName = new HashMap<>();
		Map<String, Integer> nameToIndex = new HashMap<>();
		boolean changed = false;
		for(LocalVariableNode lvn : node.localVariables) {
			int index = lvn.index;
			String name = lvn.name;
			if(indexToName.containsValue(name)) {
				// The variable name is NOT unique.
				// Set both variables names to <NAME + INDEX>
				// Even with 3+ duplicates, this method will give each a unique index-based name.
				int otherIndex = nameToIndex.get(name);
				LocalVariableNode otherLvn = indexToVar.get(otherIndex);
				if (!lvn.desc.equals(otherLvn.desc)) {
					if (index != otherIndex) {
						// Different indices are used
						lvn.name = name + index;
						otherLvn.name = name + otherIndex;
					} else {
						// Same index but other type?
						// Just give it a random name.
						// TODO: Naming instead off of types would be better.
						lvn.name = nextIndexName(name, node);
					}
					changed = true;
				}
				// Update maps
				indexToVar.put(index, lvn);
				indexToName.put(index, lvn.name);
				nameToIndex.put(lvn.name, index);
			} else {
				// The variable name is unique.
				// Update maps
				indexToVar.put(index, lvn);
				indexToName.put(index, name);
				nameToIndex.put(name, index);
			}
		}
		// Logging
		if (changed) {
			Log.warn("Separating variables of same name pointing to different indices: " + node.name + node.desc);
		}
	}

	/**
	 * Reallocates variable indices of variables that share the same index but names.
	 * This is done to prevent type conflicts of variables by the same index in different scopes.
	 * Recaf does not understand variable scope at the moment,
	 * so this is a hack to be removed in the future when it does.
	 *
	 * @param node
	 * 		Method to update.
	 *
	 * @see VariableGenerator Place to add scoped variable support later.
	 */
	public static void splitSameIndexedVariablesOfDiffNames(MethodNode node) {
		if (node.localVariables == null)
			return;
		Map<Integer, String> indexToName = new HashMap<>();
		boolean changed = false;
		int nextFreeVar = computeMavVar(AccessFlag.isStatic(node.access), node.localVariables);
		for(LocalVariableNode lvn : node.localVariables) {
			int index = lvn.index;
			String name = lvn.name;
			if(!name.equals(indexToName.getOrDefault(index, name))) {
				// Update the variables index and bump the next free index
				index = lvn.index = nextFreeVar;
				nextFreeVar += Type.getType(lvn.desc).getSize();
				indexToName.put(index, lvn.name);
				changed = true;
			} else {
				indexToName.put(index, name);
			}
		}
		// Logging
		if (changed) {
			Log.warn("Separating variables of same index reusing the same name: " + node.name + node.desc);
		}
	}

	/**
	 * @param name
	 * 		Base name.
	 * @param node
	 * 		Method with variable names to compare to.
	 *
	 * @return Base name + a number, yields first non-taken name.
	 */
	private static String nextIndexName(String name, MethodNode node) {
		int i = 1;
		String[] tmp = {name + i};
		while(node.localVariables.stream().anyMatch(lvn -> tmp[0].equals(lvn.name))) {
			i++;
			tmp[0] = name + i;
		}
		return tmp[0];
	}

	private static int computeMavVar(boolean isStatic, List<LocalVariableNode> vars) {
		int max = isStatic ? 0 : 1;
		for (LocalVariableNode lvn : vars) {
			if (lvn.index >= max) {
				try {
					max = lvn.index + Type.getType(lvn.desc).getSize();
				} catch (IllegalArgumentException ex) {
					// If there is garbage in the descriptor ASM's type parse will fail.
					// We don't know if its supposed to be a wide type (double/long) so we
					// will just increment the max-value by 2 to be safe.
					max = lvn.index + 2;
				}
			}
		}
		return max;
	}


	private String name(LabelNode label) {
		return labelToName.getOrDefault(label, "?");
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/FieldAssembler.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.FieldNode;

/**
 * Assembler for field.
 *
 * @author Matt
 */
public class FieldAssembler implements Assembler<FieldNode> {
	@Override
	public FieldNode compile(ParseResult<RootAST> result) throws AssemblerException {
		if(!result.isSuccess()) {
			ASTParseException cause = result.getProblems().get(0);
			AssemblerException ex  = new AssemblerException(cause, "AST must not contain errors", cause.getLine());
			ex.addSubExceptions(result.getProblems());
			throw ex;
		}
		RootAST root = result.getRoot();
		// Get definition
		FieldDefinitionAST definition = root.search(FieldDefinitionAST.class).stream().findFirst().orElse(null);
		if (definition == null)
			throw new AssemblerException("AST must have definition statement");
		int access = toAccess(definition);
		String name = definition.getName().getName();
		String desc = definition.getType().getDesc();
		SignatureAST signatureAST = root.search(SignatureAST.class).stream().findFirst().orElse(null);
		DefaultValueAST defaultValueAST = root.search(DefaultValueAST.class).stream().findFirst().orElse(null);
		String signature = (signatureAST == null) ? null : signatureAST.getSignature();
		Object value = (defaultValueAST == null) ? null : defaultValueAST.toValue();
		return new FieldNode(access, name, desc, signature, value);
	}

	/**
	 * @param definition
	 * 		AST of definition. Contains modifier AST children.
	 *
	 * @return Combined value of modifier children.
	 */
	private int toAccess(FieldDefinitionAST definition) {
		return definition.search(DefinitionModifierAST.class).stream()
				.mapToInt(DefinitionModifierAST::getValue)
				.reduce(0, (a, b) -> a | b);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/MethodAnalyzer.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.analysis.SimAnalyzer;
import me.coley.analysis.SimInterpreter;
import me.coley.analysis.TypeChecker;
import me.coley.analysis.TypeResolver;
import me.coley.analysis.util.TypeUtil;
import me.coley.recaf.Recaf;
import me.coley.recaf.graph.inheritance.HierarchyGraph;
import org.objectweb.asm.Type;

/**
 * {@link SimAnalyzer} extension that implements a {@link #createTypeChecker() type checker}
 * using Recaf's workspaces.
 */
public class MethodAnalyzer extends SimAnalyzer {

	/**
	 * Create method analyzer.
	 *
	 * @param interpreter
	 * 		Interpreter to use.
	 */
	public MethodAnalyzer(SimInterpreter interpreter) {
		super(interpreter);
	}

	@Override
	protected TypeChecker createTypeChecker() {
		return (parent, child) -> getGraph()
				.getAllParents(child.getInternalName())
					.anyMatch(n -> n != null && n.equals(parent.getInternalName()));
	}

	@Override
	protected TypeResolver createTypeResolver() {
		return new TypeResolver() {
			@Override
			public Type common(Type type1, Type type2) {
				String common = getGraph().getCommon(type1.getInternalName(), type2.getInternalName());
				if (common != null)
					return Type.getObjectType(common);
				return TypeUtil.OBJECT_TYPE;
			}

			@Override
			public Type commonException(Type type1, Type type2) {
				String common = getGraph().getCommon(type1.getInternalName(), type2.getInternalName());
				if (common != null)
					return Type.getObjectType(common);
				return TypeUtil.EXCEPTION_TYPE;
			}
		};
	}

	private static HierarchyGraph getGraph() {
		return Recaf.getCurrentWorkspace().getHierarchyGraph();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/MethodAssembler.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.config.ConfAssembler;
import me.coley.analysis.value.AbstractValue;
import me.coley.recaf.control.Controller;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.parse.bytecode.exception.VerifierException;
import me.coley.recaf.util.AccessFlag;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.Frame;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Bytecode assembler for methods.
 *
 * @author Matt
 */
public class MethodAssembler implements Assembler<MethodNode> {
	private final String declaringType;
	private final ConfAssembler config;
	private final Controller controller;
	private Collection<LocalVariableNode> defaultVariables = Collections.emptySet();
	private MethodNode lastCompile;
	private MethodVerifier lastVerifier;
	private MethodCompilation compilation;

	/**
	 * @param declaringType
	 * 		Internal name of class declaring the method to be assembled.
	 * @param controller
	 * 		Controller to pull assembler config from.
	 */
	public MethodAssembler(String declaringType, Controller controller) {
		this.declaringType = declaringType;
		this.controller = controller;
		this.config = controller.config().assembler();
	}

	@Override
	public MethodNode compile(ParseResult<RootAST> result) throws AssemblerException {
		if(!result.isSuccess()) {
			ASTParseException cause = result.getProblems().get(0);
			AssemblerException ex  = new AssemblerException(cause, "AST must not contain errors", cause.getLine());
			ex.addSubExceptions(result.getProblems());
			throw ex;
		}
		RootAST root = result.getRoot();
		// Get definition
		MethodDefinitionAST definition = root.search(MethodDefinitionAST.class).stream().findFirst().orElse(null);
		if (definition == null)
			throw new AssemblerException("AST must have definition statement");
		int access = definition.getModifierMask();
		String name = definition.getName().getName();
		String desc = definition.getDescriptor();
		String[] exceptions = toExceptions(root);
		SignatureAST signatureAST = root.search(SignatureAST.class).stream().findFirst().orElse(null);
		String signature = (signatureAST == null) ? null : signatureAST.getSignature();
		MethodNode node = new MethodNode(access, name, desc, signature, exceptions);
		// Check if method is abstract, do no further handling
		if(AccessFlag.isAbstract(access))
			return node;
		List<LocalVariableNode> priorVars = lastCompile != null ? lastCompile.localVariables : null;
		if (priorVars == null)
			priorVars = Collections.emptyList();
		MethodCompilation compilation = this.compilation =
				new MethodCompilation(result, definition, node, declaringType, controller, priorVars);
		// Create label mappings
		root.search(LabelAST.class).forEach(lbl -> {
			LabelNode generated = new LabelNode();
			compilation.assignLabel(generated, lbl);
		});
		// Parse try-catches
		for(TryCatchAST tc : root.search(TryCatchAST.class)) {
			LabelNode start = compilation.getLabel(tc.getLblStart().getName());
			if(start == null)
				throw new AssemblerException("No label associated with try-catch start: " +
						tc.getLblStart().getName(), tc.getLine());
			LabelNode end = compilation.getLabel(tc.getLblEnd().getName());
			if(end == null)
				throw new AssemblerException("No label associated with try-catch end: " +
						tc.getLblEnd().getName(), tc.getLine());
			LabelNode handler = compilation.getLabel(tc.getLblHandler().getName());
			if(handler == null)
				throw new AssemblerException("No label associated with try-catch handler: " +
						tc.getLblHandler().getName(), tc.getLine());
			String type = tc.getType().getType();
			node.tryCatchBlocks.add(new TryCatchBlockNode(start, end, handler, type));
		}
		// Parse variable name indices
		VariableNameCache variableNames = new VariableNameCache(AccessFlag.isStatic(access), declaringType);
		if (defaultVariables != null)
			variableNames.populateDefaults(defaultVariables);
		variableNames.visit(root);
		compilation.setVariableNames(variableNames);
		// Parse instructions
		node.instructions = new InsnList();
		for(AST ast : root.getChildren()) {
			if (ast instanceof Compilable) {
				((Compilable) ast).compile(compilation);
			}
		}
		// Set stack size (dummy) and max local count.
		node.maxStack = 0xFF;
		node.maxLocals = variableNames.getMax();
		// Verify code is valid & store analyzed stack data.
		// Use the saved data to fill in missing variable types.
		if (config.verify)
			lastVerifier = verify(node);
		if (config.variables) {
			// Compute variable information
			VariableGenerator variables = new VariableGenerator(variableNames, compilation, node);
			variables.computeVariables(lastVerifier);
			if (variables.getVariables() != null)
				node.localVariables.addAll(variables.getVariables());
		}
		// Call complete to notify we are done
		compilation.onCompletion();
		return (lastCompile = node);
	}

	/**
	 * Verify the generated method.
	 *
	 * @param generated
	 * 		Method generated by this assembler.
	 *
	 * @return Method verifier instance that contains analyzed frames of the method.
	 *
	 * @throws VerifierException
	 * 		Wrapped verification exception.
	 */
	private MethodVerifier verify(MethodNode generated) throws VerifierException {
		MethodVerifier verifier = new MethodVerifier(this, declaringType);
		verifier.verify(generated);
		return verifier;
	}

	/**
	 * @param defaultVariables
	 * 		Map of existing variables to use as a baseline.
	 */
	public void setDefaultVariables(Collection<LocalVariableNode> defaultVariables) {
		this.defaultVariables = defaultVariables;
	}

	/**
	 * @return Analyzed frames. Will be {@code null} if analysis failed.
	 */
	public Frame<AbstractValue>[] getFrames() {
		if (lastVerifier == null)
			return null;
		return lastVerifier.getFrames();
	}

	/**
	 * @param insn
	 * 		Generated instruction.
	 *
	 * @return Line instruction was generated from.
	 */
	public int getLine(AbstractInsnNode insn) {
		MethodCompilation compilation = this.compilation;
		if (compilation == null)
			return -1;
		return compilation.getLine(insn);
	}

	/**
	 * @param line
	 * 		Line number.
	 *
	 * @return Instruction at line.
	 */
	public AbstractInsnNode getInsn(int line) {
		MethodCompilation compilation = this.compilation;
		if (compilation == null)
			return null;
		return compilation.getInsn(line);
	}

	/**
	 * @return Last compiled method.
	 */
	public MethodNode getLastCompile() {
		return lastCompile;
	}

	/**
	 * @return Declaring type of method.
	 */
	public String getDeclaringType() {
		return declaringType;
	}

	/**
	 * @return compilation context.
	 */
	public MethodCompilation getCompilation() {
		return compilation;
	}

	/**
	 * @param root
	 * 		AST of method.
	 *
	 * @return All thrown types.
	 */
	private static String[] toExceptions(RootAST root) {
		return root.search(ThrowsAST.class).stream()
				.map(ast -> ast.getType().getType())
				.toArray(String[]::new);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/MethodCompilation.java`:

```java
package me.coley.recaf.parse.bytecode;

import javassist.ClassPool;
import javassist.CtBehavior;
import javassist.CtClass;
import me.coley.recaf.compiler.JavassistASMTranslator;
import me.coley.recaf.compiler.JavassistCompilationResult;
import me.coley.recaf.compiler.JavassistCompiler;
import me.coley.recaf.control.Controller;
import me.coley.recaf.metadata.Comments;
import me.coley.recaf.parse.bytecode.ast.AST;
import me.coley.recaf.parse.bytecode.ast.LabelAST;
import me.coley.recaf.parse.bytecode.ast.MethodDefinitionAST;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.util.TypeUtil;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.*;

/**
 * AST compilation context.
 *
 * @author xxDark
 */
public final class MethodCompilation {
    private final ParseResult<RootAST> ast;
    private final MethodDefinitionAST methodDefinition;
    private final MethodNode node;
    private final String declaringType;
    private final Controller controller;
	private final List<LocalVariableNode> priorVars;
	private final Comments comments = new Comments();
    private final Map<String, LabelNode> nameToLabel = new LinkedHashMap<>();
    private final Map<LabelNode, LabelAST> labelToAst = new HashMap<>();
    private final Map<AbstractInsnNode, AST> insnToAst = new HashMap<>();
    private final Map<Integer, AbstractInsnNode> lineToInsn = new HashMap<>();
	private VariableNameCache variableNames;

	/**
	 * @param ast
	 * 		Root AST.
	 * @param methodDefinition
	 * 		Definition of the method to compile.
	 * @param node
	 * 		ASM representation of the method.
	 * @param declaringType
	 * 		The type declaring the method.
	 * @param controller
	 * 		Controller to pull references from.
	 * @param priorVars
	 * 		Prior variable information.
	 */
	public MethodCompilation(ParseResult<RootAST> ast, MethodDefinitionAST methodDefinition,
							 MethodNode node, String declaringType, Controller controller,
							 List<LocalVariableNode> priorVars) {
		this.ast = ast;
		this.methodDefinition = methodDefinition;
		this.node = node;
		this.declaringType = declaringType;
		this.controller = controller;
		this.priorVars = priorVars;
	}

    /**
     * @return  root AST parse result.
     */
    public ParseResult<RootAST> getAst() {
        return ast;
    }

    /**
     * @return method definition.
     */
    public MethodDefinitionAST getMethodDefinition() {
        return methodDefinition;
    }

    /**
     * @return ASM representation of the method.
     */
    public MethodNode getNode() {
        return node;
    }

    /**
     * @param name
     *      Name of the label.
     *
     * @return label by it's name. May be {@code null}.
     */
    public LabelNode getLabel(String name) {
        return nameToLabel.get(name);
    }

    /**
     * @param node
     *      Label node.
     *
     * @return label's AST. May be {@code null}.
     */
    public LabelAST getLabelAst(LabelNode node) {
        return labelToAst.get(node);
    }

    /**
     * @return a map of name > label layout.
     */
    public Map<String, LabelNode> getNameToLabel() {
        return Collections.unmodifiableMap(nameToLabel);
    }

    /**
     * @return a map of label > AST layout.
     */
    public Map<LabelNode, LabelAST> getLabelToAst() {
        return Collections.unmodifiableMap(labelToAst);
    }

    /**
     * Adds and register instruction to specific AST.
     *
     * @param insn
     *      Instruction to assign.
     * @param ast
     *      Instruction's AST.
     *
     * @see MethodCompilation#assignInstruction(AbstractInsnNode, AST)
     */
    public void addInstruction(AbstractInsnNode insn, AST ast) {
        node.instructions.add(insn);
        assignInstruction(insn, ast);
    }

    /**
     * Adds a comment at the current instruction offset.
     *
     * @param comment
     * 		Comment string to add.
     */
    public void addComment(String comment) {
        int index = node.instructions.size();
		comments.addComment(index, comment);
	}

	/**
	 * Compiles an expression and inserts the generated code at the current instruction offset.
	 *
	 * @param expression
	 * 		Expression to compile.
	 * @param ast
	 * 		Associated AST.
	 *
	 * @throws AssemblerException
	 * 		When the expression cannot be compiled.
	 */
	public void addExpression(String expression, AST ast) throws AssemblerException {
		// TODO: Since instructions and AST have a one to one mapping we may want to make a map of lines
		//       to expressions if something goes wrong in the code generated by the expression.
		try {
			InputStream stream = new ByteArrayInputStream(controller.getWorkspace().getRawClass(declaringType));
			CtClass declaring = ClassPool.getDefault().makeClass(stream);
			CtBehavior containerMethod;
			if (node.name.equals("<init>")) {
				containerMethod = declaring.getConstructor(node.desc);
			} else {
				containerMethod = declaring.getMethod(node.name, node.desc);
			}
			// Compile with Javassist
			JavassistCompilationResult result =
					JavassistCompiler.compileExpression(declaring, containerMethod, expression,
							priorVars, variableNames);
			// Translate to ASM
			JavassistASMTranslator translator = new JavassistASMTranslator();
			translator.visit(declaring, result.getBytecode().toCodeAttribute());
			node.instructions.add(translator.getInstructions());
			// Add variables
			Object[] entries = nameToLabel.keySet().toArray();
			result.getSymbols().forEach((name, dec) -> {
				String desc = dec.getClassName();
				if (TypeUtil.isPrimitiveClassName(desc))
					desc = TypeUtil.classToPrimitive(desc);
				int index = dec.getLocalVar();
				LabelNode start = nameToLabel.get(String.valueOf(entries[0]));
				LabelNode end = nameToLabel.get(String.valueOf(entries[nameToLabel.size() - 1]));
				node.localVariables.add(new LocalVariableNode(name, desc, null, start, end, index));
			});
		} catch (Exception ex) {
			String msg = ex.getMessage();
			if (msg == null)
				msg = "Unknown error with expression compilation";
			throw new AssemblerException(ex, msg, ast.getLine());
		}
	}

	/**
	 * Assigns instruction to specific AST.
	 * Also sets the line to specific instruction.
	 *
	 * @param insn
	 * 		Instruction to assign.
	 * @param ast
	 * 		Instruction's AST.
	 */
	public void assignInstruction(AbstractInsnNode insn, AST ast) {
		insnToAst.put(insn, ast);
		lineToInsn.put(ast.getLine(), insn);
	}

    /**
     * Assigns label to specific AST.
     *
     * @param label
     *      Instruction to assign.
     * @param ast
     *      Label's AST.
     */
    public void assignLabel(LabelNode label, LabelAST ast) {
        nameToLabel.put(ast.getName().getName(), label);
        labelToAst.put(label, ast);
    }

    /**
     * @param node
     *      Instruction to get line from.
     *
     * @return line of the instruction. May return {@code -1} if AST is missing.
     */
    public int getLine(AbstractInsnNode node) {
        AST ast = insnToAst.get(node);
        return ast == null ? -1 : ast.getLine();
    }

    /**
     * @param line
     *      Line to get instruction from.
     * @return instruction by it's line. May be {@code null}.
     */
    public AbstractInsnNode getInsn(int line) {
        return lineToInsn.get(line);
    }

    /**
     * @return Name cache of variables for the method.
     */
    public VariableNameCache getVariableNameCache() {
        return variableNames;
    }

    // Internal methods
    void setVariableNames(VariableNameCache variableNames) {
        this.variableNames = variableNames;
    }

    void onCompletion() {
        comments.applyTo(node);
    }
}

```

`src/main/java/me/coley/recaf/parse/bytecode/MethodVerifier.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.analysis.SimInterpreter;
import me.coley.analysis.value.AbstractValue;
import me.coley.recaf.parse.bytecode.exception.VerifierException;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.*;

/**
 * Basic method analyzer.
 *
 * @author Matt
 */
class MethodVerifier extends MethodAnalyzer {
	private final String currentType;
	private final MethodAssembler assembler;

	/**
	 * Create the verifier.
	 *
	 * @param assembler
	 * 		Assembler responsible assembling the method.
	 * @param currentType
	 * 		Declaring type of method to be analyzed.
	 */
	MethodVerifier(MethodAssembler assembler, String currentType) {
		super(new SimInterpreter());
		this.currentType = currentType;
		this.assembler = assembler;
		this.setSkipDeadCodeBlocks(false);
	}

	Frame<AbstractValue>[] verify(MethodNode method) throws VerifierException {
		try {
			return analyze(currentType, method);
		} catch(AnalyzerException ex) {
			// Thrown on verify failure.
			int line = assembler.getLine(ex.node);
			if (line == -1) {
				// This is an ugly hack, but sometimes ASM does not include "ex.node" even when the
				// damn insn index is known, meaning it TOTALLY can provide it....
				String errMessage = ex.getMessage();
				if (errMessage != null) {
					int msgIndex = errMessage.indexOf("Error at instruction ");
					if (msgIndex > 0) {
						msgIndex += "Error at instruction ".length();
						String numStr = errMessage.substring(msgIndex, errMessage.indexOf(':', msgIndex));
						if (numStr.matches("\\d+")) {
							int insnIndex = Integer.parseInt(numStr);
							line = assembler.getLine(method.instructions.get(insnIndex));
						}
					}
				}
			}
			throw new VerifierException(ex,
					"Verification failed on line: " + line + "\n" + ex.getMessage(), line);
		} catch(Exception ex) {
			// IndexOutOfBoundsException: When local variables are messed up
			// Exception: ?
			throw new VerifierException(ex, "Verifier crashed: (" + ex.getClass().getSimpleName() + ") "
					+ ex.getMessage(), -1);
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/Parse.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.parser.*;
import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.AbstractInsnNode;

import java.util.*;
import java.util.function.Supplier;

/**
 * AST Parser utility.
 *
 * @author Matt
 */
public class Parse {
	private static final Map<Integer, Supplier<AbstractParser>> insnTypeToParser = new HashMap<>();

	static {
		Parse.insnTypeToParser.put(AbstractInsnNode.LINE, LineInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.INSN, InsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.INT_INSN, IntInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.VAR_INSN, VarInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.TYPE_INSN, TypeInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.IINC_INSN, IincInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.MULTIANEWARRAY_INSN, MultiArrayParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.FIELD_INSN, FieldInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.METHOD_INSN, MethodInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.LDC_INSN, LdcInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.JUMP_INSN, JumpInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.TABLESWITCH_INSN, TableSwitchInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.LOOKUPSWITCH_INSN, LookupSwitchInsnParser::new);
		Parse.insnTypeToParser.put(AbstractInsnNode.INVOKE_DYNAMIC_INSN, InvokeDynamicParser::new);
	}

	/**
	 * @param text
	 * 		Text to visit.
	 *
	 * @return Parse result wrapper of generated AST.
	 */
	public static ParseResult<RootAST> parse(String text) {
		List<ASTParseException> problems = new ArrayList<>();
		RootAST root = new RootAST();
		int lineNo = 0;
		String[] lines = text.split("[\n\r]");
		// Collect aliases
		List<AliasAST> aliases = new ArrayList<>();
		for(String line : lines) {
			lineNo++;
			// Skip empty lines
			if(line.trim().isEmpty())
				continue;
			// Check for alias
			String token = line.trim().split("\\s")[0].toUpperCase();
			try {
				if (token.equals("ALIAS")) {
					// Why? Because we want to support aliases-in-aliases when they
					// are defined in order.
					String lineCopy = line;
					for (AliasAST alias : aliases)
						lineCopy = lineCopy.replace("${" + alias.getName().getName() + "}",
								alias.getValue().getValue());
					// Parse alias
					aliases.add((AliasAST) getParser(lineNo, token).visit(lineNo, lineCopy));
				}
			} catch(ClassCastException | ASTParseException ex) {
				/* ignored, we will collect the error on the second pass */
			}
		}
		// Parse again
		lineNo = 0;
		for(String line : lines) {
			lineNo++;
			// Skip empty lines
			String trim = line.trim();
			if(trim.isEmpty())
				continue;
			// Determine parse action from starting token
			String token = trim.split("\\s")[0].toUpperCase();
			try {
				AbstractParser parser = getParser(lineNo, token);
				if(parser == null)
					throw new ASTParseException(lineNo, "Unknown identifier: " + token);
				// Apply aliases
				String lineCopy = line;
				for (AliasAST alias : aliases)
					lineCopy = lineCopy.replace("${" + alias.getName().getName() + "}",
							alias.getValue().getValue());
				// Parse and add to root
				AST ast = parser.visit(lineNo, lineCopy);
				root.addChild(ast);
			} catch(ASTParseException ex) {
				problems.add(ex);
			}
		}
		return new ParseResult<>(root, problems);
	}

	/**
	 * @param lineNo
	 * 		Line the token appears on.
	 * @param token
	 * 		First token on line.
	 *
	 * @return Parser associated with the token.
	 *
	 * @throws ASTParseException
	 * 		When the token is not valid.
	 */
	public static AbstractParser<?> getParser(int lineNo, String token) throws ASTParseException {
		if (token.startsWith("//"))
			return new CommentParser();
		if(token.endsWith(":"))
			return new LabelParser();
		if (token.equals("DEFINE"))
			return new DefinitionParser();
		if (token.equals("VALUE"))
			return new DefaultValueParser();
		if(token.equals("THROWS"))
			return new ThrowsParser();
		if(token.equals("TRY"))
			return new TryCatchParser();
		if(token.equals("ALIAS"))
			return new AliasDeclarationParser();
		if(token.equals("SIGNATURE"))
			return new SignatureParser();
		if(token.equals("EXPR"))
			return new ExpressionParser();
		// Get opcode from token (opcode?) then get the opcode's group
		// Lookup group's parser
		try {
			int opcode = OpcodeUtil.nameToOpcode(token);
			int type = OpcodeUtil.opcodeToType(opcode);
			return getInsnParser(type);
		} catch(NullPointerException ex) {
			// Thrown when the opcode name isn't a real opcode
			throw new ASTParseException(lineNo, "Not a real opcode: " + token);
		}
	}

	/**
	 * @param type
	 * 		Instruction type, see {@link AbstractInsnNode#getType()}.
	 *
	 * @return Parser for type.
	 */
	public static AbstractParser<?> getInsnParser(int type) {
		Supplier<AbstractParser> supplier = insnTypeToParser.get(type);
		if(supplier == null)
			return null;
		return supplier.get();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ParseResult.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.AST;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.List;

/**
 * AST parse result.
 *
 * @param <T>
 * 		Type of root node AST.
 */
public class ParseResult<T extends AST> {
	private final List<ASTParseException> problems;
	private final T root;

	/**
	 * @param root
	 * 		Root node of AST.
	 * @param problems
	 * 		Parse problems.
	 */
	public ParseResult(T root, List<ASTParseException> problems) {
		this.root = root;
		this.problems = problems;
	}

	/**
	 * @return {@code true} if no problems found when building the AST.
	 */
	public boolean isSuccess() {
		return problems.isEmpty();
	}

	/**
	 * @return Parse problems.
	 */
	public List<ASTParseException> getProblems() {
		return problems;
	}

	/**
	 * @return Parsed AST. May be incomplete if there are {@link #getProblems() problems}.
	 */
	public T getRoot() {
		return root;
	}

}

```

`src/main/java/me/coley/recaf/parse/bytecode/VariableGenerator.java`:

```java
package me.coley.recaf.parse.bytecode;

import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import me.coley.recaf.parse.bytecode.ast.DefinitionArgAST;
import me.coley.recaf.parse.bytecode.ast.VariableReference;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.util.AccessFlag;
import me.coley.recaf.util.TypeUtil;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

import java.util.*;

import static org.objectweb.asm.Opcodes.*;

/**
 * Variable analysis. Used to generate {@link #getVariables() variable nodes}.
 *
 * @author Matt
 */
public class VariableGenerator {
	private final VariableNameCache nameCache;
	private final MethodCompilation compilation;
	private final MethodNode node;
	private final List<LocalVariableNode> variableNodes = new ArrayList<>();
	private final int minimumVarIndex;

	VariableGenerator(VariableNameCache nameCache, MethodCompilation compilation, MethodNode node) {
		this.nameCache = nameCache;
		this.compilation = compilation;
		this.node = node;
		minimumVarIndex = computeArgUsedIndices();
	}

	private int computeArgUsedIndices() {
		Type methodType = Type.getMethodType(node.desc);
		int index = AccessFlag.isStatic(node.access) ? 0 : 1;
		int lastArgSize = 0;
		for (Type argType : methodType.getArgumentTypes()) {
			lastArgSize = argType.getSize();
			index += lastArgSize;
		}
		return index;
	}

	/**
	 * Visit the method with verifier information.
	 *
	 * @param verifier
	 * 		Verifier with analysis data. May be {@code null}.
	 */
	void computeVariables(MethodVerifier verifier) throws AssemblerException {
		// Compute the variable indices to their assigned types
		Multimap<Integer, Integer> indexToSort = MultimapBuilder.hashKeys().hashSetValues().build();
		Multimap<Integer, String> indexToName = MultimapBuilder.hashKeys().hashSetValues().build();
		for (VariableReference reference : compilation.getAst().getRoot().search(VariableReference.class)) {
			int index = reference.getVariableIndex(nameCache);
			int sort = reference.getVariableSort();
			String name = reference.getVariableName().getName();
			indexToSort.put(index, sort);
			// Only add variable refs that are not numeric
			if (!name.matches("\\d+"))
				indexToName.put(index, name);
		}
		// Compute the method argument variables first
		for (DefinitionArgAST reference : compilation.getAst().getRoot().search(DefinitionArgAST.class)) {
			int index = reference.getVariableIndex(nameCache);
			String name = reference.getVariableName().getName();
			// Only add variable refs that are not numeric
			if (!name.matches("\\d+"))
				computeArgument(index, name, reference.getDesc().getDesc());
		}
		// If a variable index only has one type, this is very easy.
		// Otherwise, if it has multiple types we must consider scope...
		for (int index : indexToSort.keySet()) {
			// Skip over variables already declared by arguments.
			// It is illegal to re-assign variables to argument-occupied indices.
			if (index < minimumVarIndex)
				continue;
			Collection<Integer> sorts = indexToSort.get(index);
			Collection<String> names = indexToName.get(index);
			// TODO: Support variable index reuse with same name via scope analysis
			if (names.size() > 1)
				throw new AssemblerException(
						"Named variables sharing the same index is not yet supported in Recaf's assembler\n" +
						"The disassembler should have de-duplicated the indices. Please open a bug report.");
			if (sorts.size() == 1) {
				// TODO: Don't pass in the name like this.
				//       See above note.
				if (!names.isEmpty())
					computeSimple(index, names.iterator().next());
			} else if (verifier != null) {
				computeScoped(index, verifier);
			}
		}
	}

	/**
	 * Simple entire-range scoped variable.
	 *
	 * @param index
	 * 		Arg variable index.
	 * @param name
	 * 		Arg name.
	 * @param desc
	 * 		Arg type.
	 */
	private void computeArgument(int index, String name, String desc) {
		LabelNode first = null;
		LabelNode last = null;
		for (AbstractInsnNode insn : node.instructions) {
			if (insn instanceof LabelNode) {
				LabelNode lbl = (LabelNode) insn;
				if (first == null) {
					first = lbl;
				} else {
					last = lbl;
				}
			}
		}
		addVariable(index, name, Type.getType(desc), first, last);
	}

	/**
	 * Simple min-max range check.
	 *
	 * @param index
	 * 		Variable to compute.
	 * @param name
	 * 		Variable name.
	 *
	 * @throws AssemblerException
	 * 		When name lookup fails.
	 */
	private void computeSimple(int index, String name) throws AssemblerException {
		boolean foundUsage = false;
		LabelNode first = null;
		LabelNode last = null;
		Type type = null;
		for (AbstractInsnNode insn : node.instructions) {
			// If variable usage, record that we saw it and the implied type. Invalidate the last label.
			// If label usage, record as first if not seen variable yet. Otherwise set last.
			if (insn instanceof VarInsnNode) {
				VarInsnNode vin = (VarInsnNode) insn;
				if (vin.var == index) {
					type = getType(vin.getOpcode());
					foundUsage = true;
					last = null;
				}
			} else if (insn instanceof IincInsnNode) {
				IincInsnNode iinc = (IincInsnNode) insn;
				if (iinc.var == index) {
					type = Type.INT_TYPE;
					foundUsage = true;
					last = null;
				}
			} else if (insn instanceof LabelNode) {
				LabelNode lbl = (LabelNode) insn;
				if (!foundUsage) {
					first = lbl;
				} else {
					last = lbl;
				}
			}
		}
		// Validate
		if (type == null)
			throw new AssemblerException("Could not determine type from variable: " + name);
		if (first == null)
			throw new AssemblerException("Could not determine end of range for variable: " + name);
		// Add variable
		addVariable(index, name, type, first, last);
	}

	private void computeScoped(int index, MethodVerifier verifier) throws AssemblerException {
		// TODO: Make scoped variable
	}

	/**
	 * Register variable.
	 *
	 * @param index
	 * 		Var index.
	 * @param name
	 * 		Var name.
	 * @param type
	 * 		Var type.
	 * @param start
	 * 		Starting label.
	 * @param end
	 * 		Ending label.
	 */
	private void addVariable(int index, String name, Type type, LabelNode start, LabelNode end) {
		variableNodes.add(new LocalVariableNode(name, type.getDescriptor(), null, start, end, index));
	}

	/**
	 * @return {@code null} when no variables used. A list of generated variables when they are declared.
	 */
	public List<LocalVariableNode> getVariables() {
		if (variableNodes.isEmpty())
			return null;
		return variableNodes;
	}

	/**
	 * @param opcode
	 * 		Var opcode.
	 *
	 * @return Type derived from the opcode.
	 *
	 * @throws AssemblerException
	 * 		When the opcode is not supported.
	 */
	private static Type getType(int opcode) throws AssemblerException {
		switch (opcode) {
			case ALOAD:
			case ASTORE:
				return TypeUtil.OBJECT_TYPE;
			case IINC:
			case ILOAD:
			case ISTORE:
				return Type.INT_TYPE;
			case FLOAD:
			case FSTORE:
				return Type.FLOAT_TYPE;
			case DLOAD:
			case DSTORE:
				return Type.DOUBLE_TYPE;
			case LLOAD:
			case LSTORE:
				return Type.LONG_TYPE;
			default:
				throw new AssemblerException("Unsupported opcode for variable reference: " + opcode);
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/VariableNameCache.java`:

```java
package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.DefinitionArgAST;
import me.coley.recaf.parse.bytecode.ast.LabelAST;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.ast.VariableReference;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.util.TypeUtil;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.LocalVariableNode;

import java.util.*;

/**
 * Variable name/index handling.
 *
 * @author Matt
 */
public class VariableNameCache {
	private final Map<String, Integer> nameToIndex = new HashMap<>();
	private final Set<Integer> usedRawIndices = new HashSet<>();
	private final boolean isStatic;
	private int next;
	private int maxIndex;

	/**
	 * @param isStatic
	 * 		Is the method static or not.
	 * @param currentType
	 * 		Internal name of declaring class.
	 */
	VariableNameCache(boolean isStatic, String currentType) {
		// Add "this" for instance methods
		this.isStatic = isStatic;
		if (!isStatic) {
			nameToIndex.put("this", 0);
			nameToIndex.put("0", 0);
			setNext(next + 1);
		}
	}

	/**
	 * @param root
	 * 		AST root.
	 *
	 * @throws AssemblerException
	 * 		When fetching type-information from an instruction fails.<br>
	 * 		Or when variables cannot fetch label information.
	 */
	void visit(RootAST root) throws AssemblerException {
		// Method descriptor
		// - contains explicit types & names
		// - highest priority due to being part of the method definition
		int argNext = isStatic ? 0 : 1;
		List<LabelAST> labels = root.search(LabelAST.class);
		for (DefinitionArgAST arg : root.search(DefinitionArgAST.class)) {
			String name = arg.getVariableName().getName();
			Type type = Type.getType(arg.getDesc().getDesc());
			// Get index from name
			int index = -1;
			if (name.matches("\\d+"))
				index = Integer.parseInt(name);
			else
				index = nameToIndex.getOrDefault(name, argNext);
			// Update for next arg index
			argNext += type.getSize();
			// Populate
			nameToIndex.put(String.valueOf(index), index);
			nameToIndex.put(name, index);
			// Update next index
			setNext(index + getNextVarIncrement(index, type.getSize()));
		}
		// Update next to be the minimum index following the last argument index
		setNext(argNext);
		// Add data for raw-indexed variables
		// We must track what indices they use so named variables do not conflict.
		for (VariableReference ast : root.search(VariableReference.class)) {
			String name = ast.getVariableName().getName();
			if (name.matches("\\d+")) {
				int index = Integer.parseInt(name);
				int size = TypeUtil.sortToSize(ast.getVariableSort());
				nameToIndex.put(name, index);
				usedRawIndices.add(index);
				// Doubles/longs take two spaces
				if (size > 1)
					usedRawIndices.add(index + 1);
			}
		}
		// Fit next into the next index that is not used by a raw-indexed variable
		next += getNextVarIncrement(next, 0);
		// Add data for named variables
		for (VariableReference ast : root.search(VariableReference.class)) {
			String name = ast.getVariableName().getName();
			// Skip raw-index variables
			if (name.matches("\\d+"))
				continue;
			// Add index mapping if it does not exist
			if (!nameToIndex.containsKey(name)) {
				int index = next;
				int size = TypeUtil.sortToSize(ast.getVariableSort());
				nameToIndex.put(name, index);
				setNext(index + getNextVarIncrement(index, size));
				// Track used indices
				usedRawIndices.add(index);
				if (size > 1)
					usedRawIndices.add(index + 1);
			}
		}
	}

	/**
	 * Adds a variable to the cache.
	 *
	 * @param name
	 * 		Variable name.
	 * @param type
	 * 		Variable type.
	 *
	 * @return Assigned index of the new variable.
	 */
	public int getAndIncrementNext(String name, Type type) {
		int size = type.getSize();
		int ret = getNextFreeVar(next, size);
		// Update used indices
		usedRawIndices.add(ret);
		if (size > 1)
			usedRawIndices.add(ret + 1);
		nameToIndex.put(name, ret);
		// Update next and max values
		next = getNextFreeVar(next, 1);
		maxIndex = next;
		return ret;
	}

	/**
	 * Finds the next free variable.
	 *
	 * @param start
	 * 		Starting position.
	 * @param size
	 * 		Size of variable to check for free space.
	 *
	 * @return Next free index.
	 */
	public int getNextFreeVar(int start, int size) {
		int temp = start;
		if (size == 1)
			while (isIndexUsed(temp))
				temp++;
		else
			while (isIndexUsed(temp) && isIndexUsed(temp + 1))
				temp++;
		return temp;
	}

	/**
	 * Finds the increment needed to fit the next variable slot. Will skip already used values.
	 *
	 * @param current
	 * 		Current variable index, without increment.
	 * @param size
	 * 		Size of variable just discovered.
	 *
	 * @return Variable increment amount.
	 */
	private int getNextVarIncrement(int current, int size) {
		int temp = current + size;
		while (isIndexUsed(temp))
			temp++;
		return temp - current;
	}

	/**
	 * @param index
	 * 		Index to check.
	 *
	 * @return {@code true} if the index is used.
	 */
	public boolean isIndexUsed(int index) {
		return usedRawIndices.contains(index) || nameToIndex.containsValue(index);
	}

	/**
	 * @param name
	 * 		Variable name.
	 *
	 * @return Index.
	 *
	 * @throws AssemblerException
	 * 		When index lookup fails.
	 */
	public int getIndex(String name) throws AssemblerException {
		try {
			return nameToIndex.get(name);
		} catch (Exception ex) {
			throw new AssemblerException("Failed to fetch index of: " + name);
		}
	}

	/**
	 * @return Max used locals.
	 */
	public int getMax() {
		// We offset by one because this needs to be 1-based, not 0-based in the contexts
		// that this getter method is used in.
		int value = maxIndex + 1;
		// Check if a reserved index occupies a higher space
		OptionalInt maxUsed = usedRawIndices.stream().mapToInt(i -> i).max();
		if (maxUsed.isPresent()) {
			int maxUsedInt = maxUsed.getAsInt() + 1;
			if (value < maxUsedInt)
				value = maxUsedInt;
		}
		return value;
	}

	/**
	 * @param variables
	 * 		Map of default indices to use for variable names.
	 */
	public void populateDefaults(Collection<LocalVariableNode> variables) {
		variables.forEach(variable -> {
			Type type;
			try {
				type = Type.getType(variable.desc);
			} catch (Exception ex) {
				// Sometimes obfuscators will put in garbage into the local variable debug info.
				// ASM doesn't like that, so we will just skip the variable if it has bogus info.
				return;
			}
			// Populate
			String name = variable.name;
			int index = variable.index;
			nameToIndex.put(name, index);
			// Update next index
			setNext(index + getNextVarIncrement(index, type.getSize()));
		});
	}

	// Internal use only
	Map<String, Integer> getNameToIndex() {
		return nameToIndex;
	}

	private void setNext(int next) {
		this.next = next;
		if (next > maxIndex)
			maxIndex = next;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/AST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.ArrayList;
import java.util.List;

/**
 * Base AST.
 *
 * @author Matt
 */
public abstract class AST {
	private final int line;
	private final int start;
	private final List<AST> children = new ArrayList<>();
	private AST parent;
	private AST next;
	private AST prev;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 */
	public AST(int line, int start) {
		this.line = line;
		this.start = start;
	}

	/**
	 * @return Line number this node is written on<i>(1-indexed)</i>.
	 */
	public int getLine() {
		return line;
	}

	/**
	 * @return Offset from line start this node starts at.
	 */
	public int getStart() {
		return start;
	}

	/**
	 * @return Children nodes.
	 */
	public List<AST> getChildren() {
		return children;
	}

	/**
	 * @param ast
	 * 		Child node to add.
	 */
	public void addChild(AST ast) {
		// Link parent/child
		getChildren().add(ast);
		ast.setParent(this);
		// Link prev/next for children
		if (getChildren().size() > 1) {
			AST prev = getChildren().get(getChildren().size() - 2);
			prev.setNext(ast);
			ast.setPrev(prev);
		}
	}

	/**
	 * @param type
	 * 		Class of AST node type.
	 * @param <T>
	 * 		Type of AST node.
	 *
	 * @return List of AST nodes of the given class type in the AST.
	 */
	public <T> List<T> search(Class<T> type) {
		return search(type, new ArrayList<>());
	}

	@SuppressWarnings("unchecked")
	private <T> List<T> search(Class<T> type, List<T> list) {
		for(AST ast : getChildren())
			if(type.isAssignableFrom(ast.getClass()))
				list.add((T) ast);
			else
				ast.search(type, list);
		return list;
	}

	/**
	 * @return Parent node.
	 */
	public AST getParent() {
		return parent;
	}

	/**
	 * @param parent
	 * 		Parent node.
	 */
	public void setParent(AST parent) {
		this.parent = parent;
	}

	/**
	 * @return Adjacent node.
	 */
	public AST getNext() {
		return next;
	}

	/**
	 * @param next
	 * 		Adjacent node.
	 */
	public void setNext(AST next) {
		this.next = next;
	}

	/**
	 * @return Adjacent node.
	 */
	public AST getPrev() {
		return prev;
	}

	/**
	 * @param prev
	 * 		Adjacent node.
	 */
	public void setPrev(AST prev) {
		this.prev = prev;
	}

	/**
	 * @return String representation of this node.
	 */
	public abstract String print();

	@Override
	public String toString() {
		return print();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/AliasAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * Alias AST.
 *
 * @author Matt
 */
public class AliasAST extends InsnAST {
	private final NameAST name;
	private final StringAST value;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param name
	 * 		Alias name AST.
	 * @param value
	 * 		Increment value AST.
	 */
	public AliasAST(int line, int start, OpcodeAST opcode, NameAST name, StringAST value) {
		super(line, start, opcode);
		this.name = name;
		this.value = value;
		addChild(name);
		addChild(value);
	}

	/**
	 * @return Alias name AST.
	 */
	public NameAST getName() {
		return name;
	}

	/**
	 * @return Increment value AST.
	 */
	public StringAST getValue() {
		return value;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + name.print() + " " + value.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		// No-op: this is not compilable.
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/CommentAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * Comment AST.
 *
 * @author Matt
 */
public class CommentAST extends AST implements Compilable {
	private final String comment;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param comment
	 * 		Content of comment.
	 */
	public CommentAST(int line, int start, String comment) {
		super(line, start);
		this.comment = comment;
	}

	/**
	 * @return Content of comment.
	 */
	public String getComment() {
		return comment;
	}


	@Override
	public String print() {
		return "//" + comment;
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addComment(comment.trim());
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/Compilable.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * Represents compilable AST element.
 *
 * @author xxDark
 */
public interface Compilable {

    /**
     * Compiles this element.
     *
     * @param compilation
     * 		Compilation context.
     *
     * @throws AssemblerException
     * 		When compilation has failed.
     */
    void compile(MethodCompilation compilation) throws AssemblerException;
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/DefaultValueAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import org.objectweb.asm.Type;

/**
 * Field default value AST.
 *
 * @author Matt
 */
public class DefaultValueAST extends AST {
	private final AST content;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param content
	 * 		Constant value AST.
	 */
	public DefaultValueAST(int line, int start, AST content) {
		super(line, start);
		this.content = content;
		addChild(content);
	}

	/**
	 * @return Constant value AST.
	 */
	public AST getContent() {
		return content;
	}

	@Override
	public String print() {
		return "VALUE " + content.print();
	}

	/**
	 * @return Field value.
	 */
	public Object toValue() {
		Object value = null;
		if(content instanceof StringAST)
			value = ((StringAST) content).getUnescapedValue();
		else if(content instanceof NumberAST)
			value = ((NumberAST) content).getValue();
		else if(content instanceof DescAST)
			value = Type.getType(((DescAST) content).getDesc());
		else if(content instanceof HandleAST)
			value = ((HandleAST) content).compile();
		return value;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/DefinitionAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.ArrayList;
import java.util.List;

/**
 * Common base for definition AST objects.
 *
 * @author Matt
 */
public abstract class DefinitionAST extends AST {
	protected final List<DefinitionModifierAST> modifiers = new ArrayList<>();
	protected final NameAST name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Member name.
	 */
	public DefinitionAST(int line, int start, NameAST name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Full descriptor of the definition.
	 */
	public abstract String getDescriptor();

	/**
	 * @return Method name.
	 */
	public NameAST getName() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/DefinitionArgAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import org.objectweb.asm.Type;

/**
 * Method argument AST.
 *
 * @author Matt
 */
public class DefinitionArgAST extends AST implements VariableReference {
	private final DescAST desc;
	private final NameAST name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param desc
	 * 		Argument type, in descriptor format.
	 * @param name
	 * 		Argument name.
	 */
	public DefinitionArgAST(int line, int start, DescAST desc, NameAST name) {
		super(line, start);
		this.desc = desc;
		this.name = name;
		addChild(desc);
		addChild(name);
	}

	@Override
	public NameAST getVariableName() {
		return name;
	}

	@Override
	public int getVariableSort() {
		return Type.getType(getDesc().getDesc()).getSort();
	}

	/**
	 * @return Argument type, in descriptor format.
	 */
	public DescAST getDesc() {
		return desc;
	}

	@Override
	public String print() {
		return getDesc().print() + " " + getVariableName().print();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/DefinitionModifierAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.AccessFlag;

/**
 * Method modifier AST.
 *
 * @author Matt
 */
public class DefinitionModifierAST extends AST {
	private final String name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Modifier name.
	 */
	public DefinitionModifierAST(int line, int start, String name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Modifier name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Value of modifier
	 */
	public int getValue() {
		return AccessFlag.getFlag(getName()).getMask();
	}

	@Override
	public String print() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/DescAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;
	
import me.coley.recaf.util.EscapeUtil;

/**
 * Member descriptor AST.
 *
 * @author Matt
 */
public class DescAST extends AST {
	private final String desc;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param desc
	 * 		Member descriptor.
	 */
	public DescAST(int line, int start, String desc) {
		super(line, start);
		this.desc = desc;
	}

	/**
	 * @return Member descriptor.
	 */
	public String getDesc() {
		return desc;
	}
	
	/**
	 * @return Desc without escapes.
	 */
	public String getUnescapedDesc() {
		return EscapeUtil.unescape(desc);
	}

	@Override
	public String print() {
		return desc;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/ExpressionAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * A one-liner source level expression.
 *
 * @author Matt
 */
public class ExpressionAST extends AST implements Compilable {
	private final String expression;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param expression
	 * 		Expression literal value.
	 */
	public ExpressionAST(int line, int start, String expression) {
		super(line, start);
		this.expression = expression;
	}

	/**
	 * @return Expression literal value.
	 */
	public String getExpression() {
		return expression;
	}

	@Override
	public String print() {
		return "EXPR " + expression;
	}


	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addExpression(expression, this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/FieldDefinitionAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.List;

import static java.util.stream.Collectors.joining;

/**
 * Field declaration AST.
 *
 * @author Matt
 */
public class FieldDefinitionAST extends DefinitionAST {
	private final DescAST type;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Field name.
	 * @param type
	 * 		Field return type.
	 */
	public FieldDefinitionAST(int line, int start, NameAST name, DescAST type) {
		super(line, start, name);
		this.type = type;
	}

	/**
	 * @return Field access modifier nodes.
	 */
	public List<DefinitionModifierAST> getModifiers() {
		return modifiers;
	}

	/**
	 * @param modifier
	 * 		Modifier node to add.
	 */
	public void addModifier(DefinitionModifierAST modifier) {
		modifiers.add(modifier);
		addChild(modifier);
	}

	/**
	 * @return Field type.
	 */
	public DescAST getType() {
		return type;
	}

	@Override
	public String getDescriptor() {
		return getType().getDesc();
	}

	@Override
	public String print() {
		String modifiersStr = getModifiers().stream().map(AST::print).collect(joining(" "));
		return "DEFINE " + modifiersStr + " " + getType().print() + " " + getName().print();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/FieldInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * Field reference instruction AST.
 *
 * @author Matt
 */
public class FieldInsnAST extends InsnAST {
	private final TypeAST owner;
	private final NameAST name;
	private final DescAST desc;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param owner
	 * 		Field owner type AST.
	 * @param name
	 * 		Field name AST.
	 * @param desc
	 * 		Field descriptor AST.
	 */
	public FieldInsnAST(int line, int start, OpcodeAST opcode, TypeAST owner, NameAST name, DescAST desc) {
		super(line, start, opcode);
		this.owner = owner;
		this.name = name;
		this.desc = desc;
		addChild(owner);
		addChild(name);
		addChild(desc);
	}

	/**
	 * @return Type AST of field owner.
	 */
	public TypeAST getOwner() {
		return owner;
	}

	/**
	 * @return Name AST of field name.
	 */
	public NameAST getName() {
		return name;
	}

	/**
	 * @return Desc AST of field descriptor.
	 */
	public DescAST getDesc() {
		return desc;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + owner.print() + "." + name.print() + " " + desc.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new FieldInsnNode(getOpcode().getOpcode(), getOwner().getType(),
				getName().getName(), getDesc().getDesc()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/FlowController.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.List;

/**
 * Common to all instructions that modify flow control.
 *
 * @author Matt
 */
public interface FlowController {
	/**
	 * @return List of label names this instruction may branch to.
	 */
	List<String> targets();
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/HandleAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;

/**
 * Handle AST.
 *
 * @author Matt
 */
public class HandleAST extends AST {
	private final TagAST tag;
	private final TypeAST owner;
	private final NameAST name;
	private final DescAST desc;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param tag
	 * 		Handle tag AST.
	 * @param owner
	 * 		Handle reference owner type AST.
	 * @param name
	 * 		Handle reference name AST.
	 * @param desc
	 * 		Handle reference descriptor AST.
	 */
	public HandleAST(int line, int start, TagAST tag, TypeAST owner, NameAST name, DescAST desc) {
		super(line, start);
		this.tag = tag;
		this.owner = owner;
		this.name = name;
		this.desc = desc;
		addChild(tag);
		addChild(owner);
		addChild(name);
		addChild(desc);
	}

	/**
	 * @return Handle tag AST.
	 */
	public TagAST getTag() {
		return tag;
	}

	/**
	 * @return Type AST of reference owner.
	 */
	public TypeAST getOwner() {
		return owner;
	}

	/**
	 * @return Name AST of reference name.
	 */
	public NameAST getName() {
		return name;
	}

	/**
	 * @return Desc AST of reference descriptor.
	 */
	public DescAST getDesc() {
		return desc;
	}

	@Override
	public String print() {
		String split = getTag().isMethod() ? "" : " ";
		return "handle[" + getTag().print() + " " +
				owner.print() + "." + name.print() + split + desc.print() + "]";
	}

	/**
	 * @return ASM handle from AST data.
	 */
	public Handle compile() {
		return new Handle(getTag().getTag(), getOwner().getUnescapedType(), getName().getUnescapedName(),
				getDesc().getUnescapedDesc(), getTag().getTag() == Opcodes.H_INVOKEINTERFACE);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/IincInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

/**
 * Variable instruction AST.
 *
 * @author Matt
 */
public class IincInsnAST extends InsnAST implements VariableReference {
	private final NameAST variable;
	private final NumberAST incr;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param variable
	 * 		Variable name AST.
	 * @param incr
	 * 		Increment value AST.
	 */
	public IincInsnAST(int line, int start, OpcodeAST opcode, NameAST variable, NumberAST incr) {
		super(line, start, opcode);
		this.variable = variable;
		this.incr = incr;
		addChild(variable);
		addChild(incr);
	}

	@Override
	public NameAST getVariableName() {
		return variable;
	}

	@Override
	public int getVariableSort() {
		return Type.INT;
	}

	/**
	 * @return Increment value AST.
	 */
	public NumberAST getIncrement() {
		return incr;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + variable.print() + " " + incr.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new IincInsnNode(getVariableIndex(compilation.getVariableNameCache()),
				getIncrement().getIntValue()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/InsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * Base instruction AST.
 *
 * @author Matt
 */
public class InsnAST extends AST implements Instruction {
	private final OpcodeAST opcode;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 */
	public InsnAST(int line, int start, OpcodeAST opcode) {
		super(line, start);
		this.opcode = opcode;
		addChild(opcode);
	}

	@Override
	public OpcodeAST getOpcode() {
		return opcode;
	}

	@Override
	public String print() {
		return opcode.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new InsnNode(getOpcode().getOpcode()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/Instruction.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * Common to all instruction AST.
 *
 * @author Matt
 */
public interface Instruction extends Compilable {
	/**
	 * @return Opcode AST.
	 */
	OpcodeAST getOpcode();

	/**
	 * @return Instruction group. See {@link AbstractInsnNode#getType()}
	 */
	default int getInsnType() {
		return OpcodeUtil.opcodeToType(getOpcode().getOpcode());
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/IntInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.util.TypeUtil;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

/**
 * Int instruction AST.
 *
 * @author Matt
 */
public class IntInsnAST extends InsnAST {
	private final NumberAST value;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param value
	 * 		Int value.
	 */
	public IntInsnAST(int line, int start, OpcodeAST opcode, NumberAST value) {
		super(line, start, opcode);
		this.value = value;
		addChild(value);
	}

	/**
	 * @return value AST.
	 */
	public NumberAST getValue() {
		return value;
	}

	@Override
	public String print() {
		if (getOpcode().getOpcode() == Opcodes.NEWARRAY) {
			return getOpcode().print() + " " + TypeUtil.newArrayArgToType(value.getIntValue()).getDescriptor();
		} else {
			return getOpcode().print() + " " + value.print();
		}
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new IntInsnNode(getOpcode().getOpcode(), getValue().getIntValue()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/InvokeDynamicAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.Type;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Invokedynamic instruction AST.
 *
 * @author Matt
 */
public class InvokeDynamicAST extends InsnAST {
	private final NameAST name;
	private final DescAST desc;
	private final HandleAST handle;
	private final List<AST> args;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param name
	 * 		Invokedynamic name AST.
	 * @param desc
	 * 		Invokedynamic descriptor AST.
	 * @param handle
	 * 		Invokedynamic handle AST.
	 * @param args
	 * 		Invokedynamic arguments.
	 */
	public InvokeDynamicAST(int line, int start, OpcodeAST opcode, NameAST name, DescAST desc,
							HandleAST handle, List<AST> args) {
		super(line, start, opcode);
		this.name = name;
		this.desc = desc;
		this.handle = handle;
		this.args = args;
		addChild(name);
		addChild(desc);
		addChild(handle);
		args.forEach(this::addChild);
	}

	/**
	 * @return Name AST of invokedynamic.
	 */
	public NameAST getName() {
		return name;
	}

	/**
	 * @return Desc AST of invokedynamic.
	 */
	public DescAST getDesc() {
		return desc;
	}

	/**
	 * @return Invoke dynamic handle AST.
	 */
	public HandleAST getHandle() {
		return handle;
	}

	/**
	 * @return Invokedynamic arguments.
	 */
	public List<AST> getArgs() {
		return args;
	}

	@Override
	public String print() {
		String argsStr = args.stream()
				.map(AST::print)
				.collect(Collectors.joining(", "));
		return getOpcode().print() + " " +  name.print() + " " + desc.print() + " " +
				handle.print() + " args[" + argsStr + "]";
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		Object[] convertedArgs = new Object[args.size()];
		for(int i = 0; i < args.size(); i++) {
			AST arg = args.get(i);
			if(arg instanceof NumberAST) {
				convertedArgs[i] = ((NumberAST) arg).getValue();
			} else if(arg instanceof StringAST) {
				convertedArgs[i] = ((StringAST) arg).getUnescapedValue();
			} else if(arg instanceof HandleAST) {
				convertedArgs[i] = ((HandleAST) arg).compile();
			} else if(arg instanceof TypeAST) {
				convertedArgs[i] = Type.getType(((TypeAST) arg).getType());
			} else if(arg instanceof DescAST) {
				convertedArgs[i] = Type.getType(((DescAST) arg).getDesc());
			}
		}
		compilation.addInstruction(new InvokeDynamicInsnNode(getName().getUnescapedName(), getDesc().getUnescapedDesc(),
				getHandle().compile(), convertedArgs), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/JumpInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

import java.util.Collections;
import java.util.List;

/**
 * Jump instruction AST.
 *
 * @author Matt
 */
public class JumpInsnAST extends InsnAST implements FlowController {
	private final NameAST label;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param label
	 * 		Label name AST.
	 */
	public JumpInsnAST(int line, int start, OpcodeAST opcode, NameAST label) {
		super(line, start, opcode);
		this.label = label;
		addChild(label);
	}

	/**
	 * @return Label name AST.
	 */
	public NameAST getLabel() {
		return label;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + label.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		LabelNode label = compilation.getLabel(getLabel().getName());
		if (label == null)
			throw new AssemblerException("Specified destination label '" + getLabel().getName() +
					"' does not exist", getLine());
		compilation.addInstruction(new JumpInsnNode(getOpcode().getOpcode(), label), this);
	}

	@Override
	public List<String> targets() {
		return Collections.singletonList(getLabel().getName());
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/LabelAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;

/**
 * Label AST.
 *
 * @author Matt
 */
public class LabelAST extends AST implements Compilable {
	private final NameAST name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Label name.
	 */
	public LabelAST(int line, int start, NameAST name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Name AST.
	 */
	public NameAST getName() {
		return name;
	}


	@Override
	public String print() {
		return name.print() + ":";
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(compilation.getLabel(getName().getName()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/LdcInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.Type;

/**
 * Load constant instruction AST.
 *
 * @author Matt
 */
public class LdcInsnAST extends InsnAST {
	private final AST content;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param content
	 * 		Constant value AST.
	 */
	public LdcInsnAST(int line, int start, OpcodeAST opcode, AST content) {
		super(line, start, opcode);
		this.content = content;
		addChild(content);
	}

	/**
	 * @return Constant value AST.
	 */
	public AST getContent() {
		return content;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + content.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		Object value = null;
		if(content instanceof StringAST)
			value = ((StringAST) content).getUnescapedValue();
		else if(content instanceof NumberAST)
			value = ((NumberAST) content).getValue();
		else if(content instanceof DescAST)
			value = Type.getType(((DescAST) content).getDesc());
		else if(content instanceof HandleAST)
			value = ((HandleAST) content).compile();
		compilation.addInstruction(new LdcInsnNode(value), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/LineInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * Line number instruction AST.
 *
 * @author Matt
 */
public class LineInsnAST extends InsnAST {
	private final NameAST label;
	private final NumberAST lineNumber;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param label
	 * 		Label name AST.
	 * @param lineNumber
	 * 		Line number AST.
	 */
	public LineInsnAST(int line, int start, OpcodeAST opcode, NameAST label, NumberAST lineNumber) {
		super(line, start, opcode);
		this.label = label;
		this.lineNumber = lineNumber;
		addChild(label);
		addChild(lineNumber);
	}

	/**
	 * @return Label name AST.
	 */
	public NameAST getLabel() {
		return label;
	}

	/**
	 * @return Line number AST.
	 */
	public NumberAST getLineNumber() {
		return lineNumber;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + label.print() + " " + lineNumber.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new LineNumberNode(getLineNumber().getIntValue(),
				compilation.getLabel(getLabel().getName())), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/LookupSwitchInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Table switch instruction AST.
 *
 * @author Matt
 */
public class LookupSwitchInsnAST extends InsnAST implements FlowController {
	private final Map<NumberAST, NameAST> mapping;
	private final NameAST dfltLabel;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param mapping
	 * 		Mapping of values to labels.
	 * @param dfltLabel
	 * 		Default fallback label AST.
	 */
	public LookupSwitchInsnAST(int line, int start, OpcodeAST opcode,
							   Map<NumberAST, NameAST> mapping, NameAST dfltLabel) {
		super(line, start, opcode);
		this.mapping = mapping;
		this.dfltLabel = dfltLabel;
		mapping.forEach((k, v) -> {
			addChild(k);
			addChild(v);
		});
		addChild(dfltLabel);
	}

	/**
	 * @return Mapping of values to labels.
	 */
	public Map<NumberAST, NameAST> getMapping() {
		return mapping;
	}

	/**
	 * @return Default fallback label AST.
	 */
	public NameAST getDfltLabel() {
		return dfltLabel;
	}

	@Override
	public String print() {
		String map = mapping.entrySet().stream()
				.map(e -> e.getKey().print() + "=" + e.getValue().print())
				.sorted()
				.collect(Collectors.joining(", "));
		return getOpcode().print() +
				" mapping[" + map + "]" +
				" default[" + dfltLabel.print() + "]";
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		int[] keys = new int[mapping.size()];
		LabelNode[] lbls = new LabelNode[mapping.size()];
		int i = 0;
		for(Map.Entry<NumberAST, NameAST> entry : mapping.entrySet()) {
			int key = entry.getKey().getIntValue();
			LabelNode lbl = compilation.getLabel(entry.getValue().getName());
			keys[i] = key;
			lbls[i] = lbl;
			i++;
		}
		LabelNode dflt = compilation.getLabel(getDfltLabel().getName());
		compilation.addInstruction(new LookupSwitchInsnNode(dflt, keys, lbls), this);
	}

	@Override
	public List<String> targets() {
		List<String> targets = new ArrayList<>();
		targets.add(getDfltLabel().getName());
		targets.addAll(getMapping().values().stream().map(NameAST::getName).collect(Collectors.toList()));
		return targets;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/MethodDefinitionAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.joining;

/**
 * Method declaration AST.
 *
 * @author Matt
 */
public class MethodDefinitionAST extends DefinitionAST {
	private final List<DefinitionArgAST> arguments = new ArrayList<>();
	private final DescAST retType;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Method name.
	 * @param retType
	 * 		Method return type.
	 */
	public MethodDefinitionAST(int line, int start, NameAST name, DescAST retType) {
		super(line, start, name);
		this.retType = retType;
	}

	/**
	 * @return Method access modifier nodes.
	 */
	public List<DefinitionModifierAST> getModifiers() {
		return modifiers;
	}

	/**
	 * @param modifier
	 * 		Modifier node to add.
	 */
	public void addModifier(DefinitionModifierAST modifier) {
		modifiers.add(modifier);
		addChild(modifier);
	}

	/**
	 * @return Combined modifiers.
	 */
	public int getModifierMask() {
		return search(DefinitionModifierAST.class).stream()
				.mapToInt(DefinitionModifierAST::getValue)
				.reduce(0, (a, b) -> a | b);
	}

	/**
	 * @return Method parameter nodes.
	 */
	public List<DefinitionArgAST> getArguments() {
		return arguments;
	}

	/**
	 * @param arg
	 * 		Argument node to add.
	 */
	public void addArgument(DefinitionArgAST arg) {
		arguments.add(arg);
		addChild(arg);
	}

	/**
	 * @return Method return type.
	 */
	public DescAST getReturnType() {
		return retType;
	}


	/**
	 * @return Combined method descriptor of argument children and return type child.
	 */
	@Override
	public String getDescriptor() {
		String args = search(DefinitionArgAST.class).stream()
				.map(ast -> ast.getDesc().getDesc())
				.collect(Collectors.joining());
		String end = getReturnType().getDesc();
		return "(" + args + ")" + end;
	}

	@Override
	public String print() {
		String modifiersStr = getModifiers().stream().map(AST::print).collect(joining(" "));
		String argumentsStr = getArguments().stream().map(AST::print).collect(joining(", "));
		String ret = getReturnType().print();
		return "DEFINE " + modifiersStr + " " + getName().print() + "(" + argumentsStr + ")" + ret;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/MethodInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * Method reference instruction AST.
 *
 * @author Matt
 */
public class MethodInsnAST extends InsnAST {
	private final TypeAST owner;
	private final NameAST name;
	private final DescAST desc;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param owner
	 * 		Method owner type AST.
	 * @param name
	 * 		Method name AST.
	 * @param desc
	 * 		Method descriptor AST.
	 */
	public MethodInsnAST(int line, int start, OpcodeAST opcode, TypeAST owner, NameAST name, DescAST desc) {
		super(line, start, opcode);
		this.owner = owner;
		this.name = name;
		this.desc = desc;
		addChild(owner);
		addChild(name);
		addChild(desc);
	}

	/**
	 * @return Type AST of method owner.
	 */
	public TypeAST getOwner() {
		return owner;
	}

	/**
	 * @return Name AST of method name.
	 */
	public NameAST getName() {
		return name;
	}

	/**
	 * @return Desc AST of method descriptor.
	 */
	public DescAST getDesc() {
		return desc;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + owner.print() + "." + name.print() + desc.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new MethodInsnNode(getOpcode().getOpcode(), getOwner().getType(),
				getName().getName(), getDesc().getDesc()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/MultiArrayInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * MultiANewArray instruction AST.
 *
 * @author Matt
 */
public class MultiArrayInsnAST extends InsnAST {
	private final DescAST desc;
	private final NumberAST dims;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param desc
	 * 		Descriptor AST.
	 * @param dims
	 * 		Dimension number AST.
	 */
	public MultiArrayInsnAST(int line, int start, OpcodeAST opcode, DescAST desc, NumberAST dims) {
		super(line, start, opcode);
		this.desc = desc;
		this.dims = dims;
		addChild(desc);
		addChild(dims);
	}

	/**
	 * @return Descriptor AST.
	 */
	public DescAST getDesc() {
		return desc;
	}

	/**
	 * @return Dimension number AST.
	 */
	public NumberAST getDimensions() {
		return dims;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + desc.print() + " " + dims.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new MultiANewArrayInsnNode(getDesc().getDesc(),
				getDimensions().getIntValue()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/NameAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.EscapeUtil;

/**
 * Generic name AST.
 *
 * @author Matt
 */
public class NameAST extends AST {
	private final String name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Name.
	 */
	public NameAST(int line, int start, String name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Name.
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * @return Name without escapes.
	 */
	public String getUnescapedName() {
		return EscapeUtil.unescape(name);
	}


	@Override
	public String print() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/NumberAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

/**
 * Generic number AST.
 *
 * @author Matt
 */
public class NumberAST extends AST {
	private final Number value;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param value
	 * 		Numeric value.
	 */
	public NumberAST(int line, int start, Number value) {
		super(line, start);
		this.value = value;
	}

	/**
	 * @return value.
	 */
	public Number getValue() {
		return value;
	}

	/**
	 * @return value as int.
	 */
	public int getIntValue() {
		return value.intValue();
	}

	/**
	 * @return value as long.
	 */
	public long getLongValue() {
		return value.longValue();
	}

	/**
	 * @return value as float.
	 */
	public float getFloatValue() {
		return value.floatValue();
	}

	/**
	 * @return value as double.
	 */
	public double getDoubleValue() {
		return value.doubleValue();
	}

	@Override
	public String print() {
		String val = String.valueOf(value);
		String suffix = "";
		if (value instanceof Long)
			suffix = "L";
		else if (value instanceof Float)
			suffix = "F";
		return val + suffix;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/OpcodeAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.OpcodeUtil;

/**
 * Instruction name AST.
 *
 * @author Matt
 */
public class OpcodeAST extends AST {
	private final String name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Opcode display name.
	 */
	public OpcodeAST(int line, int start, String name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Opcode display name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Opcode value.
	 */
	public int getOpcode() {
		return OpcodeUtil.nameToOpcode(getName());
	}

	@Override
	public String print() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/RootAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import java.util.stream.Collectors;

/**
 * Root AST.
 *
 * @author Matt
 */
public class RootAST extends AST {
	/**
	 * Create root.
	 */
	public RootAST() {
		super(0,0);
	}

	/**
	 * @param line
	 * 		Line number.
	 *
	 * @return AST at line number. May be {@code null}.
	 */
	public AST getAtLine(int line) {
		return getChildren().stream()
					.filter(ast -> ast.getLine() == line)
					.findFirst().orElse(null);
	}

	@Override
	public String print() {
		return getChildren().stream().map(AST::print).collect(Collectors.joining("\n"));
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/SignatureAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

/**
 * Member generic signature AST.
 *
 * @author Matt
 */
public class SignatureAST extends AST {
	private final String signature;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param signature
	 * 		Member generic signature.
	 */
	public SignatureAST(int line, int start, String signature) {
		super(line, start);
		this.signature = signature;
	}

	/**
	 * @return Member descriptor.
	 */
	public String getSignature() {
		return signature;
	}

	@Override
	public String print() {
		return "SIGNATURE " + signature;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/StringAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.EscapeUtil;

/**
 * String AST.
 *
 * @author Matt
 */
public class StringAST extends AST {
	private final String value;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param value
	 * 		Value.
	 */
	public StringAST(int line, int start, String value) {
		super(line, start);
		this.value = value;
	}

	/**
	 * @return Value.
	 */
	public String getValue() {
		return value;
	}

	/**
	 * @return Value without escapes.
	 */
	public String getUnescapedValue() {
		return EscapeUtil.unescape(value);
	}

	@Override
	public String print() {
		return "\"" + value + "\"";
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/TableSwitchInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Table switch instruction AST.
 *
 * @author Matt
 */
public class TableSwitchInsnAST extends InsnAST implements FlowController {
	private final NumberAST rangeMin;
	private final NumberAST rangeMax;
	private final List<NameAST> labels;
	private final NameAST dfltLabel;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param rangeMin
	 * 		Min switch range value AST.
	 * @param rangeMax
	 * 		Max switch range value AST.
	 * @param labels
	 * 		Labels (AST) that link to value in range.
	 * @param dfltLabel
	 * 		Default fallback label AST.
	 */
	public TableSwitchInsnAST(int line, int start, OpcodeAST opcode, NumberAST rangeMin,
							  NumberAST rangeMax, List<NameAST> labels, NameAST dfltLabel) {
		super(line, start, opcode);
		this.rangeMin = rangeMin;
		this.rangeMax = rangeMax;
		this.labels = labels;
		this.dfltLabel = dfltLabel;
		addChild(rangeMin);
		addChild(rangeMax);
		labels.forEach(this::addChild);
		addChild(dfltLabel);
	}

	/**
	 * @return Min switch range value AST.
	 */
	public NumberAST getRangeMin() {
		return rangeMin;
	}

	/**
	 * @return Max switch range value AST.
	 */
	public NumberAST getRangeMax() {
		return rangeMax;
	}

	/**
	 * @return Labels (AST) that link to value in range.
	 */
	public List<NameAST> getLabels() {
		return labels;
	}

	/**
	 * @return Default fallback label AST.
	 */
	public NameAST getDfltLabel() {
		return dfltLabel;
	}

	@Override
	public String print() {
		String lbls = labels.stream()
				.map(NameAST::print)
				.collect(Collectors.joining(", "));
		return getOpcode().print() +
				" range[" + rangeMin.print() +":" + rangeMax.print() + "]" +
				" offsets[" + lbls + "]" +
				" default[" + dfltLabel.print() + "]";
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		LabelNode[] lbls = getLabels().stream()
				.map(ast -> compilation.getLabel(ast.getName()))
				.toArray(LabelNode[]::new);
		LabelNode dflt = compilation.getLabel(getDfltLabel().getName());
		compilation.addInstruction(new TableSwitchInsnNode(getRangeMin().getIntValue(), getRangeMax().getIntValue(),
				dflt, lbls), this);
	}

	@Override
	public List<String> targets() {
		List<String> targets = new ArrayList<>();
		targets.add(getDfltLabel().getName());
		targets.addAll(getLabels().stream().map(NameAST::getName).collect(Collectors.toList()));
		return targets;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/TagAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.Opcodes;

/**
 * Handle tag AST.
 *
 * @author Matt
 */
public class TagAST extends AST {
	private final String name;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param name
	 * 		Tag display name.
	 */
	public TagAST(int line, int start, String name) {
		super(line, start);
		this.name = name;
	}

	/**
	 * @return Opcode display name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Opcode value.
	 */
	public int getTag() {
		return OpcodeUtil.nameToTag(getName());
	}

	/**
	 * @return {@code true} if the tag is for a field reference.
	 */
	public boolean isField() {
		int tag = getTag();
		return tag >= Opcodes.H_GETFIELD && tag <= Opcodes.H_PUTSTATIC;
	}

	/**
	 * @return {@code true} if the tag is for a method reference.
	 */
	public boolean isMethod() {
		return !isField();
	}

	@Override
	public String print() {
		return name;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/ThrowsAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

/**
 * Method throws AST.
 *
 * @author Matt
 */
public class ThrowsAST extends AST {
	private final TypeAST type;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param type
	 * 		Exception type.
	 */
	public ThrowsAST(int line, int start, TypeAST type) {
		super(line, start);
		this.type = type;
		addChild(type);
	}

	/**
	 * @return Exception type.
	 */
	public TypeAST getType() {
		return type;
	}

	@Override
	public String print() {
		return "THROWS " + type.print();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/TryCatchAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

/**
 * Try-catch AST.
 *
 * @author Matt
 */
public class TryCatchAST extends AST {
	private final TypeAST type;
	private final NameAST lblStart;
	private final NameAST lblEnd;
	private final NameAST lblHandler;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param lblStart
	 * 		Try block starting label.
	 * @param lblEnd
	 * 		Try block ending label.
	 * @param type
	 * 		Type of exception caught.
	 * @param lblHandler
	 * 		Catch block starting label.
	 */
	public TryCatchAST(int line, int start, NameAST lblStart, NameAST lblEnd,
					   TypeAST type, NameAST lblHandler) {
		super(line, start);
		this.lblStart = lblStart;
		this.lblEnd = lblEnd;
		this.type = type;
		this.lblHandler = lblHandler;
		addChild(lblStart);
		addChild(lblEnd);
		addChild(type);
		addChild(lblHandler);
	}

	/**
	 * @return Type of exception caught.
	 */
	public TypeAST getType() {
		return type;
	}

	/**
	 * @return Try block starting label name AST.
	 */
	public NameAST getLblStart() {
		return lblStart;
	}

	/**
	 * @return Try block ending label name AST.
	 */
	public NameAST getLblEnd() {
		return lblEnd;
	}

	/**
	 * @return Catch block starting label name AST.
	 */
	public NameAST getLblHandler() {
		return lblHandler;
	}

	@Override
	public String print() {
		return "TRY " + lblStart.getName() + " " + lblEnd.getName() +
				" CATCH(" + type.getType() + ") " + lblHandler.getName();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/TypeAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.util.EscapeUtil;

/**
 * Internal name AST.
 *
 * @author Matt
 */
public class TypeAST extends AST {
	private final String type;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param type
	 * 		Internal type name.
	 */
	public TypeAST(int line, int start, String type) {
		super(line, start);
		this.type = type;
	}

	/**
	 * @return Internal type.
	 */
	public String getType() {
		return type;
	}

	/**
	 * @return Internal type without escapes.
	 */
	public String getUnescapedType() {
		return EscapeUtil.unescape(type);
	}

	@Override
	public String print() {
		return type;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/TypeInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.tree.*;

/**
 * Type instruction AST.
 *
 * @author Matt
 */
public class TypeInsnAST extends InsnAST {
	private final TypeAST type;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param type
	 * 		Type AST.
	 */
	public TypeInsnAST(int line, int start, OpcodeAST opcode, TypeAST type) {
		super(line, start, opcode);
		this.type = type;
		addChild(type);
	}

	/**
	 * @return Type AST.
	 */
	public TypeAST getType() {
		return type;
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + type.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new TypeInsnNode(getOpcode().getOpcode(), getType().getType()), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/VarInsnAST.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.MethodCompilation;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

/**
 * Variable instruction AST.
 *
 * @author Matt
 */
public class VarInsnAST extends InsnAST implements VariableReference {
	private final NameAST variable;

	/**
	 * @param line
	 * 		Line number this node is written on.
	 * @param start
	 * 		Offset from line start this node starts at.
	 * @param opcode
	 * 		Opcode AST.
	 * @param variable
	 * 		Variable name AST.
	 */
	public VarInsnAST(int line, int start, OpcodeAST opcode, NameAST variable) {
		super(line, start, opcode);
		this.variable = variable;
		addChild(variable);
	}

	@Override
	public NameAST getVariableName() {
		return variable;
	}

	@Override
	public int getVariableSort() {
		int opcode = getOpcode().getOpcode();
		switch (opcode) {
			case Opcodes.ILOAD:
			case Opcodes.ISTORE:
				return Type.INT;
			case Opcodes.LLOAD:
			case Opcodes.LSTORE:
				return Type.LONG;
			case Opcodes.DLOAD:
			case Opcodes.DSTORE:
				return Type.DOUBLE;
			case Opcodes.FLOAD:
			case Opcodes.FSTORE:
				return Type.FLOAT;
			case Opcodes.ALOAD:
			case Opcodes.ASTORE:
			default:
				return Type.OBJECT;
		}
	}

	@Override
	public String print() {
		return getOpcode().print() + " " + variable.print();
	}

	@Override
	public void compile(MethodCompilation compilation) throws AssemblerException {
		compilation.addInstruction(new VarInsnNode(getOpcode().getOpcode(),
				getVariableIndex(compilation.getVariableNameCache())), this);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/ast/VariableReference.java`:

```java
package me.coley.recaf.parse.bytecode.ast;

import me.coley.recaf.parse.bytecode.VariableNameCache;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import org.objectweb.asm.Type;

/**
 * Common to AST that reference variables.
 *
 * @author Matt
 */
public interface VariableReference {
	/**
	 * @return Variable name AST.
	 */
	NameAST getVariableName();

	/**
	 * @return Variable {@link Type#getSort()}.
	 */
	int getVariableSort();

	/**
	 * @param variableNameCache
	 * 		Variable name-to-index lookup.
	 *
	 * @return Index of {@link #getVariableName()}.
	 *
	 * @throws AssemblerException
	 * 		Variable failed index lookup.
	 */
	default int getVariableIndex(VariableNameCache variableNameCache) throws AssemblerException {
		try {
			return variableNameCache.getIndex(getVariableName().getName());
		} catch (AssemblerException ex) {
			// Rethrow with line number
			int line = -1;
			if (this instanceof AST)
				line = ((AST) this).getLine();
			throw new AssemblerException(ex.getMessage(), line);
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/exception/ASTParseException.java`:

```java
package me.coley.recaf.parse.bytecode.exception;

import me.coley.recaf.util.struct.LineException;

/**
 * Parse error.
 *
 * @author Matt
 */
public class ASTParseException extends Exception implements LineException {
	private final int line;

	/**
	 * @param line
	 * 		Line the parse error occurred on.
	 * @param message
	 * 		Reason for parse failure.
	 */
	public ASTParseException(int line, String message) {
		this(null, line, message);
	}

	/**
	 * @param cause
	 * 		Cause exception.
	 * @param line
	 * 		Line the parse error occurred on.
	 * @param message
	 * 		Reason for parse failure.
	 */
	public ASTParseException(Exception cause, int line, String message) {
		super(message, cause);
		this.line = line;
	}

	@Override
	public int getLine() {
		return line;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/exception/AssemblerException.java`:

```java
package me.coley.recaf.parse.bytecode.exception;

import me.coley.recaf.util.struct.LineException;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Exception for invalid assembler input.
 *
 * @author Matt
 */
public class AssemblerException extends Exception implements LineException {
	private final List<LineException> subExceptions = new ArrayList<>();
	private final int line;

	/**
	 * @param message
	 * 		Reason for assembler error.
	 */
	public AssemblerException(String message) {
		this(null, message, -1);
	}

	/**
	 * @param message
	 * 		Reason for assembler error.
	 * @param line
	 * 		Line number relevant to the error.
	 */
	public AssemblerException(String message, int line) {
		this(null, message, line);
	}

	/**
	 * @param t
	 * 		Cause exception.
	 * @param message
	 * 		Reason for assembler error.
	 * @param line
	 * 		Line number relevant to the error.
	 */
	public AssemblerException(Throwable t, String message, int line) {
		super(Objects.requireNonNull(message), t);
		this.line = line;
	}

	/**
	 * @param exceptions
	 * 		Exceptions to add.
	 * @param <T>
	 * 		Type of exception.
	 */
	public <T extends LineException> void addSubExceptions(List<T> exceptions) {
		subExceptions.addAll(exceptions);
	}

	/**
	 * Since this can be a wrapper for multiple exceptions <i>(not suppressed per-say)</i> we want
	 * to access them.
	 *
	 * @return Sub exceptions.
	 */
	public List<LineException> getSubExceptions() {
		return subExceptions;
	}

	/**
	 * @return Line number relevant to the error.
	 * May be {@code -1} if it is not specific to one line.
	 */
	@Override
	public int getLine() {
		return line;
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/exception/VerifierException.java`:

```java
package me.coley.recaf.parse.bytecode.exception;

import java.util.Objects;

/**
 * Extension of {@link AssemblerException} as an identifier for verification-related assembler problems.
 */
public class VerifierException extends AssemblerException {
	/**
	 * @param message
	 * 		Reason for assembler error.
	 */
	public VerifierException(String message) {
		this(null, message, -1);
	}

	/**
	 * @param message
	 * 		Reason for assembler error.
	 * @param line
	 * 		Line number relevant to the error.
	 */
	public VerifierException(String message, int line) {
		this(null, message, line);
	}

	/**
	 * @param ex
	 * 		Cause exception.
	 * @param message
	 * 		Reason for assembler error.
	 * @param line
	 * 		Line number relevant to the error.
	 */
	public VerifierException(Exception ex, String message, int line) {
		super(ex, Objects.requireNonNull(message), line);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/AliasDeclarationParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;

/**
 * {@link AliasAST} parser.
 *
 * @author Matt
 */
public class AliasDeclarationParser extends AbstractParser<AliasAST> {
	@Override
	public AliasAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// name
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST name = nameParser.visit(lineNo, trim[1]);
			// content
			StringParser stringParser = new StringParser();
			stringParser.setOffset(line.indexOf("\""));
			StringAST content = stringParser.visit(lineNo, line.substring(line.indexOf("\"")));
			return new AliasAST(lineNo, start, op, name, content);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for var instruction");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/ArgParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;

/**
 * {@link DefinitionArgAST} parser.
 *
 * @author Matt
 */
public class ArgParser extends AbstractParser<DefinitionArgAST> {
	@Override
	public DefinitionArgAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if (!trim.matches(".+\\s+.+"))
				throw new IllegalStateException();
			int start = line.indexOf(trim);
			String[] split = trim.split("\\s+");
			String typeStr = split[0];
			String nameStr = split[1];
			DescParser descParser = new DescParser();
			descParser.setOffset(start);
			DescAST descAST = descParser.visit(lineNo, typeStr);
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(nameStr));
			NameAST nameAST = nameParser.visit(lineNo, nameStr);
			return new DefinitionArgAST(lineNo, getOffset() + start, descAST, nameAST);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for arg, expected \"<type> <name>\"");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/CommentParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.CommentAST;

/**
 * {@link CommentAST} parser.
 *
 * @author Matt
 */
public class CommentParser extends AbstractParser<CommentAST> {
	@Override
	public CommentAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			String content = trim.substring(2);
			int start = line.indexOf(trim);
			return new CommentAST(lineNo, start, content);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for comment, expected \"//\" at beginning");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/DefaultValueParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.ast.AST;
import me.coley.recaf.parse.bytecode.ast.DefaultValueAST;
import me.coley.recaf.parse.bytecode.ast.RootAST;

import java.util.Collections;
import java.util.List;

/**
 * {@link DefaultValueAST} parser.
 *
 * @author Matt
 */
public class DefaultValueParser extends AbstractParser<DefaultValueAST> {
	private static final String PREFIX = "VALUE ";

	@Override
	public DefaultValueAST visit(int lineNo, String line) throws ASTParseException {
		try {
			int offset = PREFIX.length();
			String content = line.substring(offset).trim();
			AST ast = null;
			if(content.contains("\"")) {
				// String
				StringParser parser = new StringParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			} else if(content.contains("[") || content.contains(";")) {
				// Type
				DescParser parser = new DescParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			} else if(content.endsWith("F") || content.endsWith("f")) {
				// Float
				FloatParser parser = new FloatParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			} else if(content.endsWith("L") || content.endsWith("l") ||
					  content.endsWith("J") || content.endsWith("j")) {
				// Long
				LongParser parser = new LongParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			} else if(content.contains(".")) {
				// Double
				DoubleParser parser = new DoubleParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			} else {
				// Integer
				IntParser parser = new IntParser();
				parser.setOffset(offset);
				ast = parser.visit(lineNo, content);
			}
			return new DefaultValueAST(lineNo, 0, ast);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for LDC");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/DefinitionParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.DefinitionAST;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

/**
 * Wrapper parser for all parsers using the {@code DEFINE} keyword.
 *
 * @author Matt
 * @see FieldDefinitionParser
 * @see MethodDefinitionParser
 */
public class DefinitionParser extends AbstractParser<DefinitionAST> {
	public static final String DEFINE = "DEFINE";
	public static final int DEFINE_LEN = (DEFINE + " ").length();

	@Override
	public DefinitionAST visit(int lineNo, String text) throws ASTParseException {
		if (text.contains("("))
			return new MethodDefinitionParser().visit(lineNo, text);
		else
			return new FieldDefinitionParser().visit(lineNo, text);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/DescParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AutoCompleteUtil;
import org.objectweb.asm.Type;
import me.coley.recaf.util.EscapeUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link DescAST} parser.
 *
 * @author Matt
 */
public class DescParser extends AbstractParser<DescAST> {
	@Override
	public DescAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			trim = EscapeUtil.unescape(trim);
			// Verify
			if(trim.contains("(")) {
				Type type = Type.getMethodType(trim);
				if(!validate(type.getReturnType().getDescriptor()))
					throw new ASTParseException(lineNo,
							"Invalid method return type " + type.getReturnType().getDescriptor());
				for(Type arg : type.getArgumentTypes())
					if(!validate(arg.getDescriptor()))
						throw new ASTParseException(lineNo,
								"Invalid method arg type " + arg.getDescriptor());
			} else {
				if(!validate(trim))
					throw new ASTParseException(lineNo, "Invalid field descriptor: " + trim);
			}
			// Create AST
			int start = line.indexOf(trim);
			return new DescAST(lineNo, getOffset() + start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for descriptor: " + ex.getMessage());
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if(text.contains("("))
			return Collections.emptyList();
		// Suggest field types
		return AutoCompleteUtil.descriptorName(text.trim());
	}

	private static boolean validate(String token) {
		// Void check
		if(token.equals("V"))
			return true;
		// Ensure type is not an array
		Type type = Type.getType(token);
		while(type.getSort() == Type.ARRAY)
			type = type.getElementType();
		// Check for primitives
		if(type.getSort() < Type.ARRAY)
			return true;
		// Verify L...; pattern
		// - getDescriptor doesn't modify the original element type (vs getInternalName)
		String desc = type.getDescriptor();
		return desc.startsWith("L") && desc.endsWith(";");
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/DoubleParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.NumberAST;

/**
 * {@link NumberAST} parser for doubles.
 *
 * @author Matt
 */
public class DoubleParser extends AbstractParser<NumberAST> {
	@Override
	public NumberAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			// Check standard numbers, then exponential form form if that fails
			int start = line.indexOf(trim);
			if(!trim.matches("-?[.\\d]+[Dd]?"))
				if (trim.equals("Infinity"))
					return new NumberAST(lineNo, getOffset() + start, Double.POSITIVE_INFINITY);
				else if (trim.equals("-Infinity"))
					return new NumberAST(lineNo, getOffset() + start, Double.NEGATIVE_INFINITY);
				else if (trim.equals("NaN"))
					return new NumberAST(lineNo, getOffset() + start, Double.NaN);
				else if (!trim.matches("-?[\\d.]+(?:[eE]-?\\d+)?[dD]?"))
					throw new ASTParseException(lineNo, "Invalid double: " + trim);
			return new NumberAST(lineNo, getOffset() + start, Double.valueOf(trim));
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/ExpressionParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link ExpressionAST} parser.
 *
 * @author Matt
 */
public class ExpressionParser extends AbstractParser<ExpressionAST> {
	private static final int EXPR_OFFSET = "EXPR ".length();

	@Override
	public ExpressionAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim().substring(EXPR_OFFSET);
			int start = line.indexOf(EXPR_OFFSET);
			return new ExpressionAST(lineNo, start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for expression");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/FieldDefinitionParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.ast.DefinitionModifierAST;
import me.coley.recaf.parse.bytecode.ast.DescAST;
import me.coley.recaf.parse.bytecode.ast.FieldDefinitionAST;
import me.coley.recaf.parse.bytecode.ast.NameAST;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.util.AutoCompleteUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link FieldDefinitionAST} parser.
 *
 * @author Matt
 */
public class FieldDefinitionParser extends AbstractParser<FieldDefinitionAST> {
	@Override
	public FieldDefinitionAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			// Fetch the name first, even though it appears after the access modifiers
			String[] split = trim.split("\\s+");
			if(split.length < 2)
				throw new ASTParseException(lineNo, "Bad format for FIELD, missing arguments");
			String name = split[split.length - 1];
			String desc =  split[split.length - 2];
			int nameStart = trim.lastIndexOf(name);
			int descStart = trim.lastIndexOf(" " + desc);
			int start = line.indexOf(trim);
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(nameStart);
			NameAST nameAST = nameParser.visit(lineNo, name);
			DescParser descParser = new DescParser();
			descParser.setOffset(descStart);
			DescAST descAST = descParser.visit(lineNo, desc);
			FieldDefinitionAST def = new FieldDefinitionAST(lineNo, start, nameAST, descAST);
			def.addChild(nameAST);
			// Parse access modifiers
			if (descStart > DefinitionParser.DEFINE_LEN) {
				String modifiersSection = trim.substring(DefinitionParser.DEFINE_LEN, descStart);
				while(!modifiersSection.trim().isEmpty()) {
					// Get current modifier
					start = line.indexOf(modifiersSection);
					int space = modifiersSection.indexOf(' ');
					int end = space;
					if(end == -1)
						end = modifiersSection.length();
					String modStr = modifiersSection.substring(0, end);
					// Parse modifier
					ModifierParser modifierParser = new ModifierParser();
					modifierParser.setOffset(start);
					DefinitionModifierAST modifierAST = modifierParser.visit(lineNo, modStr);
					def.addModifier(modifierAST);
					// cut section to fit next modifier
					if(space == -1)
						break;
					else
						modifiersSection = modifiersSection.substring(modStr.length()).trim();
				}
			}
			def.addChild(descAST);
			return def;
		} catch(IndexOutOfBoundsException ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for FIELD");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// If we have a space (after the FIELD part) and have not started writing the descriptor
		// then we can suggest access modifiers or the type
		if (text.contains(" ") && !text.contains(";")) {
			String[] parts = text.split("\\s+");
			String last = parts[parts.length - 1];
			if(last.charAt(0) == 'L') {
				// Complete type
				return AutoCompleteUtil.descriptorName(last);
			} else {
				// Complete modifier
				return new ModifierParser().suggest(lastParse, last);
			}
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/FieldInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AutoCompleteUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link FieldInsnAST} parser.
 *
 * @author Matt
 */
public class FieldInsnParser extends AbstractParser<FieldInsnAST> {
	@Override
	public FieldInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 3)
				throw new ASTParseException(lineNo, "Not enough parameters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// owner & name
			String typeAndName = trim[1];
			int dot = typeAndName.indexOf('.');
			if (dot == -1)
				throw new ASTParseException(lineNo, "Format error: expecting '<Owner>.<Name> <Desc>'" +
						" - missing '.'");
			String typeS = typeAndName.substring(0, dot);
			String nameS = typeAndName.substring(dot + 1);
			// owner
			TypeParser typeParser = new TypeParser();
			typeParser.setOffset(line.indexOf(typeAndName));
			TypeAST owner = typeParser.visit(lineNo, typeS);
			// name
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf('.'));
			NameAST name = nameParser.visit(lineNo, nameS);
			// desc
			DescParser descParser = new DescParser();
			descParser.setOffset(line.lastIndexOf(trim[2]));
			DescAST desc = descParser.visit(lineNo, trim[2]);
			return new FieldInsnAST(lineNo, start, op, owner, name, desc);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for field instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// DEFINE owner.name desc
		int space = text.indexOf(' ');
		if (space >= 0) {
			String sub = text.substring(space + 1);
			int dot = sub.indexOf('.');
			if (dot == -1)
				return new TypeParser().suggest(lastParse, sub);
			return AutoCompleteUtil.field(sub);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/FloatParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.NumberAST;

/**
 * {@link NumberAST} parser for floats.
 *
 * @author Matt
 */
public class FloatParser extends AbstractParser<NumberAST> {
	@Override
	public NumberAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			int start = line.indexOf(trim);
			if(!trim.matches("-?[.\\d]+[Ff]?"))
				if (trim.matches("Infinity[Ff]"))
					return new NumberAST(lineNo, getOffset() + start, Float.POSITIVE_INFINITY);
				else if (trim.matches("-Infinity[Ff]"))
					return new NumberAST(lineNo, getOffset() + start, Float.NEGATIVE_INFINITY);
				else if (trim.matches("NaN[Ff]"))
					return new NumberAST(lineNo, getOffset() + start, Float.NaN);
				else if (!trim.matches("-?[\\d.]+(?:[eE]-?\\d+)?[Ff]?"))
					throw new ASTParseException(lineNo, "Invalid float: " + trim);
			return new NumberAST(lineNo, getOffset() + start, Float.valueOf(trim));
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/HandleParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AutoCompleteUtil;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;

import java.util.List;

/**
 * {@link HandleAST} parser.
 *
 * @author Matt
 */
public class HandleParser extends AbstractParser<HandleAST> {
	// This handle is what's used 90% of the time so lets just provide a helpful alias.
	public static final Handle DEFAULT_HANDLE = new Handle(Opcodes.H_INVOKESTATIC,
			"java/lang/invoke/LambdaMetafactory",
			"metafactory",
			"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;" +
			"Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)" +
			"Ljava/lang/invoke/CallSite;", false);
	public static final String DEFAULT_HANDLE_ALIAS = "H_META";

	@Override
	public HandleAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			TagParser opParser = new TagParser();
			opParser.setOffset(line.indexOf(trim[0]));
			TagAST tag = opParser.visit(lineNo, trim[0]);
			// owner & name & desc
			String data = trim[1];
			int dot = data.indexOf('.');
			if (dot == -1)
				throw new ASTParseException(lineNo, "Format error: Missing '.' after owner type");
			// Determine split index, for field or method type
			int descSplit = data.indexOf('(');
			if(descSplit < dot) {
				descSplit = data.indexOf(' ');
				if(descSplit < dot)
					throw new ASTParseException(lineNo, "Format error: Missing valid handle descriptor");
			}
			String typeS = data.substring(0, dot);
			String nameS = data.substring(dot + 1, descSplit);
			String descS = data.substring(descSplit);
			// owner
			TypeParser typeParser = new TypeParser();
			typeParser.setOffset(line.indexOf(data));
			TypeAST owner = typeParser.visit(lineNo, typeS);
			// name
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(dot + 1);
			NameAST name = nameParser.visit(lineNo, nameS);
			// desc
			DescParser descParser = new DescParser();
			descParser.setOffset(descSplit);
			DescAST desc = descParser.visit(lineNo, descS);
			return new HandleAST(lineNo, start, tag, owner, name, desc);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for handle ");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// TAG owner.name+desc
		int space = text.indexOf(' ');
		if (space > 0) {
			String sub = text.substring(space + 1);
			int dot = sub.indexOf('.');
			if (dot == -1)
				return new TypeParser().suggest(lastParse, sub);
			// Determine if we need to suggest fields or methods based on tag
			boolean isMethod = false;
			try {
				TagParser opParser = new TagParser();
				TagAST tag = opParser.visit(0, text.substring(0, space));
				isMethod = tag.isMethod();
			} catch(Exception ex) { /* ignored */ }
			if(isMethod)
				return AutoCompleteUtil.method(sub);
			else
				return AutoCompleteUtil.field(sub);
		} else
			// No space, so must be typing the tag. Suggest tag names.
			return new TagParser().suggest(lastParse, text);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/IincInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link IincInsnAST} parser.
 *
 * @author Matt
 */
public class IincInsnParser extends AbstractParser<IincInsnAST> {
	@Override
	public IincInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 3)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// variable
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST variable = nameParser.visit(lineNo, trim[1]);
			// incr
			IntParser numParser = new IntParser();
			numParser.setOffset(line.indexOf(trim[2]));
			NumberAST incr = numParser.visit(lineNo, trim[2]);
			return new IincInsnAST(lineNo, start, op, variable, incr);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for increment instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		try {
			NameParser nameParser = new NameParser(this);
			String[] parts = text.trim().split("\\s+");
			// last word is the 'variable' portion
			if(parts.length == 2)
				return nameParser.suggest(lastParse, parts[parts.length - 1]);
		} catch(Exception ex) { /* ignored */ }
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/InsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;

/**
 * {@link InsnAST} parser.
 *
 * @author Matt
 */
public class InsnParser extends AbstractParser<InsnAST> {
	@Override
	public InsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim));
			OpcodeAST op = opParser.visit(lineNo, trim);
			int start = line.indexOf(trim);
			return new InsnAST(lineNo, start, op);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for basic instruction");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/IntInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.util.TypeUtil;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * {@link IntInsnAST} parser.
 *
 * @author Matt
 */
public class IntInsnParser extends AbstractParser<IntInsnAST> {
	@Override
	public IntInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// TODO: For NEWARRAY, using types instead of magic number values would be intuitive
			String valueStr = trim[1];
			int valueStrStart = line.indexOf(valueStr);
			NumberAST num = null;
			if (op.getOpcode() == Opcodes.NEWARRAY) {
				// Type to value
				DescParser descParser = new DescParser();
				descParser.setOffset(line.indexOf(valueStr));
				DescAST desc = descParser.visit(lineNo, valueStr);
				if (!TypeUtil.isPrimitiveDesc(desc.getDesc())) {
					throw new ASTParseException(lineNo, "Expected primitive descriptor for NEWARRAY");
				}
				num = new NumberAST(lineNo, valueStrStart,
						TypeUtil.typeToNewArrayArg(Type.getType(desc.getDesc())));
			} else {
				// Value
				IntParser numParser = new IntParser();
				numParser.setOffset(valueStrStart);
				num = numParser.visit(lineNo, valueStr);
			}
			return new IntInsnAST(lineNo, start, op, num);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for int instruction");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/IntParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;

/**
 * {@link NumberAST} parser for integers.
 *
 * @author Matt
 */
public class IntParser extends AbstractParser<NumberAST> {
	@Override
	public NumberAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if(!trim.matches("-?\\d+"))
				throw new ASTParseException(lineNo, "Invalid integer: " + trim);
			int start = line.indexOf(trim);
			return new NumberAST(lineNo, getOffset() + start, Integer.valueOf(trim));
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number, value not a valid int");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/InvokeDynamicParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.RegexUtil;

import java.util.*;

/**
 * {@link InvokeDynamicAST} parser.
 *
 * @author Matt
 */
public class InvokeDynamicParser extends AbstractParser<InvokeDynamicAST> {
	private static String BRACKET_WRAPPING = "\\w*\\[.+]";
	private static String BRACKET_WRAPPING_OR_EMPTY = "\\w*\\[.*]";

	@Override
	public InvokeDynamicAST visit(int lineNo, String line) throws ASTParseException {
		try {
			// Split here:
			//              v    v    v
			// INVOKEDYNAMIC name desc handle[...] args[...]
			String[] trim = line.trim().split("\\s+(?=.*\\[(?=.*\\[))");
			if (trim.length < 4)
				throw new ASTParseException(lineNo, "Not enough paramters");
			// 0 = op
			// 1 = name
			// 2 = desc
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// name
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST name = nameParser.visit(lineNo, trim[1]);
			// desc
			DescParser descParser = new DescParser();
			descParser.setOffset(line.indexOf(trim[2]));
			DescAST desc = descParser.visit(lineNo, trim[2]);
			// handle & args
			// - Split space between handle and args
			trim = line.substring(RegexUtil.indexOf("(?:(?<=\\s)handle|handle|\\s)\\[\\s*H_", line))
					.split("(?<=\\])\\s+(?=.*\\[)");
			// handle
			String handleS = trim[0];
			if (!handleS.matches(BRACKET_WRAPPING))
				throw new ASTParseException(lineNo, "Invalid handle, require wrapping in '[' and ']'");
			handleS = handleS.substring(handleS.indexOf('[') + 1, handleS.indexOf(']'));
			HandleParser handleParser = new HandleParser();
			handleParser.setOffset(line.indexOf(trim[0]));
			HandleAST handle = handleParser.visit(lineNo, handleS);
			// args
			String argsS = trim[1];
			if (!argsS.matches(BRACKET_WRAPPING_OR_EMPTY))
				throw new ASTParseException(lineNo, "Invalid args, require wrapping in '[' and ']'");
			argsS = argsS.substring(argsS.indexOf('[') + 1, argsS.lastIndexOf(']'));
			// if the args has a string with commas, this will break...
			// we'll fix that whenever it happens
			List<AST> args = new ArrayList<>();
			if (!argsS.isEmpty()) {
				String[] argsSplit = argsS.split(",\\s*(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)");
				for(String arg : argsSplit) {
					AST ast = parseArg(lineNo, arg);
					if(ast == null)
						throw new ASTParseException(lineNo, "Failed parsing BSM arg: " + arg);
					args.add(ast);
				}
			}
			return new InvokeDynamicAST(lineNo, start, op, name, desc, handle, args);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for invokedynamic instruction");
		}
	}

	/**
	 * @param lineNo
	 * 		Line number.
	 * @param arg
	 * 		Arg text.
	 *
	 * @return BSM arg ast value.
	 *
	 * @throws ASTParseException
	 * 		When the arg cannot be parsed.
	 */
	private static AST parseArg(int lineNo, String arg) throws ASTParseException {
		AbstractParser parser = null;
		if(arg.contains("\""))
			parser = new StringParser();
		else if(arg.matches("-?\\d+"))
			parser = new IntParser();
		else if(arg.matches("-?\\d+[LlJj]?"))
			parser = new LongParser();
		else if(arg.matches("-?\\d+\\.\\d+[Ff]?"))
			parser = new FloatParser();
		else if(arg.matches("-?\\d+\\.\\d+[Dd]?"))
			parser = new DoubleParser();
		else if(arg.matches(BRACKET_WRAPPING)) {
			parser = new HandleParser();
			arg = arg.substring(arg.indexOf('[') + 1, arg.indexOf(']'));
		} else
			parser = new DescParser();
		return parser.visit(lineNo, arg);
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// INVOKEDYNAMIC name desc handle[...] args[...]
		//  - Can only really suggest the handle...
		int b1 = text.indexOf('[');
		int b2 = text.lastIndexOf('[');
		if(b1 == -1)
			// not at handle yet
			return Collections.emptyList();
		else if(b2 != b1)
			// past handle, at args
			return Collections.emptyList();
		else
			// in the handle
			return new HandleParser().suggest(lastParse, text.substring(b1 + 1));
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/JumpInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link JumpInsnAST} parser.
 *
 * @author Matt
 */
public class JumpInsnParser extends AbstractParser<JumpInsnAST> {
	@Override
	public JumpInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// label
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST label = nameParser.visit(lineNo, trim[1]);
			return new JumpInsnAST(lineNo, start, op, label);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for var instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if (text.contains(" ")) {
			String[] parts = text.split("\\s+");
			return new NameParser(this).suggest(lastParse, parts[parts.length - 1]);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/LabelParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.*;

/**
 * {@link LabelAST} parser.
 *
 * @author Matt
 */
public class LabelParser extends AbstractParser<LabelAST> {
	@Override
	public LabelAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			String name = trim.substring(0, trim.indexOf(':'));
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(name));
			NameAST ast = nameParser.visit(lineNo, name);
			int start = line.indexOf(trim);
			return new LabelAST(lineNo, start, ast);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for label, expected colon(:) at end");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/LdcInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link TypeAST} parser.
 *
 * @author Matt
 */
public class LdcInsnParser extends AbstractParser<LdcInsnAST> {
	@Override
	public LdcInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			int ti = line.indexOf(trim);
			int space = line.indexOf(' ');
			String opS = trim.substring(0, space);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(opS));
			OpcodeAST op = opParser.visit(lineNo, opS);
			// content
			String content = trim.substring(space + 1);
			AST ast = null;
			if(content.contains("\"")) {
				// String
				StringParser parser = new StringParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			} else if(content.contains("H_") && content.contains("]")) {
				// Handle
				HandleParser parser = new HandleParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content.substring(content.indexOf('[') + 1, content.lastIndexOf(']')));
			} else if(content.startsWith("(") || content.contains("[") || content.contains(";")) {
				// Type
				DescParser parser = new DescParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			} else if(content.matches("-?(?:(?:Infinity|NaN)|-?(?:\\d+\\.\\d+))[Ff]") ||
					content.matches("-?[\\d.]+[eE](?:-?\\d+)?[Ff]")) {
				// Float
				FloatParser parser = new FloatParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			} else if(content.matches("-?\\d+[LlJj]")) {
				// Long
				LongParser parser = new LongParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			} else if(content.matches("-?(?:Infinity|NaN)|-?(?:\\d+\\.\\d+[Dd]?)") ||
					content.matches("-?[\\d.]+[eE](?:-?\\d+)?[dD]?")) {
				// Double
				DoubleParser parser = new DoubleParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			} else {
				// Integer
				IntParser parser = new IntParser();
				parser.setOffset(ti + space + 1);
				ast = parser.visit(lineNo, content);
			}
			return new LdcInsnAST(lineNo, ti, op, ast);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for LDC");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// Attempt to complete content for Type values
		if (text.contains(" ") && !text.contains("\"")) {
			String[] parts = text.split("\\s+");
			return new TypeParser().suggest(lastParse, parts[parts.length - 1]);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/LineInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link LineInsnAST} parser.
 *
 * @author Matt
 */
public class LineInsnParser extends AbstractParser<LineInsnAST> {
	@Override
	public LineInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 3)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// label
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST label = nameParser.visit(lineNo, trim[1]);
			// line
			IntParser numParser = new IntParser();
			numParser.setOffset(line.indexOf(trim[2]));
			NumberAST lineNum = numParser.visit(lineNo, trim[2]);
			return new LineInsnAST(lineNo, start, op, label, lineNum);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for line-number instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// LINE label number
		if (text.contains(" ")) {
			String[] parts = text.split("\\s+");
			// Only complete if we're on the label portion
			if (parts.length == 2)
				return new NameParser(this).suggest(lastParse, parts[parts.length - 1]);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/LongParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.NumberAST;

/**
 * {@link NumberAST} parser for longs.
 *
 * @author Matt
 */
public class LongParser extends AbstractParser<NumberAST> {
	@Override
	public NumberAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if(!trim.matches("-?\\d+[LlJj]?"))
				if (!trim.matches("-?[\\d.]+(?:[eE]-?\\d+)?[LlJj]?"))
					throw new ASTParseException(lineNo, "Invalid long: " + trim);
			char last = trim.charAt(trim.length() - 1);
			if (!(last > '0' && last < '9'))
				trim = trim.substring(0, trim.length() - 1);
			int start = line.indexOf(trim);
			return new NumberAST(lineNo, getOffset() + start, Long.valueOf(trim));
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/LookupSwitchInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.RegexUtil;

import java.util.*;

/**
 * {@link TableSwitchInsnAST} parser.
 *
 * @author Matt
 */
public class LookupSwitchInsnParser extends AbstractParser<LookupSwitchInsnAST> {
	@Override
	public LookupSwitchInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			String opS = RegexUtil.getFirstWord(trim);
			if (opS == null)
				throw new ASTParseException(lineNo, "Missing TABLESWITCH opcode");
			int start = line.indexOf(opS);
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(start);
			OpcodeAST op = opParser.visit(lineNo, opS);
			// Collect parameters
			String[] data = RegexUtil.allMatches(line, "(?<=\\[).*?(?=\\])");
			if (data.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			// mapping
			String mapS = data[0];
			Map<NumberAST, NameAST> mapping = new LinkedHashMap<>();
			if (!mapS.isEmpty()) {
				NameParser nameParser = new NameParser(this);
				IntParser intParser = new IntParser();
				String[] mapS2 = mapS.split(",\\s*");
				for (String map : mapS2) {
					// map: Value=Label
					if (!map.contains("="))
						throw new ASTParseException(lineNo, "Invalid mapping format, expected: <Value>=<Label>");
					nameParser.setOffset(line.indexOf(map));
					intParser.setOffset(line.indexOf(map));
					String[] mapKV = map.split("=");
					mapping.put(intParser.visit(lineNo, mapKV[0]), nameParser.visit(lineNo, mapKV[1]));
				}
			}
			// dflt
			String dfltS = data[1];
			if (mapS.isEmpty()) {
				// Handle case where mapping is empty
				dfltS = trim.substring(trim.lastIndexOf('[') + 1, trim.lastIndexOf(']'));
			}
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.lastIndexOf(dfltS));
			NameAST dflt = nameParser.visit(lineNo, dfltS);
			return new LookupSwitchInsnAST(lineNo, start, op, mapping, dflt);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for table-switch instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if (text.matches(".*[\\[=]\\w+")) {
			String last = RegexUtil.getLastToken("\\w+", text);
			return new NameParser(this).suggest(lastParse, last);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/MethodDefinitionParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link MethodDefinitionAST} parser.
 *
 * @author Matt
 */
public class MethodDefinitionParser extends AbstractParser<MethodDefinitionAST> {
	@Override
	public MethodDefinitionAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if(!trim.matches(".+(.*).+"))
				throw new ASTParseException(lineNo, "Bad format for DEFINE, bad method descriptor");
			// Fetch the name first, even though it appears after the access modifiers
			String name = trim.substring(0, trim.indexOf('('));
			int nameStart = name.lastIndexOf(' ') + 1;
			name = name.substring(nameStart);
			int descStart = line.indexOf(')') + 1;
			String desc = line.substring(descStart);
			int start = line.indexOf(trim);
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(nameStart);
			NameAST nameAST = nameParser.visit(lineNo, name);
			DescParser descParser = new DescParser();
			descParser.setOffset(descStart);
			DescAST descAST = descParser.visit(lineNo, desc);
			MethodDefinitionAST def = new MethodDefinitionAST(lineNo, start, nameAST, descAST);
			def.addChild(nameAST);
			// Parse access modifiers
			String modifiersSection = trim.substring(DefinitionParser.DEFINE_LEN, nameStart);
			while(!modifiersSection.trim().isEmpty()) {
				// Get current modifier
				start = line.indexOf(modifiersSection);
				int space = modifiersSection.indexOf(' ');
				int end = space;
				if (end == -1)
					end = modifiersSection.length();
				String modStr = modifiersSection.substring(0, end);
				// Parse modifier
				ModifierParser modifierParser = new ModifierParser();
				modifierParser.setOffset(start);
				DefinitionModifierAST modifierAST = modifierParser.visit(lineNo, modStr);
				def.addModifier(modifierAST);
				// cut section to fit next modifier
				if (space == -1)
					break;
				else
					modifiersSection = modifiersSection.substring(modStr.length()).trim();
			}
			// Parse argument types
			String argsSection = trim.substring(trim.indexOf('(') + 1, trim.indexOf(')'));
			while(!argsSection.trim().isEmpty()) {
				// Get current arg
				int comma = argsSection.indexOf(',');
				int end = comma;
				if(end == -1)
					end = argsSection.length();
				start = line.indexOf(argsSection);
				String argString = argsSection.substring(0, end);
				// Parse arg
				ArgParser argParser = new ArgParser();
				argParser.setOffset(start);
				DefinitionArgAST argAST = argParser.visit(lineNo, argString);
				def.addArgument(argAST);
				// cut section to fit next arg
				if(comma == -1)
					break;
				else
					argsSection = argsSection.substring(end + 1).trim();
			}
			def.addChild(descAST);
			return def;
		} catch(IndexOutOfBoundsException ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for DEFINE");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// If we have a space (after the DEFINE part) and have not started writing the descriptor
		// then we can suggest access modifiers
		if (text.contains(" ") && !text.contains("(")) {
			String[] parts = text.split("\\s+");
			return new ModifierParser().suggest(lastParse, parts[parts.length - 1]);
		}
		// TODO: Arg desc suggestions
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/MethodInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AutoCompleteUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link MethodInsnAST} parser.
 *
 * @author Matt
 */
public class MethodInsnParser extends AbstractParser<MethodInsnAST> {
	@Override
	public MethodInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// owner & name & desc
			String data = trim[1];
			int dot = data.indexOf('.');
			if (dot == -1)
				throw new ASTParseException(lineNo, "Format error: expecting '<Owner>.<Name><Desc>'" +
						" - missing '.'");
			int parenthesis = data.indexOf('(');
			if (parenthesis < dot)
				throw new ASTParseException(lineNo, "Format error: Missing valid method descriptor");
			String typeS = data.substring(0, dot);
			String nameS = data.substring(dot + 1, parenthesis);
			String descS = data.substring(parenthesis);
			// owner
			TypeParser typeParser = new TypeParser();
			typeParser.setOffset(line.indexOf(data));
			TypeAST owner = typeParser.visit(lineNo, typeS);
			// name
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf('.'));
			NameAST name = nameParser.visit(lineNo, nameS);
			// desc
			DescParser descParser = new DescParser();
			descParser.setOffset(line.indexOf('('));
			DescAST desc = descParser.visit(lineNo, descS);
			return new MethodInsnAST(lineNo, start, op, owner, name, desc);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for method instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// METHOD owner.name+desc
		int space = text.indexOf(' ');
		if (space >= 0) {
			String sub = text.substring(space + 1);
			int dot = sub.indexOf('.');
			if (dot == -1)
				return new TypeParser().suggest(lastParse, sub);
			return AutoCompleteUtil.method(sub);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/ModifierParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AccessFlag;

import java.util.*;
import java.util.stream.Collectors;

/**
 * {@link DefinitionModifierAST} parser.
 *
 * @author Matt
 */
public class ModifierParser extends AbstractParser<DefinitionModifierAST> {
	private static final List<String> ALLOWED_NAMES = Arrays.stream(AccessFlag.values())
			.map(AccessFlag::getName)
			.collect(Collectors.toList());

	@Override
	public DefinitionModifierAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim().toLowerCase();
			if(!ALLOWED_NAMES.contains(trim))
				throw new ASTParseException(lineNo, "Illegal method modifier '" + trim + "'");
			int start = line.indexOf(trim);
			return new DefinitionModifierAST(lineNo, getOffset() + start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for modifier");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		String trim = text.trim();
		return ALLOWED_NAMES.stream().filter(n -> n.startsWith(trim)).collect(Collectors.toList());
	}

}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/MultiArrayParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link MultiArrayInsnAST} parser.
 *
 * @author Matt
 */
public class MultiArrayParser extends AbstractParser<MultiArrayInsnAST> {
	@Override
	public MultiArrayInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// desc
			DescParser descParser = new DescParser();
			descParser.setOffset(line.indexOf(trim[1]));
			DescAST type = descParser.visit(lineNo, trim[1]);
			// dims
			IntParser numParser = new IntParser();
			numParser.setOffset(line.indexOf(trim[2]));
			NumberAST dims = numParser.visit(lineNo, trim[2]);
			return new MultiArrayInsnAST(lineNo, start, op, type, dims);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for MultiANewArray instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// MULTI type number
		if (text.contains(" ")) {
			String[] parts = text.split("\\s+");
			// Only complete if we're on the type portion
			if (parts.length == 2)
				return new DescParser().suggest(lastParse, parts[parts.length - 1]);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/NameParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.EscapeUtil;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * {@link NameAST} parser.
 *
 * @author Matt
 */
public class NameParser extends AbstractParser<NameAST> {
	/**
	 * Create name parser with parent context.
	 *
	 * @param parent
	 * 		Parent parser.
	 */
	public NameParser(AbstractParser parent) {
		super(parent);
	}

	@Override
	public NameAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if (trim.isEmpty())
				throw new ASTParseException(lineNo, "Name cannot be empty!");
			trim = EscapeUtil.unescape(trim);
			int start = line.indexOf(trim);
			return new NameAST(lineNo, getOffset() + start, trim);
		} catch (Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for name");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// No context of last parse, can't pull names from last parsed AST
		// No context parent parser, unsure what to suggest
		if (lastParse == null || parent == null)
			return Collections.emptyList();
		// Complete labels if we belong to a label parser
		boolean tableParent = parent instanceof TableSwitchInsnParser || parent instanceof LookupSwitchInsnParser;
		if (parent instanceof TryCatchParser || parent instanceof JumpInsnParser || parent instanceof LineInsnParser
			|| tableParent) {
			return lastParse.getRoot().search(LabelAST.class).stream()
					.map(l -> l.getName().getName())
					.filter(n -> n.startsWith(text))
					.collect(Collectors.toList());
		}
		// Complete variable names if we belong to a variable parser
		else if (parent instanceof VarInsnParser || parent instanceof IincInsnParser) {
			return lastParse.getRoot().search(NameAST.class).stream()
					.filter(ast -> ast.getName().startsWith(text))
					.filter(ast -> ast.getParent() instanceof VarInsnAST || ast.getParent() instanceof DefinitionArgAST)
					.map(NameAST::getName)
					.distinct()
					.sorted()
					.collect(Collectors.toList());
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/NumericParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

/**
 * {@link NumberAST} parser.
 *
 * @author Matt
 */
public class NumericParser extends AbstractParser<NumberAST> {
	@Override
	public NumberAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String content = line.trim();
			NumberAST ast = null;
			if(content.endsWith("F") || content.endsWith("f")) {
				// Float
				FloatParser parser = new FloatParser();
				ast = parser.visit(lineNo, content);
			} else if(content.endsWith("L") || content.endsWith("l") ||
					  content.endsWith("J") || content.endsWith("j")) {
				// Long
				LongParser parser = new LongParser();
				ast = parser.visit(lineNo, content);
			} else if(content.contains(".")) {
				// Double
				DoubleParser parser = new DoubleParser();
				ast = parser.visit(lineNo, content);
			} else {
				// Integer
				IntParser parser = new IntParser();
				ast = parser.visit(lineNo, content);
			}
			return ast;
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/OpcodeParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.OpcodeUtil;

import java.util.*;
import java.util.stream.Collectors;

/**
 * {@link OpcodeAST} parser.
 *
 * @author Matt
 */
public class OpcodeParser extends AbstractParser<OpcodeAST> {
	public static final Set<String> ALLOWED_NAMES = OpcodeUtil.getInsnNames();

	@Override
	public OpcodeAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim().toUpperCase();
			if(!ALLOWED_NAMES.contains(trim))
				throw new ASTParseException(lineNo, "Illegal opcode '" + trim + "'");
			int start = line.indexOf(trim);
			return new OpcodeAST(lineNo, getOffset() + start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for opcode");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		String trim = text.trim();
		return ALLOWED_NAMES.stream().filter(n -> n.startsWith(trim)).collect(Collectors.toList());
	}

}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/SignatureParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.ast.SignatureAST;
import me.coley.recaf.util.AutoCompleteUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link SignatureAST} parser.
 *
 * @author Matt
 */
public class SignatureParser extends AbstractParser<SignatureAST> {
	@Override
	public SignatureAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			String sig = trim[1];
			// TODO: Verify signature?
			//  - Technically you can put in garbage data in here...
			// Create AST
			int start = line.indexOf(sig);
			return new SignatureAST(lineNo, getOffset() + start, sig);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for descriptor");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if(text.contains("("))
			return Collections.emptyList();
		// Suggest field types
		return AutoCompleteUtil.descriptorName(text.trim());
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/StringParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.AbstractParser;
import me.coley.recaf.parse.bytecode.ast.StringAST;

/**
 * {@link StringAST} parser.
 *
 * @author Matt
 */
public class StringParser extends AbstractParser<StringAST> {
	@Override
	public StringAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			if(!(trim.charAt(0) == '"' && trim.charAt(trim.length() - 1) == '"'))
				throw new ASTParseException(lineNo, "Invalid string: " + trim);
			int start = line.indexOf(trim);
			return new StringAST(lineNo, getOffset() + start, trim.substring(1, trim.length() - 1));
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for number");
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/TableSwitchInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.RegexUtil;

import java.util.*;

/**
 * {@link TableSwitchInsnAST} parser.
 *
 * @author Matt
 */
public class TableSwitchInsnParser extends AbstractParser<TableSwitchInsnAST> {
	@Override
	public TableSwitchInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			String opS = RegexUtil.getFirstWord(trim);
			if (opS == null)
				throw new ASTParseException(lineNo, "Missing TABLESWITCH opcode");
			int start = line.indexOf(opS);
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(start);
			OpcodeAST op = opParser.visit(lineNo, opS);
			// Collect parameters
			String[] data = RegexUtil.allMatches(line, "(?<=\\[).*?(?=\\])");
			if (data.length < 3)
				throw new ASTParseException(lineNo, "Not enough paramters");
			// min & max
			String minMaxS = data[0];
			if (!minMaxS.contains(":"))
				throw new ASTParseException(lineNo, "Bad range format, expected <MIN>:<MAX>");
			int minMaxStart = line.indexOf(minMaxS);
			String[] minMaxS2 = minMaxS.split(":");
			IntParser intParser = new IntParser();
			intParser.setOffset(minMaxStart);
			NumberAST min = intParser.visit(lineNo, minMaxS2[0]);
			NumberAST max = intParser.visit(lineNo, minMaxS2[1]);
			// labels
			List<NameAST> labels = new ArrayList<>();
			String labelsS = data[1];
			int labelsStart = line.indexOf(labelsS);
			NameParser parser = new NameParser(this);
			String[] labelsS2 = labelsS.split(",\\s*");
			for (String name : labelsS2) {
				parser.setOffset(labelsStart + labelsS.indexOf(name));
				labels.add(parser.visit(lineNo, name));
			}
			// dflt
			String dfltS = data[2];
			parser.setOffset(line.lastIndexOf(dfltS));
			NameAST dflt = parser.visit(lineNo, dfltS);
			return new TableSwitchInsnAST(lineNo, start, op, min, max, labels, dflt);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for table-switch instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if (text.contains(" ")) {
			String last = RegexUtil.getLastToken("\\w+", text);
			return new NameParser(this).suggest(lastParse, last);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/TagParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.OpcodeUtil;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * {@link TagAST} parser.
 *
 * @author Matt
 */
public class TagParser extends AbstractParser<TagAST> {
	private static final Set<String> ALLOWED_NAMES = OpcodeUtil.getTagNames();

	@Override
	public TagAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim().toUpperCase();
			if(!ALLOWED_NAMES.contains(trim))
				throw new ASTParseException(lineNo, "Illegal tag '" + trim + "'");
			int start = line.indexOf(trim);
			return new TagAST(lineNo, getOffset() + start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for tag");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		String trim = text.trim();
		return ALLOWED_NAMES.stream().filter(n -> n.startsWith(trim)).collect(Collectors.toList());
	}

}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/ThrowsParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link ThrowsAST} parser.
 *
 * @author Matt
 */
public class ThrowsParser extends AbstractParser<ThrowsAST> {
	private static final int THROWS_LEN = "THROWS ".length();

	@Override
	public ThrowsAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			int start = line.indexOf(trim);
			// Sub-parser, set offset so it starts after THROWS's ' ', so error reporting yields
			// the correct character offset.
			TypeParser typeParser = new TypeParser();
			typeParser.setOffset(start + THROWS_LEN);
			TypeAST type = typeParser.visit(lineNo, trim.substring(THROWS_LEN));
			return new ThrowsAST(lineNo, start, type);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for THROWS");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if (text.length() <= THROWS_LEN)
			return Collections.emptyList();
		return new TypeParser().suggest(lastParse, text.substring(THROWS_LEN));
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/TryCatchParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.RegexUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link ThrowsAST} parser.
 *
 * @author Matt
 */
public class TryCatchParser extends AbstractParser<TryCatchAST> {
	private static final int TRY_LEN = "TRY ".length();

	@Override
	public TryCatchAST visit(int lineNo, String line) throws ASTParseException {
		try {
			// TRY start end CATCH(type) handler
			String trim = line.trim();
			int start = line.indexOf(trim);
			NameParser nameParser = new NameParser(this);
			if (!trim.contains("CATCH"))
				throw new ASTParseException(lineNo, "Missing CATCH(<type>) <handler>");
			int catchIndex = trim.indexOf("CATCH");
			String[] parts = trim.substring(0, catchIndex).split("\\s+");
			// 0 = TRY
			// 1 = start
			// 2 = end
			NameAST lblStart = nameParser.visit(lineNo, parts[1]);
			nameParser.setOffset(start + TRY_LEN);
			nameParser.setOffset(trim.indexOf(parts[2]));
			NameAST lblEnd = nameParser.visit(lineNo, parts[2]);
			// parse type
			String typeS = RegexUtil.getFirstToken("(?<=\\().+(?=\\))", trim);
			if (typeS == null)
				throw new ASTParseException(lineNo, "Missing type in CATCH(<type>)");
			typeS = typeS.trim();
			TypeAST type = null;
			if (!typeS.equals("*")) {
				TypeParser typeParser = new TypeParser();
				typeParser.setOffset(line.indexOf(typeS));
				type = typeParser.visit(lineNo, typeS.trim());
			} else {
				// Wildcard, type is null internally
				type = new TypeAST(lineNo, line.indexOf(typeS), "*") {
					@Override
					public String getType() {
						return null;
					}
				};
			}
			// handler label
			int typeEnd = trim.indexOf(')');
			nameParser.setOffset(typeEnd + 1);
			NameAST lblHandler = nameParser.visit(lineNo, trim.substring(typeEnd + 1).trim());
			return new TryCatchAST(lineNo, start, lblStart, lblEnd, type, lblHandler);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for TRY");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		// Suggest exception type
		int start = text.indexOf('(') + 1;
		int end = text.indexOf(')');
		if (start > 0 && end == -1) {
			String type = text.substring(start).trim();
			return new TypeParser().suggest(lastParse, type);
		}
		// No context of last parse, can't pull names from last parsed AST
		if(lastParse == null)
			return Collections.emptyList();
		// Suggest label names
		try {
			String trim = text.trim();
			NameParser nameParser = new NameParser(this);
			String[] parts = trim.split("\\s+");
			return nameParser.suggest(lastParse, parts[parts.length - 1]);
		} catch(Exception ex) {
			return Collections.emptyList();
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/TypeInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link TypeInsnAST} parser.
 *
 * @author Matt
 */
public class TypeInsnParser extends AbstractParser<TypeInsnAST> {
	@Override
	public TypeInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// type
			TypeParser typeParser = new TypeParser();
			typeParser.setOffset(line.indexOf(trim[1]));
			TypeAST type = typeParser.visit(lineNo, trim[1]);
			return new TypeInsnAST(lineNo, start, op, type);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for type instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		if (text.contains(" ")) {
			String[] parts = text.split("\\s+");
			return new TypeParser().suggest(lastParse, parts[parts.length - 1]);
		}
		return Collections.emptyList();
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/TypeParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.ast.TypeAST;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.util.AutoCompleteUtil;
import me.coley.recaf.util.EscapeUtil;

import java.util.Collections;
import java.util.List;

/**
 * {@link TypeAST} parser.
 *
 * @author Matt
 */
public class TypeParser extends AbstractParser<TypeAST> {
	@Override
	public TypeAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String trim = line.trim();
			trim = EscapeUtil.unescape(trim);
			if (trim.charAt(0) == '[') {
				// Handle array types
				if (!trim.matches("\\S+"))
					throw new ASTParseException(lineNo, "Name cannot contain whitespace characters");
			} else {
				// Handle normal types, cannot have any '[' or ';' in it
				if(!trim.matches("[^\\[;]+"))
					throw new ASTParseException(lineNo, "Contains illegal characters");
				if (!trim.matches("\\S+"))
					throw new ASTParseException(lineNo, "Name cannot contain whitespace characters");
			}
			int start = line.indexOf(trim);
			return new TypeAST(lineNo, getOffset() + start, trim);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for type");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		String trim = text.trim();
		if (trim.isEmpty())
			return Collections.emptyList();
		return AutoCompleteUtil.internalName(trim);
	}
}

```

`src/main/java/me/coley/recaf/parse/bytecode/parser/VarInsnParser.java`:

```java
package me.coley.recaf.parse.bytecode.parser;

import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;

import java.util.Collections;
import java.util.List;

/**
 * {@link VarInsnAST} parser.
 *
 * @author Matt
 */
public class VarInsnParser extends AbstractParser<VarInsnAST> {
	@Override
	public VarInsnAST visit(int lineNo, String line) throws ASTParseException {
		try {
			String[] trim = line.trim().split("\\s+");
			if (trim.length < 2)
				throw new ASTParseException(lineNo, "Not enough paramters");
			int start = line.indexOf(trim[0]);
			// op
			OpcodeParser opParser = new OpcodeParser();
			opParser.setOffset(line.indexOf(trim[0]));
			OpcodeAST op = opParser.visit(lineNo, trim[0]);
			// variable
			NameParser nameParser = new NameParser(this);
			nameParser.setOffset(line.indexOf(trim[1]));
			NameAST variable = nameParser.visit(lineNo, trim[1]);
			return new VarInsnAST(lineNo, start, op, variable);
		} catch(Exception ex) {
			throw new ASTParseException(ex, lineNo, "Bad format for var instruction");
		}
	}

	@Override
	public List<String> suggest(ParseResult<RootAST> lastParse, String text) {
		try {
			NameParser nameParser = new NameParser(this);
			String[] parts = text.trim().split("\\s+");
			return nameParser.suggest(lastParse, parts[parts.length - 1]);
		} catch(Exception ex) {
			return Collections.emptyList();
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/javadoc/DocField.java`:

```java
package me.coley.recaf.parse.javadoc;

import java.util.List;

/**
 * Javadoc field wrapper.
 *
 * @author Matt
 */
public class DocField extends DocMember {
	private String type;

	/**
	 * @param modifiers
	 * 		Field's access modifiers.
	 * @param name
	 * 		Field's name.
	 * @param description
	 * 		Field's purpose.
	 * @param type
	 * 		Field's declared type.
	 */
	public DocField(List<String> modifiers, String name, String description, String type) {
		super(modifiers, name, description);
		this.type = type;
	}

	/**
	 * @return Field's declared type.
	 */
	public String getType() {
		return type;
	}
}
```

`src/main/java/me/coley/recaf/parse/javadoc/DocMember.java`:

```java
package me.coley.recaf.parse.javadoc;

import java.util.List;

/**
 * Base javadoc member wrapper.
 *
 * @author Matt
 */
public class DocMember {
	private List<String> modifiers;
	private String name;
	private String description;

	/**
	 * @param modifiers
	 * 		Member's access modifiers.
	 * @param name
	 * 		Member's name.
	 * @param description
	 * 		Member's purpose.
	 */
	DocMember(List<String> modifiers, String name, String description) {
		this.modifiers = modifiers;
		this.name = name;
		this.description = description;
	}

	/**
	 * @return Member's name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Member's purpose.
	 */
	public String getDescription() {
		return description;
	}

	/**
	 * @return Access modifiers of the member.
	 */
	public List<String> getModifiers() {
		return modifiers;
	}
}
```

`src/main/java/me/coley/recaf/parse/javadoc/DocMethod.java`:

```java
package me.coley.recaf.parse.javadoc;

import java.util.List;

/**
 * Javadoc method wrapper.
 *
 * @author Matt
 */
public class DocMethod extends DocMember {
	private final String returnType;
	private final String returnDescription;
	private final List<DocParameter> parameters;

	/**
	 * @param modifiers
	 * 		Method's access modifiers.
	 * @param name
	 * 		Method's name.
	 * @param description
	 * 		Method's purpose.
	 * @param returnType
	 * 		Method's declared type.
	 * @param returnDescription
	 * 		Method's return value purpose.
	 * @param parameters
	 * 		Method's parameter information.
	 */
	public DocMethod(List<String> modifiers, String name, String description,
					 String returnDescription, String returnType,
					 List<DocParameter> parameters) {
		super(modifiers, name, description);
		if (returnDescription == null || returnDescription.trim().isEmpty())
			returnDescription = "n/a";
		this.returnType = returnType;
		this.returnDescription = returnDescription;
		this.parameters = parameters;
	}

	/**
	 * @return Method's return type.
	 */
	public String getReturnType() {
		return returnType;
	}

	/**
	 * @return Method's return value purpose.
	 */
	public String getReturnDescription() {
		return returnDescription;
	}

	/**
	 * @return Method's parameter information.
	 */
	public List<DocParameter> getParameters() {
		return parameters;
	}
}
```

`src/main/java/me/coley/recaf/parse/javadoc/DocParameter.java`:

```java
package me.coley.recaf.parse.javadoc;

/**
 * Javadoc method parameter wrapper.
 *
 * @author Matt
 */
public class DocParameter {
	// TODO: Record type?
	// - Given as signature types, generics don't have inlined type information
	// - Generally seems like a pain
	private final String name;
	private final String description;

	/**
	 * @param name
	 * 		Parameter's name.
	 * @param description
	 * 		Parameter's purpose.
	 */
	public DocParameter(String name, String description) {
		this.name = name;
		this.description = description;
	}

	/**
	 * @return Parameter's name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Parameter's purpose.
	 */
	public String getDescription() {
		return description;
	}
}

```

`src/main/java/me/coley/recaf/parse/javadoc/DocumentationParseException.java`:

```java
package me.coley.recaf.parse.javadoc;

import org.jsoup.parser.ParseErrorList;

/**
 * Wrapper for jsoup parse error list.
 *
 * @author Matt
 */
public class DocumentationParseException extends Exception {
	private final String html;
	private final ParseErrorList errors;

	/**
	 * @param html The offending HTML.
	 * @param errors JSoup error list for the given html.
	 */
	public DocumentationParseException(String html, ParseErrorList errors) {
		this.html = html;
		this.errors = errors;
	}

	/**
	 * @return The offending HTML.
	 */
	public String getHtml() {
		return html;
	}

	/**
	 * @return JSoup error list for the given html.
	 */
	public ParseErrorList getErrors() {
		return errors;
	}
}

```

`src/main/java/me/coley/recaf/parse/javadoc/FormattingVisitor.java`:

```java
package me.coley.recaf.parse.javadoc;


import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.NodeVisitor;

/**
 * Breadth-first DOM visitor that builds a formatted string based on the visited content.
 *
 * @author Jonathan Hedley, jonathan@hedley.net - <a href="https://github.com/jhy/jsoup/blob/master/src/main/java/org/jsoup/examples/HtmlToPlainText.java">HtmlToPlainText</a>
 * @author Matt
 */
public class FormattingVisitor implements NodeVisitor {
	private final StringBuilder sb = new StringBuilder();

	@Override
	public void head(Node node, int depth) {
		String name = node.nodeName();
		// TextNodes carry all user-readable text in the DOM.
		if(node instanceof TextNode)
			text(((TextNode) node).text());
		// Other nodes are used only for formatting, not content
		else if(name.equals("li"))
			text("\n * ");
		else if(name.equals("dt"))
			text("  ");
		else if(StringUtil.in(name, "p", "h1", "h2", "h3", "h4", "h5", "tr"))
			spacing(node);
	}

	@Override
	public void tail(Node node, int depth) {
		String name = node.nodeName();
		if(StringUtil.in(name, "br", "dd", "dt", "p", "h1", "h2", "h3", "h4", "h5", "ul", "ol", "table"))
			spacing(node);
	}

	@Override
	public String toString() {
		return sb.toString();
	}

	private void text(String text) {
		// Don't add empty lines first
		if(text.trim().isEmpty() && sb.length() == 0)
			return;
		sb.append(text);
	}

	private void spacing(Node node) {
		// Common for <li><p> patterns, causing additional uneeded space
		if (node.nodeName().equals("p") && node.parent().nodeName().equals("li"))
			return;
		// Add spacing
		text("\n");
	}
}
```

`src/main/java/me/coley/recaf/parse/javadoc/Javadocs.java`:

```java
package me.coley.recaf.parse.javadoc;

import me.coley.recaf.util.StringUtil;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.parser.ParseErrorList;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeTraversor;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Javadocs wrapper for a class.
 *
 * @author Matt
 */
public class Javadocs {
	public static final String NO_DESCRIPTION = "n/a";
	private static final String DEFAULT_PACKAGE = "";
	private final String html;
	private final String name;
	private final String packageName;
	private Document doc;
	private String description;
	private List<String> inheritance;
	private List<String> interfaces;
	private List<String> subclasses;
	private List<DocField> fields;
	private List<DocMethod> methods;

	/**
	 * @param name
	 * 		Internal name of class.
	 * @param html
	 * 		Documentation HTML for the class.
	 */
	public Javadocs(String name, String html) {
		this.html = html;
		this.name = name.substring(0, name.lastIndexOf("."));
		this.packageName = name.contains("/") ? name.substring(0, name.lastIndexOf("/")) : DEFAULT_PACKAGE;
	}

	/**
	 * Analyze the source code minimally.
	 *
	 * @throws DocumentationParseException
	 * 		Thrown when the parse tree encountered errors.
	 * 		The file may be partially parsed even if thrown.
	 */
	public void parse() throws DocumentationParseException {
		doc = Jsoup.parse(html);
		ParseErrorList errors = doc.parser().getErrors();
		if (!errors.isEmpty())
			throw new DocumentationParseException(html, errors);
	}

	/**
	 * @return Package the class resides in.
	 */
	public String getPackageName() {
		return packageName;
	}

	/**
	 * @return Internal class name representation.
	 */
	public String getInternalName() {
		return name;
	}

	/**
	 * @return Class description.
	 */
	public String getDescription() {
		if (description !=null)
			return description;
		try {
			// Inside <div class="description"><ul><li>
			// - Get last <div class="block">
			// - Return string content.
			Element el = doc.getElementsByClass("description").get(0).child(0).child(0);
			int i = el.children().size() - 1;
			while (i > 0) {
				Element ec = el.child(i);
				if(ec.tagName().equals("div") && ec.className().equals("block"))
					return description = text(ec);
				i--;
			}
		} catch(IndexOutOfBoundsException ex) {
			// Expected
		}
		// Description not found
		return description = NO_DESCRIPTION;
	}

	/**
	 * @return List of classes this class extends. First element is the parent class, last element
	 * is the Object class.
	 */
	public List<String> getInheritance() {
		if(inheritance != null)
			return inheritance;
		// Chain of "ul > li > ul > ..."
		// - first will be the root of the chain
		// We can simply pattern match the display text.
		Elements in = doc.getElementsByClass("inheritance");
		if (in == null || in.isEmpty())
			return inheritance = Collections.emptyList();
		Element root = in.get(0);
		String[] lines = StringUtil.splitNewlineSkipEmpty(root.wholeText());
		List<String> list = Arrays.asList(lines);
		Collections.reverse(list);
		return inheritance =
				list.stream().map(s -> s.replace('.', '/')).collect(Collectors.toList());
	}

	/**
	 * @return List of <i>all</i> implemented interfaces.
	 */
	public List<String> getInterfaces() {
		if (interfaces != null)
			return interfaces;
		try {
			return interfaces = scanLinks("All Implemented Interfaces:");
		} catch(IndexOutOfBoundsException ex) {
			// Expected, no interfaces specified
		}
		return interfaces = Collections.emptyList();
	}

	/**
	 * @return List of direct subclasses.
	 */
	public List<String> getSubclasses() {
		if (subclasses != null)
			return subclasses;
		try {
			return subclasses = scanLinks("Direct Known Subclasses:");
		} catch(IndexOutOfBoundsException ex) {
			// Expected, no subclasses specified
		}
		return subclasses = Collections.emptyList();
	}

	/**
	 * Common scan function for subclasses/implemented interfaces.
	 *
	 * @param ownText
	 * 		Text of the &lt;dt&gt; element to match as the starting position of the scan.
	 *
	 * @return List of internal names referenced by links.
	 */
	private List<String> scanLinks(String ownText) {
		List<String> list = new ArrayList<>();
		// <dt>ownText</dt>
		// - Get parent of this
		// - Iterate over <dd><code>'s children
		// - Contains a <a>, use "a.href" to parse internal name
		Element el = doc.getElementsContainingOwnText(ownText).get(0);
		int indexOf = el.parent().children().indexOf(el);
		el = el.parent().child(indexOf + 1);
		// Java 8: A series of <a>
		// - Link is essentially the exact same as internal name
		// Java 9: A series of <code> <a>
		// - Link is relative
		for (Element e : el.children()) {
			if (e.tagName().equals("a")) {
				// Java 8 or lower
				String url = e.attr("href");
				if(url != null)
					list.add(url.substring(url.lastIndexOf("../") + 3, url.length() - 5));
			} else if (e.tagName().equals("code")) {
				// Java 9 or higher, must resolve relative paths
				e = e.child(0);
				String url = e.attr("href");
				String rel = getPackageName();
				while (url.contains("../")) {
					url = url.substring(3);
					rel = rel.substring(0, rel.lastIndexOf("/"));
				}
				rel += "/" + url.substring(0, url.length() - 5);
				list.add(rel);
			}
		}
		return list;
	}

	/**
	 * @return List of field docs.
	 */
	public List<DocField> getFields() {
		if (fields != null)
			return fields;
		// <h3>Method Detail</h2>
		// - Get parent of this
		// - Iterate over <ul><li> children
		// - Parse for info
		List<DocField> list = new ArrayList<>();
		Elements fields = doc.getElementsContainingOwnText("Field Detail");
		if (fields == null || fields.isEmpty()) {
			this.fields = list;
			return list;
		}
		Element el = fields.get(0);
		el = el.parent();
		for (Element e : el.children()) {
			if (!e.tagName().equals("ul"))
				continue;
			// Select the <li> child
			e = e.child(0);
			String name = null;
			String data = null;
			StringBuilder description = new StringBuilder();
			for (Element c : e.children()){
				// Header block
				if (c.tagName().equals("h4"))
					name = c.ownText();
				// Definition block
				else if (c.tagName().equals("pre"))
					data = c.text();
				// Standard description block
				else if (c.tagName().equals("div"))
					description.append(text(c)).append("\n");
			}
			Objects.requireNonNull(data, "Failed to parse Javadoc for field:\n" + e.html());
			// data == <modifiers> <type> <name>
			// - Sometimes odd unicode char (160) exists instead of space
			String[] split = data.replace('\u00A0', ' ').replace("&nbsp;", " ").split("\\s");
			int typeIndex = split.length - 2;
			String type = split[typeIndex];
			List<String> modifiers = Arrays.asList(Arrays.copyOfRange(split, 0, typeIndex));
			list.add(new DocField(modifiers, name, description.toString().trim(), type));
		}
		return this.fields = list;
	}

	/**
	 * @return List of method docs.
	 */
	public List<DocMethod> getMethods() {
		if (methods != null)
			return methods;
		// <h3>Method Detail</h2>
		// - Get parent of this
		// - Iterate over <ul><li> children
		// - Parse for info
		List<DocMethod> list = new ArrayList<>();
		Elements methods = doc.getElementsContainingOwnText("Method Detail");
		if (methods == null || methods.isEmpty()) {
			this.methods = list;
			return list;
		}
		Element el = methods.get(0);
		el = el.parent();
		for (Element e : el.children()) {
			if (!e.tagName().equals("ul"))
				continue;
			// Select the <li> child
			e = e.child(0);
			String name = null;
			String data = null;
			StringBuilder retDescription = new StringBuilder();
			StringBuilder description = new StringBuilder();
			List<DocParameter> parameters = new ArrayList<>();
			for (Element c : e.children()){
				// Header block
				if (c.tagName().equals("h4"))
					name = c.ownText();
				// Definition block
				else if (c.tagName().equals("pre"))
					data = c.text();
				// Standard description block
				else if (c.tagName().equals("div"))
					description.append(text(c)).append("\n");
				// Contains children of items like "Parameters:" & "Returns:"
				// - <dt>'s text is the header
				// - following <dd>s are content
				else if (c.tagName().equals("dl"))
					// increment i based on key/content type
					parseMethodDescriptor(c, retDescription, parameters);
			}
			Objects.requireNonNull(data, "Failed to parse Javadoc for method:\n" + e.html());
			// data == <modifiers> <type> <name(args>
			// - Sometimes odd unicode char (160) exists instead of space
			String[] split = data.replace('\u00A0', ' ').substring(0, data.indexOf('(')).split("\\s");
			int typeIndex = split.length - 2;
			String type = split[typeIndex];
			if (type.contains("<"))
				type = type.substring(0, type.indexOf("<"));
			List<String> modifiers = Arrays.asList(Arrays.copyOfRange(split, 0, typeIndex));
			list.add(new DocMethod(modifiers, name, description.toString().trim(),
					retDescription.toString(), type, parameters));
		}
		return this.methods = list;
	}

	private void parseMethodDescriptor(Element c, StringBuilder retDesc, List<DocParameter> params) {
		for (int i = 0; i < c.children().size();) {
			Element cc = c.child(i);
			String key = cc.text();
			if (key.startsWith("Returns")) {
				// Returns should just have one following element
				retDesc.append(c.child(i+1).text());
				i+=2;
			} else if (key.startsWith("Parameters")) {
				// Parameters followed by 0 or more <dd> content elments
				// <dd><code>parameter</code> - description</dd>
				while (i < c.children().size() - 1) {
					Element value = c.child(i + 1);
					if (!value.tagName().equals("dd"))
						break;
					String pname = value.child(0).text();
					String pdesc = value.text();
					if (pdesc.length() > pname.length() + 3)
						pdesc = pdesc.substring(pname.length() + 3);
					params.add(new DocParameter(pname, pdesc));
					i++;
				}
				i++;
			} else {
				// Unknown documentation element
				i++;
			}
		}
	}

	private static String text(Element element) {
		FormattingVisitor formatter = new FormattingVisitor();
		NodeTraversor.traverse(formatter, element);
		return formatter.toString();
	}
}

```

`src/main/java/me/coley/recaf/parse/source/SourceCode.java`:

```java
package me.coley.recaf.parse.source;

import com.github.javaparser.*;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.nodeTypes.NodeWithName;
import me.coley.recaf.util.JavaParserRecovery;
import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Source code wrapper.
 *
 * @author Matt
 */
public class SourceCode {
	/**
	 * Simple names belonging to the <i>"java.lang"</i> package.
	 */
	public static final String[] LANG_PACKAGE_NAMES;
	private static final String DEFAULT_PACKAGE = "";
	private final JavaResource resource;
	private final String code;
	private final List<String> lines;
	private CompilationUnit unit;
	// JavaParser values. Lazily instantiated.
	private List<String> explicitImports;
	private List<String> impliedImports;
	private String packageName;
	private String simpleName;
	private String internalName;

	/**
	 * @param resource
	 * 		Resource this source is attached to.
	 * @param code
	 * 		Full source code text.
	 */
	public SourceCode(JavaResource resource, String code) {
		this.resource = resource;
		this.code = code;
		this.lines = Arrays.asList(StringUtil.splitNewline(code));
	}

	/**
	 * Analyze the source code minimally.
	 *
	 * @return Parse result of class.
	 *
	 * @throws SourceCodeException
	 * 		Thrown if the source code could not be parsed.
	 */
	public ParseResult<CompilationUnit> analyze() throws SourceCodeException {
		ParseResult<CompilationUnit> result = analyze0(code, new JavaParser());
		if(!result.getProblems().isEmpty())
			throw new SourceCodeException(result);
		return result;
	}

	/**
	 * Analyze the source code.
	 *
	 * @param workspace
	 * 		Workspace to use for assistance in type resolving.
	 *
	 * @return Parse result of class.
	 *
	 * @throws SourceCodeException
	 * 		Thrown if the source code could not be parsed.
	 */
	public ParseResult<CompilationUnit> analyze(Workspace workspace) throws SourceCodeException {
		ParseResult<CompilationUnit> result = analyze0(code, new JavaParser(workspace.getSourceParseConfig()));
		if(!result.getProblems().isEmpty())
			throw new SourceCodeException(result);
		return result;
	}

	/**
	 * Analyze the source code with known problems filtered out.
	 *
	 * @param workspace
	 * 		Workspace to use for assistance in type resolving.
	 *
	 * @param knownProblems
	 *      Known problems that was arisen in parsing
	 *
	 * @return Parse result of class.
	 */
	public ParseResult<CompilationUnit> analyzeFiltered(Workspace workspace, Collection<Problem> knownProblems) {
		String cleanedCode = JavaParserRecovery.filterDecompiledCode(code, knownProblems);
		return analyze0(cleanedCode, new JavaParser(workspace.getSourceParseConfig()));
	}

	/**
	 * Analyze the source code using the specific parser.
	 *
	 * @param parser
	 *      the parser instance.
	 *
	 * @return
	 *      Parse result of class.
	 */
	private ParseResult<CompilationUnit> analyze0(String code, JavaParser parser) {
		ParseResult<CompilationUnit> result = parser.parse(code);
		if(result.getResult().isPresent())
			this.unit = result.getResult().get();
		return result;
	}

	/**
	 * Returns the AST node at the given position. Returns the deepest node in the AST at the point.
	 *
	 * @param line
	 * 		Cursor line.
	 * @param column
	 * 		Cursor column.
	 *
	 * @return JavaParser AST node at the given position in the source code.
	 */
	public Node getVerboseNodeAt(int line, int column) {
		return getNodeAt(line, column, unit.findRootNode(), node -> {
			// Verify the node range can be accessed
			if (!node.getBegin().isPresent() || !node.getEnd().isPresent())
				return false;
			// Should be fine
			return true;
		});
	}

	/**
	 * Returns the AST node at the given position.
	 * The child-most node may not be returned if the parent is better suited for contextual
	 * purposes.
	 *
	 * @param line
	 * 		Cursor line.
	 * @param column
	 * 		Cursor column.
	 *
	 * @return JavaParser AST node at the given position in the source code.
	 */
	public Node getNodeAt(int line, int column) {
		return getNodeAt(line, column, unit.findRootNode(), node -> {
			// We want to know more about this type, don't resolve down to the lowest AST
			// type... the parent has more data and is essentially just a wrapper around SimpleName.
			if (node instanceof SimpleName)
				return false;
			// Verify the node range can be accessed
			if (!node.getBegin().isPresent() || !node.getEnd().isPresent())
				return false;
			// Same as above, we want to return the node with actual context.
			if (node instanceof NameExpr)
				return false;
			// Should be fine
			return true;
		});
	}

	private Node getNodeAt(int line, int column, Node root, Predicate<Node> filter) {
		if (!filter.test(root))
			return null;
		// Check cursor is in bounds
		// We won't instantly return null because the root range may be SMALLER than
		// the range of children. This is really stupid IMO but thats how JavaParser is...
		boolean bounds = true;
		Position cursor = new Position(line, column);
		if (cursor.isBefore(root.getBegin().get()) || cursor.isAfter(root.getEnd().get()))
			bounds = false;
		// Iterate over children, return non-null child
		for (Node child : root.getChildNodes()) {
			Node ret = getNodeAt(line, column, child, filter);
			if (ret != null)
				return ret;
		}
		// If we're not in bounds and none of our children are THEN we assume this node is bad.
		if (!bounds)
			return null;
		// In bounds so we're good!
		return root;
	}

	/**
	 * @return Class package in standard format <i>(Not internal, using ".")</i>
	 */
	public String getPackage() {
		if (packageName != null)
			return packageName;
		// fetch package
		return packageName = unit.getPackageDeclaration().map(NodeWithName::getNameAsString).orElse(DEFAULT_PACKAGE);
	}

	/**
	 * @return List of classes imported. Wildcards are mapped to the entire package.
	 */
	public List<String> getImports() {
		if (explicitImports != null)
			return explicitImports;
		// compute imports
		return explicitImports = unit.getImports().stream().flatMap(imp -> {
			// Ignore static imports
			if (imp.isStatic())
				return Stream.empty();
			// Check wildcard import
			if (imp.isAsterisk()) {
				String pkg = imp.getNameAsString();
				return resource.getClasses().keySet().stream()
						.filter(name -> {
							int index = name.lastIndexOf('/');
							if (index == -1) return false;
							String tmpPackageName = name.substring(0, index);
							return tmpPackageName.equals(pkg);
						});
			}
			// Single class import
			return Stream.of(imp.getNameAsString().replace('.', '/'));
		}).collect(Collectors.toList());
	}

	/**
	 * @return List of all classes imported. This includes the {@link #getImports() explicit
	 * imports} and the implied classes from the current and "java.lang" packages.
	 */
	public List<String> getAllImports() {
		if (impliedImports != null)
			return impliedImports;
		// Get stream of classes in the same package
		String pkg = getPackage();
		Stream<String> pkgStream;
		if (pkg.equals(DEFAULT_PACKAGE))
			pkgStream = resource.getClasses().keySet().stream().filter(name ->!name.contains("/"));
		else
			pkgStream = resource.getClasses().keySet().stream().filter(name -> {
				if (!name.contains("/"))
					return false;
				String tmpPackageName = name.substring(0, name.lastIndexOf("/"));
				return tmpPackageName.equals(pkg);
			});
		pkgStream = Stream.concat(pkgStream, Stream.of(LANG_PACKAGE_NAMES).map(n -> "java/lang/" + n));
		// Combine with explicit
		return impliedImports = Stream.concat(getImports().stream(), pkgStream)
				.collect(Collectors.toList());
	}

	/**
	 * @return Class name.
	 */
	public String getName() {
		if (simpleName != null)
			return simpleName;
		// fetch declared name (Should be same as source file name)
		TypeDeclaration<?> type = unit.getType(0);
		if(type != null)
			return simpleName = type.getNameAsString();
		throw new IllegalStateException("Failed to fetch type from source file: " + code);
	}

	/**
	 * @return Internal class name representation.
	 */
	public String getInternalName() {
		if (internalName != null)
			return internalName;
		// compute internal name
		if(getPackage().equals(DEFAULT_PACKAGE))
			return internalName = getName();
		return internalName = (getPackage() + "." + getName()).replace(".", "/");
	}

	/**
	 * @param line
	 * 		The source line to target.
	 * @param context
	 * 		The number of lines before and after the targeted line to include.
	 *
	 * @return Source from lines (line - context) to (line + context).
	 */
	public String getSurrounding(int line, int context) {
		// Offset so we're 0-based
		line--;
		//
		int min = Math.max(0, line - context);
		int max = Math.min(lines.size() - 1, line + context);
		StringBuilder sb = new StringBuilder();
		for (int i = min; i <= max; i++) {
			sb.append(lines.get(i));
			if (i < max)
				sb.append('\n');
		}
		return sb.toString();
	}

	/**
	 * @return Abstract syntax tree representation of source code.
	 */
	public CompilationUnit getUnit() {
		return unit;
	}

	/**
	 * @return Full source code text.
	 */
	public String getCode() {
		return code;
	}

	/**
	 * @return Full source code split by newlines.
	 */
	public List<String> getLines() {
		return lines;
	}

	static {
		// I'm hiding this behemoth down here.
		// - Don't touch it, Checkstyle will complain
		//
		// There's no clean way to look up things in a package.
		// "java.lang" won't change often so.... this is fine
		LANG_PACKAGE_NAMES = new String[]{"AbstractMethodError", "Annotation", "Appendable",
			"ArithmeticException", "ArrayIndexOutOfBoundsException", "ArrayStoreException",
			"AssertionError", "AutoCloseable", "Boolean", "BootstrapMethodError", "Byte",
			"Character", "CharSequence", "Class", "ClassCastException", "ClassCircularityError",
			"ClassFormatError", "ClassLoader", "ClassNotFoundException", "ClassValue",
			"Cloneable", "CloneNotSupportedException", "Comparable", "Compiler", "Deprecated",
			"Double", "Enum", "EnumConstantNotPresentException", "Error", "Exception",
			"ExceptionInInitializerError", "Float", "IllegalAccessError",
			"IllegalAccessException", "IllegalArgumentException",
			"IllegalMonitorStateException", "IllegalStateException",
			"IllegalThreadStateException", "IncompatibleClassChangeError",
			"IndexOutOfBoundsException", "InheritableThreadLocal", "InstantiationError",
			"InstantiationException", "Integer", "Interface", "InternalError",
			"InterruptedException", "Iterable", "LinkageError", "Long", "Math",
			"NegativeArraySizeException", "NoClassDefFoundError", "NoSuchFieldError",
			"NoSuchFieldException", "NoSuchMethodError", "NoSuchMethodException",
			"NullPointerException", "Number", "NumberFormatException", "Object",
			"OutOfMemoryError", "Override", "Package", "Process", "ProcessBuilder", "Readable",
			"ReflectiveOperationException", "Runnable", "Runtime", "RuntimeException",
			"RuntimePermission", "SafeVarargs", "SecurityException", "SecurityManager", "Short",
			"StackOverflowError", "StackTraceElement", "StrictMath", "String", "StringBuffer",
			"StringBuilder", "StringIndexOutOfBoundsException", "SuppressWarnings", "System",
			"Thread", "ThreadDeath", "ThreadGroup", "ThreadLocal", "Throwable",
			"TypeNotPresentException", "UnknownError", "UnsatisfiedLinkError",
			"UnsupportedClassVersionError", "UnsupportedOperationException", "VerifyError",
			"VirtualMachineError", "Void"};
	}
}

```

`src/main/java/me/coley/recaf/parse/source/SourceCodeException.java`:

```java
package me.coley.recaf.parse.source;

import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;

/**
 * Exception thrown for when the JavaParser api fails to parse a source file.
 *
 * @author Matt
 */
public class SourceCodeException extends Exception {
	private final ParseResult<CompilationUnit> result;

	/**
	 * @param result Result returned as a parse failure.
	 */
	public SourceCodeException(ParseResult<CompilationUnit> result) {
		this.result = result;
	}

	/**
	 * @return Failing parse result.
	 */
	public ParseResult<CompilationUnit> getResult() {
		return result;
	}
}

```

`src/main/java/me/coley/recaf/parse/source/WorkspaceClassPath.java`:

```java
package me.coley.recaf.parse.source;

import javassist.ClassPath;
import me.coley.recaf.util.Log;
import me.coley.recaf.workspace.Workspace;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;

/**
 * Javassist classpath implementation that pulls classes from a workspace.
 *
 * @author Matt Coley
 */
public class WorkspaceClassPath implements ClassPath {
	private static final RecafStreamHandler dummyUrlHandler = new RecafStreamHandler();
	private final Workspace workspace;

	/**
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	public WorkspaceClassPath(Workspace workspace) {
		this.workspace = workspace;
	}

	@Override
	public InputStream openClassfile(String classname) {
		byte[] bytes = workspace.getRawClass(classname);
		if (bytes != null)
			return new ByteArrayInputStream(bytes);
		return null;
	}

	@Override
	public URL find(String classname) {
		// Javassist does a URL lookup before allowing any actual reading, so we have to supply some
		// dummy value in order to then call "openClassfile"
		try {
			String internalName = classname.replace('.', '/');
			return new URL(null, "recaf:" + internalName, dummyUrlHandler);
		} catch (Exception ex) {
			Log.error("Failed to create 'recaf' URL scheme", ex);
			return null;
		}
	}

	private static class RecafStreamHandler extends URLStreamHandler {
		@Override
		protected URLConnection openConnection(URL u) {
			// No-op
			return null;
		}
	}
}

```

`src/main/java/me/coley/recaf/parse/source/WorkspaceTypeResolver.java`:

```java
package me.coley.recaf.parse.source;

import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;
import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import javassist.*;
import me.coley.recaf.util.StringUtil;
import me.coley.recaf.workspace.Workspace;

import java.io.*;

import static com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.toTypeDeclaration;

/**
 * Type resolver that uses a Recaf workspace as a classpath.
 *
 * @author Matt
 */
public class WorkspaceTypeResolver implements TypeSolver {
	private final TypeSolver childSolver = new ReflectionTypeSolver(false);
	private final ClassPool classPool = new ClassPool(false);
	private Workspace workspace;
	private TypeSolver parent;

	/**
	 * @param workspace
	 * 		Workspace to pull classes from.
	 */
	public WorkspaceTypeResolver(Workspace workspace) {
		this.workspace = workspace;
		classPool.appendClassPath(new WorkspaceClassPath(workspace));
		classPool.appendSystemPath();
	}

	@Override
	public TypeSolver getParent() {
		return this.parent;
	}

	@Override
	public void setParent(TypeSolver parent) {
		this.parent = parent;
	}

	@Override
	public SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveType(String name) {
		try {
			// The default resolve seems to infinite loop on Object, but this doesn't.
			// IDK, JavaParser is weird.
			if (name.equals("java.lang.Object"))
				return SymbolReference.solved(new ReflectionClassDeclaration(Object.class, getRoot()));
			// JavaParser has no understanding of the difference between
			// a package separator and an inner class separator...
			// I mean, its designed to mimic source-level constructs but this is still disappointing...
			// I would like to not have to have a loop like this here for performance reasons.
			String internal = name.replace('.','/');
			do {
				if (workspace.hasClass(internal)) {
					InputStream is = new ByteArrayInputStream(workspace.getRawClass(internal));
					ResolvedReferenceTypeDeclaration dec = toTypeDeclaration(classPool.makeClass(is), getRoot());
					return SymbolReference.solved(dec);
				} else {
					internal = StringUtil.replaceLast(internal, "/", "$");
				}
			} while (internal.indexOf('/') > 0);
		} catch(IOException ex) {
			throw new IllegalStateException("Failed to resolve type: " + name, ex);
		}
		return childSolver.tryToSolveType(name);
	}
}

```

`src/main/java/me/coley/recaf/plugin/PluginFolderSource.java`:

```java
package me.coley.recaf.plugin;

import me.coley.recaf.Recaf;
import me.coley.recaf.plugin.api.BasePlugin;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.VMUtil;
import org.objectweb.asm.ClassReader;
import org.plugface.core.PluginSource;
import org.plugface.core.internal.PluginClassLoader;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * A plugin source that loads from Recaf's plugins directory.
 *
 * @author Matt
 */
public class PluginFolderSource implements PluginSource {
	private final Map<Path, URL> pluginJarUrls = new HashMap<>();
	private final Map<Path, BufferedImage> pluginIcons = new HashMap<>();
	private final Map<String, Path> classToPlugin = new HashMap<>();

	/**
	 * Create the plugin folder source.
	 *
	 * @throws IOException
	 * 		When the plugin folder cannot be found or generated.
	 */
	public 	PluginFolderSource() throws IOException {
		Path pluginsDir = getPluginDir();
		// Ensure directory exists
		if(!Files.isDirectory(pluginsDir))
			Files.createDirectories(pluginsDir);
		// Populate plugin map
		for(Path filePath : Files.newDirectoryStream(pluginsDir)) {
			if(filePath.getFileName().toString().endsWith(".jar")) {
				pluginJarUrls.put(filePath, filePath.toUri().toURL());
			}
		}
	}

	@Override
	public Collection<Class<?>> load() throws PluginLoadException {
		List<Class<?>> plugins = new ArrayList<>();
		PluginClassLoader loader =
				new PluginClassLoader(pluginJarUrls.values().toArray(new URL[0]));
		VMUtil.setParent(loader, Recaf.class.getClassLoader());
		for(Path pluginPath : pluginJarUrls.keySet()) {
			File path = pluginPath.toAbsolutePath().toFile();
			String className = null;
			try (JarFile jar = new JarFile(path)) {
				for(Enumeration<JarEntry> entries = jar.entries(); entries.hasMoreElements(); ) {
					JarEntry entry = entries.nextElement();
					if(entry.isDirectory())
						continue;
					// Add classes
					if (entry.getName().endsWith(".class")) {
						className = toName(entry);
						if (isPluginClass(jar, entry)) {
							plugins.add(Class.forName(className, false, loader));
						}
						classToPlugin.put(className, pluginPath);
					}
					// Check for plugin icon
					else if(entry.getName().endsWith("icon.png")) {
						BufferedImage image = ImageIO.read(jar.getInputStream(entry));
						pluginIcons.put(pluginPath, image);
					}
					// Check for translation files
					else if(entry.getName().endsWith(LangUtil.DEFAULT_LANGUAGE + ".json")){
						LangUtil.load(jar.getInputStream(entry));
					}
				}
			} catch(IOException ex) {
				throw new PluginLoadException(path, ex, "Failed to load jar file");
			} catch(ReflectiveOperationException ex) {
				throw new PluginLoadException(path, ex, "Failed to load '" + className + "' in jar");
			}
		}
		return plugins;
	}

	/**
	 * @param jar
	 * 		Container.
	 * @param entry
	 * 		Entry in container that has the class file extension.
	 *
	 * @return {@code true} if the entry is a class that implements a plugin API interface.
	 *
	 * @throws IOException
	 * 		When the entry cannot be read.
	 */
	private boolean isPluginClass(JarFile jar, JarEntry entry) throws IOException {
		byte[] content = IOUtil.toByteArray(jar.getInputStream(entry));
		String[] interfaces = new ClassReader(content).getInterfaces();
		String pluginPackage = BasePlugin.class.getPackage().getName().replace('.', '/');
		for (String itf : interfaces) {
			if (itf.startsWith(pluginPackage))
				return true;
		}
		return false;
	}

	/**
	 * @return Map of plugin paths to their icons. Not all plugins have icons.
	 */
	public Map<Path, BufferedImage> getPluginIcons() {
		return pluginIcons;
	}

	/**
	 * @return Map of plugin class names <i>(qualified names)</i> to their containing plugin-jar's path.
	 */
	public Map<String, Path> getClassToPlugin() {
		return classToPlugin;
	}

	/**
	 * Entry to qualified class name.
	 *
	 * @param entry
	 * 		Jar entry of a class file.
	 *
	 * @return Class name.
	 */
	private static String toName(JarEntry entry) {
		return entry.getName().substring(0, entry.getName().length() - 6).replace('/', '.');
	}

	/**
	 * @return Directory for Recaf plugins.
	 */
	private static Path getPluginDir() {
		return Recaf.getDirectory("plugins");
	}
}

```

`src/main/java/me/coley/recaf/plugin/PluginKeybinds.java`:

```java
package me.coley.recaf.plugin;

import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.plugin.api.BasePlugin;
import me.coley.recaf.plugin.api.KeybindProviderPlugin;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.view.FileViewport;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Keybind manager for plugins.
 *
 * @author Matt
 */
public class PluginKeybinds {
	private static final PluginKeybinds INSTANCE;
	private final Set<KeybindProviderPlugin> keybindProviders = new HashSet<>();
	private final Map<KeybindProviderPlugin, Map<ConfKeybinding.Binding, Runnable>>
			globalBinds = new HashMap<>();
	private final Map<KeybindProviderPlugin, Map<ConfKeybinding.Binding, Consumer<ClassViewport>>>
			classViewBinds = new HashMap<>();
	private final Map<KeybindProviderPlugin, Map<ConfKeybinding.Binding, Consumer<FileViewport>>>
			fileViewBinds = new HashMap<>();

	// Deny constructor
	private PluginKeybinds() {}

	/**
	 * Setup keybind collections.
	 */
	public void setup() {
		if (keybindProviders.isEmpty()) {
			Collection<KeybindProviderPlugin> keybindProviders = PluginsManager.getInstance()
					.ofType(KeybindProviderPlugin.class);
			globalBinds.putAll(keybindProviders.stream()
					.collect(Collectors.toMap(provider -> provider, KeybindProviderPlugin::createGlobalBindings)));
			classViewBinds.putAll(keybindProviders.stream()
					.collect(Collectors.toMap(provider -> provider, KeybindProviderPlugin::createClassViewBindings)));
			fileViewBinds.putAll(keybindProviders.stream()
					.collect(Collectors.toMap(provider -> provider, KeybindProviderPlugin::createFileViewBindings)));
		}
	}

	/**
	 * @return Active global binds and their actions.
	 */
	public Map<ConfKeybinding.Binding, Runnable> getGlobalBinds() {
		return globalBinds.entrySet().stream()
				.filter(p -> isActive(p.getKey()))
				.flatMap(p -> p.getValue().entrySet().stream())
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}

	/**
	 * @return Active class-view binds and their actions.
	 */
	public Map<ConfKeybinding.Binding, Consumer<ClassViewport>> getClassViewBinds() {
		return classViewBinds.entrySet().stream()
				.filter(p -> isActive(p.getKey()))
				.flatMap(p -> p.getValue().entrySet().stream())
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}

	/**
	 * @return Active file-view binds and their actions.
	 */
	public Map<ConfKeybinding.Binding, Consumer<FileViewport>> getFileViewBinds() {
		return fileViewBinds.entrySet().stream()
				.filter(p -> isActive(p.getKey()))
				.flatMap(p -> p.getValue().entrySet().stream())
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}

	/**
	 * @param plugin
	 * 		Plugin to check.
	 *
	 * @return {@code true} When the plugin state is active.
	 */
	private static boolean isActive(BasePlugin plugin) {
		return PluginsManager.getInstance().getPluginStates().getOrDefault(plugin.getName(), false);
	}

	/**
	 * @return Plugin keybind manager instance.
	 */
	public static PluginKeybinds getInstance() {
		return INSTANCE;
	}

	static {
		INSTANCE = new PluginKeybinds();
	}
}

```

`src/main/java/me/coley/recaf/plugin/PluginLoadException.java`:

```java
package me.coley.recaf.plugin;

import java.io.File;

/**
 * A wrapper for error-handling in plugin loading.
 *
 * @author Matt
 */
public class PluginLoadException extends Exception {
	private final File jar;

	/**
	 * Create the load exception.
	 *
	 * @param jar
	 * 		The plugin jar that caused the load exception.
	 * @param ex
	 * 		The cause exception.
	 * @param message
	 * 		Exception message explaining what went wrong.
	 */
	public PluginLoadException(File jar, Exception ex, String message) {
		super(message, ex);
		this.jar = jar;
	}

	/**
	 * @return The plugin jar that caused the load exception.
	 */
	public final File getJar() {
		return jar;
	}
}

```

`src/main/java/me/coley/recaf/plugin/PluginsManager.java`:

```java
package me.coley.recaf.plugin;

import me.coley.recaf.plugin.api.BasePlugin;
import me.coley.recaf.plugin.api.InternalPlugin;
import me.coley.recaf.plugin.api.InternalApi;
import me.coley.recaf.util.Log;
import me.coley.recaf.workspace.EntryLoader;
import org.plugface.core.PluginContext;
import org.plugface.core.impl.DefaultPluginContext;
import org.plugface.core.impl.DefaultPluginManager;
import org.plugface.core.internal.AnnotationProcessor;
import org.plugface.core.internal.DependencyResolver;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Plugin manager.
 *
 * @author Matt
 */
public class PluginsManager extends DefaultPluginManager {
	private static final PluginsManager INSTANCE;
	private final Map<String, BasePlugin> plugins = new HashMap<>();
	private final Map<String, Boolean> pluginStates = new HashMap<>();
	private final Map<String, BufferedImage> pluginIcons = new HashMap<>();
	private EntryLoader entryLoader;

	/**
	 * Deny public construction.
	 */
	private PluginsManager(PluginContext context, AnnotationProcessor processor,
						   DependencyResolver resolver) {
		super(context, processor, resolver);
	}

	/**
	 * Initialize the plugin manager.
	 *
	 * @throws Exception
	 * 		See other throws.
	 * @throws PluginLoadException
	 * 		When loading specific plugin crashes when loaded.
	 * @throws IOException
	 * 		When the plugin directory cannot be read from or created.
	 * @throws IllegalStateException
	 * 		When the plugin does not properly define a name.
	 */
	public void load() throws Exception {
		PluginFolderSource source = new PluginFolderSource();
		// Collect plugin instances
		Collection<Object> instances = loadPlugins(source);
		for (Object instance : instances) {
			if (instance instanceof BasePlugin) {
				BasePlugin plugin = (BasePlugin) instance;
				String name = plugin.getName();
				String version = plugin.getVersion();
				String className = instance.getClass().getName();
				BufferedImage icon =
						source.getPluginIcons().get(source.getClassToPlugin().get(className));
				Log.info("Discovered plugin '{}-{}'", name, version);
				// PlugFace already has its own internal storage of the plugin instances,
				// but we want to control them a bit easier. So we'll keep a local reference.
				addPlugin(name, plugin, icon);
			} else {
				Log.error("Class '{}' does not extend plugin!", instance.getClass().getName());
			}
		}
		// Done
		if (!plugins.isEmpty())
			Log.info("Loaded {} plugins", plugins.size());
	}


	/**
	 * @return Collection of all plugin instances.
	 */
	public Map<String, BasePlugin> plugins() {
		return plugins;
	}

	/**
	 * @return Collection of visible plugin instances.
	 */
	public Map<String, BasePlugin> visiblePlugins() {
		return plugins().entrySet()
				.stream()
				.filter(e -> !(e.getValue() instanceof InternalPlugin))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}

	/**
	 * @return Map of plugin states.
	 */
	public Map<String, Boolean> getPluginStates() {
		return pluginStates;
	}

	/**
	 * Map of plugin's icons. Not all plugins have icons.
	 *
	 * @return Map of plugin icons.
	 */
	public Map<String, BufferedImage> getPluginIcons() {
		return pluginIcons;
	}

	/**
	 * @return {@code true} when 1 or more plugins have been loaded.
	 */
	public boolean hasPlugins() {
		return !plugins.isEmpty();
	}

	/**
	 * @return The current entry loader defined by a plugin.
	 */
	public EntryLoader getEntryLoader() {
		return entryLoader;
	}

	/**
	 * Set current entry loader.
	 *
	 * @param entryLoader
	 * 		New entry loader defined by a plugin.
	 */
	public void setEntryLoader(EntryLoader entryLoader) {
		this.entryLoader = entryLoader;
	}

	/**
	 * Fetch the active plugins matching the given type.
	 * This will exclude plugins that are disabled.
	 *
	 * @param type
	 * 		Class of plugin.
	 * @param <T>
	 * 		Plugin type.
	 *
	 * @return Collection of active plugins matching the given type.
	 */
	@SuppressWarnings("unchecked")
	public <T extends BasePlugin> Collection<T> ofType(Class<T> type) {
		return plugins().values().stream()
						.filter(plugin -> type.isAssignableFrom(plugin.getClass()))
						.filter(plugin -> pluginStates.getOrDefault(plugin.getName(), false))
						.map(plugin -> (T) plugin)
						.collect(Collectors.toList());
	}

	/**
	 * @return Plugins manager instance.
	 */
	public static PluginsManager getInstance() {
		return INSTANCE;
	}

	/**
	 * Registers a plugin.
	 *
	 * @param name
	 * 		Name of the plugin.
	 * @param plugin
	 * 		Plugin to register.
	 * @param icon
	 * 		Icon of the plugin.
	 */
	@InternalApi
	public void addPlugin(String name, BasePlugin plugin, BufferedImage icon) {
		plugins.put(name, plugin);
		pluginStates.put(name, Boolean.TRUE);
		if (icon != null) {
			pluginIcons.put(name, icon);
		}
	}

	/**
	 * Registers a plugin.
	 *
	 * @param plugin
	 * 		Plugin to register.
	 * @param icon
	 * 		Icon of the plugin.
	 */
	@InternalApi
	public void addPlugin(BasePlugin plugin, BufferedImage icon) {
		addPlugin(plugin.getName(), plugin, icon);
	}

	/**
	 * Registers a plugin.
	 *
	 * @param plugin
	 * 		Plugin to register.
	 */
	@InternalApi
	public void addPlugin(BasePlugin plugin) {
		addPlugin(plugin, null);
	}

	static {
		DefaultPluginContext context = new DefaultPluginContext();
		AnnotationProcessor processor = new AnnotationProcessor();
		DependencyResolver resolver = new DependencyResolver(processor);
		INSTANCE = new PluginsManager(context, processor, resolver);
	}
}

```

`src/main/java/me/coley/recaf/plugin/api/AttachPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import com.sun.tools.attach.VirtualMachine;

/**
 * Plugin that can intercept VMs Recaf attaches to.
 *
 * @author xxDark
 */
public interface AttachPlugin extends BasePlugin {

    /**
     * Called whether Recaf's agent is about to be loaded
     * into target VM.
     *
     * @param virtualMachine Target JVM.
     */
    void onAgentLoad(VirtualMachine virtualMachine);
}

```

`src/main/java/me/coley/recaf/plugin/api/BasePlugin.java`:

```java
package me.coley.recaf.plugin.api;

/**
 * Common plugin class.
 *
 * @author Matt
 */
public interface BasePlugin {
	/**
	 * @return Plugin name.
	 */
	default String getName() {
		org.plugface.core.annotations.Plugin anno =
				getClass().getAnnotation(org.plugface.core.annotations.Plugin.class);
		if (anno == null)
			throw new IllegalStateException("Class '" + getClass().getName() +
					"' does not have an @Plugin annotation!");
		return anno.name();
	}

	/**
	 * @return Plugin version.
	 */
	String getVersion();

	/**
	 * @return Description of the plugin's functionality.
	 */
	String getDescription();
}

```

`src/main/java/me/coley/recaf/plugin/api/ClassVisitorPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import org.objectweb.asm.ClassVisitor;

/**
 * Allow plugins to intercept and modify {@link ClassVisitor}.
 *
 * @author xxDark
 */
public interface ClassVisitorPlugin extends BasePlugin {
    /**
     * Intercepts the given {@link ClassVisitor}.
     *
     * @param visitor
     *      Visitor to intercept.
     * @return intercepted {@link ClassVisitor}.
     */
    ClassVisitor intercept(ClassVisitor visitor);
}

```

`src/main/java/me/coley/recaf/plugin/api/CommandPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import java.util.concurrent.Callable;

/**
 * A plugin that can be registered as a pico-cli command.
 * It will need the correct annotations applied to it in the implementing class.
 * <hr>
 * See <a href="https://picocli.info/">picocli.info</a> for more information on how to create
 * a functional command.
 *
 * @author Matt
 */
public interface CommandPlugin extends BasePlugin, Callable<Void> {}

```

`src/main/java/me/coley/recaf/plugin/api/ConfigurablePlugin.java`:

```java
package me.coley.recaf.plugin.api;

import javafx.scene.Node;
import me.coley.recaf.config.Conf;
import me.coley.recaf.config.Configurable;
import me.coley.recaf.config.FieldWrapper;

import java.util.Map;
import java.util.function.Function;

/**
 * Allow plugins to automatically support persistent config using the {@link Conf} annotation on fields.
 *
 * @author Matt
 */
public interface ConfigurablePlugin extends BasePlugin, Configurable {
	/**
	 * @return Title of tab to put in config menu.
	 */
	String getConfigTabTitle();

	/**
	 * Add custom controls to support editors for the configurable fields.
	 * <br>
	 * Map keys should match {@link Conf#value()}.
	 *
	 * @param editors
	 * 		Existing map to populate.
	 */
	default void addFieldEditors(Map<String, Function<FieldWrapper, Node>> editors) {}
}

```

`src/main/java/me/coley/recaf/plugin/api/ContextMenuInjectorPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import javafx.scene.control.ContextMenu;
import me.coley.recaf.ui.ContextBuilder;
import me.coley.recaf.workspace.JavaResource;
import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * Allow plugins to update context menus.
 *
 * @author Matt
 */
public interface ContextMenuInjectorPlugin extends BasePlugin {
	/**
	 * Intercept context-menus for classes.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param name
	 * 		Package name.
	 */
	default void forPackage(ContextBuilder builder, ContextMenu menu, String name) {}

	/**
	 * Intercept context-menus for classes.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param name
	 * 		Class name.
	 */
	default void forClass(ContextBuilder builder, ContextMenu menu, String name) {}

	/**
	 * Intercept context-menus for fields.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param owner
	 * 		Declaring class name.
	 * @param name
	 * 		Field name.
	 * @param desc
	 * 		Field descriptor.
	 */
	default void forField(ContextBuilder builder, ContextMenu menu, String owner, String name, String desc) {}

	/**
	 * Intercept context-menus for methods.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param owner
	 * 		Declaring class name.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 */
	default void forMethod(ContextBuilder builder, ContextMenu menu, String owner, String name, String desc) {}

	/**
	 * Intercept context-menus for methods.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param owner
	 * 		Class that declares the method.
	 * @param name
	 * 		Declaring method name.
	 * @param desc
	 * 		Declaring method descriptor.
	 * @param insn
	 * 		Instruction value.
	 */
	default void forInsn(ContextBuilder builder, ContextMenu menu, String owner, String name, String desc,
						 AbstractInsnNode insn) {}

	/**
	 * Intercept context-menus for files.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param name
	 * 		File name.
	 */
	default void forFile(ContextBuilder builder, ContextMenu menu, String name) {}

	/**
	 * Intercept context-menus for resource roots.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 * @param resource
	 * 		Root resource.
	 */
	default void forResourceRoot(ContextBuilder builder, ContextMenu menu, JavaResource resource) {}

	/**
	 * Intercept context-menus for class tabs.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 */
	default void forClassTab(ContextBuilder builder, ContextMenu menu) {}

	/**
	 * Intercept context-menus for file tabs.
	 *
	 * @param builder
	 * 		Context menu builder.
	 * @param menu
	 * 		The menu to modify.
	 */
	default void forFileTab(ContextBuilder builder, ContextMenu menu) {}
}

```

`src/main/java/me/coley/recaf/plugin/api/EntryLoaderProviderPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import me.coley.recaf.workspace.EntryLoader;

/**
 * Allow plugins to provide entry loader for archives.
 *
 * @author Matt
 */
public interface EntryLoaderProviderPlugin extends BasePlugin {
	/**
	 * @return Created loader.
	 */
	EntryLoader create();
}

```

`src/main/java/me/coley/recaf/plugin/api/ExitPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import me.coley.recaf.control.Controller;

/**
 * Allows plugins to be notified of Recaf's shutdown.
 *
 * @author xxDark
 */
public interface ExitPlugin extends BasePlugin {

    /**
     * Called before application is about to shutdown.
     *
     * @param controller
     * 		The controller context Recaf was started with.
     */
    void onExit(Controller controller);
}

```

`src/main/java/me/coley/recaf/plugin/api/ExportInterceptorPlugin.java`:

```java
package me.coley.recaf.plugin.api;

/**
 * Allow plugins to intercept and modify exported classes and files.
 *
 * @author Matt
 */
public interface ExportInterceptorPlugin extends BasePlugin {
	/**
	 * Intercept the given item. May be a class or file.
	 *
	 * @param name
	 * 		Name of item being exported.
	 * 		Typically is a full path, allowing identification based on file extensions.
	 * @param code
	 * 		Raw data of item.
	 *
	 * @return Raw data of item to export.
	 */
	byte[] intercept(String name, byte[] code);
}

```

`src/main/java/me/coley/recaf/plugin/api/InternalApi.java`:

```java
package me.coley.recaf.plugin.api;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Indicates that the method or a class is an internal part
 * of the API and should not be used directly.
 *
 * @author xxDark
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface InternalApi { }

```

`src/main/java/me/coley/recaf/plugin/api/InternalPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import me.coley.recaf.util.InternalElement;

/**
 * Internal plugin base for Recaf.
 *
 * @author xxDark
 */
@InternalApi
public interface InternalPlugin extends BasePlugin, InternalElement { }

```

`src/main/java/me/coley/recaf/plugin/api/KeybindProviderPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import javafx.scene.input.KeyCode;
import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.view.FileViewport;

import java.util.Collections;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Allow plugins to register keybinds bound to certain actions.
 * <br>
 * See {@link ConfKeybinding.Binding#from(KeyCode...)} for easily creating bind instances.
 *
 * @author Matt
 */
public interface KeybindProviderPlugin extends BasePlugin {
	/**
	 * Create a map of keybinds for class-views.
	 *
	 * @return Generated binds, linked to their actions.
	 */
	default Map<ConfKeybinding.Binding, Runnable> createGlobalBindings() {
		return Collections.emptyMap();
	}

	/**
	 * Create a map of keybinds for class-views.
	 *
	 * @return Generated binds, linked to their actions.
	 */
	default Map<ConfKeybinding.Binding, Consumer<ClassViewport>> createClassViewBindings() {
		return Collections.emptyMap();
	}

	/**
	 * Create a map of keybinds for file-views.
	 *
	 * @return Generated binds, linked to their actions.
	 */
	default Map<ConfKeybinding.Binding, Consumer<FileViewport>> createFileViewBindings() {
		return Collections.emptyMap();
	}
}

```

`src/main/java/me/coley/recaf/plugin/api/LoadInterceptorPlugin.java`:

```java
package me.coley.recaf.plugin.api;

/**
 * Allow plugins to intercept and modify loaded classes and files.
 *
 * @author Matt
 */
public interface LoadInterceptorPlugin extends BasePlugin {
	/**
	 * Intercept the given class.
	 *
	 * @param name
	 * 		Internal name of class.
	 * @param code
	 * 		Raw bytecode of class.
	 *
	 * @return Bytecode of class to load.
	 */
	byte[] interceptClass(String name, byte[] code);

	/**
	 * Intercept the given class. This class however, cannot be parsed by ASM.
	 *
	 * @param entryName
	 * 		File name.
	 * @param code
	 * 		Raw bytecode of class.
	 *
	 * @return Bytecode of class to load.
	 */
	byte[] interceptInvalidClass(String entryName, byte[] code);

	/**
	 * Intercept the given file.
	 *
	 * @param entryName
	 * 		File name.
	 * @param value
	 * 		Raw data of file.
	 *
	 * @return Raw data to load.
	 */
	byte[] interceptFile(String entryName, byte[] value);
}

```

`src/main/java/me/coley/recaf/plugin/api/MenuProviderPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import javafx.scene.control.Menu;

/**
 * Allow plugins to insert themselves into the plugin menu dropdown.
 *
 * @author Matt
 */
public interface MenuProviderPlugin extends BasePlugin {
	/**
	 * Create a menu/menu-item for the plugin.
	 *
	 * @return Generated menu.
	 */
	Menu createMenu();
}

```

`src/main/java/me/coley/recaf/plugin/api/StartupPlugin.java`:

```java
package me.coley.recaf.plugin.api;

import me.coley.recaf.control.Controller;

/**
 * Allows plugins to be notified of Recaf's initialization.
 *
 * @author Matt
 */
public interface StartupPlugin extends BasePlugin {
	/**
	 * Called before the controller is started, but after the controller is configured.
	 *
	 * @param controller
	 * 		The controller context Recaf was started with.
	 */
	void onStart(Controller controller);
}

```

`src/main/java/me/coley/recaf/plugin/api/WorkspacePlugin.java`:

```java
package me.coley.recaf.plugin.api;

import me.coley.recaf.workspace.Workspace;

/**
 * Allow plugins to perform workspace specific actions
 *
 * @author xxDark
 * @see Workspace
 */
public interface WorkspacePlugin extends BasePlugin {
    /**
     * Called whether workspace is closed.
     *
     * @param workspace the workspace.
     */
    void onClosed(Workspace workspace);

    /**
     * Called whether new workspace is opened.
     * @param workspace the workspace.
     */
    void onOpened(Workspace workspace);
}

```

`src/main/java/me/coley/recaf/search/ClassInheritanceQuery.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.workspace.Workspace;

import java.util.Set;
import java.util.stream.Collectors;

/**
 * Query to find classes inheriting a given class.
 *
 * @author Matt
 */
public class ClassInheritanceQuery extends Query {
	private final Set<String> descendants;

	/**
	 * Constructs an inheritance query.
	 *
	 * @param workspace
	 * 		Workspace to generate hierarchy from.
	 * @param name
	 * 		Class name
	 */
	public ClassInheritanceQuery(Workspace workspace, String name) {
		super(QueryType.CLASS_INHERITANCE, null);
		this.descendants = workspace.getHierarchyGraph().getAllDescendants(name)
				.collect(Collectors.toSet());
	}

	/**
	 * Adds a result if the given class is a descendant of the specified class.
	 *
	 * @param access
	 * 		Class modifiers.
	 * @param name
	 * 		Name of class.
	 */
	public void match(int access, String name) {
		if(descendants.contains(name)) {
			getMatched().add(new ClassResult(access, name));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/ClassNameQuery.java`:

```java
package me.coley.recaf.search;

/**
 * Query to find classes matching the given name.
 *
 * @author Matt
 */
public class ClassNameQuery extends Query {
	private final String name;

	/**
	 * Constructs a class name matching query.
	 *
	 * @param name
	 * 		Class name pattern.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public ClassNameQuery(String name, StringMatchMode stringMode) {
		super(QueryType.CLASS_NAME, stringMode);
		this.name = name;
	}

	/**
	 * Adds a result if the given class matches the specified name pattern.
	 *
	 * @param access
	 * 		Class modifiers.
	 * @param name
	 * 		Name of class.
	 */
	public void match(int access, String name) {
		if (stringMode.match(this.name, name)) {
			getMatched().add(new ClassResult(access, name));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/ClassReferenceQuery.java`:

```java
package me.coley.recaf.search;

import java.util.function.IntSupplier;

/**
 * Query to find references to the given class.
 *
 * @author Matt
 */
public class ClassReferenceQuery extends Query {
	private final String name;

	/**
	 * Constructs a class referencing query.
	 *
	 * @param name
	 * 		Class name pattern.
	 *
	 */
	public ClassReferenceQuery(String name) {
		this(name, StringMatchMode.EQUALS);
	}

	/**
	 * Constructs a class referencing query.
	 *
	 * @param name
	 * 		Class name pattern.
	 * @param stringMode
	 * 		How to match class names.
	 */
	public ClassReferenceQuery(String name, StringMatchMode stringMode) {
		super(QueryType.CLASS_REFERENCE, stringMode);
		this.name = name;
	}

	/**
	 * Adds a result if the given class matches the specified name pattern.
	 *
	 * @param access
	 * 		Class modifiers.
	 * @param name
	 * 		Name of class.
	 */
	public void match(IntSupplier access, String name) {
		if (stringMode.match(this.name, name)) {
			getMatched().add(new ClassResult(access.getAsInt(), name));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/ClassResult.java`:

```java
package me.coley.recaf.search;

import java.util.Objects;

/**
 * Search result of a matched class.
 *
 * @author Matt
 */
public class ClassResult extends SearchResult {
	private final int access;
	private final String name;

	/**
	 * Constructs a class result.
	 *
	 * @param access
	 * 		Class modifiers.
	 * @param name
	 * 		Name of class.
	 */
	public ClassResult(int access, String name) {
		this.access = access;
		this.name = name;
	}

	/**
	 * @return Class modifiers.
	 */
	public int getAccess() {
		return access;
	}

	/**
	 * @return Name of class.
	 */
	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return name;
	}

	@Override
	public int hashCode() {
		return Objects.hash(name, access);
	}

	@Override
	public boolean equals(Object other) {
		if (other instanceof ClassResult)
			return hashCode() == other.hashCode();
		return false;
	}

	@Override
	public int compareTo(SearchResult other) {
		int ret = super.compareTo(other);
		if (ret == 0) {
			if (other instanceof ClassResult) {
				ClassResult otherResult = (ClassResult) other;
				return name.compareTo(otherResult.name);
			}
		}
		return ret;
	}
}

```

`src/main/java/me/coley/recaf/search/Context.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.parse.bytecode.Disassembler;
import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * Utility to allow results to easily be linked with their location.
 *
 * @param <T>
 * 		Parent context type.
 *
 * @author Matt
 */
@SuppressWarnings("unchecked")
public abstract class Context<T extends Context> implements Comparable<Context<?>> {
	private static final int WIDER_SCOPE = 1;
	private static final int DEEPER_SCOPE = -1;
	protected T parent;

	/**
	 * @return Parent context. {@code null} if the current context is a Class.
	 */
	public T getParent() {
		return parent;
	}

	/**
	 * Creates a context.
	 *
	 * @param access
	 * 		Class modifiers.
	 * @param name
	 * 		Name of class.
	 *
	 * @return Class context.
	 */
	public static ClassContext withClass(int access, String name) {
		return new ClassContext(access, name);
	}

	/**
	 * Appends an annotation context.
	 *
	 * @param type
	 * 		Annotation type.
	 *
	 * @return Annotation context.
	 */
	public AnnotationContext withAnno(String type) {
		return new AnnotationContext(this, type);
	}

	/**
	 * @param other
	 * 		Context to be compared
	 *
	 * @return {@code true} if both contexts are considered similar.
	 */
	public boolean isSimilar(Context<?> other) {
		return this == other || (this.getClass() == other.getClass() && this.compareTo(other) == 0);
	}

	/**
	 * @param other
	 * 		Context to be compared.
	 *
	 * @return {@code true} if this context contains the other.
	 */
	public abstract boolean contains(Context<?> other);

	/**
	 * Class context.
	 */
	public static class ClassContext extends Context<Context> {
		private final int access;
		private final String name;

		/**
		 * @param access
		 * 		Class modifiers.
		 * @param name
		 * 		Name of class.
		 */
		ClassContext(int access, String name) {
			this.access = access;
			this.name = name;
		}

		/**
		 * @return Class modifiers.
		 */
		public int getAccess() {
			return access;
		}

		/**
		 * @return Name of class.
		 */
		public String getName() {
			return name;
		}

		/**
		 * Appends a member context.
		 *
		 * @param access
		 * 		Member modifiers.
		 * @param name
		 * 		Name of member.
		 * @param desc
		 * 		Descriptor of member.
		 *
		 * @return Member context.
		 */
		public MemberContext withMember(int access, String name, String desc) {
			return new MemberContext(this, access, name, desc);
		}

		@Override
		public int compareTo(Context<?> other) {
			if(other instanceof ClassContext) {
				ClassContext otherClass = (ClassContext) other;
				return name.compareTo(otherClass.name);
			}
			return WIDER_SCOPE;
		}

		@Override
		public boolean contains(Context<?> other) {
			// Check if member is in class
			if (other instanceof MemberContext)
				return (other.getParent().compareTo(this) == 0);
			else {
				// Get root context of other
				while (other.getParent() != null)
					other = other.getParent();
				// Check for match against this class
				return (other.compareTo(this) == 0);
			}
		}

		@Override
		public String toString() {
			return name;
		}
	}

	/**
	 * Member context.
	 */
	public static class MemberContext extends Context<ClassContext> {
		private final int access;
		private final String name;
		private final String desc;

		/**
		 * @param parent
		 * 		Parent context.
		 * @param access
		 * 		Member modifers.
		 * @param name
		 * 		Name of member.
		 * @param desc
		 * 		Descriptor of member.
		 */
		MemberContext(ClassContext parent, int access, String name, String desc) {
			this.parent = parent;
			this.access = access;
			this.name = name;
			this.desc = desc;
		}

		/**
		 * @return Member modifiers.
		 */
		public int getAccess() {
			return access;
		}

		/**
		 * @return Member name.
		 */
		public String getName() {
			return name;
		}

		/**
		 * @return Member descriptor.
		 */
		public String getDesc() {
			return desc;
		}

		/**
		 * @return {@code true} if the {@link #getDesc() descriptor} outlines a field type.
		 */
		public boolean isField() {
			return !isMethod();
		}

		/**
		 * @return {@code true} if the {@link #getDesc() descriptor} outlines a method type.
		 */
		public boolean isMethod() {
			return desc.contains("(");
		}

		/**
		 * Appends an instruction context.
		 *
		 * @param insn
		 * 		Instruction value.
		 * @param pos
		 * 		Offset in the method instructions.
		 *
		 * @return Instruction context.
		 */
		public InsnContext withInsn(AbstractInsnNode insn, int pos) {
			return new InsnContext(this, insn, pos);
		}

		/**
		 * Appends a local variable context.
		 *
		 * @param index
		 * 		Variable index.
		 * @param name
		 * 		Variable name.
		 * @param descriptor
		 * 		Variable descriptor.
		 *
		 * @return Local variable context.
		 */
		public LocalContext withLocal(int index, String name, String descriptor) {
			return new LocalContext(this, index, name, descriptor);
		}

		/**
		 * Appends a catch block context.
		 *
		 * @param type
		 * 		Catch type.
		 *
		 * @return Catch block context.
		 */
		public CatchContext withCatch(String type) {
			return new CatchContext(this, type);
		}


		@Override
		public int compareTo(Context<?> other) {
			if(other instanceof ClassContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof MemberContext) {
				if (parent.compareTo(other.parent) == 0) {
					MemberContext otherMember = (MemberContext) other;
					return (name + desc).compareTo(otherMember.name + otherMember.desc);
				}
			}
			return WIDER_SCOPE;
		}

		@Override
		public boolean contains(Context<?> other) {
			// Check if the other context is an instruction that resides in this method.
			if (other instanceof InsnContext)
				return (other.getParent().compareTo(this) == 0);
			return false;
		}

		@Override
		public String toString() {
			String suffix = isMethod() ? name + desc : name + " " + desc;
			return parent.toString() + " " + suffix;
		}
	}

	/**
	 * Method local variable context.
	 */
	public static class LocalContext extends Context<MemberContext> {
		private final int index;
		private final String name;
		private final String descriptor;

		/**
		 * @param parent
		 * 		Method parent context.
		 * @param index
		 * 		Variable index.
		 * @param name
		 * 		Variable name.
		 * @param descriptor
		 * 		Variable type descriptor.
		 */
		public LocalContext(MemberContext parent, int index, String name, String descriptor) {
			this.parent = parent;
			this.index = index;
			this.name = name;
			this.descriptor = descriptor;
		}

		/**
		 * @return Variable index.
		 */
		public int getIndex() {
			return index;
		}

		/**
		 * @return Variable name.
		 */
		public String getName() {
			return name;
		}

		/**
		 * @return Variable type descriptor.
		 */
		public String getDescriptor() {
			return descriptor;
		}

		@Override
		public boolean contains(Context<?> other) {
			return false;
		}

		@Override
		public int compareTo(Context<?> other) {
			if(other instanceof MemberContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof LocalContext) {
				if (parent.compareTo(other.parent) == 0) {
					LocalContext otherLocal = (LocalContext) other;
					return Integer.compare(index, otherLocal.index);
				}
			}
			return WIDER_SCOPE;
		}
	}

	/**
	 * Catch block context.
	 */
	public static class CatchContext extends Context<MemberContext> {
		private final String type;

		/**
		 * @param parent
		 * 		Method parent context.
		 * @param type
		 * 		Catch type.
		 */
		public CatchContext(MemberContext parent, String type) {
			this.parent = parent;
			this.type = type;
		}

		/**
		 * @return Catch type.
		 */
		public String getType() {
			return type;
		}

		@Override
		public boolean contains(Context<?> other) {
			return false;
		}

		@Override
		public int compareTo(Context<?> other) {
			if(other instanceof MemberContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof CatchContext) {
				if (parent.compareTo(other.parent) == 0) {
					CatchContext otherCatch = (CatchContext) other;
					return type.compareTo(otherCatch.type);
				}
			}
			return WIDER_SCOPE;
		}
	}

	/**
	 * Instruction context.
	 */
	public static class InsnContext extends Context<MemberContext> {
		private final AbstractInsnNode insn;
		private final int pos;

		/**
		 * @param parent
		 * 		Parent context.
		 * @param insn
		 * 		Instruction value.
		 * 	 @param pos
		 * 		  		Offset in the method instructions.
		 */
		InsnContext(MemberContext parent, AbstractInsnNode insn, int pos) {
			this.parent = parent;
			this.insn = insn;
			this.pos = pos;
		}

		/**
		 * @return Instruction value.
		 */
		public AbstractInsnNode getInsn() {
			return insn;
		}

		@Override
		public int compareTo(Context<?> other) {
			if(other instanceof ClassContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof MemberContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof InsnContext) {
				if (parent.compareTo(other.parent) == 0) {
					InsnContext otherInsn = (InsnContext) other;
					return Integer.compare(pos, otherInsn.pos);
				}
			}
			// Most deep context, so always be "less than"
			return DEEPER_SCOPE;
		}

		@Override
		public boolean isSimilar(Context<?> other) {
			return this == other || (this.getClass() == other.getClass() && parent.compareTo(other.parent) == 0);
		}

		@Override
		public boolean contains(Context<?> other) {
			// Insns are the deepest scope, so it doesn't make sense to contain anything.
			return false;
		}

		@Override
		public String toString() {
			return parent.toString() + " " + pos + ":" + Disassembler.insn(insn);
		}
	}

	/**
	 * Annotation context.
	 */
	public static class AnnotationContext extends Context<Context> {
		private final String type;

		/**
		 * @param parent
		 * 		Parent context.
		 * @param type
		 * 		Annotation type.
		 */
		AnnotationContext(Context parent, String type) {
			this.parent = parent;
			this.type = type;
		}

		/**
		 * @return Annotation type.
		 */
		public String getType() {
			return type;
		}

		@Override
		@SuppressWarnings("unchecked")
		public int compareTo(Context<?> other) {
			if(other instanceof ClassContext) {
				return DEEPER_SCOPE;
			} else if(other instanceof MemberContext) {
				return WIDER_SCOPE;
			} else if(other instanceof InsnContext) {
				return WIDER_SCOPE;
			} else if(other instanceof AnnotationContext) {
				if (parent.compareTo(other.parent) == 0) {
					AnnotationContext otherAnno = (AnnotationContext) other;
					return type.compareTo(otherAnno.type);
				}
			}
			return WIDER_SCOPE;
		}

		@Override
		public boolean contains(Context<?> other) {
			// Check if the other context is an embedded annotation.
			if (other instanceof AnnotationContext) {
				return (other.getParent().compareTo(this) == 0);
			}
			return false;
		}

		@Override
		public String toString() {
			return "@" + type + " " + parent.toString();
		}
	}
}

```

`src/main/java/me/coley/recaf/search/InsnResult.java`:

```java
package me.coley.recaf.search;

import java.util.List;
import java.util.Objects;

/**
 * Search result of a matched class.
 *
 * @author Matt
 */
public class InsnResult extends SearchResult {
	private final int index;
	private final List<String> lines;

	/**
	 * Constructs a insn result.
	 *
	 * @param index
	 * 		Index of first matched item.
	 * @param lines
	 * 		Lines of matched dissasembled method code.
	 */
	public InsnResult(int index, List<String> lines) {
		this.index = index;
		this.lines = lines;
	}

	/**
	 * @return Matched Lines of dissasembled method code.
	 */
	public List<String> getLines() {
		return lines;
	}

	@Override
	public String toString() {
		return String.join("\n", lines);
	}

	@Override
	public int hashCode() {
		return Objects.hash(lines);
	}

	@Override
	public boolean equals(Object other) {
		if (other instanceof InsnResult)
			return hashCode() == other.hashCode();
		return false;
	}

	@Override
	@SuppressWarnings("unchecked")
	public int compareTo(SearchResult other) {
		int ret = super.compareTo(other);
		if (ret == 0) {
			if (other instanceof InsnResult) {
				InsnResult otherResult = (InsnResult) other;
				ret = getContext().getParent().compareTo(otherResult.getContext().getParent());
				// Same method -> sort by index
				if (ret == 0)
					return Integer.compare(index, otherResult.index);
				// Different method
				return ret;
			}
		}
		return ret;
	}
}

```

`src/main/java/me/coley/recaf/search/InsnTextQuery.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.util.StringUtil;

import java.util.ArrayList;
import java.util.List;

/**
 * Query to find instructions based off of their disassembled representation.
 *
 * @author Matt
 */
public class InsnTextQuery extends Query {
	private final List<String> lines;

	/**
	 * Constructs a instruction text query.
	 *
	 * @param lines
	 * 		Consecutive lines to match.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public InsnTextQuery(List<String> lines, StringMatchMode stringMode) {
		super(QueryType.INSTRUCTION_TEXT, stringMode);
		this.lines = lines;
	}

	/**
	 * Adds a result if the given class matches the specified name pattern.
	 *
	 * @param code
	 * 		Disassembled method code.
	 */
	public void match(String code) {
		String[] codeLines = StringUtil.splitNewline(code);
		int max = codeLines.length - lines.size();
		// Ensure search query is shorter than method code
		if (max <= 0)
			return;
		// Iterate over method code
		for (int i = 0; i < max; i++) {
			boolean match = true;
			List<String> ret = new ArrayList<>();
			// Iterate over query code
			// - Assert each line matches the query input
			// - If matching for all lines, return the match
			// - If a line doesn't match skip to the next method insn starting point
			for (int j = 0; j < lines.size(); j++) {
				String line = lines.get(j);
				String lineDis = codeLines[i+j];
				ret.add(lineDis);
				if (!stringMode.match(line, lineDis)) {
					match = false;
					break;
				}
			}
			// Add result and continue to next line
			if(match) {
				getMatched().add(new InsnResult(i, ret));
				i += lines.size() - 1;
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/search/MemberDefinitionQuery.java`:

```java
package me.coley.recaf.search;

/**
 * Query to find member definitions matching the given information.
 *
 * @author Matt
 */
public class MemberDefinitionQuery extends Query {
	private final String owner;
	private final String name;
	private final String desc;

	/**
	 * Constructs a member definition query.
	 *
	 * @param owner
	 * 		Name of class containing the member. May be {@code null} to match members of any class.
	 * @param name
	 * 		Member name. May be {@code null} to match members of any name.
	 * @param desc
	 * 		Member descriptor. May be {@code null} to match members of any type.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public MemberDefinitionQuery(String owner, String name, String desc, StringMatchMode
			stringMode) {
		super(QueryType.MEMBER_DEFINITION, stringMode);
		if(owner == null && name == null && desc == null) {
			throw new IllegalArgumentException("At least one query parameter must be non-null!");
		}
		this.owner = owner;
		this.name = name;
		this.desc = desc;
	}

	/**
	 * Adds a result if the given member matches the specified member.
	 *
	 * @param access
	 * 		Member modifers.
	 * @param owner
	 * 		Name of class containing the member.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	public void match(int access, String owner, String name, String desc) {
		boolean hasOwner = this.owner == null || stringMode.match(this.owner, owner);
		boolean hasName = this.name == null || stringMode.match(this.name, name);
		boolean hasDesc = this.desc == null || stringMode.match(this.desc, desc);
		if(hasOwner && hasName && hasDesc) {
			getMatched().add(new MemberResult(access, owner, name, desc));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/MemberReferenceQuery.java`:

```java
package me.coley.recaf.search;

import java.util.function.IntSupplier;

/**
 * Query to find member references matching the given information.
 *
 * @author Matt
 */
public class MemberReferenceQuery extends Query {
	private final String owner;
	private final String name;
	private final String desc;

	/**
	 * Constructs a member references query.
	 *
	 * @param owner
	 * 		Name of class containing the member. May be {@code null} to match members of any class.
	 * @param name
	 * 		Member name. May be {@code null} to match members of any name.
	 * @param desc
	 * 		Member descriptor. May be {@code null} to match members of any type.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public MemberReferenceQuery(String owner, String name, String desc, StringMatchMode
			stringMode) {
		super(QueryType.MEMBER_REFERENCE, stringMode);
		if(owner == null && name == null && desc == null) {
			throw new IllegalArgumentException("At least one query parameter must be non-null!");
		}
		this.owner = owner;
		this.name = name;
		this.desc = desc;
	}

	/**
	 * Adds a result if the given member matches the specified member.
	 *
	 * @param access
	 * 		Member modifers.
	 * @param owner
	 * 		Name of class containing the member.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	public void match(IntSupplier access, String owner, String name, String desc) {
		boolean hasOwner = this.owner == null || stringMode.match(this.owner, owner);
		boolean hasName = this.name == null || stringMode.match(this.name, name);
		boolean hasDesc = this.desc == null || stringMode.match(this.desc, desc);
		if(hasOwner && hasName && hasDesc) {
			getMatched().add(new MemberResult(access.getAsInt(), owner, name, desc));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/MemberResult.java`:

```java
package me.coley.recaf.search;

import java.util.Objects;

/**
 * Search result of a matched member.
 *
 * @author Matt
 */
public class MemberResult extends SearchResult {
	private final int access;
	private final String owner;
	private final String name;
	private final String desc;

	/**
	 * Constructs a member result.
	 *
	 * @param access
	 * 		Member modifers.
	 * @param owner
	 * 		Name of class containing the member.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	public MemberResult(int access, String owner, String name, String desc) {
		this.access = access;
		this.owner = owner;
		this.name = name;
		this.desc = desc;
	}

	/**
	 * @return Member modifiers.
	 */
	public int getAccess() {
		return access;
	}

	/**
	 * @return Name of class containing the member.
	 */
	public String getOwner() {
		return owner;
	}

	/**
	 * @return Member name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Member descriptor.
	 */
	public String getDesc() {
		return desc;
	}

	/**
	 * @return {@code true} if the {@link #getDesc() descriptor} outlines a field type.
	 */
	public boolean isField() {
		return !isMethod();
	}

	/**
	 * @return {@code true} if the {@link #getDesc() descriptor} outlines a method type.
	 */
	public boolean isMethod() {
		return desc.contains("(");
	}

	@Override
	public String toString() {
		if(isMethod()) {
			return owner + "." + name + desc;
		} else {
			return owner + "." + name + " " + desc;
		}
	}

	@Override
	public int hashCode() {
		return Objects.hash(owner, name, desc);
	}

	@Override
	public boolean equals(Object other) {
		if(other instanceof MemberResult)
			return hashCode() == other.hashCode();
		return false;
	}

	@Override
	public int compareTo(SearchResult other) {
		int ret = super.compareTo(other);
		if (ret == 0) {
			if (other instanceof MemberResult) {
				MemberResult otherResult = (MemberResult) other;
				if (isField() && otherResult.isMethod())
					return 1;
				if (isMethod() && otherResult.isField())
					return -1;
				return toString().compareTo(otherResult.toString());
			}
		}
		return ret;
	}
}

```

`src/main/java/me/coley/recaf/search/Query.java`:

```java
package me.coley.recaf.search;

import java.util.*;

/**
 * Query base.
 *
 * @author Matt
 */
public abstract class Query {
	private final QueryType type;
	protected final StringMatchMode stringMode;
	protected final List<SearchResult> matched = new ArrayList<>();

	/**
	 * Baseline query.
	 *
	 * @param type
	 * 		Type of query implementation.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public Query(QueryType type, StringMatchMode stringMode) {
		this.type = type;
		this.stringMode = stringMode;
	}

	/**
	 * @return Implementation type.
	 */
	public QueryType getType() {
		return type;
	}

	/**
	 * @param type
	 * 		Implementation type.
	 *
	 * @return {@code true} if the query's type matches the given type.
	 */
	public boolean isType(QueryType type) {
		return this.type.equals(type);
	}

	/**
	 * A temporary storage of results.
	 *
	 * @return List of results matched.
	 */
	public List<SearchResult> getMatched() {
		return matched;
	}
}

```

`src/main/java/me/coley/recaf/search/QueryType.java`:

```java
package me.coley.recaf.search;

/**
 * Type of query, useful for switching over query implementation types.
 *
 * @author Matt
 */
public enum QueryType {
	/**
	 * Match a class if it matches a given name.
	 */
	CLASS_NAME,
	/**
	 * Match a class if it inherits a given class.
	 */
	CLASS_INHERITANCE,
	/**
	 * Match a member if it matches a given definition.
	 */
	MEMBER_DEFINITION,
	/**
	 * Match an instruction if it references a given class.
	 */
	CLASS_REFERENCE,
	/**
	 * Match an instruction if it references a given member.
	 */
	MEMBER_REFERENCE,
	/**
	 * Match an instruction / field-constant if it's string value matches a given pattern.
	 */
	STRING,
	/**
	 * Match an instruction if it contains a given value.
	 */
	VALUE,
	/**
	 * Match a method if it contains the given sequence of instruction patterns.
	 */
	INSTRUCTION_TEXT
}

```

`src/main/java/me/coley/recaf/search/SearchAnnotationVisitor.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;

import java.lang.reflect.Array;

/**
 * Visitor that adds matched results in annotations to a result collector.
 *
 * @author Matt
 */
public class SearchAnnotationVisitor extends AnnotationVisitor {
	private final SearchCollector collector;
	private final Context.AnnotationContext context;

	/**
	 * Constructs an annotation search visitor.
	 *
	 * @param collector
	 * 		Result collector.
	 * @param context
	 * 		Current search context.
	 * @param descriptor
	 * 		Annotation type.
	 */
	public SearchAnnotationVisitor(SearchCollector collector, Context<?> context, String
			descriptor) {
		super(Recaf.ASM_VERSION);
		this.collector = collector;
		this.context = context.withAnno(descriptor);
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					String type = Type.getType(descriptor).getInternalName();
					q.match(collector.getAccess(type, Opcodes.ACC_ANNOTATION), type);
					collector.addMatched(this.context, q);
				});
	}

	@Override
	public void visit(String name, Object value) {
		// Skip null
		if (value == null) {
			return;
		}
		if (value instanceof String) {
			collector.queries(StringQuery.class)
					.forEach(q -> {
						q.match((String) value);
						collector.addMatched(context, q);
					});
		} else if (value instanceof Number) {
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						q.match(value);
						collector.addMatched(context, q);
					});
		} else if (value instanceof Character){
			int cval = (Character) value;
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						q.match(cval);
						collector.addMatched(context, q);
					});
		} else if (value.getClass().isArray()) {
			int length = Array.getLength(value);
			Object[] array = new Object[length];
			for(int i = 0; i < length; i++)
				array[i] = Array.get(value, i);
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						for (Object i : array)
							q.match(i);
						collector.addMatched(context, q);
					});
		}
	}

	@Override
	public void visitEnum(String name, String descriptor, String value) {
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					String type = Type.getType(descriptor).getInternalName();
					q.match(collector.getAccess(type, Opcodes.ACC_ANNOTATION), type);
					collector.addMatched(context, q);
				});
		collector.queries(StringQuery.class)
				.forEach(q -> {
					q.match(value);
					collector.addMatched(context, q);
				});
	}

	@Override
	public AnnotationVisitor visitAnnotation(String name, String descriptor) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitArray(final String name) {
		return this;
	}
}
```

`src/main/java/me/coley/recaf/search/SearchBuilder.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.*;

import java.util.*;

/**
 * Builder for {@link SearchCollector}.
 *
 * @author Matt
 */
public class SearchBuilder {
	private final Workspace workspace;
	private final List<Query> queries = new ArrayList<>();
	private int readFlags = ClassReader.SKIP_FRAMES;
	private Collection<String> skipped = Collections.emptyList();

	private SearchBuilder(Workspace workspace) {
		this.workspace = workspace;
	}

	/**
	 * @param workspace
	 * 		The workspace to search in. Only uses the primary resource.
	 *
	 * @return Initial builder.
	 */
	public static SearchBuilder in(Workspace workspace) {
		return new SearchBuilder(workspace);
	}

	/**
	 * @param query
	 * 		Query to add to the search.
	 *
	 * @return Builder with additional query.
	 */
	public SearchBuilder query(Query query) {
		queries.add(query);
		return this;
	}

	/**
	 * @return Builder that skips debug information <i>
	 * ({@link org.objectweb.asm.ClassVisitor#visitSource},
	 * {@link org.objectweb.asm.MethodVisitor#visitLocalVariable}, and
	 * {@link org.objectweb.asm.MethodVisitor#visitLineNumber})</i>
	 */
	public SearchBuilder skipDebug() {
		this.readFlags |= ClassReader.SKIP_DEBUG;
		return this;
	}

	/**
	 * @return Builder that skips parsing method bodies.
	 */
	public SearchBuilder skipCode() {
		this.readFlags |= ClassReader.SKIP_CODE;
		return this;
	}

	/**
	 * @param skipped
	 * 		Package prefixes to skip.
	 *
	 * @return Builder that skips classes matching the given packages/prefixes.
	 */
	public SearchBuilder skipPackages(Collection<String> skipped) {
		this.skipped = skipped;
		return this;
	}

	/**
	 * @return SearchCollector from the builder. The search is started by calling this method.
	 */
	public SearchCollector build() {
		SearchCollector collector = new SearchCollector(workspace, queries);
		SearchClassVisitor sv = new SearchClassVisitor(collector);
		workspace.getPrimaryClassReaders().forEach(cr -> {
			String name = cr.getClassName();
			if (skip(name))
				return;
			cr.accept(sv, readFlags);
		});
		return collector;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return {@code true} if the class should be skipped.
	 */
	private boolean skip(String name) {
		return skipped.stream().anyMatch(name::startsWith);
	}
}

```

`src/main/java/me/coley/recaf/search/SearchClassVisitor.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;

/**
 * Visitor that adds matched results in classes to a result collector.
 *
 * @author Matt
 */
public class SearchClassVisitor extends ClassVisitor {
	private final SearchCollector collector;
	private Context.ClassContext context;

	/**
	 * @param collector
	 * 		Result collector.
	 */
	public SearchClassVisitor(SearchCollector collector) {
		super(Recaf.ASM_VERSION);
		this.collector = collector;
	}

	/**
	 * @return Root search context.
	 */
	public Context.ClassContext getContext() {
		return context;
	}

	@Override
	public void visit(int version, int access, String name, String sig, String superName, String[] interfaces) {
		context = Context.withClass(access, name);
		collector.queries(ClassNameQuery.class)
				.forEach(q -> {
					q.match(access, name);
					collector.addMatched(context, q);
				});
		collector.queries(ClassInheritanceQuery.class)
				.forEach(q -> {
					q.match(access, name);
					collector.addMatched(context, q);
				});
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int ref, TypePath typePath, String descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public FieldVisitor visitField(int access, String name, String descriptor, String signature,
								   Object value) {
		Context.MemberContext fieldContext = context.withMember(access, name, descriptor);
		if (value instanceof String) {
			collector.queries(StringQuery.class)
					.forEach(q -> {
						q.match((String) value);
						collector.addMatched(fieldContext, q);
					});
		} else {
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						q.match(value);
						collector.addMatched(fieldContext, q);
					});
		}
		collector.queries(MemberDefinitionQuery.class)
				.forEach(q -> {
					q.match(access, context.getName(), name, descriptor);
					collector.addMatched(fieldContext, q);
				});
		return new SearchFieldVisitor(collector, fieldContext);
	}

	@Override
	public MethodVisitor visitMethod(int access, String name, String descriptor, String sig, String[] ex) {
		Context.MemberContext methodContext = context.withMember(access, name, descriptor);
		collector.queries(MemberDefinitionQuery.class)
				.forEach(q -> {
					q.match(access, context.getName(), name, descriptor);
					collector.addMatched(methodContext, q);
				});
		return new SearchMethodVisitor(collector, methodContext);
	}
}

```

`src/main/java/me/coley/recaf/search/SearchCollector.java`:

```java
package me.coley.recaf.search;

import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import com.google.common.collect.Multimaps;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;

import java.util.*;
import java.util.function.Function;
import java.util.function.IntSupplier;
import java.util.stream.Stream;

import static org.objectweb.asm.ClassReader.*;

/*
 * TODO with Search API:
 *  - Method inheritance (child of given)
 *  - Strings in odd places (dynamic instruction arguments)
 *  - Not internal to the API, but supply a way to handle "\\uXXXX" (unicode search)
 *  - Smart optimization, skip certain visitor-api calls if we know our queries won't need to look there
 */
/**
 * Search result collector.
 *
 * @author Matt
 */
public class SearchCollector {
	public static final int ACC_NOT_FOUND = 0;
	private final ListMultimap<Query, SearchResult> results = MultimapBuilder
			.linkedHashKeys(2).arrayListValues().build();
	private final Map<Query, List<SearchResult>> resultMapView = Multimaps.asMap(results);
	private final Workspace workspace;
	private final Collection<Query> queries;

	/**
	 * Constructs a class search visitor.
	 *
	 * @param workspace
	 * 		Workspace to pull additional references from.
	 * @param queries
	 * 		Queries to check for collecting results.
	 */
	public SearchCollector(Workspace workspace, Collection<Query> queries) {
		this.workspace = workspace;
		this.queries = queries;
	}

	/**
	 * @return Map of queries to their results.
	 */
	public ListMultimap<Query, SearchResult> getResultsMap() {
		return results;
	}

	/**
	 * @return Flattened list of the {@link #getResultsMap() result map} containing entries shared
	 * among multiple queries that are similar.
	 * @see SearchResult#isContextSimilar(SearchResult)
	 */
	public List<SearchResult> getOverlappingResults() {
		// Get results of multiple queries that are similar
		return resultMapView.values().stream()
				// Cast the stream to Collection for compatibility with LinkedHashSet
				.map((Function<List<?>, Collection<SearchResult>>) Collection.class::cast)
				.reduce((a, b) -> {
					Set<SearchResult> overlapping = new LinkedHashSet<>(Math.min(a.size(), b.size()));
					for (SearchResult resultA : a) {
						for (SearchResult resultB : b) {
							if (resultA.isContextSimilar(resultB) || (
								resultA.getContext().contains(resultB.getContext()) ||
								resultB.getContext().contains(resultA.getContext()))) {
								overlapping.add(resultA);
								overlapping.add(resultB);
							}
						}
					}
					return overlapping;
				})
				// Cast the Optional to List for compatibility with Collections.emptyList()
				.map((Function<Collection<SearchResult>, List<SearchResult>>) ArrayList::new)
				.orElseGet(Collections::emptyList);
	}

	/**
	 * @return Flattened list of the {@link #getResultsMap() result map}.
	 */
	public List<SearchResult> getAllResults() {
		return new ArrayList<>(results.values());
	}

	/**
	 * @param clazz
	 * 		Query class reference.
	 * @param <T>
	 * 		Kind of query class.
	 *
	 * @return Stream of queries matching the given class.
	 */
	<T extends Query> Stream<T> queries(Class<T> clazz) {
		return queries.stream()
				.filter(clazz::isInstance)
				.map(clazz::cast);
	}

	/**
	 * Adds all results from the query to the {@link #getResultsMap() results map}.
	 *
	 * @param context
	 * 		Optional context to add to results.
	 * @param query
	 * 		Query with results to add.
	 */
	void addMatched(Context<?> context, Query query) {
		List<SearchResult> matched = query.getMatched();
		if(context == null)
			throw new IllegalStateException("Must have context");
		matched.forEach(res -> res.setContext(context));
		results.putAll(query, matched);
		matched.clear();
	}

	// We use suppliers so that we don't have to lookup this information unless
	// we are sure that there is a match and this information is needed.
	// Looking this up in hundreds of cases where we don't need it would just waste time.

	IntSupplier getAccess(String owner, String name, String desc) {
		return () -> acc(owner, name, desc, ACC_NOT_FOUND);
	}

	IntSupplier getAccess(String name, int defaultAcc) {
		return () -> acc(name, defaultAcc);
	}

	private int acc(String name, int defaultAcc) {
		// Descriptor format
		if(name.endsWith(";"))
			throw new IllegalStateException("Must use internal name, not descriptor!");
		// Get access
		if(workspace.hasClass(name))
			return workspace.getClassReader(name).getAccess();
		// Unknown
		return defaultAcc;
	}

	private int acc(String owner, String name, String desc, int defaultAcc) {
		if(workspace.hasClass(owner))
			if(desc.contains("(")) {
				ClassReader reader = workspace.getClassReader(owner);
				MethodNode node = ClassUtil.getMethod(
						reader, SKIP_CODE | SKIP_DEBUG, name, desc);
				if(node != null)
					return node.access;
				// Try and look in parent classes for the method definition
				int ret = acc(reader.getSuperName(), name, desc, defaultAcc);
				if(ret != defaultAcc)
					return ret;
				for(String itf : reader.getInterfaces()) {
					ret = acc(itf, name, desc, defaultAcc);
					if(ret != defaultAcc)
						return ret;
				}
			} else {
				FieldNode node = ClassUtil.getField(
						workspace.getClassReader(owner), SKIP_CODE | SKIP_DEBUG, name, desc);
				if(node != null)
					return node.access;
			}
		return defaultAcc;
	}
}

```

`src/main/java/me/coley/recaf/search/SearchFieldVisitor.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;

/**
 * Visitor that adds matched results in fields to a result collector.
 *
 * @author Matt
 */
public class SearchFieldVisitor extends FieldVisitor {
	private final SearchCollector collector;
	private final Context.MemberContext context;

	/**
	 * @param collector
	 * 		Result collector.
	 * @param context
	 * 		Field context.
	 */
	public SearchFieldVisitor(SearchCollector collector, Context.MemberContext context) {
		super(Recaf.ASM_VERSION);
		this.collector = collector;
		this.context = context;
	}

	/**
	 * @return Field search context.
	 */
	public Context.MemberContext getContext() {
		return context;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String
			descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}
}
```

`src/main/java/me/coley/recaf/search/SearchMethodVisitor.java`:

```java
package me.coley.recaf.search;

import me.coley.recaf.Recaf;
import me.coley.recaf.parse.bytecode.Disassembler;
import me.coley.recaf.util.AccessFlag;
import me.coley.recaf.util.InsnUtil;
import me.coley.recaf.util.Log;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.List;
import java.util.stream.Collectors;

import static me.coley.recaf.search.SearchCollector.ACC_NOT_FOUND;

/**
 * Visitor that adds matched results in methods to a result collector.
 *
 * @author Matt
 */
public class SearchMethodVisitor extends MethodNode {
	private final SearchCollector collector;
	private final Context.MemberContext context;

	/**
	 * @param collector
	 * 		Result collector.
	 * @param context
	 * 		Search context base.
	 */
	public SearchMethodVisitor(SearchCollector collector, Context.MemberContext context) {
		super(Recaf.ASM_VERSION);
		this.access = context.getAccess();
		this.name = context.getName();
		this.desc = context.getDesc();
		this.collector = collector;
		this.context = context;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor,
												 boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor,
												 boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor,
													 boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start,
														  Label[] end, int[] index, String descriptor,
														  boolean visible) {
		return new SearchAnnotationVisitor(collector, context, descriptor);
	}

	@Override
	public void visitLocalVariable(String name, String descriptor, String signature, Label start,
								   Label end, int index) {
		super.visitLocalVariable(name, descriptor, signature, start, end, index);
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					Type t = Type.getType(descriptor);
					if (t.getSort() == Type.ARRAY)
						t = t.getElementType();
					String type = t.getInternalName();
					q.match(collector.getAccess(type, ACC_NOT_FOUND), type);
					collector.addMatched(context.withLocal(index, name, descriptor), q);
				});
	}

	@Override
	public void visitInsn(int opcode) {
		super.visitInsn(opcode);
		if (opcode >= Opcodes.ICONST_M1 && opcode <= Opcodes.DCONST_1) {
			int value = InsnUtil.getValue(opcode);
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						q.match(value);
						collector.addMatched(context.withInsn(last(), lastPos()), q);
					});
		}

	}

	@Override
	public void visitIntInsn(int opcode, int operand) {
		super.visitIntInsn(opcode, operand);
		collector.queries(ValueQuery.class)
				.forEach(q -> {
					q.match(operand);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});	}

	@Override
	public void visitIincInsn(int var, int increment) {
		super.visitIincInsn(var, increment);
		collector.queries(ValueQuery.class)
				.forEach(q -> {
					q.match(increment);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});
	}

	@Override
	public void visitTableSwitchInsn(
			int min, int max, Label dflt,  Label... labels) {
		super.visitTableSwitchInsn(min, max, dflt, labels);
		collector.queries(ValueQuery.class)
				.forEach(q -> {
					q.match(min);
					q.match(max);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});
	}

	@Override
	public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
		super.visitLookupSwitchInsn(dflt, keys, labels);
		collector.queries(ValueQuery.class)
				.forEach(q -> {
					for(int key : keys)
						q.match(key);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});
	}

	@Override
	public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {
		super.visitMultiANewArrayInsn(descriptor, numDimensions);
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					String types = Type.getType(descriptor).getInternalName();
					q.match(collector.getAccess(types, ACC_NOT_FOUND), types);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});
	}

	@Override
	public void visitTypeInsn(int opcode, String type) {
		super.visitTypeInsn(opcode, type);
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					Type typee = type.contains(";") ? Type.getType(type) : Type.getObjectType(type);
					String types = typee.getSort() == Type.ARRAY ?
							typee.getElementType().getInternalName() : typee.getInternalName();
					q.match(collector.getAccess(types, ACC_NOT_FOUND), types);
					collector.addMatched(context.withInsn(last(), lastPos()), q);
				});
	}

	@Override
	public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
		super.visitTryCatchBlock(start, end, handler, type);
		collector.queries(ClassReferenceQuery.class)
				.forEach(q -> {
					if (type == null)
						return;
					// "type" is already in internal format
					q.match(collector.getAccess(type, ACC_NOT_FOUND), type);
					collector.addMatched(context.withCatch(type), q);
				});
	}

	@Override
	public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {
		super.visitFieldInsn(opcode, owner,name, descriptor);
		Context.InsnContext insnContext = context.withInsn(last(), lastPos());
		collector.queries(MemberReferenceQuery.class)
				.forEach(q -> {
					q.match(collector.getAccess(owner, name, descriptor), owner, name, descriptor);
					collector.addMatched(insnContext, q);
				});
	}

	@Override
	public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean itf) {
		super.visitMethodInsn(opcode, owner, name, descriptor, itf);
		Context.InsnContext insnContext = context.withInsn(last(), lastPos());
		collector.queries(MemberReferenceQuery.class)
				.forEach(q -> {
					q.match(collector.getAccess(owner, name, descriptor), owner, name, descriptor);
					collector.addMatched(insnContext, q);
				});
	}

	@Override
	public void visitInvokeDynamicInsn(String name, String descriptor, Handle handle,
									   Object... bootstrapMethodArguments) {
		super.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);
		Context.InsnContext insnContext = context.withInsn(last(), lastPos());
		collector.queries(MemberReferenceQuery.class)
				.forEach(q -> {
					q.match(collector.getAccess(handle.getOwner(), handle.getName(), handle.getDesc()),
							handle.getOwner(), handle.getName(), handle.getDesc());
					collector.addMatched(insnContext, q);
				});
		for(Object o : bootstrapMethodArguments) {
			if (o instanceof Handle) {
				Handle h = (Handle) o;
				collector.queries(MemberReferenceQuery.class)
						.forEach(q -> {
							q.match(collector.getAccess(h.getOwner(), h.getName(), h.getDesc()),
									h.getOwner(), h.getName(), h.getDesc());
							collector.addMatched(insnContext, q);
						});
			} else if (o instanceof String) {
				String s = (String) o;
				collector.queries(StringQuery.class)
						.forEach(q -> {
							q.match(s);
							collector.addMatched(insnContext, q);
						});
			} else if (o instanceof Number) {
				Number n = (Number) o;
				collector.queries(ValueQuery.class)
						.forEach(q -> {
							q.match(n);
							collector.addMatched(context.withInsn(last(), lastPos()), q);
						});
			}
		}
	}

	@Override
	public void visitLdcInsn(Object value) {
		super.visitLdcInsn(value);
		Context.InsnContext insnContext = context.withInsn(last(), lastPos());
		if (value instanceof String) {
			collector.queries(StringQuery.class)
					.forEach(q -> {
						q.match((String) value);
						collector.addMatched(insnContext, q);
					});
		} else if (value instanceof Type) {
			Type type = (Type) value;
			collector.queries(ClassReferenceQuery.class)
					.forEach(q -> {
						String types = type.getSort() == Type.ARRAY ?
								type.getElementType().getInternalName() : type.getInternalName();
						q.match(collector.getAccess(types, Opcodes.ACC_ANNOTATION), types);
						collector.addMatched(insnContext, q);
					});
		} else if (value instanceof Handle) {
			Handle handle = (Handle) value;
			collector.queries(MemberReferenceQuery.class)
					.forEach(q -> {
						q.match(collector.getAccess(handle.getOwner(), handle.getName(), handle.getDesc()),
								handle.getOwner(), handle.getName(), handle.getDesc());
						collector.addMatched(insnContext, q);
					});
		} else if (value instanceof ConstantDynamic) {
			ConstantDynamic dynamic = (ConstantDynamic) value;
			Handle handle = dynamic.getBootstrapMethod();
			collector.queries(MemberReferenceQuery.class)
					.forEach(q -> {
						q.match(collector.getAccess(handle.getOwner(), handle.getName(), handle.getDesc()),
								handle.getOwner(), handle.getName(), handle.getDesc());
						collector.addMatched(insnContext, q);
					});
			for(int bsm = 0; bsm < dynamic.getBootstrapMethodArgumentCount(); bsm++) {
				Object o = dynamic.getBootstrapMethodArgument(bsm);
				if (o instanceof Handle) {
					Handle h = (Handle) o;
					collector.queries(MemberReferenceQuery.class)
							.forEach(q -> {
								q.match(collector.getAccess(h.getOwner(), h.getName(), h.getDesc()),
										h.getOwner(), h.getName(), h.getDesc());
								collector.addMatched(insnContext, q);
							});
				}
			}
		} else {
			collector.queries(ValueQuery.class)
					.forEach(q -> {
						q.match(value);
						collector.addMatched(insnContext, q);
					});
		}
	}

	@Override
	public void visitEnd() {
		super.visitEnd();
		// Don't check disassembled text on abstract methods
		if (AccessFlag.isAbstract(access))
			return;
		List<InsnTextQuery> insnTextQueries = collector.queries(InsnTextQuery.class).collect(Collectors.toList());
		if (!insnTextQueries.isEmpty()) {
			try {
				String code = new Disassembler().disassemble(this);
				insnTextQueries.forEach(q -> {
					q.match(code);
					collector.addMatched(context, q);
				});
			} catch(Exception ex) {
				String owner = context.getParent().getName();
				Log.error(ex, "Failed to disassemble method: " + owner + "." + name + desc);
			}
		}
	}

	private AbstractInsnNode last() {
		return instructions.getLast();
	}

	private int lastPos() {
		return instructions.size() - 1;
	}
}
```

`src/main/java/me/coley/recaf/search/SearchResult.java`:

```java
package me.coley.recaf.search;

/**
 * Search result base.
 *
 * @author Matt
 */
public abstract class SearchResult implements Comparable<SearchResult> {
	private Context<?> context;

	/**
	 * Sets the context <i>(Where the result is located)</i> of the search result.
	 *
	 * @param context
	 * 		Context of the result.
	 */
	public void setContext(Context<?> context) {
		this.context = context;
	}

	/**
	 * @return Context of the result.
	 */
	public Context<?> getContext() {
		return context;
	}

	@Override
	public int compareTo(SearchResult other) {
		return context.compareTo(other.context);
	}

	/**
	 * @param other
	 * 		Result to be compared
	 *
	 * @return {@code true} if both contexts are considered similar.
	 *
	 * @see Context#isSimilar(Context)
	 */
	public boolean isContextSimilar(SearchResult other) {
		return context != null && other.context != null && context.isSimilar(other.context);
	}

	@Override
	public String toString() {
		throw new UnsupportedOperationException("Unimplemented result string representation");
	}
}

```

`src/main/java/me/coley/recaf/search/StringMatchMode.java`:

```java
package me.coley.recaf.search;

import jregex.Pattern;
import me.coley.recaf.util.Log;

import java.util.function.BiPredicate;

/**
 * String match implementations.
 *
 * @author Matt
 */
public enum StringMatchMode {
	/**
	 * String match via equality.
	 */
	EQUALS((key, text) -> text.equals(key)),
	/**
	 * String match via containment.
	 */
	CONTAINS((key, text) -> text.contains(key)),
	/**
	 * String match via same prefix.
	 */
	STARTS_WITH((key, text) -> text.startsWith(key)),
	/**
	 * String match via same suffix.
	 */
	ENDS_WITH((key, text) -> text.endsWith(key)),
	/**
	 * String match via regular expression matching.
	 */
	REGEX((key, text) -> regmatch(text, key));

	private static boolean regmatch(String text, String key) {
		try {
			return new Pattern(key).matcher(text).find();
		} catch(Exception ex) {
			Log.error(ex, "Invalid pattern: '{}'", key);
			return false;
		}
	}

	private final BiPredicate<String, String> matcher;

	StringMatchMode(BiPredicate<String, String> matcher)  {
		this.matcher = matcher;
	}

	/**
	 * @param key
	 * 		Expected pattern.
	 * @param text
	 * 		Text to test for a match.
	 *
	 * @return {@code true} if the given text matches with the given key.
	 */
	public boolean match(String key, String text) {
		return matcher.test(key, text);
	}
}

```

`src/main/java/me/coley/recaf/search/StringQuery.java`:

```java
package me.coley.recaf.search;

/**
 * Query to find strings matching the given pattern.
 *
 * @author Matt
 */
public class StringQuery extends Query {
	private final String pattern;

	/**
	 * Constructs a string matching query.
	 *
	 * @param pattern
	 * 		String pattern.
	 * @param stringMode
	 * 		How to match strings.
	 */
	public StringQuery(String pattern, StringMatchMode stringMode) {
		super(QueryType.CLASS_NAME, stringMode);
		this.pattern = pattern;
	}

	/**
	 * Adds a result if the given string matches the specified name pattern.
	 *
	 * @param text
	 * 		Text to match.
	 */
	public void match(String text) {
		if(stringMode.match(pattern, text)) {
			getMatched().add(new StringResult(text));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/StringResult.java`:

```java
package me.coley.recaf.search;

/**
 * Search result of a String.
 *
 * @author Matt
 */
public class StringResult extends SearchResult {
	private final String text;

	/**
	 * Constructs a class result.
	 *
	 * @param text
	 * 		Matched text.
	 */
	public StringResult(String text) {
		this.text = text;
	}

	/**
	 * @return Matched text.
	 */
	public String getText() {
		return text;
	}

	@Override
	public int compareTo(SearchResult other) {
		int ret = super.compareTo(other);
		if(ret == 0) {
			if(other instanceof StringResult) {
				StringResult otherResult = (StringResult) other;
				return text.compareTo(otherResult.text);
			}
		}
		return ret;
	}

	@Override
	public String toString() {
		return text.replace("\n", "\\n").replace("\t", "\\t");
	}
}

```

`src/main/java/me/coley/recaf/search/ValueQuery.java`:

```java
package me.coley.recaf.search;

/**
 * Query to find constant values.
 *
 * @author Matt
 */
public class ValueQuery extends Query {
	private final Object value;

	/**
	 * Constructs a value matching query.
	 *
	 * @param value
	 * 		Value to search for.
	 */
	public ValueQuery(Object value) {
		super(QueryType.VALUE, null);
		this.value = value;
	}

	/**
	 * Adds a result if the given value matches the specified value.
	 *
	 * @param value
	 * 		Value to match.
	 */
	public void match(Object value) {
		if(this.value.equals(value)) {
			getMatched().add(new ValueResult(value));
		}
	}
}

```

`src/main/java/me/coley/recaf/search/ValueResult.java`:

```java
package me.coley.recaf.search;

/**
 * Search result of some value.
 *
 * @author Matt
 */
public class ValueResult extends SearchResult {
	private final Object value;

	/**
	 * Constructs a value result.
	 *
	 * @param value
	 * 		Matched value.
	 */
	public ValueResult(Object value) {
		this.value = value;
	}

	/**
	 * @return Matched value.
	 */
	public Object getValue() {
		return value;
	}

	@Override
	@SuppressWarnings("unchecked")
	public int compareTo(SearchResult other) {
		int ret = super.compareTo(other);
		if (ret == 0) {
			if (other instanceof ValueResult) {
				ValueResult otherResult = (ValueResult) other;
				if (value instanceof Comparable && otherResult.value instanceof Comparable) {
					Comparable compValue = (Comparable) value;
					Comparable compOtherValue = (Comparable) otherResult.value;
					return compValue.compareTo(compOtherValue);
				}
			}
		}
		return ret;
	}
}

```

`src/main/java/me/coley/recaf/ui/ContextBuilder.java`:

```java
package me.coley.recaf.ui;

import javafx.application.Platform;
import javafx.scene.control.*;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.stage.FileChooser;
import javafx.stage.Window;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.decompile.DecompileImpl;
import me.coley.recaf.parse.bytecode.Disassembler;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ContextMenuInjectorPlugin;
import me.coley.recaf.search.StringMatchMode;
import me.coley.recaf.ui.controls.ActionMenuItem;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.ui.controls.RenamingTextField;
import me.coley.recaf.ui.controls.pane.SearchPane;
import me.coley.recaf.ui.controls.ViewportTabs;
import me.coley.recaf.ui.controls.popup.YesNoWindow;
import me.coley.recaf.ui.controls.text.BytecodeMemberInserterPane;
import me.coley.recaf.ui.controls.tree.JavaResourceTree;
import me.coley.recaf.ui.controls.view.BytecodeViewport;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.view.FileViewport;
import me.coley.recaf.util.*;
import me.coley.recaf.workspace.JavaResource;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.Map;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Context menu builder.
 *
 * @author Matt
 */
public class ContextBuilder {
	private static final int SKIP = ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE;
	private static PluginsManager plugins = PluginsManager.getInstance();
	private GuiController controller;
	private JavaResource resource;
	// class ctx options
	private ClassViewport classView;
	private TreeView<?> treeView;
	private boolean declaration;
	private ClassReader reader;
	// file ctx options
	private FileViewport fileView;

	/**
	 * @return Context menu builder.
	 */
	public static ContextBuilder menu() {
		return new ContextBuilder();
	}

	/**
	 * @param controller
	 * 		Controller context.
	 *
	 * @return Builder.
	 */
	public ContextBuilder controller(GuiController controller) {
		this.controller = controller;
		return this;
	}

	/**
	 * @param resource
	 * 		JavaResource context.
	 *
	 * @return Builder.
	 */
	public ContextBuilder resource(JavaResource resource) {
		this.resource = resource;
		return this;
	}

	/**
	 * @param classView
	 * 		Class viewport containing the class/declaring-class.
	 *
	 * @return Builder.
	 */
	public ContextBuilder view(ClassViewport classView) {
		this.classView = classView;
		return this;
	}

	/**
	 * @param fileView
	 * 		File viewport containing the file.
	 *
	 * @return Builder.
	 */
	public ContextBuilder view(FileViewport fileView) {
		this.fileView = fileView;
		return this;
	}

	/**
	 * @param treeView
	 * 		Tree viewport containing the class.
	 *
	 * @return Builder.
	 */
	public ContextBuilder tree(TreeView<?> treeView) {
		this.treeView = treeView;
		return this;
	}

	/**
	 * @param declaration
	 * 		If the member is a declaration <i>(As opposed to a reference)</i>
	 *
	 * @return Builder.
	 */
	public ContextBuilder declaration(boolean declaration) {
		this.declaration = declaration;
		return this;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return {@code true} if the containing resource can be found and a class-reader
	 * generated.
	 */
	private boolean setupClass(String name) {
		resource = controller.getWorkspace().getContainingResourceForClass(name);
		if(resource == null)
			return false;
		// Try to fetch class
		reader = controller.getWorkspace().getClassReader(name);
		if(reader == null)
			try {
				reader = new ClassReader(name);
			} catch(Exception ex) {
				return false;
			}
		return true;
	}

	/**
	 * @return {@code true} when the item is a declaration instead of a reference.
	 * Otherwise, {@code false}.
	 */
	public boolean isDeclaration() {
		return declaration;
	}

	/**
	 * @return The viewport the item resides in.
	 * Will be {@code null} if the item does not belong to a class viewport.
	 */
	public ClassViewport getClassView() {
		return classView;
	}

	/**
	 * @return The viewport the item resides in.
	 * Will be {@code null} if the item does not belong to a file viewport.
	 */
	public FileViewport getFileView() {
		return fileView;
	}

	/**
	 * @return The UI controller.
	 */
	public GuiController getController() {
		return controller;
	}

	/**
	 * @return The class reader of the item.
	 * Will be {@code null} if the item does not relate to a class file.
	 */
	public ClassReader getReader() {
		return reader;
	}

	/**
	 * @return The resource the item belongs to.
	 * Will be {@code null} if the item does not relate to a class or file in one of the loaded resources.
	 */
	public JavaResource getResource() {
		return resource;
	}

	/**
	 * @return The host tree view that holds the item we're adding the context menu to.
	 * Will be {@code null} if the item does not belong to a tree-view.
	 */
	public TreeView<?> getTreeView() {
		return treeView;
	}

	/**
	 * @return {@code true} when the {@link #treeView} belongs to a resource tree
	 * <i>(Inside the workspace navigator)</i>.
	 */
	public boolean isWorkspaceTree() {
		return treeView != null && treeView.getParent() instanceof JavaResourceTree;
	}

	/**
	 * @param name
	 * 		Full path name of file.
	 *
	 * @return {@code true} if the primary resource contains the file.
	 */
	public boolean isPrimaryFile(String name) {
		return controller.getWorkspace().getPrimary().getFiles().containsKey(name);
	}

	/**
	 * @param name
	 * 		Full path name of class.
	 *
	 * @return {@code true} if the primary resource contains the class.
	 */
	public boolean isPrimaryClass(String name) {
		return controller.getWorkspace().getPrimary().getClasses().containsKey(name);
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Context menu for classes.
	 */
	public ContextMenu ofClass(String name) {
		if(!setupClass(name))
			return null;
		// Create header
		int access = reader.getAccess();
		MenuItem header = new MenuItem(shorten(name));
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(UiUtil.createClassGraphic(access));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add options for classes we have knowledge of
		if(hasClass(controller, name)) {
			if (!declaration) {
				MenuItem jump = new ActionMenuItem(LangUtil.translate("ui.edit.method.goto"), () -> {
					controller.windows().getMainWindow().openClass(resource, name);
				});
				menu.getItems().add(jump);
			}
			// Allow searching for class references
			MenuItem search = new ActionMenuItem(LangUtil.translate("ui.edit.search"), () -> {
				SearchPane sp = controller.windows().getMainWindow().getMenubar().searchClassReference();
				sp.setInput("ui.search.cls_reference.name", name);
				sp.setInput("ui.search.matchmode", StringMatchMode.EQUALS);
				sp.search();
			});
			menu.getItems().add(search);
			// Renaming
			if (isPrimaryClass(name)) {
				MenuItem rename = new ActionMenuItem(LangUtil.translate("misc.rename"), () -> {
					Window main = controller.windows().getMainWindow().getStage();
					RenamingTextField popup = RenamingTextField.forClass(controller, name);
					popup.show(main);
				});
				menu.getItems().add(rename);
				if (isWorkspaceTree()) {
					// Add workspace-navigator specific items, but only for primary classes
					MenuItem remove = new ActionMenuItem(LangUtil.translate("misc.remove"), () -> {
						YesNoWindow.prompt(LangUtil.translate("misc.confirm.message"), () -> {
							controller.getWorkspace().getPrimary().getClasses().remove(name);
							controller.windows().getMainWindow().getTabs().closeTab(name);
						}, null).show(treeView);
					});
					menu.getItems().add(remove);
				} else {
					// Add class items, not shown in workspace navigator
					String sAddField = LangUtil.translate("misc.add") + " Field";
					String sAddMethod = LangUtil.translate("misc.add") + " Method";
					MenuItem addField = new ActionMenuItem(sAddField, () -> {
						BytecodeMemberInserterPane pane = new BytecodeMemberInserterPane(controller, name, false);
						BytecodeViewport view = new BytecodeViewport(controller,
								getClassView(),controller.getWorkspace().getPrimary(), name, pane);
						view.updateView();
						controller.windows().window(sAddField, view, 500, 200).show();
					});
					MenuItem addMethod = new ActionMenuItem(sAddMethod, () -> {
						BytecodeMemberInserterPane pane = new BytecodeMemberInserterPane(controller, name, true);
						BytecodeViewport view = new BytecodeViewport(controller,
								getClassView(),controller.getWorkspace().getPrimary(), name, pane);
						view.updateView();
						controller.windows().window(sAddMethod, view, 500, 200).show();
					});
					menu.getItems().addAll(new SeparatorMenuItem(), addField, addMethod);
				}
			}
			menu.getItems().addAll(
					new SeparatorMenuItem(),
					new ActionMenuItem(translate("ui.edit.copypath"), () -> {
						ClipboardContent content = new ClipboardContent();
						content.putString(name);
						Clipboard.getSystemClipboard().setContent(content);
					})
			);
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class).forEach(injector -> injector.forClass(this, menu, name));
		return menu;
	}

	/**
	 * @param owner
	 * 		Declaring class name.
	 * @param name
	 * 		Field name.
	 * @param desc
	 * 		Field descriptor.
	 *
	 * @return Context menu for fields.
	 */
	public ContextMenu ofField(String owner, String name, String desc) {
		if(!setupClass(owner))
			return null;
		// Fetch field
		FieldNode node = ClassUtil.getField(reader, SKIP, name, desc);
		if(node == null)
			return null;
		int access = node.access;
		// Create header
		MenuItem header = new MenuItem(name);
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(UiUtil.createFieldGraphic(access));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add options for fields we have knowledge of
		if(hasClass(controller, owner)) {
			if (declaration) {
				if (isPrimaryClass(owner)) {
					MenuItem remove = new ActionMenuItem(LangUtil.translate("misc.remove"), () -> {
						YesNoWindow.prompt(LangUtil.translate("misc.confirm.message"), () -> {
							byte[] updated = ClassUtil.removeField(reader, node.name, node.desc);
							getResource().getClasses().put(reader.getClassName(), updated);
							getClassView().updateView();
						}, null).show(classView);
					});
					menu.getItems().add(remove);
				}
			} else {
				MenuItem jump = new ActionMenuItem(LangUtil.translate("ui.edit.method.goto"), () -> {
					ClassViewport view = controller.windows().getMainWindow().openClass(resource, owner);
					Platform.runLater(() -> view.selectMember(name, desc));
				});
				menu.getItems().add(jump);
			}
			// Allow searching for references to this member
			MenuItem search = new ActionMenuItem(LangUtil.translate("ui.edit.search"), () -> {
				SearchPane sp = controller.windows().getMainWindow().getMenubar().searchMemberReference();
				sp.setInput("ui.search.mem_reference.owner", owner);
				sp.setInput("ui.search.mem_reference.name", name);
				sp.setInput("ui.search.mem_reference.desc", desc);
				sp.setInput("ui.search.matchmode", StringMatchMode.EQUALS);
				sp.search();
			});
			menu.getItems().add(search);
			// Renaming
			if (isPrimaryClass(owner)) {
				MenuItem rename = new ActionMenuItem(LangUtil.translate("misc.rename"), () -> {
					Window main = controller.windows().getMainWindow().getStage();
					RenamingTextField popup = RenamingTextField.forMember(controller, owner, name, desc);
					popup.show(main);
				});
				menu.getItems().add(rename);
			}
		}
		// Add other edit options
		if(declaration && resource.isPrimary()) {
			MenuItem edit = new ActionMenuItem(LangUtil.translate("ui.edit.method.editasm"), () -> {
				BytecodeViewport view = new BytecodeViewport(controller, classView, resource, owner, name, desc);
				view.updateView();
				controller.windows().window(name, view, 500, 100).show();
			});
			menu.getItems().add(edit);
			// TODO:
			//  - Remove
			//  - Duplicate
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class)
				.forEach(injector -> injector.forField(this, menu, owner, name, desc));
		return menu;
	}

	/**
	 * @param owner
	 * 		Declaring class name.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 *
	 * @return Context menu for methods.
	 */
	public ContextMenu ofMethod(String owner, String name, String desc) {
		if(!setupClass(owner))
			return null;
		// Fetch method
		MethodNode node = ClassUtil.getMethod(reader, SKIP, name, desc);
		if(node == null)
			return null;
		int access = node.access;
		// Create header
		MenuItem header = new MenuItem(name);
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(UiUtil.createMethodGraphic(access));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add options for methods we have knowledge of
		if(hasClass(controller, owner)) {
			if (declaration) {
				if (isPrimaryClass(owner)) {
					MenuItem remove = new ActionMenuItem(LangUtil.translate("misc.remove"), () -> {
						YesNoWindow.prompt(LangUtil.translate("misc.confirm.message"), () -> {
							byte[] updated = ClassUtil.removeMethod(reader, node.name, node.desc);
							getResource().getClasses().put(reader.getClassName(), updated);
							getClassView().updateView();
						}, null).show(classView);
					});
					menu.getItems().add(remove);
				}
			} else {
				MenuItem jump = new ActionMenuItem(LangUtil.translate("ui.edit.method.goto"), () -> {
					ClassViewport view = controller.windows().getMainWindow().openClass(resource, owner);
					ThreadUtil.run(() -> view.selectMember(name, desc));
				});
				menu.getItems().add(jump);
			}
			// Allow searching for references to this member
			MenuItem search = new ActionMenuItem(LangUtil.translate("ui.edit.search"), () -> {
				SearchPane sp = controller.windows().getMainWindow().getMenubar().searchMemberReference();
				sp.setInput("ui.search.mem_reference.owner", owner);
				sp.setInput("ui.search.mem_reference.name", name);
				sp.setInput("ui.search.mem_reference.desc", desc);
				sp.setInput("ui.search.matchmode", StringMatchMode.EQUALS);
				sp.search();
			});
			menu.getItems().add(search);
			// Renaming
			if (isPrimaryClass(owner)) {
				MenuItem rename = new ActionMenuItem(LangUtil.translate("ui.edit.method.rename"), () -> {
					Window main = controller.windows().getMainWindow().getStage();
					RenamingTextField popup = RenamingTextField.forMember(controller, owner, name, desc);
					popup.show(main);
				});
				menu.getItems().add(rename);
			}
		}
		// Add edit options
		if(declaration && resource.isPrimary()) {
			MenuItem edit = new ActionMenuItem(LangUtil.translate("ui.edit.method.editasm"), () -> {
				BytecodeViewport view = new BytecodeViewport(controller, classView, resource, owner, name, desc);
				view.updateView();
				controller.windows().window(name + desc, view, 600, 600).show();
			});
			menu.getItems().add(edit);
			// TODO:
			//  - Remove
			//  - Duplicate
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class)
				.forEach(injector -> injector.forMethod(this, menu, owner, name, desc));
		return menu;
	}

	/**
	 * @param owner
	 * 		Class method is declared in.
	 * @param name
	 * 		Declaring method name.
	 * @param desc
	 * 		Declaring method descriptor.
	 * @param insn
	 * 		Instruction value.
	 *
	 * @return Context menu for instructions in search results.
	 */
	public ContextMenu ofInsn(String owner, String name, String desc, AbstractInsnNode insn) {
		if(!setupClass(owner))
			return null;
		// Fetch declaring method
		MethodNode node = ClassUtil.getMethod(reader, SKIP, name, desc);
		if(node == null)
			return null;
		// Create header
		MenuItem header = new MenuItem(StringUtil.limit(Disassembler.insn(insn), 25));
		header.getStyleClass().add("context-menu-header");
		// TODO: Change graphic depending on insn type.
		//  - Icon for field return types
		//  - Icon for method return types
		//  - Icon for type declarations
		//  - Primitive icon for primitive values
		//  - No icon for anything else
		// header.setGraphic(...);
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add options for insns in classes we have knowledge of.
		// This should cover all classes, but we still want to make the assertion.
		if (hasClass(controller, owner)) {
			// TODO: Add more instruction menu options:
			//  - Depends on insn type?
			// Allow searching for references to this member
			MenuItem search = new ActionMenuItem(LangUtil.translate("ui.edit.search"), () -> {
				SearchPane sp = controller.windows().getMainWindow().getMenubar().searchMemberReference();
				sp.setInput("ui.search.mem_reference.owner", owner);
				sp.setInput("ui.search.mem_reference.name", name);
				sp.setInput("ui.search.mem_reference.desc", desc);
				sp.setInput("ui.search.matchmode", StringMatchMode.EQUALS);
				sp.search();
			});
			menu.getItems().add(search);
		}
		// Add option to go to editor
		if(resource.isPrimary()) {
			MenuItem edit = new ActionMenuItem(LangUtil.translate("ui.edit.method.editasm"), () -> {
				BytecodeViewport view = new BytecodeViewport(controller, classView, resource, owner, name, desc);
				view.updateView();
				controller.windows().window(name + desc, view, 600, 600).show();
			});
			menu.getItems().add(edit);
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class)
				.forEach(injector -> injector.forInsn(this, menu, owner, name, desc, insn));
		return menu;
	}

	/**
	 * @param name
	 * 		Package name.
	 *
	 * @return Context menu for packages.
	 */
	public ContextMenu ofPackage(String name) {
		MenuItem header = new MenuItem(shorten(name));
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(new IconView("icons/folder-package.png"));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		String packagePrefix = name + '/';
		// Add workspace-navigator specific items, but only for primary files
		if(isWorkspaceTree() && controller.getWorkspace().getPrimaryClassNames().stream()
				.anyMatch(cls -> cls.startsWith(packagePrefix))) {
			MenuItem rename = new ActionMenuItem(LangUtil.translate("misc.rename"), () -> {
				Window main = controller.windows().getMainWindow().getStage();
				RenamingTextField popup = RenamingTextField.forPackage(controller, name);
				popup.show(main);
			});
			MenuItem remove = new ActionMenuItem(LangUtil.translate("misc.remove"), () -> {
				Map<String, byte[]> classes = controller.getWorkspace().getPrimary().getClasses();
				ViewportTabs tabs = controller.windows().getMainWindow().getTabs();
				YesNoWindow.prompt(LangUtil.translate("misc.confirm.message"), () -> {
					new HashSet<>(classes.keySet()).forEach(cls -> {
						if (cls.startsWith(packagePrefix)) {
							classes.remove(cls);
							tabs.closeTab(cls);
						}
					});
				}, null).show(treeView);
			});
			menu.getItems().addAll(
					rename,
					remove,
					new SeparatorMenuItem(),
					new ActionMenuItem(translate("ui.edit.copypath"), () -> {
						ClipboardContent content = new ClipboardContent();
						content.putString(name);
						Clipboard.getSystemClipboard().setContent(content);
					})
			);
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class).forEach(injector -> injector.forPackage(this, menu, name));
		return menu;
	}

	/**
	 * @param name
	 * 		File name.
	 *
	 * @return Context menu for files.
	 */
	public ContextMenu ofFile(String name) {
		// Create the menu
		MenuItem header = new MenuItem(shorten(name));
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(UiUtil.createFileGraphic(name));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add workspace-navigator specific items, but only for primary files
		if (isWorkspaceTree() && isPrimaryFile(name)) {
			MenuItem rename = new ActionMenuItem(LangUtil.translate("misc.rename"), () -> {
				Window main = controller.windows().getMainWindow().getStage();
				RenamingTextField popup = RenamingTextField.forFile(controller, name);
				popup.show(main);
			});
			MenuItem remove = new ActionMenuItem(LangUtil.translate("misc.remove"), () -> {
				YesNoWindow.prompt(LangUtil.translate("misc.confirm.message"), () -> {
					controller.getWorkspace().getPrimary().getFiles().remove(name);
					controller.windows().getMainWindow().getTabs().closeTab(name);
				}, null).show(treeView);
			});
			menu.getItems().addAll(
					rename,
					remove,
					new SeparatorMenuItem(),
					new ActionMenuItem(translate("ui.edit.copypath"), () -> {
						ClipboardContent content = new ClipboardContent();
						content.putString(name);
						Clipboard.getSystemClipboard().setContent(content);
					})
			);

		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class).forEach(injector -> injector.forFile(this, menu, name));
		return menu;
	}

	/**
	 * @param resource
	 * 		Root resource.
	 *
	 * @return Context menu for resource roots.
	 */
	public ContextMenu ofRoot(JavaResource resource) {
		this.resource = resource;
		String name = resource.toString();
		MenuItem header = new MenuItem(shorten(name));
		header.getStyleClass().add("context-menu-header");
		header.setGraphic(new IconView(UiUtil.getResourceIcon(resource)));
		header.setDisable(true);
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(header);
		// Add workspace-navigator specific items, but only for primary files
		if(isWorkspaceTree()) {
			FileChooser.ExtensionFilter filter =
					new FileChooser.ExtensionFilter(translate("ui.fileprompt.open.extensions"),
							"*.jar", "*.zip", "*.tar", "*.tar.gz");
			FileChooser loader = new FileChooser();
			loader.setTitle(translate("ui.fileprompt.open"));
			loader.getExtensionFilters().add(filter);
			loader.setSelectedExtensionFilter(filter);
			loader.setInitialDirectory(controller.config().backend().getRecentLoadDir());
			MenuItem addDoc = new ActionMenuItem(LangUtil.translate("ui.load.adddocs"), () -> {
				File file = loader.showOpenDialog(null);
				if (file != null) {
					try {
						resource.setClassDocs(file.toPath());
					} catch(IOException ex) {
						Log.error(ex, "Failed to set resource documentation");
					}
				}
			});
			MenuItem addSrc = new ActionMenuItem(LangUtil.translate("ui.load.addsrc"), () -> {
				File file = loader.showOpenDialog(null);
				if (file != null) {
					try {
						resource.setClassSources(file.toPath());
					} catch(IOException ex) {
						Log.error(ex, "Failed to set resource sources");
					}
				}
			});
			menu.getItems().add(addDoc);
			menu.getItems().add(addSrc);
		}
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class)
				.forEach(injector -> injector.forResourceRoot(this, menu, resource));
		return menu;
	}

	/**
	 * @param className The name of the class
	 * @return Context menu for tabs of {@link ClassViewport ClassViewports}.
	 */
	public ContextMenu ofClassTab(String className) {
		// No header necessary
		Menu menuDecompile = new Menu(LangUtil.translate("decompile.decompiler.name"));
		for (DecompileImpl impl : DecompileImpl.values())
			menuDecompile.getItems()
					.add(new ActionMenuItem(impl.toString(), () -> classView.setOverrideDecompiler(impl)));
		Menu menuMode = new Menu(LangUtil.translate("display.classmode.name"));
		for (ClassViewport.ClassMode mode : ClassViewport.ClassMode.values())
			menuMode.getItems().add(new ActionMenuItem(mode.toString(), () -> classView.setOverrideMode(mode)));
		// Create menu
		ContextMenu menu = new ContextMenu();
		menu.getItems().addAll(
				menuDecompile,
				menuMode
		);
		addTabOptions(menu, className);
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class).forEach(injector -> injector.forClassTab(this, menu));
		return menu;
	}

	/**
	 * @param fileName The name of the file
	 * @return Context menu for tabs of {@link FileViewport FileViewports}.
	 */
	public ContextMenu ofFileTab(String fileName) {
		// No header necessary
		Menu menuMode = new Menu(LangUtil.translate("display.classmode.name"));
		for (FileViewport.FileMode mode : FileViewport.FileMode.values())
			menuMode.getItems().add(new ActionMenuItem(mode.toString(), () -> fileView.setOverrideMode(mode)));
		// Create menu
		ContextMenu menu = new ContextMenu();
		menu.getItems().add(menuMode);
		addTabOptions(menu, fileName);
		// Inject plugin menus
		plugins.ofType(ContextMenuInjectorPlugin.class).forEach(injector -> injector.forFileTab(this, menu));
		return menu;
	}

	/**
	 * Add common tab options
	 *
	 * @param menu
	 * 		Context Menu
	 */
	private void addTabOptions(ContextMenu menu, String name) {
		menu.getItems().addAll(
				new SeparatorMenuItem(),
				new ActionMenuItem(translate("ui.edit.tab.close"), () -> {
					getTabs().closeTab(name);
				}),
				new ActionMenuItem(translate("ui.edit.tab.closeothers"), () -> {
					getTabs().closeAllExcept(name);
				}),
				new ActionMenuItem(translate("ui.edit.tab.closeall"), () -> {
					if (isClass())
						classView.getController().windows().getMainWindow().clearTabViewports();
					else
						fileView.getController().windows().getMainWindow().clearTabViewports();
				}),
				new SeparatorMenuItem(),
				new ActionMenuItem(translate("ui.edit.copypath"), () -> {
					ClipboardContent content = new ClipboardContent();
					content.putString(name);
					Clipboard.getSystemClipboard().setContent(content);
				})
		);
	}

	private ViewportTabs getTabs() {
		return isClass()
				? classView.getController().windows().getMainWindow().getTabs()
				: fileView.getController().windows().getMainWindow().getTabs();
	}

	/**
	 * Is the current viewport (opened tab) a class?
	 *
	 * @return boolean
	 */
	private boolean isClass() {
		return classView != null;
	}

	private static String shorten(String name) {
		return name.contains("/") ? name.substring(name.lastIndexOf("/") + 1) : name;
	}

	private static boolean hasClass(GuiController controller, String name) {
		return controller.getWorkspace().hasClass(name);
	}
}

```

`src/main/java/me/coley/recaf/ui/MainMenu.java`:

```java
package me.coley.recaf.ui;

import javafx.scene.Node;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.SeparatorMenuItem;
import javafx.stage.FileChooser;
import javafx.stage.FileChooser.ExtensionFilter;
import javafx.stage.Stage;
import me.coley.recaf.Recaf;
import me.coley.recaf.command.impl.Export;
import me.coley.recaf.config.ConfBackend;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.mapping.MappingImpl;
import me.coley.recaf.mapping.Mappings;
import me.coley.recaf.mapping.TinyV2Mappings;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.MenuProviderPlugin;
import me.coley.recaf.search.QueryType;
import me.coley.recaf.ui.controls.*;
import me.coley.recaf.ui.controls.pane.*;
import me.coley.recaf.util.*;
import me.coley.recaf.util.self.SelfUpdater;
import me.coley.recaf.workspace.*;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;
import static me.coley.recaf.util.LangUtil.translate;
import static me.coley.recaf.util.Log.error;
import static me.coley.recaf.util.UiUtil.getFileIcon;

/**
 * Primary menu.
 *
 * @author Matt
 */
public class MainMenu extends MenuBar {
	private final FileChooser fcLoadApp = new FileChooser();
	private final FileChooser fcLoadMap = new FileChooser();
	private final FileChooser fcSaveApp = new FileChooser();
	private final FileChooser fcSaveWorkspace = new FileChooser();
	private final FileChooser fcSaveMap = new FileChooser();
	private final GuiController controller;
	private final Menu mFile;
	private final Menu mFileRecent;
	private final Menu mMapping;
	private final Menu mConfig;
	private final Menu mThemeEditor;
	private final Menu mSearch;
	private final Menu mHistory;
	private final Menu mAttach;
	private final Menu mPlugins;
	private final Menu mHelp;

	/**
	 * @param controller
	 * 		Controller context.
	 */
	public MainMenu(GuiController controller) {
		// TODO: Properly managed disabled state of menu items
		this.controller = controller;
		// Setup mac system menubar
		boolean isUseSystemMenuBar = controller.config().display().useSystemMenubar;
		boolean isEmptyMenuItemsSupported = !isUseSystemMenuBar || OSUtil.getOSType() != OSUtil.MAC;
		setUseSystemMenuBar(isUseSystemMenuBar);
		// Setup menu entries
		mFile = new Menu(translate("ui.menubar.file"));
		mFileRecent = new Menu(translate("ui.menubar.file.recent"));
		mMapping = new Menu(translate("ui.menubar.mapping"));
		updateRecent();
		if (InstrumentationResource.isActive()) {
			// Agent file menu
			mFile.getItems().addAll(
					new ActionMenuItem(translate("ui.menubar.file.addlib"), this::addLibrary),
					new ActionMenuItem(translate("ui.menubar.file.saveapp"), this::saveApplication),
					new ActionMenuItem(translate("ui.menubar.file.agentexport"), this::saveAgent));
		} else {
			// Normal file menu
			mFile.getItems().add(
					new ActionMenuItem(translate("ui.menubar.file.load"), this::load));
			if (controller.config().display().getMaxRecent() > 0)
				mFile.getItems().add(mFileRecent);
			mFile.getItems().addAll(
					new ActionMenuItem(translate("ui.menubar.file.addlib"), this::addLibrary),
					new ActionMenuItem(translate("ui.menubar.file.saveapp"), this::saveApplication),
					new ActionMenuItem(translate("ui.menubar.file.saveworkspace"), this::saveWorkspace));
			// Mapping menu
			Menu mApply = new Menu(translate("ui.menubar.mapping.apply"));
			Menu mExport = new Menu(translate("ui.menubar.mapping.export"));
			populateMappingMenus(mApply, mExport);
			mMapping.getItems().add(mApply);
			mMapping.getItems().add(mExport);
		}
		if (isEmptyMenuItemsSupported) {
			mThemeEditor = new ActionMenu(translate("ui.menubar.themeeditor"), this::showThemeEditor);
			mConfig = new ActionMenu(translate("ui.menubar.config"), this::showConfig);
		} else {
			mConfig = new Menu(translate("ui.menubar.config"));
			mConfig.getItems().add(new ActionMenuItem(translate("misc.open"), this::showConfig));
			mThemeEditor = new Menu(translate("ui.menubar.themeeditor"));
			mThemeEditor.getItems().add(new ActionMenuItem(translate("misc.open"), this::showThemeEditor));
		}
		mSearch = new Menu(translate("ui.menubar.search"));
		mSearch.getItems().addAll(
				new ActionMenuItem(translate("ui.menubar.search.string"), this::searchString),
				new ActionMenuItem(translate("ui.menubar.search.value"), this::searchValue),
				new ActionMenuItem(translate("ui.menubar.search.cls_reference"), this::searchClassReference),
				new ActionMenuItem(translate("ui.menubar.search.mem_reference"), this::searchMemberReference),
				new ActionMenuItem(translate("ui.menubar.search.declare"),  this::searchDeclaration),
				new ActionMenuItem(translate("ui.menubar.search.insn"),  this::searchInsn));
		mAttach = new Menu(translate("ui.menubar.attach"));
		mAttach.getItems().addAll(
				new ActionMenuItem(translate("ui.menubar.attach.existing"), this::attachExisting),
				new ActionMenuItem(translate("ui.menubar.attach.create"), this::attachCreate));
		if (isEmptyMenuItemsSupported) {
			mHistory = new ActionMenu(translate("ui.menubar.history"), this::showHistory);
		} else {
			mHistory = new Menu(translate("ui.menubar.history"));
			mHistory.getItems().add(new ActionMenuItem(translate("misc.open"), this::showHistory));
		}
		mHelp = new Menu(translate("ui.menubar.help"));
		if (SelfUpdater.hasUpdate()) {
			mHelp.getItems().add(0,
					new ActionMenuItem(translate("ui.menubar.help.update") + SelfUpdater.getLatestVersion(),
							this::showUpdatePrompt));
		}
		mHelp.getItems().addAll(
				new ActionMenuItem(translate("ui.menubar.help.documentation"), this::showDocumentation),
				new ActionMenuItem(translate("ui.menubar.help.info"), this::showInformation),
				new ActionMenuItem(translate("ui.menubar.help.contact"), this::showContact)
		);
		mPlugins = new Menu(translate("ui.menubar.plugins"));
		if (PluginsManager.getInstance().hasPlugins())
			mPlugins.getItems()
					.add(new ActionMenuItem(translate("ui.menubar.plugins.manage"), this::openPluginManager));
		mPlugins.getItems()
				.add(new ActionMenuItem(translate("ui.menubar.plugins.opendir"), this::openPluginDirectory));
		if (!PluginsManager.getInstance().ofType(MenuProviderPlugin.class).isEmpty()) {
			mPlugins.getItems().add(new SeparatorMenuItem());
			PluginsManager.getInstance().ofType(MenuProviderPlugin.class).forEach(plugin -> {
				mPlugins.getItems().add(plugin.createMenu());
			});
		}
		//
		getMenus().addAll(mFile, mConfig, /* mThemeEditor, */ mSearch, mHistory);
		if (!InstrumentationResource.isActive()) {
			if (ClasspathUtil.classExists("com.sun.tools.attach.VirtualMachine")) {
				getMenus().add(mAttach);
			}
			getMenus().add(mMapping);
		}
		getMenus().addAll(mPlugins, mHelp);
		// Setup file-choosers
		ExtensionFilter loadFilter = new ExtensionFilter(translate("ui.fileprompt.open.extensions"),
				"*.jar", "*.war", "*.class", "*.json");
		ExtensionFilter mappingFilter = new ExtensionFilter(translate("ui.fileprompt.mapping.extensions"),
				"*.txt", "*.map", "*.mapping", "*.enigma", "*.pro", "*.srg", "*.tsrg", "*.tiny", "*.tinyv2");
		ExtensionFilter saveFilter = new ExtensionFilter(translate("ui.fileprompt.export.extensions"),
				"*.jar", "*.war", "*.class", "*.zip");
		ExtensionFilter saveWorkspaceFilter = new ExtensionFilter(translate("ui.fileprompt.workspace.extensions"),
				"*.json");
		ExtensionFilter saveMapFilter = new ExtensionFilter(translate("ui.fileprompt.export.mapping"),
				"*.txt", "*.map", "*.mapping");
		fcLoadApp.setTitle(translate("ui.fileprompt.open"));
		fcLoadApp.getExtensionFilters().add(loadFilter);
		fcLoadApp.setSelectedExtensionFilter(loadFilter);
		fcSaveApp.setTitle(translate("ui.fileprompt.export"));
		fcSaveApp.getExtensionFilters().add(saveFilter);
		fcSaveApp.setSelectedExtensionFilter(saveFilter);
		fcLoadMap.setTitle(translate("ui.fileprompt.mapping"));
		fcLoadMap.getExtensionFilters().add(mappingFilter);
		fcLoadMap.setSelectedExtensionFilter(mappingFilter);
		fcSaveWorkspace.setTitle(translate("ui.fileprompt.workspace"));
		fcSaveWorkspace.getExtensionFilters().add(saveWorkspaceFilter);
		fcSaveWorkspace.setSelectedExtensionFilter(saveWorkspaceFilter);
		fcSaveMap.setTitle(translate("ui.fileprompt.export.mapping"));
		fcSaveMap.getExtensionFilters().add(saveMapFilter);
		fcSaveMap.setSelectedExtensionFilter(saveMapFilter);
	}

	/**
	 * Add mapping sub-items in the menus.
	 *
	 * @param applyMenu
	 * 		Menu to hold sub-items to apply mappings of a given type.
	 * @param exportMenu
	 * 		Menu to hold sub-items to save as a given type of mappings.
	 */
	private void populateMappingMenus(Menu applyMenu, Menu exportMenu) {
		for (MappingImpl impl : MappingImpl.values()) {
			if (impl == MappingImpl.TINY2) {
				// Edge case since there are multiple ways we can interpret the mapping directions
				Menu tiny2Menu = new Menu(impl.getDisplay());
				for (TinyV2Mappings.TinyV2SubType subType : TinyV2Mappings.TinyV2SubType.values()) {
					tiny2Menu.getItems()
							.add(new ActionMenuItem(subType.toString(), () -> applyTinyV2Map(subType)));
				}
				applyMenu.getItems().add(tiny2Menu);
			} else {
				applyMenu.getItems().add(new ActionMenuItem(impl.getDisplay(), () -> applyMap(impl)));
			}
			// TODO: Rewrite the mapping implementation design to work with both reading and writing
			if (impl == MappingImpl.SIMPLE)  {
				exportMenu.getItems().addAll(new ActionMenuItem(impl.getDisplay(), () -> exportMap(impl)));
			}
		}
	}

	/**
	 * Open string search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchString() {
		return search(QueryType.STRING, "string");
	}

	/**
	 * Open value search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchValue() {
		return search(QueryType.VALUE, "value");
	}

	/**
	 * Open class reference search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchClassReference() {
		return search(QueryType.CLASS_REFERENCE, "cls_reference");
	}

	/**
	 * Open member reference search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchMemberReference() {
		return search(QueryType.MEMBER_REFERENCE, "mem_reference");
	}

	/**
	 * Open declaration search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchDeclaration() {
		return search(QueryType.MEMBER_DEFINITION, "declare");
	}

	/**
	 * Open instruction text search window.
	 *
	 * @return Search window.
	 */
	public SearchPane searchInsn() {
		return search(QueryType.INSTRUCTION_TEXT, "insn");
	}

	private SearchPane search(QueryType type, String key) {
		SearchPane pane = new SearchPane(controller, type);
		Stage stage  = controller.windows().window(
				translate("ui.menubar.search") + ":" + translate("ui.menubar.search." + key),
				pane, 600, 400);
		stage.show();
		stage.toFront();
		return pane;
	}

	/**
	 * Prompt a file open prompt to load an application.
	 */
	private void load() {
		fcLoadApp.setInitialDirectory(config().getRecentLoadDir());
		File file = fcLoadApp.showOpenDialog(null);
		if(file != null) {
			controller.loadWorkspace(IOUtil.toPath(file), null);
		}
	}

	/**
	 * Adds a selected resource to the current workspace.
	 */
	private void addLibrary() {
		final Workspace workspace = controller.getWorkspace();

		if (workspace == null)
			return;

		fcLoadApp.setInitialDirectory(config().getRecentLoadDir());
		List<File> files = fcLoadApp.showOpenMultipleDialog(null);

		if (files != null) {

			for (File file : files) {
				try {
					JavaResource resource = FileSystemResource.of(file.toPath());

					workspace.getLibraries().add(resource);
					controller.windows().getMainWindow().getNavigator().refresh();
				} catch(Exception ex) {
					error(ex, "Failed to add library: {}", file.getName());
					ExceptionAlert.show(ex, "Failed to add library: " + file.getName());
				}
			}
		}
	}

	/**
	 * Save the current application to a file.
	 */
	public void saveApplication() {
		if (controller.getWorkspace() == null) {
			return;
		}
		fcSaveApp.setInitialDirectory(config().getRecentSaveAppDir());
		File file = fcSaveApp.showSaveDialog(null);
		if (file != null) {
			Export exporter = new Export();
			exporter.setController(controller);
			exporter.output = file;
			exporter.compress = config().compress;
			try {
				exporter.call();
				config().recentSaveApp = file.getAbsolutePath();
			} catch(Exception ex) {
				error(ex, "Failed to save application to file: {}", file.getName());
				ExceptionAlert.show(ex, "Failed to save application to file: " + file.getName());
			}
		}
	}

	/**
	 * Export the current {@link Workspace#getAggregatedMappings() aggregated mappings} to the given format.
	 *
	 * @param impl
	 * 		Mapping implementation to use.
	 */
	private void exportMap(MappingImpl impl) {
		if (controller.getWorkspace() == null) {
			return;
		}

		fcSaveMap.setInitialDirectory(config().getRecentSaveMapDir());
		File file = fcSaveMap.showSaveDialog(null);
		if (file != null) {
			// TODO: Make the Mappings classes do this conversion for their respective format
			String fullMapping = controller.getWorkspace().getAggregatedMappings().entrySet().stream()
					.map(e -> e.getKey() + " " + e.getValue())
					.collect(Collectors.joining("\n"));
			try {
				FileUtils.write(file, fullMapping, UTF_8);
				config().recentSaveMap = file.getAbsolutePath();
			} catch(IOException ex) {
				error(ex, "Failed to save simple mapping to file: {}", file.getName());
				ExceptionAlert.show(ex, "Failed to save simple mapping to file: " + file.getName());
			}

		}
	}

	/**
	 * Load a file and apply mappings of the given type.
	 *
	 * @param impl Mapping implementation type.
	 */
	private void applyMap(MappingImpl impl) {
		fcLoadMap.setInitialDirectory(config().getRecentLoadDir());
		File file = fcLoadMap.showOpenDialog(null);
		if (file != null) {
			try {
				Mappings mappings = impl.create(file.toPath(), controller.getWorkspace());
				mappings.setCheckFieldHierarchy(true);
				mappings.setCheckMethodHierarchy(true);
				mappings.accept(controller.getWorkspace().getPrimary());
			} catch (Exception ex) {
				error(ex, "Failed to apply mappings: {}", file.getName());
				ExceptionAlert.show(ex, "Failed to apply mappings: " + file.getName());
			}
		}
	}

	private void applyTinyV2Map(TinyV2Mappings.TinyV2SubType subType) {
		fcLoadMap.setInitialDirectory(config().getRecentLoadDir());
		File file = fcLoadMap.showOpenDialog(null);
		if (file != null) {
			try {
				Mappings mappings = new TinyV2Mappings(file.toPath(), controller.getWorkspace(), subType);
				mappings.setCheckFieldHierarchy(true);
				mappings.setCheckMethodHierarchy(true);
				mappings.accept(controller.getWorkspace().getPrimary());
			} catch (Exception ex) {
				error(ex, "Failed to apply mappings: {}", file.getName());
				ExceptionAlert.show(ex, "Failed to apply mappings: " + file.getName());
			}
		}
	}

	/**
	 * Show update prompt.
	 */
	public void showUpdatePrompt() {
		Stage stage = controller.windows()
				.window(translate("ui.menubar.help.update") + SelfUpdater.getLatestVersion(),
						new UpdatePane(controller));
		stage.show();
		stage.toFront();
	}

	/**
	 * Display history window.
	 */
	private void showHistory() {
		Stage stage = controller.windows().getHistoryWindow();
		if(stage == null) {
			HistoryPane pane = new HistoryPane(controller);
			PluginsManager.getInstance()
					.addPlugin(new HistoryPane.HistoryPlugin(pane));
			stage = controller.windows().window(translate("ui.menubar.history"), pane, 800, 600);
			controller.windows().setHistoryWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Display contact information window.
	 */
	private void showContact() {
		Stage stage = controller.windows().getContactWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.help.contact"), new ContactInfoPane());
			controller.windows().setContactWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Open documentation page in browser.
	 */
	private void showDocumentation() {
		try {
			UiUtil.showDocument(URI.create(Recaf.DOC_URL));
		} catch(Exception ex) {
			Log.error(ex, "Failed to open documentation url");
		}
	}

	/**
	 * Display system information window.
	 */
	private void showInformation() {
		Stage stage = controller.windows().getInformationWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.help.info"), new SysInfoPane());
			controller.windows().setInformationWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Display system information window.
	 */
	private void openPluginManager() {
		Stage stage = controller.windows().getPluginsWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.plugins"), new PluginManagerPane(), 600, 233);
			controller.windows().setPluginsWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Open plugin directory.
	 */
	private void openPluginDirectory() {
		try {
			UiUtil.showDocument(Recaf.getDirectory("plugins").toUri());
		} catch(IOException ex) {
			Log.error(ex, "Failed to open plugins directory");
		}
	}

	/**
	 * Display attach window.
	 */
	private void attachExisting() {
		Stage stage = controller.windows().getAttachWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.attach"), new AttachPane(controller), 800, 600);
			controller.windows().setAttachWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Display JVM creation window.
	 */
	private void attachCreate() {
		Stage stage = controller.windows().getJvmCreatorWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.createjvm"), new JvmCreationPane(controller), 650, 480);
			controller.windows().setJvmCreatorWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * Save the current application via instrumentation.
	 */
	public void saveAgent() {
		try {
			InstrumentationResource.getInstance().save();
		} catch(Throwable t) {
			error(t, "Failed to save agent changes");
			ExceptionAlert.show(t, "Failed to save agent changes");
		}
	}

	/**
	 * Save the current workspace to a file.
	 */
	private void saveWorkspace() {
		if (controller.getWorkspace() == null) {
			return;
		}
		fcSaveWorkspace.setInitialDirectory(config().getRecentSaveWorkspaceDir());
		File file = fcSaveWorkspace.showSaveDialog(null);
		if (file != null) {
			String json = WorkspaceIO.toJson(controller.getWorkspace());
			try {
				FileUtils.write(file, json, UTF_8);
				config().recentSaveWorkspace = file.getAbsolutePath();
			} catch(IOException ex) {
				error(ex, "Failed to save workspace to file: {}", file.getName());
				ExceptionAlert.show(ex, "Failed to save workspace to file: " + file.getName());
			}
		}
	}

	/**
	 * Update the recent files menu.
	 */
	public void updateRecent() {
		mFileRecent.getItems().clear();
		config().getRecentFiles().forEach(this::addRecentItem);
	}

	/**
	 * @param path
	 * 		Path to add to recent files menu.
	 */
	private void addRecentItem(String path) {
		Path fspath = Paths.get(path);
		if(Files.exists(fspath)) {
			String name = fspath.getFileName().toString();
			if (Files.isDirectory(fspath))
				name += "/";
			Node graphic = new IconView(getFileIcon(name));
			mFileRecent.getItems().add(new ActionMenuItem(name, graphic, () -> controller.loadWorkspace(fspath, null)));
		} else {
			// Not a valid file, so we remove it from the files list
			config().recentFiles.remove(path);
		}
	}

	/**
	 * Open config window.
	 */
	private void showConfig() {
		Stage stage = controller.windows().getConfigWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.config"), new ConfigTabs(controller));
			controller.windows().setConfigWindow(stage);
		}
		stage.show();
		stage.toFront();
	}


	/**
	 * Open theme editor window.
	 */
	private void showThemeEditor() {
		Themes.showThemeEditor(controller);
	}

	/**
	 * @return Private config.
	 */
	private ConfBackend config() {
		return controller.config().backend();
	}
}

```

`src/main/java/me/coley/recaf/ui/MainWindow.java`:

```java
package me.coley.recaf.ui;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Orientation;
import javafx.scene.Scene;
import javafx.scene.control.SplitPane;
import javafx.scene.image.Image;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.InternalPlugin;
import me.coley.recaf.plugin.api.WorkspacePlugin;
import me.coley.recaf.ui.controls.ViewportTabs;
import me.coley.recaf.ui.controls.WorkspaceNavigator;
import me.coley.recaf.ui.controls.popup.UpdateWindow;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.view.FileViewport;
import me.coley.recaf.util.OSUtil;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.util.VMUtil;
import me.coley.recaf.util.self.SelfUpdater;
import me.coley.recaf.workspace.InstrumentationResource;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;
import org.plugface.core.annotations.Plugin;

import java.lang.management.ManagementFactory;
import java.lang.management.PlatformLoggingMXBean;

import static me.coley.recaf.util.ClasspathUtil.resource;

/**
 * Primary window.
 *
 * @author Matt
 */
public class MainWindow extends Application {
	private static MainWindow window;
	private final GuiController controller;
	private Stage stage;
	private BorderPane root;
	private BorderPane navRoot;
	private BorderPane viewRoot;
	private MainMenu menubar;
	private ViewportTabs tabs;
	private WorkspaceNavigator navigator;

	private MainWindow(GuiController controller) {
		this.controller = controller;
	}

	@Override
	public void start(Stage stage) throws Exception {
		Platform.setImplicitExit(false);
		// Set instances
		window = this;
		this.stage = stage;
		stage.setOnCloseRequest(e -> controller.exit());
		setup();
		stage.show();
	}

	private void setup() {
		if (OSUtil.getOSType() == OSUtil.MAC) {
			UiUtil.setupMacDockIcon();
		} else {
			stage.getIcons().add(new Image(resource("icons/logo.png")));
		}
		stage.setTitle("Recaf");
		menubar = new MainMenu(controller);
		root = new BorderPane();
		root.setTop(menubar);
		navRoot = new BorderPane();
		viewRoot = new BorderPane();
		tabs = new ViewportTabs(controller);
		SplitPane split = new SplitPane();
		split.setOrientation(Orientation.HORIZONTAL);
		split.getItems().addAll(navRoot, viewRoot);
		split.setDividerPositions(0.333);
		SplitPane.setResizableWithParent(navRoot, Boolean.FALSE);
		root.setCenter(split);
		viewRoot.setCenter(tabs);
		// Navigation
		updateWorkspaceNavigator();
		PluginsManager.getInstance().addPlugin(new WindowPlugin());
		// Create scene & display the window
		Scene scene = new Scene(root, 800, 600);
		controller.windows().reapplyStyle(scene);
		controller.config().keys().registerMainWindowKeys(controller, stage, scene);
		stage.setScene(scene);
		// Show update prompt
		if (SelfUpdater.hasUpdate())
			UpdateWindow.create(this).show(root);
	}

	private void updateWorkspaceNavigator() {
		Platform.runLater(() -> navRoot.setCenter(navigator = new WorkspaceNavigator(controller)));
	}

	/**
	 * @param resource
	 * 		Resource containing the class.
	 * @param name
	 * 		Name of class to open.
	 *
	 * @return Viewport of the class.
	 */
	public ClassViewport openClass(JavaResource resource, String name) {
		return tabs.openClass(resource, name);
	}

	/**
	 * @param name
	 * 		Name of class.
	 *
	 * @return Viewport of the class. {@code null} if the class is not currently open.
	 */
	public ClassViewport getClassViewport(String name) {
		return tabs.getClassViewport(name);
	}

	/**
	 * @param resource
	 * 		Resource containing the resource.
	 * @param name
	 * 		Name of file to open.
	 *
	 * @return Viewport of the file.
	 */
	public FileViewport openFile(JavaResource resource, String name) {
		return tabs.openFile(resource, name);
	}

	/**
	 * @param name
	 * 		Name of file.
	 *
	 * @return Viewport of the file. {@code null} if the file is not currently open.
	 */
	public FileViewport getFileViewport(String name) {
		return tabs.getFileViewport(name);
	}

	/**
	 * @return Open class/file tabs.
	 */
	public ViewportTabs getTabs() {
		return tabs;
	}

	/**
	 * Save the current application to a file.
	 */
	public void saveApplication() {
		menubar.saveApplication();
	}

	/**
	 * @return Initial stage.
	 */
	public Stage getStage() {
		return stage;
	}

	/**
	 * @return Root control.
	 */
	public BorderPane getRoot() {
		return root;
	}

	/**
	 * @return Menubar.
	 */
	public MainMenu getMenubar() {
		return menubar;
	}

	/**
	 * @return Workspace navigator. Will be {@code null} if the current workspace is {@code null}.
	 */
	public WorkspaceNavigator getNavigator() {
		return navigator;
	}

	/**
	 * @param controller
	 * 		Window context.
	 *
	 * @return main window instance.
	 */
	public static MainWindow get(GuiController controller) {
		if (window == null) {
			MainWindow app = window = new MainWindow(controller);
			VMUtil.tkIint();
			Platform.runLater(() -> {
				Stage stage = new Stage();
				try {
					// When Recaf is run as an agent on Java 11+ then there is some additional weird classloader logic
					// with modules where it cannot resolve paths to resources. We can simply set the classloader here
					// to point it to whatever classloader has loaded Recaf.
					if (VMUtil.getVmVersion() >= 11 && InstrumentationResource.isActive() &&
							Thread.currentThread().getContextClassLoader() == null) {
						Thread.currentThread().setContextClassLoader(Recaf.class.getClassLoader());
					}
					// Initialize the JFX app once things are configured.
					app.init();
					app.start(stage);
				} catch (Exception ex) {
					throw new RuntimeException(ex);
				}
				// Disable CSS logger, it complains a lot about non-issues
				try {
					ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class)
							.setLoggerLevel("javafx.css", "OFF");
				} catch (IllegalArgumentException ignored) {
					// Expected: logger may not exist
				}
			});
		}
		return window;
	}

	/**
	 * Clear open tabs and remove the current workspace navigator.
	 */
	public void clear() {
		if (tabs != null)
			tabs.getTabs().clear();
		if (navRoot != null && navRoot.getCenter() != null) {
			WorkspaceNavigator nav = ((WorkspaceNavigator) navRoot.getCenter());
			nav.enablePlaceholder();
			nav.clear("...");
		}
	}

	/**
	 * Clear tab viewports
	 */
	public void clearTabViewports() {
		if (tabs != null)
			ThreadUtil.checkJfxAndEnqueue(() -> tabs.clearViewports());
	}

	/**
	 * Set disability status of window components.
	 *
	 * @param status
	 * 		Disability status.
	 */
	public void disable(boolean status) {
		menubar.setDisable(status);
		if (tabs != null)
			tabs.setDisable(status);
		if (navRoot != null)
			navRoot.setDisable(status);
	}

	/**
	 * Update the navigation pane with an informational message.<br>
	 * Used when loading workspaces for visual feedback.
	 *
	 * @param status
	 * 		Message to update.
	 */
	public void status(String status) {
		if (navRoot != null && navRoot.isDisable() && navRoot.getCenter() != null)
			((WorkspaceNavigator) navRoot.getCenter()).clear(status);
	}

	/**
	 * @param title
	 * 		Window title to set.
	 */
	public void setTitle(String title) {
		ThreadUtil.checkJfxAndEnqueue(() -> stage.setTitle(title));
	}

	@Plugin(name = "MainWindow")
	private final class WindowPlugin implements WorkspacePlugin, InternalPlugin {

		@Override
		public void onOpened(Workspace workspace) {
			updateWorkspaceNavigator();
		}

		@Override
		public void onClosed(Workspace workspace) {
		}

		@Override
		public String getVersion() {
			return Recaf.VERSION;
		}

		@Override
		public String getDescription() {
			return "Main window UI.";
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/Themes.java`:

```java
package me.coley.recaf.ui;

import javafx.stage.Stage;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.text.CssThemeEditorPane;
import me.coley.recaf.util.Resource;
import me.coley.recaf.util.self.SelfReferenceUtil;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Theme manager.
 *
 * @author Matt
 */
public class Themes {
	/**
	 * Open the custom theme editor.
	 *
	 * @param controller
	 * 		Current controller.
	 */
	public static void showThemeEditor(GuiController controller) {
		Stage stage = controller.windows().getThemeEditorWindow();
		if(stage == null) {
			stage = controller.windows().window(translate("ui.menubar.themeeditor"),
					new CssThemeEditorPane(controller));
			controller.windows().setThemeEditorWindow(stage);
		}
		stage.show();
		stage.toFront();
	}

	/**
	 * @return List of application-wide styles.
	 */
	public static List<Resource> getStyles() {
		List<Resource> resources =  SelfReferenceUtil.get().getStyles();
		resources.addAll(get("ui-", ".css"));
		return resources;
	}

	/**
	 * @return List of text-editor styles.
	 */
	public static List<Resource> getTextThemes() {
		List<Resource> resources =  SelfReferenceUtil.get().getTextThemes();
		resources.addAll(get("text-", ".css"));
		return resources;
	}

	private static Collection<Resource> get(String prefix, String suffix) {
		List<Resource> resources = new ArrayList<>();
		File styleDirectory = Recaf.getDirectory("style").toFile();
		if (!styleDirectory.exists())
			styleDirectory.mkdir();
		for (File file : styleDirectory.listFiles()) {
			String name = file.getName();
			if (name.startsWith(prefix) && name.endsWith(suffix))
				resources.add(Resource.external(file.getPath().replace('\\', '/')));
		}
		return resources;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ActionButton.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.Button;

/**
 * Button with an on-click runnable action.
 *
 * @author Matt
 */
public final class ActionButton extends Button {
	/**
	 * @param text
	 * 		Button display text.
	 * @param action
	 * 		Action to run on-click.
	 */
	public ActionButton(String text, Runnable action) {
		super(text);
		setOnAction(o -> action.run());
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/ActionMenu.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.Menu;
import javafx.scene.layout.HBox;

/**
 * Menu with an on-click runnable action.
 *
 * @author Matt
 */
public class ActionMenu extends Menu {
	/**
	 * @param text
	 * 		Menu item display text.
	 * @param action
	 * 		Action to run on-click.
	 */
	public ActionMenu(String text, Runnable action) {
		this(text, null, action);
	}

	/**
	 * @param text
	 * 		Menu display text.
	 * @param graphic
	 * 		Menu graphic.
	 * @param action
	 * 		Action to run on-click.
	 */
	public ActionMenu(String text, Node graphic, Runnable action) {
		super();
		// This is a hack: https://stackoverflow.com/a/10317260
		// Works well enough without having to screw with CSS.
		Label label = new Label(text);
		label.getStyleClass().add("action-menu-title");
		if (graphic != null)
			setGraphic(new HBox(graphic, label));
		else
			setGraphic(label);
		label.setOnMousePressed(e -> action.run());
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ActionMenuItem.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.Node;
import javafx.scene.control.MenuItem;

/**
 * MenuItem with an on-click runnable action.
 *
 * @author Matt
 */
public class ActionMenuItem extends MenuItem {
	/**
	 * @param text
	 * 		Menu item display text.
	 * @param action
	 * 		Action to run on-click.
	 */
	public ActionMenuItem(String text, Runnable action) {
		this(text, null, action);
	}

	/**
	 * @param text
	 * 		Menu item display text.
	 * @param graphic
	 * 		Menu item graphic.
	 * @param action
	 * 		Action to run on-click.
	 */
	public ActionMenuItem(String text, Node graphic, Runnable action) {
		super(text);
		setGraphic(graphic);
		setOnAction(e -> action.run());
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ActionTextArea.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.TextArea;
import javafx.scene.input.KeyEvent;
import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.control.gui.GuiController;

import java.util.function.Predicate;

/**
 * TextArea with an on-save action.
 *
 * @author Matt
 */
public final class ActionTextArea extends TextArea {
	private final GuiController controller;
	private final Predicate<String> action;

	/**
	 * @param controller
	 * 		Controller to pull save keybind from.
	 * @param text
	 * 		Initial text.
	 * @param action
	 * 		Action to run on-save.
	 */
	public ActionTextArea(GuiController controller, String text, Predicate<String> action) {
		super(text == null ? "" : text);
		this.controller = controller;
		this.action = action;
		setOnKeyReleased(this::handleKeyReleased);
	}

	private void handleKeyReleased(KeyEvent e) {
		ConfKeybinding keys = controller.config().keys();
		if (keys.save.match(e)) {
			action.test(getText());
		}
	}

	/**
	 * @return On-save action.
	 */
	public Predicate<String> getAction() {
		return action;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/ActionTextField.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.control.gui.GuiController;

import java.util.function.Predicate;

/**
 * TextField with an on-save action.
 *
 * @author Matt
 */
public final class ActionTextField extends TextField {
	private final GuiController controller;
	private final Predicate<String> action;

	/**
	 * @param controller
	 * 		Controller to pull save keybind from.
	 * @param text
	 * 		Initial text.
	 * @param action
	 * 		Action to run on-save.
	 */
	public ActionTextField(GuiController controller, String text, Predicate<String> action) {
		super(text == null ? "" : text);
		this.controller = controller;
		this.action = action;
		setOnKeyReleased(this::handleKeyReleased);
	}

	private void handleKeyReleased(KeyEvent e) {
		ConfKeybinding keys = controller.config().keys();
		if (keys.save.match(e)) {
			action.test(getText());
		}
	}

	/**
	 * @return On-save action.
	 */
	public Predicate<String> getAction() {
		return action;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/ClassEditor.java`:

```java
package me.coley.recaf.ui.controls;

import java.util.Map;

/**
 * Common functionality of class editor displays.
 *
 * @author Matt
 */
public interface ClassEditor {
	/**
	 * Compiles the current source code.
	 *
	 * @param name
	 * 		Class name to compile.
	 *
	 * @return Recompiled bytecode of classes <i>(Should there be any inner classes)</i>.
	 */
	Map<String, byte[]> save(String name);

	/**
	 * Select the definition of the given member.
	 *
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	void selectMember(String name, String desc);
}

```

`src/main/java/me/coley/recaf/ui/controls/EnumComboBox.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.collections.FXCollections;
import javafx.scene.control.ComboBox;
import me.coley.recaf.config.FieldWrapper;

/**
 * ComboBox for enumeration types.
 *
 * @param <E>
 * 		Enumeration type.
 *
 * @author Matt
 */
public class EnumComboBox<E extends Enum> extends ComboBox<E> {
	/**
	 * @param type
	 * 		Enumeration type.
	 * @param initial
	 * 		Initial selection.
	 */
	public EnumComboBox(Class<E> type, E initial) {
		super(FXCollections.observableArrayList(type.getEnumConstants()));
		setValue(initial);
	}

	/**
	 * @param wrapper
	 * 		Wrapper of an enumeration field.
	 */
	public EnumComboBox(FieldWrapper wrapper) {
		this(wrapper.type(), wrapper.get());
		getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> wrapper.set(n));
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/ExceptionAlert.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.application.Platform;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.stage.Stage;
import me.coley.recaf.util.UiUtil;

import java.io.*;
import java.net.URI;
import java.net.URLEncoder;

import static me.coley.recaf.util.LangUtil.translate;
import static me.coley.recaf.util.ClasspathUtil.resource;
import static me.coley.recaf.util.Log.error;

/**
 * Alert that shows an exception.
 *
 * @author Matt
 */
public class ExceptionAlert extends Alert {
	private static final String BUG_REPORT_LINK = "https://github.com/Col-E/Recaf/" +
			"issues/new?template=bug_report.md&title=";

	private ExceptionAlert(Throwable t, String msg) {
		super(AlertType.ERROR);
		setTitle("An error occurred");
		String header = t.getMessage();
		if(header == null)
			header = "(" + translate("ui.noerrormsg") + ")";
		setHeaderText(header);
		setContentText(msg);
		// Get exception text
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		t.printStackTrace(pw);
		String exText = sw.toString();
		// Create expandable Exception.
		Label lbl = new Label("Exception stacktrace:");
		TextArea txt = new TextArea(exText);
		txt.setEditable(false);
		txt.setWrapText(false);
		txt.setMaxWidth(Double.MAX_VALUE);
		txt.setMaxHeight(Double.MAX_VALUE);
		Hyperlink link = new Hyperlink("[Bug report]");
		link.setOnAction(e -> {
			try {
				// Append suffix to bug report url for the issue title
				String suffix = t.getClass().getSimpleName();
				if (t.getMessage() != null)
					suffix = suffix + ": " + t.getMessage();
				suffix = URLEncoder.encode(suffix, "UTF-8");
				// Open link in default browser
				UiUtil.showDocument(URI.create(BUG_REPORT_LINK + suffix));
			} catch(IOException exx) {
				error(exx, "Failed to open bug report link");
				show(exx, "Failed to open bug report link.");
			}
		});
		TextFlow prompt = new TextFlow(new Text(translate("ui.openissue")), link);
		GridPane.setVgrow(txt, Priority.ALWAYS);
		GridPane.setHgrow(txt, Priority.ALWAYS);
		GridPane grid = new GridPane();
		grid.setMaxWidth(Double.MAX_VALUE);
		grid.add(lbl, 0, 0);
		grid.add(txt, 0, 1);
		grid.add(prompt, 0, 2);
		getDialogPane().setExpandableContent(grid);
		getDialogPane().setExpanded(true);
		// Set icon
		Stage stage = (Stage) getDialogPane().getScene().getWindow();
		stage.getIcons().add(new Image(resource("icons/error.png")));
	}

	/**
	 * Show the dialog for the given exception.
	 *
	 * @param t
	 * 		Exception to show in the dialog.
	 */
	public static void show(Throwable t) {
		show(t, null);
	}

	/**
	 * Show the dialog for the given exception.
	 *
	 * @param t
	 * 		Exception to show in the dialog.
	 * @param msg
	 * 		Additional message to show.
	 */
	public static void show(Throwable t, String msg) {
		Platform.runLater(() -> new ExceptionAlert(t, msg).show());
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/FontComboBox.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.collections.FXCollections;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ListCell;
import javafx.scene.text.Font;
import javafx.util.StringConverter;
import me.coley.recaf.Recaf;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.control.gui.GuiController;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * ComboBox for font types.
 *
 * @author Matt
 */
public class FontComboBox extends ComboBox<Font> {
	private static final List<Font> FONT_LIST = new ArrayList<>();
	private static final File FONT_CSS = Recaf.getDirectory("style").resolve("font.css").toFile();


	/**
	 * @param values
	 * 		Font types.
	 * @param initial
	 * 		Initial selection.
	 */
	public FontComboBox(Collection<Font> values, Font initial) {
		super(FXCollections.observableArrayList(values));
		setCellFactory(e -> new FontCell());
		setConverter(new StringConverter<Font>() {
			@Override
			public String toString(Font object) {
				return object.getName();
			}

			@Override
			public Font fromString(String string) {
				return Font.font(string, 12);
			}
		});
		setValue(initial);
	}

	/**
	 * @param controller
	 * 		Controller to update.
	 * @param wrapper
	 * 		Wrapper of an string field representing the font family name.
	 * @param initial
	 * 		Initial selection.
	 */
	public FontComboBox(GuiController controller, FieldWrapper wrapper, String initial) {
		this(FONT_LIST, new Font(initial, 12));
		getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
			wrapper.set(n.getFamily());
			update(controller);
		});
	}

	/**
	 * Update's the font-size override sheet and reapplies styles to open windows.
	 *
	 * @param controller
	 * 		Controller to update.
	 */
	private static void update(GuiController controller) {
		try {
			String uiFont = controller.config().display().uiFont;
			String monoFont = controller.config().display().monoFont;
			String css = 	".root { -fx-font-family: \"" + uiFont + "\" !important; }\n" +
							".lineno { -fx-font-family: \"" + uiFont + "\" !important; }\n" +
							".h1 { -fx-font-family: \"" + uiFont + "\" !important; }\n" +
							".h2 { -fx-font-family: \"" + uiFont + "\" !important; }\n" +
							".monospaced { -fx-font-family: \"" + monoFont + "\" !important; }\n";
			FileUtils.write(FONT_CSS, css, StandardCharsets.UTF_8);
			controller.windows().reapplyStyles();
		} catch (IOException ex) {
			ExceptionAlert.show(ex, "Failed to set font size");
		}
	}

	/**
	 * Adds the font-size override to the given scene.
	 *
	 * @param scene
	 * 		Scene to add stylesheet to.
	 */
	public static void addMonoFontStyleSheet(Scene scene) {
		if (FONT_CSS.exists())
			scene.getStylesheets().add("file:///" + FONT_CSS.getAbsolutePath().replace("\\", "/"));
	}

	static class FontCell extends ListCell<Font> {
		@Override
		protected void updateItem(Font item, boolean empty) {
			super.updateItem(item, empty);
			if (empty) {
				setText(null);
				setGraphic(null);
			} else {
				setStyle("-fx-font-family: \"" + item.getFamily() + "\" !important;");
				setText(item.getName());
			}
		}
	}

	static {
		SortedSet<Font> fonts = new TreeSet<>(Comparator.comparing(Font::getFamily));
		for (String family : Font.getFamilies()) {
			Font font = Font.font(family, 12);
			fonts.add(font);
		}
		FONT_LIST.addAll(fonts);
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/FontSlider.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.Scene;
import javafx.scene.control.Slider;
import me.coley.recaf.Recaf;
import me.coley.recaf.config.ConfigManager;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.control.gui.GuiController;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Objects;

/**
 * Font scaling control &amp; utility.
 *
 * @author Matt
 */
public class FontSlider extends Slider {
	private static final File FONT_SIZE_CSS = Recaf.getDirectory("style").resolve("font-size.css").toFile();
	private static final int FONT_SIZE_MIN = 10;
	private static final int FONT_SIZE_MAX = 16;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param wrapper
	 * 		Font size field wrapper.
	 */
	public FontSlider(GuiController controller, FieldWrapper wrapper) {
		setMin(FONT_SIZE_MIN);
		setMax(FONT_SIZE_MAX);
		setMajorTickUnit(1);
		setMinorTickCount(0);
		setShowTickMarks(true);
		setShowTickLabels(true);
		setSnapToTicks(true);
		setValue(Objects.requireNonNull(wrapper.get()));
		// On release, set the font field value and update the UI
		valueProperty().addListener(((observable, oldValue, newValue) -> {
			double oldValue2 = Math.round(oldValue.doubleValue());
			double newValue2 = Math.round(newValue.doubleValue());
			setValue(newValue2);
			if (newValue2 != oldValue2) {
				wrapper.set(newValue2);
				update(controller);
			}
		}));
	}

	/**
	 * Clamps the font size so that it doesn't go out of bounds.
	 * @param configManager
	 * 		ConfigManager to update.
	 */
	private static void clampFontSize(ConfigManager configManager) {
		if(configManager.display().uiFontSize > FONT_SIZE_MAX)
			configManager.display().uiFontSize = FONT_SIZE_MAX;

		if(configManager.display().uiFontSize < FONT_SIZE_MIN)
			configManager.display().uiFontSize = FONT_SIZE_MIN;

		if(configManager.display().monoFontSize > FONT_SIZE_MAX)
			configManager.display().monoFontSize = FONT_SIZE_MAX;

		if(configManager.display().monoFontSize < FONT_SIZE_MIN)
			configManager.display().monoFontSize = FONT_SIZE_MIN;
	}

	/**
	 * Update's the font-size override sheet and reapplies styles to open windows.
	 *
	 * @param controller
	 * 		Controller to update.
	 */
	public static void update(GuiController controller) {
		try {
			clampFontSize(controller.config());

			double uiFontSize = controller.config().display().uiFontSize;
			double monoFontSize = controller.config().display().monoFontSize;

			String css = 	".root { -fx-font-size: " + uiFontSize + "px; }\n" +
							".lineno { -fx-font-size: " + uiFontSize + "px; }\n" +
							".h1 { -fx-font-size: " + (uiFontSize + 5) + "px; }\n" +
							".h2 { -fx-font-size: " + (uiFontSize + 3) + "px; }\n" +
							".monospaced { -fx-font-size: " + monoFontSize + "px; }\n" +
							".monospaced-tree { -fx-font-size: " + uiFontSize + "px; }\n";
			FileUtils.write(FONT_SIZE_CSS, css, StandardCharsets.UTF_8);
			controller.windows().reapplyStyles();
		} catch (IOException ex) {
			ExceptionAlert.show(ex, "Failed to set font size");
		}
	}

	/**
	 * Adds the font-size override to the given scene.
	 *
	 * @param scene
	 * 		Scene to add stylesheet to.
	 */
	public static void addFontSizeStyleSheet(Scene scene) {
		if (FONT_SIZE_CSS.exists())
			scene.getStylesheets().add("file:///" + FONT_SIZE_CSS.getAbsolutePath().replace("\\", "/"));
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/HexEditor.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.application.Platform;
import javafx.scene.control.*;
import javafx.scene.control.cell.*;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.*;
import javafx.collections.*;
import javafx.beans.property.*;
import javafx.util.Callback;
import javafx.util.converter.DefaultStringConverter;
import me.coley.recaf.util.ThreadUtil;

import java.util.Arrays;
import java.util.function.Consumer;

/**
 * Hex editor control.
 *
 * @author Matt
 */
public class HexEditor extends BorderPane {
	private static final int INVALID = Byte.MAX_VALUE + 1;
	private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
	private static final int COLS_PER_LINE = 16;
	private final TableView<Integer> contentTable = new TableView<>();
	private final TableView<Integer> offsetTable = new TableView<>();
	private final TableView<Integer> textTable = new TableView<>();
	private final TableViewExtra<?> tveContent = new TableViewExtra<>(contentTable);
	private final TableViewExtra<?> tveOffset = new TableViewExtra<>(offsetTable);
	private final TableViewExtra<?> tveText = new TableViewExtra<>(textTable);
	private byte[] content;
	private Consumer<byte[]> contentCallback;

	/**
	 * @param array
	 * 		Content to edit.
	 */
	public HexEditor(byte[] array) {
		content = array;
		DummyList dummy = new DummyList();
		TableColumn<Integer, String> offsetColumn = new TableColumn<>("Offset");
		TableColumn<Integer, String> textColumn = new TableColumn<>("Text");
		Callback<TableColumn<Integer, String>,TableCell<Integer, String>> columnCellFactory =
				offsetColumn.getCellFactory();
		offsetColumn.setCellValueFactory(cellData -> {
			int row = cellData.getValue();
			if (row >= dummy.size() - DummyList.DUMMY_PAD_LINES)
				return new SimpleStringProperty();
			return new SimpleStringProperty(Integer.toHexString(row * COLS_PER_LINE) + ":");
		});
		textColumn.setCellValueFactory(cellData -> {
			int row = cellData.getValue();
			StringBuilder sb = new StringBuilder();
			for (int i = row * COLS_PER_LINE; i < ((row + 1) * COLS_PER_LINE); i++){
				if(i >= content.length)
					break;
				char c = (char) content[i];
				// http://www.techdictionary.com/ascii.html
				// - 0x20: space
				// - 0x7E: tilde
				// Everything in between is a standard character.
				if (c >= 0x20 && c <= 0xF1)
					sb.append(c);
				else
					sb.append('.');
			}
			return new SimpleStringProperty(sb.toString());
		});
		offsetColumn.setCellFactory(col -> {
			TableCell<Integer, String> cell = columnCellFactory.call(col);
			cell.getStyleClass().add("hex-offset-cell");
			cell.getStyleClass().add("hex-cell");
			return cell;
		});
		textColumn.setCellFactory(col -> {
			TableCell<Integer, String> cell = columnCellFactory.call(col);
			cell.getStyleClass().add("hex-text-cell");
			cell.getStyleClass().add("hex-cell");
			return cell;
		});
		for(int columnIndex = 0; columnIndex < COLS_PER_LINE; columnIndex++) {
			int columnCopy = columnIndex;
			TableColumn<Integer, String> contentColumn = new TableColumn<>(String.valueOf(HEX_ARRAY[columnIndex]));
			// Handle edit actions
			contentColumn.setOnEditCommit(e -> {
				// Verify valid hex format
				String text = e.getNewValue().toUpperCase();
				if(isHex(text)) {
					// Update array
					int index = (e.getRowValue() * COLS_PER_LINE) + columnCopy;
					byte value = unhex(text);
					updateContent(index, value);
				}
				// Update table
				refresh();
			});
			// Create property wrappers of hex strings
			contentColumn.setCellValueFactory(cellData -> {
				int row = cellData.getValue();
				int index = (row * COLS_PER_LINE) + columnCopy;
				int value = index >= content.length ? INVALID : content[index];
				if(value == INVALID)
					return new SimpleStringProperty();
				return new SimpleStringProperty(hex(value));
			});
			// Column cells
			contentColumn.setCellFactory(col -> {
				TextFieldTableCell<Integer, String> cell = new TextFieldTableCell<>();
				cell.setConverter(new DefaultStringConverter());
				cell.getStyleClass().add("hex-cell");
				// We don't have the row context, so we will set the text field to be editable if
				// it fits the basic hex patterns we're expecting to be set later.
				cell.textProperty().addListener((v, o, n) ->
					cell.setEditable(n != null && n.length() == 2)
				);
				return cell;
			});
			contentTable.getColumns().add(contentColumn);
		}
		// Setup items / selection model / sizing
		contentTable.setEditable(true);
		contentTable.setItems(dummy);
		contentTable.getSelectionModel().selectFirst();
		contentTable.sortPolicyProperty().set(t -> false);
		contentTable.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		contentTable.getStyleClass().add("hex-content-table");
		offsetTable.setItems(contentTable.getItems());
		offsetTable.sortPolicyProperty().set(t -> false);
		offsetTable.getColumns().add(offsetColumn);
		offsetTable.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		offsetTable.selectionModelProperty().bind(contentTable.selectionModelProperty());
		offsetTable.getStyleClass().add("hex-offset-table");
		textTable.setItems(contentTable.getItems());
		textTable.sortPolicyProperty().set(t -> false);
		textTable.getColumns().add(textColumn);
		textTable.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		textTable.selectionModelProperty().bind(contentTable.selectionModelProperty());
		textTable.getStyleClass().add("hex-text-table");
		// Scroll synchronization hackery
		contentTable.addEventFilter(ScrollEvent.ANY, e -> syncFromContent());
		offsetTable.addEventFilter(ScrollEvent.ANY, e -> syncFromOffset());
		textTable.addEventFilter(ScrollEvent.ANY, e -> syncFromText());
		contentTable.getSelectionModel().selectedIndexProperty().addListener((v, o, n) -> syncFromContent());
		// Add to layout
		getStyleClass().add("hex-wrapper");
		setCenter(contentTable);
		setLeft(offsetTable);
		setRight(textTable);
		// Register a refresh so the elements are resized properly
		// - JavaFX bug, and yes that delay is needed.
		ThreadUtil.runJfxDelayed(100, () -> {
			contentTable.refresh();
			offsetTable.refresh();
			textTable.refresh();
		});
	}

	private void updateContent(int index, byte value) {
		content[index] = value;
		if (contentCallback != null)
			contentCallback.accept(content);
	}

	private void refresh() {
		contentTable.refresh();
		textTable.refresh();
	}

	/**
	 * @param contentCallback
	 * 		Called when the content is modified.
	 */
	public void setContentCallback(Consumer<byte[]> contentCallback) {
		this.contentCallback = contentCallback;
	}

	/**
	 * @return Array being modified.
	 */
	public byte[] getContent() {
		return content;
	}

	/**
	 * @param editable
	 *        {@code true} to allow editing of the content table, {@code false} to disable editing.
	 */
	public void setEditable(boolean editable) {
		contentTable.setEditable(editable);
	}

	// ================= SCROLL SYNCHRONIZATION ================== //

	private void syncFromContent() {
		Platform.runLater(() -> {
			int top = tveContent.getFirstVisibleIndex();
			contentTable.scrollTo(top);
			offsetTable.scrollTo(top);
			textTable.scrollTo(top);
		});
	}

	private void syncFromOffset() {
		Platform.runLater(() -> {
			int top = tveOffset.getFirstVisibleIndex();
			contentTable.scrollTo(top);
			textTable.scrollTo(top);
		});
	}

	private void syncFromText() {
		Platform.runLater(() -> {
			int top = tveText.getFirstVisibleIndex();
			offsetTable.scrollTo(top);
			contentTable.scrollTo(top);
		});
	}

	// ======================== HEX UTILS ======================== //

	private static boolean isHex(String text) {
		return  text.length() == 2 &&
				Arrays.binarySearch(HEX_ARRAY, text.charAt(0)) >= 0 &&
				Arrays.binarySearch(HEX_ARRAY, text.charAt(1)) >= 0;
	}

	private static String hex(int value) {
		return new String(new char[]{
				HEX_ARRAY[(value & 0xFF) >>> 4],
				HEX_ARRAY[(value & 0xFF) & 0x0F]
		});
	}

	private static byte unhex(String value) {
		return (byte) Integer.parseInt(value, 16);
	}

	// ====================== INNER CLASSES ====================== //

	/**
	 * Dummy observable list. Truly a hack, but it works.
	 */
	private class DummyList extends ObservableListBase<Integer> {
		private static final int DUMMY_PAD_LINES = 1;

		@Override
		public int size() {
			// We add DUMMY_PAD_LINES to the actual length so the table has a final "dummy" line.
			// This allows the entire table to be visible with out scroll sync hack.
			return DUMMY_PAD_LINES + (int) Math.ceil(content.length / (double) COLS_PER_LINE);
		}

		@Override
		public Integer get(int index) {
			// The arg is the row. We don't get a per-column index so we will just return the
			// arg and handle fetching the actual content locally instead of here.
			// This is just semantics to get the table to display the byte array.
			return index;
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/IconView.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

import static me.coley.recaf.util.ClasspathUtil.resource;

/**
 * ImageView extension for icons.
 */
public class IconView extends ImageView {
	private static final int DEFAULT_ICON_SIZE = 16;

	/**
	 * @param path
	 * 		Path to resource.
	 */
	public IconView(String path) {
		this(new Image(resource(path)));
	}

	/**
	 * @param image
	 * 		Image resource.
	 */
	public IconView(Image image) {
		super(image);
		fitHeightProperty().set(DEFAULT_ICON_SIZE);
		fitWidthProperty().set(DEFAULT_ICON_SIZE);
	}

	/**
	 * @param image
	 * 		Image resource.
	 * @param size
	 * 		Image width/height.
	 */
	public IconView(Image image, int size) {
		super(image);
		fitHeightProperty().set(size);
		fitWidthProperty().set(size);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/KeybindField.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.event.Event;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import me.coley.recaf.Recaf;
import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Log;

/**
 * TextField for updating keybinds.
 *
 * @author Matt
 */
public class KeybindField extends TextField {
	private final ConfKeybinding.Binding target;
	private final String name;
	private ConfKeybinding.Binding lastest;

	/**
	 * @param field
	 * 		Target field of the binding to modify.
	 */
	public KeybindField(FieldWrapper field) {
		this.target = field.get();
		if (target == null)
			throw new IllegalStateException("KeybindField's target binding must not be null!");
		this.name = field.isTranslatable() ? field.name() : field.key();
		getStyleClass().add("key-field");
		setText(target.toString());
		setPromptText(LangUtil.translate("binding.inputprompt.initial"));
		// Show prompt when focused, otherwise show current target binding text
		focusedProperty().addListener((v, old, focus) -> setText(focus ? null : target.toString()));
		// Listen for new binding
		setOnKeyPressed(e -> {
			e.consume();
			// Skip if no-name support for the character
			if(e.getCode().getName().equalsIgnoreCase("undefined"))
				return;
			// Set target to latest
			if(e.getCode() == KeyCode.ENTER) {
				update();
				return;
			}
			// Update latest
			lastest = ConfKeybinding.Binding.from(e);
			setPromptText(LangUtil.translate("binding.inputprompt.finish"));
			setText(null);
			conf().setIsUpdating(true);
		});
		// Disable text updating
		setOnKeyTyped(Event::consume);
	}

	private void update() {
		conf().setIsUpdating(false);
		target.clear();
		target.addAll(lastest);
		getParent().requestFocus();

		setText(target.toString());
		Log.info("Updating keybind '{}' to '{}'", name, target.toString());
	}

	private ConfKeybinding conf() {
		return Recaf.getController().config().keys();
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/LanguageCombo.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.ComboBox;
import javafx.util.StringConverter;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.util.Resource;
import me.coley.recaf.util.self.SelfReferenceUtil;

import java.util.List;

import static me.coley.recaf.util.Log.error;

/**
 * Language combobox.
 *
 * @author Matt
 */
public class LanguageCombo extends ComboBox<Resource> {
	/**
	 * @param wrapper
	 * 		wrapper for the language config field.
	 */
	public LanguageCombo(FieldWrapper wrapper) {
		// Extract: translations/{name}.json
		setConverter(new StringConverter<Resource>() {
			@Override
			public String toString(Resource r) {
				String p = r.getPath();
				p = p.substring(p.lastIndexOf('/') + 1);
				return p.substring(0, p.length() - 5);
			}

			@Override
			public Resource fromString(String text) { return null; }
		});
		try {
			Resource value = wrapper.get();
			List<Resource> langs = SelfReferenceUtil.get().getLangs();
			getItems().addAll(langs);
			getSelectionModel().select(value);
			getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> wrapper.set(n));
			setMaxWidth(Double.MAX_VALUE);
		} catch(Exception ex) {
			error(ex, "Failed creating language selector");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/NullableText.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.TextField;

/**
 * TextField with {@code null} text for empty strings.
 *
 * @author Matt
 */
public class NullableText extends TextField {
	/**
	 * @return Wrapper of standard 'getText' but empty strings are returned as {@code null}.
	 */
	public String get() {
		String text = super.getText();
		if(text == null || text.trim().isEmpty())
			return null;
		return text;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/NumberSlider.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.Slider;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.control.gui.GuiController;

/**
 * Generic number scaling control &amp; utility.
 *
 * @param <N>
 * 		Type of number.
 *
 * @author Matt
 */
public class NumberSlider<N extends Number> extends Slider {
	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param wrapper
	 * 		Numeric field wrapper.
	 * @param min
	 * 		Slider min value.
	 * @param max
	 * 		Slider max value.
	 * @param majorTick
	 * 		Slider tick interval.
	 */
	public NumberSlider(GuiController controller, FieldWrapper wrapper, int min, int max,
						int majorTick) {
		setMin(min);
		setMax(max);
		setMajorTickUnit(majorTick);
		setShowTickMarks(true);
		setShowTickLabels(true);
		setSnapToTicks(true);
		setValue(toDouble(wrapper.get()));
		valueProperty().addListener(((observable, oldValue, newValue) -> {
			setValue((Double) newValue);
			if(!oldValue.equals(newValue)) {
				wrapper.set(toLong(newValue));
			}
		}));
	}

	private static long toLong(Number value) {
		return value.longValue();
	}

	private static double toDouble(Object value) {
		return ((Number) value).doubleValue();
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/NumericText.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.TextField;

/**
 * TextField that with a numeric text parse.
 *
 * @author Matt
 */
public class NumericText extends TextField {
	/**
	 * @return Generic number, {@code null} if text does not represent any number format.
	 */
	public Number get() {
		String text = getText();
		// Normal int
		if(text.matches("-?\\d+"))
			return Integer.parseInt(text);
		// Double
		else if(text.matches("-?\\d+\\.?\\d*[dD]?")) {
			if(text.toLowerCase().contains("d"))
				return Double.parseDouble(text.substring(0, text.length() - 1));
			else
				return Double.parseDouble(text);
		}
		// Float
		else if(text.matches("-?\\d+\\.?\\d*[fF]"))
			return Float.parseFloat(text.substring(0, text.length() - 1));
		// Long
		else if(text.matches("-?\\d+\\.?\\d*[lL]"))
			return Long.parseLong(text.substring(0, text.length() - 1));
		// Hex int
		else if(text.matches("-?0x\\d+"))
			return (int) Long.parseLong(text.replace("0x", ""), 16);
		// Hex long
		else if(text.matches("-?0x\\d+[lL]"))
			return Long.parseLong(text.substring(0, text.length() - 1).replace("0x", ""), 16);
		return null;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/PackageSelector.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.*;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import me.coley.recaf.control.gui.WindowManager;

import java.util.*;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Utility for selecting packages.
 *
 * @author Matt
 */
public class PackageSelector extends Button {
	private List<String> selected = Collections.emptyList();

	/**
	 * @param wm
	 * 		Window manager to use to spawn the package selector popup.
	 */
	public PackageSelector(WindowManager wm) {
		setText(translate("ui.search.skippackages.empty"));
		setOnAction(e -> {
			// Editable list
			BorderPane rootPane = new BorderPane();
			ListView<String> list = new ListView<>();
			list.itemsProperty().get().addAll(selected);
			list.setOnKeyPressed(ee -> {
				if(ee.getCode() == KeyCode.DELETE) {
					int index = list.getSelectionModel().getSelectedIndex();
					list.getItems().remove(index);
					update(list.getItems());
				}
			});
			list.setEditable(true);
			// List add
			BorderPane addPane = new BorderPane();
			TextField text = new TextField();
			Button btnAdd = new Button(translate("misc.add"));
			Runnable action = () -> {
				String pack = text.getText();
				if(pack == null || pack.isEmpty())
					return;
				list.getItems().add(pack);
				text.setText("");
				update(list.getItems());
			};
			text.setOnAction(ee -> action.run());
			btnAdd.setOnAction(ee -> action.run());
			addPane.setCenter(text);
			addPane.setRight(btnAdd);
			rootPane.setCenter(list);
			rootPane.setBottom(addPane);
			// Setup popup stage
			Stage dialog = wm.window(translate("ui.search.skippackages"), rootPane);
			dialog.initOwner(wm.getConfigWindow());
			dialog.show();
			// Close on focus lost
			dialog.focusedProperty().addListener((n, o, focused) -> {
				if(!focused)
					dialog.close();
			});
		});
	}

	private void update(Collection<String> items) {
		selected = new ArrayList<>(items);
		int size = selected.size();
		if(size == 0) {
			setText(translate("ui.search.skippackages.empty"));
			setGraphic(null);
		} else if(size == 1) {
			setText(selected.get(0));
			setGraphic(new IconView("icons/folder-package.png"));
		} else {
			setText(size + " packages");
			setGraphic(new IconView("icons/folder-package.png"));
		}
	}

	/**
	 * @return Selected packages.
	 */
	public List<String> get() {
		return selected;
	}

	/**
	 * @param values
	 * 		Selected packages to set.
	 */
	public void set(List<String> values) {
		update(values);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/RenamingTextField.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.application.Platform;
import javafx.scene.control.Tab;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.stage.PopupWindow;
import javafx.stage.Stage;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.mapping.Mappings;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.workspace.Workspace;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * A popup textfield for renaming classes and members.
 *
 * @author Matt
 */
public class RenamingTextField extends PopupWindow {
	private final GuiController controller;
	private final TextField text;
	private Supplier<Map<String, String>> mapSupplier;
	private Consumer<Map<String, String>> onRename;

	private RenamingTextField(GuiController controller, String initialText, Consumer<RenamingTextField> renameAction) {
		this.controller = controller;
		setHideOnEscape(true);
		setAutoHide(true);
		setOnShown(e -> {
			// Disable root so key events do not get passed to the window that owns the rename popup.
			controller.windows().getMainWindow().getRoot().setDisable(true);
			// Center on main window
			Stage main = controller.windows().getMainWindow().getStage();
			int x = (int) (main.getX() + Math.round((main.getWidth() / 2) - (getWidth() / 2)));
			int y = (int) (main.getY() + Math.round((main.getHeight() / 2) - (getHeight() / 2)));
			setX(x);
			setY(y);
		});
		setOnHiding(e -> {
			// Re-enable root after completion/cancellation
			controller.windows().getMainWindow().getRoot().setDisable(false);
		});
		text = new TextField(initialText);
		text.getStyleClass().add("remap-field");
		text.setPrefWidth(400);
		// Close on hitting escape/close-window bind
		text.setOnKeyPressed(e -> {
			if (controller.config().keys().closeWindow.match(e) || e.getCode() == KeyCode.ESCAPE)
				hide();
		});
		// Set on-enter action
		text.setOnAction(e -> renameAction.accept(this));
		// Setup & show
		getScene().setRoot(text);
		Platform.runLater(() -> {
			text.requestFocus();
			text.selectAll();
		});
	}

	/**
	 * @return Value of text-field.
	 */
	public String getText() {
		return text.getText();
	}

	/**
	 * @param mapSupplier
	 * 		Mapping generator.
	 */
	public void setMapSupplier(Supplier<Map<String, String>> mapSupplier) {
		this.mapSupplier = mapSupplier;
	}

	/**
	 * @param onRename
	 * 		Action to run on the mappings.
	 */
	public void setOnRename(Consumer<Map<String, String>> onRename) {
		this.onRename = onRename;
	}

	/**
	 * Create a renaming field for classes.
	 *
	 * @param controller
	 * 		Controller to act on.
	 * @param name
	 * 		Class name.
	 *
	 * @return Renaming field popup.
	 */
	public static RenamingTextField forClass(GuiController controller, String name) {
		RenamingTextField popup = new RenamingTextField(controller, name, RenamingTextField::defaultAction);
		// Set map supplier for class renaming
		popup.setMapSupplier(() -> {
			String renamed = popup.getText();
			Map<String, String> map = new HashMap<>();
			map.put(name, renamed);
			// Map inners as well
			String prefix = name + "$";
			controller.getWorkspace().getPrimaryClassNames().stream()
					.filter(n -> n.startsWith(prefix))
					.forEach(n -> map.put(n, renamed + n.substring(name.length())));
			return map;
		});
		// Close class tabs with old names & open the new ones
		popup.setOnRename((renamed) -> renamed.forEach((oldName, newName) -> {
			// Get old tab index
			Tab tab = controller.windows().getMainWindow().getTabs().getTab(oldName);
			if (tab == null)
				return;
			int oldIndex = controller.windows().getMainWindow().getTabs().getTabs().indexOf(tab);
			if (oldIndex == -1)
				return;
			// Close old tab
			controller.windows().getMainWindow().getTabs().closeTab(oldName);
			// Open new tab and move to old index
			controller.windows().getMainWindow().openClass(controller.getWorkspace().getPrimary(), newName);
			tab = controller.windows().getMainWindow().getTabs().getTab(newName);
			controller.windows().getMainWindow().getTabs().getTabs().remove(tab);
			controller.windows().getMainWindow().getTabs().getTabs().add(oldIndex, tab);
			controller.windows().getMainWindow().getTabs().select(tab);
		}));
		return popup;
	}

	/**
	 * Create a renaming field for packages.
	 *
	 * @param controller
	 * 		Controller to act on.
	 * @param name
	 * 		Package name.
	 *
	 * @return Renaming field popup.
	 */
	public static RenamingTextField forPackage(GuiController controller, String name) {
		RenamingTextField popup = new RenamingTextField(controller, name, RenamingTextField::defaultAction);
		// Set map supplier for package renaming
		popup.setMapSupplier(() -> {
			String renamed = popup.getText();
			Map<String, String> map = new HashMap<>();
			// Map all classes in the package
			String prefix = name + "/";
			controller.getWorkspace().getPrimaryClassNames().stream()
					.filter(n -> n.startsWith(prefix))
					.forEach(n -> map.put(n, renamed + "/" + n.substring(name.length() + 1)));
			return map;
		});
		// Close class tabs with old names & open the new ones
		popup.setOnRename((renamed) -> renamed.forEach((oldName, newName) -> {
			// Get old tab index
			Tab tab = controller.windows().getMainWindow().getTabs().getTab(oldName);
			if (tab == null)
				return;
			int oldIndex = controller.windows().getMainWindow().getTabs().getTabs().indexOf(tab);
			if (oldIndex == -1)
				return;
			// Close old tab
			controller.windows().getMainWindow().getTabs().closeTab(oldName);
			// Open new tab and move to old index
			controller.windows().getMainWindow().openClass(controller.getWorkspace().getPrimary(), newName);
			tab = controller.windows().getMainWindow().getTabs().getTab(newName);
			controller.windows().getMainWindow().getTabs().getTabs().remove(tab);
			controller.windows().getMainWindow().getTabs().getTabs().add(oldIndex, tab);
			controller.windows().getMainWindow().getTabs().select(tab);
		}));
		return popup;
	}

	/**
	 * Create a renaming field for members.
	 *
	 * @param controller
	 * 		Controller to act on.
	 * @param owner
	 * 		Member's defining class name.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 *
	 * @return Renaming field popup.
	 */
	public static RenamingTextField forMember(GuiController controller, String owner, String name, String desc) {
		RenamingTextField popup = new RenamingTextField(controller, name, RenamingTextField::defaultAction);
		// Set map supplier for member renaming
		popup.setMapSupplier(() -> {
			Map<String, String> map = new HashMap<>();
			boolean isMethod = desc.contains("(");
			if(isMethod) {
				// Method references should be renamed for the entier hierarchy
				controller.getWorkspace().getHierarchyGraph().getHierarchyNames(owner)
						.forEach(hierarchyMember -> map.put(hierarchyMember + "." + name + desc, popup.getText()));
			} else {
				// Field references may not be based on the direct class they are declared in.
				// A child class may refer to a parent class member, using the child class as an owner.
				// However, once a child class introduces a shadowing field name, we want to stop introducing
				// children as owners for this mapping run.
				map.put(owner + "." + name + " " + desc, popup.getText());
				Workspace workspace = controller.getWorkspace();
				workspace.getHierarchyGraph()
						.getAllDescendantsWithBreakCondition(owner,
								n -> ClassUtil.containsField(workspace.getClassReader(n), name, desc))
						.forEach(childOwner -> map.put(childOwner + "." + name, popup.getText()));
			}
			return map;
		});
		// Close class tab with old name & open the new one
		popup.setOnRename(renamed -> {
			// Get old tab index, skipping of the owner class is not currently open
			Tab tab = controller.windows().getMainWindow().getTabs().getTab(owner);
			if (tab == null)
				return;
			int oldIndex = controller.windows().getMainWindow().getTabs().getTabs().indexOf(tab);
			if (oldIndex == -1)
				return;
			// Update display
			ClassViewport viewport =
					controller.windows().getMainWindow().openClass(controller.getWorkspace().getPrimary(), owner);
			viewport.updateView();
		});
		return popup;
	}

	/**
	 * Create a renaming field for files.
	 *
	 * @param controller
	 * 		Controller to act on.
	 * @param name
	 * 		File name.
	 *
	 * @return Renaming field popup.
	 */
	public static RenamingTextField forFile(GuiController controller, String name) {
		RenamingTextField popup = new RenamingTextField(controller, name, RenamingTextField::fileAction);
		// Set map supplier for file renaming
		popup.setMapSupplier(() -> {
			String renamed = popup.getText();
			Map<String, String> map = new HashMap<>();
			map.put(name, renamed);
			return map;
		});
		// Close class tabs with old names & open the new ones
		popup.setOnRename((renamed) -> renamed.forEach((oldName, newName) -> {
			// Get old tab index
			Tab tab = controller.windows().getMainWindow().getTabs().getTab(oldName);
			if (tab == null)
				return;
			int oldIndex = controller.windows().getMainWindow().getTabs().getTabs().indexOf(tab);
			if (oldIndex == -1)
				return;
			// Close old tab
			controller.windows().getMainWindow().getTabs().closeTab(oldName);
			// Open new tab and move to old index
			controller.windows().getMainWindow().openFile(controller.getWorkspace().getPrimary(), newName);
			tab = controller.windows().getMainWindow().getTabs().getTab(newName);
			controller.windows().getMainWindow().getTabs().getTabs().remove(tab);
			controller.windows().getMainWindow().getTabs().getTabs().add(oldIndex, tab);
			controller.windows().getMainWindow().getTabs().select(tab);
		}));
		return popup;
	}

	private static void fileAction(RenamingTextField field) {
		// Apply mappings
		Map<String, String> map = field.mapSupplier.get();
		Map<String, byte[]> files = field.controller.getWorkspace().getPrimary().getFiles();
		map.forEach((oldName, newName) -> {
			byte[] tmp = files.remove(oldName);
			if (tmp != null)
				files.put(newName, tmp);
		});
		// Close popup
		field.hide();
		field.onRename.accept(map);
	}

	private static void defaultAction(RenamingTextField field) {
		// Apply mappings
		Map<String, String> map = field.mapSupplier.get();
		Mappings mappings = new Mappings(field.controller.getWorkspace());
		mappings.setMappings(map);
		mappings.accept(field.controller.getWorkspace().getPrimary());
		// Refresh affected tabs
		ViewportTabs tabs = field.controller.windows().getMainWindow().getTabs();
		for (String updated : field.controller.getWorkspace().getDefinitionUpdatedClasses()) {
			if (tabs.isOpen(updated)) {
				tabs.getClassViewport(updated).updateView();
			}
		}
		// Close popup
		field.hide();
		field.onRename.accept(map);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ResourceComboBox.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.ComboBox;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.workspace.JavaResource;

/**
 * Combo-Box for resources.
 *
 * @author Matt
 */
public class ResourceComboBox extends ComboBox<JavaResource> {
	/**
	 * @param controller
	 * 		Controller with resources.
	 */
	public ResourceComboBox(GuiController controller) {
		getStyleClass().add("resource-selector");
		setCellFactory(e -> new ResourceSelectionCell(controller));
		setMaxWidth(Double.MAX_VALUE);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ResourceSelectionCell.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.*;
import javafx.scene.control.cell.ComboBoxListCell;
import javafx.scene.layout.HBox;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.*;


/**
 * Cell/renderer for displaying {@link JavaResource}s.
 */
public class ResourceSelectionCell extends ComboBoxListCell<JavaResource> {
	private final GuiController controller;

	/**
	 * @param controller
	 * 		Controller to use.
	 */
	public ResourceSelectionCell(GuiController controller) {
		this.controller = controller;
	}

	@Override
	public void updateItem(JavaResource item, boolean empty) {
		super.updateItem(item, empty);
		if(!empty) {
			HBox g = new HBox();
			if(item != null) {
				String t = item.toString();
				// Add icon for resource types
				g.getChildren().add(new IconView(UiUtil.getResourceIcon(item)));
				// Indicate which resource is the primary resource
				if(controller.getWorkspace() != null && item == controller.getWorkspace().getPrimary()) {
					Label lbl = new Label(" [Primary]");
					lbl.getStyleClass().add("bold");
					g.getChildren().add(lbl);
				}
				setText(t);
			}
			setGraphic(g);
		} else {
			setGraphic(null);
			setText(null);
		}
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/SearchBar.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import me.coley.recaf.util.struct.Pair;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Basic search bar.
 *
 * @author Matt
 */
public class SearchBar extends GridPane {
	private final Label lblResults = new Label();
	private final TextField txtSearch = new TextField();
	private final Supplier<String> text;
	// actions
	private Runnable onEscape;
	private Consumer<Results> onSearch;
	// inputs
	private boolean dirty = true;
	private String lastSearchText;
	// last result
	private Results results;

	/**
	 * @param text
	 * 		Supplier of searchable text.
	 */
	public SearchBar(Supplier<String> text) {
		setAlignment(Pos.CENTER_LEFT);
		setHgap(7);
		ColumnConstraints column1 = new ColumnConstraints();
		column1.setPercentWidth(75);
		ColumnConstraints column2 = new ColumnConstraints();
		column2.setPercentWidth(25);
		getColumnConstraints().addAll(column1, column2);
		// TODO: Better search field:
		//  - Options
		//     - regex
		this.text = text;
		getStyleClass().add("context-menu");
		txtSearch.getStyleClass().add("search-field");
		txtSearch.setOnKeyPressed(e -> {
			// Check if we've updated the search query
			String searchText = e.getText();
			if(!searchText.equals(lastSearchText)) {
				dirty = true;
			}
			lastSearchText = searchText;
			// Handle operations
			if(e.getCode().getName().equals(KeyCode.ESCAPE.getName())) {
				// Escape the search bar
				if(onEscape != null)
					onEscape.run();
			} else if(e.getCode().getName().equals(KeyCode.ENTER.getName())) {
				// Empty check
				if (txtSearch.getText().isEmpty()) {
					results = null;
					return;
				}
				// Find next
				//  - Run search if necessary
				if(dirty) {
					results = search();
					dirty = false;
				}
				if(onSearch != null && results != null)
					onSearch.accept(results);
			}
		});
		add(txtSearch, 0, 0);
		add(lblResults, 1, 0);
	}

	/**
	 * @param onSearch
	 * 		Search result handler to run.
	 */
	public void setOnSearch(Consumer<Results> onSearch) {
		this.onSearch = onSearch;
	}

	/**
	 * @param onEscape
	 * 		Escape handler to run.
	 */
	public void setOnEscape(Runnable onEscape) {
		this.onEscape = onEscape;
	}

	/**
	 * Focus the search bar input text-field.
	 */
	public void focus() {
		txtSearch.requestFocus();
		txtSearch.selectAll();
	}

	/**
	 * Clear the search bar display.
	 */
	public void clear() {
		txtSearch.clear();
		lblResults.setText("");
	}

	/**
	 * @param text
	 * 		Text to set.
	 */
	public void setText(String text) {
		txtSearch.setText(text);
	}

	/**
	 * @return Search result ranges of the current search parameters.
	 */
	private Results search() {
		Results results = new Results();
		String searchText = txtSearch.getText();
		String targetText = text.get();
		int len = searchText.length();
		int index = targetText.indexOf(searchText);
		while(index >= 0) {
			// Add result
			results.add(index, index + len);
			// Find next
			index = targetText.indexOf(searchText, index + len);
		}
		return results;
	}

	/**
	 * Search results wrapper.
	 *
	 * @author Matt
	 */
	public class Results {
		private final List<Pair<Integer, Integer>> ranges = new ArrayList<>();

		private void add(int start, int end) {
			ranges.add(new Pair<>(start, end));
		}

		/**
		 * @param caret
		 * 		Caret position in text.
		 *
		 * @return Next range immediately after the caret position.
		 */
		public Pair<Integer, Integer> next(int caret) {
			// Check for no matches
			if(ranges.isEmpty()) {
				lblResults.setText(translate("ui.search.results.none"));
				return null;
			}
			// Find first result where the caret is before the result range
			Pair<Integer, Integer> match = null;
			int i = 1;
			for(Pair<Integer, Integer> range : ranges) {
				if(caret < range.getKey()) {
					match = range;
					break;
				}
				i++;
			}
			// No match after caret position, wrap around
			if(match == null) {
				i = 1;
				match = ranges.get(0);
			}
			lblResults.setText(translate("ui.search.results.indexpre") + i + "/" + ranges.size());
			return match;
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/SplitableTabPane.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.SnapshotParameters;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.image.WritableImage;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DataFormat;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.scene.transform.Transform;
import javafx.stage.Stage;

import java.awt.*;

/**
 * Simplistic drag-and-drop support for tabs so that they can be split into multiple windows.
 *
 * @author Matt
 */
public class SplitableTabPane extends TabPane {
	private static final SnapshotParameters SNAPSHOT_PARAMETERS;
	private static final String DROP_TARGET_STYLE = "drag-target";
	private static final String TAB_DRAG_KEY = "split-tab";
	private static final ObjectProperty<Tab> draggedTab = new SimpleObjectProperty<>();

	/**
	 * Creates the splittable tab pane.
	 */
	public SplitableTabPane() {
		TabPane selfPane = this;
		// Allow this pane to accept transfers
		setOnDragOver(dragEvent -> {
			Dragboard dragboard = dragEvent.getDragboard();
			if (dragboard.hasString()
					&& TAB_DRAG_KEY.equals(dragboard.getString())
					&& draggedTab.get() != null
					&& draggedTab.get().getTabPane() != selfPane) {
				dragEvent.acceptTransferModes(TransferMode.MOVE);
				dragEvent.consume();
			}
		});
		// Setup start drag
		setOnDragDetected(mouseEvent -> {
			if (mouseEvent.getSource() instanceof TabPane) {
				Pane rootPane = (Pane) getScene().getRoot();
				rootPane.setOnDragOver(dragEvent -> {
					dragEvent.acceptTransferModes(TransferMode.MOVE);
					dragEvent.consume();
				});
				draggedTab.setValue(getSelectionModel().getSelectedItem());
				WritableImage snapshot = draggedTab.get().getContent().snapshot(SNAPSHOT_PARAMETERS, null);
				ClipboardContent clipboardContent = new ClipboardContent();
				clipboardContent.put(DataFormat.PLAIN_TEXT, TAB_DRAG_KEY);
				Dragboard db = startDragAndDrop(TransferMode.MOVE);
				db.setDragView(snapshot, 40, 40);
				db.setContent(clipboardContent);
			}
			mouseEvent.consume();
		});
		// Setup end dragging in the case where there is no tab-pane target
		setOnDragDone(dragEvent -> {
			Tab dragged = draggedTab.get();
			if (!dragEvent.isDropCompleted() && dragged != null) {
				createTabStage(dragged).show();
				setCursor(Cursor.DEFAULT);
				dragEvent.consume();
				removeStyle();
			}
		});
		// Setup end dragging in the case where this is the tab-pane target
		setOnDragDropped(dragEvent -> {
			Dragboard dragboard = dragEvent.getDragboard();
			Tab dragged = draggedTab.get();
			if (dragboard.hasString()
					&& TAB_DRAG_KEY.equals(dragboard.getString())
					&& dragged != null) {
				if (dragged.getTabPane() != selfPane) {
					SplitableTabPane owner = (SplitableTabPane) dragged.getTabPane();
					owner.closeTab(dragged);
					getTabs().add(dragged);
					getSelectionModel().select(dragged);
				}
				dragEvent.setDropCompleted(true);
				draggedTab.set(null);
				dragEvent.consume();
				removeStyle();
			}
		});
		// Highlighting with style classes
		setOnDragEntered(dragEvent -> {
			Dragboard dragboard = dragEvent.getDragboard();
			if (dragboard.hasString()
					&& TAB_DRAG_KEY.equals(dragboard.getString())
					&& draggedTab.get() != null
					&& draggedTab.get().getTabPane() != selfPane) {
				addStyle();
			}
		});
		setOnDragExited(dragEvent -> {
			Dragboard dragboard = dragEvent.getDragboard();
			if (dragboard.hasString()
					&& TAB_DRAG_KEY.equals(dragboard.getString())
					&& draggedTab.get() != null
					&& draggedTab.get().getTabPane() != selfPane) {
				removeStyle();
			}
		});
	}

	/**
	 * @param tab
	 * 		Tab to remove.
	 */
	public void closeTab(Tab tab) {
		getTabs().remove(tab);
	}

	/**
	 * Create a new tab with the given title and content.
	 *
	 * @param title
	 * 		Tab title.
	 * @param content
	 * 		Tab content.
	 *
	 * @return New tab.
	 */
	protected Tab createTab(String title, Node content) {
		Tab tab = new Tab(title, content);
		tab.setClosable(true);
		return tab;
	}

	/**
	 * Create a new stage for the given tab when it is dropped outside of the scope of a {@link SplitableTabPane}
	 *
	 * @param tab
	 * 		Tab to wrap in a new stage.
	 *
	 * @return New stage.
	 */
	protected Stage createTabStage(Tab tab) {
		// Validate content
		Pane content = (Pane) tab.getContent();
		if (content == null)
			throw new IllegalArgumentException("Cannot detach '" + tab.getText() + "' because content is null");
		// Remove content from tab
		closeTab(tab);
		// Create stage
		SplitableTabPane tabPaneCopy = newTabPane();
		tabPaneCopy.getTabs().add(tab);
		BorderPane root = new BorderPane(tabPaneCopy);
		Scene scene = new Scene(root, root.getPrefWidth(), root.getPrefHeight());
		Stage stage = createStage(tab.getText(), scene);
		// Set location to mouse
		Point mouseLocation = MouseInfo.getPointerInfo().getLocation();
		stage.setX(mouseLocation.getX());
		stage.setY(mouseLocation.getY());
		return stage;
	}

	/**
	 * Create a basic stage with the given title and scene.
	 *
	 * @param title
	 * 		Title for stage.
	 * @param scene
	 * 		Stage content.
	 *
	 * @return New stage.
	 */
	protected Stage createStage(String title, Scene scene) {
		Stage stage = new Stage();
		stage.setScene(scene);
		stage.setTitle(title);
		return stage;
	}

	/**
	 * @return New instance of {@link SplitableTabPane} to be used in a newly created {@link Stage}.
	 */
	protected SplitableTabPane newTabPane() {
		return new SplitableTabPane();
	}

	private void addStyle() {
		getStyleClass().add(DROP_TARGET_STYLE);
	}

	private void removeStyle() {
		getStyleClass().remove(DROP_TARGET_STYLE);
	}

	static {
		SNAPSHOT_PARAMETERS = new SnapshotParameters();
		SNAPSHOT_PARAMETERS.setTransform(Transform.scale(0.4, 0.4));
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/StyleCombo.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.ComboBox;
import javafx.util.StringConverter;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.Themes;
import me.coley.recaf.util.Resource;

import static me.coley.recaf.util.Log.error;

/**
 * Style combobox.
 *
 * @author Matt
 */
public class StyleCombo extends ComboBox<Resource> {
	/**
	 * @param controller
	 * 		Controller context to update styles of.
	 * @param wrapper
	 * 		wrapper for the style config field.
	 */
	public StyleCombo(GuiController controller, FieldWrapper wrapper) {
		// Extract: style/ui-{name}.css
		setConverter(new StringConverter<Resource>() {
			@Override
			public String toString(Resource r) {
				String p = r.getPath();
				p = p.substring(p.lastIndexOf('/') + 1);
				return p.substring(3, p.length() - 4);
			}

			@Override
			public Resource fromString(String text) { return null; }
		});
		try {
			Resource value = wrapper.get();
			getItems().addAll(Themes.getStyles());
			getSelectionModel().select(value);
			getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
				wrapper.set(n);
				controller.windows().reapplyStyles();
			});
			setMaxWidth(Double.MAX_VALUE);
		} catch(Exception ex) {
			error(ex, "Failed creating style selector");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/SubLabeled.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.Label;
import javafx.scene.layout.VBox;

/**
 * Label with sub-label.
 *
 * @author Matt
 */
public class SubLabeled extends VBox {
	private final String primary;
	private final String secondary;

	/**
	 * @param primary
	 * 		Main text, more prominent.
	 * @param secondary
	 * 		Secondary text, less prominent.
	 */
	public SubLabeled(String primary, String secondary) {
		this(primary, secondary, "h2");
	}

	/**
	 * @param primary
	 * 		Main text, more prominent.
	 * @param secondary
	 * 		Secondary text, less prominent.
	 * @param primaryClass
	 * 		Header style class.
	 */
	public SubLabeled(String primary, String secondary, String primaryClass) {
		this.primary = primary;
		this.secondary = secondary;
		Label lblPrimary = new Label(primary);
		Label lblSecondary = new Label(secondary);
		lblPrimary.getStyleClass().add(primaryClass);
		lblSecondary.getStyleClass().add("faint");
		getChildren().addAll(lblPrimary, lblSecondary);
	}

	/**
	 * @return Primary label text.
	 */
	public String getPrimaryText() {
		return primary;
	}

	/**
	 * @return Secondary label text.
	 */
	public String getSecondaryText() {
		return secondary;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/TableViewExtra.java`:

```java
package me.coley.recaf.ui.controls;

import java.util.LinkedHashSet;

import javafx.scene.control.TableRow;
import javafx.scene.control.TableView;
import javafx.util.Callback;

/**
 * Extra calls for TableView which would have been nice to see in JavaFx TableView
 *
 * @param <T>
 * 		Table content type.
 *
 * @author <a href="https://stackoverflow.com/users/4712734/duncg">DuncG</a>
 */
public class TableViewExtra<T> {
	private final LinkedHashSet<TableRow<T>> rows = new LinkedHashSet<>();
	private final TableView<T> table;
	private int firstIndex;

	/**
	 * @param tableView
	 * 		Table to wrap.
	 */
	public TableViewExtra(TableView<T> tableView) {
		this.table = tableView;
		// Callback to monitor row creation and to identify visible screen rows
		final Callback<TableView<T>, TableRow<T>> rf = tableView.getRowFactory();
		final Callback<TableView<T>, TableRow<T>> modifiedRowFactory = param -> {
			TableRow<T> r = rf != null ? rf.call(param) : new TableRow<>();
			// Save row, this implementation relies on JaxaFX re-using TableRow efficiently
			rows.add(r);
			return r;
		};
		tableView.setRowFactory(modifiedRowFactory);
	}

	private void recomputeVisibleIndexes() {
		firstIndex = -1;
		// Work out which of the rows are visible
		double tblViewHeight = table.getHeight();
		double headerHeight =
                table.lookup(".column-header-background").getBoundsInLocal().getHeight();
		double viewPortHeight = tblViewHeight - headerHeight;
		for(TableRow<T> r : rows) {
			if(!r.isVisible())
				continue;
			double minY = r.getBoundsInParent().getMinY();
			double maxY = r.getBoundsInParent().getMaxY();
			boolean hidden = (maxY < 0) || (minY > viewPortHeight);
			if(hidden)
				continue;
			if(firstIndex < 0 || r.getIndex() < firstIndex)
				firstIndex = r.getIndex();
		}
	}

	/**
	 * Find the first row in the table which is visible on the display
	 *
	 * @return {@code -1} if none visible or the index of the first visible row (wholly or fully)
	 */
	public int getFirstVisibleIndex() {
		recomputeVisibleIndexes();
		return firstIndex;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/ThemeCombo.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.ComboBox;
import javafx.util.StringConverter;
import me.coley.recaf.config.FieldWrapper;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.Themes;
import me.coley.recaf.util.Resource;

import static me.coley.recaf.util.Log.error;

/**
 * Text theme combobox.
 *
 * @author Matt
 */
public class ThemeCombo extends ComboBox<Resource> {
	/**
	 * @param controller
	 * 		Controller context to update text theme of.
	 * @param wrapper
	 * 		wrapper for the style config field.
	 */
	public ThemeCombo(GuiController controller, FieldWrapper wrapper) {
		// Extract: style/text-{name}.css
		setConverter(new StringConverter<Resource>() {
			@Override
			public String toString(Resource r) {
				String p = r.getPath();
				p = p.substring(p.lastIndexOf('/') + 1);
				return p.substring(5, p.length() - 4);
			}

			@Override
			public Resource fromString(String text) { return null; }
		});
		try {
			Resource value = wrapper.get();
			getItems().addAll(Themes.getTextThemes());
			getSelectionModel().select(value);
			getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
				wrapper.set(n);
				controller.windows().reapplyStyles();
			});
			setMaxWidth(Double.MAX_VALUE);
		} catch(Exception ex) {
			error(ex, "Failed creating theme selector");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/TimestampLabel.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.Label;
import me.coley.recaf.config.FieldWrapper;

import java.time.Instant;

/**
 * Label for displaying times.
 *
 * @author Matt
 */
public class TimestampLabel extends Label {
	/**
	 * @param field
	 * 		Time field, assumed to be a long.
	 */
	public TimestampLabel(FieldWrapper field) {
		super(getTimeString(field.get()));
	}

	private static <T extends Number> String getTimeString(T time) {
		return Instant.ofEpochMilli(time.longValue()).toString();
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/Toggle.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.scene.control.CheckBox;
import me.coley.recaf.config.FieldWrapper;

/**
 * Checkbox for updating booleans.
 *
 * @author Matt
 */
public class Toggle extends CheckBox {
	/**
	 * @param field
	 * 		Target field of the boolean to modify.
	 */
	public Toggle(FieldWrapper field) {
		super("");
		setSelected(field.get());
		// Update field when box is ticked
		selectedProperty().addListener((v, old, current) -> {
			field.set(current);
		});
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/ViewportTabs.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.image.Image;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.ContextBuilder;
import me.coley.recaf.ui.controls.view.*;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.JavaResource;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import static me.coley.recaf.util.ClasspathUtil.resource;

/* TODO:
 *  - Fix tab dropdown menu icons not being sized despite using fit-width/height properties
 *    - Wrapping them in a BorderPane should scale them... but instead they vanish.
 *    - Why do the icons not show up? No clue. But its better than varied icon sizes.
 *  - Tab updating/reloading
 *    - If we split one tab to a new window, update a file, but have an alternate view open
 *      the two items become out of sync. I'm thinking we should have a stronger event-based
 *      system that can fire off changes to handle this. Plus it will be extensible and allow
 *      some decoupling later on.
 */

/**
 * TabPane to hold a tab for each {@link EditorViewport}
 *
 * @author Matt
 */
public class ViewportTabs extends SplitableTabPane {
	private final GuiController controller;
	private final Map<String, Tab> nameToTab = new HashMap<>();

	/**
	 * @param controller
	 * 		Gui controller.
	 */
	public ViewportTabs(GuiController controller) {
		this.controller = controller;
		setTabClosingPolicy(TabPane.TabClosingPolicy.ALL_TABS);
		// Keybind for closing current tab
		setOnKeyPressed(e -> {
			if(controller.config().keys().closeTab.match(e)) {
				Tab current = getSelectionModel().getSelectedItem();
				if(current != null)
					closeTab(current);
				Tab newCurrent = getSelectionModel().getSelectedItem();
				if(newCurrent != null)
					newCurrent.getContent().requestFocus();
			}
		});
	}

	/**
	 * @param resource
	 * 		Resource containing the class.
	 * @param name
	 * 		Name of class to open.
	 *
	 * @return Viewport of the class.
	 */
	public ClassViewport openClass(JavaResource resource, String name) {
		if(nameToTab.containsKey(name))
			return getClassViewport(name);
		// Create new tab
		ClassViewport view = new ClassViewport(controller, resource, name);
		view.updateView();
		Tab tab = createTab(name, view);
		int access = ClassUtil.getAccess(resource.getClasses().get(name));
		tab.setGraphic(UiUtil.createClassGraphic(access));
		// Setup context menu
		tab.setContextMenu(ContextBuilder.menu().view(view).ofClassTab(name));
		// Select & return
		select(tab);
		return view;
	}

	/**
	 * @param name
	 * 		Name of class to check.
	 *
	 * @return Viewport of the class.
	 */
	public ClassViewport getClassViewport(String name) {
		if(nameToTab.containsKey(name)) {
			// Select the tab
			Tab tab = nameToTab.get(name);
			select(tab);
			return (ClassViewport) tab.getContent();
		}
		return null;
	}

	/**
	 * @param resource
	 * 		Resource containing the resource.
	 * @param name
	 * 		Name of resource to open.
	 *
	 * @return Viewport of the file.
	 */
	public FileViewport openFile(JavaResource resource, String name) {
		if(nameToTab.containsKey(name)) {
			return getFileViewport(name);
		}
		// Create new tab
		FileViewport view = new FileViewport(controller, resource, name);
		view.updateView();
		Tab tab = createTab(name, view);
		BorderPane wrap = new BorderPane(UiUtil.createFileGraphic(name));
		UiUtil.createFileGraphic(name).fitWidthProperty().bind(wrap.widthProperty());
		tab.setGraphic(wrap);
		// Setup context menu
		tab.setContextMenu(ContextBuilder.menu().view(view).ofFileTab(name));
		// Select and return
		select(tab);
		return view;
	}

	/**
	 * @param name
	 * 		Name of file to check.
	 *
	 * @return Viewport of the file.
	 */
	public FileViewport getFileViewport(String name) {
		if(nameToTab.containsKey(name)) {
			// Select the tab
			Tab tab = nameToTab.get(name);
			select(tab);
			return (FileViewport) tab.getContent();
		}
		return null;
	}

	/**
	 * Clears viewports
	 */
	public void clearViewports() {
		new HashSet<>(nameToTab.values()).forEach(this::closeTab);
	}

	/**
	 * Closes a tab by the given name.
	 *
	 * @param name
	 * 		Name of item open in the target tab.
	 */
	public void closeTab(String name) {
		Tab tab = nameToTab.get(name);
		if(tab != null)
			closeTab(tab);
	}

	@Override
	public void closeTab(Tab tab) {
		// Call close handler
		EventHandler<Event> handler = tab.getOnClosed();
		if(handler != null)
			handler.handle(null);
		// Actually close tab
		getTabs().remove(tab);
	}

	/**
	 * @param name
	 * 		The tab name to keep.
	 */
	public void closeAllExcept(String name) {
		new HashMap<>(nameToTab).forEach((tabName, tab) -> {
			if (!tabName.equals(name))
				closeTab(tab);
		});
	}

	/**
	 * @param key
	 * 		Tab name.
	 *
	 * @return {@code true} if a tab by the name is open, otherwise {@code false}.
	 */
	public boolean isOpen(String key) {
		return nameToTab.containsKey(key);
	}

	private Tab createTab(String name, EditorViewport view) {
		// Normalize name
		String title = name;
		if(title.contains("/"))
			title = title.substring(title.lastIndexOf("/") + 1);
		Tab tab = super.createTab(title, view);
		// Name lookup
		tab.setOnClosed(o -> nameToTab.remove(name));
		nameToTab.put(name, tab);
		// Add and return
		getTabs().add(tab);
		return tab;
	}

	/**
	 * @param name
	 * 		Tab name.
	 *
	 * @return Instance matching name.
	 */
	public Tab getTab(String name) {
		return nameToTab.get(name);
	}

	/**
	 * Select the given tab.
	 *
	 * @param tab
	 * 		Tab to select.
	 */
	public void select(Tab tab) {
		getSelectionModel().select(tab);
		tab.getContent().requestFocus();
	}

	@Override
	protected Stage createStage(String title, Scene scene) {
		// Create and update the stage
		Stage stage = super.createStage("Split view", scene);
		stage.getIcons().add(new Image(resource("icons/logo.png")));
		controller.windows().reapplyStyle(scene);
		return stage;
	}

	@Override
	protected SplitableTabPane newTabPane() {
		return new ViewportTabs(controller);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/WorkspaceNavigator.java`:

```java
package me.coley.recaf.ui.controls;

import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.input.DragEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.BorderPane;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.tree.*;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.workspace.*;

import java.io.File;
import java.util.*;

// TODO: Account for user adds/removes a library to workspace

/**
 * Navigator for a workspace.
 *
 * @author Matt
 */
public class WorkspaceNavigator extends BorderPane {
	private final GuiController controller;
	private final Map<JavaResource, JavaResourceTree> resourceToTree = new HashMap<>();
	private final BorderPane placeholder = new BorderPane();
	private final Label lblPlaceholder = new Label();
	private ResourceComboBox comboResources;

	/**
	 * @param controller
	 * 		Controller.
	 */
	public WorkspaceNavigator(GuiController controller) {
		this.controller = controller;
		// Style as a tree so it takes on the style of what should be there.
		placeholder.getStyleClass().add("tree-view");
		placeholder.setCenter(lblPlaceholder);
		// Create content for workspace
		refresh();
		// Events
		setOnDragOver(this::onDragOver);
		setOnDragDropped(this::onDragDrop);
	}

	/**
	 * Refresh the navigator's content.
	 */
	public void refresh() {
		// Setup trees for each resource
		List<JavaResource> resources = resources();
		if (resources.size() > 1) {
			boolean firstTime = false;
			// Resource switcher
			if (comboResources == null) {
				firstTime = true;
				comboResources = new ResourceComboBox(controller);
				comboResources.getSelectionModel().selectedItemProperty().addListener((v, o, n) -> setCurrent(n));
				BorderPane.setAlignment(comboResources, Pos.CENTER);
				setTop(comboResources);
			}
			// Reset content
			comboResources.getItems().setAll(resources);
			// Select first item if nothing is selected already
			if (firstTime)
				comboResources.getSelectionModel().select(0);
		} else if (controller.getWorkspace() != null) {
			// Only one resource to show
			setCurrent(controller.getWorkspace().getPrimary());
		} else {
			// Set placeholder
			enablePlaceholder();
			clear(LangUtil.translate("ui.looaddrop.prompt"));
		}
	}

	private void setCurrent(JavaResource resource) {
		if (resource != null)
			setCenter(resourceToTree.computeIfAbsent(resource, (k) -> new JavaResourceTree(controller, k)));
	}

	private List<JavaResource> resources() {
		Workspace workspace= controller.getWorkspace();
		if (workspace == null)
			return Collections.emptyList();
		List<JavaResource> list = new ArrayList<>();
		list.add(controller.getWorkspace().getPrimary());
		controller.getWorkspace().getLibraries().stream()
					.filter(res -> !(res instanceof EmptyResource))
					.forEach(list::add);
		return list;
	}

	private void onDragOver(DragEvent e) {
		// Allow drag-drop content
		if (e.getGestureSource() != this && e.getDragboard().hasFiles())
			e.acceptTransferModes(TransferMode.COPY_OR_MOVE);
		e.consume();
	}

	private void onDragDrop(DragEvent e) {
		// Load drag-drop files
		if(e.getDragboard().hasFiles()) {
			File file = e.getDragboard().getFiles().get(0);
			controller.loadWorkspace(IOUtil.toPath(file), null);
		}
	}

	/**
	 * Set the center node to the placeholder.
	 */
	public void enablePlaceholder() {
		setCenter(placeholder);
	}

	/**
	 * Clear display / set placeholder value for center node.
	 *
	 * @param placeholderText
	 * 		Placeholder text to set for center node.
	 */
	public void clear(String placeholderText) {
		lblPlaceholder.setText(placeholderText);
	}



}

```

`src/main/java/me/coley/recaf/ui/controls/node/ClassNodeEditorPane.java`:

```java
package me.coley.recaf.ui.controls.node;

import javafx.application.Platform;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.*;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.bytecode.parser.ModifierParser;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ClassVisitorPlugin;
import me.coley.recaf.ui.controls.*;
import me.coley.recaf.ui.controls.pane.ColumnPane;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.util.AccessFlag;
import me.coley.recaf.util.UiUtil;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static me.coley.recaf.util.LangUtil.translate;
import static me.coley.recaf.ui.ContextBuilder.menu;
import static me.coley.recaf.util.ClassUtil.VERSION_OFFSET;

/**
 * Editor for {@link ClassNode}.
 *
 * @author Matt
 */
public class ClassNodeEditorPane extends TabPane implements ClassEditor {
	private final GuiController controller;
	private final TableView<FieldNode> fields = new TableView<>();
	private final TableView<MethodNode> methods = new TableView<>();
	private final ColumnPane classInfoTable = new ColumnPane(new Insets(5, 10, 5, 10), 38, 62, 5);
	private final Map<Supplier<Boolean>, Node> classInfoEditors = new HashMap<>();
	private ClassNode node;
	private Tab tabClass;
	private Tab tabFields;
	private Tab tabMethods;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param node
	 * 		Node instance to work off of.
	 */
	public ClassNodeEditorPane(GuiController controller, ClassNode node) {
		this.controller = controller;
		this.node = node;
		setup();
	}

	/**
	 * Setup tables.
	 */
	public void setup() {
		setupClass();
		setupFields();
		setupMethods();
	}

	/**
	 * Refresh tables.
	 *
	 * @param node
	 * 		Updated node.
	 */
	public void refresh(ClassNode node) {
		this.node = node;
		ObservableList<FieldNode> src = FXCollections.observableArrayList(this.node.fields);
		ObservableList<MethodNode> src2 = FXCollections.observableArrayList(this.node.methods);
		Platform.runLater(() -> {
			fields.setItems(src);
			methods.setItems(src2);
		});
	}

	private void setupClass() {
		// TODO: Support the following
		//  - Module
		//  - nestHostClass / nestMembers
		//  - Permitted subclasses
		//  - Record component nodes
		//  - Annotations
		//  - Inner classes
		getTabs().add(tabClass = new Tab(translate("ui.edit.tab.classinfo"), classInfoTable));
		TextField txtName = new ActionTextField(controller, node.name, n -> {
			if (n.isEmpty())
				return false;
			// TODO: Should there be an option to remap this instead of just overriding?
			// TODO: This will have to re-open the editor with the correct updated path
			node.name = n;
			return true;
		});
		TextField txtSignature = new ActionTextField(controller, node.signature, n -> {
			if (n.isEmpty())
				node.signature = null;
			else
				node.signature = n;
			return true;
		});
		TextField txtSuper = new ActionTextField(controller, node.superName, n -> {
			if (n.isEmpty())
				node.superName = null;
			else
				node.superName = n;
			return true;
		});
		TextArea txtInterfaces = new ActionTextArea(controller, String.join("\n", node.interfaces), n -> {
			if (n.isEmpty())
				node.interfaces = Collections.emptyList();
			else
				node.interfaces = Arrays.asList(n.split("\\s+"));
			return true;
		});
		TextField txtSource = new ActionTextField(controller, node.sourceFile, n -> {
			if (n.isEmpty())
				node.sourceFile = null;
			else
				node.sourceFile = n;
			return true;
		});
		TextField txtSourceDebug = new ActionTextField(controller, node.sourceDebug, n -> {
			if (n.isEmpty())
				node.sourceDebug = null;
			else
				node.sourceDebug = n;
			return true;
		});
		TextField txtVersion = new ActionTextField(controller, String.valueOf(node.version - VERSION_OFFSET), n -> {
			try {
				int v = Integer.parseInt(n) + VERSION_OFFSET;
				if (v > Opcodes.V16 || v < 45)
					return false;
				node.version = v;
				return true;
			} catch (NumberFormatException ignored) {
				return false;
			}
		});
		TextField txtAccess = new ActionTextField(controller,
				Arrays.stream(AccessFlag.values())
						.filter(f -> f.getTypes().contains(AccessFlag.Type.CLASS))
						.filter(f -> (node.access & f.getMask()) == f.getMask())
						.map(AccessFlag::getName)
						.collect(Collectors.joining(" ")),
				n -> {
					try {
						int acc = 0;
						for (String arg : n.split("\\s+")) {
							if (arg.isEmpty())
								continue;
							acc |= new ModifierParser().visit(0, arg).getValue();
						}
						node.access = acc;
						return true;
					} catch (Throwable ignored) {
						return false;
					}
				});
		TextField txtOuterClass = new ActionTextField(controller, node.outerClass, n -> {
			if (n.isEmpty())
				node.outerClass = null;
			else
				node.outerClass = n;
			return true;
		});
		TextField txtOuterMethod = new ActionTextField(controller, node.outerMethod, n -> {
			if (n.isEmpty())
				node.outerMethod = null;
			else
				node.outerMethod = n;
			return true;
		});
		TextField txtOuterMethodDesc = new ActionTextField(controller, node.outerMethodDesc, n -> {
			if (n.isEmpty())
				node.outerMethodDesc = null;
			else
				node.outerMethodDesc = n;
			return true;
		});
		txtName.setDisable(true);
		addEditor("ui.bean.class.name", txtName);
		addEditor("ui.bean.class.signature", txtSignature);
		addEditor("ui.bean.class.supername", txtSuper);
		addEditor("ui.bean.class.interfaces", txtInterfaces);
		addEditor("ui.bean.class.version", txtVersion);
		addEditor("ui.bean.class.access", txtAccess);
		addEditor("ui.bean.class.sourcefile", txtSource);
		addEditor("ui.bean.class.sourcedebug", txtSourceDebug);
		addEditor("ui.bean.class.outerclass", txtOuterClass);
		addEditor("ui.bean.class.outermethod", txtOuterMethod);
		addEditor("ui.bean.class.outermethoddesc", txtOuterMethodDesc);
	}

	@SuppressWarnings("unchecked")
	private void addEditor(String key, Node node) {
		// SubLabeled label = new SubLabeled(translate(key + ".name"), translate(key + ".desc"), "bold");
		Label label = new Label(translate(key + ".name"));
		label.getStyleClass().add("bold");
		label.setTooltip(new Tooltip(translate(key + ".desc")));
		// Store save-action
		classInfoTable.add(label, node);
		Supplier<String>[] supplier = new Supplier[1];
		Predicate<String>[] predicate = new Predicate[1];
		if (node instanceof ActionTextField) {
			supplier[0] = ((ActionTextField) node)::getText;
			predicate[0] = ((ActionTextField) node).getAction();
		} else if (node instanceof ActionTextArea) {
			supplier[0] = ((ActionTextArea) node)::getText;
			predicate[0] = ((ActionTextArea) node).getAction();
		} else {
			throw new IllegalStateException("No editor for field: " + key);
		}
		classInfoEditors.put(() -> predicate[0].test(supplier[0].get()), node);
	}

	private void setupFields() {
		ObservableList<FieldNode> src = FXCollections.observableArrayList(node.fields);
		fields.setItems(src);
		TableColumn<FieldNode, Integer> colIndex = new TableColumn<>(translate("ui.edit.tab.fields.index"));
		TableColumn<FieldNode, Integer> colAcc = new TableColumn<>(translate("ui.edit.tab.fields.access"));
		TableColumn<FieldNode, Type> colType = new TableColumn<>(translate("ui.edit.tab.fields.type"));
		TableColumn<FieldNode, String> colName = new TableColumn<>(translate("ui.edit.tab.fields.name"));
		colIndex.setCellValueFactory(c -> new SimpleObjectProperty<>(src.indexOf(c.getValue()) + 1));
		colAcc.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().access));
		colAcc.setCellFactory(col -> new TableCell<FieldNode, Integer>() {
			@Override
			public void updateItem(Integer item, boolean empty) {
				super.updateItem(item, empty);
				setText(null);
				if (empty) {
					setGraphic(null);
				} else {
					setGraphic(UiUtil.createFieldGraphic(item));
				}
			}
		});
		colType.setCellValueFactory(c -> new SimpleObjectProperty<>(Type.getType(c.getValue().desc)));
		colType.setCellFactory(col -> new TableCell<FieldNode, Type>() {
			@Override
			public void updateItem(Type item, boolean empty) {
				super.updateItem(item, empty);
				setGraphic(null);
				if (empty) {
					setText(null);
				} else {
					Type used = item;
					int arrayLevel = item.getSort() == Type.ARRAY ? item.getDimensions() : 0;
					if (arrayLevel > 0)
						used = used.getElementType();
					String argType = used.getInternalName();
					if (argType.indexOf('/') > 0) {
						argType = argType.substring(argType.lastIndexOf('/') + 1);
					} else if (used.getSort() <= Type.DOUBLE) {
						argType = used.getClassName();
					}
					setText(argType + array(arrayLevel));
					setTooltip(new Tooltip(item.getDescriptor()));
				}
			}
		});
		colName.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().name));
		fields.getColumns().add(colIndex);
		fields.getColumns().add(colAcc);
		fields.getColumns().add(colType);
		fields.getColumns().add(colName);
		fields.setRowFactory(t -> new TableRow<FieldNode>() {
			@Override
			protected void updateItem(FieldNode item, boolean empty) {
				super.updateItem(item, empty);
				if (item != null)
					setContextMenu(menu()
							.controller(controller)
							.view((ClassViewport) ClassNodeEditorPane.this.getParent())
							.declaration(true)
							.ofField(node.name, item.name, item.desc));
				else
					setContextMenu(null);
			}
		});
		getTabs().add(tabFields = new Tab(translate("ui.edit.tab.fields"), fields));
	}

	private void setupMethods() {
		ObservableList<MethodNode> src = FXCollections.observableArrayList(node.methods);
		methods.setItems(src);
		TableColumn<MethodNode, Integer> colIndex = new TableColumn<>(translate("ui.edit.tab.fields.index"));
		TableColumn<MethodNode, Integer> colAcc = new TableColumn<>(translate("ui.edit.tab.methods.access"));
		TableColumn<MethodNode, Type> colType = new TableColumn<>(translate("ui.edit.tab.methods.return"));
		TableColumn<MethodNode, String> colName = new TableColumn<>(translate("ui.edit.tab.methods.name"));
		TableColumn<MethodNode, Type> colArgs = new TableColumn<>(translate("ui.edit.tab.methods.args"));
		colIndex.setCellValueFactory(c -> new SimpleObjectProperty<>(src.indexOf(c.getValue()) + 1));
		colAcc.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().access));
		colAcc.setCellFactory(col -> new TableCell<MethodNode, Integer>() {
			@Override
			public void updateItem(Integer item, boolean empty) {
				super.updateItem(item, empty);
				setText(null);
				if (empty) {
					setGraphic(null);
				} else {
					setGraphic(UiUtil.createMethodGraphic(item));
				}
			}
		});
		colType.setCellValueFactory(c -> new SimpleObjectProperty<>(Type.getType(c.getValue().desc).getReturnType()));
		colType.setCellFactory(col -> new TableCell<MethodNode, Type>() {
			@Override
			public void updateItem(Type item, boolean empty) {
				super.updateItem(item, empty);
				setGraphic(null);
				if (empty) {
					setText(null);
				} else {
					Type used = item;
					int arrayLevel = item.getSort() == Type.ARRAY ? item.getDimensions() : 0;
					if (arrayLevel > 0)
						used = used.getElementType();
					String argType = used.getInternalName();
					if (argType.indexOf('/') > 0) {
						argType = argType.substring(argType.lastIndexOf('/') + 1);
					} else if (used.getSort() <= Type.DOUBLE) {
						argType = used.getClassName();
					}
					setText(argType + array(arrayLevel));
					setTooltip(new Tooltip(item.getDescriptor()));
				}
			}
		});
		colName.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().name));
		colArgs.setCellValueFactory(c -> new SimpleObjectProperty<>(Type.getType(c.getValue().desc)));
		colArgs.setCellFactory(col -> new TableCell<MethodNode, Type>() {
			@Override
			public void updateItem(Type item, boolean empty) {
				super.updateItem(item, empty);
				setGraphic(null);
				if (empty) {
					setText(null);
				} else {
					List<String> args = new ArrayList<>();
					for (Type arg : item.getArgumentTypes()) {
						Type used = arg;
						int arrayLevel = arg.getSort() == Type.ARRAY ? arg.getDimensions() : 0;
						if (arrayLevel > 0)
							used = used.getElementType();
						String argType = used.getInternalName();
						if (argType.indexOf('/') > 0) {
							argType = argType.substring(argType.lastIndexOf('/') + 1);
						} else if (used.getSort() <= Type.DOUBLE) {
							argType = used.getClassName();
						}
						args.add(argType + array(arrayLevel));
					}
					setText(String.join(", ", args));
					String descArgs = item.getDescriptor();
					descArgs = descArgs.substring(0, descArgs.indexOf(')') + 1);
					setTooltip(new Tooltip(descArgs));
				}
			}
		});
		methods.getColumns().add(colIndex);
		methods.getColumns().add(colAcc);
		methods.getColumns().add(colType);
		methods.getColumns().add(colName);
		methods.getColumns().add(colArgs);
		methods.setRowFactory(t -> new TableRow<MethodNode>() {
			@Override
			protected void updateItem(MethodNode item, boolean empty) {
				super.updateItem(item, empty);
				if (item != null)
					setContextMenu(menu()
							.controller(controller)
							.view((ClassViewport) ClassNodeEditorPane.this.getParent())
							.declaration(true)
							.ofMethod(node.name, item.name, item.desc));
			}
		});
		getTabs().add(tabMethods = new Tab(translate("ui.edit.tab.methods"), methods));
	}

	private static String array(int arrayLevel) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < arrayLevel; i++)
			sb.append("[]");
		return sb.toString();
	}

	@Override
	public Map<String, byte[]> save(String name) {
		for (Map.Entry<Supplier<Boolean>, Node> entry : classInfoEditors.entrySet()) {
			// This will apply all editor actions. If any fail to apply their changes the save is aborted.
			if (!entry.getKey().get()) {
				UiUtil.animateFailure(entry.getValue(), 500);
				throw new IllegalStateException("Fix the invalid input");
			}
		}
		ClassWriter cw = controller.getWorkspace().createWriter(ClassWriter.COMPUTE_FRAMES);
		ClassVisitor visitor = cw;
		for (ClassVisitorPlugin visitorPlugin : PluginsManager.getInstance()
				.ofType(ClassVisitorPlugin.class)) {
			visitor = visitorPlugin.intercept(visitor);
		}
		node.accept(visitor);
		return Collections.singletonMap(node.name, cw.toByteArray());
	}

	@Override
	public void selectMember(String name, String desc) {
		boolean method = desc.contains("(");
		int i = 0;
		TableView<?> target;
		if (method) {
			selectionModelProperty().get().select(tabMethods);
			for (MethodNode mn : methods.getItems()) {
				if (mn.name.equals(name) && mn.desc.equals(desc))
					break;
				i++;
			}
			target = methods;
		} else {
			selectionModelProperty().get().select(tabFields);
			for (FieldNode fn : fields.getItems()) {
				if (fn.name.equals(name) && fn.desc.equals(desc))
					break;
				i++;
			}
			target = fields;
		}
		if (i < target.getItems().size()) {
			int idx = i;
			Platform.runLater(() -> {
				target.requestFocus();
				target.getSelectionModel().select(idx);
				target.getFocusModel().focus(idx);
			});
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/AttachPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import com.google.common.collect.Sets;
import com.sun.tools.attach.AgentInitializationException;
import com.sun.tools.attach.AgentLoadException;
import com.sun.tools.attach.spi.AttachProvider;
import javafx.application.Platform;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import me.coley.recaf.control.gui.GuiController;

import com.sun.tools.attach.VirtualMachine;
import com.sun.tools.attach.VirtualMachineDescriptor;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.AttachPlugin;
import me.coley.recaf.ui.controls.*;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.util.self.SelfReferenceUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.util.struct.Expireable;
import me.coley.recaf.workspace.FileSystemResource;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Consumer;

/**
 * UI for attaching to other VM's.
 *
 * @author Matt
 */
public class AttachPane extends BorderPane {
	private static final long UPDATE_TIME_MS = 1000;
	private final Map<String, VMInfo> info = new TreeMap<>();
	private final ListView<VMInfo> list = new ListView<>();
	private final BorderPane view = new BorderPane();
	private final GuiController controller;

	/**
	 * @param controller
	 * 		Controller to use.
	 */
	public AttachPane(GuiController controller) {
		this.controller = controller;
		refreshVmList();
		setup();
	}

	/**
	 * Setup primary components.
	 */
	private void setup() {
		view.getStyleClass().add("vm-view");
		list.getStyleClass().add("vm-list");
		list.setItems(FXCollections.observableArrayList());
		list.setCellFactory(c -> new VMCell());
		list.getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
			view.setCenter(createVmDisplay(n));
		});
		SplitPane split = new SplitPane(list, view);
		SplitPane.setResizableWithParent(list, Boolean.FALSE);
		split.setDividerPositions(0.37);
		setCenter(split);
		// Create thread to continually update vm info (remove dead vms, add new ones)
		ThreadUtil.runRepeated(UPDATE_TIME_MS, () -> {
			Stage attachWindow = controller.windows().getAttachWindow();
			if (attachWindow == null || attachWindow.isShowing()) {
				refreshVmList();
			}
		});
	}

	/**
	 * Create a display for the given vm.
	 * @param vm JVM to potentially attach to.
	 * @return Node containing VM properties, and actions.
	 */
	private Node createVmDisplay(VMInfo vm) {
		BorderPane pane = new BorderPane();
		HBox horizontal = new HBox();
		horizontal.getStyleClass().add("vm-buttons");
		horizontal.getChildren().addAll(
				new ActionButton(LangUtil.translate("ui.attach"), () -> attach(vm)),
				new ActionButton(LangUtil.translate("ui.attach.copy"), () -> copy(vm)));
		pane.setBottom(horizontal);
		TableView<Map.Entry<String,String>> table = new TableView<>();
		table.getStyleClass().add("vm-info-table");
		TableColumn<Map.Entry<String,String>, String> keyColumn = new TableColumn<>("Key");
		TableColumn<Map.Entry<String,String>, String> valueColumn = new TableColumn<>("Value");
		keyColumn.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getKey()));
		valueColumn.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getValue()));
		table.getColumns().add(keyColumn);
		table.getColumns().add(valueColumn);
		List<Map.Entry<String, String>> entries = new ArrayList<>(vm.getProperties().entrySet());
		table.setItems(FXCollections.observableArrayList(entries));
		valueColumn.prefWidthProperty().bind(pane.widthProperty().subtract(keyColumn.widthProperty()).subtract(15));
		pane.setCenter(table);
		return pane;
	}

	/**
	 * Attach to the VM.
	 *
	 * @param vm
	 * 		VM to attach to.
	 */
	private void attach(VMInfo vm) {
		Runnable onSuccess = () -> {
			Log.info("Successfully attached to VM '{}' ... Closing current instance.", vm.getPid());
			try {
				vm.detach();
			} catch(Exception ex) {
				Log.error(ex, "Failed to detach from VM '{}'", vm.getPid());
			}
			controller.exit();
		};
		Consumer<Throwable> onError = (ex) -> {
			ExceptionAlert.show(ex, "Recaf failed to connect to the target VM: " +  vm.getPid());
			try {
				vm.detach();
			} catch(Exception dex) {
				Log.error(dex, "Failed to detach from VM '{}'", vm.getPid());
			}
		};
		vm.attach(onSuccess, onError);
	}

	/**
	 * Copy the VM's information to the current instance.
	 *
	 * @param vm
	 * 		VM to attach to.
	 */
	private void copy(VMInfo vm) {
		List<JavaResource> libs = new ArrayList<>();
		String path = vm.getProperties().get("java.class.path");
		String javaHome = vm.getProperties().get("java.home");
		String localDir = vm.getProperties().get("user.dir");
		String separator = vm.getProperties().get("path.separator");
		if(path != null && !path.isEmpty()) {
			String[] items = path.split(separator);
			for(String item : items) {
				Path filePath = Paths.get(item);
				boolean isAbsolute = filePath.isAbsolute();
				Path file;
				if (isAbsolute)
					file = Paths.get(item);
				else
					file = Paths.get(localDir, item);
				if(!Files.exists(file) || file.toAbsolutePath().startsWith(javaHome))
					continue;
				try {
					libs.add(FileSystemResource.of(file));
				} catch(Exception ex) {
					Log.warn("Could not load classpath item '{}'", item);
				}
			}
		}
		promptPrimary(libs);
	}

	private void promptPrimary(List<JavaResource> libs) {
		BorderPane pane = new BorderPane();
		Stage stage = controller.windows().window(LangUtil.translate("ui.menubar.file.newwizard"), pane);
		ResourceComboBox comboResources = new ResourceComboBox(controller);
		comboResources.setItems(FXCollections.observableArrayList(libs));
		ActionButton btn = new ActionButton(LangUtil.translate("misc.load"), () -> {
			JavaResource primary = comboResources.getSelectionModel().getSelectedItem();
			libs.remove(primary);
			controller.setWorkspace(new Workspace(primary, libs));
			if (primary instanceof FileSystemResource) {
				FileSystemResource fsPrimary = (FileSystemResource) primary;
				controller.config().backend().onLoad(fsPrimary.getPath(), controller.config().display().getMaxRecent());
			}
			stage.close();
		});
		btn.prefWidthProperty().bind(pane.widthProperty());
		btn.setDisable(true);
		comboResources.getSelectionModel().selectedItemProperty().addListener((ob, old, cur) -> {
			btn.setDisable(false);
		});
		comboResources.getSelectionModel().select(0);
		BorderPane.setAlignment(comboResources, Pos.CENTER);
		pane.setTop(comboResources);
		pane.setCenter(btn);
		stage.show();
	}

	/**
	 * Returns the currently detected VM's. The list can be updated via {@link #refreshVmList()}.
	 *
	 * @return Currently detected VM's.
	 */
	public Collection<VMInfo> getInfo() {
		return info.values();
	}

	/**
	 * Reset the {@link #getInfo VM information} list.
	 */
	public void refreshVmList() {
		Set<String> oldKeys = new HashSet<>(info.keySet());
		Set<String> newKeys = new HashSet<>();
		for(VirtualMachineDescriptor descr : VirtualMachine.list()) {
			try {
				// Attach
				AttachProvider provider = descr.provider();
				VirtualMachine machine = provider.attachVirtualMachine(descr);
				String id = machine.id();
				newKeys.add(id);
				if (info.containsKey(id))
					continue;
				if(!id.matches("\\d+")) {
					Log.trace("Skipping VM {}, could not match PID in descriptor", descr.id());
					machine.detach();
					continue;
				}
				// Store info
				int pid = Integer.parseInt(machine.id());
				info.put(id, new VMInfo(machine, pid, descr.displayName()));
			} catch(Exception ex) {
				// Can't connect? Log the failure
				String cause = ex.getMessage();
				if (cause == null)
					cause = ex.toString();
				// Don't log when OpenJDK refuses to connect to itself
				// (Oracle's VM seems 100% fine connecting to self)
				else if (cause.equals("Can not attach to current VM"))
					continue;
				Log.warn("Failed to attach to remote vm '{}' - Cause: {}", descr.id(), cause);
			}
		}
		// Remove any old VM
		// Add any new VM
		Set<String> removed = Sets.difference(oldKeys, newKeys);
		Set<String> added = Sets.difference(newKeys, oldKeys);
		Platform.runLater(() -> {
			removed.forEach(r -> {
				VMInfo vm = info.remove(r);
				list.getItems().remove(vm);
				Log.trace("Update discovered VM list, removed: {}:{}", vm.pid, vm.displayName);
			});
			added.forEach(a -> {
				VMInfo vm = info.get(a);
				list.getItems().add(vm);
				Log.trace("Update discovered VM list, added: {}:{}", vm.pid, vm.displayName);
			});
		});
	}

	/**
	 * Cell to display VM's.
	 */
	private static class VMCell extends ListCell<VMInfo> {
		@Override
		public void updateItem(VMInfo item, boolean empty) {
			super.updateItem(item, empty);
			if(empty) {
				setGraphic(null);
			} else {
				getStyleClass().add("vm-cell");
				BorderPane pane = new BorderPane();
				pane.setLeft(new IconView(UiUtil.getFileIcon("app.jar")));
				pane.setLeft(new BorderPane(pane.getLeft()));
				pane.getLeft().getStyleClass().add("vm-icon");
				pane.setCenter(new SubLabeled(item.pid + " - " + item.getMainClass(),
						"VM: " + item.getVmName()  +
						"\nVersion: " + item.getJavaVersion(), "bold"));
				setGraphic(pane);
			}
		}
	}

	/**
	 * Remove VM information.
	 */
	public static class VMInfo {
		private static final long UPDATE_THRESHOLD = 5000;
		private final VirtualMachine machine;
		private final int pid;
		private final String displayName;
		private final Expireable<Map<String, String>> properties;

		/**
		 * @param machine
		 * 		The wrapped VM.
		 * @param pid
		 * 		VM's process identifier.
		 * @param displayName
		 * VM's display name;
		 */
		private VMInfo(VirtualMachine machine, int pid, String displayName) {
			this.machine = machine;
			this.pid = pid;
			this.displayName = displayName;
			this.properties = new Expireable<>(UPDATE_THRESHOLD, () -> {
				Map<String, String> properties = new TreeMap<>();
				try {
					// Try and fetch remote properties
					if (!ThreadUtil.timeout(500, () -> {
						try {
							Map<?, ?> map = machine.getSystemProperties();
							map.forEach((k, v) -> properties.put(k.toString(), v.toString()));
							Log.trace("Read {} properties from VM '{}'", map.size(), machine.id());
						} catch(IOException e) {
							Log.warn(e, "Failed to fetch properties (IO error) for VM '{}'", machine.id());
						}
					})) {
						Log.warn("Failed to fetch properties (Timed out) from VM: '{}'" + machine.id());
					}
				} catch(Exception ex) {
					Log.warn("Failed to fetch properties from VM '{}'" + machine.id());
				}
				return properties;
			});
		}

		/**
		 * @return VM's process identifier.
		 */
		public int getPid() {
			return pid;
		}

		/**
		 * @return VM's properties.
		 */
		public Map<String, String> getProperties() {
			return properties.get();
		}

		/**
		 * @return VM's name.
		 */
		public String getVmName() {
			return getProperties().getOrDefault("java.vm.name", "?");
		}

		/**
		 * @return Version of java supported by the VM.
		 */
		public String getJavaVersion() {
			return getProperties().getOrDefault("java.version", "?");
		}

		/**
		 * @return Classpath items of the VM.
		 */
		public List<String> getClasspath() {
			String path =  getProperties().get("java.class.path");
			if (path == null || path.isEmpty())
				return Collections.emptyList();
			return Arrays.asList(path.split(";"));
		}

		/**
		 * @return Main class of the VM. May be {@code null}.
		 */
		public String getMainClass() {
			// Get source string to find main class name from
			String source = displayName;
			if (source == null || source.isEmpty()) {
				source = getProperties().get("sun.java.command");
			}
			// Still null/missing? Give up
			if (source == null || source.isEmpty())
				return "<?>";
			String trim = source.trim();
			int end = trim.indexOf(' ');
			if (end == -1)
				end = trim.length();
			return trim.substring(0, end);
		}

		/**
		 * Attempt to attach to the VM.
		 * The following exceptions may be fed to the passed handler:
		 * <ul>
		 * <li><b>IOException</b> - When the Recaf agent could not be fetched.</li>
		 * <li><b>AgentInitializationException</b> - When the agent failed to initialize in the
		 * target VM.</li>
		 * <li><b>AgentLoadException</b> - When the agent failed to load in the target VM.</li>
		 * </ul>
		 *
		 * @param onSuccess
		 * 		Action to run on successfully connecting to the target VM.
		 * @param onError
		 * 		Action to run on failure to connect to the target VM.
		 */
		public void attach(Runnable onSuccess, Consumer<Throwable> onError) {
			ThreadUtil.run(() -> {
				Throwable thrown;
				try {
					String path = SelfReferenceUtil.get().getPath();
					Log.info("Attempting to attatch to '{}' with agent '{}'", getPid(), path);
					PluginsManager.getInstance()
							.ofType(AttachPlugin.class)
							.forEach(plugin -> plugin.onAgentLoad(machine));
					// Attempt to load
					machine.loadAgent(path);
					if (onSuccess != null)
						Platform.runLater(onSuccess);
					return;
				} catch(IOException ex) {
					Log.error(ex, "Recaf failed to connect to target machine '{}'", getPid());
					thrown = ex;
				} catch(AgentInitializationException ex) {
					Log.error(ex, "Recaf agent failed to initialize in the target machine '{}'", getPid());
					thrown = ex;
				} catch(AgentLoadException ex) {
					Log.error(ex, "Recaf agent crashed in the target machine '{}'", getPid());
					thrown = ex;
				} catch (Throwable t) {
					Log.error(t, "Recaf agent failed to load due unhandled error '{}'", getPid());
					thrown = t;
				}
				// Handle errors
				if(onError != null)
					Platform.runLater(() -> onError.accept(thrown));
			});
		}

		/**
		 * Detach from the target VM.
		 *
		 * @throws IOException
		 * 		When an error occurred while detaching,
		 * 		likely due to the target VM being dead, or already detached.
		 */
		public void detach() throws IOException {
			machine.detach();
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/ColumnPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.layout.*;
import me.coley.recaf.ui.controls.SubLabeled;

/**
 * Wrapper for grid in two columns, intended for labeled <i>(left)</i> content<i>(right)</i>.
 *
 * @author Matt
 */
public class ColumnPane extends BorderPane {
	protected final GridPane grid = new GridPane();
	protected int row;

	/**
	 * Setup grid.
	 *
	 * @param insets
	 * 		Padding between container and border.
	 * @param leftPercent
	 * 		Percent of the space for the left column to fill.
	 * @param rightPercent
	 * 		Percent of the space for right column to fill.
	 * @param vgap
	 * 		Vertical spacing between items.
	 */
	public ColumnPane(Insets insets, double leftPercent, double rightPercent, double vgap) {
		setCenter(grid);
		setPadding(insets);
		ColumnConstraints column1 = new ColumnConstraints();
		ColumnConstraints column2 = new ColumnConstraints();
		column1.setPercentWidth(leftPercent);
		column2.setPercentWidth(rightPercent);
		column2.setFillWidth(true);
		column2.setHgrow(Priority.ALWAYS);
		column2.setHalignment(HPos.RIGHT);
		grid.getColumnConstraints().addAll(column1, column2);
		grid.setVgap(vgap);
	}

	/**
	 * Setup grid.
	 */
	public ColumnPane() {
		this(new Insets(5, 10, 5, 10), 70, 30, 5);
	}

	/**
	 * Add row of controls.
	 *
	 * @param left
	 * 		Smaller left control.
	 * @param right
	 * 		Larger right control.
	 */
	public void add(Node left, Node right) {
		// Dummy SubLabeled for proper sizing. Otherwise, a Region would suffice.
		if (left == null)
			left = new SubLabeled(" ", " ");
		// Add controls
		grid.add(left, 0, row);
		grid.add(right, 1, row);
		row++;
		// Force allow HGrow, using Region instead of Node due to inconsistent behavior using Node
		if (right instanceof Region)
			((Region) right).setMaxWidth(Double.MAX_VALUE);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/ConfigPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.application.Platform;
import javafx.scene.Node;
import javafx.scene.control.*;
import me.coley.recaf.config.*;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.api.ConfigurablePlugin;
import me.coley.recaf.ui.controls.Toggle;
import me.coley.recaf.ui.controls.*;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.OSUtil;

import java.util.*;
import java.util.function.Function;

/**
 * Pane for some config.
 *
 * @author Matt
 */
public class ConfigPane extends ColumnPane {
	private static final Map<Class<?>, Function<FieldWrapper, Node>> DEFAULT_EDITORS = new HashMap<>();
	private final Map<String, Function<FieldWrapper, Node>> editorOverrides = new HashMap<>();
	private final Set<String> ignoredItems = new HashSet<>();
	private final Configurable config;
	private boolean hideUnsupported;

	/**
	 * @param config
	 * 		Config of the pane.
	 */
	private ConfigPane(Configurable config) {
		this.config = config;
	}

	/**
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Display config.
	 */
	public ConfigPane(GuiController controller, ConfDisplay config) {
		this(config);
		editorOverrides.put("display.language", LanguageCombo::new);
		editorOverrides.put("display.uifontsize", v -> new FontSlider(controller, v));
		editorOverrides.put("display.monofontsize", v -> new FontSlider(controller, v));
		editorOverrides.put("display.uifont", v -> new FontComboBox(controller, v, config.uiFont));
		editorOverrides.put("display.monofont", v -> new FontComboBox(controller, v, config.monoFont));
		editorOverrides.put("display.textstyle", v -> new ThemeCombo(controller, v));
		editorOverrides.put("display.appstyle", v -> new StyleCombo(controller, v));
		editorOverrides.put("display.classmode", EnumComboBox::new);
		editorOverrides.put("display.filemode", EnumComboBox::new);
		editorOverrides.put("display.forceWordWrap", Toggle::new);
		editorOverrides.put("display.suggest.classerrors", Toggle::new);
		editorOverrides.put("display.maxrecent", v -> new NumberSlider<>(controller, v, 0, 20, 2));
		editorOverrides.put("display.maxtreedepth", v -> new NumberSlider<>(controller, v, 10, 100, 10));
		if (OSUtil.getOSType() == OSUtil.MAC) {
			editorOverrides.put("display.usesystemmenubar", Toggle::new);
		} else {
			ignoredItems.add("display.usesystemmenubar");
		}
		setupConfigControls(config);
	}

	/**
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Keybind config.
	 */
	public ConfigPane(GuiController controller, ConfKeybinding config) {
		this(config);
		editorOverrides.put("binding.saveapp", KeybindField::new);
		editorOverrides.put("binding.save", KeybindField::new);
		editorOverrides.put("binding.find", KeybindField::new);
		editorOverrides.put("binding.rename", KeybindField::new);
		editorOverrides.put("binding.undo", KeybindField::new);
		editorOverrides.put("binding.gotodef", KeybindField::new);
		editorOverrides.put("binding.close.window", KeybindField::new);
		editorOverrides.put("binding.close.tab", KeybindField::new);
		setupConfigControls(config);
	}

	/**
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Decompiler config.
	 */
	public ConfigPane(GuiController controller, ConfDecompile config) {
		this(config);
		// TODO: When the decompiler is changed, switch options are displayed
		editorOverrides.put("decompile.decompiler", EnumComboBox::new);
		editorOverrides.put("decompile.showsynthetics", Toggle::new);
		editorOverrides.put("decompile.stripdebug", Toggle::new);
		editorOverrides.put("decompile.showname", Toggle::new);
		editorOverrides.put("decompile.timeout", (w) -> new NumberSlider<>(controller, w, 1_000, 20_000, 1_000));
		hideUnsupported = true;
		setupConfigControls(config);
	}

	/**
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Assembler config.
	 */
	public ConfigPane(GuiController controller, ConfAssembler config) {
		this(config);
		editorOverrides.put("assembler.verify", Toggle::new);
		editorOverrides.put("assembler.variables", Toggle::new);
		editorOverrides.put("assembler.stripdebug", Toggle::new);
		editorOverrides.put("assembler.useexistingdata", Toggle::new);
		editorOverrides.put("assembler.phantoms", Toggle::new);
		setupConfigControls(config);
	}

	/**
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Updates config.
	 */
	public ConfigPane(GuiController controller, ConfUpdate config) {
		this(config);
		editorOverrides.put("update.active", Toggle::new);
		editorOverrides.put("update.lastcheck", TimestampLabel::new);
		editorOverrides.put("update.frequency", EnumComboBox::new);
		setupConfigControls(config);
	}

	/**
	 * Create a config pane for a configurable plugin.
	 *
	 * @param controller
	 * 		Gui controller.
	 * @param config
	 * 		Configurable plugin.
	 */
	public ConfigPane(GuiController controller, ConfigurablePlugin config) {
		this(config);
		config.addFieldEditors(editorOverrides);
		setupConfigControls(config);
	}

	private void setupConfigControls(Configurable config) {
		for(FieldWrapper field : config.getConfigFields()) {
			// Skip hidden values
			if(field.hidden())
				continue;
			// Skip ignored items
			if(ignoredItems.contains(field.key()))
				continue;
			// Create label node
			Node label = null;
			if (field.isTranslatable()) {
				label = new SubLabeled(field.name(), field.description());
			} else {
				label = new Label(field.key());
				label.getStyleClass().add("h2");
			}
			// Check for override editor
			if (editorOverrides.containsKey(field.key())) {
				// Add label/editor
				Node editor = editorOverrides.get(field.key()).apply(field);
				add(label, editor);
			} else if (DEFAULT_EDITORS.containsKey(field.type())) {
				Log.debug("Using default editor for value '{}', type: {}", field.key(), field.type().getName());
				Node editor = DEFAULT_EDITORS.get(field.type()).apply(field);
				add(label, editor);
			} else if (field.type().isEnum()) {
				Node editor = DEFAULT_EDITORS.get(Enum.class).apply(field);
				add(label, editor);
			}else if (!hideUnsupported) {
				add(label, new Label("Unsupported: " + field.type() + " - " + field.key()));
			}
		}
	}

	/**
	 * @return Wrapped config.
	 */
	public Configurable getConfig() {
		return config;
	}

	/**
	 * Refresh editor values.
	 */
	public void refresh() {
		Platform.runLater(() -> {
			row = 0;
			grid.getChildren().clear();
			setupConfigControls(config);
		});
	}

	static {
		// Populate default editors
		DEFAULT_EDITORS.put(boolean.class, Toggle::new);
		DEFAULT_EDITORS.put(Boolean.class, Toggle::new);
		DEFAULT_EDITORS.put(Enum.class, EnumComboBox::new);
		DEFAULT_EDITORS.put(ConfKeybinding.Binding.class, KeybindField::new);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/ConfigTabs.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ConfigurablePlugin;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * TabPane to hold a {@link ConfigPane} for each {@link me.coley.recaf.config.Config}
 *
 * @author Matt
 */
public class ConfigTabs extends TabPane {
	/**
	 * @param controller
	 * 		Gui controller.
	 */
	public ConfigTabs(GuiController controller) {
		// Configure tabs
		setTabClosingPolicy(TabClosingPolicy.UNAVAILABLE);
		// Add default tabs
		Tab tabDisplay = new Tab(translate("display"), new ConfigPane(controller, controller.config().display()));
		Tab tabBinding = new Tab(translate("binding"), new ConfigPane(controller, controller.config().keys()));
		Tab tabDecompile = new Tab(translate("decompile"), new ConfigPane(controller, controller.config().decompile()));
		Tab tabAssembler = new Tab(translate("assembler"), new ConfigPane(controller, controller.config().assembler()));
		Tab tabUpdates = new Tab(translate("update"), new ConfigPane(controller, controller.config().update()));
		getTabs().addAll(tabDisplay, tabBinding, tabDecompile, tabAssembler, tabUpdates);
		// Add plugin tabs
		PluginsManager.getInstance().ofType(ConfigurablePlugin.class)
				.forEach(plugin -> getTabs().add(
						new Tab(plugin.getConfigTabTitle(), new ConfigPane(controller, plugin))));
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/ContactInfoPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Hyperlink;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.UiUtil;

import java.io.IOException;
import java.net.URI;

/**
 * Panel that shows contact information.
 *
 * @author Matt
 */
public class ContactInfoPane extends GridPane {
	private static final int SEP_SIZE = 2;

	/**
	 * Create contact pane.
	 */
	public ContactInfoPane() {
		// Grid config
		setVgap(4);
		setHgap(5);
		setPadding(new Insets(15));
		setAlignment(Pos.CENTER);
		// System
		addRow(0, new Label("GitHub"), link("https://github.com/Col-E/Recaf", "icons/github.png"));
		addRow(1, new Label("Discord"), new Hyperlink("https://discord.gg/Bya5HaA", new IconView("icons/discord.png")));
	}

	private Node link(String url, String iconPath) {
		Hyperlink link = new Hyperlink(url, new IconView(iconPath));
		link.setOnAction(e -> {
			try {
				UiUtil.showDocument(URI.create(url));
			} catch(IOException | IllegalArgumentException ex) {
				Log.error(ex, "Failed to open URL");
			}
		});
		return link;
	}

	@Override
	public void addRow(int rowIndex, Node... children) {
		super.addRow(rowIndex, children);
		if(children[0].getClass() == Label.class) {
			children[0].getStyleClass().add("bold");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/HistoryPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.application.Platform;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextArea;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.api.InternalPlugin;
import me.coley.recaf.plugin.api.WorkspacePlugin;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.ui.controls.SubLabeled;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.util.struct.InternalBiConsumer;
import me.coley.recaf.workspace.History;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;
import org.apache.commons.codec.digest.DigestUtils;
import org.plugface.core.annotations.Plugin;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * UI for managing save-states for classes and files.
 *
 * @author Matt
 */
public class HistoryPane extends BorderPane {
	private final ListView<History> list = new ListView<>();
	private final BorderPane view = new BorderPane();
	private final GuiController controller;

	/**
	 * Create the history pane.
	 *
	 * @param controller
	 * 		Controller to pull from.
	 */
	public HistoryPane(GuiController controller) {
		this.controller = controller;
		setup();
		// Ensure access to current/future workspace history maps
		if(controller.getWorkspace() != null) {
			rehookWorkspace();
			update();
		}
	}

	private void setup() {
		list.setCellFactory(cb -> new HistCell());
		list.getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
			view.setCenter(createHistoryView(n == null ? o : n));
		});
		view.getStyleClass().add("hist-view");
		SplitPane split = new SplitPane(list, view);
		SplitPane.setResizableWithParent(list, Boolean.FALSE);
		split.setDividerPositions(0.37);
		setCenter(split);
	}

	private Node createHistoryView(History history) {
		byte[] data = history.peek();
		boolean isClass = ClassUtil.isClass(data);
		String type = isClass ? "class" : "file";
		BorderPane pane = new BorderPane();
		// Content
		int count = history.size() - 1;
		String sub = count > 0 ? "[" + count + " states]" : "[Initial state]";
		BorderPane display = new BorderPane();
		display.setTop(new SubLabeled(history.name, sub));
		display.setCenter(new VBox(
				new TextArea(
						"Last updated:          " + history.getMostRecentUpdate() + "\n" +
						"Content length:        " + data.length + "\n" +
						"Content hash (MD5):    " + DigestUtils.md5Hex(data) + "\n" +
						"Content hash (SHA1):   " + DigestUtils.sha1Hex(data) + "\n" +
						"Content hash (SHA256): " + DigestUtils.sha256Hex(data))
		));
		display.getCenter().getStyleClass().add("hist-data");
		pane.setCenter(display);
		// Buttons
		HBox horizontal = new HBox();
		horizontal.getStyleClass().add("hist-buttons");
		horizontal.getChildren().addAll(
				new ActionButton(LangUtil.translate("ui.history.pop"), () -> {
					pop(history, isClass);
					// Update content sub-text
					int updatedCount = history.size() - 1;
					String updatedSub = updatedCount > 0 ? "[" + updatedCount + " states]" : "[Initial state]";
					display.setTop(new SubLabeled(history.name, updatedSub));
					// Update content data
					byte[] updatedData = history.peek();
					display.setCenter(new VBox(
							new Label("Last updated:        " + history.getMostRecentUpdate()),
							new Label("Content length:      " + updatedData.length),
							new Label("Content hash (MD5):  " + DigestUtils.md5Hex(updatedData)),
							new Label("Content hash (SHA1): " + DigestUtils.sha1Hex(updatedData))
					));
					display.getCenter().getStyleClass().add("monospaced");
				}),
				new ActionButton(LangUtil.translate("ui.history.open." + type), () -> open(history, isClass)));
		pane.setBottom(horizontal);
		return pane;
	}

	/**
	 * Pop the most recent change of the given history.
	 *
	 * @param history
	 * 		History of some class/file.
	 * @param isClass
	 * 		If the item is a class.
	 */
	private void pop(History history, boolean isClass) {
		// If the file is open, undo it via the editor viewport.
		String key = history.name;
		if (controller.windows().getMainWindow().getTabs().isOpen(key)) {
			if (isClass)
				controller.windows().getMainWindow().getClassViewport(key).undo();
			else
				controller.windows().getMainWindow().getFileViewport(key).undo();
		}
		// Otherwise, simply pop it.
		else {
			history.pop();
		}
	}

	/**
	 * Open the class/file wrapped by the given history.
	 *
	 * @param history
	 * 		History of some class/file.
	 * @param isClass
	 * 		If the item is a class.
	 */
	private void open(History history, boolean isClass) {
		String key = history.name;
		JavaResource resource = controller.getWorkspace().getPrimary();
		if (isClass)
			controller.windows().getMainWindow().openClass(resource, key);
		else
			controller.windows().getMainWindow().openFile(resource, key);
	}

	/**
	 * Add class/file map listeners so file updates call {@link #update()}.
	 */
	private void rehookWorkspace() {
		// Whenever a class/file is updated, call "update()"
		controller.getWorkspace().getPrimary().getClasses().getPutListeners()
				.add(InternalBiConsumer.internal((name, value) -> update()));
		controller.getWorkspace().getPrimary().getFiles().getPutListeners()
				.add(InternalBiConsumer.internal((name, value) -> update()));
	}

	/**
	 * Update displayed history wrappers in the list-view.
	 */
	private void update() {
		Platform.runLater(() -> {
			History oldSelection = list.getSelectionModel().getSelectedItem();
			list.getItems().clear();
			JavaResource resource = controller.getWorkspace().getPrimary();
			// Get class/file histories that have multiple states, then sort them
			List<History> orderedClasses = new ArrayList<>(resource.getClassHistory().values());
			List<History> orderedFiles = new ArrayList<>(resource.getFileHistory().values());
			orderedClasses.removeIf(History::isAtInitial);
			orderedClasses.sort(Comparator.comparing(o -> o.name));
			orderedFiles.removeIf(History::isAtInitial);
			orderedFiles.sort(Comparator.comparing(o -> o.name));
			// Combine and set as new list-view item-list
			List<History> ordered = new ArrayList<>();
			ordered.addAll(orderedClasses);
			ordered.addAll(orderedFiles);
			list.getItems().addAll(ordered);
			// Update selected view
			if (oldSelection != null && list.getItems().contains(oldSelection))
				list.getSelectionModel().select(oldSelection);
		});
	}

	/**
	 * Cell to display class histories.
	 */
	private static class HistCell extends ListCell<History> {
		@Override
		public void updateItem(History item, boolean empty) {
			super.updateItem(item, empty);
			if(!empty) {
				Node g = null;
				String text = item.name;
				// Create graphic based on history content
				// - (only way to differ between class/file)
				int count = item.size() - 1;
				byte[] data = item.peek();
				if (ClassUtil.isClass(data)) {
					g = UiUtil.createClassGraphic(ClassUtil.getAccess(data));
				} else {
					g = UiUtil.createFileGraphic(text);
				}
				getStyleClass().add("hist-cell");
				BorderPane wrap = new BorderPane();
				String sub = count > 0 ? "[" + count + " states]" : "[Initial state]";
				wrap.setLeft(g);
				wrap.setLeft(new BorderPane(wrap.getLeft()));
				wrap.getLeft().getStyleClass().add("hist-icon");
				wrap.setCenter(new SubLabeled(text, sub, "bold"));
				setGraphic(wrap);
			} else {
				setGraphic(null);
				setText(null);
			}
		}
	}

	/**
	 * Plugin to rehook workspace.
	 */
	@Plugin(name = "History")
	public static final class HistoryPlugin implements WorkspacePlugin, InternalPlugin {
		private final HistoryPane history;

		/**
		 * @param history
		 * 		History pane.
		 */
		public HistoryPlugin(HistoryPane history) {
			this.history = history;
		}

		@Override
		public void onOpened(Workspace workspace) {
			history.rehookWorkspace();
		}

		@Override
		public void onClosed(Workspace workspace) { }

		@Override
		public String getVersion() {
			return Recaf.VERSION;
		}

		@Override
		public String getDescription() {
			return "UI to display items history.";
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/JvmCreationPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.FileChooser;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.ui.controls.ExceptionAlert;
import me.coley.recaf.util.*;
import me.coley.recaf.util.self.SelfReferenceUtil;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * UI for creating new JVM processes to attach to.
 *
 * @author Matt
 */
public class JvmCreationPane extends GridPane {
	// Executable
	private final FileItem fileJava;
	// Classpath
	private final BorderPane cpPane = new BorderPane();
	private final FileItem fileJar;
	private final ListView<FileItem> listCpItems = new ListView<>();
	private final TextField txtMainClass = new TextField();
	private final Button btnAddCpListItem;
	private boolean isJar;
	// Args
	private final TextField txtJvmArgs = new TextField();
	private final TextField txtAppArgs = new TextField();
	// Run
	private final Button btnRun;

	/**
	 * @param controller
	 * 		Controller to use.
	 */
	public JvmCreationPane(GuiController controller) {
		fileJava = new FileItem(controller, null);
		fileJar = new FileItem(controller, null);
		fileJava.setPrompt("<system-path::java>");
		btnAddCpListItem = new ActionButton(translate("misc.add"), () -> {
			listCpItems.getItems().add(new FileItem(controller, listCpItems));
		});
		btnRun = new ActionButton(translate("ui.attach"), () -> {
			List<String> command = new LinkedList<>();
			String execPath = (fileJava.isEmpty() ? IOUtil.toString(VMUtil.getJavaPath()) : fileJava.getPath());
			String jvmArgs = txtJvmArgs.getText();
			command.add(execPath);
			command.add(jvmArgs);
			command.add("-javaagent:\"" + SelfReferenceUtil.get().getPath() + '"');
			if (isJar) {
				command.addAll(Arrays.asList("-jar", fileJar.getPath()));
			} else {
				command.addAll(Arrays.asList("-cp", String.join(File.pathSeparator, getPaths()),
						txtMainClass.getText()));
			}
			String appArgs = txtAppArgs.getText();
			command.addAll(Arrays.asList(appArgs.split(" ")));
			try {
				ProcessBuilder.Redirect redirect = ProcessBuilder.Redirect.to(Log.logFile.toFile());
				Process process = new ProcessBuilder().command(command)
						.redirectOutput(redirect)
						.redirectError(redirect)
						.start();
				Log.info("Started new process: {}", String.join(" ", command));
				ThreadUtil.run(() -> {
					boolean exit = ProcessUtil.waitFor(process, 10L, TimeUnit.SECONDS);
					if (exit) {
						int exitCode = process.exitValue();
						if (exitCode != 0) {
							Log.error("Failed to start JVM. Exit code: {}", exitCode);
							ExceptionAlert.show(new IllegalStateException("Process finished with exit code: " +
									exitCode), "Failed to start JVM.");
						}
					}
				});
			} catch (IOException e) {
				Log.error(e, "Failed to start JVM: {}", e.getMessage());
				ExceptionAlert.show(e, "Failed to start JVM.");
			}
		});
		setup();
	}

	private void setup() {
		// Grid config
		setVgap(4);
		setHgap(5);
		setPadding(new Insets(15));
		setAlignment(Pos.TOP_CENTER);
		ColumnConstraints column1 = new ColumnConstraints();
		ColumnConstraints column2 = new ColumnConstraints();
		column1.setPercentWidth(25);
		column2.setPercentWidth(100 - column1.getPercentWidth());
		getColumnConstraints().addAll(column1, column2);
		// System
		addRow(this, 0, new Label("Java"), fileJava);
		addRow(this, 1, new Label("Classpath type"), createCpTypeRadios());
		addRow(this, 2, new Label("Classpath"), cpPane);
		addRow(this, 3, new Label("JVM args"), txtJvmArgs);
		addRow(this, 4, new Label("Application args"), txtAppArgs);
		add(btnRun, 1, 5);
	}

	/**
	 * @return Radio button group that swaps out {@link #cpPane} content.
	 */
	private Node createCpTypeRadios() {
		// Two options
		RadioButton radJar = new RadioButton("Runnable Jar");
		RadioButton radCp = new RadioButton("Classpath list");
		// Multiple cp item layout
		BorderPane bpCpList = new BorderPane();
		GridPane grid = new GridPane();
		grid.setVgap(4);
		grid.setHgap(5);
		grid.setPadding(new Insets(15));
		grid.setAlignment(Pos.CENTER);
		addRow(grid, 0, new Label(""), btnAddCpListItem);
		addRow(grid, 1, new Label("Main class"), txtMainClass);
		bpCpList.setCenter(listCpItems);
		bpCpList.setBottom(grid);
		// Set to jar
		radJar.setOnAction(e -> {
			isJar = true;
			radCp.setSelected(false);
			cpPane.setCenter(fileJar);
		});
		// Set to multiple
		radCp.setOnAction(e -> {
			isJar = false;
			radJar.setSelected(false);
			cpPane.setCenter(bpCpList);
		});
		// Use jar layout by default
		radJar.fire();
		return new VBox(radJar, radCp);
	}

	private static void addRow(GridPane grid, int rowIndex, Node... children) {
		grid.addRow(rowIndex, children);
		if (children[0].getClass() == Label.class) {
			children[0].getStyleClass().add("bold");
		}
	}

	/**
	 * @return Collection of added classpath values.
	 */
	private Collection<String> getPaths() {
		return listCpItems.getItems().stream().map(FileItem::getPath).collect(Collectors.toList());
	}

	/**
	 * Wrapper component for a file, shown in a text field with action buttons for selecting a file via a prompt.
	 */
	static class FileItem extends BorderPane {
		private final FileChooser fc = new FileChooser();
		private final TextField text = new TextField();

		/**
		 * @param controller
		 * 		Controller to pull config from for initial directory for file prompt.
		 * @param parent
		 * 		Parent listview to support removing self. {@code null} if not in a list.
		 */
		private FileItem(GuiController controller, ListView<FileItem> parent) {
			fc.setInitialDirectory(controller.config().backend().getRecentLoadDir());
			// Update text
			Button btnSelect = new ActionButton(translate("misc.select"), () -> {
				File file = fc.showOpenDialog(null);
				if (file != null) {
					text.setText(file.getAbsolutePath());
				}
			});
			setCenter(text);
			// Remove this item
			if (parent != null) {
				Button btnDelete = new ActionButton(translate("misc.remove"), () -> parent.getItems().remove(this));
				setRight(new HBox(btnSelect, btnDelete));
			} else {
				setRight(new HBox(btnSelect));
			}
		}

		private String getPath() {
			return text.getText();
		}

		private boolean isEmpty() {
			return getPath().trim().isEmpty();
		}

		private void setPrompt(String msg) {
			text.setPromptText(msg);
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/PluginManagerPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.collections.FXCollections;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.BasePlugin;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.ui.controls.SubLabeled;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.UiUtil;

import java.awt.image.BufferedImage;

/**
 * UI for managing plugins.
 *
 * @author Matt
 */
public class PluginManagerPane extends BorderPane {
	private static final PluginsManager manager = PluginsManager.getInstance();
	private final ListView<BasePlugin> list = new ListView<>();
	private final BorderPane view = new BorderPane();

	/**
	 * Create the plugin pane.
	 */
	public PluginManagerPane() {
		setup();
	}

	private void setup() {
		list.setCellFactory(cb -> new PluginCell());
		list.getSelectionModel().selectedItemProperty().addListener((ob, o, n) -> {
			view.setCenter(createPluginView(n == null ? o : n));
		});
		list.setItems(FXCollections.observableArrayList(PluginsManager.getInstance().visiblePlugins().values()));
		view.getStyleClass().add("plugin-view");
		SplitPane split = new SplitPane(list, view);
		SplitPane.setResizableWithParent(list, Boolean.FALSE);
		split.setDividerPositions(0.37);
		setCenter(split);
	}

	private Node createPluginView(BasePlugin plugin) {
		BorderPane pane = new BorderPane();
		pane.setPadding(new Insets(15));
		// Content
		VBox box = new VBox();
		box.setSpacing(10);
		HBox title = new HBox();
		BufferedImage icon = manager.getPluginIcons().get(plugin.getName());
		if (icon != null) {
			IconView iconView = new IconView(UiUtil.toFXImage(icon), 32);
			BorderPane wrapper = new BorderPane(iconView);
			wrapper.setPadding(new Insets(4, 8, 0, 0));
			title.getChildren().add(wrapper);
		}
		title.getChildren().add(new SubLabeled(plugin.getName(), plugin.getDescription()));
		box.getChildren().add(title);
		pane.setCenter(box);
		// Controls
		HBox horizontal = new HBox();
		CheckBox chkEnabled = new CheckBox(LangUtil.translate("misc.enabled"));
		chkEnabled.setSelected(manager.getPluginStates().get(plugin.getName()));
		chkEnabled.selectedProperty()
				.addListener((ob, o, n) -> manager.getPluginStates().put(plugin.getName(), n));
		horizontal.getChildren().add(chkEnabled);
		box.getChildren().add(horizontal);
		return pane;
	}

	private static class PluginCell extends ListCell<BasePlugin> {
		@Override
		public void updateItem(BasePlugin item, boolean empty) {
			super.updateItem(item, empty);
			if(!empty) {
				String name = item.getName();
				String version = item.getVersion();
				BufferedImage icon = manager.getPluginIcons().get(name);
				setText(name + " - " + version);
				if (icon != null)
					setGraphic(new IconView(UiUtil.toFXImage(icon)));
				else
					setGraphic(UiUtil.createFileGraphic("plugin.jar"));
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/SearchPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.control.*;
import me.coley.recaf.control.Controller;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.search.*;
import me.coley.recaf.ui.controls.NullableText;
import me.coley.recaf.ui.controls.NumericText;
import me.coley.recaf.ui.controls.PackageSelector;
import me.coley.recaf.ui.controls.SubLabeled;
import me.coley.recaf.ui.controls.tree.*;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.workspace.Workspace;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Pane for displaying search query inputs &amp; results.
 *
 * @author Matt
 */
@SuppressWarnings("unchecked")
public class SearchPane extends SplitPane {
	private final Map<String, Input> inputMap = new HashMap<>();
	private final TreeView tree = new TreeView();
	private final Runnable searchAction;


	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param type
	 * 		Type of query.
	 */
	public SearchPane(GuiController controller, QueryType type) {
		setOrientation(Orientation.VERTICAL);
		setDividerPositions(0.5);
		tree.setCellFactory(e -> new JavaResourceCell());
		ColumnPane params = new ColumnPane();
		Button btn = new Button(LangUtil.translate("ui.search"));
		btn.getStyleClass().add("search-button");
		switch(type) {
			case MEMBER_DEFINITION:
				addInput(new Input<>(params, "ui.search.declaration.owner", "ui.search.declaration.owner.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.declaration.name", "ui.search.declaration.name.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.declaration.desc", "ui.search.declaration.desc.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.matchmode", "ui.search.matchmode.sub", () -> {
					ComboBox<StringMatchMode> comboMode = new ComboBox<>();
					comboMode.getItems().setAll(StringMatchMode.values());
					comboMode.setValue(StringMatchMode.CONTAINS);
					return comboMode;
				}, ComboBoxBase::getValue, ComboBoxBase::setValue));
				searchAction = () -> search(controller, () -> buildDefinitionSearch(controller.getWorkspace()));
				btn.setOnAction(e -> search());
				break;
			case CLASS_REFERENCE:
				addInput(new Input<>(params, "ui.search.cls_reference.name", "ui.search.cls_reference.name.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.matchmode", "ui.search.matchmode.sub", () -> {
					ComboBox<StringMatchMode> comboMode = new ComboBox<>();
					comboMode.getItems().setAll(StringMatchMode.values());
					comboMode.setValue(StringMatchMode.CONTAINS);
					return comboMode;
				}, ComboBoxBase::getValue, ComboBoxBase::setValue));
				searchAction = () -> search(controller, () -> buildClassReferenceSearch(controller.getWorkspace()));
				btn.setOnAction(e -> search());
				break;
			case MEMBER_REFERENCE:
				addInput(new Input<>(params, "ui.search.mem_reference.owner", "ui.search.mem_reference.owner.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.mem_reference.name", "ui.search.mem_reference.name.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.mem_reference.desc", "ui.search.mem_reference.desc.sub",
						NullableText::new, NullableText::get, NullableText::setText));
				addInput(new Input<>(params, "ui.search.matchmode", "ui.search.matchmode.sub", () -> {
					ComboBox<StringMatchMode> comboMode = new ComboBox<>();
					comboMode.getItems().setAll(StringMatchMode.values());
					comboMode.setValue(StringMatchMode.CONTAINS);
					return comboMode;
				}, ComboBoxBase::getValue, ComboBoxBase::setValue));
				searchAction = () -> search(controller, () -> buildMemberReferenceSearch(controller.getWorkspace()));
				btn.setOnAction(e -> search());
				break;
			case STRING:
				addInput(new Input<>(params, "ui.search.string", "ui.search.string.sub",
						TextField::new, TextField::getText, TextField::setText));
				addInput(new Input<>(params, "ui.search.matchmode", "ui.search.matchmode.sub", () -> {
					ComboBox<StringMatchMode> comboMode = new ComboBox<>();
					comboMode.getItems().setAll(StringMatchMode.values());
					comboMode.setValue(StringMatchMode.CONTAINS);
					return comboMode;
				}, ComboBoxBase::getValue, ComboBoxBase::setValue));
				searchAction = () -> search(controller, () -> buildStringSearch(controller.getWorkspace()));
				btn.setOnAction(e -> search());
				break;
			case VALUE:
				addInput(new Input<>(params, "ui.search.value", "ui.search.value.sub",
						NumericText::new, NumericText::get, (e, t) -> e.setText(t.toString())));
				searchAction = () -> {
					if(input("ui.search.value") == null)
						return;
					search(controller, () -> buildValueSearch(controller.getWorkspace()));
				};
				btn.setOnAction(e -> search());
				break;
			case INSTRUCTION_TEXT:
				addInput(new Input<>(params, "ui.search.insn.lines", "ui.search.insn.lines.sub",
						TextArea::new, t -> Arrays.asList(t.getText().split("[\n\r]")),
						(e, t) -> e.setText(String.join("\n", t))));
				addInput(new Input<>(params, "ui.search.matchmode", "ui.search.matchmode.sub", () -> {
					ComboBox<StringMatchMode> comboMode = new ComboBox<>();
					comboMode.getItems().setAll(StringMatchMode.values());
					comboMode.setValue(StringMatchMode.CONTAINS);
					return comboMode;
				}, ComboBoxBase::getValue, ComboBoxBase::setValue));
				searchAction = () -> search(controller, () -> buildInsnSearch(controller.getWorkspace()));
				btn.setOnAction(e -> search());
				break;
			default:
				searchAction = null;
				break;
		}
		PackageSelector selector = new PackageSelector(controller.windows());
		addInput(new Input<>(params, "ui.search.skippackages", "ui.search.skippackages.sub",
				() -> selector, PackageSelector::get, PackageSelector::set));
		params.add(null, btn);
		getItems().addAll(params, tree);
		SplitPane.setResizableWithParent(params, Boolean.FALSE);
	}

	/**
	 * Run search and display results.
	 */
	public void search() {
		searchAction.run();
		tree.requestFocus();
	}

	/**
	 * Run search and display results.
	 *
	 * @param controller
	 * 		Controller for the workspace.
	 * @param collectorSupplier
	 * 		Search generator.
	 */
	private void search(Controller controller, Supplier<SearchCollector> collectorSupplier) {
		Workspace workspace = controller.getWorkspace();
		List<SearchResult> results = null;
		SearchCollector collector = null;
		try {
			collector = collectorSupplier.get();
			results = collector.getAllResults();
		} catch(IllegalArgumentException ex) {
			// Some search argument requirements were not met
			results = Collections.emptyList();
			// TODO: visual warning
			Log.warn("Failed search due to illegal arguments: {}", ex.getMessage());
		}
		// Create parameter map so the root item can show the parameters of the search
		Map<String, Object> params = new TreeMap<>(inputMap.entrySet().stream()
				.collect(Collectors.toMap(
						e -> e.getKey().substring(e.getKey().lastIndexOf(".") + 1),
						e -> e.getValue().getOr("")
				)));
		tree.setRoot(new SearchRootItem(workspace.getPrimary(), results, params));
		JavaResourceTree.recurseOpen(tree.getRoot());
	}

	private SearchCollector buildDefinitionSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.skipDebug()
				.skipCode()
				.query(new MemberDefinitionQuery(
						input("ui.search.declaration.owner"), input("ui.search.declaration.name"),
						input("ui.search.declaration.desc"), input("ui.search.matchmode")))
				.skipPackages(input("ui.search.skippackages"))
				.build();
	}

	private SearchCollector buildClassReferenceSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.query(new ClassReferenceQuery(
						input("ui.search.cls_reference.name"), input("ui.search.matchmode")))
				.skipPackages(input("ui.search.skippackages"))
				.build();
	}

	private SearchCollector buildMemberReferenceSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.query(new MemberReferenceQuery(
						input("ui.search.mem_reference.owner"), input("ui.search.mem_reference.name"),
						input("ui.search.mem_reference.desc"), input("ui.search.matchmode")))
				.skipPackages(input("ui.search.skippackages"))
				.build();
	}

	private SearchCollector buildStringSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.skipDebug()
				.query(new StringQuery(input("ui.search.string"), input("ui.search.matchmode")))
				.skipPackages(input("ui.search.skippackages"))
				.build();
	}

	private SearchCollector buildValueSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.skipDebug()
				.skipPackages(input("ui.search.skippackages"))
				.query(new ValueQuery(input("ui.search.value"))).build();
	}

	private SearchCollector buildInsnSearch(Workspace workspace) {
		return SearchBuilder.in(workspace)
				.skipPackages(input("ui.search.skippackages"))
				.query(new InsnTextQuery(input("ui.search.insn.lines"), input("ui.search.matchmode"))).build();
	}

	/**
	 * @param input
	 * 		Input instance to register.
	 * @param <E>
	 * 		Editor type.
	 * @param <R>
	 * 		Editor content type.
	 */
	private <E extends Node, R> void addInput(Input<E, R> input) {
		inputMap.put(input.key, input);
	}

	/**
	 * @param key
	 * 		Input key.
	 * @param <R>
	 * 		Input content type.
	 *
	 * @return Input value.
	 */
	private <R> R input(String key) {
		Input<?, R> obj = inputMap.get(key);
		if (obj == null)
			throw new IllegalStateException("No input by key: " + key);
		return obj.get();
	}

	/**
	 * @param key
	 * 		Input key.
	 * @param value
	 * 		Input value to set.
	 * @param <R>
	 * 		Input content type.
	 */
	public <R> void setInput(String key, R value) {
		Input<?, R> obj = inputMap.get(key);
		if (obj == null)
			throw new IllegalStateException("No input by key: " + key);
		obj.set(value);
	}

	/**
	 * Wrapper for inputs.
	 *
	 * @param <E>
	 * 		Editor type.
	 * @param <R>
	 * 		Editor content type.
	 */
	private static class Input<E extends Node, R> {
		private final E editor;
		private final Function<E, R> mapper;
		private final BiConsumer<E, R> setter;
		private final String key;

		private Input(ColumnPane root, String key, String desc, Supplier<E> create,
					  Function<E, R> mapper, BiConsumer<E, R> setter) {
			this.editor = create.get();
			this.mapper = mapper;
			this.setter = setter;
			this.key = key;
			SubLabeled labeled = new SubLabeled(translate(key), translate(desc));
			root.add(labeled, editor);
		}

		/**
		 * @param value
		 * 		Value of editor to set.
		 */
		public void set(R value) {
			setter.accept(editor, value);
		}

		/**
		 * @return Content of editor.
		 */
		public R get() {
			return mapper.apply(editor);
		}

		/**
		 * @param fallback
		 * 		Value to return if the editor's value is {@code null}.
		 *
		 * @return Content of editor.
		 */
		public R getOr(R fallback) {
			R ret = get();
			if(ret == null)
				return fallback;
			return ret;
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/SysInfoPane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.Separator;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.layout.GridPane;
import me.coley.recaf.Recaf;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.ui.controls.SubLabeled;
import me.coley.recaf.util.ClasspathUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.UiUtil;

import javax.tools.ToolProvider;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Panel that shows system information.
 *
 * @author Matt
 */
public class SysInfoPane extends GridPane {
	private static final int SEP_SIZE = 2;

	/**
	 * Create info pane.
	 */
	public SysInfoPane() {
		// Grid config
		setVgap(4);
		setHgap(5);
		setPadding(new Insets(15));
		setAlignment(Pos.CENTER);
		int r = 0;
		// System
		addRow(r++, new SubLabeled(translate("ui.about.system"),
				translate("ui.about.system.sub")));
		addRow(r++, new Label("Name"), new Label(System.getProperty("os.name")));
		addRow(r++, new Label("Architecture"), new Label(System.getProperty("os.arch")));
		add(new Separator(), 0, (SEP_SIZE - 1) + r, 2, SEP_SIZE);
		r += (SEP_SIZE + 1);
		// Java
		addRow(r++, new SubLabeled(translate("ui.about.java"), translate("ui.about.java.sub")));
		addRow(r++, new Label("Version"), new Label(System.getProperty("java.version")));
		addRow(r++, new Label("VM name"), new Label(System.getProperty("java.vm.name")));
		addRow(r++, new Label("VM vendor"), new Label(System.getProperty("java.vm.vendor")));
		addRow(r++, new Label("Home"), new Label(System.getProperty("java.home")));
		addRow(r++, new Label("Supports compiler"), new Label(Boolean.toString(
				ToolProvider.getSystemJavaCompiler() != null
		)));
		addRow(r++, new Label("Supports attach"), new Label(Boolean.toString(
				ClasspathUtil.classExists("com.sun.tools.attach.VirtualMachine")
		)));
		add(new Separator(), 0, (SEP_SIZE - 1) + r, 2, SEP_SIZE);
		r += (SEP_SIZE + 1);
		// JavaFX
		addRow(r++, new SubLabeled(translate("ui.about.javafx"),
				translate("ui.about.javafx.sub")));
		addRow(r++, new Label("Version"), new Label(System.getProperty("javafx.version")));
		add(new Separator(), 0, (SEP_SIZE - 1) + r, 2, SEP_SIZE);
		r += (SEP_SIZE + 1);
		// Recaf
		addRow(r++, new SubLabeled(translate("ui.about.recaf"), translate("ui.about.recaf.sub")));
		addRow(r++, new Label("Version"), new Label(Recaf.VERSION));
		addRow(r++, new Label("Settings directory"), new Label(Recaf.getDirectory().toFile().getAbsolutePath()));
		add(new Separator(), 0, (SEP_SIZE - 1) + r, 2, SEP_SIZE);
		r += (SEP_SIZE + 1);
		// Copy
		addRow(r, new ActionButton(translate("ui.about.copy"), () -> {
			Clipboard clip = Clipboard.getSystemClipboard();
			ClipboardContent content = new ClipboardContent();
			content.putString(buildClipboard());
			clip.setContent(content);
		}), new ActionButton(translate("ui.about.opendir"), () -> {
			try {
				UiUtil.showDocument(Recaf.getDirectory().toUri());
			} catch(Exception ex) {
				Log.error(ex, "Failed to open Recaf directory");
			}
		}));
	}

	@Override
	public void addRow(int rowIndex, Node... children) {
		super.addRow(rowIndex, children);
		if(children[0].getClass() == Label.class) {
			children[0].getStyleClass().add("bold");
			children[1].getStyleClass().add("monospaced");
		}
	}

	/**
	 * Converts the UI to markdown text.
	 * Section headers are declared with {@link SubLabeled}.
	 * Section Key/Value pairs are declared with two consecutive {@link Label}.
	 *
	 * @return Markdown string containing all UI elements.
	 */
	public String buildClipboard() {
		// Data collection
		Map<String, Map<String, String>> data = new LinkedHashMap<>();
		// Current section title/map
		String currentSection = null;
		Map<String, String> currentMap = null;
		// Current section key
		boolean labelIsKey = true;
		String currentKey = null;
		for(Node node : getChildren()) {
			// header
			if(node.getClass() == SubLabeled.class) {
				if(currentMap != null) {
					data.put(currentSection, currentMap);
				}
				SubLabeled header = (SubLabeled) node;
				currentSection = header.getPrimaryText();
				currentMap = new LinkedHashMap<>();
			}
			// items (key:value), one follows the other
			else if(node.getClass() == Label.class) {
				String text = ((Label) node).getText();
				if(labelIsKey) {
					currentKey = text;
				} else {
					currentMap.put(currentKey, text);
				}
				// Swap since we do KEY -> VALUE, KEY -> VALUE
				labelIsKey = !labelIsKey;
			}
		}
		// Put to string
		StringBuilder sb = new StringBuilder();
		data.forEach((section, map) -> {
			sb.append("**").append(section).append("**\n")
			  .append("| ").append(String.join(" | ", map.keySet())).append(" |\n")
			  .append("| ").append(map.keySet().stream()
					.map(s -> "--------").collect(Collectors.joining(" | "))).append(" |\n")
			  .append("| `").append(String.join("` | `", map.values())).append("` |\n\n");
		});
		return sb.toString();
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/pane/UpdatePane.java`:

```java
package me.coley.recaf.ui.controls.pane;

import javafx.geometry.Insets;
import javafx.scene.control.Button;
import javafx.scene.control.Hyperlink;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.TextFlow;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.ui.controls.ExceptionAlert;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.util.self.SelfUpdater;
import org.commonmark.node.*;
import org.commonmark.parser.Parser;

import java.io.IOException;
import java.net.URL;
import java.util.function.Consumer;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Panel that shows update information.
 *
 * @author Matt
 */
public class UpdatePane extends BorderPane {
	private final GuiController controller;

	/**
	 * @param controller
	 * 		Controller to use to close Recaf.
	 */
	public UpdatePane(GuiController controller) {
		this.controller = controller;
		Button btn = getButton();
		GridPane grid = new GridPane();
		GridPane.setFillHeight(btn, true);
		GridPane.setFillWidth(btn, true);
		grid.setMaxWidth(800);
		grid.setPadding(new Insets(10));
		grid.setVgap(10);
		grid.setHgap(10);
		grid.add(getNotes(), 0, 0, 2, 1);
		grid.add(getInfo(), 0, 1, 1, 1);
		grid.add(btn, 1, 1, 1, 1);
		grid.add(getSubMessage(), 0, 2, 2, 1);
		setTop(getHeader());
		setCenter(grid);
	}

	private BorderPane getHeader() {
		Label header = new Label("Recaf: " + SelfUpdater.getLatestVersion());
		header.getStyleClass().add("h1");
		BorderPane pane = new BorderPane(header);
		pane.getStyleClass().add("update-header");
		return pane;
	}

	private BorderPane getNotes() {
		TextFlow flow = new TextFlow();
		Parser parser = Parser.builder().build();
		Node document = parser.parse(SelfUpdater.getLatestPatchnotes());
		document.accept(new AbstractVisitor() {
			@Override
			public void visit(Paragraph paragraph) {
				// Add all content to same line
				parse(paragraph, this::text, this::link);
				newLine();
			}

			@Override
			public void visit(Heading heading) {
				// Skip the version H2 text
				if (heading.getLevel() <= 2)
					return;
				// Extract heading text
				StringBuilder sb = new StringBuilder();
				parse(heading, text -> sb.append(text.getLiteral()), null);
				// Render
				addText(sb.toString(), "h2");
				newLine();
			}

			@Override
			public void visit(BulletList list) {
				Node item = list.getFirstChild();
				do {
					// Prefix with bullet point
					addText(" ● ", null);
					// Add all content to same line
					parse(item, this::text, this::link);
					// New line between items
					newLine();
					item = item.getNext();
				} while (item != null);
			}

			private void text(Text text) {
				addText(text.getLiteral(), null);
			}

			private void link(Link link) {
				String text = link.getTitle();
				if (text == null) {
					StringBuilder sb = new StringBuilder();
					parse(link, t -> sb.append(t.getLiteral()), null);
					text = sb.toString();
				}
				addLink(text, link.getDestination());
			}

			private void parse(Node node, Consumer<Text> textHandler, Consumer<Link> linkHandler) {
				if (node instanceof Text) {
					if (textHandler != null) textHandler.accept((Text) node);
				} else if (linkHandler != null && node instanceof Link) {
					linkHandler.accept((Link) node);
				} else {
					Node child = node.getFirstChild();
					do {
						parse(child, textHandler, linkHandler);
						child = child.getNext();
					} while (child != null);
				}
			}

			private void addLink(String text, String url) {
				Hyperlink link = new Hyperlink(text);
				link.getStyleClass().add("a");
				link.setOnAction(e -> {
					try {
						UiUtil.showDocument(new URL(url).toURI());
					} catch (Exception ex) {
						Log.error("Could not open URL: " + url);
					}
				});
				flow.getChildren().add(link);
			}

			private void addText(String text, String style) {
				javafx.scene.text.Text t = new javafx.scene.text.Text(text);
				if (style != null)
					t.getStyleClass().add(style);
				flow.getChildren().add(t);
			}

			private void newLine() {
				javafx.scene.text.Text t = new javafx.scene.text.Text("\n");
				flow.getChildren().add(t);
			}
		});
		BorderPane pane = new BorderPane(flow);
		pane.getStyleClass().add("content");
		pane.getStyleClass().add("update-notes");
		return pane;
	}

	private Label getSubMessage() {
		Label label = new Label(translate("update.consent"));
		label.getStyleClass().add("faint");
		return label;
	}

	private VBox getInfo() {
		VBox box = new VBox();
		int sizeInMg = SelfUpdater.getLatestArtifactSize() / 1000000;
		box.getChildren().addAll(new Label("Size: " + sizeInMg + " MB"),
				new Label("Date: " + SelfUpdater.getLatestVersionDate().toString()));
		return box;
	}

	private Button getButton() {
		Button button = new ActionButton(translate("update.download"), this::update);
		button.setMaxHeight(Double.MAX_VALUE);
		button.setMaxWidth(Double.MAX_VALUE);
		return button;
	}

	private void update() {
		try {
			SelfUpdater.updateRecaf();
			controller.exit();
		} catch (IOException ex) {
			Log.error(ex, "Failed to start update process");
			ExceptionAlert.show(ex, "Recaf failed to start the update process");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/popup/DragPopup.java`:

```java
package me.coley.recaf.ui.controls.popup;

import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.stage.Popup;
import me.coley.recaf.util.ThreadUtil;

/**
 * Draggable popup window.
 *
 * @author Matt
 */
public class DragPopup {
	private final Popup pop = new Popup();

	/**
	 * @param content
	 * 		Popup content.
	 * @param handle
	 * 		Draggable header control.
	 */
	public DragPopup(ScrollPane content, Control handle) {
		this((Node) content, handle);
		content.getStyleClass().add("scroll-antiblur-hack");
		content.getStyleClass().add("drag-popup-scroll");
		content.getStyleClass().add("drag-popup");
		content.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		content.setFitToWidth(true);
	}

	/**
	 * @param content
	 * 		Popup content.
	 * @param handle
	 * 		Draggable header control.
	 */
	public DragPopup(Node content, Control handle) {
		double[] xOffset = {0};
		double[] yOffset = {0};
		handle.getStyleClass().add("drag-popup-header");
		handle.setOnMousePressed(event -> {
			xOffset[0] = event.getSceneX();
			yOffset[0] = event.getSceneY();
		});
		handle.setOnMouseDragged(event -> {
			pop.setX(event.getScreenX() - xOffset[0]);
			pop.setY(event.getScreenY() - yOffset[0]);
		});
		BorderPane wrapper = new BorderPane();
		wrapper.getStyleClass().add("drag-popup-wrapper");
		wrapper.setCenter(content);
		wrapper.setTop(handle);
		wrapper.addEventHandler(MouseEvent.MOUSE_EXITED, e -> pop.hide());
		handle.prefWidthProperty().bind(wrapper.widthProperty());
		pop.getContent().setAll(wrapper);
		pop.setAutoHide(true);
	}

	/**
	 * Display the popup at the given location.
	 *
	 * @param parent
	 * 		Control to spawn on top of.
	 * @param x
	 * 		Screen x.
	 * @param y
	 * 		Screen y.
	 */
	public void show(Node parent, double x, double y) {
		pop.show(parent, x, y);
	}

	/**
	 * Display the popup at the center of the given parent.
	 *
	 * @param parent
	 * 		Control to spawn on top of.
	 */
	public void show(Node parent) {
		ThreadUtil.runJfxDelayed(100, () -> {
			pop.setOnShown(e -> {
				Bounds bounds = parent.localToScreen(parent.getBoundsInParent());
				double parentWidth = bounds.getMaxX() - bounds.getMinX();
				double parentHeight = bounds.getMaxY() - bounds.getMinY();
				double x = bounds.getMinX() + (parentWidth / 2);
				double y = bounds.getMinY() + (parentHeight / 2);
				pop.setX(x - pop.getWidth() / 2);
				pop.setY(y - pop.getHeight() / 2);
			});
			// Show only if parent component still exists (by checking its ownership)
			if (parent.getScene() != null && parent.getScene().getWindow() != null)
				pop.show(parent, 0, 0);
		});
	}

	protected void close() {
		pop.hide();
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/popup/SuggestionWindow.java`:

```java
package me.coley.recaf.ui.controls.popup;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import me.coley.recaf.config.ConfDecompile;
import me.coley.recaf.config.ConfDisplay;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.decompile.DecompileImpl;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.ui.controls.pane.ConfigPane;
import me.coley.recaf.ui.controls.pane.ConfigTabs;
import me.coley.recaf.ui.controls.view.ClassViewport;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Draggable suggestion window.
 *
 * @author Matt
 */
public class SuggestionWindow extends DragPopup {
	private SuggestionWindow(Node content, Control handle) {
		super(content, handle);
	}

	/**
	 * @param controller
	 * 		Controller to access config of.
	 * @param view
	 * 		View that has crashed decompiler.
	 *
	 * @return Suggestion window.
	 */
	public static SuggestionWindow suggestFailedDecompile(GuiController controller,
														  ClassViewport view) {
		return ofDecompilerChange(translate("suggest.decompile.failure"),
				translate("suggest.decompile.failure.title"), controller, view);
	}

	/**
	 * @param controller
	 * 		Controller to access config of.
	 * @param view
	 * 		View that has the errors.
	 *
	 * @return Suggestion window.
	 */
	public static SuggestionWindow suggestAltDecompile(GuiController controller,
													   ClassViewport view) {
		return ofDecompilerChange(translate("suggest.decompile.warn"),
				translate("suggest.decompile.warn.title"), controller, view);
	}

	/**
	 * @param controller
	 * 		Controller to access config of.
	 * @param view
	 * 		View that has the errors.
	 *
	 * @return Suggestion window.
	 */
	public static SuggestionWindow suggestTimeoutDecompile(GuiController controller,
													   ClassViewport view) {
		return ofDecompilerChange(translate("suggest.decompile.timeout"),
				translate("suggest.decompile.timeout.title"), controller, view);
	}

	/**
	 * @param switchMessage
	 * 		Message shown when offering switching decompilers.
	 * @param title
	 * 		Message for the window title.
	 * @param controller
	 * 		Controller to access config of.
	 * @param view
	 * 		View that has the errors.
	 *
	 * @return Suggestion window.
	 */
	public static SuggestionWindow ofDecompilerChange(String switchMessage, String title, GuiController controller,
													   ClassViewport view) {
		GridPane grid = new GridPane();
		grid.setPadding(new Insets(15));
		grid.setVgap(4);
		grid.setAlignment(Pos.CENTER);
		int col = 0;
		for(col = 0; col < 3; col++) {
			ColumnConstraints cc = new ColumnConstraints();
			cc.setHgrow(Priority.ALWAYS);
			cc.setFillWidth(true);
			grid.getColumnConstraints().add(cc);
		}
		grid.add(new Label(switchMessage), 0, 0, 3, 1);
		SuggestionWindow window = of(title, grid);
		// Add decompiler switch buttons
		col = 0;
		ConfDecompile confDecompile = controller.config().decompile();
		ConfDisplay confDisplay = controller.config().display();
		for (DecompileImpl impl : DecompileImpl.values()) {
			String text = impl.name();
			ActionButton btn = new ActionButton(text, () -> {
				confDecompile.decompiler = impl;
				refreshConfigWindow(controller);
				view.setOverrideDecompiler(null);
				window.close();
			});
			btn.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
			// Disable current
			if (impl == view.getDecompiler())
				btn.setDisable(true);
			grid.add(btn, col, 2);
			col++;
		}
		grid.add(new Label(translate("suggest.switchmodes")), 0, 3, 3, 1);
		// Add class mode switch button
		col = 0;
		for (ClassViewport.ClassMode mode : ClassViewport.ClassMode.values()) {
			String text = mode.name();
			ActionButton btn = new ActionButton(text, () -> {
				confDisplay.classEditorMode = mode;
				refreshConfigWindow(controller);
				view.setOverrideMode(confDisplay.classEditorMode);
				window.close();
			});
			btn.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
			// Disable current
			if (mode == view.getClassMode())
				btn.setDisable(true);
			grid.add(btn, col, 4);
			col++;
		}
		return window;
	}

	/**
	 * Update the config UI to reflect modified values.
	 *
	 * @param controller
	 * 		Controller to pull from.
	 */
	private static void refreshConfigWindow(GuiController controller) {
		// Do nothing if config window not populated
		if (controller.windows().getConfigWindow() == null)
			return;
		// Update the config ui
		ConfigTabs tabs = (ConfigTabs) controller.windows().getConfigWindow().getScene().getRoot();
		tabs.getTabs().forEach(t -> {
			ConfigPane pane = ((ConfigPane) t.getContent());
			if (pane.getConfig() == controller.config().display()) {
				pane.refresh();
			}
		});
	}

	/**
	 * @param title
	 * 		Window title.
	 * @param content
	 * 		Window content.
	 *
	 * @return Suggestion window instance.
	 */
	private static SuggestionWindow of(String title, Node content) {
		// Window title
		Label lblTitle = new Label(title);
		lblTitle.getStyleClass().add("h1");
		return new SuggestionWindow(content, lblTitle);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/popup/UpdateWindow.java`:

```java
package me.coley.recaf.ui.controls.popup;

import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import me.coley.recaf.Recaf;
import me.coley.recaf.ui.MainWindow;
import me.coley.recaf.ui.controls.ActionButton;
import me.coley.recaf.util.self.SelfUpdater;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Update popup window.
 *
 * @author Matt
 */
public class UpdateWindow extends DragPopup {
	private UpdateWindow(Node content, Control handle) {
		super(content, handle);
	}

	/**
	 * @param window
	 * 		Window reference to handle UI access.
	 *
	 * @return Update popup.
	 */
	public static UpdateWindow create(MainWindow window) {
		Label lblTitle = new Label(translate("update.outdated"));
		Label lblVersion = new Label(Recaf.VERSION + " → " + SelfUpdater.getLatestVersion());
		Label lblDate = new Label(SelfUpdater.getLatestVersionDate().toString());
		lblTitle.getStyleClass().add("h1");
		lblDate.getStyleClass().add("faint");
		GridPane grid = new GridPane();
		GridPane.setHalignment(lblVersion, HPos.CENTER);
		GridPane.setHalignment(lblDate, HPos.CENTER);
		grid.setPadding(new Insets(15));
		grid.setHgap(10);
		grid.setVgap(10);
		grid.setAlignment(Pos.CENTER);
		grid.add(new Label(translate("update.available")), 0, 0);
		grid.add(new ActionButton(translate("misc.open"), () -> window.getMenubar().showUpdatePrompt()), 1, 0);
		grid.add(lblVersion, 0, 1, 2, 1);
		grid.add(lblDate, 0, 2, 2, 1);
		return new UpdateWindow(grid, lblTitle);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/popup/YesNoWindow.java`:

```java
package me.coley.recaf.ui.controls.popup;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import me.coley.recaf.ui.controls.ActionButton;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * Yes no popup.
 *
 * @author Matt
 */
public class YesNoWindow extends DragPopup {
	private YesNoWindow(Node content, Control handle) {
		super(content, handle);
	}

	/**
	 * @param prompt
	 * 		Confirmation prompt text.
	 * @param yesAction
	 * 		Action to run when clicking 'yes'.
	 * @param noAction
	 * 		Action to run when clicking 'no'.
	 *
	 * @return Yes-No option window.
	 */
	public static YesNoWindow prompt(String prompt, Runnable yesAction, Runnable noAction) {
		GridPane grid = new GridPane();
		grid.setPadding(new Insets(15));
		grid.setVgap(4);
		grid.setAlignment(Pos.CENTER);
		grid.setMinWidth(150);
		for(int col = 0; col < 3; col++) {
			ColumnConstraints cc = new ColumnConstraints();
			cc.setHgrow(Priority.ALWAYS);
			cc.setFillWidth(true);
			grid.getColumnConstraints().add(cc);
		}
		grid.add(new Label(prompt), 0, 0, 2, 1);
		// Create window
		Label lblTitle = new Label(translate("misc.confirm"));
		lblTitle.getStyleClass().add("h1");
		YesNoWindow window = new YesNoWindow(grid, lblTitle);
		// Add yes/no buttons
		ActionButton btnYes = new ActionButton(translate("misc.yes"), () -> {
			if (yesAction != null)
				yesAction.run();
			window.close();
		});
		ActionButton btnNo = new ActionButton(translate("misc.no"), () -> {
			if (noAction != null)
				noAction.run();
			window.close();
		});
		btnYes.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
		btnNo.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
		grid.add(btnYes, 0, 2);
		grid.add(btnNo, 1, 2);
		return window;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeContextHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.scene.control.ContextMenu;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.ui.ContextBuilder;
import me.coley.recaf.ui.controls.ActionMenuItem;
import me.coley.recaf.ui.controls.text.selection.*;
import me.coley.recaf.util.LangUtil;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.model.TwoDimensional;

import java.util.AbstractMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static me.coley.recaf.ui.ContextBuilder.menu;

/**
 * Context menu handler for {@link BytecodeEditorPane}.
 *
 * @author Matt
 */
public class BytecodeContextHandling extends ContextHandling {
	private RootAST root;

	/**
	 * @param controller
	 * 		Controller to use.
	 * @param codeArea
	 * 		Controller to pull info from.
	 */
	public BytecodeContextHandling(GuiController controller, CodeArea codeArea) {
		super(controller, codeArea);
		// Set context selection action
		onContextRequest(selection -> {
			if(selection instanceof ClassSelection) {
				handleClassType((ClassSelection) selection);
			} else if(selection instanceof MemberSelection) {
				handleMemberType((MemberSelection) selection);
			} else if(selection instanceof LabelSelection) {
				handleLabelType((LabelSelection) selection);
			} else if(selection instanceof JumpSelection) {
				handleJumpType((JumpSelection) selection);
			} else if(selection instanceof SwitchSelection) {
				handleSwitchType((SwitchSelection) selection);
			} else if(selection instanceof VariableSelection) {
				handleVariableType((VariableSelection) selection);
			}
		});
	}

	/**
	 * @param ast
	 * 		Analyzed bytecode.
	 */
	public void setAST(RootAST ast) {
		this.root = ast;
	}

	@Override
	protected Object getSelection(TwoDimensional.Position pos) {
		int line = pos.getMajor()+1;
		int offset = pos.getMinor();
		if (root == null)
			return null;
		AST ast = root.getAtLine(line);
		if(ast == null)
			return null;
		// Check for members
		if(ast instanceof MethodInsnAST) {
			MethodInsnAST method = (MethodInsnAST) ast;
			if(offset >= method.getOwner().getStart() && offset <= method.getName().getStart())
				return new ClassSelection(method.getOwner().getType(), false);
			else
				return new MemberSelection(method.getOwner().getType(),
						method.getName().getName(), method.getDesc().getDesc(), false);
		} else if(ast instanceof FieldInsnAST) {
			FieldInsnAST field = (FieldInsnAST) ast;
			if(offset >= field.getOwner().getStart() && offset <= field.getName().getStart())
				return new ClassSelection(field.getOwner().getType(), false);
			else
				return new MemberSelection(field.getOwner().getType(),
						field.getName().getName(), field.getDesc().getDesc(), false);
		}
		// Check for types
		else if(ast instanceof TypeInsnAST) {
			TypeInsnAST type = (TypeInsnAST) ast;
			return new ClassSelection(type.getType().getType(), false);
		}
		// Check for control flow
		else if(ast instanceof LabelAST) {
			LabelAST label = (LabelAST) ast;
			return new LabelSelection(label.getName().getName());
		} else if(ast instanceof JumpInsnAST) {
			JumpInsnAST jump = (JumpInsnAST) ast;
			return new JumpSelection(jump.getLabel().getName());
		} else if(ast instanceof TableSwitchInsnAST) {
			TableSwitchInsnAST swit = (TableSwitchInsnAST) ast;
			Map<String, String> map = new LinkedHashMap<>();
			int value = swit.getRangeMin().getIntValue();
			for(NameAST target : swit.getLabels()) {
				map.put(target.getName(), String.valueOf(value));
				value++;
			}
			return new SwitchSelection(map, swit.getDfltLabel().getName());
		} else if(ast instanceof LookupSwitchInsnAST) {
			LookupSwitchInsnAST swit = (LookupSwitchInsnAST) ast;
			Map<String, String> map = swit.getMapping().entrySet().stream()
					.map(e -> new AbstractMap.SimpleEntry<>(e.getValue().getName(), e.getKey().print()))
					.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a, b) -> b, LinkedHashMap::new));
			return new SwitchSelection(map, swit.getDfltLabel().getName());
		}
		// Check for variable references
		else if(ast instanceof VarInsnAST) {
			VarInsnAST vari = (VarInsnAST) ast;
			return new VariableSelection(vari.getVariableName().getName());
		}
		return null;
	}

	@Override
	protected Object getCurrentSelection() {
		return null;
	}

	private void handleClassType(ClassSelection selection) {
		codeArea.setContextMenu(menu().controller(controller)
				.declaration(selection.dec)
				.ofClass(selection.name));
	}

	private void handleMemberType(MemberSelection selection) {
		ContextBuilder cb = menu().controller(controller)
				.declaration(selection.dec);
		if (selection.method())
			codeArea.setContextMenu(cb.ofMethod(selection.owner, selection.name, selection.desc));
		else
			codeArea.setContextMenu(cb.ofField(selection.owner, selection.name, selection.desc));
	}

	private void handleLabelType(LabelSelection selection) {
		ContextMenu menu = new ContextMenu();
		Menu refs = new Menu(LangUtil.translate("ui.edit.method.referrers"));
		for (AST ast : root.getChildren()) {
			if ((ast instanceof FlowController && ((FlowController) ast).targets().contains(selection.name)) ||
					(ast instanceof LineInsnAST && ((LineInsnAST) ast).getLabel().getName().equals(selection.name))) {
				MenuItem ref = new ActionMenuItem(ast.getLine() + ": " + ast.print(), () -> {
					int line = ast.getLine() - 1;
					codeArea.moveTo(line, 0);
					codeArea.requestFollowCaret();
				});
				refs.getItems().add(ref);
			}
		}
		if (refs.getItems().isEmpty())
			refs.setDisable(true);
		menu.getItems().add(refs);
		codeArea.setContextMenu(menu);
	}

	private void handleVariableType(VariableSelection selection) {
		ContextMenu menu = new ContextMenu();
		Menu refs = new Menu(LangUtil.translate("ui.edit.method.referrers"));
		for (AST ast : root.getChildren()) {
			if (ast instanceof VarInsnAST && ((VarInsnAST) ast).getVariableName().getName().equals(selection.name)) {
				MenuItem ref = new ActionMenuItem(ast.getLine() + ": " + ast.print(), () -> {
					int line = ast.getLine() - 1;
					codeArea.moveTo(line, 0);
					codeArea.requestFollowCaret();
				});
				refs.getItems().add(ref);
			}
		}
		if (refs.getItems().isEmpty())
			refs.setDisable(true);
		menu.getItems().add(refs);
		codeArea.setContextMenu(menu);
	}

	private void handleJumpType(JumpSelection selection) {
		ContextMenu menu = new ContextMenu();
		MenuItem jump = new ActionMenuItem(LangUtil.translate("ui.edit.method.follow"), () -> {
			for (AST ast : root.getChildren()) {
				if (ast instanceof LabelAST) {
					String name = ((LabelAST) ast).getName().getName();
					if(name.equals(selection.destination)) {
						int line = ast.getLine() - 1;
						codeArea.moveTo(line, 0);
						codeArea.requestFollowCaret();
					}
				}
			}
		});
		menu.getItems().add(jump);
		codeArea.setContextMenu(menu);
	}

	private void handleSwitchType(SwitchSelection selection) {
		ContextMenu menu = new ContextMenu();
		Menu refs = new Menu(LangUtil.translate("ui.edit.method.follow"));
		for(AST ast : root.getChildren()) {
			if(ast instanceof LabelAST) {
				String name = ((LabelAST) ast).getName().getName();
				String key = selection.mappings.get(name);
				if (key == null && name.equals(selection.dflt))
					key = "Default";
				if(key != null) {
					MenuItem ref = new ActionMenuItem(key + ": '" + ast.getLine() + ": " + ast.print() +"'", () -> {
						int line = ast.getLine() - 1;
						codeArea.moveTo(line, 0);
						codeArea.requestFollowCaret();
					});
					refs.getItems().add(ref);
				}
			}
		}
		if(refs.getItems().isEmpty())
			refs.setDisable(true);
		menu.getItems().add(refs);
		codeArea.setContextMenu(menu);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeEditorPane.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.application.Platform;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.effect.ColorAdjust;
import me.coley.recaf.metadata.Comments;
import me.coley.recaf.parse.bytecode.*;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ClassVisitorPlugin;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.ui.controls.text.model.Languages;
import me.coley.recaf.util.*;
import me.coley.recaf.util.struct.LineException;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.*;

import java.time.Duration;
import java.util.List;

/**
 * Bytecode-focused text editor.
 *
 * @author Matt
 */
public class BytecodeEditorPane extends EditorPane<BytecodeErrorHandling, BytecodeContextHandling> {
	private static final double DEFAULT_BOTTOM_DISPLAY_PERCENT = 0.72;
	public static final int HOVER_ERR_TIME = 50;
	private BytecodeStackHelper stackHelper;
	private BytecodeLocalHelper localHelper;
	private IconView errorGraphic;
	private ParseResult<RootAST> lastParse;
	protected final String className;
	protected final boolean isMethod;
	protected String memberName;
	protected String memberDesc;
	protected MethodNode currentMethod;
	protected FieldNode currentField;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param className
	 * 		Name of class containing the method.
	 * @param memberName
	 * 		Target member name.
	 * @param memberDesc
	 * 		Target member descriptor.
	 */
	public BytecodeEditorPane(GuiController controller, String className, String memberName, String memberDesc) {
		super(controller, Languages.find("bytecode"), BytecodeContextHandling::new);
		setErrorHandler(new BytecodeErrorHandling(this));
		codeArea.setMouseOverTextDelay(Duration.ofMillis(HOVER_ERR_TIME));
		this.className = className;
		this.memberName = memberName;
		this.memberDesc = memberDesc;
		this.isMethod = memberDesc.contains("(");
		final Assembler<?> ass = isMethod ?
				new MethodAssembler(className, controller) : new FieldAssembler();

		setOnCodeChange(text -> getErrorHandler().onCodeChange(() -> {
			// Reset current cache
			currentField = null;
			currentMethod = null;
			// Setup assembler & context handling
			ParseResult<RootAST> result = Parse.parse(getText());
			if (result.isSuccess())
				contextHandler.setAST(result.getRoot());
			lastParse = result;
			if(isMethod) {
				MethodAssembler assembler = (MethodAssembler) ass;
				if (controller.config().assembler().useExistingData) {
					MethodNode existingMethod = ClassUtil.getMethod(controller.getWorkspace()
							.getClassReader(className), 0, memberName, memberDesc);
					if (existingMethod != null && existingMethod.localVariables != null) {
						// We call the disassembler's methods here so that any changes the disassembler
						// makes to the local variables is what gets populated as default information
						Disassembler.splitSameIndexedVariablesOfDiffNames(existingMethod);
						Disassembler.splitSameNamedVariablesOfDiffTypes(existingMethod);
						assembler.setDefaultVariables(existingMethod.localVariables);
					}
				}
				// Recompile & verify code
				currentMethod = assembler.compile(result);
				stackHelper.setMethodAssembler(assembler);
				localHelper.setMethodAssembler(assembler);
			} else {
				FieldAssembler assembler = (FieldAssembler) ass;
				// Recompile
				currentField = assembler.compile(result);
			}
		}));
		setOnKeyReleased(e -> {
			if(controller.config().keys().gotoDef.match(e))
				contextHandler.gotoSelectedDef();
		});
		codeArea.caretPositionProperty().addListener((n, o, v) -> {
			stackHelper.setLine(codeArea.getCurrentParagraph() + 1);
		});
		// Setup auto-complete
		new BytecodeSuggestHandler(this).setup();
	}

	@Override
	protected void setupBottomContent() {
		errorGraphic = new IconView("icons/error.png");
		stackHelper = new BytecodeStackHelper(this);
		stackHelper.getStyleClass().add("stack-helper");
		localHelper = new BytecodeLocalHelper(this);
		localHelper.getStyleClass().add("local-helper");
		split.setDividerPositions(DEFAULT_BOTTOM_DISPLAY_PERCENT);
		// Done in runLater so we have proper access to "isMethod"
		Platform.runLater(() -> {
			Tab tabErrors = new Tab(LangUtil.translate("misc.errors"));
			tabErrors.setGraphic(errorGraphic);
			tabErrors.setContent(errorList);
			tabErrors.setClosable(false);
			TabPane tabs = new TabPane();
			if (isMethod) {
				Tab tabStack = new Tab(LangUtil.translate("ui.edit.method.stackhelper"));
				tabStack.setGraphic(new IconView("icons/stack.png"));
				tabStack.setContent(stackHelper);
				tabStack.setClosable(false);
				Tab tabLocals = new Tab(LangUtil.translate("ui.bean.method.localvariables.name"));
				tabLocals.setGraphic(new IconView("icons/variable.png"));
				tabLocals.setContent(localHelper);
				tabLocals.setClosable(false);
				tabs.getTabs().addAll(tabErrors, tabStack, tabLocals);
			} else {
				tabs.getTabs().addAll(tabErrors);
			}
			bottomContent.setCenter(tabs);
			onErrorsReceived(null);
		});
	}

	/**
	 * Display disassembled code in the code-area.
	 *
	 * @return {@code true} if disassembly was successful.
	 */
	public boolean disassemble() {
		ClassReader cr  = controller.getWorkspace().getClassReader(className);
		if(cr == null) {
			setEditable(false);
			setText("# Failed to fetch class: " + className);
			forgetHistory();
			return false;
		}
		if (isMethod) {
			int flags = ClassReader.SKIP_FRAMES;
			if (controller.config().assembler().stripDebug)
				flags |= ClassReader.SKIP_DEBUG;
			MethodNode method = ClassUtil.getMethod(cr, flags, memberName, memberDesc);
			if(method == null) {
				setEditable(false);
				setText("# Failed to fetch method: " + className + "." + memberName + memberDesc);
				forgetHistory();
				return false;
			}
			try {
				Disassembler disassembler = new Disassembler();
				setText(disassembler.disassemble(method));
				forgetHistory();
				return true;
			} catch(Exception ex) {
				setText("# Failed to disassemble method: " + className + "." + memberName + memberDesc);
				Log.error(ex, "Failed disassembly of '{}.{}{}'\nReason: ", className,
						memberName, memberDesc, ex.getMessage());
				return false;
			}
		} else {
			FieldNode field = ClassUtil.getField(cr, ClassReader.SKIP_FRAMES, memberName, memberDesc);
			if(field == null) {
				setEditable(false);
				setText("# Failed to fetch field: " + className + "." + memberName);
				forgetHistory();
				return false;
			}
			try {
				Disassembler disassembler = new Disassembler();
				setText(disassembler.disassemble(field));
				forgetHistory();
				return true;
			} catch(Exception ex) {
				setText("# Failed to disassemble field: " + className + "." + memberName);
				Log.error(ex, "Failed disassembly of '{}.{}'\nReason: ", className, memberName, ex.getMessage());
				return false;
			}
		}
	}

	/**
	 * @return Modified class bytecode.
	 */
	public byte[] assemble() {
		if((isMethod && currentMethod == null) || (!isMethod && currentField == null)) {
			// Skip of not saved
			return null;
		}
		// Don't use the final member name/desc, use whatever has been assembled
		String newMemberName = null;
		String newMemberDesc = null;
		if (isMethod) {
			newMemberName = currentMethod.name;
			newMemberDesc = currentMethod.desc;
		} else {
			newMemberName = currentField.name;
			newMemberDesc = currentField.desc;
		}
		// Check if user changed the name
		ClassReader cr  = controller.getWorkspace().getClassReader(className);
		ClassNode existingNode = ClassUtil.getNode(cr, ClassReader.EXPAND_FRAMES);
		int removedIndex = removeIfRenamed(newMemberName, newMemberDesc, existingNode);
		// Update last used name
		memberName = newMemberName;
		memberDesc = newMemberDesc;
		updateOrInsert(newMemberName, newMemberDesc, existingNode, removedIndex);
		// Compile changes
		ClassWriter cw = controller.getWorkspace().createWriter(ClassWriter.COMPUTE_FRAMES);
		ClassVisitor visitor = cw;
		for (ClassVisitorPlugin visitorPlugin : PluginsManager.getInstance()
				.ofType(ClassVisitorPlugin.class)) {
			visitor = visitorPlugin.intercept(visitor);
		}
		existingNode.accept(visitor);
		return cw.toByteArray();
	}


	protected int removeIfRenamed(String newMemberName, String newMemberDesc, ClassNode existingNode) {
		if ((memberName != null && !memberName.equals(newMemberName)) ||
				(memberDesc != null && !memberDesc.equals(newMemberDesc))) {
			// Remove the old member
			Log.debug("User changed member definition name or desc when inserting a new member");
			if (isMethod) {
				for(int i = 0; i < existingNode.methods.size(); i++) {
					MethodNode existingMethod = existingNode.methods.get(i);
					if(existingMethod.name.equals(memberName) && existingMethod.desc.equals(memberDesc)) {
						existingNode.methods.remove(i);
						return i;
					}
				}
			} else {
				for(int i = 0; i < existingNode.fields.size(); i++) {
					FieldNode existingField = existingNode.fields.get(i);
					if(existingField.name.equals(memberName) && existingField.desc.equals(memberDesc)) {
						existingNode.fields.remove(i);
						return i;
					}
				}
			}
		}
		return -1;
	}

	protected void updateOrInsert(String newMemberName, String newMemberDesc, ClassNode existingNode, int removedIdx) {
		boolean found = false;
		if (isMethod) {
			// Reinsert at the location if the method was removed due to a definition change
			if (removedIdx >= 0) {
				existingNode.methods.add(removedIdx, currentMethod);
				return;
			}
			// Overwrite if its been added and we're making an change
			for(int i = 0; i < existingNode.methods.size(); i++) {
				MethodNode existingMethod = existingNode.methods.get(i);
				if(existingMethod.name.equals(newMemberName) && existingMethod.desc.equals(newMemberDesc)) {
					Comments.removeComments(existingMethod);
					ClassUtil.copyMethodMetadata(existingMethod, currentMethod);
					existingNode.methods.set(i, currentMethod);
					found = true;
					break;
				}
			}
			// Add if no method match
			if(!found) {
				existingNode.methods.add(currentMethod);
			}
		} else {
			// Reinsert at the location if the field was removed due to a definition change
			if (removedIdx >= 0) {
				existingNode.fields.add(removedIdx, currentField);
				return;
			}
			// Overwrite if its been added and we're making an change
			for(int i = 0; i < existingNode.fields.size(); i++) {
				FieldNode existingField = existingNode.fields.get(i);
				if(existingField.name.equals(newMemberName) && existingField.desc.equals(newMemberDesc)) {
					ClassUtil.copyFieldMetadata(currentField, existingField);
					existingNode.fields.set(i, currentField);
					found = true;
					break;
				}
			}
			// Add if no field match
			if(!found) {
				existingNode.fields.add(currentField);
			}
		}
	}

	/**
	 * @return Last assembler parse result.
	 */
	public ParseResult<RootAST> getLastParse() {
		return lastParse;
	}

	/**
	 * Called by the error handler to notify the UI of error status.
	 *
	 * @param exceptions
	 * 		Errors reported.
	 */
	public void onErrorsReceived(List<LineException> exceptions) {
		if (exceptions == null || exceptions.isEmpty()) {
			ColorAdjust colorAdjust = new ColorAdjust();
			colorAdjust.setBrightness(-0.7);
			colorAdjust.setSaturation(-0.8);
			errorGraphic.setEffect(colorAdjust);
		} else {
			errorGraphic.setEffect(null);
			stackHelper.setErrored();
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeErrorHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.struct.*;

import java.util.*;

/**
 * Bytecode-focused error handling.
 *
 * @author Matt
 */
public class BytecodeErrorHandling extends ErrorHandling {
	private final BytecodeEditorPane bytecodePane;

	/**
	 * @param bytecodePane
	 * 		Pane to handle errors for.
	 */
	public BytecodeErrorHandling(BytecodeEditorPane bytecodePane) {
		super(bytecodePane);
		this.bytecodePane = bytecodePane;
	}

	@Override
	protected void handleCodeChangeError(Throwable ex) {
		if (ex == null)
			updateProblems(null);
		else if (ex instanceof LineException) {
			// Handle displaying errors
			AssemblerException aex = (AssemblerException) ex;
			if(aex.getSubExceptions().isEmpty())
				updateProblems(Collections.singletonList(aex));
			else
				updateProblems(aex.getSubExceptions());
		} else {
			updateProblems(Collections.singletonList(new AssemblerException(ex,
					"Uncaught exception in assembler", -1)));
			// Log this because this is something we have to fix, not the user
			Log.error(ex, "Uncaught exception in assembler");
		}
	}

	/**
	 * Update latest problems.
	 *
	 * @param exceptions
	 * 		Assembler problems.
	 */
	private void updateProblems(List<LineException> exceptions) {
		// Notify UI
		bytecodePane.onErrorsReceived(exceptions);
		// Convert problem to <Line:Message> format
		if(exceptions == null)
			setProblems(Collections.emptyList());
		else {
			List<Pair<Integer, String>> problems = new ArrayList<>(exceptions.size());
			exceptions.forEach(ex -> {
				Throwable loggedException = (Throwable) ex;
				// Fetch cause line
				int line = ex.getLine();
				if (line == -1) {
					Throwable tmpException = loggedException;
					while(tmpException.getCause() != null) {
						tmpException = tmpException.getCause();
						if (tmpException instanceof LineException) {
							int exxLine = ((LineException) tmpException).getLine();
							if (exxLine != -1) {
								loggedException = tmpException;
								line = exxLine;
							}
						}
					}
					// Couldn't determine cause line, likely an internal error.
					if (line == -1)  {
						Log.error(loggedException, "Unrecognized exception thrown when assembling method");
					}
				}
				// Fetch root message
				while (loggedException.getCause() instanceof ASTParseException)
					loggedException = loggedException.getCause();
				String msg = loggedException.getMessage();
				markProblem(ex);
				problems.add(new Pair<>(line - 1, msg));
			});
			setProblems(problems);
		}
	}

	/**
	 * @param ex
	 * 		Assembler problem.
	 */
	private void markProblem(LineException ex) {
		int index = ex.getLine() - 1;
		if (index < 0)
			return;
		int len = codeArea.getParagraph(index).length();
		int literalStart =  codeArea.position(index, 0).toOffset();
		markProblem(index, 0, len, literalStart, ex.getMessage());
	}

	@Override
	protected void toggleErrorDisplay() {
		// Do nothing
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeLocalHelper.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.beans.property.SimpleObjectProperty;
import javafx.scene.control.*;
import me.coley.recaf.parse.bytecode.MethodAssembler;
import me.coley.recaf.parse.bytecode.ast.AST;
import me.coley.recaf.parse.bytecode.ast.LabelAST;
import me.coley.recaf.parse.bytecode.ast.VarInsnAST;
import me.coley.recaf.ui.controls.ActionMenuItem;
import me.coley.recaf.util.LangUtil;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LocalVariableNode;

import static me.coley.recaf.util.LangUtil.translate;

/**
 * UI component that displays variable information.
 *
 * @author Matt
 */
public class BytecodeLocalHelper extends TableView<LocalVariableNode> {
	private final BytecodeEditorPane parent;
	private MethodAssembler assembler;
	private ContextMenu ctxMenu;

	/**
	 * @param parent
	 * 		Parent editor pane this belongs to.
	 */
	public BytecodeLocalHelper(BytecodeEditorPane parent) {
		this.parent = parent;
		getStyleClass().add("monospaced");
		// Column setup
		TableColumn<LocalVariableNode, Integer> colIndex =
				new TableColumn<>(translate("ui.bean.method.localvariable.index"));
		TableColumn<LocalVariableNode, LabelNode> colStart =
				new TableColumn<>(translate("ui.bean.method.localvariable.start"));
		TableColumn<LocalVariableNode, LabelNode> colEnd =
				new TableColumn<>(translate("ui.bean.method.localvariable.end"));
		TableColumn<LocalVariableNode, String> colName =
				new TableColumn<>(translate("ui.bean.method.localvariable.name"));
		TableColumn<LocalVariableNode, String> colDesc =
				new TableColumn<>(translate("ui.bean.method.localvariable.desc"));
		colIndex.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().index));
		colName.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().name));
		colDesc.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().desc));
		colStart.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().start));
		colEnd.setCellValueFactory(c -> new SimpleObjectProperty<>(c.getValue().end));
		colStart.setCellFactory(col -> new TableCell<LocalVariableNode, LabelNode>() {
			@Override
			public void updateItem(LabelNode item, boolean empty) {
				super.updateItem(item, empty);
				if (item == null) {
					setText(null);
				} else if (assembler != null) {
					LabelAST ast = assembler.getCompilation().getLabelAst(item);
					setText(ast == null ? "?" : ast.getName().print());
				} else {
					setText("?");
				}
			}
		});
		colEnd.setCellFactory(colStart.getCellFactory());
		getColumns().add(colIndex);
		getColumns().add(colStart);
		getColumns().add(colEnd);
		getColumns().add(colName);
		getColumns().add(colDesc);
		// Row setup
		setRowFactory(t -> new TableRow<LocalVariableNode>() {
			@Override
			protected void updateItem(LocalVariableNode item, boolean empty) {
				super.updateItem(item, empty);
				// Register double click action
				setOnMousePressed(e -> {
					if (e.getClickCount() == 2 && e.isPrimaryButtonDown()) {
						// Goto first usage
						for (AST ast : parent.getLastParse().getRoot().getChildren()) {
							if (ast instanceof VarInsnAST &&
									((VarInsnAST) ast).getVariableName().getName().equals(item.name)) {
								gotoAst(ast);
								return;
							}
						}
					}
				});
				// Show context menu
				setOnContextMenuRequested(e -> {
					// close old context menu
					if (ctxMenu != null)
						ctxMenu.hide();
					// No context menu if no parse
					if (parent.getLastParse() == null)
						return;
					// Show where local is used
					ctxMenu = new ContextMenu();
					Menu refs = new Menu(LangUtil.translate("ui.edit.method.referrers"));
					for (AST ast : parent.getLastParse().getRoot().getChildren()) {
						if (ast instanceof VarInsnAST &&
								((VarInsnAST) ast).getVariableName().getName().equals(item.name)) {
							MenuItem ref = new ActionMenuItem(ast.getLine() + ": " + ast.print(), () -> {
								gotoAst(ast);
							});
							refs.getItems().add(ref);
						}
					}
					if (refs.getItems().isEmpty())
						refs.setDisable(true);
					ctxMenu.getItems().add(refs);
					ctxMenu.show(this, e.getScreenX(), e.getScreenY());
				});
			}
		});
		// Sizing
		setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		colIndex.setMaxWidth(Integer.MAX_VALUE / 5.0);
		colStart.setMaxWidth(Integer.MAX_VALUE / 5.0);
		colEnd.setMaxWidth(Integer.MAX_VALUE / 5.0);
		colName.setMaxWidth(Integer.MAX_VALUE / 2.0);
		colDesc.setMaxWidth(Integer.MAX_VALUE);
	}

	private void gotoAst(AST ast) {
		int line = ast.getLine() - 1;
		parent.codeArea.moveTo(line, 0);
		parent.codeArea.requestFollowCaret();
	}

	/**
	 * Updates information in the table.
	 *
	 * @param assembler
	 * 		Most recent assembler instance.
	 */
	public void setMethodAssembler(MethodAssembler assembler) {
		this.assembler = assembler;
		getItems().clear();
		if (assembler.getLastCompile() == null)
			return;
		if (assembler.getLastCompile().localVariables != null)
			getItems().addAll(assembler.getLastCompile().localVariables);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeMemberInserterPane.java`:

```java
package me.coley.recaf.ui.controls.text;

import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.bytecode.parser.DefinitionParser;

/**
 * Bytecode-focused text editor for inserting new fields/methods.
 *
 * @author Matt
 */
public class BytecodeMemberInserterPane extends BytecodeEditorPane {
	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param className
	 * 		Name of class containing the method.
	 * @param isMethod
	 * 		Target member type flag.
	 */
	public BytecodeMemberInserterPane(GuiController controller, String className, boolean isMethod) {
		super(controller, className, isMethod ? "methodName" : "fieldName", isMethod ? "()V" : "Ljava/lang/Object;");
	}

	@Override
	public boolean disassemble() {
		if (isMethod) {
			setText(DefinitionParser.DEFINE + " " + memberName + memberDesc +"\n" +
					"START:\n" +
					"// Method code here\n" +
					"RETURN\n" +
					"END:\n");
		} else {
			setText(DefinitionParser.DEFINE + " " + memberDesc + " " + memberName);
		}
		forgetHistory();
		return true;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeStackHelper.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.application.Platform;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.BorderPane;
import me.coley.analysis.SimInterpreter;
import me.coley.analysis.value.AbstractValue;
import me.coley.analysis.value.NullConstantValue;
import me.coley.analysis.value.UninitializedValue;
import me.coley.recaf.parse.bytecode.MethodAnalyzer;
import me.coley.recaf.parse.bytecode.MethodAssembler;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.util.*;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.Frame;

/**
 * UI component that displays values on the stack and local variable indices.
 *
 * @author Matt
 */
public class BytecodeStackHelper extends SplitPane {
	private final BytecodeEditorPane parent;
	private final ListView<Integer> locals = new ListView<>();
	private final ListView<Integer> stack = new ListView<>();
	private Frame<AbstractValue> currentFrame;
	private MethodAssembler assembler;
	private int insnIndex;

	/**
	 * @param parent
	 * 		Bytecode panel parent, contains bytecode being analyzed.
	 */
	public BytecodeStackHelper(BytecodeEditorPane parent) {
		this.parent = parent;
		getStyleClass().add("monospaced");
		BorderPane localWrapper = new BorderPane(locals);
		BorderPane stackWrapper = new BorderPane(stack);
		localWrapper.setTop(new Label(LangUtil.translate("ui.edit.method.stackhelper.locals")));
		stackWrapper.setTop(new Label(LangUtil.translate("ui.edit.method.stackhelper.stack")));
		localWrapper.getTop().getStyleClass().add("bold");
		stackWrapper.getTop().getStyleClass().add("bold");
		getItems().addAll(localWrapper, stackWrapper);
		setDividerPositions(0.5);
		SplitPane.setResizableWithParent(locals, Boolean.FALSE);
		locals.setCellFactory(c -> new ValueCell(true));
		stack.setCellFactory(c -> new ValueCell(false));
	}

	/**
	 * @param assembler
	 * 		Assembler to pull frames from.
	 */
	public void setMethodAssembler(MethodAssembler assembler) {
		this.assembler = assembler;
		setDisable(false);
		update();
	}

	/**
	 * Called when the method assembler has reported errors.
	 */
	public void setErrored() {
		setDisable(true);
	}

	/**
	 * Called when the user selects a line. Updates the displayed content.
	 *
	 * @param line
	 * 		Selected line.
	 */
	public void setLine(int line) {
		if (assembler == null)
			return;
		int tmp = insnIndex;
		insnIndex = -1;
		// Find most recent selected item
		while(line > 0 && insnIndex == -1) {
			AbstractInsnNode insn = assembler.getInsn(line);
			if (insn != null)
				insnIndex = InsnUtil.index(insn);
			line--;
		}
		// Update if line changed
		if (tmp != insnIndex)
			update();
	}

	private void update() {
		// No valid instruction was found
		if (insnIndex == -1)
			return;
		// Skip if no prior compile
		if (assembler.getLastCompile() == null)
			return;
		// Skip abstract methods
		if (AccessFlag.isAbstract(assembler.getLastCompile().access))
			return;
		Frame<AbstractValue>[] frames = getFrames();
		if (frames == null) {
			if (isVerifyDisabled()) {
				// TODO: Warn user that verification is disabled. Enable it for more information.
				return;
			} else {
				Log.error(new IllegalStateException(),
						"Stack helper tried to display frames despite the method being non-verifiable.");
				return;
			}
		}
		if (insnIndex >= frames.length)
			return;
		// Update lists
		currentFrame = frames[insnIndex];
		Platform.runLater(() -> {
			locals.getItems().clear();
			stack.getItems().clear();
			if (currentFrame != null) {
				for (int i = 0; i < currentFrame.getLocals(); i++)
					locals.getItems().add(i);
				for (int i = 0; i < currentFrame.getStackSize(); i++)
					stack.getItems().add(i);
			}
		});
	}

	/**
	 * @return Method frames.
	 */
	private Frame<AbstractValue>[] getFrames() {
		Frame<AbstractValue>[] frames = assembler.getFrames();
		if (frames == null && isVerifyDisabled()) {
			// Generate the frames since the assembler didn't.
			try {
				MethodAnalyzer analyzer = new MethodAnalyzer(new SimInterpreter());
				analyzer.setSkipDeadCodeBlocks(false);
				frames = analyzer.analyze(assembler.getDeclaringType(), assembler.getLastCompile());
			} catch(Throwable t) {
				// We will allow failures. Users should enable verification for more information.
			}
		}
		return frames;
	}

	/**
	 * @return {@code true} when the user has assembly verification disabled/
	 */
	private boolean isVerifyDisabled() {
		return !parent.controller.config().assembler().verify;
	}

	/**
	 * Call for rendering analyzer values.
	 *
	 * @author Matt
	 */
	private class ValueCell extends ListCell<Integer> {
		private final boolean isLocal;

		public ValueCell(boolean isLocal) {
			this.isLocal = isLocal;
		}

		@Override
		protected void updateItem(Integer item, boolean empty) {
			super.updateItem(item, empty);
			if (empty) {
				setGraphic(null);
				setText(null);
			} else {
				try {
					AbstractValue value = isLocal ? currentFrame.getLocal(item) : currentFrame.getStack(item);
					StringBuilder sb = new StringBuilder();
					if (isLocal)
						sb.append(item).append(": ");
					if (value == null || value == UninitializedValue.UNINITIALIZED_VALUE) {
						setGraphic(new IconView("icons/uninitialized.png"));
						sb.append("Uninitialized");
					} else if (value instanceof NullConstantValue) {
						setGraphic(new IconView("icons/uninitialized.png"));
						sb.append("const-null");
					} else {
						setGraphic(new IconView(value.isPrimitive() ? "icons/primitive.png" : "icons/object.png"));
						Type type = value.getType();
						String simpleTypeName = EscapeUtil.escape(type.getClassName());
						if (simpleTypeName.contains("."))
							simpleTypeName = simpleTypeName.substring(simpleTypeName.lastIndexOf('.') + 1);
						sb.append(simpleTypeName);
						if (value.isValueResolved())
							sb.append(": ").append(EscapeUtil.escape(value.getValue().toString()));
					}
					setText(sb.toString());
				}catch(Throwable t) {
					setText("Error");
					Log.error(t, "Could not display {}:{}", isLocal ? "local" : "stack", item);
				}
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/BytecodeSuggestHandler.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.geometry.Bounds;
import javafx.scene.control.ListView;
import javafx.scene.input.KeyCode;
import javafx.stage.Popup;
import jregex.Matcher;
import jregex.Pattern;
import me.coley.recaf.parse.bytecode.Parse;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.util.OpcodeUtil;
import me.coley.recaf.util.RegexUtil;
import me.coley.recaf.util.struct.*;
import org.fxmisc.richtext.CodeArea;

import java.util.*;
import java.util.stream.Collectors;

import static javafx.scene.input.KeyCode.*;

/**
 * Bytecode-focused tab-completion/suggestion handling.
 *
 * @author Matt
 */
public class BytecodeSuggestHandler  {
	private static final int ROW_HEIGHT = 24;
	private final BytecodeEditorPane bytePane;
	private final CodeArea codeArea;
	private final Popup popAuto = new Popup();

	/**
	 * @param bytePane
	 * 		Pane to handle errors for.
	 */
	public BytecodeSuggestHandler(BytecodeEditorPane bytePane) {
		this.bytePane = bytePane;
		this.codeArea = bytePane.codeArea;
	}

	/**
	 * Setup suggestions for the editor.
	 */
	public void setup() {
		codeArea.setOnKeyReleased(e -> {
			// Update auto-complete on key-release except for certain non-modifying keys.
			KeyCode k = e.getCode();
			if (k == ESCAPE){
				// Remove popup if escape is pressed.
				popAuto.hide();
				e.consume();
				return;
			}
			if (k == BACK_SPACE){
				// Don't show popup if backspacing onto some text.
				popAuto.hide();
				return;
			}
			if (k != PERIOD && (k.isArrowKey() || k.isModifierKey() || k.isWhitespaceKey())) {
				// Pressing period and most normal keyboard characters will allow auto-completion
				// to be run. Arrow keys and misc. keys will not update it.
				if (k == SPACE)
					popAuto.hide();
				return;
			}
			// Hide popup and then update auto-completion.
			// This may re-show it if there are suggestions.
			popAuto.hide();
			updateAutoComplete();
		});
		codeArea.setOnKeyTyped(e -> {
			// Ensure directional / input keys are sent to the popup.
			KeyCode k = e.getCode();
			boolean move = k == UP || k == DOWN || k == ENTER || k == TAB;
			if (popAuto.isShowing() && move) {
				popAuto.requestFocus();
			}
		});
	}

	/**
	 * Update code-completion prompt.
	 */
	private void updateAutoComplete() {
		int position = codeArea.getCaretPosition();
		int line = codeArea.getCurrentParagraph();
		String lineText = codeArea.getParagraph(line).getText();
		// Ensure that the caret is at the end of the line.
		if (codeArea.getCaretColumn() < lineText.length()) {
			return;
		}
		ThreadAction.<List<String>>create().supplier(() -> {
			List<String> suggestions = null;
			try {
				suggestions = suggest(bytePane.getLastParse(), lineText);
			} catch(Exception e) {
				// If we fail, don't suggest anything
				return null;
			}
			// Limit capacity
			suggestions = suggestions.stream().limit(7).collect(Collectors.toList());
			return suggestions;
		}).consumer(suggestions -> {
			// No suggestions? Do nothing
			if (suggestions == null || suggestions.isEmpty()) {
				return;
			}
			ListView<String> listSuggestions = new ListView<>(FXCollections.observableArrayList(suggestions));
			listSuggestions.getStyleClass().add("tab-complete");
			listSuggestions.getSelectionModel().select(0);
			listSuggestions.setPrefHeight(suggestions.size() * ROW_HEIGHT + 2);
			// Get current word
			Matcher m = new Pattern("([\\/\\w]+|(?!\\.))$").matcher(lineText);
			if(!m.find()) {
				return;
			}
			String curWord = m.group(0);
			// Action to replace the word with some given replacement word.
			Runnable replace = () -> {
				String selected = listSuggestions.getSelectionModel().getSelectedItem();
				Platform.runLater(() -> {
					codeArea.replaceText(position - curWord.length(), position, selected);
					codeArea.moveTo(position + selected.length() - curWord.length());
				});
				popAuto.hide();
			};
			Optional<Bounds> val = codeArea.caretBoundsProperty().getValue();
			if (!val.isPresent())
				return;
			Bounds pointer = val.get();
			popAuto.getContent().clear();
			popAuto.getContent().add(listSuggestions);
			listSuggestions.setOnMouseClicked(e -> replace.run());
			listSuggestions.setOnKeyPressed(e -> {
				if(e.getCode() == ENTER || e.getCode() == TAB) {
					replace.run();
				}
			});
			popAuto.show(codeArea, pointer.getMaxX(), pointer.getMinY());
		}).onUi().run();
	}

	private static List<String> suggest(ParseResult<RootAST> ast, String line) {
		String firstToken = Objects.requireNonNull(RegexUtil.getFirstWord(line));
		// Suggest opcodes
		if (!line.contains(" "))
			return OpcodeUtil.getInsnNames().stream()
					.filter(n -> n.startsWith(firstToken) && !firstToken.equals(n))
					.collect(Collectors.toList());
		// Create dummy AST if needed
		if (ast == null)
			ast = Parse.parse("");
		try {
			String lastToken = Objects.requireNonNull(RegexUtil.getLastWord(line));
			return Parse.getParser(-1, firstToken).suggest(ast, line).stream()
						.filter(option -> !lastToken.equals(option))
						.collect(Collectors.toList());
		} catch(Exception ex) {
			return Collections.emptyList();
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/ContextHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.application.Platform;
import javafx.scene.input.MouseButton;
import javafx.stage.Window;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.RenamingTextField;
import me.coley.recaf.ui.controls.text.selection.ClassSelection;
import me.coley.recaf.ui.controls.text.selection.MemberSelection;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.workspace.JavaResource;
import org.fxmisc.richtext.CharacterHit;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.model.TwoDimensional;

import java.util.function.Consumer;

/**
 * Generic context handler.
 *
 * @author Matt
 */
public abstract class ContextHandling {
	protected final GuiController controller;
	protected final CodeArea codeArea;
	private Consumer<Object> consumer;

	/**
	 * @param controller
	 * 		Controller to use.
	 * @param codeArea
	 * 		Text editor events originate from.
	 */
	public ContextHandling(GuiController controller, CodeArea codeArea) {
		this.codeArea = codeArea;
		this.controller = controller;
		codeArea.setOnMousePressed(e -> {
			// Only accept right-click presses
			if (e.getButton() != MouseButton.SECONDARY)
				return;
			// Reset
			codeArea.setContextMenu(null);
			// Mouse to location
			CharacterHit hit = codeArea.hit(e.getX(), e.getY());
			int charPos = hit.getInsertionIndex();
			codeArea.getCaretSelectionBind().displaceCaret(charPos);
			TwoDimensional.Position pos = codeArea.offsetToPosition(charPos,
					TwoDimensional.Bias.Backward);
			// Get selection
			Object selection = getSelection(pos);
			if (selection == null)
				return;
			if (consumer != null)
				consumer.accept(selection);
		});
	}

	/**
	 * Goto the selected item's definition.
	 */
	public void gotoSelectedDef() {
		Object selection = getCurrentSelection();
		// Goto class or member definition
		if (selection instanceof ClassSelection) {
			String owner = ((ClassSelection) selection).name;
			JavaResource resource = controller.getWorkspace().getContainingResourceForClass(owner);
			controller.windows().getMainWindow().openClass(resource, owner);
		} else if (selection instanceof MemberSelection) {
			MemberSelection ms = (MemberSelection) selection;
			JavaResource resource = controller.getWorkspace().getContainingResourceForClass(ms.owner);
			ClassViewport view = controller.windows().getMainWindow().openClass(resource, ms.owner);
			Platform.runLater(() -> view.selectMember(ms.name, ms.desc));
		}
	}

	/**
	 * Open rename field for the class.
	 */
	public void openRenameInput() {
		Object selection = getCurrentSelection();
		Window main = controller.windows().getMainWindow().getStage();
		// Goto class or member definition
		if (selection instanceof ClassSelection) {
			String name = ((ClassSelection) selection).name;
			RenamingTextField popup = RenamingTextField.forClass(controller, name);
			popup.show(main);
		} else if (selection instanceof MemberSelection) {
			MemberSelection ms = (MemberSelection) selection;
			String owner = ms.owner;
			String name = ms.name;
			String desc = ms.desc;
			RenamingTextField popup = RenamingTextField.forMember(controller, owner, name, desc);
			popup.show(main);
		}
	}

	/**
	 * @return Selection value at current caret position.
	 */
	protected abstract Object getSelection(TwoDimensional.Position pos);

	/**
	 * @return Selection value at current caret position.
	 */
	protected abstract Object getCurrentSelection();

	/**
	 * @param consumer
	 * 		Action to take when the user interacts with some selected content.
	 */
	protected void onContextRequest(Consumer<Object> consumer) {
		this.consumer = consumer;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/CssContextHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import me.coley.recaf.control.gui.GuiController;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.model.TwoDimensional;

/**
 * Context menu handler for {@link CssThemeEditorPane}.
 *
 * @author Matt
 */
public class CssContextHandling extends ContextHandling {
	/**
	 * @param controller
	 * 		Controller to use.
	 * @param codeArea
	 * 		Controller to pull info from.
	 */
	public CssContextHandling(GuiController controller, CodeArea codeArea) {
		super(controller, codeArea);
	}

	@Override
	protected Object getSelection(TwoDimensional.Position pos) {
		return null;
	}

	@Override
	protected Object getCurrentSelection() {
		return null;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/CssErrorHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import me.coley.recaf.util.struct.Pair;
import org.w3c.css.sac.CSSParseException;

import java.util.Collections;

/**
 * Css-focused error handling.
 *
 * @author Matt
 */
public class CssErrorHandling extends ErrorHandling {
	/**
	 * @param textPane
	 * 		Pane to handle errors for.
	 */
	public CssErrorHandling(CssThemeEditorPane textPane) {
		super(textPane);
	}

	@Override
	protected void handleCodeChangeError(Throwable ex) {
		if (ex == null)
			// Clear displayed errors
			updateProblem(null);
		else if (ex instanceof CSSParseException) {
			// Handle displaying errors
			updateProblem((CSSParseException)ex);
		}
	}

	/**
	 * Update problem.
	 */
	private void updateProblem(CSSParseException ex) {
		// No problem.
		if (ex == null) {
			setProblems(Collections.emptyList());
			return;
		}
		// Convert problem to <Line:Message> format
		//  - Yeah, line needs a -2 offset for some reason.
		setProblems(Collections.singletonList(new Pair<>(ex.getLineNumber() - 2, ex.getMessage())));
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/CssThemeEditorPane.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.steadystate.css.parser.CSSOMParser;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.ExceptionAlert;
import me.coley.recaf.ui.controls.text.model.Languages;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.UiUtil;
import org.apache.commons.io.FileUtils;
import org.w3c.css.sac.CSSException;
import org.w3c.css.sac.CSSParseException;
import org.w3c.css.sac.ErrorHandler;
import org.w3c.css.sac.InputSource;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;

/**
 * Css-focused text editor. Used to update a custom theme.
 *
 * @author Matt
 */
public class CssThemeEditorPane extends EditorPane<CssErrorHandling, CssContextHandling> {
	private static final String THEME_NAME = "custom";
	private static final File THEME_FILE =
			Recaf.getDirectory("style").resolve("ui-" + THEME_NAME + ".css").toFile();

	/**
	 * @param controller
	 * 		Controller to act on.
	 */
	public CssThemeEditorPane(GuiController controller) {
		super(controller, Languages.find("css"), (c, t) -> null);
		setEditable(true);
		setErrorHandler(new CssErrorHandling(this));
		setOnCodeChange(text -> getErrorHandler().onCodeChange(() -> {
			InputSource cssSource = new InputSource(new StringReader(text));
			CSSOMParser parser = new CSSOMParser();
			parser.setErrorHandler(new ErrorHandler() {
				@Override
				public void warning(CSSParseException exception) throws CSSException {
					throw exception;
				}

				@Override
				public void error(CSSParseException exception) throws CSSException {
					throw exception;
				}

				@Override
				public void fatalError(CSSParseException exception) throws CSSException {
					throw exception;
				}
			});
			parser.parseStyleSheet(cssSource, null, null);
			// TODO: Does this throw exceptions for illegal CSS?
			//  - Update CssErrorHandling
		}));
		setOnKeyReleased(e -> {
			if(controller.config().keys().save.match(e))
				save();
		});
		// Load existing theme content
		try {
			if(THEME_FILE.exists())
				setText(FileUtils.readFileToString(THEME_FILE, StandardCharsets.UTF_8));
			else
				setText("/* ======== Custom theme ======== \n" +
						" * Tips:\n" +
						" *  - Change theme to custom in config to see live changes\n" +
						" *  - Located at: " + THEME_FILE.getAbsolutePath() + "\n" +
						" */");
		} catch(IOException ex) {
			Log.error(ex, "Failed to load custom theme");
		}

	}

	/**
	 * Apply the current CSS.
	 */
	private void save() {
		String css = getText();
		if (!THEME_FILE.getParentFile().exists())
			THEME_FILE.getParentFile().mkdir();
		// Save and reload
		try {
			FileUtils.write(THEME_FILE, css, StandardCharsets.UTF_8);
			if (controller.config().display().appStyle.getFileName().equals("ui-" + THEME_NAME + ".css"))
				controller.windows().reapplyStyles();
			UiUtil.animateSuccess(getCenter(), 500);
		} catch(Exception ex) {
			UiUtil.animateFailure(getCenter(), 500);
			ExceptionAlert.show(ex, "Failed to save custom theme");
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/EditorPane.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.application.Platform;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.SearchBar;
import me.coley.recaf.ui.controls.text.model.*;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.util.struct.Pair;
import org.fxmisc.flowless.VirtualizedScrollPane;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import org.fxmisc.wellbehaved.event.EventPattern;
import org.fxmisc.wellbehaved.event.InputMap;
import org.fxmisc.wellbehaved.event.Nodes;

import java.awt.Toolkit;
import java.util.function.*;

/**
 * Text editor panel.
 *
 * @param <E>
 * 		Error handler type.
 * @param <C>
 *     	Context handler type.
 *
 * @author Matt
 */
public class EditorPane<E extends ErrorHandling, C extends ContextHandling> extends BorderPane {
	protected final GuiController controller;
	protected final CodeArea codeArea = new CodeArea();
	protected final C contextHandler;
	protected final BorderPane bottomContent = new BorderPane();
	protected final ErrorList errorList = new ErrorList(this);
	protected final SplitPane split;
	private final SearchBar search = new SearchBar(codeArea::getText);
	private Consumer<String> onCodeChange;
	private E errHandler;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param language
	 * 		Type of text content.
	 * @param handlerFunc
	 * 		Function to supply the context handler.
	 */
	public EditorPane(GuiController controller, Language language, BiFunction<GuiController, CodeArea, C> handlerFunc) {
		this.controller = controller;
		this.contextHandler = handlerFunc.apply(controller, codeArea);
		getStyleClass().add("editor-pane");
		setupCodeArea(language);
		setupSearch();
		VirtualizedScrollPane<CodeArea> scroll = new VirtualizedScrollPane<>(codeArea);
		split = new SplitPane(scroll, bottomContent);
		split.setOrientation(Orientation.VERTICAL);
		split.setDividerPositions(1);
		split.getStyleClass().add("no-border");
		setupBottomContent();
		setCenter(split);
	}

	protected void setupBottomContent() {
		bottomContent.setCenter(errorList);
		SplitPane.setResizableWithParent(bottomContent, Boolean.FALSE);
	}

	private void setupCodeArea(Language language) {
		codeArea.setEditable(false);
		codeArea.getStyleClass().add("monospaced");
		IntFunction<Node> lineFactory = LineNumberFactory.get(codeArea,
				digits -> "%1$" + digits + "s", null, null);

		IntFunction<Node> errorFactory = new ErrorIndicatorFactory();
		IntFunction<Node> decorationFactory = line -> {
			HBox hbox = new HBox(
					lineFactory.apply(line),
					errorFactory.apply(line));
			hbox.setAlignment(Pos.CENTER_LEFT);
			return hbox;
		};
		Platform.runLater(() -> codeArea.setParagraphGraphicFactory(decorationFactory));
		LanguageStyler styler = new LanguageStyler(language);
		codeArea.richChanges()
				.filter(ch -> !ch.isPlainTextIdentity())
				.filter(ch -> !ch.getInserted().equals(ch.getRemoved()))
				.subscribe(change -> ThreadUtil.runSupplyConsumer(() -> {
					if(onCodeChange != null)
						onCodeChange.accept(codeArea.getText());
					return styler.computeStyle(codeArea.getText());
				}, computedStyle -> codeArea.setStyleSpans(0, computedStyle)));
		// So, tabs are hard-coded to be 8-characters wide visually until JavaFX 14
		// Its not great, but using 4 actual spaces is a good enough solution.
		InputMap<KeyEvent> im = InputMap.consume(
				EventPattern.keyPressed(KeyCode.TAB),
				e -> codeArea.replaceSelection("    ")
		);
		Nodes.addInputMap(codeArea, im);
	}

	private void setupSearch() {
		setOnKeyPressed(e -> {
			if(controller.config().keys().find.match(e)) {
				// On search bind:
				//  - open search field if necessary
				//  - select search field text
				boolean open = getTop() != null && getTop().equals(search);
				if(!open)
					setTop(search);
				search.setText(codeArea.getSelectedText());
				search.focus();
			}
		});
		search.setOnEscape(() -> {
			// Escape -> Hide field
			search.clear();
			codeArea.requestFocus();
			setTop(null);
		});
		search.setOnSearch(results -> {
			// On search, goto next result
			int caret = codeArea.getCaretPosition();
			Pair<Integer, Integer> range = results.next(caret);
			if (range == null) {
				// No results
				Toolkit.getDefaultToolkit().beep();
			} else {
				// Move caret to result range
				codeArea.selectRange(range.getKey(), range.getValue());
				codeArea.requestFollowCaret();
			}
		});
	}

	/**
	 * Simple call to scroll to the top of the code-area.
	 */
	public void scrollToTop() {
		codeArea.scrollToPixel(1, 1);
	}

	/**
	 * Forgets history.
	 */
	public void forgetHistory() {
		codeArea.getUndoManager().forgetHistory();
	}

	/**
	 * @return Text content
	 */
	public String getText() {
		return codeArea.getText();
	}

	/**
	 * @param text
	 * 		Text content.
	 */
	public void setText(String text) {
		codeArea.replaceText(text);
	}

	/**
	 * @param text
	 * 		Text content to append.
	 */
	public void appendText(String text) {
		codeArea.appendText(text);
	}

	/**
	 * @param wrap
	 * 		Should text wrap lines.
	 */
	public void setWrapText(boolean wrap) {
		codeArea.setWrapText(wrap);
	}

	/**
	 * @param editable
	 * 		Should text be editable.
	 */
	public void setEditable(boolean editable) {
		codeArea.setEditable(editable);
	}

	/**
	 * @param onCodeChange
	 * 		Action to run when text is modified.
	 */
	protected void setOnCodeChange(Consumer<String> onCodeChange) {
		this.onCodeChange = onCodeChange;
	}

	/**
	 * @param errHandler
	 * 		Error handler.
	 */
	protected void setErrorHandler(E errHandler) {
		if (this.errHandler != null)
			this.errHandler.unbind();
		this.errHandler = errHandler;
		this.errHandler.bind(errorList);
	}

	/**
	 * @return The error handler instance.
	 */
	public E getErrorHandler() {
		return errHandler;
	}

	/**
	 * @return the CodeArea instance
	 */
	public CodeArea getCodeArea(){
		return codeArea;
	}

	protected boolean hasNoErrors() {
		if (errHandler == null)
			return true;
		return !errHandler.hasErrors();
	}

	private boolean hasError(int line) {
		if (hasNoErrors())
			return false;
		return errHandler.hasError(line);
	}

	private String getLineComment(int line) {
		if (hasNoErrors())
			return null;
		return errHandler.getLineComment(line);
	}

	/**
	 * Decorator factory for building error indicators.
	 */
	class ErrorIndicatorFactory implements IntFunction<Node> {
		private final double[] shape = new double[]{0, 0, 10, 5, 0, 10};

		@Override
		public Node apply(int lineNo) {
			Polygon poly = new Polygon(shape);
			poly.getStyleClass().add("cursor-pointer");
			poly.setFill(Color.RED);
			if(hasError(lineNo)) {
				String msg = getLineComment(lineNo);
				if(msg != null) {
					Tooltip.install(poly, new Tooltip(msg));
				}
			} else {
				poly.setVisible(false);
			}
			return poly;
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/ErrorCell.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.text.Text;
import me.coley.recaf.util.struct.Pair;
import org.fxmisc.richtext.CodeArea;

/**
 * Cell renderer.
 *
 * @author Matt
 */
public class ErrorCell extends ListCell<Pair<Integer, String>> {
	private final CodeArea codeArea;

	/**
	 * @param codeArea
	 * 		Code area containing the text with errors.
	 */
	public ErrorCell(CodeArea codeArea) {
		this.codeArea = codeArea;
	}

	@Override
	public void updateItem(Pair<Integer, String> item, boolean empty) {
		super.updateItem(item, empty);
		if(empty) {
			setText(null);
			setGraphic(null);
		} else {
			setText(item.getValue());
			int index = item.getKey();
			Node g = new Text(String.valueOf(index + 1));
			g.getStyleClass().addAll("bold", "error-cell");
			setGraphic(g);
			// on-click: go to line
			if(index >= 0) {
				setOnMouseClicked(me -> {
					codeArea.moveTo(index, 0);
					codeArea.requestFollowCaret();
					codeArea.requestFocus();
				});
			} else {
				setText(getText() + "\n(Cannot resolve line number from error)");
			}
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/ErrorHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.scene.NodeEventDispatcher;
import javafx.application.Platform;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.control.*;
import me.coley.recaf.util.ThreadUtil;
import me.coley.recaf.util.struct.Errorable;
import me.coley.recaf.util.struct.Pair;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.event.MouseOverTextEvent;

import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

/**
 * Error handling for {@link EditorPane} content.
 *
 * @author Matt
 */
public abstract class ErrorHandling {
	private static final double DEFAULT_ERROR_DISPLAY_PERCENT = 0.84;
	private static final int UPDATE_DELAY = 500;
	protected final CodeArea codeArea;
	private Future<?> updateThread;
	private List<Pair<Integer, String>> oldProblems = Collections.emptyList();
	private List<Pair<Integer, String>> problems = Collections.emptyList();
	private ListView<Pair<Integer, String>> errorList;

	/**
	 * @param editorPane
	 * 		Pane to handle errors for.
	 */
	public ErrorHandling(EditorPane editorPane) {
		this.codeArea = editorPane.codeArea;
	}

	/**
	 * @return {@code true} if errors have been found.
	 */
	public boolean hasErrors() {
		return !getProblems().isEmpty();
	}

	/**
	 * @param line
	 * 		Line to check.
	 *
	 * @return {@code true} if the error has an error.
	 */
	public boolean hasError(int line) {
		for(Pair<Integer, String> problem : getProblems()) {
			if(line == problem.getKey())
				return true;
		}
		return false;
	}

	/**
	 * @param line
	 * 		Line to check.
	 *
	 * @return Error message for line. {@code null} if none.
	 */
	public String getLineComment(int line) {
		for(Pair<Integer, String> problem : getProblems()) {
			if(line == problem.getKey())
				return problem.getValue();
		}
		return null;
	}

	/**
	 * Handle code change events.
	 *
	 * @param errorable
	 * 		Code change action that can produce errors.
	 */
	public void onCodeChange(Errorable<?> errorable) {
		// Because we need to clear old handlers for error-hover-messages
		clearOldEvents();
		// Check if new update thread needs to be spawned
		if (updateThread != null)
			updateThread.cancel(true);
		updateThread = ThreadUtil.runDelayed(UPDATE_DELAY, () -> {
			Platform.runLater(this::refreshProblemGraphics);
			try {
				// Attempt to run
				errorable.run();
				handleCodeChangeError(null);
			} catch(Throwable ex) {
				handleCodeChangeError(ex);
			}
			Platform.runLater(this::refreshProblemGraphics);
		});
		// Reset line items
		handleCodeChangeError(null);
	}

	/**
	 * Handle errors thrown by the {@link #onCodeChange(Errorable)}'s passed errorable function.
	 *
	 * @param ex
	 * 		The thrown exception.
	 */
	protected abstract void handleCodeChangeError(Throwable ex);

	/**
	 * Marks the given range with the <i>"error"</i> type.
	 *
	 * @param line
	 * 		Line the problem occured on.
	 * @param from
	 * 		Relative start position on line.
	 * @param to
	 * 		Relative end position on line.
	 * @param literalFrom
	 * 		Literal start position in string.
	 * @param message
	 * 		Message to supply pop-up window with.
	 */
	protected void markProblem(int line, int from, int to, int literalFrom, String message) {
		// Highlight the line & add the error indicator next to the line number
		Platform.runLater(() ->
				codeArea.setStyle(line, from, to, Collections.singleton("error"))
		);
		// Add tooltips to highlighted region
		Tooltip popup = new Tooltip(message);
		codeArea.addEventHandler(MouseOverTextEvent.MOUSE_OVER_TEXT_BEGIN, e -> {
			int charPos = e.getCharacterIndex();
			if(charPos >= literalFrom && charPos <= literalFrom + (to - from)) {
				Point2D pos = e.getScreenPosition();
				popup.show(codeArea, pos.getX(), pos.getY() + 10);
			}
		});
		codeArea.addEventHandler(MouseOverTextEvent.MOUSE_OVER_TEXT_END, e -> popup.hide());
	}

	/**
	 * Clear paragraphs's error graphics.
	 */
	protected void refreshProblemGraphics() {
		// combine old and new proble mlines
		Set<Integer> numbers = new HashSet<>();
		Set<Integer> problemLines = problems.stream().map(Pair::getKey).collect(Collectors.toSet());
		Set<Integer> oldPoblemLines = oldProblems.stream().map(Pair::getKey).collect(Collectors.toSet());
		numbers.addAll(problemLines);
		numbers.addAll(oldPoblemLines);
		// give some wiggle room for users adding/removing lines
		int range = 2;
		int max = codeArea.getParagraphs().size();
		for(int i : numbers)
			for(int p = i - range; p < i + range; p++)
				if(p >= 0 && p < max)
					codeArea.recreateParagraphGraphic(p);
	}

	/**
	 * This is cancer, but it works flawlessly. Tracking the handlers also sucks.
	 */
	protected void clearOldEvents() {
		try {
			Object handlerManager = ((NodeEventDispatcher)codeArea.getEventDispatcher()).getEventHandlerManager();
			Field handlerMap  = EventHandlerManager.class.getDeclaredField("eventHandlerMap");
			handlerMap.setAccessible(true);
			Map map = (Map) handlerMap.get(handlerManager);
			map.remove(MouseOverTextEvent.MOUSE_OVER_TEXT_BEGIN);
			map.remove(MouseOverTextEvent.MOUSE_OVER_TEXT_END);
		} catch(Exception exx) {
			exx.printStackTrace();
		}
	}

	/**
	 * @return Last reported problems.
	 */
	public List<Pair<Integer, String>> getProblems() {
		return problems;
	}

	/**
	 * @param problems
	 * 		New reported problems.
	 */
	public void setProblems(List<Pair<Integer, String>> problems) {
		this.oldProblems = this.problems;
		this.problems = problems;
		if (errorList != null)
			Platform.runLater(() -> {
				// Set problems
				errorList.getItems().setAll(problems);
				// Check if there is a UI component to update
				if (errorList.getParent() == null)
					return;
				// Update the error list display
				toggleErrorDisplay();
			});
	}

	/**
	 * Update error list, hiding it if no errors are found.
	 */
	protected void toggleErrorDisplay() {
		Node content = errorList;
		while (!(content instanceof SplitPane) && content != null)
			content = content.getParent();
		if (content == null)
			return;
		SplitPane parent = (SplitPane) content;
		if(problems.isEmpty())
			parent.setDividerPositions(1);
		else if(parent.getDividerPositions()[0] > 0.98)
			parent.setDividerPositions(DEFAULT_ERROR_DISPLAY_PERCENT);
	}

	/**
	 * Unbind {@link #errorList UI component} from error handling.
	 */
	public void unbind() {
		this.errorList = null;
	}

	/**
	 * Bind errrors to {@link #errorList UI component} .
	 *
	 * @param errorList
	 * 		UI component to display errors.
	 */
	public void bind(ListView<Pair<Integer, String>> errorList) {
		this.errorList = errorList;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/ErrorList.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.scene.control.ListView;
import me.coley.recaf.util.struct.Pair;

/**
 * Listview wrapper of errors, denoted by line number and message content.
 *
 * @author Matt
 */
public class ErrorList extends ListView<Pair<Integer, String>> {
	/**
	 * @param editorPaneOwner
	 * 		Panel that contains the code editor with marked errors.
	 */
	public ErrorList(EditorPane<?, ?> editorPaneOwner) {
		setCellFactory(e -> new ErrorCell(editorPaneOwner.codeArea));
		getStyleClass().add("error-list");
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/JavaContextHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.github.javaparser.resolution.SymbolResolver;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.ui.ContextBuilder;
import me.coley.recaf.ui.controls.view.ClassViewport;
import me.coley.recaf.ui.controls.text.selection.*;
import me.coley.recaf.util.JavaParserUtil;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.model.TwoDimensional;

import java.util.Optional;

import static me.coley.recaf.ui.ContextBuilder.menu;

/**
 * Context menu handler for {@link JavaEditorPane}.
 *
 * @author Matt
 */
public class JavaContextHandling extends ContextHandling {
	private SymbolResolver solver;
	private SourceCode code;

	/**
	 * @param controller
	 * 		Controller to pull info from.
	 * @param codeArea
	 * 		Text editor events originate from.
	 */
	public JavaContextHandling(GuiController controller, CodeArea codeArea) {
		super(controller, codeArea);
		// Fetch the solver so we can call it manually (see below for why)
		Optional<SymbolResolver> optSolver = controller.getWorkspace().getSourceParseConfig().getSymbolResolver();
		if (!optSolver.isPresent())
			throw new IllegalStateException("");
		this.solver = optSolver.get();
		// Set context selection action
		onContextRequest(selection -> {
			if (selection instanceof ClassSelection) {
				handleClassType((ClassSelection) selection);
			} else if (selection instanceof MemberSelection){
				handleMemberType((MemberSelection) selection);
			}
		});
	}

	@Override
	protected Object getSelection(TwoDimensional.Position pos) {
		return JavaParserUtil.getSelection(code, solver, pos);
	}

	@Override
	protected Object getCurrentSelection() {
		// Get selection at current position.
		TwoDimensional.Position pos = codeArea.offsetToPosition(codeArea.getCaretPosition(),
				TwoDimensional.Bias.Backward);
		return JavaParserUtil.getSelection(code, solver, pos);
	}

	/**
	 * @param code
	 * 		Analyzed code.
	 */
	public void setCode(SourceCode code) {
		this.code = code;
	}

	/**
	 * @return
	 *      Analyzed code.
	 */
	public SourceCode getCode() {
		return code;
	}

	private void handleClassType(ClassSelection selection) {
		codeArea.setContextMenu(menu().controller(controller)
				.view(getViewport())
				.declaration(selection.dec)
				.ofClass(selection.name));
	}

	private void handleMemberType(MemberSelection selection) {
		ContextBuilder cb = menu().controller(controller)
				.view(getViewport())
				.declaration(selection.dec);
		if (selection.method())
			codeArea.setContextMenu(cb.ofMethod(selection.owner, selection.name, selection.desc));
		else
			codeArea.setContextMenu(cb.ofField(selection.owner, selection.name, selection.desc));
	}

	private ClassViewport getViewport() {
		return (ClassViewport) codeArea.getParent().getParent().getParent().getParent().getParent();
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/JavaDocHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.github.javaparser.resolution.SymbolResolver;
import javafx.geometry.Point2D;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.javadoc.*;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.ui.controls.text.selection.ClassSelection;
import me.coley.recaf.ui.controls.text.selection.MemberSelection;
import me.coley.recaf.util.JavaParserUtil;
import org.fxmisc.richtext.event.MouseOverTextEvent;
import org.fxmisc.richtext.model.TwoDimensional;
import org.objectweb.asm.Type;

import java.util.Optional;

/**
 * On-hover JavaDoc handler.
 *
 * @author Matt
 */
public class JavaDocHandling {
	private final JavaEditorPane pane;
	private final SymbolResolver solver;
	private final SourceCode code;
	private Point2D last;

	/**
	 * @param pane
	 * 		Pane to handle JavaDoc on.
	 * @param controller
	 * 		Controller to pull docs from.
	 * @param code
	 * 		Analyzed code.
	 */
	public JavaDocHandling(JavaEditorPane pane, GuiController controller, SourceCode code) {
		this.pane = pane;
		// Fetch the solver so we can call it manually (see below for why)
		Optional<SymbolResolver> optSolver = controller.getWorkspace().getSourceParseConfig().getSymbolResolver();
		if (!optSolver.isPresent())
			throw new IllegalStateException("");
		this.solver = optSolver.get();
		this.code = code;
		// Set mouse-over event
		pane.codeArea.addEventHandler(MouseOverTextEvent.MOUSE_OVER_TEXT_BEGIN, e -> {
			last = e.getScreenPosition();
			// Get node from event position
			int charPos = e.getCharacterIndex();
			TwoDimensional.Position pos = pane.codeArea.offsetToPosition(charPos,
					TwoDimensional.Bias.Backward);
			// So the problem with "getSelection" is that internally it will resolve to the ACTUAL
			// proper descriptor... but in the JavaDocs, if we have generics, we can have a return type "T"
			// but in the descriptor it really is "java/lang/Object".
			Object selection = getSelection(pos);
			if(selection instanceof ClassSelection) {
				handleClassType(controller, (ClassSelection) selection);
			} else if(selection instanceof MemberSelection) {
				MemberSelection member = (MemberSelection) selection;
				if (member.method())
					handleMethodType(controller, member);
				else
					handleFieldType(controller, member);
			}
		});
	}

	protected Object getSelection(TwoDimensional.Position pos) {
		return JavaParserUtil.getSelection(code, solver, pos);
	}

	private void handleClassType(GuiController controller, ClassSelection selection) {
		Javadocs docs = controller.getWorkspace().getClassDocs(selection.name);
		if(docs == null)
			return;
		JavaDocWindow.ofClass(docs).show(pane, last.getX(), last.getY());
	}

	private void handleFieldType(GuiController controller, MemberSelection selection) {
		Javadocs docs = controller.getWorkspace().getClassDocs(selection.owner);
		if (docs == null)
			return;
		String type = simplify(Type.getType(selection.desc).getClassName());
		Optional<DocField> optField = docs.getFields().stream()
				.filter(f ->
						f.getType().equals(type) &&
						f.getName().equals(selection.name))
				.findFirst();
		optField.ifPresent(field -> JavaDocWindow.ofField(field).show(pane, last.getX(), last.getY()));
	}

	private void handleMethodType(GuiController controller, MemberSelection selection) {
		Javadocs docs = controller.getWorkspace().getClassDocs(selection.owner);
		if (docs == null)
			return;
		String retType = simplify(Type.getType(selection.desc).getReturnType().getClassName());
		Optional<DocMethod> optMethod = docs.getMethods().stream()
				.filter(f ->
						f.getReturnType().equals(retType) &&
						f.getName().equals(selection.name))
				.findFirst();
		optMethod.ifPresent(method -> JavaDocWindow.ofMethod(method).show(pane, last.getX(), last.getY()));
	}

	private String simplify(String qualified) {
		return qualified.contains(".") ?
				qualified.substring(qualified.lastIndexOf(".") + 1) : qualified;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/JavaDocWindow.java`:

```java
package me.coley.recaf.ui.controls.text;

import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import me.coley.recaf.parse.javadoc.*;
import me.coley.recaf.ui.controls.popup.DragPopup;

import java.util.stream.Collectors;

import static me.coley.recaf.util.StringUtil.indent;

/**
 * Draggable JavaDoc window.
 *
 * @author Matt
 */
public class JavaDocWindow extends DragPopup {
	private JavaDocWindow(ScrollPane content, Control handle) {
		super(content, handle);
	}

	/**
	 * @param docs
	 * 		Docs to build window from.
	 *
	 * @return Class JavaDocs window.
	 */
	public static JavaDocWindow ofClass(Javadocs docs) {
		// Build doc window
		VBox box = new VBox();
		ScrollPane root = new ScrollPane(box);
		// Class
		Label lblName = new Label(docs.getInternalName());
		Label lblNameDesc = new Label(docs.getDescription());
		lblNameDesc.setWrapText(true);
		lblName.getStyleClass().add("h1");
		lblNameDesc.getStyleClass().add("faint");
		box.getChildren().addAll(lblNameDesc);
		// Inheritance
		int indent = 1;
		Label lblInheritance = new Label("Inheritance");
		lblInheritance.getStyleClass().addAll("bold", "underlined");
		box.getChildren().add(lblInheritance);
		for (String name : docs.getInheritance()) {
			Label lblInherited = new Label(indent(indent, "  ") + name);
			lblInherited.getStyleClass().add("faint");
			box.getChildren().add(lblInherited);
			indent++;
		}
		// Subclasses
		// - one, two, three
		if (!docs.getSubclasses().isEmpty()) {
			Label lblSubclasses = new Label("Subclasses");
			lblSubclasses.getStyleClass().addAll("bold", "underlined");
			box.getChildren().add(lblSubclasses);
			VBox subs = new VBox();
			for(String name : docs.getSubclasses()) {
				Label lblSub = new Label(indent(1, "  ") + name);
				lblSub.getStyleClass().add("faint");
				subs.getChildren().add(lblSub);
			}
			box.getChildren().add(subs);
		}
		// Fields
		// - Type, name:
		// - Desc
		if (!docs.getFields().isEmpty()) {
			Label lblFields = new Label("Fields");
			lblFields.getStyleClass().addAll("bold", "underlined");
			box.getChildren().add(lblFields);
			VBox subs = new VBox();
			for(DocField field : docs.getFields()) {
				Label lblDef = new Label(indent(2, "  ") + field.getType() + " " + field.getName());
				Label lblDesc = new Label(indent(3, "  ") + field.getDescription());
				lblDesc.getStyleClass().add("faint");
				lblDesc.setWrapText(true);
				subs.getChildren().addAll(lblDef);
				if (!field.getDescription().trim().isEmpty())
					subs.getChildren().addAll(lblDesc);
			}
			box.getChildren().add(subs);
		}
		// Methods
		// - Return Type, name(args):
		// - Desc
		if (!docs.getMethods().isEmpty()) {
			Label lblMethods = new Label("Methods");
			lblMethods.getStyleClass().addAll("bold", "underlined");
			box.getChildren().add(lblMethods);
			VBox subs = new VBox();
			for(DocMethod method : docs.getMethods()) {
				String def = method.getReturnType() + " " + method.getName() + "(";
				def += method.getParameters().stream()
						.map(DocParameter::getName)
						.collect(Collectors.joining(", "));
				def += ")";
				Label lblDef = new Label(indent(2, "  ") + def);
				Label lblDesc = new Label(indent(3, "  ") + method.getDescription());
				lblDesc.getStyleClass().add("faint");
				lblDesc.setWrapText(true);
				subs.getChildren().add(lblDef);
				if (!method.getDescription().trim().isEmpty())
					subs.getChildren().add(lblDesc);
			}
			box.getChildren().add(subs);
		}
		return new JavaDocWindow(root, lblName);
	}

	/**
	 * @param field
	 * 		Docs to build window from.
	 *
	 * @return Field JavaDocs window.
	 */
	public static JavaDocWindow ofField(DocField field) {
		// Build doc window
		VBox box = new VBox();
		ScrollPane root = new ScrollPane(box);
		// Field
		Label lblDefinition = new Label(field.getType() + " " + field.getName());
		lblDefinition.getStyleClass().add("h1");
		if (field.getDescription() != null && !field.getDescription().isEmpty()) {
			Label lblDesc = new Label(field.getDescription());
			lblDesc.getStyleClass().add("faint");
			lblDesc.setWrapText(true);
			box.getChildren().addAll(lblDesc);
		}
		return new JavaDocWindow(root, lblDefinition);

	}

	/**
	 * @param method
	 * 		Docs to build window from.
	 *
	 * @return Method JavaDocs window.
	 */
	public static JavaDocWindow ofMethod(DocMethod method) {
		// Build doc window
		VBox box = new VBox();
		ScrollPane root = new ScrollPane(box);
		// Method
		String def = method.getReturnType() + " " + method.getName() + "(";
		def += method.getParameters().stream()
				.map(DocParameter::getName)
				.collect(Collectors.joining(", "));
		def += ")";
		Label lblDefinition = new Label(def);
		lblDefinition.getStyleClass().add("h1");
		// Description
		if (method.getDescription() != null && !method.getDescription().isEmpty()) {
			Label lblDesc = new Label(method.getDescription());
			lblDesc.getStyleClass().add("faint");
			lblDesc.setWrapText(true);
			box.getChildren().addAll(lblDesc);
		}
		// Parameters
		if (!method.getParameters().isEmpty()) {
			VBox subs = new VBox();
			Label lblParameters = new Label("Parameters");
			lblParameters.getStyleClass().addAll("bold", "underlined");
			box.getChildren().add(lblParameters);
			for(DocParameter parameter : method.getParameters()) {
				Label lblParamDef = new Label(indent(2, "  ") + parameter.getName());
				Label lblParamDesc = new Label(indent(3, "  ") + parameter.getDescription());
				lblParamDesc.getStyleClass().add("faint");
				lblParamDesc.setWrapText(true);
				subs.getChildren().add(lblParamDef);
				if (!parameter.getDescription().trim().isEmpty())
					subs.getChildren().add(lblParamDesc);
			}
			box.getChildren().add(subs);
		}
		// Return type
		Label lblReturn = new Label("Return");
		lblReturn.getStyleClass().addAll("bold", "underlined");
		Label lblReturnDesc = new Label(indent(2, "  ") + method.getReturnDescription());
		lblReturnDesc.getStyleClass().add("faint");
		box.getChildren().add(lblReturn);
		box.getChildren().add(lblReturnDesc);
		return new JavaDocWindow(root, lblDefinition);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/JavaEditorPane.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.github.javaparser.ParseResult;
import com.github.javaparser.Range;
import com.github.javaparser.ast.CompilationUnit;
import javafx.application.Platform;
import me.coley.recaf.compiler.JavacCompiler;
import me.coley.recaf.compiler.JavacTargetVersion;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.parse.source.SourceCodeException;
import me.coley.recaf.ui.controls.ClassEditor;
import me.coley.recaf.ui.controls.text.model.Languages;
import me.coley.recaf.util.*;
import me.coley.recaf.workspace.*;

import javax.tools.ToolProvider;
import java.util.*;

/**
 * Java-focused text editor.
 *
 * @author Matt
 */
public class JavaEditorPane extends EditorPane<JavaErrorHandling, JavaContextHandling> implements ClassEditor {
	public static final int HOVER_ERR_TIME = 50;
	public static final int HOVER_DOC_TIME = 700;
	private final JavaResource resource;
	private SourceCode code;
	private JavaDocHandling docHandler;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param resource
	 * 		Resource containing the code.
	 */
	public JavaEditorPane(GuiController controller, JavaResource resource) {
		this(controller, resource, null);
	}

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param resource
	 * 		Resource containing the code.
	 * @param initialText
	 * 		Initial text.
	 */
	public JavaEditorPane(GuiController controller, JavaResource resource, String initialText) {
		super(controller, Languages.find("java"), JavaContextHandling::new);
		this.resource = resource;
		if (initialText != null)
			setText(initialText);
		setErrorHandler(new JavaErrorHandling(this));
		setOnCodeChange(text -> getErrorHandler().onCodeChange(this::parseCode));
		setOnKeyReleased(e -> {
			if(controller.config().keys().gotoDef.match(e))
				contextHandler.gotoSelectedDef();
			else if(controller.config().keys().rename.match(e))
				contextHandler.openRenameInput();
		});
	}

	private void parseCode() throws SourceCodeException {
		code = new SourceCode(resource, getText());
		try {
			code.analyze(controller.getWorkspace());
			docHandler = new JavaDocHandling(this, controller, code);
			contextHandler.setCode(code);
		} catch (SourceCodeException e) {
			if (JavaParserUtil.isCompilationUnitParseable(code.getUnit())) {  // Also accept partial result
				docHandler = new JavaDocHandling(this, controller, code);
				contextHandler.setCode(code);
			} else if (contextHandler.getCode() == null) {  // If the code has never been parsed successfully before now
				ParseResult<CompilationUnit> parseResult = code.analyzeFiltered(controller.getWorkspace(),
						e.getResult().getProblems());
				if (parseResult.isSuccessful() || parseResult.getResult()
						.filter(JavaParserUtil::isCompilationUnitParseable).isPresent()) {
					docHandler = new JavaDocHandling(this, controller, code);
					contextHandler.setCode(code);

					// We've got the basics parsed and working. Time to reset the unit back to
					// the original source (with `contextHandler.getCode()` not longer null).
					// This will throw the same SourceCodeException
					parseCode();
				}
			}
			throw e;
		}
	}

	@Override
	public void setText(String text) {
		if (!canCompile())
			text = LangUtil.translate("ui.bean.class.recompile.unsupported") + text;
		if (!getText().equals(text))
			super.setText(text);
	}

	@Override
	public Map<String, byte[]> save(String name) {
		if (!canCompile())
			throw new UnsupportedOperationException("Recompilation not supported in read-only mode");
		int version = ClassUtil.getVersion(resource.getClasses().get(name));
		JavacCompiler javac = new JavacCompiler();
		javac.addToClassPath(resource);
		javac.addToClassPath(controller.getWorkspace().getLibraries());
		javac.addToClassPath(controller.getWorkspace().getPhantoms());
		javac.addUnit(name, getText());
		javac.options().lineNumbers = true;
		javac.options().variables = true;
		javac.options().sourceName = true;
		JavacTargetVersion classVersion = JavacTargetVersion.fromClassMajor(version);
		JavacTargetVersion minSupportedVersion = JavacTargetVersion.getMinJavacSupport();
		JavacTargetVersion maxSupportedVersion = JavacTargetVersion.getMaxJavacSupport();
		if (minSupportedVersion.ordinal() > classVersion.ordinal())
			classVersion = minSupportedVersion;
		if (maxSupportedVersion.ordinal() < classVersion.ordinal())
			classVersion = maxSupportedVersion;
		javac.options().setTarget(classVersion);
		javac.setCompileListener(getErrorHandler());
		if (javac.compile())
			return javac.getUnits();
		else
			throw new IllegalStateException("Failed compile due to compilation errors");
	}

	@Override
	public void selectMember(String name, String desc) {
		// Delay until analysis has run
		if (code == null) {
			// Reschedule the check
			try {
				Thread.sleep(50);
			} catch (Exception e) { /* ignored */ }
			ThreadUtil.run(() -> selectMember(name, desc));
			return;
		}

		// Select member if unit analysis was a success
		if (code.getUnit() != null) {
			// Jump to range if found
			Optional<Range> range = JavaParserUtil.getMemberRange(code.getUnit(), name, desc);
			if(range.isPresent()) {
				int line = range.get().begin.line - 1;
				int column = range.get().begin.column - 1;
				Platform.runLater(() -> {
					codeArea.moveTo(line, column);
					codeArea.requestFollowCaret();
					codeArea.requestFocus();
				});
			}
		}
	}

	/**
	 * Add the resource to the classpath.
	 *
	 * @param path
	 * 		Classpath to build on.
	 * @param resource
	 * 		Resource to add.
	 */
	private void add(List<String> path, JavaResource resource) {
		if (resource instanceof FileSystemResource) {
			FileSystemResource fsr = (FileSystemResource) resource;
			path.add(IOUtil.toString(fsr.getPath()));
		} else if (resource instanceof DeferringResource) {
			JavaResource deferred = ((DeferringResource) resource).getBacking();
			add(path, deferred);
		}
	}

	/**
	 * @return {@code true} if compilation is supported.
	 */
	public boolean canCompile() {
		return ToolProvider.getSystemJavaCompiler() != null;
	}

	/**
	 * @return Parsed &amp; analyzed code.
	 */
	public SourceCode getAnalyzedCode() {
		return code;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/JavaErrorHandling.java`:

```java
package me.coley.recaf.ui.controls.text;

import com.github.javaparser.*;
import javafx.application.Platform;
import me.coley.recaf.compiler.VirtualJavaFileObject;
import me.coley.recaf.parse.source.SourceCodeException;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.struct.Pair;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.time.Duration;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Java-focused error handling.
 *
 * @author Matt
 */
public class JavaErrorHandling extends ErrorHandling
		implements DiagnosticListener<VirtualJavaFileObject> {
	/**
	 * @param textPane
	 * 		Pane to handle errors for.
	 */
	public JavaErrorHandling(JavaEditorPane textPane) {
		super(textPane);
	}

	// Update javac problems
	@Override
	public void report(Diagnostic<? extends VirtualJavaFileObject> diagnostic) {
		// Skip non-errors
		if (diagnostic.getKind() != Diagnostic.Kind.ERROR)
			return;
		// Convert the diagnostic to location data
		// 0-index the line number
		int line = (int) diagnostic.getLineNumber() - 1;
		int column = (int) diagnostic.getColumnNumber();
		int literalStart = calculate(new Position(line + 1, column));
		// TODO: Properly fix this not fetching the correct section of text in weird cases
		String[] split = codeArea.getText().substring(literalStart).split("[^\\w.]+");
		int wordLength = split.length == 0 ? 1 : split[0].length();
		int to = column + wordLength;
		String msg = diagnostic.getMessage(Locale.ENGLISH);
		Diagnostic.Kind kind = diagnostic.getKind();
		switch(kind) {
			case ERROR:
			case WARNING:
			case MANDATORY_WARNING:
				Log.warn("Line {}, Col {}: {}", line, column, msg);
				break;
			case NOTE:
			case OTHER:
			default:
				Log.info("Line {}, Col {}: {}", line, column, msg);
				break;
		}
		getProblems().add(new Pair<>(line, msg));
		setProblems(getProblems());
		// Mark problem, 0-indexing the column
		markProblem(line, column - 1, to - 1, literalStart, msg);
		refreshProblemGraphics();
	}

	@Override
	protected void handleCodeChangeError(Throwable ex) {
		if (ex == null)
			// Clear displayed errors
			updateProblems(Collections.emptyList());
		else if (ex instanceof SourceCodeException) {
			// Handle displaying errors
			SourceCodeException sce = (SourceCodeException) ex;
			updateProblems(sce.getResult().getProblems());
			for(Problem problem : sce.getResult().getProblems())
				problem.getLocation().flatMap(TokenRange::toRange).ifPresent(r -> markProblem(problem, r));
		}
	}

	/**
	 * Update problems with JavaParser output.
	 *
	 * @param problems
	 * 		JavaParser problems.
	 */
	private void updateProblems(List<Problem> problems) {
		// Convert problem to <Line:Message> format
		setProblems(problems.stream().map(p -> {
			int key = -1;
			try {
				if (p.getLocation().isPresent()) {
					key = p.getLocation().get().getBegin().getRange().get().begin.line - 1;
				} else {
					// This is a hack to read the error message for the line number
					// when the line number is not directly given... yuck.
					String jpLineMsg = "at line ";
					if (p.getMessage().contains(jpLineMsg)) {
						String line = p.getMessage().substring(
								p.getMessage().indexOf(jpLineMsg) + jpLineMsg.length(),
								p.getMessage().indexOf(",")
						);
						key = Integer.parseInt(line) - 1;
					}
				}
			} catch (Exception ex) { /* ignored */ }
			String value = p.getMessage();
			return new Pair<>(key, value);
		}).collect(Collectors.toList()));
		// If there are problems, make on-hover timing nearly instant
		// - show errors immediately
		// - show non-errors after a delay
		int delay = problems.isEmpty() ? JavaEditorPane.HOVER_DOC_TIME : JavaEditorPane.HOVER_ERR_TIME;
		Platform.runLater(() -> codeArea.setMouseOverTextDelay(Duration.ofMillis(delay)));
	}

	/**
	 * @param problem
	 * 		JavaParser problem.
	 * @param range
	 * 		Range of problem.
	 */
	private void markProblem(Problem problem, Range range) {
		// Convert the JavaParser range to location data
		// - 0-index the line number
		int line = range.begin.line - 1;
		int literalStart = calculate(range.begin);
		int wordLength = codeArea.getText().substring(literalStart).split("[^\\w.]")[0].length();
		int from = range.begin.column - 1;
		int to = from + wordLength;
		//
		markProblem(line, from, to, literalStart, problem.getMessage());
	}

	/**
	 * @param position
	 * 		Javaparser row/column position.
	 *
	 * @return Index of position in entire string.
	 */
	private int calculate(Position position) {
		try (BufferedReader reader = new BufferedReader(new StringReader(codeArea.getText()))) {
			int distance = 0;
			for (int i = 1; i < position.line; i++)
				distance += reader.readLine().length() + 1;
			distance += position.column - 1;
			return distance;
		} catch (IOException e) {
			throw new AssertionError(e);
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/model/Language.java`:

```java
package me.coley.recaf.ui.controls.text.model;

import java.util.*;

/**
 * A collection of rules that match against a language's feature set and themes to apply distinct
 * styles to each of these rules.
 *
 * @author Geoff Hayward
 * @author Matt
 */
public class Language {
	private final List<Rule> rules;
	private final String name;
	private final boolean wrap;

	/**
	 * @param name
	 * 		Identifier.
	 * @param rules
	 * 		Rules for matching against language features.
	 * @param wrap
	 * 		Should text wrapping be enabled.
	 */
	public Language(String name, List<Rule> rules, boolean wrap) {
		if(name == null)
			throw new IllegalStateException("Language name must not be null");
		if(rules == null)
			throw new IllegalStateException("Language rule list must not be null");
		this.name = name;
		this.rules = rules;
		this.wrap = wrap;
	}

	/**
	 * @return Identifier.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Rules for matching against language features.
	 */
	public List<Rule> getRules() {
		return rules;
	}

	/**
	 * @return Should text wrapping be enabled.
	 */
	public boolean doWrap() {
		return wrap;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/model/LanguageStyler.java`:

```java
package me.coley.recaf.ui.controls.text.model;

import jregex.Matcher;
import jregex.Pattern;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.RegexUtil;
import org.fxmisc.richtext.model.StyleSpans;
import org.fxmisc.richtext.model.StyleSpansBuilder;

import java.util.*;

/**
 * Utility for applying a given theme to some text based on the given language rule-set.
 *
 * @author Matt
 */
public class LanguageStyler {
	private Language language;

	/**
	 * @param language
	 * 		Language with rules to apply to text.
	 */
	public LanguageStyler(Language language) {
		if(language == null)
			throw new IllegalStateException("Language must not be null");
		this.language = language;
	}

	/**
	 * @param text
	 * 		Text to apply styles to.
	 *
	 * @return Stylized regions of the text <i>(via css tags)</i>.
	 */
	public StyleSpans<Collection<String>> computeStyle(String text) {
		Matcher matcher = getPattern().matcher(text);
		int lastKwEnd = 0;
		StyleSpansBuilder<Collection<String>> spansBuilder = new StyleSpansBuilder<>();
		try {
			while(matcher.find()) {
				String styleClass = getClassFromGroup(matcher);
				if(styleClass == null)
					styleClass = "text";
				spansBuilder.add(Collections.emptyList(), matcher.start() - lastKwEnd);
				spansBuilder.add(Collections.singleton(styleClass), matcher.end() - matcher.start());
				lastKwEnd = matcher.end();
			}
		} catch(NullPointerException npe) {
			// There was once some odd behavior in 'matcher.find()' which caused NPE...
			// This seems to have been fixed, but we will check for regressions
			Log.error(npe, "Error occurred when computing styles:");
		}
		spansBuilder.add(Collections.emptyList(), text.length() - lastKwEnd);
		return spansBuilder.create();
	}

	/**
	 * @return Compiled regex pattern from {@link #getRules() all existing rules}.
	 */
	public Pattern getPattern() {
		if(getRules().isEmpty())
			return RegexUtil.pattern("({EMPTY}EMPTY)");
		StringBuilder sb = new StringBuilder();
		for(Rule rule : getRules())
			sb.append("({" + rule.getPatternGroupName() + "}" + rule.getPattern() + ")|");
		return RegexUtil.pattern(sb.substring(0, sb.length() - 1));
	}

	/**
	 * @return List of language rules.
	 */
	private List<Rule> getRules() {
		return language.getRules();
	}

	/**
	 * Fetch the CSS class name to use based on the matched group.
	 *
	 * @param matcher
	 * 		Matcher that has found a group.
	 *
	 * @return CSS class name <i>(Raw name of regex rule)</i>
	 */
	private String getClassFromGroup(Matcher matcher) {
		for(Rule rule : getRules())
			if(matcher.group(rule.getPatternGroupName()) != null)
				return rule.getName();
		return null;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/model/Languages.java`:

```java
package me.coley.recaf.ui.controls.text.model;

import com.eclipsesource.json.*;
import me.coley.recaf.util.Log;
import org.apache.commons.io.IOUtils;

import java.net.URL;
import java.util.*;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Utility for loading language style rulesets.
 *
 * @author Matt
 */
public class Languages {
	private static final Language NONE = new Language("none", Collections.emptyList(), true);
	private static final Map<String, Language> CACHE = new HashMap<>();

	/**
	 * @param key
	 * 		Name of language
	 *
	 * @return Language ruleset for styling.
	 */
	public static Language find(String key) {
		key = key.toLowerCase();
		// Check if already fetched
		Language language = CACHE.get(key);
		if(language != null)
			return language;
		// Attempt to read language file
		try {
			String file = "languages/" + key + ".json";
			URL url = Thread.currentThread().getContextClassLoader().getResource(file);
			// If file found, parse
			if(url != null) {
				String jsStr = IOUtils.toString(url.openStream(), UTF_8);
				JsonObject json = Json.parse(jsStr).asObject();
				language = parse(json);
			}
		} catch(Exception ex) {
			Log.error(ex, "Failed parsing language json for type '{}'", key);
		}
		// Update cache and return
		if (language == null)
			language = NONE;
		CACHE.put(key, language);
		return language;
	}

	private static Language parse(JsonObject json) {
		String name = json.getString("name", null);
		if (name == null)
			throw new IllegalArgumentException("Language JSON missing name");
		boolean wrap = json.getBoolean("wrap", true);
		JsonArray jsonArray = json.get("rules").asArray();
		List<Rule> rules = new ArrayList<>();
		jsonArray.forEach(arr -> {
			String ruleName = arr.asObject().getString("name", null);
			String rulePattern = arr.asObject().getString("pattern", null);
			rules.add(new Rule(ruleName, rulePattern));
		});
		return new Language(name, rules, wrap);
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/text/model/Rule.java`:

```java
package me.coley.recaf.ui.controls.text.model;

/**
 * Language rule that matches against a feature of a language using regex.
 *
 * @author Geoff Hayward
 * @author Matt
 */
public class Rule {
	private final String name;
	private final String pattern;

	/**
	 * @param name
	 * 		Identifier.
	 * @param pattern
	 * 		Pattern string to match.
	 */
	public Rule(String name, String pattern) {
		if(name == null)
			throw new IllegalStateException("Rule name must not be null");
		if(pattern == null)
			throw new IllegalStateException("Rule pattern must not be null");
		this.name = name;
		this.pattern = pattern;
	}

	/**
	 * @return Identifier.
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return Pattern string to match.
	 */
	public String getPattern() {
		return pattern;
	}

	/**
	 * @return Name as proper regex group title.
	 */
	public String getPatternGroupName() {
		return sterilize(name);
	}

	/**
	 * @param name
	 * 		Original name.
	 *
	 * @return Name stripped of invalid identifier characters. Allows the name to be used as a
	 * regex group name.
	 */
	private static String sterilize(String name) {
		return name.replaceAll("[\\W\\d]+", "").toUpperCase();
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/ClassSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

/**
 * Wrapper for selected classes.
 *
 * @author Matt
 */
public class ClassSelection {
	public final String name;
	public final boolean dec;

	/**
	 * @param name
	 * 		Internal class name.
	 * @param dec
	 * 		Is the name given as a declaration or reference.
	 */
	public ClassSelection(String name, boolean dec) {
		this.name = name;
		this.dec = dec;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/JumpSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

/**
 * Wrapper for selected jump instruction.
 *
 * @author Matt
 */
public class JumpSelection {
	public final String destination;

	/**
	 * @param destination
	 * 		Destination label name.
	 */
	public JumpSelection(String destination) {
		this.destination = destination;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/LabelSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

/**
 * Wrapper for selected label.
 *
 * @author Matt
 */
public class LabelSelection {
	public final String name;

	/**
	 * @param name
	 * 		Label name.
	 */
	public LabelSelection(String name) {
		this.name = name;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/MemberSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

/**
 * Wrapper for selected fields/methods.
 *
 * @author Matt
 */
public class MemberSelection {
	public final String owner;
	public final String name;
	public final String desc;
	public final boolean dec;

	/**
	 * @param owner
	 * 		Internal name of defining class.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 * @param dec
	 * 		Is the member declared or a reference.
	 */
	public MemberSelection(String owner, String name, String desc, boolean dec) {
		this.owner = owner;
		this.name = name;
		this.desc = desc;
		this.dec = dec;
	}

	/**
	 * @return {@code true} of the {@link #desc} is that of a method.
	 */
	public boolean method() {
		return desc.contains("(");
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/SwitchSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

import java.util.Map;

/**
 * Wrapper for selected switch instruction.
 *
 * @author Matt
 */
public class SwitchSelection {
	public final Map<String, String> mappings;
	public final String dflt;

	/**
	 * @param mappings
	 * 		Map of destinations and their key values.
	 * @param dflt
	 * 		Default destination.
	 */
	public SwitchSelection(Map<String, String> mappings, String dflt) {
		this.mappings = mappings;
		this.dflt = dflt;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/text/selection/VariableSelection.java`:

```java
package me.coley.recaf.ui.controls.text.selection;

/**
 * Wrapper for selected variable.
 *
 * @author Matt
 */
public class VariableSelection {
	public final String name;

	/**
	 * @param name
	 * 		Variable name.
	 */
	public VariableSelection(String name) {
		this.name = name;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/AnnoItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent annotations.
 *
 * @author Matt
 */
public class AnnoItem extends DirectoryItem {
	private final String name;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Local item name.
	 * @param name
	 * 		Full annotation name.
	 */
	public AnnoItem(JavaResource resource, String local, String name) {
		super(resource, local);
		this.name = name;
	}

	/**
	 * @return Contained class name.
	 */
	public String getAnnoName() {
		return name;
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof AnnoItem) {
			AnnoItem c = (AnnoItem) o;
			return name.compareTo(c.name);
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/BaseItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Tree item base.
 *
 * @author Matt
 */
public class BaseItem extends FilterableTreeItem<JavaResource> {
	/**
	 * @param resource
	 * 		The resource associated with the item.
	 */
	public BaseItem(JavaResource resource) {
		super(resource);
		setValue(resource);
	}

	/**
	 * For code clarity.
	 *
	 * @return JavaResource of the item.
	 */
	protected JavaResource resource() {
		return getValue();
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/CatchItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.search.Context;
import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent catch blocks.
 *
 * @author Matt
 */
public class CatchItem extends DirectoryItem {
	private final Context.CatchContext catchContext;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param catchContext
	 * 		The catch block context.
	 */
	public CatchItem(JavaResource resource, Context.CatchContext catchContext) {
		super(resource, catchContext.getType());
		this.catchContext = catchContext;
	}

	/**
	 * @return Catch block context.
	 */
	public Context.CatchContext getCatchContext() {
		return catchContext;
	}

	/**
	 * @return Catch block type.
	 */
	public String getCatchType() {
		return getCatchContext().getType();
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof CatchItem) {
			CatchItem c = (CatchItem) o;
			return getCatchContext().compareTo(c.getCatchContext());
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/ClassFolderItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.Recaf;
import me.coley.recaf.workspace.JavaResource;

import java.util.*;

/**
 * Tree item to contain class sub-items.
 *
 * @author Matt
 */
public class ClassFolderItem extends DirectoryItem {
	private final JavaResource resource = resource();

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 */
	public ClassFolderItem(JavaResource resource) {
		super(resource, "classes");
		// Add class sub-items in sorted order
		new TreeSet<>(resource.getClasses().keySet()).forEach(this::addClass);
	}

	protected void addClass(String name) {
		DirectoryItem item = this;
		List<String> parts = new ArrayList<>(Arrays.asList(name.split("/")));
		// Prune tree directory middle section if it is obnoxiously long
		int maxDepth = Recaf.getController().config().display().maxTreeDepth;
		if (parts.size() > maxDepth) {
			String lastPart = parts.get(parts.size() - 1);
			// We keep only elements between
			// [0..maxDepth-1] and the last part
			parts = new ArrayList<>(parts.subList(0, maxDepth - 1));
			parts.add("...");
			parts.add(lastPart);
		}
		// Build directory structure
		StringBuilder sb = new StringBuilder();
		while(!parts.isEmpty()) {
			String part = parts.remove(0);
			sb.append(part).append('.');
			boolean isLeaf = parts.isEmpty();
			DirectoryItem child = item.getChild(part, isLeaf);
			if(child == null) {
				child = isLeaf ?
						new ClassItem(resource, part, name) :
						new PackageItem(resource, part, sb.substring(0, sb.length() - 1));
				item.addChild(part, child, isLeaf);
			}
			item = child;
		}
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/ClassItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent classes.
 *
 * @author Matt
 */
public class ClassItem extends DirectoryItem {
	private final String name;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Local item name.
	 * @param name
	 * 		Full class name.
	 */
	public ClassItem(JavaResource resource, String local, String name) {
		super(resource, local);
		this.name = name;
	}

	/**
	 * @return Contained class name.
	 */
	public String getClassName() {
		return name;
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof ClassItem) {
			ClassItem c = (ClassItem) o;
			return name.compareTo(c.name);
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/DirectoryItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import javafx.scene.control.TreeItem;
import me.coley.recaf.workspace.JavaResource;

import java.util.*;

/**
 * Item to be used
 *
 * @author Matt
 */
public class DirectoryItem extends BaseItem implements Comparable<DirectoryItem> {
	// Differentiate directories and leaves to account for overlapping names.
	private final Map<String, DirectoryItem> localToDir = new HashMap<>();
	private final Map<String, DirectoryItem> localToLeaf = new HashMap<>();
	private final String local;


	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Partial name of item.
	 */
	public DirectoryItem(JavaResource resource, String local) {
		super(resource);
		this.local = local;
	}

	@Override
	public void removeSourceChild(TreeItem<JavaResource> child) {
		boolean isClass = child instanceof ClassItem;
		boolean isDir = child instanceof PackageItem;
		if (isClass || isDir) {
			String childLocal = ((DirectoryItem) child).local;
			if (isClass)
				localToLeaf.remove(childLocal);
			else
				localToDir.remove(childLocal);
		}
		super.removeSourceChild(child);
	}


	/**
	 * Used for display.
	 *
	 * @return Get local item name.
	 */
	public String getLocalName() {
		return local;
	}

	/**
	 * Add a child by the local name.
	 *
	 * @param local
	 * 		Local name of child.
	 * @param child
	 * 		Child to add.
	 * @param isLeaf
	 * 		Indicator that the added child is the final element.
	 */
	public void addChild(String local, DirectoryItem child, boolean isLeaf) {
		if (isLeaf)
			localToLeaf.put(local, child);
		else
			localToDir.put(local, child);
		addSourceChild(child);
	}

	/**
	 * @param local
	 * 		Local name of child.
	 * @param isLeaf
	 * 		Does the local name belong to a leaf.
	 *
	 * @return Child item by local name.
	 */
	public DirectoryItem getChild(String local, boolean isLeaf) {
		if (isLeaf)
			return localToLeaf.get(local);
		return localToDir.get(local);
	}

	/**
	 * A path is specified as multiple local names joined by '/'.
	 *
	 * @param path
	 * 		Path to child.
	 *
	 * @return Child item by path.
	 */
	public DirectoryItem getDeepChild(String path) {
		DirectoryItem item = this;
		List<String> parts = new ArrayList<>(Arrays.asList(path.split("/")));
		while(!parts.isEmpty() && item != null) {
			String part = parts.remove(0);
			item = item.getChild(part, parts.isEmpty());
		}
		return item;
	}

	/**
	 * Expand all parents to this item.
	 */
	public void expandParents() {
		TreeItem<?> item = this;
		while ((item = item.getParent()) != null)
			item.setExpanded(true);
	}

	@Override
	public int compareTo(DirectoryItem o) {
		// Ensure classes do not appear above adjacent packages
		if (this instanceof ClassItem && !(o instanceof ClassItem))
			return 1;
		else if (o instanceof ClassItem && !(this instanceof ClassItem))
			return -1;
		// Compare local name
		return local.compareTo(o.local);
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/FileFolderItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.Recaf;
import me.coley.recaf.workspace.JavaResource;

import java.util.*;

/**
 * Tree item to contain class sub-items.
 *
 * @author Matt
 */
public class FileFolderItem extends DirectoryItem {
	private final JavaResource resource = resource();

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 */
	public FileFolderItem(JavaResource resource) {
		super(resource, "files");
		// Add class sub-items in sorted order
		new TreeSet<>(resource.getFiles().keySet()).forEach(this::addFile);
	}

	protected void addFile(String name) {
		DirectoryItem item = this;
		List<String> parts = new ArrayList<>(Arrays.asList(name.split("/")));
		// Prune tree directory middle section if it is obnoxiously long
		int maxDepth = Recaf.getController().config().display().maxTreeDepth;
		if (parts.size() > maxDepth) {
			while (parts.size() > maxDepth) {
				parts.remove(maxDepth - 1);
			}
			parts.add(maxDepth - 1, "...");
		}
		// Build directory structure
		while(!parts.isEmpty()) {
			String part = parts.remove(0);
			boolean isLeaf = parts.isEmpty();
			DirectoryItem child = item.getChild(part, isLeaf);
			if(child == null) {
				child = isLeaf ?
						new FileItem(resource, part, name) :
						new DirectoryItem(resource, part);
				item.addChild(part, child, isLeaf);
			}
			item = child;
		}
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/FileItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent files.
 *
 * @author Matt
 */
public class FileItem extends DirectoryItem {
	private final String name;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Local file name.
	 * @param name
	 * 		Full file name.
	 */
	public FileItem(JavaResource resource, String local, String name) {
		super(resource, local);
		this.name = name;
	}

	/**
	 * @return Contained file name.
	 */
	public String getFileName() {
		return name;
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof FileItem) {
			FileItem c = (FileItem) o;
			return name.compareTo(c.name);
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/FilterableTreeItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.function.Predicate;

import javafx.beans.binding.Bindings;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.scene.control.TreeItem;
import me.coley.recaf.util.Log;

/**
 * Filterable tree item.
 *
 * @param <T>
 * 		Type of value held by the item.
 *
 * @author kaznovac - https://stackoverflow.com/a/34426897
 * @author Matt - Optimization of child management.
 */
public class FilterableTreeItem<T> extends TreeItem<T> {
	private final ObservableList<TreeItem<T>> sourceChildren = FXCollections.observableArrayList();
	private final ObjectProperty<Predicate<TreeItem<T>>> predicate = new SimpleObjectProperty<>();

	/**
	 * @param value
	 * 		Item value
	 */
	public FilterableTreeItem(T value) {
		super(value);
		// Support filtering by using a filtered list backing.
		// - Apply predicate to items
		FilteredList<TreeItem<T>> filteredChildren = new FilteredList<>(sourceChildren);
		filteredChildren.predicateProperty().bind(Bindings.createObjectBinding(() -> child -> {
			if(child instanceof FilterableTreeItem)
				((FilterableTreeItem<T>) child).predicateProperty().set(predicate.get());
			if(predicate.get() == null || !child.getChildren().isEmpty())
				return true;
			return predicate.get().test(child);
		}, predicate));
		// Reflection hackery
		setUnderlyingChildren(filteredChildren);
	}

	/**
	 * Use reflection to directly set the underlying {@link TreeItem#children} field.
	 * The javadoc for that field literally says:
	 * <pre>
	 *  It is important that interactions with this list go directly into the
	 *  children property, rather than via getChildren(), as this may be
	 *  a very expensive call.
	 * </pre>
	 * This will additionally add the current tree-item's {@link TreeItem#childrenListener} to
	 * the given list's listeners.
	 *
	 * @param list
	 * 		Children list.
	 */
	@SuppressWarnings("unchecked")
	private void setUnderlyingChildren(ObservableList<TreeItem<T>> list) {
		try {
			// Add our change listener to the passed list.
			Field childrenListener = TreeItem.class.getDeclaredField("childrenListener");
			childrenListener.setAccessible(true);
			list.addListener((ListChangeListener<? super TreeItem<T>>) childrenListener.get(this));
			// Directly set "TreeItem.children"
			Field children = TreeItem.class.getDeclaredField("children");
			children.setAccessible(true);
			children.set(this, list);
		} catch(ReflectiveOperationException ex) {
			Log.error(ex, "Failed to update filterable children");
		}
	}

	/**
	 * Add an unfiltered child to this item.
	 *
	 * @param item
	 * 		Child item to add.
	 */
	public void addSourceChild(TreeItem<T> item) {
		int index = Arrays.binarySearch(getChildren().toArray(), item);
		if(index < 0)
			index = -(index + 1);
		sourceChildren.add(index, item);
	}

	/**
	 * Remove an unfiltered child from this item.
	 *
	 * @param child
	 * 		Child item to remove.
	 */
	public void removeSourceChild(TreeItem<T> child) {
		sourceChildren.remove(child);
	}

	/**
	 * @return Predicate property.
	 */
	public ObjectProperty<Predicate<TreeItem<T>>> predicateProperty() {
		return predicate;
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/tree/InsnItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.parse.bytecode.Disassembler;
import me.coley.recaf.util.InsnUtil;
import me.coley.recaf.workspace.JavaResource;
import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * Item to represent instructions.
 *
 * @author Matt
 */
public class InsnItem extends DirectoryItem {
	private final AbstractInsnNode insn;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param insn
	 * 		The instruction.
	 */
	public InsnItem(JavaResource resource, AbstractInsnNode insn) {
		super(resource, Disassembler.insn(insn));
		this.insn = insn;
	}

	/**
	 * @return Instruction value.
	 */
	public AbstractInsnNode getInsn() {
		return insn;
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof InsnItem) {
			InsnItem c = (InsnItem) o;
			return Integer.compare(InsnUtil.index(insn), InsnUtil.index(c.insn));
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/JavaResourceCell.java`:

```java
package me.coley.recaf.ui.controls.tree;

import com.google.common.base.Joiner;
import javafx.scene.Node;
import javafx.scene.control.TreeCell;
import javafx.scene.control.TreeView;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.ContextBuilder;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.JavaResource;
import org.objectweb.asm.Type;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

import static me.coley.recaf.ui.ContextBuilder.menu;

/**
 * Cell renderer.
 *
 * @author Matt
 */
public class JavaResourceCell extends TreeCell {
	private static final Map<Class<?>, Consumer<JavaResourceCell>> CLASS_TO_THING = new HashMap<>();

	@Override
	@SuppressWarnings("unchecked")
	public void updateItem(Object item, boolean empty) {
		super.updateItem(item, empty);
		if (empty) {
			setGraphic(null);
			setText(null);
			setContextMenu(null);
		} else {
			Class<?> k = getTreeItem().getClass();
			Consumer<JavaResourceCell> populator = CLASS_TO_THING.get(k);
			if (populator != null)
				populator.accept(this);
		}
	}

	private static GuiController getController() {
		return (GuiController) Recaf.getController();
	}

	static {
		// Root cells
		CLASS_TO_THING.put(RootItem.class, cell -> {
			JavaResource resource = (JavaResource) cell.getTreeItem().getValue();
			String text = resource.toString();
			Node g = new IconView(UiUtil.getResourceIcon(resource));
			cell.getStyleClass().add("tree-cell-root");
			cell.setContextMenu(menu().controller(getController()).tree(getTree(cell)).ofRoot(resource));
			cell.setGraphic(g);
			cell.setText(text);
		});
		CLASS_TO_THING.put(SearchRootItem.class, cell -> {
			SearchRootItem sri = (SearchRootItem) cell.getTreeItem();
			String text = "Search[" + Joiner.on(", ").withKeyValueSeparator("=").join(sri.getParams())  + "] - " +
					sri.getResults().size() + " results";
			Node g = new IconView(UiUtil.getResourceIcon((JavaResource) cell.getTreeItem().getValue()));
			cell.getStyleClass().add("tree-cell-root");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw sub-roots (classes/files)
		CLASS_TO_THING.put(ClassFolderItem.class, cell -> {
			BaseItem b = (BaseItem) cell.getTreeItem();
			int count = b.resource().getClasses().size();
			String text = String.format("classes (%d)", count);
			Node g = new IconView("icons/folder-source.png");
			cell.getStyleClass().add("tree-cell-root-classes");
			cell.setGraphic(g);
			cell.setText(text);
		});
		CLASS_TO_THING.put(FileFolderItem.class, cell -> {
			BaseItem b = (BaseItem) cell.getTreeItem();
			int count = b.resource().getFiles().size();
			String text = String.format("files (%d)", count);
			Node g = new IconView("icons/folder-resource.png");
			cell.getStyleClass().add("tree-cell-root-files");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw classes
		CLASS_TO_THING.put(ClassItem.class, cell -> {
			ClassItem ci = (ClassItem) cell.getTreeItem();
			int access = ClassUtil.getAccess(ci.resource().getClasses().get(ci.getClassName()));
			String text = ci.getLocalName();
			Node g = UiUtil.createClassGraphic(access);
			cell.getStyleClass().add("tree-cell-class");
			cell.getStyleClass().add("monospaced-tree");
			cell.setContextMenu(setupMenu(cell, ci).ofClass(ci.getClassName()));
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw class members
		CLASS_TO_THING.put(MemberItem.class, cell -> {
			MemberItem mi = (MemberItem) cell.getTreeItem();
			String owner = ((ClassItem) mi.getParent()).getClassName();
			ContextBuilder menu = setupMenu(cell, mi);
			String text = mi.getLocalName();
			Node g;
			if(mi.isField()) {
				g = UiUtil.createFieldGraphic(mi.getMemberAccess());
				cell.setContextMenu(menu.ofField(owner, mi.getMemberName(), mi.getMemberDesc()));
			} else {
				g = UiUtil.createMethodGraphic(mi.getMemberAccess());
				cell.setContextMenu(menu.ofMethod(owner, mi.getMemberName(), mi.getMemberDesc()));
			}
			cell.getStyleClass().add("tree-cell-member");
			cell.getStyleClass().add("monospaced-tree");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw annotations
		CLASS_TO_THING.put(InsnItem.class, cell -> {
			InsnItem ii = (InsnItem) cell.getTreeItem();
			MemberItem mi = (MemberItem) ii.getParent();
			String owner = ((ClassItem) mi.getParent()).getClassName();
			String name = mi.getMemberName();
			String desc = mi.getMemberDesc();
			// TODO: Graphical representation instead to allow syntax highlighting
			String text = ii.getLocalName();
			Node g = new IconView("icons/result.png");
			cell.getStyleClass().add("tree-cell-instruction");
			cell.getStyleClass().add("monospaced-tree");
			cell.setContextMenu(setupMenu(cell, ii).ofInsn(owner, name, desc, ii.getInsn()));
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw method instructions
		CLASS_TO_THING.put(AnnoItem.class, cell -> {
			AnnoItem ai = (AnnoItem) cell.getTreeItem();
			String text = ai.getLocalName();
			Node g = new IconView("icons/class/annotation.png");
			cell.getStyleClass().add("tree-cell-annotation");
			cell.getStyleClass().add("monospaced-tree");
			cell.setContextMenu(setupMenu(cell, ai).ofClass(ai.getAnnoName()));
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw method local variables
		CLASS_TO_THING.put(LocalItem.class, cell -> {
			LocalItem li = (LocalItem) cell.getTreeItem();
			String desc = li.getLocal().getDescriptor();
			Type type = Type.getType(desc);
			String className = type.getInternalName();
			int access = ClassUtil.getAccess(li.resource().getClasses().get(className));
			String text = "LOCAL[" + li.getLocal().getIndex() + "] " + li.getLocalName() + " - " +
					li.getLocal().getDescriptor();
			Node g = UiUtil.createClassGraphic(access);
			cell.getStyleClass().add("tree-cell-local");
			cell.getStyleClass().add("monospaced-tree");
			cell.setContextMenu(setupMenu(cell, li).ofClass(className));
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw method catch blocks
		CLASS_TO_THING.put(CatchItem.class, cell -> {
			CatchItem ci = (CatchItem) cell.getTreeItem();
			String className = ci.getCatchType();
			int access = ClassUtil.getAccess(ci.resource().getClasses().get(className));
			String text = "CATCH " + className;
			Node g = UiUtil.createClassGraphic(access);
			cell.getStyleClass().add("tree-cell-catch");
			cell.getStyleClass().add("monospaced-tree");
			cell.setContextMenu(setupMenu(cell, ci).ofClass(className));
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw files
		CLASS_TO_THING.put(FileItem.class, cell -> {
			FileItem fi = (FileItem) cell.getTreeItem();
			String text = fi.getLocalName();
			String fileName = fi.getFileName();
			Node g = UiUtil.createFileGraphic(fi.getLocalName());
			cell.setContextMenu(setupMenu(cell, fi).ofFile(fileName));
			cell.getStyleClass().add("tree-cell-file");
			cell.getStyleClass().add("monospaced-tree");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw packages
		CLASS_TO_THING.put(PackageItem.class, cell -> {
			PackageItem pi = (PackageItem) cell.getTreeItem();
			String text = pi.getLocalName();
			Node g = new IconView("icons/class/package-flat.png");
			cell.setContextMenu(setupMenu(cell, pi).ofPackage(pi.getPackageName()));
			cell.getStyleClass().add("tree-cell-directory");
			cell.getStyleClass().add("monospaced-tree");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw directories/folders
		CLASS_TO_THING.put(DirectoryItem.class, cell -> {
			DirectoryItem di = (DirectoryItem) cell.getTreeItem();
			String text = di.getLocalName();
			Node g = new IconView("icons/class/package-flat.png");
			cell.getStyleClass().add("tree-cell-directory");
			cell.getStyleClass().add("monospaced-tree");
			cell.setGraphic(g);
			cell.setText(text);
		});
		// Draw misc
		CLASS_TO_THING.put(MiscItem.class, cell -> {
			DirectoryItem di = (DirectoryItem) cell.getTreeItem();
			String text = di.getLocalName();
			Node g = new IconView("icons/result.png");
			cell.getStyleClass().add("tree-cell-misc");
			cell.setGraphic(g);
			cell.setText(text);
		});
	}

	private static ContextBuilder setupMenu(JavaResourceCell cell, DirectoryItem item) {
		return menu().controller(getController()).resource(item.getValue()).tree(getTree(cell));
	}

	private static TreeView<?> getTree(JavaResourceCell cell) {
		Node n = cell;
		while (n != null && !(n instanceof TreeView))
			n = n.getParent();
		return (TreeView<?>) n;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/JavaResourceTree.java`:

```java
package me.coley.recaf.ui.controls.tree;

import javafx.scene.control.*;
import javafx.scene.input.*;
import javafx.scene.layout.BorderPane;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.workspace.JavaResource;

/**
 * Tree representation of a given {@link JavaResource resource}.
 *
 * @author Matt
 */
@SuppressWarnings("unchecked")
public class JavaResourceTree extends BorderPane {
	private final GuiController controller;
	private final TextField search;
	private final TreeView tree;

	/**
	 * @param controller
	 * 		Controller to act on.
	 * @param resource
	 * 		Resource to model.
	 */
	public JavaResourceTree(GuiController controller, JavaResource resource) {
		this.controller = controller;
		// Tree display
		tree = new TreeView();
		tree.setCellFactory(e -> new JavaResourceCell());
		tree.setRoot(new RootItem(resource));
		tree.getRoot().setExpanded(true);
		tree.setOnMouseClicked(this::onClick);
		tree.setOnKeyPressed(this::onKey);
		setCenter(tree);
		// Search field
		search = new TextField();
		search.setPromptText(LangUtil.translate("ui.search") + "...");
		search.getStyleClass().add("search-field");
		search.setOnKeyReleased(e -> {
			// Clear search
			if(e.getCode() == KeyCode.ESCAPE)
				search.setText("");
			// Navigation keys refocus the tree
			else if (e.getCode() == KeyCode.UP ||
					e.getCode() == KeyCode.DOWN) {
				tree.requestFocus();
			}
		});
		search.textProperty().addListener((n, o, v) -> updateSearch(v));
		setBottom(search);

	}

	/**
	 * Filter items in the tree that match <i>(contains)</i> the given text.
	 *
	 * @param text
	 * 		Text to search with.
	 */
	private void updateSearch(String text) {
		RootItem root = (RootItem) tree.getRoot();
		// TODO: More verbose options
		//  - Support for actions, for example:
		//    - "enum:true com/" - search enums in com packages
		//    - "ext:json xyz" - search for whatever ending in ".json"
		root.predicateProperty().set(item -> {
			// Empty predicate -> Simple return.
			if(text.isEmpty())
				return true;
			// Check for content match
			boolean match = false;
			if(item instanceof ClassItem)
				match = ((ClassItem) item).getClassName().contains(text);
			else if(item instanceof FileItem)
				match = ((FileItem) item).getFileName().contains(text);
			// Expand items that match, hide those that do not.
			if(match)
				((DirectoryItem) item).expandParents();
			else
				item.setExpanded(false);
			return match;
		});
	}

	private void onClick(MouseEvent e) {
		TreeItem item = (TreeItem) tree.getSelectionModel().getSelectedItem();
		if(item == null)
			return;
		// Right click
		if(e.getButton() == MouseButton.SECONDARY) {
			// TODO: Context menu items
			//  (Update context menu builder so source can be used to determine additional options)
			//  - Remove item
			//  - Specifics for classes
			//    - ?
			//  - Specifics for files
			//    - Copy item (to location of given name, prompted)
		}
		// Double click
		else if(e.getClickCount() == 2) {
			// Open selected
			if(item.isLeaf())
				openItem(item);
			// Recursively open children until multiple options are present
			else if(item.isExpanded()) {
				recurseOpen(item);
			}
		}
	}

	private void onKey(KeyEvent e) {
		// Check find keybind
		if (controller.config().keys().find.match(e)) {
			if (search.isFocused())
				search.selectAll();
			search.requestFocus();
			return;
		}
		// Focus text search when typing in tree
		else if (!e.getText().trim().isEmpty()) {
			search.setText(e.getText());
			search.requestFocus();
		}
		// All further actions are for tree-item specific
		TreeItem item = (TreeItem) tree.getSelectionModel().getSelectedItem();
		if(item == null)
			return;
		// Open selected
		if(e.getCode() == KeyCode.ENTER) {
			if(!item.isLeaf())
				return;
			openItem(item);
		}
		// Recursively open children until multiple options are present
		else if(e.getCode() == KeyCode.RIGHT || e.getCode() == KeyCode.KP_RIGHT) {
			recurseOpen(item);
		}
	}

	/**
	 * Open the class or resource in the ui.
	 *
	 * @param item
	 * 		Item representing value.
	 */
	private void openItem(TreeItem item) {
		if(item instanceof ClassItem) {
			ClassItem ci = (ClassItem) item;
			String name = ci.getClassName();
			JavaResource resource = ci.resource();
			controller.windows().getMainWindow().openClass(resource, name);
		} else if(item instanceof FileItem) {
			FileItem ri = (FileItem) item;
			String name = ri.getFileName();
			JavaResource resource = ri.resource();
			controller.windows().getMainWindow().openFile(resource, name);
		}
	}

	/**
	 * Opens children recursively as long as only as there is only a path of single children.
	 *
	 * @param item
	 * 		Item to recursively open.
	 */
	public static void recurseOpen(TreeItem item) {
		item.setExpanded(true);
		if(item.getChildren().size() == 1)
			recurseOpen((TreeItem) item.getChildren().get(0));
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/tree/LocalItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.search.Context;
import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent local variables.
 *
 * @author Matt
 */
public class LocalItem extends DirectoryItem {
	private final Context.LocalContext local;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		The local variable context.
	 */
	public LocalItem(JavaResource resource, Context.LocalContext local) {
		super(resource, local.getName());
		this.local = local;
	}

	/**
	 * @return Local variable context.
	 */
	public Context.LocalContext getLocal() {
		return local;
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof LocalItem) {
			LocalItem c = (LocalItem) o;
			return local.compareTo(c.getLocal());
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/MemberItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent members <i>(field or method)</i>.
 *
 * @author Matt
 */
public class MemberItem extends DirectoryItem {
	private final String name;
	private final String desc;
	private final int access;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Local name in tree.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 * @param access
	 * 		Member access modifiers.
	 */
	public MemberItem(JavaResource resource, String local, String name, String desc, int access) {
		super(resource, local);
		this.name = name;
		this.desc = desc;
		this.access = access;
	}

	/**
	 * @return Contained member name.
	 */
	public String getMemberName() {
		return name;
	}

	/**
	 * @return Contained member descriptor.
	 */
	public String getMemberDesc() {
		return desc;
	}

	/**
	 * @return Contained member access modifiers.
	 */
	public int getMemberAccess() {
		return access;
	}

	/**
	 * @return {@code true} if the member represents a method.
	 */
	public boolean isMethod() {
		return desc.indexOf('(') == 0;
	}

	/**
	 * @return {@code true} if the member represents a field.
	 */
	public boolean isField() {
		return !isMethod();
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof MemberItem) {
			MemberItem c = (MemberItem) o;
			if (isField() && c.isMethod())
				return -1;
			else if (isMethod() && c.isField())
				return 1;
			return getLocalName().compareTo(c.getLocalName());
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/MiscItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Item to represent any other potential data.
 *
 * @author Matt
 */
public class MiscItem extends DirectoryItem {
	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Local item name.
	 */
	public MiscItem(JavaResource resource, String local) {
		super(resource, local);
	}

	@Override
	public int compareTo(DirectoryItem o) {
		if(o instanceof MiscItem) {
			MiscItem c = (MiscItem) o;
			return super.compareTo(o);
		}
		return 1;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/PackageItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.workspace.JavaResource;

/**
 * Tree item to represent packages.
 *
 * @author Matt
 */
public class PackageItem extends DirectoryItem {
	private final String packageName;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param local
	 * 		Partial name of the package.
	 * @param packageName
	 * 		Full package name.
	 */
	public PackageItem(JavaResource resource, String local, String packageName) {
		super(resource, local);
		this.packageName = packageName;
	}

	/**
	 * @return Package name.
	 */
	public String getPackageName() {
		return packageName;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/RootItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import javafx.application.Platform;
import me.coley.recaf.util.struct.InternalBiConsumer;
import me.coley.recaf.util.struct.InternalConsumer;
import me.coley.recaf.workspace.JavaResource;

/**
 * Root item
 *
 * @author Matt
 */
public class RootItem extends BaseItem {
	private ClassFolderItem classes;
	private FileFolderItem files;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 */
	public RootItem(JavaResource resource) {
		super(resource);
		// classes sub-folder
		if(resource.getClasses().size() > 0) {
			addSourceChild(classes = new ClassFolderItem(resource));
			// Register listeners and update if the classes update
			resource.getClasses().getRemoveListeners().add(InternalConsumer.internal(r -> {
				String name = r.toString();
				DirectoryItem di = classes.getDeepChild(name);
				if (di != null) {
					Platform.runLater(() -> {
						BaseItem parent = (BaseItem) di.getParent();
						if(parent != null) {
							parent.removeSourceChild(di);
							// Remove directories if needed
							while(parent.isLeaf() && !(parent instanceof ClassFolderItem)) {
								BaseItem parentOfParent = (BaseItem) parent.getParent();
								parentOfParent.removeSourceChild(parent);
								parent = parentOfParent;
							}
						}
					});
				}
			}));
			resource.getClasses().getPutListeners().add(InternalBiConsumer.internal((k, v) -> {
				// Put includes updates, so only "add" the class when it doesn't already exist
				if (!resource.getClasses().containsKey(k))
					Platform.runLater(() -> classes.addClass(k));
			}));
		}
		// files sub-folder
		if(resource.getFiles().size() > 0) {
			addSourceChild(files = new FileFolderItem(resource));
			// Register listeners and update if the files update
			resource.getFiles().getRemoveListeners().add(InternalConsumer.internal(r -> {
				String name = r.toString();
				DirectoryItem di = files.getDeepChild(name);
				if (di != null) {
					Platform.runLater(() -> {
						BaseItem parent = (BaseItem) di.getParent();
						if(parent != null) {
							parent.removeSourceChild(di);
							// Remove directories if needed
							while(parent.isLeaf() && !(parent instanceof FileFolderItem)) {
								BaseItem parentOfParent = (BaseItem) parent.getParent();
								parentOfParent.removeSourceChild(parent);
								parent = parentOfParent;
							}
						}
					});
				}
			}));
			resource.getFiles().getPutListeners().add(InternalBiConsumer.internal((k, v) -> {
				// Put includes updates, so only "add" the file when it doesn't already exist
				if (!resource.getFiles().containsKey(k))
					Platform.runLater(() -> files.addFile(k));
			}));
		}
		// TODO: Sub-folders for these?
		//  - docs
		//  - sources
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/tree/SearchRootItem.java`:

```java
package me.coley.recaf.ui.controls.tree;

import me.coley.recaf.search.*;
import me.coley.recaf.workspace.JavaResource;

import java.util.*;

/**
 * Root item
 *
 * @author Matt
 */
public class SearchRootItem extends DirectoryItem {
	private final JavaResource resource = resource();
	private final Collection<SearchResult> results;
	private final Map<String,Object> params;

	/**
	 * @param resource
	 * 		The resource associated with the item.
	 * @param results
	 * 		Results to show in sub-items.
	 * @param params
	 * 		Search parameters.
	 */
	public SearchRootItem(JavaResource resource, Collection<SearchResult> results, Map<String,Object> params) {
		super(resource, null);
		this.results = results;
		this.params = params;
		// Add result sub-items in sorted order
		Set<SearchResult> sorted = new TreeSet<>((a, b) -> {
			int cmp = getClassContext(a.getContext()).compareTo(getClassContext(b.getContext()));
			if (cmp == 0)
				return a.compareTo(b);
			else
				return cmp;
		});
		sorted.addAll(results);
		sorted.forEach(this::addResult);
	}

	/**
	 * @return Results of the search.
	 */
	public Collection<SearchResult> getResults() {
		return results;
	}

	/**
	 * @return Parameters used in the search.
	 */
	public Map<String, Object> getParams() {
		return params;
	}

	private void addResult(SearchResult result) {
		// Add the class scope
		Context.ClassContext ctxClass = getClassContext(result.getContext());
		String name = ctxClass.getName();
		DirectoryItem item = this;
		List<String> parts = new ArrayList<>(Arrays.asList(name.split("/")));
		while(!parts.isEmpty()) {
			String part = parts.remove(0);
			boolean isLeaf = parts.isEmpty();
			DirectoryItem child = item.getChild(part, isLeaf);
			if(child == null) {
				child = isLeaf ?
						new ClassItem(resource, part, name) :
						new DirectoryItem(resource, part);
				item.addChild(part, child, isLeaf);
			}
			item = child;
		}
		// Check for if we need to add more scope
		Context<?> ctx = result.getContext();
		if(ctx == ctxClass)
			return;
		if(ctx instanceof Context.MemberContext){
			Context.MemberContext mctx = (Context.MemberContext) ctx;
			item = addMember(item, mctx);
			if (mctx.isField()) {
				if(result instanceof StringResult) {
					String text = ((StringResult) result).getText();
					item.addChild(text, new MiscItem(resource(), text), true);
				} else if(result instanceof ValueResult) {
					String text = ((ValueResult) result).getValue().toString();
					item.addChild(text, new MiscItem(resource(), text), true);
				}
			} else if(result instanceof InsnResult) {
				String text = String.join("\n", ((InsnResult) result).getLines());
				item.addChild(text, new MiscItem(resource(), text), true);
			}
		}
		else if(ctx instanceof Context.InsnContext)
			addInsn(item, (Context.InsnContext) ctx);
		else if(ctx instanceof Context.LocalContext)
			addLocal(item, (Context.LocalContext) ctx);
		else if(ctx instanceof Context.CatchContext)
			addCatch(item, (Context.CatchContext) ctx);
		else if(ctx instanceof Context.AnnotationContext) {
			item = addAnno(item, (Context.AnnotationContext) ctx);
			if(result instanceof StringResult) {
				String text = ((StringResult) result).getText();
				item.addChild(text, new MiscItem(resource(), text), true);
			} else if(result instanceof ValueResult) {
				String text = ((ValueResult) result).getValue().toString();
				item.addChild(text, new MiscItem(resource(), text), true);
			}
		}
	}

	private DirectoryItem addMember(DirectoryItem item, Context.MemberContext ctx) {
		// Check existing
		String name = ctx.getName();
		String desc = ctx.getDesc();
		String local = desc.indexOf('(') == 0 ? name + desc : name + " " + desc;
		DirectoryItem mi = item.getChild(local, true);
		if (mi != null)
			return mi;
		// Create new
		mi = new MemberItem(resource(), local, name, desc, ctx.getAccess());
		item.addChild(mi.getLocalName(), mi, true);
		return mi;
	}

	private void addInsn(DirectoryItem item, Context.InsnContext ctx) {
		// Add parent context first
		item = addMember(item, ctx.getParent());
		InsnItem ii = new InsnItem(resource(), ctx.getInsn());
		item.addChild(ii.getLocalName(), ii, true);
	}

	private void addLocal(DirectoryItem item, Context.LocalContext ctx) {
		// Add parent context first
		item = addMember(item, ctx.getParent());
		LocalItem ii = new LocalItem(resource(), ctx);
		item.addChild(ii.getLocalName(), ii, true);
	}

	private void addCatch(DirectoryItem item, Context.CatchContext ctx) {
		// Add parent context first
		item = addMember(item, ctx.getParent());
		CatchItem ii = new CatchItem(resource(), ctx);
		item.addChild(ii.getLocalName(), ii, true);
	}

	private DirectoryItem addAnno(DirectoryItem item, Context.AnnotationContext ctx) {
		Context<?> ctxParent = ctx.getParent();
		// Check if we must add the parent first
		if(ctxParent instanceof Context.MemberContext)
			item = addMember(item, (Context.MemberContext) ctxParent);
		else if(ctxParent instanceof Context.AnnotationContext)
			item = addAnno(item, (Context.AnnotationContext) ctxParent);
		// Add the annotation
		String name = ctx.getType();
		String local = name.substring(1, name.length() - 1);
		// Check existing
		DirectoryItem ai = item.getChild(local, true);
		if(ai != null)
			return ai;
		// Create new
		ai = new AnnoItem(resource(), local, name);
		item.addChild(local, ai, true);
		return ai;
	}

	private Context.ClassContext getClassContext(Context<?> ctx) {
		while (!ctx.getClass().equals(Context.ClassContext.class))
			ctx = ctx.getParent();
		return (Context.ClassContext) ctx;
	}
}
```

`src/main/java/me/coley/recaf/ui/controls/view/BytecodeViewport.java`:

```java
package me.coley.recaf.ui.controls.view;

import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.ui.controls.text.BytecodeEditorPane;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.History;
import me.coley.recaf.workspace.JavaResource;

import java.util.Map;

/**
 * Wrapper for {@link BytecodeEditorPane}.
 *
 * @author Matt
 */
public class BytecodeViewport extends EditorViewport {
	private final BytecodeEditorPane pane;
	private final ClassViewport host;
	private final String owner;

	/**
	 * @param controller
	 * 		Controller context.
	 * @param host
	 * 		Class viewport.
	 * @param resource
	 * 		Resource the file resides in.
	 * @param owner
	 * 		Class that declares the Member.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	public BytecodeViewport(GuiController controller, ClassViewport host, JavaResource resource,
							String owner, String name, String desc) {
		this(controller, host, resource, owner, new BytecodeEditorPane(controller, owner, name, desc));
	}

	/**
	 * @param controller
	 * 		Controller context.
	 * @param host
	 * 		Class viewport.
	 * @param resource
	 * 		Resource the file resides in.
	 * @param owner
	 * 		Class that declares the Member.
	 * @param editor
	 * 		Member editor.
	 */
	public BytecodeViewport(GuiController controller, ClassViewport host, JavaResource resource,
							String owner, BytecodeEditorPane editor) {
		super(controller, resource, owner);
		this.pane = editor;
		this.host = host;
		this.owner = owner;
		setCenter(pane);
		pane.setWrapText(controller.config().display().forceWordWrap);
	}

	@Override
	protected History getHistory(String path) {
		return resource.getClassHistory(path);
	}

	@Override
	protected Map<String, byte[]> getMap() {
		return resource.getClasses();
	}

	@Override
	public void updateView() {
		// Try to disassemble
		boolean success = pane.disassemble();
		pane.setEditable(success);
		if (!success)
			pane.setText("// Failed to disassemble: " + path);
	}

	@Override
	public void save() {
		try {
			current = pane.assemble();
		} catch(Throwable t) {
			Log.error(t, "Uncaught exception when assembling method");
			UiUtil.animateFailure(getCenter(), 500);
		}
		if (current == null)
			return;
		super.save();
		// Update viewport
		if (host != null) {
			ClassViewport view = host;
			// Check of host holds the class that defines the method, if not, see if that class is open
			if(!owner.equals(view.path))
				view = controller.windows().getMainWindow().getClassViewport(owner);
			if(view != null)
				view.updateView();
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/view/ClassViewport.java`:

```java
package me.coley.recaf.ui.controls.view;

import javafx.application.Platform;
import javafx.scene.input.KeyEvent;
import me.coley.recaf.config.ConfigManager;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.decompile.DecompileImpl;
import me.coley.recaf.plugin.PluginKeybinds;
import me.coley.recaf.ui.controls.ClassEditor;
import me.coley.recaf.ui.controls.FontSlider;
import me.coley.recaf.ui.controls.HexEditor;
import me.coley.recaf.ui.controls.popup.SuggestionWindow;
import me.coley.recaf.ui.controls.node.ClassNodeEditorPane;
import me.coley.recaf.ui.controls.text.JavaEditorPane;
import me.coley.recaf.util.*;
import me.coley.recaf.workspace.History;
import me.coley.recaf.workspace.JavaResource;
import org.fxmisc.richtext.CodeArea;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Multi-view wrapper for classes in resources.
 *
 * @author Matt
 */
public class ClassViewport extends EditorViewport {
	private ClassMode overrideMode;
	private DecompileImpl overrideDecompiler;
	private double lastScrollX;
	private double lastScrollY;

	/**
	 * @param controller
	 * 		Controller context.
	 * @param resource
	 * 		Resource the file resides in.
	 * @param path
	 * 		Path to file.
	 */
	public ClassViewport(GuiController controller, JavaResource resource, String path) {
		super(controller, resource, path);
	}

	@Override
	protected void handleKeyReleased(KeyEvent e) {
		super.handleKeyReleased(e);
		// Custom bind support
		PluginKeybinds.getInstance().getClassViewBinds().forEach((bind, action) -> {
			try {
				if (bind.match(e))
					action.accept(this);
			} catch(Throwable t) {
				Log.error(t, "Failed executing class keybind action");
			}
		});

		ConfigManager config = controller.config();

		if(config.keys().swapview.match(e)) {
			setOverrideMode(ClassMode.values()[(getClassMode().ordinal() + 1) % ClassMode.values().length]);
			requestFocus();
		}

		if(config.keys().incFontSize.match(e)) {
			config.display().monoFontSize++;
			FontSlider.update(controller);
			config.save();
		}

		if(config.keys().decFontSize.match(e)) {
			config.display().monoFontSize--;
			FontSlider.update(controller);
			config.save();
		}
	}

	@Override
	protected History getHistory(String path) {
		return resource.getClassHistory(path);
	}

	@Override
	protected Map<String, byte[]> getMap() {
		return resource.getClasses();
	}

	@Override
	public void updateView() {
		switch(getClassMode()) {
			case DECOMPILE: {
				// Fetch decompiler

				DecompileImpl decompiler = getDecompiler();
				long timeout = controller.config().decompile().timeout;
				boolean showSuggestions = controller.config().display().suggestClassWithErrors;
				// Get or create pane
				String initialText = "// Decompiling class: " + path + "\n" +
						"// - Decompiler: " + decompiler.getNameAndVersion() + "\n";
				JavaEditorPane pane = null;
				if (getCenter() instanceof JavaEditorPane) {
					pane = (JavaEditorPane) getCenter();
					if (!pane.getCodeArea().getText().equals(initialText)){
						trySaveCurrentScrollPosition();
					}
					pane.setText(initialText);
				} else {
					pane = new JavaEditorPane(controller, resource, initialText);
					pane.setWrapText(controller.config().display().forceWordWrap);
					setCenter(pane);
				}
				pane.setEditable(pane.canCompile() && resource.isPrimary());
				// Actions
				Supplier<String> supplier = () -> {
					// SUPPLIER: Fetch decompiled code
					String decompilerPrefix = (controller.config().decompile().showName ?
							"// Decompiled with: " + decompiler.getNameAndVersion() + "\n" : "");
					byte[] clazz = controller.getWorkspace().getRawClass(path);
					int version = ClassUtil.getVersion(clazz) - ClassUtil.VERSION_OFFSET;
					String classVersionPrefix = "// Class Version: " + version + "\n";
					String decompile = decompilerPrefix + classVersionPrefix +
							decompiler.create(controller).decompile(path);
					return EscapeUtil.unescapeUnicode(decompile);
				};
				JavaEditorPane finalPane = pane;
				Consumer<String> consumer = decompile -> {
					// CONSUMER: Set decompiled text and check for errors
					// Update text
					Platform.runLater(() -> {
						finalPane.setText(decompile);
						finalPane.forgetHistory();
						if (lastScrollY > 0) {
							finalPane.getCodeArea().scrollXToPixel(lastScrollX);
							finalPane.getCodeArea().scrollYToPixel(lastScrollY);
						} else {
							finalPane.scrollToTop();
						}
					});
					// Sometimes the code analysis gets stuck on the initial commented out text...
					// This checks for getting stuck and forces an update. Hacky, but does the job.
					ThreadUtil.runJfxDelayed(600, () -> {
						int errorCheckDelay = 0;
						if (finalPane.getAnalyzedCode().getCode().length() != decompile.length()) {
							finalPane.appendText(" ");
							errorCheckDelay = 400;
						}
						// Show popup suggesting switching modes when the decompile has errors
						if (showSuggestions) {
							ThreadUtil.runJfxDelayed(errorCheckDelay, () -> {
								if(finalPane.getErrorHandler().hasErrors()) {
									SuggestionWindow.suggestAltDecompile(controller, this).show(this);
								}
							});
						}
					});
				};
				Runnable timeoutAction = () -> {
					// TIMEOUT: Suggest another decompiler
					Platform.runLater(() -> {
						finalPane.appendText("// \n// Timed out after " + timeout + " ms\n// \n" +
								"// Suggestion: Change the decompiler or switch the class mode to " +
								ClassMode.TABLE.name());
					});
					// Show popup suggesting switching modes when the decompile fails
					if(showSuggestions) {
						ThreadUtil.runJfxDelayed(100, () -> {
							SuggestionWindow.suggestTimeoutDecompile(controller, this).show(this);
						});
					}
				};
				Consumer<Throwable> handler = t -> {
					// ERROR-HANDLER: Print decompile error
					StringWriter sw = new StringWriter();
					PrintWriter pw = new PrintWriter(sw);
					t.printStackTrace(pw);
					String decompile = LangUtil.translate("decompile.fail") + "\n\nError Message: "
							+ t.getMessage() + "\n\nStackTrace:\n" + sw.toString();
					finalPane.setEditable(false);
					// Show popup suggesting switching modes when the decompile fails
					if(showSuggestions) {
						ThreadUtil.runJfxDelayed(100, () -> {
							SuggestionWindow.suggestFailedDecompile(controller, this).show(this);
						});
					}
					// Update text
					Platform.runLater(() -> {
						finalPane.appendText("\n/*\n" + decompile + "\n*/");
						finalPane.forgetHistory();
					});
				};
				// Run actions
				ThreadUtil.runSupplyConsumer(supplier, timeout, timeoutAction, consumer, handler);
				break;
			}
			case TABLE: {
				// TODO: like how Recaf was in 1.X
				ClassNodeEditorPane pane = null;
				ClassReader cr = controller.getWorkspace().getClassReader(path);
				ClassNode node = ClassUtil.getNode(cr, ClassReader.SKIP_FRAMES);
				if(getCenter() instanceof ClassNodeEditorPane) {
					pane = (ClassNodeEditorPane) getCenter();
					pane.refresh(node);
				} else {
					pane = new ClassNodeEditorPane(controller, node);
					setCenter(pane);
				}
				break;
			}
			case HEX:
			default:
				HexEditor hex = new HexEditor(last);
				hex.setContentCallback(array -> current = array);
				hex.setEditable(resource.isPrimary());
				setCenter(hex);
				break;
		}
	}

	@Override
	public void save() {
		// Handle saving for editing decompiled java
		if (getCenter() instanceof JavaEditorPane) {
			try {
				Map<String, byte[]> map = ((ClassEditor) getCenter()).save(path);
				current = map.get(path);
				// Save other inners
				map.remove(path);
				JavaResource resource = controller.getWorkspace().getPrimary();
				map.forEach((key, value) -> {
					resource.getClasses().put(key, value);
					resource.getClassHistory(key).push(value);
				});
			} catch(UnsupportedOperationException ex) {
				Log.warn("Recompiling not supported. Please run Recaf with a JDK.", path);
				return;
			} catch(Exception ex) {
				Log.error("Failed recompiling code for '{}' - Reason: '{}'", path, ex.getMessage());
				return;
			}
		} else if (getCenter() instanceof ClassNodeEditorPane) {
			try {
				current = ((ClassEditor) getCenter()).save(path).get(path);
			} catch(IllegalStateException ex) {
				Log.error("Failed saving changes for '{}' - Reason: '{}'", path, ex.getMessage());
				return;
			} catch(Throwable t) {
				Log.error(t, "Failed saving changes for '{}' - Uncaught exception", path);
				return;
			}
		}
		// Save content
		super.save();
	}

	/**
	 * Jump to the definition of the given member.
	 *
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 */
	public void selectMember(String name, String desc) {
		if (getCenter() instanceof  ClassEditor)
			((ClassEditor)getCenter()).selectMember(name, desc);
	}

	/**
	 * Set a new mode to view classes in then refresh the view.
	 *
	 * @param overrideMode
	 * 		New mode to view classes in.
	 */
	public void setOverrideMode(ClassMode overrideMode) {
		this.overrideMode = overrideMode;
		updateView();
	}

	/**
	 * Set the tab's decompiler then refresh the view.
	 * @param overrideDecompiler New mode to view classes in.
	 */
	public void setOverrideDecompiler(DecompileImpl overrideDecompiler) {
		this.overrideDecompiler = overrideDecompiler;
		// Ensure the mode is set to decompile & refresh the view
		setOverrideMode(ClassMode.DECOMPILE);
	}

	/**
	 * @return Decompiler to use when the {@link #getClassMode() mode} is set to decompile.
	 */
	public DecompileImpl getDecompiler() {
		if (overrideDecompiler != null)
			return overrideDecompiler;
		return controller.config().decompile().decompiler;
	}

	/**
	 * @return Mode that indicated which view to use for modifying classes.
	 */
	public ClassMode getClassMode() {
		if (overrideMode != null)
			return overrideMode;
		return controller.config().display().classEditorMode;
	}

	/**
	 * @return Controller
	 */
	public GuiController getController() {
		return controller;
	}

	private void trySaveCurrentScrollPosition(){
		if (getCenter() instanceof JavaEditorPane){
			CodeArea codeArea = ((JavaEditorPane) getCenter()).getCodeArea();
			lastScrollX = codeArea.getEstimatedScrollX();
			lastScrollY = codeArea.getEstimatedScrollY();
		}
	}

	/**
	 * Viewport editor type.
	 */
	public enum ClassMode {
		DECOMPILE, TABLE, HEX;

		@Override
		public String toString() {
			return StringUtil.toString(this);
		}
	}
}

```

`src/main/java/me/coley/recaf/ui/controls/view/EditorViewport.java`:

```java
package me.coley.recaf.ui.controls.view;

import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import me.coley.recaf.config.ConfKeybinding;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.History;
import me.coley.recaf.workspace.JavaResource;

import java.util.Arrays;
import java.util.Map;

/**
 * Multi-view wrapper for files in resources.
 *
 * @author Matt
 */
public abstract class EditorViewport extends BorderPane {
	protected final GuiController controller;
	protected final JavaResource resource;
	protected final String path;
	protected byte[] last;
	protected byte[] current;

	/**
	 * @param controller
	 * 		Controller context.
	 * @param resource
	 * 		Resource the file resides in.
	 * @param path
	 * 		Path to file.
	 */
	public EditorViewport(GuiController controller, JavaResource resource, String path) {
		this.controller = controller;
		this.resource = resource;
		this.path = path;
		fetchLast();
		setOnKeyReleased(this::handleKeyReleased);
	}

	/**
	 * Handle keybinds.
	 *
	 * @param e
	 * 		Key event.
	 */
	protected void handleKeyReleased(KeyEvent e) {
		ConfKeybinding keys = controller.config().keys();
		// If the resource is the primary, we can add editing support
		if (resource.isPrimary()) {
			if (keys.save.match(e))
				save();
			if (keys.undo.match(e))
				undo();
		}
	}

	/**
	 * Set {@link #last} to the current file content.
	 */
	private void fetchLast() {
		last = getMap().get(path);
	}

	/**
	 * Save current modifications &amp; create a history entry for the changed item.<br>
	 * If {@link #current} is {@code null} there is no modification to save.
	 */
	public void save() {
		// Skip if no modifications to save.
		if (current == null || Arrays.equals(last, current))
			return;
		// Save current & create history entry.
		getMap().put(path, current);
		getHistory(path).push(current);
		// Set current to null so we can't save the same thing over and over.
		last = current;
		current = null;
		onSaveSuccess();
	}

	/**
	 * Indicate operation success
	 */
	protected void onSaveSuccess()
	{
		UiUtil.animateSuccess(getCenter(), 500);
	}

	/**
	 * Loads the most recent save from the file history.
	 */
	public void undo() {
		// Reset caches
		last = getHistory(path).pop();
		current = null;
		// Update view with popped content
		updateView();
	}

	/**
	 * @return The resource the content resides in.
	 */
	public JavaResource getResource() {
		return resource;
	}

	/**
	 * @return The path of the content in the resource.
	 */
	public String getPath() {
		return path;
	}

	/**
	 * @param path
	 * 		File path.
	 *
	 * @return Resource of file.
	 */
	protected abstract History getHistory(String path);

	/**
	 * @return Map in resource to use for pulling/putting files.
	 */
	protected abstract Map<String, byte[]> getMap();

	/**
	 * Set the viewport for the current editor mode.
	 */
	protected abstract void updateView();
}

```

`src/main/java/me/coley/recaf/ui/controls/view/FileViewport.java`:

```java
package me.coley.recaf.ui.controls.view;

import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import jregex.Matcher;
import jregex.Pattern;
import me.coley.recaf.control.gui.GuiController;
import me.coley.recaf.plugin.PluginKeybinds;
import me.coley.recaf.ui.controls.HexEditor;
import me.coley.recaf.ui.controls.text.JavaEditorPane;
import me.coley.recaf.ui.controls.text.EditorPane;
import me.coley.recaf.ui.controls.text.model.Language;
import me.coley.recaf.ui.controls.text.model.Languages;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.StringUtil;
import me.coley.recaf.util.UiUtil;
import me.coley.recaf.workspace.History;
import me.coley.recaf.workspace.JavaResource;

import java.awt.image.BufferedImage;
import java.util.Map;

/**
 * Multi-view wrapper for files in resources.
 *
 * @author Matt
 */
public class FileViewport extends EditorViewport {
	private static final float TEXT_THRESHOLD = 0.9f;
	private static final Pattern TEXT_MATCHER = new Pattern(
			"[\\w\\d\\s\\<\\>\\-\\\\\\/\\.:,!@#+$%^&*\"=\\[\\]?;\\{\\}\\(\\)|]+");
	private FileMode overrideMode;

	/**
	 * @param controller
	 * 		Controller context.
	 * @param resource
	 * 		Resource the file resides in.
	 * @param path
	 * 		Path to file.
	 */
	public FileViewport(GuiController controller, JavaResource resource, String path) {
		super(controller, resource, path);
	}

	@Override
	protected void handleKeyReleased(KeyEvent e) {
		super.handleKeyReleased(e);
		// Custom bind support
		PluginKeybinds.getInstance().getFileViewBinds().forEach((bind, action) -> {
			try {
				if (bind.match(e))
					action.accept(this);
			} catch(Throwable t) {
				Log.error(t, "Failed executing file keybind action");
			}
		});
	}

	@Override
	protected History getHistory(String path) {
		return resource.getFileHistory(path);
	}


	@Override
	protected Map<String, byte[]> getMap() {
		return resource.getFiles();
	}

	@Override
	public void updateView() {
		updateFileMode(getFileMode());
	}

	/**
	 * @return Mode that indicated which view to use for modifying files.
	 */
	public FileMode getFileMode() {
		if (overrideMode != null)
			return overrideMode;
		return controller.config().display().fileEditorMode;
	}

	private void updateFileMode(FileMode mode) {
		switch(mode) {
			case AUTOMATIC:
				// Determine which resource mode to use based on the % of the
				// content matches common text symbols. Binary data will likely
				// not contain a high % of legible text content.
				String text = new String(last);
				Matcher m = TEXT_MATCHER.matcher(text);
				float size = 0;
				while (m.find())
					size += m.length();
				if (size / text.length() > TEXT_THRESHOLD)
					updateFileMode(FileMode.TEXT);
				else {
					// Check for image types
					BufferedImage img = UiUtil.toImage(last);
					if(img != null) {
						ImageView view = new ImageView(UiUtil.toFXImage(img));
						setCenter(view);
						return;
					}
					// Fall back to default hex mode.
					updateFileMode(FileMode.HEX);
				}
				return;
			case TEXT:
				updateTextMode();
				break;
			case HEX:
			default:
				updateHexMode();
				break;
		}
		// Focus after setting
		if (getCenter() != null)
			getCenter().requestFocus();
	}

	/**
	 * Handle the current file as a binary type.
	 */
	private void updateHexMode() {
		// Fallback: Hex editor
		HexEditor hex = new HexEditor(last);
		hex.setContentCallback(array -> current = array);
		hex.setEditable(resource.isPrimary());
		setCenter(hex);
	}

	/**
	 * Handle the current file as a text type.
	 */
	private void updateTextMode() {
		// Get language by extension
		String ext = "none";
		if (path.contains("."))
			ext = path.substring(path.lastIndexOf(".") + 1);
		Language lang = Languages.find(ext);
		// Create editor
		EditorPane pane = lang.getName().equals("Java") ?
				new JavaEditorPane(controller, resource) :
				new EditorPane<>(controller, lang, (a, b) -> null);
		pane.setText(new String(last));
		pane.scrollToTop();
		pane.setWrapText(lang.doWrap() || controller.config().display().forceWordWrap);
		pane.setEditable(resource.isPrimary());
		pane.setOnKeyReleased(e -> current = pane.getText().getBytes());
		setCenter(pane);
	}

	/**
	 * Set a new mode to view files in then refresh the view.
	 *
	 * @param overrideMode
	 * 		New mode to view files in.
	 */
	public void setOverrideMode(FileMode overrideMode) {
		this.overrideMode = overrideMode;
		updateView();
	}

	/**
	 * @return Controller
	 */
	public GuiController getController() {
		return controller;
	}

	/**
	 * Viewport editor type.
	 */
	public enum FileMode {
		AUTOMATIC, TEXT, HEX;

		@Override
		public String toString() {
			return StringUtil.toString(this);
		}
	}
}

```

`src/main/java/me/coley/recaf/util/AccessFlag.java`:

```java
package me.coley.recaf.util;

import com.google.common.base.Joiner;
import com.google.common.collect.Iterables;
import com.google.common.collect.MultimapBuilder;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;
import org.objectweb.asm.Opcodes;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Utility for handling access flags.
 *
 * @author Matt
 * @author Andy Li
 */
public enum AccessFlag {
	ACC_PUBLIC(Opcodes.ACC_PUBLIC, "public", true, Type.CLASS, Type.INNER_CLASS, Type.METHOD, Type.FIELD),
	ACC_PRIVATE(Opcodes.ACC_PRIVATE, "private", true, Type.INNER_CLASS, Type.METHOD, Type.FIELD),
	ACC_PROTECTED(Opcodes.ACC_PROTECTED, "protected", true, Type.INNER_CLASS, Type.METHOD, Type.FIELD),
	ACC_STATIC(Opcodes.ACC_STATIC, "static", true, Type.INNER_CLASS, Type.METHOD, Type.FIELD),
	ACC_FINAL(Opcodes.ACC_FINAL, "final", true, Type.CLASS, Type.INNER_CLASS, Type.METHOD, Type.FIELD, Type.PARAM),
	ACC_SYNCHRONIZED(Opcodes.ACC_SYNCHRONIZED, "synchronized", true, Type.METHOD),
	ACC_SUPER(Opcodes.ACC_SUPER, "super", false, Type.CLASS),
	ACC_BRIDGE(Opcodes.ACC_BRIDGE, "bridge", false, Type.METHOD),
	ACC_VOLATILE(Opcodes.ACC_VOLATILE, "volatile", true, Type.FIELD),
	ACC_VARARGS(Opcodes.ACC_VARARGS, "varargs", false, Type.METHOD),
	ACC_TRANSIENT(Opcodes.ACC_TRANSIENT, "transient", true, Type.FIELD),
	ACC_NATIVE(Opcodes.ACC_NATIVE, "native", true, Type.METHOD),
	ACC_INTERFACE(Opcodes.ACC_INTERFACE, "interface", true, Type.CLASS, Type.INNER_CLASS),
	ACC_ABSTRACT(Opcodes.ACC_ABSTRACT, "abstract", true, Type.CLASS, Type.INNER_CLASS, Type.METHOD),
	ACC_STRICT(Opcodes.ACC_STRICT, "strictfp", true, Type.METHOD),
	ACC_SYNTHETIC(Opcodes.ACC_SYNTHETIC, "synthetic", false,
			Type.CLASS, Type.INNER_CLASS, Type.METHOD, Type.FIELD, Type.PARAM),
	ACC_ANNOTATION(Opcodes.ACC_ANNOTATION, "annotation", false, Type.CLASS, Type.INNER_CLASS),
	ACC_ENUM(Opcodes.ACC_ENUM, "enum", true, Type.CLASS, Type.INNER_CLASS, Type.FIELD),
	ACC_MODULE(Opcodes.ACC_MODULE, "module", false, Type.CLASS),
	ACC_MANDATED(Opcodes.ACC_MANDATED, "mandated", false, Type.PARAM);

	private static final Joiner JOINER = Joiner.on(' ').skipNulls();
	private static final SetMultimap<Integer, AccessFlag> maskToFlagsMap;
	private static final Map<String, AccessFlag> nameToFlagMap;
	private static final SetMultimap<Type, AccessFlag> typeToFlagsMap;

	static {
		AccessFlag[] flags = values();
		SetMultimap<Integer, AccessFlag> maskMap = MultimapBuilder.SetMultimapBuilder
				.linkedHashKeys(flags.length)
				.enumSetValues(AccessFlag.class)
				.build();
		Map<String, AccessFlag> nameMap = new LinkedHashMap<>(flags.length);
		SetMultimap<Type, AccessFlag> typeMap = MultimapBuilder.SetMultimapBuilder
				.enumKeys(Type.class)
				.enumSetValues(AccessFlag.class)
				.build();
		for (AccessFlag flag : flags) {
			maskMap.put(flag.mask, flag);
			nameMap.put(flag.name, flag);
			flag.types.forEach(type -> typeMap.put(type, flag));
		}
		maskToFlagsMap = Multimaps.unmodifiableSetMultimap(maskMap);
		nameToFlagMap = Collections.unmodifiableMap(nameMap);
		typeToFlagsMap = Multimaps.unmodifiableSetMultimap(typeMap);
		Type.populateOrder();  // lazy load
	}

	/**
	 * @param mask
	 * 		Access flags mask.
	 *
	 * @return Set of applicable flags.
	 */
	public static Set<AccessFlag> getFlags(int mask) {
		return maskToFlagsMap.get(mask);
	}

	/**
	 * @param type
	 * 		Flag type.
	 *
	 * @return Set of flags that belong to the type group.
	 */
	public static Set<AccessFlag> getApplicableFlags(Type type) {
		return typeToFlagsMap.get(type);
	}

	/**
	 * @param type
	 * 		Flag type.
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return Set of flags that belong to the type group in the access flag mask.
	 */
	public static Set<AccessFlag> getApplicableFlags(Type type, int acc) {
		Set<AccessFlag> flags = EnumSet.noneOf(AccessFlag.class);
		for (AccessFlag applicableFlag : getApplicableFlags(type))
			if (applicableFlag.has(acc))
				flags.add(applicableFlag);
		return flags;
	}

	/**
	 * @param type
	 * 		Flag type.
	 * @param flags
	 * 		Collection of flags.
	 *
	 * @return Sorted order of flags.
	 */
	public static List<AccessFlag> sort(Type type, Collection<AccessFlag> flags) {
		List<AccessFlag> list;
		if (flags instanceof List) {
			list = (List<AccessFlag>) flags;
		} else {
			list = new ArrayList<>(flags);
		}
		list.sort(type.recommendOrderComparator);
		return list;
	}

	/**
	 * @param name
	 * 		Name of flag.
	 *
	 * @return Flag from name.
	 */
	public static AccessFlag getFlag(String name) {
		return nameToFlagMap.get(name);
	}

	/**
	 * @param flags
	 * 		Array of access flags.
	 *
	 * @return Access flag mask.
	 */
	public static int createAccess(AccessFlag... flags) {
		int acc = 0;
		for (AccessFlag flag : flags) flag.set(acc);
		return acc;
	}

	/**
	 * @param acc
	 * 		Access flag mask.
	 * @param flags
	 * 		Array of flags to check exist in the mask.
	 *
	 * @return {@code true} if all specified flags exist in the mask.
	 */
	public static boolean hasAll(int acc, AccessFlag... flags) {
		for (AccessFlag flag : flags) {
			if (!flag.has(acc)) return false;
		}
		return true;
	}

	/**
	 * Flag mask value.
	 */
	private final int mask;
	/**
	 * Flag identifier.
	 */
	private final String name;
	/**
	 * If the flag is treated as a keyword by the Java compiler.
	 */
	private final boolean isKeyword;
	/**
	 * Applicable flag type groups.
	 */
	private final Set<Type> types;

	AccessFlag(int mask, String name, boolean isKeyword, Set<Type> types) {
		this.mask = mask;
		this.name = name;
		this.isKeyword = isKeyword;
		this.types = Collections.unmodifiableSet(types);
	}

	AccessFlag(int mask, String name, boolean isKeyword, Type type) {
		this(mask, name, isKeyword, Collections.singleton(type));
	}

	AccessFlag(int mask, String name, boolean isKeyword, Type firstType, Type... restTypes) {
		this(mask, name, isKeyword, EnumSet.of(firstType, restTypes));
	}

	/**
	 * @return Access flag mask.
	 */
	public int getMask() {
		return mask;
	}

	/**
	 * @param access Access flag mask.
	 * @return {@code true} if the flag contains the mask.
	 */
	public boolean has(int access) {
		return (access & mask) != 0;
	}

	/**
	 * @param access Access flag mask.
	 * @return Mask combined with the given access flag mask.
	 */
	public int set(int access) {
		return access | mask;
	}

	/**
	 * @param access Access flag mask.
	 * @return Mask without the current flag.
	 */
	public int clear(int access) {
		return access & (~mask);
	}

	/**
	 * @return Applicable targets for the current flag.
	 */
	public Set<Type> getTypes() {
		return types;
	}

	/**
	 * @return Flag identifier.
	 */
	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return getCodeFriendlyName();
	}

	/**
	 * @param flags
	 * 		Collection of flags.
	 *
	 * @return String representation of flags.
	 */
	public static String toString(Iterable<AccessFlag> flags) {
		// Don't include ACC_SUPER, is meaningless
		return JOINER.join(Iterables.filter(flags, flag -> flag != ACC_SUPER));
	}

	/**
	 * @param type
	 * 		Flag type.
	 * @param flags
	 * 		Collection of flags.
	 *
	 * @return String representation of flags in sorted order.
	 */
	public static String sortAndToString(Type type, Collection<AccessFlag> flags) {
		List<AccessFlag> list;
		try {
			list = sort(type, flags);
		} catch (UnsupportedOperationException ex) { // Collection is unmodifiable
			list = sort(type, new ArrayList<>(flags));
		}
		return toString(list);
	}

	/**
	 * @param type
	 * 		Flag type.
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return String representation of flags in sorted order.
	 */
	public static String sortAndToString(Type type, int acc) {
		return sortAndToString(type, getApplicableFlags(type, acc));
	}

	/**
	 * @return Flag identifier with surrounding comments if the identifier is not a Java keyword.
	 */
	public String getCodeFriendlyName() {
		return isKeyword ? this.name : "/* " + name + " */"; // comment out non-keyword
	}

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the public flag.
	 */
	public static boolean isPublic(int acc) { return ACC_PUBLIC.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the private flag.
	 */
	public static boolean isPrivate(int acc) { return ACC_PRIVATE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the protected flag.
	 */
	public static boolean isProtected(int acc) { return ACC_PROTECTED.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the static flag.
	 */
	public static boolean isStatic(int acc) { return ACC_STATIC.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the final flag.
	 */
	public static boolean isFinal(int acc) { return ACC_FINAL.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the synchronized flag.
	 */
	public static boolean isSynchronized(int acc) { return ACC_SYNCHRONIZED.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the super flag.
	 */
	public static boolean isSuper(int acc) { return ACC_SUPER.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the bridge flag.
	 */
	public static boolean isBridge(int acc) { return ACC_BRIDGE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the volatile flag.
	 */
	public static boolean isVolatile(int acc) { return ACC_VOLATILE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the varargs flag.
	 */
	public static boolean isVarargs(int acc) { return ACC_VARARGS.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the transient flag.
	 */
	public static boolean isTransient(int acc) { return ACC_TRANSIENT.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the native flag.
	 */
	public static boolean isNative(int acc) { return ACC_NATIVE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the interface flag.
	 */
	public static boolean isInterface(int acc) { return ACC_INTERFACE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the abstract flag.
	 */
	public static boolean isAbstract(int acc) { return ACC_ABSTRACT.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the strict <i>(Floating point math)</i> flag.
	 */
	public static boolean isStrict(int acc) { return ACC_STRICT.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the synthetic flag.
	 */
	public static boolean isSynthetic(int acc) { return ACC_SYNTHETIC.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the annotation flag.
	 */
	public static boolean isAnnotation(int acc) { return ACC_ANNOTATION.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the enum flag.
	 */
	public static boolean isEnum(int acc) { return ACC_ENUM.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the module flag.
	 */
	public static boolean isModule(int acc) { return ACC_MODULE.has(acc); }

	/**
	 * @param acc
	 * 		Access flag mask.
	 *
	 * @return {@code true} when the mask contains the mandated flag.
	 */
	public static boolean isMandated(int acc) { return ACC_MANDATED.has(acc); }

	/**
	 * Flag group.
	 */
	public enum Type {
		CLASS("public abstract final strictfp"),
		INNER_CLASS("public protected private abstract static final strictfp"),
		METHOD("public protected private abstract static final synchronized native strictfp"),
		FIELD("public protected private static final transient volatile"),
		PARAM("final");

		private static void populateOrder() {  // lazy load
			for (Type type : values()) {
				List<AccessFlag> orderList = type.orderList;
				orderList.clear();
				orderList.addAll(parseModifierOrder(type.order));
			}
		}

		private static List<AccessFlag> parseModifierOrder(String string) {
			if (string == null) return Collections.emptyList();
			return Arrays.stream(string.split(" "))
					.map(nameToFlagMap::get)
					.map(Objects::requireNonNull)
					.collect(Collectors.toList());
		}

		private final String order;
		private final List<AccessFlag> orderList = new ArrayList<>();
		/**
		 * Unmodifiable view of `orderList`
 		 */
		public final List<AccessFlag> recommendOrder = Collections.unmodifiableList(orderList);
		/**
		 * Comparator to sort flags by their recommended ordering.
		 */
		public final Comparator<AccessFlag> recommendOrderComparator;

		Type(String recommendOrder) {
			this.order = recommendOrder;
			this.recommendOrderComparator = Comparator.comparingInt(this::index);
		}

		private int index(AccessFlag flag) {
			if (recommendOrder.isEmpty()) return 0; // not intialized yet
			int idx = recommendOrder.indexOf(flag);
			return idx == -1 ? Integer.MAX_VALUE : idx;
		}
	}
}
```

`src/main/java/me/coley/recaf/util/AutoCompleteUtil.java`:

```java
package me.coley.recaf.util;

import me.coley.recaf.Recaf;
import me.coley.recaf.workspace.Workspace;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Type;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Autocomplete utility.
 *
 * @author Matt
 * @author Andy Li
 */
public class AutoCompleteUtil {
	/**
	 * A sorted list of class names for auto-completion,
	 * including {@linkplain ClasspathUtil#getSystemClassNames() the system's} and
	 * {@linkplain Workspace#getClassNames()} the current input's}.
	 */
	private static Set<String> cachedClassNames;

	/**
	 * Computes and/or returns a sorted list of class names available for completion.
	 */
	private static Stream<String> classNames() {
		Set<String> systemClassNames = ClasspathUtil.getSystemClassNames();
		Optional<Workspace> opt = Optional.ofNullable(Recaf.getCurrentWorkspace());
		if (opt.isPresent()) {
			Set<String> inputClasses = opt.get().getClassNames();
			int totalSize = inputClasses.size() + systemClassNames.size();
			cachedClassNames = Collections.unmodifiableSet(Stream
					.concat(inputClasses.stream(), systemClassNames.stream())
					.distinct()
					.sorted(Comparator.naturalOrder())  // Pre-sort to save some time
					.collect(Collectors.toCollection(() -> new LinkedHashSet<>(totalSize))));
		} else {
			cachedClassNames = systemClassNames;
		}
		return cachedClassNames.stream();
	}

	// =================================================================== //

	/**
	 * Completes internal names.
	 *
	 * @param part
	 * 		current token to complete on
	 *
	 * @return a list of internal name completions, ordered alphabetically
	 */
	public static List<String> internalName(String part) {
		String key = part.trim();
		if (part.isEmpty())
			return Collections.emptyList();
		return classNames()
				.filter(name -> name.startsWith(key) && !name.equals(key))
				.collect(Collectors.toList());
	}

	/**
	 * Completes descriptors.
	 *
	 * @param part
	 * 		Current token to complete on
	 *
	 * @return List of descriptor completions, ordered alphabetically.
	 */
	public static List<String> descriptorName(String part) {
		part = part.trim();
		if (part.isEmpty())
			return Collections.emptyList();
		StringBuilder prefixBuilder = new StringBuilder(1);
		StringBuilder keyBuilder = new StringBuilder(part.length() - 1);
		for (char c : part.toCharArray()) {
			if (keyBuilder.length() == 0) {
				// Separate the prefix (`L` or `[L` etc) from the actual token for matching
				if(c == 'L' || c == '[') {
					prefixBuilder.append(c);
					continue;
				}
			} else if (c == ';') {
				// Already completed, don't bother
				return Collections.emptyList();
			}
			keyBuilder.append(c);
		}
		// No tokens to complete or no valid prefix found.
		if (prefixBuilder.length() == 0 || prefixBuilder.indexOf("L") == -1 || keyBuilder.length() == 0)
			return Collections.emptyList();
		//
		String prefix = prefixBuilder.toString();
		String key = keyBuilder.toString();
		return classNames()
				.filter(name -> name.startsWith(key))
				// .sorted()                       // Input stream is already sorted
				.map(name -> prefix + name + ";")  // Re-adds the prefix and the suffix to the suggestions
				.collect(Collectors.toList());
	}

	// =================================================================== //

	/**
	 * Completes methods.
	 *
	 * @param line
	 * 		Current line to complete.
	 *
	 * @return List of method completions, ordered alphabetically.
	 */
	public static List<String> method(String line) {
		return matchSignatures(line,
				c -> Arrays.stream(c.getDeclaredMethods())
						.map(md -> md.getName().concat(Type.getMethodDescriptor(md))),
				cr -> ClassUtil.getMethodDefs(cr).stream()
						.map(p -> p.getKey() + p.getValue()));
	}

	/**
	 * Completes fields.

	 * @param line
	 * 		Current line to complete.
	 *
	 * @return List of field completions, ordered alphabetically.
	 */
	public static List<String> field(String line) {
		return matchSignatures(line,
				c -> Arrays.stream(c.getDeclaredFields())
						.map(fd -> fd.getName() + " " + Type.getType(fd.getType())),
				cr -> ClassUtil.getFieldDefs(cr).stream()
						.map(p -> p.getKey()  + " " + p.getValue()));
	}

	/**
	 * Completes signatures.
	 *
	 * @param line
	 * 		Current line to complete.
	 * @param signaturesFromClass
	 * 		The function used to map {@link Class classes} to signatures.
	 * @param signaturesFromNode
	 * 		The function used to map {@link ClassReader}s to signatures.
	 *
	 * @return List of signature completions, ordered alphabetically.
	 */
	private static List<String> matchSignatures(String line,
	                                            Function<Class<?>, Stream<String>> signaturesFromClass,
	                                            Function<ClassReader, Stream<String>> signaturesFromNode) {
		int dot = line.indexOf('.');
		if (dot == -1)
			return Collections.emptyList();
		String owner = line.substring(0, dot).trim();
		String member = line.substring(dot + 1);
		// Assembler should have already run the parse chain, so we can fetch values
		Stream<String> signatures = null;
		// Attempt to check against workspace classes, fallback using runtime classes
		Optional<Workspace> opt = Optional.ofNullable(Recaf.getCurrentWorkspace());
		if (opt.isPresent()) {
			Workspace in = opt.get();
			ClassReader cr = in.getClassReader(owner);
			if (cr != null)
				signatures = signaturesFromNode.apply(cr);
		}
		if (signatures == null) {
			// Check runtime
			Optional<Class<?>> c = ClasspathUtil.getSystemClassIfExists(owner.replace('/', '.'));
			signatures = c.map(signaturesFromClass).orElse(null);
		}
		if (signatures != null) {
			return signatures
					.filter(s -> s.startsWith(member))
					.sorted(Comparator.naturalOrder())
					.collect(Collectors.toList());
		} else {
			return Collections.emptyList();
		}
	}
}
```

`src/main/java/me/coley/recaf/util/ClassUtil.java`:

```java
package me.coley.recaf.util;

import me.coley.recaf.Recaf;
import me.coley.recaf.util.struct.Pair;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.objectweb.asm.ClassReader.*;

/**
 * Utilities for dealing with class-file loading/parsing.
 *
 * @author Matt
 */
public class ClassUtil {
	/**
	 * The offset from which a version and the version constant value is. For example, Java 8 is 52 <i>(44 + 8)</i>.
	 */
	public static final int VERSION_OFFSET = 44;

	/**
	 * @param name
	 * 		Internal class name.
	 *
	 * @return {@link org.objectweb.asm.ClassReader} loaded from runtime.
	 */
	public static ClassReader fromRuntime(String name) {
		try {
			return new ClassReader(name);
		} catch(IOException e) {
			// Expected / allowed: ignore these
		} catch(Exception ex) {
			// Unexpected
			throw new IllegalStateException("Failed to load class from runtime: " + name, ex);
		}
		return null;
	}

	/**
	 * @param reader
	 * 		Class reader to generate a node from.
	 * @param readFlags
	 * 		Flags to apply when generating the node.
	 *
	 * @return Node from reader.
	 */
	public static ClassNode getNode(ClassReader reader, int readFlags) {
		ClassNode node = new ClassNode();
		reader.accept(node, readFlags);
		return node;
	}

	/**
	 * @param node
	 * 		Node to convert back to bytecode.
	 * @param writeFlags
	 * 		Writer flags to use in conversion.
	 *
	 * @return Class bytecode.
	 */
	public static byte[] toCode(ClassNode node, int writeFlags) {
		ClassWriter cw = new ClassWriter(writeFlags);
		node.accept(cw);
		return cw.toByteArray();
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 * @param name
	 * 		Name of method to check.
	 * @param desc
	 * 		Descriptor of method to check.
	 *
	 * @return {@code true} if the {@link org.objectweb.asm.ClassReader} contains the method by the
	 * given name &amp; descriptor.
	 */
	public static boolean containsMethod(ClassReader reader, String name, String desc) {
		boolean[] contains = {false};
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public MethodVisitor visitMethod(int access, String vname, String vdesc, String
					signature, String[] exceptions) {
				if (name.equals(vname) && vdesc.equals(desc)) contains[0] = true;
				return null;
			}
		}, SKIP_DEBUG | SKIP_CODE);
		return contains[0];
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 * @param name
	 * 		Name of field to check.
	 * @param desc
	 * 		Descriptor of field to check.
	 *
	 * @return {@code true} if the {@link org.objectweb.asm.ClassReader} contains the field by the
	 * given name &amp; descriptor.
	 */
	public static boolean containsField(ClassReader reader, String name, String desc) {
		boolean[] contains = {false};
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public FieldVisitor visitField(int access, String vname, String vdesc, String
					signature, Object value) {
				if (name.equals(vname) && vdesc.equals(desc)) contains[0] = true;
				return null;
			}
		}, SKIP_DEBUG | SKIP_CODE);
		return contains[0];
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 * @param readFlags
	 * 		ClassReader flags to apply.
	 * @param name
	 * 		Name of method to fetch.
	 * @param desc
	 * 		Descriptor of method to fetch.
	 *
	 * @return {@link org.objectweb.asm.tree.MethodNode Method} matching the given definition in
	 * the given class.
	 */
	public static MethodNode getMethod(ClassReader reader, int readFlags, String name, String desc) {
		MethodNode[] method = {null};
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public MethodVisitor visitMethod(int access, String vname, String vdesc, String
					signature, String[] exceptions) {
				if(name.equals(vname) && vdesc.equals(desc)) {
					MethodNode vmethod = new MethodNode(access, vname, vdesc, signature, exceptions);
					method[0] = vmethod;
					return vmethod;
				}
				return null;
			}
		}, readFlags);
		return method[0];
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 *
	 * @return List of Pair&lt;method-name, method-descriptor&gt;
	 */
	public static List<Pair<String, String>> getMethodDefs(ClassReader reader) {
		List<Pair<String, String>> methods = new ArrayList<>();
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public MethodVisitor visitMethod(int access, String vname, String vdesc, String
					signature, String[] exceptions) {
				methods.add(new Pair<>(vname, vdesc));
				return null;
			}
		}, SKIP_DEBUG | SKIP_CODE);
		return methods;
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 * @param readFlags
	 * 		ClassReader flags to apply.
	 * @param name
	 * 		Name of field to fetch.
	 * @param desc
	 * 		Descriptor of field to fetch.
	 *
	 * @return {@link org.objectweb.asm.tree.FieldNode Field} matching the given definition in
	 * the given class.
	 */
	public static FieldNode getField(ClassReader reader, int readFlags, String name, String desc) {
		FieldNode[] field = {null};
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public FieldVisitor visitField(int access, String vname, String vdesc, String signature, Object value) {
				if(name.equals(vname) && vdesc.equals(desc)) {
					FieldNode vfield = new FieldNode(access, vname, vdesc, signature, value);
					field[0] = vfield;
					return vfield;
				}
				return null;
			}
		}, readFlags);
		return field[0];
	}

	/**
	 * @param reader
	 * 		Class to visit.
	 *
	 * @return List of Pair&lt;field-name, field-descriptor&gt;
	 */
	public static List<Pair<String, String>> getFieldDefs(ClassReader reader) {
		List<Pair<String, String>> fields = new ArrayList<>();
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION) {
			@Override
			public FieldVisitor visitField(int access, String vname, String vdesc, String
					signature, Object value) {
				fields.add(new Pair<>(vname, vdesc));
				return null;
			}
		}, SKIP_DEBUG | SKIP_CODE);
		return fields;
	}

	/**
	 * Remove a field from the class.
	 *
	 * @param reader
	 * 		Reader containing the class.
	 * @param name
	 * 		Name of field to remove.
	 * @param desc
	 * 		Descriptor of field to remove.
	 *
	 * @return Updated bytecode of class.
	 */
	public static byte[] removeField(ClassReader reader, String name, String desc) {
		ClassWriter cw = new ClassWriter(0);
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION, cw) {
			@Override
			public FieldVisitor visitField(int access, String vname, String vdesc, String
					signature, Object value) {
				// Skip given field, effectively removing it
				if (vname.endsWith(name) && vdesc.endsWith(desc))
					return null;
				return super.visitField(access, vname, vdesc, signature, value);
			}
		}, EXPAND_FRAMES);
		return cw.toByteArray();
	}

	/**
	 * Remove a method from the class.
	 *
	 * @param reader
	 * 		Reader containing the class.
	 * @param name
	 * 		Name of method to remove.
	 * @param desc
	 * 		Descriptor of method to remove.
	 *
	 * @return Updated bytecode of class.
	 */
	public static byte[] removeMethod(ClassReader reader, String name, String desc) {
		ClassWriter cw = new ClassWriter(0);
		reader.accept(new ClassVisitor(Recaf.ASM_VERSION, cw) {
			@Override
			public MethodVisitor visitMethod(int access, String vname, String vdesc, String
					signature, String[] exceptions) {
				// Skip given method, effectively removing it
				if (vname.endsWith(name) && vdesc.endsWith(desc))
					return null;
				return super.visitMethod(access, vname, vdesc, signature, exceptions);
			}
		}, EXPAND_FRAMES);
		return cw.toByteArray();
	}

	/**
	 * @param code
	 * 		Class bytecode.
	 *
	 * @return Class access. If an parse error occurred then return is {@code 0}.
	 */
	public static int getAccess(byte[] code) {
		try {
			return new ClassReader(code).getAccess();
		} catch(Exception ex) { /* Bad class file? */ return 0;}
	}

	/**
	 * @param code
	 * 		Class bytecode.
	 *
	 * @return Class major version. If an parse error occurred then return is {@link Opcodes#V1_8}.
	 */
	public static int getVersion(byte[] code) {
		try {
			return (((code[6] & 0xFF) << 8) | (code[7] & 0xFF));
		} catch(Exception ex) { /* Bad class file? */ return Opcodes.V1_8;}
	}

	/**
	 * @param data
	 * 		Potential class bytecode.
	 *
	 * @return {@code true} if data has class magic prefix.
	 */
	public static boolean isClass(byte[] data) {
		return data.length >= 4 &&
				0xCAFEBABEL == ((
						(0xFF & data[0]) << 24L |
						(0xFF & data[1]) << 16L |
						(0xFF & data[2]) << 8L  |
						 0xFF & data[3]) & 0xFFFFFFFFL);
	}

	/**
	 * Copies method metadata.
	 *
	 * @param from method to copy from.
	 * @param to method to copy to.
	 */
	public static void copyMethodMetadata(MethodNode from, MethodNode to) {
		if (to.invisibleAnnotations == null && from.invisibleAnnotations != null)
			to.invisibleAnnotations = new ArrayList<>();
		if (to.visibleAnnotations == null && from.visibleAnnotations != null)
			to.visibleAnnotations = new ArrayList<>();
		if (to.invisibleTypeAnnotations == null && from.invisibleTypeAnnotations != null)
			to.invisibleTypeAnnotations = new ArrayList<>();
		if (to.visibleTypeAnnotations == null && from.visibleTypeAnnotations != null)
			to.visibleTypeAnnotations = new ArrayList<>();
		if (to.invisibleLocalVariableAnnotations == null && from.invisibleLocalVariableAnnotations != null)
			to.invisibleLocalVariableAnnotations = new ArrayList<>();
		if (to.visibleLocalVariableAnnotations == null && from.visibleLocalVariableAnnotations != null)
			to.visibleLocalVariableAnnotations = new ArrayList<>();
		updateAnnotationList(to.invisibleAnnotations, from.invisibleAnnotations);
		updateAnnotationList(to.visibleAnnotations, from.visibleAnnotations);
		updateAnnotationList(to.invisibleTypeAnnotations, from.invisibleTypeAnnotations);
		updateAnnotationList(to.visibleTypeAnnotations, from.visibleTypeAnnotations);
		updateAnnotationList(to.invisibleLocalVariableAnnotations, from.invisibleLocalVariableAnnotations);
		updateAnnotationList(to.visibleLocalVariableAnnotations, from.visibleLocalVariableAnnotations);
		to.invisibleParameterAnnotations = from.invisibleParameterAnnotations;
		to.visibleParameterAnnotations = from.visibleParameterAnnotations;
		to.visibleAnnotableParameterCount = from.visibleAnnotableParameterCount;
		to.invisibleAnnotableParameterCount = from.invisibleAnnotableParameterCount;
	}

	@SuppressWarnings("all")
	private static <T extends AnnotationNode> void updateAnnotationList(List<T> to, List<T> from) {
		// No data to copy
		if (from == null)
			return;
		// Add if not null
		if (to != null)
			for (T node : from) {
				String fromType = node.desc;
				// We are replacing the annotation of the matching type.
				// You can only have one of any single type on an item.
				if (node instanceof TypeAnnotationNode) {
					// For type annotations we need to do some extra checks...
					to.removeIf(n -> {
						if (!n.desc.equals(fromType)) {
							return false;
						}
						if (n instanceof TypeAnnotationNode) {
							TypeAnnotationNode fromNode = (TypeAnnotationNode) node;
							TypeAnnotationNode toNode = (TypeAnnotationNode) n;
							// Type paths must match as well, indicating the target is the same
							return fromNode.typePath.toString().equals(toNode.typePath.toString());
						}
						return false;
					});
				} else {
					to.removeIf(n -> n.desc.equals(fromType));
				}

				to.add(node);
			}

	}

	/**
	 * Copies field metadata.
	 *
	 * @param from field to copy from.
	 * @param to field to copy to.
	 */
	public static void copyFieldMetadata(FieldNode from, FieldNode to) {
		to.invisibleAnnotations = from.invisibleAnnotations;
		to.visibleAnnotations = from.visibleAnnotations;
		to.invisibleTypeAnnotations = from.invisibleTypeAnnotations;
		to.visibleTypeAnnotations = from.visibleTypeAnnotations;
	}

	/**
	 * Strip debug information from the given class bytecode.
	 *
	 * @param code
	 * 		Class bytecode.
	 *
	 * @return Class bytecode, modified to remove all debug information.
	 */
	public static byte[] stripDebugForDecompile(byte[] code) {
		if (code == null || code.length <= 10)
			return code;
		ClassReader cr = new ClassReader(code);
		ClassWriter cw = new ClassWriter(0);
		cr.accept(cw, SKIP_DEBUG | EXPAND_FRAMES);
		return cw.toByteArray();
	}

	/**
	 * Validate the class can be parsed by ASM.
	 *
	 * @param value
	 * 		Class bytecode.
	 *
	 * @return {@code true} when the class can be read by ASM.
	 */
	public static boolean isValidClass(byte[] value) {
		if (!isClass(value))
			return false;
		try {
			getNode(new ClassReader(value), SKIP_FRAMES);
			return true;
		} catch(Throwable t) {
			return false;
		}
	}

}

```

`src/main/java/me/coley/recaf/util/ClasspathUtil.java`:

```java
package me.coley.recaf.util;

import me.coley.recaf.Recaf;

import java.io.*;

import java.lang.module.ModuleFinder;
import java.lang.module.ModuleReader;
import java.lang.module.ModuleReference;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import static java.lang.Class.forName;

/**
 * Classpath utility.
 *
 * @author Matt
 * @author Andy Li
 * @author xxDark
 */
public class ClasspathUtil {
	private static final String RECAF_CL = "me.coley.recaf.util.RecafClassLoader";
	/**
	 * The system classloader, provided by {@link ClassLoader#getSystemClassLoader()}.
	 */
	public static final ClassLoader scl = ClassLoader.getSystemClassLoader();

	/**
	 * A sorted, unmodifiable list of all class names
	 */
	private static final Set<String> systemClassNames;

	static {
		try {
			systemClassNames = Collections.unmodifiableSet(scanBootstrapClasses());
		} catch (Exception ex) {
			throw new ExceptionInInitializerError(ex);
		}
		if (!areBootstrapClassesFound()) {
			Log.warn("Bootstrap classes are missing!");
		}
	}

	/**
	 * Check if a resource exists in the current classpath.
	 *
	 * @param path
	 *            Path to resource.
	 * @return {@code true} if resource exists. {@code false} otherwise.
	 */
	public static boolean resourceExists(String path) {
		if (!path.startsWith("/"))
			path = "/" + path;
		return ClasspathUtil.class.getResource(path) != null;
	}

	/**
	 * Fetch a resource as a stream in the current classpath.
	 *
	 * @param path
	 * 		Path to resource.
	 *
	 * @return Stream of resource.
	 */
	public static InputStream resource(String path) {
		if (!path.startsWith("/"))
			path = "/" + path;
		return ClasspathUtil.class.getResourceAsStream(path);
	}

	/**
	 * @return A sorted, unmodifiable list of all class names in the system classpath.
	 */
	public static Set<String> getSystemClassNames() {
		return systemClassNames;
	}

	/**
	 * Checks if bootstrap classes is found in {@link #getSystemClassNames()}.
	 * @return {@code true} if they do, {@code false} if they don't
	 */
	public static boolean areBootstrapClassesFound() {
		return checkBootstrapClassExists(getSystemClassNames());
	}

	/**
	 * Returns the class associated with the specified name, using
	 * {@linkplain #scl the system class loader}.
	 * <br> The class will not be initialized if it has not been initialized earlier.
	 * <br> This is equivalent to {@code Class.forName(className, false, ClassLoader
	 * .getSystemClassLoader())}
	 *
	 * @param className
	 * 		The fully qualified class name.
	 *
	 * @return class object representing the desired class
	 *
	 * @throws ClassNotFoundException
	 * 		if the class cannot be located by the system class loader
	 * @see Class#forName(String, boolean, ClassLoader)
	 */
	public static Class<?> getSystemClass(String className) throws ClassNotFoundException {
		return forName(className, false, ClasspathUtil.scl);
	}

	/**
	 * Check if a class by the given name exists and is accessible by the system classloader.
	 *
	 * @param name
	 * 		The fully qualified class name.
	 *
	 * @return {@code true} if the class exists, {@code false} otherwise.
	 */
	public static boolean classExists(String name) {
		try {
			getSystemClass(name);
			return true;
		} catch(Exception ex) {
			return false;
		}
	}

	/**
	 * Returns the class associated with the specified name, using
	 * {@linkplain #scl the system class loader}.
	 * <br> The class will not be initialized if it has not been initialized earlier.
	 * <br> This is equivalent to {@code Class.forName(className, false, ClassLoader
	 * .getSystemClassLoader())}
	 *
	 * @param className
	 * 		The fully qualified class name.
	 *
	 * @return class object representing the desired class,
	 * or {@code null} if it cannot be located by the system class loader
	 *
	 * @see Class#forName(String, boolean, ClassLoader)
	 */
	public static Optional<Class<?>> getSystemClassIfExists(String className) {
		try {
			return Optional.of(getSystemClass(className));
		} catch (ClassNotFoundException | NullPointerException ex) {
			return Optional.empty();
		}
	}


	/**
	 * @param loader
	 * 		Loader to check.
	 *
	 * @return {@code true} if loader belongs to Recaf.
	 */
	public static boolean isRecafLoader(ClassLoader loader) {
		// Why are all good features only available in JDK9+?
		// See java.lang.ClassLoader#getName().
		if (loader == Recaf.class.getClassLoader()) {
			return true;
		}
		return loader != null && RECAF_CL.equals(loader.getClass().getName());
	}

	/**
	 * @param clazz
	 * 		Class to check.
	 *
	 * @return {@code true} if class is loaded by Recaf.
	 */
	public static boolean isRecafClass(Class<?> clazz) {
		return isRecafLoader(clazz.getClassLoader());
	}

	/**
	 * Internal utility to check if bootstrap classes exist in a list of class names.
	 */
	private static boolean checkBootstrapClassExists(Collection<String> names) {
		String name = Object.class.getName();
		return names.contains(name) || names.contains(name.replace('.', '/'));
	}

	private static Set<String> scanBootstrapClasses() throws Exception {
		int vmVersion = VMUtil.getVmVersion();
		Set<String> classes = new LinkedHashSet<>(4096, 1F);
		if (vmVersion < 9) {
			Method method = ClassLoader.class.getDeclaredMethod("getBootstrapClassPath");
			method.setAccessible(true);
			Field field = URLClassLoader.class.getDeclaredField("ucp");
			field.setAccessible(true);

			Object bootstrapClasspath = method.invoke(null);
			URLClassLoader dummyLoader = new URLClassLoader(new URL[0]);
			Field modifiers = Field.class.getDeclaredField("modifiers");
			modifiers.setAccessible(true);
			modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);
			// Change the URLClassPath in the dummy loader to the bootstrap one.
			field.set(dummyLoader, bootstrapClasspath);
			URL[] urls = dummyLoader.getURLs();
			for (URL url : urls) {
				String protocol = url.getProtocol();
				JarFile jar = null;
				if ("jar".equals(protocol)) {
					jar = ((JarURLConnection)url.openConnection()).getJarFile();
				} else if ("file".equals(protocol)) {
					File file = new File(url.toURI());
					if (!file.isFile()) continue;
					jar = new JarFile(file);
				}
				if (jar == null) continue;
				try {
					Enumeration<? extends JarEntry> enumeration = jar.entries();
					while (enumeration.hasMoreElements()) {
						JarEntry entry = enumeration.nextElement();
						String name = entry.getName();
						if (name.endsWith(".class")) {
							classes.add(name.substring(0, name.length() - 6));
						}
					}
				} finally {
					jar.close();
				}
			}
			return classes;
		} else {
			Set<ModuleReference> references = ModuleFinder.ofSystem().findAll();
			for (ModuleReference ref : references) {
				try (ModuleReader mr = ref.open()) {
					mr.list().forEach(s -> {
						classes.add(s.substring(0, s.length() - 6));
					});
				}
			}
		}
		return classes;
	}
}
```

`src/main/java/me/coley/recaf/util/CollectionUtil.java`:

```java
package me.coley.recaf.util;

import java.util.*;

/**
 * Misc collection utilities.
 */
public class CollectionUtil {
	/**
	 * Copies a collection into a set.
	 *
	 * @param original
	 * 		Original collection.
	 * @param <T>
	 * 		Type of item in collection.
	 *
	 * @return Copied set.
	 */
	public static <T> Set<T> copySet(Collection<T> original) {
		return new HashSet<>(original);
	}

	/**
	 * Copies a collection into a list.
	 *
	 * @param original
	 * 		Original collection.
	 * @param <T>
	 * 		Type of item in collection.
	 *
	 * @return Copied list
	 */
	public static <T> Set<T> copyList(Collection<T> original) {
		return new HashSet<>(original);
	}

	/**
	 * Copies a map into another map.
	 *
	 * @param original
	 * 		Original collection.
	 * @param <K>
	 * 		Type of key items.
	 * @param <V>
	 * 		Type of value items.
	 *
	 * @return Copied map.
	 */
	public static <K, V> Map<K, V> copyMap(Map<K, V> original) {
		return new HashMap<>(original);
	}

	/**
	 * @param original
	 * 		Original map.
	 * @param <K>
	 * 		Type of key items.
	 * @param <V>
	 * 		Type of value items.
	 *
	 * @return Inverted map.
	 */
	public static <V, K> Map<V, K> invert(Map<K, V> original) {
		Map<V, K> inv = new HashMap<>();
		for (Map.Entry<K, V> entry : original.entrySet())
			inv.put(entry.getValue(), entry.getKey());
		return inv;
	}
}

```

`src/main/java/me/coley/recaf/util/DefineUtil.java`:

```java
package me.coley.recaf.util;

import java.lang.reflect.Constructor;

/**
 * Utility for defining classes at runtime.
 * 
 * @author Matt
 */
public class DefineUtil {
	/**
	 * Define a class of the give name via its bytecode.
	 * 
	 * @param name
	 *            Name of the class to define.
	 * @param bytecode
	 *            Bytecode of the class.
	 * @return Instance of the class <i>(Default constructor)</i>
	 * @throws ClassNotFoundException
	 *             Not thrown, only there to satisfy compiler enforced
	 *             exception.
	 * @throws NoSuchMethodException
	 *             Thrown if there is no default constructor in the class.
	 * @throws ReflectiveOperationException
	 *             Thrown if the constructor could not be called.
	 */
	public static Object create(String name, byte[] bytecode) throws ClassNotFoundException, NoSuchMethodException,
			ReflectiveOperationException {
		Class<?> c = new ClassDefiner(name, bytecode).findClass(name);
		Constructor<?> con = c.getDeclaredConstructor();
		return con.newInstance();
	}

	/**
	 * Define a class of the give name via its bytecode.
	 * 
	 * @param name
	 *            Name of the class to define.
	 * @param bytecode
	 *            Bytecode of the class.
	 * @param argTypes
	 *            Constructor type arguments.
	 * @param argValues
	 *            Constructor argument values.
	 * @return Instance of the class.
	 * @throws ClassNotFoundException
	 *             Not thrown, only there to satisfy compiler enforced
	 *             exception.
	 * @throws NoSuchMethodException
	 *             Thrown if a constructor defined by the given type array does
	 *             not exist.
	 * @throws ReflectiveOperationException
	 *             Thrown if the constructor could not be called.
	 */
	public static Object create(String name, byte[] bytecode, Class<?>[] argTypes, Object[] argValues)
			throws ClassNotFoundException, NoSuchMethodException, ReflectiveOperationException {
		Class<?> c = new ClassDefiner(name, bytecode).findClass(name);
		Constructor<?> con = c.getDeclaredConstructor(argTypes);
		return con.newInstance(argValues);
	}

	/**
	 * Simple loader that exposes defineClass. Will only load the supplied
	 * class.
	 * 
	 * @author Matt
	 */
	static class ClassDefiner extends ClassLoader {
		private final byte[] bytecode;
		private final String name;

		public ClassDefiner(String name, byte[] bytecode) {
			super(ClasspathUtil.scl);
			this.name = name;
			this.bytecode = bytecode;
		}

		@Override
		public final Class<?> findClass(String name) throws ClassNotFoundException {
			if (this.name.equals(name)) {
				return defineClass(name, bytecode, 0, bytecode.length, null);
			}
			return super.findClass(name);

		}
	}

}
```

`src/main/java/me/coley/recaf/util/EscapeUtil.java`:

```java
package me.coley.recaf.util;

import org.reactfx.util.TriFunction;

import java.util.HashMap;
import java.util.Map;

/**
 * Escape code replacement utility.
 *
 * @author xxDark
 */
public final class EscapeUtil {
	private static final Map<String, String> WHITESPACE_TO_ESCAPE = new HashMap<>();
	private static final Map<String, String> ESCAPE_TO_WHITESPACE = new HashMap<>();
	private static final char TERMINATOR = '\0';

	private EscapeUtil() {}

	/**
	 * Replaces any unicode-whitespace or common escapable sequence with an escaped sequence.
	 *
	 * @param input
	 * 		Input text.
	 *
	 * @return String without escaped characters.
	 */
	public static String escape(String input) {
		return visit(escapeCommon(input), EscapeUtil::computeUnescapeUnicode);
	}

	/**
	 * Replaces any common escapable sequence with an escaped sequence.
	 *
	 * @param input
	 * 		Input text.
	 *
	 * @return String without common escaped characters.
	 */
	public static String escapeCommon(String input) {
		return visit(input, EscapeUtil::computeUnescapeStandard);
	}

	/**
	 * Replaces any escape code with its literal value.
	 *
	 * @param input
	 * 		Input text.
	 *
	 * @return String with escaped characters.
	 */
	public static String unescape(String input) {
		return unescapeStandard(unescapeUnicode(input));
	}

	/**
	 * Replaces escaped unicode with actual unicode. For example: {@code \u0048}
	 *
	 * @param input
	 * 		Input text.
	 *
	 * @return String with escaped characters.
	 */
	public static String unescapeUnicode(String input) {
		return visit(input, EscapeUtil::computeEscapeUnicode);
	}

	/**
	 * Replaces standard escape codes with literal values. For example: {@code \n}
	 *
	 * @param input
	 * 		Input text.
	 *
	 * @return String with escaped characters.
	 */
	public static String unescapeStandard(String input) {
		return visit(input, EscapeUtil::computeEscapeStandard);
	}

	private static String visit(String input, TriFunction<String, Integer, StringBuilder, Integer> consumer) {
		int len = input.length();
		int cursor = 0;
		StringBuilder builder = new StringBuilder(len);
		while(cursor < len) {
			int consumed = consumer.apply(input, cursor, builder);
			if (consumed == 0) {
				// Nothing consumed, not an escaped character
				char c1 = input.charAt(cursor++);
				builder.append(c1);
				// Does additional character need to be appended?
				if (Character.isHighSurrogate(c1) && cursor < len) {
					char c2 = input.charAt(cursor);
					if (Character.isLowSurrogate(c2)) {
						builder.append(c2);
						cursor += 1;
					}
				}
			} else {
				// Shift cursor by amount consumed
				for (int pt = 0; pt < consumed; ++pt) {
					cursor += Character.charCount(Character.codePointAt(input, cursor));
				}
			}
		}
		return builder.toString();
	}

	private static int computeUnescapeUnicode(String input, int cursor, StringBuilder builder) {
		// Bounds check
		if (cursor >= input.length()) {
			return 0;
		}
		// Check if next character finishes an unescape value, 1 if so, 0 if not.
		String current = String.valueOf(input.charAt(cursor));
		String escaped = WHITESPACE_TO_ESCAPE.get(current);
		if (escaped != null) {
			builder.append(escaped);
			return 1;
		}
		// No replacement
		return 0;
	}

	private static int computeUnescapeStandard(String input, int cursor, StringBuilder builder) {
		// Bounds check
		if (cursor >= input.length()) {
			return 0;
		}
		// Check if next character finishes an unescape value, 1 if so, 0 if not.
		char current = input.charAt(cursor);
		switch(current) {
			case '\n':
				builder.append("\\n");
				return 1;
			case '\r':
				builder.append("\\r");
				return 1;
			case '\t':
				builder.append("\\t");
				return 1;
			case '\\':
				builder.append("\\\\");
				return 1;
			default:
				return 0;
		}
	}

	private static int computeEscapeUnicode(String input, int cursor, StringBuilder builder) {
		// Bounds check
		if (cursor + 1 >= input.length()) {
			return 0;
		}

		// Check for double backslash in prefix "\\\\u" in "\\\\uXXXX"
		boolean initialEscape = input.charAt(cursor) == '\\' && input.charAt(cursor + 1) == '\\';

		// Check prefix "\\u" in "\\uXXXX"
		if (!initialEscape) {
			if (input.charAt(cursor) != '\\' || input.charAt(cursor + 1) != 'u') {
				return 0;
			}
		}

		// Compute escape size, initial is 2 for the "\\u"
		int len = 2;
		// Combined:
		// - Bounds check
		// - Case check for "\\uuXXXX" where 'u' is repeated
		while(cursor + len < input.length() && input.charAt(cursor + len) == 'u') {
			len++;
		}
		// Combined:
		// - Bounds check
		// - Case check for "\\u+XXXX" format
		if (cursor + len < input.length() && input.charAt(cursor + len) == '+') {
			len += 1;
		}
		// Bounds check, then fetch hex value and store in builder, then return total consumed length
		if (cursor + len + 4 <= input.length()) {
			String substring = input.substring(cursor, cursor + len + 4);

			if (initialEscape) {
				builder.append(substring);
				return len + 4;
			}

			String unicode = input.substring(cursor + len, cursor + len + 4);
			try {
				int value = Integer.parseInt(unicode, 16);
				builder.append(value != TERMINATOR ? (char) value : substring);
			} catch(NumberFormatException ignored) {
				return 0;
			}
			return len + 4;
		}
		return 0;
	}

	private static int computeEscapeStandard(String input, int cursor, StringBuilder builder) {
		// Bounds check
		if (cursor + 1 >= input.length()) {
			return 0;
		}
		// Check prefix '\' in "\X"
		if (input.charAt(cursor) != '\\') {
			return 0;
		}
		// Check if next character finishes the escape pattern, 2 if so, 0 if not.
		char next = input.charAt(cursor + 1);
		switch(next) {
			case 'n':
				builder.append('\n');
				return 2;
			case 'r':
				builder.append('\r');
				return 2;
			case 't':
				builder.append('\t');
				return 2;
			case '\\':
				builder.append('\\');
				return 2;
			default:
				return 0;
		}
	}

	static void addWhitespace(String unescape, String escape) {
		// Mapping between whitespace unicode value and character
		WHITESPACE_TO_ESCAPE.put(unescape, escape);
		ESCAPE_TO_WHITESPACE.put(escape, unescape);
	}

	static {
		//Unicode whitespaces
		for (int i = 0; i < 0x20; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x7F; i < 0xA0; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x6E5; i < 0x6E6; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x17B4; i < 0x17B5; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x180B; i < 0x180E; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x2000; i < 0x200F; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x2028; i < 0x202F; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		for (int i = 0x205F; i < 0x206F; i++) {
			addWhitespace(String.valueOf(Character.toChars(i)), "\\u" + String.format("%04X", i));
		}
		addWhitespace(String.valueOf(Character.toChars('\u3164')), "\\u" + String.format("%04X", (int) '\u3164'));
		addWhitespace(String.valueOf(Character.toChars('\u318F')), "\\u" + String.format("%04X", (int) '\u318F'));
	}
}

```

`src/main/java/me/coley/recaf/util/IOUtil.java`:

```java
package me.coley.recaf.util;

import me.coley.recaf.workspace.WarResource;

import java.io.*;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * Faster I/O utils
 *
 * @author xxDark
 */
public final class IOUtil {
    /**
     * Indicates that we can read as many bytes
     * as we want.
     */
    public static final int ANY = Integer.MIN_VALUE;
    /**
     * Default buffer size.
     */
    private static final int BUFFER_SIZE = 4096;

    private IOUtil() {
    }

    /**
     * Transfers data from input to output stream.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param buffer data buffer
     * @param max    maximum amount of bytes to transfer
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(InputStream in, OutputStream out, byte[] buffer, int max) throws IOException {
        int transferred = 0;
        int r;
        while ((max == ANY || max > 0) && (r = in.read(buffer, 0,
                max == ANY ? buffer.length : Math.min(buffer.length, max))) != -1) {
            transferred += r;
            out.write(buffer, 0, r);
            if (max != ANY) {
                max -= r;
            }
        }
        return transferred;
    }

    /**
     * Transfers data from input to output stream.
     * No limits.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param buffer data buffer
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(InputStream in, OutputStream out, byte[] buffer) throws IOException {
        return transfer(in, out, buffer, ANY);
    }

    /**
     * Transfers data from input to output stream.
     *
     * @param in  an input stream
     * @param out an output stream
     * @param max maximum amount of bytes to transfer
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(InputStream in, OutputStream out, int max) throws IOException {
        return transfer(in, out, new byte[BUFFER_SIZE], max);
    }

    /**
     * Transfers data from url to output stream.
     * No limits.
     *
     * @param url    the url
     * @param out    an output stream
     * @param buffer data buffer
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(URL url, OutputStream out, byte[] buffer) throws IOException {
        try (InputStream in = url.openStream()) {
            return transfer(in, out, buffer, ANY);
        }
    }

    /**
     * Transfers data from url to output stream.
     *
     * @param url the url
     * @param out an output stream
     * @param max maximum amount of bytes to transfer
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(URL url, OutputStream out, int max) throws IOException {
        try (InputStream in = url.openStream()) {
            return transfer(in, out, ANY);
        }
    }

    /**
     * Transfers data from url to output stream.
     * No limits.
     *
     * @param url the url
     * @param out an output stream
     * @return amount of bytes read
     * @throws IOException if any I/O error occurs
     */
    public static int transfer(URL url, OutputStream out) throws IOException {
        try (InputStream in = url.openStream()) {
            return transfer(in, out, ANY);
        }
    }

    /**
     * Reads data from input stream to byte array.
     *
     * @param url    the url
     * @param out    an output stream
     * @param buffer data buffer
     * @param max    maximum amount of bytes to transfer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, ByteArrayOutputStream out, byte[] buffer, int max)
            throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, out, buffer, max);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url    the url
     * @param out    an output stream
     * @param length data buffer length
     * @param max    maximum amount of bytes to transfer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, ByteArrayOutputStream out, int length, int max)
            throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, out, length, max);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url    the url
     * @param out    an output stream
     * @param buffer data buffer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, ByteArrayOutputStream out, byte[] buffer) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, out, buffer);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url    the url
     * @param out    an output stream
     * @param length data buffer length
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, ByteArrayOutputStream out, int length) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, out, length);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url the url
     * @param out an output stream
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, ByteArrayOutputStream out) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, out);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in an input stream
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in) throws IOException {
        return toByteArray(in, new ByteArrayOutputStream(in.available()));
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in     an input stream
     * @param buffer data buffer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, byte[] buffer) throws IOException {
        return toByteArray(in, new ByteArrayOutputStream(in.available()), buffer);
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in     an input stream
     * @param length data buffer length
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, int length) throws IOException {
        return toByteArray(in, new ByteArrayOutputStream(in.available()), length);
    }


    /**
     * Reads data from input stream to byte array.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param buffer data buffer
     * @param max    maximum amount of bytes to transfer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, ByteArrayOutputStream out, byte[] buffer, int max)
            throws IOException {
        transfer(in, out, buffer, max);
        return out.toByteArray();
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param length data buffer length
     * @param max    maximum amount of bytes to transfer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, ByteArrayOutputStream out, int length, int max)
            throws IOException {
        return toByteArray(in, out, new byte[length], max);
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param buffer data buffer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, ByteArrayOutputStream out, byte[] buffer) throws IOException {
        return toByteArray(in, out, buffer, ANY);
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in     an input stream
     * @param out    an output stream
     * @param length data buffer length
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, ByteArrayOutputStream out, int length) throws IOException {
        return toByteArray(in, out, new byte[length]);
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param in  an input stream
     * @param out an output stream
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(InputStream in, ByteArrayOutputStream out) throws IOException {
        return toByteArray(in, out, new byte[BUFFER_SIZE]);
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url the url
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url    the url
     * @param buffer data buffer
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, byte[] buffer) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, buffer);
        }
    }

    /**
     * Reads data from input stream to byte array.
     * No limits.
     *
     * @param url    an input stream
     * @param length data buffer length
     * @return array of bytes
     * @throws IOException if any I/O error occurs
     */
    public static byte[] toByteArray(URL url, int length) throws IOException {
        try (InputStream in = url.openStream()) {
            return toByteArray(in, new ByteArrayOutputStream(in.available()), length);
        }
    }

    /**
     * @param path The path to get extension from.
     * @return path extension.
     */
    public static String getExtension(Path path) {
        String name = path.getFileName().toString();
        return name.substring(name.lastIndexOf(".") + 1).toLowerCase();
    }

    /**
     * Same as above, but makes an attempt to detect known
     * extension from file's header first.
     *
     * @param path The path to get extension from.
     * @return path extension.
     */
    public static String detectExtension(Path path) {
        byte[] header;
        try (InputStream in = Files.newInputStream(path)) {
            header = new byte[4];
            // reader header: commonly, it is first 4 bytes
            if (in.read(header) != 4) {
                // oops
                return getExtension(path);
            }
        } catch (IOException e) {
            // fallback to the method above
            Log.warn("Could not determine file type of path: {}", path.getFileName());
            return getExtension(path);
        }
        if (isZipHeader(header)) {
            // maybe it is a jar/war file?
            try (ZipFile zipFile = new ZipFile(path.toFile())) {
                // read first entry
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                if (!entries.hasMoreElements()) {
                    // we cannot check whether it is a jar/war
                    // or not
                    return "zip";
                }
                ZipEntry entry = entries.nextElement();
                byte[] extra = entry.getExtra();
                if (extra == null) {
                    return "zip";
                }
                if (isJarSignature(extra)) {
                    // Check whether jar file is a WAR archive
                    if (zipFile.getEntry(WarResource.WAR_CLASS_PREFIX) != null) {
                        return "war";
                    }
                    String ext = getExtension(path);
                    if ("war".equals(ext)) {
                        // if the user wishes so
                        return "war";
                    }
                    return "jar";
                }
                return "zip";
            } catch (IOException e) {
                // fallback to the method above
                Log.warn("Could not determine file type of path: {}", path.getFileName());
                return getExtension(path);
            }
        }
        return isClassHeader(header) ? "class" : getExtension(path);
    }

    /**
     * @param prefix path prefix
     * @param suffix path suffix
     * @return new created temp path.
     * @throws IOException if any I/O error occur.
     */
    public static Path createTempFile(String prefix, String suffix) throws IOException {
        Path path = Files.createTempFile(prefix, suffix);
        path.toFile().deleteOnExit();
        return path;
    }

    /**
     * @param file
     * the file to convert to path
     * @return path from file
     */
    public static Path toPath(File file) {
        return file.toPath().normalize();
    }

    /**
     * @param path the path
     * @return normalized and absolute path as string
     */
    public static String toString(Path path) {
        return path.toAbsolutePath().normalize().toString();
    }

    /**
     * @param bytes byte array to check.
     * @return {@code true} if byte array represents
     * a zip file header.
     */
    public static boolean isZipHeader(byte[] bytes) {
        if (bytes.length < 4) {
            return false;
        }
        return bytes[0] == (byte) 0x50 && bytes[1] == (byte) 0x4B
                && bytes[2] == (byte) 0x03 && bytes[3] == (byte) 0x04;
    }

    /**
     * @param bytes byte array to check.
     * @return {@code true} if byte array represents
     * a class file header.
     */
    public static boolean isClassHeader(byte[] bytes) {
        return ClassUtil.isClass(bytes);
    }

    /**
     * @param bytes byte array to check.
     * @return {@code true} if byte array represents
     * jar file signature.
     */
    public static boolean isJarSignature(byte[] bytes) {
        if (bytes.length < 2) {
            return false;
        }
        return bytes[0] == -2 && bytes[1] == -54;
    }
}

```

`src/main/java/me/coley/recaf/util/IllegalBytecodePatcherUtil.java`:

```java
package me.coley.recaf.util;

import me.coley.cafedude.classfile.ClassFile;
import me.coley.cafedude.io.ClassFileReader;
import me.coley.cafedude.io.ClassFileWriter;

import java.util.Map;
import me.coley.cafedude.transform.IllegalStrippingTransformer;

/**
 * Utility to attempt basic recovery of classes that crash ASM.
 *
 * @author Matt
 */
public class IllegalBytecodePatcherUtil {
	/**
	 * @param classes
	 * 		Successfully loaded classes in the input.
	 * @param invalidClasses
	 * 		The complete map of invalid classes in the input.
	 * @param value
	 * 		Raw bytecode of a class that crashes ASM.
	 *
	 * @return Modified bytecode, hopefully that yields valid ASM parsable class.
	 * If any exception is thrown the original bytecode is returned.
	 */
	public static byte[] fix(Map<String, byte[]> classes, Map<String, byte[]> invalidClasses, byte[] value) {
		try {
			ClassFile cf = new ClassFileReader().read(value);
			new IllegalStrippingTransformer(cf).transform();
			// Patch oak classes (pre-java)
			//  - CafeDude does this by default
			if (cf.getVersionMajor() < 45 ||(cf.getVersionMajor() == 45 && cf.getVersionMinor() <= 2)) {
				// Bump version into range where class file format uses full length values
				cf.setVersionMajor(45);
				cf.setVersionMinor(3);
			}
			return new ClassFileWriter().write(cf);
		} catch (Throwable t) {
			// Fallback, yield original value
			Log.error(t, "Failed to patch class");
			return value;
		}
	}
}

```

`src/main/java/me/coley/recaf/util/InsnUtil.java`:

```java
package me.coley.recaf.util;

import org.objectweb.asm.tree.AbstractInsnNode;

import java.lang.reflect.Field;

import static org.objectweb.asm.Opcodes.*;

/**
 * Instruction level utilities.
 *
 * @author Matt
 */
public class InsnUtil {
	private static Field INSN_INDEX;

	/**
	 * @param opcode
	 * 		Instruction opcode. Should be of type
	 *        {@link org.objectweb.asm.tree.AbstractInsnNode#INSN}.
	 *
	 * @return value represented by the instruction.
	 *
	 * @throws IllegalArgumentException
	 * 		Thrown if the opcode does not have a known value.
	 */
	public static int getValue(int opcode) {
		switch(opcode) {
			case ICONST_M1:
				return -1;
			case FCONST_0:
			case LCONST_0:
			case DCONST_0:
			case ICONST_0:
				return 0;
			case FCONST_1:
			case LCONST_1:
			case DCONST_1:
			case ICONST_1:
				return 1;
			case FCONST_2:
			case ICONST_2:
				return 2;
			case ICONST_3:
				return 3;
			case ICONST_4:
				return 4;
			case ICONST_5:
				return 5;
			default:
				throw new IllegalArgumentException("Invalid opcode, does not have a known value: " + opcode);
		}
	}

	/**
	 * Calculate the index of an instruction.
	 *
	 * @param ain
	 * 		instruction.
	 *
	 * @return Instruction index.
	 */
	public static int index(AbstractInsnNode ain) {
		try {
			int v = (int) INSN_INDEX.get(ain);
			// Can return -1
			if (v >= 0)
				return v;
		} catch(Exception ex) { /* Fail */ }
		// Fallback
		int index = 0;
		while(ain.getPrevious() != null) {
			ain = ain.getPrevious();
			index++;
		}
		return index;
	}

	/**
	 * Get the first insn connected to the given one.
	 *
	 * @param insn
	 * 		instruction
	 *
	 * @return First insn in the insn-list.
	 */
	public static AbstractInsnNode getFirst(AbstractInsnNode insn) {
		while(insn.getPrevious() != null)
			insn = insn.getPrevious();
		return insn;
	}

	static {
		try {
			INSN_INDEX = AbstractInsnNode.class.getDeclaredField("index");
			INSN_INDEX.setAccessible(true);
		} catch(Exception ex) {
			Log.warn("Failed to fetch AbstractInsnNode index field!");
		}
	}
}

```

`src/main/java/me/coley/recaf/util/InternalElement.java`:

```java
package me.coley.recaf.util;

import java.util.function.Predicate;

/**
 * Mark an object as internal.
 *
 * @author xxDark
 */
public interface InternalElement {
    Predicate<Object> INTERNAL_PREDICATE = o -> o instanceof InternalElement;
    Predicate<Object> NOT_INTERNAL_PREDICATE = INTERNAL_PREDICATE.negate();

    /**
     * Helper method to check if the object
     * is marked as internal or not.
     *
     * @param object
     *      Object to check.
     *
     * @return {@code true} if object is internal, {@code false} otherwise.
     */
    static boolean isInternal(Object object) {
        return object instanceof InternalElement;
    }
}

```

`src/main/java/me/coley/recaf/util/Java9Util.java`:

```java
package me.coley.recaf.util;

import sun.misc.Unsafe;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * Package-private util to deal with modules.
 *
 * @author xxDark
 */
final class Java9Util {

    private static final MethodHandle CLASS_MODULE;
    private static final MethodHandle CLASS_LOADER_MODULE;
    private static final MethodHandle METHOD_MODIFIERS;

    /**
     * Deny all constructions.
     */
    private Java9Util() {
    }

    /**
     * @param klass {@link Class} to get module from.
     * @return {@link Module} of the class.
     */
    static Module getClassModule(Class<?> klass) {
        try {
            return (Module) CLASS_MODULE.invokeExact(klass);
        } catch (Throwable t) {
            // That should never happen.
            throw new AssertionError(t);
        }
    }

    /**
     * @param loader {@link ClassLoader} to get module from.
     * @return {@link Module} of the class.
     */
    static Module getLoaderModule(ClassLoader loader) {
        try {
            return (Module) CLASS_LOADER_MODULE.invokeExact(loader);
        } catch (Throwable t) {
            // That should never happen.
            throw new AssertionError(t);
        }
    }


    /**
     * @param method {@link Method} to change modifiers for.
     * @param modifiers new modifiers.
     */
    static void setMethodModifiers(Method method, int modifiers) {
        try {
            METHOD_MODIFIERS.invokeExact(method, modifiers);
        } catch (Throwable t) {
            // That should never happen.
            throw new AssertionError(t);
        }
    }


    static {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            Unsafe unsafe = (Unsafe) field.get(null);
            field = Lookup.class.getDeclaredField("IMPL_LOOKUP");
            MethodHandles.publicLookup();
            Lookup lookup = (Lookup)
                    unsafe.getObject(unsafe.staticFieldBase(field), unsafe.staticFieldOffset(field));
            MethodType type = MethodType.methodType(Module.class);
            CLASS_MODULE = lookup.findVirtual(Class.class, "getModule", type);
            CLASS_LOADER_MODULE = lookup.findVirtual(ClassLoader.class, "getUnnamedModule", type);
            METHOD_MODIFIERS = lookup.findSetter(Method.class, "modifiers", Integer.TYPE);
        } catch (NoSuchMethodException | IllegalAccessException | NoSuchFieldException ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }
}

```

`src/main/java/me/coley/recaf/util/JavaParserRecovery.java`:

```java
package me.coley.recaf.util;

import com.github.javaparser.Problem;
import com.github.javaparser.TokenRange;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import jregex.Matcher;
import jregex.Pattern;

import java.io.IOException;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.function.Function;

/**
 * Utility for basic code patches to make JavaParser parse more of the code.
 *
 * @author Matt
 * @author Andy Li
 */
public class JavaParserRecovery {
	private static final List<RecoveryStrategy> RECOVERY_STRATEGIES = new ArrayList<>();
	private static final String GROUP_LINE = "line";
	private static final String GROUP_COLUMN = "column";
	private static final Pattern PATTERN_LOCATION = RegexUtil.pattern("line ({" + GROUP_LINE + "}\\d+)," +
			" column ({" + GROUP_COLUMN + "}\\d+)");

	static {
		RECOVERY_STRATEGIES.add(JavaParserRecovery::recoverCFR);
		RECOVERY_STRATEGIES.add(JavaParserRecovery::recoverMissingSemicolon);
		RECOVERY_STRATEGIES.add(JavaParserRecovery::recoverMissingQuote);
		RECOVERY_STRATEGIES.add(JavaParserRecovery::recoverCurlyBraces);
	}

	/**
	 * Clean up the source code generated from decompiler and filter out the problems.
	 *
	 * @param code
	 * 		Source to clean up.
	 * @param problems
	 * 		Known problems.
	 *
	 * @return Cleaned source for parsing
	 */
	public static String filterDecompiledCode(String code, Collection<Problem> problems) {
		// Map the problems that prevent the lexer from doing a full parse.
		ListMultimap<Integer, LexicalError> lexerErrorMap = MultimapBuilder.ListMultimapBuilder
				.treeKeys()
				.arrayListValues().build();
		for (Problem problem : new HashSet<>(problems)) {
			String message = problem.getMessage();
			if (!problem.getLocation().isPresent() && message.contains("at line ")) {
				Matcher matcher = PATTERN_LOCATION.matcher(message);
				if (matcher.find()) {
					int line = Integer.parseInt(matcher.group(GROUP_LINE));
					int column = Integer.parseInt(matcher.group(GROUP_COLUMN));
					lexerErrorMap.put(line, new LexicalError(problem, line, column));
				}
			}
		}
		// Map the problems collection that were found after the lexer completed.
		// These should have more specific locations reported by JavaParser that are associated with AST nodes.
		ListMultimap<Integer, Problem> problemMap = MultimapBuilder.ListMultimapBuilder
				.treeKeys()
				.arrayListValues()
				.build(problems.stream()
						.filter(p -> p.getLocation().flatMap(TokenRange::toRange).isPresent())
						.collect(ImmutableListMultimap.toImmutableListMultimap(p ->
								p.getLocation().flatMap(TokenRange::toRange).get().begin.line, Function.identity())));
		// Rebuild the source with attempted fixes applied
		StringBuilder builder = new StringBuilder(code.length());
		try (LineNumberReader reader = new LineNumberReader(new StringReader(code))) {
			String line;
			while ((line = reader.readLine()) != null) {
				int lineNo = reader.getLineNumber();
				boolean commentOut = false;
				boolean custom = false;
				// Iterate over recovery strategies and attempt to find a fix to the line's problems.
				LineInfo lineInfo = new LineInfo(lineNo, line);
				for (RecoveryStrategy recoveryStrategy : RECOVERY_STRATEGIES) {
					RecoveryType recoveryType = recoveryStrategy.tryRecover(lineInfo, problemMap, lexerErrorMap);
					if (recoveryType == RecoveryType.LINE_COMMENT) {
						commentOut = true;
						break;
					} else if (recoveryType == RecoveryType.TEXT_EDIT) {
						custom = true;
						break;
					}
				}
				// Apply comment recovery if set
				if (commentOut) {
					// Insert line comment, and substring the line by '//'s length.
					// The user's wont see this so its OK. This balances out the change so context actions
					// do not occur at offset positions.
					builder.append("//");
					lineInfo.text = lineInfo.text.substring(2);
				} else if (custom) {
					// When a custom change is applies attempt to keep the document length the same.
					// We don't want document offsets where the user is requesting context actions to not represent
					// what is being parsed.
					//
					// This will screw up selection on the current line, but fixes it for the rest of the file.
					// Its an OK sacrifice in my opinion.
					int sizeDiff = line.length() - lineInfo.text.length();
					if (sizeDiff < 0) {
						// Line is longer than original, cut padding if possible.
						String prefix = lineInfo.text.substring(0, -sizeDiff);
						if (prefix.trim().length() == 0) {
							lineInfo.text = lineInfo.text.substring(-sizeDiff);
						}
					} else if (sizeDiff > 0) {
						// Line is shorter than original, add padding.
						for (int i = 0; i < sizeDiff; i++)
							builder.append(' ');
					}
				}
				builder.append(lineInfo.text).append('\n');
			}
		} catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
		return builder.toString();
	}


	private static RecoveryType recoverCFR(LineInfo line,
										   ListMultimap<Integer, Problem> problemMap,
										   ListMultimap<Integer, LexicalError> lexerErrorMap) {
		String trim = line.text.trim();
		// CFR is known to sometimes generate pseudocode that starts with **
		// Usually "** GOTO label", but can be other operations like "** continue;"
		// If the line starts with the "**" pattern we can just comment it out.
		if (trim.startsWith("** ")) {
			return RecoveryType.LINE_COMMENT;
		}
		// If it doesn't start with the content, we still want to patch it out.
		if (trim.contains("** continue;")) {
			line.text = line.text.replace("** continue;", "continue;");
			return RecoveryType.TEXT_EDIT;
		} else if (trim.contains("** case")) {
			line.text = line.text.replace("** case ", "case ");
			return RecoveryType.TEXT_EDIT;
		} else if (trim.contains("** GOTO ")) {
			// Appending the ';' because these pseudocode statements don't have them, and they always are the last
			// expression on a line (as far as I've seen) so its just simple to slap it on the end.
			line.text = line.text.replace("** GOTO ", "break ") + ";";
			return RecoveryType.TEXT_EDIT;
		}
		return RecoveryType.NONE;
	}

	private static RecoveryType recoverMissingSemicolon(LineInfo line,
														ListMultimap<Integer, Problem> problemMap,
														ListMultimap<Integer, LexicalError> lexerErrorMap) {
		List<Problem> lineProblems = problemMap.get(line.number);
		// Check for the an unfinished expression. The lexer doesn't say something like "oh I want a ';' here".
		// Instead it says "Oh expression, did you mean to assign that?"
		if (lineProblems.size() == 1 && lineProblems.stream()
					.map(Problem::getMessage)
					.anyMatch(m -> m.contains("Parse error. Found \"")
							&& m.contains("expected one of") && m.contains(">>>="))) {
			// Check if there is no ';'
			String trim = line.text.trim();
			if (trim.charAt(trim.length() - 1) != ';') {
				line.text += ";";
				return RecoveryType.TEXT_EDIT;
			}
		}
		return RecoveryType.NONE;
	}

	private static RecoveryType recoverMissingQuote(LineInfo line,
													ListMultimap<Integer, Problem> problemMap,
													ListMultimap<Integer, LexicalError> lexerErrorMap) {
		// Missing quotes come up as lexer problems
		List<LexicalError> lineProblems = lexerErrorMap.get(line.number);
		if (lineProblems.size() == 1) {
			// Check for 'encountered newline after ...' where '...' starts with an opening quote.
			LexicalError error = lineProblems.get(0);
			String msg = error.getMessage();
			if (msg.contains("Encountered: \"\\n\"") && msg.contains("after : \"\\\"")) {
				// Get the offending text
				String afterPattern = "after : \"\\";
				String afterOffendingText = msg.substring(
						msg.lastIndexOf(afterPattern) + afterPattern.length(),
						msg.length() - 1);
				int startOfProblem = line.text.indexOf(afterOffendingText);
				// Rebuild the line
				String originalText = line.text;
				// Estimate where the quote should be, probably before a ')' or ';'
				String suffix = originalText.substring(startOfProblem + 1);
				int end = suffix.indexOf(')');
				if (end < 0) {
					end = suffix.indexOf(';');
				}
				if (end > 0) {
					suffix = suffix.substring(end);
				}
				// To prevent offsetting things in the AST positions, make the quote size big enough
				// so the line length matches the old line length.
				int quoteContentLen = originalText.length() - startOfProblem - suffix.length() - 2;
				String quoteContent = Strings.repeat("?", Math.max(1, quoteContentLen));
				line.text = originalText.substring(0, startOfProblem) + "\"" + quoteContent + "\"" + suffix;
				return RecoveryType.TEXT_EDIT;
			}
		}
		return RecoveryType.NONE;
	}

	private static RecoveryType recoverCurlyBraces(LineInfo line,
												   ListMultimap<Integer, Problem> problemMap,
												   ListMultimap<Integer, LexicalError> lexerErrorMap) {
		// Check the current line
		List<Problem> lineProblems = problemMap.get(line.number);
		if (!lineProblems.isEmpty() && lineProblems.stream().map(Problem::getMessage)
					.noneMatch(m -> m.contains("expected \"}\"") || m.contains("expected \"{\""))) {
			return RecoveryType.LINE_COMMENT;
		}

		// Check the previous line
		List<Problem> priorLineProblems = problemMap.get(line.number - 1);
		if (!priorLineProblems.isEmpty() && priorLineProblems.stream().map(Problem::getMessage)
					.anyMatch(m -> m.contains("expected \"}\""))) {
			return RecoveryType.LINE_COMMENT;
		}

		// Check the next line
		List<Problem> nextLineProblems = problemMap.get(line.number + 1);
		if (!nextLineProblems.isEmpty() && nextLineProblems.stream().map(Problem::getMessage)
					.anyMatch(m -> m.contains("expected \"{\""))) {
			return RecoveryType.LINE_COMMENT;
		}

		// Does not apply here
		return RecoveryType.NONE;
	}

	/**
	 * Recovery implementation interface.
	 */
	interface RecoveryStrategy {
		RecoveryType tryRecover(LineInfo lineInfo,
								ListMultimap<Integer, Problem> problemMap,
								ListMultimap<Integer, LexicalError> lexerErrorMap);
	}

	/**
	 * Type of recovery applied.
	 */
	enum RecoveryType {
		LINE_COMMENT, TEXT_EDIT, NONE;
	}

	/**
	 * Wrapper for lexer errors that JavaParser can't handle in such a way to
	 * provide accurate location info with tokens.
	 */
	static class LexicalError {
		private final Problem problem;
		private final int line;
		private final int column;

		private LexicalError(Problem problem, int line, int column) {
			this.problem = problem;
			this.line = line;
			this.column = column;
		}

		String getMessage() {
			return problem.getMessage();
		}
	}

	/**
	 * Line info wrapper, allows editing of line's text.
	 */
	static class LineInfo {
		private final int number;
		private String text;

		public LineInfo(int number, String text) {
			this.number = number;
			this.text = text;
		}
	}
}

```

`src/main/java/me/coley/recaf/util/JavaParserUtil.java`:

```java
package me.coley.recaf.util;

import com.github.javaparser.Range;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.resolution.Resolvable;
import com.github.javaparser.resolution.SymbolResolver;
import com.github.javaparser.resolution.UnsolvedSymbolException;
import com.github.javaparser.resolution.declarations.*;
import com.github.javaparser.resolution.types.ResolvedReferenceType;
import com.github.javaparser.resolution.types.ResolvedType;
import com.github.javaparser.resolution.types.ResolvedTypeVariable;
import com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserFieldDeclaration;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.ui.controls.text.selection.ClassSelection;
import me.coley.recaf.ui.controls.text.selection.MemberSelection;
import org.fxmisc.richtext.model.TwoDimensional;

import java.lang.reflect.Method;
import java.util.Optional;

/**
 * JavaParser utilities.
 *
 * @author Matt
 */
public class JavaParserUtil {
	private static final NodeList<Type> NO_TYPE_ARGS = null;
	private static Method GET_SOLVER;

	/**
	 * Check if the specified compliation unit is considered parsed.
	 *
	 * @param unit
	 *      the compliation unit
	 * @return
	 *      {@code false} if unparseable
	 */
	public static boolean isCompilationUnitParseable(CompilationUnit unit) {
		return unit != null && unit.getParsed() == Node.Parsedness.PARSED;
	}

	/**
	 * Fetch type of selection from the given position.
	 *
	 * @param code
	 * 		Source to analyze.
	 * @param solver
	 * 		Parser symbol resolver.
	 * @param pos
	 * 		Position in source.
	 *
	 * @return Type of selection.
	 */
	public static Object getSelection(SourceCode code, SymbolResolver solver, TwoDimensional.Position pos) {
		// Get declaration at point
		Node node = getSelectedNode(code, pos);
		if(node == null)
			return null;
		// Resolve node to some declaration type and display context menu
		Object selection = checkForDeclaredSelection(solver, node);
		if (selection == null)
			selection = checkReferencedSelection(node);
		return selection;
	}

	/**
	 * @param code
	 * 		Code wrapper.
	 * @param pos
	 * 		Position of caret.
	 *
	 * @return Node of supported type at position.
	 */
	private static Node getSelectedNode(SourceCode code, TwoDimensional.Position pos) {
		// Abort if no analyzed code to parse
		if (code == null)
			return null;
		// Get node at row/column
		Node node = code.getVerboseNodeAt(pos.getMajor() + 1, pos.getMinor());
		// Go up a level until node type is supported
		while(node != null) {
			if(node instanceof Resolvable || node instanceof InitializerDeclaration)
				break;
			Optional<Node> parent = node.getParentNode();
			if(!parent.isPresent())
				break;
			node = parent.get();
		}
		return node;
	}

	/**
	 * Fetch type of selection from the given node.
	 *
	 * @param solver
	 * 		Parser symbol resolver.
	 * @param node
	 * 		Node type to check.
	 *
	 * @return Type of selection.
	 */
	private static Object checkForDeclaredSelection(SymbolResolver solver, Node node) {
		try {
			CompilationUnit unit = node.findCompilationUnit().orElseThrow(AssertionError::new);
			if (solver != null && !unit.containsData(Node.SYMBOL_RESOLVER_KEY)) {
				unit.setData(Node.SYMBOL_RESOLVER_KEY, solver);
			}

			if(node instanceof TypeDeclaration) {
				ResolvedReferenceTypeDeclaration dec = ((TypeDeclaration) node).resolve();
				String name = toInternal(dec);
				return new ClassSelection(name, true);
			} else if(node instanceof FieldDeclaration || (node instanceof VariableDeclarator &&
					node.getParentNode().get() instanceof FieldDeclaration)) {
				// Check if we need to fetch the parent instead
				if(node instanceof VariableDeclarator)
					node = node.getParentNode().get();
				ResolvedFieldDeclaration dec = ((FieldDeclaration) node).resolve();
				String owner = getOwner(dec);
				String name = dec.getName();
				String desc = getDescriptor(dec.getType());
				return new MemberSelection(owner, name, desc, true);
			} else if(node instanceof MethodDeclaration) {
				ResolvedMethodDeclaration dec = ((MethodDeclaration) node).resolve();
				String owner = getOwner(dec);
				String name = dec.getName();
				String desc = getDescriptor(dec);
				return new MemberSelection(owner, name, desc, true);
			} else if(node instanceof ConstructorDeclaration) {
				ResolvedConstructorDeclaration dec = ((ConstructorDeclaration) node).resolve();
				String owner = toInternal(dec.declaringType());
				String name = "<init>";
				String desc = getDescriptor(dec);
				return new MemberSelection(owner, name, desc, true);
			} else if(node instanceof InitializerDeclaration) {
				InitializerDeclaration dec = (InitializerDeclaration) node;
				if(!dec.getParentNode().isPresent())
					return null; // sanity check, but it should ALWAYS be present and a type declaration
				String owner = toInternal(((TypeDeclaration) dec.getParentNode().get()).resolve());
				String name = "<clinit>";
				String desc = "()V";
				return new MemberSelection(owner, name, desc, true);
			} else if (node instanceof EnumConstantDeclaration) {
				EnumConstantDeclaration dec = (EnumConstantDeclaration) node;
				String owner = toInternal(((TypeDeclaration) dec.getParentNode().get()).resolve());
				String name = dec.getNameAsString();
				String desc = "L" + owner + ";";
				return new MemberSelection(owner, name, desc, true);
			} else if(node instanceof NameExpr) {
				// Ok so this one is a bit tricky. There are different cases we want to handle.
				NameExpr nameExpr = (NameExpr) node;
				// This "type" is used as a fallback. This is for cases like:
				//  - MyType.func()
				//  - MyType.constant
				// Where we want to resolve the type "MyType" and NOT the whole declared member.
				// This works because in these cases "MyType" is not a reference or declaration, only a name.
				ResolvedType type = solver.calculateType(nameExpr);
				String internal = toInternal(type);
				// Check if we want to resolve the member, and not the selected value's type.
				// - Check by seeing if the resolved member name is the selected name.
				try {
					ResolvedValueDeclaration dec = nameExpr.resolve();
					if (nameExpr.getName().asString().equals(dec.getName())) {
						String owner = dec.isField() ? getOwner(dec.asField()) : getOwner(dec.asMethod());
						String name = dec.getName();
						String desc = getDescriptor(dec.getType());
						return new MemberSelection(owner, name, desc, false);
					}
				} catch(Exception ex) {
					// TODO: Enum constant references in self class map to defining type, not the field ref
					//
					// Failed, but its ok. We'll just return the type of this name.
					// - Method arguments names will have their type resolved
				}
				return new ClassSelection(internal, false);
			}
		} catch(UnsolvedSymbolException ex) {
			Log.error("Failed to resolve: " + ex.toString());
		}
		return null;
	}

	/**
	 * Fetch type of selection from the given node.
	 *
	 * @param node
	 * 		Node type to check.
	 *
	 * @return Type of selection.
	 */
	private static Object checkReferencedSelection(Node node) {
		if (node instanceof Resolvable<?>) {
			Object resolved = null;
			try {
				if (node instanceof ReferenceType) {
					ResolvedType dec = ((ReferenceType) node).resolve();
					String name = toInternal(dec);
					return new ClassSelection(name, false);
				}
				Resolvable<?> r = (Resolvable<?>) node;
				resolved = r.resolve();
			} catch (Throwable ex) {
				return null;
			}
			if (resolved instanceof ResolvedReferenceType) {
				ResolvedReferenceType type = (ResolvedReferenceType) resolved;
				return new ClassSelection(toInternal(type), false);
			} else if (resolved instanceof ResolvedReferenceTypeDeclaration) {
				ResolvedReferenceTypeDeclaration type = (ResolvedReferenceTypeDeclaration) resolved;
				return new ClassSelection(toInternal(type), false);
			} else if (resolved instanceof ResolvedConstructorDeclaration) {
				ResolvedConstructorDeclaration type = (ResolvedConstructorDeclaration) resolved;
				return new ClassSelection(toInternal(type.declaringType()), false);
			} else if (resolved instanceof ResolvedFieldDeclaration) {
				ResolvedFieldDeclaration type = (ResolvedFieldDeclaration) resolved;
				String owner = getOwner(type);
				String name = type.getName();
				String desc = getDescriptor(type);
				return new MemberSelection(owner, name, desc, false);
			} else if (resolved instanceof ResolvedMethodDeclaration) {
				ResolvedMethodDeclaration type = (ResolvedMethodDeclaration) resolved;
				String owner = getOwner(type);
				String name = type.getName();
				String desc = getDescriptor(type);
				return new MemberSelection(owner, name, desc, false);
			} else if (resolved instanceof ResolvedEnumConstantDeclaration) {
				ResolvedEnumConstantDeclaration type = (ResolvedEnumConstantDeclaration) resolved;
				String owner = toInternal(type.getType());
				String name = type.getName();
				String desc = getDescriptor(type);
				return new MemberSelection(owner, name, desc, false);
			}
		}
		return null;
	}

	/**
	 * @param type
	 * 		Resolved field declaration.
	 *
	 * @return Descriptor of the resolved field. May be {@code null}.
	 */
	public static String getDescriptor(ResolvedFieldDeclaration type) {
		String desc = null;
		try {
			desc =	getDescriptor(type.getType());
		} catch(UnsolvedSymbolException ex) {
			if (type instanceof JavaParserFieldDeclaration) {
				desc = getDescriptor(((JavaParserFieldDeclaration) type).getWrappedNode().getCommonType());
			}
		} catch(UnsupportedOperationException e) { /* Ignored */ }
		return desc;
	}

	/**
	 * @param type
	 * 		Resolved method declaration.
	 *
	 * @return Descriptor of the resolved method.
	 */
	public static String getDescriptor(ResolvedMethodDeclaration type) {
		Optional<MethodDeclaration> ast = type.toAst();
		String desc = null;
		if (ast.isPresent()) {
			desc = getDescriptor(ast.get());
		} /* else if (type instanceof JavassistMethodDeclaration){
			CtMethod method = Reflect.get(type, "ctMethod");
			if (method != null)
				desc = method.getMethodInfo().getDescriptor();
		} else if (type instanceof ReflectionMethodDeclaration) {
			ReflectionMethodDeclaration ref = (ReflectionMethodDeclaration) type;
			Method method = Reflect.get(ref, "method");
			desc = org.objectweb.asm.Type.getType(method).getDescriptor();
		} */ else {
			StringBuilder sbDesc = new StringBuilder("(");
			// Append the method parameters for the descriptor
			int p = type.getNumberOfParams();
			for (int i = 0; i < p; i++) {
				ResolvedParameterDeclaration param = type.getParam(i);
				String pDesc = null;
				if (param.isType()) {
					pDesc = "L" + param.asType().getQualifiedName().replace('.', '/') + ";";
				} else {
					ResolvedType pType = param.getType();
					pDesc = typeToDesc(pType);
				}
				if (pDesc == null)
					return null;
				sbDesc.append(pDesc);
			}
			// Append the return type for the descriptor
			ResolvedType typeRet = type.getReturnType();
			String retDesc = typeToDesc(typeRet);
			if (retDesc == null) {
				return null;
			}
			sbDesc.append(")");
			sbDesc.append(retDesc);
			return sbDesc.toString();
		}
		return desc;
	}

	/**
	 * @param type
	 * 		Resolved constructor declaration.
	 *
	 * @return Descriptor of the resolved constructor.
	 */
	public static String getDescriptor(ResolvedConstructorDeclaration type) {
		StringBuilder sbDesc = new StringBuilder("(");
		// Append the constructor parameters for the descriptor
		int p = type.getNumberOfParams();
		for(int i = 0; i < p; i++) {
			ResolvedParameterDeclaration param = type.getParam(i);
			sbDesc.append(typeToDesc(param.getType()));
		}
		sbDesc.append(")V");
		return sbDesc.toString();
	}

	/**
	 * @param md
	 *            JavaParser method declaration.
	 * @return Internal descriptor from declaration, or {@code null} if any parsing
	 *         failures occured.
	 */
	public static String getDescriptor(MethodDeclaration md) {
		StringBuilder sbDesc = new StringBuilder("(");
		// Append the method parameters for the descriptor
		NodeList<Parameter> params = md.getParameters();
		for (Parameter param : params) {
			Type pType = param.getType();
			String pDesc = getDescriptor(pType);
			if (pDesc == null)
				return null;
			if (param.isVarArgs())
				pDesc = "[" + pDesc;
			sbDesc.append(pDesc);
		}
		// Append the return type for the descriptor
		Type typeRet = md.getType();
		String retDesc = getDescriptor(typeRet);
		if (retDesc == null)
			return null;
		sbDesc.append(")");
		sbDesc.append(retDesc);
		return sbDesc.toString();
	}

	/**
	 * @param dec
	 * 		Resolved value declaration.
	 *
	 * @return Internal descriptor of the value's type.
	 */
	public static String getDescriptor(ResolvedValueDeclaration dec) {
		return getDescriptor(dec.getType());
	}

	/**
	 * @param type
	 * 		JavaParser type.
	 *
	 * @return Internal descriptor from type, assuming the type is available or if it is a
	 * primitive or void type.
	 */
	public static String getDescriptor(ResolvedType type) {
		if (type.isArray())
			return "[" + getDescriptor(type.asArrayType().getComponentType());
		return type.isPrimitive() ? primTypeToDesc(type) : typeToDesc(type);
	}

	/**
	 * @param type
	 * 		JavaParser type.
	 *
	 * @return Internal descriptor from type, assuming the type is available or if it is a
	 * primitive or void type.
	 */
	public static String getDescriptor(Type type) {
		if (type.isArrayType())
			return "[" + getDescriptor(type.asArrayType().getComponentType());
		return isPrim(type) ? primTypeToDesc(type) : typeToDesc(type);
	}

	/**
	 * Converts the resolved type to an internal representation.
	 * If the type is an array the component type's internal name is returned.
	 * Primitives return their boxed names.
	 *
	 * @param type
	 * 		JavaParser resolved type.
	 *
	 * @return Internalized representation.
	 */
	public static String toInternal(ResolvedType type) {
		if(type.isVoid() || type.isPrimitive())
			return type.asPrimitive().getBoxTypeQName().replace(".", "/");
		if(type.isArray())
			return toInternal(type.asArrayType().getComponentType());
		if(type.isReference()) {
			if(type.asReferenceType().getTypeDeclaration() != null)
				return toInternal(type.asReferenceType().getTypeDeclaration().get());
			else
				return type.asReferenceType().getQualifiedName().replace(".", "/");
		}
		// The above cases should have internalized the name...
		// If not lets be alerted of a uncaught case.
		throw new IllegalStateException("Cannot internalize type: " + type);
	}

	/**
	 * Converts the resolved type to an internal representation.
	 *
	 * @param type
	 * 		JavaParser resolved declaration type.
	 *
	 * @return Internalized representation.
	 */
	public static String toInternal(ResolvedTypeDeclaration type) {
		if(type.isType()) {
			String qualified = type.getQualifiedName();
			String baseName = type.getClassName();
			// If the class is an inner class, the patterns are like so:
			// - Qualified: com.example.Outer.Inner
			// - Base: Outer.inner
			// From this, we can easily fix up name to use proper internals, like:
			// - com/example/Outer$Inner
			if (baseName.contains("."))
				baseName = baseName.replace('.', '$');
			String prefix = qualified.substring(0, qualified.length() - baseName.length());
			return (prefix + baseName).replace('.', '/');
		}
		// The above cases should have internalized the name...
		// If not lets be alerted of a uncaught case.
		throw new IllegalStateException("Cannot internalize type: " + type);
	}

	/**
	 * @param dec
	 * 		Resolved field declaration.
	 *
	 * @return Internal name of the field's owner.
	 */
	public static String getOwner(ResolvedFieldDeclaration dec) {
		return toInternal(dec.declaringType());
	}

	/**
	 * @param dec
	 * 		Resolved method declaration.
	 *
	 * @return Internal name of the method's owner.
	 */
	public static String getOwner(ResolvedMethodDeclaration dec) {
		return toInternal(dec.declaringType());
	}

	/**
	 * @param type
	 *            JavaParser type. Must be an object type.
	 * @return Internal descriptor from type, assuming the type is available.
	 */
	private static String typeToDesc(ResolvedType type) {
		String qualified = null;
		if(type instanceof ResolvedTypeVariable)
			qualified = ((ResolvedTypeVariable) type).qualifiedName();
		else if(type instanceof ResolvedTypeParameterDeclaration)
			qualified = type.asTypeParameter().getQualifiedName();
		else if(type.isPrimitive())
			return primTypeToDesc(type.asPrimitive());
		else if(type.isVoid())
			return "V";
		else
			qualified = toInternal(type);
		if(qualified == null)
			return null;
		// Substring out generics
		if(qualified.contains("<") && qualified.contains(">"))
			qualified = qualified.substring(0, qualified.indexOf('<'));
		StringBuilder sbDesc = new StringBuilder();
		for(int i = 0; i < type.arrayLevel(); i++)
			sbDesc.append("[");
		sbDesc.append("L");
		sbDesc.append(qualified.replace('.', '/'));
		sbDesc.append(";");
		return sbDesc.toString();
	}

	/**
	 * @param type
	 *            JavaParser type. Must be an object type.
	 * @return Internal descriptor from type, assuming the type is available.
	 */
	private static String typeToDesc(Type type) {
		String key = null;
		if (type instanceof ClassOrInterfaceType) {
			ClassOrInterfaceType clsType = (ClassOrInterfaceType) type;
			clsType.setTypeArguments(NO_TYPE_ARGS);
			try {
				key = toInternal(clsType.resolve().asReferenceType());
			} catch(UnsolvedSymbolException ex) {
				Log.warn("JavaParser failed to resolve type '{}'", ex.getName());
			} catch(UnsupportedOperationException ex) {
				// Ok, so it may be "unsupported" however it may not technically be unresolvable.
				// For instance, generic types like "<T>" are "unsupported" but do get resolved
				// to their appropriate generic type parameter. JavaParser throws that away though.
				SymbolResolver solver = getSymbolResolver(type);
				if (solver != null) {
					Object resolved = solver.toResolvedType(type, Object.class);
					if (resolved instanceof ResolvedTypeVariable) {
						ResolvedTypeParameterDeclaration typeParam = ((ResolvedTypeVariable)resolved).asTypeParameter();
						if (typeParam.hasLowerBound())
							key = toInternal(typeParam.getLowerBound());
						else
							key = "java/lang/Object";
					}
				} else {
					Log.warn("Unsupported resolve operation for '{}'", ex.getMessage());
				}
			}
		}
		if (key == null)
			key = type.asString();
		if (key.contains("<"))
			key = key.substring(0, key.indexOf("<"));
		StringBuilder sbDesc = new StringBuilder();
		for (int i = 0; i < type.getArrayLevel(); i++)
			sbDesc.append("[");
		sbDesc.append("L");
		sbDesc.append(key.replace('.', '/'));
		sbDesc.append(";");
		return sbDesc.toString();
	}

	/**
	 * @param type
	 *            JavaParser type.
	 * @return {@code true} if the type denotes a primitive or void type.
	 */
	private static boolean isPrim(Type type) {
		// void is not a primitive, but lets just pretend it is.
		return type.isVoidType() || type.isPrimitiveType();
	}

	/**
	 * @param type
	 *            JavaParser type. Must be a primitive.
	 * @return Internal descriptor.
	 */
	private static String primTypeToDesc(ResolvedType type) {
		return primTypeToDesc(type.describe(), type.arrayLevel());
	}

	/**
	 * @param type
	 *            JavaParser type. Must be a primitive.
	 * @return Internal descriptor.
	 */
	private static String primTypeToDesc(Type type) {
		return primTypeToDesc(type.asString(), type.getArrayLevel());
	}

	/**
	 * @param type
	 *            JavaParser type. Must be a primitive.
	 * @return Internal descriptor.
	 */
	private static String primTypeToDesc(String type, int arrayLevel) {
		String desc = null;
		switch (type) {
			case "boolean":
				desc = "Z";
				break;
			case "char":
				desc = "C";
				break;
			case "int":
				desc = "I";
				break;
			case "long":
				desc = "J";
				break;
			case "short":
				desc = "S";
				break;
			case "byte":
				desc = "B";
				break;
			case "double":
				desc = "D";
				break;
			case "float":
				desc = "F";
				break;
			case "void":
				desc = "V";
				break;
			default:
				throw new RuntimeException("Unknown primitive type field '" + type + "'");
		}
		StringBuilder sbDesc = new StringBuilder();
		for (int i = 0; i < arrayLevel; i++)
			sbDesc.append("[");
		sbDesc.append(desc);
		return sbDesc.toString();
	}

	// ==================================================================================== //

	/**
	 * @param node
	 * 		Node to resolve.
	 *
	 * @return If the node is a class, {@code {name}}.<br>If the node is a member, {@code {owner,
	 * name, desc}}.
	 */
	public static String[] resolveReference(Node node) {
		if(!(node instanceof Resolvable))
			return null;
		// Resolve node to some declaration type
		Resolvable<?> r = (Resolvable<?>) node;
		Object resolved = null;
		try {
			resolved = r.resolve();
		} catch(Exception ex) {
			return null;
		}
		if (resolved instanceof ResolvedMethodDeclaration) {
			ResolvedMethodDeclaration type = (ResolvedMethodDeclaration) resolved;
			ResolvedTypeDeclaration declaring = type.declaringType();
			String owner = declaring.getQualifiedName().replace('.', '/');
			String name = type.getName();
			String desc = getDescriptor(type);
			return new String[] { owner, name, desc };
		} else if (resolved instanceof ResolvedFieldDeclaration) {
			ResolvedFieldDeclaration type = (ResolvedFieldDeclaration) resolved;
			ResolvedTypeDeclaration declaring = type.declaringType();
			String owner = declaring.getQualifiedName().replace('.', '/');
			String name = type.getName();
			String desc = getDescriptor(type);
			return new String[] { owner, name, desc };
		} else if (resolved instanceof ResolvedTypeDeclaration) {
			ResolvedTypeDeclaration owner = (ResolvedTypeDeclaration) resolved;
			String ownerInternal = owner.getQualifiedName().replace('.', '/');
			return new String[] { ownerInternal };
		}
		return null;
	}

	// ==================================================================================== //


	/**
	 * Finds the member by the given name and descriptor and returns its range.
	 *
	 * @param unit
	 * 		AST tree.
	 * @param name
	 * 		Member name.
	 * @param desc
	 * 		Member descriptor.
	 *
	 * @return Range of member if the member exists.
	 */
	public static Optional<Range> getMemberRange(CompilationUnit unit, String name, String desc) {
		Optional<Range> range = Optional.empty();
		if(desc.contains("(")) {
			// Methods
			Optional<MethodDeclaration> opt = unit.findFirst(MethodDeclaration.class,
					(MethodDeclaration md) ->
							name.equals(md.getName().asString()) && desc.equals(getDescriptor(md)));
			if(opt.isPresent())
				range = opt.get().getName().getRange();
		} else {
			// Fields
			Optional<FieldDeclaration> opt = unit.findFirst(FieldDeclaration.class, (FieldDeclaration fd) -> {
				VariableDeclarator vd = fd.getVariable(0);
				return name.equals(vd.getName().asString()) &&
						desc.equals(getDescriptor(vd.getType()));
			});
			if(opt.isPresent())
				range = opt.get().getVariable(0).getName().getRange();
		}
		return range;
	}

	private static SymbolResolver getSymbolResolver(Node node) {
		if (GET_SOLVER == null)
			return null;
		try {
			return (SymbolResolver) GET_SOLVER.invoke(node);
		} catch(Throwable t) {
			return null;
		}
	}

	static {
		try {
			GET_SOLVER = Node.class.getDeclaredMethod("getSymbolResolver");
			GET_SOLVER.setAccessible(true);
		} catch(Throwable t) {
			Log.warn("Failed to get symbol-solver method");
		}
	}
}

```

`src/main/java/me/coley/recaf/util/LangUtil.java`:

```java
package me.coley.recaf.util;

import com.eclipsesource.json.*;
import org.apache.commons.io.IOUtils;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

import static me.coley.recaf.util.Log.*;
import static java.nio.charset.StandardCharsets.UTF_8;


/**
 * Simplistic language translation loader.
 *
 * @author Matt
 */
public class LangUtil {
	private static final Map<String, String> MAP = new HashMap<>();
	private static final boolean DEBUG = true;
	public static final String DEFAULT_LANGUAGE = "en";

	/**
	 * Get translated string.
	 *
	 * @param key
	 *            Translation key.
	 * @return Translated string.
	 */
	public static String translate(String key) {
		if (DEBUG && !MAP.containsKey(key))
			error("\"{}\": \"missing_translation\",", key);
		return MAP.getOrDefault(key, key);
	}

	/**
	 * Load language from {@link InputStream}.
	 *
	 * @param in
	 *            {@link InputStream} to load language from.
	 */
	public static void load(InputStream in) {
		try {
			String jsStr = IOUtils.toString(in, UTF_8);
			JsonObject json = Json.parse(jsStr).asObject();
			json.forEach(v -> MAP.put(v.getName(), v.getValue().asString()));
		} catch (Exception ex) {
			throw new IllegalStateException("Failed to fetch language from input stream", ex);
		}
	}

	/**
	 * Load language from URL.
	 *
	 * @param url
	 *            URL to load language from.
	 */
	public static void load(URL url) {
		try (InputStream in = url.openStream()) {
			load(in);
		} catch (IOException ex) {
			throw new IllegalStateException("Failed to fetch language from URL: " + url, ex);
		}
	}

	/**
	 * Load language from resource.
	 *
	 * @param resource
	 *            Resource wrapper for file.
	 */
	public static void load(Resource resource) {
		String file = resource.getPath();
		try {
			if(resource.isInternal()) {
				Enumeration<URL> urls = LangUtil.class.getClassLoader().getResources(file);
				if (!urls.hasMoreElements()) {
					throw new IOException(file);
				}
				load(urls.nextElement());
				while (urls.hasMoreElements()) {
					load(urls.nextElement());
				}
			} else {
				try (InputStream in  = new FileInputStream(file)) {
					load(in);
				}
			}
		} catch(Exception ex) {
			throw new IllegalStateException("Failed to fetch language file: " + file, ex);
		}
	}

	/**
	 * Insert a translation key-value pair.
	 *
	 * @param key
	 *            Translation key.
	 * @param value
	 *            Translation text.
	 */
	public static void load(String key, String value) {
		MAP.put(key, value);
	}

	/**
	 * Clears available translations.
	 */
	public static void clear() {
		MAP.clear();
	}

	static {
		load(Resource.internal("translations/" + DEFAULT_LANGUAGE + ".json"));
	}
}

```

`src/main/java/me/coley/recaf/util/Log.java`:

```java
package me.coley.recaf.util;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.core.FileAppender;
import me.coley.recaf.Recaf;
import me.coley.recaf.util.struct.Pair;
import me.coley.recaf.workspace.InstrumentationResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
import java.util.regex.Matcher;

/**
 * Proxy to intercept tinylog logging.
 *
 * @author Matt
 */
@SuppressWarnings({"unchecked", "rawtypes"})
public class Log {
	public static final String APP_LOGGER = "recaf-logger";
	public static final String FILE_LOGGER = "recaf-file-logger";
	public static final Logger appLogger = LoggerFactory.getLogger(APP_LOGGER);
	public static final Logger fileLogger;
	public static final Path logFile;
	/**
	 * Set of consumers that are fed trace-level messages.
	 */
	public static final Set<Consumer<String>> traceConsumers = new HashSet<>();
	/**
	 * Set of consumers that are fed debug-level messages.
	 */
	public static final Set<Consumer<String>> debugConsumers = new HashSet<>();
	/**
	 * Set of consumers that are fed info-level messages.
	 */
	public static final Set<Consumer<String>> infoConsumers = new HashSet<>();
	/**
	 * Set of consumers that are fed warn-level messages.
	 */
	public static final Set<Consumer<String>> warnConsumers = new HashSet<>();
	/**
	 * Set of consumers that are fed error-level messages.
	 */
	public static final Set<Consumer<Pair<String, Throwable>>> errorConsumers = new HashSet<>();

	/**
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void trace(String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.trace(msgCmp);
		fileLogger.trace(msgCmp);
		traceConsumers.forEach(c -> c.accept(msgCmp));
	}

	/**
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void debug(String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.debug(msgCmp);
		fileLogger.debug(msgCmp);
		debugConsumers.forEach(c -> c.accept(msgCmp));
	}

	/**
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void info(String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.info(msgCmp);
		fileLogger.info(msgCmp);
		infoConsumers.forEach(c -> c.accept(msgCmp));
	}

	/**
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void warn(String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.warn(msgCmp);
		fileLogger.warn(msgCmp);
		warnConsumers.forEach(c -> c.accept(msgCmp));
	}

	/**
	 * @param t
	 * 		Exception to print.
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void warn(Throwable t, String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.warn(msgCmp, t);
		fileLogger.warn(msgCmp, t);
		warnConsumers.forEach(c -> c.accept(msgCmp));
	}

	/**
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void error(String msg, Object... args) {
		error(null, msg, args);
	}

	/**
	 * @param t
	 * 		Exception to print.
	 * @param msg
	 * 		Message format.
	 * @param args
	 * 		Message arguments.
	 */
	public static void error(Throwable t, String msg, Object... args) {
		String msgCmp = compile(msg,args);
		appLogger.error(msgCmp, t);
		fileLogger.error(msgCmp, t);
		errorConsumers.forEach(c -> c.accept(new Pair<>(msgCmp, t)));
	}

	/**
	 * Compiles message with "{}" arg patterns.
	 *
	 * @param msg
	 * 		Message pattern.
	 * @param args
	 * 		Values to pass.
	 *
	 * @return Compiled message with inlined arg values.
	 */
	private static String compile(String msg, Object[] args) {
		int c = 0;
		while(msg.contains("{}")) {
			// Failsafe, shouldn't occur if logging is written correctly
			if (c == args.length) 
				return msg;
			// Replace arg in pattern
			Object arg = args[c];
			String argStr = arg == null ? "null" : arg.toString();
			msg = msg.replaceFirst("\\{}", Matcher.quoteReplacement(argStr));
			c++;
		}
		return msg;
	}

	static {
		// Clear old log
		Path logfile = Recaf.getDirectory().resolve("rclog.txt");
		logFile = logfile;
		IOException ioException = null;
		try {
			Files.deleteIfExists(logfile);
		} catch (IOException ex) {
			ioException = ex;
		}
		// We do it this ugly way so the file path can be set programmatically
		LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
		FileAppender fileAppender = new FileAppender<>();
		fileAppender.setContext(loggerContext);
		fileAppender.setName(FILE_LOGGER);
		fileAppender.setPrudent(true);
		fileAppender.setFile(IOUtil.toString(logfile));
		fileAppender.setAppend(ioException != null);
		// Immediate flush if we are in instrumentation mode.
		fileAppender.setImmediateFlush(InstrumentationResource.isActive());
		// Pattern
		PatternLayoutEncoder encoder = new PatternLayoutEncoder();
		encoder.setContext(loggerContext);
		encoder.setPattern("%d{HH:mm:ss.SSS} [%thread] %-5level: %msg%n");
		encoder.start();
		fileAppender.setEncoder(encoder);
		// Start file appender
		fileAppender.start();
		// Create logger
		ch.qos.logback.classic.Logger logbackLogger = loggerContext.getLogger(FILE_LOGGER);
		logbackLogger.setLevel(Level.ALL);
		logbackLogger.addAppender(fileAppender);
		logbackLogger.setAdditive(false);
		fileLogger = logbackLogger;
		if (ioException != null) {
			warn("Failed to delete old log file, will append instead");
		}
	}
}

```

`src/main/java/me/coley/recaf/util/MavenUtil.java`:

```java
package me.coley.recaf.util;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;

import static java.io.File.separator;
import static java.io.File.separatorChar;

/**
 * Utilities for finding maven artifacts. The alternative is a 16 megabyte dependency bloat...
 *
 * @author Matt
 */
public class MavenUtil {
	private static final String CENTRAL_URL = "https://repo1.maven.org/maven2/";

	/**
	 * Verifies that the maven artifact can be located on maven central.
	 *
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 *
	 * @throws IOException
	 * 		Thrown if at any point a faulty URL is generated or if there is no data to read <i>(No
	 * 		such group/artifact/version existing on central)</i>
	 */
	public static void verifyArtifactOnCentral(String groupId, String artifactId, String version)
			throws IOException {
		String groupUrl;
		String artifactUrl;
		String versionUrl;
		String jarUrl;
		// Test connection to maven central
		try {
			NetworkUtil.verifyUrlContent(CENTRAL_URL);
		} catch(MalformedURLException ex) {
			throw new IOException("Central URL is malformed, this should NOT happen", ex);
		} catch(IOException ex) {
			throw new IOException("Maven central is down or has migrated to a new URL: " +
					CENTRAL_URL, ex);
		}
		// Test connection to the group
		try {
			groupUrl = CENTRAL_URL + groupId.replace(".", "/") + "/";
			NetworkUtil.verifyUrlContent(groupUrl);
		} catch(MalformedURLException ex) {
			throw new IOException("Invalid group, generates invalid URL: " + groupId, ex);
		} catch(IOException ex) {
			throw new IOException("Invalid group, does not exist on central: " + groupId, ex);
		}
		// Test connection to the artifact
		try {
			artifactUrl = groupUrl + artifactId + "/";
			NetworkUtil.verifyUrlContent(artifactUrl);
		} catch(MalformedURLException ex) {
			throw new IOException("Invalid artifact, generates invalid URL: " + groupId + ":" +
					artifactId, ex);
		} catch(IOException ex) {
			throw new IOException("Invalid artifact, does not exist on central: " + groupId + ":" +
					artifactId, ex);
		}
		// Test connection to the version
		try {
			versionUrl = artifactUrl + version + "/";
			NetworkUtil.verifyUrlContent(versionUrl);
		} catch(MalformedURLException ex) {
			throw new IOException("Invalid version, generates invalid URL: " + groupId + ":" +
					artifactId + ":" + version, ex);
		} catch(IOException ex) {
			throw new IOException("Invalid version, does not exist on central: " + groupId + ":" +
					artifactId + ":" + version, ex);
		}
		// Test connection to the full url
		try {
			jarUrl = versionUrl + artifactId + "-" + version + ".jar";
			NetworkUtil.verifyUrlContent(jarUrl);
			// TODO: In some cases there are OS-specific jars:
			//  https://repo1.maven.org/maven2/org/openjfx/javafx-controls/13-ea+10/
		} catch(MalformedURLException ex) {
			throw new IOException("Failed to generate maven jar url: " + groupId + ":" + artifactId + ":" +
					version, ex);
		} catch(IOException ex) {
			throw new IOException("Jar does not match expected name on maven central: " + groupId + ":" +
					artifactId + ":" + version, ex);
		}
	}

	/**
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 *
	 * @return URL pointing to the online maven central artifact.
	 *
	 * @throws MalformedURLException
	 * 		Thrown if any of the components result given result in a malformed generated URL.
	 */
	public static URL getArtifactUrl(String groupId, String artifactId, String version) throws MalformedURLException {
		return getArtifactUrl(groupId, artifactId, version, "");
	}

	/**
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 * @param suffix
	 * 		Url suffix.
	 * 		Used to specify other maven jars such as <i>"-source"</i> and <i>"-javadoc"</i>
	 *
	 * @return URL pointing to the online maven central artifact.
	 *
	 * @throws MalformedURLException
	 * 		Thrown if any of the components result given result in a malformed generated URL.
	 */
	public static URL getArtifactUrl(String groupId, String artifactId, String version, String suffix)
			throws MalformedURLException {
		String url = CENTRAL_URL + groupId.replace(".", "/") + "/" + artifactId +
				"/" + version + "/" + artifactId + "-" + version + suffix + ".jar";
		return new URL(url);
	}

	/**
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 *
	 * @return File pointing to the local artifact.
	 */
	public static Path getLocalArtifactUrl(String groupId, String artifactId, String version) {
		return getLocalArtifactUrl(groupId, artifactId, version, "");
	}

	/**
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 * @param suffix
	 * 		File name suffix.
	 * 		Used to specify other maven jars such as <i>"-source"</i> and <i>"-javadoc"</i>
	 *
	 * @return File pointing to the local artifact.
	 */
	public static Path getLocalArtifactUrl(String groupId, String artifactId, String version, String suffix) {
		String path = groupId.replace('.', separatorChar) + separator + artifactId +
				separator + version + separator + artifactId + "-" + version + suffix + ".jar";
		return getMavenHome().resolve(path);
	}

	/**
	 * @return Local directory containing downloaded maven artifacts.
	 */
	public static Path getMavenHome() {
		return Paths.get(System.getProperty("user.home"), ".m2", "repository");
	}
}

```

`src/main/java/me/coley/recaf/util/Natives.java`:

```java
package me.coley.recaf.util;

import java.io.FileNotFoundException;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;

/**
 * @author xxDark
 */
public final class Natives {
    private static final String VM_CLASS = "com.sun.tools.attach.VirtualMachine";

    /**
     * Disallow public constructions.
     */
    private Natives() {
    }

    /**
     * Attempts to load attach library.
     *
     * @return {@link Optional} result containing {@link Throwable}
     * if any error occurred.
     */
    public static Optional<Throwable> loadAttach() {
        if (ClasspathUtil.classExists(VM_CLASS))
            return Optional.empty();
        try {
            System.loadLibrary("attach");
            try {
                Class.forName(VM_CLASS, true, null);
                return Optional.empty();
            } catch (ClassNotFoundException ignored) {
                // expected, see below
            }
            if (VMUtil.getVmVersion() < 9) {
                Path toolsPath = Paths.get("lib", "tools.jar");
                Path jrePath = Paths.get(System.getProperty("java.home"));
                Path maybePath = jrePath.resolve(toolsPath);
                if (Files.notExists(maybePath)) {
                    // CD .. -> CD toolsPath
                    maybePath = jrePath.getParent().resolve(toolsPath);
                }
                if (Files.notExists(maybePath)) {
                    return Optional.of(new FileNotFoundException("Could not locate tools.jar"));
                }
                ClassLoader cl = Natives.class.getClassLoader();
                if (!(cl instanceof URLClassLoader)) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                VMUtil.addURL(cl, maybePath.toUri().toURL());
            }
            return Optional.empty();
        } catch (UnsatisfiedLinkError ignored) {
            // attach library not found, that's ok.
            return Optional.empty();
        } catch (Throwable t) {
            return Optional.of(t);
        }
    }
}

```

`src/main/java/me/coley/recaf/util/NetworkUtil.java`:

```java
package me.coley.recaf.util;

import java.io.IOException;
import java.net.*;

/**
 * Networking utilities.
 *
 * @author Matt
 */
public class NetworkUtil {
	/**
	 * Timeout for URL verification. One second should be enough to do a simple length check.
	 */
	private static final int TIMEOUT = 1000;

	/**
	 * Verify that the URL points to a valid file.
	 *
	 * @param url
	 * 		The URL to verify.
	 *
	 * @throws IOException
	 * 		Thrown if the url times out or there is no content at the URL.
	 * @throws MalformedURLException
	 * 		Thrown if the url given is not formatted properly.
	 */
	public static void verifyUrlContent(String url) throws MalformedURLException, IOException {
		verifyUrlContent(new URL(url));
	}

	/**
	 * Verify that the URL points to a valid file.
	 *
	 * @param url
	 * 		The URL to verify.
	 *
	 * @throws IOException
	 * 		When the url times out or there is no content at the URL.
	 */
	public static void verifyUrlContent(URL url) throws IOException {
		try {
			URLConnection conn = url.openConnection();
			conn.setReadTimeout(TIMEOUT);
			conn.setConnectTimeout(TIMEOUT);
			// Online check
			if(url.toString().startsWith("http")) {
				HttpURLConnection hconn = (HttpURLConnection) conn;
				hconn.setRequestMethod("GET");
				hconn.connect();
				// Request must be a "200 OK"
				int response = hconn.getResponseCode();
				if(response != 200)
					throw new IOException("File at URL \"" + url +
							"\" could not be loaded, gave response code: " + response);
			}
			// Local url check fallback
			else if (conn.getContentLength() == -1)
				throw new IOException("File at URL \"" + url + "\" does not exist!");

		} catch(Exception ex) {
			throw new IOException("File at URL \"" + url + "\" could not be reached!");
		}
	}
}

```

`src/main/java/me/coley/recaf/util/OSUtil.java`:

```java
package me.coley.recaf.util;

/**
 * Operating system utility.
 */
public enum OSUtil {
	WINDOWS("win"),
	MAC("mac"),
	LINUX("linux");

	private final String mvnName;

	OSUtil(String mvnName) {
		this.mvnName = mvnName;
	}

	/**
	 * @return Maven artifact name suffix.
	 */
	public String getMvnName() {
		return mvnName;
	}

	/**
	 * @return Operating system short-hand name.
	 */
	public static OSUtil getOSType() {
		String s = System.getProperty("os.name").toLowerCase();
		if (s.contains("win")) {
			return WINDOWS;
		}
		if (s.contains("mac") || s.contains("osx")) {
			return MAC;
		}
		return LINUX;
	}
}

```

`src/main/java/me/coley/recaf/util/OpcodeUtil.java`:

```java
package me.coley.recaf.util;

import java.util.*;

import javassist.bytecode.Opcode;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;

import static java.util.stream.Collectors.toCollection;
import static java.util.stream.Stream.of;

/**
 * Utility for opcode value/text representations.
 *
 * @author Andy Li
 * @author Matt
 */
public class OpcodeUtil implements Opcodes {
	// Custom Opcodes
	public static final int LINE = 256;
	public static final int LABEL = 257;
	public static final int CATCH = 258;
	public static final int THROWS = 259;
	public static final int COMMENT = 260;
	public static final int ALIAS = 261;
	public static final int CATCH_INSN = 20;
	public static final int THROWS_INSN = 21;
	public static final int COMMENT_INSN = 22;
	public static final int ALIAS_INSN = 23;
	//
	private static final Map<Integer, Integer> opcodeToType = new LinkedHashMap<>();
	private static final Map<Integer, String> opcodeToName = new LinkedHashMap<>();
	private static final Map<String, Integer> nameToOpcode = new LinkedHashMap<>();
	private static final Map<Integer, String> frameToName = new LinkedHashMap<>();
	private static final Map<String, Integer> nameToFrame = new LinkedHashMap<>();
	private static final Map<Integer, String> tagToName = new LinkedHashMap<>();
	private static final Map<String, Integer> nameToTag = new LinkedHashMap<>();
	private static final Map<Integer, Set<String>> insnTypeToCodes = new LinkedHashMap<>();
	private static final Map<Integer, Integer> indexedVarToArgOp = new HashMap<>();
	private static final Map<Integer, Integer> indexedVarToIndex = new HashMap<>();
	/**
	 * Opcodes of INSN type.
	 */
	public static final Set<String> OPS_INSN = of("AALOAD", "AASTORE", "ACONST_NULL", "ARETURN",
			"ARRAYLENGTH", "ATHROW", "BALOAD", "BASTORE", "CALOAD", "CASTORE", "D2F", "D2I", "D2L", "DADD",
			"DALOAD", "DASTORE", "DCMPG", "DCMPL", "DCONST_0", "DCONST_1", "DDIV", "DMUL", "DNEG", "DREM",
			"DRETURN", "DSUB", "DUP", "DUP2", "DUP2_X1", "DUP2_X2", "DUP_X1", "DUP_X2", "F2D", "F2I", "F2L",
			"FADD", "FALOAD", "FASTORE", "FCMPG", "FCMPL", "FCONST_0", "FCONST_1", "FCONST_2", "FDIV", "FMUL",
			"FNEG", "FREM", "FRETURN", "FSUB", "I2B", "I2C", "I2D", "I2F", "I2L", "I2S", "IADD", "IALOAD",
			"IAND", "IASTORE", "ICONST_0", "ICONST_1", "ICONST_2", "ICONST_3", "ICONST_4", "ICONST_5",
			"ICONST_M1", "IDIV", "IMUL", "INEG", "IOR", "IREM", "IRETURN", "ISHL", "ISHR", "ISUB", "IUSHR",
			"IXOR", "L2D", "L2F", "L2I", "LADD", "LALOAD", "LAND", "LASTORE", "LCMP", "LCONST_0", "LCONST_1",
			"LDIV", "LMUL", "LNEG", "LOR", "LREM", "LRETURN", "LSHL", "LSHR", "LSUB", "LUSHR", "LXOR",
			"MONITORENTER", "MONITOREXIT", "NOP", "POP", "POP2", "RETURN", "SALOAD", "SASTORE", "SWAP")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for constants.
	 */
	public static final Set<String> OPS_INSN_SUB_CONSTS = of("ACONST_NULL", "DCONST_0", "DCONST_1",
			"FCONST_0", "FCONST_1", "FCONST_2", "ICONST_0", "ICONST_1", "ICONST_2", "ICONST_3", "ICONST_4",
			"ICONST_5", "ICONST_M1", "LCONST_0","LCONST_1")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for array loads/saves/etc.
	 */
	public static final Set<String> OPS_INSN_SUB_ARRAY = of("AALOAD", "AASTORE", "ARRAYLENGTH",
			"BALOAD", "BASTORE", "CALOAD", "CASTORE", "DALOAD", "DASTORE", "FALOAD", "FASTORE", "IALOAD",
			"IASTORE", "LALOAD", "LASTORE", "SALOAD", "SASTORE")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for stack management.
	 */
	public static final Set<String> OPS_INSN_SUB_STACK = of("DUP", "DUP2", "DUP2_X1", "DUP2_X2",
			"DUP_X1", "DUP_X2", "POP","POP2", "SWAP")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for math handling.
	 */
	public static final Set<String> OPS_INSN_SUB_MATH = of("DADD", "DDIV", "DMUL", "DNEG", "DREM",
			"DSUB", "FADD", "FDIV", "FMUL", "FNEG", "FREM", "FSUB", "IADD", "IAND", "IDIV", "IMUL", "INEG",
			"IOR", "IREM", "ISHL", "ISHR", "ISUB", "IUSHR", "IXOR", "LADD", "LAND", "LDIV", "LMUL", "LNEG",
			"LOR", "LREM", "LSHL", "LSHR", "LSUB", "LUSHR")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for type conversion.
	 */
	public static final Set<String> OPS_INSN_SUB_CONVERT = of("D2F", "D2I", "D2L", "F2D", "F2I",
			"F2L", "I2B", "I2C", "I2D", "I2F", "I2L", "I2S", "L2D", "L2F", "L2I")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for primitve comparisons.
	 */
	public static final Set<String> OPS_INSN_SUB_COMPARE = of("DCMPG", "DCMPL", "FCMPG", "FCMPL", "LCMP")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for returns.
	 */
	public static final Set<String> OPS_INSN_SUB_RETURN = of("ARETURN", "DRETURN", "FRETURN",
			"IRETURN", "LRETURN","RETURN")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for monitors.
	 */
	public static final Set<String> OPS_INSN_SUB_MONITOR = of("MONITORENTER", "MONITOREXIT")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Subset of {@link #OPS_INSN} for exceptions.
	 */
	public static final Set<String> OPS_INSN_SUB_EXCEPTION = of("ATHROW")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of INT type.
	 */
	public static final Set<String> OPS_INT = of("BIPUSH", "SIPUSH", "NEWARRAY")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of INT type.
	 */
	public static final Set<String> OPS_VAR = of("ALOAD", "ASTORE", "DLOAD", "DSTORE", "FLOAD",
			"FSTORE", "ILOAD", "ISTORE", "LLOAD", "LSTORE", "RET")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of TYPE type.
	 */
	public static final Set<String> OPS_TYPE = of("ANEWARRAY", "CHECKCAST", "INSTANCEOF", "NEW")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of FIELD type.
	 */
	public static final Set<String> OPS_FIELD = of("GETSTATIC", "PUTSTATIC", "GETFIELD", "PUTFIELD")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of METHOD type.
	 */
	public static final Set<String> OPS_METHOD = of("INVOKEVIRTUAL", "INVOKESPECIAL", "INVOKESTATIC",
			"INVOKEINTERFACE")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of INDY_METHOD type.
	 */
	public static final Set<String> OPS_INDY_METHOD = of("INVOKEDYNAMIC")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of JUMP type.
	 */
	public static final Set<String> OPS_JUMP = of("GOTO", "IF_ACMPEQ", "IF_ACMPNE", "IF_ICMPEQ",
			"IF_ICMPGE", "IF_ICMPGT", "IF_ICMPLE", "IF_ICMPLT", "IF_ICMPNE", "IFEQ", "IFGE", "IFGT",
			"IFLE", "IFLT", "IFNE", "IFNONNULL", "IFNULL", "JSR")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of LDC type.
	 */
	public static final Set<String> OPS_LDC = of("LDC")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of IINC type.
	 */
	public static final Set<String> OPS_IINC = of("IINC")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of TABLESWITCH type.
	 */
	public static final Set<String> OPS_TABLESWITCH = of("TABLESWITCH")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of LOOKUPSWITCH type.
	 */
	public static final Set<String> OPS_LOOKUPSWITCH = of("LOOKUPSWITCH")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of LOOKUPSWITCH type.
	 */
	public static final Set<String> OPS_MULTIANEWARRAY = of("MULTIANEWARRAY")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of FRAME type.
	 */
	public static final Set<String> OPS_FRAME = of("F_NEW", "F_FULL", "F_APPEND", "F_CHOP", "F_SAME",
			"F_APPEND", "F_SAME1")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of LABEL type. Also see {@link #OPS_FRAME}[0].
	 */
	public static final Set<String> OPS_LABEL = of("LABEL")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcodes of LABEL type. Also see {@link #OPS_FRAME}[0].
	 */
	public static final Set<String> OPS_LINE = of("LINE")
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Types of InvokeDynamic handle tags.
	 */
	public static final Set<String> OPS_TAG = of("H_GETFIELD", "H_GETSTATIC", "H_PUTFIELD", "H_PUTSTATIC",
			"H_INVOKEINTERFACE", "H_INVOKESPECIAL", "H_INVOKESTATIC", "H_INVOKEVIRTUAL", "H_NEWINVOKESPECIAL")
			.collect(toCollection(LinkedHashSet::new));
	private static final Set<Set<String>> INSN_SUBS = of(OPS_INSN_SUB_ARRAY, OPS_INSN_SUB_COMPARE,
			OPS_INSN_SUB_CONSTS, OPS_INSN_SUB_CONVERT, OPS_INSN_SUB_EXCEPTION, OPS_INSN_SUB_MATH,
			OPS_INSN_SUB_MONITOR, OPS_INSN_SUB_RETURN, OPS_INSN_SUB_STACK)
			.collect(toCollection(LinkedHashSet::new));
	/**
	 * Opcode type for custom opcodes.
	 */
	public static final int CUSTOM = 60;

	/**
	 * @param indexedVarOp
	 * 		Index based variable opcode, such as {@code ALOAD_0}.
	 *
	 * @return Non-indexed opcode, such as {@code ALOAD}.
	 * If a argument based opcode such as {@code ALOAD} is passed then itself is returned.
	 */
	public static int deindexVarOp(int indexedVarOp) {
		return indexedVarToArgOp.getOrDefault(indexedVarOp, indexedVarOp);
	}

	/**
	 * @param indexedVarOp
	 * 		Index based variable opcode, such as {@code ALOAD_0}.
	 *
	 * @return Index indicated by opcode, such as {@code 0}.
	 */
	public static int indexFromVarOp(int indexedVarOp) {
		return indexedVarToIndex.get(indexedVarOp);
	}

	/**
	 * Converts an opcode name to its value.
	 *
	 * @param name
	 * 		Opcode name.
	 *
	 * @return Opcode value.
	 *
	 * @throws NullPointerException
	 * 		when the name does not map to an opcode.
	 */
	public static int nameToOpcode(String name) throws NullPointerException {
		return nameToOpcode.get(name);
	}

	/**
	 * Converts an opcode value to its name.
	 * 
	 * @param op
	 *            Opcode value.
	 * @return Opcode name.
	 */
	public static String opcodeToName(int op) {
		return opcodeToName.get(op);
	}

	/**
	 * Converts an opcode <i>(Pertaining to frames)</i> name to its value.
	 *
	 * @param name
	 * 		Opcode name.
	 *
	 * @return Opcode value.
	 *
	 * @throws NullPointerException
	 * 		when the name does not map to a frame.
	 */
	public static int nameToFrame(String name) throws NullPointerException {
		return nameToFrame.get(name);
	}

	/**
	 * Converts an opcode <i>(Pertaining to frames)</i> value to its name.
	 * 
	 * @param op
	 *            Opcode value.
	 * @return Opcode name.
	 */
	public static String frameToName(int op) {
		return frameToName.get(op);
	}

	/**
	 * Converts a handle tag name to its value.
	 *
	 * @param tag
	 * 		Handle tag name.
	 *
	 * @return Handle tag value.
	 *
	 * @throws NullPointerException
	 * 		when the name does not map to a tag.
	 */
	public static int nameToTag(String tag) throws NullPointerException {
		return nameToTag.get(tag);
	}

	/**
	 * Converts a handle tag value to its name.
	 * 
	 * @param tag
	 *            Handle tag value.
	 * @return Handle tag name.
	 */
	public static String tagToName(int tag) {
		return tagToName.get(tag);
	}

	/**
	 * Retrieves the ASM type of the given opcode.
	 *
	 * @param opcode
	 * 		Opcode value.
	 *
	 * @return Type of opcode.
	 *
	 * @throws NullPointerException
	 * 		When the opcode does not map to a type.
	 */
	public static int opcodeToType(int opcode) throws NullPointerException {
		return opcodeToType.get(opcode);
	}

	/**
	 * Retrieves the set of opcode names by the given opcode type.
	 * <br>
	 * For reference: {@link org.objectweb.asm.tree.AbstractInsnNode}:
	 * <ul>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#FIELD_INSN FIELD_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#IINC_INSN IINC_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#INSN INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#INT_INSN INT_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#INVOKE_DYNAMIC_INSN INVOKE_DYNAMIC_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#JUMP_INSN JUMP_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#LDC_INSN LDC_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#LOOKUPSWITCH_INSN LOOKUPSWITCH_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#METHOD_INSN METHOD_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#MULTIANEWARRAY_INSN MULTIANEWARRAY_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#TABLESWITCH_INSN TABLESWITCH_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#TYPE_INSN TYPE_INSN}</li>
	 * <li>{@link org.objectweb.asm.tree.AbstractInsnNode#VAR_INSN VAR_INSN}</li>
	 * </ul>
	 *
	 * @param type
	 *            Type of opcode
	 * @return Set of opcode names.
	 */
	public static Set<String> typeToCodes(int type) {
		return insnTypeToCodes.get(type);
	}

	/**
	 * Return smaller subset of the {@link #OPS_INSN} set containing the given
	 * opcodes and others related to it.
	 * 
	 *
	 * @param insnOpName
	 *            The name of opcode
	 * @return The desired subset.
	 */
	public static Set<String> getInsnSubset(String insnOpName) {
		for (Set<String> set : INSN_SUBS) {
			if (set.contains(insnOpName)) {
				return set;
			}
		}
		// If not found, return empty set
		return Collections.emptySet();
	}

	/**
	 * @return Set of all opcode names.
	 */
	public static Set<String> getInsnNames() {
		return nameToOpcode.keySet();
	}

	/**
	 * @return Set of all handle tag names.
	 */
	public static Set<String> getTagNames() {
		return nameToTag.keySet();
	}

	private static void putOpcode(int op, String text) {
		nameToOpcode.put(text, op);
		opcodeToName.put(op, text);
	}

	private static void putFrame(int op, String text) {
		nameToFrame.put(text, op);
		frameToName.put(op, text);
	}

	private static void putTag(int op, String text) {
		nameToTag.put(text, op);
		tagToName.put(op, text);
	}

	private static void putType(int opcode, int type) {
		opcodeToType.put(opcode, type);
	}

	static {
		insnTypeToCodes.put(AbstractInsnNode.FIELD_INSN, OpcodeUtil.OPS_FIELD);
		insnTypeToCodes.put(AbstractInsnNode.FRAME, OpcodeUtil.OPS_FRAME);
		insnTypeToCodes.put(AbstractInsnNode.IINC_INSN, OpcodeUtil.OPS_IINC);
		insnTypeToCodes.put(AbstractInsnNode.INSN, OpcodeUtil.OPS_INSN);
		insnTypeToCodes.put(AbstractInsnNode.INT_INSN, OpcodeUtil.OPS_INT);
		insnTypeToCodes.put(AbstractInsnNode.INVOKE_DYNAMIC_INSN, OpcodeUtil.OPS_INDY_METHOD);
		insnTypeToCodes.put(AbstractInsnNode.JUMP_INSN, OpcodeUtil.OPS_JUMP);
		insnTypeToCodes.put(AbstractInsnNode.LABEL, OpcodeUtil.OPS_LABEL);
		insnTypeToCodes.put(AbstractInsnNode.LDC_INSN, OpcodeUtil.OPS_LDC);
		insnTypeToCodes.put(AbstractInsnNode.LINE, OpcodeUtil.OPS_LINE);
		insnTypeToCodes.put(AbstractInsnNode.LOOKUPSWITCH_INSN, OpcodeUtil.OPS_LOOKUPSWITCH);
		insnTypeToCodes.put(AbstractInsnNode.METHOD_INSN, OpcodeUtil.OPS_METHOD);
		insnTypeToCodes.put(AbstractInsnNode.MULTIANEWARRAY_INSN, OpcodeUtil.OPS_MULTIANEWARRAY);
		insnTypeToCodes.put(AbstractInsnNode.TABLESWITCH_INSN, OpcodeUtil.OPS_TABLESWITCH);
		insnTypeToCodes.put(AbstractInsnNode.TYPE_INSN, OpcodeUtil.OPS_TYPE);
		insnTypeToCodes.put(AbstractInsnNode.VAR_INSN, OpcodeUtil.OPS_VAR);
		// Custom opcodes
		putOpcode(LABEL, "LABEL");
		putOpcode(LINE, "LINE");
		putOpcode(CATCH, "CATCH");
		putOpcode(THROWS, "THROWS");
		putOpcode(COMMENT, "//");
		putOpcode(ALIAS, "ALIAS");
		putType(LABEL, AbstractInsnNode.LABEL);
		putType(LINE, AbstractInsnNode.LINE);
		putType(CATCH, CATCH_INSN);
		putType(THROWS, THROWS_INSN);
		putType(COMMENT, COMMENT_INSN);
		putType(ALIAS, ALIAS_INSN);
		// Default opcodes
		putOpcode(AALOAD, "AALOAD");
		putOpcode(AASTORE, "AASTORE");
		putOpcode(ACONST_NULL, "ACONST_NULL");
		putOpcode(ALOAD, "ALOAD");
		putOpcode(ANEWARRAY, "ANEWARRAY");
		putOpcode(ARETURN, "ARETURN");
		putOpcode(ARRAYLENGTH, "ARRAYLENGTH");
		putOpcode(ASTORE, "ASTORE");
		putOpcode(ATHROW, "ATHROW");
		putOpcode(BALOAD, "BALOAD");
		putOpcode(BASTORE, "BASTORE");
		putOpcode(BIPUSH, "BIPUSH");
		putOpcode(CALOAD, "CALOAD");
		putOpcode(CASTORE, "CASTORE");
		putOpcode(CHECKCAST, "CHECKCAST");
		putOpcode(D2F, "D2F");
		putOpcode(D2I, "D2I");
		putOpcode(D2L, "D2L");
		putOpcode(DADD, "DADD");
		putOpcode(DALOAD, "DALOAD");
		putOpcode(DASTORE, "DASTORE");
		putOpcode(DCMPG, "DCMPG");
		putOpcode(DCMPL, "DCMPL");
		putOpcode(DCONST_0, "DCONST_0");
		putOpcode(DCONST_1, "DCONST_1");
		putOpcode(DDIV, "DDIV");
		putOpcode(DLOAD, "DLOAD");
		putOpcode(DMUL, "DMUL");
		putOpcode(DNEG, "DNEG");
		putOpcode(DREM, "DREM");
		putOpcode(DRETURN, "DRETURN");
		putOpcode(DSTORE, "DSTORE");
		putOpcode(DSUB, "DSUB");
		putOpcode(DUP, "DUP");
		putOpcode(DUP2, "DUP2");
		putOpcode(DUP2_X1, "DUP2_X1");
		putOpcode(DUP2_X2, "DUP2_X2");
		putOpcode(DUP_X1, "DUP_X1");
		putOpcode(DUP_X2, "DUP_X2");
		putOpcode(F2D, "F2D");
		putOpcode(F2I, "F2I");
		putOpcode(F2L, "F2L");
		putOpcode(F_NEW, "F_NEW");
		putOpcode(FADD, "FADD");
		putOpcode(FALOAD, "FALOAD");
		putOpcode(FASTORE, "FASTORE");
		putOpcode(FCMPG, "FCMPG");
		putOpcode(FCMPL, "FCMPL");
		putOpcode(FCONST_0, "FCONST_0");
		putOpcode(FCONST_1, "FCONST_1");
		putOpcode(FCONST_2, "FCONST_2");
		putOpcode(FDIV, "FDIV");
		putOpcode(FLOAD, "FLOAD");
		putOpcode(FMUL, "FMUL");
		putOpcode(FNEG, "FNEG");
		putOpcode(FREM, "FREM");
		putOpcode(FRETURN, "FRETURN");
		putOpcode(FSTORE, "FSTORE");
		putOpcode(FSUB, "FSUB");
		putOpcode(GETFIELD, "GETFIELD");
		putOpcode(GETSTATIC, "GETSTATIC");
		putOpcode(GOTO, "GOTO");
		putOpcode(I2B, "I2B");
		putOpcode(I2C, "I2C");
		putOpcode(I2D, "I2D");
		putOpcode(I2F, "I2F");
		putOpcode(I2L, "I2L");
		putOpcode(I2S, "I2S");
		putOpcode(IADD, "IADD");
		putOpcode(IALOAD, "IALOAD");
		putOpcode(IAND, "IAND");
		putOpcode(IASTORE, "IASTORE");
		putOpcode(ICONST_0, "ICONST_0");
		putOpcode(ICONST_1, "ICONST_1");
		putOpcode(ICONST_2, "ICONST_2");
		putOpcode(ICONST_3, "ICONST_3");
		putOpcode(ICONST_4, "ICONST_4");
		putOpcode(ICONST_5, "ICONST_5");
		putOpcode(ICONST_M1, "ICONST_M1");
		putOpcode(IDIV, "IDIV");
		putOpcode(IF_ACMPEQ, "IF_ACMPEQ");
		putOpcode(IF_ACMPNE, "IF_ACMPNE");
		putOpcode(IF_ICMPEQ, "IF_ICMPEQ");
		putOpcode(IF_ICMPGE, "IF_ICMPGE");
		putOpcode(IF_ICMPGT, "IF_ICMPGT");
		putOpcode(IF_ICMPLE, "IF_ICMPLE");
		putOpcode(IF_ICMPLT, "IF_ICMPLT");
		putOpcode(IF_ICMPNE, "IF_ICMPNE");
		putOpcode(IFEQ, "IFEQ");
		putOpcode(IFGE, "IFGE");
		putOpcode(IFGT, "IFGT");
		putOpcode(IFLE, "IFLE");
		putOpcode(IFLT, "IFLT");
		putOpcode(IFNE, "IFNE");
		putOpcode(IFNONNULL, "IFNONNULL");
		putOpcode(IFNULL, "IFNULL");
		putOpcode(IINC, "IINC");
		putOpcode(ILOAD, "ILOAD");
		putOpcode(IMUL, "IMUL");
		putOpcode(INEG, "INEG");
		putOpcode(INSTANCEOF, "INSTANCEOF");
		putOpcode(INVOKEDYNAMIC, "INVOKEDYNAMIC");
		putOpcode(INVOKEINTERFACE, "INVOKEINTERFACE");
		putOpcode(INVOKESPECIAL, "INVOKESPECIAL");
		putOpcode(INVOKESTATIC, "INVOKESTATIC");
		putOpcode(INVOKEVIRTUAL, "INVOKEVIRTUAL");
		putOpcode(IOR, "IOR");
		putOpcode(IREM, "IREM");
		putOpcode(IRETURN, "IRETURN");
		putOpcode(ISHL, "ISHL");
		putOpcode(ISHR, "ISHR");
		putOpcode(ISTORE, "ISTORE");
		putOpcode(ISUB, "ISUB");
		putOpcode(IUSHR, "IUSHR");
		putOpcode(IXOR, "IXOR");
		putOpcode(JSR, "JSR");
		putOpcode(L2D, "L2D");
		putOpcode(L2F, "L2F");
		putOpcode(L2I, "L2I");
		putOpcode(LADD, "LADD");
		putOpcode(LALOAD, "LALOAD");
		putOpcode(LAND, "LAND");
		putOpcode(LASTORE, "LASTORE");
		putOpcode(LCMP, "LCMP");
		putOpcode(LCONST_0, "LCONST_0");
		putOpcode(LCONST_1, "LCONST_1");
		putOpcode(LDC, "LDC");
		putOpcode(LDIV, "LDIV");
		putOpcode(LLOAD, "LLOAD");
		putOpcode(LMUL, "LMUL");
		putOpcode(LNEG, "LNEG");
		putOpcode(LOOKUPSWITCH, "LOOKUPSWITCH");
		putOpcode(LOR, "LOR");
		putOpcode(LREM, "LREM");
		putOpcode(LRETURN, "LRETURN");
		putOpcode(LSHL, "LSHL");
		putOpcode(LSHR, "LSHR");
		putOpcode(LSTORE, "LSTORE");
		putOpcode(LSUB, "LSUB");
		putOpcode(LUSHR, "LUSHR");
		putOpcode(LXOR, "LXOR");
		putOpcode(MONITORENTER, "MONITORENTER");
		putOpcode(MONITOREXIT, "MONITOREXIT");
		putOpcode(MULTIANEWARRAY, "MULTIANEWARRAY");
		putOpcode(NEW, "NEW");
		putOpcode(NEWARRAY, "NEWARRAY");
		putOpcode(NOP, "NOP");
		putOpcode(POP, "POP");
		putOpcode(POP2, "POP2");
		putOpcode(PUTFIELD, "PUTFIELD");
		putOpcode(PUTSTATIC, "PUTSTATIC");
		putOpcode(RET, "RET");
		putOpcode(RETURN, "RETURN");
		putOpcode(SALOAD, "SALOAD");
		putOpcode(SASTORE, "SASTORE");
		putOpcode(SIPUSH, "SIPUSH");
		putOpcode(SWAP, "SWAP");
		putOpcode(TABLESWITCH, "TABLESWITCH");
		putFrame(F_APPEND, "F_APPEND");
		putFrame(F_APPEND, "F_APPEND");
		putFrame(F_CHOP, "F_CHOP");
		putFrame(F_FULL, "F_FULL");
		putFrame(F_NEW, "F_NEW");
		putFrame(F_SAME, "F_SAME");
		putFrame(F_SAME1, "F_SAME1");
		putTag(Opcodes.H_GETFIELD, "H_GETFIELD");
		putTag(Opcodes.H_GETSTATIC, "H_GETSTATIC");
		putTag(Opcodes.H_INVOKEINTERFACE, "H_INVOKEINTERFACE");
		putTag(Opcodes.H_INVOKESPECIAL, "H_INVOKESPECIAL");
		putTag(Opcodes.H_INVOKESTATIC, "H_INVOKESTATIC");
		putTag(Opcodes.H_INVOKEVIRTUAL, "H_INVOKEVIRTUAL");
		putTag(Opcodes.H_NEWINVOKESPECIAL, "H_NEWINVOKESPECIAL");
		putTag(Opcodes.H_PUTFIELD, "H_PUTFIELD");
		putTag(Opcodes.H_PUTSTATIC, "H_PUTSTATIC");
		putType(NOP, AbstractInsnNode.INSN);
		putType(ACONST_NULL, AbstractInsnNode.INSN);
		putType(ICONST_M1, AbstractInsnNode.INSN);
		putType(ICONST_0, AbstractInsnNode.INSN);
		putType(ICONST_1, AbstractInsnNode.INSN);
		putType(ICONST_2, AbstractInsnNode.INSN);
		putType(ICONST_3, AbstractInsnNode.INSN);
		putType(ICONST_4, AbstractInsnNode.INSN);
		putType(ICONST_5, AbstractInsnNode.INSN);
		putType(LCONST_0, AbstractInsnNode.INSN);
		putType(LCONST_1, AbstractInsnNode.INSN);
		putType(FCONST_0, AbstractInsnNode.INSN);
		putType(FCONST_1, AbstractInsnNode.INSN);
		putType(FCONST_2, AbstractInsnNode.INSN);
		putType(DCONST_0, AbstractInsnNode.INSN);
		putType(DCONST_1, AbstractInsnNode.INSN);
		putType(IALOAD, AbstractInsnNode.INSN);
		putType(LALOAD, AbstractInsnNode.INSN);
		putType(FALOAD, AbstractInsnNode.INSN);
		putType(DALOAD, AbstractInsnNode.INSN);
		putType(AALOAD, AbstractInsnNode.INSN);
		putType(BALOAD, AbstractInsnNode.INSN);
		putType(CALOAD, AbstractInsnNode.INSN);
		putType(SALOAD, AbstractInsnNode.INSN);
		putType(IASTORE, AbstractInsnNode.INSN);
		putType(LASTORE, AbstractInsnNode.INSN);
		putType(FASTORE, AbstractInsnNode.INSN);
		putType(DASTORE, AbstractInsnNode.INSN);
		putType(AASTORE, AbstractInsnNode.INSN);
		putType(BASTORE, AbstractInsnNode.INSN);
		putType(CASTORE, AbstractInsnNode.INSN);
		putType(SASTORE, AbstractInsnNode.INSN);
		putType(POP, AbstractInsnNode.INSN);
		putType(POP2, AbstractInsnNode.INSN);
		putType(DUP, AbstractInsnNode.INSN);
		putType(DUP_X1, AbstractInsnNode.INSN);
		putType(DUP_X2, AbstractInsnNode.INSN);
		putType(DUP2, AbstractInsnNode.INSN);
		putType(DUP2_X1, AbstractInsnNode.INSN);
		putType(DUP2_X2, AbstractInsnNode.INSN);
		putType(SWAP, AbstractInsnNode.INSN);
		putType(IADD, AbstractInsnNode.INSN);
		putType(LADD, AbstractInsnNode.INSN);
		putType(FADD, AbstractInsnNode.INSN);
		putType(DADD, AbstractInsnNode.INSN);
		putType(ISUB, AbstractInsnNode.INSN);
		putType(LSUB, AbstractInsnNode.INSN);
		putType(FSUB, AbstractInsnNode.INSN);
		putType(DSUB, AbstractInsnNode.INSN);
		putType(IMUL, AbstractInsnNode.INSN);
		putType(LMUL, AbstractInsnNode.INSN);
		putType(FMUL, AbstractInsnNode.INSN);
		putType(DMUL, AbstractInsnNode.INSN);
		putType(IDIV, AbstractInsnNode.INSN);
		putType(LDIV, AbstractInsnNode.INSN);
		putType(FDIV, AbstractInsnNode.INSN);
		putType(DDIV, AbstractInsnNode.INSN);
		putType(IREM, AbstractInsnNode.INSN);
		putType(LREM, AbstractInsnNode.INSN);
		putType(FREM, AbstractInsnNode.INSN);
		putType(DREM, AbstractInsnNode.INSN);
		putType(INEG, AbstractInsnNode.INSN);
		putType(LNEG, AbstractInsnNode.INSN);
		putType(FNEG, AbstractInsnNode.INSN);
		putType(DNEG, AbstractInsnNode.INSN);
		putType(ISHL, AbstractInsnNode.INSN);
		putType(LSHL, AbstractInsnNode.INSN);
		putType(ISHR, AbstractInsnNode.INSN);
		putType(LSHR, AbstractInsnNode.INSN);
		putType(IUSHR, AbstractInsnNode.INSN);
		putType(LUSHR, AbstractInsnNode.INSN);
		putType(IAND, AbstractInsnNode.INSN);
		putType(LAND, AbstractInsnNode.INSN);
		putType(IOR, AbstractInsnNode.INSN);
		putType(LOR, AbstractInsnNode.INSN);
		putType(IXOR, AbstractInsnNode.INSN);
		putType(LXOR, AbstractInsnNode.INSN);
		putType(I2L, AbstractInsnNode.INSN);
		putType(I2F, AbstractInsnNode.INSN);
		putType(I2D, AbstractInsnNode.INSN);
		putType(L2I, AbstractInsnNode.INSN);
		putType(L2F, AbstractInsnNode.INSN);
		putType(L2D, AbstractInsnNode.INSN);
		putType(F2I, AbstractInsnNode.INSN);
		putType(F2L, AbstractInsnNode.INSN);
		putType(F2D, AbstractInsnNode.INSN);
		putType(D2I, AbstractInsnNode.INSN);
		putType(D2L, AbstractInsnNode.INSN);
		putType(D2F, AbstractInsnNode.INSN);
		putType(I2B, AbstractInsnNode.INSN);
		putType(I2C, AbstractInsnNode.INSN);
		putType(I2S, AbstractInsnNode.INSN);
		putType(LCMP, AbstractInsnNode.INSN);
		putType(FCMPL, AbstractInsnNode.INSN);
		putType(FCMPG, AbstractInsnNode.INSN);
		putType(DCMPL, AbstractInsnNode.INSN);
		putType(DCMPG, AbstractInsnNode.INSN);
		putType(IRETURN, AbstractInsnNode.INSN);
		putType(LRETURN, AbstractInsnNode.INSN);
		putType(FRETURN, AbstractInsnNode.INSN);
		putType(DRETURN, AbstractInsnNode.INSN);
		putType(ARETURN, AbstractInsnNode.INSN);
		putType(RETURN, AbstractInsnNode.INSN);
		putType(ARRAYLENGTH, AbstractInsnNode.INSN);
		putType(ATHROW, AbstractInsnNode.INSN);
		putType(MONITORENTER, AbstractInsnNode.INSN);
		putType(MONITOREXIT, AbstractInsnNode.INSN);
		putType(BIPUSH, AbstractInsnNode.INT_INSN);
		putType(SIPUSH, AbstractInsnNode.INT_INSN);
		putType(NEWARRAY, AbstractInsnNode.INT_INSN);
		putType(ILOAD, AbstractInsnNode.VAR_INSN);
		putType(LLOAD, AbstractInsnNode.VAR_INSN);
		putType(FLOAD, AbstractInsnNode.VAR_INSN);
		putType(DLOAD, AbstractInsnNode.VAR_INSN);
		putType(ALOAD, AbstractInsnNode.VAR_INSN);
		putType(ISTORE, AbstractInsnNode.VAR_INSN);
		putType(LSTORE, AbstractInsnNode.VAR_INSN);
		putType(FSTORE, AbstractInsnNode.VAR_INSN);
		putType(DSTORE, AbstractInsnNode.VAR_INSN);
		putType(ASTORE, AbstractInsnNode.VAR_INSN);
		putType(RET, AbstractInsnNode.VAR_INSN);
		putType(NEW, AbstractInsnNode.TYPE_INSN);
		putType(ANEWARRAY, AbstractInsnNode.TYPE_INSN);
		putType(CHECKCAST, AbstractInsnNode.TYPE_INSN);
		putType(INSTANCEOF, AbstractInsnNode.TYPE_INSN);
		putType(GETSTATIC, AbstractInsnNode.FIELD_INSN);
		putType(GETFIELD, AbstractInsnNode.FIELD_INSN);
		putType(PUTSTATIC, AbstractInsnNode.FIELD_INSN);
		putType(PUTFIELD, AbstractInsnNode.FIELD_INSN);
		putType(INVOKEVIRTUAL, AbstractInsnNode.METHOD_INSN);
		putType(INVOKESPECIAL, AbstractInsnNode.METHOD_INSN);
		putType(INVOKESTATIC, AbstractInsnNode.METHOD_INSN);
		putType(INVOKEINTERFACE, AbstractInsnNode.METHOD_INSN);
		putType(INVOKEDYNAMIC, AbstractInsnNode.INVOKE_DYNAMIC_INSN);
		putType(IFEQ, AbstractInsnNode.JUMP_INSN);
		putType(IFNE, AbstractInsnNode.JUMP_INSN);
		putType(IFLT, AbstractInsnNode.JUMP_INSN);
		putType(IFGE, AbstractInsnNode.JUMP_INSN);
		putType(IFGT, AbstractInsnNode.JUMP_INSN);
		putType(IFLE, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPEQ, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPNE, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPLT, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPGE, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPGT, AbstractInsnNode.JUMP_INSN);
		putType(IF_ICMPLE, AbstractInsnNode.JUMP_INSN);
		putType(IF_ACMPEQ, AbstractInsnNode.JUMP_INSN);
		putType(IF_ACMPNE, AbstractInsnNode.JUMP_INSN);
		putType(GOTO, AbstractInsnNode.JUMP_INSN);
		putType(JSR, AbstractInsnNode.JUMP_INSN);
		putType(IFNULL, AbstractInsnNode.JUMP_INSN);
		putType(IFNONNULL, AbstractInsnNode.JUMP_INSN);
		putType(LDC, AbstractInsnNode.LDC_INSN);
		putType(IINC, AbstractInsnNode.IINC_INSN);
		putType(TABLESWITCH, AbstractInsnNode.TABLESWITCH_INSN);
		putType(LOOKUPSWITCH, AbstractInsnNode.LOOKUPSWITCH_INSN);
		putType(MULTIANEWARRAY, AbstractInsnNode.MULTIANEWARRAY_INSN);
		// Handle opcodes that ASM abstracts away
		putType(Opcode.GOTO_W, AbstractInsnNode.JUMP_INSN);
		putType(Opcode.LDC2_W, AbstractInsnNode.LDC_INSN);
		putType(Opcode.LDC_W, AbstractInsnNode.LDC_INSN);
		Arrays.asList(Opcode.ALOAD_0, Opcode.ALOAD_1, Opcode.ALOAD_2, Opcode.ALOAD_3)
					.forEach(op -> indexedVarToArgOp.put(op, ALOAD));
		Arrays.asList(Opcode.ASTORE_0, Opcode.ASTORE_1, Opcode.ASTORE_2, Opcode.ASTORE_3)
					.forEach(op -> indexedVarToArgOp.put(op, ASTORE));
		Arrays.asList(Opcode.DLOAD_0, Opcode.DLOAD_1, Opcode.DLOAD_2, Opcode.DLOAD_3)
					.forEach(op -> indexedVarToArgOp.put(op, DLOAD));
		Arrays.asList(Opcode.DSTORE_0, Opcode.DSTORE_1, Opcode.DSTORE_2, Opcode.DSTORE_3)
					.forEach(op -> indexedVarToArgOp.put(op, DSTORE));
		Arrays.asList(Opcode.FLOAD_0, Opcode.FLOAD_1, Opcode.FLOAD_2, Opcode.FLOAD_3)
					.forEach(op -> indexedVarToArgOp.put(op, FLOAD));
		Arrays.asList(Opcode.FSTORE_0, Opcode.FSTORE_1, Opcode.FSTORE_2, Opcode.FSTORE_3)
					.forEach(op -> indexedVarToArgOp.put(op, FSTORE));
		Arrays.asList(Opcode.ILOAD_0, Opcode.ILOAD_1, Opcode.ILOAD_2, Opcode.ILOAD_3)
					.forEach(op -> indexedVarToArgOp.put(op, ILOAD));
		Arrays.asList(Opcode.ISTORE_0, Opcode.ISTORE_1, Opcode.ISTORE_2, Opcode.ISTORE_3)
					.forEach(op -> indexedVarToArgOp.put(op, ISTORE));
		Arrays.asList(Opcode.LLOAD_0, Opcode.LLOAD_1, Opcode.LLOAD_2, Opcode.LLOAD_3)
					.forEach(op -> indexedVarToArgOp.put(op, LLOAD));
		Arrays.asList(Opcode.LSTORE_0, Opcode.LSTORE_1, Opcode.LSTORE_2, Opcode.LSTORE_3)
					.forEach(op -> indexedVarToArgOp.put(op, LSTORE));
		for (int op : indexedVarToArgOp.keySet()) {
			putType(op, AbstractInsnNode.VAR_INSN);
		}
		// Add index mappings
		indexedVarToIndex.put(Opcode.ALOAD_0, 0);
		indexedVarToIndex.put(Opcode.ALOAD_1, 1);
		indexedVarToIndex.put(Opcode.ALOAD_2, 2);
		indexedVarToIndex.put(Opcode.ALOAD_3, 3);
		indexedVarToIndex.put(Opcode.ASTORE_0, 0);
		indexedVarToIndex.put(Opcode.ASTORE_1, 1);
		indexedVarToIndex.put(Opcode.ASTORE_2, 2);
		indexedVarToIndex.put(Opcode.ASTORE_3, 3);
		indexedVarToIndex.put(Opcode.DLOAD_0, 0);
		indexedVarToIndex.put(Opcode.DLOAD_1, 1);
		indexedVarToIndex.put(Opcode.DLOAD_2, 2);
		indexedVarToIndex.put(Opcode.DLOAD_3, 3);
		indexedVarToIndex.put(Opcode.DSTORE_0, 0);
		indexedVarToIndex.put(Opcode.DSTORE_1, 1);
		indexedVarToIndex.put(Opcode.DSTORE_2, 2);
		indexedVarToIndex.put(Opcode.DSTORE_3, 3);
		indexedVarToIndex.put(Opcode.FLOAD_0, 0);
		indexedVarToIndex.put(Opcode.FLOAD_1, 1);
		indexedVarToIndex.put(Opcode.FLOAD_2, 2);
		indexedVarToIndex.put(Opcode.FLOAD_3, 3);
		indexedVarToIndex.put(Opcode.FSTORE_0, 0);
		indexedVarToIndex.put(Opcode.FSTORE_1, 1);
		indexedVarToIndex.put(Opcode.FSTORE_2, 2);
		indexedVarToIndex.put(Opcode.FSTORE_3, 3);
		indexedVarToIndex.put(Opcode.ILOAD_0, 0);
		indexedVarToIndex.put(Opcode.ILOAD_1, 1);
		indexedVarToIndex.put(Opcode.ILOAD_2, 2);
		indexedVarToIndex.put(Opcode.ILOAD_3, 3);
		indexedVarToIndex.put(Opcode.ISTORE_0, 0);
		indexedVarToIndex.put(Opcode.ISTORE_1, 1);
		indexedVarToIndex.put(Opcode.ISTORE_2, 2);
		indexedVarToIndex.put(Opcode.ISTORE_3, 3);
		indexedVarToIndex.put(Opcode.LLOAD_0, 0);
		indexedVarToIndex.put(Opcode.LLOAD_1, 1);
		indexedVarToIndex.put(Opcode.LLOAD_2, 2);
		indexedVarToIndex.put(Opcode.LLOAD_3, 3);
		indexedVarToIndex.put(Opcode.LSTORE_0, 0);
		indexedVarToIndex.put(Opcode.LSTORE_1, 1);
		indexedVarToIndex.put(Opcode.LSTORE_2, 2);
		indexedVarToIndex.put(Opcode.LSTORE_3, 3);
	}
}
```

`src/main/java/me/coley/recaf/util/ProcessUtil.java`:

```java
package me.coley.recaf.util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Set of utilities for {@link Process}.
 *
 * @author xxDark
 */
public final class ProcessUtil {

    /**
     * Deny all constructions.
     */
    private ProcessUtil() { }

    /**
     * Waits for process to finish.
     *
     * @param process
     *      Process to wait for.
     * @param timeout
     *      The maximum time to wait.
     * @param unit
     *      The time unit of the {@code timeout} argument.
     *
     * @return {@code true} if process was terminated.
     */
    public static boolean waitFor(Process process, long timeout, TimeUnit unit) {
        long now = System.currentTimeMillis();
        while (timeout > 0L) {
            try {
                return process.waitFor(timeout, unit);
            } catch (InterruptedException ex) {
                timeout -= (System.currentTimeMillis() - now);
            }
        }
        return false;
    }

    /**
     * Reads <i>stderr</i> of the process.
     *
     * @param process
     *      Process to read error from.
     * @return
     *      Content of process's <i>stderr</i>.
     *
     * @throws IOException
     *      When any I/O error occur.
     */
    public static List<String> readProcessError(Process process) throws IOException {
        List<String> result = new LinkedList<>();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                result.add(line);
            }
        }
        return result;
    }
}

```

`src/main/java/me/coley/recaf/util/RecafClassLoader.java`:

```java
package me.coley.recaf.util;

import java.net.URL;
import java.net.URLClassLoader;

/**
 * Bootstrap class loader for Recaf.
 *
 * @author xxDark
 */
public final class RecafClassLoader extends URLClassLoader {

    /**
     * @param urls
     *      Bootstrap URLs.
     */
    public RecafClassLoader(URL[] urls) {
        super(urls, ClassLoader.getSystemClassLoader().getParent());
    }
}

```

`src/main/java/me/coley/recaf/util/ReflectUtil.java`:

```java
package me.coley.recaf.util;

import java.lang.reflect.Constructor;

/**
 * Reflection utils
 *
 * @author Matt
 */
public class ReflectUtil {
	/**
	 * @param type
	 * 		Class to construct.
	 * @param argTypes
	 * 		Argument types.
	 * @param args
	 * 		Argument values.
	 * @param <T>
	 * 		Assumed class type.
	 *
	 * @return New instance of class.
	 */
	public static <T> T quietNew(Class<T> type, Class<?>[] argTypes, Object[] args) {
		try {
			Constructor<T> constructor = type.getDeclaredConstructor(argTypes);
			constructor.setAccessible(true);
			return constructor.newInstance(args);
		} catch (ReflectiveOperationException ex) {
			throw new IllegalStateException("Constructor failure: " + type.getName(), ex);
		}
	}
}

```

`src/main/java/me/coley/recaf/util/RegexUtil.java`:

```java
package me.coley.recaf.util;

import jregex.Matcher;
import jregex.Pattern;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Misc regex patterns.
 *
 * @author Matt
 */
public class RegexUtil {
	private static final Pattern WORD = new Pattern("\\s*(\\S+)\\s*");
	private static final String[] EMPTY = new String[0];
	private static final Map<String, Pattern> PATTERNS = new HashMap<>();

	/**
	 * @param text
	 * 		Some text containing at least one word character.
	 *
	 * @return The first sequence of connected word characters.
	 * {@code null} if no word characters are found.
	 */
	public static String getFirstWord(String text) {
		Matcher m = WORD.matcher(text);
		if(m.find())
			return m.group(1);
		return null;
	}

	/**
	 * @param text
	 * 		Some text containing at least one word character.
	 *
	 * @return The last sequence of connected word characters.
	 * {@code null} if no word characters are found.
	 */
	public static String getLastWord(String text) {
		Matcher m = WORD.matcher(text);
		String f = null;
		while(m.find())
			f = m.group(0);
		return f;
	}

	/**
	 * @param pattern
	 * 		Pattern to match.
	 * @param text
	 * 		Some text containing a match for the given pattern.
	 *
	 * @return First matching sequence from the text.
	 */
	public static String getFirstToken(String pattern, String text) {
		Matcher m = getMatcher(pattern, text);
		if(m.find())
			return m.group(0);
		return null;
	}

	/**
	 * @param pattern
	 * 		Pattern to match.
	 * @param text
	 * 		Some text containing at least one word character.
	 *
	 * @return The last sequence of connected word characters. {@code null} if no word characters
	 * are found.
	 */
	public static String getLastToken(String pattern, String text) {
		Matcher m = getMatcher(pattern, text);
		String f = null;
		while(m.find())
			f = m.group(0);
		return f;
	}

	/**
	 * @param pattern
	 * 		Pattern to match.
	 * @param text
	 * 		Some text containing at least one word character.
	 *
	 * @return Index of the first match.
	 */
	public static int indexOf(String pattern, String text) {
		Matcher m = getMatcher(pattern, text);
		if(m.find())
			return text.indexOf(m.group(0));
		return -1;
	}

	/**
	 * @param pattern
	 * 		Pattern to match.
	 * @param text
	 * 		Some text containing a match for the given pattern.
	 *
	 * @return Text matcher.
	 */
	public static Matcher getMatcher(String pattern, String text) {
		return new Pattern(pattern).matcher(text);
	}

	/**
	 * @param text
	 * 		Text to split, unless splitter chars reside in a single-quote range.
	 *
	 * @return Matched words.
	 */
	public static String[] wordSplit(String text) {
		List<String> list = new ArrayList<>();
		Matcher m = getMatcher("([^\\']\\S*|\\'.+?\\')\\s*", text);
		while(m.find()) {
			String word = m.group(1);
			if (word.matches("'.+'"))
				word = word.substring(1, word.length() - 1);
			list.add(word);
		}
		return list.toArray(EMPTY);
	}

	/**
	 * @param text
	 * 		Text to split.
	 * @param pattern
	 * 		Pattern to match words of.
	 *
	 * @return Matched words.
	 */
	public static String[] allMatches(String text, String pattern) {
		List<String> list = new ArrayList<>();
		Matcher m = getMatcher(pattern, text);
		while(m.find())
			list.add(m.group(0));
		return list.toArray(EMPTY);
	}

	/**
	 * Creates new {@link Pattern} or gets it from cache.
	 *
	 * @param regex pattern's regex
	 * @return {@link Pattern}
	 */
	public static Pattern pattern(String regex) {
		return PATTERNS.computeIfAbsent(regex, Pattern::new);
	}

	/**
	 * Checks if the entire input matches a pattern.
	 *
	 * @param pattern pattern
	 * @param input an input to verify
	 *
	 * @return {@code true} if input matches.
	 */
	public static boolean matches(String pattern, String input) {
		return pattern(pattern).matches(input);
	}
}

```

`src/main/java/me/coley/recaf/util/Resource.java`:

```java
package me.coley.recaf.util;

import java.io.File;
import java.io.IOException;
import java.net.URL;

/**
 * Wrapper for a resource to assist in handling of mixed classpath and non-classpath items.
 *
 * @author Matt
 */
public class Resource {
	private final String path;
	private final boolean internal;

	/**
	 * Create a resource wrapper.
	 *
	 * @param path
	 * 		Path to resource.
	 * @param internal
	 *        {@code true} if the resource is in the classpath, {@code false} if it is external.
	 */
	private Resource(String path, boolean internal) {
		this.path = path;
		this.internal = internal;
	}

	/**
	 * Create an internal resource.
	 * @param path Path to resource.
	 * @return Internal resource wrapper.
	 */
	public static Resource internal(String path) {
		return new Resource(path, true);
	}

	/**
	 * Create an external resource.
	 * @param path Path to resource.
	 * @return External resource wrapper.
	 */
	public static Resource external(String path) {
		return new Resource(path, false);
	}

	/**
	 * @return Resource path.
	 */
	public String getPath() {
		return path;
	}

	/**
	 * @return {@code true} if the resource is in the classpath, {@code false} if it is external.
	 */
	public boolean isInternal() {
		return internal;
	}

	/**
	 * @return Name of resource file.
	 */
	public String getFileName() {
		String name = getPath();
		int sep = name.lastIndexOf('/');
		if (sep > 0)
			name = name.substring(sep + 1);
		return name;
	}

	/**
	 * Creates a URL path to resource,
	 *
	 * @return URL path to resource.
	 *
	 * @throws IOException When the path cannot be created.
	 */
	public URL getURL() throws IOException {
		return new File(getPath()).toURI().toURL();
	}
}

```

`src/main/java/me/coley/recaf/util/ShortcutUtil.java`:

```java
package me.coley.recaf.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.ParseException;

/**
 * Represents a Windows shortcut (typically visible to Java only as a '.lnk' file).
 * <br>
 * Retrieved 2011-09-23 from:
 * <a href="http://stackoverflow.com/questions/309495/windows-shortcut-lnk-parser-in-java/672775#672775">
 *     Windows shortcut (.lnk) parser in Java?</a> - Originally called LnkParser
 *
 *
 * @author crysxd - Removing Apache VFS dependency
 * @author Headerified - Refactoring and comments
 * @author Stefan Cordes - Adaptation
 */
public class ShortcutUtil {
	private boolean isDirectory;
	private boolean isLocal;
	private String realFile;


	/**
	 * Provides a quick test to see if this could be a valid link !
	 * If you try to instantiate a new WindowShortcut and the link is not valid,
	 * Exceptions may be thrown and Exceptions are extremely slow to generate,
	 * therefore any code needing to loop through several files should first check this.
	 *
	 * @param path
	 * 		the potential link
	 *
	 * @return true if may be a link, false otherwise
	 */
	public static boolean isPotentialValidLink(final Path path) {
		if (!Files.exists(path))
			return false;
		if (!IOUtil.getExtension(path).equals("lnk"))
			return false;
		final int minimumLength = 0x64;
		try (InputStream fis = Files.newInputStream(path)) {
			return fis.available() >= minimumLength && isMagicPresent(IOUtil.toByteArray(fis, 32));
		} catch(Exception ex) {
			return false;
		}
	}

	/**
	 * @param path
	 * 		Path reference to shortcut.
	 *
	 * @throws IOException
	 * 		If the path cannot be read.
	 * @throws ParseException
	 * 		If the link cannot be read.
	 */
	public ShortcutUtil(final Path path) throws IOException, ParseException {
		try(InputStream in = Files.newInputStream(path)) {
			parseLink(IOUtil.toByteArray(in));
		}
	}

	/**
	 * @return the name of the filesystem object pointed to by this shortcut
	 */
	public String getRealFilename() {
		return realFile;
	}

	/**
	 * Tests if the shortcut points to a local resource.
	 *
	 * @return true if the 'local' bit is set in this shortcut, false otherwise
	 */
	public boolean isLocal() {
		return isLocal;
	}

	/**
	 * Tests if the shortcut points to a directory.
	 *
	 * @return true if the 'directory' bit is set in this shortcut, false otherwise
	 */
	public boolean isDirectory() {
		return isDirectory;
	}

	private static boolean isMagicPresent(final byte[] link) {
		final int magic = 0x0000004C;
		final int magicOffset = 0x00;
		return link.length >= 32 && bytesToDword(link, magicOffset) == magic;
	}

	/**
	 * Gobbles up link data by parsing it and storing info in member fields
	 *
	 * @param link
	 * 		all the bytes from the .lnk file
	 */
	private void parseLink(final byte[] link) throws ParseException {
		try {
			if(!isMagicPresent(link))
				throw new ParseException("Invalid shortcut; magic is missing", 0);

			// get the flags byte
			final byte flags = link[0x14];

			// get the file attributes byte
			final int fileAttsOffset = 0x18;
			final byte fileAtts = link[fileAttsOffset];
			final byte isDirMask = (byte) 0x10;
			isDirectory = (fileAtts & isDirMask) > 0;

			// if the shell settings are present, skip them
			final int shellOffset = 0x4c;
			final byte hasShellMask = (byte) 0x01;
			int shellLen = 0;
			if((flags & hasShellMask) > 0) {
				// the plus 2 accounts for the length marker itself
				shellLen = bytesToWord(link, shellOffset) + 2;
			}

			// get to the file settings
			final int fileStart = 0x4c + shellLen;

			final int fileLocationInfoFlagOffsetOffset = 0x08;
			final int fileLocationInfoFlag =
					link[fileStart + fileLocationInfoFlagOffsetOffset];
			isLocal = (fileLocationInfoFlag & 2) == 0;
			// get the local volume and local system values
			//final int localVolumeTable_offset_offset = 0x0C;
			final int basenameOffsetOffset = 0x10;
			final int networkVolumeTableOffsetOffset = 0x14;
			final int finalnameOffsetOffset = 0x18;
			final int finalnameOffset = link[fileStart + finalnameOffsetOffset] + fileStart;
			final String finalname = getNullDelimitedString(link, finalnameOffset);
			if(isLocal) {
				final int basenameOffset = link[fileStart + basenameOffsetOffset] + fileStart;
				final String basename = getNullDelimitedString(link, basenameOffset);
				realFile = basename + finalname;
			} else {
				final int networkVolumeTableOffset =
						link[fileStart + networkVolumeTableOffsetOffset] + fileStart;
				final int shareNameOffsetOffset = 0x08;
				final int shareNameOffset =
						link[networkVolumeTableOffset + shareNameOffsetOffset] + networkVolumeTableOffset;
				final String shareName = getNullDelimitedString(link, shareNameOffset);
				realFile = shareName + "\\" + finalname;
			}
		} catch(final ArrayIndexOutOfBoundsException e) {
			throw new ParseException("Could not be parsed, probably not a valid WindowsShortcut", 0);
		}
	}

	private static String getNullDelimitedString(final byte[] bytes, final int off) {
		// count bytes until the null character (0)
		int len = 0;
		while(bytes[off + len] != 0)
			len++;
		return new String(bytes, off, len);
	}

	/*
	 * Convert two bytes into a short note, this is little endian because it's
	 * for an Intel only OS.
	 */
	private static int bytesToWord(final byte[] bytes, final int off) {
		return ((bytes[off + 1] & 0xff) << 8) | (bytes[off] & 0xff);
	}

	private static int bytesToDword(final byte[] bytes, final int off) {
		return (bytesToWord(bytes, off + 2) << 16) | bytesToWord(bytes, off);
	}
}
```

`src/main/java/me/coley/recaf/util/StringUtil.java`:

```java
package me.coley.recaf.util;

import java.util.Arrays;

/**
 * String parsing &amp; manipulation utilities.
 *
 * @author Matt
 */
public class StringUtil {
	/**
	 * @param input
	 * 		Some text containing newlines.
	 *
	 * @return Input split by newline.
	 */
	public static String[] splitNewline(String input) {
		return input.split("\\r\\n|\\n");
	}

	/**
	 * @param input
	 * 		Some text containing newlines.
	 *
	 * @return Input split by newline.
	 * Empty lines <i>(Containing only the newline split)</i> are omitted.
	 */
	public static String[] splitNewlineSkipEmpty(String input) {
		String[] split = input.split("[\\r\\n]+");
		// If the first line of the file is a newline split will still have
		// one blank entry at the start.
		if (split[0].isEmpty())
			return Arrays.copyOfRange(split, 1, split.length);
		return split;
	}

	/**
	 * Replace the last match of some text in the given string.
	 *
	 * @param string
	 * 		Text containing items to replace.
	 * @param toReplace
	 * 		Pattern to match.
	 * @param replacement
	 * 		Text to replace pattern with.
	 *
	 * @return Modified string.
	 */
	public static String replaceLast(String string, String toReplace, String replacement) {
		int i = string.lastIndexOf(toReplace);
		if (i > -1)
			return string.substring(0, i) + replacement + string.substring(i + toReplace.length());
		return string;
	}

	/**
	 * Creates a string incrementing in numerical value.
	 * Example: a, b, c, ... z, aa, ab ...
	 *
	 * @param alphabet
	 * 		The alphabet to pull from.
	 * @param index
	 * 		Name index.
	 *
	 * @return Generated String
	 */
	public static String generateName(String alphabet, int index) {
		// String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		char[] charz = alphabet.toCharArray();
		int alphabetLength = charz.length;
		int m = 8;
		final char[] array = new char[m];
		int n = m - 1;
		while (index > charz.length - 1) {
			int k = Math.abs(-(index % alphabetLength));
			array[n--] = charz[k];
			index /= alphabetLength;
			index -= 1;
		}
		array[n] = charz[index];
		return new String(array, n, m - n);
	}

	/**
	 * @param level
	 * 		Level of indent.
	 * @param indent
	 * 		Indent format.
	 *
	 * @return Indented string.
	 */
	public static String indent(int level, String indent) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < level; i++)
			sb.append(indent);
		return sb.toString();
	}

	/**
	 * @param str
	 * 		Original string.
	 * @param maxLength
	 * 		Maximum length.
	 *
	 * @return String, cutting off anything past the maximum length if necessary.
	 */
	public static String limit(String str, int maxLength) {
		if (str.length() > maxLength)
			return str.substring(0, maxLength);
		return str;
	}

	/**
	 * Convert an enum to a string.
	 *
	 * @param value
	 * 		Enum value.
	 * @param <E>
	 * 		Type of enum.
	 *
	 * @return Case modified name of enum.
	 */
	public static <E extends Enum<?>> String toString(E value) {
		return value.name().substring(0, 1).toUpperCase() + value.name().substring(1).toLowerCase();
	}

	/**
	 * @param pattern
	 * 		Pattern to look for.
	 * @param text
	 * 		Text to check.
	 *
	 * @return Number of times the given pattern appears in the text.
	 */
	public static int count(String pattern, String text) {
		int count = 0;
		while (text.contains(pattern)) {
			text = text.replaceFirst(pattern, "");
			count++;
		}
		return count;
	}
}

```

`src/main/java/me/coley/recaf/util/ThreadUtil.java`:

```java
package me.coley.recaf.util;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import javafx.application.Platform;
import javafx.concurrent.Task;

import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static me.coley.recaf.util.Log.*;

/**
 * Threading utils.
 *
 * @author Matt
 */
public class ThreadUtil {
	private static final ScheduledExecutorService scheduledService =
			Executors.newScheduledThreadPool(threadCount(),
					new ThreadFactoryBuilder()
							.setNameFormat("Recaf Scheduler Thread #%d")
							.setDaemon(true).build());
	private static final ExecutorService service = Executors.newWorkStealingPool(threadCount());

	/**
	 * @param action
	 * 		Runnable to start in new thread.
	 *
	 * @return Thread future.
	 */
	public static Future<?> run(Runnable action) {
		return service.submit(action);
	}

	/**
	 * @param action
	 * 		Task to start in new thread.
	 * @param <T>
	 * 		Type of task return value.
	 *
	 * @return Thread future.
	 */
	@SuppressWarnings("unchecked")
	public static <T> Future<T> run(Task<T> action) {
		return (Future<T>) service.submit(action);
	}

	/**
	 * @param updateInterval
	 * 		Time in milliseconds between each execution.
	 * @param action
	 * 		Runnable to start in new thread.
	 *
	 * @return Scheduled future.
	 */
	public static ScheduledFuture<?> runRepeated(long updateInterval, Runnable action) {
		return scheduledService.scheduleAtFixedRate(action, 0, updateInterval,
				TimeUnit.MILLISECONDS);
	}

	/**
	 * @param time
	 * 		Delay to wait in milliseconds.
	 * @param action
	 * 		Runnable to start in new thread.
	 *
	 * @return Scheduled future.
	 */
	public static Future<?> runDelayed(long time, Runnable action) {
		return scheduledService.schedule(action, time, TimeUnit.MILLISECONDS);
	}

	/**
	 * Run a given action with a timeout.
	 *
	 * @param time
	 * 		Timeout in milliseconds.
	 * @param action
	 * 		Runnable to execute.
	 *
	 * @return {@code true}
	 */
	public static boolean timeout(int time, Runnable action) {
		try {
			Future<?> future = run(action);
			future.get(time, TimeUnit.MILLISECONDS);
			return true;
		} catch(TimeoutException e) {
			// Expected: Timeout
			return false;
		} catch(Throwable t) {
			// Other error
			return true;
		}
	}

	/**
	 * @param supplier
	 * 		Value generator, run on a non-jfx thread.
	 * @param consumer
	 * 		JavaFx consumer thread, takes the supplied value.
	 * @param <T>
	 * 		Type of value.
	 */
	public static <T> void runSupplyConsumer(Supplier<T> supplier, Consumer<T> consumer) {
		runSupplyConsumer(supplier, Long.MAX_VALUE, null, consumer, null);
	}

	/**
	 * @param supplier
	 * 		Value generator, run on a non-jfx thread.
	 * @param supplierTimeout
	 * 		Time to wait on the supplier generating a value before aborting the task.
	 * @param timeoutAction
	 * 		Action to run when timeout is reached.
	 * @param consumer
	 * 		JavaFx consumer thread, takes the supplied value.
	 * @param handler
	 * 		Error handling.
	 * @param <T>
	 * 		Type of value.
	 */
	public static <T> void runSupplyConsumer(Supplier<T> supplier, long supplierTimeout, Runnable timeoutAction,
											 Consumer<T> consumer, Consumer<Throwable> handler) {
		new Thread(() -> {
			try {
				// Attempt to compute value within given time
				Future<T> future = service.submit(supplier::get);
				T value = future.get(supplierTimeout, TimeUnit.MILLISECONDS);
				// Execute action with value
				Platform.runLater(() -> consumer.accept(value));
			} catch(CancellationException | InterruptedException | TimeoutException r) {
				// Timed out
				if (timeoutAction != null)
					timeoutAction.run();
			} catch(ExecutionException e) {
				// Supplier encountered an error
				// - Actual cause is wrapped twice
				Throwable cause = e.getCause().getCause();
				if(handler != null)
					handler.accept(cause);
			}
			catch(Throwable t) {
				// Unknown error
				if(handler != null)
					handler.accept(t);
			}
		}).start();
	}

	/**
	 * @param time
	 * 		Delay to wait in milliseconds.
	 * @param consumer
	 * 		JavaFx runnable action.
	 *
	 * @return Scheduled future.
	 */
	public static Future<?> runJfxDelayed(long time, Runnable consumer) {
		return scheduledService.schedule(() -> Platform.runLater(consumer), time, TimeUnit.MILLISECONDS);
	}

	/**
	 * @param consumer
	 * 		JavaFx runnable action.
	 */
	public static void checkJfxAndEnqueue(Runnable consumer) {
		if (!Platform.isFxApplicationThread()) {
			Platform.runLater(consumer);
		} else {
			consumer.run();
		}
	}

	/**
	 * Shutdowns executors.
	 */
	public static void shutdown() {
		trace("Shutting down thread executors");
		service.shutdownNow();
		scheduledService.shutdownNow();
	}

	private static int threadCount() {
		return Runtime.getRuntime().availableProcessors();
	}
}

```

`src/main/java/me/coley/recaf/util/TypeUtil.java`:

```java
package me.coley.recaf.util;

import org.objectweb.asm.Type;

/**
 * Utilities for ASM's {@link Type} class <i>(And some additional descriptor cases)</i>
 *
 * @author Matt
 */
public class TypeUtil {
	private static final Type[] PRIMITIVES = new Type[]{
		Type.VOID_TYPE,
		Type.BOOLEAN_TYPE,
		Type.BYTE_TYPE,
		Type.CHAR_TYPE,
		Type.SHORT_TYPE,
		Type.INT_TYPE,
		Type.FLOAT_TYPE,
		Type.DOUBLE_TYPE,
		Type.LONG_TYPE
	};

	/**
	 * Cosntant for object type.
	 */
	public static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");

	/**
	 * private sort denoting an object type, such as "com/Example" versus the
	 * standard "Lcom/Example;".
	 */
	private static final int INTERNAL = 12;

	/**
	 * @param desc
	 *            Type to check.
	 * @return Type denotes a primitive type.
	 */
	public static boolean isPrimitiveDesc(String desc) {
		if(desc.length() != 1) {
			return false;
		}
		switch(desc.charAt(0)) {
			case 'Z':
			case 'C':
			case 'B':
			case 'S':
			case 'I':
			case 'F':
			case 'J':
			case 'D':
				return true;
			default:
				return false;
		}
	}

	/**
	 * @param arg
	 * 		Operand value of a NEWARRAY instruction.
	 *
	 * @return Array element type.
	 */
	public static Type newArrayArgToType(int arg) {
		switch(arg) {
			case 4: return Type.BOOLEAN_TYPE;
			case 5: return Type.CHAR_TYPE;
			case 6: return Type.FLOAT_TYPE;
			case 7: return Type.DOUBLE_TYPE;
			case 8: return Type.BYTE_TYPE;
			case 9: return Type.SHORT_TYPE;
			case 10: return Type.INT_TYPE;
			case 11: return Type.LONG_TYPE;
			default: break;
		}
		throw new IllegalArgumentException("Unexpected NEWARRAY arg: " + arg);
	}

	/**
	 * @param type
	 * 		Array element type.
	 *
	 * @return Operand value for a NEWARRAY instruction.
	 */
	public static int typeToNewArrayArg(Type type) {
		switch(type.getDescriptor().charAt(0)) {
			case 'Z': return 4;
			case 'C': return 5;
			case 'F': return 6;
			case 'D': return 7;
			case 'B': return 8;
			case 'S': return 9;
			case 'I': return 10;
			case 'J': return 11;
			default: break;
		}
		throw new IllegalArgumentException("Unexpected NEWARRAY type: " + type.getDescriptor());
	}

	/**
	 * @param desc
	 *            Text to check.
	 * @return {@code true} when the descriptor is in method format, "(Ltype/args;)Lreturn;"
	 */
	public static boolean isMethodDesc(String desc) {
		// This assumes a lot, but hey, it serves our purposes.
		return desc.charAt(0) == '(';
	}

	/**
	 * @param desc
	 *            Text to check.
	 * @return {@code true} when the descriptor is in standard format, "Lcom/Example;".
	 */
	public static boolean isFieldDesc(String desc) {
		return desc.length() > 2 && desc.charAt(0) == 'L' && desc.charAt(desc.length() - 1) == ';';
	}

	/**
	 * @param desc
	 *            Text to check.
	 * @return Type is object/internal format of "com/Example".
	 */
	public static boolean isInternal(String desc) {
		return !isMethodDesc(desc) && !isFieldDesc(desc);
	}

	/**
	 * Convert a Type sort to a string representation.
	 *
	 * @param sort
	 * 		Type sort value.
	 *
	 * @return Sort string value.
	 */
	public static String sortToString(int sort) {
		switch(sort) {
			case Type.VOID:
				return "VOID";
			case Type.BOOLEAN:
				return "BOOLEAN";
			case Type.CHAR:
				return "CHAR";
			case Type.BYTE:
				return "BYTE";
			case Type.SHORT:
				return "SHORT";
			case Type.INT:
				return "INT";
			case Type.FLOAT:
				return "FLOAT";
			case Type.LONG:
				return "LONG";
			case Type.DOUBLE:
				return "DOUBLE";
			case Type.ARRAY:
				return "ARRAY";
			case Type.OBJECT:
				return "OBJECT";
			case Type.METHOD:
				return "METHOD";
			case INTERNAL:
				return "INTERNAL";
			default:
				return "UNKNOWN";
		}
	}

	/**
	 * @param sort
	 * 		Type sort<i>(kind)</i>
	 *
	 * @return Size of type.
	 */
	public static int sortToSize(int sort) {
		switch(sort) {
			case Type.LONG:
			case Type.DOUBLE:
				return 2;
			default:
				return 1;
		}
	}

	/**
	 * @param type
	 * 		Some array type.
	 *
	 * @return Array depth.
	 */
	public static int getArrayDepth(Type type) {
		if (type.getSort() == Type.ARRAY)
			return type.getDimensions();
		return 0;
	}

	/**
	 * @param desc
	 * 		Some class name.
	 *
	 * @return {@code true} if it matches the class name of a primitive type.
	 */
	public static boolean isPrimitiveClassName(String desc) {
		for (Type prim : PRIMITIVES)
			if (prim.getClassName().equals(desc))
				return true;
		return false;
	}

	/**
	 * @param desc
	 * 		Must be a primitive class name. See {@link #isPrimitiveClassName(String)}.
	 *
	 * @return Internal name.
	 */
	public static String classToPrimitive(String desc) {
		for (Type prim : PRIMITIVES)
			if (prim.getClassName().equals(desc))
				return prim.getInternalName();
		throw new IllegalArgumentException("Descriptor was not a primitive class name!");
	}
}

```

`src/main/java/me/coley/recaf/util/UiUtil.java`:

```java
package me.coley.recaf.util;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.InnerShadow;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.paint.Color;
import javafx.util.Duration;
import me.coley.recaf.ui.controls.IconView;
import me.coley.recaf.workspace.*;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.URI;
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

import static me.coley.recaf.util.ClasspathUtil.resource;

/**
 * Utilities for UI functions.
 *
 * @author Matt
 */
public class UiUtil {
	/**
	 * @param name
	 * 		File name.
	 *
	 * @return Path to icon based on file extension.
	 */
	public static String getFileIcon(String name) {
		String path = null;
		String ext = name.toLowerCase();
		if(ext.contains(".")) {
			ext = ext.substring(ext.lastIndexOf(".") + 1);
			if(Arrays.asList("txt", "mf", "properties").contains(ext))
				path = "icons/text.png";
			else if(Arrays.asList("json", "xml", "html", "css", "js").contains(ext))
				path = "icons/text-code.png";
			else if(Arrays.asList("png", "gif", "jpeg", "jpg", "bmp").contains(ext))
				path = "icons/image.png";
			else if(Arrays.asList("jar", "war").contains(ext))
				path = "icons/jar.png";
		} else if (ext.endsWith("/")) {
			path = "icons/folder-source.png";
		}
		if(path == null)
			path = "icons/binary.png";
		return path;
	}

	/**
	 * @param resource
	 * 		Workspace resource instance.
	 *
	 * @return Icon path based on the type of resource.
	 */
	public static String getResourceIcon(JavaResource resource) {
		if(resource instanceof DirectoryResource)
			return "icons/folder-source.png";
		else if(resource instanceof ArchiveResource)
			return "icons/jar.png";
		else if(resource instanceof ClassResource)
			return "icons/binary.png";
		else if(resource instanceof UrlResource)
			return "icons/link.png";
		else if(resource instanceof MavenResource)
			return "icons/data.png";
		// TODO: Unique debug/agent icon?
		else if(resource instanceof InstrumentationResource)
			return "icons/data.png";
		return "icons/binary.png";
	}

	/**
	 * @param name
	 * 		File name.
	 *
	 * @return Icon representing type of file <i>(Based on extension)</i>
	 */
	public static IconView createFileGraphic(String name) {
		return new IconView(getFileIcon(name));
	}

	/**
	 * @param access
	 * 		Class modifiers.
	 *
	 * @return Graphic representing class's attributes.
	 */
	public static Node createClassGraphic(int access) {
		Group g = new Group();
		// Root icon
		String base = "icons/class/class.png";
		if(AccessFlag.isEnum(access))
			base = "icons/class/enum.png";
		else if(AccessFlag.isAnnotation(access))
			base = "icons/class/annotation.png";
		else if(AccessFlag.isInterface(access))
			base = "icons/class/interface.png";
		g.getChildren().add(new IconView(base));
		// Add modifiers
		if(AccessFlag.isFinal(access) && !AccessFlag.isEnum(access))
			g.getChildren().add(new IconView("icons/modifier/final.png"));
		if(AccessFlag.isAbstract(access) && !AccessFlag.isInterface(access))
			g.getChildren().add(new IconView("icons/modifier/abstract.png"));
		if(AccessFlag.isBridge(access) || AccessFlag.isSynthetic(access))
			g.getChildren().add(new IconView("icons/modifier/synthetic.png"));
		createAccessToolTips(g, AccessFlag.Type.CLASS, access);
		return g;
	}

	/**
	 * @param access
	 * 		Field modifiers.
	 *
	 * @return Graphic representing fields's attributes.
	 */
	public static Node createFieldGraphic(int access) {
		Group g = new Group();
		// Root icon
		String base = null;
		if(AccessFlag.isPublic(access))
			base = "icons/modifier/field_public.png";
		else if(AccessFlag.isProtected(access))
			base = "icons/modifier/field_protected.png";
		else if(AccessFlag.isPrivate(access))
			base = "icons/modifier/field_private.png";
		else
			base = "icons/modifier/field_default.png";
		g.getChildren().add(new IconView(base));
		// Add modifiers
		if(AccessFlag.isStatic(access))
			g.getChildren().add(new IconView("icons/modifier/static.png"));
		if(AccessFlag.isFinal(access))
			g.getChildren().add(new IconView("icons/modifier/final.png"));
		if(AccessFlag.isBridge(access) || AccessFlag.isSynthetic(access))
			g.getChildren().add(new IconView("icons/modifier/synthetic.png"));
		createAccessToolTips(g, AccessFlag.Type.FIELD, access);
		return g;
	}

	/**
	 * @param access
	 * 		Field modifiers.
	 *
	 * @return Graphic representing fields's attributes.
	 */
	public static Node createMethodGraphic(int access) {
		Group g = new Group();
		// Root icon
		String base = null;
		if(AccessFlag.isPublic(access))
			base = "icons/modifier/method_public.png";
		else if(AccessFlag.isProtected(access))
			base = "icons/modifier/method_protected.png";
		else if(AccessFlag.isPrivate(access))
			base = "icons/modifier/method_private.png";
		else
			base = "icons/modifier/method_default.png";
		g.getChildren().add(new IconView(base));
		// Add modifiers
		if(AccessFlag.isStatic(access))
			g.getChildren().add(new IconView("icons/modifier/static.png"));
		else if(AccessFlag.isNative(access))
			g.getChildren().add(new IconView("icons/modifier/native.png"));
		else if(AccessFlag.isAbstract(access))
			g.getChildren().add(new IconView("icons/modifier/abstract.png"));
		if(AccessFlag.isFinal(access))
			g.getChildren().add(new IconView("icons/modifier/final.png"));
		if(AccessFlag.isBridge(access) || AccessFlag.isSynthetic(access))
			g.getChildren().add(new IconView("icons/modifier/synthetic.png"));
		createAccessToolTips(g, AccessFlag.Type.METHOD, access);
		return g;
	}

	private static void createAccessToolTips(Node node, AccessFlag.Type type, int access) {
		Set<String> accessFlags = AccessFlag.getApplicableFlags(type, access).stream()
				.map(AccessFlag::getName).collect(Collectors.toSet());
		Tooltip tooltip = new Tooltip(String.join(", ", accessFlags));
		// Show tooltip instantly, Tooltip.install(node, tooltip) has a significant delay
		node.setOnMouseEntered(event -> {
			if (!tooltip.getText().isEmpty()) {
				tooltip.show(node, event.getScreenX() + 10, event.getScreenY() + 1);
			}
		});
		node.setOnMouseExited(event -> tooltip.hide());
	}

	/**
	 * Convert raw bytes to an image.
	 *
	 * @param content
	 * 		Some raw bytes of a file.
	 *
	 * @return Image instance, if bytes represent a valid image, otherwise {@code null}.
	 */
	public static BufferedImage toImage(byte[] content) {
		try {
			return ImageIO.read(new ByteArrayInputStream(content));
		} catch(Exception ex) {
			return null;
		}
	}

	/**
	 * Convert a AWT image to a JavaFX image.
	 *
	 * @param img
	 * 		The image to convert.
	 *
	 * @return JavaFX image.
	 */
	public static WritableImage toFXImage(BufferedImage img) {
		// This is a stripped down version of "SwingFXUtils.toFXImage(img, fxImg)"
		int w = img.getWidth();
		int h = img.getHeight();
		// Ensure image type is ARGB.
		switch(img.getType()) {
			case BufferedImage.TYPE_INT_ARGB:
			case BufferedImage.TYPE_INT_ARGB_PRE:
				break;
			default:
				// Convert to ARGB
				BufferedImage converted = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);
				Graphics2D g2d = converted.createGraphics();
				g2d.drawImage(img, 0, 0, null);
				g2d.dispose();
				img = converted;
				break;
		}
		// Even if the image type is ARGB_PRE, we use "getIntArgbInstance()"
		// Using "getIntArgbPreInstance()" removes transparency.
		WritableImage fxImg = new WritableImage(w, h);
		PixelWriter pw = fxImg.getPixelWriter();
		int[] data = img.getRGB(0, 0, w, h, null, 0, w);
		pw.setPixels(0, 0, w, h, PixelFormat.getIntArgbInstance(), data, 0, w);
		return fxImg;
	}

	/**
	 * Configures the doc icon to use the Recaf logo on MacOS platforms.
	 */
	public static void setupMacDockIcon() {
		try {
			/* Why reflection?
			com.apple.eawt.Application is platform-specific class, that stored in apple-distributed rt.jar
			and if we use it directly, build must throw an error: "package com.apple.eawt does not exist"
			*/
			BufferedImage image = ImageIO.read(resource("icons/logo.png"));
			Class<?> applicationClass = Class.forName("com.apple.eawt.Application");
			Object application = applicationClass.getMethod("getApplication").invoke(null);
			Method dockIconSetter = applicationClass.getMethod("setDockIconImage", java.awt.Image.class);
			dockIconSetter.invoke(application, image);
		} catch (Exception ignored) {
			// Just ignore if we can't load dock image, it's not critical.
		}
	}

	/**
	 * Play an animation that indicates success <i>(Thin green border)</i>.
	 *
	 * @param node
	 * 		Node to animate.
	 * @param millis
	 * 		Duration in milliseconds of fade.
	 */
	public static void animateSuccess(Node node, long millis) {
		animate(node, millis, 90, 255, 60);
	}

	/**
	 * Play an animation that indicates failure <i>(Thin red border)</i>.
	 *
	 * @param node
	 * 		Node to animate.
	 * @param millis
	 * 		Duration in milliseconds of fade.
	 */
	public static void animateFailure(Node node, long millis) {
		animate(node, millis, 255, 60, 40);
	}

	private static void animate(Node node, long millis, int r, int g, int b) {
		DoubleProperty dblProp = new SimpleDoubleProperty(1);
		dblProp.addListener((ob, o, n) -> {
			InnerShadow innerShadow = new InnerShadow();
			innerShadow.setBlurType(BlurType.ONE_PASS_BOX);
			innerShadow.setChoke(1);
			innerShadow.setRadius(5);
			innerShadow.setColor(Color.rgb(r, g, b, n.doubleValue()));
			node.setEffect(innerShadow);
		});
		Timeline timeline = new Timeline();
		KeyValue kv = new KeyValue(dblProp, 0);
		KeyFrame kf = new KeyFrame(Duration.millis(millis), kv);
		timeline.getKeyFrames().add(kf);
		timeline.play();
	}

	/**
	 *  Attempts to launch a browser to display a {@link URI}.
	 *
	 * @param uri
	 * 		URI to display.
	 *
	 * @throws IOException
	 * 		If the browser is not found, or it fails
	 * 		to be launched.
	 */
	public static void showDocument(URI uri) throws IOException {
		switch (OSUtil.getOSType()) {
			case MAC:
				Runtime.getRuntime().exec("open " + uri);
				break;
			case WINDOWS:
				Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + uri);
				break;
			case LINUX:
				Runtime rt = Runtime.getRuntime();
				String[] browsers = new String[]{"xdg-open", "google-chrome", "firefox", "opera",
					"konqueror", "mozilla"};

				for (String browser : browsers) {
					try (InputStream in = rt.exec(new String[]{"which", browser}).getInputStream()) {
						if (in.read() != -1) {
							rt.exec(new String[]{browser, uri.toString()});
							return;
						}
					}
				}
				throw new IOException("No browser found");
			default:
				throw new IllegalStateException("Unsupported OS");
		}
	}
}

```

`src/main/java/me/coley/recaf/util/VMUtil.java`:

```java
package me.coley.recaf.util;

import com.sun.javafx.application.PlatformImpl;

import java.lang.instrument.Instrumentation;
import java.lang.reflect.Modifier;
import java.util.HashSet;
import javafx.application.Platform;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.zip.ZipOutputStream;

/**
 * Dependent and non-dependent platform utilities for VM.
 *
 * @author xxDark
 */
public final class VMUtil {
    private static int vmVersion = -1;

    /**
     * Deny all constructions.
     */
    private VMUtil() { }

    /**
     * Appends URL to the {@link URLClassLoader}.
     *
     * @param cl  the classloader to add {@link URL} for.
     * @param url the {@link URL} to add.
     */
    public static void addURL(ClassLoader cl, URL url) {
        if (cl instanceof URLClassLoader) {
            addURL0(cl, url);
        } else {
            addURL1(cl, url);
        }
    }

    /**
     * @return running VM version.
     */
    public static int getVmVersion() {
        if (vmVersion < 0) {
            // Check for class version, ez
            String property = System.getProperty("java.class.version", "");
            if (!property.isEmpty())
                return vmVersion = (int) (Float.parseFloat(property) - ClassUtil.VERSION_OFFSET);
            // Odd, not found. Try the spec version
            Log.warn("Using fallback vm-version fetch, no value for 'java.class.version'");
            property = System.getProperty("java.vm.specification.version", "");
            if (property.contains("."))
                return vmVersion = (int) Float.parseFloat(property.substring(property.indexOf('.') + 1));
            else if (!property.isEmpty())
                return vmVersion = Integer.parseInt(property);
            // Very odd
            Log.warn("Fallback vm-version fetch failed, defaulting to 8");
            return 8;
        }
        return vmVersion;
    }

    private static void addURL0(ClassLoader loader, URL url) {
        Method method;
        try {
            method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException("No 'addURL' method in java.net.URLClassLoader", ex);
        }
        method.setAccessible(true);
        try {
            method.invoke(loader, url);
        } catch (IllegalAccessException ex) {
            throw new IllegalStateException("'addURL' became inaccessible", ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException("Error adding URL", ex.getTargetException());
        }
    }

    private static void addURL1(ClassLoader loader, URL url) {
        Class<?> currentClass =  loader.getClass();
        do {
            Field field;
            try {
                field = currentClass.getDeclaredField("ucp");
            } catch (NoSuchFieldException ignored) {
                continue;
            }
            field.setAccessible(true);
            Object ucp;
            try {
                ucp = field.get(loader);
            } catch (IllegalAccessException ex) {
                throw new IllegalStateException("'ucp' became inaccessible", ex);
            }
            String className;
            if (getVmVersion() < 9) {
                className = "sun.misc.URLClassPath";
            } else {
                className = "jdk.internal.misc.URLClassPath";
            }
            Method method;
            try {
                method = Class.forName(className, true, null).getDeclaredMethod("addURL", URL.class);
            } catch (NoSuchMethodException ex) {
                throw new RuntimeException("No 'addURL' method in " + className, ex);
            } catch (ClassNotFoundException ex) {
                throw new RuntimeException(className + " was not found", ex);
            }
            method.setAccessible(true);
            try {
                method.invoke(ucp, url);
                break;
            } catch (IllegalAccessException ex) {
                throw new IllegalStateException("'addURL' became inaccessible", ex);
            } catch (InvocationTargetException ex) {
                throw new RuntimeException("Error adding URL", ex.getTargetException());
            }
        } while ((currentClass=currentClass.getSuperclass()) != Object.class);
        throw new IllegalArgumentException("No 'ucp' field in " + loader);
    }

    /**
     * Closes {@link URLClassLoader}.
     *
     * @param loader
     *      Loader to close.
     *
     * @throws IOException
     *      When I/O error occurs.
     */
    public static void close(URLClassLoader loader) throws IOException {
        loader.close();
    }

    /**
     * Sets parent class loader.
     *
     * @param loader
     *      Loader to change parent for.
     * @param parent
     *      New parent loader.
     */
    public static void setParent(ClassLoader loader, ClassLoader parent) {
        Field field;
        try {
            field = ClassLoader.class.getDeclaredField("parent");
        } catch (NoSuchFieldException ex) {
            throw new RuntimeException("No 'parent' field in java.lang.ClassLoader", ex);
        }
        field.setAccessible(true);
        try {
            field.set(loader, parent);
        } catch (IllegalAccessException ex) {
            throw new IllegalStateException("'parent' became inaccessible", ex);
        }
    }

    /**
     * Initializes toolkit.
     */
    public static void tkIint() {
        if (getVmVersion() < 9) {
            PlatformImpl.startup(() -> {});
        } else {
            Method m;
            try {
                m = Platform.class.getDeclaredMethod("startup", Runnable.class);
            } catch (NoSuchMethodException ex) {
                throw new RuntimeException("javafx.application.Platform.startup(Runnable) is missing", ex);
            }
            m.setAccessible(true);
            try {
                m.invoke(null, (Runnable) () -> {});
            } catch (IllegalAccessException ex) {
                throw new IllegalStateException("'startup' became inaccessible", ex);
            } catch (InvocationTargetException ex) {
                throw new RuntimeException("Unable to initialize toolkit", ex.getTargetException());
            }
        }
    }

    /**
     * Locates path to Java executable.
     *
     * @return path to Java executable.
     *
     * @throws IllegalArgumentException
     *      When Recaf can't detect a path.
     */
    public static Path getJavaPath() {
        Path javaHome = Paths.get(System.getProperty("java.home"));
        Path bin = javaHome.resolve("bin");
        OSUtil os = OSUtil.getOSType();
        switch (os) {
            case WINDOWS:
                return bin.resolve("java.exe");
            case LINUX:
            case MAC:
                return bin.resolve("java");
            default:
                throw new IllegalArgumentException("Don't know how to find Java path for: " + os.getMvnName());
        }
    }

    /**
     * Patches JDK stuff.
     */
    public static void patch() {
        if (getVmVersion() > 8) {
            openPackages();
            patchReflectionFilters();
        }
    }

    /**
     * Opens all packages.
     */
    private static void openPackages() {
        try {
            Method export = Module.class.getDeclaredMethod("implAddOpens", String.class);
            Java9Util.setMethodModifiers(export, Modifier.PUBLIC);
            HashSet<Module> modules = new HashSet<>();
            Class<?> classBase = VMUtil.class;
            Module base = Java9Util.getClassModule(classBase);
            if (base.getLayer() != null)
                modules.addAll(base.getLayer().modules());
            modules.addAll(ModuleLayer.boot().modules());
            for (ClassLoader cl = classBase.getClassLoader(); cl != null; cl = cl.getParent()) {
                modules.add(Java9Util.getLoaderModule(cl));
            }
            for (Module module : modules) {
                for (String name : module.getPackages()) {
                    try {
                        export.invoke(module, name);
                    } catch (Exception ex) {
                        Log.error(ex, "Could not export package {} in module {}", name, module);
                    }
                }
            }
        } catch (Exception ex) {
            throw new IllegalStateException("Could not export packages", ex);
        }
    }

    /**
     * Patches reflection filters.
     */
    private static void patchReflectionFilters() {
        Class<?> klass;
        try {
            klass = Class.forName("jdk.internal.reflect.Reflection",
                    true, null);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException("Unable to locate 'jdk.internal.reflect.Reflection' class", ex);
        }
        try {
            Field[] fields;
            try {
                Method m = Class.class.getDeclaredMethod("getDeclaredFieldsImpl");
                m.setAccessible(true);
                fields = (Field[]) m.invoke(klass);
            } catch (NoSuchMethodException | InvocationTargetException ex) {
                try {
                    Method m = Class.class.getDeclaredMethod("getDeclaredFields0", Boolean.TYPE);
                    m.setAccessible(true);
                    fields = (Field[]) m.invoke(klass, false);
                } catch (InvocationTargetException | NoSuchMethodException ex1) {
                    ex.addSuppressed(ex1);
                    throw new RuntimeException("Unable to get all class fields", ex);
                }
            }
            int c = 0;
            for (Field field : fields) {
                String name = field.getName();
                if ("fieldFilterMap".equals(name) || "methodFilterMap".equals(name)) {
                    field.setAccessible(true);
                    field.set(null, new HashMap<>(0));
                    if (++c == 2) {
                        return;
                    }
                }
            }
            throw new RuntimeException("One of field patches did not apply properly. " +
                    "Expected to patch two fields, but patched: " + c);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException("Unable to patch reflection filters", ex);
        }
    }

    /**
     * Attempts to make an {@link Instrumentation} capable
     * of transforming/redefining classes.
     *
     * @param instrumentation
     *      Instrumentation to patch.
     */
    public static void patchInstrumentation(Instrumentation instrumentation) {
        try {
            Class<?> klass = instrumentation.getClass();
            Field field = klass.getDeclaredField("mEnvironmentSupportsRedefineClasses");
            field.setAccessible(true);
            field.setBoolean(instrumentation, true);
            (field = klass.getDeclaredField("mEnvironmentSupportsRetransformClassesKnown")).setAccessible(true);
            field.setBoolean(instrumentation, true);
            (field = klass.getDeclaredField("mEnvironmentSupportsRetransformClasses")).setAccessible(true);
            field.setBoolean(instrumentation, true);
        } catch (NoSuchFieldException | IllegalAccessException ex) {
            Log.error("Could not patch instrumentation instance:", ex);
        }
    }

    /**
     * Attempts to patch {@link ZipOutputStream} to prevent
     * some tools from exploiting ZIP writing
     * mechanism.
     *
     * @param zip
     *      Stream to patch.
     */
    public static void patchZipOutput(ZipOutputStream zip) {
        try {
            Field field = ZipOutputStream.class.getDeclaredField("names");
            field.setAccessible(true);
            field.set(zip, new DiscardingSet());
        } catch (NoSuchFieldException | IllegalAccessException ex) {
            Log.error(ex, "Could not replace ZIP names");
        }
    }

    /**
     * A set that discards it's elements upon adding.
     * This class is used to prevent "Duplicate zip entry: "
     * error
     *
     * @author xDark
     */
    private static final class DiscardingSet extends HashSet<String> {

        @Override
        public boolean add(String s) {
            return true;
        }
    }
}

```

`src/main/java/me/coley/recaf/util/self/SelfDependencyPatcher.java`:

```java
package me.coley.recaf.util.self;

import me.coley.recaf.Recaf;
import me.coley.recaf.util.*;

import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Utility for patching self when missing dependencies.
 *
 * @author Matt
 * @author xxDark
 */
public class SelfDependencyPatcher {
	private static final String JFX_CLASSIFIER = createClassifier();
	private static final String JFX_VERSION = "18-ea+8";
	private static final List<String> JFX_DEPENDENCY_URLS = Arrays.asList(
		jfxUrlPattern("media"),
		jfxUrlPattern("controls"),
		jfxUrlPattern("graphics"),
		jfxUrlPattern("base")
	);

	/**
	 * Ensures that the JavaFX runtime is on the class path.
	 */
	public static void ensureJavafxSupport() {
		// Skip if platform class already exists
		if (ClasspathUtil.classExists("javafx.application.Platform"))
			return;
		// Check if JavaFX independent releases are compatible with current VM
		if (VMUtil.getVmVersion() < 11) {
			alertPre11UserMissingJFX();
			return;
		}
		// Ensure dependencies are downloaded
		List<Path> dependencyPaths = getLocalDependencies();
		addToClasspath(dependencyPaths);
	}

	/**
	 * @return List of path elements pointing to the local JavaFX dependencies to add into the classpath.
	 */
	private static List<Path> getLocalDependencies() {
		List<Path> dependencyPaths = new ArrayList<>();
		try {
			Path dependenciesDirectory = Recaf.getDirectory("dependencies");
			if (!Files.exists(dependenciesDirectory)) {
				Files.createDirectories(dependenciesDirectory);
			}
			for (String dependencyPattern : JFX_DEPENDENCY_URLS) {
				// Get appropriate remote URL
				String dependencyUrlPath = String.format(dependencyPattern, JFX_CLASSIFIER);
				Path dependencyFilePath = dependenciesDirectory.resolve(getUrlArtifactFileName(dependencyUrlPath));
				// Add the file to the paths list we will use later to inject
				dependencyPaths.add(dependencyFilePath);
				// Write to local directory if they are not already downloaded
				if (!Files.exists(dependencyFilePath)) {
					URL depURL = new URL(dependencyUrlPath);
					Files.copy(depURL.openStream(), dependencyFilePath, StandardCopyOption.REPLACE_EXISTING);
				}
			}
		} catch (MalformedURLException ex) {
			Log.error("Invalid dependency URL path", ex);
			alertUserFailedInit(ex);
		} catch (IOException ex) {
			Log.error("Failed to write remote dependency to cache", ex);
			alertUserFailedInit(ex);
		}
		return dependencyPaths;
	}

	/**
	 * Inserts the given jars into the classpath.
	 *
	 * @param dependencyPaths
	 * 		List of path elements to JavaFX jars to add to the classpath.
	 */
	private static void addToClasspath(List<Path> dependencyPaths) {
		try {
			// Fetch UCP of application's ClassLoader
			// - ((ClassLoaders.AppClassLoader) ClassLoaders.appClassLoader()).ucp
			Class<?> clsClassLoaders = Class.forName("jdk.internal.loader.ClassLoaders");
			Object appClassLoader = clsClassLoaders.getDeclaredMethod("appClassLoader").invoke(null);
			Class<?> ucpOwner = appClassLoader.getClass();
			// Field removed in 16, but still exists in parent class "BuiltinClassLoader"
			if (VMUtil.getVmVersion() >= 16)
				ucpOwner = ucpOwner.getSuperclass();
			Field fieldUCP = ucpOwner.getDeclaredField("ucp");
			fieldUCP.setAccessible(true);
			Object ucp = fieldUCP.get(appClassLoader);
			Class<?> clsUCP = ucp.getClass();
			Method addURL = clsUCP.getDeclaredMethod("addURL", URL.class);
			addURL.setAccessible(true);
			// Add each jar.
			for (Path path : dependencyPaths) {
				URL url = path.toAbsolutePath().toUri().toURL();
				addURL.invoke(ucp, url);
			}
		} catch (MalformedURLException ex) {
			// This should never occur
			Log.error("Failed to resolve local dependency jar to URL", ex);
			alertUserFailedInit(ex);
		} catch (ReflectiveOperationException ex) {
			// This should only occur if a JRE has some customizations to the way core classloaders are handled.
			// Or if they update something in a newer version of Java.
			Log.error("Failed to add missing JavaFX paths to classpath", ex);
			alertUserFailedInit(ex);
		}
	}

	/**
	 * Create a visible alert that the user cannot install JavaFX automatically due to incompatible Java versions.
	 */
	private static void alertPre11UserMissingJFX() {
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		toolkit.beep();
		// Collect debug information
		String[] properties = {
			"os.name", "os.version", "os.arch",
			"java.version", "java.vm.name", "java.vm.vendor", "java.home"
		};
		StringWriter writer = new StringWriter();
		for (String prop : properties) {
			writer.append(String.format("%s = %s", prop, System.getProperty(prop)));
		}
		String debugInfo = writer.toString();
		// Show message
		String style = "<style>" +
				"p {font-family: Arial; font-size:14;} " +
				"pre { background: #DDDDDD; padding: 5px; border: 1px solid black; }" +
				"</style>";
		String message = "<p>The required JavaFX classes could not be found locally.<br><br>Your environment:</p>" +
				"<pre>" + debugInfo + "</pre>" +
				"<p>You have two options:<br>" +
				" 1. Use a JDK that bundles JavaFX<br>" +
				" 2. Update to Java 11 or higher <i>(Recaf will automatically download JavaFX)</i></p>";
		JEditorPane pane = new JEditorPane("text/html", style + message);
		pane.setEditable(false);
		pane.setOpaque(false);
		JOptionPane.showMessageDialog(null,
				pane, "JavaFX could not be found",
				JOptionPane.ERROR_MESSAGE);
		System.exit(0);
	}

	/**
	 * Create a visible alert that the user cannot install JavaFX automatically due to some error that occurred.
	 */
	private static void alertUserFailedInit(Exception ex) {
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		toolkit.beep();
		// Collect some debug info
		StringWriter writer = new StringWriter();
		writer.append("OS: " + System.getProperty("os.name") + "\n");
		writer.append("Version: " + System.getProperty("java.version") + "\n");
		writer.append("Vendor: " + System.getProperty("java.vm.vendor") + "\n\n");
		writer.append("Exception: ");
		// Append exception to string
		ex.printStackTrace(new PrintWriter(writer));
		String errorString = writer.toString();
		// Copy to clipboard
		StringSelection selection = new StringSelection(errorString);
		Clipboard clipboard = toolkit.getSystemClipboard();
		clipboard.setContents(selection, selection);
		// Show message
		String bugReportURL = "https://github.com/Col-E/Recaf/issues/new/choose";
		String style = "<style>" +
				"p {font-family: Arial; font-size:14;} " +
				"pre { background: #DDDDDD; padding: 5px; border: 1px solid black; }" +
				"</style>";
		String message = "<p>Something went wrong when trying to load JavaFX.<br>" +
				"<b>The following information about the problem has been copied to your clipboard:</b></p><br>" +
				"<pre>" + errorString + "</pre>" +
				"<p>Please make sure that you meet one of the following requirements:<br>" +
				" 1. Use a JDK that bundles JavaFX<br>" +
				" 2. Update to Java 11 or higher <i>(Recaf will automatically download JavaFX)</i><br><br>" +
				"If you believe this is a bug, please " +
				"<a href=\"" + bugReportURL + "\">open an issue on GitHub</a></p>";
		JEditorPane pane = new JEditorPane("text/html", style + message);
		pane.setEditable(false);
		pane.setOpaque(false);
		int height = 250 + StringUtil.count("\n", errorString) * 22;
		if (height > toolkit.getScreenSize().height - 100) {
			height = toolkit.getScreenSize().height - 100;
		}
		JScrollPane scroll = new JScrollPane(pane);
		scroll.setPreferredSize(new Dimension(800, height));
		scroll.setBorder(BorderFactory.createEmptyBorder());
		JOptionPane.showMessageDialog(null,
				scroll, "Error initializing JavaFX",
				JOptionPane.ERROR_MESSAGE);
		System.exit(0);
	}

	/**
	 * @param url
	 * 		Full url path.
	 *
	 * @return Name of file at url.
	 */
	private static String getUrlArtifactFileName(String url) {
		return url.substring(url.lastIndexOf('/') + 1);
	}

	/**
	 * @param component
	 * 		Name of the component.
	 *
	 * @return Formed pattern <i>(Arg for classifier)</i> for the URL to the component.
	 */
	private static String jfxUrlPattern(String component) {
		// Add platform specific identifier to the end.
		return String.format("https://repo1.maven.org/maven2/org/openjfx/javafx-%s/%s/javafx-%s-%s",
				component, JFX_VERSION, component, JFX_VERSION) + "-%s.jar";
	}


	/**
	 * @return JavaFX Maven classifier based on the current OS/platform.
	 */
	private static String createClassifier() {
		// Possible targets:
		// - linux-aarch64
		// - linux-arm32
		// - linux
		// - mac-aarch64
		// - mac
		// - win
		String os = normalizeOs();
		// JavaFX does not differentiate against windows
		if (os.equals("win"))
			return os;
		// Check for arch-specific releases
		String arch = normalizeArch();
		if (os.equals("mac") && arch.equals("aarch64"))
			return os + "-" + arch;
		if (os.equals("linux") && arch.equals("aarch64"))
			return os + "-" + arch;
		if (os.equals("linux") && arch.equals("arm32"))
			return os + "-" + arch;
		// Fallback to default
		return os;
	}

	/**
	 * @return Operating system name pattern matching the maven classifier format.
	 * This portion supplies the prefix in {@code OS-ARCH} classifiers.
	 */
	private static String normalizeOs() {
		OSUtil os = OSUtil.getOSType();
		if (os == OSUtil.MAC)
			return "mac";
		if (os == OSUtil.WINDOWS)
			return "win";
		// It's probably a linux system
		return "linux";
	}

	/**
	 * @return Architecture name pattern matching the maven classifier format.
	 * This portion supplies the suffix in {@code OS-ARCH} classifiers.
	 */
	private static String normalizeArch() {
		// JavaFX only targets certain architectures, so we only care about normalizing a few.
		String arch = normalize(System.getProperty("os.arch"));
		if ("aarch64".equals(arch))
			return "aarch64";
		if (arch.matches("^(arm|arm32)$"))
			return "arm32";
		return arch;
	}

	/**
	 * @param value
	 * 		Some text value.
	 *
	 * @return Value lower-cased with non-letters and non-numbers stripped from the name.
	 */
	private static String normalize(String value) {
		return value.toLowerCase().replaceAll("[^a-z0-9]+", "");
	}
}

```

`src/main/java/me/coley/recaf/util/self/SelfReferenceUtil.java`:

```java
package me.coley.recaf.util.self;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.CodeSource;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import me.coley.recaf.Recaf;
import me.coley.recaf.util.Resource;

import static me.coley.recaf.util.Log.error;

/**
 * Utility for self-referencing the Recaf application as a file.
 *
 * @author Matt
 */
public class SelfReferenceUtil {
	private final File file;
	private final boolean isJar;

	private SelfReferenceUtil(File file) {
		this.file = file;
		this.isJar = file.getName().toLowerCase().endsWith(".jar");
	}

	/**
	 * @return File reference to self.
	 */
	public File getFile() {
		return file;
	}

	/**
	 * @return File path to self.
	 */
	public String getPath() {
		return file.getAbsolutePath();
	}

	/**
	 * @return Is the current executable context a jar file.
	 */
	public boolean isJar() {
		return isJar;
	}

	/**
	 * @return List of language files recognized.
	 */
	public List<Resource> getLangs() {
		return getFiles("translations/", ".json");
	}

	/**
	 * @return List of application-wide styles recognized.
	 */
	public List<Resource> getStyles() {
		return getFiles("style/ui-", ".css");
	}

	/**
	 * @return List of text-editor styles recognized.
	 */
	public List<Resource> getTextThemes() {
		return getFiles("style/text-", ".css");
	}

	/**
	 * @param prefix
	 *            File prefix to match.
	 * @param suffix
	 *            File suffix to match <i>(such as a file extension)</i>.
	 * @return List of matching files.
	 */
	private List<Resource> getFiles(String prefix, String suffix) {
		List<Resource> list = new ArrayList<>();
		if (isJar()) {
			// Read self as jar
			try (ZipFile file = new ZipFile(getFile())) {
				Enumeration<? extends ZipEntry> entries = file.entries();
				while (entries.hasMoreElements()) {
					ZipEntry entry = entries.nextElement();
					// skip directories
					if (entry.isDirectory()) continue;
					String name = entry.getName();
					if (prefix != null && !name.startsWith(prefix))
						continue;
					if (suffix != null && !name.endsWith(suffix))
						continue;
					list.add(Resource.internal(name));
				}
			} catch (Exception ex) {
				error(ex, "Failed internal file (archive) lookup: {}", getFile());
			}
		} else {
			// Read self as file directory
			Path dir = getFile().toPath();
			try {
				Files.walk(dir).forEach(p -> {
					File file = dir.relativize(p).toFile();
					String path = file.getPath().replace('\\', '/');
					if (prefix != null && !path.startsWith(prefix))
						return;
					if (suffix != null && !path.endsWith(suffix))
						return;
					list.add(Resource.internal(path));
				});
			} catch(IOException ex) {
				error(ex, "Failed internal file (directory) lookup: {}", getFile());
			}
		}
		return list;
	}

	/**
	 * @return Recaf executable context.
	 */
	public static SelfReferenceUtil get() {
		try {
			CodeSource codeSource = Recaf.class.getProtectionDomain().getCodeSource();
			File selfFile = new File(codeSource.getLocation().toURI().getPath());
			return new SelfReferenceUtil(selfFile);
		} catch(URISyntaxException ex) {
			// This shouldn't happen since the location URL shouldn't be invalid.
			throw new IllegalStateException("Failed to resolve self reference", ex);
		}
	}
}
```

`src/main/java/me/coley/recaf/util/self/SelfUpdater.java`:

```java
package me.coley.recaf.util.self;

import com.eclipsesource.json.Json;
import com.eclipsesource.json.JsonArray;
import com.eclipsesource.json.JsonObject;
import com.eclipsesource.json.JsonValue;
import me.coley.recaf.Recaf;
import me.coley.recaf.control.Controller;
import me.coley.recaf.util.LangUtil;
import me.coley.recaf.util.Log;
import org.apache.commons.io.IOUtils;

import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.format.DateTimeParseException;

/**
 * Utility for updating Recaf.
 *
 * @author Matt
 */
public class SelfUpdater {
	private static final String API = "https://api.github.com/repos/Col-E/Recaf/releases/latest";
	private static final long UPDATER_START_DELAY_MS = 1000;
	private static final String currentVersion = Recaf.VERSION;
	private static boolean disabled;
	private static String latestVersion;
	private static String latestArtifact;
	private static String latestPatchnotes;
	private static Instant latestVersionDate;
	private static int latestArtifactSize;
	private static Controller controller;
	private static String[] args;

	/**
	 * Start the update process.
	 *
	 * @throws IOException
	 * 		When starting the update task fails.
	 */
	public static void updateRecaf() throws IOException {
		// Skip if no updates
		if (!hasUpdate())
			return;
		String path = SelfReferenceUtil.get().getPath().replace(currentVersion, latestVersion);
		Log.info("Start update: '{}' ==> '{}'", latestVersion, path);
		UpdateTaskStarter starter = new UpdateTaskStarter(path, latestArtifact, UPDATER_START_DELAY_MS, args);
		starter.start();
	}

	/**
	 * Fetch latest update information.
	 */
	public static void checkForUpdates() {
		// Check if updates are disabled, or if we're not a jar (developer workspace)
		if (disabled || !isJarContext())
			return;
		// Check if update process should run
		if (shouldSkipUpdate())
			return;
		// Get latest data
		try {
			updateCheckDate();
			fetchLatestInfo();
		} catch(IOException ex) {
			Log.error(ex, "Failed to read from release API");
		}
	}

	/**
	 * Fetch the {@link #latestVersion latest version}
	 * and {@link #latestArtifact latest artifact url}.
	 *
	 * @throws IOException
	 * 		When opening a connection to the API url fails.
	 */
	private static void fetchLatestInfo() throws IOException {
		URL updateURL = new URL(API);
		String content = IOUtils.toString(updateURL.openStream(), StandardCharsets.UTF_8);
		JsonObject updateJson = Json.parse(content).asObject();
		// compare versions
		latestVersion = updateJson.getString("tag_name", "2.0.0");
		latestPatchnotes = updateJson.getString("body", "#Error\nCould not fetch update notes.");
		if (isOutdated()) {
			Log.info(LangUtil.translate("update.outdated"));
			JsonArray assets = updateJson.get("assets").asArray();
			for(JsonValue assetValue : assets.values()) {
				JsonObject assetObj = assetValue.asObject();
				String file = assetObj.getString("name", "invalid");
				// Skip non-jars
				if (!file.endsWith(".jar")) {
					continue;
				}
				// Find the largest jar
				int size = assetObj.getInt("size", 0);
				if (size > latestArtifactSize) {
					latestArtifactSize = size;
					String fileURL = assetObj.getString("browser_download_url", null);
					if (fileURL != null)
						latestArtifact = fileURL;
				}
			}
			try {
				String date = updateJson.getString("published_at", null);
				if (date != null)
					latestVersionDate = Instant.parse(date);
			} catch(DateTimeParseException ex) {
				Log.warn("Failed to parse timestamp for latest release");
			}
			if (latestArtifact == null)
				Log.warn(LangUtil.translate("update.fail.nodownload"));
		}
	}

	/**
	 * @return {@code true} when the current version is behind latest version.
	 */
	private static boolean isOutdated() {
		try {
			String[] arrSelf = currentVersion.split("\\.");
			String[] arrLatest = latestVersion.split("\\.");
			if (arrSelf.length == arrLatest.length) {
				for (int i = 0; i < arrSelf.length; i++) {
					int iSelf = Integer.parseInt(arrSelf[i]);
					int iLatest = Integer.parseInt(arrLatest[i]);
					if (iSelf == iLatest) {
						// do nothing
						continue;
					} else {
						return iSelf < iLatest;
					}
				}
			}
		} catch (Exception ex) {
			Log.error(ex, "Failed parsing versions, current is '{}', latest is '{}'", currentVersion, latestArtifact);
		}
		return false;
	}

	/**
	 * @return {@code true} if the update process should be skipped.
	 */
	private static boolean shouldSkipUpdate()  {
		return controller.config().update().shouldSkip();
	}

	/**
	 * Updates the last check time in the config.
	 */
	private static void updateCheckDate() {
		controller.config().update().lastCheck = System.currentTimeMillis();
	}

	/**
	 * Set the controller to load configuration from.
	 *
	 * @param controller
	 * 		Controller to pull config from.
	 */
	public static void setController(Controller controller) {
		SelfUpdater.controller = controller;
	}

	/**
	 * @param args
	 * 		Launch arguments to pass to Recaf instance.
	 */
	public static void setArgs(String[] args) {
		// Copy arguments
		SelfUpdater.args = args;
	}

	/**
	 * Disable update checks.
	 */
	public static void disable() {
		disabled = true;
	}

	/**
	 * @return {@code true} when Recaf is run from a jar.
	 */
	private static boolean isJarContext() {
		return SelfReferenceUtil.get().isJar();
	}

	/**
	 * @return {@code true} when an update has been detected.
	 */
	public static boolean hasUpdate() {
		return latestArtifact != null;
	}

	/**
	 * @return Most up to date version of Recaf.
	 */
	public static String getLatestVersion() {
		return latestVersion;
	}

	/**
	 * @return URL string to latest artifact of Recaf.
	 */
	public static String getLatestArtifact() {
		return latestArtifact;
	}

	/**
	 * @return Markdown text of latest Recaf update notes.
	 */
	public static String getLatestPatchnotes() {
		return latestPatchnotes;
	}

	/**
	 * @return Time of most recent Recaf update.
	 */
	public static Instant getLatestVersionDate() {
		return latestVersionDate;
	}

	/**
	 * @return Size in bytes of most recent Recaf update.
	 */
	public static int getLatestArtifactSize() {
		return latestArtifactSize;
	}
}

```

`src/main/java/me/coley/recaf/util/self/UpdateTaskStarter.java`:

```java
package me.coley.recaf.util.self;

import me.coley.recaf.Recaf;
import org.objectweb.asm.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * Creates an independent update script and executes it.
 *
 * @author Matt
 */
public class UpdateTaskStarter implements Opcodes {
	private static final String CLASS_NAME = "UpdateRunner";
	private final String filePath;
	private final String url;
	private final long delay;
	private final String[] args;

	/**
	 * @param filePath
	 * 		Destination of downloaded artifact.
	 * @param url
	 * 		Artifact url to download.
	 * @param delay
	 * 		Delay before starting download.
	 * @param args
	 * 		Arguments to pass to downloaded artifact.
	 */
	public UpdateTaskStarter(String filePath, String url, long delay, String[] args) {
		this.filePath = filePath;
		this.url = url;
		this.delay = delay;
		this.args = args;
	}

	/**
	 * Start the updater.
	 *
	 * @throws IOException
	 * 		When the update runner class cannot be written to,
	 * 		or when the process failed to start.
	 */
	public void start() throws IOException {
		// Write updater class
		Path updaterPath = Recaf.getDirectory().resolve(CLASS_NAME +".class");
		Files.write(updaterPath, dump(), StandardOpenOption.CREATE);
		// Execute
		List<String> procArgs = new LinkedList<>();
		procArgs.add(System.getProperty("java.home") + File.separator + "bin" + File.separator + "java");
		procArgs.add("-cp");
		procArgs.add(Recaf.getDirectory().toString());
		procArgs.add(CLASS_NAME);
		if (args != null)
			Collections.addAll(procArgs, args);
		new ProcessBuilder(procArgs).start();
	}

	/**
	 * Auto-generated code by ASMifier, slightly modified.
	 *
	 * @return Bytecode of runner class.
	 */
	private byte[] dump() {
		// This is the original method code that we will be writing to a file.
		/*
		public static void main(String[] args) throws Throwable {
			// Wait
			Thread.sleep(DELAY_HERE);
			// Download
			String pathStr = "FILE_PATH_HERE";
			try(InputStream is = new URL("URL_HERE").openStream()) {
				Files.copy(is, Paths.get(pathStr), StandardCopyOption.REPLACE_EXISTING);
			}
			// Execute downloaded jar
			List<String> procArgs = new ArrayList<>();
			procArgs.add(System.getProperty("java.home") + File.separator + "bin" + File.separator + "java");
			procArgs.add("-jar");
			procArgs.add(pathStr);
			Collections.addAll(procArgs, args);
			new ProcessBuilder(procArgs).start();
		}
		*/
		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
		cw.visit(50, ACC_PUBLIC + ACC_SUPER, CLASS_NAME, null, "java/lang/Object", null);
		// Constructor
		MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
		mv.visitCode();
		mv.visitVarInsn(ALOAD, 0);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		mv.visitInsn(RETURN);
		mv.visitMaxs(1, 1);
		mv.visitEnd();
		// Main method
		mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null,
				new String[]{"java/lang/Throwable"});
		mv.visitCode();
		Label l0 = new Label();
		Label l1 = new Label();
		Label l2 = new Label();
		mv.visitTryCatchBlock(l0, l1, l2, "java/lang/Throwable");
		Label l3 = new Label();
		Label l4 = new Label();
		Label l5 = new Label();
		mv.visitTryCatchBlock(l3, l4, l5, "java/lang/Throwable");
		Label l6 = new Label();
		mv.visitTryCatchBlock(l3, l4, l6, null);
		Label l7 = new Label();
		Label l8 = new Label();
		Label l9 = new Label();
		mv.visitTryCatchBlock(l7, l8, l9, "java/lang/Throwable");
		Label l10 = new Label();
		mv.visitTryCatchBlock(l5, l10, l6, null);
		Label l11 = new Label();
		mv.visitLabel(l11);
		mv.visitLineNumber(16, l11);
		mv.visitLdcInsn(delay);
		mv.visitMethodInsn(INVOKESTATIC, "java/lang/Thread", "sleep", "(J)V", false);
		Label l12 = new Label();
		mv.visitLabel(l12);
		mv.visitLineNumber(18, l12);
		mv.visitLdcInsn(filePath);
		mv.visitVarInsn(ASTORE, 1);
		Label l13 = new Label();
		mv.visitLabel(l13);
		mv.visitLineNumber(19, l13);
		mv.visitTypeInsn(NEW, "java/net/URL");
		mv.visitInsn(DUP);
		mv.visitLdcInsn(url);
		mv.visitMethodInsn(INVOKESPECIAL, "java/net/URL", "<init>", "(Ljava/lang/String;)V", false);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/net/URL", "openStream", "()Ljava/io/InputStream;", false);
		mv.visitVarInsn(ASTORE, 2);
		Label l14 = new Label();
		mv.visitLabel(l14);
		mv.visitInsn(ACONST_NULL);
		mv.visitVarInsn(ASTORE, 3);
		mv.visitLabel(l3);
		mv.visitLineNumber(20, l3);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitVarInsn(ALOAD, 1);
		mv.visitInsn(ICONST_0);
		mv.visitTypeInsn(ANEWARRAY, "java/lang/String");
		mv.visitMethodInsn(INVOKESTATIC, "java/nio/file/Paths", "get",
				"(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;", false);
		mv.visitInsn(ICONST_1);
		mv.visitTypeInsn(ANEWARRAY, "java/nio/file/CopyOption");
		mv.visitInsn(DUP);
		mv.visitInsn(ICONST_0);
		mv.visitFieldInsn(GETSTATIC, "java/nio/file/StandardCopyOption", "REPLACE_EXISTING",
				"Ljava/nio/file/StandardCopyOption;");
		mv.visitInsn(AASTORE);
		mv.visitMethodInsn(INVOKESTATIC, "java/nio/file/Files", "copy",
				"(Ljava/io/InputStream;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)J", false);
		mv.visitInsn(POP2);
		mv.visitLabel(l4);
		mv.visitLineNumber(21, l4);
		mv.visitVarInsn(ALOAD, 2);
		Label l15 = new Label();
		mv.visitJumpInsn(IFNULL, l15);
		mv.visitVarInsn(ALOAD, 3);
		Label l16 = new Label();
		mv.visitJumpInsn(IFNULL, l16);
		mv.visitLabel(l0);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/InputStream", "close", "()V", false);
		mv.visitLabel(l1);
		mv.visitJumpInsn(GOTO, l15);
		mv.visitLabel(l2);
		mv.visitVarInsn(ASTORE, 4);
		mv.visitVarInsn(ALOAD, 3);
		mv.visitVarInsn(ALOAD, 4);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Throwable", "addSuppressed",
				"(Ljava/lang/Throwable;)V", false);
		mv.visitJumpInsn(GOTO, l15);
		mv.visitLabel(l16);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/InputStream", "close", "()V", false);
		mv.visitJumpInsn(GOTO, l15);
		mv.visitLabel(l5);
		mv.visitLineNumber(19, l5);
		mv.visitVarInsn(ASTORE, 4);
		mv.visitVarInsn(ALOAD, 4);
		mv.visitVarInsn(ASTORE, 3);
		mv.visitVarInsn(ALOAD, 4);
		mv.visitInsn(ATHROW);
		mv.visitLabel(l6);
		mv.visitLineNumber(21, l6);
		mv.visitVarInsn(ASTORE, 5);
		mv.visitLabel(l10);
		mv.visitVarInsn(ALOAD, 2);
		Label l17 = new Label();
		mv.visitJumpInsn(IFNULL, l17);
		mv.visitVarInsn(ALOAD, 3);
		Label l18 = new Label();
		mv.visitJumpInsn(IFNULL, l18);
		mv.visitLabel(l7);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/InputStream", "close", "()V", false);
		mv.visitLabel(l8);
		mv.visitJumpInsn(GOTO, l17);
		mv.visitLabel(l9);
		mv.visitVarInsn(ASTORE, 6);
		mv.visitVarInsn(ALOAD, 3);
		mv.visitVarInsn(ALOAD, 6);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Throwable", "addSuppressed",
				"(Ljava/lang/Throwable;)V", false);
		mv.visitJumpInsn(GOTO, l17);
		mv.visitLabel(l18);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/InputStream", "close", "()V", false);
		mv.visitLabel(l17);
		mv.visitVarInsn(ALOAD, 5);
		mv.visitInsn(ATHROW);
		mv.visitLabel(l15);
		mv.visitLineNumber(23, l15);
		mv.visitTypeInsn(NEW, "java/util/ArrayList");
		mv.visitInsn(DUP);
		mv.visitMethodInsn(INVOKESPECIAL, "java/util/ArrayList", "<init>", "()V", false);
		mv.visitVarInsn(ASTORE, 2);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
		mv.visitInsn(DUP);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
		mv.visitLdcInsn("java.home");
		mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "getProperty",
				"(Ljava/lang/String;)Ljava/lang/String;", false);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append",
				"(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitFieldInsn(GETSTATIC, "java/io/File", "separator", "Ljava/lang/String;");
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append",
				"(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitLdcInsn("bin");
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append",
				"(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitFieldInsn(GETSTATIC, "java/io/File", "separator", "Ljava/lang/String;");
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append",
				"(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitLdcInsn("java");
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append",
				"(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString",
				"()Ljava/lang/String;", false);
		mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z", true);
		mv.visitInsn(POP);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitLdcInsn("-jar");
		mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z", true);
		mv.visitInsn(POP);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitVarInsn(ALOAD, 1);
		mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z", true);
		mv.visitInsn(POP);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitVarInsn(ALOAD, 0);
		mv.visitMethodInsn(INVOKESTATIC, "java/util/Collections", "addAll",
				"(Ljava/util/Collection;[Ljava/lang/Object;)Z", false);
		mv.visitInsn(POP);
		mv.visitTypeInsn(NEW, "java/lang/ProcessBuilder");
		mv.visitInsn(DUP);
		mv.visitVarInsn(ALOAD, 2);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/ProcessBuilder", "<init>", "(Ljava/util/List;)V", false);
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/ProcessBuilder", "start", "()Ljava/lang/Process;", false);
		mv.visitInsn(POP);
		mv.visitInsn(RETURN);
		mv.visitMaxs(6, 7);
		mv.visitEnd();
		cw.visitEnd();
		return cw.toByteArray();
	}
}

```

`src/main/java/me/coley/recaf/util/struct/Errorable.java`:

```java
package me.coley.recaf.util.struct;

/**
 * Essentially {@link Runnable} but can throw an exception.
 *
 * @param <T>
 * 		Type of exception.
 *
 * @author Matt
 */
public interface Errorable<T extends Throwable> {
	/**
	 * @throws T
	 * 		Exception thrown.
	 */
	void run() throws T;
}

```

`src/main/java/me/coley/recaf/util/struct/Expireable.java`:

```java
package me.coley.recaf.util.struct;

import java.util.function.Supplier;

/**
 * A value that expires after a given threshold, prompting a new value to be supplied.
 *
 * @param <T>
 * 		Type to store.
 */
public class Expireable<T> {
	private final Supplier<T> getter;
	private long threshold;
	private long lastGet;
	private T value;

	/**
	 * Create an expirable value.
	 *
	 * @param threshold
	 * 		Time until the current value is invalidated.
	 * @param getter
	 * 		Supplier function for the value.
	 */
	public Expireable(long threshold, Supplier<T> getter) {
		this.threshold = threshold;
		this.getter = getter;
		this.value = getter.get();
		this.lastGet = System.currentTimeMillis();
	}

	/**
	 * @return Current value.
	 */
	public T get() {
		if(System.currentTimeMillis() - lastGet > threshold) {
			value = getter.get();
			lastGet = System.currentTimeMillis();
		}
		return value;
	}
}

```

`src/main/java/me/coley/recaf/util/struct/InternalBiConsumer.java`:

```java
package me.coley.recaf.util.struct;

import me.coley.recaf.plugin.api.InternalApi;
import me.coley.recaf.util.InternalElement;

import java.util.function.BiConsumer;

/**
 * Internal listener for Recaf purposes.
 *
 * @param <T>
 *     First type of an object.
 * @param <U>
 *     Second type an object.
 *
 * @author xxDark
 */
@InternalApi
@FunctionalInterface
public interface InternalBiConsumer<T, U> extends BiConsumer<T, U>, InternalElement {

    /**
     * Wraps bi consumer into internal listener.
     *
     * @param consumer
     *      Original bi consumer.
     * @param <T>
     *     First type of an object.
     * @param <U>
     *     Second type an object.
     * @return
     *      BiConsumer wrapped into internal listener.
     */
    static <T, U> InternalBiConsumer<T, U> internal(BiConsumer<T, U> consumer) {
        return consumer::accept;
    }
}

```

`src/main/java/me/coley/recaf/util/struct/InternalConsumer.java`:

```java
package me.coley.recaf.util.struct;

import me.coley.recaf.plugin.api.InternalApi;
import me.coley.recaf.util.InternalElement;

import java.util.function.Consumer;

/**
 * Internal listener for Recaf purposes.
 *
 * @param <T>
 *     Type of an object.
 *
 * @author xxDark
 */
@InternalApi
@FunctionalInterface
public interface InternalConsumer<T> extends Consumer<T>, InternalElement {

    /**
     * Wraps consumer into internal listener.
     *
     * @param consumer
     *      Original consumer.
     * @param <T>
     *     Type of an object.
     * @return
     *      Consumer wrapped into internal listener.
     */
    static <T> InternalConsumer<T> internal(Consumer<T> consumer) {
        return consumer::accept;
    }
}

```

`src/main/java/me/coley/recaf/util/struct/LineException.java`:

```java
package me.coley.recaf.util.struct;

/**
 * Model of exception that holds line information.
 */
public interface LineException {
	/**
	 * @return Line the parse error occurred on.
	 */
	int getLine();

	/**
	 * @return Error message.
	 */
	String getMessage();
}

```

`src/main/java/me/coley/recaf/util/struct/ListeningMap.java`:

```java
package me.coley.recaf.util.struct;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Map implementation that allows registering listeners for map update calls.<br>
 * See:<ul>
 * <li>{@link #getPutListeners()}</li>
 * <li>{@link #getRemoveListeners()}</li>
 * </ul>
 *
 * @param <K> Key type of map.
 * @param <V> Value type of map.
 */
public class ListeningMap<K, V> implements Map<K, V> {
	private final Set<BiConsumer<K, V>> putListeners = new HashSet<>();
	private final Set<Consumer<Object>> removeListeners = new HashSet<>();
	private Map<K, V> backing;

	/**
	 * @param backing
	 * 		The map to contain the actual data.
	 */
	public void setBacking(Map<K, V> backing) {
		this.backing = backing;
	}

	/**
	 * @return {@code true} when the backing map is not null.
	 */
	public boolean isBacked() {
		return backing != null;
	}

	/**
	 * @return Set of listeners that are fed the key and value of items putted items.
	 */
	public Set<BiConsumer<K, V>> getPutListeners() {
		return putListeners;
	}

	/**
	 * @return Set of listeners that are fed keys or removed items.
	 */
	public Set<Consumer<Object>> getRemoveListeners() {
		return removeListeners;
	}

	@Override
	public V put(K key, V value) {
		putListeners.forEach(listener -> listener.accept(key, value));
		return backing.put(key, value);
	}

	@Override
	public V remove(Object key) {
		removeListeners.forEach(listener -> listener.accept(key));
		return backing.remove(key);
	}

	@Override
	public void putAll(Map<? extends K, ? extends V> m) {
		for(Map.Entry<? extends K, ? extends V> e : m.entrySet())
			put(e.getKey(), e.getValue());
	}

	@Override
	public V get(Object key) {
		return backing.get(key);
	}

	@Override
	public int size() {
		return backing.size();
	}

	@Override
	public boolean isEmpty() {
		return backing.isEmpty();
	}

	@Override
	public boolean containsKey(Object key) {
		return backing.containsKey(key);
	}

	@Override
	public boolean containsValue(Object value) {
		return backing.containsValue(value);
	}

	@Override
	public void clear() {
		backing.clear();
	}

	@Override
	public Set<K> keySet() {
		return backing.keySet();
	}

	@Override
	public Collection<V> values() {
		return backing.values();
	}

	@Override
	public Set<Entry<K, V>> entrySet() {
		return backing.entrySet();
	}
}

```

`src/main/java/me/coley/recaf/util/struct/Pair.java`:

```java
package me.coley.recaf.util.struct;

import java.util.Objects;

/**
 * Simple Key:Value pair.
 *
 * @param <K>
 * 		Key type.
 * @param <V>
 * 		Value type.
 *
 * @author Matt
 */
public class Pair<K, V> {
	private final K key;
	private final V value;

	/**
	 * Constructs a pair.
	 *
	 * @param key
	 * 		Left item.
	 * @param value
	 * 		Right item.
	 */
	public Pair(K key, V value) {
		this.key = key;
		this.value = value;
	}

	/**
	 * @return Left item.
	 */
	public K getKey() { return key; }

	/**
	 * @return Right item, or item associated with the {@link #getKey()}.
	 */
	public V getValue() { return value; }

	@Override
	public String toString() { return key + "=" + value; }

	@Override
	public int hashCode() {	return Objects.hash(key, value); }

	@Override
	public boolean equals(Object o) {
		if(this == o) return true;
		if(o instanceof Pair) {
			Pair other = (Pair) o;
			if(key != null && !key.equals(other.key)) return false;
			if(value != null && !value.equals(other.value)) return false;
			return true;
		}
		return false;
	}
}

```

`src/main/java/me/coley/recaf/util/struct/ThreadAction.java`:

```java
package me.coley.recaf.util.struct;

import javafx.application.Platform;
import me.coley.recaf.util.ThreadUtil;

import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Utility to run consumers on a given thread.
 *
 * @param <T>
 * 		Type of content.
 *
 * @author Matt
 */
public class ThreadAction<T> {
	private Supplier<T> supplier;
	private Consumer<T> consumer;
	private boolean consumerFx;

	/**
	 * @param <T>
	 * 		Type of content.
	 *
	 * @return Built action.
	 */
	public static <T> ThreadAction<T> create() {
		return new ThreadAction<>();
	}

	/**
	 * @param supplier
	 * 		Content source.
	 *
	 * @return Built action.
	 */
	public ThreadAction<T> supplier(Supplier<T> supplier) {
		this.supplier = supplier;
		return this;
	}

	/**
	 * @param consumer
	 * 		Action to run on content.
	 *
	 * @return Built action.
	 */
	public ThreadAction<T> consumer(Consumer<T> consumer) {
		this.consumer = consumer;
		return this;
	}

	/**
	 * Set consumer action to run on JavaFx thread.
	 *
	 * @return Built action.
	 */
	public ThreadAction<T> onUi() {
		this.consumerFx = true;
		return this;
	}

	/**
	 * Run 'em.
	 */
	public void run() {
		ThreadUtil.run(() -> {
			T value = supplier.get();
			if(consumer != null) {
				if(consumerFx) {
					Platform.runLater(() -> consumer.accept(value));
				} else {
					consumer.accept(value);
				}
			}
		});
	}
}
```

`src/main/java/me/coley/recaf/workspace/ArchiveResource.java`:

```java
package me.coley.recaf.workspace;

import java.io.IOException;
import java.nio.file.Path;

/**
 * Importable archive base.
 *
 * @author Matt
 */
public abstract class ArchiveResource extends FileSystemResource {
	/**
	 * Constructs an archive file resource.
	 *
	 * @param kind
	 * 		The kind of resource implementation.
	 * @param path
	 * 		The reference to the file resource.
	 *
	 * @throws IOException
	 * 		When the file does not exist.
	 */
	public ArchiveResource(ResourceKind kind, Path path) throws IOException {
		super(kind, path);
	}
}

```

`src/main/java/me/coley/recaf/workspace/ClassResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.parse.source.SourceCodeException;
import me.coley.recaf.util.IOUtil;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * Importable class resource.
 *
 * @author Matt
 */
public class ClassResource extends FileSystemResource {
	/**
	 * Constructs a class resource.
	 *
	 * @param path
	 * 		Path reference to a class file.
	 *
	 * @throws IOException
	 * 		When the path does not exist.
	 */
	public ClassResource(Path path) throws IOException {
		super(ResourceKind.CLASS, path);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		EntryLoader loader = getEntryLoader();
		try (InputStream stream = Files.newInputStream(getPath())) {
			byte[] value = IOUtil.toByteArray(stream);
			loader.onClass(getPath().getFileName().toString(), value);
			loader.finishClasses();
			return loader.getClasses();
		} catch(ArrayIndexOutOfBoundsException | IllegalArgumentException ex) {
			throw new IOException("Failed to load class '" + getPath().getFileName() + "'", ex);
		}
	}

	@Override
	protected Map<String, byte[]> loadFiles() {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, SourceCode> loadSources(Path path) throws IOException {
		if (IOUtil.getExtension(path).equals("java")) {
			try {
				SourceCode code = new SourceCode(this, String.join("", Files.readAllLines(path,
						StandardCharsets.UTF_8)));
				code.analyze();
				return Collections.singletonMap(code.getInternalName(), code);
			} catch(IOException ex) {
				throw new IOException("Failed to read from source file: " + path, ex);
			} catch(SourceCodeException ex) {
				throw new IOException("Invalid source code file: " + path, ex);
			}
		}
		return super.loadSources(path);
	}
}

```

`src/main/java/me/coley/recaf/workspace/DeferringResource.java`:

```java
package me.coley.recaf.workspace;

import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import me.coley.recaf.parse.javadoc.Javadocs;
import me.coley.recaf.parse.source.SourceCode;

import java.io.IOException;
import java.nio.file.Path;
import java.util.*;

/**
 * Resource that defers to some backing resource.
 *
 * @author Matt
 */
public class DeferringResource extends JavaResource {
	private JavaResource backing;

	/**
	 * Constructs a java resource.
	 *
	 * @param kind
	 * 		The kind of resource implementation.
	 */
	public DeferringResource(ResourceKind kind) {
		super(kind);
	}

	/**
	 * @param backing
	 * 		Resource to defer to.
	 */
	public void setBacking(JavaResource backing) {
		this.backing = backing;
	}

	/**
	 * @return Deferred resource.
	 */
	public JavaResource getBacking() {
		return backing;
	}

	// ====================== Overrides pointing to backing resource ====================== //

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return backing.loadClasses();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		return backing.loadFiles();
	}

	@Override
	public List<String> getSkippedPrefixes() {
		return backing.getSkippedPrefixes();
	}

	@Override
	public void setSkippedPrefixes(List<String> skippedPrefixes) {
		backing.setSkippedPrefixes(skippedPrefixes);
	}

	@Override
	public Set<String> getDirtyClasses() {
		return backing.getDirtyClasses();
	}

	@Override
	public Set<String> getDirtyFiles() {
		return backing.getDirtyFiles();
	}

	@Override
	public History getClassHistory(String name) {
		return backing.getClassHistory(name);
	}

	@Override
	public Map<String, History> getClassHistory() {
		return backing.getClassHistory();
	}

	@Override
	public History getFileHistory(String name) {
		return backing.getFileHistory(name);
	}

	@Override
	public Map<String, History> getFileHistory() {
		return backing.getFileHistory();
	}

	@Override
	public boolean createClassSave(String name) {
		return backing.createClassSave(name);
	}

	@Override
	public boolean createFileSave(String name) {
		return backing.createFileSave(name);
	}

	@Override
	public Map<String, SourceCode> getClassSources() {
		return backing.getClassSources();
	}

	@Override
	public SourceCode getClassSource(String name) {
		return backing.getClassSource(name);
	}

	@Override
	public boolean setClassSources(Path path) throws IOException {
		return backing.setClassSources(path);
	}

	@Override
	public Map<String, ParseResult<CompilationUnit>> analyzeSource(Workspace workspace) {
		return backing.analyzeSource(workspace);
	}

	@Override
	public Map<String, Javadocs> getClassDocs() {
		return backing.getClassDocs();
	}

	@Override
	public Javadocs getClassDocs(String name) {
		return backing.getClassDocs(name);
	}

	@Override
	public boolean setClassDocs(Path path) throws IOException {
		return backing.setClassDocs(path);
	}

	@Override
	public void invalidate() {
		backing.invalidate();
	}

	@Override
	public ResourceLocation getShortName() {
		return backing.getShortName();
	}

	@Override
	public ResourceLocation getName() {
		return backing.getName();
	}
}

```

`src/main/java/me/coley/recaf/workspace/DirectoryResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Importable directory resource.
 *
 * @author Matt
 */
public class DirectoryResource extends ArchiveResource {
	private static final String SEPARATOR = System.getProperty("file.separator");


	/**
	 * Constructs a directory resource.
	 *
	 * @param path
	 * 		Path reference to a directory.
	 *
	 * @throws IOException
	 * 		When the path does not exist.
	 */
	public DirectoryResource(Path path) throws IOException {
		super(ResourceKind.DIRECTORY, path);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		// iterate jar entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();
		Path root = getPath();
		List<Path> classFilePaths = Files.walk(root)
				.filter(Files::isRegularFile)
				.collect(Collectors.toList());
		String absolutePath = IOUtil.toString(root);
		for (Path path : classFilePaths) {
			File file = path.toFile();
			String relative = file.getAbsolutePath().substring(absolutePath.length() + 1)
					.replace(SEPARATOR, "/");
			if (shouldSkip(relative))
				continue;
			if(!loader.isFileValidClassName(relative))
				continue;
			out.reset();
			byte[] in = IOUtil.toByteArray(new FileInputStream(file), out, buffer);
			loader.onClass(relative, in);
		}
		loader.finishClasses();
		return loader.getClasses();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		// iterate jar entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();
		Path root = getPath();
		List<Path> classFilePaths = Files.walk(root)
				.filter(Files::isRegularFile)
				.collect(Collectors.toList());
		String absolutePath = IOUtil.toString(root);
		for (Path path : classFilePaths) {
			File file = path.toFile();
			String relative = file.getAbsolutePath().substring(absolutePath.length() + 1)
					.replace(SEPARATOR, "/");
			if (shouldSkip(relative))
				continue;
			if(loader.isFileValidClassName(relative))
				continue;
			out.reset();
			byte[] in = IOUtil.toByteArray(new FileInputStream(file), out, buffer);
			loader.onFile(relative, in);
		}
		loader.finishFiles();
		return loader.getFiles();
	}

	@Override
	protected void verify() throws IOException {
		if(!Files.isDirectory(getPath()))
			throw new IOException("The directory \"" + getPath().getFileName() + "\" does not exist!");
	}
}

```

`src/main/java/me/coley/recaf/workspace/EmptyResource.java`:

```java
package me.coley.recaf.workspace;

import java.io.IOException;
import java.util.Collections;
import java.util.Map;

/**
 * Empty resource, useful for attaching additional sources/javadocs.
 *
 * @author Matt
 */
public class EmptyResource extends JavaResource {
	private static final ResourceLocation LOCATION = LiteralResourceLocation.ofKind(ResourceKind.EMPTY, "Empty");

	/**
	 * Constructs an empty resource.
	 */
	public EmptyResource() {
		super(ResourceKind.EMPTY);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	public ResourceLocation getShortName() {
		return LOCATION;
	}

	@Override
	public ResourceLocation getName() {
		return LOCATION;
	}
}

```

`src/main/java/me/coley/recaf/workspace/EntryLoader.java`:

```java
package me.coley.recaf.workspace;

import me.coley.cafedude.InvalidClassException;
import me.coley.cafedude.io.ClassFileReader;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.LoadInterceptorPlugin;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.IllegalBytecodePatcherUtil;
import me.coley.recaf.util.Log;
import org.objectweb.asm.ClassReader;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipEntry;

import static me.coley.recaf.util.Log.*;

/**
 * Standard archive content loader.
 *
 * @author Matt
 */
public class EntryLoader {
	private final Map<String, byte[]> classes = new HashMap<>();
	private final Map<String, byte[]> files = new HashMap<>();
	private final Map<String, byte[]> invalidClasses = new HashMap<>();
	private final Map<String, byte[]> invalidJunkClasses = new HashMap<>();

	/**
	 * @return New archive entry loader instance.
	 */
	public static EntryLoader create() {
		EntryLoader loader = PluginsManager.getInstance().getEntryLoader();
		// Fallback to default
		if (loader == null)
			loader = new EntryLoader();
		return loader;
	}

	/**
	 * Load a class from the input.
	 * <br>
	 * Checks if the class is invalid and adds it to a temporary store to be parsed later
	 * if it contains illegal bytecode patterns.
	 *
	 * @param entryName
	 * 		Class's archive entry name.
	 * @param value
	 * 		Class's bytecode.
	 *
	 * @return Addition was a success.
	 */
	public boolean onClass(String entryName, byte[] value) {
		// Check if class is valid. If it is not it will be stored for later.
		if (!ClassUtil.isValidClass(value)) {
			try {
				// If the data can be read, overwrite whatever entry we have previously seen
				new ClassFileReader().read(value);
				invalidClasses.put(entryName, value);
				if (invalidJunkClasses.remove(entryName) != null) {
					debug("Replacing class '{}' previously associated with non-class junk with" +
							" newly discovered class data", entryName);
				}
				return false;
			} catch (InvalidClassException e) {
				// Skip if we think this is junk data that is masking an invalid class we already recovered
				if (invalidClasses.containsKey(entryName)) {
					debug("Skipping masking junk data for class '{}'", entryName);
					return false;
				}
				// Doesnt look like the CAFEDOOD backup parser can read it either.
				if (invalidJunkClasses.containsKey(entryName)) {
					// Already seen it. Probably dupe junk data.
					debug("Skipping duplicate invalid class '{}'", entryName);
					return false;
				} else {
					debug("Invalid class detected, not parsable by backup reader \"{}\"", entryName);
				}
				invalidJunkClasses.put(entryName, value);
				return false;
			}
		}
		// Check if we've already seen this class
		String clsName = new ClassReader(value).getClassName();
		if (classes.containsKey(clsName)) {
			debug("Skipping duplicate class '{}'", clsName);
			return false;
		}
		// Load the class
		handleAddClass(entryName, value);
		return true;
	}

	/**
	 * Add the class to the loaded classes map.
	 *
	 * @param entryName
	 * 		Class's archive entry name.
	 * @param value
	 * 		Class's bytecode.
	 *
	 * @return Addition was a success.
	 */
	private boolean handleAddClass(String entryName, byte[] value) {
		String name = new ClassReader(value).getClassName();
		for(LoadInterceptorPlugin interceptor :
				PluginsManager.getInstance().ofType(LoadInterceptorPlugin.class)) {
			// Intercept class
			try {
				value = interceptor.interceptClass(name, value);
			} catch(Throwable t) {
				Log.error(t, "Plugin '{}' threw exception when reading the class '{}'", interceptor.getName(), name);
			}
			// Make sure the class interception doesn't break the class
			if (!ClassUtil.isValidClass(value)) {
				warn("Invalid class '{}' due to modifications by plugin '{}'\nAdding as a file instead.", entryName);
				onFile(entryName, value);
				return false;
			}
			// Update name
			name = new ClassReader(value).getClassName();
		}
		classes.put(name, value);
		return true;
	}

	/**
	 * Load a file.
	 *
	 * @param entryName
	 * 		File's archive entry name.
	 * @param value
	 * 		File's raw value.
	 *
	 * @return Addition was a success.
	 */
	public boolean onFile(String entryName, byte[] value) {
		for (LoadInterceptorPlugin interceptor : PluginsManager.getInstance().ofType(LoadInterceptorPlugin.class)) {
			value = interceptor.interceptFile(entryName, value);
		}
		files.put(entryName, value);
		return true;
	}

	/**
	 * @param entry
	 * 		Zip entry in the archive.
	 *
	 * @return {@code true} if the entry indicates the content should be a class file.
	 */
	public boolean isValidClassEntry(ZipEntry entry) {
		return isFileValidClassName(entry.getName());
	}

	/**
	 * @param name
	 * 		File name.
	 *
	 * @return {@code true} if the entry indicates the content should be a class file.
	 */
	public boolean isFileValidClassName(String name) {
		// Must end in .class or .class/
		return name.endsWith(".class") || name.endsWith(".class/");
	}

	/**
	 * @param input
	 * 		An {@link InputStream} to test.
	 *
	 * @return {@code true} if the entry indicates the content should be a class file.
	 *
	 * @throws IOException
	 * 		If any I/O occurs.
	 */
	public boolean isValidClassFile(InputStream input) throws IOException {
		// Try to read class file header
		byte[] tmp = new byte[4];
		if (input.read(tmp) != 4) {
			return false;
		}
		return IOUtil.isClassHeader(tmp);
	}

	/**
	 * @param entry
	 * 		Zip entry in the archive.
	 *
	 * @return If the entry indicates the content is a valid file.
	 */
	public boolean isValidFileEntry(ZipEntry entry) {
		// If the entry is a directory, then skip it....
		// Unless its a "fake" directory because archive manipulation by obfuscation
		if (entry.isDirectory() && !isValidClassEntry(entry))
			return false;
		String name = entry.getName();
		// name / directory escaping
		if (name.contains("../"))
			return false;
		// empty directory names is a no
		return !name.contains("//");
	}

	/**
	 * Called when all classes in the jar have been read.
	 */
	public void finishClasses() {
		Collection<LoadInterceptorPlugin> interceptors =
				PluginsManager.getInstance().ofType(LoadInterceptorPlugin.class);
		for (Map.Entry<String, byte[]> e : invalidClasses.entrySet()) {
			String entryName = e.getKey();
			byte[] value = e.getValue();
			try {
				// Attempt to patch invalid classes.
				// If the internal measure fails, allow plugins to patch invalid classes
				if (!ClassUtil.isValidClass(value)) {
					debug("Attempting to patch invalid class '{}'", entryName);
					byte[] patched = IllegalBytecodePatcherUtil.fix(classes, invalidClasses, value);
					if (ClassUtil.isValidClass(patched)) {
						value = patched;
					} else if (!interceptors.isEmpty()) {
						for (LoadInterceptorPlugin interceptor : interceptors) {
							try {
								value = interceptor.interceptInvalidClass(entryName, value);
							} catch (Throwable t) {
								Log.error(t, "Plugin '{}' threw an exception when reading the invalid class '{}'",
										interceptor.getName(), entryName);
							}
						}
					}
				}
				// Check if class is valid
				if (ClassUtil.isValidClass(value)) {
					debug("Illegal class patching success!");
					handleAddClass(entryName, value);
				} else {
					warn("Invalid class \"{}\" - Cannot be parsed with ASM reader\n" +
							"Adding as a file instead.", entryName);
					onFile(entryName, value);
				}
			} catch (Throwable t) {
				error(t, "Failed to patch invalid class due to patcher crash \"{}\"", entryName);
			}
		}
		for (Map.Entry<String, byte[]> e : invalidJunkClasses.entrySet()) {
			if (classes.containsKey(e.getKey()) || files.containsKey(e.getKey()))
				continue;
			onFile(e.getKey(), e.getValue());
		}
	}

	/**
	 * Called when all files in the archive have been read.
	 */
	public void finishFiles() {}

	/**
	 * @return Loaded classes.
	 */
	public Map<String, byte[]> getClasses() {
		return classes;
	}

	/**
	 * @return Loaded files.
	 */
	public Map<String, byte[]> getFiles() {
		return files;
	}

	/**
	 * @return Set of classes that failed to load.
	 */
	public Set<String> getInvalidClasses() {
		return invalidClasses.keySet();
	}
}

```

`src/main/java/me/coley/recaf/workspace/FileSystemResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Importable resource from the file system.
 *
 * @author Matt
 */
public abstract class FileSystemResource extends JavaResource {
	private final Path path;

	/**
	 * Constructs a file system resource.
	 *
	 * @param kind
	 * 		The kind of resource implementation.
	 * @param path
	 * 		The reference to the file resource.
	 *
	 * @throws IOException
	 * 		When the path does not exist.
	 */
	public FileSystemResource(ResourceKind kind, Path path) throws IOException {
		super(kind);
		this.path = path;
		verify();
	}

	/**
	 * Create a FileSystemResource from the given file.
	 *
	 * @param path
	 * 		File to load as a resource.
	 *
	 * @return File resource.
	 *
	 * @throws IOException
	 * 		When the file cannot be read.
	 * @throws UnsupportedOperationException
	 * 		When the file extension is not supported.
	 */
	public static FileSystemResource of(Path path) throws IOException {
		if (Files.isDirectory(path))
			return new DirectoryResource(path);
		String ext = IOUtil.getExtension(path);
		switch(ext) {
			case "class":
				return new ClassResource(path);
			case "jar":
				return new JarResource(path);
			case "war":
				return new WarResource(path);
			default:
				throw new UnsupportedOperationException("File type '" + ext + "' is not " +
						"allowed for libraries");
		}
	}

	/**
	 * @return The path imported from.
	 */
	public Path getPath() {
		return path;
	}

	/**
	 * Verify the file exists.
	 *
	 * @throws IOException
	 * 		When the file does not exist.
	 */
	protected void verify() throws IOException {
		if (!Files.exists(path))
			throw new IOException("The file \"" + path + "\" does not exist!");
	}

	@Override
	public ResourceLocation getShortName() {
		return new FileSystemResourceLocation(getKind(), path.getFileName());
	}

	@Override
	public ResourceLocation getName() {
		return new FileSystemResourceLocation(getKind(), path);
	}

	@Override
	public String toString() {
		return path.getFileName().toString();
	}
}

```

`src/main/java/me/coley/recaf/workspace/FileSystemResourceLocation.java`:

```java
package me.coley.recaf.workspace;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Objects;

/**
 * Represents file system resource location.
 *
 * @author xxDark
 */
public final class FileSystemResourceLocation extends ResourceLocation {
    private final Path path;

    /**
     * Create the file system location.
     *
     * @param kind kind of the resource.
     * @param path file system path.
     */
    public FileSystemResourceLocation(ResourceKind kind, Path path) {
        super(kind);
        this.path = path;
    }

    @Override
    public ResourceLocation normalize() {
        return new FileSystemResourceLocation(kind(), path.normalize());
    }

    @Override
    public ResourceLocation concat(ResourceLocation other) {
        // We can only concat fs location or literal
        Path path = null;
        if (other instanceof FileSystemResourceLocation) {
            path = ((FileSystemResourceLocation) other).path;
            if (!this.path.getFileSystem().equals(path.getFileSystem())) {
                throw new IllegalStateException("File systems mismatch!");
            }
        } else if (other instanceof LiteralResourceLocation) {
            path = Paths.get(((LiteralResourceLocation) other).getLiteral());
        }
        if (path == null) {
            throw new IllegalArgumentException("Can only concat with file system paths or literals!");
        }
        return new FileSystemResourceLocation(kind(), this.path.resolve(path));
    }

    @Override
    public ResourceLocation toAbsolute() {
        return new FileSystemResourceLocation(kind(), path.toAbsolutePath());
    }

    @Override
    public boolean isAbsolute() {
        return path.isAbsolute();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FileSystemResourceLocation that = (FileSystemResourceLocation) o;
        return Objects.equals(path, that.path);
    }

    @Override
    public int hashCode() {
        return path.hashCode();
    }

    @Override
    public String toString() {
        return path.toString();
    }
}

```

`src/main/java/me/coley/recaf/workspace/History.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.struct.ListeningMap;

import java.time.Instant;
import java.util.Stack;

import static me.coley.recaf.util.Log.*;

/**
 * History manager for files.
 *
 * @author Matt
 */
public class History {
	// TODO: For large inputs it would make sense to offload this to the file system.
	//  - But only for large inputs. In-memory is much faster and should be the default.
	/**
	 * Stack of changed content.
	 */
	private final Stack<byte[]> stack = new Stack<>();
	/**
	 * Stack of when the content was changed.
	 */
	private final Stack<Instant> times = new Stack<>();
	/**
	 * File map to update when the history is rolled back.
	 */
	private final ListeningMap<String, byte[]> map;
	/**
	 * File being tracked.
	 */
	public final String name;
	/**
	 * Flag for if bottom is reached.
	 */
	private boolean atInitial = true;

	/**
	 * Constructs a history for an item of the given name in the given map.
	 *
	 * @param map
	 * 		Map containing the item.
	 * @param name
	 * 		Item's key.
	 */
	public History(ListeningMap<String, byte[]> map, String name) {
		this.map = map;
		this.name = name;
	}

	/**
	 * @return Size of history for the current file.
	 */
	public int size() {
		return stack.size();
	}

	/**
	 * @return {@code true} if the top of the stack is the initial state of the item.
	 */
	public boolean isAtInitial() {
		return atInitial;
	}

	/**
	 * Wipe all items from the history.
	 */
	public void clear() {
		stack.clear();
		times.clear();
	}

	/**
	 * Fetch the creation times of all save states.
	 *
	 * @return Array of timestamps of each tracked change.
	 */
	public Instant[] getFileTimes() {
		return times.toArray(new Instant[0]);
	}

	/**
	 * @return Instant of most recent change.
	 */
	public Instant getMostRecentUpdate() {
		return times.peek();
	}

	/**
	 * Gets most recent change, deleting it in the process.
	 *
	 * @return Most recent version of the tracked file.
	 */
	public byte[] pop() {
		Instant time = times.pop();
		byte[] content = stack.pop();
		if (content != null) {
			map.put(name, content);
			// If the size is now 0, we just pop'd the initial state.
			// Since we ALWAYS want to keep the initial state we will push it back.
			if (size() == 0) {
				times.push(time);
				stack.push(content);
				atInitial = true;
				info("Reverted '{}' - initial state", name);
			} else {
				info("Reverted '{}' - {} total", name, stack.size());
			}
		} else {
			throw new IllegalStateException("No history to revert to!");
		}
		return content;
	}

	/**
	 * @return Most recent version of the tracked file.
	 */
	public byte[] peek() {
		return stack.peek();
	}

	/**
	 * Updates current value, pushing the latest value into the history
	 * stack.
	 *
	 * @param modified
	 * 		Changed value.
	 */
	public void push(byte[] modified) {
		stack.push(modified);
		times.push(Instant.now());
		// Don't log the initial push
		if(stack.size() > 1) {
			info("Saved '{}' - {} total", name, stack.size());
			atInitial = false;
		}
	}
}
```

`src/main/java/me/coley/recaf/workspace/InstrumentationResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.Recaf;
import me.coley.recaf.control.Controller;
import me.coley.recaf.plugin.PluginsManager;
import me.coley.recaf.plugin.api.ExitPlugin;
import me.coley.recaf.plugin.api.InternalPlugin;
import me.coley.recaf.plugin.api.StartupPlugin;
import me.coley.recaf.util.ClasspathUtil;
import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.Log;
import org.objectweb.asm.Type;
import org.plugface.core.annotations.Plugin;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.instrument.ClassDefinition;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.security.ProtectionDomain;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Importable instrumentation resource.
 *
 * @author Matt
 */
public class InstrumentationResource extends JavaResource {
	private static final ResourceLocation LOCATION = LiteralResourceLocation.ofKind(
			ResourceKind.INSTRUMENTATION,
			"Instrumentation");
	public static Instrumentation instrumentation;
	private static InstrumentationResource instance;

	/**
	 * Constructs an instrumentation resource.
	 *
	 * @throws IllegalStateException
	 * 		When the {@link #instrumentation} instance has not been set.
	 * @throws IOException
	 * 		When querying for runtime classes fails.
	 */
	private InstrumentationResource() throws IllegalStateException, IOException {
		super(ResourceKind.INSTRUMENTATION);
		// Instrumentation is ALWAYS primary
		setPrimary(true);
		if(instrumentation == null)
			throw new IllegalStateException("Instrumentation has not been initialized!");
		if (instance != null)
			throw new IllegalStateException("There already is an instrumentation resource!");
		instance = this;
		setSkippedPrefixes(Arrays.asList("java/", "javax/", "javafx/", "sun/",
				"com/sun/", "com/oracle/", "jdk/", "me/coley/"));
	}

	/**
	 * Setup an instrumentation based workspace.
	 *
	 * @param controller Controller to act on.
	 *
	 * @return Created workspace.
	 */
	public static Workspace setup(Controller controller) {
		try {
			// Add transformer to add new classes to the map
			ClassFileTransformer transformer = new InstrumentationResourceTransformer();
			instrumentation.addTransformer(transformer);
			// Setup hook for workspace.
			PluginsManager.getInstance()
					.addPlugin(new InstrumentationPlugin(instance, transformer));
			Log.info("Loaded instrumentation workspace");
		} catch(Exception ex) {
			Log.error(ex, "Failed to initialize instrumentation");
		}
		return controller.getWorkspace();
	}

	/**
	 * Saves changed by retransforming classes.
	 *
	 * @throws ClassNotFoundException
	 * 		When the modified class couldn't be found.
	 * @throws UnmodifiableClassException
	 * 		When the modified class is not allowed to be modified.
	 * @throws ClassFormatError
	 * 		When the modified class is not valid.
	 */
	public void save() throws ClassNotFoundException, UnmodifiableClassException, ClassFormatError {
		// Classes to update
		Set<String> dirty = new HashSet<>(getDirtyClasses());
		if(dirty.isEmpty()) {
			Log.info("There are no classes to redefine.", dirty.size());
			return;
		}
		Log.info("Preparing to redefine {} classes", dirty.size());
		ClassDefinition[] definitions = new ClassDefinition[dirty.size()];
		int i = 0;
		for (String name : dirty) {
			String clsName = name.replace('/', '.');
			Class<?> cls = Class.forName(clsName, false, ClasspathUtil.scl);
			byte[] value = getClasses().get(name);
			if (value == null)
				throw new IllegalStateException("Failed to fetch code for class: " + name);
			definitions[i] = new ClassDefinition(cls, value);
			i++;
		}
		// Apply new definitions
		instrumentation.redefineClasses(definitions);
		// We don't want to continually re-apply changes that don't need to be updated
		getDirtyClasses().clear();
		Log.info("Successfully redefined {} classes", definitions.length);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> loadFiles() {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> copyMap(Map<String, byte[]> map) {
		return new ConcurrentHashMap<>(map);
	}

	@Override
	public String toString() {
		return "Instrumentation";
	}

	private void loadRuntimeClasses(Map<String, byte[]> map) throws IOException {
		// iterate over loaded classes
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		Class<?>[] klass = {null};
		int failedTransformations = 0;
		// Let's skipp all Recaf's classes.
		for(Class<?> c : instrumentation.getAllLoadedClasses()) {
			if (ClasspathUtil.isRecafClass(c)) {
				continue;
			}
			String name = Type.getInternalName(c);
			// skip specified prefixes
			if(shouldSkip(name))
				continue;
			// Skip array types
			if (name.contains("["))
				continue;
			try {
				klass[0] = c;
				instrumentation.retransformClasses(klass);
			} catch (UnmodifiableClassException ex) {
				if (++failedTransformations < 5) {
					Log.error("Could not get live version of a class {}:", name, ex);
				}
				String path = name.concat(".class");
				ClassLoader loader = c.getClassLoader();
				try(InputStream in = (loader != null) ?
						loader.getResourceAsStream(path) :
						ClassLoader.getSystemResourceAsStream(path)) {
					if(in != null) {
						out.reset();
						getClasses().put(name, IOUtil.toByteArray(in, out, buffer));
						getDirtyClasses().remove(name);
					}
				}
			}
		}
		if (failedTransformations != 0) {
			Log.error("Could not get live version for {} classes", failedTransformations);
		}
	}

	/**
	 * @return Instrumentation resource instance.
	 *
	 * @throws IOException
	 * 		When the resource cannot be instantiated.
	 */
	public static InstrumentationResource getInstance() throws IOException {
		if (instance == null)
			instance = new InstrumentationResource();
		return instance;
	}

	/**
	 * @return {@code true} if Recaf is running as a Java agent.
	 */
	public static boolean isActive() {
		return instrumentation != null;
	}

	/**
	 * Transformer to load classes from instrumentation.
	 */
	private static class InstrumentationResourceTransformer implements ClassFileTransformer {
		private boolean firstTransformerLoad = true;

		public byte[] transform(Module module, ClassLoader loader, String className,
								Class<?> cls, ProtectionDomain domain, byte[] buffer) {
			return transform(loader, className, cls, domain, buffer);
		}

		@Override
		public byte[] transform(ClassLoader loader, String className,
								Class<?> cls, ProtectionDomain domain, byte[] buffer) {
			// This super odd way of getting the resource IS INTENTIONAL.
			// If you choose to optimize this in the future verify it behaves the same.
			InstrumentationResource res;
			try {
				res = getInstance();
				synchronized (this) {
					if (firstTransformerLoad) {
						firstTransformerLoad = false;
						// There is a time gap between when we first called 'loadClasses' and this gets called.
						// We need to fetch those classes here so we have everything available.
						res.loadRuntimeClasses(getInstance().getClasses());
					}
				}
			} catch(IOException ex) { return buffer; }
			// Checks to skip class
			if (ClasspathUtil.isRecafLoader(loader)) {
				return buffer;
			}
			String internal = className.replace('.', '/');
			if(res.shouldSkip(internal))
				return buffer;
			// Add to classes map
			res.getClasses().put(internal, buffer);
			// Make sure the class is NOT marked as dirty after initially registering it
			res.getDirtyClasses().remove(internal);
			return buffer;
		}
	}

	@Override
	public ResourceLocation getShortName() {
		return LOCATION;
	}

	@Override
	public ResourceLocation getName() {
		return LOCATION;
	}

	@Plugin(name = "Instrumentation")
	private static final class InstrumentationPlugin implements InternalPlugin,
			StartupPlugin, ExitPlugin {
		private final InstrumentationResource resource;
		private final ClassFileTransformer transformer;

		/**
		 * @param resource
		 * 		Instrumentation resource.
		 * @param transformer
		 * 		Instrumentation transformer.
		 */
		InstrumentationPlugin(InstrumentationResource resource,
							  ClassFileTransformer transformer) {
			this.resource = resource;
			this.transformer = transformer;
		}

		@Override
		public void onStart(Controller controller) {
			controller.setWorkspace(new Workspace(resource));
		}

		@Override
		public void onExit(Controller controller) {
			instrumentation.removeTransformer(transformer);
		}

		@Override
		public String getVersion() {
			return Recaf.VERSION;
		}

		@Override
		public String getDescription() {
			return "Instrumentation hook";
		}
	}
}

```

`src/main/java/me/coley/recaf/workspace/JarResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;

import java.io.*;
import java.nio.file.Path;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * Importable jar resource.
 *
 * @author Matt
 */
public class JarResource extends ArchiveResource {
	/**
	 * Constructs a jar resource.
	 *
	 * @param path
	 * 		Path reference to a jar file.
	 *
	 * @throws IOException
	 * 		When the path does not exist.
	 */
	public JarResource(Path path) throws IOException {
		super(ResourceKind.JAR, path);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		// iterate jar entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();

		try (ZipInputStream zis = new ZipInputStream(new FileInputStream(getPath().toFile()))) {
			ZipEntry entry;

			while ((entry = zis.getNextEntry()) != null) {
				// verify entries are classes and valid files
				// - skip intentional garbage / zip file abnormalities
				if (shouldSkip(entry.getName()))
					continue;

				out.reset();
				byte[] in;
				if (!loader.isValidClassEntry(entry)) {
					// The class file might not end with .class or .class/
					// so we also check it's header.
					in = IOUtil.toByteArray(zis, out, buffer, 4);
					if (!loader.isValidClassFile(new ByteArrayInputStream(in))) {
						continue;
					}
				}

				in = IOUtil.toByteArray(zis, out, buffer);

				// There is no possible way a "class" under 30 bytes is valid
				if (in.length < 30)
					continue;

				loader.onClass(entry.getName(), in);
			}
		} catch (ZipException e) {
			if (e.getMessage().contains("invalid entry CRC")) {
				// "ZipFile"/"JarFile" reads the entire ZIP file structure before letting us do any entry parsing.
				// This may not always be ideal, but this way has one major bonus. It totally ignores CRC validity.
				// It also ignores a few other zip entry values.
				// Since somebody can intentionally write bogus data there to crash "ZipInputStream" this way works.
				try (ZipFile zf = new ZipFile(getPath().toString())) {
					Enumeration<? extends ZipEntry> entries = zf.entries();
					while (entries.hasMoreElements()) {
						ZipEntry entry = entries.nextElement();

						if (shouldSkip(entry.getName()))
							continue;

						out.reset();
						byte[] in;

						if (!loader.isValidClassEntry(entry)) {
							// The class file might not end with .class or .class/
							// so we also check it's header.
							out.reset();
							try (InputStream zis = zf.getInputStream(entry)) {
								in = IOUtil.toByteArray(zis, out, buffer, 4);
							}
							if (!loader.isValidClassFile(new ByteArrayInputStream(in))) {
								continue;
							}
						}

						out.reset();
						try (InputStream zis = zf.getInputStream(entry)) {
							in = IOUtil.toByteArray(zis, out, buffer);
						}

						loader.onClass(entry.getName(), in);
					}
				}
			}
		}
		loader.finishClasses();
		return loader.getClasses();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		// iterate jar entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();
		try (ZipFile zipFile = new ZipFile(getPath().toFile())) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while(entries.hasMoreElements()) {
				// verify entries are not classes and are valid files
				// - skip intentional garbage / zip file abnormalities
				ZipEntry entry = entries.nextElement();
				if (shouldSkip(entry.getName()))
					continue;
				if(loader.isValidClassEntry(entry))
					continue;
				if(!loader.isValidFileEntry(entry))
					continue;
				out.reset();
				InputStream stream = zipFile.getInputStream(entry);
				byte[] in = IOUtil.toByteArray(stream, out, buffer);
				loader.onFile(entry.getName(), in);
			}
		}
		loader.finishFiles();
		return loader.getFiles();
	}
}

```

`src/main/java/me/coley/recaf/workspace/JavaResource.java`:

```java
package me.coley.recaf.workspace;

import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import me.coley.recaf.parse.javadoc.DocumentationParseException;
import me.coley.recaf.parse.javadoc.Javadocs;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.parse.source.SourceCodeException;
import me.coley.recaf.util.InternalElement;
import me.coley.recaf.util.struct.InternalBiConsumer;
import me.coley.recaf.util.struct.InternalConsumer;
import me.coley.recaf.util.struct.ListeningMap;
import org.apache.commons.io.IOUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.*;
import java.util.zip.*;

import static me.coley.recaf.util.Log.*;

/**
 * An importable unit.
 *
 * @author Matt
 */
public abstract class JavaResource {
	private final ResourceKind kind;
	private EntryLoader entryLoader = EntryLoader.create();
	private List<String> skippedPrefixes = Collections.emptyList();
	private final ListeningMap<String, byte[]> cachedClasses = new ListeningMap<>();
	private final ListeningMap<String, byte[]> cachedFiles = new ListeningMap<>();
	private final Map<String, History> classHistory = new HashMap<>();
	private final Map<String, History> fileHistory = new HashMap<>();
	private final Set<String> dirtyClasses = new HashSet<>();
	private final Set<String> dirtyFiles = new HashSet<>();
	private final Map<String, SourceCode> classSource = new HashMap<>();
	private final Map<String, Javadocs> classDocs = new HashMap<>();
	private Path classSourceFile;
	private Path classDocsFile;
	private boolean isPrimary;

	/**
	 * Constructs a java resource.
	 *
	 * @param kind
	 * 		The kind of resource implementation.
	 */
	public JavaResource(ResourceKind kind) {
		this.kind = kind;
	}

	/**
	 * @return Type of referenced resource.
	 */
	public ResourceKind getKind() {
		return kind;
	}

	/**
	 * @return Prefixes to skip.
	 */
	public List<String> getSkippedPrefixes() {
		return skippedPrefixes;
	}

	/**
	 * @param name
	 * 		File name.
	 *
	 * @return {@code true} if the name if prefixed by a blacklisted item.
	 */
	protected boolean shouldSkip(String name) {
		for(String prefix : getSkippedPrefixes())
			if(name.startsWith(prefix))
				return true;
		return false;
	}

	/**
	 * @param skippedPrefixes
	 * 		Prefixes to skip.
	 */
	public void setSkippedPrefixes(List<String> skippedPrefixes) {
		this.skippedPrefixes = skippedPrefixes;
	}

	/**
	 * @return Set of classes that have been modified since initially loading.
	 */
	public Set<String> getDirtyClasses() {
		return dirtyClasses;
	}

	/**
	 * @return Set of files that have been modified since initially loading.
	 */
	public Set<String> getDirtyFiles() {
		return dirtyFiles;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return History for class. {@code null} if no save-states for the class exist.
	 */
	public History getClassHistory(String name) {
		return classHistory.get(name);
	}

	/**
	 * @return Map of all class histories.
	 */
	public Map<String, History> getClassHistory() {
		return classHistory;
	}

	/**
	 * @param name
	 * 		File name.
	 *
	 * @return History for file. {@code null} if no save-states for the file exist.
	 */
	public History getFileHistory(String name) {
		return fileHistory.get(name);
	}

	/**
	 * @return Map of all file histories.
	 */
	public Map<String, History> getFileHistory() {
		return fileHistory;
	}

	/**
	 * @return Map of class names to sources.
	 */
	public Map<String, SourceCode> getClassSources() {
		return classSource;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Source code wrapper for class.
	 */
	public SourceCode getClassSource(String name) {
		return classSource.get(name);
	}

	/**
	 * @return Map of class names to javadocs.
	 */
	public Map<String, Javadocs> getClassDocs() {
		return classDocs;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Javadocs wrapper for class.
	 */
	public Javadocs getClassDocs(String name) {
		return classDocs.get(name);
	}

	/**
	 * Create a save-state for the class.
	 *
	 * @param name
	 * 		Class name.
	 *
	 * @return {@code true} if the save-state was created successfully.
	 */
	public boolean createClassSave(String name) {
		if (isPrimary()) {
			byte[] value = cachedClasses.get(name);
			if (value == null)
				return false;
			History history = classHistory.computeIfAbsent(name, key -> new History(cachedClasses, key));
			history.push(value);
		}
		return true;
	}

	private void addClassSave(String name, byte[] value) {
		if (isPrimary()) {
			History history = classHistory.computeIfAbsent(name, key -> new History(cachedClasses, key));
			history.push(value);
		}
	}

	/**
	 * Create a save-state for the file.
	 *
	 * @param name
	 * 		File name.
	 *
	 * @return {@code true} if the save-state was created successfully.
	 */
	public boolean createFileSave(String name) {
		if (isPrimary()) {
			byte[] value = cachedFiles.get(name);
			if (value == null)
				return false;
			History history = fileHistory.computeIfAbsent(name, key -> new History(cachedFiles, key));
			history.push(value);
		}
		return true;
	}

	private void addFileSave(String name, byte[] value) {
		if (isPrimary()) {
			History history = fileHistory.computeIfAbsent(name, key -> new History(cachedFiles, key));
			history.push(value);
		}
	}

	/**
	 * @return Map of class names to their bytecode.
	 */
	public ListeningMap<String, byte[]> getClasses() {
		synchronized(cachedClasses) {
			if (!cachedClasses.isBacked()) {
				try {
					cachedClasses.setBacking(copyMap(loadClasses()));
					// If this resource is not the primary resource, we are done
					if (!isPrimary())
						return cachedClasses;
					// Register listeners
					cachedClasses.getPutListeners()
							.add(InternalBiConsumer.internal((name, code) -> dirtyClasses.add(name)));
					cachedClasses.getRemoveListeners().add(InternalConsumer.internal(dirtyClasses::remove));
					// Create initial save state
					for (Map.Entry<String, byte[]> e : cachedClasses.entrySet()) {
						addClassSave(e.getKey(), e.getValue());
					}
					// Add listener to create initial save states for newly made classes
					cachedClasses.getPutListeners().add(InternalBiConsumer.internal((name, code) -> {
						if (!cachedClasses.containsKey(name)) {
							addClassSave(name, code);
						}
					}));
				} catch(IOException ex) {
					error(ex, "Failed to load classes from resource \"{}\"", toString());
					cachedClasses.setBacking(Collections.emptyMap());
				}
			}
		}
		return cachedClasses;
	}

	/**
	 * @return Map of file names to their raw data.
	 */
	public ListeningMap<String, byte[]> getFiles() {
		synchronized(cachedFiles) {
			try {
				if (!cachedFiles.isBacked()) {
					cachedFiles.setBacking(copyMap(loadFiles()));
					// If this resource is not the primary resource, we are done
					if (!isPrimary())
						return cachedFiles;
					// Register listeners
					cachedFiles.getPutListeners()
							.add(InternalBiConsumer.internal((name, code) -> dirtyFiles.add(name)));
					cachedFiles.getRemoveListeners().add(InternalConsumer.internal(dirtyFiles::remove));
					// Create initial save state
					for (Map.Entry<String, byte[]> e : cachedFiles.entrySet()) {
						addFileSave(e.getKey(), e.getValue());
					}
					// Add listener to create initial save states for newly made files
					cachedFiles.getPutListeners().add(InternalBiConsumer.internal((name, code) -> {
						if (!cachedFiles.containsKey(name)) {
							addFileSave(name, code);
						}
					}));
				}
			} catch(IOException ex) {
				error(ex, "Failed to load files from resource \"{}\"", toString());
				cachedFiles.setBacking(Collections.emptyMap());
			}
		}
		return cachedFiles;
	}

	/**
	 * Refresh this resource.
	 */
	public void invalidate() {
		cachedFiles.getPutListeners().removeIf(InternalElement.INTERNAL_PREDICATE);
		cachedFiles.getRemoveListeners().removeIf(InternalElement.INTERNAL_PREDICATE);
		cachedFiles.clear();
		cachedFiles.setBacking(null);
		cachedClasses.getPutListeners().removeIf(InternalElement.INTERNAL_PREDICATE);
		cachedClasses.getRemoveListeners().removeIf(InternalElement.INTERNAL_PREDICATE);
		cachedClasses.clear();
		cachedClasses.setBacking(null);
		classDocs.clear();
		classSource.clear();
		classHistory.clear();
	}

	/**
	 * Copy a map for loaded items.
	 *
	 * @param map
	 * 		Map to copy.
	 *
	 * @return Copied map.
	 */
	protected Map<String, byte[]> copyMap(Map<String, byte[]> map) {
		return new HashMap<>(map);
	}

	/**
	 * @return Map of class names to their bytecode.
	 *
	 * @throws IOException
	 * 		When the resource could not be fetched or parsed.
	 */
	protected abstract Map<String, byte[]> loadClasses() throws IOException;

	/**
	 * @return Map of file names to their raw data.
	 *
	 * @throws IOException
	 * 		When the resource could not be fetched or parsed.
	 */
	protected abstract Map<String, byte[]> loadFiles() throws IOException;

	/**
	 * @param path
	 * 		File containing source code.
	 *
	 * @return Map of class names to their source code wrappers.
	 *
	 * @throws IOException
	 * 		When the file could not be fetched or parsed.
	 */
	protected Map<String, SourceCode> loadSources(Path path) throws IOException {
		Map<String, SourceCode> map = new HashMap<>();
		// Will throw IO exception if the file couldn't be opened as an archive
		try (ZipFile zip = new ZipFile(path.toFile())) {
			Enumeration<? extends ZipEntry> entries = zip.entries();
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();
				String name = entry.getName();
				if (!name.endsWith(".java"))
					continue;
				String src = IOUtils.toString(zip.getInputStream(entry), StandardCharsets.UTF_8);
				try {
					SourceCode code = new SourceCode(this, src);
					code.analyze();
					map.put(code.getInternalName(), code);
				} catch(SourceCodeException ex) {
					error(ex, "Failed to parse source: {} in {}", name, path);
				}
			}
		}
		return map;
	}

	/**
	 * @param path
	 * 		File containing documentation.
	 *
	 * @return Map of class names to their documentation.
	 *
	 * @throws IOException
	 * 		When the file could not be fetched or parsed.
	 */
	protected Map<String, Javadocs> loadDocs(Path path) throws IOException {
		Map<String, Javadocs> map = new HashMap<>(512, 1F);
		// Will throw IO exception if the file couldn't be opened as an archive
		try (ZipFile zip = new ZipFile(path.toFile())) {
			Enumeration<? extends ZipEntry> entries = zip.entries();
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();
				String name = entry.getName();
				if (!name.endsWith(".html"))
					continue;
				if (name.contains("-") || name.contains("index"))
					continue;
				String src = IOUtils.toString(zip.getInputStream(entry), StandardCharsets.UTF_8);
				try {
					Javadocs docs = new Javadocs(name, src);
					docs.parse();
					map.put(docs.getInternalName(), docs);
				} catch(DocumentationParseException ex) {
					error(ex, "Failed to parse docs: {} in {}", name, path);
				}
			}
		}
		return map;
	}

	/**
	 * Loads the source code from the given file.
	 *
	 * @param path
	 * 		Path to file containing source code.
	 *
	 * @return {@code true} if sources have been discovered. {@code false} if no sources were
	 * found.
	 *
	 * @throws IOException
	 * 		When the path could not be fetched or parsed.
	 */
	public boolean setClassSources(Path path) throws  IOException {
		this.classSourceFile = path;
		this.classSource.clear();
		this.classSource.putAll(loadSources(path));
		return !classSource.isEmpty();
	}

	/**
	 * Loads the documentation from the given file.
	 *
	 * @param path
	 * 		File containing documentation.
	 *
	 * @return {@code true} if docs have been discovered. {@code false} if no docs were
	 * found.
	 *
	 * @throws IOException
	 * 		When the path could not be fetched or parsed.
	 */
	public boolean setClassDocs(Path path) throws  IOException {
		this.classDocsFile = path;
		this.classDocs.clear();
		this.classDocs.putAll(loadDocs(path));
		return !classDocs.isEmpty();
	}

	/**
	 * @return Path to file containing source code. May be {@code null}.
	 */
	public Path getClassSourcePath() {
		return classSourceFile;
	}

	/**
	 * @return Path to file containing documentation. May be {@code null}.
	 */
	public Path getClassDocsPath() {
		return classDocsFile;
	}

	/**
	 * Analyzes attached sources.
	 * This also allows workspace-wide name lookups for better type-resolving.
	 *
	 * @param workspace
	 * 		Context to analyze in. Allows application of a workspace-scoped type resolver.
	 *
	 * @return Map of class names to their parse result. If an
	 * {@link SourceCodeException} occured during analysis of a class
	 * then it's result may have {@link com.github.javaparser.ParseResult#isSuccessful()} be {@code false}.
	 */
	public Map<String, ParseResult<CompilationUnit>> analyzeSource(Workspace workspace) {
		Map<String,ParseResult<CompilationUnit>> copy = new HashMap<>();
		classSource.forEach((name, value) -> {
			try {
				copy.put(name, value.analyze(workspace));
			} catch(SourceCodeException ex) {
				error(ex, "Failed to parse source: {}", name);
				copy.put(name, ex.getResult());
			}
		});
		return copy;
	}

	/**
	 * @return Loader used to read content from archive files.
	 */
	public EntryLoader getEntryLoader() {
		return entryLoader;
	}

	/**
	 * Set the entry loader. Custom entry loaders could allow handling of some non-standard
	 * inputs <i>(obfuscation or packing for example)</i>.
	 *
	 * @param entryLoader
	 * 		Loader used to read content.
	 */
	public void setEntryLoader(EntryLoader entryLoader) {
		this.entryLoader = entryLoader;
	}

	/**
	 * @return {@code true} if the resource is a workspace's primary resource.
	 */
	public boolean isPrimary() {
		return isPrimary;
	}

	/**
	 * @param primary
	 *        {@code true} if the resource is a workspace's primary resource.
	 */
	public void setPrimary(boolean primary) {
		isPrimary = primary;
	}

	/**
	 * @return short resource name
	 */
	public abstract ResourceLocation getShortName();

	/**
	 * @return full resource name
	 */
	public abstract ResourceLocation getName();

	@Override
	public String toString() {
		return getShortName().toString();
	}
}
// TODO: Allow resources to have update-checks, ex: the referenced resource is modified externally
```

`src/main/java/me/coley/recaf/workspace/LazyClasspathResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.Log;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;

/**
 * Resource for lazyily fetching classes via runtime lookups.
 *
 * @author Matt
 */
public class LazyClasspathResource extends JavaResource {
	private static final ResourceLocation LOCATION = LiteralResourceLocation.ofKind(ResourceKind.JAR, "ClassPath");
	private static final LazyClasspathResource INSTANCE = new LazyClasspathResource();

	private LazyClasspathResource() {
		super(ResourceKind.JAR);
	}

	/**
	 * @return The classpath resource instance.
	 */
	public static LazyClasspathResource get() {
		return INSTANCE;
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return new HashMap<String, byte[]>() {
			private final Map<String, byte[]> cache = new HashMap<>();

			@Override
			public byte[] get(Object name) {
				if (name == null)
					return null;
				String key = name.toString();
				if (key.contains("."))
					key = key.replace('.', '/');
				if(cache.containsKey(key))
					return cache.get(key);
				// Can't do "computeIfAbsent" since we also want to store null values.
				byte[] value = null;
				try (InputStream in = ClassLoader.getSystemResourceAsStream(key + ".class")) {
					if (in != null) {
						value = IOUtil.toByteArray(in);
					}
				} catch (IOException ex) {
					Log.error(ex, "Failed to fetch runtime bytecode of class '{}'", key);
				}
				cache.put(key, value);
				return value;
			}

			@Override
			public boolean containsKey(Object key) {
				return get(key) != null;
			}
		};
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> copyMap(Map<String, byte[]> map) {
		return map;
	}

	@Override
	public ResourceLocation getShortName() {
		return LOCATION;
	}

	@Override
	public ResourceLocation getName() {
		return LOCATION;
	}
}

```

`src/main/java/me/coley/recaf/workspace/LiteralResourceLocation.java`:

```java
package me.coley.recaf.workspace;

import java.util.Objects;

/**
 * Represents literal resource location.
 *
 * @author xxDark
 */
public final class LiteralResourceLocation extends ResourceLocation {
    private final String literal;

    /**
     * No public constructions are allowed.
     */
    private LiteralResourceLocation(ResourceKind kind, String literal) {
        super(kind);
        this.literal = literal;
    }

    @Override
    public ResourceLocation normalize() {
        return this;
    }

    @Override
    public ResourceLocation concat(ResourceLocation other) {
        if (!(other instanceof LiteralResourceLocation)) {
            throw new IllegalArgumentException("Cannot concat with non-literal location!");
        }
        return new LiteralResourceLocation(kind(), literal + ((LiteralResourceLocation) other).literal);
    }

    @Override
    public ResourceLocation toAbsolute() {
        return this;
    }

    @Override
    public boolean isAbsolute() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LiteralResourceLocation that = (LiteralResourceLocation) o;
        return Objects.equals(literal, that.literal);
    }

    @Override
    public int hashCode() {
        return literal.hashCode();
    }

    @Override
    public String toString() {
        return literal;
    }

    /**
     * @return backing literal.
     */
    public String getLiteral() {
        return literal;
    }

    /**
     * @param kind    kind of the location.
     * @param literal location literal.
     * @return new literal resource location.
     */
    public static ResourceLocation ofKind(ResourceKind kind, String literal) {
        return new LiteralResourceLocation(kind, literal);
    }
}

```

`src/main/java/me/coley/recaf/workspace/MavenResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.MavenUtil;
import me.coley.recaf.util.NetworkUtil;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Importable maven resource.
 *
 * @author Matt
 */
public class MavenResource extends DeferringResource {
	// Artifact coordinate identifiers
	private final String groupId;
	private final String artifactId;
	private final String version;

	/**
	 * Constructs a maven artifact resource.
	 *
	 * @param groupId
	 * 		Maven artifact group.
	 * @param artifactId
	 * 		Maven artifact identifier.
	 * @param version
	 * 		Maven artifact version.
	 *
	 * @throws IOException
	 * 		When the artifact cannot be found locally or online.
	 */
	public MavenResource(String groupId, String artifactId, String version) throws IOException {
		super(ResourceKind.MAVEN);
		this.groupId = groupId;
		this.artifactId = artifactId;
		this.version = version;
		findArtifact();
	}

	/**
	 * @return Combined group, artifact, version identifiers.
	 */
	public String getCoords() {
		return getGroupId() + ":" + getArtifactId() + ":" + getVersion();
	}

	/**
	 * @return Maven artifact group.
	 */
	public String getGroupId() {
		return groupId;
	}

	/**
	 * @return Maven artifact identifier.
	 */
	public String getArtifactId() {
		return artifactId;
	}

	/**
	 * @return Maven artifact version.
	 */
	public String getVersion() {
		return version;
	}

	/**
	 * @throws IOException
	 * 		Throw when the local artifact cannot be found <i>(Does not exist locally and cannot be
	 * 		fetched)</i>.
	 */
	private void findArtifact() throws IOException {
		// Check local maven repo
		Path localArtifact = MavenUtil.getLocalArtifactUrl(groupId, artifactId, version);
		if (Files.exists(localArtifact)) {
			setBacking(new JarResource(localArtifact));
			return;
		}
		// Verify artifact is on central
		MavenUtil.verifyArtifactOnCentral(groupId, artifactId, version);
		// Copy artifact to local maven repo
		URL url = MavenUtil.getArtifactUrl(groupId, artifactId, version);
		FileUtils.copyURLToFile(url, localArtifact.toFile());
		setBacking(new JarResource(localArtifact));
		// TODO: Not here, but allow auto-resolving ALL dependencies not just the specified one
	}

	/**
	 * @return {@code true} if sources were found and loaded.
	 *
	 * @throws IOException
	 * 		When the sources could not be downloaded / found.
	 */
	public boolean fetchSources() throws IOException {
		// Check local maven repo
		Path localArtifact = MavenUtil.getLocalArtifactUrl(groupId, artifactId, version, "-sources");
		if (Files.exists(localArtifact))
			return setClassSources(localArtifact);
		try {
			// Find and verify the sources jar url
			URL sourceUrl = MavenUtil.getArtifactUrl(groupId, artifactId, version, "-sources");
			try {
				NetworkUtil.verifyUrlContent(sourceUrl);
			} catch(IllegalArgumentException ex) {
				throw new IOException(ex);
			}
			// Download
			FileUtils.copyURLToFile(sourceUrl, localArtifact.toFile());
			return setClassSources(localArtifact);
		} catch(MalformedURLException ex) {
			// This should NOT ever occur since the url generated should already be pre-verified.
			throw new IOException(ex);
		}
	}

	/**
	 * @return {@code true} if javadocs were found and loaded.
	 *
	 * @throws IOException
	 * 		When the javadocs could not be downloaded / found.
	 */
	public boolean fetchJavadoc() throws IOException {
		// Check local maven repo
		Path localArtifact = MavenUtil.getLocalArtifactUrl(groupId, artifactId, version, "-javadoc");
		if (Files.exists(localArtifact))
			return setClassDocs(localArtifact);
		try {
			// Find and verify the javadocs jar url
			URL sourceUrl = MavenUtil.getArtifactUrl(groupId, artifactId, version, "-javadoc");
			try {
				NetworkUtil.verifyUrlContent(sourceUrl);
			} catch(IllegalArgumentException ex) {
				throw new IOException(ex);
			}
			// Download
			FileUtils.copyURLToFile(sourceUrl, localArtifact.toFile());
			return setClassDocs(localArtifact);
		} catch(MalformedURLException ex) {
			// This should NOT ever occur since the url generated should already be pre-verified.
			throw new IllegalArgumentException(ex);
		}
	}

	@Override
	public String toString() {
		return getCoords();
	}
}
```

`src/main/java/me/coley/recaf/workspace/PhantomResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.Recaf;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.ReflectUtil;
import org.clyze.jphantom.ClassMembers;
import org.clyze.jphantom.JPhantom;
import org.clyze.jphantom.Options;
import org.clyze.jphantom.Phantoms;
import org.clyze.jphantom.access.ClassAccessStateMachine;
import org.clyze.jphantom.access.FieldAccessStateMachine;
import org.clyze.jphantom.access.MethodAccessStateMachine;
import org.clyze.jphantom.adapters.ClassPhantomExtractor;
import org.clyze.jphantom.hier.ClassHierarchy;
import org.clyze.jphantom.hier.IncrementalClassHierarchy;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.util.*;

/**
 * Resource for holding phantom references.
 *
 * @author Matt
 */
public class PhantomResource extends JavaResource {
	private static final ResourceLocation LOCATION = LiteralResourceLocation.ofKind(ResourceKind.JAR, "Phantoms");
	// TODO: Update phantom refs when:
	//  - using the recompilers
	//  - assembling methods (just at startup?)

	// TODO: Add a visual indicator when this passes / fails

	/**
	 * Constructs the phantom resource.
	 */
	public PhantomResource() {
		super(ResourceKind.JAR);
	}

	/**
	 * Clear the Phantom class cache internally and in file cache.
	 *
	 * @throws IOException
	 * 		When the files cannot be deleted.
	 */
	public void clear() throws IOException {
		getClasses().clear();
	}

	/**
	 * Populates the current resource with phantom classes
	 * and dumps the classes into {@code [RECAF]/classpath/generated/output.jar}
	 *
	 * @param classes
	 * 		Collection of classes to generate phantoms for.
	 *
	 * @throws IOException
	 * 		Thrown when JPhantom cannot read from the temporary file where these classes are written to.
	 */
	public void populatePhantoms(Map<String, byte[]> classes) throws IOException {
		Log.debug("Begin generating phantom classes, given {} input classes", classes.size());
		// Clear old classes
		clear();
		// Write the parameter passed classes to a temp jar
		Map<Type, ClassNode> nodes = new HashMap<>();
		classes.forEach((name, c) -> {
			ClassReader cr = new ClassReader(c);
			ClassNode node = ClassUtil.getNode(cr, 0);
			nodes.put(Type.getObjectType(node.name), node);
		});
		// Read into JPhantom
		Options.V().setSoftFail(true);
		Options.V().setJavaVersion(8);
		ClassHierarchy hierarchy = createHierarchy(classes);
		ClassMembers members = createMembers(classes, hierarchy);
		classes.forEach((name, c) -> {
			ClassReader cr = new ClassReader(c);
			if (cr.getClassName().contains("$"))
				return;
			try {
				cr.accept(new ClassPhantomExtractor(hierarchy, members), 0);
			} catch (Throwable t) {
				Log.debug("Phantom extraction failed: {}", t);
			}
		});
		// Remove duplicate constraints for faster analysis
		Set<String> existingConstraints = new HashSet<>();
		ClassAccessStateMachine.v().getConstraints().removeIf(c -> {
			boolean isDuplicate = existingConstraints.contains(c.toString());
			existingConstraints.add(c.toString());
			return isDuplicate;
		});
		// Execute and populate the current resource with generated classes
		JPhantom phantom = new JPhantom(nodes, hierarchy, members);
		phantom.run();
		phantom.getGenerated().forEach((k, v) -> getClasses().put(k.getInternalName(), decorate(v)));
		Log.debug("Phantom analysis complete, generated {} classes", classes.size());
		// Cleanup
		Phantoms.refresh();
		ClassAccessStateMachine.refresh();
		FieldAccessStateMachine.refresh();
		MethodAccessStateMachine.refresh();
	}

	/**
	 * @param classMap
	 * 		Map to pull classes from.
	 * @param hierarchy
	 * 		Hierarchy to pass to {@link ClassMembers} constructor.
	 *
	 * @return Members instance.
	 */
	public static ClassMembers createMembers(Map<String, byte[]> classMap, ClassHierarchy hierarchy) {
		Class<?>[] argTypes = new Class[]{ClassHierarchy.class};
		Object[] argVals = new Object[]{hierarchy};
		ClassMembers repo = ReflectUtil.quietNew(ClassMembers.class, argTypes, argVals);
		try {
			new ClassReader("java/lang/Object").accept(repo.new Feeder(), 0);
		} catch (IOException ex) {
			Log.error("Failed to get initial reader ClassMembers, could not lookup 'java/lang/Object'");
			throw new IllegalStateException();
		}
		for (Map.Entry<String, byte[]> e : classMap.entrySet()) {
			try {
				new ClassReader(e.getValue()).accept(repo.new Feeder(), 0);
			} catch (Throwable t) {
				Log.debug("Could not supply {} to ClassMembers feeder", e.getKey(), t);
			}
		}
		return repo;
	}

	/**
	 * @param classMap
	 * 		Map to pull classes from.
	 *
	 * @return Class hierarchy.
	 */
	public static ClassHierarchy createHierarchy(Map<String, byte[]> classMap) {
		ClassHierarchy hierarchy = new IncrementalClassHierarchy();
		for (Map.Entry<String, byte[]> e : classMap.entrySet()) {
			try {
				ClassReader reader = new ClassReader(e.getValue());
				String[] ifaceNames = reader.getInterfaces();
				Type clazz = Type.getObjectType(reader.getClassName());
				Type superclass = reader.getSuperName() == null ?
						Type.getObjectType("java/lang/Object") : Type.getObjectType(reader.getSuperName());
				Type[] ifaces = new Type[ifaceNames.length];
				for (int i = 0; i < ifaces.length; i++)
					ifaces[i] = Type.getObjectType(ifaceNames[i]);
				// Add type to hierarchy
				boolean isInterface = (reader.getAccess() & Opcodes.ACC_INTERFACE) != 0;
				if (isInterface) {
					hierarchy.addInterface(clazz, ifaces);
				} else {
					hierarchy.addClass(clazz, superclass, ifaces);
				}
			} catch (Exception ex) {
				Log.error("JPhantom: Hierarchy failure for: {}", e.getKey(), ex);
			}
		}
		return hierarchy;
	}

	/**
	 * Adds a note to the given class that it has been auto-generated.
	 *
	 * @param generated
	 * 		Input generated JPhantom class.
	 *
	 * @return modified class that clearly indicates it is generated.
	 */
	private byte[] decorate(byte[] generated) {
		ClassWriter cw = new ClassWriter(0);
		ClassVisitor cv = new ClassVisitor(Recaf.ASM_VERSION, cw) {
			@Override
			public void visitEnd() {
				visitAnnotation("LAutoGenerated;", true)
						.visit("msg", "Recaf/JPhantom automatically generated this class");
				super.visitEnd();
			}
		};
		new ClassReader(generated).accept(cv, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
		return cw.toByteArray();
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	public ResourceLocation getShortName() {
		return LOCATION;
	}

	@Override
	public ResourceLocation getName() {
		return LOCATION;
	}
}

```

`src/main/java/me/coley/recaf/workspace/ResourceKind.java`:

```java
package me.coley.recaf.workspace;

/**
 * The kind of a Java resource input.
 *
 * <ul>
 *     <li><b>Class</b> - Resource of a single file</li>
 *     <li><b>Jar</b> - Resource of multiple files in an archive</li>
 *     <li><b>War</b> - Resource of multiple files in an archive</li>
 *     <li><b>Directory</b> - Resource of multiple files in a directory</li>
 *     <li><b>Maven</b> - Resource of multiple files in a maven artifact</li>
 *     <li><b>URL</b> - Resource hosted online, should map to either a {@link #CLASS} or {@link #JAR}</li>
 *     <li><b>Instrumentation</b> - Resource of from the current agent instrumentation</li>
 * </ul>
 *
 * @author Matt
 */
public enum ResourceKind {
	/**
	 * Resource of a single file.
	 */
	CLASS,
	/**
	 * Resource of multiple files in an archive.
	 */
	JAR,
	/**
	 * Resource of multiple files in an archive. For web applications.
	 */
	WAR,
	/**
	 * Resource of multiple files in a directory.
	 */
	DIRECTORY,
	/**
	 * Resource of multiple files in a maven artifact.
	 */
	MAVEN,
	/**
	 * Resource hosted online, should map to either a <b><i>CLASS</i></b> or <b><i>JAR</i></b>.
	 */
	URL,
	/**
	 * Resource of from the current agent instrumentation.
	 */
	INSTRUMENTATION,
	/**
	 * Resource for a debugger.
	 */
	DEBUGGER,
	/**
	 * Dummy resource.
	 */
	EMPTY
}

```

`src/main/java/me/coley/recaf/workspace/ResourceLocation.java`:

```java
package me.coley.recaf.workspace;

/**
 * Location of a Java resource.
 *
 * @author xxDark
 */
public abstract class ResourceLocation {
    private final ResourceKind kind;

    /**
     * Create resource location.
     *
     * @param kind location kind.
     */
    public ResourceLocation(ResourceKind kind) {
        this.kind = kind;
    }

    /**
     * @return Type of referenced resource.
     */
    public ResourceKind kind() {
        return kind;
    }

    /**
     * @return {@link ResourceLocation} with redundant name elements eliminated.
     */
    public abstract ResourceLocation normalize();

    /**
     * @param other other location.
     * @return result of concating two locations together.
     */
    public abstract ResourceLocation concat(ResourceLocation other);

    /**
     * @return absolute location of this location.
     */
    public abstract ResourceLocation toAbsolute();

    /**
     * @return {@code true} if this location is absolute,
     * {@code false} otherwise.
     */
    public abstract boolean isAbsolute();

    @Override
    public abstract boolean equals(Object other);

    @Override
    public abstract String toString();
}

```

`src/main/java/me/coley/recaf/workspace/UrlResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;
import me.coley.recaf.util.NetworkUtil;

import java.io.IOException;
import java.io.OutputStream;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Importable online resource.
 *
 * @author Matt
 */
public class UrlResource extends DeferringResource {
	private final URL url;

	/**
	 * Constructs a URL resource.
	 *
	 * @param url
	 * 		The URL to pull content from. Should reference a class or jar file.
	 *
	 * @throws IOException
	 * 		When the content of the URL cannot be resolved.
	 */
	public UrlResource(URL url) throws IOException {
		super(ResourceKind.URL);
		this.url = url;
		verify();
		detectUrlKind();
	}

	/**
	 * @return The URL imported from.
	 */
	public URL getUrl() {
		return url;
	}

	/**
	 * Verify that the URL points to a valid location.
	 *
	 * @throws IOException
	 * 		When the url times out or there is no content at the URL.
	 */
	private void verify() throws IOException {
		NetworkUtil.verifyUrlContent(url);
	}

	/**
	 * Analyze the URL to determine which backing JavaResource implementation to use.
	 */
	private void detectUrlKind() throws IOException {
		String name = url.toString().toLowerCase();
		Path path;
		if (name.endsWith(".class")) {
			try {
				if (name.startsWith("file:"))
					path = Paths.get(url.toURI());
				else {
					path = IOUtil.createTempFile("recaf", "temp.class");
					try (OutputStream os = Files.newOutputStream(path)) {
						IOUtil.transfer(url, os);
					}
				}
				setBacking(new ClassResource(path));
			} catch(IOException | URISyntaxException ex) {
				throw new IOException("Failed to import class from URL '" + name + "'", ex);
			}
		} else if (name.endsWith(".jar")) {
			try {
				if (name.startsWith("file:"))
					path = Paths.get(url.toURI());
				else {
					path = IOUtil.createTempFile("recaf", "temp.jar");
					try (OutputStream os = Files.newOutputStream(path)) {
						IOUtil.transfer(url, os);
					}
				}
				setBacking(new JarResource(path));
			} catch(IOException | URISyntaxException ex) {
				throw new IOException("Failed to import jar from URL '" + name + "'", ex);
			}
		} else if (name.endsWith(".war")) {
			try {
				if (name.startsWith("file:"))
					path = Paths.get(url.toURI());
				else {
					path = IOUtil.createTempFile("recaf", "temp.war");
					try (OutputStream os = Files.newOutputStream(path)) {
						IOUtil.transfer(url, os);
					}
				}
				setBacking(new WarResource(path));
			} catch(IOException | URISyntaxException ex) {
				throw new IOException("Failed to import war from URL '" + name + "'", ex);
			}
		} else {
			// Invalid URL
			throw new IOException("URLs must end in a '.class' or '.jar', found '" + name + "'");
		}
	}
}
```

`src/main/java/me/coley/recaf/workspace/WarResource.java`:

```java
package me.coley.recaf.workspace;

import me.coley.recaf.util.IOUtil;

import java.io.*;
import java.nio.file.Path;
import java.util.Enumeration;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * Importable war resource.
 *
 * @author Matt
 */
public class WarResource extends ArchiveResource {
	public static final String WAR_CLASS_PREFIX = "WEB-INF/classes/";

	/**
	 * Constructs a war resource.
	 *
	 * @param path
	 * 		Path reference to a war file.
	 *
	 * @throws IOException
	 * 		When the file does not exist.
	 */
	public WarResource(Path path) throws IOException {
		super(ResourceKind.WAR, path);
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		// iterate war entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();
		ZipInputStream zis = new ZipInputStream(new FileInputStream(getPath().toFile()));
		ZipEntry entry;
		while ((entry = zis.getNextEntry()) != null) {
			// verify entries are classes and valid files
			// - skip intentional garbage / zip file abnormalities
			if (shouldSkip(entry.getName()))
				continue;
			if(!loader.isValidFileEntry(entry))
				continue;
			if (loader.isValidClassEntry(entry)) {
				out.reset();
				byte[] in = IOUtil.toByteArray(zis, out, buffer);
				// There is no possible way a "class" under 30 bytes is valid
				if (in.length < 30)
					continue;
				String name = entry.getName();
				if (name.startsWith(WAR_CLASS_PREFIX))
					name = name.substring(WAR_CLASS_PREFIX.length());
				loader.onClass(name, in);
			}
		}
		loader.finishClasses();
		return loader.getClasses();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		// iterate war entries
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		byte[] buffer = new byte[8192];
		EntryLoader loader = getEntryLoader();
		try (ZipFile zipFile = new ZipFile(getPath().toFile())) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while(entries.hasMoreElements()) {
				// verify entries are not classes and are valid files
				// - skip intentional garbage / zip file abnormalities
				ZipEntry entry = entries.nextElement();
				if (shouldSkip(entry.getName()))
					continue;
				if(loader.isValidClassEntry(entry))
					continue;
				if(!loader.isValidFileEntry(entry))
					continue;
				out.reset();
				InputStream stream = zipFile.getInputStream(entry);
				byte[] in = IOUtil.toByteArray(stream, out, buffer);
				loader.onFile(entry.getName(), in);
			}
		}
		loader.finishFiles();
		return loader.getFiles();
	}
}

```

`src/main/java/me/coley/recaf/workspace/Workspace.java`:

```java
package me.coley.recaf.workspace;

import com.github.javaparser.ParseResult;
import com.github.javaparser.ParserConfiguration;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import me.coley.recaf.Recaf;
import me.coley.recaf.compiler.JavacCompiler;
import me.coley.recaf.control.Controller;
import me.coley.recaf.control.headless.HeadlessController;
import me.coley.recaf.graph.flow.FlowGraph;
import me.coley.recaf.graph.inheritance.HierarchyGraph;
import me.coley.recaf.mapping.AsmMappingUtils;
import me.coley.recaf.parse.javadoc.Javadocs;
import me.coley.recaf.parse.source.*;
import me.coley.recaf.util.Log;
import me.coley.recaf.util.ThreadUtil;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Input manager
 *
 * @author Matt
 */
public class Workspace {
	private static final LazyClasspathResource CP = LazyClasspathResource.get();
	private final Map<String, String> aggregatedMappings = new TreeMap<>();
	private final PhantomResource phantoms = new PhantomResource();
	private final JavaResource primary;
	private final List<JavaResource> libraries;
	private HierarchyGraph hierarchyGraph;
	private FlowGraph flowGraph;
	private ParserConfiguration config;

	/**
	 * Constructs a workspace.
	 *
	 * @param primary
	 * 		Primary resource containing the content to analyze and modify.
	 */
	public Workspace(JavaResource primary) {
		this(primary, new ArrayList<>());
	}

	/**
	 * Constructs a workspace.
	 *
	 * @param primary
	 * 		Primary resource containing the content to analyze and modify.
	 * @param libraries
	 * 		Backing resources used for reference.
	 */
	public Workspace(JavaResource primary, List<JavaResource> libraries) {
		this.primary = primary;
		this.primary.setPrimary(true);
		this.libraries = libraries;
	}

	/**
	 * @return Primary file being worked on.
	 */
	public JavaResource getPrimary() {
		return primary;
	}

	/**
	 * @return Libraries of the {@link #getPrimary() primary file}.
	 */
	public List<JavaResource> getLibraries() {
		return libraries;
	}

	/**
	 * @return Recaf managed resource containing phantom references.
	 */
	public PhantomResource getPhantoms() {
		return phantoms;
	}

	/**
	 * @return Inheritance hierarchy utility.
	 */
	public HierarchyGraph getHierarchyGraph() {
		if(hierarchyGraph == null)
			hierarchyGraph = new HierarchyGraph(this);
		return hierarchyGraph;
	}

	/**
	 * @return Method flow utility.
	 */
	public FlowGraph getFlowGraph() {
		if(flowGraph == null)
			flowGraph = new FlowGraph(this);
		return flowGraph;
	}

	/**
	 * @return Aggregated ASM mappings for the workspace.
	 */
	public Map<String, String> getAggregatedMappings() {
		return Collections.unmodifiableMap(aggregatedMappings);
	}

	// ====================================== RENAME UTILS ====================================== //

	private Set<String> definitionUpdatedClasses = Collections.emptySet();

	/**
	 * @return File location of temporary primary jar.
	 */
	public File getTemporaryPrimaryDefinitionJar() {
		return JavacCompiler.getCompilerClasspathDirectory().resolve("primary.jar").toFile();
	}

	/**
	 * Called when any definitions in the primary jar are updated. This is necessary when
	 * supporting recompilation since we will need updated class and members definitions.
	 *
	 * @param classes
	 * 		The set of class names that have been updated as a result of the definition changes.
	 */
	public void onPrimaryDefinitionChanges(Set<String> classes) {
		definitionUpdatedClasses = classes;
	}

	/**
	 * Updated after calls to {@link #onPrimaryDefinitionChanges(Set)}.
	 *
	 * @return The set of class names that have been updated as a result of the definition changes.
	 */
	public Set<String> getDefinitionUpdatedClasses() {
		return definitionUpdatedClasses;
	}

	/**
	 * Update the generated jar file
	 */
	public void analyzePhantoms() {
		Controller controller = Recaf.getController();
		if (controller == null || controller instanceof HeadlessController) {
			// If we're using a headless controller, we very likely do not need to create phantom references.
			// (Realistically, I doubt people will use the assembler in CLI mode)
			return;
		}
		// Skip if phantoms disabled
		if (!controller.config().assembler().phantoms)
			return;
		// Thread this so we don't hang any important threads.
		ThreadUtil.run(() -> {
			try {
				long start = System.currentTimeMillis();
				phantoms.populatePhantoms(primary.getClasses());
				Log.debug("Generated {} phantom classes in {} ms",
						phantoms.getClasses().size(), (System.currentTimeMillis() - start));
			} catch (Throwable t) {
				Log.error(t, "Failed to analyze phantom references for primary resource");
			}
		});
	}

	/**
	 * Update the aggregate ASM mappings in the workspace.
	 *
	 * @param newMappings    The additional ASM mappings that were added.
	 * @param changedClasses The set of class names that have been updated as a result of the definition changes.
	 */
	public void updateAggregateMappings(Map<String, String> newMappings, Set<String> changedClasses) {
		Map<String, String> usefulMappings = new HashMap<>();
		for (Map.Entry<String, String> newMapping : newMappings.entrySet()) {
			// only process mappings that actually caused changes in their own class
			String className = AsmMappingUtils.getClassNameFromAsmKey(newMapping.getKey());
			if (!changedClasses.contains(className)) {
				Log.trace("Omitting unused mapping: " + newMapping.getKey() + " -> " + newMapping.getValue());
				continue;
			}

			usefulMappings.put(newMapping.getKey(), newMapping.getValue());
		}
		AsmMappingUtils.applyMappingToExisting(this.aggregatedMappings, usefulMappings);
	}

	// ================================= CLASS / RESOURCE UTILS ================================= //

	/**
	 * @return Set of all class names loaded in the workspace.
	 */
	public Set<String> getClassNames() {
		Set<String> names = getPrimaryClassNames();
		names.addAll(getLibraryClassNames());
		return names;
	}

	/**
	 * @return Set of all class names loaded in the primary resource.
	 */
	public Set<String> getPrimaryClassNames() {
		return new HashSet<>(primary.getClasses().keySet());
	}

	/**
	 * @return Set of all class names loaded in the library resources.
	 */
	public Set<String> getLibraryClassNames() {
		Set<String> names = new HashSet<>();
		for(JavaResource resource : getLibraries())
			names.addAll(resource.getClasses().keySet());
		return names;
	}

	/**
	 * @return Set of all classes loaded in the primary resource.
	 */
	public Set<byte[]> getPrimaryClasses() {
		return new HashSet<>(primary.getClasses().values());
	}

	/**
	 * @return Set of all classes loaded in the library resources.
	 */
	public Set<byte[]> getLibraryClasses() {
		Set<byte[]> values = new HashSet<>();
		for(JavaResource resource : getLibraries())
			values.addAll(resource.getClasses().values());
		return values;
	}

	/**
	 * @return Set of all classes loaded in the primary resource as
	 * {@link org.objectweb.asm.ClassReader}.
	 */
	public Set<ClassReader> getPrimaryClassReaders() {
		return getPrimaryClasses().stream()
				.map(ClassReader::new)
				.collect(Collectors.toSet());
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return The resource that contains the class.
	 */
	public JavaResource getContainingResourceForClass(String name) {
		if(getPrimary().getClasses().containsKey(name))
			return primary;
		for(JavaResource resource : getLibraries())
			if(resource.getClasses().containsKey(name))
				return resource;
		if(CP.getClasses().containsKey(name))
			return CP;
		else if (phantoms.getClasses().containsKey(name))
			return phantoms;
		return null;
	}


	/**
	 * @param name
	 * 		File name.
	 *
	 * @return The resource that contains the file.
	 */
	public JavaResource getContainingResourceForFile(String name) {
		if(getPrimary().getFiles().containsKey(name))
			return primary;
		for(JavaResource resource : getLibraries())
			if(resource.getFiles().containsKey(name))
				return resource;
		return null;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return {@code true} if one of the workspace sources contains the class.
	 */
	public boolean hasClass(String name) {
		if (primary.getClasses().containsKey(name))
			return true;
		for (JavaResource resource : getLibraries())
			if (resource.getClasses().containsKey(name))
				return true;
		if (CP.getClasses().containsKey(name))
			return true;
		else
			return phantoms.getClasses().containsKey(name);
	}

	/**
	 * @param name
	 * 		Resource name.
	 *
	 * @return {@code true} if one of the workspace sources contains the resource.
	 */
	public boolean hasFile(String name) {
		if(primary.getFiles().containsKey(name))
			return true;
		for(JavaResource resource : getLibraries())
			if(resource.getFiles().containsKey(name))
				return true;
		return false;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return Raw bytecode of the class by the given name.
	 */
	public byte[] getRawClass(String name) {
		byte[] ret = primary.getClasses().get(name);
		if(ret != null)
			return ret;
		for(JavaResource resource : getLibraries()) {
			ret = resource.getClasses().get(name);
			if(ret != null)
				return ret;
		}
		if (CP.getClasses().containsKey(name))
			return CP.getClasses().get(name);
		else if (phantoms.getClasses().containsKey(name))
			return phantoms.getClasses().get(name);
		return null;
	}

	/**
	 * @param name
	 * 		Class name.
	 *
	 * @return {@link org.objectweb.asm.ClassReader} for the given class.
	 */
	public ClassReader getClassReader(String name) {
		byte[] ret = getRawClass(name);
		if(ret != null)
			return new ClassReader(ret);
		return null;
	}

	/**
	 * @param flags
	 * 		Writer flags.
	 *
	 * @return {@link ClassWriter} capable of frame-generation.
	 */
	public WorkspaceClassWriter createWriter(int flags) {
		return new WorkspaceClassWriter(this, flags);
	}

	/**
	 * @param name
	 * 		Resource name.
	 *
	 * @return Resource binary by the given name.
	 */
	public byte[] getFile(String name) {
		byte[] ret = primary.getFiles().get(name);
		if(ret != null)
			return ret;
		for(JavaResource resource : getLibraries())
			ret = resource.getFiles().get(name);
		if(ret != null)
			return ret;
		return null;
	}

	// ================================= SOURCE / JAVADOC UTILS ================================= //

	/**
	 * Analyzes attached sources of all resources.
	 * This also allows workspace-wide name lookups for better type-resolving.
	 *
	 * @return Map of class names to their parse result. If an
	 * {@link SourceCodeException} occured during analysis of a class
	 * then it's result may have {@link com.github.javaparser.ParseResult#isSuccessful()} be {@code false}.
	 */
	public Map<String, ParseResult<CompilationUnit>> analyzeSources() {
		return Stream.concat(Stream.of(primary), libraries.stream())
				.flatMap(resource -> resource.analyzeSource(this).entrySet().stream())
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}

	/**
	 * @param name
	 * 		Internal name of a Java class.
	 *
	 * @return Source wrapper of class.
	 */
	public SourceCode getSource(String name) {
		SourceCode code = primary.getClassSource(name);
		if(code != null)
			return code;
		for(JavaResource resource : libraries)
			if((code = resource.getClassSource(name)) != null)
				break;
		return code;
	}

	/**
	 * @return JavaParser config to assist in resolving symbols.
	 */
	public ParserConfiguration getSourceParseConfig() {
		if (config == null)
			updateSourceConfig();
		return config;
	}

	/**
	 * Creates a source config with a type resolver that can access all types in the workspace.
	 */
	public void updateSourceConfig() {
		TypeSolver solver = new WorkspaceTypeResolver(this);
		config = new ParserConfiguration()
				.setSymbolResolver(new JavaSymbolSolver(solver))
				.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_16);
	}

	/**
	 * @param name
	 * 		Internal name of a Java class.
	 *
	 * @return Javadocs wrapper of class.
	 */
	public Javadocs getClassDocs(String name) {
		Javadocs docs = primary.getClassDocs(name);
		if(docs != null)
			return docs;
		for(JavaResource resource : libraries)
			if((docs = resource.getClassDocs(name)) != null)
				break;
		return docs;
	}
}
```

`src/main/java/me/coley/recaf/workspace/WorkspaceClassWriter.java`:

```java
package me.coley.recaf.workspace;

import org.objectweb.asm.ClassWriter;

import java.util.Map;

/**
 * Writer that uses workspace hierarchy to compute common parents for frame generation.
 *
 * @author Matt
 */
public class WorkspaceClassWriter extends ClassWriter {
	private final Workspace workspace;
	private Map<String, String> mappings;
	private Map<String, String> reverseMappings;

	/**
	 * @param workspace
	 * 		Workspace to use for hierarchy lookups.
	 * @param flags
	 * 		Writer flags.
	 */
	WorkspaceClassWriter(Workspace workspace, int flags) {
		super(flags);
		this.workspace = workspace;
	}

	@Override
	protected String getCommonSuperClass(String type1, String type2) throws TypeNotPresentException {
		// Default assumption if a type isn't given
		if(type1 == null || type2 == null)
			return "java/lang/Object";
		// Apply mappings if they exist
		if (mappings != null) {
			// We're likely looking at bytecode that is not reflected in the workspace yet.
			// So we have to "undo" the mappings for the given types.
			type1 = reverseMappings.getOrDefault(type1, type1);
			type2 = reverseMappings.getOrDefault(type2, type2);
		}
		// Find common parent in workspace
		String common = workspace.getHierarchyGraph().getCommon(type1, type2);
		if (common != null && !common.equals("java/lang/Object")) {
			// Assuming we have mappings we want to make sure the common name is using the mapped name.
			if (mappings != null)
				common = mappings.getOrDefault(common, common);
			return common;
		}
		// Fallback: Use base common parent lookup
		try {
			return super.getCommonSuperClass(type1, type2);
		} catch(Throwable ex) {
			return "java/lang/Object";
		}
	}

	/**
	 * When remapping classes, they're not in the workspace. So providing the
	 * <i>base-to-renamed</i> mappings will allow us to do a lookup.
	 *
	 * @param mappings
	 * 		<i>base-to-renamed</i> map.
	 * @param reverseMappings
	 * 		<i>renamed-to-base</i> map.
	 */
	public void setMappings(Map<String, String> mappings, Map<String, String> reverseMappings) {
		this.mappings = mappings;
		this.reverseMappings = reverseMappings;
	}
}

```

`src/main/java/me/coley/recaf/workspace/WorkspaceIO.java`:

```java
package me.coley.recaf.workspace;

import com.eclipsesource.json.*;
import me.coley.recaf.util.IOUtil;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

/**
 * IO Utilities for {@link Workspace}.
 *
 * @author Matt
 */
public class WorkspaceIO {
	/**
	 * @param json
	 * 		Json file.
	 *
	 * @return Workspace loaded from a json config.
	 *
	 * @throws Exception
	 * 		Thrown if the path could not be read or parsed.
	 */
	public static Workspace fromJson(Path json) throws Exception {
		return fromJson(String.join("", Files.readAllLines(json, StandardCharsets.UTF_8)));
	}

	/**
	 * @param json
	 * 		Json text.
	 *
	 * @return Workspace loaded from a json string.
	 *
	 * @throws Exception
	 * 		Thrown if the json could not be parsed.
	 */
	public static Workspace fromJson(String json) throws Exception {
		JsonObject root = Json.parse(json).asObject();
		JsonObject jprimary = root.get("primary").asObject();
		JavaResource primary = deserializeResource(jprimary);
		List<JavaResource> libraries = new ArrayList<>();
		if(root.names().contains("libraries")) {
			JsonArray jlibraries = root.get("libraries").asArray();
			for(JsonValue value : jlibraries)
				libraries.add(deserializeResource(value.asObject()));
		}
		return new Workspace(primary, libraries);
	}

	/**
	 * @param workspace
	 * 		Workspace instance.
	 *
	 * @return Json text representation of a workspace.
	 */
	public static String toJson(Workspace workspace) {
		JsonObject root = Json.object();
		JsonObject jprimary = serializeResource(workspace.getPrimary());
		JsonArray jlibraries = new JsonArray();
		for(JavaResource library : workspace.getLibraries())
			jlibraries.add(serializeResource(library));
		root.add("primary", jprimary);
		root.add("libraries", jlibraries);
		return root.toString(WriterConfig.PRETTY_PRINT);
	}

	/**
	 * @param resource
	 * 		Resource reference.
	 *
	 * @return Json representation of the reference.
	 */
	private static JsonObject serializeResource(JavaResource resource) {
		JsonObject root = serializeBase(resource);
		serializeExtras(resource, root);
		return root;
	}

	/**
	 * @param jresource
	 * 		Json representation of a resource reference.
	 *
	 * @return Resource reference.
	 *
	 * @throws IllegalArgumentException
	 * 		Thrown if the json object was malformed or if instantiation of the resource failed.
	 * @throws IOException
	 * 		Thrown when the resource's source failed to be loaded.
	 */
	private static JavaResource deserializeResource(JsonObject jresource) throws IllegalArgumentException, IOException {
		JavaResource resource = deserializeBase(jresource);
		deserializeExtras(resource, jresource);
		return resource;
	}

	/**
	 * Serialize core values <i>(kind/kind-source)</i>
	 *
	 * @param resource
	 * 		Resource to serialize.
	 *
	 * @return Json of resource.
	 */
	private static JsonObject serializeBase(JavaResource resource) {
		JsonObject root = Json.object();
		ResourceKind kind = resource.getKind();
		switch(kind) {
			case CLASS:
				Path clazz = ((ClassResource) resource).getPath();
				root.add("kind", "class");
				root.add("source", IOUtil.toString(clazz));
				break;
			case JAR:
				Path jar = ((JarResource) resource).getPath();
				root.add("kind", "jar");
				root.add("source", IOUtil.toString(jar));
				break;
			case WAR:
				Path war = ((WarResource) resource).getPath();
				root.add("kind", "war");
				root.add("source", IOUtil.toString(war));
				break;
			case DIRECTORY:
				Path dir = ((DirectoryResource) resource).getPath();
				root.add("kind", "directory");
				root.add("source", IOUtil.toString(dir));
				break;
			case MAVEN:
				MavenResource maven = (MavenResource) resource;
				root.add("kind", "maven");
				root.add("source", maven.getCoords());
				break;
			case URL:
				UrlResource url = (UrlResource) resource;
				root.add("kind", "url");
				root.add("source", url.getUrl().toString());
				break;
			case INSTRUMENTATION:
				root.add("kind", "instrumentation");
				root.add("source", "n/a");
				break;
			case DEBUGGER:
				root.add("kind", "debugger");
				root.add("source", "n/a");
				break;
			case EMPTY:
				root.add("kind", "empty");
				root.add("source", "n/a");
				break;
			default:
				throw new IllegalStateException("Unsupported kind: " + kind);
		}
		return root;
	}

	/**
	 * Deserialize core values <i>(kind/kind-source)</i>
	 *
	 * @param jresource
	 * 		Json to deserialize.
	 *
	 * @return Deserialized resource..
	 */
	private static JavaResource deserializeBase(JsonObject jresource) throws IOException {
		String kind = jresource.getString("kind", null);
		if (kind == null)
			throw new IllegalArgumentException("Invalid resource, kind not specified!");
		String source = jresource.getString("source", null);
		if (source == null)
			throw new IllegalArgumentException("Invalid resource, source not specified!");
		JavaResource resource = null;
		switch(kind) {
			case "class":
			case "jar":
			case "war":
			case "directory":
				Path path = Paths.get(source);
				if (Files.exists(path))
					resource = FileSystemResource.of(path);
				break;
			case "maven":
				String[] args = source.split(":");
				if (args.length != 3)
					throw new IllegalArgumentException("Invalid resource, maven source format invalid: " +
							source);
				resource = new MavenResource(args[0], args[1], args[2]);
				break;
			case "url":
				try {
					URL url = new URL(source);
					resource = new UrlResource(url);
				} catch(MalformedURLException ex) {
					throw new IllegalArgumentException("Invalid resource, url source format invalid: " +
							source, ex);
				}
				break;
			case "empty":
				resource = new EmptyResource();
				break;
			case "debugger":
			case "instrumentation":
				// Do nothing. Can't be deserialized.
				break;
			default:
				throw new IllegalStateException("Unsupported kind: " + kind);
		}
		if (resource == null)
			throw new IllegalStateException("Failed to load resource: " + kind + "/" + source);
		return resource;
	}


	/**
	 * Serialize non-core attributes.
	 *
	 * @param resource
	 * 		Resource to serialize.
	 * @param jresource
	 * 		Json to append data to.
	 */
	private static void serializeExtras(JavaResource resource, JsonObject jresource) {
		if (resource.getSkippedPrefixes().size() > 0) {
			JsonArray skipped = Json.array(resource.getSkippedPrefixes().toArray(new String[0]));
			jresource.add("skipped", skipped);
		}
		if (resource.getClassSourcePath() != null) {
			jresource.add("attach-src", resource.getClassSourcePath().toAbsolutePath().toString());
		}
		if (resource.getClassDocsPath() != null) {
			jresource.add("attach-docs", resource.getClassDocsPath().toAbsolutePath().toString());
		}
	}


	/**
	 * Deserialize non-core attributes.
	 *
	 * @param resource
	 * 		Resource to derialize.
	 * @param jresource
	 * 		Json to read data from.
	 */
	private static void deserializeExtras(JavaResource resource, JsonObject jresource) throws  IOException {
		if (resource == null)
			return;
		JsonValue value = jresource.get("skipped");
		if (value != null) {
			List<String> skipped = new ArrayList<>();
			value.asArray().forEach(val -> skipped.add(val.asString()));
			resource.setSkippedPrefixes(skipped);
		}
		value = jresource.get("attach-src");
		if (value != null) {
			File src = new File(value.asString());
			if (src.exists())
				resource.setClassSources(src.toPath());
		}
		value = jresource.get("attach-docs");
		if (value != null) {
			File docs = new File(value.asString());
			if (docs.exists())
				resource.setClassDocs(docs.toPath());
		}
	}
}

```

`src/main/resources/languages/bytecode.json`:

```json
{
	"name": "Java Bytecode",
	"wrap": false,
	"rules": [
		{
			"name": "comment-line",
			"pattern": "//.*"
		},
		{
			"name": "constant",
			"pattern": "\\b0[xX][0-9a-fA-F]+\\b|\\b(?:[\\d_]+\\.\\d+|[\\d_]+)[DLF]?\\b"
		},
		{
			"name": "string",
			"pattern": "(?<!\\\\)\".*\""
		},
		{
			"name": "keyword",
			"pattern": "\\b((?:I(?:F(?:_(?:ICMP(?:G[ET]|L[ET]|EQ|NE)|ACMP(?:EQ|NE))|N(?:(?:ONN)?ULL|E)|G[ET]|L[ET]|EQ)|N(?:VOKE(?:S(?:PECIAL|TATIC)|INTERFACE|DYNAMIC|VIRTUAL)|STANCEOF|EG)|A(?:(?:[DN]|LOA)D|STORE)|CONST_(?:[02345]|M?1)|S(?:H[LR]|TORE|UB)|(?:USH|X?O)R|RE(?:TURN|M)|2[BCDFLS]|LOAD|DIV|INC|MUL)|L(?:A(?:(?:[DN]|LOA)D|STORE|BEL)|S(?:H[LR]|TORE|UB)|C(?:ONST_[01]|MP)|O(?:OKUPSWITCH|R)|RE(?:TURN|M)|(?:USH|XO)R|D(?:IV|C)|2[DFI]|LOAD|INE|MUL|NEG)|D(?:UP(?:2(?:_X[12])?|_X[12])?|A(?:(?:LOA|D)D|STORE)|C(?:ONST_[01]|MP[GL])|RE(?:TURN|M)|S(?:TORE|UB)|2[FIL]|EFINE|LOAD|DIV|MUL|NEG)|F(?:C(?:ONST_[012]|MP[GL])|A(?:(?:LOA|D)D|STORE)|I(?:ELD|NAL)|RE(?:TURN|M)|S(?:TORE|UB)|2[DIL]|LOAD|_NEW|DIV|MUL|NEG)|A(?:R(?:RAYLENGTH|ETURN)|A(?:STORE|LOAD)|L(?:IAS|OAD)|CONST_NULL|NEWARRAY|BSTRACT|STORE|THROW)|S(?:Y(?:CHRONIZED|NTHETIC)|I(?:GNATURE|PUSH)|T(?:RICTFP|ATIC)|A(?:STORE|LOAD)|WAP)|P(?:U(?:T(?:STATIC|FIELD)|BLIC)|R(?:OTECTED|IVATE)|OP2?)|M(?:ONITORE(?:NTER|XIT)|ULTIANEWARRAY)|C(?:A(?:STORE|LOAD|TCH)|HECKCAST)|B(?:A(?:STORE|LOAD)|IPUSH|RIDGE)|G(?:ET(?:STATIC|FIELD)|OTO)|N(?:EW(?:ARRAY)?|ATIVE|OP)|T(?:ABLESWITCH|HROWS|RY)|VA(?:RARGS|LUE)|RET(?:URN)?|JSR|EXPR))\\b",
			"pattern-unoptimized": "\\b(PUBLIC|PROTECTED|PRIVATE|STATIC|FINAL|SYCHRONIZED|VARARGS|NATIVE|ABSTRACT|STRICTFP|SYNTHETIC|BRIDGE|AALOAD|AASTORE|ACONST_NULL|ALIAS|ALOAD|ANEWARRAY|ARETURN|ARRAYLENGTH|ASTORE|ATHROW|BALOAD|BASTORE|BIPUSH|CALOAD|CASTORE|CATCH|CHECKCAST|D2F|D2I|D2L|DADD|DALOAD|DASTORE|DCMPG|DCMPL|DCONST_0|DCONST_1|DDIV|DEFINE|DLOAD|DMUL|DNEG|DREM|DRETURN|DSTORE|DSUB|DUP|DUP2|DUP2_X1|DUP2_X2|DUP_X1|DUP_X2|F2D|F2I|F2L|F_NEW|FADD|FALOAD|FASTORE|FCMPG|FCMPL|FCONST_0|FCONST_1|FCONST_2|FDIV|FIELD|FLOAD|FMUL|FNEG|FREM|FRETURN|FSTORE|FSUB|GETFIELD|GETSTATIC|GOTO|I2B|I2C|I2D|I2F|I2L|I2S|IADD|IALOAD|IAND|IASTORE|ICONST_0|ICONST_1|ICONST_2|ICONST_3|ICONST_4|ICONST_5|ICONST_M1|IDIV|IF_ACMPEQ|IF_ACMPNE|IF_ICMPEQ|IF_ICMPGE|IF_ICMPGT|IF_ICMPLE|IF_ICMPLT|IF_ICMPNE|IFEQ|IFGE|IFGT|IFLE|IFLT|IFNE|IFNONNULL|IFNULL|IINC|ILOAD|IMUL|INEG|INSTANCEOF|INVOKEDYNAMIC|INVOKEINTERFACE|INVOKESPECIAL|INVOKESTATIC|INVOKEVIRTUAL|IOR|IREM|IRETURN|ISHL|ISHR|ISTORE|ISUB|IUSHR|IXOR|JSR|L2D|L2F|L2I|LABEL|LADD|LALOAD|LAND|LASTORE|LCMP|LCONST_0|LCONST_1|LDC|LDIV|LINE|LLOAD|LMUL|LNEG|LOOKUPSWITCH|LOR|LREM|LRETURN|LSHL|LSHR|LSTORE|LSUB|LUSHR|LXOR|MONITORENTER|MONITOREXIT|MULTIANEWARRAY|NEW|NEWARRAY|NOP|POP|POP2|PUTFIELD|PUTSTATIC|RET|RETURN|SALOAD|SASTORE|SIPUSH|SWAP|TABLESWITCH|THROWS|TRY|VALUE|EXPR)\\b"
		}
	]
}
```

`src/main/resources/languages/css.json`:

```json
{
	"name": "CSS",
	"wrap": false,
	"rules": [
		{
			"name": "comment-multi",
			"pattern": "/[*]+(.|\\n)+?\\*/"
		},
		{
			"name": "string",
			"pattern": "\\\"([^\"\\\\]|\\\\.)*\\\"|\\'([^'\\\\]|\\\\.)*\\'"
		},
		{
			"name": "annotation",
			"pattern": "@\\w+|(?<=\\s)@\\w+"
		},
		{
			"name": "keyword",
			"pattern": "(?!\\s+)[\\w-]+(?=:)(?=.*;|.\\s)|[#.\\-:\\w*]+(?=[\\w\\s\\-:.,*]*\\{)|\\b(?:d(?:a(?:rk(?:s(?:late(?:gr[ae]y|blue)|(?:eagree|almo)n)|g(?:r(?:e(?:en|y)|ay)|oldenrod)|o(?:r(?:ange|chid)|livegreen)|(?:turquois|blu)e|magenta|violet|khaki|cyan|red)|shed)|o(?:(?:dgerblu|ubl)e|tted)|eep(?:skyblue|pink)|imgr[ae]y)|l(?:i(?:ght(?:s(?:(?:eagree|almo)n|(?:teel|ky)blue|lategr[ae]y)|g(?:r(?:e(?:en|y)|ay)|oldenrodyellow)|c(?:oral|yan)|yellow|blue|pink)|me(?:green)?|nen)|a(?:vender(?:blush)?|wngreen)|e(?:monchiffon|ft))|m(?:edium(?:(?:aquamarin|turquois|purpl|blu)e|s(?:(?:pring|ea)green|lateblue)|(?:violetre|orchi)d)|i(?:(?:dnightblu|styros)e|ntcream)|o(?:nospace|ccasin)|a(?:genta|roon))|s(?:(?:a(?:(?:ddle|ndy)brow|lmo)|pringgree)n|t(?:eelblue|atic|icky)|late(?:gr[ae]y|blue)|ea(?:green|shell)|i(?:enna|lver)|kyblue|olid|now)|p(?:a(?:le(?:g(?:oldenrod|reen)|turquoise|violetred)|payawhip)|o(?:wderblue|inter)|e(?:achpuff|ru)|urple|ink|lum)|c(?:o(?:r(?:n(?:flowerblue|silk)|al)|ntain)|(?:h(?:artreus|ocolat)|adetblu)e|(?:rimso|ya)n|enter)|b(?:l(?:a(?:nchedalmond|ck)|ue(?:violet)?|ock)|o(?:rder-box|ld)|(?:isqu|eig)e|urlywood|rown)|r(?:e(?:peat(?:-[xy])?|lative|d)|o(?:sybrown|yalblue)|i(?:dge|ght)|gba?)|g(?:r(?:e(?:en(?:yellow)?|y)|oove|ay)|ol(?:denro)?d|hostwhite|ainsboro)|i(?:n(?:line(?:-block)?|di(?:anred|go)|(?:heri|se)t|itial)|talic|vory)|o(?:l(?:ive(?:drab)?|dlace)|r(?:angere|chi)d|blique|utset)|a(?:(?:(?:ntiquewhi|bsolu)t|zur)e|qua(?:marine)?|uto)|f(?:i(?:rebrick|xed)|loralwhite|orestgreen|uchsia)|t(?:(?:urquois|histl)e|ransparent|omato|eal|an)|n(?:o(?:-repeat|wrap|ne)|av(?:ajowhite|y))|h(?:o(?:neydew|tpink)|idden)|wh(?:it(?:esmok)?e|eat)|vi(?:sible|olet)|yellow(?:green)?|justify|khaki)\\b",
			"pattern-unoptimized": "(?!\\s+)[\\w-]+(?=:)(?=.*;|.\\s)|[#.\\-:\\w*]+(?=[\\w\\s\\-:.,*]*\\{)|\\b(auto|rgb|rgba|transparent|visible|hidden|nowrap|left|right|center|justify|static|relative|fixed|absolute|sticky|block|inline|inline-block|none|initial|inherit|border-box|contain|repeat|no-repeat|repeat-x|repeat-y|italic|bold|oblique|dotted|dashed|solid|double|groove|ridge|inset|outset|none|hidden|black|silver|gray|white|maroon|red|purple|fuchsia|green|lime|olive|yellow|navy|blue|teal|aqua|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|turquoise|violet|wheat|whitesmoke|yellowgreen|monospace|pointer)\\b"
		},
		{
			"name": "constant",
			"pattern": "[\\d.]+px|[\\d.]+%|[\\d.]+em|[\\d.]+deg|#\\w+|\\d+\\.\\d+|\\d+"
		}
	]
}
```

`src/main/resources/languages/java.json`:

```json
{
	"name": "Java",
	"wrap": false,
	"rules": [
		{
			"name": "comment-javadoc",
			"pattern": "\\/[*]{2}[\\s\\S]*?\\*\\/"
		},
		{
			"name": "comment-multi",
			"pattern": "\\/\\*[\\s\\S]*?\\*\\/"
		},
		{
			"name": "comment-line",
			"pattern": "//.+"
		},
		{
			"name": "annotation",
			"pattern": "@\\w+|(?<=\\s)@\\w+"
		},
		{
			"name": "constant",
			"pattern": "\\b0[xX][0-9a-fA-F]+\\b|\\b(?:[\\d_]+\\.\\d+|[\\d_]+)\\b|\\b(?:true|false|null)\\b|'[\\\\]?.'"
		},
		{
			"name": "string",
			"pattern": "\"(?:[^\"\\\\]|\\\\.)*\""
		},
		{
			"name": "keyword",
			"pattern": "\\b(?:i(?:n(?:t(?:erface)?|stanceof)|mp(?:lements|ort)|f)|s(?:t(?:rictfp|atic)|ynchronized|witch|hort|uper)|c(?:on(?:tinue|st)|a(?:tch|se)|lass|har)|p(?:r(?:otected|ivate)|ackage|ublic)|t(?:r(?:ansient|y)|h(?:rows?|is))|f(?:inal(?:ly)?|loat|or)|d(?:o(?:uble)?|efault)|v(?:o(?:latile|id)|ar)|b(?:oolean|reak|yte)|e(?:xtends|lse|num)|a(?:bstrac|sser)t|n(?:ative|ull|ew)|return|while|yield|goto|long)\\b",
			"pattern-unoptimized": "\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|null|throw|throws|transient|try|var|void|volatile|while|yield)\\b"
		}
	]
}
```

`src/main/resources/languages/json.json`:

```json
{
	"name": "JSON",
	"wrap": false,
	"rules": [
		{
			"name": "annotation",
			"pattern": "\"(?:[^\"\\\\]|\\\\.)*\"(?=[,\\s])"
		},
		{
			"name": "string",
			"pattern": "\"(?:[^\"\\\\]|\\\\.)*\""
		},
		{
			"name": "constant",
			"pattern": "(?:\\b([\\d._]*[\\d])\\b)+|\\b(?:true|false|null)\\b"
		}
	]
}
```

`src/main/resources/languages/mf.json`:

```json
{
	"name": "Manifest",
	"wrap": true,
	"rules": [
		{
			"name": "keyword",
			"pattern": "(?<=[\\n\\r])\\S+(?=:)|^\\S+(?=:)"
		}
	]
}
```

`src/main/resources/languages/properties.json`:

```json
{
	"name": "Properties",
	"wrap": true,
	"rules": [
		{
			"name": "comment-line",
			"pattern": "#.*"
		},
		{
			"name": "keyword",
			"pattern": "(?<=[\\n\\r])\\S+(?==)|^\\S+(?==)"
		}
	]
}
```

`src/main/resources/languages/xml.json`:

```json
{
	"name": "Extensible Markup Language",
	"wrap": false,
	"rules": [
		{
			"name": "comment-multi",
			"pattern": "<!--[\\w\\W]*?-->"
		},
		{
			"name": "string",
			"pattern": "\"(?:[^\"\\\\]|\\\\.)*\""
		},
		{
			"name": "keyword",
			"pattern": "(?<=<)[?\\w\\.]+(?=[\\w\\W]+>)|(?<=<\\/)[\\w\\.]+(?=>)"
		}
	]
}
```

`src/main/resources/logback.xml`:

```xml
<configuration>
	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
		<encoder>
			<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level: %msg%n</pattern>
		</encoder>
	</appender>
	<logger name="recaf-logger" level="trace" additivity="false">
		<appender-ref ref="STDOUT"/>
	</logger>
	<shutdownHook class="ch.qos.logback.core.hook.DelayingShutdownHook">
	</shutdownHook>
</configuration>
```

`src/main/resources/style/base.css`:

```css
/* =========================
 * ==   Generic Elements  ==
 * =========================
 */
.h1 {
	-fx-font-size: 18px;
	-fx-font-weight: bold;
}
.h2 {
	-fx-font-size: 15px;
	-fx-font-weight: bold;
}
.a {
    -fx-underline: true;
    -fx-text-fill: rgb(24, 101, 217);
    -fx-fill: rgb(24, 101, 217);
}
.bold {
	-fx-font-weight: bold;
}
.underlined {
	-fx-underline: true;
}
.faint {
	-fx-fill: rgb(116, 116, 116);
}
.no-border {
	-fx-border-width: 0;
	-fx-background-insets: -1;
}
.no-border *.list-view {
	-fx-border-width: 0;
   	-fx-background-insets: -1;
}
/* This is the default monospaced entry, but is overridden with a separate user-generated sheet */
.monospaced {
	-fx-font-family: 'monospaced';
}

/* Separate class for tree cells, they need to use the ui font size */
.monospaced-tree {
	-fx-font-family: 'monospaced';
}

.drag-target {
    -fx-effect: innershadow(one-pass-box, rgba(15, 200, 255), 50, 0.333, 0, 0);
}
/* =========================
 * ==     JFX Controls    ==
 * =========================
 */
.text-area {
	-fx-font-family: 'monospaced';
}
.key-field:focused {
    -fx-prompt-text-fill: rgb(111, 111, 111);
}
	/* hack to get title to fill menu container. Yes the color is needed. */
.action-menu-title {
	-fx-background-insets: -5px -8px -5px -8px;
	-fx-background-color: rgba(241, 241, 241, 0.001);
}
.tree-cell-annotation,
.tree-cell-class,
.tree-cell-directory,
.tree-cell-file,
.tree-cell-member,
.tree-cell-instruction,
.tree-cell-local,
.tree-cell-catch {

}
/* =========================
 * ==     Hex Controls    ==
 * =========================
 */
	/* Hide hex scroll bars */
.hex-wrapper .table-view .scroll-bar:vertical .track {
	-fx-padding: 0;
	-fx-background-color: transparent;
	-fx-border-color: transparent;
	-fx-background-radius: 0;
	-fx-border-radius: 2;
}
.hex-wrapper .table-view .scroll-bar:vertical .increment-button ,
.hex-wrapper .table-view .scroll-bar:vertical .decrement-button {
	-fx-background-color: transparent;
	-fx-background-radius: 0;
	-fx-padding: 0 0 0 0;
}
.hex-wrapper .table-view .scroll-bar:vertical .increment-arrow,
.hex-wrapper .table-view .scroll-bar:vertical .decrement-arrow {
	-fx-shape: " ";
	-fx-padding: 0;
}
.hex-wrapper .table-view .scroll-bar:vertical .thumb {
    -fx-background-color: transparent;
	-fx-background-insets: 0, 0, 0;
	-fx-background-radius: 2em;
    -fx-padding: 0px;
}
   /* Hide accessible hint */
.hex-wrapper .table-view {
	-fx-focus-color: transparent;
}
   /* sizing */
.hex-content-table {
	-fx-min-width: 470px;
	-fx-fixed-cell-size: 20px;
}
.hex-offset-table {
	-fx-min-width: 80px;
    -fx-pref-width: 80px;
    -fx-fixed-cell-size: 20px;
}
.hex-text-table {
	-fx-min-width: 146px;
	-fx-pref-width: 146px;
	-fx-fixed-cell-size: 20px;
}
.hex-cell {
	-fx-font-family: 'monospaced';
	-fx-padding: 0;
}
.hex-cell *.text-field {
	-fx-font-family: 'monospaced';
	-fx-text-fill: rgb(0, 0, 0);
	-fx-background-color: transparent;
 	-fx-background-insets: 0;
 	-fx-background-radius: 0;
 	-fx-border-width: 0;
 	-fx-padding: -5 0 -5 0;
}
/* =========================
 * ==     About Panel     ==
 * =========================
 */
.about-panel *.label {
	-fx-font-size: 16px;
}
/* =========================
 * ==    Verification     ==
 * =========================
 */
.verify-pass {}
.verify-fail {
	-fx-effect: innershadow(one-pass-box, red, 10, 1, 0, 0);
}
/* Hack to fix effect changing child hbox heights */
.verify-pass *.text-hbox,
.verify-fail *.text-hbox {
	 -fx-pref-height: 17;
}
/* =========================
 * ==   Attach Elements   ==
 * =========================
 */
.vm-cell {
	-fx-padding: 3 3 3 8;
}
.vm-buttons {}
.vm-info-table {}
.vm-list {}
.vm-cell {}
.vm-icon {
	-fx-padding: 2 15 2 2;
}
/* =========================
 * ==   History Elements  ==
 * =========================
 */
.hist-view {
	-fx-padding: 10;
}
.hist-data {
	-fx-font-family: 'monospaced';
	-fx-padding: 16 0 0 0;
}
.hist-cell {
	-fx-padding: 3 3 3 8;
}
.hist-icon {
	-fx-padding: 2 15 2 2;
}
/* =========================
 * ==        Misc         ==
 * =========================
 */
.drag-popup {
	-fx-max-width: 500;
	-fx-max-height: 500;
	-fx-min-height: 50;
	-fx-min-width: 200;
}
.scroll-antiblur-hack {
	-fx-background-color: -fx-box-border, -fx-background;
	-fx-background-insets: 0, 1;
	-fx-padding: 1;
}
.cursor-pointer {
	-fx-cursor: hand;
}
.tooltip {
	-fx-font-family: 'sans-serif';
	-fx-font-size: 1em;
}
.search-button {
	-fx-background-image: url('../icons/find.png');
	-fx-background-repeat: no-repeat;
	-fx-background-position: 5% center;
}
.remap-field {
	-fx-font-family: 'monospaced';
}
.search-field {
	-fx-background-image: url('../icons/find.png');
	-fx-background-repeat: no-repeat;
	-fx-background-position: right center;
}
.error-list {
	-fx-border-width: 1 0 0 0;
	-fx-border-color: black;
}
.error-cell {
	-fx-fill: red;
}
```

`src/main/resources/style/text-dark.css`:

```css
/* nodes */
.styled-text-area {
	-fx-background-color: rgb(45, 45, 46);
	-fx-accent: rgb(255, 97, 117);
	-fx-fill: rgb(224, 226, 228);
}
.paragraph-box {
	-fx-background-color: rgb(45, 45, 46);
}
.paragraph-box:has-caret {
    -fx-background-color: rgb(50, 50, 51);
}
.code-area {
	-fx-highlight-fill: rgb(44, 108, 131);
	-rtfx-border-stroke-color: rgb(41, 159, 200);
    -rtfx-border-stroke-width: 1;
    -rtfx-border-stroke-type: inside;
}
.lineno {
	-fx-background-color: rgb(29, 29, 31);
	-fx-fill: rgb(198, 217, 225);
	-fx-background-insets: -2;
	-fx-max-height: 1000px;
}
.caret {
	-fx-stroke: white;
}
/* decompiled code */
.code-area .text {
    -fx-fill: rgb(216, 216, 216);
}
.code-area .keyword {
    -fx-fill: rgb(0, 175, 255);
    -fx-font-weight: bold;
}
.code-area .string {
    -fx-fill: rgb(175, 215, 223);
}
.code-area .constant {
	-fx-fill: rgb(125, 215, 215);
}
.code-area .annotation {
    -fx-fill: rgb(0, 215, 215);
}
.code-area .comment-javadoc {
	-fx-fill: rgb(105, 135, 215);
}
.code-area .comment-multi {
	-fx-fill: rgb(155, 155, 215);
}
.code-area .comment-line {
	-fx-fill: rgb(175, 175, 215);
}
.code-area .error {
	-fx-fill: rgb(255, 0, 0);
	-fx-underline: true;
}
/* context menu */
.code-context-menu {
    -fx-background-color: rgb(41, 49, 52);
}
.code-context-menu *.menu-item:focused {
	-fx-background-color: rgb(49, 60, 64);
}
.code-context-menu *.menu-item:hover {
	-fx-background-color: rgb(49, 60, 64);
}
/* tab complete */
.tab-complete {
	-fx-max-height: 165px;
	-fx-max-width: 300px;
	-fx-opacity: 1;
	-fx-base: black;
	-fx-focus-color: rgb(37, 40, 45);
    -fx-faint-focus-color: transparent;
}
.tab-complete *.list-cell {
	-fx-accent: rgb(60, 60, 66);
	-fx-background-color: rgb(37, 40, 45);
	-fx-text-fill: white;
}
.tab-complete *.list-cell:selected {
	-fx-background-color: rgb(54, 60, 76);
	-fx-font-weight: bold;
}
```

`src/main/resources/style/text-default.css`:

```css
/* nodes */
.styled-text-area {
	-fx-background-color: rgb(255, 255, 255);
	-fx-accent: rgb(173, 214, 255);
	-fx-fill: rgb(0, 0, 0);
}
.paragraph-box {
	-fx-background-color: rgb(255, 255, 255);
}
.paragraph-box:has-caret {
    -fx-background-color: rgb(238, 238, 238);
}
.code-area {
	-fx-highlight-fill: rgb(44, 108, 131);
	-rtfx-border-stroke-color: rgb(41, 159, 200);
    -rtfx-border-stroke-width: 1;
    -rtfx-border-stroke-type: inside;
}
.lineno {
	-fx-background-color: rgb(238, 238, 238);
	-fx-fill: rgb(0, 0, 0);
	-fx-background-insets: -2;
}
.caret {
	-fx-stroke: black;
}
/* decompiled code */
.code-area .text {
    -fx-fill: rgb(33, 33, 33);
}
.code-area .keyword {
    -fx-fill: rgb(0, 0, 255);
    -fx-font-weight: bold;
}
.code-area .string {
    -fx-fill: rgb(163, 21, 21);
}
.code-area .constant {
    -fx-fill: rgb(43, 125, 160);
}
.code-area .annotation {
    -fx-fill: rgb(43, 145, 175);
}
.code-area .comment-javadoc {
	-fx-fill: rgb(29, 135, 17);
}
.code-area .comment-multi {
	-fx-fill: rgb(0, 128, 0);
}
.code-area .comment-line {
	-fx-fill: rgb(0, 128, 0);
}
.code-area .error {
	-fx-fill: rgb(255, 0, 0);
	-fx-underline: true;
}
/* verify disassembly code */
.code-area .ver-key {
	-fx-fill: rgb(234, 125, 242);
}
.code-area .ver-op {
	-fx-fill: rgb(187, 249, 104);
}
.code-area .ver-pre-good {
	-fx-fill: rgb(143, 201, 145);
}
.code-area .ver-pre-err {
	-fx-fill: rgb(231, 162, 145);
}
.code-area .ver-const {
	-fx-fill: rgb(247, 129, 32);
}
.code-area .ver-line {
	-fx-fill: rgb(148, 172, 224);
}
/* context menu */
.code-context-menu {
    -fx-background-color: rgb(41, 49, 52);
}
.code-context-menu *.menu-item:focused {
	-fx-background-color: rgb(49, 60, 64);
}
.code-context-menu *.menu-item:hover {
	-fx-background-color: rgb(49, 60, 64);
	
}
/* tab complete */
.tab-complete {
	-fx-max-height: 165px;
	-fx-max-width: 300px;
	-fx-opacity: 0.85;
	-fx-base: black;
	-fx-focus-color: rgb(37, 44, 45);
    -fx-faint-focus-color: transparent;
}
.tab-complete *.list-cell {
	-fx-accent: rgb(60, 60, 66);
	-fx-background-color: rgb(37, 44, 45);
	-fx-text-fill: white;
}
.tab-complete *.list-cell:selected {
	-fx-background-color: rgb(54, 69, 76);
	-fx-font-weight: bold;
}

```

`src/main/resources/style/ui-dark.css`:

```css
/* =========================
 * ==     JFX Controls    ==
 * =========================
 */
.root {
	-fx-base: rgb(45, 45, 46);
	-fx-background: rgb(45, 45, 46);
	/* Brighten controls */
	-fx-color: derive(-fx-base, -40%);
	/* Control background */
	-fx-control-inner-background: rgb(46, 46, 47);
	/* Alternative control background (rows) */
	-fx-control-inner-background-alt: derive(-fx-control-inner-background, 2.5%);
	/* Text colors */
	-fx-light-text-color: rgb(220, 220, 220);
	-fx-mid-text-color: rgb(100, 100, 100);
	-fx-dark-text-color: rgb(20, 20, 20);
	/* Accent colors */
	-fx-accent: rgb(51, 51, 52);
	-fx-focus-color: rgb(51, 51, 52);
	/* Non-focused-selected elements */
	-fx-selection-bar-non-focused: rgb(45, 45, 46);
}
* {
	-fx-highlight-fill: rgba(0, 180, 255, 0.4);
}
/* Scroll */
.scroll-bar {
	-fx-background-color: rgb(61,61,62);
}
.scroll-bar .thumb {
	-fx-background-color: rgb(91,91,92);
	-fx-background-radius: 0;
}
.scroll-bar .thumb:hover,
.scroll-bar .thumb:pressed {
	-fx-background-color: rgb(141,141,142);
}
.scroll-bar .increment-button .increment-arrow,
.scroll-bar .decrement-button .decrement-arrow {
	-fx-background-color: rgb(200,200,200);
}
.corner {
    -fx-background-color: rgb(61,61,62);
}
/* Menu */
.menu-bar {
	-fx-background-color: rgb(45, 45, 48);
}
.menu {
	-fx-padding: 6 14 6 14;
	-fx-background-insets: -1;
}
.menu-item {
	-fx-padding: 5 11 5 11;
	-fx-background-insets: -1;
}
.menu:hover {
	-fx-background-color: rgb(61, 61, 62);
}
.context-menu,
.menu:showing {
	-fx-background-color: rgb(27, 27, 28);
	-fx-border-insets: -1;
	-fx-border-width: 1;
	-fx-border-color: black;
}
.context-menu {
	-fx-min-width: 80px;
	-fx-background-insets: -1;
	-fx-border-insets: -1;
	-fx-border-width: 1;
	-fx-border-color: black;
}
.context-menu .menu-item:focused {
	-fx-background-color: rgb(61, 61, 62);
}
.context-menu-header {
	-fx-opacity: 1.0 !important;
	-fx-background-color: rgb(24, 50, 95) !important;
}
.context-menu-header .label {
    -fx-opacity: 1.0;
}

/* Tabs */
.tab-pane {
	-fx-tab-min-width: 100px;
}
.tab-pane *.tab-header-background {
	-fx-background-color: rgb(29, 29, 31);
	-fx-border-width: 0 0 1 0;
	-fx-border-color: black;
}
.headers-region {
	-fx-background-color: rgb(75, 75, 76);
}
.tab {
	-fx-background-color: rgb(36,36,37);
	-fx-background-insets: 2 -1 -1 -1;
	-fx-background-radius: 0;
	-fx-padding: 2 2 1 2;
	-fx-border-insets: 0;
	-fx-border-width: 1 1 1 1;
	-fx-border-color: black;
}
.tab:selected {
	-fx-background-color: rgb(45, 45, 46);
	-fx-background-insets: 2 -1 -1 -1;
	-fx-padding: 2;
	-fx-border-insets: 0;
	-fx-border-width: 1 1 0 1;
	-fx-border-color: black;
}
.tab:selected .focus-indicator {
	-fx-border-color: transparent;
}
/* Table */
.table-view {
	-fx-selection-bar: rgb(50, 71, 77);
	-fx-selection-bar-non-focused: rgb(46, 56, 59);
	-fx-background-color: rgb(36,36,37);
	-fx-background-insets: 2 -1 -1 -1;
	-fx-background-radius: 0;
	-fx-padding: -1;
	-fx-border-width: 0 1 1 1;
	-fx-border-color: rgb(22, 22, 23);
}
.table-view .filler,
.table-view .show-hide-columns-button,
.column-overlay {
	-fx-background-color: transparent;
}
.column-header-background {
	-fx-background-color: rgb(36,36,37);
	-fx-background-insets: 2 -1 -1 -1;
	-fx-padding: -1;
	-fx-border-insets: 0;
	-fx-border-width: 0 1 0 1;
	-fx-border-color: rgb(22, 22, 23);
}
.column-header {
	-fx-background-color: rgb(45, 45, 46);
	-fx-background-insets: -1 -0 -1 0;
	-fx-padding: 2;
	-fx-border-insets: 1 -1 1 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(22, 22, 23);
}
/* Splitpane */
.split-pane-divider {
	-fx-background-color: black;
	-fx-padding: 0;
	-fx-background-insets: -5;
}
/* Tree */
.tree-table-view,
.tree-view {
	-fx-background-color: rgb(29, 29, 31);
	-fx-background-insets: 0;
	-fx-border-width: 0 1 0 0;
	-fx-border-color: black;
}
.tree-table-cell,
.tree-cell {
	-fx-background-color: rgb(29, 29, 31);
}
.tree-cell:selected {
	-fx-background-color: rgb(44, 48, 55);
}
/* Buttons */
.box,
.button,
.combo-box,
.slider .thumb {
	-fx-background-radius: 0;
	-fx-background-color: rgb(63, 63, 70);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(85, 85, 85);
}
.check-box:hover .box,
.button:hover,
.combo-box:hover,
.slider .thumb:hover {
	-fx-background-color: rgb(80, 80, 85);
	-fx-border-color: rgb(0, 122, 205);
}
.check-box:pressed .box,
.button:pressed,
.combo-box:pressed,
.slider .thumb:pressed {
	-fx-background-color: rgb(0, 122, 205);
	-fx-border-color: rgb(0, 162, 245);
}
.combo-box:showing {
	-fx-background-color: rgb(27, 27, 28);
	-fx-border-width: 1 1 0 1;
	-fx-border-color: black;
}
.combo-box .combo-box-popup .list-cell {
	-fx-background-color: rgb(27, 27, 28);
}
.combo-box .combo-box-popup .list-cell:hover {
	-fx-background-color: rgb(61, 61, 62);
}
.combo-box .combo-box-popup .list-view {
	-fx-background-color: rgb(27, 27, 28);
	-fx-border-width: 0 1 1 1;
	-fx-border-color: black;
}
.hyperlink {
	-fx-text-fill: rgb(30, 132, 250);
}
hyperlink:visited {
	-fx-text-fill: rgb(98, 59, 217);
}
/* slider */
.slider .track {
	-fx-background-radius: 0;
	-fx-background-color: rgb(29, 29, 31);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(65, 65, 65);
}
.slider .thumb {
/*
	-fx-background-insets: 3;
	-fx-border-insets: 3;
	*/
	-fx-padding: 5;
}
.axis-tick-mark {
	-fx-stroke: rgb(100, 100, 100);
}
/* Text */
.text-area .content,
.text-field {
	-fx-background-radius: 0;
	-fx-background-color: rgb(63, 63, 70);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(85, 85, 85);
}
.text-area {
	-fx-background-radius: 0;
	-fx-background-color: rgb(63, 63, 70);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(85, 85, 85);
}
.text-area .content {
	-fx-border-width: 0;
}
/* Popup */
.tooltip {
	-fx-background-radius: 0;
	-fx-background-color: rgb(40, 40, 42);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(70, 70, 72);
}
/* =========================
 * ==   Attach Elements   ==
 * =========================
 */
.vm-view {
	-fx-border-width: 0 0 0 1;
	-fx-border-color: black;
}
.vm-buttons {
	-fx-padding: 1 0 1 0;
}
.vm-buttons .button {
	-fx-min-width: 140px;
	-fx-min-height: 48px;
}
.vm-icon {
	-fx-padding: 2 15 2 2;
}

/* =========================
 * ==   History Elements  ==
 * =========================
 */
.hist-view {
	-fx-border-width: 0 0 0 1;
	-fx-border-color: black;
}
.hist-buttons {
	-fx-padding: 1 0 1 0;
}
.hist-buttons .button {
	-fx-min-width: 140px;
	-fx-min-height: 48px;
}
.hist-icon {
	-fx-padding: 2 13 2 2;
}
/* =========================
 * ==    Other Elements   ==
 * =========================
 */
.faint {
	-fx-text-fill: rgb(134, 134, 135);
}
.search-button {
	-fx-background-image: url('../icons/find-light.png');
}
.search-field {
	-fx-prompt-text-fill: rgb(134, 134, 135);
	-fx-background-image: url('../icons/find-light.png');
	-fx-background-color: rgb(39, 39, 41);
	-fx-border-width: 1;
	-fx-border-insets: 0 0 -1 -1;
	-fx-border-color: black;
}
.resource-selector {
	-fx-prompt-text-fill: rgb(134, 134, 135);
	-fx-background-color: rgb(39, 39, 41);
	-fx-border-color: rgb(39, 39, 41) black black rgb(39, 39, 41);
	-fx-border-insets: 0 0 0 -1;
}
.resource-selector:hover {
	-fx-border-width: 1;
	-fx-border-insets: 0;
	-fx-padding: 0 0 0 -1;
}
.resource-selector:showing {
	-fx-border-color: black;
	-fx-border-insets: 0;
	-fx-border-width: 1 1 0 1;
	-fx-padding: 0 0 1 -1;
}
  /* Javadoc popup */
.drag-popup-wrapper {
	-fx-background-radius: 0;
	-fx-background-color: rgb(40, 40, 42);
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(95, 95, 95)
}
.drag-popup-wrapper .scroll-pane {
	-fx-background-insets: 0;
	-fx-border-width: 0;
	-fx-padding: 15;
}
.drag-popup-header {
	-fx-padding: 5;
	-fx-background-radius: 0;
	-fx-background-color: rgb(63, 63, 70);
	-fx-background-insets: 0;
	-fx-border-width: 0 0 1 0;
	-fx-border-color: rgb(95, 95, 95);
}
.update-header {
	-fx-padding: 5;
	-fx-background-color: rgb(32, 33, 35);
	-fx-border-width: 0 0 1 0;
	-fx-border-color: rgb(95, 95, 95);
}
.update-notes * {
	-fx-fill: rgb(220, 220, 220);
}
```

`src/main/resources/style/ui-default.css`:

```css
  /* Javadoc popup */
.doc-wrapper {
	-fx-background-radius: 0;
	-fx-background-color: white;
	-fx-background-insets: 0;
	-fx-border-width: 1;
	-fx-border-color: rgb(125, 125, 125);
}
.doc-wrapper .scroll-pane {
	-fx-background-insets: 0;
	-fx-border-width: 0;
	-fx-padding: 15;
}
.doc-header {
	-fx-padding: 5;
	-fx-background-radius: 0;
	-fx-background-color: rgb(230, 230, 235);
	-fx-background-insets: 0;
	-fx-border-width: 0 0 1 0;
	-fx-border-color: rgb(125, 125, 125);
}

/* Drag popup */
  .drag-popup-wrapper {
	  -fx-background-radius: 0;
	  -fx-background-color: white;
	  -fx-background-insets: 0;
	  -fx-border-width: 1;
	  -fx-border-color: rgb(125, 125, 125);
  }
  .drag-popup-wrapper .scroll-pane {
	  -fx-background-insets: 0;
	  -fx-border-width: 0;
	  -fx-padding: 15;
  }
  .drag-popup-header {
	  -fx-padding: 5;
	  -fx-background-radius: 0;
	  -fx-background-color: rgb(230, 230, 235);
	  -fx-background-insets: 0;
	  -fx-border-width: 0 0 1 0;
	  -fx-border-color: rgb(125, 125, 125);
  }
```

`src/main/resources/translations/en.json`:

```json
{
	"misc.add": "Add",
	"misc.save": "Save",
	"misc.load": "Load",
	"misc.remove": "Remove",
	"misc.edit": "Edit",
	"misc.duplicate": "Duplicate",
	"misc.rename": "Rename",
	"misc.error": "Error",
	"misc.errors": "Errors",
	"misc.access": "Access",
	"misc.yes": "Yes",
	"misc.no": "No",
	"misc.confirm": "Confirmation",
	"misc.confirm.message": "Are you sure?",
	"misc.enabled": "Enabled",
	"misc.open": "Open",
	"misc.select": "Select",
	"misc.firsttime.cli": "This is your first time using Recaf.\nIt is recommended you read the documentation before beginning.\n - Type 'y' to open the documentation.\n - Press <enter> to skip.",
	"misc.firsttime.gui": "This is your first time using Recaf.\nIt is recommended you read the documentation before beginning.\n - Press 'yes' to open the documentation.",
	"misc.firsttime.gui.title": "Welcome to Recaf",
	"ui.verify": "Verification failed",
	"ui.config": "Config",
	"ui.history": "History",
	"ui.history.pop": "Revert to last",
	"ui.history.open.class": "Open class",
	"ui.history.open.file": "Open file",
	"ui.info.logging": "Logging",
	"ui.info.other": "Other",
	"ui.attach": "Attach",
	"ui.attach.copy": "Copy to workspace",
	"ui.createjvm": "Create new JVM",
	"ui.noerrormsg": "No error message was specified",
	"ui.openissue": "Please report this exception if you believe this to be a bug",
	"ui.quitonattach.name": "Quit on attach",
	"ui.quitonattach.desc": "Close the current Recaf instance when the agent instance is loaded.",
	"ui.attach.prompt": "Select a virtual machine...",
	"ui.looaddrop.prompt": "Drop application [class/jar] to begin",
	"ui.load.resolve": "Resolving file path",
	"ui.load.initialize.resource": "Initializing resource type",
	"ui.load.initialize.workspace": "Initializing workspace",
	"ui.load.loading": "Loading resource content",
	"ui.load.srcdocs": "Loading sources and documentation",
	"ui.load.adddocs": "Add JavaDocs",
	"ui.load.addsrc": "Add sources",
	"ui.load.done": "Done",

	"ui.fileprompt.open": "Open file",
	"ui.fileprompt.open.extensions": "Java programs & workspaces",
	"ui.fileprompt.export": "Export file",
	"ui.fileprompt.export.extensions": "Java programs & archives",
	"ui.fileprompt.workspace": "Export workspace",
	"ui.fileprompt.workspace.extensions": "Recaf workspaces",
	"ui.fileprompt.mapping": "Select mappings",
	"ui.fileprompt.mapping.extensions": "Mappings",
	"ui.fileprompt.export.mapping": "Save mappings",
	"ui.fileprompt.export.mapping.extensions": "Simple mappings",

	"ui.menubar.file": "File",
	"ui.menubar.file.addlib": "Add library",
	"ui.menubar.file.newwizard": "New workspace",
	"ui.menubar.file.load": "Load",
	"ui.menubar.file.recent": "Load recent",
	"ui.menubar.file.saveapp": "Export program",
	"ui.menubar.file.saveworkspace": "Export workspace",
	"ui.menubar.file.agentexport": "Apply changes",
	"ui.menubar.mapping": "Mappings",
	"ui.menubar.mapping.apply": "Apply map file",
	"ui.menubar.mapping.export": "Export map file",
	"ui.menubar.config": "Config",
	"ui.menubar.themeeditor": "Theme editor",
	"ui.menubar.search": "Search",
	"ui.menubar.search.string": "Strings",
	"ui.menubar.search.value": "Values",
	"ui.menubar.search.cls_reference": "Class references",
	"ui.menubar.search.mem_reference": "Member references",
	"ui.menubar.search.declare": "Member declarations",
	"ui.menubar.search.insn": "Instructions",
	"ui.menubar.history": "History",
	"ui.menubar.history.new": "Create save state",
	"ui.menubar.history.view": "View states",
	"ui.menubar.attach": "Attach",
	"ui.menubar.attach.existing": "Running process",
	"ui.menubar.attach.create": "Create new process",
	"ui.menubar.plugins": "Plugins",
	"ui.menubar.plugins.manage": "Manage plugins",
	"ui.menubar.plugins.opendir": "Open plugins directory",
	"ui.menubar.help": "Help",
	"ui.menubar.help.about": "About",
	"ui.menubar.help.documentation": "Documentation",
	"ui.menubar.help.info": "System information",
	"ui.menubar.help.contact": "Contact",
	"ui.menubar.help.update": "Download update: ",
	"ui.edit.search": "Search references",
	"ui.edit.copypath": "Copy path",
	"ui.edit.tab.close": "Close",
	"ui.edit.tab.closeothers": "Close others",
	"ui.edit.tab.closeall": "Close all",
	"ui.edit.tab.classinfo": "Class",
	"ui.edit.tab.methods": "Methods",
	"ui.edit.tab.methods.access": "Access",
	"ui.edit.tab.methods.name": "Name",
	"ui.edit.tab.methods.return": "Return",
	"ui.edit.tab.methods.args": "Arguments",
	"ui.edit.tab.methods.index": "Index",
	"ui.edit.tab.fields": "Fields",
	"ui.edit.tab.fields.access": "Access",
	"ui.edit.tab.fields.name": "Name",
	"ui.edit.tab.fields.type": "Type",
	"ui.edit.tab.fields.index": "Index",
	"ui.edit.method.rename": "Rename",
	"ui.edit.method.follow": "Follow",
	"ui.edit.method.referrers": "Referrers",
	"ui.edit.method.goto": "Goto definition",
	"ui.edit.method.define": "Open definition",
	"ui.edit.method.editasm": "Edit with assembler",
	"ui.edit.method.assemblyfirsterror": "First error on line",
	"ui.edit.method.insertstandard": "Insert",
	"ui.edit.method.insertassembly": "Insert with assembler",
	"ui.edit.method.move.up": "Shift up",
	"ui.edit.method.move.down": "Shift down",
	"ui.edit.method.stackhelper": "Analysis",
	"ui.edit.method.stackhelper.stack": "Stack",
	"ui.edit.method.stackhelper.locals": "Locals",
	"ui.edit.method.stackhelper.colstackopcode": "Stack source instruction",
	"ui.edit.method.stackhelper.colstackvalue": "Value",
	"ui.edit.method.stackhelper.collocalopcode": "Local source instruction",
	"ui.edit.method.stackhelper.collocalvalue": "Value",
	"ui.edit.method.stackhelper.colindex": "Index",
	"ui.edit.method.stackhelper.title": "Stack/Locals: ",
	"ui.edit.method.block.title": "Blocks",
	"ui.edit.method.block.save": "Save as block",
	"ui.edit.method.block.load": "Insert block",
	"ui.edit.method.insert": "Insertion location",
	"ui.edit.method.insert.title": "Insert opcode: ",
	"ui.edit.method.insert.after": "After",
	"ui.edit.method.insert.before": "Before",

	"ui.search": "Search",
	"ui.search.string": "String",
	"ui.search.string.sub": "Content of the string",
	"ui.search.matchmode": "Match mode",
	"ui.search.matchmode.sub": "Method of string matching",
	"ui.search.value": "Value",
	"ui.search.value.sub": "Numeric value. Suffix D/F/L to for double/float/long",
	"ui.search.reference": "Reference",
	"ui.search.cls_reference.name": "Name",
	"ui.search.cls_reference.name.sub": "Class name",
	"ui.search.mem_reference.owner": "Owner",
	"ui.search.mem_reference.owner.sub": "Class name containing the definition",
	"ui.search.mem_reference.name": "Name",
	"ui.search.mem_reference.name.sub": "Member name",
	"ui.search.mem_reference.desc": "Descriptor",
	"ui.search.mem_reference.desc.sub": "Member type descriptor",
	"ui.search.declaration": "Declaration",
	"ui.search.declaration.owner": "Owner",
	"ui.search.declaration.owner.sub": "Class name containing the definition",
	"ui.search.declaration.name": "Name",
	"ui.search.declaration.name.sub": "Member name",
	"ui.search.declaration.desc": "Descriptor",
	"ui.search.declaration.desc.sub": "Member type descriptor",
	"ui.search.insn": "Instructions",
	"ui.search.insn.lines": "Text lines",
	"ui.search.insn.lines.sub": "Lines to match",
	"ui.search.skippackages": "Skipped packages",
	"ui.search.skippackages.sub": "Classes in these packages will not be searched",
	"ui.search.skippackages.empty": "No skipped packages",
	"ui.search.results.none": "No results",
	"ui.search.results.indexpre": "Result: ",

	"ui.about.system": "System",
	"ui.about.system.sub": "Information about the OS",
	"ui.about.java": "Java",
	"ui.about.java.sub": "Information about the JVM",
	"ui.about.javafx": "JavaFX",
	"ui.about.javafx.sub": "Information about the JavaFX UI",
	"ui.about.recaf": "Recaf",
	"ui.about.recaf.sub": "Information about Recaf",
	"ui.about.copy": "Copy information to clipboard",
	"ui.about.opendir": "Open Recaf directory",

	"ui.bean.class": "Class",
	"ui.bean.class.version.name": "Version",
	"ui.bean.class.version.desc": "Java version class was compiled with.",
	"ui.bean.class.access.name": "Access",
	"ui.bean.class.access.desc": "Access permissions such as public, private, static, etc.",
	"ui.bean.class.name.name": "Name",
	"ui.bean.class.name.desc": "Name of class.",
	"ui.bean.class.signature.name": "Signature",
	"ui.bean.class.signature.desc": "Generic type descriptor.",
	"ui.bean.class.supername.name": "Super name",
	"ui.bean.class.supername.desc": "Name of parent class",
	"ui.bean.class.sourcefile.name": "Source file.",
	"ui.bean.class.sourcefile.desc": "Name of source file class was written in.",
	"ui.bean.class.sourcedebug.name": "Source debug",
	"ui.bean.class.sourcedebug.desc": "Used to identify source language class was compiled from. Read JSR-045 for more information.",
	"ui.bean.class.outerclass.name": "Outer class",
	"ui.bean.class.outerclass.desc": "Name of outer class, the class this was written inside of in the source.",
	"ui.bean.class.outermethod.name": "Outer method",
	"ui.bean.class.outermethod.desc": "The name of the method that contains this class, or null if this class is not enclosed in a method.",
	"ui.bean.class.outermethoddesc.name": "Outer method desc",
	"ui.bean.class.outermethoddesc.desc": "The descriptor of the method that contains this class, or null if this class is not enclosed in a method.",
	"ui.bean.class.decompile.name": "Decompile",
	"ui.bean.class.decompile.desc": "Decompile bytecode into java source code",
	"ui.bean.class.recompile.name": "Recompile",
	"ui.bean.class.recompile.desc": "Recompile decompiled code",
	"ui.bean.class.recompile.unsupported": "// =============================================== //\n// Recompile disabled. Please run Recaf with a JDK //\n// =============================================== //\n\n",
	"ui.bean.class.annotations.title": "Annotations",
	"ui.bean.class.annotations.ref.tooltip": "Type reference",
	"ui.bean.class.annotations.desc.tooltip": "Annotation descriptor",
	"ui.bean.class.annotations.type.tooltip": "Annotation type-path",
	"ui.bean.class.visibleannotations.name": "Visible annotations",
	"ui.bean.class.visibleannotations.desc": "List of runtime applicable annotations for the class.",
	"ui.bean.class.invisibleannotations.name": "Invisible annotations",
	"ui.bean.class.invisibleannotations.desc": "List of applicable annotations for the class.",
	"ui.bean.class.visibletypeannotations.name": "Visible type annotations",
	"ui.bean.class.visibletypeannotations.desc": "List of applicable type-annotations for the class.",
	"ui.bean.class.invisibletypeannotations.name": "Invisible type annotations",
	"ui.bean.class.invisibletypeannotations.desc": "List of applicable type-annotations for the class.",
	"ui.bean.class.attrs.name": "Other attributes",
	"ui.bean.class.attrs.desc": "List of non-standard attributes.",
	"ui.bean.class.innerclasses.name": "Inner classes",
	"ui.bean.class.innerclasses.desc": "List of inner classes.",
	"ui.bean.class.innerclasses.name.tooltip": "The internal name of an inner class.",
	"ui.bean.class.innerclasses.inner.tooltip": "The simple name of the inner class inside its enclosing class. May be null for anonymous inner classes.",
	"ui.bean.class.innerclasses.outer.tooltip": "The internal name of the class to which the inner class belongs. May be null.",
	"ui.bean.class.fields.name": "Fields",
	"ui.bean.class.fields.desc": "List of fields.",
	"ui.bean.class.methods.name": "Methods",
	"ui.bean.class.methods.desc": "List of methods",
	"ui.bean.class.module.name": "Module",
	"ui.bean.class.module.desc": "missing_translation",
	"ui.bean.class.interfaces.name": "Interfaces",
	"ui.bean.class.interfaces.desc": "List of implemented interfaces.",
	"ui.bean.class.nesthostclass.name": "Nest host",
	"ui.bean.class.nesthostclass.desc": "The internal name of the nest host class of this class. May be null.",
	"ui.bean.class.nestmembers.name": "Nest members",
	"ui.bean.class.nestmembers.desc": "The internal names of the nest members of this class. May be null",
	
	"ui.bean.field": "Properties",
	"ui.bean.field.access.name": "Access",
	"ui.bean.field.access.desc": "Access permissions such as public, private, static, etc.",
	"ui.bean.field.name.name": "Name",
	"ui.bean.field.name.desc": "Name of field.",
	"ui.bean.field.desc.name": "Desc",
	"ui.bean.field.desc.desc": "Type descriptor of field.",
	"ui.bean.field.signature.name": "Signature",
	"ui.bean.field.signature.desc": "Generic type descriptor.",
	"ui.bean.field.value.name": "Value",
	"ui.bean.field.value.desc": "Value of this constant field.",
	"ui.bean.field.attrs.name": "Other attributes",
	"ui.bean.field.attrs.desc": "List of non-standard attributes.",
	"ui.bean.field.visibleannotations.name": "Visible annotations",
	"ui.bean.field.visibleannotations.desc": "List of runtime applicable annotations for the field.",
	"ui.bean.field.invisibleannotations.name": "Invisible annotations",
	"ui.bean.field.invisibleannotations.desc": "List of applicable annotations for the field. Not accessible via reflective APIS.",
	"ui.bean.field.visibletypeannotations.name": "Visible type annotations",
	"ui.bean.field.visibletypeannotations.desc": "List of applicable type-annotations for the field.",
	"ui.bean.field.invisibletypeannotations.name": "Invisible type annotations",
	"ui.bean.field.invisibletypeannotations.desc": "List of applicable type-annotations for the field. Not accessible via reflective APIS.",
	
	"ui.bean.method.access.name": "Access",
	"ui.bean.method.access.desc": "Access permissions such as public, private, static, etc.",
	"ui.bean.method.name.name": "Name",
	"ui.bean.method.name.desc": "Name of method.",
	"ui.bean.method.desc.name": "Desc",
	"ui.bean.method.desc.desc": "Type descriptor of method.",
	"ui.bean.method.signature.name": "Signature",
	"ui.bean.method.signature.desc": "Generic type descriptor.",
	"ui.bean.method.exceptions.name": "Exceptions",
	"ui.bean.method.exceptions.desc": "List of exceptions the method can potentially throw.",
	"ui.bean.method.parameters.name": "Parameters",
	"ui.bean.method.parameters.desc": "Parameter debug information such as names and types.",
	"ui.bean.method.annotationdefault.name": "Annotation default",
	"ui.bean.method.annotationdefault.desc": "missing_translation",
	"ui.bean.method.instructions.name": "Edit instructions",
	"ui.bean.method.instructions.desc": "Method opcodes containing execution logic.",
	"ui.bean.method.instructions.find.title": "Search",
	"ui.bean.method.instructions.find.confirm": "Confirm",
	"ui.bean.method.trycatchblocks.name": "Try-catches",
	"ui.bean.method.trycatchblocks.desc": "Try-catch block information.",
	"ui.bean.method.trycatchblocks.start": "Start",
	"ui.bean.method.trycatchblocks.end": "End",
	"ui.bean.method.trycatchblocks.handler": "Handler",
	"ui.bean.method.trycatchblocks.type": "Type",
	"ui.bean.method.trycatchblocks.start.tooltip": "Start of the try block.",
	"ui.bean.method.trycatchblocks.end.tooltip": "End of the try block.",
	"ui.bean.method.trycatchblocks.handler.tooltip": "Start of the catch block.",
	"ui.bean.method.trycatchblocks.type.tooltip": "Type of exception caught. Leave blank for any type.",
	"ui.bean.method.maxstack.name": "Max stack",
	"ui.bean.method.maxstack.desc": "Maximum number of items allowed in the stack in the methods code.",
	"ui.bean.method.maxlocals.name": "Max locals",
	"ui.bean.method.maxlocals.desc": "Maximum number of local variable indices.",
	"ui.bean.method.localvariables.name": "Locals",
	"ui.bean.method.localvariables.desc": "Local variable debugging information such as their type, name, etc.",
	"ui.bean.method.label.name": "Label",
	"ui.bean.method.localvariable.index": "Index",
	"ui.bean.method.localvariable.name": "Name",
	"ui.bean.method.localvariable.desc": "Descriptor",
	"ui.bean.method.localvariable.start": "Start",
	"ui.bean.method.localvariable.end": "End",
	"ui.bean.method.localvariable.index.tooltip": "Index in the local variable table to use.",
	"ui.bean.method.localvariable.name.tooltip": "Variable name.",
	"ui.bean.method.localvariables.desc.tooltip": "Variable type descriptor.",
	"ui.bean.method.localvariables.signature.tooltip": "Generic type descriptor.",
	"ui.bean.method.visibleannotations.name": "Visible annotations",
	"ui.bean.method.visibleannotations.desc": "List of runtime applicable annotations for the method.",
	"ui.bean.method.invisibleannotations.name": "Invisible annotations",
	"ui.bean.method.invisibleannotations.desc": "List of applicable annotations for the method. Not accessible via reflective APIS.",
	"ui.bean.method.visibletypeannotations.name": "Visible type annotations",
	"ui.bean.method.visibletypeannotations.desc": "List of applicable type-annotations for the method.",
	"ui.bean.method.invisibletypeannotations.name": "Invisible type annotations",
	"ui.bean.method.invisibletypeannotations.desc": "List of applicable type-annotations for the method. Not accessible via reflective APIS.",
	"ui.bean.method.visibleannotableparametercount.name": "Visible parameter count",
	"ui.bean.method.visibleannotableparametercount.desc": "The number of method parameters than can have runtime visible annotations.",
	"ui.bean.method.invisibleannotableparametercount.name": "Invisible parameter count",
	"ui.bean.method.invisibleannotableparametercount.desc": "The number of method parameters than can have runtime invisible annotations.",
	"ui.bean.method.visiblelocalvariableannotations.name": "Visible variable annotations",
	"ui.bean.method.visiblelocalvariableannotations.desc": "List of applicable type-annotations for the method's variables.",
	"ui.bean.method.invisiblelocalvariableannotations.name": "Invisible variable annotations",
	"ui.bean.method.invisiblelocalvariableannotations.desc": "List of applicable type-annotations for the method's variables. Not accessible via reflective APIS.",
	
	"ui.bean.insn.cst.desc": "Load constant's value. Can be any primitive or String.",
	"ui.bean.insn.cst.name": "Value",
	"ui.bean.insn.cst.type": "Value type",
	"ui.bean.insn.type.name": "Type",
	"ui.bean.insn.type.desc": "ASM Type",
	"ui.bean.insn.desc.desc": "Descriptor of the member.",
	"ui.bean.insn.desc.name": "Descriptor",
	"ui.bean.insn.opcode.name": "Opcode",
	"ui.bean.insn.opcode.desc": "Opcode to use, items shown are based on the type classified by ASM.",
	"ui.bean.insn.itf.desc": "Does the method belong to an interface class?",
	"ui.bean.insn.itf.name": "Interface",
	"ui.bean.insn.label.desc": "Label offset in the bytecode",
	"ui.bean.insn.label.name": "Label",
	"ui.bean.insn.label.nullvalue": "<Empty>",
	"ui.bean.insn.line.desc": "Line number this label value links to.",
	"ui.bean.insn.line.name": "Line",
	"ui.bean.insn.name.desc": "Name of the member.",
	"ui.bean.insn.name.name": "Name",
	"ui.bean.insn.owner.desc": "Owner (class) of the member.",
	"ui.bean.insn.owner.name": "Owner",
	"ui.bean.insn.operand.name": "Operand",
	"ui.bean.insn.operand.desc": "Value of the integer to push onto the stack.",
	"ui.bean.insn.start.desc": "Label indicating where the variable is defined.",
	"ui.bean.insn.start.name": "Start",
	"ui.bean.insn.value.desc": "Value",
	"ui.bean.insn.value.name": "Value",
	"ui.bean.insn.var.desc": "Points to a variable in the local variable table",
	"ui.bean.insn.var.name": "Variable Index",
	"ui.bean.insn.bsm.desc": "Boostrap Method",
	"ui.bean.insn.bsm.name": "Boostrap Method",
	"ui.bean.insn.bsmargs.desc": "Constants arguments, where the first is the Callsite information.",
	"ui.bean.insn.bsmargs.name": "Bootstrap Arguments",
	"ui.bean.insn.dflt.desc": "Location to jump to for fallback cases.",
	"ui.bean.insn.dflt.name": "Default label",
	"ui.bean.insn.keys.desc": "List of key.",
	"ui.bean.insn.keys.name": "Keys",
	"ui.bean.insn.labels.desc": "List of labels.",
	"ui.bean.insn.labels.name": "Labels",
	"ui.bean.insn.max.desc": "Maximum value for the case.",
	"ui.bean.insn.max.name": "Max",
	"ui.bean.insn.min.desc": "Minimum value for the case.",
	"ui.bean.insn.min.name": "Min",
	"ui.bean.insn.dims.name": "Dimensions",
	"ui.bean.insn.dims.desc": "Number of dimensions in the array.",
	"ui.bean.insn.incr.name": "Increment",
	"ui.bean.insn.incr.desc": "Value to increment variable by.",
	"ui.bean.handle.tag.name": "Tag",
	"ui.bean.handle.tag.desc": "Values indicating different opcodes",
	"ui.bean.handle.owner.name": "Owner",
	"ui.bean.handle.owner.desc": "Class that owns the member",
	"ui.bean.handle.name.name": "Name",
	"ui.bean.handle.name.desc": "Member name.",
	"ui.bean.handle.descriptor.name": "Desc",
	"ui.bean.handle.descriptor.desc": "Member descriptor",
	"ui.bean.handle.isInterface.name": "Is Interface",
	"ui.bean.handle.isInterface.desc": "Does the member belong to an interface",
	"ui.bean.bsmarg.tag.name": "Tag",
	"ui.bean.bsmarg.tag.desc": "Values indicating different opcodes",
	"ui.bean.bsmarg.owner.name": "Owner",
	"ui.bean.bsmarg.owner.desc": "Class that owns the member",
	"ui.bean.bsmarg.name.name": "Name",
	"ui.bean.bsmarg.name.desc": "Member descriptor",
	"ui.bean.bsmarg.descriptor.name": "Desc",
	"ui.bean.bsmarg.descriptor.desc": "Member descriptor",
	"ui.bean.bsmarg.isInterface.name": "Is Interface",
	"ui.bean.bsmarg.isInterface.desc": "Does the member belong to an interface",
	"ui.bean.bsmarg.type0.name": "Type arg[0]",
	"ui.bean.bsmarg.type0.desc": "Type descriptor of member",
	"ui.bean.bsmarg.type2.name": "Type arg[2]",
	"ui.bean.bsmarg.type2.desc": "Type descriptor of member",
	"ui.bean.typeannotation.reftype.classtypeparameter": "Class Type Parameter",
	"ui.bean.typeannotation.reftype.methodtypeparameter": "Method Type Parameter",
	"ui.bean.typeannotation.reftype.classextends": "Class Extends",
	"ui.bean.typeannotation.reftype.classtypeparameterbound": "Class Type Parameter Bound",
	"ui.bean.typeannotation.reftype.methodtypeparameterbound": "Method Type Parameter Bound",
	"ui.bean.typeannotation.reftype.field": "Field",
	"ui.bean.typeannotation.reftype.methodreturn": "Method Return",
	"ui.bean.typeannotation.reftype.methodreceiver": "Method Receiver",
	"ui.bean.typeannotation.reftype.methodformalparameter": "Method Formal Parameter",
	"ui.bean.typeannotation.reftype.throws": "Throws",
	"ui.bean.typeannotation.reftype.localvariable": "Local Variable",
	"ui.bean.typeannotation.reftype.resourcevariable": "Resource Variable",
	"ui.bean.typeannotation.reftype.exceptionparameter": "Exception Parameter",
	"ui.bean.typeannotation.reftype.instanceof": "Instanceof",
	"ui.bean.typeannotation.reftype.new": "New",
	"ui.bean.typeannotation.reftype.constructorreference": "Constructor Reference",
	"ui.bean.typeannotation.reftype.methodreference": "Method Reference",
	"ui.bean.typeannotation.reftype.cast": "Cast",
	"ui.bean.typeannotation.reftype.constructorinvocationtypeargument": "Constructor Invocation Type Argument",
	"ui.bean.typeannotation.reftype.methodinvocationtypeargument": "Method Invocation Type Argument",
	"ui.bean.typeannotation.reftype.constructorreferencetypeargument": "Constructor Reference Type Argument",
	"ui.bean.typeannotation.reftype.methodreferencetypeargument": "Method Reference Type Argument",
	"ui.bean.typeannotation.reftype.unknown": "Unknown",

	"update": "Updates",
	"update.available": "An update is available.",
	"update.fail.resolve": "Could not resolve path to executable self.",
	"update.fail.jarread": "Could not read contents of pom.xml from self-jar.",
	"update.fail.nodownload": "Recaf is outdated, but the download url could not be found.",
	"update.fail.unknown": "Update check failed for reason: ",
	"update.outdated": "Recaf is outdated",
	"update.complete": "Update complete, please run the new version.",
	"update.updated": "Update check complete: No updates available",
	"update.consent": "Updating adds new features and fixes bugs. Press \"Download\" to download and run the updated version.",
	"update.download": "Download",
	"update.active.name": "Allow update checking",
	"update.active.desc": "If disabled, you will not be notified of new versions.",
	"update.lastcheck.name": "Last check",
	"update.lastcheck.desc": "Last time since checking for updates.",
	"update.frequency.name": "Frequency",
	"update.frequency.desc": "Minimum time between checks.",
	"update.frequency.always": "Always",
	"update.frequency.daily": "Daily",
	"update.frequency.weekly": "Weekly",

	"asm": "ASM - Bytecode",
	"asm.version.name": "Version",
	"asm.version.desc": "ASM library version to use.",
	"asm.out.computemaxs.name": "Compute maxs",
	"asm.out.computemaxs.desc": "Force ASM to compute max stack/local-table sizes.",
	"asm.out.computeframes.name": "Compute frames",
	"asm.out.computeframes.desc": "Force ASM to compute stack frames.",
	"asm.out.reflectionexport.name": "Reflection export",
	"asm.out.reflectionexport.desc": "Allow export process to lookup missing classes from runtime.",
	"asm.in.skipcode.name": "Skip Code",
	"asm.in.skipcode.desc": "Force ASM to skip method code.",
	"asm.in.skipdebug.name": "Skip Debug",
	"asm.in.skipdebug.desc": "Force ASM to skip debug information like variable names",
	"asm.in.skipframes.name": "Skip Frames",
	"asm.in.skipframes.desc": "Force ASM to skip existing stack-frames when loading a new input.",
	"asm.in.expandframes.name": "Expand Frames",
	"asm.in.expandframes.desc": "Force ASM to expand existing stack-frames into a common format.",
	"asm.edit.verify.name": "Verify",
	"asm.edit.verify.desc": "When edits create invalid bytecode, highlight the editor window. Also prevent exporting until verification passes modified classes.",
	"asm.edit.linkedmethods.name": "Linked method renaming",
	"asm.edit.linkedmethods.desc": "When renaming methods, rename all child and parent declarations too.",
	"asm.edit.locklibmethods.name": "Lock linked library names",
	"asm.edit.locklibmethods.desc": "Disallow renaming of known library methods. Requires linked method renaming to be active.",
	"asm.edit.locklibmethods.locked": "Method extends library method and has been locked to prevent accidental renaming.",

	"display": "Display",
	"display.simplify.name": "Simplify type descriptors",
	"display.simplify.desc": "Hides package names for type descriptors.",
	"display.jumphelp.name": "Inline jump help",
	"display.jumphelp.desc": "Shows opcode-specific jump logic in opcodes",
	"display.topmost.name": "Top-most editor windows",
	"display.topmost.desc": "When editing a value, keep the window as topmost.",
	"display.language.name": "Language",
	"display.language.desc": "Language to translate UI components into.",
	"display.appstyle.name": "Window style",
	"display.appstyle.desc": "Visual theme to style windows with.",
	"display.textstyle.name": "Text style",
	"display.textstyle.desc": "Visual theme to style text editors with.",
	"display.loglevel.name": "Log level",
	"display.loglevel.desc": "Level of logging to display in console.",
	"display.buttonbar.name": "Show button bar",
	"display.buttonbar.desc": "Show the easy-access button-bar in the UI. Restart to apply changes.",
	"display.maxlength.tree.name": "Max tree name length",
	"display.maxlength.tree.desc": "The max length of names in the file tree. Useful for obfuscated assemblies with crazy names.",
	"display.maxtreedepth.name": "Max tree directory depth",
	"display.maxtreedepth.desc": "The max number of directories to show in the file tree before truncation.",
	"display.accessflags.name" : "Access Flags tooltip",
	"display.accessflags.desc" : "Displays a tooltip when hovering over access icons",
	"display.treesourcename.name": "Show SourceFile names",
	"display.treesourcename.desc": "Display classes SourceFile next to their declared names in the file-tree.",
	"display.exitwarning.name": "Give save prompt on exit",
	"display.exitwarning.desc": "When Recaf is closed with ask if the current project should be saved.",
	"display.exitwarning.title": "Save before closing?",
	"display.exitwarning.message": "Do you wish to save your work before closing?",
	"display.classmode.name": "Class Mode",
	"display.classmode.desc": "Editor mode for classes",
	"display.filemode.name": "File Mode",
	"display.filemode.desc": "Editor mode for non-classes",
	"display.uifontsize.name": "UI Font Size",
	"display.uifontsize.desc": "Font size for any non monospaced text in pixels",
	"display.monofontsize.name": "Monospaced Font Size",
	"display.monofontsize.desc": "Font size for monospaced text in pixels",
	"display.uifont.name": "UI Font",
	"display.uifont.desc": "Font to use for non monospaced text",
	"display.monofont.name": "Monospace Font",
	"display.monofont.desc": "Font to use for monospaced text",
	"display.forceWordWrap.name": "Word wrap",
	"display.forceWordWrap.desc": "Force word wrap in all text editors",
	"display.suggest.classerrors.name": "Display error suggestions",
	"display.suggest.classerrors.desc": "Show suggestion popups when certain errors occur",
	"display.maxrecent.name": "Max recent files",
	"display.maxrecent.desc": "How many items to show in recent files menu.",
	"display.usesystemmenubar.name": "System menubar",
	"display.usesystemmenubar.desc": "Use system menubar on macOS.",

	"binding": "Keybinds",
	"binding.inputprompt.initial": " <waiting>",
	"binding.inputprompt.finish": " <ENTER to finish>",
	"binding.close.window.name": "Close window",
	"binding.close.window.desc": "Closes the current active window.",
	"binding.close.tab.name": "Close tab",
	"binding.close.tab.desc": "Closes the current active tab.",
	"binding.saveapp.name": "Save application",
	"binding.saveapp.desc": "Save the application to a file.",
	"binding.save.name": "Save changes",
	"binding.save.desc": "Apply changes in the current editor viewport.",
	"binding.undo.name": "Undo change",
	"binding.undo.desc": "Undo the most recent change in the current editor viewport.",
	"binding.find.name": "Find",
	"binding.find.desc": "Open find search menu.",
	"binding.rename.name": "Rename",
	"binding.rename.desc": "Rename the selected class/member.",
	"binding.gotodef.name": "Goto definition",
	"binding.gotodef.desc": "Jump to the definition of the selected item.",
	"binding.swapview.name": "Swap view",
	"binding.swapview.desc": "Swaps your view to the next available viewport type.",
	"binding.incfontsize.name": "Increase editor font size",
	"binding.incfontsize.desc": "Increases the editor's font size.",
	"binding.decfontsize.name": "Decrease editor font size",
	"binding.decfontsize.desc": "Decreases the editor's font size.",

	"backend": "Backend / Private",

	"decompile": "Decompile",
	"decompile.decompiler.name": "Decompiler",
	"decompile.decompiler.desc": "The decompiler engine to use",
	"decompile.showsynthetics.name": "Show synthetics",
	"decompile.showsynthetics.desc": "Show compiler-generated code",
	"decompile.stripdebug.name": "Strip debug",
	"decompile.stripdebug.desc": "Strip debug info before decompiling.",
	"decompile.showname.name": "Show name",
	"decompile.showname.desc": "Include comment showing current decompiler/version",
	"decompile.timeout.name": "Timeout",
	"decompile.timeout.desc": "Time in millis to wait before aborting decompile processes",
	"decompile.fail": "Decompile failed. You can change decompilers in the config menu.",

	"assembler": "Assembler",
	"assembler.verify.name": "Verify",
	"assembler.verify.desc": "Verify method bytecode. This also allows better variable type analysis.",
	"assembler.variables.name": "Variables",
	"assembler.variables.desc": "Save variable debug information after assembling.",
	"assembler.useexistingdata.name": "Use existing data",
	"assembler.useexistingdata.desc": "Use existing variable information instead of recalculating indices and types.",
	"assembler.stripdebug.name": "Strip debug",
	"assembler.stripdebug.desc": "Strip debug info before disassembling, removing variable names.",
	"assembler.phantoms.name": "Generate missing classes",
	"assembler.phantoms.desc": "Try to generate missing code, skipping the need to add libraries.",

	"suggest.decompile.warn.title": "Decompile has errors",
	"suggest.decompile.warn": "The current decompiler's output has some problems in it.\nThis will disable interaction in the class.\nWould you like to switch to another decompiler?",
	"suggest.decompile.timeout.title": "Decompile timed out",
	"suggest.decompile.timeout": "The current decompiler took too long and was terminated.\nWould you like to switch to another decompiler?",
	"suggest.decompile.failure.title": "Decompiler crash",
	"suggest.decompile.failure": "The current decompiler crashed.\nWould you like to switch to another decompiler?",
	"suggest.switchmodes": "The class view-mode can also be changed:",

	"cfr": "CFR Decompiler",
	"cfr.aexagg.desc": "Remove nested exception handlers if they don't change semantics",
	"cfr.aexagg.name": "Aggressive exception optimization",
	"cfr.aggressivesizethreshold.desc": "Opcode count at which to trigger aggressive reductions",
	"cfr.aggressivesizethreshold.name": "Aggressive threshold",
	"cfr.allowcorrecting.desc": "Allow transformations which correct errors, potentially at the cost of altering emitted code behaviour.",
	"cfr.allowcorrecting.name": "Allow correcting",
	"cfr.arrayiter.desc": "Re-sugar array based iteration.",
	"cfr.arrayiter.name": "Array iteration",
	"cfr.collectioniter.desc": "Re-sugar collection based iteration.",
	"cfr.collectioniter.name": "Collection iteration",
	"cfr.commentmonitors.desc": "Replace monitors with comments - useful if we're completely confused.",
	"cfr.commentmonitors.name": "Comment monitors",
	"cfr.comments.desc": "Output comments describing decompiler status, fallback flags etc.",
	"cfr.comments.name": "Comment info",
	"cfr.decodeenumswitch.desc": "Re-sugar switch on enum",
	"cfr.decodeenumswitch.name": "Decode enum-switch",
	"cfr.decodefinally.desc": "Re-sugar finally statements",
	"cfr.decodefinally.name": "Decode finally",
	"cfr.decodelambdas.desc": "Re-build lambda functions",
	"cfr.decodelambdas.name": "Decode lambdas",
	"cfr.decodestringswitch.desc": "Re-sugar switch on String",
	"cfr.decodestringswitch.name": "Decode string-switch",
	"cfr.dumpclasspath.desc": "Dump class path for debugging purposes",
	"cfr.dumpclasspath.name": "Dump class path",
	"cfr.eclipse.desc": "Enable transformations to handle eclipse code better.",
	"cfr.eclipse.name": "Eclipse",
	"cfr.elidescala.desc": "Hide things which aren't helpful in scala output (serialVersionUID, @ScalaSignature).",
	"cfr.elidescala.name": "Clean Scala",
	"cfr.forcecondpropagate.desc": "Pull results of deterministic jumps back through some constant assignments.",
	"cfr.forcecondpropagate.name": "Force condition propagation",
	"cfr.forceexceptionprune.desc": "Try to extend and merge exceptions more aggressively.",
	"cfr.forceexceptionprune.name": "Force exception pruning",
	"cfr.forcereturningifs.desc": "Move return up to jump site.",
	"cfr.forcereturningifs.name": "Force returning ifs",
	"cfr.forcetopsort.desc": "Force basic block sorting. Useful for flow-obfuscated code.",
	"cfr.forcetopsort.name": "Force top-sort",
	"cfr.forcetopsortaggress.desc": "Force extra aggressive topsort options.",
	"cfr.forcetopsortaggress.name": "Force top-sort:aggressive",
	"cfr.forloopaggcapture.desc": "Allow for loops to aggresively roll mutations into update section, even if they don't appear to be involved with the predicate",
	"cfr.forloopaggcapture.name": "For-loop capturing",
	"cfr.hidebridgemethods.desc": "Hide methods with bridge access",
	"cfr.hidebridgemethods.name": "Hide bridge methods",
	"cfr.hidelangimports.desc": "Hide imports from java.lang.*",
	"cfr.hidelangimports.name": "Hide lang imports",
	"cfr.hidelongstrings.desc": "Hide very long strings - useful if obfuscators have placed fake code in strings",
	"cfr.hidelongstrings.name": "Hide long strings",
	"cfr.hideutf.desc": "Hide UTF8 characters - quote them instead of showing the raw characters",
	"cfr.hideutf.name": "Hide UTF8",
	"cfr.innerclasses.desc": "Include inner classes in decompilation of outer-class.",
	"cfr.innerclasses.name": "Decompile inner classes",
	"cfr.j14classobj.desc": "Reverse Java 1.4 class object construction",
	"cfr.j14classobj.name": "Java 1.4 class object",
	"cfr.labelledblocks.desc": "Allow code to be emitted which uses labelled blocks, (handling odd forward gotos).",
	"cfr.labelledblocks.name": "Labelled blocks",
	"cfr.lenient.desc": "Be a bit more lenient in situations where we'd normally throw an exception",
	"cfr.lenient.name": "Lenient",
	"cfr.liftconstructorinit.desc": "Lift initialisation code common to all constructors into member initialisation",
	"cfr.liftconstructorinit.name": "Lift constructor init",
	"cfr.override.desc": "Generate @Override annotations (if method is seen to implement interface method, or override a base class method)",
	"cfr.override.name": "Emit @Override",
	"cfr.pullcodecase.desc": "Pull code into case statements aggressively.",
	"cfr.pullcodecase.name": "Pull code case",
	"cfr.recover.desc": "Allow more and more aggressive options to be set if decompilation fails",
	"cfr.recover.name": "Recover",
	"cfr.recovertypeclash.desc": "Split lifetimes where analysis caused type clash",
	"cfr.recovertypeclash.name": "Recover type clash",
	"cfr.recovertypehints.desc": "Recover type hints for iterators from first pass.",
	"cfr.recovertypehints.name": "Recover type hints",
	"cfr.recpass.desc": "Decompile specifically with recovery options from pass #X. (really only useful for debugging)",
	"cfr.recpass.name": "Recpass",
	"cfr.relinkconststring.desc": "Relink constant strings - if there is a local reference to a string which matches a static final, use the static final.",
	"cfr.relinkconststring.name": "Relink const-strings",
	"cfr.removebadgenerics.desc": "Hide generics where we've obviously got it wrong, and fallback to non-generic",
	"cfr.removebadgenerics.name": "Hide bad generics",
	"cfr.removeboilerplate.desc": "Remove boilerplate functions - constructor boilerplate, lambda deserialization etc",
	"cfr.removeboilerplate.name": "Remove boilerplate",
	"cfr.removedeadmethods.desc": "Remove pointless methods - default constructor etc",
	"cfr.removedeadmethods.name": "Remove unused methods",
	"cfr.removeinnerclasssynthetics.desc": "Remove (where possible) implicit outer class references in inner classes",
	"cfr.removeinnerclasssynthetics.name": "Remove inner class synthetics",
	"cfr.renamedupmembers.desc": "Rename ambiguous/duplicate members.",
	"cfr.renamedupmembers.name": "Rename duplicate members",
	"cfr.renameenumidents.desc": "Rename ENUM identifiers which do not match their 'expected' string names.",
	"cfr.renameenumidents.name": "Rename enum identifiers",
	"cfr.renameillegalidents.desc": "Rename identifiers which are not valid java identifiers.",
	"cfr.renameillegalidents.name": "Rename illegal identifiers",
	"cfr.renamesmallmembers.desc": "Rename small members. Useful for proguard-like obfuscation.",
	"cfr.renamesmallmembers.name": "Rename small members",
	"cfr.showinferrable.desc": "Decorate methods with explicit types if not implied by arguments.",
	"cfr.showinferrable.name": "Show inferrable",
	"cfr.showops.desc": "Show some (cryptic!) debug info.",
	"cfr.showops.name": "Show OPs",
	"cfr.showversion.desc": "Show CFR version used in header",
	"cfr.showversion.name": "Show version",
	"cfr.silent.desc": "Don't display state while decompiling",
	"cfr.silent.name": "Silent",
	"cfr.staticinitreturn.desc": "Try to remove return from static init",
	"cfr.staticinitreturn.name": "Static init return",
	"cfr.stringbuffer.desc": "Convert new Stringbuffer().add.add.add to string + string + string",
	"cfr.stringbuffer.name": "Clean StringBuffer",
	"cfr.stringbuilder.desc": "Convert new Stringbuilder().add.add.add to string + string + string",
	"cfr.stringbuilder.name": "Clean StringBuilder",
	"cfr.stringconcat.desc": "Convert usages of StringConcatFactor to string + string + string",
	"cfr.stringconcat.name": "Deinfigy string concat",
	"cfr.sugarasserts.desc": "Re-sugar assert calls",
	"cfr.sugarasserts.name": "Sugar asserts",
	"cfr.sugarboxing.desc": "Where possible, remove pointless boxing wrappers",
	"cfr.sugarboxing.name": "Sugar boxing",
	"cfr.sugarenums.desc": "Re-sugar enums",
	"cfr.sugarenums.name": "Sugar enums",
	"cfr.switchexpression.desc": "Java 13 switch as expressions, where switches return values.",
	"cfr.switchexpression.name": "Switch expressions",
	"cfr.tidymonitors.desc": "Remove support code for monitors - eg catch blocks just to exit a monitor",
	"cfr.tidymonitors.name": "Tidy monitors",
	"cfr.tryresources.desc": "When active attempt to display try-catch blocks as try-with-resource blocks.",
	"cfr.tryresources.name": "Use try-with-resource",
	"cfr.usenametable.desc": "Use local variable name table if present.",
	"cfr.usenametable.name": "Use name table"
}
```

`src/main/resources/translations/fr.json`:

```json
{
	"misc.add": "Ajouter",
	"misc.save": "Sauvegarder",
	"misc.load": "Charger",
	"misc.remove": "Supprimer",
	"misc.edit": "Modifier",
	"misc.duplicate": "Dupliquer",
	"misc.rename": "Renommer",
	"misc.error": "Erreur",
	"misc.errors": "Erreurs",
	"misc.access": "Accéder",
	"misc.yes": "Oui",
	"misc.no": "Non",
	"misc.confirm": "Confirmation",
	"misc.confirm.message": "Êtes vous sûr(e) ?",
	"misc.enabled": "Activé",
	"misc.open": "Ouvrir",
	"misc.firsttime.cli": "Ceci est la première fois que vous utilisez Recaf.\nIl vous est recommandé de lire la documentation avant de commencer.\nAppuyez sur 'y' pour ouvrir la documentation.\n - Appuyez sur <entrée> pour passer.",
	"misc.firsttime.gui": "Ceci est la première fois que vous utilisez Recaf.\nIl vous est recommandé de lire la documentation avant de commencer.\nAppuyez sur 'ok' pour ouvrir la documentation.",
	"misc.firsttime.gui.title": "Bienvenue dans Recaf",
	"ui.verify": "Vérification échouée",
	"ui.config": "Configuration",
	"ui.history": "Historique",
	"ui.history.pop": "Revenir à la dernière modification",
	"ui.history.open.class": "Ouvrir une classe",
	"ui.history.open.file": "Ouvrir un fichier",
	"ui.info.logging": "Logging",
	"ui.info.other": "Autre",
	"ui.attach": "Attacher",
	"ui.attach.copy": "Copier dans l'espace de travail",
	"ui.noerrormsg": "Aucun message d'erreur n'a été spécifié",
	"ui.openissue": "Signalez s'il vous plait cette exception si vous pensez que c'est un bogue",
	"ui.quitonattach.name": "Quitter à l'attachement",
	"ui.quitonattach.desc": "Fermer l'instance courante de Recaf quand l'instance d'agent est chargée.",
	"ui.attach.prompt": "Sélectionnez une machine virtuelle...",
	"ui.looaddrop.prompt": "Déposez un élément [classe/jar]",
	"ui.load.resolve": "Résolution du chemin de fichier",
	"ui.load.initialize.resource": "Initialisation du type de ressource",
	"ui.load.initialize.workspace": "Initialisation de l'espace de travail",
	"ui.load.loading": "Chargement du contenu des ressources",
	"ui.load.srcdocs": "Chargement des sources et documentation",
	"ui.load.adddocs": "Ajouter de la JavaDoc",
	"ui.load.addsrc": "Ajouter des sources",
	"ui.load.done": "Terminé",

	"ui.fileprompt.open": "Ouvrir un fichier",
	"ui.fileprompt.open.extensions": "Programmes & espaces de travail Java",
	"ui.fileprompt.export": "Exporter un fichier",
	"ui.fileprompt.export.extensions": "Programmes et archives Java",
	"ui.fileprompt.workspace": "Exporter l'espace de travail",
	"ui.fileprompt.workspace.extensions": "Espaces de travail Recaf",
	"ui.fileprompt.mapping": "Sélectionner des mappings",
	"ui.fileprompt.mapping.extensions": "Mappings",

	"ui.menubar.file": "Fichier",
	"ui.menubar.file.addlib": "Ajouter une librairie",
	"ui.menubar.file.newwizard": "Nouvel espace de travail",
	"ui.menubar.file.load": "Ouvrir",
	"ui.menubar.file.recent": "Ouvrir un élément récent",
	"ui.menubar.file.saveapp": "Exporter le programme",
	"ui.menubar.file.saveworkspace": "Exporter l'espace de travail",
	"ui.menubar.file.closeall": "Tout fermer",
	"ui.menubar.file.agentexport": "Appliquer les changements",
	"ui.menubar.mapping": "Mappings",
	"ui.menubar.mapping.apply": "Appliquer un fichier de mapping",
	"ui.menubar.config": "Configuration",
	"ui.menubar.themeeditor": "Éditeur de thème",
	"ui.menubar.search": "Rechercher",
	"ui.menubar.search.string": "Chaîne de caractères",
	"ui.menubar.search.value": "Valeur",
	"ui.menubar.search.cls_reference": "Références de classe",
	"ui.menubar.search.mem_reference": "Références de membre",
	"ui.menubar.search.declare": "Déclaration de membre",
	"ui.menubar.search.insn": "Instruction",
	"ui.menubar.history": "Historique",
	"ui.menubar.history.new": "Créer un état de sauvegarde",
	"ui.menubar.history.view": "Visualiser les états",
	"ui.menubar.attach": "Attacher",
	"ui.menubar.plugins": "Modules complémentaires",
	"ui.menubar.plugins.manage": "Gérer les modules complémentaires",
	"ui.menubar.plugins.opendir": "Ouvrir le répertoire des modules complémentaires",
	"ui.menubar.help": "Aide",
	"ui.menubar.help.about": "À propos",
	"ui.menubar.help.documentation": "Documentation",
	"ui.menubar.help.info": "Informations système",
	"ui.menubar.help.contact": "Contact",
	"ui.menubar.help.update": "Télécharger la mise à jour : ",
	"ui.edit.search": "Rechercher des références",
	"ui.edit.copypath": "Copier le chemin",
	"ui.edit.tab.close": "Fermer",
	"ui.edit.tab.closeothers": "Fermer les autres",
	"ui.edit.tab.closeall": "Tout fermer",
	"ui.edit.tab.classinfo": "Information de la classe",
	"ui.edit.tab.methods": "Méthodes",
	"ui.edit.tab.methods.access": "Visibilité",
	"ui.edit.tab.methods.name": "Nom",
	"ui.edit.tab.methods.return": "Retours",
	"ui.edit.tab.methods.args": "Paramètres",
	"ui.edit.tab.methods.index": "Index",
	"ui.edit.tab.fields": "Champs",
	"ui.edit.tab.fields.access": "Visibilité",
	"ui.edit.tab.fields.name": "Nom",
	"ui.edit.tab.fields.type": "Type",
	"ui.edit.tab.fields.index": "Index",
	"ui.edit.method.rename": "Renommer",
	"ui.edit.method.follow": "Suivre",
	"ui.edit.method.referrers": "Référents",
	"ui.edit.method.goto": "Accéder à la définition",
	"ui.edit.method.define": "Ouvrir la définition",
	"ui.edit.method.editasm": "Éditer en assembleur",
	"ui.edit.method.assemblyfirsterror": "Première erreur sur la ligne",
	"ui.edit.method.insertstandard": "Insérer",
	"ui.edit.method.insertassembly": "Insérer en assembleur",
	"ui.edit.method.move.up": "Déplacer vers le haut",
	"ui.edit.method.move.down": "Déplacer vers le bas",
	"ui.edit.method.stackhelper": "Analyse",
	"ui.edit.method.stackhelper.stack": "Pile",
	"ui.edit.method.stackhelper.locals": "Variables locales",
	"ui.edit.method.stackhelper.colstackopcode": "Source d'instruction sur la pile",
	"ui.edit.method.stackhelper.colstackvalue": "Valeur",
	"ui.edit.method.stackhelper.collocalopcode": "Source d'instruction de la variable locale",
	"ui.edit.method.stackhelper.collocalvalue": "Valeur",
	"ui.edit.method.stackhelper.colindex": "Index",
	"ui.edit.method.stackhelper.title": "Pile/Variable locale : ",
	"ui.edit.method.block.title": "Blocs",
	"ui.edit.method.block.save": "Sauvegarder en tant que bloc",
	"ui.edit.method.block.load": "Insérer un bloc",
	"ui.edit.method.insert": "Emplacement de l'insertion",
	"ui.edit.method.insert.title": "Insérer un opcode : ",
	"ui.edit.method.insert.after": "Après",
	"ui.edit.method.insert.before": "Avant",

	"ui.search": "Rechercher",
	"ui.search.string": "Chaîne de caractères",
	"ui.search.string.sub": "Contenu de la chaîne de caractères",
	"ui.search.matchmode": "Mode de correspondance",
	"ui.search.matchmode.sub": "Méthode de correspondance de chaîne de caractère",
	"ui.search.value": "Valeur",
	"ui.search.value.sub": "Valeur numérique. Suffixes D/F/L pour double/float/long",
	"ui.search.reference": "Référence",
	"ui.search.cls_reference.name": "Nom",
	"ui.search.cls_reference.name.sub": "Nom de classe",
	"ui.search.mem_reference.owner": "Propriétaire",
	"ui.search.mem_reference.owner.sub": "Nom de la classe contenant la définition",
	"ui.search.mem_reference.name": "Nom",
	"ui.search.mem_reference.name.sub": "Nom du membre",
	"ui.search.mem_reference.desc": "Descripteur",
	"ui.search.mem_reference.desc.sub": "Descripteur du type de membre",
	"ui.search.declaration": "Déclaration",
	"ui.search.declaration.owner": "Propriétaire",
	"ui.search.declaration.owner.sub": "Nom de la classe contenant la définition",
	"ui.search.declaration.name": "Nom",
	"ui.search.declaration.name.sub": "Nom du membre",
	"ui.search.declaration.desc": "Descripteur",
	"ui.search.declaration.desc.sub": "Descripteur du type de membre",
	"ui.search.insn": "Instructions",
	"ui.search.insn.lines": "Lignes de texte",
	"ui.search.insn.lines.sub": "Lignes à correspondre",
	"ui.search.skippackages": "Packages ignorés",
	"ui.search.skippackages.sub": "Les classes dans ces packages seront ignorées",
	"ui.search.skippackages.empty": "Aucun package ignoré",
	"ui.search.results.none": "Aucun résultat",
	"ui.search.results.indexpre": "Résultat : ",

	"ui.about.system": "Système",
	"ui.about.system.sub": "Informations sur le système d'exploitation",
	"ui.about.java": "Java",
	"ui.about.java.sub": "Informations sur la JVM",
	"ui.about.javafx": "JavaFX",
	"ui.about.javafx.sub": "Informations sur JavaFX UI",
	"ui.about.recaf": "Recaf",
	"ui.about.recaf.sub": "Informations sur Recaf",
	"ui.about.copy": "Copier les informations dans le presse papier",
	"ui.about.opendir": "Ouvrir le répertoire Recaf",

	"ui.bean.class": "Propriétés",
	"ui.bean.class.extended": "Propriétés étendues",
	"ui.bean.class.version.name": "Version",
	"ui.bean.class.version.desc": "Version de Java avec laquelle cette classe a été compilée.",
	"ui.bean.class.access.name": "Visibilité",
	"ui.bean.class.access.desc": "Visibilité comme public, private, static, etc.",
	"ui.bean.class.name.name": "Nom",
	"ui.bean.class.name.desc": "Nom de la classe.",
	"ui.bean.class.signature.name": "Signature",
	"ui.bean.class.signature.desc": "Descripteur de type générique.",
	"ui.bean.class.supername.name": "Classe parente",
	"ui.bean.class.supername.desc": "Nom de la classe parente",
	"ui.bean.class.sourcefile.name": "Fichier source.",
	"ui.bean.class.sourcefile.desc": "Nom du fichier source contenant cette classe.",
	"ui.bean.class.sourcedebug.name": "Débogage de source",
	"ui.bean.class.sourcedebug.desc": "Sert à l'identification du langage du code source d'origine. Lisez la JSR-045 pour plus d'informations.",
	"ui.bean.class.outerclass.name": "Classe Externe",
	"ui.bean.class.outerclass.desc": "Nom de la classe externe, la classe dans la quelle celle-ci est contenue dans le code source.",
	"ui.bean.class.outermethod.name": "Méthode externe",
	"ui.bean.class.outermethod.desc": "Le nom de la méthode qui contient cette classe, ou null si celle-ci n'est pas dans une méthode.",
	"ui.bean.class.outermethoddesc.name": "Descripteur de la méthode externe",
	"ui.bean.class.outermethoddesc.desc": "Le descripteur de la méthode qui contient cette classe, ou null si celle-ci n'est pas dans une méthode.",
	"ui.bean.class.decompile.name": "Décompilation",
	"ui.bean.class.decompile.desc": "Décompiler le bytecode vers du code source Java",
	"ui.bean.class.recompile.name": "Recompilation",
	"ui.bean.class.recompile.desc": "Recompile le code source décompilé",
	"ui.bean.class.recompile.unsupported": "// =============================================== //\n// Recompilation désactivée. Redémarrez Recaf après avoir installé un JDK //\n// =============================================== //\n\n",
	"ui.bean.class.annotations.title": "Annotations",
	"ui.bean.class.annotations.ref.tooltip": "Référence de type",
	"ui.bean.class.annotations.desc.tooltip": "Descripteur d'annotation",
	"ui.bean.class.annotations.type.tooltip": "Type-path d'annotation",
	"ui.bean.class.visibleannotations.name": "Annotations visibles",
	"ui.bean.class.visibleannotations.desc": "Liste des annotations de classe liées à l'exécution.",
	"ui.bean.class.invisibleannotations.name": "Annotations invisibles",
	"ui.bean.class.invisibleannotations.desc": "Liste des annotations applicables à cette classe.",
	"ui.bean.class.visibletypeannotations.name": "Annotations de types visibles",
	"ui.bean.class.visibletypeannotations.desc": "Liste des annotations de type applicables à cette classe.",
	"ui.bean.class.invisibletypeannotations.name": "Annotations de types invisibles",
	"ui.bean.class.invisibletypeannotations.desc": "Liste des annotations de type applicables à cette classe.",
	"ui.bean.class.attrs.name": "Autres attributs",
	"ui.bean.class.attrs.desc": "Liste des attributs non standard.",
	"ui.bean.class.innerclasses.name": "Classes internes",
	"ui.bean.class.innerclasses.desc": "Liste des classes internes",
	"ui.bean.class.innerclasses.name.tooltip": "Le nom interne de la sous-classe.",
	"ui.bean.class.innerclasses.inner.tooltip": "Le nom basique de la sous-classe à l'intérieur de la classe encapsulante. Peut être null pour des sous-classes anonymes.",
	"ui.bean.class.innerclasses.outer.tooltip": "Le nom interne de la classe dans laquelle la sous-classe appartient. Peut être null.",
	"ui.bean.class.fields.name": "Champs",
	"ui.bean.class.fields.desc": "Liste des champs.",
	"ui.bean.class.methods.name": "Méthodes",
	"ui.bean.class.methods.desc": "Liste des méthodes",
	"ui.bean.class.module.name": "Modules",
	"ui.bean.class.module.desc": "Liste des modules",
	"ui.bean.class.interfaces.name": "Interfaces",
	"ui.bean.class.interfaces.desc": "Liste des interfaces implémentées.",
	"ui.bean.class.nesthostclass.name": "Hôte principale",
	"ui.bean.class.nesthostclass.desc": "Le nom interne de la classe hôte principale de cette classe. Peut être null.",
	"ui.bean.class.nestmembers.name": "Membres imbriqués",
	"ui.bean.class.nestmembers.desc": "Les noms interne des membres de cette classe. Peut être null.",
	
	"ui.bean.field": "Propriétés",
	"ui.bean.field.access.name": "Visibilité",
	"ui.bean.field.access.desc": "Visibilité comme public, private, static, etc.",
	"ui.bean.field.name.name": "Nom",
	"ui.bean.field.name.desc": "Nom du champ.",
	"ui.bean.field.desc.name": "Descripteur",
	"ui.bean.field.desc.desc": "Descripteur de type du champ.",
	"ui.bean.field.signature.name": "Signature",
	"ui.bean.field.signature.desc": "Descripteur de type générique.",
	"ui.bean.field.value.name": "Valeur",
	"ui.bean.field.value.desc": "Valeur de ce champ constant.",
	"ui.bean.field.attrs.name": "Autres attributs",
	"ui.bean.field.attrs.desc": "Liste des attributs non standard.",
	"ui.bean.field.visibleannotations.name": "Annotations visibles",
	"ui.bean.field.visibleannotations.desc": "Liste des annotations de champ liées à l'exécution.",
	"ui.bean.field.invisibleannotations.name": "Annotations invisibles",
	"ui.bean.field.invisibleannotations.desc": "Liste des annotations applicables à ce champ. Non disponible à travers l'API de réflexion.",
	"ui.bean.field.visibletypeannotations.name": "Annotations de types visibles",
	"ui.bean.field.visibletypeannotations.desc": "Liste des annotations de type applicables à ce champ.",
	"ui.bean.field.invisibletypeannotations.name": "Annotations de types invisibles",
	"ui.bean.field.invisibletypeannotations.desc": "Liste des annotations de type applicables à ce champ. Non disponible à travers l'API de réflexion.",
	
	"ui.bean.method.access.name": "Visibilité",
	"ui.bean.method.access.desc": "Visibilité comme public, private, static, etc.",
	"ui.bean.method.name.name": "Nom",
	"ui.bean.method.name.desc": "Nom de la méthode.",
	"ui.bean.method.desc.name": "Description",
	"ui.bean.method.desc.desc": "Descripteur de type de la méthode.",
	"ui.bean.method.signature.name": "Signature",
	"ui.bean.method.signature.desc": "Descripteur de type générique.",
	"ui.bean.method.exceptions.name": "Exceptions",
	"ui.bean.method.exceptions.desc": "Liste des exceptions que la méthode peut potentiellement générer.",
	"ui.bean.method.parameters.name": "Paramètres",
	"ui.bean.method.parameters.desc": "Données de débogage des paramètres comme les noms et les types.",
	"ui.bean.method.annotationdefault.name": "Annotation par défaut",
	"ui.bean.method.annotationdefault.desc": "missing_translation",
	"ui.bean.method.instructions.name": "Instructions de modifications",
	"ui.bean.method.instructions.desc": "Opcodes de méthodes contenant la logique d'exécution.",
	"ui.bean.method.instructions.find.title": "Rechercher",
	"ui.bean.method.instructions.find.confirm": "Valider",
	"ui.bean.method.trycatchblocks.name": "Try/catch",
	"ui.bean.method.trycatchblocks.desc": "Informations sur les blocs try/catch.",
	"ui.bean.method.trycatchblocks.start": "Début",
	"ui.bean.method.trycatchblocks.end": "Fin",
	"ui.bean.method.trycatchblocks.handler": "Handler",
	"ui.bean.method.trycatchblocks.type": "Type",
	"ui.bean.method.trycatchblocks.start.tooltip": "Début du bloc try.",
	"ui.bean.method.trycatchblocks.end.tooltip": "Fin du bloc try.",
	"ui.bean.method.trycatchblocks.handler.tooltip": "Début du bloc catch.",
	"ui.bean.method.trycatchblocks.type.tooltip": "Type de l'exception gérée. Laisser vide pour un type quelconque.",
	"ui.bean.method.maxstack.name": "Pile maximum",
	"ui.bean.method.maxstack.desc": "Nombre maximum d'éléments autorisés dans la pile du code de la méthode.",
	"ui.bean.method.maxlocals.name": "Variables locales maximum",
	"ui.bean.method.maxlocals.desc": "Nombre d'indices maximum de variables locales.",
	"ui.bean.method.localvariables.name": "Variable locale",
	"ui.bean.method.localvariables.desc": "Données de débogage des variables locales comme les noms et les types.",
	"ui.bean.method.label.name": "Libellé",
	"ui.bean.method.localvariable.index": "Indice",
	"ui.bean.method.localvariable.name": "Nom",
	"ui.bean.method.localvariable.desc": "Descripteur",
	"ui.bean.method.localvariable.start": "Début",
	"ui.bean.method.localvariable.end": "Fin",
	"ui.bean.method.localvariable.index.tooltip": "Indice dans la table de variables locales à utiliser.",
	"ui.bean.method.localvariable.name.tooltip": "Nom de la variable.",
	"ui.bean.method.localvariables.desc.tooltip": "Descripteur du type de variable.",
	"ui.bean.method.localvariables.signature.tooltip": "Descripteur générique de type.",
	"ui.bean.method.visibleannotations.name": "Annotations visibles",
	"ui.bean.method.visibleannotations.desc": "Liste des annotations de méthodes liées à l'exécution.",
	"ui.bean.method.invisibleannotations.name": "Annotations invisibles",
	"ui.bean.method.invisibleannotations.desc": "Liste des annotations applicables à cette méthode. Non disponible à travers l'API de réflexion.",
	"ui.bean.method.visibletypeannotations.name": "Annotations de types visible",
	"ui.bean.method.visibletypeannotations.desc": "Liste des annotations de type applicables à cette méthode.",
	"ui.bean.method.invisibletypeannotations.name": "Annotations de types invisible",
	"ui.bean.method.invisibletypeannotations.desc": "Liste des annotations de type applicables à cette méthode. Non disponible à travers l'API de réflexion.",
	"ui.bean.method.visibleannotableparametercount.name": "Nombre de paramètres visibles",
	"ui.bean.method.visibleannotableparametercount.desc": "Nombre de paramètres de méthode visible qui peuvent posséder des annotations visibles liées à l'exécution.",
	"ui.bean.method.invisibleannotableparametercount.name": "Nombre de paramètres invisibles",
	"ui.bean.method.invisibleannotableparametercount.desc": "Nombre de paramètres de méthode visible qui peuvent posséder des annotations invisibles liées à l'exécution.",
	"ui.bean.method.visiblelocalvariableannotations.name": "Annotations de variables visibles",
	"ui.bean.method.visiblelocalvariableannotations.desc": "Liste des annotations de type applicables aux variables de cette méthode.",
	"ui.bean.method.invisiblelocalvariableannotations.name": "Annotations de variables invisibles",
	"ui.bean.method.invisiblelocalvariableannotations.desc": "Liste des annotations de type applicables aux variables de la méthode. Non disponible à travers l'API de réflexion.",
	
	"ui.bean.insn.cst.desc": "Charger la valeur de la constante. Peut être n'importe quel type primitif ou String.",
	"ui.bean.insn.cst.name": "Valeur",
	"ui.bean.insn.cst.type": "Type de valeur",
	"ui.bean.insn.type.name": "Type",
	"ui.bean.insn.type.desc": "Type ASM",
	"ui.bean.insn.desc.desc": "Descripteur du membre.",
	"ui.bean.insn.desc.name": "Descripteur",
	"ui.bean.insn.opcode.name": "Opcode",
	"ui.bean.insn.opcode.desc": "Opcode à utiliser, les éléments affichés sont basés sur le type classé par ASM.",
	"ui.bean.insn.itf.desc": "La méthode appartient-elle à une interface ?",
	"ui.bean.insn.itf.name": "Interface",
	"ui.bean.insn.label.desc": "Décalage du libellé dans le bytecode",
	"ui.bean.insn.label.name": "Libellé",
	"ui.bean.insn.label.nullvalue": "<Vide>",
	"ui.bean.insn.line.desc": "Numéro de ligne qui correspond à ce libellé.",
	"ui.bean.insn.line.name": "Ligne",
	"ui.bean.insn.name.desc": "Nom du membre.",
	"ui.bean.insn.name.name": "Nom",
	"ui.bean.insn.owner.desc": "Propriétaire (classe) du membre.",
	"ui.bean.insn.owner.name": "Propriétaire",
	"ui.bean.insn.operand.name": "Opérande",
	"ui.bean.insn.operand.desc": "Valeur de l'entier à envoyer dans la pile.",
	"ui.bean.insn.start.desc": "Libellé indiquant où est définie la variable.",
	"ui.bean.insn.start.name": "Début",
	"ui.bean.insn.value.desc": "Valeur",
	"ui.bean.insn.value.name": "Valeur",
	"ui.bean.insn.var.desc": "Pointe vers une variable contenue dans la table locale de variables",
	"ui.bean.insn.var.name": "Indice de variable",
	"ui.bean.insn.bsm.desc": "Méthode de démarrage",
	"ui.bean.insn.bsm.name": "Méthode de démarrage",
	"ui.bean.insn.bsmargs.desc": "Arguments de constantes, où le premier concerne le Callsite.",
	"ui.bean.insn.bsmargs.name": "Arguments de démarrage",
	"ui.bean.insn.dflt.desc": "Emplacement vers lequel sauter en cas de fallback.",
	"ui.bean.insn.dflt.name": "Libellé par défaut",
	"ui.bean.insn.keys.desc": "Liste des clés.",
	"ui.bean.insn.keys.name": "Clés",
	"ui.bean.insn.labels.desc": "Liste des libellés.",
	"ui.bean.insn.labels.name": "Libellés",
	"ui.bean.insn.max.desc": "Valeur maximum pour le cas.",
	"ui.bean.insn.max.name": "Maximum",
	"ui.bean.insn.min.desc": "Valeur minimum pour le cas",
	"ui.bean.insn.min.name": "Minimum",
	"ui.bean.insn.dims.name": "Dimensions",
	"ui.bean.insn.dims.desc": "Nombre de dimensions du tableau.",
	"ui.bean.insn.incr.name": "Incrementer",
	"ui.bean.insn.incr.desc": "Incrémenter la variable par cette valeur..",
	"ui.bean.handle.tag.name": "Tag",
	"ui.bean.handle.tag.desc": "Valeurs indiquant des opcodes différents",
	"ui.bean.handle.owner.name": "Propriétaire",
	"ui.bean.handle.owner.desc": "Classe à laquelle appartient ce membre",
	"ui.bean.handle.name.name": "Nom",
	"ui.bean.handle.name.desc": "Nom du membre",
	"ui.bean.handle.descriptor.name": "Descripteur",
	"ui.bean.handle.descriptor.desc": "Descripteur du membre",
	"ui.bean.handle.isInterface.name": "Est une interface",
	"ui.bean.handle.isInterface.desc": "Le membre appartient-il à une interface ?",
	"ui.bean.bsmarg.tag.name": "Tag",
	"ui.bean.bsmarg.tag.desc": "Valeurs indiquant des opcodes différents",
	"ui.bean.bsmarg.owner.name": "Propriétaire",
	"ui.bean.bsmarg.owner.desc": "Classe à laquelle appartient ce membre",
	"ui.bean.bsmarg.name.name": "Nom",
	"ui.bean.bsmarg.name.desc": "Descripteur du membre",
	"ui.bean.bsmarg.descriptor.name": "Descripteur",
	"ui.bean.bsmarg.descriptor.desc": "Descripteur du membre",
	"ui.bean.bsmarg.isInterface.name": "Est une interface",
	"ui.bean.bsmarg.isInterface.desc": "Le membre appartient-il à une interface ?",
	"ui.bean.bsmarg.type0.name": "Type arg[0]",
	"ui.bean.bsmarg.type0.desc": "Descripteur de type du membre",
	"ui.bean.bsmarg.type2.name": "Type arg[2]",
	"ui.bean.bsmarg.type2.desc": "Descripteur de type du membre",
	"ui.bean.typeannotation.reftype.classtypeparameter": "Paramètre de type de classe",
	"ui.bean.typeannotation.reftype.methodtypeparameter": "Paramètre de type de méthode",
	"ui.bean.typeannotation.reftype.classextends": "Classe étend",
	"ui.bean.typeannotation.reftype.classtypeparameterbound": "Paramètre lié au type de classe",
	"ui.bean.typeannotation.reftype.methodtypeparameterbound": "Paramètre lié au type de méthode",
	"ui.bean.typeannotation.reftype.field": "Champ",
	"ui.bean.typeannotation.reftype.methodreturn": "Retour de méthode",
	"ui.bean.typeannotation.reftype.methodreceiver": "Méthode réceptrice",
	"ui.bean.typeannotation.reftype.methodformalparameter": "Paramètre formel de la méthode",
	"ui.bean.typeannotation.reftype.throws": "Lance",
	"ui.bean.typeannotation.reftype.localvariable": "Variable locale",
	"ui.bean.typeannotation.reftype.resourcevariable": "Variable de resource",
	"ui.bean.typeannotation.reftype.exceptionparameter": "Paramètre d'exception",
	"ui.bean.typeannotation.reftype.instanceof": "Instance de",
	"ui.bean.typeannotation.reftype.new": "Nouvel",
	"ui.bean.typeannotation.reftype.constructorreference": "Référence du constructeur",
	"ui.bean.typeannotation.reftype.methodreference": "Reference de la méthode",
	"ui.bean.typeannotation.reftype.cast": "Transtypage",
	"ui.bean.typeannotation.reftype.constructorinvocationtypeargument": "Argument d'invocation du type de constructeur",
	"ui.bean.typeannotation.reftype.methodinvocationtypeargument": "Argument d'invocation du type de méthode",
	"ui.bean.typeannotation.reftype.constructorreferencetypeargument": "Argument de référence du type de constructeur",
	"ui.bean.typeannotation.reftype.methodreferencetypeargument": "Argument de référence du type de méthode",
	"ui.bean.typeannotation.reftype.unknown": "Inconnu",

	"update": "Mises à jour",
	"update.available": "Une mise à jour est disponible.",
	"update.fail.resolve": "Erreur lors de la résolution du chemin de l'exécutable.",
	"update.fail.jarread": "Lecture impossible du contenu de pom.sml depuis le fichier jar actuel.",
	"update.fail.nodownload": "Recaf n'est pas à jour, mais l'adresse de téléchargement n'a pas pu être trouvée.",
	"update.fail.unknown": "La vérification des mises à jour a échouée pour la raison suivante : ",
	"update.outdated": "Recaf n'est pas à jour",
	"update.complete": "Mise à jour terminée, veuillez lancer la nouvelle version.",
	"update.updated": "Recherche de mise à jour terminée : Aucune mise à jour n'est disponible",
	"update.consent": "Cette mise à jour apporte de nouvelles fonctionnalités et corrige des bogues. Appuyez sur \"Télécharger\" pour télécharger et lancer la nouvelle version.",
	"update.download": "Télécharger",
	"update.active.name": "Autoriser la recherche de mise à jour",
	"update.active.desc": "Si désactivé, vous ne serez pas informé de nouvelles mises à jour.",
	"update.lastcheck.name": "Dernière vérification",
	"update.lastcheck.desc": "Dernière fois depuis la recherche de mise à jour.",
	"update.frequency.name": "Fréquence",
	"update.frequency.desc": "Délai rentre chaque vérification.",
	"update.frequency.always": "Toujours",
	"update.frequency.daily": "Quotidien",
	"update.frequency.weekly": "Hebdomadaire",

	"asm": "ASM - Bytecode",
	"asm.version.name": "Version",
	"asm.version.desc": "Librairie ASM à utiliser.",
	"asm.out.computemaxs.name": "Calculer les maxs",
	"asm.out.computemaxs.desc": "Forcer ASM à calculer la taille maximum des piles et tables locales.",
	"asm.out.computeframes.name": "Calculer les trames",
	"asm.out.computeframes.desc": "Forcer ASM à calculer les trames de la pile.",
	"asm.out.reflectionexport.name": "Export de reflection",
	"asm.out.reflectionexport.desc": "Autoriser le processus d'export à chercher les classes manquantes à l'exécution.",
	"asm.in.skipcode.name": "Ignore le code",
	"asm.in.skipcode.desc": "Forcer ASM à ignorer le code des méthodes.",
	"asm.in.skipdebug.name": "Ignorer les données de débogage",
	"asm.in.skipdebug.desc": "Forcer ASM à ignorer des données de débogage comme le nom des variables",
	"asm.in.skipframes.name": "Ignorer les trames",
	"asm.in.skipframes.desc": "Forcer ASM à ignore les trames de la pile lors du chargement d'une nouvelle entrée.",
	"asm.in.expandframes.name": "Expansion des trames",
	"asm.in.expandframes.desc": "Forcer ASM à convertir les trames existante de la pile vers un format de données plus commun.",
	"asm.edit.verify.name": "Vérifier",
	"asm.edit.verify.desc": "Lorsque les modifications génèrent du bytecode invalide, le surligner dans la vue d'édition. Interdire aussi l'export tant que la vérification n'est pas passée sur les classes modifiées.",
	"asm.edit.linkedmethods.name": "Renommage de méthodes liées",
	"asm.edit.linkedmethods.desc": "Lors du renommage des méthodes, renommer aussi les déclarations enfant et parentes.",
	"asm.edit.locklibmethods.name": "Verrouiller les noms de méthodes liées",
	"asm.edit.locklibmethods.desc": "Ne pas autoriser le renommage des méthodes liées connues. Requiert l'activation du renommage de méthodes liées.",
	"asm.edit.locklibmethods.locked": "La méthode étend une méthode liée et a été verrouillée afin d'éviter le renommage accidentel.",

	"display": "Affichage",
	"display.simplify.name": "Simplifier les descripteurs de type",
	"display.simplify.desc": "Cache les noms de packages pour les descripteurs de type.",
	"display.jumphelp.name": "Aide inline pour les sauts",
	"display.jumphelp.desc": "Montrer les sauts logiques spécifiques aux opcodes dans les opcodes",
	"display.topmost.name": "Toujours afficher par dessus",
	"display.topmost.desc": "Lors de l'édition d'une valeur, garder la fenêtre par dessus les autres.",
	"display.language.name": "Langue",
	"display.language.desc": "Langue dans laquelle l'interface sera affichée.",
	"display.appstyle.name": "Apparence de la fenêtre",
	"display.appstyle.desc": "Style visuel appliqué aux fenêtres.",
	"display.textstyle.name": "Apparence du texte",
	"display.textstyle.desc": "Style visuel appliqué au texte des éditeurs.",
	"display.loglevel.name": "Niveau de journalisation",
	"display.loglevel.desc": "Niveau de journalisation à afficher dans la console.",
	"display.buttonbar.name": "Afficher la barre de boutons",
	"display.buttonbar.desc": "Afficher la barre de boutons pratique dans l'interface. Redémarrez pour appliquer ce changement.",
	"display.maxlength.tree.name": "Longueur maximum du nom de l'arbre",
	"display.maxlength.tree.desc": "Longueur maximum des noms dans l'arborescence. Utile pour de l'assembleur obfusqué avec des noms compliqués.",
	"display.treesourcename.name": "Afficher les noms des SourceFile",
	"display.treesourcename.desc": "Afficher les SourceFile des classes à coté de leur noms déclarés dans l'arborescence.",
	"display.exitwarning.name": "Demander de sauvegarder à la fermeture",
	"display.exitwarning.desc": "Avant que Recaf se ferme, demander si le projet actuel doit être sauvegardé.",
	"display.exitwarning.title": "Sauvegarder avant de quitter ?",
	"display.exitwarning.message": "Souhaitez vous sauvegarder votre travail avant de quitter ?",
	"display.classmode.name": "Mode de classe",
	"display.classmode.desc": "Mode d'éditeur pour les classes",
	"display.filemode.name": "Mode de fichier",
	"display.filemode.desc": "Mode d'éditeur pour les fichiers",
	"display.fontsize.name": "Taille de la police",
	"display.fontsize.desc": "Taille de la police en pixels",
	"display.suggest.classerrors.name": "Afficher des suggestions pour les erreurs",
	"display.suggest.classerrors.desc": "Afficher des popups de suggestions quand certaines erreurs surviennent",

	"binding": "Raccourcis",
	"binding.inputprompt.initial": " <patientez>",
	"binding.inputprompt.finish": " <ENTRÉE pour terminer>",
	"binding.close.window.name": "Fermer la fenêtre",
	"binding.close.window.desc": "Ferme la fenêtre active.",
	"binding.close.tab.name": "Fermer l'onglet",
	"binding.close.tab.desc": "Ferme l'onglet actif.",
	"binding.saveapp.name": "Sauvegarder le programme",
	"binding.saveapp.desc": "Sauvegarder le programme vers un fichier.",
	"binding.save.name": "Sauvegarder les modifications",
	"binding.save.desc": "Appliquer les changements dans la vue d'édition actuelle.",
	"binding.undo.name": "Annuler la dernière modification",
	"binding.undo.desc": "Annuler la modification la plus récente dans la vue d'édition actuelle.",
	"binding.find.name": "Rechercher",
	"binding.find.desc": "Ouvrir le menu de recherche.",
	"binding.rename.name": "Renommer",
	"binding.rename.desc": "Renommer la classe/membre sélectionné.",
	"binding.gotodef.name": "Aller à la définition",
	"binding.gotodef.desc": "Aller à la définition de l'élément sélectionné.",

	"backend": "Backend / Privé",

	"decompile": "Décompilation",
	"decompile.decompiler.name": "Décompilateur",
	"decompile.decompiler.desc": "Le moteur de décompilation à utiliser",
	"decompile.showsynthetics.name": "Montrer le code synthétique",
	"decompile.showsynthetics.desc": "Montrer le code généré par le compilateur",
	"decompile.stripdebug.name": "Supprimer les données de débogage",
	"decompile.stripdebug.desc": "Supprimer les données de débogage avant le désassemblage.",
	"decompile.showname.name": "Afficher le nom",
	"decompile.showname.desc": "Inclure un commentaire indiquant le décompilateur actuel et sa version",
	"decompile.timeout.name": "Timeout",
	"decompile.timeout.desc": "Temps en millisecondes à attendre avant d'annuler le processus de décompilation",
	"decompile.fail": "Décompilation échouée. Essayez de changer le décompilateur dans le menu de configuration.",

	"assembler": "Assembleur",
	"assembler.verify.name": "Vérifier",
	"assembler.verify.desc": "Vérifier le bytecode des méthodes. Ceci permet aussi une meilleure analyse des types de variables.",
	"assembler.variables.name": "Variables",
	"assembler.variables.desc": "Sauvegarder les données de débogage des variables après l'assemblage.",
	"assembler.useexistingdata.name": "Utiliser les données existantes",
	"assembler.useexistingdata.desc": "Utiliser les données des variables au lieu de recalculer les indices et les types.",
	"assembler.stripdebug.name": "Supprimer les données de débogage",
	"assembler.stripdebug.desc": "Supprimer les données de débogage avant le désassemblage, supprimant ainsi le nom des variables.",

	"suggest.decompile.warn.title": "Erreur de décompilation",
	"suggest.decompile.warn": "La sortie du décompilateur contient des erreurs.\nCeci va provoquer la désactivation des interactions avec la classe.\nVoulez vous changer de décompilateur ?",
	"suggest.decompile.timeout.title": "Timeout du décompilateur",
	"suggest.decompile.timeout": "Le décompilateur actuel a pris trop de temps et a été arrêté.\nVoulez vous changer de décompilateur ?",
	"suggest.decompile.failure.title": "Arrêt inattendu du décompilateur",
	"suggest.decompile.failure": "Le décompilateur actuel s'est arrêté de manière inattendue.\nVoulez vous changer de décompilateur ?",
	"suggest.switchmodes": "Le mode de vue de la classe peut aussi être changé :",

	"cfr": "Décompilateur CFR",
	"cfr.aexagg.desc": "Supprimer les gestionnaires d'exceptions imbriqués s'il ne changement pas la sémantique",
	"cfr.aexagg.name": "Optimisation agressive des exceptions",
	"cfr.aggressivesizethreshold.desc": "Nombre d'opcodes à partir duquel déclencher la réduction aggressive",
	"cfr.aggressivesizethreshold.name": "Seuil d'agressivité",
	"cfr.allowcorrecting.desc": "Autoriser les transformations qui corrigent les erreurs, pouvant altérer le comportement du code.",
	"cfr.allowcorrecting.name": "Autoriser la correction",
	"cfr.arrayiter.desc": "Améliorer la lisibilité des itérations de tableaux.",
	"cfr.arrayiter.name": "Itération de tableau",
	"cfr.collectioniter.desc": "Améliorer la lisibilité des itérations de collections.",
	"cfr.collectioniter.name": "Itération de collection",
	"cfr.commentmonitors.desc": "Remplacer les moniteurs par des commentaires - useful if we're completely confused.",
	"cfr.commentmonitors.name": "Commenter les moniteurs",
	"cfr.comments.desc": "Générer des commentaires décrivant le statut du décompilateur, les options (flags) de fallback, etc.",
	"cfr.comments.name": "Commentaires d'informations",
	"cfr.decodeenumswitch.desc": "Améliorer la lisibilité des switchs sur les énumérations",
	"cfr.decodeenumswitch.name": "Décoder les switchs sur les énumérations",
	"cfr.decodefinally.desc": "Améliorer la lisibilité des instructions finally",
	"cfr.decodefinally.name": "Decoder les instructions finally",
	"cfr.decodelambdas.desc": "Reconstruire les fonctions lambdas",
	"cfr.decodelambdas.name": "Decoder les lambdas",
	"cfr.decodestringswitch.desc": "Améliorer la lisibilité des switchs sur les chaînes de caractères",
	"cfr.decodestringswitch.name": "Décoder les switchs de chaînes de caractères",
	"cfr.dumpclasspath.desc": "Extraire le chemin de la classe pour aider au débogage",
	"cfr.dumpclasspath.name": "Extraire le chemin de la classe",
	"cfr.eclipse.desc": "Activer les transformations pour mieux ²gérer le code eclipse.",
	"cfr.eclipse.name": "Eclipse",
	"cfr.elidescala.desc": "Cacher des informations non utiles dans le code Scala (serialVersionUID, @ScalaSignature).",
	"cfr.elidescala.name": "Nettoyer le Scala",
	"cfr.forcecondpropagate.desc": "Récupérer les résultats des sauts déterminants avec l'aide d'assignements de constantes",
	"cfr.forcecondpropagate.name": "Forcer la propagation des conditions",
	"cfr.forceexceptionprune.desc": "Essayer d'étendre et de rassembler les exceptions de façon plus aggressive.",
	"cfr.forceexceptionprune.name": "Forcer le rassemblement d'exceptions",
	"cfr.forcereturningifs.desc": "Déplacer le return à l'emplacement du saut.",
	"cfr.forcereturningifs.name": "Forcer le retours des conditions",
	"cfr.forcetopsort.desc": "Forcer le tri de bloc basique. Utile pour du code avec de l'obfuscation en flux (flow).",
	"cfr.forcetopsort.name": "Forcer le top-sort",
	"cfr.forcetopsortaggress.desc": "Forcer les options agressives supplémentaires de topsort.",
	"cfr.forcetopsortaggress.name": "Forcer le top-sort:aggressive",
	"cfr.forloopaggcapture.desc": "Autoriser les boucles à roll les mutations de façon aggressive dans la section de mise à jour, même si elles ne semblent pas impliquées avec le prédicat",
	"cfr.forloopaggcapture.name": "Capture des boucles for",
	"cfr.hidebridgemethods.desc": "Cacher les méthodes avec un accès de pont",
	"cfr.hidebridgemethods.name": "Cacher les méthodes de pont",
	"cfr.hidelangimports.desc": "Cacher les imports de java.lang.*",
	"cfr.hidelangimports.name": "Cacher les imports lang",
	"cfr.hidelongstrings.desc": "Cacher toutes les chaînes de caractères longue - pratique si l'obfuscateur a généré du faux code dans les chaînes de caractères",
	"cfr.hidelongstrings.name": "Cacher les chaînes de caractères longues",
	"cfr.hideutf.desc": "Cacher les caractères UTF8 - les englober dans des guillemets au lieu de montrer les caractères bruts",
	"cfr.hideutf.name": "Cacher l'UTF8",
	"cfr.innerclasses.desc": "Incorporer les classes intérieures dans la décompilation de la classe extérieure.",
	"cfr.innerclasses.name": "Décompiler les classes intérieures",
	"cfr.j14classobj.desc": "Déconstruire les objets de classe de Java 1.4",
	"cfr.j14classobj.name": "Objets de classe Java 1.4",
	"cfr.labelledblocks.desc": "Permet au code généré d'utiliser des blocs libellés (labelled), (prenant en charge des forward gotos particuliers)",
	"cfr.labelledblocks.name": "Blocs libellés",
	"cfr.lenient.desc": "Appliquer plus d'indulgence dans des situations qui requièrent normalement la levée d'une exception.",
	"cfr.lenient.name": "Indulgence",
	"cfr.liftconstructorinit.desc": "Lever le code commun d'initialisation des constructs vers un membre d'initialisation",
	"cfr.liftconstructorinit.name": "Lever l'init des constructeurs",
	"cfr.override.desc": "Générer des annotations @Override (if method is seen to implement interface method, or override a base class method)",
	"cfr.override.name": "Générer des @Override",
	"cfr.pullcodecase.desc": "Récupérer le code des expressions case de manière plus aggressive.",
	"cfr.pullcodecase.name": "Récupérer les case",
	"cfr.recover.desc": "Autoriser l'utilisation incrémentale d'options agressives si la décompilation échoue",
	"cfr.recover.name": "Récupérer",
	"cfr.recovertypeclash.desc": "Couper les lifetimes où l'analyse a causé des conflits de type",
	"cfr.recovertypeclash.name": "Récupérer les conflits de types",
	"cfr.recovertypehints.desc": "Récupérer le type hinting pour les itérateurs depuis la première passe.",
	"cfr.recovertypehints.name": "Récupérer le type hinting",
	"cfr.recpass.desc": "Décompiler spécifiquement avec des options de récupération de la passe #X. (Utile pour le débogage)",
	"cfr.recpass.name": "Recpass",
	"cfr.relinkconststring.desc": "Relier les chaînes de caractères constantes. Si il y a une référence local à une chaîne de caractère qui correspond à un static final, utiliser le static final.",
	"cfr.relinkconststring.name": "Relier les chaînes de caractères constantes",
	"cfr.removebadgenerics.desc": "Cacher les génériques qui ne sont pas valide, et fallback vers les non-génériques",
	"cfr.removebadgenerics.name": "Cacher les génériques non valides",
	"cfr.removeboilerplate.desc": "Supprimer les fonctions et constructeurs boilerplate, désérialisation lambda, etc.",
	"cfr.removeboilerplate.name": "Supprimer le boilerplate",
	"cfr.removedeadmethods.desc": "Supprimer les méthodes qui ne font plus sens, comme les constructeurs par défaut, etc.",
	"cfr.removedeadmethods.name": "Supprimer les méthodes non utilisées",
	"cfr.removeinnerclasssynthetics.desc": "Supprimer (lorsque c'est possible) les références implicites aux classes extérieures dans les classes intérieures",
	"cfr.removeinnerclasssynthetics.name": "Supprimer les références externes dans les classes intérieures",
	"cfr.renamedupmembers.desc": "Renommer les membres ambigus/duplicatas.",
	"cfr.renamedupmembers.name": "Supprimer les membres duplicatas",
	"cfr.renameenumidents.desc": "Renommer les identifiants d'énumérations qui ne correspondent pas à leur 'supposé' chaîne de caractère.",
	"cfr.renameenumidents.name": "Renommer les identifiants d'énumérations",
	"cfr.renameillegalidents.desc": "Renommer les identifiants qui ne sont pas des identifiants Java valides.",
	"cfr.renameillegalidents.name": "Renommer les identifiants invalides",
	"cfr.renamesmallmembers.desc": "Renommer les membres courts. Utile pour de l'obfuscation de type proguard.",
	"cfr.renamesmallmembers.name": "Renommer les membres courts",
	"cfr.showinferrable.desc": "Décorer les méthodes avec des types explicites s'ils sont pas donnés par les arguments.",
	"cfr.showinferrable.name": "Afficher Show inferrable",
	"cfr.showops.desc": "Afficher des informations de débogage (peu compréhensibles).",
	"cfr.showops.name": "Afficher les OPs",
	"cfr.showversion.desc": "Afficher dans l'entête la version de CFR utilisée",
	"cfr.showversion.name": "Afficher la version",
	"cfr.silent.desc": "Ne pas afficher l'état lors de la compilation",
	"cfr.silent.name": "Discret",
	"cfr.staticinitreturn.desc": "Essayer de supprimer le retour d'init statique",
	"cfr.staticinitreturn.name": "Retour d'init statique",
	"cfr.stringbuffer.desc": "Convertir les new Stringbuffer().add.add.add vers string + string + string",
	"cfr.stringbuffer.name": "Nettoyer le StringBuffer",
	"cfr.stringbuilder.desc": "Convertir les new Stringbuilder().add.add.add vers string + string + string",
	"cfr.stringbuilder.name": "Nettoyer le StringBuilder",
	"cfr.stringconcat.desc": "Convertir les usages de StringConcatFactor vers string + string + string",
	"cfr.stringconcat.name": "Convertir les concaténations de chaînes de caractères",
	"cfr.sugarasserts.desc": "Améliorer la lisibilité des appels d'assertion",
	"cfr.sugarasserts.name": "Améliorer la lisibilité des assertions",
	"cfr.sugarboxing.desc": "Supprimer les boxing wrappers là ou c'est possible",
	"cfr.sugarboxing.name": "Améliorer la lisibilité des boxings",
	"cfr.sugarenums.desc": "Améliorer la lisibilité des énumérations",
	"cfr.sugarenums.name": "Améliorer la lisibilité des énumérations",
	"cfr.switchexpression.desc": "Expressions switch de Java 13, où les switch retournent des valeurs.",
	"cfr.switchexpression.name": "Expressions switch",
	"cfr.tidymonitors.desc": "Supprimer le code du support des moniteurs - ex: des blocs catch juste pour quitter un moniteur",
	"cfr.tidymonitors.name": "Nettoyer les moniteurs",
	"cfr.tryresources.desc": "Si actif, tenter d'afficher les blocs try-catch en tant que try-with-resource.",
	"cfr.tryresources.name": "Utiliser les blocs try-with-resource",
	"cfr.usenametable.desc": "Utiliser la table locale de noms de variables si elle est présente.",
	"cfr.usenametable.name": "Utiliser la table de noms"
}
```

`src/main/resources/translations/zh-cn.json`:

```json
{
	"misc.add": "添加",
	"misc.save": "保存",
	"misc.load": "载入",
	"misc.remove": "移除",
	"misc.edit": "编辑",
	"misc.duplicate": "复制",
	"misc.rename": "重命名",
	"misc.error": "错误",
	"misc.access": "访问",
	"misc.yes": "是",
	"misc.no": "不",
	"misc.confirm": "确认",
	"misc.confirm.message": "你确定吗?",
	"misc.enabled": "启用",
	"misc.open": "开",
	"misc.select": "选择",

	"ui.verify": "验证失败",
	"ui.config": "配置",
	"ui.history": "历史",
	"ui.history.pop": "退回到上一个状态",
	"ui.history.open.class": "打开类",
	"ui.history.open.file": "打开文件",
	"ui.info.logging": "日志",
	"ui.info.other": "其他",
	"ui.attach": "注入",
	"ui.attach.copy": "复制到工作空间",
	"ui.noerrormsg": "无错误消息",
	"ui.openissue": "如果您认为这是一个错误,请报告此异常",
	"ui.quitonattach.name": "退出注入",
	"ui.quitonattach.desc": "加载代理实例后关闭当前Recaf实例.",
	"ui.attach.prompt": "选择虚拟机...",
	"ui.looaddrop.prompt": "拖放加载应用程序(class或jar)",
	"ui.load.resolve": "解析文件路径",
	"ui.load.initialize.resource": "初始化资源类型",
	"ui.load.initialize.workspace": "初始化工作空间",
	"ui.load.loading": "加载资源内容",
	"ui.load.srcdocs": "加载源码和文档",
	"ui.load.adddocs": "添加注解",
	"ui.load.addsrc": "添加源码",
	"ui.load.done": "完成",

	"ui.fileprompt.open": "打开文件",
	"ui.fileprompt.open.extensions": "Java程序和工作空间",
	"ui.fileprompt.export": "导出文件",
	
	"ui.menubar.file": "文件",
	"ui.menubar.file.addlib": "添加库",
	"ui.menubar.file.newwizard": "新建工作空间",
	"ui.menubar.file.load": "加载",
	"ui.menubar.file.recent": "最近加载",
	"ui.menubar.file.saveapp": "导出程序",
	"ui.menubar.file.saveworkspace": "导出工作空间",
	"ui.menubar.file.agentexport": "应用更改",
	"ui.menubar.config": "配置",
	"ui.menubar.themeeditor": "主题编辑器",
	"ui.menubar.search": "搜索",
	"ui.menubar.search.string": "字符串",
	"ui.menubar.search.value": "数值",
	"ui.menubar.search.cls_reference": "类引用",
	"ui.menubar.search.mem_reference": "成员引用",
	"ui.menubar.search.declare": "声明",
	"ui.menubar.search.insn": "指令",
	"ui.menubar.history": "历史",
	"ui.menubar.history.new": "创建保存状态",
	"ui.menubar.history.view": "查看保存状态",
	"ui.menubar.attach": "注入",
	"ui.menubar.plugins": "插件",
	"ui.menubar.plugins.manage": "管理插件",
	"ui.menubar.plugins.opendir": "打开插件目录",
	"ui.menubar.help": "帮助",
	"ui.menubar.help.about": "关于",
	"ui.menubar.help.documentation": "文档",
	"ui.menubar.help.info": "系统信息",
	"ui.menubar.help.contact": "联系",
	"ui.menubar.help.update": "下载更新:",
	"ui.edit.search": "搜索引用",
	"ui.edit.tab.closeall": "关闭所有",
	"ui.edit.tab.classinfo": "类",
	"ui.edit.tab.methods": "方法",
	"ui.edit.tab.methods.access": "访问",
	"ui.edit.tab.methods.name": "名称",
	"ui.edit.tab.methods.return": "返回",
	"ui.edit.tab.methods.args": "参数",
	"ui.edit.tab.methods.index": "索引",
	"ui.edit.tab.fields": "字段",
	"ui.edit.tab.fields.access": "访问",
	"ui.edit.tab.fields.name": "名称",
	"ui.edit.tab.fields.type": "类型",
	"ui.edit.tab.fields.index": "索引",
	"ui.edit.method.rename": "重命名",
	"ui.edit.method.follow": "跟随",
	"ui.edit.method.referrers": "来源",
	"ui.edit.method.goto": "转到定义",
	"ui.edit.method.define": "打开定义",
	"ui.edit.method.editasm": "编辑汇编代码",
	"ui.edit.method.assemblyfirsterror": "第一处错误位于行",
	"ui.edit.method.insertstandard": "插入",
	"ui.edit.method.insertassembly": "插入汇编代码",
	"ui.edit.method.move.up": "上移",
	"ui.edit.method.move.down": "下移",
	"ui.edit.method.stackhelper": "locals/stack",
	"ui.edit.method.stackhelper.colstackopcode": "Stack源操作码",
	"ui.edit.method.stackhelper.colstackvalue": "值",
	"ui.edit.method.stackhelper.collocalopcode": "Local源操作码",
	"ui.edit.method.stackhelper.collocalvalue": "值",
	"ui.edit.method.stackhelper.colindex": "索引",
	"ui.edit.method.stackhelper.title": "Stack/Locals:",
	"ui.edit.method.block.title": "代码块",
	"ui.edit.method.block.save": "保存为代码块",
	"ui.edit.method.block.load": "插入代码块",
	"ui.edit.method.insert": "插入位置",
	"ui.edit.method.insert.title": "插入指令:",
	"ui.edit.method.insert.after": "之后",
	"ui.edit.method.insert.before": "之前",

	"ui.search": "搜索",
	"ui.search.string": "字符串",
	"ui.search.string.sub": "字符串内容",
	"ui.search.matchmode": "匹配模式",
	"ui.search.matchmode.sub": "字符串匹配方法",
	"ui.search.value": "值",
	"ui.search.value.sub": "数值.后缀D/F/L为double/float/long",
	"ui.search.reference": "引用",
	"ui.search.cls_reference.name": "名称",
	"ui.search.cls_reference.name.sub": "类名",
	"ui.search.mem_reference.owner": "所有者",
	"ui.search.mem_reference.owner.sub": "包含定义的类名",
	"ui.search.mem_reference.name": "名称",
	"ui.search.mem_reference.name.sub": "成员名称",
	"ui.search.mem_reference.desc": "描述符",
	"ui.search.mem_reference.desc.sub": "成员类型描述符",
	"ui.search.declaration": "声明",
	"ui.search.declaration.owner": "所有者",
	"ui.search.declaration.owner.sub": "包含定义的类名",
	"ui.search.declaration.name": "名称",
	"ui.search.declaration.name.sub": "成员名称",
	"ui.search.declaration.desc": "描述符",
	"ui.search.declaration.desc.sub": "成员类型描述符",
	"ui.search.insn": "说明",
	"ui.search.insn.lines": "文本行",
	"ui.search.insn.lines.sub": "要匹配的行",
	"ui.search.skippackages": "跳过的包",
	"ui.search.skippackages.sub": "将不搜索这些包中的类",
	"ui.search.skippackages.empty": "没有跳过的包",
	"ui.search.results.none": "没有结果",
	"ui.search.results.indexpre": "结果:",

	"ui.about.system": "系统",
	"ui.about.system.sub": "操作系统信息",
	"ui.about.java": "Java",
	"ui.about.java.sub": "关于JVM的信息",
	"ui.about.javafx": "JavaFX",
	"ui.about.javafx.sub": "关于JavaFX的信息",
	"ui.about.recaf": "Recaf",
	"ui.about.recaf.sub": "关于Recaf的信息",
	"ui.about.copy": "复制到剪贴板",
	"ui.about.opendir": "打开Recaf目录",

	"ui.bean.class": "类",
	"ui.bean.class.extended": "扩展属性",
	"ui.bean.class.version.name": "版本",
	"ui.bean.class.version.desc": "编译这个类使用的Java版本.",
	"ui.bean.class.access.name": "访问",
	"ui.bean.class.access.desc": "访问权限,例如公有(public),私有(private),静态(static)等.",
	"ui.bean.class.name.name": "名称",
	"ui.bean.class.name.desc": "类的名称.",
	"ui.bean.class.signature.name": "签名",
	"ui.bean.class.signature.desc": "泛型描述符.",
	"ui.bean.class.supername.name": "超类名称",
	"ui.bean.class.supername.desc": "父类的名称",
	"ui.bean.class.sourcefile.name": "源文件",
	"ui.bean.class.sourcefile.desc": "此类所对应的源文件的名称.",
	"ui.bean.class.sourcedebug.name": "源文件调试",
	"ui.bean.class.sourcedebug.desc": "用于表名此类是以何种语言的源码编译出来的.阅读JSR-045获取更多信息.",
	"ui.bean.class.outerclass.name": "外部类",
	"ui.bean.class.outerclass.desc": "外部类的名称,指示此类在源码里写在了哪个类的里面.",
	"ui.bean.class.outermethod.name": "外部方法",
	"ui.bean.class.outermethod.desc": "包含此内部类的方法的名称,留空表示此内部类并非包含在方法内部.",
	"ui.bean.class.outermethoddesc.name": "外部方法描述符",
	"ui.bean.class.outermethoddesc.desc": "包含此内部类的方法的描述符,留空表示此内部类并非包含在方法内部.",
	"ui.bean.class.decompile.name": "反编译",
	"ui.bean.class.decompile.desc": "将字节码反编译为Java源码.",
	"ui.bean.class.recompile.name": "重编译",
	"ui.bean.class.recompile.desc": "重新编译反编译后的代码.",
	"ui.bean.class.recompile.unsupported": "//===============================================//\n//重新编译已禁用.请用JDK运行Recaf//\n//===============================================//\n\n",
	"ui.bean.class.annotations.title": "注解",
	"ui.bean.class.annotations.ref.tooltip": "类型引用",
	"ui.bean.class.annotations.desc.tooltip": "注解描述符",
	"ui.bean.class.annotations.type.tooltip": "注解类型描述符",
	"ui.bean.class.visibleannotations.name": "可见注解",
	"ui.bean.class.visibleannotations.desc": "运行时可见的注解列表.",
	"ui.bean.class.invisibleannotations.name": "不可见注解",
	"ui.bean.class.invisibleannotations.desc": "运行时不可见的注解列表.",
	"ui.bean.class.visibletypeannotations.name": "可见类型注解",
	"ui.bean.class.visibletypeannotations.desc": "运行时可见的类型注解列表.",
	"ui.bean.class.invisibletypeannotations.name": "不可见类型注解",
	"ui.bean.class.invisibletypeannotations.desc": "运行时不可见的注解列表.",
	"ui.bean.class.attrs.name": "其他属性",
	"ui.bean.class.attrs.desc": "非标准属性列表.",
	"ui.bean.class.innerclasses.name": "内部类",
	"ui.bean.class.innerclasses.desc": "内部类列表.",
	"ui.bean.class.innerclasses.name.tooltip": "内部类的完整内部名.",
	"ui.bean.class.innerclasses.outer.tooltip": "这个内部类所属的外部类的内部名.可以留空.",
	"ui.bean.class.innerclasses.inner.tooltip": "这个内部类的简单名.留空则表示匿名内部类.",
	"ui.bean.class.fields.name": "字段",
	"ui.bean.class.fields.desc": "字段列表.",
	"ui.bean.class.methods.name": "方法",
	"ui.bean.class.methods.desc": "方法列表.",
	"ui.bean.class.module.name": "模块",
	"ui.bean.class.module.desc": "missing_translation",
	"ui.bean.class.interfaces.name": "接口",
	"ui.bean.class.interfaces.desc": "实现的接口的列表.",
	"ui.bean.class.nesthostclass.name": "嵌套宿主",
	"ui.bean.class.nesthostclass.desc": "该类的嵌套宿主类的内部名称.可能为空.",
	"ui.bean.class.nestmembers.name": "成员",
	"ui.bean.class.nestmembers.desc": "这个类的嵌套成员的内部名称.可能为空.",
	
	"ui.bean.field": "属性",
	"ui.bean.field.access.name": "修饰符",
	"ui.bean.field.access.desc": "public,private,static等修饰符.",
	"ui.bean.field.name.name": "名称",
	"ui.bean.field.name.desc": "字段名称.",
	"ui.bean.field.desc.name": "描述符",
	"ui.bean.field.desc.desc": "字段的类型描述符.",
	"ui.bean.field.signature.name": "签名",
	"ui.bean.field.signature.desc": "泛型描述符.",
	"ui.bean.field.value.name": "值",
	"ui.bean.field.value.desc": "这个常量字段的值.",
	"ui.bean.field.attrs.name": "其他属性",
	"ui.bean.field.attrs.desc": "非标准属性列表.",
	"ui.bean.field.visibleannotations.name": "可见注解",
	"ui.bean.field.visibleannotations.desc": "运行时可见的注解列表.",
	"ui.bean.field.invisibleannotations.name": "不可见注解",
	"ui.bean.field.invisibleannotations.desc": "运行时不可见的注解列表.",
	"ui.bean.field.visibletypeannotations.name": "可见类型注解",
	"ui.bean.field.visibletypeannotations.desc": "运行时可见的类型注解列表.",
	"ui.bean.field.invisibletypeannotations.name": "不可见类型注解",
	"ui.bean.field.invisibletypeannotations.desc": "运行时不可见的注解列表.",
	
	"ui.bean.method.access.name": "修饰符",
	"ui.bean.method.access.desc": "public,private,static等修饰符.",
	"ui.bean.method.name.name": "名称",
	"ui.bean.method.name.desc": "方法名称.",
	"ui.bean.method.desc.name": "描述符",
	"ui.bean.method.desc.desc": "方法的类型描述符.",
	"ui.bean.method.signature.name": "签名",
	"ui.bean.method.signature.desc": "泛型描述符.",
	"ui.bean.method.exceptions.name": "异常",
	"ui.bean.method.exceptions.desc": "此方法可能抛出的异常列表.",
	"ui.bean.method.parameters.name": "参数",
	"ui.bean.method.parameters.desc": "调试用参数信息,例如名称和类型.",
	"ui.bean.method.annotationdefault.name": "注解默认值",
	"ui.bean.method.annotationdefault.desc": "missing_translation",
	"ui.bean.method.instructions.name": "指令",
	"ui.bean.method.instructions.desc": "包含程序逻辑的操作码.",
	"ui.bean.method.instructions.find.title": "搜索指令",
	"ui.bean.method.instructions.find.confirm": "确定",
	"ui.bean.method.trycatchblocks.name": "Try-catch块",
	"ui.bean.method.trycatchblocks.desc": "Try-catch块信息.",
	"ui.bean.method.trycatchblocks.start": "开始",
	"ui.bean.method.trycatchblocks.end": "结束",
	"ui.bean.method.trycatchblocks.handler": "处理器",
	"ui.bean.method.trycatchblocks.type": "类型",
	"ui.bean.method.trycatchblocks.start.tooltip": "try块的开始.",
	"ui.bean.method.trycatchblocks.end.tooltip": "try块的结束.",
	"ui.bean.method.trycatchblocks.handler.tooltip": "catch块的开始.",
	"ui.bean.method.trycatchblocks.type.tooltip": "catch块捕获的异常类型.留空则为任何异常.",
	"ui.bean.method.maxstack.name": "最大stack深度",
	"ui.bean.method.maxstack.desc": "此方法的操作数栈中,任意时刻能存放的最大数量.",
	"ui.bean.method.maxlocals.name": "最大locals数量",
	"ui.bean.method.maxlocals.desc": "最大局部变量数量.",
	"ui.bean.method.localvariables.name": "局部变量表",
	"ui.bean.method.localvariables.desc": "局部变量调试信息,例如名称和类型等.",
	"ui.bean.method.label.name": "标签",
	"ui.bean.method.localvariable.start": "开始",
	"ui.bean.method.localvariable.end": "结束",
	"ui.bean.method.localvariable.index.tooltip": "此局部变量的索引.",
	"ui.bean.method.localvariable.name.tooltip": "变量名.",
	"ui.bean.method.localvariables.desc.tooltip": "变量类型描述符.",
	"ui.bean.method.localvariables.signature.tooltip": "泛型描述符.",
	"ui.bean.method.visibleannotations.name": "可见注解",
	"ui.bean.method.visibleannotations.desc": "运行时可见的注解列表.",
	"ui.bean.method.invisibleannotations.name": "不可见注解",
	"ui.bean.method.invisibleannotations.desc": "运行时不可见的注解列表.",
	"ui.bean.method.visibletypeannotations.name": "可见类型注解",
	"ui.bean.method.visibletypeannotations.desc": "运行时可见的类型注解.",
	"ui.bean.method.invisibletypeannotations.name": "不可见类型注解",
	"ui.bean.method.invisibletypeannotations.desc": "运行时不可见的类型注解.",
	"ui.bean.method.visibleannotableparametercount.name": "可见参数数量",
	"ui.bean.method.visibleannotableparametercount.desc": "允许拥有运行时可见注解的参数的数量.",
	"ui.bean.method.invisibleannotableparametercount.name": "不可见参数数量",
	"ui.bean.method.invisibleannotableparametercount.desc": "允许拥有运行时不可见注解的参数的数量.",
	"ui.bean.method.visiblelocalvariableannotations.name": "可见变量注解",
	"ui.bean.method.visiblelocalvariableannotations.desc": "运行时可见的变量注解列表.",
	"ui.bean.method.invisiblelocalvariableannotations.name": "不可见变量注解",
	"ui.bean.method.invisiblelocalvariableannotations.desc": "运行时不可见的变量注解列表.",
	
	"ui.bean.insn.cst.desc": "加载一个常量值.可以是任何基本类型或字符串.",
	"ui.bean.insn.cst.name": "值",
	"ui.bean.insn.cst.type": "值类型",
	"ui.bean.insn.type.name": "类型",
	"ui.bean.insn.type.desc": "ASM类型.",
	"ui.bean.insn.desc.desc": "成员的描述符.",
	"ui.bean.insn.desc.name": "描述符",
	"ui.bean.insn.opcode.name": "操作码",
	"ui.bean.insn.opcode.desc": "要使用的操作码.",
	"ui.bean.insn.itf.desc": "这个方法是否属于一个接口?",
	"ui.bean.insn.itf.name": "接口",
	"ui.bean.insn.label.desc": "字节码中的偏移量.",
	"ui.bean.insn.label.name": "标签",
	"ui.bean.insn.label.nullvalue": "<空>",
	"ui.bean.insn.line.desc": "此标签对应的行数.",
	"ui.bean.insn.line.name": "行",
	"ui.bean.insn.name.desc": "成员名称.",
	"ui.bean.insn.name.name": "名称",
	"ui.bean.insn.owner.desc": "成员的所有者(类).",
	"ui.bean.insn.owner.name": "所有者",
	"ui.bean.insn.operand.name": "操作数",
	"ui.bean.insn.operand.desc": "要压入堆栈的整数值.",
	"ui.bean.insn.start.desc": "指示此变量是在何处声明的标签.",
	"ui.bean.insn.start.name": "开始",
	"ui.bean.insn.value.desc": "值.",
	"ui.bean.insn.value.name": "值",
	"ui.bean.insn.var.desc": "指向局部变量表中的一个变量.",
	"ui.bean.insn.var.name": "变量索引",
	"ui.bean.insn.bsm.desc": "引导方法.",
	"ui.bean.insn.bsm.name": "引导方法",
	"ui.bean.insn.bsmargs.desc": "常量参数,第一个是调用点信息.",
	"ui.bean.insn.bsmargs.name": "引导参数",
	"ui.bean.insn.dflt.desc": "default情况下跳转到的标签.",
	"ui.bean.insn.dflt.name": "默认标签",
	"ui.bean.insn.keys.desc": "键列表.",
	"ui.bean.insn.keys.name": "键",
	"ui.bean.insn.labels.desc": "标签列表.",
	"ui.bean.insn.labels.name": "标签",
	"ui.bean.insn.max.desc": "case的最大值.",
	"ui.bean.insn.max.name": "最大值",
	"ui.bean.insn.min.desc": "case的最小值.",
	"ui.bean.insn.min.name": "最小值",
	"ui.bean.insn.dims.name": "维度",
	"ui.bean.insn.dims.desc": "数组维度.",
	"ui.bean.insn.incr.name": "增量",
	"ui.bean.insn.incr.desc": "要增加的数量.",
	"ui.bean.handle.tag.name": "类型",
	"ui.bean.handle.tag.desc": "指示不同的操作码.",
	"ui.bean.handle.owner.name": "所有者",
	"ui.bean.handle.owner.desc": "此成员所属的类.",
	"ui.bean.handle.name.name": "名称",
	"ui.bean.handle.name.desc": "成员名称.",
	"ui.bean.handle.descriptor.name": "描述符",
	"ui.bean.handle.descriptor.desc": "成员描述符.",
	"ui.bean.handle.isInterface.name": "接口",
	"ui.bean.handle.isInterface.desc": "该成员是否属于一个接口.",
	"ui.bean.bsmarg.tag.name": "类型",
	"ui.bean.bsmarg.tag.desc": "指示不同的操作码.",
	"ui.bean.bsmarg.owner.name": "所有者",
	"ui.bean.bsmarg.owner.desc": "此成员所属的类.",
	"ui.bean.bsmarg.name.name": "名称",
	"ui.bean.bsmarg.name.desc": "成员名称.",
	"ui.bean.bsmarg.descriptor.name": "描述符",
	"ui.bean.bsmarg.descriptor.desc": "成员描述符.",
	"ui.bean.bsmarg.isInterface.name": "接口",
	"ui.bean.bsmarg.isInterface.desc": "该成员是否属于一个接口.",
	"ui.bean.bsmarg.type0.name": "arg[0]类型",
	"ui.bean.bsmarg.type0.desc": "成员的类型描述符.",
	"ui.bean.bsmarg.type2.name": "arg[2]类型",
	"ui.bean.bsmarg.type2.desc": "成员的类型描述符.",
	"ui.bean.typeannotation.reftype.classtypeparameter": "类泛型参数",
	"ui.bean.typeannotation.reftype.methodtypeparameter": "方法泛型参数",
	"ui.bean.typeannotation.reftype.classextends": "类继承/实现",
	"ui.bean.typeannotation.reftype.classtypeparameterbound": "类泛型参数约束",
	"ui.bean.typeannotation.reftype.methodtypeparameterbound": "方法泛型参数约束",
	"ui.bean.typeannotation.reftype.field": "字段",
	"ui.bean.typeannotation.reftype.methodreturn": "方法返回值",
	"ui.bean.typeannotation.reftype.methodreceiver": "方法接收",
	"ui.bean.typeannotation.reftype.methodformalparameter": "方法形参",
	"ui.bean.typeannotation.reftype.throws": "Throws",
	"ui.bean.typeannotation.reftype.localvariable": "局部变量",
	"ui.bean.typeannotation.reftype.resourcevariable": "Resource变量",
	"ui.bean.typeannotation.reftype.exceptionparameter": "异常参数",
	"ui.bean.typeannotation.reftype.instanceof": "Instanceof",
	"ui.bean.typeannotation.reftype.new": "New",
	"ui.bean.typeannotation.reftype.constructorreference": "构造器引用",
	"ui.bean.typeannotation.reftype.methodreference": "方法引用",
	"ui.bean.typeannotation.reftype.cast": "强制转换",
	"ui.bean.typeannotation.reftype.constructorinvocationtypeargument": "构造器调用类型参数",
	"ui.bean.typeannotation.reftype.methodinvocationtypeargument": "方法调用类型参数",
	"ui.bean.typeannotation.reftype.constructorreferencetypeargument": "构造器引用类型参数",
	"ui.bean.typeannotation.reftype.methodreferencetypeargument": "方法引用类型参数",
	"ui.bean.typeannotation.reftype.unknown": "未知",

	"update": "更新",
	"update.available": "有可用的更新.",
	"update.fail.resolve": "无法获取自身可执行文件的路径.",
	"update.fail.jarread": "无法读取内置的pom.xml.",
	"update.fail.nodownload": "Recaf有新版本,但获取不到下载地址.",
	"update.fail.unknwon": "更新检查失败:",
	"update.outdated": "Recaf有新版本",
	"update.complete": "更新完成,请运行新版本.",
	"update.updated": "更新检查完成:已经是最新版本",
	"update.consent": "更新会添加新功能并修复错误.按“下载”下载并运行更新的版本.",
	"update.download": "下载",
	"update.active.name": "允许检查更新",
	"update.active.desc": "启用后将会按照指定频率定时检查并应用更新.",
	"update.lastcheck.name": "最后检查",
	"update.lastcheck.desc": "最后一次检查更新的时间.",
	"update.frequency.name": "检查频率",
	"update.frequency.desc": "两次检查之间的最小间隔时间.",
	"update.frequency.always": "每次启动",
	"update.frequency.daily": "每天",
	"update.frequency.weekly": "每周",

	"asm": "ASM-字节码",
	"asm.version.name": "版本",
	"asm.version.desc": "要使用的ASM库版本.",
	"asm.out.computemaxs.name": "计算max",
	"asm.out.computemaxs.desc": "强制ASM计算stack/local-table大小.",
	"asm.out.computeframes.name": "计算frame",
	"asm.out.computeframes.desc": "强制ASM计算堆栈frame.",
	"asm.out.reflectionexport.name": "反射导出",
	"asm.out.reflectionexport.desc": "允许导出程序在运行时查找缺失的类.",
	"asm.in.skipcode.name": "跳过Code段",
	"asm.in.skipcode.desc": "强制ASM跳过方法的Code段.",
	"asm.in.skipdebug.name": "跳过调试信息",
	"asm.in.skipdebug.desc": "强制ASM跳过调试信息,如变量名",
	"asm.in.skipframes.name": "跳过frame",
	"asm.in.skipframes.desc": "强制ASM跳过已有的frame信息.",
	"asm.in.expandframes.name": "展开frame",
	"asm.in.expandframes.desc": "强制ASM将现有堆栈frame扩展为通用格式.",
	"asm.edit.verify.name": "校验",
	"asm.edit.verify.desc": "当编辑创建无效的字节码时,突出显示编辑器窗口.在验证通过修改后的类之前,还要阻止导出.",
	"asm.edit.linkedmethods.name": "重命名关联的方法",
	"asm.edit.linkedmethods.desc": "重命名方法时,也重命名所有子声明和父声明.",
	"asm.edit.locklibmethods.name": "锁定关联的库名称",
	"asm.edit.locklibmethods.desc": "禁止重命名已知的库方法.需要重命名链接方法.",
	"asm.edit.locklibmethods.locked": "方法扩展了库方法,并已被锁定以防止意外重命名.",

	"display": "显示",
	"display.simplify.name": "简化类型描述符",
	"display.simplify.desc": "隐藏类型描述符中的包名.",
	"display.jumphelp.name": "显示跳转语句高亮",
	"display.jumphelp.desc": "显示操作码中的跳转逻辑.",
	"display.topmost.name": "置顶编辑窗口",
	"display.topmost.desc": "编辑时,将输入窗置顶.",
	"display.language.name": "语言",
	"display.language.desc": "界面使用的语言.",
	"display.appstyle.name": "窗口样式",
	"display.appstyle.desc": "视觉主题来设置窗口样式.",
	"display.textstyle.name": "文本样式",
	"display.textstyle.desc": "使用视觉主题设置文本编辑器的样式.",
	"display.loglevel.name": "日志级别",
	"display.loglevel.desc": "控制台中输出的日志级别.",
	"display.buttonbar.name": "显示快捷工具栏",
	"display.buttonbar.desc": "在窗体中显示快捷工具栏.重新启动以应用更改.",
	"display.maxlength.tree.name": "最大树节点名称长度",
	"display.maxlength.tree.desc": "文件树中每个节点最多显示多少个字符.在遇到混淆产生的,长的吓人的名字时很有用.",
	"display.treesourcename.name": "显示源文件名",
	"display.treesourcename.desc": "在文件树中声明的名称旁边显示类SourceFile.",
	"display.exitwarning.name": "退出时提示保存",
	"display.exitwarning.desc": "关闭Recaf时询问是否应保存当前项目.",
	"display.exitwarning.title": "关闭前保存?",
	"display.exitwarning.message": "你是否想在关闭之前保存项目?",
	"display.classmode.name": "类模式",
	"display.classmode.desc": "类的编辑器模式",
	"display.filemode.name": "文件模式",
	"display.filemode.desc": "非类的编辑器模式",
	"display.fontsize.name": "字体大小",
	"display.fontsize.desc": "字体大小(以像素为单位)",
	"display.suggest.classerrors.name": "显示错误建议",
	"display.suggest.classerrors.desc": "发生特定错误时弹出建议窗口",

	"binding": "快捷键",
	"binding.inputprompt.initial": "<waiting>",
	"binding.inputprompt.finish": "<ENTERtofinish>",
	"binding.close.window.name": "关闭窗口",
	"binding.close.window.desc": "关闭当前活动窗口.",
	"binding.close.tab.name": "关闭标签",
	"binding.close.tab.desc": "关闭当前的活动标签.",
	"binding.saveapp.name": "保存应用程序",
	"binding.saveapp.desc": "将应用程序保存到文件.",
	"binding.save.name": "保存更改",
	"binding.save.desc": "保存当前编辑器窗口中的更改.",
	"binding.undo.name": "撤消更改",
	"binding.undo.desc": "撤消当前编辑器窗口中最近的更改.",
	"binding.find.name": "查找",
	"binding.find.desc": "打开查找搜索菜单.",
	"binding.rename.name": "重命名",
	"binding.rename.desc": "重命名选定的类或成员.",
	"binding.gotodef.name": "转到定义",
	"binding.gotodef.desc": "跳转到选定项的定义.",

	"backend": "Backend/Private",

	"decompile": "反编译",
	"decompile.decompiler.name": "反编译器",
	"decompile.decompiler.desc": "要使用的反编译器.",
	"decompile.showsynthetics.name": "显示synthetics成员",
	"decompile.showsynthetics.desc": "显示编译器生成的代码.",
	"decompile.stripdebug.name": "除去调试",
	"decompile.stripdebug.desc": "在反编译之前除去调试信息.",
	"decompile.timeout.name": "超时",
	"decompile.timeout.desc": "中止反编译进程之前等待的时间(以毫秒为单位)",
	"decompile.fail": "反编译失败.您可以在配置菜单中更改反编译器.",

	"assembler": "反编译器",
	"assembler.verify.name": "校验",
	"assembler.verify.desc": "校验方法字节码.这也可以更好地进行变量类型分析.",
	"assembler.variables.name": "变量",
	"assembler.variables.desc": "组装后保存变量调试信息.",

	"suggest.decompile.warn.title": "反编译结果出错",
	"suggest.decompile.warn": "当前反编译器的输出存在问题.\n这将禁用交互功能.\n要切换到另一个反编译器吗?",
	"suggest.decompile.timeout.title": "反编译超时",
	"suggest.decompile.timeout": "当前反编译器耗时太长,已终止.\n要切换到另一个反编译器吗?",
	"suggest.decompile.failure.title": "反编译器崩溃",
	"suggest.decompile.failure": "当前反编译器崩溃.\n要切换到另一个反编译器吗?",
	"suggest.switchmodes": "类视图模式也可以更改:",

	"cfr": "CFR反编译器",
	"cfr.aexagg.desc": "Remove nested exception handlers if they don't change semantics",
	"cfr.aexagg.name": "Aggressive exception optimization",
	"cfr.aggressivesizethreshold.desc": "Opcode count at which to trigger aggressive reductions",
	"cfr.aggressivesizethreshold.name": "Aggressive threshold",
	"cfr.allowcorrecting.desc": "Allow transformations which correct errors, potentially at the cost of altering emitted code behaviour.",
	"cfr.allowcorrecting.name": "Allow correcting",
	"cfr.arrayiter.desc": "Re-sugar array based iteration.",
	"cfr.arrayiter.name": "Array iteration",
	"cfr.collectioniter.desc": "Re-sugar collection based iteration.",
	"cfr.collectioniter.name": "Collection iteration",
	"cfr.commentmonitors.desc": "Replace monitors with comments - useful if we're completely confused.",
	"cfr.commentmonitors.name": "Comment monitors",
	"cfr.comments.desc": "Output comments describing decompiler status, fallback flags etc.",
	"cfr.comments.name": "Comment info",
	"cfr.decodeenumswitch.desc": "Re-sugar switch on enum",
	"cfr.decodeenumswitch.name": "Decode enum-switch",
	"cfr.decodefinally.desc": "Re-sugar finally statements",
	"cfr.decodefinally.name": "Decode finally",
	"cfr.decodelambdas.desc": "Re-build lambda functions",
	"cfr.decodelambdas.name": "Decode lambdas",
	"cfr.decodestringswitch.desc": "Re-sugar switch on String",
	"cfr.decodestringswitch.name": "Decode string-switch",
	"cfr.dumpclasspath.desc": "Dump class path for debugging purposes",
	"cfr.dumpclasspath.name": "Dump class path",
	"cfr.eclipse.desc": "Enable transformations to handle eclipse code better.",
	"cfr.eclipse.name": "Eclipse",
	"cfr.elidescala.desc": "Hide things which aren't helpful in scala output (serialVersionUID, @ScalaSignature).",
	"cfr.elidescala.name": "Clean Scala",
	"cfr.forcecondpropagate.desc": "Pull results of deterministic jumps back through some constant assignments.",
	"cfr.forcecondpropagate.name": "Force condition propagation",
	"cfr.forceexceptionprune.desc": "Try to extend and merge exceptions more aggressively.",
	"cfr.forceexceptionprune.name": "Force exception pruning",
	"cfr.forcereturningifs.desc": "Move return up to jump site.",
	"cfr.forcereturningifs.name": "Force returning ifs",
	"cfr.forcetopsort.desc": "Force basic block sorting. Useful for flow-obfuscated code.",
	"cfr.forcetopsort.name": "Force top-sort",
	"cfr.forcetopsortaggress.desc": "Force extra aggressive topsort options.",
	"cfr.forcetopsortaggress.name": "Force top-sort:aggressive",
	"cfr.forloopaggcapture.desc": "Allow for loops to aggresively roll mutations into update section, even if they don't appear to be involved with the predicate",
	"cfr.forloopaggcapture.name": "For-loop capturing",
	"cfr.hidebridgemethods.desc": "Hide methods with bridge access",
	"cfr.hidebridgemethods.name": "Hide bridge methods",
	"cfr.hidelangimports.desc": "Hide imports from java.lang.*",
	"cfr.hidelangimports.name": "Hide lang imports",
	"cfr.hidelongstrings.desc": "Hide very long strings - useful if obfuscators have placed fake code in strings",
	"cfr.hidelongstrings.name": "Hide long strings",
	"cfr.hideutf.desc": "Hide UTF8 characters - quote them instead of showing the raw characters",
	"cfr.hideutf.name": "Hide UTF8",
	"cfr.innerclasses.desc": "Include inner classes in decompilation of outer-class.",
	"cfr.innerclasses.name": "Decompile inner classes",
	"cfr.j14classobj.desc": "Reverse Java 1.4 class object construction",
	"cfr.j14classobj.name": "Java 1.4 class object",
	"cfr.labelledblocks.desc": "Allow code to be emitted which uses labelled blocks, (handling odd forward gotos).",
	"cfr.labelledblocks.name": "Labelled blocks",
	"cfr.lenient.desc": "Be a bit more lenient in situations where we'd normally throw an exception",
	"cfr.lenient.name": "Lenient",
	"cfr.liftconstructorinit.desc": "Lift initialisation code common to all constructors into member initialisation",
	"cfr.liftconstructorinit.name": "Lift constructor init",
	"cfr.override.desc": "Generate @Override annotations (if method is seen to implement interface method, or override a base class method)",
	"cfr.override.name": "Emit @Override",
	"cfr.pullcodecase.desc": "Pull code into case statements aggressively.",
	"cfr.pullcodecase.name": "Pull code case",
	"cfr.recover.desc": "Allow more and more aggressive options to be set if decompilation fails",
	"cfr.recover.name": "Recover",
	"cfr.recovertypeclash.desc": "Split lifetimes where analysis caused type clash",
	"cfr.recovertypeclash.name": "Recover type clash",
	"cfr.recovertypehints.desc": "Recover type hints for iterators from first pass.",
	"cfr.recovertypehints.name": "Recover type hints",
	"cfr.recpass.desc": "Decompile specifically with recovery options from pass #X. (really only useful for debugging)",
	"cfr.recpass.name": "Recpass",
	"cfr.relinkconststring.desc": "Relink constant strings - if there is a local reference to a string which matches a static final, use the static final.",
	"cfr.relinkconststring.name": "Relink const-strings",
	"cfr.removebadgenerics.desc": "Hide generics where we've obviously got it wrong, and fallback to non-generic",
	"cfr.removebadgenerics.name": "Hide bad generics",
	"cfr.removeboilerplate.desc": "Remove boilerplate functions - constructor boilerplate, lambda deserialisation etc",
	"cfr.removeboilerplate.name": "Remove boilerplate",
	"cfr.removedeadmethods.desc": "Remove pointless methods - default constructor etc",
	"cfr.removedeadmethods.name": "Remove unused methods",
	"cfr.removeinnerclasssynthetics.desc": "Remove (where possible) implicit outer class references in inner classes",
	"cfr.removeinnerclasssynthetics.name": "Remove inner class synthetics",
	"cfr.renamedupmembers.desc": "Rename ambiguous/duplicate members.",
	"cfr.renamedupmembers.name": "Rename duplicate members",
	"cfr.renameenumidents.desc": "Rename ENUM identifiers which do not match their 'expected' string names.",
	"cfr.renameenumidents.name": "Rename enum identifiers",
	"cfr.renameillegalidents.desc": "Rename identifiers which are not valid java identifiers.",
	"cfr.renameillegalidents.name": "Rename illegal identifiers",
	"cfr.renamesmallmembers.desc": "Rename small members. Useful for proguard-like obfuscation.",
	"cfr.renamesmallmembers.name": "Rename small members",
	"cfr.showinferrable.desc": "Decorate methods with explicit types if not implied by arguments.",
	"cfr.showinferrable.name": "Show inferrable",
	"cfr.showops.desc": "Show some (cryptic!) debug info.",
	"cfr.showops.name": "Show OPs",
	"cfr.showversion.desc": "Show CFR version used in header",
	"cfr.showversion.name": "Show version",
	"cfr.silent.desc": "Don't display state while decompiling",
	"cfr.silent.name": "Silent",
	"cfr.staticinitreturn.desc": "Try to remove return from static init",
	"cfr.staticinitreturn.name": "Static init return",
	"cfr.stringbuffer.desc": "Convert new Stringbuffer().add.add.add to string + string + string",
	"cfr.stringbuffer.name": "Clean StringBuffer",
	"cfr.stringbuilder.desc": "Convert new Stringbuilder().add.add.add to string + string + string",
	"cfr.stringbuilder.name": "Clean StringBuilder",
	"cfr.stringconcat.desc": "Convert usages of StringConcatFactor to string + string + string",
	"cfr.stringconcat.name": "Deinfigy string concat",
	"cfr.sugarasserts.desc": "Re-sugar assert calls",
	"cfr.sugarasserts.name": "Sugar asserts",
	"cfr.sugarboxing.desc": "Where possible, remove pointless boxing wrappers",
	"cfr.sugarboxing.name": "Sugar boxing",
	"cfr.sugarenums.desc": "Re-sugar enums",
	"cfr.sugarenums.name": "Sugar enums",
	"cfr.switchexpression.desc": "Java 13 switch as expressions, where switches return values.",
	"cfr.switchexpression.name": "Switch expressions",
	"cfr.tidymonitors.desc": "Remove support code for monitors - eg catch blocks just to exit a monitor",
	"cfr.tidymonitors.name": "Tidy monitors",
	"cfr.tryresources.desc": "When active attempt to display try-catch blocks as try-with-resource blocks.",
	"cfr.tryresources.name": "Use try-with-resource",
	"cfr.usenametable.desc": "Use local variable name table if present.",
	"cfr.usenametable.name": "Use name table"
}

```

`src/test/java/me/coley/recaf/AssemblyAstTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.parse.bytecode.Parse;
import me.coley.recaf.parse.bytecode.ParseResult;
import me.coley.recaf.parse.bytecode.exception.ASTParseException;
import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.util.EscapeUtil;
import me.coley.recaf.util.RegexUtil;
import me.coley.recaf.util.TypeUtil;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.Type;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the bytecode AST and associated systems <i>(Assembler)</i>.
 *
 * @author Matt
 */
public class AssemblyAstTest {
	@Nested
	public class Format {
		@Test
		public void testParseComment() {
			String msg = "Hello world";
			String line = "//" + msg;
			CommentAST ast = single(line);
			assertEquals(msg, ast.getComment());
			assertEquals(line, ast.print());
		}

		@Test
		public void testSignature() {
			String pre = "SIGNATURE ";
			String sig = "Ljava/util/Set<Ljava/lang/String;>;";
			SignatureAST ast = single(pre + sig);
			assertEquals(sig, ast.getSignature());
			assertEquals(pre + sig, ast.print());
		}

		@Test
		public void testAlias() {
			RootAST root = Parse.parse(
					"ALIAS hello \"\"Hello World\"\"\n" +
					"LDC ${hello}").getRoot();
			LdcInsnAST ldc = (LdcInsnAST) root.getChildren().get(1);
			assertEquals("LDC \"Hello World\"", ldc.print());
		}

		@Test
		public void testAliasInAlias() {
			RootAST root = Parse.parse(
					"ALIAS one \"World\"\n" +
					"ALIAS two \"\"Hello ${one}\"\"\n" +
					"LDC ${two}").getRoot();
			LdcInsnAST ldc = (LdcInsnAST) root.getChildren().get(2);
			assertEquals("LDC \"Hello World\"", ldc.print());
		}

		@Test
		public void testParseCommentAfterNewline() {
			String msg = "test";
			String line = "//" + msg;
			CommentAST ast = single("\n" + line);
			assertEquals(msg, ast.getComment());
			assertEquals(line, ast.print());
		}

		@Test
		public void testParseLabel() {
			String name = "LABEL";
			String line = name + ":";
			LabelAST ast = single(line);
			assertEquals(name, ast.getName().getName());
			assertEquals(line, ast.print());
		}

		@Test
		public void testParseThrows() {
			String type = "java/lang/Exception";
			String line = "THROWS " + type;
			ThrowsAST ast = single(line);
			assertEquals(type, ast.getType().getType());
			assertEquals(line, ast.print());
		}

		@Test
		public void testMethodDefine() {
			MethodDefinitionAST def = single("DEFINE public static main([Ljava/lang/String; args)V");
			assertEquals("main", def.getName().getName());
			assertEquals(2, def.getModifiers().size());
			assertEquals("public", def.getModifiers().get(0).getName());
			assertEquals("static", def.getModifiers().get(1).getName());
			assertEquals(1, def.getArguments().size());
			assertEquals("[Ljava/lang/String;", def.getArguments().get(0).getDesc().getDesc());
			assertEquals("args", def.getArguments().get(0).getVariableName().getName());
			assertEquals("V", def.getReturnType().getDesc());
		}


		@Test
		public void testFieldDefine() {
			FieldDefinitionAST def = single("DEFINE public static Ljava/util/List; myList");
			assertEquals("myList", def.getName().getName());
			assertEquals(2, def.getModifiers().size());
			assertEquals("public", def.getModifiers().get(0).getName());
			assertEquals("static", def.getModifiers().get(1).getName());
			assertEquals("Ljava/util/List;", def.getType().getDesc());
		}

		@Test
		public void testMethodDefineNoModifiers() {
			MethodDefinitionAST def = single("DEFINE func(Ljava/lang/String; s)V");
			assertEquals("func", def.getName().getName());
			assertEquals(0, def.getModifiers().size());
		}

		@Test
		public void testFieldDefineNoModifiers() {
			FieldDefinitionAST def = single("DEFINE Ljava/util/List; myList");
			assertEquals("myList", def.getName().getName());
			assertEquals("Ljava/util/List;", def.getType().getDesc());
			assertEquals(0, def.getModifiers().size());
		}

		@Test
		public void testFieldDefinePrimitive() {
			FieldDefinitionAST def = single("DEFINE J myLong");
			assertEquals("myLong", def.getName().getName());
			assertEquals("J", def.getType().getDesc());
			assertEquals(0, def.getModifiers().size());
		}

		@Test
		public void testMethodDefineNoArgs() {
			MethodDefinitionAST def = single("DEFINE func()V");
			assertEquals("func", def.getName().getName());
			assertEquals(0, def.getArguments().size());
		}

		@Test
		public void testMethodDefineMultipleArgs() {
			MethodDefinitionAST def = single("DEFINE func(I int1, I int2)V");
			assertEquals("func", def.getName().getName());
			assertEquals(2, def.getArguments().size());
			assertEquals("I", def.getArguments().get(0).getDesc().getDesc());
			assertEquals("int1", def.getArguments().get(0).getVariableName().getName());
			assertEquals("I", def.getArguments().get(1).getDesc().getDesc());
			assertEquals("int2", def.getArguments().get(1).getVariableName().getName());
		}


		@Test
		public void testTryCatch() {
			TryCatchAST def = single("TRY start end CATCH(java/lang/Exception) handler");
			assertEquals("start", def.getLblStart().getName());
			assertEquals("end", def.getLblEnd().getName());
			assertEquals("handler", def.getLblHandler().getName());
			assertEquals("java/lang/Exception", def.getType().getType());
		}


		@Test
		public void testPrevNextLinkage() {
			String line = "//a\n//b\n//c";
			RootAST root = Parse.parse(line).getRoot();
			assertEquals(root.getChildren().get(0), root.getChildren().get(1).getPrev());
			assertEquals(root.getChildren().get(1), root.getChildren().get(2).getPrev());
			assertEquals(root.getChildren().get(1), root.getChildren().get(0).getNext());
			assertEquals(root.getChildren().get(2), root.getChildren().get(1).getNext());
			assertEquals(line, root.print());
		}

		@Test
		public void testInsn() {
			RootAST root = Parse.parse("ACONST_NULL\nARETURN").getRoot();
			assertEquals("ACONST_NULL", root.getChildren().get(0).print());
			assertEquals("ARETURN", root.getChildren().get(1).print());
		}

		@Test
		public void testIntInsn() {
			String text = "BIPUSH 5";
			IntInsnAST iiAst = single(text);
			assertEquals(text, iiAst.print());
			assertEquals("BIPUSH", iiAst.getOpcode().print());
			assertEquals(5, iiAst.getValue().getIntValue());
		}

		@Test
		public void testVarInsn() {
			String text = "ILOAD i";
			VarInsnAST iiAst = single(text);
			assertEquals(text, iiAst.print());
			assertEquals("ILOAD", iiAst.getOpcode().print());
			assertEquals("i", iiAst.getVariableName().getName());
		}

		@Test
		public void testTypeInsn() {
			String text = "NEW java/lang/String";
			TypeInsnAST tiAST = single(text);
			assertEquals(text, tiAST.print());
			assertEquals("NEW", tiAST.getOpcode().print());
			assertEquals("java/lang/String", tiAST.getType().getType());
		}

		@Test
		public void testIincInsn() {
			String text = "IINC i 2";
			IincInsnAST tiAST = single(text);
			assertEquals(text, tiAST.print());
			assertEquals("IINC", tiAST.getOpcode().print());
			assertEquals("i", tiAST.getVariableName().getName());
			assertEquals(2, tiAST.getIncrement().getIntValue());
		}

		@Test
		public void testLineInsn() {
			String text = "LINE lbl 2";
			LineInsnAST lineAST = single(text);
			assertEquals(text, lineAST.print());
			assertEquals("LINE", lineAST.getOpcode().print());
			assertEquals("lbl", lineAST.getLabel().getName());
			assertEquals(2, lineAST.getLineNumber().getIntValue());
		}

		@Test
		public void testNewArray() {
			String text = "NEWARRAY I";
			IntInsnAST arrayAST = single(text);
			assertEquals(text, arrayAST.print());
			assertEquals(TypeUtil.typeToNewArrayArg(Type.INT_TYPE), arrayAST.getValue().getIntValue());
		}

		@Test
		public void testMultiANewArrayInsn() {
			String text = "MULTIANEWARRAY [[Ljava/lang/String; 2";
			MultiArrayInsnAST arrayAST = single(text);
			assertEquals(text, arrayAST.print());
			assertEquals("MULTIANEWARRAY", arrayAST.getOpcode().print());
			assertEquals("[[Ljava/lang/String;", arrayAST.getDesc().getDesc());
			assertEquals(2, arrayAST.getDimensions().getIntValue());
		}

		@Test
		public void testFieldInsn() {
			String text = "GETSTATIC java/lang/System.out Ljava/io/PrintStream;";
			FieldInsnAST fieldAST = single(text);
			assertEquals(text, fieldAST.print());
			assertEquals("GETSTATIC", fieldAST.getOpcode().print());
			assertEquals("java/lang/System", fieldAST.getOwner().getType());
			assertEquals("out", fieldAST.getName().getName());
			assertEquals("Ljava/io/PrintStream;", fieldAST.getDesc().getDesc());
		}

		@Test
		public void testMethodInsn() {
			String text = "INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V";
			MethodInsnAST methodAST = single(text);
			assertEquals(text, methodAST.print());
			assertEquals("INVOKEVIRTUAL", methodAST.getOpcode().print());
			assertEquals("java/io/PrintStream", methodAST.getOwner().getType());
			assertEquals("println", methodAST.getName().getName());
			assertEquals("(Ljava/lang/String;)V", methodAST.getDesc().getDesc());
		}

		@Test
		public void testMethodInsnArrayReturn() {
			String text = "INVOKEVIRTUAL java/lang/String.getBytes()[B";
			MethodInsnAST methodAST = single(text);
			assertEquals(text, methodAST.print());
			assertEquals("INVOKEVIRTUAL", methodAST.getOpcode().print());
			assertEquals("java/lang/String", methodAST.getOwner().getType());
			assertEquals("getBytes", methodAST.getName().getName());
			assertEquals("()[B", methodAST.getDesc().getDesc());
		}

		@Test
		public void testLdcInsn() {
			// int
			String text = "LDC 1";
			LdcInsnAST ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("LDC", ldc.getOpcode().print());
			assertEquals(1, ((NumberAST) ldc.getContent()).getIntValue());
			// negative int
			text = "LDC -10";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(-10, ((NumberAST) ldc.getContent()).getIntValue());
			// long
			text = "LDC 10000000000L";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(10000000000L, ((NumberAST) ldc.getContent()).getLongValue());
			// negative long
			text = "LDC -10000000000L";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(-10000000000L, ((NumberAST) ldc.getContent()).getLongValue());
			// double
			text = "LDC 2.5";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(2.5, ((NumberAST) ldc.getContent()).getDoubleValue());
			// negative double
			text = "LDC -2.5";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(-2.5, ((NumberAST) ldc.getContent()).getDoubleValue());
			// float
			text = "LDC 2.6F";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(2.6F, ((NumberAST) ldc.getContent()).getFloatValue());
			// negative float
			text = "LDC -2.6F";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals(-2.6F, ((NumberAST) ldc.getContent()).getFloatValue());
			// string
			text = "LDC \"text\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("text", ((StringAST) ldc.getContent()).getValue());
			// empty string
			text = "LDC \"\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("", ((StringAST) ldc.getContent()).getValue());
			// newline string
			text = "LDC \"" + EscapeUtil.escape("\n") + "\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("\\n", ((StringAST) ldc.getContent()).getValue());
			assertEquals("\n", ((StringAST) ldc.getContent()).getUnescapedValue());
			// tab string
			text = "LDC \"" + EscapeUtil.escape("\t") + "\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("\\t", ((StringAST) ldc.getContent()).getValue());
			assertEquals("\t", ((StringAST) ldc.getContent()).getUnescapedValue());
			text = "LDC \"\t\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("\t", ((StringAST) ldc.getContent()).getValue());
			assertEquals("\t", ((StringAST) ldc.getContent()).getUnescapedValue());
			// Null terminator string, because people (obfuscators) are mean
			text = "LDC \"\\u0000\"";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("\\u0000", ((StringAST) ldc.getContent()).getUnescapedValue());
			// Unicode - escaped
			text = "LDC \"\\u4E0B\\u96E8\\u4E86\"";
			ldc = single(text);
			assertEquals("\\u4E0B\\u96E8\\u4E86", ((StringAST) ldc.getContent()).getValue());
			assertEquals("下雨了", ((StringAST) ldc.getContent()).getUnescapedValue());
			assertEquals(text, ldc.print());
			// Unicode - unescaped
			text = "LDC \"下雨了\"";
			ldc = single(text);
			assertEquals("下雨了", ((StringAST) ldc.getContent()).getValue());
			assertEquals("下雨了", ((StringAST) ldc.getContent()).getUnescapedValue());
			assertEquals(text, ldc.print());
			// Unicode - but not actually unicode. Its close but not exact so it shouldn't match.
			text = "LDC \"\\u048\"";
			ldc = single(text);
			assertEquals("\\u048", ((StringAST) ldc.getContent()).getValue());
			assertEquals("\\u048", ((StringAST) ldc.getContent()).getUnescapedValue());
			assertEquals(text, ldc.print());
			// Windows path url
			text = "LDC \"" + EscapeUtil.escapeCommon("C:\\example\\recaf.jar") + "\"";
			ldc = single(text);
			assertEquals("C:\\\\example\\\\recaf.jar", ((StringAST) ldc.getContent()).getValue());
			assertEquals("C:\\example\\recaf.jar", ((StringAST) ldc.getContent()).getUnescapedValue());
			assertEquals(text, ldc.print());
			// type
			text = "LDC Ljava/lang/String;";
			ldc = single(text);
			assertEquals(text, ldc.print());
			assertEquals("Ljava/lang/String;", ((DescAST) ldc.getContent()).getDesc());
		}

		@Test
		public void testTableSwitchInsn() {
			String text = "TABLESWITCH range[0:2] offsets[A, B, C] default[D]";
			TableSwitchInsnAST tbl = single(text);
			assertEquals(text, tbl.print());
			assertEquals("TABLESWITCH", tbl.getOpcode().print());
			assertEquals("D", tbl.getDfltLabel().print());
			assertEquals(0, tbl.getRangeMin().getIntValue());
			assertEquals(2, tbl.getRangeMax().getIntValue());
			assertEquals(3, tbl.getLabels().size());
		}

		@Test
		public void testLookupSwitchInsn() {
			String text = "LOOKUPSWITCH mapping[0=A, 1=B, 2=C] default[D]";
			LookupSwitchInsnAST tbl = single(text);
			assertEquals(text, tbl.print());
			assertEquals("LOOKUPSWITCH", tbl.getOpcode().print());
			assertEquals("D", tbl.getDfltLabel().print());
			assertEquals(3, tbl.getMapping().size());
		}

		@Test
		public void testEmptyLookupSwitchInsn() {
			String text = "LOOKUPSWITCH mapping[] default[D]";
			LookupSwitchInsnAST tbl = single(text);
			assertEquals(text, tbl.print());
			assertEquals("LOOKUPSWITCH", tbl.getOpcode().print());
			assertEquals("D", tbl.getDfltLabel().print());
			assertEquals(0, tbl.getMapping().size());
		}

		@Test
		public void testInvokeDynamic() {
			String text = "INVOKEDYNAMIC handle (Lgame/SnakeController;)Ljavafx/event/EventHandler; "
					+ H_META + " args[handle[H_INVOKESTATIC game/FxMain" +
					".lambda$start$0(Lgame/SnakeController;Ljavafx/scene/input/KeyEvent;)V], " +
					"(Ljavafx/event/Event;)V, (Ljavafx/scene/input/KeyEvent;)V]";
			InvokeDynamicAST indy = single(text);
			assertEquals(text, indy.print());
			assertEquals("INVOKEDYNAMIC", indy.getOpcode().print());
			assertEquals("handle", indy.getName().getName());
			assertEquals("(Lgame/SnakeController;)Ljavafx/event/EventHandler;", indy.getDesc().getDesc());

			 text = "INVOKEDYNAMIC handle (Lgame/SnakeController;)Ljavafx/event/EventHandler; "
					+ H_META + " args[-1]";
			 indy = single(text);
			assertEquals(text, indy.print());
		}

		@Test
		public void testInvokeDynamicHandleWithArrType() {
			String text = "INVOKEDYNAMIC apply ([LString;)" +
					"LIntFunction; handle[H_INVOKESTATIC Meta.factory(LLookup;LString;LMethodType;LMethodType;LMethodHandle;LMethodType;)LCallSite;] " +
					"args[" +
					"handle[H_INVOKESTATIC TextBlockLiteralExpr.stripIndent([LString;I)LPair;]" +
					"]";
			InvokeDynamicAST indy = single(text);
			assertEquals(text, indy.print());
			HandleAST handle = (HandleAST) indy.getArgs().get(0);
			assertEquals("H_INVOKESTATIC", handle.getTag().getName());
			assertEquals("TextBlockLiteralExpr", handle.getOwner().getType());
			assertEquals("stripIndent", handle.getName().getName());
			assertEquals("([LString;I)LPair;", handle.getDesc().getDesc());
		}

		@Test
		public void testInvokeDynamicNoArgs() {
			String text = "INVOKEDYNAMIC y (IJ)Ljava/lang/String; handle[H_INVOKESTATIC " +
					"com/example.call(Ljava/lang/invoke/MethodHandles$Lookup;" +
					"Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;] " +
					"args[]";
			InvokeDynamicAST indy = single(text);
			assertEquals(text, indy.print());
		}

		@Test
		public void testInvokeDynamicStringWithCommaArgs() {
			String text = "INVOKEDYNAMIC y (IJ)Ljava/lang/String; handle[H_INVOKESTATIC " +
					"com/example.call(Ljava/lang/invoke/MethodHandles$Lookup;" +
					"Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;] " +
					"args[\",aaaa\", \"bb,bb\", \"cccc,\", 0]";
			InvokeDynamicAST indy = single(text);
			assertEquals(text, indy.print());
		}
	}

	@Nested
	public class Suggestions {
		@Test
		public void testTypeInsnSuggest() {
			List<String> suggestions = suggest(null, "NEW java/lang/Stri");
			assertTrue(suggestions.contains("java/lang/String"));
		}

		@Test
		public void testMultiANewArrayInsnSuggest() {
			List<String> suggestions = suggest(null, "MULTIANEWARRAY [Ljava/lang/Stri");
			assertTrue(suggestions.contains("[Ljava/lang/String;"));
		}

		@Test
		public void testTypeSuggestFromField() {
			List<String> suggestions = suggest(null, "GETSTATIC java/lang/Syst");
			assertTrue(suggestions.contains("java/lang/System"));
		}

		@Test
		public void testMemberSuggestFromField() {
			List<String> suggestions = suggest(null, "GETSTATIC java/lang/System.ou");
			assertTrue(suggestions.contains("out Ljava/io/PrintStream;"));
		}

		@Test
		public void testTypeSuggestFromMethod() {
			List<String> suggestions = suggest(null, "INVOKESTATIC java/lang/Syst");
			assertTrue(suggestions.contains("java/lang/System"));
		}

		@Test
		public void testMemberSuggestFromMethod() {
			List<String> suggestions = suggest(null, "INVOKESTATIC java/io/PrintStream.printl");
			assertTrue(suggestions.contains("println(Ljava/lang/String;)V"));
		}

		@Test
		public void testVariableSuggestFromInsns() {
			ParseResult<RootAST> ast = Parse.parse("ISTORE example\nISTORE other\nISTORE also");
			List<String> suggestions = suggest(ast, "ILOAD ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testVariableSuggestFromDefinition() {
			ParseResult<RootAST> ast = Parse.parse("DEFINE public static main([Ljava/lang/String; args)V");
			List<String> suggestions = suggest(ast, "ALOAD a");
			assertTrue(suggestions.contains("args"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testLabelSuggestJump() {
			ParseResult<RootAST> ast = Parse.parse("example:\nother:");
			List<String> suggestions = suggest(ast, "GOTO ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testLabelSuggestSwitch() {
			ParseResult<RootAST> ast = Parse.parse("example:\nother:");
			List<String> suggestions = suggest(ast, "TABLESWITCH range[0-2] offsets[A, B, C] default[ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
			//
			suggestions = suggest(ast, "TABLESWITCH range[0-2] offsets[A, B, ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testLookupSwitchInsn() {
			ParseResult<RootAST> ast = Parse.parse("example:\nother:");
			List<String> suggestions = suggest(ast, "LOOKUPSWITCH mapping[0=A, 1=B, 2=C] default[ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
			//
			ast = Parse.parse("example:\nother:");
			suggestions = suggest(ast, "LOOKUPSWITCH mapping[0=A, 1=B, 2=ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testCatchType() {
			List<String> suggestions = suggest(null, "TRY start end CATCH(java/lang/Exce");
			assertTrue(suggestions.contains("java/lang/Exception"));
		}

		@Test
		public void testLabelSuggestLine() {
			ParseResult<RootAST> ast = Parse.parse("example:\nother:");
			List<String> suggestions = suggest(ast, "LINE ex");
			assertTrue(suggestions.contains("example"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testIndySuggestHandleTag() {
			List<String> suggestions = suggest(null, "INVOKEDYNAMIC name ()V handle[H_GET");
			assertTrue(suggestions.contains("H_GETSTATIC"));
			assertTrue(suggestions.contains("H_GETFIELD"));
			assertEquals(2, suggestions.size());
		}

		@Test
		public void testIndySuggestHandleField() {
			List<String> suggestions = suggest(null, "INVOKEDYNAMIC name ()V handle[H_GETSTATIC java/lang/System.ou");
			assertTrue(suggestions.contains("out Ljava/io/PrintStream;"));
			assertEquals(1, suggestions.size());
		}

		@Test
		public void testIndySuggestHandleMethod() {
			List<String> suggestions = suggest(null, "INVOKEDYNAMIC name ()V handle[H_INVOKEVIRTUAL java/io/PrintStream.printl");
			assertTrue(suggestions.contains("println(Ljava/lang/String;)V"));
		}


		@Test
		public void testDoesNotSuggestAlreadyTyped() {
			ParseResult<RootAST> ast = Parse.parse("example:\nother:");
			List<String> suggestions = suggest(ast, "GOTO example");
			assertFalse(suggestions.contains("example"));
			assertTrue(suggestions.isEmpty());
		}
	}

	@Nested
	public class Errors {
		@Test
		public void testBadInsn() {
			// Not real opcode name: "ACONST_OOF"
			assertErrors(() -> Parse.parse("ACONST_OOF"));
			assertErrors(() -> Parse.parse("IRETURN\nACONST_OOF\nIRETURN "));
		}

		@Test
		public void testParseBadThrows() {
			assertErrors(() -> Parse.parse("THROWS"));
			assertErrors(() -> Parse.parse("THROWS "));
			assertErrors(() -> Parse.parse("THROWS  "));
			assertErrors(() -> Parse.parse("THROWS\t"));
		}

		@Test
		public void testParseBadType() {
			assertErrors(() -> Parse.parse("THROWS no spaces allowed"));
			assertErrors(() -> Parse.parse("THROWS no_;_allowed"));
			assertErrors(() -> Parse.parse("THROWS Ljava/lang/String;"));
		}

		@Test
		public void testParseBadDefine() {
			assertErrors(() -> Parse.parse("DEFINE "));
			assertErrors(() -> Parse.parse("DEFINE ()V"));
			assertErrors(() -> Parse.parse("DEFINE (I arg)V"));
			assertErrors(() -> Parse.parse("DEFINE name()"));
			assertErrors(() -> Parse.parse("DEFINE notstatic name()V"));
			assertErrors(() -> Parse.parse("DEFINE name(NotDesc arg)V"));
			assertErrors(() -> Parse.parse("DEFINE name(LDesc;)V"));
		}

		@Test
		public void testBadTryCatch() {
			// Missing catch type
			assertErrors(() -> Parse.parse("TRY start end CATCH() handler"));
			assertErrors(() -> Parse.parse("TRY start end CATCH handler"));
			// Missing
			assertErrors(() -> Parse.parse("TRY start end"));
			assertErrors(() -> Parse.parse("TRY start"));
			assertErrors(() -> Parse.parse("TRY"));
		}

		@Test
		public void testBadInt() {
			// Long
			assertErrors(() -> Parse.parse("BIPUSH 100000000000000"));
			// Float
			assertErrors(() -> Parse.parse("BIPUSH 120F"));
			// Double
			assertErrors(() -> Parse.parse("BIPUSH 120.0"));
		}

		@Test
		public void testBadField() {
			// Invalid because no name could be matched
			assertErrors(() -> Parse.parse("GETFIELD Dummy Ljava/lang/Stri"));
			// Invalid because field descriptor is not complete
			assertErrors(() -> Parse.parse("GETFIELD Dummy.in Ljava/lang/Stri"));
			// Invalid because field descriptor is not complete
			assertErrors(() -> Parse.parse("GETFIELD Dummy.in [[Ljava/lang/Stri"));
			// Invalid because field only specifies owner
			assertErrors(() -> Parse.parse("GETFIELD Dummy"));
		}

		@Test
		public void testBadMethod() {
			// missing variable name, but has desc
			assertErrors(() -> Parse.parse("INVOKESTATIC Dummy.(I)V"));
			// missing return type
			assertErrors(() -> Parse.parse("INVOKESTATIC Dummy.call(I)"));
			// descriptor is incomplete
			assertErrors(() -> Parse.parse("INVOKESTATIC Dummy.call(I"));
			assertErrors(() -> Parse.parse("INVOKESTATIC Dummy.call("));
			// descriptor is missing
			assertErrors(() -> Parse.parse("INVOKESTATIC Dummy.call"));
		}
	}

	// ================================================================ //
	// ============================= UTILS ============================ //
	// ================================================================ //

	private static List<String> suggest(ParseResult<RootAST> ast, String line) {
		// Don't suggest opcodes, not the point here
		if (!line.contains(" "))
			return Collections.emptyList();
		// Create dummy AST if needed
		if (ast == null)
			ast = Parse.parse("");
		try {
			String firstToken = Objects.requireNonNull(RegexUtil.getFirstWord(line));
			String lastToken = Objects.requireNonNull(RegexUtil.getLastWord(line));
			return Parse.getParser(-1, firstToken).suggest(ast, line).stream()
					.filter(option -> !lastToken.equals(option))
					.collect(Collectors.toList());
		} catch(Exception ex) {
			fail(ex);
			return null;
		}
	}

	private static void assertErrors(Supplier<ParseResult<?>> resultSupplier) {
		List<ASTParseException> problems = resultSupplier.get().getProblems();
		// problems.forEach(e -> System.err.println(e.getMessage()));
		assertFalse(problems.isEmpty());
	}

	@SuppressWarnings("unchecked")
	private static <T extends AST> T single(String line) {
		try {
			ParseResult<RootAST> res = Parse.parse(line);
			if (!res.isSuccess())
				fail(res.getProblems().get(0));
			return (T) res.getRoot().getChildren().get(0);
		} catch(ClassCastException ex) {
			fail(ex);
			return (T) new RootAST();
		}
	}

	// Hiding the ugly constant down here
	private static final String H_META = "handle[H_INVOKESTATIC java/lang/invoke/LambdaMetafactory." +
			"metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;" +
			"Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;" +
			"Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)" +
			"Ljava/lang/invoke/CallSite;]";
}

```

`src/test/java/me/coley/recaf/AssemblyCasesTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.parse.bytecode.*;
import me.coley.analysis.value.VirtualValue;
import me.coley.analysis.value.AbstractValue;
import me.coley.recaf.parse.bytecode.ast.RootAST;
import me.coley.recaf.parse.bytecode.exception.AssemblerException;
import me.coley.recaf.parse.bytecode.exception.VerifierException;
import me.coley.recaf.workspace.LazyClasspathResource;
import org.junit.jupiter.api.*;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.Frame;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.*;
import static me.coley.recaf.util.TestUtils.*;

/**
 * More verbose cases for the assembler.
 *
 * @author Matt
 */
public class AssemblyCasesTest {
	private static final String D1 = "DEFINE static func()V\nSTART:\n";
	private static final String D2 = "\nEND:\n";

	@BeforeEach
	public void setup() throws IOException {
		// Set dummy controller/workspace so type analysis works
		Recaf.setController(setupController(LazyClasspathResource.get()));
	}

	@AfterEach
	public void shutdown() {
		removeController();
	}

	@Nested
	public class VerifyPassCases {
		@Test
		public void testSharedExceptionHandlerOfDifferentTypes() {
			String s = "DEFINE PRIVATE example()Z\n" +
					"TRY EX_START EX_END CATCH(java/lang/InterruptedException) EX_HANDLER\n" +
					"TRY EX_START EX_END CATCH(java/util/concurrent/TimeoutException) EX_HANDLER\n" +
					"EX_START:\n" +
					"NOP\n" +
					"EX_END:\n" +
					"GOTO EXIT\n" +
					"EX_HANDLER:\n" +
					"ASTORE 1\n" +
					"ICONST_0\n" +
					"IRETURN\n" +
					"EXIT:\n" +
					"ICONST_1\n" +
					"IRETURN";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testScopedVariableDiffs() {
			String s = "DEFINE public static hi()V\n" +
					"A:\n" +
					"LCONST_1\n" +
					"LSTORE 0\n" +
					"B:\n" +
					"GOTO C\n" +
					"C:\n" +
					"ICONST_1\n" +
					"ISTORE 1\n" +
					"D:\n" +
					"RETURN";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testScopedVariableDiffsAlt() {
			String s = "DEFINE public static hi()V\n" +
					"A:\n" +
					"ICONST_1\n" +
					"ISTORE 1\n" +
					"B:\n" +
					"GOTO C\n" +
					"C:\n" +
					"LCONST_1\n" +
					"LSTORE 0\n" +
					"D:\n" +
					"RETURN";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testHelloWorld() {
			String s = "DEFINE public static hi()V\n" +
					"A:\n" +
					"LINE A 4\n" +
					"GETSTATIC java/lang/System.out Ljava/io/PrintStream;\n" +
					"LDC \"Hello world\"\n" +
					"INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V\n" +
					"B:\n" +
					"LINE B 5\n" +
					"RETURN";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testOnlyParameterLocals() {
			String s = "DEFINE public add(I unused, I count)V\n" +
					"START:\n" +
					"ALOAD this\n" +
					"DUP\n" +
					"GETFIELD Test.increment I\n" +
					"ILOAD count\n" + "" +
					"IADD\n" +
					"PUTFIELD Test.increment I\n" +
					"RETURN\n" +
					"END:";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testPutStatic() {
			String s = "DEFINE public static init()V\n" +
					"THROWS java/io/IOException\n" +
					"A:\n" +
					"LDC Ljava/lang/System;\n" +
					"LDC \"/logo.png\"\n" +
					"INVOKEVIRTUAL java/lang/Class.getResource(Ljava/lang/String;)Ljava/net/URL;\n" +
					"INVOKESTATIC javax/imageio/ImageIO.read(Ljava/net/URL;)Ljava/awt/image/BufferedImage;\n" +
					"PUTSTATIC Test.logo Ljava/awt/image/BufferedImage;\n" +
					"RETURN";
			verifyPass(Parse.parse(s));
		}

		@Test
		public void testStoreBoolInInt() {
			verifyPass(parse("ICONST_0\nPUTSTATIC Test.boolVal Z\nRETURN"));
		}

		@Test
		public void testPassIntAsBool() {
			verifyPass(parse("ICONST_0\nINVOKESTATIC Test.func(Z)V\nRETURN"));
		}

		@Test
		public void testPrimitiveLongUnknownValue() {
			// Unknown long value from, 'nanoTime()'
			//  - Attempt to do math with value should not fail...
			//  - Instead, "we know the type, but not the value"
			String s = "DEFINE static public time()F\n" +
					"A:\n" +
					"INVOKESTATIC java/lang/System.nanoTime()J\n" +
					"LDC 1000000L\n" +
					"LDIV\n" +
					"L2F\n" +
					"LDC 1000.0F\n" +
					"FDIV\n" +
					"FRETURN";
			verifyPass(parseLit(s));
		}

		@Test
		public void testNullVarDiscoversTypeInControlFlowEdge() {
			verifyPass(parseLit(
					"DEFINE STATIC call()I\n" +
					"START:\n" +
					// Eventual return value
					"ICONST_0\n" +
					// string = null
					"ACONST_NULL\n" +
					"ASTORE string\n" +
					// if (whatever.number != 0) string = targetString
					"GETSTATIC whatever.number I\n" +
					"IFEQ SKIP\n" +
					"GETSTATIC whatever.targetString Ljava/lang/String;\n" +
					// new Result(string)
					"ASTORE string\n" +
					"SKIP:\n" +
					"ALOAD string\n" +
					"PUTSTATIC whatever.output Ljava/lang/String;\n" +
					"IRETURN\n" +
					"END:"
			));
		}

		@Test
		public void testReservedVariableIndicesFreeAfterScopeChange1() {
			try {
				/*
				 try {
				     $0 = 0.0D; // also reserves $1
				     $2 = 0.0D; // also reserves $3
				 } catch (Throwable t) {}
				 $1 = 0;
				 $3 = 0;
				 */
				verifyPass(parse("" +
						"TRY EX_START EX_END CATCH(java/lang/Throwable) EX_HANDLER\n" +
						"EX_START:\n" +
						"DCONST_0\n" +
						"DSTORE 0\n" +
						"DCONST_0\n" +
						"DSTORE 2\n" +
						"GOTO EXIT_TRY\n" +
						"EX_END:\n" +
						"EX_HANDLER:\n" +
						"POP\n" +
						"GOTO EXIT_TRY\n" +
						"EXIT_TRY:\n" +
						"ICONST_1\n" +
						"ISTORE 1\n" +
						"ICONST_3\n" +
						"ISTORE 3\n" +
						"C:\n" +
						"RETURN"));
			} catch(Exception ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testReservedVariableIndicesFreeAfterScopeChange2() {
			try {
				/*
				 if (String.value != null) {
				     $0 = 0.0D; // also reserves $1
				     $2 = 0.0D; // also reserves $3
				 }
				 $1 = 0;
				 $3 = 0;
				 */
				verifyPass(parse("" +
						"A:\n" +
						"GETSTATIC java/lang/String.value Ljava/lang/String;\n" +
						"IFNULL B\n" +
						"DCONST_0\n" +
						"DSTORE 0\n" +
						"DCONST_0\n" +
						"DSTORE 2\n" +
						"B:\n" +
						"ICONST_1\n" +
						"ISTORE 1\n" +
						"ICONST_3\n" +
						"ISTORE 3\n" +
						"C:\n" +
						"RETURN"));
			} catch(Exception ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testTypeDiscoveryInTryCatch() {
			verifyPass(parseLit(
					"DEFINE STATIC dump(LMyStream; stream)[B\n"+
					"TRY EX_START EX_END CATCH(java/lang/Throwable) EX_HANDLER\n"+
					"START:\n"+
					// out = null
					"ACONST_NULL\n"+
					"ASTORE out\n"+
					// out=stream.getValue()
					// stream.close()
					"EX_START:\n"+
					"ALOAD stream\n"+
					"INVOKEVIRTUAL MyStream.getValue()[B;\n"+
					"ASTORE out\n"+
					"ALOAD stream\n"+
					"INVOKEVIRTUAL MyStream.close()V\n"+
					"EX_END:\n"+
					"GOTO RET_ADDR\n"+
					// Error
					"EX_HANDLER:\n"+
					"ACONST_NULL\n"+
					"INVOKEVIRTUAL java/lang/Throwable.addSuppressed(Ljava/lang/Throwable;)V\n"+
					"ACONST_NULL\n"+
					"ASTORE out\n"+
					// Load and ret
					"RET_ADDR:\n"+
					"ALOAD out\n"+
					"ARETURN\n"+
					"THE_END:"
			));
		}

		@Test
		public void testTypeDiscoveryInIfStatement() {
			// The "myType" variable should be "Type"
			// But its initially null, so we only assume "Object"
			// It is set to a "Type" in a branch. We want to make sure this knowledge is used.
			String s = "DEFINE static from(LType; var0, LType; var1)LType;\n" +
					"A:\n" +
					"ACONST_NULL\n" +
					"ASTORE myType\n" +
					"ICONST_0\n" +
					"IFEQ B\n" +
					"NEW Type\n" +
					"ASTORE myType\n" +
					"B:\n" +
					"ALOAD myType\n" +
					"ARETURN\n" +
					"C:";
			verifyPass(parseLit(s));
		}
	}

	@Nested
	public class VerifyFailingCases {
		@Test
		public void testScopedVariableDiffs() {
			// This is the same as the passing test case, but without the jump.
			// With no jump, there is no ability for a scope change.
			String s = "DEFINE public static hi()V\n" +
					"A:\n" +
					"LCONST_1\n" +
					"LSTORE 0\n" +
					"B:\n" +
					"ICONST_1\n" +
					"ISTORE 1\n" +
					"C:\n" +
					"RETURN";
			try {
				verifyFails(Parse.parse(s));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testStoreObjInInt() {
			try {
				verifyFails(parse("ACONST_NULL\nISTORE 0\nRETURN"));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testStoreIntAsObj() {
			try {
				verifyFails(parse("ICONST_0\nASTORE 0\nRETURN"));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testVoidHasObjReturn() {
			try {
				verifyFails(parse("ACONST_NULL\nARETURN"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testReferenceOnPrimitive() {
			try {
				verifyFails(parse("ICONST_0\nINVOKEVIRTUAL owner.name()V\nRETURN"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testStoreDoubleInInt() {
			try {
				verifyFails(parse(
						"DCONST_1\n" +
						"ISTORE test\n" +
						"RETURN"));
				verifyFails(parse(
						"INVOKESTATIC test.get()D\n" +
						"ISTORE test\n" +
						"RETURN"));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testStoreDoubleInInt2() {
			try {
				verifyFails(parse(
						"DCONST_1\n" +
						"ISTORE 0\n" +
						"RETURN"));
				verifyFails(parse(
						"INVOKESTATIC test.get()D\n" +
						"ISTORE 0\n" +
						"RETURN"));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testInvokeOnNull() {
			try {
				verifyFails(parse("ACONST_NULL\nICONST_0\nINVOKEVIRTUAL test.get(I)V\nRETURN"));
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testPopOnEmpty() {
			try {
				verifyFails(parse("POP\nRETURN"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testPop2On1Size() {
			try {
				verifyFails(parse("ACONST_NULL\nPOP2\nRETURN"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testMissingReturn() {
			try {
				verifyFails(parse("NOP"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testStoreInWideVariableTypesReservedSpace() {
			try {
				// Double takes two spots, 0 and 1
				// Should fail if we try to save to 1
				verifyFails(parse("DCONST_0\nDSTORE 0\nICONST_0\nISTORE 1\nRETURN"));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testPutStaticObjectIntoInt() {
			try {
				String s = "LDC Ljava/lang/System;\n" +
						"LDC \"/logo.png\"\n" +
						"INVOKEVIRTUAL java/lang/Class.getResource(Ljava/lang/String;)Ljava/net/URL;\n" +
						"PUTSTATIC Test.url I\n" +
						"RETURN";
				verifyFails(parse(s));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}

		@Test
		public void testPutStaticIntIntoObject() {
			try {
				String s = "BIPUSH 32\n" +
						"PUTSTATIC Test.value Ljava/lang/Object;\n" +
						"RETURN";
				verifyFails(parse(s));
			} catch(AssemblerException ex) {
				// Catches "assembler.compile"
				fail(ex);
			}
		}
	}

	@Nested
	public class Variables {
		@Test
		public void testRawIndices() {
			try {
				MethodNode node = compile(parse(
						"ICONST_0\nISTORE 0\n" +
								"ICONST_0\nISTORE 1\n" +
								"ICONST_0\nISTORE 2\n"));
				assertEquals(0, ((VarInsnNode) node.instructions.get(2)).var);
				assertEquals(1, ((VarInsnNode) node.instructions.get(4)).var);
				assertEquals(2, ((VarInsnNode) node.instructions.get(6)).var);
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testNamedIndices() {
			try {
				MethodNode node = compile(parse(
						"ICONST_0\nISTORE zero\n" +
								"ICONST_0\nISTORE one\n" +
								"ICONST_0\nISTORE two\n"));
				assertEquals(0, ((VarInsnNode) node.instructions.get(2)).var);
				assertEquals(1, ((VarInsnNode) node.instructions.get(4)).var);
				assertEquals(2, ((VarInsnNode) node.instructions.get(6)).var);
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testMixedIndices() {
			try {
				MethodNode node = compile(parse(
						"ICONST_0\nISTORE 0\n" +
								"ICONST_0\nISTORE k\n" +
								"ICONST_0\nISTORE 2\n"));
				assertEquals(0, ((VarInsnNode) node.instructions.get(2)).var);
				assertEquals(1, ((VarInsnNode) node.instructions.get(4)).var);
				assertEquals(2, ((VarInsnNode) node.instructions.get(6)).var);
			} catch(AssemblerException ex) {
				fail(ex);
			}
		}

		@Test
		public void testStaticArgsAndTwoWordStorage() {
			String s = "DEFINE static from(LType; var0, LType; var1)LType;\n" +
					"A:\n" +
					"LCONST_0\n" +
					"LSTORE var2\n" +
					"B:\n" +
					"ACONST_NULL\n" +
					"ARETURN";
			verifyPass(parseLit(s));
		}
	}

	@Nested
	public class InvokeSimulation {
		@Test
		public void testStaticMathCall() {
			int large = 20;
			int small = 5;
			Frame<AbstractValue>[] frames = getFrames(parse(
					"A:\n" +
					"BIPUSH " + large + "\n" +
					"BIPUSH " + small + "\n" +
					"INVOKESTATIC java/lang/Math.min(II)I\n" +
					"ISTORE 0\n" +
					"B:\n" +
					"RETURN"));
			assertEquals(small, frames[frames.length - 2].getLocal(0).getValue());
		}

		@Test
		public void testStringLength() {
			String str = "1234567";
			Frame<AbstractValue>[] frames = getFrames(parse(
					"A:\n" +
					"LDC \"" + str + "\"\n" +
					"INVOKEVIRTUAL java/lang/String.length()I\n" +
					"ISTORE 0\n" +
					"B:\n" +
					"RETURN"));
			assertEquals(str, frames[3].getStack(0).getValue());
			assertEquals(str.length(), frames[4].getStack(0).getValue());
		}

		@Test
		public void testCompilerGeneratedStringBuilder() {
			String part1 = "Hello";
			String part2 = "World";
			Frame<AbstractValue>[] frames = getFrames(parse(
					"A:\n" +
					"LDC \""+ part1 + "\"\n" +
					"ASTORE s\n" +
					"NEW java/lang/StringBuilder\n" +
					"DUP\n" +
					"INVOKESPECIAL java/lang/StringBuilder.<init>()V\n" +
					"ALOAD s\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"LDC \""+ part2 + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.toString()Ljava/lang/String;\n" +
					"ASTORE s\n" +
					"RETURN"));
			assertEquals(part1 + part2, frames[frames.length - 2].getStack(0).getValue());
		}

		@Test
		public void testManualStringBuilder() {
			String part1 = "Hello";
			String part2 = "World";
			Frame<AbstractValue>[] frames = getFrames(parse(
					"A:\n" +
					"NEW java/lang/StringBuilder\n" +
					"DUP\n" +
					"INVOKESPECIAL java/lang/StringBuilder.<init>()V\n" +
					"ASTORE sb\n" +
					"B:\n" +
					"ALOAD sb\n" +
					"LDC \""+ part1 + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"LDC \""+ part2 + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"POP\n" +
					"ALOAD sb\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.toString()Ljava/lang/String;\n" +
					"ASTORE str\n" +
					"RETURN"));
			VirtualValue retFrameLocal = (VirtualValue) frames[frames.length - 2].getLocal(1);
			assertEquals(part1 + part2, retFrameLocal.getValue());
		}

		@Test
		public void testDontMergeWhenScopeChanges() {
			String initial = "INIT";
			String one = "PATH_A";
			String two = "PATH_B";
			Frame<AbstractValue>[] frames = getFrames(parse(
					"NEW java/lang/StringBuilder\n" +
					"DUP\n" +
					"LDC \""+ initial + "\"\n" +
					"INVOKESPECIAL java/lang/StringBuilder.<init>(Ljava/lang/String;)V\n" +
					"ASTORE sb\n" +
					"B:\n" +
					"INVOKESTATIC MyClass.someBool()Z\n" +
					"IFEQ D\n" +
					"C:\n" +
					"ALOAD sb\n" +
					"LDC \""+ one + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"GOTO E\n" +
					"D:\n" +
					"ALOAD sb\n" +
					"LDC \""+ two + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"E:\n" +
					"ALOAD sb\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.toString()Ljava/lang/String;\n" +
					"INVOKESTATIC Logger.print(Ljava/lang/String;)V\n" +
					"RETURN"));
			VirtualValue retFrameLocal = (VirtualValue) frames[frames.length - 2].getLocal(0);
			assertFalse(retFrameLocal.isNull());
			assertFalse(retFrameLocal.isValueUnresolved());
			assertNotEquals(initial, retFrameLocal.getValue());
			assertNotEquals(one, retFrameLocal.getValue());
			assertNotEquals(two, retFrameLocal.getValue());
		}

		@Test
		@Disabled
		// TODO: Manage opaque predicates
		public void testMergeWithOpaquePredicate() {
			String initial = "INIT";
			String one = "PATH_A";
			String two = "PATH_B";
			Frame<AbstractValue>[] frames = getFrames(parse(
					"NEW java/lang/StringBuilder\n" +
					"DUP\n" +
					"LDC \""+ initial + "\"\n" +
					"INVOKESPECIAL java/lang/StringBuilder.<init>(Ljava/lang/String;)V\n" +
					"ASTORE sb\n" +
					"B:\n" +
					"ICONST_0\n" +
					"IFEQ D\n" +
					"C:\n" +
					"ALOAD sb\n" +
					"LDC \""+ one + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"GOTO E\n" +
					"D:\n" +
					"ALOAD sb\n" +
					"LDC \""+ two + "\"\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;\n" +
					"E:\n" +
					"ALOAD sb\n" +
					"INVOKEVIRTUAL java/lang/StringBuilder.toString()Ljava/lang/String;\n" +
					"INVOKESTATIC Logger.print(Ljava/lang/String;)V\n" +
					"RETURN"));
			VirtualValue retFrameLocal = (VirtualValue) frames[frames.length - 2].getLocal(0);
			assertFalse(retFrameLocal.isNull());
			assertFalse(retFrameLocal.isValueUnresolved());
			assertNotEquals(initial, retFrameLocal.getValue());
			assertNotEquals(one, retFrameLocal.getValue());
			assertEquals(two, retFrameLocal.getValue());
		}
	}

	// =============================================================== //

	private static MethodNode compile(ParseResult<RootAST> result) throws AssemblerException {
		Recaf.getController().config().assembler().verify = false;
		MethodAssembler assembler = new MethodAssembler("Test", Recaf.getController());
		return assembler.compile(result);
	}

	private static void verifyFails(ParseResult<RootAST> result) throws AssemblerException {
		Recaf.getController().config().assembler().verify = true;
		MethodAssembler assembler = new MethodAssembler("Test", Recaf.getController());
		try {
			assembler.compile(result);
			fail("Code did not throw any verification exceptions");
		} catch(VerifierException ex) {
			System.err.println(ex.getMessage());
		}
	}

	private static void verifyPass(ParseResult<RootAST> result) {
		Recaf.getController().config().assembler().verify = true;
		MethodAssembler assembler = new MethodAssembler("Test", Recaf.getController());
		try {
			assembler.compile(result);
		} catch(AssemblerException ex) {
			fail(ex);
		}
	}

	private static Frame<AbstractValue>[] getFrames(ParseResult<RootAST> result) {
		Recaf.getController().config().assembler().verify = true;
		MethodAssembler assembler = new MethodAssembler("Test", Recaf.getController());
		try {
			assembler.compile(result);
			return assembler.getFrames();
		} catch(AssemblerException ex) {
			fail(ex);
			throw new IllegalStateException(ex);
		}
	}

	private static ParseResult<RootAST> parse(String code) {
		return Parse.parse(D1 + code + D2);
	}

	private static ParseResult<RootAST> parseLit(String code) {
		return Parse.parse(code);
	}
}

```

`src/test/java/me/coley/recaf/Base.java`:

```java
package me.coley.recaf;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Base testing utilities.
 *
 * @author Matt
 */
public class Base {
	/**
	 * @param file
	 * 		Path to file in classpath.
	 *
	 * @return File reference.
	 *
	 * @throws IOException
	 * 		Thrown if the URL to the file could not be created.
	 */
	public static Path getClasspathFile(String file) throws IOException {
		return new File(URLDecoder.decode(getClasspathUrl(file).getFile(), "UTF-8")).toPath();
	}

	/**
	 * @param file
	 * 		Path to file in classpath.
	 *
	 * @return URL reference.
	 */
	public static URL getClasspathUrl(String file) {
		ClassLoader classLoader = Base.class.getClassLoader();
		return classLoader.getResource(file);
	}
}

```

`src/test/java/me/coley/recaf/CompilerTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.compiler.*;
import org.junit.jupiter.api.Test;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticListener;

import static org.junit.jupiter.api.Assertions.*;


/**
 * Tests for the compiler.
 *
 * @author Matt
 */
public class CompilerTest {
	private final static DiagnosticListener<VirtualJavaFileObject> FAIL_ON_ERROR = message -> {
		assertNotSame(message.getKind(), Diagnostic.Kind.ERROR);
	};

	/**
	 * Tests generation of inner class units.
	 */
	@Test
	public void testInner() {
		// source code
		String s = "public class HelloWorld {" +
				"  public static void main(String args[])" +
				"  {" +
				"    A.print(\"Hello from an inner class\");" +
				"  }" +
				"  public" +
				" static class A {" +
				"    public static void print(String s){" +
				"        System.out.println(s);" +
				"    }" +
				"  }" +
				"}";
		// create the compiler, add the code
		JavacCompiler c = new JavacCompiler();
		c.addUnit("HelloWorld", s);
		c.setCompileListener(FAIL_ON_ERROR);
		assertTrue(c.compile());
		// compiled code
		byte[] outer = c.getUnitCode("HelloWorld");
		byte[] inner = c.getUnitCode("HelloWorld$A");
		assertNotNull(outer);
		assertNotNull(inner);
	}

	/**
	 * Tests generation of inner class units.
	 */
	@Test
	public void testDebug() {
		// source code
		StringBuilder s = new StringBuilder();
		s.append("public class HelloWorld {" +
				"  public static void main(String args[])" +
				"  {" +
				"    String a = \"Hello \";" +
				"    String b = \"World!\";" +
				"    System.out.print(a + b);" +
				"  }" +
				"}");
		// create the compilers, add the code
		JavacCompiler cDebug = new JavacCompiler();
		cDebug.addUnit("HelloWorld", s.toString());
		cDebug.options().lineNumbers = true;
		cDebug.options().variables = true;
		cDebug.options().sourceName = true;
		cDebug.options().setTarget(JavacTargetVersion.V8);
		cDebug.setCompileListener(FAIL_ON_ERROR);
		assertTrue(cDebug.compile());
		JavacCompiler cNone = new JavacCompiler();
		cNone.addUnit("HelloWorld", s.toString());
		cNone.setCompileListener(FAIL_ON_ERROR);
		assertTrue(cNone.compile());
		// compiled code
		byte[] debug = cDebug.getUnitCode("HelloWorld");
		byte[] nodebug = cNone.getUnitCode("HelloWorld");
		assertNotNull(debug);
		assertNotNull(nodebug);
		assertTrue(debug.length > nodebug.length);
	}
}
```

`src/test/java/me/coley/recaf/CorrelationTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.graph.flow.FlowBuilder;
import me.coley.recaf.graph.flow.FlowVertex;
import me.coley.recaf.mapping.Correlation;
import me.coley.recaf.mapping.CorrelationResult;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.*;
import org.objectweb.asm.ClassReader;

import java.io.IOException;
import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Tests for correlation analysis.
 *
 * @author Matt
 */
public class CorrelationTest extends Base {
	private JavaResource base;

	@BeforeEach
	public void setup() {
		try {
			// Load base calculator program, and the obfuscated version
			// - renamed class & method names
			// - no control flow obfuscation, so flow analysis should be the same
			base = new JarResource(getClasspathFile("calc.jar"));
		} catch(IOException ex) {
			// Thrown if loading classpath resources fails
			fail(ex);
		}
	}

	/**
	 * The renamed jar is the same as the base jar except all the identifiers have been renamed.
	 * Flow analysis should result in the same exact paths.
	 */
	@Nested
	public class WithRenamed {
		private JavaResource target;
		private Workspace workspace;

		@BeforeEach
		public void setup() {
			try {
				// Load base calculator program, and the obfuscated version
				// - renamed class & method names
				// - no control flow obfuscation, so flow analysis should be the same
				target = new JarResource(getClasspathFile("calc-renamed.jar"));
				workspace = new Workspace(target, Collections.singletonList(base));
			} catch(IOException ex) {
				// Thrown if loading classpath resources fails
				fail(ex);
			}
		}


		@Test
		public void testSameFlowInObfuscatedJar() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			Set<CorrelationResult> results = correlation.analyze();
			// Assert there are no differences in flow
			assertEquals(1, results.size());
			CorrelationResult result = results.iterator().next();
			assertEquals(Collections.emptySet(), result.getDifference());
		}

		@Test
		public void testMappingsInObfuscatedJar() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			Set<CorrelationResult> results = correlation.analyze();
			assertEquals(1, results.size());
			CorrelationResult result = results.iterator().next();
			// Create mappings
			Map<String, String> mappings = result.getMappings();
			// 8 class renames
			// 5 static method renames
			// 7 instance method renames
			assertEquals(20, mappings.size());
		}
	}

	/**
	 * The modified jar is the same as the base jar except the main method has an additional
	 * logging call. This messes up the flow analysis algorithm used by the correlation mapper
	 * unless the entry point is manually specified to be a common point <i>after</i> the main
	 * method.
	 */
	@Nested
	public class WithModified {
		private JavaResource target;
		private Workspace workspace;

		@BeforeEach
		public void setup() {
			try {
				// Load base calculator program, and the modified version
				// - added a single call to main(String[])
				target = new JarResource(getClasspathFile("calc-modified.jar"));
				workspace = new Workspace(target, Collections.singletonList(base));
			} catch(IOException ex) {
				// Thrown if loading classpath resources fails
				fail(ex);
			}
		}


		@Test
		public void testFaultyFlowModifiedEntry() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			Set<CorrelationResult> results = correlation.analyze();
			// Assert there the difference is the main method (entry)
			assertEquals(1, results.size());
			CorrelationResult result = results.iterator().next();
			Set<FlowBuilder.Flow> difference = result.getDifference();
			assertEquals(1, difference.size());
			FlowBuilder.Flow vertex = difference.iterator().next();
			assertEquals("Start", vertex.getValue().getOwner());
			assertEquals("main", vertex.getValue().getName());
			assertEquals("([Ljava/lang/String;)V", vertex.getValue().getDesc());
		}

		@Test
		public void testSameFlowInModifiedJarByChaningTheEntryPoint() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			FlowVertex baseEntrt = workspace.getFlowGraph().getVertex(
					new ClassReader(base.getClasses().get("calc/Calculator")), "evaluate", "(Ljava/lang/String;)D");
			FlowVertex targetEntrt = workspace.getFlowGraph().getVertex(
					new ClassReader(target.getClasses().get("calc/Calculator")), "evaluate", "(Ljava/lang/String;)D");
			// Assert there is no difference in flow since the only difference (main method)
			// is no longer a part of the flow graph.
			CorrelationResult result = correlation.analyze(baseEntrt, targetEntrt);
			assertEquals(Collections.emptySet(), result.getDifference());
		}

		@Test
		public void testMappingsInModifiedJar() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			Set<CorrelationResult> results = correlation.analyze();
			assertEquals(1, results.size());
			CorrelationResult result = results.iterator().next();
			// Create mappings
			Map<String, String> mappings = result.getMappings();
			// There should be NO mappings since the entry point
			// has been modified, which throws the entire thing off.
			assertEquals(0, mappings.size());
		}

		@Test
		public void testMappingsInModifiedJarByChaningTheEntryPoint() {
			// Run correlation analysis
			Correlation correlation = new Correlation(workspace, base, target);
			FlowVertex baseEntrt = workspace.getFlowGraph().getVertex(
					new ClassReader(base.getClasses().get("calc/Calculator")), "evaluate", "(Ljava/lang/String;)D");
			FlowVertex targetEntrt = workspace.getFlowGraph().getVertex(
					new ClassReader(target.getClasses().get("calc/Calculator")), "evaluate", "(Ljava/lang/String;)D");
			// Assert there is no difference in flow since the only difference (main method)
			// is no longer a part of the flow graph.
			CorrelationResult result = correlation.analyze(baseEntrt, targetEntrt);
			// Create mappings
			Map<String, String> mappings = result.getMappings();
			// We know that the analysis has run and they match if
			// "testSameFlowInModifiedJarByChaningTheEntryPoint" passes.
			//
			// However, there should be NO mappings since the jar has no identifiers renamed.
			assertEquals(0, mappings.size());
		}
	}
}

```

`src/test/java/me/coley/recaf/DecompileTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.control.Controller;
import me.coley.recaf.decompile.cfr.CfrDecompiler;
import me.coley.recaf.decompile.fernflower.FernFlowerDecompiler;
import me.coley.recaf.decompile.procyon.ProcyonDecompiler;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.*;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.*;
import static me.coley.recaf.util.TestUtils.*;

/**
 * Decompiler implementation tests.
 *
 * @author Matt
 */
public class DecompileTest extends Base {
	private Controller controller;

	@Nested
	public class Basic {
		@BeforeEach
		public void setup() {
			try {
				JavaResource resource = new JarResource(getClasspathFile("inherit.jar"));
				resource.getClasses();
				resource.getFiles();
				controller = setupController(resource);
			} catch(IOException ex) {
				fail(ex);
			}
		}

		@AfterEach
		public void shutdown() {
			removeController();
		}

		@Test
		public void testFernFlower() {
			FernFlowerDecompiler decompiler = new FernFlowerDecompiler(controller);
			for (String name : controller.getWorkspace().getPrimaryClassNames()) {
				String decomp = decompiler.decompile(name);
				assertNotNull(decomp);
			}
		}

		@Test
		public void testCfr() {
			CfrDecompiler decompiler = new CfrDecompiler(controller);
			for (String name : controller.getWorkspace().getPrimaryClassNames()) {
				String decomp = decompiler.decompile(name);
				assertNotNull(decomp);
			}
		}

		@Test
		public void testProcyon() {
			ProcyonDecompiler decompiler = new ProcyonDecompiler(controller);
			for (String name : controller.getWorkspace().getPrimaryClassNames()) {
				String decomp = decompiler.decompile(name);
				assertNotNull(decomp);
			}
		}
	}

	@Nested
	public class FernFlower {
		@AfterEach
		public void shutdown() {
			removeController();
		}

		@Test
		public void testNamedInner() {
			try {
				JavaResource resource = new JarResource(getClasspathFile("InnerTest.jar"));
				resource.getClasses();
				resource.getFiles();
				controller = setupController(resource);
				FernFlowerDecompiler decompiler = new FernFlowerDecompiler(controller);
				String decomp = decompiler.decompile("Host$InnerMember");
				assertNotNull(decomp);
				assertFalse(decomp.trim().isEmpty());
			} catch(IOException ex) {
				fail(ex);
			}
		}

		@Test
		public void testAnonymousInner() {
			try {
				JavaResource resource = new JarResource(getClasspathFile("InnerTest.jar"));
				resource.getClasses();
				resource.getFiles();
				controller = setupController(resource);
				FernFlowerDecompiler decompiler = new FernFlowerDecompiler(controller);
				String decomp = decompiler.decompile("Host$1");
				assertNotNull(decomp);
				assertFalse(decomp.trim().isEmpty());
			} catch(IOException ex) {
				fail(ex);
			}
		}
	}

	// TODO: Test for options working by decompiling a synthetic member with differing options
}

```

`src/test/java/me/coley/recaf/ExpressionCompilerTest.java`:

```java
package me.coley.recaf;

import javassist.*;
import javassist.bytecode.*;
import me.coley.recaf.compiler.JavassistASMTranslator;
import me.coley.recaf.parse.bytecode.Disassembler;
import me.coley.recaf.compiler.JavassistCompiler;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Collections;

public class ExpressionCompilerTest extends Base {
	private final ClassPool pool = ClassPool.getDefault();
	private final JavassistASMTranslator translator = new JavassistASMTranslator();

	@Nested
	class MethodCompilations {
		@Test
		public void testClone() throws Exception {
			CtClass ctPoint = pool.makeClass(getClasspathUrl("Point.class").openStream());
			System.out.println(disassembleMethod(ctPoint, "public Point clone() { return new Point(x, y); }"));
		}

		@Test
		public void testMoveX() throws Exception {
			CtClass ctPoint = pool.makeClass(getClasspathUrl("Point.class").openStream());
			System.out.println(disassembleMethod(ctPoint, "public void moveX(int dx) { x += dx; }"));
		}

		@Test
		public void testDistanceTo() throws Exception {
			CtClass ctPoint = pool.makeClass(getClasspathUrl("Point.class").openStream());
			System.out.println(disassembleMethod(ctPoint, "public double distanceTo(Point p) { " +
					"double dx2 = Math.pow((double)x-p.x, 2.0);" +
					"double dy2 = Math.pow((double)y-p.y, 2.0);" +
					"double d = Math.sqrt(dx2 + dy2);" +
					"return d;" +
					" }"));
		}
	}

	@Nested
	class BodyCompilations {
		@Test
		public void testMovePrint() throws Exception {
			CtClass ctPoint = pool.makeClass(getClasspathUrl("Point.class").openStream());
			CtMethod ctMethod = ctPoint.getMethod("move", "(II)V");
			System.out.println(disassembleStatement(ctPoint, ctMethod, "System.out.println(\"Moving by \" + dx + \",\" + dy);"));
			System.out.println();
			System.out.println(disassembleStatement(ctPoint, ctMethod, "System.out.println(\"Moved to \" + x + \",\" + y);"));
		}

		@Test
		public void testConditionalMovePrint() throws Exception {
			CtClass ctPoint = pool.makeClass(getClasspathUrl("Point.class").openStream());
			CtMethod ctMethod = ctPoint.getMethod("move", "(II)V");
			System.out.println(disassembleStatement(ctPoint, ctMethod, "if (dx > 0 && dy > 0) System.out.println(\"Moving by \" + dx + \",\" + dy);"));
		}
	}

	private String disassembleMethod(CtClass owner, String src) throws CannotCompileException, BadBytecode {
		CtMethod compiled = JavassistCompiler.compileMethod(owner, src);
		return translate(owner, compiled, compiled.getMethodInfo().getCodeAttribute());
	}

	private String disassembleStatement(CtClass owner, CtBehavior method, String src) throws CannotCompileException, BadBytecode {
		Bytecode compiled = JavassistCompiler.compileExpression(owner, method, src, Collections.emptyList(), null).getBytecode();
		return translate(owner, method, compiled.toCodeAttribute());
	}

	private String translate(CtClass owner, CtBehavior method, CodeAttribute code) throws CannotCompileException, BadBytecode {
		translator.visit(owner, code);
		return new Disassembler().disassemble(translator.toAsmMethod(method));
	}
}

```

`src/test/java/me/coley/recaf/FlowGraphTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.graph.*;
import me.coley.recaf.graph.flow.FlowGraph;
import me.coley.recaf.graph.flow.FlowVertex;
import me.coley.recaf.workspace.JarResource;
import me.coley.recaf.workspace.Workspace;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for method flow graph.
 *
 * @author Matt
 */
public class FlowGraphTest extends Base {
	private FlowGraph graph;

	@BeforeEach
	public void setup() throws IOException {
		Path file = getClasspathFile("calls.jar");
		Workspace workspace = new Workspace(new JarResource(file));
		graph = workspace.getFlowGraph();
	}

	@Test
	public void testSimpleOutbound() {
		// Just a "System.out.println", so we need the "println" call
		FlowVertex one = graph.getVertex("test/Parent", "thing", "()V");
		assertEquals(1, one.getEdges().size());
		FlowVertex other = (FlowVertex) one.getEdges().iterator().next().getOther(one);
		assertEquals("java/io/PrintStream", other.getOwner());
		assertEquals("println", other.getName());
		assertEquals("(Ljava/lang/String;)V", other.getDesc());
	}

	@Test
	public void testRecursive() {
		// Recursive call to self should link to the same vertex
		FlowVertex count = graph.getVertex("test/Recursion", "countTo10", "(I)V");
		FlowVertex calledCount = getSingleEdgeOther(count);
		assertEquals(count, calledCount);
	}

	@Test
	public void testChain() {
		// one -> two --> three
		FlowVertex one = graph.getVertex("test/Chain", "one", "()V");
		FlowVertex two = graph.getVertex("test/Chain", "two", "()V");
		FlowVertex three = graph.getVertex("test/Chain", "three", "()V");
		// Use search to show the path following the chain
		SearchResult<ClassReader> result  = new ClassDfsSearch(ClassDfsSearch.Type.ALL).find(one, three);
		assertNotNull(result);
		List<Vertex<ClassReader>> path = result.getPath();
		assertEquals(3, path.size());
		assertEquals(one, path.get(0));
		assertEquals(two, path.get(1));
		assertEquals(three, path.get(2));
	}

	@Test
	public void testLoopback() {
		// one -> two --> three --> one
		FlowVertex one = graph.getVertex("test/Loopback", "one", "()V");
		FlowVertex two = graph.getVertex("test/Loopback", "two", "()V");
		FlowVertex three = graph.getVertex("test/Loopback", "three", "()V");
		// Show that the edges point to the next expected vertex
		FlowVertex oneEdge = getSingleEdgeOther(one);
		assertEquals(two, oneEdge);
		FlowVertex twoEdge = getSingleEdgeOther(two);
		assertEquals(three, twoEdge);
		FlowVertex threeEdge = getSingleEdgeOther(three);
		assertEquals(one, threeEdge);
	}

	@Test
	public void testChildCallsParent() {
		// Child extends Parent
		// Method calls "super.doThing"
		FlowVertex parentThing = graph.getVertex("test/Parent", "thing", "()V");
		FlowVertex callsParent = graph.getVertex("test/Child", "callParentThing", "()V");
		FlowVertex calledParent = getSingleEdgeOther(callsParent);
		assertEquals(parentThing, calledParent);
	}

	@Test
	public void testChildCallsInterface() {
		// Child implements Interface
		// Method calls "Interface.super.doThing"
		FlowVertex interfaceThing = graph.getVertex("test/Interface", "thing", "()V");
		FlowVertex callsInterface = graph.getVertex("test/Child", "callInterfaceThing", "()V");
		FlowVertex calledInterface = getSingleEdgeOther(callsInterface);
		assertEquals(interfaceThing, calledInterface);
	}

	/**
	 * @param vertex
	 * 		Vertex with one edge.
	 *
	 * @return The vertex on the other end of the edge.
	 */
	private static FlowVertex getSingleEdgeOther(FlowVertex vertex) {
		Set<Edge<ClassReader>> edges = vertex.getEdges();
		assertEquals(1, edges.size());
		return (FlowVertex) edges.iterator().next().getOther(vertex);
	}
}
```

`src/test/java/me/coley/recaf/GraphTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.graph.*;
import me.coley.recaf.util.struct.Pair;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for basic graph logic.
 *
 * @author Matt
 */
public class GraphTest extends Base {
	private Graph<Integer, IVert> undirectedGraph;
	private Graph<Integer, IVert> directedGraph;

	@BeforeEach
	public void setup() {
		//   1   4
		//  / \ /
		// 2   3
		//  \ / \
		//   5   6
		IVert u1 = new IVert(1);
		IVert u2 = new IVert(2);
		IVert u3 = new IVert(3);
		IVert u4 = new IVert(4);
		IVert u5 = new IVert(5);
		IVert u6 = new IVert(6);
		u1.addEdge(u2, false);
		u1.addEdge(u3, false);
		u2.addEdge(u5, false);
		u3.addEdge(u5, false);
		u3.addEdge(u6, false);
		u4.addEdge(u3, false);
		undirectedGraph = () -> new HashSet<>(Arrays.asList(u1, u2, u3, u4, u5, u6));
		//
		//
		//     1
		//    v v
		//   2   3   6
		//  v     v v
		// 4       5
		IVert d1 = new IVert(1);
		IVert d2 = new IVert(2);
		IVert d3 = new IVert(3);
		IVert d4 = new IVert(4);
		IVert d5 = new IVert(5);
		IVert d6 = new IVert(6);
		d1.addEdge(d2, true);
		d1.addEdge(d3, true);
		d2.addEdge(d4, true);
		d3.addEdge(d5, true);
		d6.addEdge(d5, true);
		directedGraph = () -> new HashSet<>(Arrays.asList(d1, d2, d3, d4, d5, d6));
	}

	@Test
	public void testVertexContainment() {
		// values
		for(int i = 1; i < 6; i++)
			assertTrue(undirectedGraph.containsVertex(i));
		assertFalse(undirectedGraph.containsVertex(-1));
		// vertices
		for(int i = 1; i < 6; i++)
			assertTrue(undirectedGraph.containsVertex(undirectedGraph.getVertex(i)));
	}

	@Test
	public void testUndirectedPathSearch() {
		IVert v1 = undirectedGraph.getVertex(2);
		IVert v4 = undirectedGraph.getVertex(4);
		// Use DFS to find the path between v1 and v4
		Search<Integer> search = new DepthFirstSearch<>();
		SearchResult<Integer> result = search.find(v1, v4);
		assertNotNull(result);
		// Path must follow one of the given paths
		String[] paths = new String[]{"2 1 3 4", "2 5 3 4"};
		String path = result.getPath().stream()
				.map(String::valueOf)
				.collect(Collectors.joining(" ")).toString();
		assertTrue(Arrays.binarySearch(paths, path) >= 0);
	}

	@Test
	public void testDirectedPathSearch() {
		IVert v1 = directedGraph.getVertex(1);
		for(int i = 2; i < 5; i++) {
			IVert vOther = directedGraph.getVertex(i);
			// Use DFS to find the path between v1 and vOther
			Search<Integer> search = new DepthFirstSearch<>();
			SearchResult<Integer> result = search.find(v1, vOther);
			assertNotNull(result);
		}
		IVert v5 = directedGraph.getVertex(5);
		for(int i = 1; i < 4; i++) {
			IVert vOther = directedGraph.getVertex(i);
			// Use DFS to ensure no path exists between v5 and vOther
			Search<Integer> search = new DepthFirstSearch<>();
			SearchResult<Integer> result = search.find(v5, vOther);
			assertNull(result);
		}
	}

	@Test
	public void testDirectedChildren() {
		// Create a set of vertex names that are children of "1"
		Set<String> children = directedGraph.getVertex(1).getAllDirectedChildren(true)
				.map(String::valueOf)
				.collect(Collectors.toSet());
		// Ensure all expected vertices are in the results, all others are not in results
		for (int i = 1; i < 5; i++) {
			String num = String.valueOf(i);
			assertTrue(children.contains(num));
		}
		// [6 -> 5] thus is not accessible from branching off of "1".
		assertFalse(children.contains("6"));
	}

	@Test
	public void testDirectedParents() {
		// Create a set of vertex names that are parents of "5"
		Set<String> children = directedGraph.getVertex(5).getAllDirectedParents(true)
				.map(String::valueOf)
				.collect(Collectors.toSet());
		// Ensure all expected vertices are in the results, all others are not in results
		String[] expected = new String[]{"5", "6", "3", "1"};
		String[] unexpected = new String[]{"4", "2"};
		for(String s : expected) {
			assertTrue(children.contains(s));
		}
		for(String s : unexpected) {
			assertFalse(children.contains(s));
		}
	}

	@Test
	public void testIsDirectedRoot() {
		// Not roots: 2, 3, 4, 5
		for(int i = 2; i < 5; i++)
			assertFalse(directedGraph.getVertex(i).isRoot());
		// Roots: 1, 6
		assertTrue(directedGraph.getVertex(1).isRoot());
		assertTrue(directedGraph.getVertex(6).isRoot());
	}

	@Test
	public void testGetAllRoots() {
		IVert v1 = directedGraph.getVertex(1);
		IVert v4 = directedGraph.getVertex(4);
		IVert v5 = directedGraph.getVertex(5);
		IVert v6 = directedGraph.getVertex(6);
		// 5 -> 6 (root)
		// 5 -> 3 -> 1 (root)
		Set<Vertex<Integer>> roots = v5.getAllRoots().collect(Collectors.toSet());
		assertTrue(roots.contains(v1));
		assertTrue(roots.contains(v6));
		assertEquals(2, roots.size());
		// 4 -> 2 -> 1 (root)
		roots = v4.getAllRoots().collect(Collectors.toSet());
		assertTrue(roots.contains(v1));
		assertEquals(1, roots.size());
		// 1 (root)
		roots = v1.getAllRoots().collect(Collectors.toSet());
		assertTrue(roots.contains(v1));
		assertEquals(1, roots.size());
	}

	@Test
	public void testIsDirectedLeaf() {
		// Not leaves: 1, 2, 3, 6
		for(int i = 1; i < 3; i++)
			assertFalse(directedGraph.getVertex(i).isLeaf());
		assertFalse(directedGraph.getVertex(6).isLeaf());
		// Leaves: 4, 5
		assertTrue(directedGraph.getVertex(4).isLeaf());
		assertTrue(directedGraph.getVertex(5).isLeaf());
	}

	@Test
	public void testGetAllLeaves() {
		IVert v1 = directedGraph.getVertex(1);
		IVert v4 = directedGraph.getVertex(4);
		IVert v5 = directedGraph.getVertex(5);
		IVert v6 = directedGraph.getVertex(6);
		// 1 -> 2 -> 4 (leaf)
		// 1 -> 3 -> 5 (leaf)
		Set<Vertex<Integer>> leaves = v1.getAllLeaves().collect(Collectors.toSet());
		assertTrue(leaves.contains(v4));
		assertTrue(leaves.contains(v5));
		assertEquals(2, leaves.size());
		// 6 -> 5 (leaf)
		leaves = v6.getAllLeaves().collect(Collectors.toSet());
		assertTrue(leaves.contains(v5));
		assertEquals(1, leaves.size());
		// 5 (leaf)
		leaves = v5.getAllLeaves().collect(Collectors.toSet());
		assertTrue(leaves.contains(v5));
		assertEquals(1, leaves.size());
	}

	/**
	 * By the intended design of Vertex, there is not supposed to be a "edges" field,
	 * rather it should be dynamically generated off of whatever the data is.
	 *
	 * But since we're just testing we can work with this dumb implementation.
	 */
	public static class IVert extends Vertex<Integer> {
		private final Set<Edge<Integer>> edges = new HashSet<>();
		private int data;

		public IVert(int data) {
			this.data = data;
		}

		public void addEdge(IVert other, boolean directed) {
			// Create the edge
			Edge<Integer> edge = null;
			if(directed) {
				// Directed edge
				edge = new DirectedEdge<>(IVert.this, other);
			} else {
				// Undirected edge
				edge = () -> new Pair<>(this, other);
			}
			// Add the edge
			edges.add(edge);
			other.edges.add(edge);
		}

		@Override
		public Integer getData() {
			return data;
		}

		@Override
		public void setData(Integer data) {
			this.data = data;
		}

		@Override
		public int hashCode() {
			return data;
		}

		@Override
		public boolean equals(Object other) {
			if(this == other)
				return true;
			return getData().equals(other);
		}

		@Override
		public String toString() {
			return String.valueOf(data);
		}

		@Override
		public Set<Edge<Integer>> getEdges() {
			return edges;
		}
	}
}
```

`src/test/java/me/coley/recaf/HeadlessTest.java`:

```java
package me.coley.recaf;

import com.strobel.core.Mapping;
import me.coley.recaf.control.headless.HeadlessController;
import me.coley.recaf.mapping.MappingImpl;
import me.coley.recaf.mapping.Mappings;
import me.coley.recaf.workspace.JavaResource;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;

import java.io.ByteArrayInputStream;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

import static me.coley.recaf.util.Log.info;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for basic functionality of headless mode.
 *
 * @author Matt
 */
public class HeadlessTest extends Base {
	@Test
	public void test() throws Exception {
		HeadlessController controller = new HeadlessController(null, null);
		controller.setup();
		invokeRun(controller, "help");
		invokeRun(controller, "loadworkspace " + getClasspathFile("calc.jar").normalize().toAbsolutePath());
		assertEquals("calc.jar", controller.getWorkspace().getPrimary().getShortName().toString());
	}

	@Test
	public void remapManifestTest() throws Exception {
		HeadlessController controller = new HeadlessController(null, null);
		controller.setup();
		invokeRun(controller, "loadworkspace " + getClasspathFile("Manifest.jar").normalize().toAbsolutePath());
		assertEquals("Manifest.jar", controller.getWorkspace().getPrimary().getShortName().toString());

		// Check Manifest
		JavaResource primary = controller.getWorkspace().getPrimary();
		byte[] manifestBytes = primary.getFiles().get("META-INF/MANIFEST.MF");
		assertNotEquals(manifestBytes, null);
		Manifest manifest = new Manifest(new ByteArrayInputStream(manifestBytes));
		Attributes attr = manifest.getMainAttributes();
		assertEquals(attr.size(), 2);
		String mainClass = attr.getValue("Main-Class").replaceAll("\\.", "/");
		assertEquals(mainClass, "Code/Code/Code");

		invokeRun(controller, "remap PROGUARD " + getClasspathFile("manifest-map.txt").normalize().toAbsolutePath());
		manifestBytes = primary.getFiles().get("META-INF/MANIFEST.MF");
		manifest = new Manifest(new ByteArrayInputStream(manifestBytes));
		attr = manifest.getMainAttributes();
		mainClass = attr.getValue("Main-Class").replaceAll("\\.", "/");
		assertEquals(mainClass, "some/pkg/Main");
	}

	private static void invokeRun(HeadlessController controller, String cmd) throws Exception {
		Method m = controller.getClass().getDeclaredMethod("handle", String.class);
		m.setAccessible(true);
		m.invoke(controller, cmd);
	}
}

```

`src/test/java/me/coley/recaf/HierarchyGraphTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.graph.ClassDfsSearch;
import me.coley.recaf.graph.SearchResult;
import me.coley.recaf.graph.inheritance.*;
import me.coley.recaf.workspace.JarResource;
import me.coley.recaf.workspace.Workspace;
import org.junit.jupiter.api.*;
import org.objectweb.asm.ClassReader;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for class hierarchy graph.
 *
 * @author Matt
 */
public class HierarchyGraphTest extends Base {
	private HierarchyGraph graph;

	@BeforeEach
	public void setup() throws IOException {
		Path file = getClasspathFile("inherit.jar");
		Workspace workspace = new Workspace(new JarResource(file));
		graph = workspace.getHierarchyGraph();
	}


	@Test
	public void testDescendants() {
		String actualParent = "test/Greetings";
		Set<String> expectedChildren = new HashSet<>(Arrays.asList(
				"test/Person", "test/Jedi", "test/Sith", "test/Yoda"));
		Set<String> descendants = graph.getAllDescendants(actualParent).collect(Collectors.toSet());
		expectedChildren.forEach(child -> assertTrue(descendants.contains(child)));
	}

	@Test
	public void testParents() {
		String actualChild = "test/Yoda";
		Set<String> expectedParents = new HashSet<>(Arrays.asList(
				"test/Jedi", "test/Person", "test/Greetings", "java/lang/Object"));
		Set<String> parents = graph.getAllParents(actualChild).collect(Collectors.toSet());
		expectedParents.forEach(parent -> assertTrue(parents.contains(parent)));
	}

	@Test
	public void testParentToChildSearch() {
		HierarchyVertex vertex = graph.getVertex("test/Person");
		HierarchyVertex target = graph.getVertex("test/Yoda");
		SearchResult<ClassReader> result = new ClassDfsSearch(ClassDfsSearch.Type.CHILDREN).find(vertex, target);
		if (result != null) {
			String[] expectedPath = new String[] {"test/Person", "test/Jedi", "test/Yoda"};
			String[] actualPath = result.getPath().stream()
					.map(v -> v.getData().getClassName()).toArray(String[]::new);
			assertArrayEquals(expectedPath, actualPath);
		} else {
			fail("no path");
		}
	}

	@Test
	public void testFindCommon() {
		assertEquals("test/Person", graph.getCommon("test/Jedi", "test/Sith"));
		assertEquals("test/Person", graph.getCommon("test/Jedi", "test/Person"));
		assertEquals("test/Person", graph.getCommon("test/Person", "test/Person"));
	}

	@Test
	public void testChildToParentSearch() {
		HierarchyVertex vertex = graph.getVertex("test/Yoda");
		HierarchyVertex target = graph.getVertex("test/Person");
		SearchResult<ClassReader> result = new ClassDfsSearch(ClassDfsSearch.Type.PARENTS).find(vertex, target);
		if (result != null) {
			String[] expectedPath = new String[] {"test/Yoda", "test/Jedi", "test/Person"};
			String[] actualPath = result.getPath().stream()
					.map(v -> v.getData().getClassName()).toArray(String[]::new);
			assertArrayEquals(expectedPath, actualPath);
		} else {
			fail("no path");
		}
	}

	@Test
	public void testHierarchyBuilder() {
		HierarchyVertex vertex = graph.getVertex("test/Yoda");
		Set<HierarchyVertex> hierarchy = graph.getHierarchy(vertex);
		// Almost all names should be discovered in the hierarchy for this test case.
		// Sith and Jedi for example, share the same parent "Person".
		Set<String> expected = new HashSet<>(Arrays.asList(
				"test/Deal", "test/Absolutes",
				"test/Person", "test/Greetings",
				"test/Jedi", "test/Sith",
				"test/Yoda", "java/lang/Object"));
		assertEquals(expected.size(), hierarchy.stream()
				.filter(v -> expected.contains(v.getData().getClassName()))
				.count());
		// Only two classes that should NOT be in there.
		// Never used
		assertFalse(hierarchy.stream().anyMatch(v -> v.getData().getClassName().equals("test/Speech")));
		// Referenced as field, never inherited
		assertFalse(hierarchy.stream().anyMatch(v -> v.getData().getClassName().equals("test/Ability")));
	}

	@Test
	public void testIsLibrary() {
		// The "say" method is defined only by classes in the input.
		// - It is not a "library" method.
		assertFalse(graph.isLibrary("test/Yoda", "say", "()V"));
		// The "toString" method belongs to "java/lang/Object" which is not in the input.
		// - It is a "library" method.
		assertTrue(graph.isLibrary("test/Yoda", "toString", "()Ljava/lang/String;"));
	}

	@Test
	public void testAreLinked() {
		// Yoda -> Jedi -> Person -> Greetings
		assertTrue(graph.areLinked("test/Yoda", "say", "()V", "test/Greetings", "say", "()V"));
		// No path between Yoda and Speech
		assertFalse(graph.areLinked("test/Yoda", "say", "()V", "test/Speech", "say", "()V"));
	}
}
```

`src/test/java/me/coley/recaf/HistoryTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for resource history.
 *
 * @author Matt
 */
public class HistoryTest extends Base {
	private final static byte[] DUMMY = new byte[] { 1, 2, 3, 4};
	private JavaResource resource;

	@BeforeEach
	public void setup() {
		try {
			resource = new JarResource(getClasspathFile("calc.jar"));
			resource.setPrimary(true);
			resource.getClasses();
			resource.getFiles();
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testClassHasInitialState(){
		String key = "Start";
		assertEquals(1, resource.getClassHistory(key).size());
	}

	@Test
	public void testResourceHasInitialState(){
		String key = "src/Start.java";
		assertEquals(1, resource.getFileHistory(key).size());
	}

	@Test
	public void testClassCanAlwaysCanRollbackToInitial(){
		String key = "Start";
		for (int i = 0; i < 5; i++) {
			assertEquals(1, resource.getClassHistory(key).size());
			resource.getClassHistory(key).pop();
		}
	}

	@Test
	public void testResourceCanAlwaysCanRollbackToInitial(){
		String key = "src/Start.java";
		for (int i = 0; i < 5; i++) {
			assertEquals(1, resource.getFileHistory(key).size());
			resource.getFileHistory(key).pop();
		}
	}

	@Test
	public void testNewClassHasInitialState(){
		// Inserting a class not already in the workspace should create an initial state
		String key = "NewClass";
		resource.getClasses().put(key, DUMMY);
		assertEquals(1, resource.getClassHistory(key).size());
	}

	@Test
	public void testNewResourceHasInitialState(){
		// Inserting a class not already in the workspace should create an initial state
		String key = "src/NewClass.java";
		resource.getClasses().put(key, DUMMY);
		assertEquals(1, resource.getClassHistory(key).size());
	}

	@Test
	public void testClassCreateSave(){
		String key = "Start";
		// Create additional history entries
		resource.createClassSave(key);
		assertEquals(2, resource.getClassHistory(key).size());
		resource.createClassSave(key);
		assertEquals(3, resource.getClassHistory(key).size());
	}

	@Test
	public void testResourceCreateSave(){
		String key = "src/Start.java";
		// Create additional history entries
		resource.createFileSave(key);
		assertEquals(2, resource.getFileHistory(key).size());
		resource.createFileSave(key);
		assertEquals(3, resource.getFileHistory(key).size());
	}

	@Test
	public void testClassRollback(){
		String key = "Start";
		byte[] initial = resource.getClassHistory(key).peek();
		resource.getClasses().put(key, DUMMY);
		resource.createClassSave(key);
		// Rollback and assert pop'd value and value in class map are present and the same
		assertArrayEquals(DUMMY, resource.getClassHistory(key).pop());
		assertArrayEquals(initial, resource.getClassHistory(key).pop());
	}

	@Test
	public void testResourceRollback(){
		String key = "src/Start.java";
		byte[] initial = resource.getFileHistory(key).peek();
		resource.getFiles().put(key, DUMMY);
		resource.createFileSave(key);
		// Rollback and assert pop'd value and value in class map are present and the same
		assertArrayEquals(DUMMY, resource.getFileHistory(key).pop());
		assertArrayEquals(initial, resource.getFileHistory(key).pop());
	}
}

```

`src/test/java/me/coley/recaf/JavadocsTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.parse.javadoc.*;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.io.IOException;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

// TODO: The calc docs are REALLY simple and don't provide a robust test backing. Find better sample.
/**
 * Tests for workspace resource documentation bindings.
 *
 * @author Matt
 */
public class JavadocsTest extends Base {
	// paths to javadoc zipz
	private static final String JAVA8 = "calc-docs-8.zip";
	private static final String JAVA12 = "calc-docs-12.zip";
	private static JavaResource base;
	private static Workspace workspace;

	@BeforeEach
	public void setup() {
		try {
			base = new JarResource(getClasspathFile("calc.jar"));
			workspace = new Workspace(base);
		} catch(IOException ex) {
			fail(ex);
		}
	}

	private void load(String file) {
		try {
			base.setClassDocs(getClasspathFile(file));
		} catch(IOException ex) {
			fail(ex);
		}
	}

	// ============================================================================== //

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testAllLoaded(String file) {
		load(file);
		for(String name : base.getClasses().keySet()) {
			// Start was not added in the docs
			if(name.equals("Start"))
				continue;
			assertNotNull(base.getClassDocs(name), name + " was null");
		}
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testField(String file) {
		load(file);
		Javadocs docs = base.getClassDocs("calc/Expression");
		List<DocField> fields = docs.getFields();
		//
		assertEquals(1, fields.size());
		DocField field = fields.get(0);
		assertEquals("i", field.getName());
		assertEquals("int", field.getType());
		assertEquals("", field.getDescription());
		assertEquals("protected", field.getModifiers().get(0));
		assertEquals("final", field.getModifiers().get(1));
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testMethod(String file) {
		load(file);
		Javadocs docs = base.getClassDocs("calc/Expression");
		List<DocMethod> methods = docs.getMethods();
		//
		assertEquals(2, methods.size());
		//
		DocMethod method = methods.get(0);
		assertEquals("evaluate", method.getName());
		assertEquals("double", method.getReturnType());
		assertEquals("Evaluates an expression as a level deeper than the current one in the expression tree,", method.getDescription());
		assertEquals("protected", method.getModifiers().get(0));
		assertEquals("final", method.getModifiers().get(1));
		assertEquals("Evaluated result.", method.getReturnDescription());
		assertEquals(1, method.getParameters().size());
		DocParameter parameter = method.getParameters().get(0);
		assertEquals("expression", parameter.getName());
		assertEquals("Some math expression.", parameter.getDescription());
		//
		method = methods.get(1);
		assertEquals("accept", method.getName());
		assertEquals("double", method.getReturnType());
		assertEquals("", method.getDescription());
		assertEquals("public", method.getModifiers().get(0));
		assertEquals("abstract", method.getModifiers().get(1));
		assertEquals("Evaluated result.", method.getReturnDescription());
		assertEquals(1, method.getParameters().size());
		parameter = method.getParameters().get(0);
		assertEquals("expression", parameter.getName());
		assertEquals("Some math expression.", parameter.getDescription());
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testInheritance(String file) {
		load(file);
		Javadocs docs = base.getClassDocs("calc/Calculator");
		List<String> inheritance = docs.getInheritance();
		// Inheritance should be ordered by "child > parent > root"
		assertEquals(2, inheritance.size());
		assertEquals("calc/Calculator", inheritance.get(0));
		assertEquals("java/lang/Object", inheritance.get(1));
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testSubclasses(String file) {
		load(file);
		Javadocs docs = base.getClassDocs("calc/Expression");
		List<String> subclasses = docs.getSubclasses();
		// Inheritance should be ordered by "child > parent > root"
		String[] keys = {
				"calc/AddAndSub", "calc/Constant", "calc/Exponent", "calc/MultAndDiv", "calc/Parenthesis"
		};
		assertEquals(keys.length, subclasses.size());
		for(int i = 0; i < keys.length; i++)
			assertEquals(keys[i], subclasses.get(i));
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testNoSubclasses(String file) {
		load(file);
		Javadocs docs = base.getClassDocs("calc/Exponent");
		List<String> subclasses = docs.getSubclasses();
		assertEquals(0, subclasses.size());
	}

	@ParameterizedTest
	@ValueSource(strings = { JAVA8, JAVA12 })
	public void testDescription(String file) {
		load(file);
		String[][] keys =  {
				{ "calc/AddAndSub", "Addition and subtraction evaluator. Both included in one evaluator due to order equivalence." },
				{ "calc/Calculator", "Main calculator logic." },
				{ "calc/Constant", "Constant evaluator." },
				{ "calc/Exponent", "Exponent evaluator." },
				{ "calc/Expression", "Base expression class." },
				{ "calc/MatchUtil", Javadocs.NO_DESCRIPTION },
				{ "calc/MultAndDiv", "Multiple and division evaluator. Both included in one evaluator due to order equivalence." },
				{ "calc/Parenthesis", "Parenthesis evaluator." }
		};
		for (String[] part : keys)
			assertEquals(part[1], base.getClassDocs(part[0]).getDescription());
	}

	@Test
	public void testMavenLoading() {
		MavenResource resource;
		try {
			resource = new MavenResource("org.ow2.asm", "asm", "7.2-beta");
			resource.getClasses();
			if(!resource.fetchJavadoc())
				fail("Failed to fetch sources from maven: " + resource.getCoords());
			assertTrue(resource.getClassDocs().size() > 0);
		} catch(IOException ex) {
			fail(ex);
			return;
		}
	}
}

```

`src/test/java/me/coley/recaf/RemappingTest.java`:

```java
package me.coley.recaf;

import com.google.common.collect.MapDifference;
import com.google.common.collect.Maps;
import me.coley.recaf.mapping.*;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.objectweb.asm.ClassReader.*;

/**
 * Remapping tests.
 *
 * @author Matt
 */
public class RemappingTest extends Base {
	private JavaResource resource;
	private Workspace workspace;
	private Path classMapFile;
	private Path methodMapFile;
	private Path methodEnigmaMapFile;
	private Path methodTSrgMapFile;
	private Path methodTiny1MapFile;
	private Path methodTiny2MapFile;
	private Path methodProguardMapFile;
	private Path methodJadxMapFile;

	@BeforeEach
	public void setup() {
		try {
			resource = new JarResource(getClasspathFile("inherit.jar"));
			workspace = new Workspace(resource);
			classMapFile = getClasspathFile("inherit-class-map.txt");
			/*
			test/Jedi 				-> 		rename/GoodGuy
			test/Sith				->		rename/BadGuy
			test/Greetings			->		rename/Hello
			 */
			methodMapFile = getClasspathFile("inherit-method-map.txt");
			methodEnigmaMapFile = getClasspathFile("inherit-method-map-enigma.txt");
			methodProguardMapFile = getClasspathFile("inherit-method-map-proguard.txt");
			methodTSrgMapFile = getClasspathFile("inherit-method-map-tsrg.txt");
			methodTiny1MapFile = getClasspathFile("inherit-method-map-tiny-1.txt");
			methodTiny2MapFile = getClasspathFile("inherit-method-map-tiny-2.txt");
			methodJadxMapFile = getClasspathFile("inherit-method-map-jadx.txt");
			/*
			test/Greetings			->		rename/Hello
			test/Greetings.say()V	->		rename/Hello.speak()
			 */
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testRenamedClasses() {
		try {
			Mappings mappings = MappingImpl.SIMPLE.create(classMapFile, workspace);
			mappings.accept(resource).forEach((old, value) -> {
				ClassReader reader = new ClassReader(value);
				String rename = reader.getClassName();
				String renameSuper = reader.getSuperName();
				switch(old) {
					case "test/Jedi":
						assertEquals("rename/GoodGuy", rename);
						assertEquals("test/Person", renameSuper);
						break;
					case "test/Sith":
						assertEquals("rename/BadGuy", rename);
						assertEquals("test/Person", renameSuper);
						break;
					case "test/Greetings":
						assertEquals("rename/Hello", rename);
						break;
					case "test/Yoda":
						// Class not explicitly renamed, but has renamed references
						assertEquals("test/Yoda", rename);
						assertEquals("rename/GoodGuy", renameSuper);
						break;
					case "test/Person":
						// Class not explicitly renamed, but has renamed references
						String[] interfaces = reader.getInterfaces();
						assertEquals(1, interfaces.length);
						assertEquals("rename/Hello", interfaces[0]);
						assertEquals("test/Person", rename);
						break;
					default:
						// No other values should have been updated
						fail("No other values should have been updated by renaming: " + old +
								" -> " + rename);
				}
			});
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testRenamedMethod() {
		try {
			Mappings mappings = MappingImpl.SIMPLE.create(methodMapFile, workspace);
			mappings.accept(resource).forEach((old, value) -> {
				ClassReader reader = new ClassReader(value);
				ClassNode node = new ClassNode();
				reader.accept(node, SKIP_DEBUG | SKIP_CODE);
				String rename = reader.getClassName();
				switch(old) {
					case "test/Jedi":
					case "test/Sith":
					case "test/Yoda":
						// Method should be renamed from "say" to "speak"
						assertEquals("speak", node.methods.get(1).name);
						break;
					case "test/Greetings":
						// Class was renamed
						assertEquals("rename/Hello", rename);
						// Method should be renamed from "say" to "speak"
						assertEquals("speak", node.methods.get(0).name);
						break;
					case "test/Person":
						// Class not explicitly renamed, but has renamed references
						String[] interfaces = reader.getInterfaces();
						assertEquals(1, interfaces.length);
						assertEquals("rename/Hello", interfaces[0]);
						assertEquals("test/Person", rename);
						break;
					default:
						// No other values should have been updated
						fail("No other values should have been updated by renaming: " + old +
								" -> " + rename);
				}
			});
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testResourceKeys() {
		try {
			Map<String, byte[]> classes = resource.getClasses();
			// Before
			assertFalse(classes.containsKey("rename/GoodGuy"));
			assertFalse(classes.containsKey("rename/BadGuy"));
			assertFalse(classes.containsKey("rename/Hello"));
			assertTrue(classes.containsKey("test/Jedi"));
			assertTrue(classes.containsKey("test/Sith"));
			assertTrue(classes.containsKey("test/Greetings"));
			// After
			Mappings mappings = MappingImpl.SIMPLE.create(classMapFile, workspace);
			mappings.accept(resource);
			assertTrue(classes.containsKey("rename/GoodGuy"));
			assertTrue(classes.containsKey("rename/BadGuy"));
			assertTrue(classes.containsKey("rename/Hello"));
			assertFalse(classes.containsKey("test/Jedi"));
			assertFalse(classes.containsKey("test/Sith"));
			assertFalse(classes.containsKey("test/Greetings"));
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testEngimaMappings() {
		testSame(MappingImpl.ENIGMA, methodEnigmaMapFile);
	}

	@Test
	public void testTSrgMappings() { testSame(MappingImpl.TSRG, methodTSrgMapFile); }

	@Test
	public void testTinyV1Mappings() {
		testSame(MappingImpl.TINY, methodTiny1MapFile);
	}

	@Test
	public void testTinyV2Mappings() {
		testSame(MappingImpl.TINY2, methodTiny2MapFile);
	}

	@Test
	public void testProguardMappings() {
		testSame(MappingImpl.PROGUARD, methodProguardMapFile);
	}

	@Test
	public void testJadxMappings() {
		// Unlike the other mappings, JADX is not capable of moving to other packages
		try {
			Mappings mappingsImpl = MappingImpl.JADX.create(methodJadxMapFile, workspace);
			Map<String, String> map = mappingsImpl.getMappings();
			assertEquals("test/Hello", map.get("test/Greetings"));
			assertEquals("speak", map.get("test/Greetings.say()V"));
		} catch (IOException ex) {
			fail(ex);
		}
	}

	private void testSame(MappingImpl toCompare, Path mapping) {
		try {
			// Both of these files outline the same data, just in different formats
			Mappings mappingsSimple = MappingImpl.SIMPLE.create(methodMapFile, workspace);
			Mappings mappingsToCompare = toCompare.create(mapping, workspace);
			// So their parsed values should be the same.
			MapDifference<String, String> difference =
					Maps.difference(mappingsSimple.getMappings(), mappingsToCompare.getMappings());
			assertTrue(difference.areEqual());
		} catch(IOException ex) {
			fail(ex);
		}
	}
}

```

`src/test/java/me/coley/recaf/ResourceInputTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for using {@link JavaResource} implementations.
 *
 * @author Matt
 */
public class ResourceInputTest extends Base {
	private final static int CLASSES_IN_INHERIT_JAR = 9;
	private final static int CLASSES_IN_CALC_JAR = 9;

	@Test
	public void testJar() {
		try {
			Path file = getClasspathFile("inherit.jar");
			JavaResource resource = new JarResource(file);
			assertEquals(CLASSES_IN_INHERIT_JAR, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testJarResourcesDoNotContainClasses() {
		try {
			Path file = getClasspathFile("calc.jar");
			JavaResource resource = new JarResource(file);
			for (String name : resource.getFiles().keySet())
				assertFalse(name.endsWith(".class"));
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testClass() {
		try {
			Path file = getClasspathFile("Hello.class");
			JavaResource resource = new ClassResource(file);
			assertEquals(1, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testUrlJar() {
		try {
			URL url = getClasspathUrl("inherit.jar");
			JavaResource resource = new UrlResource(url);
			assertEquals(CLASSES_IN_INHERIT_JAR, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testUrlClass() {
		try {
			URL url = getClasspathUrl("Hello.class");
			JavaResource resource = new UrlResource(url);
			assertEquals(1, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testMaven() {
		try {
			// ASM-commons as of 7.2-beta has 27 classes
			JavaResource resource = new MavenResource("org.ow2.asm", "asm-commons", "7.2-beta");
			assertEquals(27, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testSkipPrefixes() {
		try {
			Path file = getClasspathFile("calc.jar");
			JavaResource resource = new JarResource(file);
			resource.setSkippedPrefixes(Collections.singletonList("calc"));
			assertEquals(1, resource.getClasses().size());
		} catch(IOException ex) {
			fail(ex);
		}
	}

	// ================== BAD INPUTS ====================== //

	@Test
	public void testUrlClassDoesNotExist() {
		try {
			URL url = new URL("file://DoesNotExist.class");
			assertThrows(IOException.class, () -> new UrlResource(url));
		} catch(MalformedURLException ex) {
			fail(ex);
		}
	}

	@Test
	public void testFileDoesNotExist() {
		Path path = Paths.get("DoesNotExist.class");
		assertThrows(IOException.class, () -> new ClassResource(path));
	}

	@Test
	public void testMavenDoesNotExist() {
		assertThrows(IOException.class, () -> new MavenResource("does","not","exist"));
	}
}

```

`src/test/java/me/coley/recaf/ResourceUpdateTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.*;

import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Tests the listening map used in {@link me.coley.recaf.workspace.JavaResource}.
 *
 * @author Matt
 */
public class ResourceUpdateTest extends Base {
	private JavaResource resource;
	private Workspace workspace;

	@BeforeEach
	public void setup() {
		resource = new DummyResource();
		workspace = new Workspace(resource);
	}

	@Test
	public void testClassPut() {
		String valueToPut = "Test";
		// Record values put in the map
		Set<String> putted = new HashSet<>();
		resource.getClasses().getPutListeners().add((name, code) -> putted.add(name));
		// Put value in map
		resource.getClasses().put(valueToPut, new byte[0]);
		// Assert value listener has been fired
		assertTrue(putted.contains(valueToPut));
		assertTrue(resource.getDirtyClasses().contains(valueToPut));
	}

	@Test
	public void testResourcePut() {
		String valueToPut = "Test";
		// Record values put in the map
		Set<String> putted = new HashSet<>();
		resource.getFiles().getPutListeners().add((name, data) -> putted.add(name));
		// Put value in map
		resource.getFiles().put(valueToPut, new byte[0]);
		// Assert value listener has been fired
		assertTrue(putted.contains(valueToPut));
		assertTrue(resource.getDirtyFiles().contains(valueToPut));
	}

	@Test
	public void testClassPutAll() {
		String valueToPut1 = "Test1";
		String valueToPut2 = "Test2";
		Map<String, byte[]> map = new HashMap<>();
		map.put(valueToPut1, new byte[0]);
		map.put(valueToPut2, new byte[0]);
		// Record values put in the map
		Set<String> putted = new HashSet<>();
		resource.getClasses().getPutListeners().add((name, code) -> putted.add(name));
		// Put value in map
		resource.getClasses().putAll(map);
		// Assert value listener has been fired
		assertTrue(putted.contains(valueToPut1));
		assertTrue(putted.contains(valueToPut2));
		assertTrue(resource.getDirtyClasses().contains(valueToPut1));
		assertTrue(resource.getDirtyClasses().contains(valueToPut2));

	}

	@Test
	public void testResourcePutAll() {
		String valueToPut1 = "Test1";
		String valueToPut2 = "Test2";
		Map<String, byte[]> map = new HashMap<>();
		map.put(valueToPut1, new byte[0]);
		map.put(valueToPut2, new byte[0]);
		// Record values put in the map
		Set<String> putted = new HashSet<>();
		resource.getFiles().getPutListeners().add((name, data) -> putted.add(name));
		// Put value in map
		resource.getFiles().putAll(map);
		// Assert value listener has been fired
		assertTrue(putted.contains(valueToPut1));
		assertTrue(putted.contains(valueToPut2));
		assertTrue(resource.getDirtyFiles().contains(valueToPut1));
		assertTrue(resource.getDirtyFiles().contains(valueToPut2));
	}

	@Test
	public void testClassRemove() {
		String valueToRemove = "Test";
		// Record values removed from the map
		Set<Object> removed = new HashSet<>();
		resource.getClasses().getRemoveListeners().add(removed::add);
		// Remove value from map
		resource.getClasses().remove(valueToRemove);
		// Assert value listener has been fired
		assertTrue(removed.contains(valueToRemove));
	}

	@Test
	public void testResourceRemove() {
		String valueToRemove = "Test";
		// Record values removed from the map
		Set<Object> removed = new HashSet<>();
		resource.getFiles().getRemoveListeners().add(removed::add);
		// Remove value from map
		resource.getFiles().remove(valueToRemove);
		// Assert value listener has been fired
		assertTrue(removed.contains(valueToRemove));
	}

	/**
	 * Empty resource that allows items to be added.
	 */
	private static class DummyResource extends EmptyResource {
		@Override
		protected Map<String, byte[]> loadClasses() throws IOException {
			return new HashMap<>();
		}

		@Override
		protected Map<String, byte[]> loadFiles() throws IOException {
			return new HashMap<>();
		}
	}
}

```

`src/test/java/me/coley/recaf/SearchTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.search.*;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.*;
import org.objectweb.asm.Opcodes;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import static me.coley.recaf.search.StringMatchMode.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the Search api.
 *
 * @author Matt
 */
public class SearchTest extends Base {
	private static JavaResource base;
	private static Workspace workspace;

	@BeforeAll
	public static void setup() {
		try {
			base = new JarResource(getClasspathFile("calc.jar"));
			workspace = new Workspace(base);
		} catch(IOException ex) {
			fail(ex);
		}
	}

	@Test
	public void testStringResultContext() {
		// Setup search - String "EVAL: " in Calculator.evaluate(int, String)
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new StringQuery("EVAL", STARTS_WITH)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(1, results.size());
		StringResult res = (StringResult) results.get(0);
		assertEquals("EVAL: ", res.getText());
		// Assert context shows the string is in the expected method
		// - res context is of the LDC insn
		// - parent is of the method containing the String
		contextEquals(res.getContext().getParent(), "calc/Calculator", "evaluate", "(ILjava/lang/String;)D");
	}

	@Test
	public void testValue() {
		// Setup search - Calculator.MAX_DEPTH = 30
		// - Javac inlines constants, but keeps the field constant value attribute
		// - So there should be the field const and the inline value in results
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new ValueQuery(30)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(2, results.size());
		ValueResult resField = (ValueResult) results.get(0);
		contextEquals(resField.getContext(), "calc/Calculator", "MAX_DEPTH", "I");
		ValueResult resInsn = (ValueResult) results.get(1);
		contextEquals(resInsn.getContext().getParent(), "calc/Calculator", "evaluate", "(ILjava/lang/String;)D");
	}

	@Test
	public void testOverlappingResultsInMethodCode() {
		// Setup search - two queries that have results in the same method:
		// - Calculator.evaluate(int, String)
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new ValueQuery(30))
				.query(new StringQuery("EVAL: ", STARTS_WITH))
				.build();
		// Show results
		List<SearchResult> results = collector.getOverlappingResults();
		assertEquals(2, results.size());
		boolean isValFirst = results.get(0) instanceof ValueResult;
		ValueResult resVal = isValFirst ?
				(ValueResult) results.get(0) : (ValueResult) results.get(1);
		StringResult resStr = isValFirst ?
				(StringResult) results.get(1) : (StringResult) results.get(0);
		assertEquals(30, resVal.getValue());
		assertEquals("EVAL: ", resStr.getText());
		contextEquals(resVal.getContext().getParent(), "calc/Calculator", "evaluate", "(ILjava/lang/String;)D");
		contextEquals(resStr.getContext().getParent(), "calc/Calculator", "evaluate", "(ILjava/lang/String;)D");
	}

	@Test
	public void testOverlapToNarrowResults() {
		// Setup search - two queries, one for a class qualifier, other for a value
		// - Effectively search for a value in a specific class
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new ClassNameQuery("calc/Parenthesis", EQUALS))
				.query(new ValueQuery(0))
				.build();
		// Show results
		List<SearchResult> results = collector.getOverlappingResults();
		// Ensure all contexts match the given type
		assertEquals(4, results.size());
		Context.ClassContext expected = Context.withClass(Opcodes.ACC_PUBLIC, "calc/Parenthesis");
		for (SearchResult result : results) {
			// Get root context of result
			Context<?> context = result.getContext();
			while (context.getParent() != null)
				context = context.getParent();
			// Assert all results are in the expected class
			// There are value results in other classes but we wanted this search to be
			// narrowed to the scope of the Parenthesis class.
			assertTrue(context instanceof Context.ClassContext);
			assertEquals(expected.getName(), ((Context.ClassContext) context).getName());
		}
	}

	@Test
	public void testOverlapExcludesOtherClasses() {
		// Setup search - fetch all strings and only return them if they're sharing the
		// same context as the "30" value result.
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new ValueQuery(30))
				.query(new StringQuery("", CONTAINS))
				.build();
		// Show results
		List<SearchResult> results = collector.getOverlappingResults();
		// All results should be instruction-level in the method Calculator.evaluate(int, String)
		// So asserting that all results parents are in this method should be valid
		for (SearchResult result : results) {
			contextEquals(result.getContext().getParent(), "calc/Calculator", "evaluate", "(ILjava/lang/String;)D");
		}
	}

	@Test
	public void testMemberDefAnyInClass() {
		// Setup search - Any member in "Expression"
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new MemberDefinitionQuery("calc/Expression", null, null, EQUALS)).build();
		// Show results - should be given four (field + 3 methods)
		Set<String> results = collector.getAllResults().stream()
				.map(Object::toString)
				.collect(Collectors.toSet());
		assertEquals(4, results.size());
		assertTrue(results.contains("calc/Expression.i I"));
		assertTrue(results.contains("calc/Expression.<init>(I)V"));
		assertTrue(results.contains("calc/Expression.accept(Ljava/lang/String;)D"));
		assertTrue(results.contains("calc/Expression.evaluate(Ljava/lang/String;)D"));
	}

	@Test
	public void testMemberDefAnyIntField() {
		// Setup search - Any int member in any class
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new MemberDefinitionQuery(null, null, "I", EQUALS)).build();
		// Show results - should be the given three
		Set<String> results = collector.getAllResults().stream()
				.map(Object::toString)
				.collect(Collectors.toSet());
		assertEquals(3, results.size());
		assertTrue(results.contains("calc/Parenthesis.LEVEL_UNSET I"));
		assertTrue(results.contains("calc/Calculator.MAX_DEPTH I"));
		assertTrue(results.contains("calc/Expression.i I"));
	}

	@Test
	public void testClassReference() {
		// Setup search - References to the "Exponent" class
		// - Should be 3 references in "Exponent"
		// - 2 "this" variables in "calc/Exponent"
		// - 1 type reference in "calc/Calculator"
		SearchCollector collector = SearchBuilder.in(workspace)
				.query(new ClassReferenceQuery("calc/Exponent")).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(3, results.size());
		int calc = 0, exp = 0;
		for (SearchResult res : results) {
			if (res.getContext() instanceof Context.InsnContext) {
				Context.InsnContext insnContext = (Context.InsnContext) res.getContext();
				String owner = insnContext.getParent().getParent().getName();
				if (!owner.equals("calc/Calculator"))
					fail("Unexpected result in: " + owner);
				calc++;
			} else if(res.getContext() instanceof Context.LocalContext) {
				Context.LocalContext localContext = (Context.LocalContext) res.getContext();
				String owner = localContext.getParent().getParent().getName();
				if (!owner.equals("calc/Exponent"))
					fail("Unexpected result in: " + owner);
				exp++;
			}
		}
		// - LOCAL this
		// - LOCAL this
		assertEquals(2, exp);
		// - NEW Exponent
		assertEquals(1, calc);
	}

	@Test
	public void testMemberReference() {
		// Setup search - References to the "Calculator.log(int, String)" method
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug()
				.query(new MemberReferenceQuery("calc/Calculator", "log", null, EQUALS)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(2, results.size());
		for (SearchResult res : results) {
			Context.InsnContext insnContext = (Context.InsnContext) res.getContext();
			String owner = insnContext.getParent().getParent().getName();
			if (!owner.equals("calc/Calculator")) {
				fail("Unexpected result in: " + owner);
			}
		}
	}

	@Test
	public void testNoMemberReferenceWhenCodeSkipped() {
		// Setup search - References to the "Calculator.log(int, String)" method
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new MemberReferenceQuery("calc/Calculator", "log", null, EQUALS)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(0, results.size());
	}

	@Test
	public void testClassNameEquals() {
		// Setup search - Equality for "Start"
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new ClassNameQuery("Start", EQUALS)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(1, results.size());
		assertEquals("Start", ((ClassResult)results.get(0)).getName());
	}

	@Test
	public void testClassNameStartsWith() {
		// Setup search - Starts with for "Start"
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new ClassNameQuery("S", STARTS_WITH)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(1, results.size());
		assertEquals("Start", ((ClassResult)results.get(0)).getName());
	}

	@Test
	public void testClassNameEndsWith() {
		// Setup search - Ends with for "ParenTHESIS"
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new ClassNameQuery("thesis", ENDS_WITH)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(1, results.size());
		assertEquals("calc/Parenthesis", ((ClassResult)results.get(0)).getName());
	}

	@Test
	public void testClassNameRegex() {
		// Setup search - Regex for "Start" by matching only word characters (no package splits)
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new ClassNameQuery("^\\w+$", REGEX)).build();
		// Show results
		List<SearchResult> results = collector.getAllResults();
		assertEquals(1, results.size());
		assertEquals("Start", ((ClassResult)results.get(0)).getName());
	}

	@Test
	public void testClassInheritance() {
		// Setup search - All implementations of "Expression"
		SearchCollector collector = SearchBuilder.in(workspace).skipDebug().skipCode()
				.query(new ClassInheritanceQuery(workspace, "calc/Expression")).build();
		// Show results
		Set<String> results = collector.getAllResults().stream()
				.map(res -> ((ClassResult)res).getName())
				.collect(Collectors.toSet());
		assertEquals(5, results.size());
		assertTrue(results.contains("calc/Parenthesis"));
		assertTrue(results.contains("calc/Exponent"));
		assertTrue(results.contains("calc/MultAndDiv"));
		assertTrue(results.contains("calc/AddAndSub"));
		assertTrue(results.contains("calc/Constant"));
	}

	private static void contextEquals(Context<?> context, String owner, String name, String desc) {
		assertTrue(context instanceof Context.MemberContext);
		Context.MemberContext member = (Context.MemberContext) context;
		assertEquals(owner, member.getParent().getName());
		assertEquals(name, member.getName());
		assertEquals(desc, member.getDesc());
	}
}

```

`src/test/java/me/coley/recaf/SourceCodeTest.java`:

```java
package me.coley.recaf;

import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.resolution.declarations.*;
import com.github.javaparser.resolution.types.ResolvedPrimitiveType;
import com.github.javaparser.resolution.types.ResolvedReferenceType;
import com.github.javaparser.resolution.types.ResolvedType;
import com.google.common.collect.Sets;
import me.coley.recaf.parse.source.SourceCode;
import me.coley.recaf.workspace.*;
import org.junit.jupiter.api.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;
import static java.util.Collections.*;
import static me.coley.recaf.util.JavaParserUtil.*;


/**
 * Tests for workspace resource source code bindings.
 *
 * @author Matt
 */
public class SourceCodeTest extends Base {
	@Nested
	public class SourceUsage {
		private JavaResource resource;
		private Workspace workspace;

		@BeforeEach
		public void setup() {
			try {
				Path file = getClasspathFile("calc.jar");
				resource = new JarResource(file);
				resource.getClasses();
				if(!resource.setClassSources(file))
					fail("Failed to read sources!");
				workspace = new Workspace(resource);
			} catch(IOException ex) {
				fail(ex);
			}
		}

		@Test
		public void testNodeAtPos() {
			SourceCode code = resource.getClassSource("Start");
			// Line 7: Two tabs then this:
			//
			// Scanner scanner = new Scanner(System.in);
			//
			// First "Scanner" is an AST Tyoe
			Node node = code.getNodeAt(7, 5); // Scanner
			assertTrue(node instanceof ClassOrInterfaceType);
			assertEquals("Scanner", ((ClassOrInterfaceType)node).asString());
			// "scanner" is just a SimpleName, so we return the parent VariableDeclarator
			node = code.getNodeAt(7, 13); // scanner
			assertTrue(node instanceof VariableDeclarator);
			assertEquals("scanner", ((VariableDeclarator)node).getNameAsString());
			// Second "Scanner" is also an AST Type
			node = code.getNodeAt(7, 27); // Scanner
			assertTrue(node instanceof ClassOrInterfaceType);
			assertEquals("Scanner", ((ClassOrInterfaceType)node).asString());
			// "System.in" is a FieldAccessExpr
			// - "System" is a NameExpr - Field.scope
			// - "in" is a NameExpr - Field.name
			node = code.getNodeAt(7, 34); // System
			assertTrue(node instanceof FieldAccessExpr);
			assertTrue(((FieldAccessExpr)node).getScope() instanceof NameExpr);
			assertEquals("System", ((NameExpr)((FieldAccessExpr)node).getScope()).getNameAsString());
			assertEquals("in", ((FieldAccessExpr)node).getNameAsString());
		}

		@Test
		public void testClassResolve() {
			// Enable advanced resolving
			workspace.analyzeSources();
			// Line 7: Two tabs then this:
			//
			// Scanner scanner = new Scanner(System.in);
			//
			SourceCode code = resource.getClassSource("calc/Calculator");
			Node node = code.getNodeAt(6, 37); // String
			assertTrue(node instanceof ClassOrInterfaceType);
			ClassOrInterfaceType classType = (ClassOrInterfaceType) node;
			ResolvedType dec = classType.resolve();
			assertEquals("java/lang/String", toInternal(dec));
			//
			node = code.getNodeAt(22, 18); // Exponent
			assertTrue(node instanceof ClassOrInterfaceType);
			classType = (ClassOrInterfaceType) node;
			dec = classType.resolve();
			assertEquals("calc/Exponent", toInternal(dec));
			//
			node = code.getNodeAt(10, 25); // int
			assertTrue(node instanceof PrimitiveType);
			PrimitiveType primType = (PrimitiveType) node;
			ResolvedPrimitiveType decPrim = primType.resolve();
			assertEquals("java/lang/Integer", toInternal(decPrim));
		}

		@Test
		public void testFieldResolve() {
			// Enable advanced resolving
			workspace.analyzeSources();
			// Line 7: Two tabs then this:
			//
			// Scanner scanner = new Scanner(System.in);
			//
			SourceCode code = resource.getClassSource("Start");
			Node node = code.getNodeAt(7, 34);
			assertTrue(node instanceof FieldAccessExpr);
			FieldAccessExpr fieldExpr = (FieldAccessExpr) node;
			ResolvedFieldDeclaration dec = (ResolvedFieldDeclaration) fieldExpr.resolve();
			assertEquals("java/lang/System", getOwner(dec));
			assertEquals("in", dec.getName());
			assertEquals("Ljava/io/InputStream;", getDescriptor(dec));
		}

		@Test
		public void testMethodResolve() {
			// Enable advanced resolving
			workspace.analyzeSources();
			// Line 18: Three tabs then this:
			//
			// return new Parenthesis(i).accept(expression);
			//
			SourceCode code = resource.getClassSource("calc/Calculator");
			Node node = code.getNodeAt(18, 33);
			assertTrue(node instanceof MethodCallExpr);
			MethodCallExpr callExpr = (MethodCallExpr) node;
			ResolvedMethodDeclaration dec = callExpr.resolve();
			assertEquals("calc/Parenthesis", getOwner(dec));
			assertEquals("accept", dec.getName());
			assertEquals("(Ljava/lang/String;)D", getDescriptor(dec));
			//
			node = code.getNodeAt(44, 16);
			assertTrue(node instanceof MethodCallExpr);
			callExpr = (MethodCallExpr) node;
			dec = callExpr.resolve();
			assertEquals("java/io/PrintStream", getOwner(dec));
			assertEquals("println", dec.getName());
			assertEquals("(Ljava/lang/String;)V", getDescriptor(dec));
		}

		@Test
		public void testNoImports() {
			List<String> imports = resource.getClassSource("calc/Expression").getImports();
			assertEquals(0, imports.size());
		}

		@Test
		public void testImpliedImports() {
			List<String> imports = resource.getClassSource("calc/Expression").getAllImports();
			assertEquals(8, imports.size() - SourceCode.LANG_PACKAGE_NAMES.length);
			for(String name : resource.getClasses().keySet())
				// Implied imports include classes in the same package
				// - of which there should be 8
				if(name.startsWith("calc/"))
					assertTrue(imports.contains(name));
		}

		@Test
		public void testExplicitImports() {
			List<String> imports = resource.getClassSource("calc/MatchUtil").getImports();
			// Imports only two classes
			assertEquals(2, imports.size());
			assertTrue(imports.contains("java/util/regex/Matcher"));
			assertTrue(imports.contains("java/util/regex/Pattern"));
		}

		@Test
		public void testWildcardImport() {
			List<String> imports = resource.getClassSource("Start").getImports();
			assertEquals(9, imports.size());
			for(String name : resource.getClasses().keySet())
				// Should have imported the entire package "calc.*"
				// which is all the remaining classes.
				if(name.startsWith("calc/"))
					assertTrue(imports.contains(name));
			// Also imports scanner
			assertTrue(imports.contains("java/util/Scanner"));
		}

		@Test
		public void testSurrounding() {
			// Test that the 5th line of the source file + a context radius of 1 line
			// matches the constructor of the given class.
			//
			// public Constant(int i) {
			//     super(i);
			// }
			String expected = "\tpublic Constant(int i) {\n\t\tsuper(i);\n\t}";
			String actual = resource.getClassSource("calc/Constant").getSurrounding(5, 1);
			assertEquals(expected, actual);
		}
	}

	@Nested
	public class SourceLoading {
		@Test
		public void testDefaultSourceLoading() {
			JavaResource resource;
			try {
				Path file = getClasspathFile("calc.jar");
				resource = new JarResource(file);
				resource.getClasses();
				if(!resource.setClassSources(file))
					fail("Failed to read sources!");
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertMatchingSource(resource);
		}

		@Test
		public void testSingleClassSourceLoading() {
			JavaResource resource;
			try {
				resource = new ClassResource(getClasspathFile("Hello.class"));
				resource.getClasses();
				if(!resource.setClassSources(getClasspathFile("Hello.java")))
					fail("Failed to read sources!");
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertMatchingSource(resource);
		}

		@Test
		public void testUrlDeferLoading() {
			JavaResource resource;
			try {
				resource = new UrlResource(getClasspathUrl("calc.jar"));
				resource.getClasses();
				if(!resource.setClassSources(getClasspathFile("calc.jar"))) {
					fail("Failed to read sources!");
				}
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertMatchingSource(resource);
		}

		@Test
		public void testJarFailsOnMissingFile() {
			JavaResource resource;
			try {
				Path file = getClasspathFile("calc.jar");
				resource = new JarResource(file);
				resource.getClasses();
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertThrows(IOException.class, () -> resource.setClassSources(Paths.get("Does/Not/Exist")));
		}

		@Test
		public void testJarFailsOnBadFileType() {
			JavaResource resource;
			Path source;
			try {
				Path file = getClasspathFile("calc.jar");
				source = getClasspathFile("Hello.class");
				resource = new JarResource(file);
				resource.getClasses();
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertThrows(IOException.class, () -> resource.setClassSources(source));
		}

		@Test
		public void testMavenLoading() {
			MavenResource resource;
			try {
				resource = new MavenResource("org.ow2.asm", "asm", "7.2-beta");
				resource.getClasses();
				if(!resource.fetchSources())
					fail("Failed to fetch sources from maven: " + resource.getCoords());
			} catch(IOException ex) {
				fail(ex);
				return;
			}
			assertMatchingSource(resource);
		}
	}

	/**
	 * Asserts that the given resource's classes all have mappings to source files.<br>
	 * The given resource must not have any inner classes.
	 *
	 * @param resource
	 * 		Resource to check.
	 */
	private static void assertMatchingSource(JavaResource resource) {
		Set<String> expectedSrcNames = resource.getClasses().keySet()
				.stream().filter(name -> !name.contains("$") && !name.equals("module-info"))
				.collect(Collectors.toSet());
		Set<String> foundSrcNames = resource.getClassSources().values().stream()
				.map(SourceCode::getInternalName).collect(Collectors.toSet());
		// Show that all classes (no inners in this sample) have source code mappings
		Set<String> difference = Sets.difference(expectedSrcNames, foundSrcNames);
		assertNotEquals(emptySet(), expectedSrcNames);
		assertNotEquals(emptySet(), foundSrcNames);
		assertEquals(emptySet(), difference);
	}
}

```

`src/test/java/me/coley/recaf/StylerTest.java`:

```java
package me.coley.recaf;

import me.coley.recaf.ui.controls.text.model.LanguageStyler;
import me.coley.recaf.ui.controls.text.model.Languages;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;

import java.util.*;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.fail;

/**
 * Regression tests to assert the odd load-order-based errors with the language styler don't resurface.
 * Sometimes the order of which language is used would somehow effect the regex system.
 * It was incredibly odd, and the fix <i>seems</i> to be remove {@code \B} usage.
 *
 * @author Matt
 */
public class StylerTest {
	private static final Map<String, String> langToExample = new HashMap<>();
	static {
		langToExample.put("css", ".type {\n\tfont-family: Arial;\n}");
		langToExample.put("java", "class Name {\n\tstatic int i = 0;\n}");
		langToExample.put("json", "{ \"key\": \"val\", \"list\": [ { }  ] }");
		langToExample.put("xml", "<tag>value</tag>");
		langToExample.put("mf", "Manifest-Version: 1.0\nMain-Class: me.coley.recaf.Recaf\nCan-Redefine-Classes: true");
		langToExample.put("properties", "locale=en_US\nwriter1=file\nwriter1.file=#{user.home}/rclog.txt");
		langToExample.put("bytecode", "DEFINE static main([Ljava/lang/String; args)V\nRETURN");
	}

	@ParameterizedTest
	@MethodSource("generateCombinations")
	public void testStyleLoadOrder(String first, String second) {
		try {
			LanguageStyler styler = new LanguageStyler(Languages.find(first));
			styler.computeStyle(langToExample.get(first));
			//
			styler = new LanguageStyler(Languages.find(second));
			styler.computeStyle(langToExample.get(second));
		} catch(Throwable ex) {
			// If the system regresses to how it used to fail, it will throw a NPE
			// when the styler tries to use Matcher.find()
			fail(ex);
		}
	}

	public static Stream<Arguments> generateCombinations() {
		List<Arguments> pairs = new ArrayList<>();
		for (String first : langToExample.keySet())
			for (String second : langToExample.keySet())
				pairs.add(Arguments.of(first, second));
		return pairs.stream();
	}
}

```

`src/test/java/me/coley/recaf/mapping/AsmMappingUtilsTest.java`:

```java
package me.coley.recaf.mapping;

import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Tests for the solely String-based methods of {@link AsmMappingUtils}.
 */
public class AsmMappingUtilsTest {
    @Test
    public void testSimpleKeyToKeyTransformation() {
        Map<String, String> inputMapping = new HashMap<>();
        inputMapping.put("calc/Calculator.MAX_DEPTH", "MAX_DEPTH_LEVEL");
        inputMapping.put("calc/Calculator.evaluate(ILjava/lang/String;)D", "doEvaluate");

        Map<String, String> resultMapping = AsmMappingUtils.transformAsmMappingValuesToKeyFormat(inputMapping);

        assertEquals(2, resultMapping.size());
        assertEquals("calc/Calculator.MAX_DEPTH_LEVEL", resultMapping.get("calc/Calculator.MAX_DEPTH"));
        assertEquals("calc/Calculator.doEvaluate(ILjava/lang/String;)D",
                resultMapping.get("calc/Calculator.evaluate(ILjava/lang/String;)D"));
    }

    @Test
    public void testApplyMappingToExistingOnRenamedClass() {
        Map<String, String> aggregateMapping = new HashMap<>();
        aggregateMapping.put("calc/Calculator", "renamed/MyCalc");

        Map<String, String> additionalMapping = new HashMap<>();
        additionalMapping.put("renamed/MyCalc.evaluate(ILjava/lang/String;)D", "doEvaluate");
        additionalMapping.put("renamed/MyCalc.MAX_DEPTH", "MAX_DEPTH_LEVEL");

        AsmMappingUtils.applyMappingToExisting(aggregateMapping, additionalMapping);

        assertEquals(3, aggregateMapping.size());
        assertEquals("renamed/MyCalc", aggregateMapping.get("calc/Calculator"));
        assertEquals("MAX_DEPTH_LEVEL", aggregateMapping.get("calc/Calculator.MAX_DEPTH"));
        assertEquals("doEvaluate", aggregateMapping.get("calc/Calculator.evaluate(ILjava/lang/String;)D"));
    }

    @Test
    public void testApplyMappingToExistingClassRename() {
        Map<String, String> aggregateMapping = new HashMap<>();
        aggregateMapping.put("calc/Calculator.evaluate(ILjava/lang/String;)D", "doEvaluate");
        aggregateMapping.put("calc/Calculator.MAX_DEPTH", "MAX_DEPTH_LEVEL");

        Map<String, String> additionalMapping = new HashMap<>();
        additionalMapping.put("calc/Calculator", "renamed/MyCalc");

        AsmMappingUtils.applyMappingToExisting(aggregateMapping, additionalMapping);

        assertEquals(3, aggregateMapping.size());
        assertEquals("renamed/MyCalc", aggregateMapping.get("calc/Calculator"));
        assertEquals("MAX_DEPTH_LEVEL", aggregateMapping.get("calc/Calculator.MAX_DEPTH"));
        assertEquals("doEvaluate", aggregateMapping.get("calc/Calculator.evaluate(ILjava/lang/String;)D"));
    }

    @Test
    public void testApplyMappingToExistingTransitiveRenames() {
        Map<String, String> aggregateMapping = new HashMap<>();
        aggregateMapping.put("calc/Calculator.evaluate(ILjava/lang/String;)D", "doEvaluate");
        aggregateMapping.put("calc/Calculator.MAX_DEPTH", "MAX_DEPTH_LEVEL");
        aggregateMapping.put("calc/Calculator", "renamed/MyCalc");

        Map<String, String> additionalMapping = new HashMap<>();
        additionalMapping.put("renamed/MyCalc", "renamed2/MyCalc2");

        AsmMappingUtils.applyMappingToExisting(aggregateMapping, additionalMapping);

        assertEquals(3, aggregateMapping.size());
        assertEquals("renamed2/MyCalc2", aggregateMapping.get("calc/Calculator"));
        assertEquals("MAX_DEPTH_LEVEL", aggregateMapping.get("calc/Calculator.MAX_DEPTH"));
        assertEquals("doEvaluate", aggregateMapping.get("calc/Calculator.evaluate(ILjava/lang/String;)D"));
    }
}
```

`src/test/java/me/coley/recaf/util/TestUtils.java`:

```java
package me.coley.recaf.util;

import me.coley.recaf.Recaf;
import me.coley.recaf.control.Controller;
import me.coley.recaf.control.headless.HeadlessController;
import me.coley.recaf.workspace.JavaResource;
import me.coley.recaf.workspace.Workspace;

import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.fail;

/**
 * Some common utilities.
 */
public class TestUtils {
	/**
	 * Set the current controller to a wrapper of the given resource.
	 *
	 * @param resource
	 * 		Resource to wrap in a headless controller.
	 *
	 * @return Controller instance.
	 *
	 * @throws IOException
	 * 		When the config cannot be initialized.
	 */
	public static Controller setupController(JavaResource resource) throws IOException {
		// Set up the controller
		Controller controller = new HeadlessController((Path) null, null);
		controller.setWorkspace(new Workspace(resource));
		controller.config().initialize();
		return controller;
	}

	/**
	 * Used reflection to remove the controller...
	 */
	public static void removeController() {
		try {
			// In "Recaf.java" we prevent setting the controller twice...
			// I swear I'm taking crazy pills, because the surefire config should be isolating tests...
			// That means each test should get a separate JVM. But clearly something is wrong.
			Field f = Recaf.class.getDeclaredField("currentController");
			f.setAccessible(true);
			f.set(null, null);
		} catch(Exception ex) {
			fail("Failed to reset");
		}
	}
}

```

`src/test/resources/Hello.java`:

```java
public class Hello {
	public static void main(String[] args) {
		System.out.println("Hello world!");
	}
}
```

`src/test/resources/Point.java`:

```java
public class Point {
	private int x, y;
	public Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
	public void move(int dx, int dy) {
		x += dx;
		y += dy;
	}
}
```

`src/test/resources/inherit-class-map.txt`:

```txt
test/Jedi rename/GoodGuy
test/Sith rename/BadGuy
test/Greetings rename/Hello
```

`src/test/resources/inherit-method-map-enigma.txt`:

```txt
CLASS test/Greetings rename/Hello
	METHOD say speak ()V
```

`src/test/resources/inherit-method-map-jadx.txt`:

```txt
c test.Greetings Hello
m test.Greetings.say()V speak
```

`src/test/resources/inherit-method-map-proguard.txt`:

```txt
# Backwards format because proguard mappings are intended to be undone, not applied
rename.Hello -> test.Greetings:
    void speak() -> say
```

`src/test/resources/inherit-method-map-tiny-1.txt`:

```txt
v1	intermediary	named
CLASS	test/Greetings	rename/Hello
METHOD	test/Greetings	()V	say	speak
```

`src/test/resources/inherit-method-map-tiny-2.txt`:

```txt
tiny	2	0	intermediary	named
c	test/Greetings	rename/Hello
	m	()V	say	speak
```

`src/test/resources/inherit-method-map-tsrg.txt`:

```txt
test/Greetings rename/Hello
	say ()V speak
```

`src/test/resources/inherit-method-map.txt`:

```txt
test/Greetings rename/Hello
test/Greetings.say()V speak
```

`src/test/resources/manifest-map.txt`:

```txt
some.pkg.Main -> Code.Code.Code:
    void <init>() -> <init>
    void main(java.lang.String[]) -> Code

```

`src/test/resources/tinylog.properties`:

```properties
locale=en_US
writingthread=true

writer=console
writer.level=info
writer.format={level}-{date}: {message|indent=4}
```