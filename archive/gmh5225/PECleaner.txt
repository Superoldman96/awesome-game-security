Project Path: arc_gmh5225_PECleaner_mladxpkf

Source Tree:

```txt
arc_gmh5225_PECleaner_mladxpkf
├── LICENSE
├── PECleaner
│   ├── Lib
│   │   ├── Hex.cpp
│   │   ├── Hex.h
│   │   ├── Macros.h
│   │   ├── PE.cpp
│   │   └── PE.h
│   ├── Main.cpp
│   ├── PECleaner.vcxproj
│   ├── PECleaner.vcxproj.filters
│   ├── StripDebugInformation.cpp
│   └── StripDebugInformation.h
├── PECleaner.sln
├── README.md
├── resources
│   ├── after.png
│   └── before.png
└── tests
    ├── CppTest_x64_DEBUG.exe
    ├── CppTest_x86_DEBUG.exe
    └── Invalid PE.exe

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Colin Senner

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PECleaner.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2026
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PECleaner", "PECleaner\PECleaner.vcxproj", "{6950CB1E-0B55-46BA-9CE2-B4085E70EF52}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6950CB1E-0B55-46BA-9CE2-B4085E70EF52}.Debug|x64.ActiveCfg = Debug|x64
		{6950CB1E-0B55-46BA-9CE2-B4085E70EF52}.Debug|x64.Build.0 = Debug|x64
		{6950CB1E-0B55-46BA-9CE2-B4085E70EF52}.Release|x64.ActiveCfg = Release|x64
		{6950CB1E-0B55-46BA-9CE2-B4085E70EF52}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A0FCD712-1B5A-4C6C-9578-1F97D477BBF7}
	EndGlobalSection
EndGlobal

```

`PECleaner/Lib/Hex.cpp`:

```cpp
#include "Hex.h"
#include <stdio.h>

#define COLOR_BLUE(string) "\x1b[36m" string "\x1b[0m"

bool isPrintableAscii(char c) 
{
	return c >= 33 && c <= 126;
}

void PrintSpaces(size_t num) {
	for (size_t i = 0; i < num; i++)
	{
		printf(" ");
	}
}

void Hex(void* bytes, size_t len, size_t columns, size_t separator, bool ascii)
{
	size_t offset = 0;
	size_t offset_ascii = 0;
	size_t address = (size_t)bytes;
	size_t lineLength = 0;

	size_t rows = (len / columns) + 1;
	size_t numSeparators = (columns / separator) - 1;
	size_t columnLength = 6 + (columns * 3) + (numSeparators * 2);

	printf("          ");

	// Print columns
	for (unsigned int col = 0; col < columns; col++)
	{
		if (col != 0 && col % separator == 0)
			printf("| ");

		printf(COLOR_BLUE("%02X "), col);
	}

	printf("\n");

	for (unsigned int row = 0; row < rows; row++)
	{
		if (offset >= len)
			break;

		offset_ascii = offset;

		printf(COLOR_BLUE("%08X  "), (unsigned int)address + (unsigned int)offset);
		lineLength = 6;

		for (unsigned int col = 0; col < columns; col++)
		{
			if (offset >= len)
				break;

			if (col != 0 && col % separator == 0)
			{
				printf("| ");
				lineLength += 2;
			}

			printf("%02X ", ((unsigned char*)bytes)[offset++]);
			lineLength += 3;
		}		

		// Print ASCII characters
		if (ascii)
		{
			// Print spaces out to the correct alignment
			size_t spacesToAdd = columnLength - lineLength + 4;
			PrintSpaces(spacesToAdd);

			for (unsigned int col = 0; col < columns; col++)
			{
				if (offset_ascii >= len)
					break;

				char c = ((unsigned char*)bytes)[offset_ascii++];

				c = isPrintableAscii(c) ? c : '.';
				printf("%c", c);
			}
		}

		printf("\n");
	}
}
```

`PECleaner/Lib/Hex.h`:

```h
#pragma once

void Hex(void* bytes, size_t len, size_t columns = 16, size_t separator = 4, bool ascii = true);
```

`PECleaner/Lib/Macros.h`:

```h
#pragma once

#define AddPtr(ptr, offset) (void*) (((SIZE_T)ptr) + ((SIZE_T)offset))
#define SubPtr(ptr, offset) (void*) (((SIZE_T)ptr) - ((SIZE_T)offset))
#define ValueAt(ptr, offset, type) (*(type*)AddPtr(ptr, offset))
```

`PECleaner/Lib/PE.cpp`:

```cpp
#include "PE.h"
#include <Windows.h>

bool ValidatePE(void* pe)
{
	auto dosHeader = PeDosHeader(pe);

	// 'MZ'
	if (!dosHeader || dosHeader->e_magic != 0x5A4D)
		return false;

	// The NT header doesn't differ at the start
	auto ntHeader = PeNtHeader32(pe);

	// 'PE'
	if (!ntHeader || *(DWORD*)ntHeader != 0x4550)
		return false;

	return true;
}

PIMAGE_DOS_HEADER PeDosHeader(void* pe) 
{
	if (!pe)
		return nullptr;

	return (PIMAGE_DOS_HEADER)pe;
}

PIMAGE_NT_HEADERS32 PeNtHeader32(void* pe)
{
	if (!pe)
		return nullptr;

	auto dosHeader = PeDosHeader(pe);

	if (!dosHeader)
		return nullptr;

	auto ntHeader = (PIMAGE_NT_HEADERS32)((size_t)dosHeader + (size_t)dosHeader->e_lfanew);

	return ntHeader;
}

PIMAGE_NT_HEADERS64 PeNtHeader64(void* pe)
{
	return (PIMAGE_NT_HEADERS64)(PeNtHeader32(pe));
}

size_t PeNtHeaderSize(int mode)
{
	if (mode == 32)
		return sizeof(IMAGE_NT_HEADERS32);
	else if (mode == 64)
		return sizeof(IMAGE_NT_HEADERS64);

	return 0;
}

// Returns the correct header type as a void *. 
// user casts it to either a PIMAGE_NT_HEADERS32 / 64 struct;
void* PeNtHeader(void* pe, int mode)
{
	if (mode == 32)
		return (void*)PeNtHeader32(pe);
	else if (mode == 64)
		return (void*)PeNtHeader64(pe);

	return nullptr;
}

PIMAGE_FILE_HEADER PeFileHeader(void* pe, int mode)
{
	void* ntHeader = nullptr;
	PIMAGE_FILE_HEADER fileHeader = nullptr;

	ntHeader = PeNtHeader(pe, mode);

	if (!ntHeader)
		return nullptr;

	if (mode == 32)
		return &((PIMAGE_NT_HEADERS32)ntHeader)->FileHeader;
	else if (mode == 64)
		return &((PIMAGE_NT_HEADERS64)ntHeader)->FileHeader;

	return nullptr;
}

void* PeOptionalHeader(void* pe)
{
	return (void*)PeOptionalHeader32(pe);
}

PIMAGE_OPTIONAL_HEADER32 PeOptionalHeader32(void* pe)
{
	auto ntHeader = PeNtHeader32(pe);

	if (!ntHeader)
		return nullptr;

	return &ntHeader->OptionalHeader;
}

PIMAGE_OPTIONAL_HEADER64 PeOptionalHeader64(void* pe)
{
	return (PIMAGE_OPTIONAL_HEADER64)PeOptionalHeader32(pe);
}

size_t PeOptionalHeaderSize(int mode)
{
	if (mode == 32)
		return sizeof(IMAGE_OPTIONAL_HEADER32);
	else if (mode == 64)
		return sizeof(IMAGE_OPTIONAL_HEADER64);

	return 0;
}

PIMAGE_SECTION_HEADER PeSectionHeaderByIndex(void* pe, size_t index)
{
	auto dosHeader = PeDosHeader(pe);
	auto mode = PeArchitectureMode(pe);
	auto fileHeader = PeFileHeader(pe, mode);

	if (!dosHeader || !fileHeader)
		return nullptr;

	if (index >= fileHeader->NumberOfSections)
		return nullptr;

	// Use the correct header size for the architecture mode of the pe
	auto headersSize = mode == 32 ? sizeof(IMAGE_NT_HEADERS32) : sizeof(IMAGE_NT_HEADERS64);

	size_t rvaSectionHeader = (size_t)((size_t)dosHeader->e_lfanew + headersSize);

	auto sectionHeader = (PIMAGE_SECTION_HEADER)((size_t)dosHeader + (size_t)rvaSectionHeader);

	sectionHeader = &sectionHeader[index];

	return sectionHeader;
}

PIMAGE_SECTION_HEADER PeSectionHeaderByName(void* pe, char* name)
{
	auto dosHeader = PeDosHeader(pe);
	auto mode = PeArchitectureMode(pe);
	auto fileHeader = PeFileHeader(pe, mode);
	bool bFound = false;
	PIMAGE_SECTION_HEADER sectionHeader = nullptr;

	if (!dosHeader || !fileHeader)
		return nullptr;

	// Use the correct header size for the architecture mode of the pe
	auto headersSize = mode == 32 ? sizeof(IMAGE_NT_HEADERS32) : sizeof(IMAGE_NT_HEADERS64);

	size_t rvaSectionHeader = (size_t)((size_t)dosHeader->e_lfanew + headersSize);

	auto first = (PIMAGE_SECTION_HEADER)((size_t)dosHeader + (size_t)rvaSectionHeader);

	for (int i = 0; i < fileHeader->NumberOfSections; i++)
	{
		sectionHeader = &first[i];

		if (!_stricmp(name, (const char*)sectionHeader->Name))
		{
			bFound = true;
			break;
		}		
	}

	if (bFound)
		return sectionHeader;

	return nullptr;
}

PIMAGE_DATA_DIRECTORY PeDataDirectory(void* pe, int entry)
{
	// Last entry in winnt.h
	if (entry > IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)
		return nullptr;

	auto mode = PeArchitectureMode(pe);
	auto optionalHeader = PeOptionalHeader(pe);

	if (mode == -1)
		return nullptr;

	auto directory = mode == 32 ? &((PIMAGE_OPTIONAL_HEADER32)optionalHeader)->DataDirectory[entry] : &((PIMAGE_OPTIONAL_HEADER64)optionalHeader)->DataDirectory[entry];

	return directory;
}

#define AMD64 0x8664
#define INTEL_386 0x014C

int PeArchitectureMode(void * pe)
{
	// The machine word is at the beginning of the NT header.
	// before sizes differ between architectures.
	auto fileHeader = PeFileHeader(pe, 32);

	if (!fileHeader)
		return -1;

	if (fileHeader->Machine == AMD64)
		return 64;
	
	if (fileHeader->Machine == INTEL_386)
		return 32;

	return -1;
}

```

`PECleaner/Lib/PE.h`:

```h
#pragma once
#include <Windows.h>

PIMAGE_DOS_HEADER PeDosHeader(void* pe);

// Returns the correct header type as a void *. 
// user casts it to either a PIMAGE_NT_HEADERS32/64 struct;
void* PeNtHeader(void* pe, int mode);

PIMAGE_NT_HEADERS32 PeNtHeader32(void* pe);

PIMAGE_NT_HEADERS64 PeNtHeader64(void* pe);

// Returns the correct sizeof(NT_HEADER) given the mode
size_t PeNtHeaderSize(int mode);

PIMAGE_FILE_HEADER PeFileHeader(void* pe, int mode);

// Returns the correct header type as a void *. 
// user casts it to either a PIMAGE_OPTIONAL_HEADER32/64;
void* PeOptionalHeader(void* pe);

PIMAGE_OPTIONAL_HEADER32 PeOptionalHeader32(void* pe);

PIMAGE_OPTIONAL_HEADER64 PeOptionalHeader64(void* pe);

size_t PeOptionalHeaderSize(int mode);

// Returns information about the section.
// index 0 => section header for '.text' section.
PIMAGE_SECTION_HEADER PeSectionHeaderByIndex(void* pe, size_t index = 0);

// Returns information about the section.
// name - e.g. ".rdata", ".text"
PIMAGE_SECTION_HEADER PeSectionHeaderByName(void* pe, char* name);

// Returns a struct with a VirtualAddress and Size.
// arg: 
//		entry : corresponds with windows defines in winnt.h
// e.g.
// IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
// IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
// IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
// IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
// IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
// IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
// IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
PIMAGE_DATA_DIRECTORY PeDataDirectory(void* pe, int entry);

// Returns true if the ptr appears to point to a valid pe file
bool ValidatePE(void* pe);

// Returns 32 or 64 for the PE architecture, -1 on error.
int PeArchitectureMode(void * pe);
```

`PECleaner/Main.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include "Lib/PE.h"
#include "StripDebugInformation.h"
#include "Lib/Hex.h"

unsigned int FileLength(FILE* fs)
{
	fseek(fs, 0, SEEK_END);
	long fsize = ftell(fs);
	fseek(fs, 0, SEEK_SET);

	return fsize;
}

void Test(void* pe)
{
	printf("DATA DIRECTORY:\n");
	auto mode = PeArchitectureMode(pe);


	return;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage:  PeCleaner.exe <exefile>\n");
		printf("\nPeCleaner strips out Rich header and debug information from PE files overwriting file.\n");

		return 0;
	}

	char* inFile = argv[1];
	char* outFile = inFile;

	size_t bytesRead = 0;
	DWORD bytesWritten = 0;
	DWORD fileLength = 0;
	unsigned char* buffer = nullptr;
	int mode = 0;

	HANDLE hFile = nullptr;
	FILE* fs;

	//printf("Opening file: '%s'\n", inFile);
	if (fopen_s(&fs, inFile, "rb"))
	{
		printf("Couldn't open file '%s'.\n", inFile);
		return 1;
	}

	fileLength = FileLength(fs);

	//printf("Length: %d bytes.\n", fileLength);

	// Make a buffer the size of the file we're reading
	buffer = (unsigned char*)malloc(fileLength + 1);
	ZeroMemory(buffer, fileLength + 1);

	if (!buffer) 
	{
		printf("Couldn't allocate %d bytes for a buffer.\n", fileLength);
		goto cleanup;
	}

	// Read the file into a buffer
	bytesRead = fread_s(buffer, fileLength, 1, fileLength, fs);

	if (bytesRead != fileLength)
	{
		printf("Couldn't read entire file into buffer.  Bytes Read: %zd.\n", bytesRead);
		goto cleanup;
	}

	if (fclose(fs))
		printf("Problem closing the file %s\n", inFile);

	if (!ValidatePE(buffer))
	{
		printf("Invalid PE File format.\n");
		goto cleanup;
	}

	mode = PeArchitectureMode(buffer);

	if (mode == -1)
	{
		printf("Couldn't detect the architecture mode of the PE file.\n");
		goto cleanup;
	}

	printf("Architecture is: %d-bit\n", mode);

	// Strip the DebugDirectory Information
	if (!StripDebugInformation(buffer))
	{
		printf("Couldn't strip debug information.\n");
		goto cleanup;
	}

	printf("Debug Information Stripped...\n");

	// Strip the RICH header
	StripRichHeader(buffer);

	printf("Rich header stripped...\n");

	// Create the out file
	hFile = CreateFileA(outFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (!hFile) 
	{
		printf("Couldn't create the file '%s' for writing.\n", outFile);
		goto cleanup;
	}

	if (!WriteFile(hFile, buffer, fileLength, &bytesWritten, NULL))
	{
		printf("Couldn't write file.  Error: %08X.\n", GetLastError());
		goto cleanup;
	}


	// Close handles, cleanup and exit
cleanup:
	fclose(fs);

	if (buffer)
		free(buffer);

	if (hFile)
		CloseHandle(hFile);

    return 0;
}
```

`PECleaner/PECleaner.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{6950cb1e-0b55-46ba-9ce2-b4085e70ef52}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PESanitizer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>PECleaner</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)_debug</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(TargetPath)" "$(SolutionDir)bin\"
copy "$(OutDir)$(TargetName).pdb" "$(SolutionDir)bin\"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Copy to bin folder</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(TargetPath)" "$(SolutionDir)bin\"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Copy to bin folder</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Lib\Hex.cpp" />
    <ClCompile Include="Lib\PE.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="StripDebugInformation.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Lib\Hex.h" />
    <ClInclude Include="Lib\Macros.h" />
    <ClInclude Include="Lib\PE.h" />
    <ClInclude Include="StripDebugInformation.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PECleaner/PECleaner.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Lib">
      <UniqueIdentifier>{8f0639c8-9967-4b1c-a2dc-315910bd2344}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Lib\Hex.cpp">
      <Filter>Lib</Filter>
    </ClCompile>
    <ClCompile Include="Lib\PE.cpp">
      <Filter>Lib</Filter>
    </ClCompile>
    <ClCompile Include="StripDebugInformation.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StripDebugInformation.h" />
    <ClInclude Include="Lib\Macros.h">
      <Filter>Lib</Filter>
    </ClInclude>
    <ClInclude Include="Lib\Hex.h">
      <Filter>Lib</Filter>
    </ClInclude>
    <ClInclude Include="Lib\PE.h">
      <Filter>Lib</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PECleaner/StripDebugInformation.cpp`:

```cpp
#include "StripDebugInformation.h"
#include "Lib/PE.h"
#include "Lib/Hex.h"

#include <Windows.h>
#include <stdio.h>

// Returns the address and size of a module's section
// index is the section you want to get
// e.g. 0 => .text, 1 => .data
bool StripDebugInformation(void* pe)
{
  // Virtual Address shown includes the .rdata section (0x2150)
  auto debugDirectory = PeDataDirectory(pe, IMAGE_DIRECTORY_ENTRY_DEBUG);

  size_t debugEntries = debugDirectory->Size / sizeof(IMAGE_DEBUG_DIRECTORY);

  // We need to get the VA of rdata and subtract them to find the debug directory entry
  auto rdata = PeSectionHeaderByName(pe, (char*)".rdata");

  if (!rdata)
    return false;

  // Take the VA of the debugDirectory (0x2150) and the VA of the .rdata section (0x2000) and subtract them
  // To get the offset into the .rdata section of the DEBUG_DIRECTORY (0x150)
  size_t debugDirectoryOffset = (size_t)debugDirectory->VirtualAddress - (size_t)rdata->VirtualAddress;

  // Add the pe base + rdata's start on disk + the offset of the debug directory.
  auto debugEntry = (PIMAGE_DEBUG_DIRECTORY)((size_t)pe + (size_t)rdata->PointerToRawData + (size_t)debugDirectoryOffset);

  // Strip all the information from them
  auto first = debugEntry;
  for (unsigned int i = 0; i < debugEntries; i++)
  {
    auto entry = &first[i];

    if (entry->PointerToRawData) {
      void* entryData = (void*)((size_t)pe + (size_t)entry->PointerToRawData);

      // Zero out the address that PointerToRawData points to
      ZeroMemory(entryData, entry->SizeOfData);
    }

    // Remove the entry itself from the debug directory
    ZeroMemory(entry, sizeof(IMAGE_DEBUG_DIRECTORY));
  }

  ZeroMemory(debugDirectory, sizeof(IMAGE_DATA_DIRECTORY));

  return true;
}

bool StripRichHeader(void* pe)
{
  auto mode = PeArchitectureMode(pe);
  auto ptrSize = mode == 32 ? 4 : 8;
  auto dosHeader = PeDosHeader(pe);
  auto ntHeader = PeNtHeader(pe, mode);
  bool bFound = false;
  void* pCurHeader = ntHeader;

  while (pCurHeader > dosHeader)
  {
    // 'Rich'
    if (*(DWORD*)pCurHeader == 0x68636952)
    {
      bFound = true;
      break;
    }

    pCurHeader = (void*)((size_t)pCurHeader - ptrSize);
  }

  if (bFound)
  {
    // pCurHeader points to the rich header
    auto richHeaderStart = (void*)((size_t)pe + 0x80);
    auto richHeaderEnd = (void*)((size_t)pCurHeader + 8);

    ZeroMemory(richHeaderStart, (size_t)richHeaderEnd - (size_t)richHeaderStart);
  }

  return bFound;
}

```

`PECleaner/StripDebugInformation.h`:

```h
#pragma once

bool StripDebugInformation(void* pe);

// Scans from the beginning of the NT header back to the dosHeader looking for 'Rich'
// Once it finds rich, it knows where the end of the rich header is.
// Zeros out PE + 0x80 - end of rich header.
bool StripRichHeader(void* pe);
```

`README.md`:

```md
# PECleaner

Portable executable files leak information about the compiler, author, and build environment in the form of a RICH header. This tool removes the RICH header from x86/x64 PE files. Simple.

## Usage

1. Open the test file `tests\CppTest_x64_DEBUG.exe` in a hex editor and look at the RICH header.

Run PECleaner on the test file.

`.\PeCleaner.exe ..\tests\CppTest_x64_DEBUG.exe`

---
# Example

Before (partial) This portion of the rich header contains environment specific information.

![before](resources/before.png)

After

![after](resources/after.png)
```