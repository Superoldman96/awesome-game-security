Project Path: arc_gmh5225_DeepAimDetector_9frnl8ab

Source Tree:

```txt
arc_gmh5225_DeepAimDetector_9frnl8ab
├── README.md
├── images
│   └── Setpember_24_2020_Test.png
├── model
│   └── lstm.ipynb
└── parser
    └── to_csv.go

```

`README.md`:

```md
# DeepAimDetector
We train a small aimbot detector on individual gunfights, boosting the supervision and detection signal.

### Implementation Overview
Data is parsed from 64 hz SourceTV demos, sampled at 32 hz.  
Primary features are view angle deltas, and the relative angular position of targets.
The model is a vanilla LSTM-512.  
Training data:  
- ~15,000 data points (~5,000 if trained on kills instead of bullet impacts)
- All generated by me
- All cheat samples from one commercial "legit" aimbot
- All kills using ak-47 on bots in deathmatch

### Results
Test accuracy on data from a different player using the same cheat:  
![alt text](images/Setpember_24_2020_Test.png)

### Discussion
This toy experiment determines that a small neural network can, with moderate discriminative ability, determine if an engagement was assisted by a legit aimbot. A highlight is that the model maintains decent accuracy (~0.6 AUC) when tested against data from a player it had not seen before.

But this model is quite academic. A production model would have to be validated against a representative sample of players to ensure acceptable performance across the board. Even assuming good generalization, we require much more data to boost our discriminative ability to useful levels. The current model can achieve ~90% specificity at ~20% sensitivity on a balanced dataset--which is unacceptable on the true, imbalanced distribution of cheaters. Assuming that 1% of kills in real games are assisted by an aimbot, the model would flag 50 clean kills per assisted kill.

On the bright side, the model is per-engagement, not per player. So one might be able to improve per-player specificity and sensitivity by running the model on many of their shots. But I doubt that measurements from the model are perfectly independent, so one might also exhaust the predictive power of the test. Lastly, real cheaters could adapt and toggle their aim assistance to hide within the noise of the model.

Overall, I think it's quite difficult to detect legit aim assistance with the resources of a single engineer and a few community server owners. I think it's even difficult for humans to detect it, and I hope to post results on human benchmarks in a few weeks. In the future, I think I will try to incrementally improve the detection of rage and semi-rage aim assistance.

Lastly, to make an actual impact, I need to integrate with and improve an existing ban pipeline. 

### TODO
- More feature engineering
- Model other cheats
- Get cheat samples from real games
- Benchmark human detection ability

### Long-term Goals
- Self-/semi-supervision to improve sample efficiency
  - Multi-task with player skill modeling
- Scale

```

`model/lstm.ipynb`:

```ipynb
Jupyter Notebook Summary:
Total cells: 15 (14 code, 1 markdown, 0 raw)

Code Cell #1:
```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, roc_auc_score
from keras import initializers
from keras.models import Model
from keras.layers import LSTM, Activation, Dense, Dropout, Input, Embedding, Bidirectional
from tensorflow.keras import regularizers
from tensorflow.keras.optimizers import RMSprop, Adam
from keras.preprocessing.text import Tokenizer
from keras.preprocessing import sequence
from keras.utils import to_categorical
from keras.callbacks import EarlyStopping
%matplotlib inline

np.set_printoptions(precision=3, suppress=True)

seed = 16
np.random.seed(seed)
```

Code Cell #2:
```python
df = pd.read_csv('train.csv', header=None, delimiter=',',encoding='latin-1')

sb.countplot(df[0])
plt.xlabel('Cheating')
plt.title('Clean and cheat samples, total')
```

Code Cell #3:
```python
num_samples = 48
num_features = 0

def extract_features(df):
    global num_samples # why tho
    global num_features
    data = df.to_numpy()
    
    Y = data[:, 0]
    X = data[:, 1:]
    
    # Only us some features
    features = [0, 1, 2, 3, 4, 5, 6]
    num_features = len(features)
    idxs = []
    
    for i in range(X.shape[1]):
        if (i >= 7 * num_samples):
            continue
        if (i % 7) in features:
            idxs.append(i)
            
    num_samples = len(idxs) // num_features
    X = X[:, idxs]
    X = X.reshape(-1, num_samples, num_features)
    
    return X, Y
    

def split(X, Y):
    X_train, X_val, Y_train, Y_val = [], [], [], []
    
    # Split training at test set, in chunks to prevent information leak
    chunk_size = 100
    val_fraction = 0.2
    chunks = [[*range(chunk_size * i, chunk_size * (i+1))] for i in range(Y.shape[0]//chunk_size)]
    chunks.append([*range(chunk_size * (Y.shape[0]//chunk_size - 1), Y.shape[0] -1)])
    np.random.shuffle(chunks)
    
    for i, chunk in enumerate(chunks):
        if i < len(chunks) * 0.2:
            X_val.extend(X[chunk])
            Y_val.extend(Y[chunk])
        else:
            X_train.extend(X[chunk])
            Y_train.extend(Y[chunk])
            
    X_train = np.array(X_train)
    Y_train = np.array(Y_train)
    X_val = np.array(X_val)
    Y_val = np.array(Y_val)
    
    return X_train, Y_train, X_val, Y_val
```

... [11 more code cells omitted]

```

`parser/to_csv.go`:

```go
package main

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"

	strings "strings"

	"github.com/golang/geo/r3"
	dem "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs"
	common "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/common"
	events "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/events"
)

// File paths
var dest = "../model/other.csv"
var source = "./demos/other/"

// Defines amount of frames to collect around attacks
const samplesPerSecond = 32
const secondsBeforeAttack = 1
const secondsAfterAttack = 1
const secondsPerAttack = secondsBeforeAttack + secondsAfterAttack
const samplesPerAttack = int(samplesPerSecond * secondsPerAttack)

// PlayerData stores all data of a player in a single frame.
type PlayerData struct {
	weapon    string
	position  r3.Vector
	yaw       float32
	pitch     float32
	crouching bool
	firing    bool
	health    int
}

// AttackTime marks when an attacker shot a victim
type AttackTime struct {
	attacker    int
	victim      int
	startFrame  int
	attackFrame int
	endFrame    int
}

// FireFrameKey is a key to a dictionary that marks
// if a shooter shoot at a given frame
type FireFrameKey struct {
	shooter int
	frame   int
}

// AttackData stores the features of a single sample fed into the model.
type AttackData struct {
	// Whether the attacker used an aimbot during the attack
	attackerAimbot bool

	// One-hot encoding of attacking gun
	weaponAK47 bool
	weaponM4A4 bool
	weaponAWP  bool

	// Viewangle deltas
	attackerDeltaYaw   [samplesPerAttack]float32
	attackerDeltaPitch [samplesPerAttack]float32

	// Angles between the attacker's crosshair and the victim
	crosshairToVictimYaw   [samplesPerAttack]float32
	crosshairToVictimPitch [samplesPerAttack]float32

	victimDistance    [samplesPerAttack]float32
	attackerCrouching [samplesPerAttack]bool
	victimCrouching   [samplesPerAttack]bool
	attackerFiring    [samplesPerAttack]bool

	attackerHealth [samplesPerAttack]int
	victimHealth   [samplesPerAttack]int

	attackerViewVector     [samplesPerAttack]r3.Vector
	attackerToVictimVector [samplesPerAttack]r3.Vector

	//attackerX [samplesPerAttack]float32
	//victimX   [samplesPerAttack]float32
}

// Marks guns that the model will be trained on
// TODO: Test model on different sets of guns.
var validGuns = map[string]bool{
	"AK-47": true,
	//"M4A4":  true,
	//"AWP":   true,
	//"M4A1": true,
	//"AUG":    true,
	//"SG 553": true,
}

// Stores data to be fed into model
var modelData = []AttackData{}

func main() {
	//source = "E:/demos/shadowkeeper/"

	files, err := ioutil.ReadDir(source)
	if err != nil {
		log.Fatal(err)
	}
	for _, f := range files {
		fmt.Println(f.Name())
		parseDemo(source, f.Name())
	}
	csvExport()
}

func parseDemo(source string, name string) {
	// Times when a player is attacked by a valid gun
	var attackTimes = []AttackTime{}
	// Marks if a player is firing at a given frame.
	var fireFrames = map[FireFrameKey]bool{}
	// Marks frames surrounding attacks that should be gathered
	// for easier processing into model inputs
	var isMarked = map[int]bool{}
	// Stores the PlayerData for each player for each marked framed
	var markedFrameData = map[int]map[int]PlayerData{}
	// Marks if the demo was generated with an aimbot
	aimbot := strings.Contains(name, "_aimbot_")

	f, err := os.Open(source + name)
	defer f.Close()
	checkError(err)
	p := dem.NewParser(f)

	h, err := p.ParseHeader()
	FrameRate := h.FrameRate()

	// Calculate the demo framerate with some hacks
	tick := -1
	for !(2900 < tick && tick < 3000) {
		_, err = p.ParseNextFrame()
		tick = p.GameState().IngameTick()
	}
	checkError(err)
	iters := 10
	for i := 0; i < iters; i++ {
		_, err = p.ParseNextFrame()
		checkError(err)
	}
	nextTick := p.GameState().IngameTick()

	TicksPerFrame := float64(nextTick-tick) / float64(iters)
	FrameRate2 := p.TickRate() / TicksPerFrame

	if FrameRate == 0 {
		FrameRate = FrameRate2
	}

	var framesBeforeAttack int
	var framesAfterAttack int
	if (math.Abs(FrameRate-32.0) < 1) && (FrameRate2 == 32) {
		framesBeforeAttack = secondsBeforeAttack * 32
		framesAfterAttack = secondsAfterAttack * 32
	} else if (math.Abs(FrameRate-64.0) < 4) && (FrameRate2 == 64) {
		framesBeforeAttack = secondsBeforeAttack * 64
		framesAfterAttack = secondsAfterAttack * 64
	} else if (math.Abs(FrameRate-128) < 4) && (FrameRate2 == 128) {
		framesBeforeAttack = secondsBeforeAttack * 128
		framesAfterAttack = secondsAfterAttack * 128
	} else {
		println("Invalid frame rate: ", FrameRate, FrameRate2)
		return
	}

	framesPerAttack := framesBeforeAttack + framesAfterAttack
	framesPerSample := int(framesPerAttack / samplesPerAttack)
	println("Frames per sample ", framesPerSample)

	// First pass.

	// Get frame times of attacks with valid guns,
	// and mark surrounding frames for retrieval.
	attackCount := 0
	p.RegisterEventHandler(func(e events.PlayerHurt) {
		if !validGuns[e.Weapon.String()] {
			return
		}
		if e.Attacker.SteamID64 == 0 { // Ignore bots
			return
		}

		attackCount++
		attackFrame := p.CurrentFrame()
		start := attackFrame - framesBeforeAttack
		end := attackFrame + framesAfterAttack
		for frame := start; frame < end; frame++ {
			isMarked[frame] = true
		}
		isMarked[start-framesPerSample] = true // For first sample delta angles
		new := AttackTime{
			e.Attacker.UserID, e.Player.UserID, start, attackFrame, end}
		attackTimes = append(attackTimes, new)
	})

	// Track frames where a player fires a weapon
	p.RegisterEventHandler(func(e events.WeaponFire) {
		frame := p.CurrentFrame()
		// Include previous frames so that shot is not lost after sampling
		for i := 0; i < framesPerSample; i++ {
			fireFrames[FireFrameKey{e.Shooter.UserID, frame - i}] = true
		}
	})
	err = p.ParseToEnd()
	fmt.Printf("Valid attacks: %d\n", attackCount)

	// Second pass.

	// Extract player data from marked frames
	f, err = os.Open(source + name)
	p = dem.NewParser(f)
	for ok := true; ok; ok, err = p.ParseNextFrame() {
		checkError(err)
		frame := p.CurrentFrame()

		if !isMarked[frame] {
			continue
		}

		var players = map[int]PlayerData{}
		gs := p.GameState()
		for _, player := range gs.Participants().Playing() {
			players[player.UserID] = extractPlayerData(frame, player, fireFrames)
		}
		markedFrameData[frame] = players
	}

	// Extract each attack's AttackData, and add it to modelData
	for _, attack := range attackTimes {
		weapon := markedFrameData[attack.attackFrame][attack.attacker].weapon
		attackData := AttackData{
			attackerAimbot: aimbot,
			weaponAK47:     weapon == "AK-47",
			weaponM4A4:     weapon == "M4A4",
			weaponAWP:      weapon == "AWP",
		}

		prevFrame := attack.startFrame - framesPerSample
		prevAttackerYaw := markedFrameData[prevFrame][attack.attacker].yaw
		prevAttackerPitch := markedFrameData[prevFrame][attack.attacker].pitch

		for sample := 0; sample < samplesPerAttack; sample++ {
			frame := framesPerSample*sample + attack.startFrame
			attacker := markedFrameData[frame][attack.attacker]
			victim := markedFrameData[frame][attack.victim]

			attackerYaw := attacker.yaw
			attackerPitch := attacker.pitch
			attackData.attackerDeltaYaw[sample] = normalizeAngle(
				attackerYaw - prevAttackerYaw)
			attackData.attackerDeltaPitch[sample] = attackerPitch - prevAttackerPitch
			prevAttackerYaw = attackerYaw
			prevAttackerPitch = attackerPitch

			attackerToVictim := victim.position.Sub(attacker.position)
			attackData.attackerToVictimVector[sample] = attackerToVictim.Normalize()

			dX := attackerToVictim.X
			dY := attackerToVictim.Y
			dZ := attackerToVictim.Z
			attackerToVictimYaw := 180 / math.Pi * float32(math.Atan2(dY, dX))
			attackerToVictimPitch := 180 / math.Pi * float32(math.Atan2(
				math.Sqrt(dX*dX+dY*dY),
				dZ))

			// Smallest angle between attackerToVictimYaw and attackerYaw
			attackData.crosshairToVictimYaw[sample] =
				normalizeAngle(attackerToVictimYaw - attackerYaw)
			attackData.crosshairToVictimPitch[sample] =
				attackerToVictimPitch - attackerPitch

			attackData.victimDistance[sample] = float32(attackerToVictim.Norm())

			attackData.attackerCrouching[sample] = attacker.crouching
			attackData.victimCrouching[sample] = victim.crouching
			attackData.attackerFiring[sample] = attacker.firing

			attackData.attackerHealth[sample] = attacker.health
			attackData.victimHealth[sample] = victim.health

			attackerYaw64 := float64(math.Pi / 180 * attackerYaw)
			attackerPitch64 := float64(math.Pi / 180 * attackerPitch)
			attackData.attackerViewVector[sample] = r3.Vector{
				math.Cos(attackerYaw64) * math.Sin(attackerPitch64),
				math.Sin(attackerYaw64) * math.Sin(attackerPitch64),
				math.Cos(attackerPitch64)}

			//attackData.attackerX[sample] = float32(attacker.position.X)
			//attackData.victimX[sample] = float32(victim.position.X)
		}
		// A player teleported. Throw away the data.
		modelData = append(modelData, attackData)
	}
	f.Close()
}

func extractPlayerData(
	frame int,
	player *common.Player,
	fireFrames map[FireFrameKey]bool) PlayerData {

	fixedPitch := float32(math.Mod(
		float64(player.ViewDirectionY())+90,
		180))

	weapon := ""
	if player.ActiveWeapon() != nil {
		weapon = player.ActiveWeapon().String()
	}

	return PlayerData{
		weapon,
		player.LastAlivePosition,
		player.ViewDirectionX(),
		fixedPitch,
		player.IsDucking(),
		fireFrames[FireFrameKey{player.UserID, frame}],
		player.Health()}
}

func csvExport() error {
	file, err := os.OpenFile(dest, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}

	writer := csv.NewWriter(file)

	for _, attackData := range modelData {
		err := writer.Write(attackToString(attackData))
		if err != nil {
			return err
		}
	}

	writer.Flush()
	file.Close()
	return nil
}

func attackToString(data AttackData) []string {
	var out []string

	var aimbot int
	if data.attackerAimbot {
		aimbot = 1
	} else {
		aimbot = 0
	}
	out = append(out, fmt.Sprintf("%d", aimbot))

	for i := 0; i < samplesPerAttack; i++ {
		//out = append(out, fmt.Sprintf("%.3f", data.attackerViewVector[i].X))
		//out = append(out, fmt.Sprintf("%.3f", data.attackerViewVector[i].Y))
		//out = append(out, fmt.Sprintf("%.3f", data.attackerViewVector[i].Z))
		//out = append(out, fmt.Sprintf("%.3f", data.attackerToVictimVector[i].X))
		//out = append(out, fmt.Sprintf("%.3f", data.attackerToVictimVector[i].Y))
		//out = append(out, fmt.Sprintf("%.3f", data.attackerToVictimVector[i].Z))
		//out = append(out, fmt.Sprintf("%.0f", data.victimDistance[i]))
		out = append(out, fmt.Sprintf("%.3f", data.attackerDeltaYaw[i]))
		out = append(out, fmt.Sprintf("%.3f", data.attackerDeltaPitch[i]))
		out = append(out, fmt.Sprintf("%.3f", data.crosshairToVictimYaw[i]))
		out = append(out, fmt.Sprintf("%.3f", data.crosshairToVictimPitch[i]))

		if data.attackerFiring[i] {
			out = append(out, fmt.Sprintf("%d", 1))
		} else {
			out = append(out, fmt.Sprintf("%d", 0))
		}

		if data.attackerHealth[i] == 0 {
			out = append(out, fmt.Sprintf("%d", 1))
		} else {
			out = append(out, fmt.Sprintf("%d", 0))
		}

		if data.victimHealth[i] == 0 {
			out = append(out, fmt.Sprintf("%d", 1))
		} else {
			out = append(out, fmt.Sprintf("%d", 0))
		}
	}
	return out
}

// Returns a mod b, keeping the sign of b
func divisorSignMod(a float64, b float64) float64 {
	return math.Mod(math.Mod(a, b)+b, b)
}

// Normalize an angle to be between -180 and 180
func normalizeAngle(a float32) float32 {
	return float32(-180 + divisorSignMod(float64(a)+180, 360))
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

```