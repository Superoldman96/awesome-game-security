Project Path: arc_gmh5225_Deobfuscator_drq1dix9

Source Tree:

```txt
arc_gmh5225_Deobfuscator_drq1dix9
â”œâ”€â”€ CODE_OF_CONDUCT.md
â”œâ”€â”€ CONTRIBUTING.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚   â””â”€â”€ run-deobfuscator.gif
â”œâ”€â”€ deobfuscator-api
â”‚   â”œâ”€â”€ pom.xml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main
â”‚           â””â”€â”€ java
â”‚               â”œâ”€â”€ org
â”‚               â”‚   â””â”€â”€ objectweb
â”‚               â”‚       â””â”€â”€ asm
â”‚               â”‚           â”œâ”€â”€ Symbol.java
â”‚               â”‚           â””â”€â”€ tree
â”‚               â”‚               â”œâ”€â”€ AbstractInsnNode.java
â”‚               â”‚               â”œâ”€â”€ InsnList.java
â”‚               â”‚               â””â”€â”€ analysis
â”‚               â”‚                   â”œâ”€â”€ JumpPredictingAnalyzer.java
â”‚               â”‚                   â”œâ”€â”€ OriginalSourceInterpreter.java
â”‚               â”‚                   â””â”€â”€ OriginalSourceValue.java
â”‚               â””â”€â”€ uwu
â”‚                   â””â”€â”€ narumi
â”‚                       â””â”€â”€ deobfuscator
â”‚                           â””â”€â”€ api
â”‚                               â”œâ”€â”€ asm
â”‚                               â”‚   â”œâ”€â”€ ClassWrapper.java
â”‚                               â”‚   â”œâ”€â”€ ConstantPool.java
â”‚                               â”‚   â”œâ”€â”€ FieldRef.java
â”‚                               â”‚   â”œâ”€â”€ InsnContext.java
â”‚                               â”‚   â”œâ”€â”€ MethodContext.java
â”‚                               â”‚   â”œâ”€â”€ MethodRef.java
â”‚                               â”‚   â”œâ”€â”€ NamedOpcodes.java
â”‚                               â”‚   â””â”€â”€ matcher
â”‚                               â”‚       â”œâ”€â”€ Match.java
â”‚                               â”‚       â”œâ”€â”€ MatchContext.java
â”‚                               â”‚       â”œâ”€â”€ group
â”‚                               â”‚       â”‚   â”œâ”€â”€ AllMatch.java
â”‚                               â”‚       â”‚   â”œâ”€â”€ AnyMatch.java
â”‚                               â”‚       â”‚   â”œâ”€â”€ NotMatch.java
â”‚                               â”‚       â”‚   â”œâ”€â”€ PositionedMatch.java
â”‚                               â”‚       â”‚   â””â”€â”€ SequenceMatch.java
â”‚                               â”‚       â””â”€â”€ impl
â”‚                               â”‚           â”œâ”€â”€ ClassTypeMatch.java
â”‚                               â”‚           â”œâ”€â”€ FieldMatch.java
â”‚                               â”‚           â”œâ”€â”€ InsnMatch.java
â”‚                               â”‚           â”œâ”€â”€ InvokeDynamicMatch.java
â”‚                               â”‚           â”œâ”€â”€ JumpMatch.java
â”‚                               â”‚           â”œâ”€â”€ MethodMatch.java
â”‚                               â”‚           â”œâ”€â”€ NumberMatch.java
â”‚                               â”‚           â”œâ”€â”€ OpcodeMatch.java
â”‚                               â”‚           â”œâ”€â”€ RangeOpcodeMatch.java
â”‚                               â”‚           â”œâ”€â”€ SkipMatch.java
â”‚                               â”‚           â”œâ”€â”€ StackMatch.java
â”‚                               â”‚           â””â”€â”€ StringMatch.java
â”‚                               â”œâ”€â”€ classpath
â”‚                               â”‚   â”œâ”€â”€ ClassProvider.java
â”‚                               â”‚   â”œâ”€â”€ ClassStorage.java
â”‚                               â”‚   â”œâ”€â”€ CombinedClassProvider.java
â”‚                               â”‚   â”œâ”€â”€ InheritanceClassWriter.java
â”‚                               â”‚   â””â”€â”€ JvmClassProvider.java
â”‚                               â”œâ”€â”€ context
â”‚                               â”‚   â”œâ”€â”€ Context.java
â”‚                               â”‚   â””â”€â”€ DeobfuscatorOptions.java
â”‚                               â”œâ”€â”€ data
â”‚                               â”‚   â”œâ”€â”€ Pair.java
â”‚                               â”‚   â”œâ”€â”€ TriConsumer.java
â”‚                               â”‚   â””â”€â”€ TriFunction.java
â”‚                               â”œâ”€â”€ exception
â”‚                               â”‚   â””â”€â”€ TransformerException.java
â”‚                               â”œâ”€â”€ execution
â”‚                               â”‚   â”œâ”€â”€ ClasspathDataSupplier.java
â”‚                               â”‚   â””â”€â”€ SandBox.java
â”‚                               â”œâ”€â”€ helper
â”‚                               â”‚   â”œâ”€â”€ AsmHelper.java
â”‚                               â”‚   â”œâ”€â”€ AsmMathHelper.java
â”‚                               â”‚   â”œâ”€â”€ ClassHelper.java
â”‚                               â”‚   â”œâ”€â”€ FileHelper.java
â”‚                               â”‚   â”œâ”€â”€ FramedInstructionsStream.java
â”‚                               â”‚   â””â”€â”€ MethodHelper.java
â”‚                               â”œâ”€â”€ inheritance
â”‚                               â”‚   â”œâ”€â”€ InheritanceGraph.java
â”‚                               â”‚   â”œâ”€â”€ InheritanceVertex.java
â”‚                               â”‚   â””â”€â”€ Streams.java
â”‚                               â””â”€â”€ transformer
â”‚                                   â”œâ”€â”€ ComposedTransformer.java
â”‚                                   â”œâ”€â”€ Transformer.java
â”‚                                   â””â”€â”€ VersionedComposedTransformer.java
â”œâ”€â”€ deobfuscator-impl
â”‚   â”œâ”€â”€ pom.xml
â”‚   â””â”€â”€ src
â”‚       â”œâ”€â”€ main
â”‚       â”‚   â”œâ”€â”€ java
â”‚       â”‚   â”‚   â””â”€â”€ uwu
â”‚       â”‚   â”‚       â””â”€â”€ narumi
â”‚       â”‚   â”‚           â””â”€â”€ deobfuscator
â”‚       â”‚   â”‚               â””â”€â”€ Deobfuscator.java
â”‚       â”‚   â””â”€â”€ resources
â”‚       â”‚       â””â”€â”€ log4j2.xml
â”‚       â””â”€â”€ test
â”‚           â”œâ”€â”€ java
â”‚           â”‚   â”œâ”€â”€ Bootstrap.java
â”‚           â”‚   â””â”€â”€ uwu
â”‚           â”‚       â””â”€â”€ narumi
â”‚           â”‚           â””â”€â”€ deobfuscator
â”‚           â”‚               â”œâ”€â”€ TestDeobfuscation.java
â”‚           â”‚               â”œâ”€â”€ base
â”‚           â”‚               â”‚   â”œâ”€â”€ AssertingResultSaver.java
â”‚           â”‚               â”‚   â”œâ”€â”€ SingleClassContextSource.java
â”‚           â”‚               â”‚   â””â”€â”€ TestDeobfuscationBase.java
â”‚           â”‚               â””â”€â”€ transformer
â”‚           â”‚                   â””â”€â”€ TestSandboxSecurityTransformer.java
â”‚           â””â”€â”€ resources
â”‚               â””â”€â”€ junit-platform.properties
â”œâ”€â”€ deobfuscator-transformers
â”‚   â”œâ”€â”€ pom.xml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main
â”‚           â””â”€â”€ java
â”‚               â””â”€â”€ uwu
â”‚                   â””â”€â”€ narumi
â”‚                       â””â”€â”€ deobfuscator
â”‚                           â””â”€â”€ core
â”‚                               â””â”€â”€ other
â”‚                                   â”œâ”€â”€ composed
â”‚                                   â”‚   â”œâ”€â”€ ComposedAllatoriTransformer.java
â”‚                                   â”‚   â”œâ”€â”€ ComposedHP888Transformer.java
â”‚                                   â”‚   â”œâ”€â”€ ComposedZelixTransformer.java
â”‚                                   â”‚   â””â”€â”€ general
â”‚                                   â”‚       â”œâ”€â”€ ComposedGeneralFlowTransformer.java
â”‚                                   â”‚       â”œâ”€â”€ ComposedGeneralRepairTransformer.java
â”‚                                   â”‚       â””â”€â”€ ComposedPeepholeCleanTransformer.java
â”‚                                   â””â”€â”€ impl
â”‚                                       â”œâ”€â”€ allatori
â”‚                                       â”‚   â””â”€â”€ AllatoriStringTransformer.java
â”‚                                       â”œâ”€â”€ clean
â”‚                                       â”‚   â”œâ”€â”€ AnnotationCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ ClassDebugInfoCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ InvalidMethodCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ LineNumberCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ LocalVariableNamesCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ MethodDebugInfoCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ ParametersInfoCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ SignatureCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ ThrowsExceptionCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ TryCatchBlockCleanTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ UnknownAttributeCleanTransformer.java
â”‚                                       â”‚   â””â”€â”€ peephole
â”‚                                       â”‚       â”œâ”€â”€ DeadCodeCleanTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ JsrInlinerTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ NopCleanTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ PopUnUsedLocalVariablesTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ UnUsedLabelCleanTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ UselessGotosCleanTransformer.java
â”‚                                       â”‚       â””â”€â”€ UselessPopCleanTransformer.java
â”‚                                       â”œâ”€â”€ exploit
â”‚                                       â”‚   â””â”€â”€ WebExploitRemoveTransformer.java
â”‚                                       â”œâ”€â”€ hp888
â”‚                                       â”‚   â”œâ”€â”€ HP888PackerTransformer.java
â”‚                                       â”‚   â””â”€â”€ HP888StringTransformer.java
â”‚                                       â”œâ”€â”€ pool
â”‚                                       â”‚   â”œâ”€â”€ InlineLocalVariablesTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ InlineStaticArrayFieldTransformer.java
â”‚                                       â”‚   â””â”€â”€ InlineStaticFieldTransformer.java
â”‚                                       â”œâ”€â”€ universal
â”‚                                       â”‚   â”œâ”€â”€ AccessRepairTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ AnnotationFilterTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ RecoverSyntheticsTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ TryCatchRepairTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ UniversalFlowTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ UniversalNumberTransformer.java
â”‚                                       â”‚   â”œâ”€â”€ flow
â”‚                                       â”‚   â”‚   â”œâ”€â”€ CleanRedundantJumpsTransformer.java
â”‚                                       â”‚   â”‚   â””â”€â”€ CleanRedundantSwitchesTransformer.java
â”‚                                       â”‚   â””â”€â”€ number
â”‚                                       â”‚       â”œâ”€â”€ MathBinaryOperationsTransformer.java
â”‚                                       â”‚       â”œâ”€â”€ MathUnaryOperationsTransformer.java
â”‚                                       â”‚       â””â”€â”€ MethodCallsOnLiteralsTransformer.java
â”‚                                       â””â”€â”€ zkm
â”‚                                           â”œâ”€â”€ ZelixLongEncryptionMPCTransformer.java
â”‚                                           â”œâ”€â”€ ZelixParametersTransformer.java
â”‚                                           â”œâ”€â”€ ZelixStringTransformer.java
â”‚                                           â””â”€â”€ ZelixUselessTryCatchRemoverTransformer.java
â”œâ”€â”€ pom.xml
â”œâ”€â”€ reverse-engineering
â”‚   â”œâ”€â”€ pom.xml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main
â”‚           â””â”€â”€ java
â”‚               â””â”€â”€ zelix
â”‚                   â”œâ”€â”€ enhancedstringenc
â”‚                   â”‚   â”œâ”€â”€ ManyStrings.java
â”‚                   â”‚   â”œâ”€â”€ ManyStringsOriginal.java
â”‚                   â”‚   â”œâ”€â”€ SomeStrings.java
â”‚                   â”‚   â””â”€â”€ SomeStrings2.java
â”‚                   â””â”€â”€ longdecrypter
â”‚                       â”œâ”€â”€ FallbackLongDecrypter.java
â”‚                       â”œâ”€â”€ ILongDecrypter.java
â”‚                       â”œâ”€â”€ Main.java
â”‚                       â””â”€â”€ SimpleLongDecrypter.java
â””â”€â”€ testData
    â”œâ”€â”€ compiled
    â”‚   â”œâ”€â”€ custom-classes
    â”‚   â”‚   â”œâ”€â”€ FlowObfSample.class
    â”‚   â”‚   â”œâ”€â”€ JSR.class
    â”‚   â”‚   â”œâ”€â”€ Pop2Sample.class
    â”‚   â”‚   â”œâ”€â”€ hp888
    â”‚   â”‚   â”‚   â”œâ”€â”€ IIIlIIIlllIIIlllIIlIllIIlIIIIIllIlIIlIlIllIIIlIIII.class
    â”‚   â”‚   â”‚   â”œâ”€â”€ com
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ bric
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ colorpicker
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ ColorPicker$1.mc
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ ColorPicker.mc
    â”‚   â”‚   â”‚   â”‚           â””â”€â”€ ColorPickerMode.mc
    â”‚   â”‚   â”‚   â””â”€â”€ pack
    â”‚   â”‚   â”‚       â””â”€â”€ MyFunction2.class
    â”‚   â”‚   â””â”€â”€ zkm
    â”‚   â”‚       â”œâ”€â”€ EnhancedStringEncManyStrings.class
    â”‚   â”‚       â”œâ”€â”€ EnhancedStringEncSomeStrings.class
    â”‚   â”‚       â”œâ”€â”€ sample1
    â”‚   â”‚       â”‚   â”œâ”€â”€ io
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ github
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ repooper
    â”‚   â”‚       â”‚   â”‚           â””â”€â”€ packetevents
    â”‚   â”‚       â”‚   â”‚               â”œâ”€â”€ PacketEvents.class
    â”‚   â”‚       â”‚   â”‚               â””â”€â”€ utils
    â”‚   â”‚       â”‚   â”‚                   â””â”€â”€ netty
    â”‚   â”‚       â”‚   â”‚                       â””â”€â”€ bytebuf
    â”‚   â”‚       â”‚   â”‚                           â”œâ”€â”€ ByteBufUtil.class
    â”‚   â”‚       â”‚   â”‚                           â”œâ”€â”€ ByteBufUtil_7.class
    â”‚   â”‚       â”‚   â”‚                           â””â”€â”€ ByteBufUtil_8.class
    â”‚   â”‚       â”‚   â””â”€â”€ me
    â”‚   â”‚       â”‚       â””â”€â”€ frep
    â”‚   â”‚       â”‚           â””â”€â”€ vulcan
    â”‚   â”‚       â”‚               â””â”€â”€ spigot
    â”‚   â”‚       â”‚                   â”œâ”€â”€ Vulcan_a.class
    â”‚   â”‚       â”‚                   â”œâ”€â”€ Vulcan_m.class
    â”‚   â”‚       â”‚                   â””â”€â”€ Vulcan_x.class
    â”‚   â”‚       â””â”€â”€ sample2
    â”‚   â”‚           â””â”€â”€ a
    â”‚   â”‚               â””â”€â”€ a
    â”‚   â”‚                   â””â”€â”€ a
    â”‚   â”‚                       â””â”€â”€ a
    â”‚   â”‚                           â”œâ”€â”€ a.class
    â”‚   â”‚                           â”œâ”€â”€ a4.class
    â”‚   â”‚                           â”œâ”€â”€ a_.class
    â”‚   â”‚                           â”œâ”€â”€ b.class
    â”‚   â”‚                           â”œâ”€â”€ ba.class
    â”‚   â”‚                           â”œâ”€â”€ bc.class
    â”‚   â”‚                           â””â”€â”€ c.class
    â”‚   â””â”€â”€ custom-jars
    â”‚       â””â”€â”€ SnakeGame-obf-zkm.jar
    â”œâ”€â”€ results
    â”‚   â”œâ”€â”€ custom-classes
    â”‚   â”‚   â”œâ”€â”€ FlowObfSample.dec
    â”‚   â”‚   â”œâ”€â”€ JSR.dec
    â”‚   â”‚   â”œâ”€â”€ Pop2Sample.dec
    â”‚   â”‚   â”œâ”€â”€ hp888
    â”‚   â”‚   â”‚   â”œâ”€â”€ com
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ bric
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ colorpicker
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ ColorPicker$1.dec
    â”‚   â”‚   â”‚   â”‚           â”œâ”€â”€ ColorPicker.dec
    â”‚   â”‚   â”‚   â”‚           â””â”€â”€ ColorPickerMode.dec
    â”‚   â”‚   â”‚   â””â”€â”€ pack
    â”‚   â”‚   â”‚       â””â”€â”€ MyFunction2.dec
    â”‚   â”‚   â””â”€â”€ zkm
    â”‚   â”‚       â”œâ”€â”€ EnhancedStringEncManyStrings.dec
    â”‚   â”‚       â”œâ”€â”€ EnhancedStringEncSomeStrings.dec
    â”‚   â”‚       â”œâ”€â”€ sample1
    â”‚   â”‚       â”‚   â””â”€â”€ io
    â”‚   â”‚       â”‚       â””â”€â”€ github
    â”‚   â”‚       â”‚           â””â”€â”€ repooper
    â”‚   â”‚       â”‚               â””â”€â”€ packetevents
    â”‚   â”‚       â”‚                   â”œâ”€â”€ PacketEvents.dec
    â”‚   â”‚       â”‚                   â””â”€â”€ utils
    â”‚   â”‚       â”‚                       â””â”€â”€ netty
    â”‚   â”‚       â”‚                           â””â”€â”€ bytebuf
    â”‚   â”‚       â”‚                               â”œâ”€â”€ ByteBufUtil.dec
    â”‚   â”‚       â”‚                               â”œâ”€â”€ ByteBufUtil_7.dec
    â”‚   â”‚       â”‚                               â””â”€â”€ ByteBufUtil_8.dec
    â”‚   â”‚       â””â”€â”€ sample2
    â”‚   â”‚           â””â”€â”€ a
    â”‚   â”‚               â””â”€â”€ a
    â”‚   â”‚                   â””â”€â”€ a
    â”‚   â”‚                       â””â”€â”€ a
    â”‚   â”‚                           â”œâ”€â”€ a4.dec
    â”‚   â”‚                           â”œâ”€â”€ a_.dec
    â”‚   â”‚                           â”œâ”€â”€ ba.dec
    â”‚   â”‚                           â””â”€â”€ bc.dec
    â”‚   â”œâ”€â”€ custom-jars
    â”‚   â”‚   â””â”€â”€ SnakeGame-obf-zkm
    â”‚   â”‚       â”œâ”€â”€ Main.dec
    â”‚   â”‚       â”œâ”€â”€ a.dec
    â”‚   â”‚       â”œâ”€â”€ b.dec
    â”‚   â”‚       â”œâ”€â”€ c.dec
    â”‚   â”‚       â”œâ”€â”€ d.dec
    â”‚   â”‚       â”œâ”€â”€ e.dec
    â”‚   â”‚       â””â”€â”€ f.dec
    â”‚   â””â”€â”€ java
    â”‚       â”œâ”€â”€ TestInlineLocalVariables.dec
    â”‚       â”œâ”€â”€ TestInlineStaticFields.dec
    â”‚       â”œâ”€â”€ TestInlineStaticFieldsWithModification.dec
    â”‚       â”œâ”€â”€ TestSimpleFlowObfuscation.dec
    â”‚       â””â”€â”€ TestUniversalNumberTransformer.dec
    â””â”€â”€ src
        â””â”€â”€ java
            â”œâ”€â”€ pom.xml
            â””â”€â”€ src
                â””â”€â”€ main
                    â””â”€â”€ java
                        â”œâ”€â”€ TestInlineLocalVariables.java
                        â”œâ”€â”€ TestInlineStaticFields.java
                        â”œâ”€â”€ TestInlineStaticFieldsWithModification.java
                        â”œâ”€â”€ TestSimpleFlowObfuscation.java
                        â”œâ”€â”€ TestUniversalNumberTransformer.java
                        â””â”€â”€ sandbox
                            â””â”€â”€ TestSandboxSecurity.java

```

`CODE_OF_CONDUCT.md`:

```md
Go Fuck Yourself
=============

Offended? Go away. We don't need people who are offended because of a stranger on the internet.  
Not offended? You're welcome to contribute.

&copy; Copyright 2015 WTFCoC Consortium Committee.
```

`CONTRIBUTING.md`:

```md
# Contributing
Welcome! We are glad that you want to contribute to our deobfuscator.

## âœ¨ Best practises
- Add comments in complex areas. ASM is hard, so let's make it easier for others to understand what is happening in code (especially inside transformers).
- Upload obfuscated test class sample. We highly recommend tests for your transformers. When someone wants to rewrite some part of the code, then these tests are helping us that we won't break anything.

## ðŸªœ Project structure
The project is structured as follows:
- [`deobfuscator-api`](./deobfuscator-api) - The API for the deobfuscator.
- [`deobfuscator-impl`](./deobfuscator-impl) - The main deobfuscator runner.
- [`deobfuscator-transformers`](./deobfuscator-transformers) - Transformers for the deobfuscator.
- [`reverse-engineering`](./reverse-engineering) - A place where you can throw your reverse-engineered classes (for example: complex number pool, complex string pool). You can reference them inside your transformers to make them more readable.
- [`testData`](./testData) - Tests for transformers
  - [`src/java`](./testData/src/java) - You can write your java code to test transformers
  - [`compiled/custom-classes`](./testData/compiled/custom-classes) - Compiled classes to test transformers. You can throw here classes from your obfuscated jars.
  - [`compiled/custom-jars`](./testData/compiled/custom-jars) - Jars to test transformers. You can throw here your obfuscated jars.
  - `deobfuscated` - Raw classes after a deobfuscation process. Useful when debugging.
  - [`results`](./testData/results) - Expected results that are auto-generated decompiled java code.
- [`TestDeobfuscation.java`](./deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/TestDeobfuscation.java) - Class where each test sample is registered.
- [`Bootstrap.java`](./deobfuscator-impl/src/test/java/Bootstrap.java) - Class where you can run deobfuscator manually.

## ðŸ§° Recommended tools
- [IntelliJ IDEA](https://www.jetbrains.com/idea/download/) - IDE for Java development
- [Recaf](https://github.com/Col-E/Recaf) - Modern java bytecode editor. Use it to analyze obfuscated classes.
- [JVM Specification](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html) - Java Virtual Machine Specification. Use it to learn more about java bytecode. There are described things like JVM instructions, some terms, etc.
- [JVM Manual](https://github.com/ethaanol/jvm-manual/wiki) - Excellent community-made JVM manual that clearly explains most JVM concepts.

## ðŸ”¢ Some basics about java bytecode
[First of all](https://www.youtube.com/watch?v=TrHabuoQf7s) you need to learn some basics about java bytecode. The best way to learn it is to write an example java code (start with "hello world" program), compile it and throw the compiled jar to Recaf. Then find your class, right click, and click `Edit` -> `Edit class in assembler`. Here you can see your java bytecode. Try to compare it with your written java code, and find similarities, like how method invocation is done, variable accesses, math operations, etc. If you want to read a bit more about bytecode itself and instructions then there is [a great documentation of all JVM instructions](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html). I also highly recommend to read [JVM Manual](https://github.com/ethaanol/jvm-manual/wiki), which explains most JVM concepts in simple and easy-to-understand terms.

In this section, we will cover some basics about java bytecode.

In bytecode, there is a concept called "the stack". You might remember it from an exception called `StackOverflowError` or from the website `stackoverflow.com`. We will dig into what is exactly stack, and how bytecode uses it.

Consider this java code example:
```java
public static void main(String[] args) {
    System.out.println("Hello World!");
}
```
This is its bytecode:
```shell
getstatic java/lang/System.out Ljava/io/PrintStream;
ldc "Hello World!"
invokevirtual java/io/PrintStream.println (Ljava/lang/String;)V
```
Let's break down these instructions.
```shell
getstatic java/lang/System.out Ljava/io/PrintStream; # Stack: (System.out)
ldc "Hello World!" # Stack: (System.out, "Hello World!")
# Stack operations:
# 1. Pop the top value - The argument for "println" method 
# Stack before: (System.out, "Hello World!")
# Stack after: (System.out)
# 2. Pop the top value - The object the method is invoked from
# Stack before: (System.out)
# Stack after: ()
invokevirtual java/io/PrintStream.println (Ljava/lang/String;)V
```
The name of the instruction is called an `opcode`. Here are the opcodes used in the example:
- `getstatic` - Gets the value of a static field.
- `ldc` - Loads a constant value onto the stack.
- `invokevirtual` - Invokes a method on an object.

Here you can see that the stack is used to pass arguments to methods and to store the object the method is invoked from. The stack is also used to store the return value of the method.

Let's now break down the syntax of these instructions:
```shell
getstatic (class name).(field name) (field descriptor)
ldc (any constant value)
invokevirtual (class name).(method name) (method descriptor)
```
The class name, field name and method name are self-explanatory. But what are these `field descriptor` and `method descriptor`?
- Field descriptor - Describes the type of the field. For example, `Ljava/lang/String;` is the descriptor for the `String` class. Equivalent to `public String someName;`
- Method descriptor - Describes the method signature (argument types and return type). For example, `(ILjava/lang/String;)Z` means that method takes `int` as a first argument, `String` as a second argument and it returns `boolean`. Equivalent to `public boolean someName(int arg1, String arg2)`.

Here you can find the list of all descriptors: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3. You need to scroll down a bit to find the table with descriptors. If you can't find it then hit <kbd>CTRL</kbd>+<kbd>F</kbd> and search for `Table 4.3-A. Interpretation of field descriptors`.

## ðŸª„ Transformers
### What are transformers?
The whole deobfuscation process is based on transformers.
Transformers are smaller pieces that are responsible for deobfuscating specific obfuscation techniques.
In simple words - transformers are transforming obfuscated code into a more readable form.

### How to create your own transformer?
Create a new class in [`deobfuscator-transformers`](./deobfuscator-transformers) module. The most basic transformer can look like this:
```java
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class SomeTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      // Code here
    }));
  }
}
```
For example, this transformer replaces every "Hello, World!" string with "Bye, World!":
```java
import org.objectweb.asm.tree.LdcInsnNode;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;

public class SomeTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      
      // Iterate over all LDC instructions in the method
      Arrays.stream(methodNode.instructions.toArray())
          .filter(insn -> insn.getOpcode() == LDC) // Check if opcode is LDC
          .map(LdcInsnNode.class::cast) // Cast to LdcInsnNode so we can access the constant value (ldcInsn.cst)
          .forEach(ldcInsn -> {
            // Replace all "Hello, World!" strings with "Bye, World!"
            if (ldcInsn.cst.equals("Hello, World!")) {
              ldcInsn.cst = "Bye, World!";
            }
          });
    }));
  }
}
```
You can also get stack values that are pushed before the instruction. For example, if you want to replace all strings with "Bye, World!" only in `System.out.println` calls:
```java
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.asm.InstructionContext;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;

public class SomeTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      MethodContext methodContext = MethodContext.framed(classWrapper, methodNode);

      // Find all System.out.println calls and replace the string with "Bye, World!"
      Arrays.stream(methodNode.instructions.toArray())
          .filter(insn -> insn.getOpcode() == INVOKEVIRTUAL) // Match only INVOKEVIRTUAL instructions
          .forEach(insn -> {
            MethodInsnNode methodInsn = (MethodInsnNode) insn;

            // Find System.out.println call
            if (methodInsn.owner.equals("java/io/PrintStream") && methodInsn.name.equals("println") && methodInsn.desc.equals("(Ljava/lang/String;)V")) {
              // Create instruction context. Required for getting stack values.
              InstructionContext insnContext = methodContext.newInsnContext(methodInsn);
              Frame<OriginalSourceValue> frame = insnContext.frame();

              // Get top value from the stack
              OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);

              // Remove all instructions that produced the top stack value. We will replace them with our own instruction.
              for (AbstractInsnNode producer : sourceValue.insns) {
                methodNode.instructions.remove(producer);
              }

              // Replace the top stack value with the string "Bye, World!"
              methodNode.instructions.insertBefore(methodInsn, new LdcInsnNode("Bye, World!"));
            }
          });
    }));
  }
}
```
The same effect you can achieve by using a utility class called `FramedInstructionsStream`. In this way, we are minimizing the boilerplate code: 
```java
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class SomeTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this)
        .editInstructionsStream(stream -> stream.filter(insn -> insn.getOpcode() == INVOKEVIRTUAL)) // Match only INVOKEVIRTUAL instructions
        .forEach(insnContext -> {
          MethodInsnNode methodInsn = (MethodInsnNode) insnContext.insn();

          // Find System.out.println call
          if (methodInsn.owner.equals("java/io/PrintStream") && methodInsn.name.equals("println") && methodInsn.desc.equals("(Ljava/lang/String;)V")) {
            Frame<OriginalSourceValue> frame = insnContext.frame();

            // Get top value from the stack
            OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);

            // Remove all instructions that produced the top stack value. We will replace them with our own instruction.
            for (AbstractInsnNode producer : sourceValue.insns) {
              insnContext.methodNode().instructions.remove(producer);
            }

            // Replace the top stack value with the string "Bye, World!"
            insnContext.methodNode().instructions.insertBefore(methodInsn, new LdcInsnNode("Bye, World!"));
          }
        });
  }
}
```
But why do we need to get a stack value from frame? Can't we just move one instruction up and replace it? The answer is: not always. Sometimes the value is produced somewhere else, so the stack value may be much further produced. To see this issue in action, consider this example:
```shell
ldc "Hello World!"  # Stack: ("Hello World!")
dup # Stack: ("Hello World!", "Hello World!")
dup # Stack: ("Hello World!", "Hello World!", "Hello World!")
getstatic java/lang/System.out Ljava/io/PrintStream;  # Stack: ("Hello World!", "Hello World!", "Hello World!", System.out)
swap # Stack: ("Hello World!", "Hello World!", System.out, "Hello World!")
invokevirtual java/io/PrintStream.println (Ljava/lang/String;)V # Stack: ("Hello World!", "Hello World!")
pop # Stack: ("Hello World!")
pop # Stack: ()
```
The above example shows that the value is produced by `ldc` instruction, but it is used much later. So this is still valid JVM bytecode AND `ldc "Hello World!"` is not straight before `invokevirtual java/io/PrintStream.println (Ljava/lang/String;)V`. This is one of a very common obfuscation techniques. Fortunately, there already exists a universal transformer that removes these useless DUP and POP pairs ([UselessPopCleanTransformer](./deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/UselessPopCleanTransformer.java)) but only simple forms of them.

The project is also greatly documented, so you can find more information about any class or transformer in their javadocs and comments inside the code. You can also view other transformers' code - see how they work and how they are implemented. There are also tests, so you can, for example, see how the transformer behaves when you modify some line of code.

## ðŸ§ª Testing
### How do these tests work?
The deobfuscator has a clever testing system. It works as follows:
1. The [registered samples](./deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/TestDeobfuscation.java) are transformed using corresponding transformers.
2. The output gets decompiled using Vineflower.
3. The decompiled code is compared against the [expected output](./testData/results).

### How to run tests?
Run command `mvn test` in the root directory of the project.

### How to create your own tests?
You can create your own tests for transformers. There are a few ways to do it:
- If the obfuscation is simple enough, you can write your own sample in [`testData/src/java`](./testData/src/java)
- If the obfuscation is more complex, you can throw your raw obfuscated classes (`.class` files) into [`testData/compiled/custom-classes`](./testData/compiled/custom-classes) and test transformers on them.
- You can also throw your obfuscated jars into [`testData/compiled/custom-jars`](./testData/compiled/custom-jars) and test transformers on them.

You also need to register each sample in class [TestDeobfuscation.java](./deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/TestDeobfuscation.java)


```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Diobfuscator
A deobfuscator for java

> [!IMPORTANT]
> **This is dev(v2) version of diobfuscator version and it's not completed yet, if you are willing to help there is a list of things that needs to be completed. The old diobfuscator was moved to [v1 branch](https://github.com/narumii/Deobfuscator/tree/v1).**<br>
> 
> - Porting old transformers to new code base
> - Testing `Match` API
> - Implementing/Improving transformers
> - Writing tests
> - Feedback on how the new api presents itself (mainly `Match` API)
>   <br>
> 
> 1. *You can also provide samples of obfuscation to help with development of the transformers.*
> 2. **No... there is no gui planned**
> 3. _Also from now on Diobfuscator uses [Java Google Codestyle](https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml)_
>    - `mvn fmt:format`
>    - `mvn fmt:check`

> Built on: [Java 17 (Temurin)](https://adoptium.net/temurin/releases/?version=17)

## âœ… How to run deobfuscator
If you want to use this deobfuscator, you need to start it from your IDE manually.

1. Place your obfuscated jar inside the root project directory. For example in `work/obf-test.jar`
2. Navigate to class [`Bootstrap.java`](./deobfuscator-impl/src/test/java/Bootstrap.java)
3. In this class edit the deobfuscator configuration
    - `inputJar` - Your obfuscated jar file that you placed in step 1
    - `transformers` - Pick transformers that you want to run. You can find them in [`deobfuscator-transformers`](./deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other) module.
4. Run this class manually from your IDE. You can use our pre-configured IntelliJ task named `Bootstrap`.

![tak](./assets/run-deobfuscator.gif)

## ðŸ”§ Contributing
Contributions are welcome! See [CONTRIBUTING.md](./CONTRIBUTING.md) for a project introduction and some basics about java bytecode.

---

<p align="center">
     <a href="https://discord.gg/tRU27KtPAZ"><img src="https://discordapp.com/api/guilds/900083350314811432/widget.png?style=banner2"/></a>
</p>

---


```

`deobfuscator-api/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>Diobfuscator</artifactId>
        <groupId>uwu.narumi</groupId>
        <version>2.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>deobfuscator-api</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <asm.version>9.7.1</asm.version>

        <log4j.version>2.23.1</log4j.version>
        <slf4j.version>2.0.13</slf4j.version>
        <cafedude.version>2.1.2</cafedude.version>
        <ssvm.version>ca3c3ab713</ssvm.version>
        <jlinker.version>205d8eaa1f</jlinker.version>
    </properties>

    <repositories>
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>com.github.xxDark</groupId>
            <artifactId>jlinker</artifactId>
            <version>${jlinker.version}</version>
        </dependency>

        <!-- Fork of SSVM -->
        <dependency>
            <groupId>com.github.EpicPlayerA10.SSVM</groupId>
            <artifactId>mirrors</artifactId>
            <version>${ssvm.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.EpicPlayerA10.SSVM</groupId>
            <artifactId>ssvm-core</artifactId>
            <version>${ssvm.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.EpicPlayerA10.SSVM</groupId>
            <artifactId>ssvm-invoke</artifactId>
            <version>${ssvm.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.EpicPlayerA10.SSVM</groupId>
            <artifactId>ssvm-io</artifactId>
            <version>${ssvm.version}</version>
        </dependency>

        <!-- ASM -->
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-commons</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-util</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-tree</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-analysis</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm</artifactId>
            <version>${asm.version}</version>
        </dependency>

        <!-- Logging -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <!-- SLF4J Bridge -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.16</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-slf4j2-impl</artifactId>
            <version>${log4j.version}</version>
        </dependency>

        <dependency>
            <groupId>com.github.Col-E</groupId>
            <artifactId>CAFED00D</artifactId>
            <version>${cafedude.version}</version>
        </dependency>
    </dependencies>

</project>
```

`deobfuscator-api/src/main/java/org/objectweb/asm/Symbol.java`:

```java
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.objectweb.asm;

/**
 * An entry of the constant pool, of the BootstrapMethods attribute, or of the (ASM specific) type
 * table of a class.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4">JVMS
 *     4.4</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
 *     4.7.23</a>
 * @author Eric Bruneton
 */

// I dont understand why this garbage lib must be so fucking closed?
public abstract class Symbol {

  // Tag values for the constant pool entries (using the same order as in the JVMS).

  /** The tag value of CONSTANT_Class_info JVMS structures. */
  public static final int CONSTANT_CLASS_TAG = 7;

  /** The tag value of CONSTANT_Fieldref_info JVMS structures. */
  public static final int CONSTANT_FIELDREF_TAG = 9;

  /** The tag value of CONSTANT_Methodref_info JVMS structures. */
  public static final int CONSTANT_METHODREF_TAG = 10;

  /** The tag value of CONSTANT_InterfaceMethodref_info JVMS structures. */
  public static final int CONSTANT_INTERFACE_METHODREF_TAG = 11;

  /** The tag value of CONSTANT_String_info JVMS structures. */
  public static final int CONSTANT_STRING_TAG = 8;

  /** The tag value of CONSTANT_Integer_info JVMS structures. */
  public static final int CONSTANT_INTEGER_TAG = 3;

  /** The tag value of CONSTANT_Float_info JVMS structures. */
  public static final int CONSTANT_FLOAT_TAG = 4;

  /** The tag value of CONSTANT_Long_info JVMS structures. */
  public static final int CONSTANT_LONG_TAG = 5;

  /** The tag value of CONSTANT_Double_info JVMS structures. */
  public static final int CONSTANT_DOUBLE_TAG = 6;

  /** The tag value of CONSTANT_NameAndType_info JVMS structures. */
  public static final int CONSTANT_NAME_AND_TYPE_TAG = 12;

  /** The tag value of CONSTANT_Utf8_info JVMS structures. */
  public static final int CONSTANT_UTF8_TAG = 1;

  /** The tag value of CONSTANT_MethodHandle_info JVMS structures. */
  public static final int CONSTANT_METHOD_HANDLE_TAG = 15;

  /** The tag value of CONSTANT_MethodType_info JVMS structures. */
  public static final int CONSTANT_METHOD_TYPE_TAG = 16;

  /** The tag value of CONSTANT_Dynamic_info JVMS structures. */
  public static final int CONSTANT_DYNAMIC_TAG = 17;

  /** The tag value of CONSTANT_InvokeDynamic_info JVMS structures. */
  public static final int CONSTANT_INVOKE_DYNAMIC_TAG = 18;

  /** The tag value of CONSTANT_Module_info JVMS structures. */
  public static final int CONSTANT_MODULE_TAG = 19;

  /** The tag value of CONSTANT_Package_info JVMS structures. */
  public static final int CONSTANT_PACKAGE_TAG = 20;

  // Tag values for the BootstrapMethods attribute entries (ASM specific tag).

  /** The tag value of the BootstrapMethods attribute entries. */
  public static final int BOOTSTRAP_METHOD_TAG = 64;

  // Tag values for the type table entries (ASM specific tags).

  /** The tag value of a normal type entry in the (ASM specific) type table of a class. */
  public static final int TYPE_TAG = 128;

  /**
   * The tag value of an uninitialized type entry in the type table of a class. This type is used
   * for the normal case where the NEW instruction is before the &lt;init&gt; constructor call (in
   * bytecode offset order), i.e. when the label of the NEW instruction is resolved when the
   * constructor call is visited. If the NEW instruction is after the constructor call, use the
   * {@link #FORWARD_UNINITIALIZED_TYPE_TAG} tag value instead.
   */
  public static final int UNINITIALIZED_TYPE_TAG = 129;

  /**
   * The tag value of an uninitialized type entry in the type table of a class. This type is used
   * for the unusual case where the NEW instruction is after the &lt;init&gt; constructor call (in
   * bytecode offset order), i.e. when the label of the NEW instruction is not resolved when the
   * constructor call is visited. If the NEW instruction is before the constructor call, use the
   * {@link #UNINITIALIZED_TYPE_TAG} tag value instead.
   */
  public static final int FORWARD_UNINITIALIZED_TYPE_TAG = 130;

  /** The tag value of a merged type entry in the (ASM specific) type table of a class. */
  public static final int MERGED_TYPE_TAG = 131;

  // Instance fields.

  /**
   * The index of this symbol in the constant pool, in the BootstrapMethods attribute, or in the
   * (ASM specific) type table of a class (depending on the {@link #tag} value).
   */
  final int index;

  /**
   * A tag indicating the type of this symbol. Must be one of the static tag values defined in this
   * class.
   */
  final int tag;

  /**
   * The internal name of the owner class of this symbol. Only used for {@link
   * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link
   * #CONSTANT_INTERFACE_METHODREF_TAG}, and {@link #CONSTANT_METHOD_HANDLE_TAG} symbols.
   */
  final String owner;

  /**
   * The name of the class field or method corresponding to this symbol. Only used for {@link
   * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link
   * #CONSTANT_INTERFACE_METHODREF_TAG}, {@link #CONSTANT_NAME_AND_TYPE_TAG}, {@link
   * #CONSTANT_METHOD_HANDLE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link
   * #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.
   */
  final String name;

  /**
   * The string value of this symbol. This is:
   *
   * <ul>
   *   <li>a field or method descriptor for {@link #CONSTANT_FIELDREF_TAG}, {@link
   *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG}, {@link
   *       #CONSTANT_NAME_AND_TYPE_TAG}, {@link #CONSTANT_METHOD_HANDLE_TAG}, {@link
   *       #CONSTANT_METHOD_TYPE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>an arbitrary string for {@link #CONSTANT_UTF8_TAG} and {@link #CONSTANT_STRING_TAG}
   *       symbols,
   *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG}, {@link
   *       #UNINITIALIZED_TYPE_TAG} and {@link #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>{@literal null} for the other types of symbol.
   * </ul>
   */
  final String value;

  /**
   * The numeric value of this symbol. This is:
   *
   * <ul>
   *   <li>the symbol's value for {@link #CONSTANT_INTEGER_TAG},{@link #CONSTANT_FLOAT_TAG}, {@link
   *       #CONSTANT_LONG_TAG}, {@link #CONSTANT_DOUBLE_TAG},
   *   <li>the CONSTANT_MethodHandle_info reference_kind field value for {@link
   *       #CONSTANT_METHOD_HANDLE_TAG} symbols,
   *   <li>the CONSTANT_InvokeDynamic_info bootstrap_method_attr_index field value for {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>the offset of a bootstrap method in the BootstrapMethods boostrap_methods array, for
   *       {@link #CONSTANT_DYNAMIC_TAG} or {@link #BOOTSTRAP_METHOD_TAG} symbols,
   *   <li>the bytecode offset of the NEW instruction that created an {@link
   *       Frame#ITEM_UNINITIALIZED} type for {@link #UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>the index of the {@link Label} (in the {@link SymbolTable#labelTable} table) of the NEW
   *       instruction that created an {@link Frame#ITEM_UNINITIALIZED} type for {@link
   *       #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>the indices (in the class' type table) of two {@link #TYPE_TAG} source types for {@link
   *       #MERGED_TYPE_TAG} symbols,
   *   <li>0 for the other types of symbol.
   * </ul>
   */
  final long data;

  /**
   * Additional information about this symbol, generally computed lazily. <i>Warning: the value of
   * this field is ignored when comparing Symbol instances</i> (to avoid duplicate entries in a
   * SymbolTable). Therefore, this field should only contain data that can be computed from the
   * other fields of this class. It contains:
   *
   * <ul>
   *   <li>the {@link Type#getArgumentsAndReturnSizes} of the symbol's method descriptor for {@link
   *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>the index in the InnerClasses_attribute 'classes' array (plus one) corresponding to this
   *       class, for {@link #CONSTANT_CLASS_TAG} symbols,
   *   <li>the index (in the class' type table) of the merged type of the two source types for
   *       {@link #MERGED_TYPE_TAG} symbols,
   *   <li>0 for the other types of symbol, or if this field has not been computed yet.
   * </ul>
   */
  int info;

  /**
   * Constructs a new Symbol. This constructor can't be used directly because the Symbol class is
   * abstract. Instead, use the factory methods of the {@link SymbolTable} class.
   *
   * @param index the symbol index in the constant pool, in the BootstrapMethods attribute, or in
   *     the (ASM specific) type table of a class (depending on 'tag').
   * @param tag the symbol type. Must be one of the static tag values defined in this class.
   * @param owner The internal name of the symbol's owner class. Maybe {@literal null}.
   * @param name The name of the symbol's corresponding class field or method. Maybe {@literal
   *     null}.
   * @param value The string value of this symbol. Maybe {@literal null}.
   * @param data The numeric value of this symbol.
   */
  Symbol(
      final int index,
      final int tag,
      final String owner,
      final String name,
      final String value,
      final long data) {
    this.index = index;
    this.tag = tag;
    this.owner = owner;
    this.name = name;
    this.value = value;
    this.data = data;
  }

  /**
   * Returns the result {@link Type#getArgumentsAndReturnSizes} on {@link #value}.
   *
   * @return the result {@link Type#getArgumentsAndReturnSizes} on {@link #value} (memoized in
   *     {@link #info} for efficiency). This should only be used for {@link
   *     #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link
   *     #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.
   */
  int getArgumentsAndReturnSizes() {
    if (info == 0) {
      info = Type.getArgumentsAndReturnSizes(value);
    }
    return info;
  }
}

```

`deobfuscator-api/src/main/java/org/objectweb/asm/tree/AbstractInsnNode.java`:

```java
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.objectweb.asm.tree;

import static org.objectweb.asm.Opcodes.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Predicate;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.MethodVisitor;
import uwu.narumi.deobfuscator.api.asm.NamedOpcodes;
import org.objectweb.asm.Type;

/**
 * A node that represents a bytecode instruction. <i>An instruction can appear at most once in at
 * most one {@link InsnList} at a time</i>.
 *
 * @author Eric Bruneton
 */
public abstract class AbstractInsnNode {

  /** The type of {@link InsnNode} instructions. */
  public static final int INSN = 0;

  /** The type of {@link IntInsnNode} instructions. */
  public static final int INT_INSN = 1;

  /** The type of {@link VarInsnNode} instructions. */
  public static final int VAR_INSN = 2;

  /** The type of {@link TypeInsnNode} instructions. */
  public static final int TYPE_INSN = 3;

  /** The type of {@link FieldInsnNode} instructions. */
  public static final int FIELD_INSN = 4;

  /** The type of {@link MethodInsnNode} instructions. */
  public static final int METHOD_INSN = 5;

  /** The type of {@link InvokeDynamicInsnNode} instructions. */
  public static final int INVOKE_DYNAMIC_INSN = 6;

  /** The type of {@link JumpInsnNode} instructions. */
  public static final int JUMP_INSN = 7;

  /** The type of {@link LabelNode} "instructions". */
  public static final int LABEL = 8;

  /** The type of {@link LdcInsnNode} instructions. */
  public static final int LDC_INSN = 9;

  /** The type of {@link IincInsnNode} instructions. */
  public static final int IINC_INSN = 10;

  /** The type of {@link TableSwitchInsnNode} instructions. */
  public static final int TABLESWITCH_INSN = 11;

  /** The type of {@link LookupSwitchInsnNode} instructions. */
  public static final int LOOKUPSWITCH_INSN = 12;

  /** The type of {@link MultiANewArrayInsnNode} instructions. */
  public static final int MULTIANEWARRAY_INSN = 13;

  /** The type of {@link FrameNode} "instructions". */
  public static final int FRAME = 14;

  /** The type of {@link LineNumberNode} "instructions". */
  public static final int LINE = 15;

  // Narumii start
  private static final AbstractInsnNode EMPTY =
      new AbstractInsnNode(-2) {
        @Override
        public int getType() {
          return 0;
        }

        @Override
        public void accept(MethodVisitor methodVisitor) {}

        @Override
        public AbstractInsnNode clone(Map<LabelNode, LabelNode> clonedLabels) {
          return this;
        }
      };
  // Narumii end

  /**
   * The opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or a line
   * number).
   */
  protected int opcode;

  /**
   * The runtime visible type annotations of this instruction. This field is only used for real
   * instructions (i.e. not for labels, frames, or line number nodes). This list is a list of {@link
   * TypeAnnotationNode} objects. May be {@literal null}.
   */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /**
   * The runtime invisible type annotations of this instruction. This field is only used for real
   * instructions (i.e. not for labels, frames, or line number nodes). This list is a list of {@link
   * TypeAnnotationNode} objects. May be {@literal null}.
   */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The previous instruction in the list to which this instruction belongs. */
  AbstractInsnNode previousInsn;

  /** The next instruction in the list to which this instruction belongs. */
  AbstractInsnNode nextInsn;

  /**
   * The index of this instruction in the list to which it belongs. The value of this field is
   * correct only when {@link InsnList#cache} is not null. A value of -1 indicates that this
   * instruction does not belong to any {@link InsnList}.
   */
  int index;

  /**
   * Constructs a new {@link AbstractInsnNode}.
   *
   * @param opcode the opcode of the instruction to be constructed.
   */
  protected AbstractInsnNode(final int opcode) {
    this.opcode = opcode;
    this.index = -1;
  }

  /**
   * Returns the opcode of this instruction.
   *
   * @return the opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or
   *     a line number).
   */
  public int getOpcode() {
    return opcode;
  }

  /**
   * Returns the type of this instruction.
   *
   * @return the type of this instruction, i.e. one the constants defined in this class.
   */
  public abstract int getType();

  /**
   * Returns the previous instruction in the list to which this instruction belongs, if any.
   *
   * @return the previous instruction in the list to which this instruction belongs, if any. May be
   *     {@literal null}.
   */
  public AbstractInsnNode getPrevious() {
    return previousInsn;
  }

  /**
   * Returns the next instruction in the list to which this instruction belongs, if any.
   *
   * @return the next instruction in the list to which this instruction belongs, if any. May be
   *     {@literal null}.
   */
  public AbstractInsnNode getNext() {
    return nextInsn;
  }

  /**
   * Makes the given method visitor visit this instruction.
   *
   * @param methodVisitor a method visitor.
   */
  public abstract void accept(MethodVisitor methodVisitor);

  /**
   * Makes the given visitor visit the annotations of this instruction.
   *
   * @param methodVisitor a method visitor.
   */
  protected final void acceptAnnotations(final MethodVisitor methodVisitor) {
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitInsnAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitInsnAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
  }

  /**
   * Returns a copy of this instruction.
   *
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return a copy of this instruction. The returned instruction does not belong to any {@link
   *     InsnList}.
   */
  public abstract AbstractInsnNode clone(Map<LabelNode, LabelNode> clonedLabels);

  /**
   * Returns the clone of the given label.
   *
   * @param label a label.
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return the clone of the given label.
   */
  static LabelNode clone(final LabelNode label, final Map<LabelNode, LabelNode> clonedLabels) {
    return clonedLabels.get(label);
  }

  /**
   * Returns the clones of the given labels.
   *
   * @param labels a list of labels.
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return the clones of the given labels.
   */
  static LabelNode[] clone(
      final List<LabelNode> labels, final Map<LabelNode, LabelNode> clonedLabels) {
    LabelNode[] clones = new LabelNode[labels.size()];
    for (int i = 0, n = clones.length; i < n; ++i) {
      clones[i] = clonedLabels.get(labels.get(i));
    }
    return clones;
  }

  /**
   * Clones the annotations of the given instruction into this instruction.
   *
   * @param insnNode the source instruction.
   * @return this instruction.
   */
  protected final AbstractInsnNode cloneAnnotations(final AbstractInsnNode insnNode) {
    if (insnNode.visibleTypeAnnotations != null) {
      this.visibleTypeAnnotations = new ArrayList<>();
      for (int i = 0, n = insnNode.visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode sourceAnnotation = insnNode.visibleTypeAnnotations.get(i);
        TypeAnnotationNode cloneAnnotation =
            new TypeAnnotationNode(
                sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
        sourceAnnotation.accept(cloneAnnotation);
        this.visibleTypeAnnotations.add(cloneAnnotation);
      }
    }
    if (insnNode.invisibleTypeAnnotations != null) {
      this.invisibleTypeAnnotations = new ArrayList<>();
      for (int i = 0, n = insnNode.invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode sourceAnnotation = insnNode.invisibleTypeAnnotations.get(i);
        TypeAnnotationNode cloneAnnotation =
            new TypeAnnotationNode(
                sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
        sourceAnnotation.accept(cloneAnnotation);
        this.invisibleTypeAnnotations.add(cloneAnnotation);
      }
    }
    return this;
  }

  // Narumii start - shorthand methods
  public boolean isString() {
    return this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof String;
  }

  public boolean isType() {
    return this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Type;
  }

  public boolean isInteger() {
    int opcode = this.getOpcode();
    return ((opcode >= ICONST_M1 && opcode <= ICONST_5)
        || opcode == BIPUSH
        || opcode == SIPUSH
        || (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Integer));
  }

  public boolean isLong() {
    int opcode = this.getOpcode();
    return (opcode == LCONST_0
        || opcode == LCONST_1
        || (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Long));
  }

  public boolean isFloat() {
    int opcode = this.getOpcode();
    return (opcode >= FCONST_0 && opcode <= FCONST_2)
        || (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Float);
  }

  public boolean isDouble() {
    int opcode = this.getOpcode();
    return (opcode >= DCONST_0 && opcode <= DCONST_1)
        || (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Double);
  }

  public boolean isNumber() {
    return (isInteger() || isLong() || isFloat() || isDouble());
  }

  public boolean isConstant() {
    return isNumber() || isType() || isString() || isNull();
  }

  public boolean isNull() {
    return this.getOpcode() == ACONST_NULL;
  }

  public String asString() {
    return (String) ((LdcInsnNode) this).cst;
  }

  public Type asType() {
    return (Type) ((LdcInsnNode) this).cst;
  }

  @Nullable
  public Object asConstant() {
    if (isNumber()) {
      return asNumber();
    } else if (isString()) {
      return asString();
    } else if (isType()) {
      return asType();
    } else if (isNull()) {
      return null;
    }

    throw new IllegalArgumentException("Not a constant");
  }

  public int asInteger() {
    int opcode = this.getOpcode();

    if (opcode >= ICONST_M1 && opcode <= ICONST_5) {
      return opcode - 3;
    } else if (this instanceof IntInsnNode && this.getOpcode() != NEWARRAY) {
      return ((IntInsnNode) this).operand;
    } else if (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Integer) {
      return (Integer) ((LdcInsnNode) this).cst;
    }

    throw new IllegalArgumentException("Not an integer");
  }

  public long asLong() {
    int opcode = this.getOpcode();

    if (opcode >= LCONST_0 && opcode <= LCONST_1) {
      return opcode - 9;
    } else if (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Long) {
      return (Long) ((LdcInsnNode) this).cst;
    }

    throw new IllegalArgumentException("Not a long");
  }

  public float asFloat() {
    int opcode = this.getOpcode();

    if (opcode >= FCONST_0 && opcode <= FCONST_2) {
      return opcode - 11;
    } else if (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Float) {
      return (Float) ((LdcInsnNode) this).cst;
    }

    throw new IllegalArgumentException("Not a float");
  }

  public double asDouble() {
    int opcode = this.getOpcode();

    if (opcode >= DCONST_0 && opcode <= DCONST_1) {
      return opcode - 14;
    } else if (this instanceof LdcInsnNode && ((LdcInsnNode) this).cst instanceof Double) {
      return (Double) ((LdcInsnNode) this).cst;
    }

    throw new IllegalArgumentException("Not a double");
  }

  public Number asNumber() {
    if (isInteger()) {
      return asInteger();
    } else if (isLong()) {
      return asLong();
    } else if (isDouble()) {
      return asDouble();
    } else if (isFloat()) {
      return asFloat();
    }

    throw new IllegalArgumentException("Not a number");
  }

  public boolean isMathOperator() {
    return (this.getOpcode() >= IADD && this.getOpcode() < INEG)
        || (this.getOpcode() > DNEG && this.getOpcode() <= LXOR);
  }

  public boolean isNumberOperator() {
    return (this.getOpcode() >= INEG && this.getOpcode() <= DNEG)
        || (this.getOpcode() >= I2L && this.getOpcode() <= I2S);
  }

  public boolean isVarLoad() {
    return this.getOpcode() >= ILOAD && this.getOpcode() <= ALOAD;
  }

  public boolean isVarStore() {
    return this.getOpcode() >= ISTORE && this.getOpcode() <= ASTORE;
  }

  public int sizeOnStack() {
    if (this.isLong() || this.isDouble()) {
      // Only long and double values take up two stack values
      return 2;
    } else {
      return 1;
    }
  }

  public boolean isJump() {
    return this instanceof JumpInsnNode;
  }

  public JumpInsnNode asJump() {
    return (JumpInsnNode) this;
  }

  public int conditionStackSize() {
    if (this.getOpcode() >= IF_ICMPEQ && this.getOpcode() <= IF_ICMPLE) return 2;

    if ((this.getOpcode() >= IFEQ && this.getOpcode() <= IFLE)
        || (this.getOpcode() == IFNULL || this.getOpcode() == IFNONNULL)) return 1;

    return 0;
  }

  public MethodInsnNode asMethodInsn() {
    return (MethodInsnNode) this;
  }

  public JumpInsnNode asFieldInsn() {
    return (JumpInsnNode) this;
  }

  public InvokeDynamicInsnNode asInvokeDynamicInsn() {
    return (InvokeDynamicInsnNode) this;
  }

  public boolean isMethodInsn() {
    return this instanceof MethodInsnNode;
  }

  public boolean isFieldInsn() {
    return this instanceof FieldInsnNode;
  }

  public boolean isInvokeDynamicInsn() {
    return this instanceof InvokeDynamicInsnNode;
  }

  public AbstractInsnNode getPrevious(int offset) {
    AbstractInsnNode current = this;
    for (int i = 0; i < offset; i++) {
      if (current == null) break;

      current = current.previousInsn;
    }

    return current;
  }

  public <T extends AbstractInsnNode> T getPreviousAs() {
    return (T) getPrevious();
  }

  public <T extends AbstractInsnNode> T getPreviousAs(int offset) {
    return (T) getPrevious(offset);
  }

  public AbstractInsnNode getNext(int offset) {
    AbstractInsnNode current = this;
    for (int i = 0; i < offset; i++) {
      if (current == null) break;

      current = current.nextInsn;
    }

    return current;
  }

  public <T extends AbstractInsnNode> T getNextAs() {
    return (T) getNext();
  }

  public <T extends AbstractInsnNode> T getNextAs(int offset) {
    return (T) getNext(offset);
  }

  public AbstractInsnNode previous() {
    AbstractInsnNode current = this;
    do {
      current = current.previousInsn;
      if (current == null) break;
    } while (current instanceof LabelNode
        || current instanceof FrameNode
        || current instanceof LineNumberNode);

    return current == null ? EMPTY : current;
  }

  public AbstractInsnNode previous(int offset) {
    AbstractInsnNode current = this;
    for (int i = 0; i < offset; i++) {
      if (current == null) break;

      current = current.previous();
    }

    return current;
  }

  public <T extends AbstractInsnNode> T previousAs() {
    return (T) previous();
  }

  public <T extends AbstractInsnNode> T previousAs(int offset) {
    return (T) previous(offset);
  }

  public AbstractInsnNode next() {
    AbstractInsnNode current = this;
    do {
      current = current.nextInsn;
      if (current == null) break;
    } while (current instanceof LabelNode
        || current instanceof FrameNode
        || current instanceof LineNumberNode);

    return current == null ? EMPTY : current;
  }

  public AbstractInsnNode next(int offset) {
    AbstractInsnNode current = this;
    for (int i = 0; i < offset; i++) {
      if (current == null) break;

      current = current.next();
    }

    return current;
  }

  public <T extends AbstractInsnNode> T nextAs() {
    return (T) next();
  }

  public <T extends AbstractInsnNode> T nextAs(int offset) {
    return (T) next(offset);
  }

  public AbstractInsnNode walkPreviousUntil(
      Predicate<AbstractInsnNode> until, Consumer<AbstractInsnNode> consumer) {
    AbstractInsnNode current = this;
    while (current != null && !until.test(current)) {
      consumer.accept(current);
      current = current.previousInsn;
    }

    return current;
  }

  public AbstractInsnNode walkNextUntil(
      Predicate<AbstractInsnNode> until, Consumer<AbstractInsnNode> consumer) {
    AbstractInsnNode current = this;
    while (current != null && !until.test(current)) {
      consumer.accept(current);
      current = current.nextInsn;
    }

    return current;
  }

  public AbstractInsnNode walkPreviousUntil(
      Predicate<AbstractInsnNode> until,
      Predicate<AbstractInsnNode> filter,
      Consumer<AbstractInsnNode> consumer) {
    AbstractInsnNode current = this;
    while (current != null && !until.test(current)) {
      if (filter.test(current)) consumer.accept(current);
      current = current.previousInsn;
    }

    return current;
  }

  public AbstractInsnNode walkNextUntil(
      Predicate<AbstractInsnNode> until,
      Predicate<AbstractInsnNode> filter,
      Consumer<AbstractInsnNode> consumer) {
    AbstractInsnNode current = this;
    while (current != null && !until.test(current)) {
      if (filter.test(current)) consumer.accept(current);
      current = current.nextInsn;
    }

    return current;
  }

  public String namedOpcode() {
    return NamedOpcodes.map(this.getOpcode());
  }

  @Override
  public String toString() {
    return "(" + namedOpcode() + ") " + super.toString();
  }
  // Narumii end
}

```

`deobfuscator-api/src/main/java/org/objectweb/asm/tree/InsnList.java`:

```java
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.objectweb.asm.tree;

import java.util.ListIterator;
import java.util.NoSuchElementException;
import org.objectweb.asm.MethodVisitor;

/**
 * A doubly linked list of {@link AbstractInsnNode} objects. <i>This implementation is not thread
 * safe</i>.
 * <p>
 * Needed to merge https://gitlab.ow2.org/asm/asm/-/merge_requests/413 into our deobfuscator
 */
public class InsnList implements Iterable<AbstractInsnNode> {

  /** The number of instructions in this list. */
  private int size;

  /** The first instruction in this list. May be {@literal null}. */
  private AbstractInsnNode firstInsn;

  /** The last instruction in this list. May be {@literal null}. */
  private AbstractInsnNode lastInsn;

  /**
   * A cache of the instructions of this list. This cache is used to improve the performance of the
   * {@link #get} method.
   */
  AbstractInsnNode[] cache;

  /**
   * Returns the number of instructions in this list.
   *
   * @return the number of instructions in this list.
   */
  public int size() {
    return size;
  }

  /**
   * Returns the first instruction in this list.
   *
   * @return the first instruction in this list, or {@literal null} if the list is empty.
   */
  public AbstractInsnNode getFirst() {
    return firstInsn;
  }

  /**
   * Returns the last instruction in this list.
   *
   * @return the last instruction in this list, or {@literal null} if the list is empty.
   */
  public AbstractInsnNode getLast() {
    return lastInsn;
  }

  /**
   * Returns the instruction whose index is given. This method builds a cache of the instructions in
   * this list to avoid scanning the whole list each time it is called. Once the cache is built,
   * this method runs in constant time. This cache is invalidated by all the methods that modify the
   * list.
   *
   * @param index the index of the instruction that must be returned.
   * @return the instruction whose index is given.
   * @throws IndexOutOfBoundsException if (index &lt; 0 || index &gt;= size()).
   */
  public AbstractInsnNode get(final int index) {
    if (index < 0 || index >= size) {
      throw new IndexOutOfBoundsException();
    }
    if (cache == null) {
      cache = toArray();
    }
    return cache[index];
  }

  /**
   * Returns {@literal true} if the given instruction belongs to this list. This method always scans
   * the instructions of this list until it finds the given instruction or reaches the end of the
   * list.
   *
   * @param insnNode an instruction.
   * @return {@literal true} if the given instruction belongs to this list.
   */
  public boolean contains(final AbstractInsnNode insnNode) {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null && currentInsn != insnNode) {
      currentInsn = currentInsn.nextInsn;
    }
    return currentInsn != null;
  }

  /**
   * Returns the index of the given instruction in this list. This method builds a cache of the
   * instruction indexes to avoid scanning the whole list each time it is called. Once the cache is
   * built, this method run in constant time. The cache is invalidated by all the methods that
   * modify the list.
   *
   * @param insnNode an instruction <i>of this list</i>.
   * @return the index of the given instruction in this list. <i>The result of this method is
   *     undefined if the given instruction does not belong to this list</i>. Use {@link #contains }
   *     to test if an instruction belongs to an instruction list or not.
   */
  public int indexOf(final AbstractInsnNode insnNode) {
    if (cache == null) {
      cache = toArray();
    }
    return insnNode.index;
  }

  /**
   * Makes the given visitor visit all the instructions in this list.
   *
   * @param methodVisitor the method visitor that must visit the instructions.
   */
  public void accept(final MethodVisitor methodVisitor) {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null) {
      currentInsn.accept(methodVisitor);
      currentInsn = currentInsn.nextInsn;
    }
  }

  /**
   * Returns an iterator over the instructions in this list.
   *
   * @return an iterator over the instructions in this list.
   */
  @Override
  public ListIterator<AbstractInsnNode> iterator() {
    return iterator(0);
  }

  /**
   * Returns an iterator over the instructions in this list.
   *
   * @param index index of instruction for the iterator to start at.
   * @return an iterator over the instructions in this list.
   */
  @SuppressWarnings("unchecked")
  public ListIterator<AbstractInsnNode> iterator(final int index) {
    return new InsnListIterator(index);
  }

  /**
   * Returns an array containing all the instructions in this list.
   *
   * @return an array containing all the instructions in this list.
   */
  public AbstractInsnNode[] toArray() {
    int currentInsnIndex = 0;
    AbstractInsnNode currentInsn = firstInsn;
    AbstractInsnNode[] insnNodeArray = new AbstractInsnNode[size];
    while (currentInsn != null) {
      insnNodeArray[currentInsnIndex] = currentInsn;
      currentInsn.index = currentInsnIndex++;
      currentInsn = currentInsn.nextInsn;
    }
    return insnNodeArray;
  }

  /**
   * Replaces an instruction of this list with another instruction.
   *
   * @param oldInsnNode an instruction <i>of this list</i>.
   * @param newInsnNode another instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void set(final AbstractInsnNode oldInsnNode, final AbstractInsnNode newInsnNode) {
    // Narumii start
    if (oldInsnNode.index == -1) {
      throw new IllegalArgumentException("oldInsnNode does not belong to InsnList");
    }
    if (newInsnNode.index != -1) {
      throw new IllegalArgumentException("newInsnNode already belongs to another InsnList");
    }
    // Narumii end
    AbstractInsnNode nextInsn = oldInsnNode.nextInsn;
    newInsnNode.nextInsn = nextInsn;
    if (nextInsn != null) {
      nextInsn.previousInsn = newInsnNode;
    } else {
      lastInsn = newInsnNode;
    }
    AbstractInsnNode previousInsn = oldInsnNode.previousInsn;
    newInsnNode.previousInsn = previousInsn;
    if (previousInsn != null) {
      previousInsn.nextInsn = newInsnNode;
    } else {
      firstInsn = newInsnNode;
    }
    if (cache != null) {
      int index = oldInsnNode.index;
      cache[index] = newInsnNode;
      newInsnNode.index = index;
    } else {
      newInsnNode.index = 0; // newInsnNode now belongs to an InsnList.
    }
    oldInsnNode.index = -1; // oldInsnNode no longer belongs to an InsnList.
    oldInsnNode.previousInsn = null;
    oldInsnNode.nextInsn = null;
  }

  /**
   * Adds the given instruction to the end of this list.
   *
   * @param insnNode an instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void add(final AbstractInsnNode insnNode) {
    // Narumii start
    if (insnNode.index != -1) {
      throw new IllegalArgumentException("insnNode already belongs to another InsnList");
    }
    // Narumii end
    ++size;
    if (lastInsn == null) {
      firstInsn = insnNode;
      lastInsn = insnNode;
    } else {
      lastInsn.nextInsn = insnNode;
      insnNode.previousInsn = lastInsn;
    }
    lastInsn = insnNode;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Adds the given instructions to the end of this list.
   *
   * @param insnList an instruction list, which is cleared during the process. This list must be
   *     different from 'this'.
   */
  public void add(final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    if (lastInsn == null) {
      firstInsn = insnList.firstInsn;
      lastInsn = insnList.lastInsn;
    } else {
      AbstractInsnNode firstInsnListElement = insnList.firstInsn;
      lastInsn.nextInsn = firstInsnListElement;
      firstInsnListElement.previousInsn = lastInsn;
      lastInsn = insnList.lastInsn;
    }
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction at the beginning of this list.
   *
   * @param insnNode an instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void insert(final AbstractInsnNode insnNode) {
    // Narumii start
    if (insnNode.index != -1) {
      throw new IllegalArgumentException("insnNode already belongs to another InsnList");
    }
    // Narumii end
    ++size;
    if (firstInsn == null) {
      firstInsn = insnNode;
      lastInsn = insnNode;
    } else {
      firstInsn.previousInsn = insnNode;
      insnNode.nextInsn = firstInsn;
    }
    firstInsn = insnNode;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions at the beginning of this list.
   *
   * @param insnList an instruction list, which is cleared during the process. This list must be
   *     different from 'this'.
   */
  public void insert(final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    if (firstInsn == null) {
      firstInsn = insnList.firstInsn;
      lastInsn = insnList.lastInsn;
    } else {
      AbstractInsnNode lastInsnListElement = insnList.lastInsn;
      firstInsn.previousInsn = lastInsnListElement;
      lastInsnListElement.nextInsn = firstInsn;
      firstInsn = insnList.firstInsn;
    }
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction after the specified instruction.
   *
   * @param previousInsn an instruction <i>of this list</i> after which insnNode must be inserted.
   * @param insnNode the instruction to be inserted, <i>which must not belong to any {@link
   *     InsnList}</i>.
   */
  public void insert(final AbstractInsnNode previousInsn, final AbstractInsnNode insnNode) {
    // Narumii start
    if (previousInsn.index == -1) {
      throw new IllegalArgumentException("previousInsn does not belong to InsnList");
    }
    if (insnNode.index != -1) {
      throw new IllegalArgumentException("insnNode already belongs to another InsnList");
    }
    // Narumii end
    ++size;
    AbstractInsnNode nextInsn = previousInsn.nextInsn;
    if (nextInsn == null) {
      lastInsn = insnNode;
    } else {
      nextInsn.previousInsn = insnNode;
    }
    previousInsn.nextInsn = insnNode;
    insnNode.nextInsn = nextInsn;
    insnNode.previousInsn = previousInsn;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions after the specified instruction.
   *
   * @param previousInsn an instruction <i>of this list</i> after which the instructions must be
   *     inserted.
   * @param insnList the instruction list to be inserted, which is cleared during the process. This
   *     list must be different from 'this'.
   */
  public void insert(final AbstractInsnNode previousInsn, final InsnList insnList) {
    // Narumii start
    if (previousInsn.index == -1) {
      throw new IllegalArgumentException("previousInsn does not belong to InsnList");
    }
    // Narumii end
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    AbstractInsnNode firstInsnListElement = insnList.firstInsn;
    AbstractInsnNode lastInsnListElement = insnList.lastInsn;
    AbstractInsnNode nextInsn = previousInsn.nextInsn;
    if (nextInsn == null) {
      lastInsn = lastInsnListElement;
    } else {
      nextInsn.previousInsn = lastInsnListElement;
    }
    previousInsn.nextInsn = firstInsnListElement;
    lastInsnListElement.nextInsn = nextInsn;
    firstInsnListElement.previousInsn = previousInsn;
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction before the specified instruction.
   *
   * @param nextInsn an instruction <i>of this list</i> before which insnNode must be inserted.
   * @param insnNode the instruction to be inserted, <i>which must not belong to any {@link
   *     InsnList}</i>.
   */
  public void insertBefore(final AbstractInsnNode nextInsn, final AbstractInsnNode insnNode) {
    // Narumii start
    if (nextInsn.index == -1) {
      throw new IllegalArgumentException("nextInsn does not belong to InsnList");
    }
    if (insnNode.index != -1) {
      throw new IllegalArgumentException("insnNode already belongs to another InsnList");
    }
    // Narumii end
    ++size;
    AbstractInsnNode previousInsn = nextInsn.previousInsn;
    if (previousInsn == null) {
      firstInsn = insnNode;
    } else {
      previousInsn.nextInsn = insnNode;
    }
    nextInsn.previousInsn = insnNode;
    insnNode.nextInsn = nextInsn;
    insnNode.previousInsn = previousInsn;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions before the specified instruction.
   *
   * @param nextInsn an instruction <i>of this list</i> before which the instructions must be
   *     inserted.
   * @param insnList the instruction list to be inserted, which is cleared during the process. This
   *     list must be different from 'this'.
   */
  public void insertBefore(final AbstractInsnNode nextInsn, final InsnList insnList) {
    // Narumii start
    if (nextInsn.index == -1) {
      throw new IllegalArgumentException("nextInsn does not belong to InsnList");
    }
    // Narumii end
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    AbstractInsnNode firstInsnListElement = insnList.firstInsn;
    AbstractInsnNode lastInsnListElement = insnList.lastInsn;
    AbstractInsnNode previousInsn = nextInsn.previousInsn;
    if (previousInsn == null) {
      firstInsn = firstInsnListElement;
    } else {
      previousInsn.nextInsn = firstInsnListElement;
    }
    nextInsn.previousInsn = lastInsnListElement;
    lastInsnListElement.nextInsn = nextInsn;
    firstInsnListElement.previousInsn = previousInsn;
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Removes the given instruction from this list.
   *
   * @param insnNode the instruction <i>of this list</i> that must be removed.
   */
  public void remove(final AbstractInsnNode insnNode) {
    // Narumii start
    if (insnNode.index == -1) {
      throw new IllegalArgumentException("insnNode does not belong to InsnList");
    }
    // Narumii end
    --size;
    AbstractInsnNode nextInsn = insnNode.nextInsn;
    AbstractInsnNode previousInsn = insnNode.previousInsn;
    if (nextInsn == null) {
      if (previousInsn == null) {
        firstInsn = null;
        lastInsn = null;
      } else {
        previousInsn.nextInsn = null;
        lastInsn = previousInsn;
      }
    } else {
      if (previousInsn == null) {
        firstInsn = nextInsn;
        nextInsn.previousInsn = null;
      } else {
        previousInsn.nextInsn = nextInsn;
        nextInsn.previousInsn = previousInsn;
      }
    }
    cache = null;
    insnNode.index = -1; // insnNode no longer belongs to an InsnList.
    insnNode.previousInsn = null;
    insnNode.nextInsn = null;
  }

  /**
   * Removes all the instructions of this list.
   *
   * @param mark if the instructions must be marked as no longer belonging to any {@link InsnList}.
   */
  void removeAll(final boolean mark) {
    if (mark) {
      AbstractInsnNode currentInsn = firstInsn;
      while (currentInsn != null) {
        AbstractInsnNode next = currentInsn.nextInsn;
        currentInsn.index = -1; // currentInsn no longer belongs to an InsnList.
        currentInsn.previousInsn = null;
        currentInsn.nextInsn = null;
        currentInsn = next;
      }
    }
    size = 0;
    firstInsn = null;
    lastInsn = null;
    cache = null;
  }

  /** Removes all the instructions of this list. */
  public void clear() {
    removeAll(false);
  }

  /**
   * Resets all the labels in the instruction list. This method should be called before reusing an
   * instruction list between several <code>ClassWriter</code>s.
   */
  public void resetLabels() {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null) {
      if (currentInsn instanceof LabelNode) {
        ((LabelNode) currentInsn).resetLabel();
      }
      currentInsn = currentInsn.nextInsn;
    }
  }

  // Note: this class is not generified because it would create bridges.
  @SuppressWarnings("rawtypes")
  private final class InsnListIterator implements ListIterator {

    AbstractInsnNode nextInsn;

    AbstractInsnNode previousInsn;

    AbstractInsnNode remove;

    InsnListIterator(final int index) {
      if (index < 0 || index > size()) {
        throw new IndexOutOfBoundsException();
      } else if (index == size()) {
        nextInsn = null;
        previousInsn = getLast();
      } else {
        AbstractInsnNode currentInsn = getFirst();
        for (int i = 0; i < index; i++) {
          currentInsn = currentInsn.nextInsn;
        }

        nextInsn = currentInsn;
        previousInsn = currentInsn.previousInsn;
      }
    }

    @Override
    public boolean hasNext() {
      return nextInsn != null;
    }

    @Override
    public Object next() {
      if (nextInsn == null) {
        throw new NoSuchElementException();
      }
      AbstractInsnNode result = nextInsn;
      previousInsn = result;
      nextInsn = result.nextInsn;
      remove = result;
      return result;
    }

    @Override
    public void remove() {
      if (remove != null) {
        if (remove == nextInsn) {
          nextInsn = nextInsn.nextInsn;
        } else {
          previousInsn = previousInsn.previousInsn;
        }
        InsnList.this.remove(remove);
        remove = null;
      } else {
        throw new IllegalStateException();
      }
    }

    @Override
    public boolean hasPrevious() {
      return previousInsn != null;
    }

    @Override
    public Object previous() {
      if (previousInsn == null) {
        throw new NoSuchElementException();
      }
      AbstractInsnNode result = previousInsn;
      nextInsn = result;
      previousInsn = result.previousInsn;
      remove = result;
      return result;
    }

    @Override
    public int nextIndex() {
      if (nextInsn == null) {
        return size();
      }
      if (cache == null) {
        cache = toArray();
      }
      return nextInsn.index;
    }

    @Override
    public int previousIndex() {
      if (previousInsn == null) {
        return -1;
      }
      if (cache == null) {
        cache = toArray();
      }
      return previousInsn.index;
    }

    @Override
    public void add(final Object o) {
      if (nextInsn != null) {
        InsnList.this.insertBefore(nextInsn, (AbstractInsnNode) o);
      } else if (previousInsn != null) {
        InsnList.this.insert(previousInsn, (AbstractInsnNode) o);
      } else {
        InsnList.this.add((AbstractInsnNode) o);
      }
      previousInsn = (AbstractInsnNode) o;
      remove = null;
    }

    @Override
    public void set(final Object o) {
      if (remove != null) {
        InsnList.this.set(remove, (AbstractInsnNode) o);
        if (remove == previousInsn) {
          previousInsn = (AbstractInsnNode) o;
        } else {
          nextInsn = (AbstractInsnNode) o;
        }
      } else {
        throw new IllegalStateException();
      }
    }
  }
}

```

`deobfuscator-api/src/main/java/org/objectweb/asm/tree/analysis/JumpPredictingAnalyzer.java`:

```java
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.objectweb.asm.tree.analysis;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.VarInsnNode;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;

/**
 * An extended {@link Analyzer} that can simulate the execution of jump instructions (if, switch)
 */
public class JumpPredictingAnalyzer implements Opcodes {

  /** The interpreter to use to symbolically interpret the bytecode instructions. */
  private final Interpreter<OriginalSourceValue> interpreter;

  /** The instructions of the currently analyzed method. */
  private InsnList insnList;

  /** The size of {@link #insnList}. */
  private int insnListSize;

  /** The exception handlers of the currently analyzed method (one list per instruction index). */
  private List<TryCatchBlockNode>[] handlers;

  /** The execution stack frames of the currently analyzed method (one per instruction index). */
  private Frame<OriginalSourceValue>[] frames;

  /** The subroutines of the currently analyzed method (one per instruction index). */
  private Subroutine[] subroutines;

  /** The instructions that remain to process (one boolean per instruction index). */
  private boolean[] inInstructionsToProcess;

  /** The indices of the instructions that remain to process in the currently analyzed method. */
  private ArrayDeque<Integer> instructionsToProcess; // Narumii - Process instructions in correct order

  /**
   * Constructs a new {@link Analyzer}.
   *
   * @param interpreter the interpreter to use to symbolically interpret the bytecode instructions.
   */
  public JumpPredictingAnalyzer(final Interpreter<OriginalSourceValue> interpreter) {
    this.interpreter = interpreter;
  }

  /**
   * Analyzes the given method.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed. The maxStack and maxLocals fields must have correct
   *     values.
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if and only if the corresponding
   *     instruction cannot be reached (dead code).
   * @throws AnalyzerException if a problem occurs during the analysis.
   */
  @SuppressWarnings("unchecked")
  public Frame<OriginalSourceValue>[] analyze(final String owner, final MethodNode method) throws AnalyzerException {
    if ((method.access & (ACC_ABSTRACT | ACC_NATIVE)) != 0) {
      frames = (Frame<OriginalSourceValue>[]) new Frame<?>[0];
      return frames;
    }
    insnList = method.instructions;
    insnListSize = insnList.size();
    handlers = (List<TryCatchBlockNode>[]) new List<?>[insnListSize];
    frames = (Frame<OriginalSourceValue>[]) new Frame<?>[insnListSize];
    subroutines = new Subroutine[insnListSize];
    inInstructionsToProcess = new boolean[insnListSize];
    instructionsToProcess = new ArrayDeque<>(); // Narumii - Process instructions in correct order

    // For each exception handler, and each instruction within its range, record in 'handlers' the
    // fact that execution can flow from this instruction to the exception handler.
    for (int i = 0; i < method.tryCatchBlocks.size(); ++i) {
      TryCatchBlockNode tryCatchBlock = method.tryCatchBlocks.get(i);
      int startIndex = insnList.indexOf(tryCatchBlock.start);
      int endIndex = insnList.indexOf(tryCatchBlock.end);
      for (int j = startIndex; j < endIndex; ++j) {
        List<TryCatchBlockNode> insnHandlers = handlers[j];
        if (insnHandlers == null) {
          insnHandlers = new ArrayList<>();
          handlers[j] = insnHandlers;
        }
        insnHandlers.add(tryCatchBlock);
      }
    }

    // Finds the method's subroutines.
    findSubroutines(method.maxLocals);

    // Initializes the data structures for the control flow analysis.
    Frame<OriginalSourceValue> currentFrame;
    try {
      currentFrame = computeInitialFrame(owner, method);
      merge(0, currentFrame, null);
      init(owner, method);
    } catch (RuntimeException e) {
      // DontCheck(IllegalCatch): can't be fixed, for backward compatibility.
      throw new AnalyzerException(insnList.get(0), "Error at instruction 0: " + e.getMessage(), e);
    }

    // Control flow analysis.
    while (!instructionsToProcess.isEmpty()) { // Narumii - Process instructions in correct order
      // Get and remove one instruction from the list of instructions to process.
      int insnIndex = instructionsToProcess.pop(); // Narumii - Process instructions in correct order
      Frame<OriginalSourceValue> oldFrame = frames[insnIndex];
      Subroutine subroutine = subroutines[insnIndex];
      inInstructionsToProcess[insnIndex] = false;

      // Simulate the execution of this instruction.
      AbstractInsnNode insnNode = null;
      try {
        insnNode = method.instructions.get(insnIndex);
        int insnOpcode = insnNode.getOpcode();
        int insnType = insnNode.getType();

        if (insnType == AbstractInsnNode.LABEL
            || insnType == AbstractInsnNode.LINE
            || insnType == AbstractInsnNode.FRAME) {
          merge(insnIndex + 1, oldFrame, subroutine);
          newControlFlowEdge(insnIndex, insnIndex + 1);
        } else {
          currentFrame.init(oldFrame).execute(insnNode, interpreter);
          subroutine = subroutine == null ? null : new Subroutine(subroutine);

          if (insnNode instanceof JumpInsnNode) {
            JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;

            // Narumii start - Predict jumps
            Optional<Boolean> predictedIfResult = AsmMathHelper.predictIf(jumpInsn, oldFrame);
            if (predictedIfResult.isPresent()) {
              // Can predict jump

              boolean ifResult = predictedIfResult.get();
              if (ifResult) {
                // Jump predicted
                int jumpInsnIndex = insnList.indexOf(jumpInsn.label);
                currentFrame.initJumpTarget(insnOpcode, jumpInsn.label);
                if (insnOpcode == JSR) {
                  merge(
                      jumpInsnIndex,
                      currentFrame,
                      new Subroutine(jumpInsn.label, method.maxLocals, jumpInsn));
                } else {
                  merge(jumpInsnIndex, currentFrame, subroutine);
                }
                newControlFlowEdge(insnIndex, jumpInsnIndex);
              } else {
                // No jump, walk to next instruction
                currentFrame.initJumpTarget(insnOpcode, /* target= */ null);
                merge(insnIndex + 1, currentFrame, subroutine);
                newControlFlowEdge(insnIndex, insnIndex + 1);
              }
            } else {
              // No known outcome of this jump. Process normally.
            // Narumii end
              if (insnOpcode != GOTO && insnOpcode != JSR) {
                currentFrame.initJumpTarget(insnOpcode, /* target= */ null);
                merge(insnIndex + 1, currentFrame, subroutine);
                newControlFlowEdge(insnIndex, insnIndex + 1);
              }
              int jumpInsnIndex = insnList.indexOf(jumpInsn.label);
              currentFrame.initJumpTarget(insnOpcode, jumpInsn.label);
              if (insnOpcode == JSR) {
                merge(
                    jumpInsnIndex,
                    currentFrame,
                    new Subroutine(jumpInsn.label, method.maxLocals, jumpInsn));
              } else {
                merge(jumpInsnIndex, currentFrame, subroutine);
              }
              newControlFlowEdge(insnIndex, jumpInsnIndex);
            }
          } else if (insnNode instanceof LookupSwitchInsnNode) {
            LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;
            // Narumii start - Predict jumps
            Optional<LabelNode> predictedJump = AsmMathHelper.predictLookupSwitch(lookupSwitchInsn, oldFrame);
            if (predictedJump.isPresent()) {
              LabelNode labelNode = predictedJump.get();
              // Predicted label. Jump to that label immediately
              int targetInsnIndex = insnList.indexOf(labelNode);
              currentFrame.initJumpTarget(insnOpcode, labelNode);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
            } else {
              // No prediction. Process normally.
            // Narumii end
              int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);
              currentFrame.initJumpTarget(insnOpcode, lookupSwitchInsn.dflt);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
              for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {
                LabelNode label = lookupSwitchInsn.labels.get(i);
                targetInsnIndex = insnList.indexOf(label);
                currentFrame.initJumpTarget(insnOpcode, label);
                merge(targetInsnIndex, currentFrame, subroutine);
                newControlFlowEdge(insnIndex, targetInsnIndex);
              }
            }
          } else if (insnNode instanceof TableSwitchInsnNode) {
            TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;
            // Narumii start - Predict jumps
            Optional<LabelNode> predictedJump = AsmMathHelper.predictTableSwitch(tableSwitchInsn, oldFrame);
            if (predictedJump.isPresent()) {
              LabelNode labelNode = predictedJump.get();
              // Predicted label. Jump to that label immediately
              int targetInsnIndex = insnList.indexOf(labelNode);
              currentFrame.initJumpTarget(insnOpcode, labelNode);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
            } else {
              // No prediction. Process normally.
            // Narumii end
              int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);
              currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
              for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {
                LabelNode label = tableSwitchInsn.labels.get(i);
                currentFrame.initJumpTarget(insnOpcode, label);
                targetInsnIndex = insnList.indexOf(label);
                merge(targetInsnIndex, currentFrame, subroutine);
                newControlFlowEdge(insnIndex, targetInsnIndex);
              }
            }
          } else if (insnOpcode == RET) {
            if (subroutine == null) {
              throw new AnalyzerException(insnNode, "RET instruction outside of a subroutine");
            }
            for (int i = 0; i < subroutine.callers.size(); ++i) {
              JumpInsnNode caller = subroutine.callers.get(i);
              int jsrInsnIndex = insnList.indexOf(caller);
              if (frames[jsrInsnIndex] != null) {
                merge(
                    jsrInsnIndex + 1,
                    frames[jsrInsnIndex],
                    currentFrame,
                    subroutines[jsrInsnIndex],
                    subroutine.localsUsed);
                newControlFlowEdge(insnIndex, jsrInsnIndex + 1);
              }
            }
          } else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {
            if (subroutine != null) {
              if (insnNode instanceof VarInsnNode) {
                int varIndex = ((VarInsnNode) insnNode).var;
                subroutine.localsUsed[varIndex] = true;
                if (insnOpcode == LLOAD
                    || insnOpcode == DLOAD
                    || insnOpcode == LSTORE
                    || insnOpcode == DSTORE) {
                  subroutine.localsUsed[varIndex + 1] = true;
                }
              } else if (insnNode instanceof IincInsnNode) {
                int varIndex = ((IincInsnNode) insnNode).var;
                subroutine.localsUsed[varIndex] = true;
              }
            }
            merge(insnIndex + 1, currentFrame, subroutine);
            newControlFlowEdge(insnIndex, insnIndex + 1);
          }
        }

        List<TryCatchBlockNode> insnHandlers = handlers[insnIndex];
        if (insnHandlers != null) {
          for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
            Type catchType;
            if (tryCatchBlock.type == null) {
              catchType = Type.getObjectType("java/lang/Throwable");
            } else {
              catchType = Type.getObjectType(tryCatchBlock.type);
            }
            if (newControlFlowExceptionEdge(insnIndex, tryCatchBlock)) {
              // Merge the frame *before* this instruction, with its stack cleared and an exception
              // pushed, with the handler's frame.
              Frame<OriginalSourceValue> handler = newFrame(oldFrame);
              OriginalSourceValue exceptionValue = interpreter.newExceptionValue(tryCatchBlock, handler, catchType);
              handler.clearStack();
              handler.push(exceptionValue);
              merge(insnList.indexOf(tryCatchBlock.handler), handler, subroutine);
              // Merge the frame *after* this instruction, with its stack cleared and an exception
              // pushed, with the handler's frame.
              handler = newFrame(currentFrame);
              handler.clearStack();
              handler.push(exceptionValue);
              merge(insnList.indexOf(tryCatchBlock.handler), handler, subroutine);
            }
          }
        }
      } catch (AnalyzerException e) {
        throw new AnalyzerException(
            e.node, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      } catch (RuntimeException e) {
        // DontCheck(IllegalCatch): can't be fixed, for backward compatibility.
        throw new AnalyzerException(
            insnNode, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      }
    }

    return frames;
  }

  /**
   * Analyzes the given method and computes and sets its maximum stack size and maximum number of
   * local variables.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if and only if the corresponding
   *     instruction cannot be reached (dead code).
   * @throws AnalyzerException if a problem occurs during the analysis.
   */
  public Frame<OriginalSourceValue>[] analyzeAndComputeMaxs(final String owner, final MethodNode method)
      throws AnalyzerException {
    method.maxLocals = computeMaxLocals(method);
    method.maxStack = -1;
    analyze(owner, method);
    method.maxStack = computeMaxStack(frames);
    return frames;
  }

  /**
   * Computes and returns the maximum number of local variables used in the given method.
   *
   * @param method a method.
   * @return the maximum number of local variables used in the given method.
   */
  private static int computeMaxLocals(final MethodNode method) {
    int maxLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;
    if ((method.access & Opcodes.ACC_STATIC) != 0) {
      maxLocals -= 1;
    }
    for (AbstractInsnNode insnNode : method.instructions) {
      if (insnNode instanceof VarInsnNode) {
        int local = ((VarInsnNode) insnNode).var;
        int size =
            (insnNode.getOpcode() == Opcodes.LLOAD
                || insnNode.getOpcode() == Opcodes.DLOAD
                || insnNode.getOpcode() == Opcodes.LSTORE
                || insnNode.getOpcode() == Opcodes.DSTORE)
                ? 2
                : 1;
        maxLocals = Math.max(maxLocals, local + size);
      } else if (insnNode instanceof IincInsnNode) {
        int local = ((IincInsnNode) insnNode).var;
        maxLocals = Math.max(maxLocals, local + 1);
      }
    }
    return maxLocals;
  }

  /**
   * Computes and returns the maximum stack size of a method, given its stack map frames.
   *
   * @param frames the stack map frames of a method.
   * @return the maximum stack size of the given method.
   */
  private static int computeMaxStack(final Frame<?>[] frames) {
    int maxStack = 0;
    for (Frame<?> frame : frames) {
      if (frame != null) {
        int stackSize = 0;
        for (int i = 0; i < frame.getStackSize(); ++i) {
          stackSize += frame.getStack(i).getSize();
        }
        maxStack = Math.max(maxStack, stackSize);
      }
    }
    return maxStack;
  }

  /**
   * Finds the subroutines of the currently analyzed method and stores them in {@link #subroutines}.
   *
   * @param maxLocals the maximum number of local variables of the currently analyzed method (long
   *     and double values count for two variables).
   * @throws AnalyzerException if the control flow graph can fall off the end of the code.
   */
  private void findSubroutines(final int maxLocals) throws AnalyzerException {
    // For each instruction, compute the subroutine to which it belongs.
    // Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.
    Subroutine main = new Subroutine(null, maxLocals, null);
    List<AbstractInsnNode> jsrInsns = new ArrayList<>();
    findSubroutine(0, main, jsrInsns);
    // Follow the nested subroutines, and collect their own nested subroutines, until all
    // subroutines are found.
    Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();
    while (!jsrInsns.isEmpty()) {
      JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);
      Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);
      if (subroutine == null) {
        subroutine = new Subroutine(jsrInsn.label, maxLocals, jsrInsn);
        jsrSubroutines.put(jsrInsn.label, subroutine);
        findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);
      } else {
        subroutine.callers.add(jsrInsn);
      }
    }
    // Clear the main 'subroutine', which is not a real subroutine (and was used only as an
    // intermediate step above to find the real ones).
    for (int i = 0; i < insnListSize; ++i) {
      if (subroutines[i] != null && subroutines[i].start == null) {
        subroutines[i] = null;
      }
    }
  }

  /**
   * Follows the control flow graph of the currently analyzed method, starting at the given
   * instruction index, and stores a copy of the given subroutine in {@link #subroutines} for each
   * encountered instruction. Jumps to nested subroutines are <i>not</i> followed: instead, the
   * corresponding instructions are put in the given list.
   *
   * @param insnIndex an instruction index.
   * @param subroutine a subroutine.
   * @param jsrInsns where the jsr instructions for nested subroutines must be put.
   * @throws AnalyzerException if the control flow graph can fall off the end of the code.
   */
  private void findSubroutine(
      final int insnIndex, final Subroutine subroutine, final List<AbstractInsnNode> jsrInsns)
      throws AnalyzerException {
    ArrayList<Integer> instructionIndicesToProcess = new ArrayList<>();
    instructionIndicesToProcess.add(insnIndex);
    while (!instructionIndicesToProcess.isEmpty()) {
      int currentInsnIndex =
          instructionIndicesToProcess.remove(instructionIndicesToProcess.size() - 1);
      if (currentInsnIndex < 0 || currentInsnIndex >= insnListSize) {
        throw new AnalyzerException(null, "Execution can fall off the end of the code");
      }
      if (subroutines[currentInsnIndex] != null) {
        continue;
      }
      subroutines[currentInsnIndex] = new Subroutine(subroutine);
      AbstractInsnNode currentInsn = insnList.get(currentInsnIndex);

      // Push the normal successors of currentInsn onto instructionIndicesToProcess.
      if (currentInsn instanceof JumpInsnNode) {
        if (currentInsn.getOpcode() == JSR) {
          // Do not follow a jsr, it leads to another subroutine!
          jsrInsns.add(currentInsn);
        } else {
          JumpInsnNode jumpInsn = (JumpInsnNode) currentInsn;
          instructionIndicesToProcess.add(insnList.indexOf(jumpInsn.label));
        }
      } else if (currentInsn instanceof TableSwitchInsnNode) {
        TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) currentInsn;
        findSubroutine(insnList.indexOf(tableSwitchInsn.dflt), subroutine, jsrInsns);
        for (int i = tableSwitchInsn.labels.size() - 1; i >= 0; --i) {
          LabelNode labelNode = tableSwitchInsn.labels.get(i);
          instructionIndicesToProcess.add(insnList.indexOf(labelNode));
        }
      } else if (currentInsn instanceof LookupSwitchInsnNode) {
        LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) currentInsn;
        findSubroutine(insnList.indexOf(lookupSwitchInsn.dflt), subroutine, jsrInsns);
        for (int i = lookupSwitchInsn.labels.size() - 1; i >= 0; --i) {
          LabelNode labelNode = lookupSwitchInsn.labels.get(i);
          instructionIndicesToProcess.add(insnList.indexOf(labelNode));
        }
      }

      // Push the exception handler successors of currentInsn onto instructionIndicesToProcess.
      List<TryCatchBlockNode> insnHandlers = handlers[currentInsnIndex];
      if (insnHandlers != null) {
        for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
          instructionIndicesToProcess.add(insnList.indexOf(tryCatchBlock.handler));
        }
      }

      // Push the next instruction, if the control flow can go from currentInsn to the next.
      switch (currentInsn.getOpcode()) {
        case GOTO:
        case RET:
        case TABLESWITCH:
        case LOOKUPSWITCH:
        case IRETURN:
        case LRETURN:
        case FRETURN:
        case DRETURN:
        case ARETURN:
        case RETURN:
        case ATHROW:
          break;
        default:
          instructionIndicesToProcess.add(currentInsnIndex + 1);
          break;
      }
    }
  }

  /**
   * Computes the initial execution stack frame of the given method.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @return the initial execution stack frame of the 'method'.
   */
  private Frame<OriginalSourceValue> computeInitialFrame(final String owner, final MethodNode method) {
    Frame<OriginalSourceValue> frame = newFrame(method.maxLocals, method.maxStack);
    int currentLocal = 0;
    boolean isInstanceMethod = (method.access & ACC_STATIC) == 0;
    if (isInstanceMethod) {
      Type ownerType = Type.getObjectType(owner);
      frame.setLocal(
          currentLocal, interpreter.newParameterValue(isInstanceMethod, currentLocal, ownerType));
      currentLocal++;
    }
    Type[] argumentTypes = Type.getArgumentTypes(method.desc);
    for (Type argumentType : argumentTypes) {
      frame.setLocal(
          currentLocal,
          interpreter.newParameterValue(isInstanceMethod, currentLocal, argumentType));
      currentLocal++;
      if (argumentType.getSize() == 2) {
        frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
        currentLocal++;
      }
    }
    while (currentLocal < method.maxLocals) {
      frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
      currentLocal++;
    }
    frame.setReturn(interpreter.newReturnTypeValue(Type.getReturnType(method.desc)));
    return frame;
  }

  /**
   * Returns the symbolic execution stack frame for each instruction of the last analyzed method.
   *
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if the corresponding instruction cannot be
   *     reached, or if an error occurred during the analysis of the method.
   */
  public Frame<OriginalSourceValue>[] getFrames() {
    return frames;
  }

  /**
   * Returns the exception handlers for the given instruction.
   *
   * @param insnIndex the index of an instruction of the last analyzed method.
   * @return a list of {@link TryCatchBlockNode} objects.
   */
  public List<TryCatchBlockNode> getHandlers(final int insnIndex) {
    return handlers[insnIndex];
  }

  /**
   * Initializes this analyzer. This method is called just before the execution of control flow
   * analysis loop in {@link #analyze}. The default implementation of this method does nothing.
   *
   * @param owner the internal name of the class to which the method belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @throws AnalyzerException if a problem occurs.
   */
  protected void init(final String owner, final MethodNode method) throws AnalyzerException {
    // Nothing to do.
  }

  /**
   * Constructs a new frame with the given size.
   *
   * @param numLocals the maximum number of local variables of the frame.
   * @param numStack the maximum stack size of the frame.
   * @return the created frame.
   */
  protected Frame<OriginalSourceValue> newFrame(final int numLocals, final int numStack) {
    return new Frame<>(numLocals, numStack);
  }

  /**
   * Constructs a copy of the given frame.
   *
   * @param frame a frame.
   * @return the created frame.
   */
  protected Frame<OriginalSourceValue> newFrame(final Frame<? extends OriginalSourceValue> frame) {
    return new Frame<>(frame);
  }

  /**
   * Creates a control flow graph edge. The default implementation of this method does nothing. It
   * can be overridden in order to construct the control flow graph of a method (this method is
   * called by the {@link #analyze} method during its visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param successorIndex index of a successor instruction.
   */
  protected void newControlFlowEdge(final int insnIndex, final int successorIndex) {
    // Nothing to do.
  }

  /**
   * Creates a control flow graph edge corresponding to an exception handler. The default
   * implementation of this method does nothing. It can be overridden in order to construct the
   * control flow graph of a method (this method is called by the {@link #analyze} method during its
   * visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param successorIndex index of a successor instruction.
   * @return true if this edge must be considered in the data flow analysis performed by this
   *     analyzer, or false otherwise. The default implementation of this method always returns
   *     true.
   */
  protected boolean newControlFlowExceptionEdge(final int insnIndex, final int successorIndex) {
    return true;
  }

  /**
   * Creates a control flow graph edge corresponding to an exception handler. The default
   * implementation of this method delegates to {@link #newControlFlowExceptionEdge(int, int)}. It
   * can be overridden in order to construct the control flow graph of a method (this method is
   * called by the {@link #analyze} method during its visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param tryCatchBlock TryCatchBlockNode corresponding to this edge.
   * @return true if this edge must be considered in the data flow analysis performed by this
   *     analyzer, or false otherwise. The default implementation of this method delegates to {@link
   *     #newControlFlowExceptionEdge(int, int)}.
   */
  protected boolean newControlFlowExceptionEdge(
      final int insnIndex, final TryCatchBlockNode tryCatchBlock) {
    return newControlFlowExceptionEdge(insnIndex, insnList.indexOf(tryCatchBlock.handler));
  }

  // -----------------------------------------------------------------------------------------------

  /**
   * Merges the given frame and subroutine into the frame and subroutines at the given instruction
   * index. If the frame or the subroutine at the given instruction index changes as a result of
   * this merge, the instruction index is added to the list of instructions to process (if it is not
   * already the case).
   *
   * @param insnIndex an instruction index.
   * @param frame a frame. This frame is left unchanged by this method.
   * @param subroutine a subroutine. This subroutine is left unchanged by this method.
   * @throws AnalyzerException if the frames have incompatible sizes.
   */
  private void merge(final int insnIndex, final Frame<OriginalSourceValue> frame, final Subroutine subroutine)
      throws AnalyzerException {
    boolean changed;
    Frame<OriginalSourceValue> oldFrame = frames[insnIndex];
    if (oldFrame == null) {
      frames[insnIndex] = newFrame(frame);
      changed = true;
    } else {
      changed = oldFrame.merge(frame, interpreter);
    }
    Subroutine oldSubroutine = subroutines[insnIndex];
    if (oldSubroutine == null) {
      if (subroutine != null) {
        subroutines[insnIndex] = new Subroutine(subroutine);
        changed = true;
      }
    } else {
      if (subroutine != null) {
        changed |= oldSubroutine.merge(subroutine);
      }
    }
    if (changed && !inInstructionsToProcess[insnIndex]) {
      inInstructionsToProcess[insnIndex] = true;
      instructionsToProcess.push(insnIndex); // Narumii - Process instructions in correct order
    }
  }

  /**
   * Merges the given frame and subroutine into the frame and subroutines at the given instruction
   * index (case of a RET instruction). If the frame or the subroutine at the given instruction
   * index changes as a result of this merge, the instruction index is added to the list of
   * instructions to process (if it is not already the case).
   *
   * @param insnIndex the index of an instruction immediately following a jsr instruction.
   * @param frameBeforeJsr the execution stack frame before the jsr instruction. This frame is
   *     merged into 'frameAfterRet'.
   * @param frameAfterRet the execution stack frame after a ret instruction of the subroutine. This
   *     frame is merged into the frame at 'insnIndex' (after it has itself been merge with
   *     'frameBeforeJsr').
   * @param subroutineBeforeJsr if the jsr is itself part of a subroutine (case of nested
   *     subroutine), the subroutine it belongs to.
   * @param localsUsed the local variables read or written in the subroutine.
   * @throws AnalyzerException if the frames have incompatible sizes.
   */
  private void merge(
      final int insnIndex,
      final Frame<OriginalSourceValue> frameBeforeJsr,
      final Frame<OriginalSourceValue> frameAfterRet,
      final Subroutine subroutineBeforeJsr,
      final boolean[] localsUsed)
      throws AnalyzerException {
    frameAfterRet.merge(frameBeforeJsr, localsUsed);

    boolean changed;
    Frame<OriginalSourceValue> oldFrame = frames[insnIndex];
    if (oldFrame == null) {
      frames[insnIndex] = newFrame(frameAfterRet);
      changed = true;
    } else {
      changed = oldFrame.merge(frameAfterRet, interpreter);
    }
    Subroutine oldSubroutine = subroutines[insnIndex];
    if (oldSubroutine != null && subroutineBeforeJsr != null) {
      changed |= oldSubroutine.merge(subroutineBeforeJsr);
    }
    if (changed && !inInstructionsToProcess[insnIndex]) {
      inInstructionsToProcess[insnIndex] = true;
      instructionsToProcess.push(insnIndex); // Narumii - Process instructions in correct order
    }
  }
}

```

`deobfuscator-api/src/main/java/org/objectweb/asm/tree/analysis/OriginalSourceInterpreter.java`:

```java
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.objectweb.asm.tree.analysis;

import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;

import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * An extended {@link SourceInterpreter} that keeps track of a
 * {@link SourceValue} that created another {@link SourceValue}.
 * <p>
 * The only modified method is {@link #copyOperation(AbstractInsnNode, OriginalSourceValue)}.
 */
public class OriginalSourceInterpreter extends Interpreter<OriginalSourceValue> implements Opcodes {

  /**
   * Constructs a new {@link SourceInterpreter} for the latest ASM API version. <i>Subclasses must
   * not use this constructor</i>. Instead, they must use the {@link #OriginalSourceInterpreter(int)}
   * version.
   */
  public OriginalSourceInterpreter() {
    super(/* latest api = */ ASM9);
    if (getClass() != OriginalSourceInterpreter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link SourceInterpreter}.
   *
   * @param api the ASM API version supported by this interpreter. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected OriginalSourceInterpreter(final int api) {
    super(api);
  }

  @Override
  public OriginalSourceValue newValue(final Type type) {
    if (type == Type.VOID_TYPE) {
      return null;
    }
    return new OriginalSourceValue(type == null ? 1 : type.getSize(), false);
  }

  @Override
  public OriginalSourceValue newParameterValue(boolean isInstanceMethod, int local, Type type) {
    if (type == Type.VOID_TYPE) {
      return null;
    }
    return new OriginalSourceValue(type == null ? 1 : type.getSize(), true);
  }

  @Override
  public OriginalSourceValue newOperation(final AbstractInsnNode insn) {
    int size;
    switch (insn.getOpcode()) {
      case LCONST_0:
      case LCONST_1:
      case DCONST_0:
      case DCONST_1:
        size = 2;
        break;
      case LDC:
        // Values able to be pushed by LDC:
        //   - int, float, string (object), type (Class, object), type (MethodType, object),
        //       handle (MethodHandle, object): one word
        //   - long, double, ConstantDynamic (can produce either single word values, or double word
        //       values): (up to) two words
        Object value = ((LdcInsnNode) insn).cst;
        if (value instanceof Long || value instanceof Double) {
          // two words guaranteed
          size = 2;
        } else if (value instanceof ConstantDynamic) {
          // might yield two words
          size = ((ConstantDynamic) value).getSize();
        } else {
          // one word guaranteed
          size = 1;
        }
        break;
      case GETSTATIC:
        size = Type.getType(((FieldInsnNode) insn).desc).getSize();
        break;
      default:
        size = 1;
        break;
    }
    return new OriginalSourceValue(size, insn);
  }

  @Override
  public OriginalSourceValue copyOperation(final AbstractInsnNode insn, final OriginalSourceValue value) {
    // Narumii start - Track the original value
    return new OriginalSourceValue(insn, value);
    // Narumii end
  }

  @Override
  public OriginalSourceValue unaryOperation(final AbstractInsnNode insn, final OriginalSourceValue value) {
    int size;
    switch (insn.getOpcode()) {
      case LNEG:
      case DNEG:
      case I2L:
      case I2D:
      case L2D:
      case F2L:
      case F2D:
      case D2L:
        size = 2;
        break;
      case GETFIELD:
        size = Type.getType(((FieldInsnNode) insn).desc).getSize();
        break;
      default:
        size = 1;
        break;
    }

    // Narumii start - Predict constant
    if (AsmMathHelper.isMathUnaryOperation(insn.getOpcode())) {
      OriginalSourceValue.ConstantValue constant = value.getConstantValue();

      if (constant != null && constant.get() instanceof Number constNum) {
        Number result = AsmMathHelper.mathUnaryOperation(constNum, insn.getOpcode());
        return new OriginalSourceValue(size, insn, null, OriginalSourceValue.ConstantValue.of(result));
      }
    }
    // Narumii end

    return new OriginalSourceValue(size, insn);
  }

  @Override
  public OriginalSourceValue binaryOperation(
      final AbstractInsnNode insn, final OriginalSourceValue value1, final OriginalSourceValue value2) {
    int size;
    switch (insn.getOpcode()) {
      case LALOAD:
      case DALOAD:
      case LADD:
      case DADD:
      case LSUB:
      case DSUB:
      case LMUL:
      case DMUL:
      case LDIV:
      case DDIV:
      case LREM:
      case DREM:
      case LSHL:
      case LSHR:
      case LUSHR:
      case LAND:
      case LOR:
      case LXOR:
        size = 2;
        break;
      default:
        size = 1;
        break;
    }

    // Narumii start - Predict constant
    if (AsmMathHelper.isMathBinaryOperation(insn.getOpcode())) {
      OriginalSourceValue.ConstantValue constant1 = value1.getConstantValue();
      OriginalSourceValue.ConstantValue constant2 = value2.getConstantValue();

      if (constant1 != null && constant2 != null && constant1.get() instanceof Number constNum1 && constant2.get() instanceof Number constNum2) {
        try {
          Number result = AsmMathHelper.mathBinaryOperation(constNum1, constNum2, insn.getOpcode());
          return new OriginalSourceValue(size, insn, null, OriginalSourceValue.ConstantValue.of(result));
        } catch (ArithmeticException ignored) {
        }
      }
    }
    // Narumii end

    return new OriginalSourceValue(size, insn);
  }

  @Override
  public OriginalSourceValue ternaryOperation(
      final AbstractInsnNode insn,
      final OriginalSourceValue value1,
      final OriginalSourceValue value2,
      final OriginalSourceValue value3) {
    return new OriginalSourceValue(1, insn);
  }

  @Override
  public OriginalSourceValue naryOperation(
      final AbstractInsnNode insn, final List<? extends OriginalSourceValue> values) {
    int size;
    int opcode = insn.getOpcode();
    if (opcode == MULTIANEWARRAY) {
      size = 1;
    } else if (opcode == INVOKEDYNAMIC) {
      size = Type.getReturnType(((InvokeDynamicInsnNode) insn).desc).getSize();
    } else {
      size = Type.getReturnType(((MethodInsnNode) insn).desc).getSize();
    }
    return new OriginalSourceValue(size, insn);
  }

  @Override
  public void returnOperation(
      final AbstractInsnNode insn, final OriginalSourceValue value, final OriginalSourceValue expected) {
    // Nothing to do.
  }

  @Override
  public OriginalSourceValue merge(final OriginalSourceValue value1, final OriginalSourceValue value2) {
    if (value1.size != value2.size || !containsAll(value1.insns, value2.insns) || !Objects.equals(value1.copiedFrom, value2.copiedFrom)) {
      Set<AbstractInsnNode> setUnion;
      if (value1.insns instanceof SmallSet && value2.insns instanceof SmallSet) {
        // Use optimized merging method
        setUnion =
            ((SmallSet<AbstractInsnNode>) value1.insns)
                .union((SmallSet<AbstractInsnNode>) value2.insns);
      } else {
        setUnion = new HashSet<>();
        setUnion.addAll(value1.insns);
        setUnion.addAll(value2.insns);
      }

      // Single producer
      if (setUnion.size() == 1) {
        AbstractInsnNode producer = setUnion.iterator().next();

        OriginalSourceValue copiedFrom = null;
        if (value1.copiedFrom != null && value2.copiedFrom != null) {
          copiedFrom = this.merge(value1.copiedFrom, value2.copiedFrom);
        }

        return new OriginalSourceValue(Math.min(value1.size, value2.size), producer, copiedFrom, null);
      }
      // Multiple producers
      return new OriginalSourceValue(Math.min(value1.size, value2.size), setUnion);
    }
    return value1;
  }

  private static <E> boolean containsAll(final Set<E> self, final Set<E> other) {
    if (self.size() < other.size()) {
      return false;
    }
    return self.containsAll(other);
  }
}

```

`deobfuscator-api/src/main/java/org/objectweb/asm/tree/analysis/OriginalSourceValue.java`:

```java
package org.objectweb.asm.tree.analysis;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;

import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;

/**
 * A {@link SourceValue} that holds the original source value on which we can operate very easily.
 * See javadoc of {@link #originalSource} for more details.
 *
 * @author EpicPlayerA10
 */
public class OriginalSourceValue extends SourceValue {

  /**
   * If the value was copied from another value, then this field will contain the value from which it was copied.
   *
   * @apiNote If this field is not null then you are 100% sure that {@link #insns} field will contain only one instruction.
   * And therefore you can use {@link #getProducer()} method to get the producer of this value.
   */
  @Nullable
  public final OriginalSourceValue copiedFrom;

  /**
   * This field holds the original source value on which we can operate very easily. This means that
   * the original source value was obtained by following all copy-like instructions (DUP, ILOAD, etc.)
   * and all kind of jumps. Very useful!
   *
   * <p>
   * Consider this example set of instructions:
   * <pre>
   * 1: A:
   * 2:   ICONST_1
   * 3:   ISTORE exVar
   * 4: B:
   * 5:   ILOAD exVar
   * 6:   DUP
   * 7:   IFNE C
   * 8: C:
   * 9:   ...
   * </pre>
   *
   * When the current class is source value of instruction at line 6, then it will follow all
   * instructions (DUP, ILOAD) and jumps to get the original source value of this instruction at line 6.
   * In this example, it will return source value of instruction at line 2.
   */
  @NotNull
  public final OriginalSourceValue originalSource;

  /**
   * Predicted constant value that holds an object to constant value such as {@link Integer}, {@link Double},
   * {@link Float}, {@link String}, {@link Type} and {@code null}. Additionally, to {@link #originalSource} it is
   * also doing all math operations on math operation instructions.
   *
   * <p>
   * Consider this example:
   * <pre>
   * 1: A:
   * 2:   ldc 12L
   * 3:   ldc 2L
   * 4:   ldiv
   * 5:   l2i
   * 6:   lookupswitch {
   * 7:     ...
   * 8:   }
   * </pre>
   *
   * In line 2, the constant value is 12L.<br>
   * In line 3, the constant value is 2L.<br>
   * In line 4, the constant value is 12L / 2L = 6L.<br>
   * In line 5, the constant value is 6 (but cast to integer).
   *
   * <p>
   * It is so convenient because for example if you want to get value of a IMUL instruction,
   * then this field already contains the calculated value! No need to calculate it manually from stack values.
   */
  @Nullable
  private ConstantValue constantValue = null;

  /**
   * If a source value is a method parameter.
   */
  private final boolean isMethodParameter;

  public OriginalSourceValue(int size, boolean isMethodParameter) {
    super(size, new SmallSet<>());
    this.isMethodParameter = isMethodParameter;

    // Fill single-producer-only fields with empty
    this.copiedFrom = null;
    this.originalSource = this;
  }

  public OriginalSourceValue(int size, AbstractInsnNode insnNode) {
    this(size, insnNode, null, null);
  }

  /**
   * Create new {@link OriginalSourceValue} from multiple producers
   *
   * @param size Stack size of the value
   * @param insnSet Set of instructions that produce this value
   */
  public OriginalSourceValue(int size, Set<AbstractInsnNode> insnSet) {
    super(size, insnSet);
    this.isMethodParameter = false;

    // Fill single-producer-only fields with empty
    this.copiedFrom = null;
    this.originalSource = this;
  }

  public OriginalSourceValue(AbstractInsnNode insnNode, OriginalSourceValue copiedFrom) {
    this(copiedFrom.size, insnNode, copiedFrom, null);
  }

  /**
   * Create new {@link OriginalSourceValue} from a single producer
   *
   * @param size Stack size of the value
   * @param insn An instruction that produces this value
   * @param copiedFrom The value from which this value was copied or null if it was not copied
   * @param constantValue Predicted constant value if exists
   */
  public OriginalSourceValue(int size, AbstractInsnNode insn, @Nullable OriginalSourceValue copiedFrom, @Nullable ConstantValue constantValue) {
    super(size, new SmallSet<>(insn));
    this.isMethodParameter = false;
    this.copiedFrom = copiedFrom;
    this.originalSource = copiedFrom == null || copiedFrom.isMethodParameter ? this : copiedFrom.originalSource;

    if (constantValue != null) {
      // If the constant value is present, then use it
      this.constantValue = constantValue;
    } else if (copiedFrom != null) {
      // Copy constant value from copied value
      this.constantValue = copiedFrom.constantValue;
    } else {
      // Try to infer constant value from producer
      if (insn.isConstant()) {
        this.constantValue = ConstantValue.of(insn.asConstant());
      }
    }
  }

  /**
   * Check if the value was produced only by one instruction.
   *
   * @apiNote If this function returns {@code true}, then the {@link #insns} field will contain only one instruction.
   */
  public boolean isOneWayProduced() {
    return insns.size() == 1;
  }

  /**
   * Get the producer of this value.
   *
   * @throws IllegalStateException If there are multiple producers. Check {@link #isOneWayProduced()} before calling this method.
   */
  public AbstractInsnNode getProducer() {
    if (insns.size() != 1) {
      throw new IllegalStateException("Expected only one instruction, but got " + insns.size());
    }
    return insns.iterator().next();
  }

  /**
   * See {@link #constantValue}.
   */
  @Nullable
  public ConstantValue getConstantValue() {
    return constantValue;
  }

  public boolean isMethodParameter() {
    return isMethodParameter;
  }

  /**
   * Walk to the last parent value until the predicate returns true.
   *
   * @param until The predicate to stop walking. If the predicate returns true, the walking will stop.
   */
  public OriginalSourceValue walkToLastParentValue(Predicate<OriginalSourceValue> until) {
    OriginalSourceValue value = this;
    while (value.copiedFrom != null) {
      if (until.test(value)) {
        break;
      }
      value = value.copiedFrom;
    }
    return value;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    if (!super.equals(o)) return false;
    OriginalSourceValue that = (OriginalSourceValue) o;
    return Objects.equals(copiedFrom, that.copiedFrom);
  }

  @Override
  public int hashCode() {
    return Objects.hash(super.hashCode(), copiedFrom);
  }

  /**
   * We need to create our own {@link Optional}-like class because {@link Optional} can't
   * store nullable values which we need to store.
   *
   * @param value A constant value. It can be {@link Integer}, {@link Double},
   * {@link Float}, {@link String}, {@link Type} or {@code null}
   */
  public record ConstantValue(Object value) {
    public static ConstantValue of(Object value) {
      return new ConstantValue(value);
    }

    public Object get() {
      return value;
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/ClassWrapper.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import java.lang.invoke.MethodType;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import uwu.narumi.deobfuscator.api.classpath.InheritanceClassWriter;
import uwu.narumi.deobfuscator.api.inheritance.InheritanceGraph;

public class ClassWrapper {

  protected static final Logger LOGGER = LogManager.getLogger(ClassWrapper.class);

  /**
   * Relative path inside jar. Mainly for saving purposes.
   */
  private final String pathInJar;
  private final ClassNode classNode;
  private final ConstantPool constantPool;

  public ClassWrapper(String pathInJar, ClassReader classReader, int classReaderFlags) {
    this.pathInJar = pathInJar;
    this.classNode = new ClassNode();
    this.constantPool = new ConstantPool(classReader);

    classReader.accept(this.classNode, classReaderFlags);
  }

  public Optional<MethodNode> findMethod(String name, String desc) {
    return classNode.methods.stream()
        .filter(methodNode -> name == null || methodNode.name.equals(name))
        .filter(methodNode -> desc == null || methodNode.desc.equals(desc))
        .findFirst();
  }

  public Optional<MethodNode> findMethod(String name, Class<?> returnType, Class<?>... parameters) {
    String descriptor = MethodType.methodType(returnType, parameters).toMethodDescriptorString();
    return classNode.methods.stream()
        .filter(methodNode -> name == null || methodNode.name.equals(name))
        .filter(methodNode -> descriptor.equals(methodNode.desc))
        .findFirst();
  }

  public Optional<MethodNode> findMethod(String name, Class<?>... parameters) {
    return findMethod(name, Void.TYPE, parameters);
  }

  public Optional<MethodNode> findMethod(Predicate<String> name, Predicate<String> desc) {
    return classNode.methods.stream()
        .filter(methodNode -> name == null || name.test(methodNode.name))
        .filter(methodNode -> desc == null || desc.test(methodNode.desc))
        .findFirst();
  }

  public Optional<MethodNode> findMethod(Predicate<MethodNode> predicate) {
    return classNode.methods.stream().filter(predicate).findFirst();
  }

  public Optional<MethodNode> findMethod(MethodInsnNode methodInsnNode) {
    return classNode.methods.stream()
        .filter(methodNode -> methodNode.name.equals(methodInsnNode.name))
        .filter(methodNode -> methodNode.desc.equals(methodInsnNode.desc))
        .findFirst();
  }

  public Optional<FieldNode> findField(String name, Class<?> type) {
    return classNode.fields.stream()
        .filter(fieldNode -> name == null || fieldNode.name.equals(name))
        .filter(fieldNode -> Type.getType(type).getDescriptor().equals(fieldNode.desc))
        .findFirst();
  }

  public Optional<FieldNode> findField(String name, String desc) {
    return classNode.fields.stream()
        .filter(fieldNode -> name == null || fieldNode.name.equals(name))
        .filter(fieldNode -> desc == null || fieldNode.desc.equals(desc))
        .findFirst();
  }

  public Optional<FieldNode> findField(Predicate<String> name, Predicate<String> desc) {
    return classNode.fields.stream()
        .filter(fieldNode -> name == null || name.test(fieldNode.name))
        .filter(fieldNode -> desc == null || desc.test(fieldNode.desc))
        .findFirst();
  }

  public Optional<FieldNode> findField(Predicate<FieldNode> predicate) {
    return classNode.fields.stream().filter(predicate).findFirst();
  }

  public Optional<FieldNode> findField(FieldInsnNode fieldInsnNode) {
    return classNode.fields.stream()
        .filter(fieldNode -> fieldNode.name.equals(fieldInsnNode.name))
        .filter(fieldNode -> fieldNode.desc.equals(fieldInsnNode.desc))
        .findFirst();
  }

  public Optional<MethodNode> findClInit() {
    return findMethod("<clinit>", "()V");
  }

  public String name() {
    return classNode.name;
  }

  public String canonicalName() {
    return classNode.name.replace('/', '.');
  }

  /**
   * Compiles class to bytes.
   */
  public byte[] compileToBytes(InheritanceGraph inheritanceGraph, int classWriterFlags) {
    try {
      ClassWriter classWriter = new InheritanceClassWriter(classWriterFlags, inheritanceGraph);
      this.classNode.accept(classWriter);

      return classWriter.toByteArray();
    } catch (Throwable e) {
      throw new RuntimeException(e);
    }
  }

  public String getPathInJar() {
    return pathInJar;
  }

  public List<FieldNode> fields() {
    return classNode.fields;
  }

  public List<MethodNode> methods() {
    return classNode.methods;
  }

  public ClassNode classNode() {
    return classNode;
  }

  public ConstantPool getConstantPool() {
    return constantPool;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/ConstantPool.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import static org.objectweb.asm.Symbol.*;

import java.util.Arrays;
import org.objectweb.asm.ClassReader;

// Fuck asm...
// TODO: Proper implementation in future maybe?
public class ConstantPool implements Cloneable {

  private final int[] cpInfoOffsets;
  private final int[] tags;
  private final Object[] values;

  public ConstantPool(ClassReader classReader) {
    this.cpInfoOffsets = new int[classReader.getItemCount()];
    this.tags = new int[classReader.getItemCount()];
    this.values = new Object[classReader.getItemCount()];
    for (int i = 0; i < this.cpInfoOffsets.length; i++) {
      this.cpInfoOffsets[i] = classReader.getItem(i);
    }

    char[] charBuffer = new char[classReader.getMaxStringLength() * 2]; // fuck you asm
    for (int i = 1; i < cpInfoOffsets.length; i++) {
      int itemOffset = cpInfoOffsets[i];
      int itemTagOffset = itemOffset - 1;
      int itemTag = classReader.readByte(itemTagOffset);

      switch (itemTag) {
        case CONSTANT_FIELDREF_TAG, CONSTANT_METHODREF_TAG, CONSTANT_INTERFACE_METHODREF_TAG -> {
          int nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));
          this.values[i] =
              new Reference(
                  classReader.readClass(itemOffset, charBuffer),
                  classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
                  classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));
        }
        case CONSTANT_INTEGER_TAG -> this.values[i] = classReader.readInt(itemOffset);
        case CONSTANT_FLOAT_TAG ->
            this.values[i] = Float.intBitsToFloat(classReader.readInt(itemOffset));
        case CONSTANT_NAME_AND_TYPE_TAG ->
            this.values[i] =
                new NameAndType(
                    classReader.readUTF8(itemOffset, charBuffer),
                    classReader.readUTF8(itemOffset + 2, charBuffer));
        case CONSTANT_LONG_TAG -> this.values[i] = classReader.readLong(itemOffset);
        case CONSTANT_DOUBLE_TAG ->
            this.values[i] = Double.longBitsToDouble(classReader.readLong(itemOffset));
        case CONSTANT_UTF8_TAG ->
            this.values[i] =
                readUtf(
                    classReader,
                    itemOffset + 2,
                    classReader.readUnsignedShort(itemOffset),
                    charBuffer);
        case CONSTANT_METHOD_HANDLE_TAG -> {
          int memberRefItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));
          int nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));

          this.values[i] =
              new MethodHandle(
                  classReader.readByte(itemOffset),
                  classReader.readClass(memberRefItemOffset, charBuffer),
                  classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
                  classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));
        }
        case CONSTANT_DYNAMIC_TAG, CONSTANT_INVOKE_DYNAMIC_TAG -> {
          int nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));
          this.values[i] =
              new DynamicReference(
                  classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
                  classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),
                  classReader.readUnsignedShort(itemOffset));
        }

        case CONSTANT_STRING_TAG,
                CONSTANT_CLASS_TAG,
                CONSTANT_METHOD_TYPE_TAG,
                CONSTANT_MODULE_TAG,
                CONSTANT_PACKAGE_TAG ->
            this.values[i] = classReader.readUTF8(itemOffset, charBuffer);
      }

      this.tags[i] = itemTag;
      i += (itemTag == CONSTANT_LONG_TAG || itemTag == CONSTANT_DOUBLE_TAG) ? 1 : 0;
    }
  }

  private ConstantPool(int[] cpInfoOffsets, int[] tags, Object[] values) {
    this.cpInfoOffsets = cpInfoOffsets;
    this.tags = tags;
    this.values = values;
  }

  public int getConstantPoolInfoIndex(int index) {
    return cpInfoOffsets[index];
  }

  public int getTag(int index) {
    return tags[index];
  }

  public Object getValue(int index) {
    return values[index];
  }

  public int getSize() {
    return cpInfoOffsets.length;
  }

  // Im actually gonna shoot myself
  private String readUtf(
      ClassReader classReader, final int utfOffset, final int utfLength, final char[] charBuffer) {
    int currentOffset = utfOffset;
    int endOffset = currentOffset + utfLength;
    int strLength = 0;
    byte[] classBuffer = classReader.b;
    while (currentOffset < endOffset) {
      int currentByte = classBuffer[currentOffset++];
      if ((currentByte & 0x80) == 0) {
        charBuffer[strLength++] = (char) (currentByte & 0x7F);
      } else if ((currentByte & 0xE0) == 0xC0) {
        charBuffer[strLength++] =
            (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));
      } else {
        charBuffer[strLength++] =
            (char)
                (((currentByte & 0xF) << 12)
                    + ((classBuffer[currentOffset++] & 0x3F) << 6)
                    + (classBuffer[currentOffset++] & 0x3F));
      }
    }
    return new String(charBuffer, 0, strLength);
  }

  @Override
  protected ConstantPool clone() {
    return new ConstantPool(
        Arrays.copyOf(cpInfoOffsets, cpInfoOffsets.length),
        Arrays.copyOf(tags, tags.length),
        Arrays.copyOf(values, values.length));
  }

  public record Reference(String owner, String name, String descriptor) {}

  public record MethodHandle(int kind, String owner, String name, String descriptor) {}

  public record DynamicReference(String name, String descriptor, int bootstrapMethodIndex) {}

  public record NameAndType(String name, String descriptor) {}
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/FieldRef.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.FieldNode;

/**
 * @param owner Class that owns this field
 * @param name Field's name
 * @param desc Field's descriptor
 */
public record FieldRef(String owner, String name, String desc) {
  public static FieldRef of(ClassNode classNode, FieldNode fieldNode) {
    return new FieldRef(classNode.name, fieldNode.name, fieldNode.desc);
  }

  public static FieldRef of(FieldInsnNode fieldInsn) {
    return new FieldRef(fieldInsn.owner, fieldInsn.name, fieldInsn.desc);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/InsnContext.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;

/**
 * Instruction context. Holds all information relevant to the current instruction.
 */
public class InsnContext {
  private final AbstractInsnNode insn;
  private final MethodContext methodContext;

  InsnContext(AbstractInsnNode insn, MethodContext methodContext) {
    this.insn = insn;
    this.methodContext = methodContext;
  }

  public InsnContext of(AbstractInsnNode insn) {
    return new InsnContext(insn, this.methodContext);
  }

  public Frame<OriginalSourceValue> frame() {
    if (this.methodContext.frames() == null) {
      throw new IllegalStateException("Got frameless method context");
    }
    return this.methodContext.frames().get(this.insn);
  }

  public MethodNode methodNode() {
    return this.methodContext.methodNode();
  }

  /**
   * Current instruction
   */
  public AbstractInsnNode insn() {
    return insn;
  }

  /**
   * Method context
   */
  public MethodContext methodContext() {
    return methodContext;
  }

  /**
   * Pops current instruction's stack values by adding POP instructions before this instruction
   *
   * @param count Stack values count to pop
   */
  public void pop(int count) {
    for (int i = 0; i < count; i++) {
      int stackValueIdx = frame().getStackSize() - (i + 1);
      OriginalSourceValue sourceValue = frame().getStack(stackValueIdx);

      // Pop
      this.methodNode().instructions.insertBefore(this.insn, AsmHelper.toPop(sourceValue));
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/MethodContext.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.Unmodifiable;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.helper.MethodHelper;

import java.util.Map;

/**
 * Method context
 */
public class MethodContext {
  private final ClassWrapper classWrapper;
  private final MethodNode methodNode;
  private final @Nullable @Unmodifiable Map<AbstractInsnNode, Frame<OriginalSourceValue>> frames;

  private MethodContext(
      ClassWrapper classWrapper,
      MethodNode methodNode,
      @Nullable @Unmodifiable Map<AbstractInsnNode, Frame<OriginalSourceValue>> frames
  ) {
    this.classWrapper = classWrapper;
    this.methodNode = methodNode;
    this.frames = frames;
  }

  /**
   * Class that owns this method
   */
  public ClassWrapper classWrapper() {
    return classWrapper;
  }

  /**
   * Method itself
   */
  public MethodNode methodNode() {
    return methodNode;
  }

  /**
   * Frames of the method
   */
  public @Nullable @Unmodifiable Map<AbstractInsnNode, Frame<OriginalSourceValue>> frames() {
    return frames;
  }

  public InsnContext newInsnContext(AbstractInsnNode insn) {
    return new InsnContext(insn, this);
  }

  /**
   * Creates new {@link MethodContext} and computes its frames
   */
  public static MethodContext framed(ClassWrapper classWrapper, MethodNode methodNode) {
    Map<AbstractInsnNode, Frame<OriginalSourceValue>> frames = MethodHelper.analyzeSource(classWrapper.classNode(), methodNode);
    return new MethodContext(classWrapper, methodNode, frames);
  }

  public static MethodContext frameless(ClassWrapper classWrapper, MethodNode methodNode) {
    return new MethodContext(classWrapper, methodNode, null);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/MethodRef.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

/**
 * @param owner Class that owns this method
 * @param name Method's name
 * @param desc Method's descriptor
 */
public record MethodRef(String owner, String name, String desc) {
  public static MethodRef of(ClassNode classNode, MethodNode methodNode) {
    return new MethodRef(classNode.name, methodNode.name, methodNode.desc);
  }

  public static MethodRef of(MethodInsnNode methodInsn) {
    return new MethodRef(methodInsn.owner, methodInsn.name, methodInsn.desc);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/NamedOpcodes.java`:

```java
package uwu.narumi.deobfuscator.api.asm;

import org.objectweb.asm.Opcodes;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

/**
 * Maps opcodes to their names. For debug purposes.
 */
public final class NamedOpcodes {

  private static final Map<Integer, String> names = new HashMap<>();

  private NamedOpcodes() {
    throw new IllegalArgumentException();
  }

  static {
    try {
      boolean found = false;
      for (Field declaredField : Opcodes.class.getDeclaredFields()) {
        if (declaredField.getName().equals("NOP")) found = true;

        if (!found) continue;

        names.put(declaredField.getInt(null), declaredField.getName());
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static String map(int opcode) {
    return names.getOrDefault(opcode, String.valueOf(opcode));
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/Match.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher;

import org.objectweb.asm.tree.AbstractInsnNode;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.asm.MethodContext;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

/**
 * A class that matches instructions providing easy api to interact with.
 */
public abstract class Match {

  private Transformation transformation;
  /**
   * @see #capture(String)
   */
  private String captureId = null;

  /**
   * Tests given instruction if it matches current {@link Match}
   *
   * @param insnContext Instruction context
   * @return If matches
   */
  public boolean matches(InsnContext insnContext) {
    return this.matchResult(insnContext) != null;
  }

  public boolean matches(MethodContext methodContext) {
    return !this.findAllMatches(methodContext).isEmpty();
  }

  /**
   * Matches the instrustion and merges if successful
   *
   * @param insnContext         Instruction context
   * @param currentMatchContext Match context to merge into
   * @return If matches
   */
  public boolean matchAndMerge(InsnContext insnContext, MatchContext currentMatchContext) {
    MatchContext result = this.matchResult(insnContext);
    if (result != null) {
      currentMatchContext.merge(result);
    }
    return result != null;
  }

  /**
   * Finds all matches in the method
   *
   * @param methodContext Method context
   * @return List of all matches
   */
  public List<MatchContext> findAllMatches(MethodContext methodContext) {
    List<MatchContext> allMatches = new ArrayList<>();

    for (AbstractInsnNode insn : methodContext.methodNode().instructions) {
      InsnContext insnContext = methodContext.newInsnContext(insn);
      MatchContext match = this.matchResult(insnContext);
      if (match != null) {
        allMatches.add(match);
      }
    }

    return allMatches;
  }

  public MatchContext findFirstMatch(MethodContext methodContext) {
    return this.findAllMatches(methodContext).stream().findFirst().orElse(null);
  }

  /**
   * @return {@link MatchContext} if matches or {@code null} if it does not match
   */
  public MatchContext matchResult(InsnContext insnContext) {
    // Create MatchContext
    MatchContext context = MatchContext.of(insnContext);

    // Test against this match
    if (!this.test(context)) {
      // No match
      return null;
    }

    if (this.captureId != null) {
      // Capture this instruction
      context.captures().put(this.captureId, context);
    }

    if (!context.collectedInsns().contains(context.insn())) {
      context.collectedInsns().add(context.insn());
    }

    // We have match!
    return context.freeze();
  }

  /**
   * @see #matches(InsnContext)
   */
  protected abstract boolean test(MatchContext context);

  public Match and(Match match) {
    return Match.of(context -> this.matchAndMerge(context.insnContext(), context) && match.matchAndMerge(context.insnContext(), context));
  }

  public Match or(Match match) {
    return Match.of(context -> this.matchAndMerge(context.insnContext(), context) || match.matchAndMerge(context.insnContext(), context));
  }

  public Match not() {
    return Match.of(context -> !matchAndMerge(context.insnContext(), context));
  }

  public Match defineTransformation(Transformation transformation) {
    this.transformation = transformation;
    return this;
  }

  /**
   * If matches, then captures instruction to {@link MatchContext#captures()} for further processing
   *
   * @param id Under what id this instruction should be captured to {@link MatchContext#captures()}
   */
  public Match capture(String id) {
    this.captureId = id;
    return this;
  }

  public Transformation transformation() {
    return this.transformation;
  }

  /**
   * Create {@link Match} from lambda
   *
   * @param predicate Your lambda predicate
   * @return A new {@link Match}
   */
  public static Match of(Predicate<MatchContext> predicate) {
    return new Match() {
      @Override
      protected boolean test(MatchContext context) {
        return predicate.test(context);
      }
    };
  }

  @FunctionalInterface
  public interface Transformation {
    /**
     * Executes given action
     *
     * @param context Current instruction context
     * @return If changed
     */
    boolean transform(InsnContext context);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/MatchContext.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.InsnContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Immutable match context. After matching process, the context is frozen by {@link MatchContext#freeze()}
 */
public class MatchContext {
  private final InsnContext insnContext;
  private final Map<String, MatchContext> captures;
  private final List<AbstractInsnNode> collectedInsns;

  private MatchContext(InsnContext insnContext, Map<String, MatchContext> captures, List<AbstractInsnNode> collectedInsns) {
    this.insnContext = insnContext;
    this.captures = captures;
    this.collectedInsns = collectedInsns;
  }

  public static MatchContext of(InsnContext insnContext) {
    return new MatchContext(insnContext, new HashMap<>(), new ArrayList<>());
  }

  public MatchContext freeze() {
    return new MatchContext(this.insnContext, Collections.unmodifiableMap(this.captures), Collections.unmodifiableList(this.collectedInsns));
  }

  /**
   * Merges other {@link MatchContext} into this {@link MatchContext}.
   *
   * @see Match#matchAndMerge(InsnContext, MatchContext)
   */
  void merge(MatchContext other) {
    this.captures.putAll(other.captures);
    for (AbstractInsnNode insn : other.collectedInsns) {
      // Don't allow duplicates
      if (this.collectedInsns.contains(insn)) continue;

      this.collectedInsns.add(insn);
    }
  }

  /**
   * @see InsnContext#insn()
   */
  public AbstractInsnNode insn() {
    return this.insnContext.insn();
  }

  /**
   * @see InsnContext#frame()
   */
  public Frame<OriginalSourceValue> frame() {
    return this.insnContext.frame();
  }

  /**
   * Instruction context
   */
  public InsnContext insnContext() {
    return insnContext;
  }

  /**
   * Captured instructions in a matching process. id -> match context
   *
   * @see Match#capture(String)
   */
  public Map<String, MatchContext> captures() {
    return captures;
  }

  /**
   * Collected instructions that matches this match and children matches
   */
  public List<AbstractInsnNode> collectedInsns() {
    return collectedInsns;
  }

  /**
   * Removes all collected instructions
   */
  public void removeAll() {
    for (AbstractInsnNode insn : this.collectedInsns) {
      this.insnContext.methodContext().methodNode().instructions.remove(insn);
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/group/AllMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.group;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class AllMatch extends Match {

  private final Match[] matches;

  private AllMatch(Match[] matches) {
    this.matches = matches;
  }

  public static AllMatch of(Match... matches) {
    return new AllMatch(matches);
  }

  @Override
  protected boolean test(MatchContext context) {
    for (Match match : matches) {
      if (!match.matchAndMerge(context.insnContext(), context)) return false;
    }

    return true;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/group/AnyMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.group;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class AnyMatch extends Match {

  private final Match[] matches;

  private AnyMatch(Match[] matches) {
    this.matches = matches;
  }

  public static AnyMatch of(Match... matches) {
    return new AnyMatch(matches);
  }

  @Override
  protected boolean test(MatchContext context) {
    for (Match match : matches) {
      if (match.matchAndMerge(context.insnContext(), context)) return true;
    }

    return false;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/group/NotMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.group;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class NotMatch extends Match {

  private final Match match;

  private NotMatch(Match match) {
    this.match = match;
  }

  public static NotMatch of(Match match) {
    return new NotMatch(match);
  }

  @Override
  protected boolean test(MatchContext context) {
    return !match.matchAndMerge(context.insnContext(), context);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/group/PositionedMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.group;

import org.objectweb.asm.tree.AbstractInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class PositionedMatch extends Match {

  private final int offset;
  private final boolean previous;
  private final boolean skipAsmInstructions;
  private final Match match;

  private PositionedMatch(int offset, boolean skipAsmInstructions, Match match) {
    this.offset = Math.abs(offset);
    this.previous = offset < 0;
    this.skipAsmInstructions = skipAsmInstructions;
    this.match = match;
  }

  @Override
  protected boolean test(MatchContext context) {
    return this.match.matchAndMerge(context.insnContext().of(walk(context.insn())), context);
  }

  private AbstractInsnNode walk(AbstractInsnNode node) {
    if (previous) {
      node = skipAsmInstructions ? node.previous(offset) : node.getPrevious(offset);
    } else {
      node = skipAsmInstructions ? node.next(offset) : node.getNext(offset);
    }

    return node;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/group/SequenceMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.group;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LineNumberNode;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

import java.util.ArrayList;
import java.util.List;

/**
 * Matches instructions in sequence
 */
// TODO: backwards match?
public class SequenceMatch extends Match {

  private static final Match FRAME_MATCH = Match.of(context -> context.insn() instanceof FrameNode);
  private static final Match LABEL_MATCH = Match.of(context -> context.insn() instanceof LabelNode);
  private static final Match LINE_MATCH = Match.of(context -> context.insn() instanceof LineNumberNode);

  private final Match[] matches;
  private final List<Match> skipMatches = new ArrayList<>(List.of(FRAME_MATCH, LABEL_MATCH, LINE_MATCH));

  private SequenceMatch(Match[] matches) {
    this.matches = matches;
  }

  public static SequenceMatch of(Match... matches) {
    return new SequenceMatch(matches);
  }

  /**
   * You can specify which instructions should be skipped during walking through instructions
   */
  public SequenceMatch skip(Match... matches) {
    this.skipMatches.addAll(List.of(matches));
    return this;
  }

  public SequenceMatch doNotSkipFrames() {
    this.skipMatches.remove(FRAME_MATCH);
    return this;
  }

  public SequenceMatch doNotSkipLabels() {
    this.skipMatches.remove(LABEL_MATCH);
    return this;
  }

  public SequenceMatch doNotSkipLineNumbers() {
    this.skipMatches.remove(LINE_MATCH);
    return this;
  }

  public SequenceMatch doNotSkip() {
    doNotSkipLabels();
    doNotSkipLabels();
    doNotSkipFrames();
    return this;
  }

  @Override
  protected boolean test(MatchContext context) {
    AbstractInsnNode currentInsn = context.insn();
    int matchIdx = 0;

    while (matchIdx < matches.length) {
      if (currentInsn == null) {
        // Expected instruction but no instructions left
        return false;
      }

      InsnContext currentInsnContext = context.insnContext().of(currentInsn);
      if (this.skipMatches.stream().anyMatch(match -> match.matches(currentInsnContext))) {
        // Skip instruction
        currentInsn = currentInsn.getNext();
        continue;
      }

      // Find match
      Match match = this.matches[matchIdx];
      if (!match.matchAndMerge(currentInsnContext, context)) {
        // No match
        return false;
      }

      // Go to next instruction
      currentInsn = currentInsn.getNext();
      matchIdx++;
    }

    return true;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/ClassTypeMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

/**
 * Matches by instruction class type
 */
public class ClassTypeMatch extends Match {

  private final Class<? extends AbstractInsnNode> classType;

  private ClassTypeMatch(Class<? extends AbstractInsnNode> classType) {
    this.classType = classType;
  }

  public static ClassTypeMatch of(Class<? extends AbstractInsnNode> classType) {
    return new ClassTypeMatch(classType);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn().getClass().equals(classType);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/FieldMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.FieldInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class FieldMatch extends Match {

  private final int opcode;
  private String owner;
  private String name;
  private String desc;

  private FieldMatch(int opcode) {
    this.opcode = opcode;
  }

  public static FieldMatch of(int opcode) {
    return new FieldMatch(opcode);
  }

  public static FieldMatch create() {
    return new FieldMatch(-1);
  }

  public static FieldMatch putStatic() {
    return new FieldMatch(Opcodes.PUTSTATIC);
  }

  public static FieldMatch getStatic() {
    return new FieldMatch(Opcodes.GETSTATIC);
  }

  public static FieldMatch putField() {
    return new FieldMatch(Opcodes.PUTFIELD);
  }

  public static FieldMatch getField() {
    return new FieldMatch(Opcodes.GETFIELD);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn() instanceof FieldInsnNode fieldInsn
        && (opcode == -1 || fieldInsn.getOpcode() == opcode)
        && (owner == null || fieldInsn.owner.equals(owner))
        && (name == null || fieldInsn.name.equals(name))
        && (desc == null || fieldInsn.desc.equals(desc));
  }

  public FieldMatch owner(String owner) {
    this.owner = owner;
    return this;
  }

  public FieldMatch name(String name) {
    this.name = name;
    return this;
  }

  public FieldMatch desc(String desc) {
    this.desc = desc;
    return this;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/InsnMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

/**
 * Matches an instruction by its instance.
 */
public class InsnMatch extends Match {

  private final AbstractInsnNode node;

  private InsnMatch(AbstractInsnNode node) {
    this.node = node;
  }

  public static InsnMatch of(AbstractInsnNode node) {
    return new InsnMatch(node);
  }

  @Override
  protected boolean test(MatchContext context) {
    return this.node.equals(context.insn());
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/InvokeDynamicMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import java.util.function.Predicate;

import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class InvokeDynamicMatch extends Match {
  private String name;
  private String desc;

  private String bsmOwner;
  private String bsmName;
  private String bsmDesc;
  private int bsmTag = -1;

  private Predicate<Object[]> bsmArgsPredicate;

  private InvokeDynamicMatch() {}

  public static InvokeDynamicMatch create() {
    return new InvokeDynamicMatch();
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn() instanceof InvokeDynamicInsnNode invokeDynamicInsn
        && (name == null || invokeDynamicInsn.name.equals(name))
        && (desc == null || invokeDynamicInsn.desc.equals(desc))
        && (bsmOwner == null || invokeDynamicInsn.bsm.getOwner().equals(bsmOwner))
        && (bsmName == null || invokeDynamicInsn.bsm.getName().equals(bsmName))
        && (bsmDesc == null || invokeDynamicInsn.bsm.getDesc().equals(bsmDesc))
        && (bsmTag == -1 || invokeDynamicInsn.bsm.getTag() == bsmTag)
        && (bsmArgsPredicate == null
            || bsmArgsPredicate.test(invokeDynamicInsn.bsmArgs));
  }

  public InvokeDynamicMatch name(String name) {
    this.name = name;
    return this;
  }

  public InvokeDynamicMatch desc(String desc) {
    this.desc = desc;
    return this;
  }

  public InvokeDynamicMatch bsmOwner(String bsmOwner) {
    this.bsmOwner = bsmOwner;
    return this;
  }

  public InvokeDynamicMatch bsmName(String bsmName) {
    this.bsmName = bsmName;
    return this;
  }

  public InvokeDynamicMatch bsmDesc(String bsmDesc) {
    this.bsmDesc = bsmDesc;
    return this;
  }

  public InvokeDynamicMatch bsmTag(int bsmTag) {
    this.bsmTag = bsmTag;
    return this;
  }

  public InvokeDynamicMatch bsmArgsPredicate(Predicate<Object[]> predicate) {
    this.bsmArgsPredicate = predicate;
    return this;
  }

  public static class Pred extends Match {
    private Predicate<String> name;
    private Predicate<String> desc;

    private Predicate<String> bsmOwner;
    private Predicate<String> bsmName;
    private Predicate<String> bsmDesc;
    private Predicate<Integer> bsmTag;

    private Predicate<Object[]> bsmArgsPredicate;

    private Pred() {}

    public static Pred create() {
      return new Pred();
    }

    @Override
    protected boolean test(MatchContext context) {
      return context.insn() instanceof InvokeDynamicInsnNode invokeDynamicInsn
          && (name == null || name.test(invokeDynamicInsn.name))
          && (desc == null || desc.test(invokeDynamicInsn.desc))
          && (bsmOwner == null || bsmOwner.test(invokeDynamicInsn.bsm.getOwner()))
          && (bsmName == null || bsmName.test(invokeDynamicInsn.bsm.getName()))
          && (bsmDesc == null || bsmDesc.test(invokeDynamicInsn.bsm.getDesc()))
          && (bsmTag == null || bsmTag.test(invokeDynamicInsn.bsm.getTag()))
          && (bsmArgsPredicate == null || bsmArgsPredicate.test(invokeDynamicInsn.bsmArgs));
    }

    public Pred name(Predicate<String> name) {
      this.name = name;
      return this;
    }

    public Pred desc(Predicate<String> desc) {
      this.desc = desc;
      return this;
    }

    public Pred bsmOwner(Predicate<String> bsmOwner) {
      this.bsmOwner = bsmOwner;
      return this;
    }

    public Pred bsmName(Predicate<String> bsmName) {
      this.bsmName = bsmName;
      return this;
    }

    public Pred bsmDesc(Predicate<String> bsmDesc) {
      this.bsmDesc = bsmDesc;
      return this;
    }

    public Pred bsmTag(Predicate<Integer> bsmTag) {
      this.bsmTag = bsmTag;
      return this;
    }

    public Pred bsmArgsPredicate(Predicate<Object[]> predicate) {
      this.bsmArgsPredicate = predicate;
      return this;
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/JumpMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class JumpMatch extends Match {

  private final int opcode;
  private final LabelNode labelNode;

  private JumpMatch(int opcode, LabelNode labelNode) {
    this.opcode = opcode;
    this.labelNode = labelNode;
  }

  public static JumpMatch of(int opcode, LabelNode labelNode) {
    return new JumpMatch(opcode, labelNode);
  }

  public static JumpMatch of(LabelNode labelNode) {
    return of(-1, labelNode);
  }

  public static JumpMatch of(int opcode) {
    return of(opcode, null);
  }

  public static JumpMatch of() {
    return of(-1, null);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn() instanceof JumpInsnNode jumpInsn
        && (opcode == -1 || jumpInsn.getOpcode() == opcode)
        && (labelNode == null || jumpInsn.label.equals(labelNode));
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/MethodMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import java.util.Arrays;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodInsnNode;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class MethodMatch extends Match {

  private final int opcode;
  private String owner;
  private String[] name;
  private String desc;

  private MethodMatch(int opcode) {
    this.opcode = opcode;
  }

  public static MethodMatch of(int opcode) {
    return new MethodMatch(opcode);
  }

  public static MethodMatch create() {
    return new MethodMatch(-1);
  }

  public static MethodMatch invokeStatic() {
    return new MethodMatch(Opcodes.INVOKESTATIC);
  }

  public static MethodMatch invokeVirtual() {
    return new MethodMatch(Opcodes.INVOKEVIRTUAL);
  }

  public static MethodMatch invokeSpecial() {
    return new MethodMatch(Opcodes.INVOKESPECIAL);
  }

  public static MethodMatch invokeInterface() {
    return new MethodMatch(Opcodes.INVOKEINTERFACE);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn() instanceof MethodInsnNode methodInsn
        && (opcode == -1 || methodInsn.getOpcode() == opcode)
        && (owner == null || methodInsn.owner.equals(owner))
        && (name == null || Arrays.binarySearch(name, methodInsn.name) >= 0)
        && (desc == null || methodInsn.desc.equals(desc));
  }

  public MethodMatch owner(String owner) {
    this.owner = owner;
    return this;
  }

  public MethodMatch name(String... name) {
    this.name = name;
    return this;
  }

  public MethodMatch desc(String desc) {
    this.desc = desc;
    return this;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/NumberMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class NumberMatch extends Match {
  private final Number number;

  private NumberMatch(Number number) {
    this.number = number;
  }

  public static NumberMatch of(Number number) {
    return new NumberMatch(number);
  }

  public static Match of() {
    return Match.of(ctx -> ctx.insn().isNumber());
  }

  public static Match numDouble() {
    return Match.of(ctx -> ctx.insn().isDouble());
  }

  public static Match numFloat() {
    return Match.of(ctx -> ctx.insn().isFloat());
  }

  public static Match numInteger() {
    return Match.of(ctx -> ctx.insn().isInteger());
  }

  public static Match numLong() {
    return Match.of(ctx -> ctx.insn().isLong());
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn().isNumber() && context.insn().asNumber().equals(this.number);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/OpcodeMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class OpcodeMatch extends Match {
  private final int opcode;

  private OpcodeMatch(int opcode) {
    this.opcode = opcode;
  }

  public static OpcodeMatch of(int opcode) {
    return new OpcodeMatch(opcode);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn().getOpcode() == opcode;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/RangeOpcodeMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class RangeOpcodeMatch extends Match {
  private final int start;
  private final int end;

  private RangeOpcodeMatch(int start, int end) {
    this.start = start;
    this.end = end;
  }

  public static RangeOpcodeMatch of(int startingOpcode, int endingOpcode) {
    return new RangeOpcodeMatch(startingOpcode, endingOpcode);
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn().getOpcode() >= start && context.insn().getOpcode() <= end;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/SkipMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class SkipMatch extends Match {

  private SkipMatch() {}

  public static SkipMatch create() {
    return new SkipMatch();
  }

  @Override
  protected boolean test(MatchContext context) {
    return true;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/StackMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

/**
 * Match instruction from stack
 */
public class StackMatch extends Match {
  private final int stackValueIdx;
  private final Match match;
  private final boolean originalValue;

  /**
   * @param stackValueIdx Index of the value in the stack, starting from the top of the stack, so '0' is the top value.
   * @param match A {@link Match} to match against that stack value
   */
  private StackMatch(int stackValueIdx, Match match, boolean originalValue) {
    this.stackValueIdx = stackValueIdx;
    this.match = match;
    this.originalValue = originalValue;
  }

  public static StackMatch of(int stackValueIdx, Match match) {
    return new StackMatch(stackValueIdx, match, false);
  }

  public static StackMatch ofOriginal(int stackValueIdx, Match match) {
    return new StackMatch(stackValueIdx, match, true);
  }

  @Override
  protected boolean test(MatchContext context) {
    if (context.insnContext().methodContext().frames() == null) {
      throw new IllegalStateException("Got frameless method context");
    }

    if (context.frame() == null) {
      // If we expect stack values, then frame can't be null
      return false;
    }

    // Pop values from stack and match them
    int index = context.frame().getStackSize() - (this.stackValueIdx + 1);
    if (index < 0) {
      // If the stack value should exist but does not, then it does not match
      return false;
    }

    if (this.match instanceof SkipMatch) {
      // Skip match earlier
      return true;
    }

    Frame<OriginalSourceValue> frame = context.frame();
    OriginalSourceValue sourceValue = frame.getStack(index);
    if (this.originalValue) {
      sourceValue = sourceValue.originalSource;
    }

    if (!sourceValue.isOneWayProduced()) {
      // We only want stack values that are one way produced
      return false;
    }

    AbstractInsnNode stackValueInsn = sourceValue.getProducer();
    return this.match.matchAndMerge(context.insnContext().of(stackValueInsn), context);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/asm/matcher/impl/StringMatch.java`:

```java
package uwu.narumi.deobfuscator.api.asm.matcher.impl;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;

public class StringMatch extends Match {

  private final String string;

  private StringMatch(String string) {
    this.string = string;
  }

  public static StringMatch of(String string) {
    return new StringMatch(string);
  }

  public static Match of() {
    return Match.of(context -> context.insn().isString());
  }

  @Override
  protected boolean test(MatchContext context) {
    return context.insn().isString() && context.insn().asString().equals(string);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/classpath/ClassProvider.java`:

```java
package uwu.narumi.deobfuscator.api.classpath;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.tree.ClassNode;

import java.util.Collection;

public interface ClassProvider {
  /**
   * Gets class bytes by internal name
   *
   * @param name Internal name of class
   * @return Class bytes
   */
  byte @Nullable [] getClass(String name);

  /**
   * Gets file bytes by name
   *
   * @param path File path
   * @return File bytes
   */
  byte @Nullable [] getFile(String path);

  /**
   * Gets class node that holds only the class information. It is not guaranteed that the class holds code.
   *
   * @param name Internal name of class
   * @return Class node
   */
  @Nullable
  ClassNode getClassInfo(String name);

  /**
   * Gets all classes in the provider.
   */
  Collection<String> getLoadedClasses();
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/classpath/ClassStorage.java`:

```java
package uwu.narumi.deobfuscator.api.classpath;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.tree.ClassNode;
import software.coley.cafedude.InvalidClassException;
import uwu.narumi.deobfuscator.api.helper.ClassHelper;
import uwu.narumi.deobfuscator.api.helper.FileHelper;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ClassStorage implements ClassProvider {
  private final Map<String, byte[]> compiledClasses = new ConcurrentHashMap<>();
  private final Map<String, byte[]> files = new ConcurrentHashMap<>();

  private final Map<String, ClassNode> classesInfo = new ConcurrentHashMap<>();

  /**
   * Adds jar to class storage
   *
   * @param jarPath Jar path
   */
  public void addJar(@NotNull Path jarPath) {
    FileHelper.loadFilesFromZip(jarPath, (classPath, bytes) -> {
      if (!ClassHelper.isClass(classPath, bytes)) {
        files.putIfAbsent(classPath, bytes);
        return;
      }

      addRawClass(bytes);
    });
  }

  public void addRawClass(byte[] bytes) {
    try {
      ClassNode classNode = ClassHelper.loadUnknownClassInfo(bytes);
      String className = classNode.name;

      // Add class to class storage
      compiledClasses.putIfAbsent(className, bytes);
      classesInfo.putIfAbsent(className, classNode);
    } catch (InvalidClassException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public byte @Nullable [] getClass(String name) {
    return compiledClasses.get(name);
  }

  @Override
  public byte @Nullable [] getFile(String path) {
    return files.get(path);
  }

  @Override
  public @Nullable ClassNode getClassInfo(String name) {
    return classesInfo.get(name);
  }

  @Override
  public Collection<String> getLoadedClasses() {
    return compiledClasses.keySet();
  }

  public Map<String, byte[]> compiledClasses() {
    return compiledClasses;
  }

  public Map<String, byte[]> files() {
    return files;
  }

  public Map<String, ClassNode> classesInfo() {
    return classesInfo;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/classpath/CombinedClassProvider.java`:

```java
package uwu.narumi.deobfuscator.api.classpath;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.tree.ClassNode;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public class CombinedClassProvider implements ClassProvider {
  private final ClassProvider[] classProviders;

  public CombinedClassProvider(ClassProvider... classProviders) {
    this.classProviders = classProviders;
  }

  @Override
  public byte @Nullable [] getClass(String name) {
    for (ClassProvider classProvider : this.classProviders) {
      byte[] bytes = classProvider.getClass(name);
      if (bytes != null) return bytes;
    }
    return null;
  }

  @Override
  public byte @Nullable [] getFile(String path) {
    for (ClassProvider classProvider : this.classProviders) {
      byte[] bytes = classProvider.getFile(path);
      if (bytes != null) return bytes;
    }
    return null;
  }

  @Override
  public @Nullable ClassNode getClassInfo(String name) {
    for (ClassProvider classProvider : this.classProviders) {
      ClassNode classInfo = classProvider.getClassInfo(name);
      if (classInfo != null) return classInfo;
    }
    return null;
  }

  @Override
  public Collection<String> getLoadedClasses() {
    Set<String> classes = new HashSet<>();
    for (ClassProvider classProvider : this.classProviders) {
      classes.addAll(classProvider.getLoadedClasses());
    }
    return classes;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/classpath/InheritanceClassWriter.java`:

```java
package uwu.narumi.deobfuscator.api.classpath;

import org.objectweb.asm.ClassWriter;
import uwu.narumi.deobfuscator.api.inheritance.InheritanceGraph;

/**
 * A {@link ClassWriter} that uses a {@link InheritanceGraph} to determine the common superclass of two classes.
 */
public class InheritanceClassWriter extends ClassWriter {
  private final InheritanceGraph inheritanceGraph;

  public InheritanceClassWriter(int flags, InheritanceGraph inheritanceGraph) {
    super(flags);
    this.inheritanceGraph = inheritanceGraph;
  }

  @Override
  protected String getCommonSuperClass(String first, String second) {
    return this.inheritanceGraph.getCommon(first, second);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/classpath/JvmClassProvider.java`:

```java
package uwu.narumi.deobfuscator.api.classpath;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.tree.ClassNode;
import uwu.narumi.deobfuscator.api.helper.ClassHelper;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Classpath that fetches default JVM classes
 */
public class JvmClassProvider implements ClassProvider {
  private static final Logger LOGGER = LogManager.getLogger();

  public static final JvmClassProvider INSTANCE = new JvmClassProvider();

  private final Map<String, byte[]> classesCache = new ConcurrentHashMap<>();
  private final Map<String, ClassNode> classInfoCache = new ConcurrentHashMap<>();

  private JvmClassProvider() {
  }

  @Override
  public byte @Nullable [] getClass(String name) {
    if (classesCache.containsKey(name)) {
      return classesCache.get(name);
    }

    // Try to find it in classloader
    byte[] value = null;
    try (InputStream in = ClassLoader.getSystemResourceAsStream(name + ".class")) {
      if (in != null) {
        value = in.readAllBytes();
      }
    } catch (IOException ex) {
      LOGGER.error("Failed to fetch runtime bytecode of class: {}", name, ex);
    }

    if (value == null) return null;

    // Cache it!
    classesCache.put(name, value);

    return value;
  }

  @Override
  public byte @Nullable [] getFile(String path) {
    // JVM classpath doesn't have files
    return null;
  }

  @Override
  public @Nullable ClassNode getClassInfo(String name) {
    if (classInfoCache.containsKey(name)) {
      return classInfoCache.get(name);
    }

    byte[] bytes = getClass(name);
    if (bytes == null) return null;

    ClassNode classNode = ClassHelper.loadClassInfo(bytes);

    // Cache it!
    classInfoCache.put(name, classNode);

    return classNode;
  }

  @Override
  public Collection<String> getLoadedClasses() {
    // We cannot determine all classes in JVM classpath
    return List.of();
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/context/Context.java`:

```java
package uwu.narumi.deobfuscator.api.context;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.UnmodifiableView;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import software.coley.cafedude.InvalidClassException;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.classpath.ClassProvider;
import uwu.narumi.deobfuscator.api.classpath.ClassStorage;
import uwu.narumi.deobfuscator.api.execution.SandBox;
import uwu.narumi.deobfuscator.api.helper.ClassHelper;

public class Context implements ClassProvider {

  private final Map<String, ClassWrapper> classesMap = new ConcurrentHashMap<>();
  private final Map<String, byte[]> filesMap = new ConcurrentHashMap<>();

  private final DeobfuscatorOptions options;

  private final ClassStorage compiledClasses;
  private final ClassStorage libraries;

  private SandBox globalSandBox = null;

  /**
   * Creates a new {@link Context} instance from its options
   *
   * @param options Deobfuscator options
   * @param compiledClasses {@link ClassStorage} that holds the original classes of the primary jar
   * @param libraries {@link ClassStorage} that holds the libraries' classes
   */
  public Context(DeobfuscatorOptions options, ClassStorage compiledClasses, ClassStorage libraries) {
    this.options = options;

    this.compiledClasses = compiledClasses;
    this.libraries = libraries;
  }

  /**
   * Gets sandbox or creates if it does not exist.
   */
  public SandBox getSandBox() {
    if (this.globalSandBox == null) {
      // Lazily load sandbox
      this.globalSandBox = new SandBox(this);
    }
    return this.globalSandBox;
  }

  public DeobfuscatorOptions getOptions() {
    return options;
  }

  /**
   * Class storage that holds already compiled classes from original jar
   */
  public ClassStorage getCompiledClasses() {
    return compiledClasses;
  }

  /**
   * Class storage that holds libraries' classes
   */
  public ClassStorage getLibraries() {
    return libraries;
  }

  public Collection<ClassWrapper> classes() {
    return classesMap.values();
  }

  @UnmodifiableView
  public List<ClassWrapper> scopedClasses(ClassWrapper scope) {
    return classesMap.values().stream()
        .filter(classWrapper -> scope == null || classWrapper.name().equals(scope.name()))
        .toList();
  }

  public void addCompiledClass(String pathInJar, byte[] bytes) {
    try {
      ClassWrapper classWrapper = ClassHelper.loadUnknownClass(pathInJar, bytes, ClassReader.SKIP_FRAMES);
      this.classesMap.putIfAbsent(classWrapper.name(), classWrapper);
      this.compiledClasses.addRawClass(bytes);
    } catch (InvalidClassException e) {
      throw new RuntimeException(e);
    }
  }

  public void addFile(String path, byte[] bytes) {
    this.filesMap.put(path, bytes);
    this.compiledClasses.files().put(path, bytes);
  }

  @Override
  public byte @Nullable [] getClass(String name) {
    // Not implemented because it would need to compile class which is CPU intensive
    return null;
  }

  @Override
  public byte @Nullable [] getFile(String path) {
    return filesMap.get(path);
  }

  @Override
  public @Nullable ClassNode getClassInfo(String name) {
    ClassWrapper classWrapper = classesMap.get(name);
    if (classWrapper == null) return null;
    return classWrapper.classNode();
  }

  @Override
  public Collection<String> getLoadedClasses() {
    return this.classesMap.keySet();
  }

  public Map<String, ClassWrapper> getClassesMap() {
    return classesMap;
  }

  public Map<String, byte[]> getFilesMap() {
    return filesMap;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/context/DeobfuscatorOptions.java`:

```java
package uwu.narumi.deobfuscator.api.context;

import org.intellij.lang.annotations.MagicConstant;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.ClassWriter;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;

/**
 * Immutable options for deobfuscator
 */
public record DeobfuscatorOptions(
    @Nullable Path inputJar,
    List<ExternalFile> externalFiles,
    Set<Path> libraries,

    @Nullable Path outputJar,
    @Nullable Path outputDir,

    List<Supplier<Transformer>> transformers,

    @MagicConstant(flagsFromClass = ClassWriter.class) int classWriterFlags,

    boolean printStacktraces,
    boolean continueOnError,
    boolean verifyBytecode,
    boolean skipFiles
) {
  public static DeobfuscatorOptions.Builder builder() {
    return new DeobfuscatorOptions.Builder();
  }

  /**
   * @param path Path to the raw file
   * @param pathInJar Relative path to file as if it were in .jar
   */
  public record ExternalFile(Path path, String pathInJar) {
  }

  /**
   * Builder for {@link DeobfuscatorOptions}
   */
  public static class Builder {
    // Inputs
    @Nullable
    private Path inputJar = null;
    private final List<ExternalFile> externalFiles = new ArrayList<>();
    private final Set<Path> libraries = new HashSet<>();

    // Outputs
    @Nullable
    private Path outputJar = null;
    @Nullable
    private Path outputDir = null;

    // Transformers
    private final List<Supplier<Transformer>> transformers = new ArrayList<>();

    // Other config
    @MagicConstant(flagsFromClass = ClassWriter.class)
    private int classWriterFlags = ClassWriter.COMPUTE_FRAMES;

    private boolean printStacktraces = true;
    private boolean continueOnError = false;
    private boolean verifyBytecode = false;
    private boolean skipFiles = false;

    private Builder() {
    }

    /**
     * Your input jar file
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder inputJar(@Nullable Path inputJar) {
      this.inputJar = inputJar;
      if (this.inputJar != null) {
        // Auto fill output jar
        if (this.outputJar == null) {
          String fullName = inputJar.getFileName().toString();
          int dot = fullName.lastIndexOf('.');

          this.outputJar = inputJar.getParent()
              .resolve(dot == -1 ? fullName + "-out" : fullName.substring(0, dot) + "-out" + fullName.substring(dot));
        }
      }
      return this;
    }

    /**
     * Add an external file to the deobfuscation context. You can add raw .class files or files that would be in .jar
     *
     * @param path Path to an external file
     * @param pathInJar Relative path to file if it were in .jar
     */
    @Contract("_,_ -> this")
    public DeobfuscatorOptions.Builder externalFile(Path path, String pathInJar) {
      this.externalFiles.add(new ExternalFile(path, pathInJar));
      return this;
    }

    /**
     * Adds all files from the directory to the deobfuscation context
     *
     * @param path Path to the directory
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder inputDir(Path path) {
      try {
        Files.walkFileTree(path, new SimpleFileVisitor<>() {
          @Override
          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            String pathInJar = path.relativize(file).toString();
            externalFile(file, pathInJar);
            return FileVisitResult.CONTINUE;
          }
        });
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
      return this;
    }

    /**
     * Add libraries to the classpath. You can pass here files or directories.
     *
     * @param paths Paths to libraries
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder libraries(Path... paths) {
      for (Path path : paths) {
        if (Files.isDirectory(path)) {
          try {
            // Walk through directory
            Files.walkFileTree(path, new SimpleFileVisitor<>() {
              @Override
              public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                libraries.add(file);
                return FileVisitResult.CONTINUE;
              }
            });
          } catch (IOException e) {
            throw new RuntimeException(e);
          }
        } else {
          this.libraries.add(path);
        }
      }
      return this;
    }

    /**
     * Output jar for deobfuscated classes. Automatically filled when input jar is set
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder outputJar(@Nullable Path outputJar) {
      this.outputJar = outputJar;
      return this;
    }

    /**
     * Set output dir it if you want to output raw compiled classes instead of jar file
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder outputDir(@Nullable Path outputDir) {
      this.outputDir = outputDir;
      return this;
    }

    /**
     * Transformers to run. You need to specify them in lambda form:
     * <pre>
     * {@code
     * () -> new MyTransformer(true, false),
     * () -> new AnotherTransformer(),
     * () -> new SuperTransformer()
     * }
     * </pre>
     *
     * We can push it further, and we can replace lambdas with no arguments with method references:
     * <pre>
     * {@code
     * () -> new MyTransformer(true, false),
     * AnotherTransformer::new,
     * SuperTransformer::new
     * }
     * </pre>
     */
    @SafeVarargs
    @Contract("_ -> this")
    public final DeobfuscatorOptions.Builder transformers(Supplier<Transformer>... transformers) {
      this.transformers.addAll(List.of(transformers));
      return this;
    }

    /**
     * Flags for {@link ClassWriter}.
     * <ul>
     * <li><code>0</code> - Deobfuscated jar can't be run</li>
     * <li>{@link ClassWriter#COMPUTE_FRAMES} - Makes a runnable deobfuscated jar</li>
     * </ul>
     */
    @Contract("_ -> this")
    public DeobfuscatorOptions.Builder classWriterFlags(@MagicConstant(flagsFromClass = ClassWriter.class) int classWriterFlags) {
      this.classWriterFlags = classWriterFlags;
      return this;
    }

    /**
     * Disables stacktraces logging
     */
    @Contract(" -> this")
    public DeobfuscatorOptions.Builder noStacktraces() {
      this.printStacktraces = false;
      return this;
    }

    /**
     * Continue deobfuscation even if errors occur
     */
    @Contract(" -> this")
    public DeobfuscatorOptions.Builder continueOnError() {
      this.continueOnError = true;
      return this;
    }

    /**
     * Verify bytecode after each transformer run. Useful when debugging which
     * transformer is causing issues (aka broke bytecode)
     */
    @Contract(" -> this")
    public DeobfuscatorOptions.Builder verifyBytecode() {
      this.verifyBytecode = true;
      return this;
    }

    /**
     * Skips files during saving.
     */
    @Contract(" -> this")
    public DeobfuscatorOptions.Builder skipFiles() {
      this.skipFiles = true;
      return this;
    }

    /**
     * Build immutable {@link DeobfuscatorOptions} with options verification
     */
    public DeobfuscatorOptions build() {
      // Verify some options
      if (this.inputJar == null && this.externalFiles.isEmpty()) {
        throw new IllegalStateException("No input files provided");
      }
      if (this.outputJar == null && this.outputDir == null) {
        throw new IllegalStateException("No output file or directory provided");
      }
      if (this.outputJar != null && this.outputDir != null) {
        throw new IllegalStateException("Output jar and output dir cannot be set at the same time");
      }

      return new DeobfuscatorOptions(
          // Input
          inputJar,
          externalFiles,
          libraries,
          // Output
          outputJar,
          outputDir,
          // Transformers
          transformers,
          // Flags
          classWriterFlags,
          // Other config
          printStacktraces,
          continueOnError,
          verifyBytecode,
          skipFiles
      );
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/data/Pair.java`:

```java
package uwu.narumi.deobfuscator.api.data;

import java.util.function.BiConsumer;

public record Pair<A, B>(A key, B value) {
  public static <X, Y> Pair<X, Y> of(X key, Y value) {
    return new Pair<>(key, value);
  }

  public void consume(BiConsumer<A, B> consumer) {
    consumer.accept(key(), value());
  }

  public boolean isPresent() {
    return key != null && value != null;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/data/TriConsumer.java`:

```java
package uwu.narumi.deobfuscator.api.data;

import java.util.Objects;

@FunctionalInterface
public interface TriConsumer<A, B, C> {
  void accept(A first, B second, C third);

  default TriConsumer<A, B, C> andThen(TriConsumer<? super A, ? super B, ? super C> after) {
    Objects.requireNonNull(after);
    return (first, second, third) -> {
      accept(first, second, third);
      after.accept(first, second, third);
    };
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/data/TriFunction.java`:

```java
package uwu.narumi.deobfuscator.api.data;

import java.util.Objects;
import java.util.function.Function;

@FunctionalInterface
public interface TriFunction<A, B, C, R> {
  R apply(A first, B second, C third);

  default <V> TriFunction<A, B, C, V> andThen(Function<? super R, ? extends V> after) {
    Objects.requireNonNull(after);
    return (A first, B second, C third) -> after.apply(apply(first, second, third));
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/exception/TransformerException.java`:

```java
package uwu.narumi.deobfuscator.api.exception;

public class TransformerException extends RuntimeException {

  public TransformerException() {}

  public TransformerException(String message) {
    super(message);
  }

  public TransformerException(String message, Throwable cause) {
    super(message, cause);
  }

  public TransformerException(Throwable cause) {
    super(cause);
  }

  public TransformerException(
      String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
    super(message, cause, enableSuppression, writableStackTrace);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/execution/ClasspathDataSupplier.java`:

```java
package uwu.narumi.deobfuscator.api.execution;

import dev.xdark.ssvm.classloading.SupplyingClassLoaderInstaller;
import uwu.narumi.deobfuscator.api.classpath.ClassProvider;

public class ClasspathDataSupplier implements SupplyingClassLoaderInstaller.DataSupplier {

  private final ClassProvider classpath;

  public ClasspathDataSupplier(ClassProvider classpath) {
    this.classpath = classpath;
  }

  @Override
  public byte[] getClass(String className) {
    return classpath.getClass(className.replace('.', '/'));
  }

  @Override
  public byte[] getResource(String resourcePath) {
    return classpath.getFile(resourcePath);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/execution/SandBox.java`:

```java
package uwu.narumi.deobfuscator.api.execution;

import dev.xdark.ssvm.LinkResolver;
import dev.xdark.ssvm.RuntimeResolver;
import dev.xdark.ssvm.VirtualMachine;
import dev.xdark.ssvm.api.VMInterface;
import dev.xdark.ssvm.classloading.SupplyingClassLoaderInstaller;
import dev.xdark.ssvm.execution.ExecutionEngine;
import dev.xdark.ssvm.filesystem.FileManager;
import dev.xdark.ssvm.invoke.InvocationUtil;
import dev.xdark.ssvm.memory.management.MemoryManager;
import dev.xdark.ssvm.mirror.type.JavaClass;
import dev.xdark.ssvm.operation.VMOperations;
import dev.xdark.ssvm.symbol.Primitives;
import dev.xdark.ssvm.symbol.Symbols;
import dev.xdark.ssvm.thread.ThreadManager;
import dev.xdark.ssvm.util.Reflection;

import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import uwu.narumi.deobfuscator.api.classpath.CombinedClassProvider;
import uwu.narumi.deobfuscator.api.context.Context;

/**
 * A wrapper for {@link VirtualMachine} with some additional features and patches
 */
public class SandBox {

  private static final Logger LOGGER = LogManager.getLogger(SandBox.class);

  private final VirtualMachine vm;
  private final SupplyingClassLoaderInstaller.DataSupplier dataSupplier;
  private final MemoryManager memoryManager;
  private final SupplyingClassLoaderInstaller.Helper helper;
  private final InvocationUtil invocationUtil;

  public SandBox(Context context) {
    // Install all classes from deobfuscator context
    this(new ClasspathDataSupplier(
        // We need to use compiled classes as they are already compiled
        new CombinedClassProvider(context.getCompiledClasses(), context.getLibraries())
    ));
  }

  public SandBox(SupplyingClassLoaderInstaller.DataSupplier dataSupplier) {
    this(dataSupplier, new VirtualMachine());
  }

  public SandBox(SupplyingClassLoaderInstaller.DataSupplier dataSupplier, VirtualMachine vm) {
    LOGGER.info("Initializing SSVM sandbox...");
    this.dataSupplier = dataSupplier;
    this.vm = vm;

    try {
      this.vm.initialize();
      this.vm.bootstrap();
      this.memoryManager = vm.getMemoryManager();
      // Install all classes from data supplier
      this.helper = SupplyingClassLoaderInstaller.install(vm, this.dataSupplier);
      this.invocationUtil = InvocationUtil.create(vm);
    } catch (Exception ex) {
      LOGGER.error("SSVM bootstrap failed. Make sure that you run this deobfuscator on java 17");

      throw new RuntimeException(ex);
    }
    LOGGER.info("Initialized SSVM sandbox");
  }

  public VirtualMachine vm() {
    return vm;
  }

  public VMInterface getVMInterface() {
    return vm.getInterface();
  }

  public MemoryManager getMemoryManager() {
    return memoryManager;
  }

  public SupplyingClassLoaderInstaller.Helper getHelper() {
    return helper;
  }

  public InvocationUtil getInvocationUtil() {
    return invocationUtil;
  }

  public Symbols getSymbols() {
    return vm.getSymbols();
  }

  public Primitives getPrimitives() {
    return vm.getPrimitives();
  }

  public VMOperations getOperations() {
    return vm.getOperations();
  }

  public LinkResolver getLinkResolver() {
    return vm.getLinkResolver();
  }

  public RuntimeResolver getRuntimeResolver() {
    return vm.getRuntimeResolver();
  }

  public Reflection getReflection() {
    return vm.getReflection();
  }

  public ThreadManager getThreadManager() {
    return vm.getThreadManager();
  }

  public FileManager getFileManager() {
    return vm.getFileManager();
  }

  public ExecutionEngine getExecutionEngine() {
    return vm.getExecutionEngine();
  }

  /**
   * Gets all classes from {@link Context} that were used by sandbox
   */
  public List<JavaClass> getUsedCustomClasses() {
    return this.vm.getClassStorage().list().stream()
        .filter(clazz -> this.dataSupplier.getClass(clazz.getName()) != null)
        .toList();
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/AsmHelper.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import java.util.*;
import java.util.function.Predicate;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.Value;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.asm.MethodRef;
import uwu.narumi.deobfuscator.api.context.Context;

public class AsmHelper implements Opcodes {

  /**
   * Very useful utility that converts number to corresponding ASM instruction.
   *
   * @param number The number
   * @return An ASM instruction that represents this number
   */
  public static AbstractInsnNode numberInsn(int number) {
    if (number >= -1 && number <= 5) {
      return new InsnNode(number + 3);
    } else if (number >= -128 && number <= 127) {
      return new IntInsnNode(BIPUSH, number);
    } else if (number >= -32768 && number <= 32767) {
      return new IntInsnNode(SIPUSH, number);
    } else {
      return new LdcInsnNode(number);
    }
  }

  public static AbstractInsnNode numberInsn(long number) {
    if (number >= 0 && number <= 1) {
      return new InsnNode((int) (number + 9));
    } else {
      return new LdcInsnNode(number);
    }
  }

  public static AbstractInsnNode numberInsn(float number) {
    if (number == 0 || number == 1 || number == 2) {
      return new InsnNode((int) (number + 11));
    } else {
      return new LdcInsnNode(number);
    }
  }

  public static AbstractInsnNode numberInsn(double number) {
    if (number == 0 || number == 1) {
      return new InsnNode((int) (number + 14));
    } else {
      return new LdcInsnNode(number);
    }
  }

  public static AbstractInsnNode numberInsn(Number number) {
    if (number instanceof Integer || number instanceof Byte || number instanceof Short) {
      return numberInsn(number.intValue());
    } else if (number instanceof Long) {
      return numberInsn(number.longValue());
    } else if (number instanceof Float) {
      return numberInsn(number.floatValue());
    } else if (number instanceof Double) {
      return numberInsn(number.doubleValue());
    }

    throw new IllegalArgumentException();
  }

  public static void visitNumber(MethodVisitor methodVisitor, int number) {
    if (number >= -1 && number <= 5) {
      methodVisitor.visitInsn(number + 3);
    } else if (number >= -128 && number <= 127) {
      methodVisitor.visitIntInsn(BIPUSH, number);
    } else if (number >= -32768 && number <= 32767) {
      methodVisitor.visitIntInsn(SIPUSH, number);
    } else {
      methodVisitor.visitLdcInsn(number);
    }
  }

  public static void visitNumber(MethodVisitor methodVisitor, long number) {
    if (number >= 0 && number <= 1) {
      methodVisitor.visitInsn((int) (number + 9));
    } else {
      methodVisitor.visitLdcInsn(number);
    }
  }

  public static boolean isAccess(int access, int opcode) {
    return (access & opcode) != 0;
  }

  /**
   * Convert constant value to instruction that represents this constant
   *
   * @param value A constant value
   * @return An instruction that represents this constant
   */
  public static AbstractInsnNode toConstantInsn(Object value) {
    if (value == null)
      return new InsnNode(ACONST_NULL);
    if (value instanceof String || value instanceof Type)
      return new LdcInsnNode(value);
    if (value instanceof Number number)
      return numberInsn(number);
    if (value instanceof Boolean bool)
      return numberInsn(bool ? 1 : 0);
    if (value instanceof Character character)
      return numberInsn(character);

    throw new IllegalArgumentException("Not a constant");
  }

  public static Type getTypeFromPrimitiveCast(MethodInsnNode insn) {
    if (insn.getOpcode() != INVOKEVIRTUAL) throw new IllegalArgumentException("Instruction is not an INVOKEVIRTUAL");

    if (insn.owner.equals("java/lang/Byte") && insn.name.equals("byteValue")) return Type.BYTE_TYPE;
    if (insn.owner.equals("java/lang/Short") && insn.name.equals("shortValue")) return Type.SHORT_TYPE;
    if (insn.owner.equals("java/lang/Integer") && insn.name.equals("intValue")) return Type.INT_TYPE;
    if (insn.owner.equals("java/lang/Long") && insn.name.equals("longValue")) return Type.LONG_TYPE;
    if (insn.owner.equals("java/lang/Double") && insn.name.equals("doubleValue")) return Type.DOUBLE_TYPE;
    if (insn.owner.equals("java/lang/Float") && insn.name.equals("floatValue")) return Type.FLOAT_TYPE;
    if (insn.owner.equals("java/lang/Boolean") && insn.name.equals("booleanValue")) return Type.BOOLEAN_TYPE;

    throw new IllegalStateException("Unexpected value: " + insn.owner+"."+insn.name+insn.desc);
  }

  public static AbstractInsnNode toPop(Value value) {
    return value.getSize() == 1 ? new InsnNode(POP) : new InsnNode(POP2);
  }

  /**
   * Update method descriptor in the current class, a superclass and interfaces
   *
   * @param context Deobfuscator context
   * @param methodContext Method context
   * @param desc New method descriptor
   */
  public static void updateMethodDescriptor(Context context, MethodContext methodContext, String desc) {
    ClassWrapper classWrapper = methodContext.classWrapper();
    MethodNode methodNode = methodContext.methodNode();

    tryUpdateMethodDescriptor(context, classWrapper, methodNode.name, methodNode.desc, desc);
  }

  /**
   * Tries to update method descriptor in the current class, a superclass and interfaces
   *
   * @param context Deobfuscator context
   * @param classWrapper A class to check
   * @param name Method name
   * @param oldDesc Old method descriptor
   * @param newDesc New method descriptor
   */
  private static void tryUpdateMethodDescriptor(Context context, ClassWrapper classWrapper, String name, String oldDesc, String newDesc) {
    // Search superclass
    if (classWrapper.classNode().superName != null) {
      ClassWrapper superClass = context.getClassesMap().get(classWrapper.classNode().superName);
      if (superClass != null) {
        tryUpdateMethodDescriptor(context, superClass, name, oldDesc, newDesc);
      }
    }

    // Search interfaces
    classWrapper.classNode().interfaces.forEach(interfaceName -> {
      ClassWrapper interfaceClass = context.getClassesMap().get(interfaceName);
      if (interfaceClass != null) {
        tryUpdateMethodDescriptor(context, interfaceClass, name, oldDesc, newDesc);
      }
    });

    Optional<MethodNode> optMethodNode = classWrapper.classNode().methods.stream()
        .filter(method -> method.name.equals(name) && method.desc.equals(oldDesc))
        .findFirst();

    // Update method descriptor
    optMethodNode.ifPresent(methodNode -> methodNode.desc = newDesc);
  }

  public static InsnList from(AbstractInsnNode... nodes) {
    InsnList insnList = new InsnList();
    for (AbstractInsnNode node : nodes) {
      insnList.add(node);
    }
    return insnList;
  }

  public static InsnList copy(InsnList insnList) {
    InsnList copiedInsnList = new InsnList();
    for (AbstractInsnNode node : insnList.toArray()) {
      copiedInsnList.add(node.clone(Map.of()));
    }

    return copiedInsnList;
  }

  public static MethodNode copyMethod(MethodNode methodNode) {
    MethodNode copyMethod =
        new MethodNode(
            methodNode.access,
            methodNode.name,
            methodNode.desc,
            methodNode.signature,
            methodNode.exceptions.toArray(new String[0]));
    methodNode.accept(copyMethod);

    return copyMethod;
  }

  public static void removeField(FieldInsnNode fieldInsnNode, Context context) {
    if (!context.getClassesMap().containsKey(fieldInsnNode.owner)) return;

    context
        .getClassesMap()
        .get(fieldInsnNode.owner)
        .fields()
        .removeIf(
            fieldNode ->
                fieldNode.name.equals(fieldInsnNode.name)
                    && fieldNode.desc.equals(fieldInsnNode.desc));
  }

  public static Optional<MethodNode> findMethod(ClassNode classNode, MethodRef methodRef) {
    if (classNode == null || classNode.methods == null) {
      return Optional.empty();
    }
    return classNode.methods.stream()
        .filter(methodNode -> methodNode.name.equals(methodRef.name()))
        .filter(methodNode -> methodNode.desc.equals(methodRef.desc()))
        .findFirst();
  }

  public static Optional<MethodNode> findMethod(
      ClassNode classNode, Predicate<MethodNode> predicate) {
    return classNode.methods == null
        ? Optional.empty()
        : classNode.methods.stream().filter(predicate).findFirst();
  }

  public static Optional<FieldNode> findField(ClassNode classNode, Predicate<FieldNode> predicate) {
    return classNode.methods == null
        ? Optional.empty()
        : classNode.fields.stream().filter(predicate).findFirst();
  }

  public static Optional<MethodNode> findClInit(ClassNode classNode) {
    return findMethod(classNode, methodNode -> methodNode.name.equals("<clinit>"));
  }

  public static List<AbstractInsnNode> getInstructionsBetween(
      AbstractInsnNode start, AbstractInsnNode end) {
    return getInstructionsBetween(start, end, true, true);
  }

  public static List<AbstractInsnNode> getInstructionsBetween(
      AbstractInsnNode start, AbstractInsnNode end, boolean includeStart, boolean includeEnd) {
    List<AbstractInsnNode> instructions = new ArrayList<>();

    if (includeStart) instructions.add(start);

    while ((start = start.getNext()) != null && start != end) {
      instructions.add(start);
    }

    if (includeEnd) instructions.add(end);

    return instructions;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/AsmMathHelper.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import static org.objectweb.asm.Opcodes.*;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.MethodMatch;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;

public final class AsmMathHelper {
  private static final Map<Integer, Predicate<Integer>> ONE_VALUE_CONDITION_PREDICATES = Map.of(
      IFEQ, value -> value == 0,
      IFNE, value -> value != 0,
      IFLT, value -> value < 0,
      IFGE, value -> value >= 0,
      IFGT, value -> value > 0,
      IFLE, value -> value <= 0
  );

  private static final Map<Integer, BiPredicate<Integer, Integer>> TWO_VALUES_VALUE_CONDITION_PREDICATES = Map.of(
      IF_ICMPEQ, Objects::equals,
      IF_ICMPNE, (first, second) -> !Objects.equals(first, second),
      IF_ICMPLT, (first, second) -> first < second,
      IF_ICMPGE, (first, second) -> first >= second,
      IF_ICMPGT, (first, second) -> first > second,
      IF_ICMPLE, (first, second) -> first <= second
  );

  // Binary operations means that instructions takes two values from stack
  private static final Map<Integer, BiFunction<Number, Number, Number>> MATH_BINARY_OPERATIONS = Map.ofEntries(
      /// Math operations ///

      // Integer
      Map.entry(IADD, (first, second) -> first.intValue() + second.intValue()),
      Map.entry(ISUB, (first, second) -> first.intValue() - second.intValue()),
      Map.entry(IMUL, (first, second) -> first.intValue() * second.intValue()),
      Map.entry(IDIV, (first, second) -> first.intValue() / second.intValue()),
      Map.entry(IREM, (first, second) -> first.intValue() % second.intValue()),
      Map.entry(IXOR, (first, second) -> first.intValue() ^ second.intValue()),
      Map.entry(IAND, (first, second) -> first.intValue() & second.intValue()),
      Map.entry(IOR, (first, second) -> first.intValue() | second.intValue()),
      Map.entry(ISHL, (first, second) -> first.intValue() << second.intValue()),
      Map.entry(ISHR, (first, second) -> first.intValue() >> second.intValue()),
      Map.entry(IUSHR, (first, second) -> first.intValue() >>> second.intValue()),
      // Long
      Map.entry(LADD, (first, second) -> first.longValue() + second.longValue()),
      Map.entry(LSUB, (first, second) -> first.longValue() - second.longValue()),
      Map.entry(LMUL, (first, second) -> first.longValue() * second.longValue()),
      Map.entry(LDIV, (first, second) -> first.longValue() / second.longValue()),
      Map.entry(LREM, (first, second) -> first.longValue() % second.longValue()),
      Map.entry(LXOR, (first, second) -> first.longValue() ^ second.longValue()),
      Map.entry(LAND, (first, second) -> first.longValue() & second.longValue()),
      Map.entry(LOR, (first, second) -> first.longValue() | second.longValue()),
      Map.entry(LSHL, (first, second) -> first.longValue() << second.longValue()),
      Map.entry(LSHR, (first, second) -> first.longValue() >> second.longValue()),
      Map.entry(LUSHR, (first, second) -> first.longValue() >>> second.longValue()),
      // Float
      Map.entry(FADD, (first, second) -> first.floatValue() + second.floatValue()),
      Map.entry(FSUB, (first, second) -> first.floatValue() - second.floatValue()),
      Map.entry(FMUL, (first, second) -> first.floatValue() * second.floatValue()),
      Map.entry(FDIV, (first, second) -> first.floatValue() / second.floatValue()),
      Map.entry(FREM, (first, second) -> first.floatValue() % second.floatValue()),
      // Double
      Map.entry(DADD, (first, second) -> first.doubleValue() + second.doubleValue()),
      Map.entry(DSUB, (first, second) -> first.doubleValue() - second.doubleValue()),
      Map.entry(DMUL, (first, second) -> first.doubleValue() * second.doubleValue()),
      Map.entry(DDIV, (first, second) -> first.doubleValue() / second.doubleValue()),
      Map.entry(DREM, (first, second) -> first.doubleValue() % second.doubleValue()),

      /// Compare operations ///
      Map.entry(LCMP, (first, second) -> Long.compare(first.longValue(), second.longValue())),
      Map.entry(FCMPL, (first, second) -> Float.isNaN(first.floatValue()) || Float.isNaN(second.floatValue()) ? -1 : Float.compare(first.floatValue(), second.floatValue())),
      Map.entry(FCMPG, (first, second) -> Float.isNaN(first.floatValue()) || Float.isNaN(second.floatValue()) ? 1 : Float.compare(first.floatValue(), second.floatValue())),
      Map.entry(DCMPL, (first, second) -> Double.isNaN(first.doubleValue()) || Double.isNaN(second.doubleValue()) ? -1 : Double.compare(first.doubleValue(), second.doubleValue())),
      Map.entry(DCMPG, (first, second) -> Double.isNaN(first.doubleValue()) || Double.isNaN(second.doubleValue()) ? 1 : Double.compare(first.doubleValue(), second.doubleValue()))
  );

  // Unary operations means that instructions takes one value from stack
  private static final Map<Integer, Function<Number, Number>> MATH_UNARY_OPERATIONS = Map.ofEntries(
      // Integer
      Map.entry(INEG, number -> -number.intValue()),
      Map.entry(I2B, Number::byteValue),
      Map.entry(I2C, Number::shortValue),
      Map.entry(I2D, Number::doubleValue),
      Map.entry(I2F, Number::floatValue),
      Map.entry(I2L, Number::longValue),
      Map.entry(I2S, Number::shortValue),
      // Long
      Map.entry(LNEG, number -> -number.longValue()),
      Map.entry(L2D, Number::doubleValue),
      Map.entry(L2F, Number::floatValue),
      Map.entry(L2I, Number::intValue),
      // Float
      Map.entry(FNEG, number -> -number.floatValue()),
      Map.entry(F2D, Number::doubleValue),
      Map.entry(F2I, Number::intValue),
      Map.entry(F2L, Number::longValue),
      // Double
      Map.entry(DNEG, number -> -number.doubleValue()),
      Map.entry(D2F, Number::floatValue),
      Map.entry(D2I, Number::intValue),
      Map.entry(D2L, Number::longValue)
  );

  public static final Match STRING_LENGTH =
      MethodMatch.invokeVirtual()
          .owner("java/lang/String")
          .name("length")
          .desc("()I")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            if (!originalInsn.isString()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(originalInsn.asString().length())
            );
            return true;
          });

  public static final Match STRING_HASHCODE =
      MethodMatch.invokeVirtual()
          .owner("java/lang/String")
          .name("hashCode")
          .desc("()I")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            if (!originalInsn.isString()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(originalInsn.asString().hashCode())
            );
            return true;
          });

  public static final Match STRING_TO_INTEGER =
      MethodMatch.invokeStatic()
          .owner("java/lang/Integer")
          .name("parseInt", "valueOf")
          .desc("(Ljava/lang/String;)I")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Integer#parseInt(String)
            if (!originalInsn.isString()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Integer.parseInt(originalInsn.asString()))
            );
            return true;
          });

  public static final Match STRING_TO_INTEGER_RADIX =
      MethodMatch.invokeStatic()
          .owner("java/lang/Integer")
          .name("parseInt", "valueOf")
          .desc("(Ljava/lang/String;I)I")
          .defineTransformation(context -> {
            // Get values from stack
            OriginalSourceValue firstValue = context.frame().getStack(context.frame().getStackSize() - 2);
            OriginalSourceValue originalFirstValue = firstValue.originalSource;
            OriginalSourceValue secondValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSecondValue = secondValue.originalSource;
            if (!originalFirstValue.isOneWayProduced() || !originalSecondValue.isOneWayProduced()) return false;

            AbstractInsnNode originalFirstInsn = originalFirstValue.getProducer();
            AbstractInsnNode originalSecondInsn = originalSecondValue.getProducer();

            // Integer#parseInt(String, int)
            if (!originalFirstInsn.isString() || !originalSecondInsn.isInteger()) return false;

            context.pop(2);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(
                    Integer.parseInt(originalFirstInsn.asString(), originalSecondInsn.asInteger())
                )
            );
            return true;
          });

  public static final Match INTEGER_REVERSE =
      MethodMatch.invokeStatic()
          .owner("java/lang/Integer")
          .name("reverse")
          .desc("(I)I")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Integer#reverse(int)
            if (!originalInsn.isInteger()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Integer.reverse(originalInsn.asInteger()))
            );
            return true;
          });

  public static final Match LONG_REVERSE =
      MethodMatch.invokeStatic()
          .owner("java/lang/Long")
          .name("reverse")
          .desc("(J)J")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Long#reverse(long)
            if (!originalInsn.isLong()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Long.reverse(originalInsn.asLong()))
            );
            return true;
          });

  public static final Match FLOAT_TO_BITS =
      MethodMatch.invokeStatic()
          .owner("java/lang/Float")
          .name("floatToIntBits")
          .desc("(F)I")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Float#floatToIntBits(float)
            if (!originalInsn.isFloat()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Float.floatToIntBits(originalInsn.asFloat()))
            );
            return true;
          });

  public static final Match BITS_TO_FLOAT =
      MethodMatch.invokeStatic()
          .owner("java/lang/Float")
          .name("intBitsToFloat")
          .desc("(I)F")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Float#intBitsToFloat(int)
            if (!originalInsn.isInteger()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Float.intBitsToFloat(originalInsn.asInteger()))
            );
            return true;
          });

  public static final Match DOUBLE_TO_BITS =
      MethodMatch.invokeStatic()
          .owner("java/lang/Double")
          .name("doubleToLongBits")
          .desc("(D)J")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Double#doubleToLongBits(double)
            if (!originalInsn.isDouble()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Double.doubleToLongBits(originalInsn.asDouble()))
            );
            return true;
          });

  public static final Match BITS_TO_DOUBLE =
      MethodMatch.invokeStatic()
          .owner("java/lang/Double")
          .name("longBitsToDouble")
          .desc("(J)D")
          .defineTransformation(context -> {
            // Get value from stack
            OriginalSourceValue sourceValue = context.frame().getStack(context.frame().getStackSize() - 1);
            OriginalSourceValue originalSourceValue = sourceValue.originalSource;
            if (!originalSourceValue.isOneWayProduced()) return false;

            AbstractInsnNode originalInsn = originalSourceValue.getProducer();
            // Double#longBitsToDouble(long)
            if (!originalInsn.isLong()) return false;

            context.pop(1);
            context.methodNode().instructions.set(
                context.insn(),
                AsmHelper.numberInsn(Double.longBitsToDouble(originalInsn.asLong()))
            );
            return true;
          });

  public static final List<Match> METHOD_CALLS_ON_LITERALS = List.of(
      STRING_LENGTH,
      STRING_HASHCODE,
      STRING_TO_INTEGER,
      STRING_TO_INTEGER_RADIX,
      INTEGER_REVERSE,
      LONG_REVERSE,
      FLOAT_TO_BITS,
      BITS_TO_FLOAT,
      DOUBLE_TO_BITS,
      BITS_TO_DOUBLE
  );

  private AsmMathHelper() {
    throw new IllegalArgumentException();
  }

  public static boolean isMathBinaryOperation(int opcode) {
    return MATH_BINARY_OPERATIONS.containsKey(opcode);
  }

  public static Number mathBinaryOperation(Number first, Number second, int opcode) {
    return MATH_BINARY_OPERATIONS.get(opcode).apply(first, second);
  }

  public static boolean isMathUnaryOperation(int opcode) {
    return MATH_UNARY_OPERATIONS.containsKey(opcode);
  }

  public static Number mathUnaryOperation(Number number, int opcode) {
    return MATH_UNARY_OPERATIONS.get(opcode).apply(number);
  }

  public static boolean isOneValueCondition(int opcode) {
    return ONE_VALUE_CONDITION_PREDICATES.containsKey(opcode);
  }

  public static boolean condition(int value, int opcode) {
    return ONE_VALUE_CONDITION_PREDICATES.get(opcode).test(value);
  }

  public static boolean isTwoValuesCondition(int opcode) {
    return TWO_VALUES_VALUE_CONDITION_PREDICATES.containsKey(opcode);
  }

  public static boolean condition(int first, int second, int opcode) {
    return TWO_VALUES_VALUE_CONDITION_PREDICATES.get(opcode).test(first, second);
  }

  /**
   * Predict if statement result
   */
  public static Optional<Boolean> predictIf(JumpInsnNode jumpInsn, Frame<OriginalSourceValue> frame) {
    if (AsmMathHelper.isOneValueCondition(jumpInsn.getOpcode())) {
      // One-value if statement

      // Get instruction from stack that is passed to if statement
      OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);
      OriginalSourceValue.ConstantValue constantValue = sourceValue.getConstantValue();
      if (constantValue == null) return Optional.empty();

      // Process if statement
      if (constantValue.get() instanceof Integer value) {
        boolean ifResult = AsmMathHelper.condition(
            value, // Value
            jumpInsn.getOpcode() // Opcode
        );

        return Optional.of(ifResult);
      }
    } else if (AsmMathHelper.isTwoValuesCondition(jumpInsn.getOpcode())) {
      // Two-value if statements

      // Get instructions from stack that are passed to if statement
      OriginalSourceValue sourceValue1 = frame.getStack(frame.getStackSize() - 2);
      OriginalSourceValue sourceValue2 = frame.getStack(frame.getStackSize() - 1);
      OriginalSourceValue.ConstantValue constValue1 = sourceValue1.getConstantValue();
      OriginalSourceValue.ConstantValue constValue2 = sourceValue2.getConstantValue();
      if (constValue1 == null || constValue2 == null) return Optional.empty();

      // Process if statement
      if (constValue1.get() instanceof Integer value1 && constValue2.get() instanceof Integer value2) {
        boolean ifResult = AsmMathHelper.condition(
            value1, // First value
            value2, // Second value
            jumpInsn.getOpcode() // Opcode
        );

        return Optional.of(ifResult);
      }
    }

    return Optional.empty();
  }

  /**
   * Predict lookup switch jump
   */
  public static Optional<LabelNode> predictLookupSwitch(LookupSwitchInsnNode lookupSwitchInsn, Frame<OriginalSourceValue> frame) {
    OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);
    OriginalSourceValue.ConstantValue constantValue = sourceValue.getConstantValue();
    if (constantValue == null) return Optional.empty();

    if (constantValue.get() instanceof Integer value) {
      int index = lookupSwitchInsn.keys.indexOf(value);

      if (index == -1) {
        // Jump to default
        return Optional.of(lookupSwitchInsn.dflt);
      } else {
        // Match found! Jump to target
        LabelNode targetLabel = lookupSwitchInsn.labels.get(index);
        return Optional.of(targetLabel);
      }
    }

    return Optional.empty();
  }

  /**
   * Predict table switch jump
   */
  public static Optional<LabelNode> predictTableSwitch(TableSwitchInsnNode tableSwitchInsn, Frame<OriginalSourceValue> frame) {
    OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);
    OriginalSourceValue.ConstantValue constantValue = sourceValue.getConstantValue();
    if (constantValue == null) return Optional.empty();

    if (constantValue.get() instanceof Integer value) {
      int index = value - tableSwitchInsn.min;

      if (index < 0 || index >= tableSwitchInsn.labels.size()) {
        // Jump to default
        return Optional.of(tableSwitchInsn.dflt);
      } else {
        // Match found! Jump to target
        LabelNode targetLabel = tableSwitchInsn.labels.get(index);
        return Optional.of(targetLabel);
      }
    }

    return Optional.empty();
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/ClassHelper.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import java.util.ArrayList;

import software.coley.cafedude.InvalidClassException;
import software.coley.cafedude.classfile.ClassFile;
import software.coley.cafedude.io.ClassFileReader;
import software.coley.cafedude.io.ClassFileWriter;
import org.intellij.lang.annotations.MagicConstant;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;

public final class ClassHelper {

  private ClassHelper() {
  }

  public static boolean isClass(String fileName, byte[] bytes) {
    return isClass(bytes) && (fileName.endsWith(".class") || fileName.endsWith(".class/"));
  }

  public static boolean isClass(byte[] bytes) {
    return bytes.length >= 4
        && String.format("%02X%02X%02X%02X", bytes[0], bytes[1], bytes[2], bytes[3]).equals("CAFEBABE");
  }

  /**
   * Load class from bytes
   *
   * @param pathInJar        Relative path of a class in a jar
   * @param bytes            Class bytes
   * @param classReaderFlags {@link ClassReader} flags
   */
  public static ClassWrapper loadClass(
      String pathInJar,
      byte[] bytes,
      @MagicConstant(flagsFromClass = ClassReader.class) int classReaderFlags
  ) {
    return new ClassWrapper(pathInJar, new ClassReader(bytes), classReaderFlags);
  }

  /**
   * Loads class from unknown sources. Applies fixes to bytecode using CAFED00D.
   *
   * @param pathInJar        Relative path of a class in a jar
   * @param bytes            Class bytes
   * @param classReaderFlags {@link ClassReader} flags
   */
  public static ClassWrapper loadUnknownClass(
      String pathInJar,
      byte[] bytes,
      @MagicConstant(flagsFromClass = ClassReader.class) int classReaderFlags
  ) throws InvalidClassException {
    // Fix class
    bytes = fixClass(bytes);

    return loadClass(pathInJar, bytes, classReaderFlags);
  }

  /**
   * Loads only class info (like class name, superclass, interfaces, etc.) without any code.
   *
   * @param bytes Class bytes
   * @return {@link ClassNode} with class info only
   */
  public static ClassNode loadClassInfo(byte[] bytes) {
    ClassNode classNode = new ClassNode();
    new ClassReader(bytes).accept(classNode, ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);
    return classNode;
  }

  /**
   * Loads class info from unknown sources. Applies fixes to bytecode using CAFED00D.
   *
   * @param bytes Class bytes
   * @return {@link ClassNode} with class info only
   */
  public static ClassNode loadUnknownClassInfo(byte[] bytes) throws InvalidClassException {
    // Fix class
    bytes = fixClass(bytes);

    return loadClassInfo(bytes);
  }

  public static byte[] fixClass(byte[] bytes) throws InvalidClassException {
    ClassFileReader classFileReader = new ClassFileReader();
    ClassFile classFile = classFileReader.read(bytes);
    bytes = new ClassFileWriter().write(classFile);

    return bytes;
  }

  public static ClassNode copy(ClassNode classNode) {
    if (classNode == null) return null;

    ClassNode copy = new ClassNode();
    copy.visit(
        classNode.version,
        classNode.access,
        classNode.name,
        null,
        classNode.superName,
        classNode.interfaces.toArray(new String[0]));
    classNode.accept(copy);

    copy.methods = new ArrayList<>();
    copy.fields = new ArrayList<>();

    classNode.methods.forEach(
        methodNode -> {
          MethodNode copyMethod =
              new MethodNode(
                  methodNode.access,
                  methodNode.name,
                  methodNode.desc,
                  null,
                  methodNode.exceptions.toArray(new String[0]));
          methodNode.accept(copyMethod);
          copy.methods.add(copyMethod);
        });

    classNode.fields.forEach(
        fieldNode ->
            copy.fields.add(
                new FieldNode(
                    fieldNode.access, fieldNode.name, fieldNode.desc, null, fieldNode.value)));

    return copy;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/FileHelper.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.function.BiConsumer;
import java.util.jar.JarFile;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public final class FileHelper {

  private static final Logger LOGGER = LogManager.getLogger(FileHelper.class);

  private FileHelper() {
  }

  public static void loadFilesFromZip(Path path, BiConsumer<String, byte[]> consumer) {
    try (JarFile zipFile = new JarFile(path.toFile())) {
      zipFile.entries()
          .asIterator()
          .forEachRemaining(zipEntry -> {
            if (zipEntry.isDirectory()) return;

            try {
              consumer.accept(zipEntry.getName(), zipFile.getInputStream(zipEntry).readAllBytes());
            } catch (Exception e) {
              LOGGER.error("Could not load ZipEntry: {}", zipEntry.getName());
              LOGGER.debug("Error", e);
            }
          });
    } catch (Exception e) {
      LOGGER.error("Could not load file: {}", path);
      throw new RuntimeException(e);
    }
  }

  public static void deleteDirectory(Path dir) {
    try {
      if (Files.notExists(dir))
        return;

      Files.walkFileTree(dir, new SimpleFileVisitor<>() {
        @Override
        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
          Files.delete(dir);
          return FileVisitResult.CONTINUE;
        }

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
          Files.delete(file);
          return FileVisitResult.CONTINUE;
        }
      });
    } catch (Exception e) {
      throw new RuntimeException("Can't delete directory", e);
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/FramedInstructionsStream.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import org.jetbrains.annotations.Contract;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.MethodNode;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * Framed instructions stream that gives {@link InsnContext} and computing all frames for you. Also, this class
 * iterate over classes and methods ASYNC, and instructions SYNC. This can really speed up computing frames for methods.
 */
public class FramedInstructionsStream {
  public static FramedInstructionsStream of(Transformer transformer) {
    return of(transformer.scope(), transformer.context());
  }

  public static FramedInstructionsStream of(ClassWrapper scope, Context context) {
    return new FramedInstructionsStream(scope, context);
  }

  private final ClassWrapper scope;
  private final Context context;

  private Function<Stream<ClassWrapper>, Stream<ClassWrapper>> classesStreamModifier = Function.identity();
  private Function<Stream<MethodNode>, Stream<MethodNode>> methodsStreamModifier = Function.identity();
  private Function<Stream<AbstractInsnNode>, Stream<AbstractInsnNode>> instructionsStreamModifier = Function.identity();
  private boolean forceSync = false;

  private FramedInstructionsStream(ClassWrapper scope, Context context) {
    this.scope = scope;
    this.context = context;
  }

  @Contract("_ -> this")
  public FramedInstructionsStream editClassesStream(Function<Stream<ClassWrapper>, Stream<ClassWrapper>> stream) {
    this.classesStreamModifier = stream;
    return this;
  }

  @Contract("_ -> this")
  public FramedInstructionsStream editMethodsStream(Function<Stream<MethodNode>, Stream<MethodNode>> stream) {
    this.methodsStreamModifier = stream;
    return this;
  }

  @Contract("_ -> this")
  public FramedInstructionsStream editInstructionsStream(Function<Stream<AbstractInsnNode>, Stream<AbstractInsnNode>> stream) {
    this.instructionsStreamModifier = stream;
    return this;
  }

  @Contract(" -> this")
  public FramedInstructionsStream forceSync() {
    this.forceSync = true;
    return this;
  }

  public void forEach(Consumer<InsnContext> consumer) {
    // Iterate over classes in parallel
    this.classesStreamModifier.apply(this.forceSync ? this.context.scopedClasses(this.scope).stream() : this.context.scopedClasses(this.scope).parallelStream())
        // Iterate over methods in parallel
        .forEach(classWrapper -> this.methodsStreamModifier.apply(this.forceSync ? classWrapper.methods().stream() : classWrapper.methods().parallelStream())
            .forEach(methodNode -> {
              // Skip if no instructions
              if (instructionsStreamModifier.apply(Arrays.stream(methodNode.instructions.toArray())).findAny().isEmpty()) return;

              // Get frames of the method
              MethodContext methodContext = MethodContext.framed(classWrapper, methodNode);

              // Iterate over instructions SYNC
              instructionsStreamModifier.apply(Arrays.stream(methodNode.instructions.toArray()))
                  .forEach(insn -> {
                    InsnContext insnContext = methodContext.newInsnContext(insn);
                    // Check if frame exists
                    if (insnContext.frame() == null) return;

                    // Pass instruction context to consumer
                    consumer.accept(insnContext);
                  });
            }));
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/helper/MethodHelper.java`:

```java
package uwu.narumi.deobfuscator.api.helper;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Unmodifiable;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.BasicInterpreter;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.Value;
import uwu.narumi.deobfuscator.api.asm.NamedOpcodes;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.JumpPredictingAnalyzer;
import org.objectweb.asm.tree.analysis.OriginalSourceInterpreter;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MethodHelper implements Opcodes {
  /**
   * Analyzes the stack frames of the method using {@link OriginalSourceInterpreter}
   *
   * @param classNode The owner class
   * @param methodNode Method
   * @return A map which corresponds to: instruction -> its own stack frame
   */
  @NotNull
  @Unmodifiable
  public static Map<AbstractInsnNode, Frame<OriginalSourceValue>> analyzeSource(
      ClassNode classNode, MethodNode methodNode
  ) {
    Map<AbstractInsnNode, Frame<OriginalSourceValue>> frames = new HashMap<>();
    Frame<OriginalSourceValue>[] framesArray;
    try {
      framesArray = new JumpPredictingAnalyzer(new OriginalSourceInterpreter()).analyze(classNode.name, methodNode);
    } catch (AnalyzerException e) {
      throw new RuntimeException(e);
    }
    for (int i = 0; i < framesArray.length; i++) {
      frames.put(methodNode.instructions.get(i), framesArray[i]);
    }
    return Collections.unmodifiableMap(frames);
  }

  /**
   * Analyzes the stack frames of the method using {@link BasicInterpreter}
   *
   * @param classNode The owner class
   * @param methodNode Method
   * @return A map which corresponds to: instruction -> its own stack frame
   */
  @NotNull
  @Unmodifiable
  public static Map<AbstractInsnNode, Frame<BasicValue>> analyzeBasic(
      ClassNode classNode, MethodNode methodNode
  ) {
    Map<AbstractInsnNode, Frame<BasicValue>> frames = new HashMap<>();
    Frame<BasicValue>[] framesArray;
    try {
      framesArray = new Analyzer<>(new BasicInterpreter()).analyze(classNode.name, methodNode);
    } catch (AnalyzerException e) {
      throw new RuntimeException(e);
    }
    for (int i = 0; i < framesArray.length; i++) {
      frames.put(methodNode.instructions.get(i), framesArray[i]);
    }
    return Collections.unmodifiableMap(frames);
  }

  public static List<String> prettyInsnList(InsnList insnList) {
    return prettyInsnList(Arrays.asList(insnList.toArray()));
  }

  public static List<String> prettyInsnList(List<AbstractInsnNode> insnList) {
    return insnList.stream().map(insn -> NamedOpcodes.map(insn.getOpcode())).toList();
  }

  /**
   * Gets local variable table of the method. Sorted ascending
   */
  public static List<Integer> getLocalVariableTable(MethodNode methodNode) {
    List<Integer> localVariableTable = new ArrayList<>();
    for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
      if (insn instanceof VarInsnNode varInsn) {
        if (!localVariableTable.contains(varInsn.var)) {
          localVariableTable.add(varInsn.var);
        }
      } else if (insn instanceof IincInsnNode iincInsn) {
        if (!localVariableTable.contains(iincInsn.var)) {
          localVariableTable.add(iincInsn.var);
        }
      }
    }

    // Sort ascending
    localVariableTable.sort(Comparator.naturalOrder());

    return localVariableTable;
  }

  /**
   * Gets var index of the first parameter of the passed method
   */
  public static int getFirstParameterIdx(MethodNode methodNode) {
    // When method is static, then the first var index is actually a reference to "this"
    return (methodNode.access & ACC_STATIC) != 0 ? 0 : 1;
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/inheritance/InheritanceGraph.java`:

```java
package uwu.narumi.deobfuscator.api.inheritance;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import uwu.narumi.deobfuscator.api.classpath.ClassProvider;
import uwu.narumi.deobfuscator.api.classpath.CombinedClassProvider;
import uwu.narumi.deobfuscator.api.classpath.JvmClassProvider;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Class inheritance graph utility.
 *
 * @author Matt Coley
 */
// Copied from https://github.com/Col-E/Recaf/blob/ac6e07cbaf168a1f2093e71a39215bda8a00402d/recaf-core/src/main/java/software/coley/recaf/services/inheritance/InheritanceGraph.java
public class InheritanceGraph {
  private static final Logger LOGGER = LogManager.getLogger();

  /** Vertex used for classes that are not found in the workspace. */
  private static final InheritanceVertex STUB = new InheritanceStubVertex();
  private static final String OBJECT = "java/lang/Object";
  private final Map<String, Set<String>> parentToChild = new ConcurrentHashMap<>();
  private final Map<String, InheritanceVertex> vertices = new ConcurrentHashMap<>();
  private final Set<String> stubs = ConcurrentHashMap.newKeySet();
  private final Function<String, InheritanceVertex> vertexProvider = createVertexProvider();
  private final ClassProvider classProvider;

  /**
   * Create an inheritance graph.
   */
  public InheritanceGraph(@NotNull ClassProvider classProvider) {
    this.classProvider = new CombinedClassProvider(classProvider, JvmClassProvider.INSTANCE);

    // Populate downwards (parent --> child) lookup
    refreshChildLookup();
  }

  /**
   * Refresh parent-to-child lookup.
   */
  private void refreshChildLookup() {
    // Clear
    parentToChild.clear();

    // Repopulate
    classProvider.getLoadedClasses().stream()
        .map(classProvider::getClassInfo)
        .filter(Objects::nonNull)
        .forEach(this::populateParentToChildLookup);
  }

  /**
   * Populate a references from the given child class to the parent class.
   *
   * @param name
   * 		Child class name.
   * @param parentName
   * 		Parent class name.
   */
  private void populateParentToChildLookup(@NotNull String name, @NotNull String parentName) {
    parentToChild.computeIfAbsent(parentName, k -> ConcurrentHashMap.newKeySet()).add(name);
  }

  /**
   * Populate all references from the given child class to its parents.
   *
   * @param info
   * 		Child class.
   */
  private void populateParentToChildLookup(@NotNull ClassNode info) {
    populateParentToChildLookup(info, Collections.newSetFromMap(new IdentityHashMap<>()));
  }

  /**
   * Populate all references from the given child class to its parents.
   *
   * @param info
   * 		Child class.
   * @param visited
   * 		Classes already visited in population.
   */
  private void populateParentToChildLookup(@NotNull ClassNode info, @NotNull Set<ClassNode> visited) {
    // Skip if already visited
    if (!visited.add(info))
      return;

    // Skip module classes
    if ((info.access & Opcodes.ACC_MODULE) != 0)
      return;

    // Add direct parent
    String name = info.name;
    String superName = info.superName;
    if (superName != null)
      populateParentToChildLookup(name, superName);

    // Visit parent
    InheritanceVertex superVertex = vertexProvider.apply(superName);
    if (superVertex != null && !superVertex.isJavaLangObject() && !superVertex.isLoop())
      populateParentToChildLookup(superVertex.getValue(), visited);

    // Add direct interfaces
    for (String itf : info.interfaces) {
      populateParentToChildLookup(name, itf);

      // Visit interfaces
      InheritanceVertex interfaceVertex = vertexProvider.apply(itf);
      if (interfaceVertex != null)
        populateParentToChildLookup(interfaceVertex.getValue(), visited);
    }
  }

  /**
   * Remove all references from the given child class to its parents.
   *
   * @param info
   * 		Child class.
   */
  private void removeParentToChildLookup(@NotNull ClassNode info) {
    String superName = info.superName;
    if (superName != null)
      removeParentToChildLookup(info.name, superName);
    for (String itf : info.interfaces)
      removeParentToChildLookup(info.name, itf);
  }

  /**
   * Remove a references from the given child class to the parent class.
   *
   * @param name
   * 		Child class name.
   * @param parentName
   * 		Parent class name.
   */
  private void removeParentToChildLookup(@NotNull String name, @NotNull String parentName) {
    Set<String> children = parentToChild.get(parentName);
    if (children != null)
      children.remove(name);
    InheritanceVertex parentVertex = getVertex(parentName);
    InheritanceVertex childVertex = getVertex(name);
    if (parentVertex != null) parentVertex.clearCachedVertices();
    if (childVertex != null) childVertex.clearCachedVertices();
  }

  /**
   * Removes the given class from the graph.
   *
   * @param cls
   * 		Class that was removed.
   */
  private void removeClass(@NotNull ClassNode cls) {
    removeParentToChildLookup(cls);

    String name = cls.name;
    vertices.remove(name);
  }


  /**
   * @param parent
   * 		Parent to find children of.
   *
   * @return Direct extensions/implementations of the given parent.
   */
  @NotNull
  private Set<String> getDirectChildren(@NotNull String parent) {
    return parentToChild.getOrDefault(parent, Collections.emptySet());
  }

  /**
   * @param name
   * 		Class name.
   *
   * @return Vertex in graph of class. {@code null} if no such class was found in the inputs.
   */
  @Nullable
  public InheritanceVertex getVertex(@NotNull String name) {
    InheritanceVertex vertex = vertices.get(name);
    if (vertex == null && !stubs.contains(name)) {
      // Vertex does not exist and was not marked as a stub.
      // We want to look up the vertex for the given class and figure out if its valid or needs to be stubbed.
      InheritanceVertex provided = vertexProvider.apply(name);
      if (provided == STUB || provided == null) {
        // Provider yielded either a stub OR no result. Discard it.
        stubs.add(name);
      } else {
        // Provider yielded a valid vertex. Update the return value and record it in the map.
        vertices.put(name, provided);
        vertex = provided;
      }
    }
    return vertex;
  }

  /**
   * @param name
   * 		Class name.
   * @param includeObject
   *        {@code true} to include {@link Object} as a vertex.
   *
   * @return Complete inheritance family of the class.
   */
  @NotNull
  public Set<InheritanceVertex> getVertexFamily(@NotNull String name, boolean includeObject) {
    InheritanceVertex vertex = getVertex(name);
    if (vertex == null)
      return Collections.emptySet();
    if (vertex.isModule())
      return Collections.singleton(vertex);
    return vertex.getFamily(includeObject);
  }

  /**
   * @param first
   * 		First class name.
   * @param second
   * 		Second class name.
   *
   * @return Common parent of the classes.
   */
  @NotNull
  public String getCommon(@NotNull String first, @NotNull String second) {
    // Full upwards hierarchy for the first
    InheritanceVertex vertex = getVertex(first);
    if (vertex == null) {
      printCantFindClass(first);
      return OBJECT;
    }
    if (OBJECT.equals(first) || OBJECT.equals(second)) {
      return OBJECT;
    }

    Set<String> firstParents = vertex.allParents()
        .map(InheritanceVertex::getName)
        .collect(Collectors.toCollection(LinkedHashSet::new));
    firstParents.add(first);

    // Ensure 'Object' is last
    firstParents.remove(OBJECT);
    firstParents.add(OBJECT);

    // Base case
    if (firstParents.contains(second))
      return second;

    // Iterate over second's parents via breadth-first-search
    Queue<String> queue = new LinkedList<>();
    queue.add(second);
    do {
      // Item to fetch parents of
      String next = queue.poll();
      if (next == null || next.equals(OBJECT))
        break;

      InheritanceVertex nextVertex = getVertex(next);
      if (nextVertex == null) {
        printCantFindClass(next);
        break;
      }

      for (String parent : nextVertex.getParents().stream()
          .map(InheritanceVertex::getName).toList()) {
        if (!parent.equals(OBJECT)) {
          // Parent in the set of visited classes? Then its valid.
          if (firstParents.contains(parent))
            return parent;
          // Queue up the parent
          queue.add(parent);
        }
      }
    } while (!queue.isEmpty());

    // Fallback option
    return OBJECT;
  }

  private void printCantFindClass(String className) {
    LOGGER.warn("Can't find class '{}'. Computed frames might be wrong. " +
        "If you want a runnable deobfuscated jar then add a missing lib using 'DeobfuscatorOptions#libraries'.", className);
  }

  @NotNull
  private Function<String, InheritanceVertex> createVertexProvider() {
    return name -> {
      // Edge case handling for 'java/lang/Object' doing a parent lookup.
      // There is no parent, do not use STUB.
      if (name == null)
        return null;

      // Edge case handling for arrays. There is no object typing of arrays.
      if (name.isEmpty() || name.charAt(0) == '[')
        return null;

      // Find class in workspace, if not found yield stub.
      ClassNode result = this.classProvider.getClassInfo(name);
      if (result == null) {
        return STUB;
      }

      // Map class to vertex.
      //ResourcePathNode resourcePath = result.getPathOfType(WorkspaceResource.class);
      //boolean isPrimary = resourcePath != null && resourcePath.isPrimary();
      //ClassInfo info = result.getValue();
      return new InheritanceVertex(result, this::getVertex, this::getDirectChildren);
    };
  }

  private static class InheritanceStubVertex extends InheritanceVertex {
    private InheritanceStubVertex() {
      super(new ClassNode(), in -> null, in -> null);
    }

    @Override
    public boolean hasField(@NotNull String name, @NotNull String desc) {
      return false;
    }

    @Override
    public boolean hasMethod(@NotNull String name, @NotNull String desc) {
      return false;
    }

    @Override
    public boolean isJavaLangObject() {
      return false;
    }

    @Override
    public boolean isParentOf(@NotNull InheritanceVertex vertex) {
      return false;
    }

    @Override
    public boolean isChildOf(@NotNull InheritanceVertex vertex) {
      return false;
    }

    @Override
    public boolean isIndirectFamilyMember(@NotNull InheritanceVertex vertex) {
      return false;
    }

    @Override
    public boolean isIndirectFamilyMember(@NotNull Set<InheritanceVertex> family, @NotNull InheritanceVertex vertex) {
      return false;
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getFamily(boolean includeObject) {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getAllParents() {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public Stream<InheritanceVertex> allParents() {
      return Stream.empty();
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getParents() {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getAllChildren() {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getChildren() {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public Set<InheritanceVertex> getAllDirectVertices() {
      return Collections.emptySet();
    }

    @NotNull
    @Override
    public String getName() {
      return "$$STUB$$";
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/inheritance/InheritanceVertex.java`:

```java
package uwu.narumi.deobfuscator.api.inheritance;

import org.jetbrains.annotations.NotNull;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Graph element for a class inheritance hierarchy.
 *
 * @author Matt Coley
 */
// Copied from https://github.com/Col-E/Recaf/blob/ac6e07cbaf168a1f2093e71a39215bda8a00402d/recaf-core/src/main/java/software/coley/recaf/services/inheritance/InheritanceVertex.java
public class InheritanceVertex {
  private final Function<String, InheritanceVertex> lookup;
  private final Function<String, Collection<String>> childrenLookup;
  //private final boolean isPrimary;
  private volatile Set<InheritanceVertex> parents;
  private volatile Set<InheritanceVertex> children;
  private ClassNode value;

  /**
   * @param value
   * 		The wrapped value.
   * @param lookup
   * 		Class vertex lookup.
   * @param childrenLookup
   * 		Class child lookup.
   */
  public InheritanceVertex(@NotNull ClassNode value,
                           @NotNull Function<String, InheritanceVertex> lookup,
                           @NotNull Function<String, Collection<String>> childrenLookup) {
    this.value = value;
    this.lookup = lookup;
    this.childrenLookup = childrenLookup;
    //this.isPrimary = isPrimary;
  }

  /**
   * @param name
   * 		Field name.
   * @param desc
   * 		Field descriptor.
   *
   * @return If the field exists in the current vertex.
   */
  public boolean hasField(@NotNull String name, @NotNull String desc) {
    for (FieldNode fn : value.fields)
      if (fn.name.equals(name) && fn.desc.equals(desc))
        return true;
    return false;
  }

  /**
   * @param name
   * 		Field name.
   * @param desc
   * 		Field descriptor.
   *
   * @return If the field exists in the current vertex or in any parent vertex.
   */
  public boolean hasFieldInSelfOrParents(@NotNull String name, @NotNull String desc) {
    if (hasField(name, desc))
      return true;
    return allParents()
        .filter(v -> v != this)
        .anyMatch(parent -> parent.hasFieldInSelfOrParents(name, desc));
  }

  /**
   * @param name
   * 		Field name.
   * @param desc
   * 		Field descriptor.
   *
   * @return If the field exists in the current vertex or in any child vertex.
   */
  public boolean hasFieldInSelfOrChildren(@NotNull String name, @NotNull String desc) {
    if (hasField(name, desc))
      return true;
    return allChildren()
        .filter(v -> v != this)
        .anyMatch(parent -> parent.hasFieldInSelfOrChildren(name, desc));
  }

  /**
   * @param name
   * 		Method name.
   * @param desc
   * 		Method descriptor.
   *
   * @return If the method exists in the current vertex.
   */
  public boolean hasMethod(@NotNull String name, @NotNull String desc) {
    for (MethodNode mn : value.methods)
      if (mn.name.equals(name) && mn.desc.equals(desc))
        return true;
    return false;
  }

  /**
   * @param name
   * 		Method name.
   * @param desc
   * 		Method descriptor.
   *
   * @return If the method exists in the current vertex or in any parent vertex.
   */
  public boolean hasMethodInSelfOrParents(@NotNull String name, @NotNull String desc) {
    if (hasMethod(name, desc))
      return true;
    return allParents()
        .filter(v -> v != this)
        .anyMatch(parent -> parent.hasMethodInSelfOrParents(name, desc));
  }

  /**
   * @param name
   * 		Method name.
   * @param desc
   * 		Method descriptor.
   *
   * @return If the method exists in the current vertex or in any child vertex.
   */
  public boolean hasMethodInSelfOrChildren(@NotNull String name, @NotNull String desc) {
    if (hasMethod(name, desc))
      return true;
    return allChildren()
        .filter(v -> v != this)
        .anyMatch(parent -> parent.hasMethodInSelfOrChildren(name, desc));
  }

  /**
   * @return {@code true} if the class represented by this vertex is a library class.
   * This means a class that does not belong to the primary {@link WorkspaceResource}
   * of a {@link Workspace}.
   */
  /*public boolean isLibraryVertex() {
    return !isPrimary;
  }*/

  /**
   * @return {@code true} when the current vertex represents {@link Object}.
   */
  public boolean isJavaLangObject() {
    return getName().equals("java/lang/Object");
  }

  /**
   * @return {@code true} when a parent of this vertex, is this vertex.
   */
  public boolean isLoop() {
    String name = getName();
    return allParents()
        .anyMatch(v -> name.equals(v.getName()));
  }

  /**
   * @return {@code true} when the current vertex represents a {@code module-info}.
   */
  public boolean isModule() {
    return (getValue().access & Opcodes.ACC_MODULE) != 0 && getValue().superName == null;
  }

  /**
   * @param name
   * 		Method name.
   * @param desc
   * 		Method descriptor.
   *
   * @return {@code true} if method is an extension of an outside class's methods and thus should not be renamed.
   * {@code false} if the method is safe to rename.
   */
  /*public boolean isLibraryMethod(@NotNull String name, @NotNull String desc) {
    // Check against this definition
    if (!isPrimary && hasMethod(name, desc))
      return true;

    // Check parents.
    // If we extend a class with a library definition then it should be considered a library method.
    for (InheritanceVertex parent : getParents())
      if (parent.isLibraryMethod(name, desc))
        return true;

    // No library definition found, so its safe to rename.
    return false;
  }*/

  /**
   * @param vertex
   * 		Supposed child vertex.
   *
   * @return {@code true} if the vertex is of a child type to this vertex's {@link #getName() type}.
   */
  public boolean isParentOf(@NotNull InheritanceVertex vertex) {
    return vertex.getAllParents().contains(this);
  }

  /**
   * @param vertex
   * 		Supposed parent vertex.
   *
   * @return {@code true} if the vertex is of a parent type to this vertex's {@link #getName() type}.
   */
  public boolean isChildOf(@NotNull InheritanceVertex vertex) {
    return getAllParents().contains(vertex);
  }

  /**
   * @param vertex
   * 		Supposed vertex that belongs in the family.
   *
   * @return {@code true} if the vertex is a family member, but is not a child or parent of the current vertex.
   */
  public boolean isIndirectFamilyMember(@NotNull InheritanceVertex vertex) {
    return isIndirectFamilyMember(getFamily(true), vertex);
  }

  /**
   * @param family
   * 		Family to check in.
   * @param vertex
   * 		Supposed vertex that belongs in the family.
   *
   * @return {@code true} if the vertex is a family member, but is not a child or parent of the current vertex.
   */
  public boolean isIndirectFamilyMember(@NotNull Set<InheritanceVertex> family, @NotNull InheritanceVertex vertex) {
    return this != vertex &&
        family.contains(vertex) &&
        !isChildOf(vertex) &&
        !isParentOf(vertex);
  }

  /**
   * @param name
   * 		Name of parent type.
   *
   * @return {@code true} when this vertex has the given parent.
   */
  public boolean hasParent(@NotNull String name) {
    for (InheritanceVertex parent : getAllParents())
      if (name.equals(parent.getName()))
        return true;

    return false;
  }

  /**
   * @param name
   * 		Name of child type.
   *
   * @return {@code true} when this vertex has the given child.
   */
  public boolean hasChild(@NotNull String name) {
    for (InheritanceVertex child : getAllChildren())
      if (name.equals(child.getName()))
        return true;

    return false;
  }

  /**
   * @param includeObject
   *        {@code true} to include {@link Object} as a vertex.
   *
   * @return The entire class hierarchy.
   */
  @NotNull
  public Set<InheritanceVertex> getFamily(boolean includeObject) {
    Set<InheritanceVertex> vertices = new LinkedHashSet<>();
    visitFamily(vertices);
    if (!includeObject)
      vertices.removeIf(InheritanceVertex::isJavaLangObject);
    return vertices;
  }

  private void visitFamily(@NotNull Set<InheritanceVertex> vertices) {
    if (isModule())
      return;
    if (vertices.add(this) && !isJavaLangObject())
      for (InheritanceVertex vertex : getAllDirectVertices())
        vertex.visitFamily(vertices);
  }

  /**
   * @return All classes this extends or implements.
   */
  @NotNull
  public Set<InheritanceVertex> getAllParents() {
    return allParents().collect(Collectors.toCollection(LinkedHashSet::new));
  }

  /**
   * @return All classes this extends or implements.
   */
  @NotNull
  public Stream<InheritanceVertex> allParents() {
    // Skip 1 to skip ourselves (which we use as the seed vertex)
    return Streams.recurseWithoutCycles(this, InheritanceVertex::getParents)
        .skip(1);
  }

  /**
   * @return Classes this directly extends or implements.
   */
  @NotNull
  public Set<InheritanceVertex> getParents() {
    Set<InheritanceVertex> parents = this.parents;
    if (parents == null) {
      synchronized (this) {
        if (isModule()) {
          parents = Collections.emptySet();
          this.parents = parents;
          return parents;
        }
        parents = this.parents;
        if (parents == null) {
          String name = getName();
          parents = new LinkedHashSet<>();
          String superName = value.superName;
          if (superName != null && !name.equals(superName)) {
            InheritanceVertex parentVertex = lookup.apply(superName);
            if (parentVertex != null)
              parents.add(parentVertex);
          }
          for (String itf : value.interfaces) {
            InheritanceVertex itfVertex = lookup.apply(itf);
            if (itfVertex != null && !name.equals(itf))
              parents.add(itfVertex);
          }
          this.parents = parents;
        }
      }
    }
    return parents;
  }

  /**
   * @return All classes extending or implementing this type.
   */
  @NotNull
  public Set<InheritanceVertex> getAllChildren() {
    return allChildren().collect(Collectors.toCollection(LinkedHashSet::new));
  }

  /**
   * @return Stream of all classes extending or implementing this type.
   */
  @NotNull
  public Stream<InheritanceVertex> allChildren() {
    // Skip 1 to skip ourselves (which we use as the seed vertex)
    return Streams.recurseWithoutCycles(this, InheritanceVertex::getChildren)
        .skip(1);
  }

  /**
   * @return Classes that extend or implement this class.
   */
  @NotNull
  public Set<InheritanceVertex> getChildren() {
    Set<InheritanceVertex> children = this.children;
    if (children == null) {
      synchronized (this) {
        if (isModule()) {
          children = Collections.emptySet();
          this.children = children;
          return children;
        }
        children = this.children;
        if (children == null) {
          String name = getName();
          children = childrenLookup.apply(value.name)
              .stream()
              .filter(childName -> !name.equals(childName))
              .map(lookup)
              .filter(Objects::nonNull)
              .collect(Collectors.toCollection(LinkedHashSet::new));
          this.children = children;
        }
      }
    }
    return children;
  }

  /**
   * @return All direct parents and child vertices.
   */
  @NotNull
  public Set<InheritanceVertex> getAllDirectVertices() {
    Set<InheritanceVertex> set = new HashSet<>(getParents());
    set.addAll(getChildren());
    return set;
  }

  /**
   * Clears cached {@link #getParents()} and {@link #getChildren()} values.
   */
  public void clearCachedVertices() {
    synchronized (this) {
      parents = null;
      children = null;
    }
  }


  /**
   * @return {@link #getValue() wrapped class's} name
   */
  @NotNull
  public String getName() {
    return value.name;
  }

  /**
   * @return Wrapped class info.
   */
  @NotNull
  public ClassNode getValue() {
    return value;
  }

  /**
   * @param value
   * 		New wrapped class info.
   */
  public void setValue(@NotNull ClassNode value) {
    this.value = value;

    // Reset children & parent sets
    synchronized (this) {
      children = null;
      parents = null;
    }
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    InheritanceVertex vertex = (InheritanceVertex) o;
    return Objects.equals(getName(), vertex.getName());
  }

  @Override
  public int hashCode() {
    return getName().hashCode();
  }

  @Override
  public String toString() {
    return getName();
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/inheritance/Streams.java`:

```java
package uwu.narumi.deobfuscator.api.inheritance;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class Streams {
  public static <T> Stream<T> recurseWithoutCycles(T seed, Function<T, Set<T>> flatMap) {
    Deque<Iterator<T>> vertices = new ArrayDeque<>();
    Set<T> visited = new HashSet<>();
    vertices.push(Collections.singletonList(seed).iterator());
    return StreamSupport.stream(new Spliterators.AbstractSpliterator<>(Long.MAX_VALUE, Spliterator.IMMUTABLE | Spliterator.NONNULL) {
      @Override
      public boolean tryAdvance(Consumer<? super T> action) {
        while (true) {
          Iterator<T> iterator = vertices.peek();
          if (iterator == null) {
            return false;
          }
          if (!iterator.hasNext()) {
            vertices.poll();
            continue;
          }
          T vertex = iterator.next();
          if (visited.add(vertex)) {
            action.accept(vertex);
            vertices.push(flatMap.apply(vertex).iterator());
            return true;
          }
        }
      }
    }, false);
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/transformer/ComposedTransformer.java`:

```java
package uwu.narumi.deobfuscator.api.transformer;

import java.util.List;
import java.util.function.Supplier;

import org.jetbrains.annotations.Nullable;

public class ComposedTransformer extends Transformer {

  private final List<Supplier<@Nullable Transformer>> transformers;

  @SafeVarargs
  public ComposedTransformer(Supplier<@Nullable Transformer>... transformers) {
    this.transformers = List.of(transformers);
  }

  @SafeVarargs
  public ComposedTransformer(boolean rerunOnChange, Supplier<Transformer>... transformers) {
    this.transformers = List.of(transformers);
    this.rerunOnChange = rerunOnChange;
  }

  @Override
  protected void transform() {
    transformers.forEach(transformerSupplier -> {
      boolean changed = Transformer.transform(transformerSupplier, scope(), context());
      if (changed) {
        this.markChange();
      }
    });
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/transformer/Transformer.java`:

```java
package uwu.narumi.deobfuscator.api.transformer;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.UnmodifiableView;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.BasicVerifier;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.exception.TransformerException;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

public abstract class Transformer extends AsmHelper implements Opcodes {
  protected static final Logger LOGGER = LogManager.getLogger();

  private Context context = null;
  private ClassWrapper scope = null;

  // Internal variables
  private boolean hasRan = false;
  private final AtomicInteger changes = new AtomicInteger(0);

  // Config
  protected boolean rerunOnChange = false;

  /**
   * Should the transformer rerun if it changed something
   */
  public boolean shouldRerunOnChange() {
    return rerunOnChange;
  }

  /**
   * Do the transformation. If you implement it you MUST use {@link Transformer#markChange()} somewhere
   */
  protected abstract void transform() throws Exception;

  /**
   * Marks that transformer changed something. You MUST use it somewhere in your transformer.
   */
  protected void markChange() {
    this.changes.incrementAndGet();
  }

  public int getChangesCount() {
    return this.changes.get();
  }

  public boolean isChanged() {
    return this.getChangesCount() > 0;
  }

  public String name() {
    return this.getClass().getSimpleName();
  }

  /**
   * Get classes for processing
   */
  @UnmodifiableView
  protected List<ClassWrapper> scopedClasses() {
    return this.context.scopedClasses(this.scope);
  }

  private void ensureInitialized() {
    if (this.context == null) {
      throw new IllegalStateException("Transformer is not initialized");
    }
  }

  @NotNull
  public Context context() {
    ensureInitialized();
    return context;
  }

  @Nullable
  public ClassWrapper scope() {
    ensureInitialized();
    return scope;
  }

  /**
   * Init transformer
   */
  private void init(Context context, ClassWrapper scope) {
    this.context = context;
    this.scope = scope;
  }

  /**
   * Run the transformer
   *
   * @param transformerSupplier The transformer supplier with all its configuration ready to go. Required to recreate
   *                            transformer multiple times with the same configuration. You must pass here new instance.
   *                            You can't reuse the existing instance.
   * @param scope You can choose the class transform or set it to null to transform all classes
   * @param context The context
   * @return If the transformation changed something
   */
  public static boolean transform(Supplier<@Nullable Transformer> transformerSupplier, @Nullable ClassWrapper scope, Context context) {
    return transform(transformerSupplier, scope, context, false);
  }

  private static boolean transform(
      Supplier<@Nullable Transformer> transformerSupplier,
      @Nullable ClassWrapper scope,
      Context context,
      boolean reran
  ) {
    Transformer transformer = transformerSupplier.get();
    if (transformer == null) {
      // Null means that transformer is disabled. Skip it
      return false;
    }

    if (transformer.hasRan) {
      throw new IllegalArgumentException("transformerSupplier tried to reuse transformer instance. You must pass a new instance of transformer");
    }

    // Initialize transformer
    transformer.init(context, scope);

    LOGGER.info("-------------------------------------");
    LOGGER.info("Running {} transformer", transformer.name());
    long start = System.currentTimeMillis();

    // Run the transformer!
    try {
      transformer.transform();
    } catch (TransformerException e) {
      LOGGER.error("! {}: {}", transformer.name(), e.getMessage());
      return false;
    } catch (Exception e) {
      LOGGER.error("Error occurred when transforming {}", transformer.name(), e);
      if (!context.getOptions().continueOnError()) {
        throw new RuntimeException(e);
      }
      return false;
    } finally {
      // Mark transformer that it was already used
      transformer.hasRan = true;
    }

    boolean changed = transformer.isChanged();

    LOGGER.info("Made {} changes", transformer.getChangesCount());
    LOGGER.info("Ended {} transformer in {} ms", transformer.name(), (System.currentTimeMillis() - start));

    if (changed && transformer.shouldRerunOnChange()) {
      LOGGER.info("\uD83D\uDD04 Changes detected. Rerunning {} transformer", transformer.name());
      Transformer.transform(transformerSupplier, scope, context, true);
    }

    // Bytecode verification
    if (context.getOptions().verifyBytecode() && !reran && changed) {
      // Verify if bytecode is valid
      try {
        verifyBytecode(scope, context);
      } catch (RuntimeException e) {
        LOGGER.error("Transformer {} produced invalid bytecode", transformer.name(), e);
      }
    }

    return changed;
  }

  /**
   * Verifies if the bytecode is valid
   */
  private static void verifyBytecode(@Nullable ClassWrapper scope, Context context) throws IllegalStateException {
    for (ClassWrapper classWrapper : context.scopedClasses(scope)) {
      for (MethodNode methodNode : classWrapper.methods()) {
        Analyzer<BasicValue> analyzer = new Analyzer<>(new BasicVerifier());
        try {
          analyzer.analyzeAndComputeMaxs(classWrapper.name(), methodNode);
        } catch (AnalyzerException e) {
          throw new IllegalStateException("Invalid bytecode in " + classWrapper.name() + "#" + methodNode.name + methodNode.desc, e);
        }
      }
    }
  }
}

```

`deobfuscator-api/src/main/java/uwu/narumi/deobfuscator/api/transformer/VersionedComposedTransformer.java`:

```java
package uwu.narumi.deobfuscator.api.transformer;

import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

public abstract class VersionedComposedTransformer extends Transformer {

  private final String version;

  public VersionedComposedTransformer(String version) {
    this.version = version;
  }

  private boolean changed = false;

  @Override
  protected void transform() {
    Map<String, List<Supplier<Transformer>>> transformers = transformersByVersions();
    if (!transformers.containsKey(version)) {
      throw new IllegalArgumentException(String.format("Version '%s' not found!", version));
    }

    transformers
        .get(version)
        .forEach(transformer -> changed |= Transformer.transform(transformer, scope(), context()));

    if (changed) {
      markChange();
    }
  }

  public abstract Map<String, List<Supplier<Transformer>>> transformersByVersions();
}

```

`deobfuscator-impl/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>Diobfuscator</artifactId>
        <groupId>uwu.narumi</groupId>
        <version>2.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>deobfuscator-impl</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <!-- Plugin for Unit Tests -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.4.0</version>

                <configuration>
                    <junitArtifactName>org.junit.jupiter:junit-jupiter</junitArtifactName>
                    <trimStackTrace>false</trimStackTrace>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <artifactId>deobfuscator-api</artifactId>
            <groupId>uwu.narumi</groupId>
            <version>2.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <artifactId>deobfuscator-transformers</artifactId>
            <groupId>uwu.narumi</groupId>
            <version>2.0-SNAPSHOT</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.11.0</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.vineflower</groupId>
            <artifactId>vineflower</artifactId>
            <version>1.10.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

`deobfuscator-impl/src/main/java/uwu/narumi/deobfuscator/Deobfuscator.java`:

```java
package uwu.narumi.deobfuscator;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import uwu.narumi.deobfuscator.api.classpath.ClassStorage;
import uwu.narumi.deobfuscator.api.classpath.CombinedClassProvider;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.context.DeobfuscatorOptions;
import uwu.narumi.deobfuscator.api.helper.ClassHelper;
import uwu.narumi.deobfuscator.api.helper.FileHelper;
import uwu.narumi.deobfuscator.api.inheritance.InheritanceGraph;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class Deobfuscator {

  /**
   * Creates a new {@link Deobfuscator} instance from its options
   */
  public static Deobfuscator from(DeobfuscatorOptions options) {
    return new Deobfuscator(options);
  }

  private static final Logger LOGGER = LogManager.getLogger(Deobfuscator.class);

  private final DeobfuscatorOptions options;
  private final Context context;

  private Deobfuscator(DeobfuscatorOptions options) {
    this.options = options;

    if (options.inputJar() != null && Files.notExists(options.inputJar())) {
      throw new IllegalArgumentException("Input jar does not exist");
    }

    if (options.outputJar() != null && Files.exists(options.outputJar())) {
      LOGGER.warn("Output file already exist, data will be overwritten");
    }

    // Those classes will be loaded by Deobfuscator#loadInput
    ClassStorage compiledClasses = new ClassStorage();

    ClassStorage libraries = buildLibraries();
    LOGGER.info("Loaded {} classes from libraries", libraries.compiledClasses().size());

    this.context = new Context(options, compiledClasses, libraries);
  }

  public ClassStorage buildLibraries() {
    ClassStorage classStorage = new ClassStorage();
    // Add libraries
    options.libraries().forEach(classStorage::addJar);

    return classStorage;
  }

  public void start() {
    loadInput();
    transform(this.options.transformers());
    saveOutput();
  }

  public Context getContext() {
    return context;
  }

  private void loadInput() {
    if (this.options.inputJar() != null) {
      LOGGER.info("Loading jar file: {}", this.options.inputJar());
      // Load jar
      FileHelper.loadFilesFromZip(this.options.inputJar(), this::loadClassOrFile);
      LOGGER.info("Loaded jar file: {}", this.options.inputJar());
    }

    for (DeobfuscatorOptions.ExternalFile externalFile : this.options.externalFiles()) {
      LOGGER.info("Loading external file: {}", externalFile.pathInJar());

      try (InputStream inputStream = new FileInputStream(externalFile.path().toFile())) {
        // Load class
        this.loadClassOrFile(externalFile.pathInJar(), inputStream.readAllBytes());

        LOGGER.info("Loaded external file: {}", externalFile.pathInJar());
      } catch (IOException e) {
        LOGGER.error("Could not load external file: {}", externalFile.pathInJar(), e);
      }
    }
  }

  private void loadClassOrFile(String pathInJar, byte[] bytes) {
    // Load class
    if (ClassHelper.isClass(pathInJar, bytes)) {
      try {
        this.context.addCompiledClass(pathInJar, bytes);
        return;
      } catch (Exception e) {
        LOGGER.error("Could not load class: {}, adding as file", pathInJar, e);
        // Will add as a file
      }
    }

    // Load file
    if (!context.getFilesMap().containsKey(pathInJar)) {
      context.addFile(pathInJar, bytes);
    }
  }

  public void transform(List<Supplier<Transformer>> transformers) {
    if (transformers.isEmpty()) return;

    // Run all transformers!
    transformers.forEach(transformerSupplier -> Transformer.transform(transformerSupplier, null, this.context));
  }

  /**
   * Saves deobfuscation output result
   */
  private void saveOutput() {
    if (this.options.outputJar() != null) {
      saveToJar();
    } else if (this.options.outputDir() != null) {
      saveToDir();
    } else {
      throw new IllegalStateException("No output file or directory provided");
    }
  }

  private void saveToDir() {
    LOGGER.info("Saving output to directory: {}", this.options.outputDir());

    save((path, data) -> {
      Path realPath = this.options.outputDir().resolve(path);
      try {
        Files.createDirectories(realPath.getParent());
        Files.write(realPath, data);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    });
  }

  private void saveToJar() {
    LOGGER.info("Saving output to jar: {}", this.options.outputJar());

    // Create directories if not exists
    if (this.options.outputJar().getParent() != null) {
      try {
        Files.createDirectories(this.options.outputJar().getParent());
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }

    try (ZipOutputStream zipOutputStream = new ZipOutputStream(Files.newOutputStream(this.options.outputJar()))) {
      zipOutputStream.setLevel(9);

      save((path, data) -> {
        try {
          zipOutputStream.putNextEntry(new ZipEntry(path));
          zipOutputStream.write(data);
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      });
    } catch (IOException e) {
      LOGGER.error("Could not save output to jar: {}", this.options.outputJar());
      throw new RuntimeException(e);
    }

    LOGGER.info("Saved output to jar: {}\n", this.options.outputJar());
  }

  /**
   * Saves classes and files using provided saver
   *
   * @param saver a consumer that accepts a path and data to save
   */
  private void save(BiConsumer<String, byte[]> saver) {
    InheritanceGraph inheritanceGraph = new InheritanceGraph(
        new CombinedClassProvider(this.context, this.context.getLibraries())
    );

    // Save classes
    context.getClassesMap().forEach((ignored, classWrapper) -> {
      String path = classWrapper.getPathInJar();

      try {
        byte[] data = classWrapper.compileToBytes(inheritanceGraph, this.options.classWriterFlags());
        saver.accept(path, data);
      } catch (Exception e) {
        LOGGER.error("Could not save class, saving original class instead of deobfuscated: {}", classWrapper.name());
        if (this.options.printStacktraces()) LOGGER.throwing(e);

        try {
          // Save original class as a fallback
          byte[] data = context.getCompiledClasses().getClass(classWrapper.name());
          saver.accept(path, data);
        } catch (Exception e2) {
          LOGGER.error("Could not save original class: {}", classWrapper.name());
          if (this.options.printStacktraces()) LOGGER.throwing(e2);
        }
      }
    });

    // Save files
    if (!this.options.skipFiles()) {
      context.getFilesMap().forEach((path, data) -> {
        try {
          saver.accept(path, data);
        } catch (Exception e) {
          LOGGER.error("Could not save file: {}", path);
          if (this.options.printStacktraces()) LOGGER.throwing(e);
        }
      });
    }
  }
}

```

`deobfuscator-impl/src/main/resources/log4j2.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%highlight{[%d{HH:mm:ss}] [%level]: %msg%n%throwable}{INFO=normal}" disableAnsi="false"/>
        </Console>
        <File name="File" fileName="deobfuscator.log" immediateFlush="false" append="false">
            <PatternLayout pattern="[%d{HH:mm:ss}] [%level]: %msg%n%throwable"/>
        </File>
    </Appenders>
    <Loggers>
        <Root level="debug">
            <AppenderRef ref="File" level="debug"/>
            <AppenderRef ref="Console" level="info"/>
        </Root>
    </Loggers>
</Configuration>
```

`deobfuscator-impl/src/test/java/Bootstrap.java`:

```java
import java.nio.file.Path;
import org.objectweb.asm.ClassWriter;
import uwu.narumi.deobfuscator.Deobfuscator;
import uwu.narumi.deobfuscator.api.context.DeobfuscatorOptions;
import uwu.narumi.deobfuscator.core.other.composed.general.ComposedGeneralFlowTransformer;

public class Bootstrap {

  public static void main(String[] args) {
    Deobfuscator.from(
        DeobfuscatorOptions.builder()
            .inputJar(Path.of("work", "obf-test.jar")) // Specify your input jar here
            //.libraries(Path.of("work", "libs")) // Specify your libraries here if needed
            .transformers(
                // Pick your transformers here
                () -> new ComposedGeneralFlowTransformer()
            )
            .continueOnError()
            .classWriterFlags(ClassWriter.COMPUTE_FRAMES)
            .build()
        ).start();
  }
}

```

`deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/TestDeobfuscation.java`:

```java
package uwu.narumi.deobfuscator;

import uwu.narumi.deobfuscator.core.other.composed.ComposedHP888Transformer;
import uwu.narumi.deobfuscator.core.other.composed.ComposedZelixTransformer;
import uwu.narumi.deobfuscator.core.other.composed.general.ComposedGeneralFlowTransformer;
import uwu.narumi.deobfuscator.core.other.composed.general.ComposedPeepholeCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.JsrInlinerTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.UselessPopCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineLocalVariablesTransformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineStaticFieldTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.UniversalNumberTransformer;
import uwu.narumi.deobfuscator.base.TestDeobfuscationBase;
import uwu.narumi.deobfuscator.transformer.TestSandboxSecurityTransformer;

import java.util.Map;

public class TestDeobfuscation extends TestDeobfuscationBase {

  @Override
  protected void registerAll() {
    test("Inlining local variables")
        .transformers(InlineLocalVariablesTransformer::new, ComposedPeepholeCleanTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "TestInlineLocalVariables.class")
        .register();
    test("Simple flow obfuscation")
        .transformers(ComposedGeneralFlowTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "TestSimpleFlowObfuscation.class")
        .register();
    test("Universal number transformer")
        .transformers(UniversalNumberTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "TestUniversalNumberTransformer.class")
        .register();
    // TODO: Uninitialized static fields should replace with 0?
    test("Inline static fields")
        .transformers(InlineStaticFieldTransformer::new, UselessPopCleanTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "TestInlineStaticFields.class")
        .register();
    test("Inline static fields with modification")
        .transformers(InlineStaticFieldTransformer::new, UselessPopCleanTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "TestInlineStaticFieldsWithModification.class")
        .register();

    // Test sandbox security (e.g. not allowing dangerous calls)
    test("Sandbox security")
        .transformers(TestSandboxSecurityTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.JAVA_CODE, "sandbox/TestSandboxSecurity.class")
        .noDecompile()
        .register();

    // JSR Inlining
    test("JSR Inlining")
        .transformers(JsrInlinerTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.CUSTOM_CLASS, "JSR.class")
        .register();

    // Samples
    test("Some flow obf sample")
        .transformers(ComposedGeneralFlowTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.CUSTOM_CLASS, "FlowObfSample.class")
        .register();

    // Zelix
    test("Zelix (22.0.3) Sample 1")
        .transformers(() -> new ComposedZelixTransformer(true))
        .input(OutputType.MULTIPLE_CLASSES, InputType.CUSTOM_CLASS, "zkm/sample1")
        .register();
    // Obfuscated using this ZKM config (https://www.zelix.com/klassmaster/docs/langZKMScript.html):
    /*
    obfuscate   changeLogFileIn=""
                changeLogFileOut="ChangeLog.txt"
                obfuscateFlow=aggressive
                exceptionObfuscation=heavy
                encryptStringLiterals=enhanced
                encryptIntegerConstants=aggressive
                encryptLongConstants=normal
                mixedCaseClassNames=false
                aggressiveMethodRenaming=true
                localVariables=delete
                lineNumbers=delete
                autoReflectionHandling=normal
                obfuscateReferences=none
                methodParameterChanges=flowObfuscate
                obfuscateParameters=normal;
     */
    test("Zelix (22.0.3) Sample 2 - Class initialization order")
        .transformers(() -> new ComposedZelixTransformer(true,
            // During obfuscation was specified classInitializationOrder option,
            // so we need to also pass it here for correct decrypted values
            Map.of("a.a.a.a.a4", "a.a.a.a.bc")
        ))
        .input(OutputType.MULTIPLE_CLASSES, InputType.CUSTOM_CLASS, "zkm/sample2")
        .register();
    // Obfuscated using the following ZKM config (https://www.zelix.com/klassmaster/docs/langZKMScript.html):
    /*
    obfuscate   changeLogFileIn=""
            changeLogFileOut="ChangeLog.txt"
            obfuscateFlow=aggressive
            exceptionObfuscation=heavy
            encryptStringLiterals=enhanced
            encryptIntegerConstants=aggressive
            encryptLongConstants=normal
            mixedCaseClassNames=ifInArchive
            aggressiveMethodRenaming=true
            collapsePackagesWithDefault=""
            localVariables=delete
            lineNumbers=delete
            autoReflectionHandling=normal
            obfuscateReferences=none
            methodParameterChanges=flowObfuscate
            obfuscateParameters=normal;
     */
    test("Zelix (22.0.3) Sample 3 - Snake Game")
        .transformers(() -> new ComposedZelixTransformer(true))
        .input(OutputType.MULTIPLE_CLASSES, InputType.CUSTOM_JAR, "SnakeGame-obf-zkm.jar")
        .register();

    // Zelix (22.0.3)
    /*
    obfuscate   changeLogFileIn=""
                changeLogFileOut="ChangeLog.txt"
                obfuscateFlow=none
                exceptionObfuscation=none
                encryptStringLiterals=enhanced
                encryptIntegerConstants=none
                encryptLongConstants=none
                mixedCaseClassNames=ifInArchive
                collapsePackagesWithDefault=""
                localVariables=delete
                lineNumbers=delete
                autoReflectionHandling=normal
                obfuscateReferences=none;
     */
    test("Zelix (22.0.3) - String Encryption - Enhanced - Some strings")
        .transformers(ComposedZelixTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.CUSTOM_CLASS, "zkm/EnhancedStringEncSomeStrings.class")
        .register();
    test("Zelix (22.0.3) - String Encryption - Enhanced - Many strings")
        .transformers(ComposedZelixTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.CUSTOM_CLASS, "zkm/EnhancedStringEncManyStrings.class")
        .register();

    // Example HP888 classes
    test("HP888")
        .transformers(() -> new ComposedHP888Transformer(".mc"))
        .input(OutputType.MULTIPLE_CLASSES, InputType.CUSTOM_CLASS, "hp888")
        .register();

    test("POP2 Sample")
        .transformers(UselessPopCleanTransformer::new)
        .input(OutputType.SINGLE_CLASS, InputType.CUSTOM_CLASS, "Pop2Sample.class")
        .register();
  }
}

```

`deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/base/AssertingResultSaver.java`:

```java
package uwu.narumi.deobfuscator.base;

import org.jetbrains.java.decompiler.main.extern.IResultSaver;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.jar.Manifest;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Result saver that will assert against previous decompiled code
 */
public class AssertingResultSaver implements IResultSaver {

  private final Path outputDir;

  private boolean savedContent = false;

  public AssertingResultSaver(Path outputDir) {
    this.outputDir = outputDir;
  }

  @Override
  public void saveFolder(String path) {
    // Nothing
  }

  @Override
  public void copyFile(String source, String path, String entryName) {
    // Nothing
  }

  /**
   * Assert decompiled code
   */
  @Override
  public void saveClassFile(String path, String qualifiedName, String entryName, String content, int[] mapping) {
    // Replace CRLF with LF
    content = content.replace("\r\n", "\n");

    // Remove file extension
    entryName = entryName.substring(0, entryName.lastIndexOf('.'));

    Path saveTo = this.outputDir.resolve(entryName + ".dec");

    try {
      if (Files.exists(saveTo)) {
        // Assert decompiled code
        String oldCode = Files.readString(saveTo);
        // Replace CRLF with LF
        oldCode = oldCode.replace("\r\n", "\n");

        assertEquals(oldCode, content);
      } else {
        // Save content
        Files.createDirectories(saveTo.getParent());
        Files.writeString(saveTo, content);

        // Mark that result saver saved content instead of asserting it
        savedContent = true;
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void createArchive(String path, String archiveName, Manifest manifest) {
    // Nothing
  }

  @Override
  public void saveDirEntry(String path, String archiveName, String entryName) {
    // Nothing
  }

  @Override
  public void copyEntry(String source, String path, String archiveName, String entry) {
    // Nothing
  }

  @Override
  public void saveClassEntry(String path, String archiveName, String qualifiedName, String entryName, String content) {
    // Nothing
  }

  @Override
  public void closeArchive(String path, String archiveName) {
    // Nothing
  }

  public boolean savedContent() {
    return savedContent;
  }
}

```

`deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/base/SingleClassContextSource.java`:

```java
package uwu.narumi.deobfuscator.base;

import java.io.FileInputStream;
import java.nio.file.Path;
import org.jetbrains.java.decompiler.main.extern.IContextSource;
import org.jetbrains.java.decompiler.main.extern.IResultSaver;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

public class SingleClassContextSource implements IContextSource {
  private final Path file;
  private final String pathInJar;

  /**
   * @param file Path to .class file
   * @param pathInJar Relative path to .class file as if it were in .jar
   */
  public SingleClassContextSource(Path file, String pathInJar) {
    this.file = file;
    this.pathInJar = pathInJar;
  }

  @Override
  public String getName() {
    return "file " + this.file;
  }

  @Override
  public Entries getEntries() {
    return new Entries(List.of(Entry.atBase(this.pathInJar)), List.of(), List.of());
  }

  @Override
  public InputStream getInputStream(String resource) throws IOException {
    return new FileInputStream(this.file.toFile());
  }

  @Override
  public IOutputSink createOutputSink(IResultSaver saver) {
    return new IOutputSink() {
      @Override
      public void begin() {

      }

      @Override
      public void acceptClass(String qualifiedName, String fileName, String content, int[] mapping) {
        saver.saveClassFile("", qualifiedName, pathInJar, content, mapping);
      }

      @Override
      public void acceptDirectory(String directory) {

      }

      @Override
      public void acceptOther(String path) {

      }

      @Override
      public void close() throws IOException {

      }
    };
  }
}

```

`deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/base/TestDeobfuscationBase.java`:

```java
package uwu.narumi.deobfuscator.base;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.config.Configurator;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.decompiler.api.Decompiler;
import org.jetbrains.java.decompiler.main.extern.IContextSource;
import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.Timeout;
import org.opentest4j.TestAbortedException;
import uwu.narumi.deobfuscator.Deobfuscator;
import uwu.narumi.deobfuscator.api.context.DeobfuscatorOptions;
import uwu.narumi.deobfuscator.api.helper.FileHelper;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Stream;

@Timeout(60)
public abstract class TestDeobfuscationBase {
  public static final Path TEST_DATA_PATH = Path.of("..", "testData");
  public static final Path COMPILED_PATH = TEST_DATA_PATH.resolve("compiled");
  public static final Path DEOBFUSCATED_PATH = TEST_DATA_PATH.resolve("deobfuscated");
  public static final Path RESULTS_PATH = TEST_DATA_PATH.resolve("results");

  private final List<RegisteredTest> registeredTests = new ArrayList<>();

  /**
   * Register your tests here
   */
  protected abstract void registerAll();

  @BeforeAll
  public static void setup() {
    // Don't spam logs
    Configurator.setRootLevel(Level.WARN);
  }

  @TestFactory
  @DisplayName("Test deobfuscation")
  public Stream<DynamicTest> testDeobfuscation() {
    this.registeredTests.clear();
    FileHelper.deleteDirectory(DEOBFUSCATED_PATH);

    this.registerAll();
    return this.registeredTests.stream().map(RegisteredTest::buildTest);
  }

  public record RegisteredTest(
      String testName,
      InputType inputType,
      OutputType outputType,
      List<Supplier<Transformer>> transformers,
      String path,
      boolean decompile
  ) {
    public RegisteredTest {
      if (outputType == OutputType.SINGLE_CLASS && inputType == InputType.CUSTOM_JAR) {
        throw new IllegalArgumentException("Cannot use 'OutputType.SINGLE_CLASS' with a jar input");
      }
    }

    /**
     * Build test
     */
    public DynamicTest buildTest() {
      return DynamicTest.dynamicTest(this.testName, this::runTest);
    }

    /**
     * Run test
     */
    private void runTest() {
      // Setup builder
      DeobfuscatorOptions.Builder optionsBuilder = DeobfuscatorOptions.builder()
          .transformers(this.transformers.toArray(new Supplier[0]));

      // Some paths
      Path outputDir = DEOBFUSCATED_PATH.resolve(this.inputType.directory());
      Path decompilerOutputDir = RESULTS_PATH.resolve(this.inputType.directory());
      IContextSource contextSource = null;

      if (this.outputType == OutputType.SINGLE_CLASS) {
        // Handle single class output

        Path relativePath = Path.of(this.inputType.directory()).resolve(this.path);
        Path compiledClassPath = COMPILED_PATH.resolve(relativePath);
        Path deobfuscatedClassPath = DEOBFUSCATED_PATH.resolve(relativePath);

        if (Files.notExists(compiledClassPath)) {
          throw new IllegalArgumentException(
              "Compiled class not found: '" + compiledClassPath.toAbsolutePath().normalize() + "'." +
                  (this.inputType == InputType.JAVA_CODE ? " Did you forgot to compile it? Use 'mvn test' to compile test classes." : "")
          );
        }

        // Add class
        optionsBuilder.externalFile(compiledClassPath, this.path);
        contextSource = new SingleClassContextSource(deobfuscatedClassPath, this.path);
      } else {
        // Handle multiple classes output

        Path inputPath = COMPILED_PATH.resolve(this.inputType.directory()).resolve(this.path);
        String relativePath = this.path;
        if (this.inputType == InputType.CUSTOM_JAR) {
          // Prepare input
          optionsBuilder.inputJar(inputPath);

          // Set the correct relative path
          relativePath = this.path.substring(0, this.path.length() - ".jar".length());
        } else {
          // Prepare input files
          optionsBuilder.inputDir(inputPath);
        }

        // Prepare output
        outputDir = outputDir.resolve(relativePath);
        decompilerOutputDir = decompilerOutputDir.resolve(relativePath);
      }

      // Last configurations
      optionsBuilder
          .outputJar(null)
          .outputDir(outputDir)
          .skipFiles();

      // Build and run deobfuscator!
      Deobfuscator.from(optionsBuilder.build()).start();

      if (!this.decompile) {
        return;
      }

      // Assert output
      this.assertOutput(contextSource, outputDir, decompilerOutputDir);
    }

    /**
     * Asserts output of a decompilation result
     *
     * @param contextSource  Class to be decompiled
     * @param inputDir Directory to decompile.
     */
    private void assertOutput(@Nullable IContextSource contextSource, @Nullable Path inputDir, Path decompilerOutputDir) {
      AssertingResultSaver assertingResultSaver = new AssertingResultSaver(decompilerOutputDir);

      Decompiler.Builder decompilerBuilder = Decompiler.builder()
          .option(IFernflowerPreferences.INDENT_STRING, "    ")
          .output(assertingResultSaver); // Assert output

      // Add sources
      if (contextSource != null) {
        decompilerBuilder.inputs(contextSource);
      } else if (inputDir != null) {
        decompilerBuilder.inputs(inputDir.toFile()); //fuck you path > file
      } else {
        throw new IllegalArgumentException();
      }

      // Decompile
      decompilerBuilder.build().decompile();

      if (assertingResultSaver.savedContent()) {
        throw new TestAbortedException("No previous decompiled code found, skipping test");
      }
    }
  }

  public enum InputType {
    CUSTOM_CLASS("custom-classes"),
    CUSTOM_JAR("custom-jars"),
    JAVA_CODE("java")
    ;

    private final String directory;

    InputType(String directory) {
      this.directory = directory;
    }

    public String directory() {
      return directory;
    }
  }

  public enum OutputType {
    SINGLE_CLASS,
    MULTIPLE_CLASSES
  }

  protected TestBuilder test(String testName) {
    return new TestBuilder().name(testName);
  }

  protected class TestBuilder {
    private String name = null;
    private InputType inputType = null;
    private OutputType outputType = null;
    private List<Supplier<Transformer>> transformers = null;
    private String path = null;

    private boolean decompile = true;

    private TestBuilder() {
    }

    /**
     * Test name
     */
    @Contract("_ -> this")
    public TestBuilder name(String name) {
      this.name = name;
      return this;
    }

    /**
     * Transformers to use
     */
    @Contract("_ -> this")
    @SafeVarargs
    public final TestBuilder transformers(Supplier<Transformer>... transformers) {
      this.transformers = List.of(transformers);
      return this;
    }

    /**
     * Specifies input to your test
     *
     * <p>Path should be:<br>
     * {@link OutputType#SINGLE_CLASS}:
     * <ul>
     *   <li>For {@link InputType#CUSTOM_CLASS} and {@link InputType#JAVA_CODE} - it should be a path to .class file</li>
     * </ul>
     * {@link OutputType#MULTIPLE_CLASSES}:
     * <ul>
     *   <li>For {@link InputType#CUSTOM_CLASS} and {@link InputType#JAVA_CODE} - it should be a path to a directory with .class files</li>
     *   <li>For {@link InputType#CUSTOM_JAR} -  it should be a path to a .jar file</li>
     * </ul>
     *
     * @param outputType Output type
     * @param inputType Input type
     * @param path Input path (see note above)
     */
    @Contract("_,_,_ -> this")
    public TestBuilder input(OutputType outputType, InputType inputType, String path) {
      this.outputType = outputType;
      this.inputType = inputType;
      this.path = path;
      return this;
    }

    @Contract(" -> this")
    public TestBuilder noDecompile() {
      this.decompile = false;
      return this;
    }

    /**
     * Register input files for testing
     */
    public void register() {
      registeredTests.add(
          new RegisteredTest(name, inputType, outputType, transformers, path, decompile)
      );
    }
  }
}

```

`deobfuscator-impl/src/test/java/uwu/narumi/deobfuscator/transformer/TestSandboxSecurityTransformer.java`:

```java
package uwu.narumi.deobfuscator.transformer;

import dev.xdark.ssvm.execution.VMException;
import dev.xdark.ssvm.mirror.type.InstanceClass;
import uwu.narumi.deobfuscator.api.execution.SandBox;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import static org.junit.jupiter.api.Assertions.assertThrows;

public class TestSandboxSecurityTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    SandBox sandBox = context().getSandBox();
    InstanceClass clazz = sandBox.getHelper().loadClass("sandbox.TestSandboxSecurity");

    assertThrows(VMException.class, () -> {
      sandBox.getInvocationUtil().invokeInt(
          clazz.getMethod("test", "()I")
      );
    });
  }
}

```

`deobfuscator-impl/src/test/resources/junit-platform.properties`:

```properties
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent

```

`deobfuscator-transformers/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>Diobfuscator</artifactId>
        <groupId>uwu.narumi</groupId>
        <version>2.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>deobfuscator-transformers</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <artifactId>deobfuscator-api</artifactId>
            <groupId>uwu.narumi</groupId>
            <version>2.0-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

</project>
```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/ComposedAllatoriTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.allatori.AllatoriStringTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.UniversalNumberTransformer;

public class ComposedAllatoriTransformer extends ComposedTransformer {

    public ComposedAllatoriTransformer(boolean strongString) {
        super(
            UniversalNumberTransformer::new,
            () -> new AllatoriStringTransformer(strongString)
        );
    }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/ComposedHP888Transformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed;

import org.jetbrains.annotations.Nullable;
import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.LocalVariableNamesCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.hp888.HP888PackerTransformer;
import uwu.narumi.deobfuscator.core.other.impl.hp888.HP888StringTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.AccessRepairTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.RecoverSyntheticsTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.UniversalNumberTransformer;

/**
 * Transformers for custom-made obfuscator by HP888. Used in projects like https://safemc.pl/
 */
public class ComposedHP888Transformer extends ComposedTransformer {

  public ComposedHP888Transformer() {
    this(null);
  }

  public ComposedHP888Transformer(@Nullable String encryptedClassFilesSuffix) {
    super(
        // Decrypt strings
        HP888StringTransformer::new,

        () -> encryptedClassFilesSuffix != null ? new ComposedTransformer(
            // Unpack encrypted classes
            () -> new HP888PackerTransformer(encryptedClassFilesSuffix),
            // Decrypt strings in unpacked classes
            HP888StringTransformer::new
        ) : null,

        // Cleanup
        UniversalNumberTransformer::new,
        AccessRepairTransformer::new,
        LocalVariableNamesCleanTransformer::new,
        RecoverSyntheticsTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/ComposedZelixTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.composed.general.ComposedPeepholeCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.JsrInlinerTransformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineStaticFieldTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.RecoverSyntheticsTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.UniversalNumberTransformer;
import uwu.narumi.deobfuscator.core.other.impl.zkm.ZelixLongEncryptionMPCTransformer;
import uwu.narumi.deobfuscator.core.other.impl.zkm.ZelixParametersTransformer;
import uwu.narumi.deobfuscator.core.other.impl.zkm.ZelixUselessTryCatchRemoverTransformer;

import java.util.HashMap;
import java.util.Map;

/**
 * Work in progress
 */
public class ComposedZelixTransformer extends ComposedTransformer {
  public ComposedZelixTransformer() {
    this(false);
  }

  public ComposedZelixTransformer(boolean experimental) {
    this(experimental, new HashMap<>());
  }

  public ComposedZelixTransformer(boolean experimental, Map<String, String> classInitializationOrder) {
    super(
        // Initial cleanup
        JsrInlinerTransformer::new,
        RecoverSyntheticsTransformer::new,

        // Fixes flow a bit
        ZelixUselessTryCatchRemoverTransformer::new,

        // Decompose method parameters
        () -> experimental ? new ZelixParametersTransformer() : null,

        // Decrypt longs
        () -> new ZelixLongEncryptionMPCTransformer(classInitializationOrder),
        InlineStaticFieldTransformer::new,
        UniversalNumberTransformer::new,

        // Cleanup
        ComposedPeepholeCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/general/ComposedGeneralFlowTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed.general;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.InvalidMethodCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineLocalVariablesTransformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineStaticFieldTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.UniversalFlowTransformer;

public class ComposedGeneralFlowTransformer extends ComposedTransformer {

  public ComposedGeneralFlowTransformer() {
    super(
        // Preparation
        InvalidMethodCleanTransformer::new,
        InlineStaticFieldTransformer::new,
        InlineLocalVariablesTransformer::new,

        // Main transformer
        UniversalFlowTransformer::new,

        // Clean up garbage
        ComposedPeepholeCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/general/ComposedGeneralRepairTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed.general;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.ClassDebugInfoCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.MethodDebugInfoCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.SignatureCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.UnknownAttributeCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.AccessRepairTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.AnnotationFilterTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.TryCatchRepairTransformer;

/**
 * If methods are hidden from decompiler, or something uncommon happen, then this transformer will try to fix it.
 */
public class ComposedGeneralRepairTransformer extends ComposedTransformer {

  public ComposedGeneralRepairTransformer() {
    super(
        AccessRepairTransformer::new,
        AnnotationFilterTransformer::new,
        TryCatchRepairTransformer::new,
        UnknownAttributeCleanTransformer::new,
        SignatureCleanTransformer::new,
        MethodDebugInfoCleanTransformer::new,
        ClassDebugInfoCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/composed/general/ComposedPeepholeCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.composed.general;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.DeadCodeCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.NopCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.UnUsedLabelCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.PopUnUsedLocalVariablesTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.UselessGotosCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.UselessPopCleanTransformer;

/**
 * A transformer that cleans up garbage instructions.
 */
public class ComposedPeepholeCleanTransformer extends ComposedTransformer {

  public ComposedPeepholeCleanTransformer() {
    super(
        // Remove dead code
        DeadCodeCleanTransformer::new,
        // Some more garbage instructions cleanup
        NopCleanTransformer::new,
        UnUsedLabelCleanTransformer::new,
        UselessGotosCleanTransformer::new,

        // Pop unused local variables stores
        PopUnUsedLocalVariablesTransformer::new,
        // Remove useless POP instructions. This also cleans up garbage var stores from the PopUnUsedLocalVariablesTransformer
        UselessPopCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/allatori/AllatoriStringTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.allatori;

import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class AllatoriStringTransformer extends Transformer {

    private HashMap<String, DecryptionMethod> decryptors = new HashMap<>();

    private boolean strong;

    public AllatoriStringTransformer(boolean strong) {
        this.strong = strong;
    }

    /* Written by https://github.com/Lampadina17 | 06/08/2024 */
    /* use UniversalNumberTransformer before this transformer to decrypt keys */
    @Override
    protected void transform() throws Exception {
        scopedClasses().forEach(classWrapper -> {
            classWrapper.methods().forEach(methodNode -> {

                AtomicBoolean isDecryptor = new AtomicBoolean(false);

                /* Find decryption methods */
                if (methodNode.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {
                    Arrays.stream(methodNode.instructions.toArray()).forEach(ain -> {
                        if (ain instanceof MethodInsnNode min) {
                            if (min.name.equals("length") && min.owner.equals("java/lang/String") && min.desc.equals("()I")) {
                                isDecryptor.set(true);
                            }
                        }
                    });
                }
                if (isDecryptor.get()) {
                    /* Extract possible keys */
                    List<Integer> possibleKeys = new ArrayList<>();
                    Arrays.stream(methodNode.instructions.toArray())
                            .filter(node -> node instanceof IntInsnNode)
                            .map(IntInsnNode.class::cast)
                            .forEach(node -> possibleKeys.add(node.operand));

                    /* Filter all possible keys */
                    Arrays.stream(methodNode.instructions.toArray())
                            .filter(node -> node instanceof InsnNode)
                            .filter(node -> node.getNext() != null && node.getNext().getOpcode() == ISTORE)
                            .forEach(node -> {
                                if (node.getOpcode() == POP) {
                                    decryptors.put(classWrapper.name(), new DecryptionMethod(classWrapper.name(), new int[]{possibleKeys.get(1), possibleKeys.get(2)}));
                                } else if (node.getOpcode() == POP2) {
                                    decryptors.put(classWrapper.name(), new DecryptionMethod(classWrapper.name(), new int[]{possibleKeys.get(0), possibleKeys.get(2)}));
                                }
                            });
                }
            });
        });

        /* Decrypt all strings */
        scopedClasses().forEach(classWrapper -> {
            classWrapper.methods().forEach(methodNode -> {
                Arrays.stream(methodNode.instructions.toArray()).forEach(node -> {
                    if (node instanceof LdcInsnNode ldc && ldc.cst instanceof String && node.getNext() instanceof MethodInsnNode next && next.getOpcode() == INVOKESTATIC) {
                        DecryptionMethod dec1 = decryptors.get(next.owner);

                        /* Decrypt and remove double encryption (Strong) */
                        if (strong && next.getNext() instanceof MethodInsnNode nextnext) {
                            DecryptionMethod dec2 = decryptors.get(nextnext.owner);
                            ldc.cst = dec2.v4weak(dec1.v4strong((String) ldc.cst, methodNode.name + classWrapper.name().replace("/", ".")));
                            methodNode.instructions.remove(nextnext);
                            methodNode.instructions.remove(next);
                            this.markChange();
                            return;
                        }

                        /* Decrypt and remove encryption (Fast/Strong) */
                        if (dec1 != null) {
                            if (strong) {
                                ldc.cst = dec1.v4strong((String) ldc.cst, methodNode.name + classWrapper.name().replace("/", "."));
                            } else {
                                ldc.cst = dec1.v4weak((String) ldc.cst);
                            }
                            /* Remove invoke */
                            methodNode.instructions.remove(next);
                            this.markChange();
                        }
                    }
                });
            });
        });
        LOGGER.info("Decrypted {} strings in {} classes", this.getChangesCount(), scopedClasses().size());
    }

    public class DecryptionMethod {

        private String owner;
        private int[] keys;

        public DecryptionMethod(String owner, int[] keys) {
            this.owner = owner;
            this.keys = keys;
        }

        /* V4 Weak */
        public String v4weak(String input) {
            int i = input.length();
            char[] a = new char[i];
            int i0 = i - 1;
            while (true) {
                if (i0 >= 0) {
                    int i1 = input.charAt(i0);
                    int i2 = i0 + -1;
                    int i3 = (char) (i1 ^ keys[0]);
                    a[i0] = (char) i3;
                    if (i2 >= 0) {
                        i0 = i2 + -1;
                        int i4 = input.charAt(i2);
                        int i5 = (char) (i4 ^ keys[1]);
                        a[i2] = (char) i5;
                        continue;
                    }
                }
                return new String(a);
            }
        }

        /* V4 Strong */
        public String v4strong(String input, String context) {
            int n;
            int n2 = input.length();
            int n3 = n2 - 1;
            char[] cArray = new char[n2];
            int n6 = n = context.length() - 1;
            int n7 = n3;
            String string2 = context;
            while (n7 >= 0) {
                int n8 = n3--;
                cArray[n8] = (char) (keys[0] ^ (input.charAt(n8) ^ string2.charAt(n)));
                if (n3 < 0) return new String(cArray);
                int n9 = n3--;
                char c = cArray[n9] = (char) (keys[1] ^ (input.charAt(n9) ^ string2.charAt(n)));
                if (--n < 0) {
                    n = n6;
                }
                n7 = n3;
            }
            return new String(cArray);
        }
    }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/AnnotationCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class AnnotationCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      classWrapper.classNode().invisibleAnnotations = null;
      classWrapper.classNode().invisibleAnnotations = null;

      classWrapper.methods().forEach(methodNode -> {
        methodNode.invisibleAnnotations = null;
        methodNode.visibleAnnotations = null;
        methodNode.invisibleParameterAnnotations = null;
        methodNode.visibleParameterAnnotations = null;
      });

      classWrapper.fields().forEach(fieldNode -> {
        fieldNode.invisibleAnnotations = null;
        fieldNode.visibleAnnotations = null;
      });
    });

    // There is always a change
    markChange();
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/ClassDebugInfoCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class ClassDebugInfoCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      classWrapper.classNode().sourceDebug = null;
      classWrapper.classNode().sourceFile = null;
    });

    // There is always a change
    markChange();
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/InvalidMethodCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicInterpreter;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Remove invalid methods. WARNING: If some transformer produces invalid bytecode in methods, this transformer will remove them.
 */
public class InvalidMethodCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().parallelStream().forEach(classWrapper -> {
      var iterator = classWrapper.methods().iterator();
      while (iterator.hasNext()) {
        MethodNode methodNode = iterator.next();

        Analyzer<?> analyzer = new Analyzer<>(new BasicInterpreter());
        try {
          analyzer.analyze(classWrapper.name(), methodNode);
        } catch (AnalyzerException e) {
          // Remove invalid method
          LOGGER.warn("Found invalid method: {}#{}{}. Removing...", classWrapper.name(), methodNode.name, methodNode.desc);
          iterator.remove();
          markChange();
        }
      }
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/LineNumberCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import java.util.Arrays;

import org.objectweb.asm.tree.LineNumberNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class LineNumberCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      Arrays.stream(methodNode.instructions.toArray())
          .filter(node -> node instanceof LineNumberNode)
          .forEach(node -> {
            methodNode.instructions.remove(node);
            this.markChange();
          });
    }));
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/LocalVariableNamesCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Removes local variable names.
 */
public class LocalVariableNamesCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(methodNode -> {
          methodNode.localVariables = null;
          this.markChange();
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/MethodDebugInfoCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;

public class MethodDebugInfoCleanTransformer extends ComposedTransformer {
  public MethodDebugInfoCleanTransformer() {
    super(
        LocalVariableNamesCleanTransformer::new,
        ParametersInfoCleanTransformer::new,
        ThrowsExceptionCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/ParametersInfoCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Removes parameter info from methods
 */
public class ParametersInfoCleanTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(methodNode -> {
          methodNode.parameters = null;
          this.markChange();
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/SignatureCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class SignatureCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      classWrapper.classNode().signature = null;
      classWrapper.methods().forEach(methodNode -> methodNode.signature = null);
      classWrapper.fields().forEach(fieldNode -> fieldNode.signature = null);
    });

    // There is always a change
    this.markChange();
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/ThrowsExceptionCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Removes "throws Exception" from methods.
 */
public class ThrowsExceptionCleanTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(methodNode -> {
          methodNode.exceptions = null;
          this.markChange();
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/TryCatchBlockCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class TryCatchBlockCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(methodNode -> {
          methodNode.tryCatchBlocks = null;
          this.markChange();
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/UnknownAttributeCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean;

import org.objectweb.asm.Attribute;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class UnknownAttributeCleanTransformer extends Transformer {

  private boolean changed = false;

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      if (classWrapper.classNode().attrs != null) {
        changed |= classWrapper.classNode().attrs.removeIf(Attribute::isUnknown);
      }
      classWrapper.methods().forEach(methodNode -> {
        if (methodNode.attrs != null) {
          changed |= methodNode.attrs.removeIf(Attribute::isUnknown);
        }
      });
      classWrapper.fields().forEach(fieldNode -> {
        if (fieldNode.attrs != null) {
          changed |= fieldNode.attrs.removeIf(Attribute::isUnknown);
        }
      });
    });

    if (changed) {
      markChange();
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/DeadCodeCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.SourceInterpreter;
import org.objectweb.asm.tree.analysis.SourceValue;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class DeadCodeCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().parallelStream().forEach(classWrapper -> classWrapper.methods().parallelStream().forEach(methodNode -> {
      // We want to use here the traditional analyzer. We want the true dead code.
      Analyzer<SourceValue> analyzer = new Analyzer<>(new SourceInterpreter());
      try {
        analyzer.analyze(classWrapper.name(), methodNode);
      } catch (AnalyzerException e) {
        throw new RuntimeException(e);
      }

      Frame<SourceValue>[] frames = analyzer.getFrames();

      AbstractInsnNode[] insns = methodNode.instructions.toArray();
      for (int i = 0; i < insns.length; i++) {
        AbstractInsnNode insn = insns[i];
        Frame<SourceValue> frame = frames[i];
        if (frame == null && insn.getType() != AbstractInsnNode.LABEL) {
          // Remove unreachable instruction
          methodNode.instructions.remove(insn);
          this.markChange();
        }
      }
    }));
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/JsrInlinerTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import org.objectweb.asm.commons.JSRInlinerAdapter;
import org.objectweb.asm.tree.MethodNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;

/**
 * Inlines very old JSR/RET instructions
 */
public class JsrInlinerTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      for (int i = 0; i < classWrapper.methods().size(); i++) {
        MethodNode methodNode = classWrapper.methods().get(i);

        boolean isJsr = Arrays.stream(methodNode.instructions.toArray()).anyMatch(insn -> insn.getOpcode() == JSR);

        if (isJsr) {
          // Inline JSR instructions
          final JSRInlinerAdapter adapter = new JSRInlinerAdapter(
              methodNode,
              methodNode.access,
              methodNode.name,
              methodNode.desc,
              methodNode.signature,
              methodNode.exceptions.toArray(new String[0])
          );

          methodNode.accept(adapter);
          classWrapper.methods().set(i, adapter);

          markChange();
        }
      }
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/NopCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import java.util.Arrays;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class NopCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(
            methodNode ->
                Arrays.stream(methodNode.instructions.toArray())
                    .filter(node -> node.getOpcode() == NOP)
                    .forEach(node -> {
                      methodNode.instructions.remove(node);
                      this.markChange();
                    }));
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/PopUnUsedLocalVariablesTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.HashSet;
import java.util.Set;

public class PopUnUsedLocalVariablesTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      MethodContext methodContext = MethodContext.framed(classWrapper, methodNode);

      Set<VarInsnNode> varStoresInUse = new HashSet<>();

      // Find all local variables in use
      for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
        if ((insn instanceof VarInsnNode && !insn.isVarStore()) || insn instanceof IincInsnNode) {
          InsnContext insnContext = methodContext.newInsnContext(insn);

          Frame<OriginalSourceValue> frame = insnContext.frame();
          if (frame == null) return;

          int varIndex;
          if (insn instanceof VarInsnNode varInsnNode) {
            varIndex = varInsnNode.var;
          } else {
            varIndex = ((IincInsnNode) insn).var;
          }

          OriginalSourceValue localVariableSourceValue = frame.getLocal(varIndex);
          for (AbstractInsnNode sourceInsn : localVariableSourceValue.insns) {
            // Save var stores in use
            if (sourceInsn.isVarStore()) {
              varStoresInUse.add((VarInsnNode) sourceInsn);
            }
          }
        }
      }

      // Remove all local variables that are not in use
      for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
        if (insn instanceof VarInsnNode varInsnNode && insn.isVarStore()) {
          if (!varStoresInUse.contains(varInsnNode)) {
            InsnContext insnContext = methodContext.newInsnContext(insn);

            // Pop the value from the stack
            insnContext.pop(1);

            methodNode.instructions.remove(insn);

            this.markChange();
          }
        }
      }
    }));

    LOGGER.info("Popped {} unused local variables", this.getChangesCount());
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/UnUsedLabelCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Stream;
import org.objectweb.asm.tree.*;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class UnUsedLabelCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().stream()
        .flatMap(classWrapper -> classWrapper.methods().stream())
        .forEach(
            methodNode -> {
              Set<LabelNode> labelNodes = new HashSet<>();

              if (methodNode.tryCatchBlocks != null)
                labelNodes.addAll(
                    methodNode.tryCatchBlocks.stream()
                        .flatMap(tbce -> Stream.of(tbce.end, tbce.start, tbce.handler))
                        .toList());

              if (methodNode.localVariables != null)
                labelNodes.addAll(
                    methodNode.localVariables.stream()
                        .flatMap(localVariable -> Stream.of(localVariable.end, localVariable.start))
                        .toList());

              Arrays.stream(methodNode.instructions.toArray())
                  .forEach(
                      node -> {
                        if (node instanceof JumpInsnNode) {
                          labelNodes.add(((JumpInsnNode) node).label);
                        } else if (node instanceof LookupSwitchInsnNode lookupSwitchInsnNode) {
                          labelNodes.addAll(lookupSwitchInsnNode.labels);
                          labelNodes.add(lookupSwitchInsnNode.dflt);
                        } else if (node instanceof TableSwitchInsnNode tableSwitchInsnNode) {
                          labelNodes.addAll(tableSwitchInsnNode.labels);
                          labelNodes.add(tableSwitchInsnNode.dflt);
                        } else if (node instanceof LineNumberNode) {
                          labelNodes.add(((LineNumberNode) node).start);
                        }
                      });

              // Remove label nodes that are not used
              Arrays.stream(methodNode.instructions.toArray())
                  .filter(node -> node instanceof LabelNode)
                  .map(LabelNode.class::cast)
                  .filter(node -> !labelNodes.contains(node))
                  .forEach(insn -> {
                    methodNode.instructions.remove(insn);
                    this.markChange();
                  });
            });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/UselessGotosCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;
import java.util.List;

/**
 * Remove useless GOTO jumps
 * <pre>
 * A:
 *   ...
 *   goto B
 * B:
 *   ...
 * </pre>
 */
public class UselessGotosCleanTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
        if (insn.getOpcode() == GOTO) {
          JumpInsnNode jumpInsn = (JumpInsnNode) insn;
          if (jumpInsn.getNext() instanceof LabelNode labelNode && jumpInsn.label == labelNode) {

            // Check if the label is used only by the jump instruction
            if (!isLabelUsedOnlyByInstructions(methodNode, jumpInsn.label)) continue;

            List<AbstractInsnNode> labelUsedInsns = Arrays.stream(methodNode.instructions.toArray())
                .filter(newInsn -> checkIfJumpHappens(newInsn, labelNode))
                .toList();

            boolean labelUsedOnlyOnce = labelUsedInsns.size() == 1;

            if (labelUsedOnlyOnce) {
              // Remove the goto and the label
              methodNode.instructions.remove(labelNode);
              methodNode.instructions.remove(jumpInsn);
              this.markChange();
            }
          }
        }
      }
    }));
  }

  private boolean isLabelUsedOnlyByInstructions(MethodNode methodNode, LabelNode labelNode) {
    if (methodNode.tryCatchBlocks != null) {
      boolean usedByTryCatchBlock = methodNode.tryCatchBlocks.stream()
          .anyMatch(tryCatchBlockNode -> tryCatchBlockNode.start == labelNode || tryCatchBlockNode.end == labelNode || tryCatchBlockNode.handler == labelNode);

      if (usedByTryCatchBlock) {
        return false;
      }
    }

    if (methodNode.localVariables != null) {
      boolean usedByLocalVariable = methodNode.localVariables.stream()
          .anyMatch(localVariableNode -> localVariableNode.start == labelNode || localVariableNode.end == labelNode);

      if (usedByLocalVariable) {
        return false;
      }
    }
    return true;
  }

  private boolean checkIfJumpHappens(AbstractInsnNode insn, LabelNode labelNode) {
    if (insn instanceof JumpInsnNode jumpInsn) {
      return jumpInsn.label == labelNode;
    } else if (insn instanceof LookupSwitchInsnNode lookupSwitchInsn) {
      return lookupSwitchInsn.labels.contains(labelNode) || lookupSwitchInsn.dflt == labelNode;
    } else if (insn instanceof TableSwitchInsnNode tableSwitchInsn) {
      return tableSwitchInsn.labels.contains(labelNode) || tableSwitchInsn.dflt == labelNode;
    }
    return false;
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/clean/peephole/UselessPopCleanTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.clean.peephole;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public class UselessPopCleanTransformer extends Transformer {
  public UselessPopCleanTransformer() {
    this.rerunOnChange = true;
  }

  private final Set<AbstractInsnNode> poppedDups = new HashSet<>();

  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this)
        .editInstructionsStream(stream -> stream.filter(insn -> insn.getOpcode() == POP || insn.getOpcode() == POP2))
        .forEach(insnContext -> {
          boolean success = tryRemovePop(insnContext);

          if (success) {
            insnContext.methodNode().instructions.remove(insnContext.insn());
            markChange();
          }
        });
  }

  /**
   * Tries to remove pop's source values
   *
   * @param insnContext Instruction context
   * @return If removed
   */
  private boolean tryRemovePop(InsnContext insnContext) {
    AbstractInsnNode insn = insnContext.insn();
    OriginalSourceValue firstValue = insnContext.frame().getStack(insnContext.frame().getStackSize() - 1);

    if (!canPop(firstValue)) return false;

    if (insn.getOpcode() == POP) {
      // Pop the value from the stack
      popSourceValue(firstValue, insnContext.methodNode());
      return true;
    } else if (insn.getOpcode() == POP2) {
      if (firstValue.getSize() == 2) {
        // Pop 2-sized value from the stack
        popSourceValue(firstValue, insnContext.methodNode());
      } else {
        // Pop two values from the stack

        int index = insnContext.frame().getStackSize() - 2;
        if (index < 0) return false;
        OriginalSourceValue secondValue = insnContext.frame().getStack(index);
        if (firstValue.getProducer().getOpcode() == DUP) {
          // Extract the original source value from DUP
          secondValue = Objects.requireNonNull(secondValue.copiedFrom);
        }

        // Return if we can't remove the source value
        if (!canPop(secondValue)) return false;

        // Pop
        popSourceValue(firstValue, insnContext.methodNode());
        popSourceValue(secondValue, insnContext.methodNode());
      }
      return true;
    }

    return false;
  }

  /**
   * Checks if source value can be popped
   */
  private boolean canPop(OriginalSourceValue sourceValue) {
    if (sourceValue.insns.isEmpty()) {
      // Nothing to remove. Probably a local variable
      return false;
    }

    // Check if all producers of the source value are constants
    for (AbstractInsnNode producer : sourceValue.insns) {
      // Can be popped if the value is constant
      if (producer.isConstant()) continue;
      // Can be popped if the value is DUP, and it wasn't popped yet
      if (producer.getOpcode() == DUP && !poppedDups.contains(producer)) continue;

      return false;
    }
    return true;
  }

  private void popSourceValue(OriginalSourceValue value, MethodNode methodNode) {
    for (AbstractInsnNode producer : value.insns) {
      if (producer.getOpcode() == DUP) {
        // Prevent popping DUP twice
        poppedDups.add(producer);
      }
      methodNode.instructions.remove(producer);
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/exploit/WebExploitRemoveTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.exploit;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class WebExploitRemoveTransformer extends Transformer {

  private boolean changed = false;

  @Override
  protected void transform() throws Exception {
    changed |= context().getClassesMap().entrySet().removeIf(entry -> entry.getKey().contains("<html>"));
    changed |= context().getFilesMap().entrySet().removeIf(entry -> entry.getKey().contains("<html>"));

    scopedClasses().forEach(classWrapper -> {
      changed |= classWrapper.methods().removeIf(methodNode -> methodNode.name.contains("<html>"));
      changed |= classWrapper.fields().removeIf(fieldNode -> fieldNode.name.contains("<html>") || fieldNode.desc.contains("<html>"));
    });

    if (changed) {
      markChange();
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/hp888/HP888PackerTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.hp888;

import org.objectweb.asm.ClassReader;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.helper.ClassHelper;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

/**
 * HP888 obfuscator has encrypted classes files (usually ending with the suffix ".mc" {@link #encryptedClassFilesSuffix})
 * that are decrypted and loaded when the jar starts.
 */
public class HP888PackerTransformer extends Transformer {

  /**
   * Suffix of encrypted class files
   */
  private final String encryptedClassFilesSuffix;

  public HP888PackerTransformer(String encryptedClassFilesSuffix) {
    this.encryptedClassFilesSuffix = encryptedClassFilesSuffix;
  }

  @Override
  protected void transform() throws Exception {
    Set<String> filesToRemove = new HashSet<>();
    HashMap<String, ClassWrapper> newClasses = new HashMap<>();
    AtomicReference<String> key = new AtomicReference<>();

    /* Firstly you must use HP888StringTransformer, so key would be decrypted,
        and it only searches in loader classes so don't tell me its bad searching. */
    scopedClasses().stream().map(ClassWrapper::classNode).forEach(classNode -> classNode.methods.forEach(methodNode -> methodNode.instructions.forEach(abstractInsnNode -> {
      if (abstractInsnNode.isString() && abstractInsnNode.asString().endsWith("==")) {
        // Find base64 key
        key.set(abstractInsnNode.asString());
      }
    })));

    if (key.get().isEmpty()) {
      LOGGER.error("Key not found");
      return;
    }

    // Decrypt encrypted classes
    Cipher cipher = Cipher.getInstance("AES");
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(Base64.getDecoder().decode(key.get()), "AES"));
    context().getFilesMap().forEach((file, bytes) -> {
      if (file.endsWith(encryptedClassFilesSuffix)) {
        filesToRemove.add(file);

        String path = file.replace(encryptedClassFilesSuffix, ".class").replace(".", "/");
        try {
          // Decrypt!
          byte[] decrypted = cipher.doFinal(bytes);

          // Load and put class
          context().addCompiledClass(path, decrypted);

          markChange();
        } catch (Exception e) {
          throw new RuntimeException("Failed to decrypt class: " + path, e);
        }
      }
    });

    // Cleanup
    filesToRemove.forEach(context().getFilesMap()::remove);
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/hp888/HP888StringTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.hp888;

import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.asm.MethodRef;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.group.SequenceMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.MethodMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.OpcodeMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.StringMatch;
import uwu.narumi.deobfuscator.api.transformer.Transformer;
import uwu.narumi.deobfuscator.core.other.impl.pool.InlineStaticFieldTransformer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Strings are encrypted using a constant pool size of a provided class.
 */
public class HP888StringTransformer extends Transformer {

  private static final Match ENCRYPTED_STRING = SequenceMatch.of(
      StringMatch.of().capture("key"),
      MethodMatch.invokeStatic().desc("(Ljava/lang/String;)Ljava/lang/String;").capture("decrypt-method")
  );

  private static final Match CLASS_FOR_CONSTANT_POOL = SequenceMatch.of(
      MethodMatch.invokeStatic(),
      OpcodeMatch.of(LDC).and(Match.of(ctx -> ((LdcInsnNode) ctx.insn()).cst instanceof Type)).capture("class"),
      MethodMatch.invokeInterface()
  );

  @Override
  protected void transform() throws Exception {
    Set<String> classesToRemove = new HashSet<>();

    scopedClasses().forEach(classWrapper -> {
      List<MethodNode> toRemove = new ArrayList<>();

      // Find all encrypted strings
      classWrapper.methods().forEach(methodNode -> {
        MethodContext methodContext = MethodContext.framed(classWrapper, methodNode);

        // Find encrypted strings
        ENCRYPTED_STRING.findAllMatches(methodContext).forEach(matchContext -> {
          AbstractInsnNode keyInsn = matchContext.captures().get("key").insn();
          MethodInsnNode decryptMethodInsn = (MethodInsnNode) matchContext.captures().get("decrypt-method").insn();
          MethodRef methodRef = MethodRef.of(decryptMethodInsn);

          // Get decrypt method
          findMethod(classWrapper.classNode(), methodRef).ifPresent(decryptMethod -> {
            String key = keyInsn.asString();

            MethodContext decryptMethodContext = MethodContext.framed(classWrapper, decryptMethod);

            // Find class for constant pool
            LdcInsnNode constantPoolClassLdc = (LdcInsnNode) CLASS_FOR_CONSTANT_POOL.findAllMatches(decryptMethodContext)
                .get(0).captures().get("class").insn();
            Type classForConstantPoolType = (Type) constantPoolClassLdc.cst;

            // Prepare data for decryption
            ClassWrapper classForConstantPool = context().getClassesMap().get(classForConstantPoolType.getInternalName());
            int constantPoolSize = classForConstantPool.getConstantPool().getSize();
            String class0 = classWrapper.name();
            String class1 = classWrapper.name();

            // Decrypt!
            String decryptedString = decrypt(key, constantPoolSize, class0.hashCode(), class1.hashCode());

            methodNode.instructions.remove(keyInsn);
            methodNode.instructions.set(decryptMethodInsn, new LdcInsnNode(decryptedString));
            markChange();

            classesToRemove.add(classWrapper.name());

            toRemove.add(decryptMethod);
          });
        });
      });
      classWrapper.methods().removeAll(toRemove);
    });

    // Inline static fields
    Transformer.transform(InlineStaticFieldTransformer::new, scope(), context());

    // Cleanup
    classesToRemove.forEach(className -> context().getClassesMap().remove(className));
  }

  private String decrypt(String string, int constantPoolSize, int className0HashCode, int className1HashCode) {
    char[] charArray = string.toCharArray();
    int i = 0;
    for (char character : charArray) {
      character = (char) (character ^ constantPoolSize);
      character = (char) (character ^ className0HashCode);
      charArray[i] = (char) (character ^ className1HashCode);
      ++i;
    }
    return new String(charArray);
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/pool/InlineLocalVariablesTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.pool;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Inlines constant local variables
 */
public class InlineLocalVariablesTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this)
        .editInstructionsStream(stream -> stream.filter(AbstractInsnNode::isVarLoad))
        .forEach(insnContext -> {
          VarInsnNode varInsn = (VarInsnNode) insnContext.insn();

          // Var store instruction
          OriginalSourceValue storeVarSourceValue = insnContext.frame().getLocal(varInsn.var);
          // Value reference
          OriginalSourceValue valueSourceValue = storeVarSourceValue.copiedFrom;
          if (valueSourceValue == null || !valueSourceValue.originalSource.isOneWayProduced() || !storeVarSourceValue.getProducer().isVarStore()) return;

          // Original source value on which we can operate
          AbstractInsnNode valueInsn = valueSourceValue.originalSource.getProducer();

          if (valueInsn.isConstant()) {
            AbstractInsnNode clone = valueInsn.clone(null);
            insnContext.methodNode().instructions.set(insnContext.insn(), clone);

            markChange();
          }
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/pool/InlineStaticArrayFieldTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.pool;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

// TODO: Don't inline value from array if it's overridden from different method than the one where
// array was created
// TODO: Don't inline array if it's overridden from different method than the where array was
// created
// TODO: Rewrite it entirely
public class InlineStaticArrayFieldTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    throw new UnsupportedOperationException("Not implemented yet");
  }

//  private static final Object NULL = new Object();
//
//  private static final Match UNBOX =
//      MethodMatch.invokeVirtual()
//          .name(
//              "intValue",
//              "longValue",
//              "shortValue",
//              "byteValue",
//              "floatValue",
//              "doubleValue",
//              "charValue",
//              "booleanValue");
//
//  private static final Match SET_STATIC_MATCHER =
//      AnyMatch.of(
//          FieldMatch.putStatic().desc("[Ljava/lang/Number;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Integer;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Float;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Short;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Double;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Byte;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Long;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Boolean;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Character;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Object;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/String;"),
//          FieldMatch.putStatic().desc("[Ljava/lang/Class;"),
//          FieldMatch.putStatic().desc("[I"),
//          FieldMatch.putStatic().desc("[J"),
//          FieldMatch.putStatic().desc("[F"),
//          FieldMatch.putStatic().desc("[D"),
//          FieldMatch.putStatic().desc("[S"),
//          FieldMatch.putStatic().desc("[C"),
//          FieldMatch.putStatic().desc("[B"),
//          FieldMatch.putStatic().desc("[Z"));
//
//  private static final InstructionMatcher ARRAY_INIT_MATCHER =
//      InstructionMatcher.builder()
//          .matches(
//              IntegerMatch.of(),
//              AnyMatch.of(
//                  TypeMatch.of(ANEWARRAY, "java/lang/Number"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Integer"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Float"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Short"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Double"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Byte"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Long"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Boolean"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Character"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Object"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/String"),
//                  TypeMatch.of(ANEWARRAY, "java/lang/Class"),
//                  IntInsnMatch.of(NEWARRAY, T_BOOLEAN),
//                  IntInsnMatch.of(NEWARRAY, T_INT),
//                  IntInsnMatch.of(NEWARRAY, T_BYTE),
//                  IntInsnMatch.of(NEWARRAY, T_CHAR),
//                  IntInsnMatch.of(NEWARRAY, T_FLOAT),
//                  IntInsnMatch.of(NEWARRAY, T_DOUBLE),
//                  IntInsnMatch.of(NEWARRAY, T_LONG),
//                  IntInsnMatch.of(NEWARRAY, T_SHORT)))
//          .build();
//
//  private static final InstructionMatcher ARRAY_STORE_MATCHER =
//      InstructionMatcher.builder()
//          .matches(
//              FieldMatch.getStatic(),
//              IntegerMatch.of(),
//              AnyMatch.of(
//                  IntegerMatch.of(),
//                  LongMatch.of(),
//                  FloatMatch.of(),
//                  DoubleMatch.of(),
//                  TypeMatch.of(),
//                  StringMatch.of(),
//                  OpcodeMatch.of(ACONST_NULL)))
//          .build();
//
//  private static final InstructionMatcher ARRAY_DUP_STORE_MATCHER =
//      InstructionMatcher.builder()
//          .matches(
//              OpcodeMatch.of(DUP),
//              IntegerMatch.of(),
//              AnyMatch.of(
//                  IntegerMatch.of(),
//                  LongMatch.of(),
//                  FloatMatch.of(),
//                  DoubleMatch.of(),
//                  TypeMatch.of(),
//                  StringMatch.of(),
//                  OpcodeMatch.of(ACONST_NULL)))
//          .build();
//
//  private static final InstructionMatcher LOAD_VALUE_MATCHER =
//      InstructionMatcher.builder()
//          .matches(
//              AnyMatch.of(
//                  FieldMatch.getStatic().desc("[Ljava/lang/Number;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Integer;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Float;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Short;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Double;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Byte;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Long;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Boolean;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Character;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Object;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/String;"),
//                  FieldMatch.getStatic().desc("[Ljava/lang/Class;"),
//                  FieldMatch.getStatic().desc("[I"),
//                  FieldMatch.getStatic().desc("[J"),
//                  FieldMatch.getStatic().desc("[F"),
//                  FieldMatch.getStatic().desc("[D"),
//                  FieldMatch.getStatic().desc("[S"),
//                  FieldMatch.getStatic().desc("[C"),
//                  FieldMatch.getStatic().desc("[B"),
//                  FieldMatch.getStatic().desc("[Z")),
//              IntegerMatch.of(),
//              AnyMatch.of(
//                  OpcodeMatch.of(AALOAD),
//                  OpcodeMatch.of(IALOAD),
//                  OpcodeMatch.of(LALOAD),
//                  OpcodeMatch.of(FALOAD),
//                  OpcodeMatch.of(DALOAD),
//                  OpcodeMatch.of(CALOAD),
//                  OpcodeMatch.of(SALOAD),
//                  OpcodeMatch.of(BALOAD)))
//          .build();
//
//  private final boolean scanOnlyStaticBlock;
//  private final AtomicInteger index = new AtomicInteger();
//
//  public InlineStaticArrayFieldTransformer() {
//    this(false);
//  }
//
//  public InlineStaticArrayFieldTransformer(boolean scanOnlyStaticBlock) {
//    this.scanOnlyStaticBlock = scanOnlyStaticBlock;
//  }
//
//  @Override
//  protected void transform(ClassWrapper scope, Context context) throws Exception {
//    context
//        .classes(scope)
//        .forEach(
//            classWrapper -> {
//              if (scanOnlyStaticBlock) {
//                classWrapper
//                    .findClInit()
//                    .ifPresent(staticBlock -> extractData(classWrapper, staticBlock, context));
//              } else {
//                List.copyOf(classWrapper.methods())
//                    .forEach(methodNode -> extractData(classWrapper, methodNode, context));
//              }
//            });
//
//    LOGGER.info("Collected {} objects from {} classes", index.get(), context.classes().size());
//    context
//        .classes(scope)
//        .forEach(
//            classWrapper -> {
//              classWrapper
//                  .methods()
//                  .forEach(
//                      methodNode ->
//                          LOAD_VALUE_MATCHER
//                              .bind(classWrapper.getClassNode(), methodNode)
//                              .modifyAll(
//                                  (result, method) -> {
//                                    FieldInsnNode node = result.get(0);
//                                    if (!classWrapper.getFieldCache().has(node)
//                                        || !classWrapper.getFieldCache().isPresent(node)) return;
//
//                                    Object value =
//                                        classWrapper
//                                            .getFieldCache()
//                                            .<Map<Integer, Object>>get(node)
//                                            .get(result.get(1).asInteger());
//                                    if (value == null) return;
//
//                                    if (value instanceof String || value instanceof Type) {
//                                      method.instructions.insertBefore(
//                                          result.start(), new LdcInsnNode(value));
//                                    } else if (value == NULL) {
//                                      method.instructions.insertBefore(
//                                          result.start(), new InsnNode(ACONST_NULL));
//                                    } else if (value instanceof Number number) {
//                                      method.instructions.insertBefore(
//                                          result.start(), getNumber(number));
//                                      if (result.end().next().matches(UNBOX))
//                                        method.instructions.remove(result.end().next());
//                                    } else if (value instanceof Boolean bool) {
//                                      method.instructions.insertBefore(
//                                          result.start(), getNumber(bool ? 1 : 0));
//                                      if (result.end().next().matches(UNBOX))
//                                        method.instructions.remove(result.end().next());
//                                    } else if (value instanceof Character character) {
//                                      method.instructions.insertBefore(
//                                          result.start(), getNumber(character));
//                                      if (result.end().next().matches(UNBOX))
//                                        method.instructions.remove(result.end().next());
//                                    }
//
//                                    result.remove();
//                                    this.markChange();
//                                  }));
//            });
//
//    LOGGER.info("Inlined {} objects in {} classes", this.getChangesCount(), context.classes().size());
//  }
//
//  private void extractData(ClassWrapper classWrapper, MethodNode methodNode, Context context) {
//    Arrays.stream(methodNode.instructions.toArray())
//        .filter(node1 -> SET_STATIC_MATCHER.test(node1, , ))
//        .map(FieldInsnNode.class::cast)
//        .filter(node -> context.get(node.owner).isPresent())
//        .filter(node -> !ARRAY_INIT_MATCHER.match(node.previous(3)))
//        .forEach(
//            node -> {
//              ClassWrapper owner = context.get(node.owner).get();
//              {
//                for (Result result : ARRAY_STORE_MATCHER.bind(classWrapper.getClassNode(), methodNode).collect()) {
//                  FieldInsnNode fieldNode = result.get(0);
//                  if (!fieldNode.owner.equals(node.owner)
//                      || !fieldNode.name.equals(node.name)
//                      || !fieldNode.desc.equals(node.desc)) continue;
//
//                  int position = result.get(1).asInteger();
//                  AbstractInsnNode valueNode = result.get(2);
//                  Object value = putValue(owner, fieldNode, position, valueNode);
//                  if (value instanceof Number
//                      || value instanceof Boolean
//                      || value instanceof Character) {
//                    //
//                    // methodNode.instructions.remove(result.end().next().next()); //boxing
//                  }
//                  //                        methodNode.instructions.remove(result.end().next());
//                  // //aastore
//                  //                        result.remove();
//                  index.incrementAndGet();
//                }
//
//                //                    methodNode.instructions.remove(node.getPrevious(2));
//                //                    methodNode.instructions.remove(node.getPrevious());
//                //                    methodNode.instructions.remove(node);
//                //                    owner.fields().removeIf(fieldNode ->
//                // fieldNode.name.equals(node.name) && fieldNode.desc.equals(node.desc));
//              }
//
//              {
//                AbstractInsnNode last =
//                    node.walkPreviousUntil(
//                        ARRAY_INIT_MATCHER::match,
//                        insn ->
//                            ARRAY_DUP_STORE_MATCHER.match(
//                                insn,
//                                result -> {
//                                  int position = result.get(1).asInteger();
//                                  AbstractInsnNode valueNode = result.get(2);
//                                  Object value = putValue(owner, node, position, valueNode);
//                                  index.incrementAndGet();
//                                }));
//              }
//            });
//
//    if (!methodNode.name.startsWith("<")
//        && methodNode.desc.equals("()V")
//        && isAccess(methodNode.access, ACC_STATIC)
//        && Arrays.stream(methodNode.instructions.toArray())
//                .filter(node -> !(node instanceof LabelNode))
//                .filter(node -> !(node instanceof FrameNode))
//                .filter(node -> !(node instanceof LineNumberNode))
//                .filter(node -> node.getOpcode() != NOP)
//                .count()
//            <= 1) {
//
//      classWrapper.methods().remove(methodNode);
//      classWrapper
//          .methods()
//          .forEach(
//              method ->
//                  Arrays.stream(method.instructions.toArray())
//                      .filter(node -> node instanceof MethodInsnNode)
//                      .map(MethodInsnNode.class::cast)
//                      .filter(node -> node.owner.equals(classWrapper.name()))
//                      .filter(node -> node.name.equals(methodNode.name))
//                      .filter(node -> node.desc.equals(methodNode.desc))
//                      .forEach(method.instructions::remove));
//    }
//  }
//
//  private Object putValue(
//      ClassWrapper owner, FieldInsnNode fieldNode, int position, AbstractInsnNode valueNode) {
//    Object value = null;
//    if (valueNode.isInteger()) {
//      value = valueNode.asInteger();
//    } else if (valueNode.isLong()) {
//      value = valueNode.asLong();
//    } else if (valueNode.isFloat()) {
//      value = valueNode.asFloat();
//    } else if (valueNode.isDouble()) {
//      value = valueNode.asDouble();
//    } else if (valueNode.isString()) {
//      value = valueNode.asString();
//    } else if (valueNode.isType()) {
//      value = valueNode.asType();
//    } else if (valueNode.getOpcode() == ACONST_NULL) {
//      value = NULL;
//    }
//
//    if (value == null) return value;
//
//    owner
//        .getFieldCache()
//        .getOrCompute(fieldNode, new HashMap<Integer, Object>())
//        .put(position, value);
//    return value;
//  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/pool/InlineStaticFieldTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.pool;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.asm.FieldRef;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;
import uwu.narumi.deobfuscator.api.helper.MethodHelper;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Inlines constant static fields
 */
public class InlineStaticFieldTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    Set<FieldRef> notConstantFields = new HashSet<>();
    Map<FieldRef, AbstractInsnNode> staticConstantFields = new HashMap<>();

    // Find all static constant fields
    scopedClasses().forEach(classWrapper -> findClInit(classWrapper.classNode()).ifPresent(clInit -> {
      var frames = MethodHelper.analyzeSource(classWrapper.classNode(), clInit);

      Arrays.stream(clInit.instructions.toArray())
          .filter(insn -> insn.getOpcode() == PUTSTATIC)
          .map(FieldInsnNode.class::cast)
          .forEach(insn -> {
            Frame<OriginalSourceValue> frame = frames.get(insn);
            if (frame == null) return;

            FieldRef fieldRef = FieldRef.of(insn);

            if (notConstantFields.contains(fieldRef)) return;

            if (staticConstantFields.containsKey(fieldRef)) {
              // It seems that it is not a constant. Its value is modified elsewhere
              notConstantFields.add(fieldRef);
              staticConstantFields.remove(fieldRef);
              return;
            }

            OriginalSourceValue sourceValue = frame.getStack(frame.getStackSize() - 1);
            if (!sourceValue.originalSource.isOneWayProduced()) return;

            AbstractInsnNode valueInsn = sourceValue.originalSource.getProducer();
            if (valueInsn.isConstant()) {
              // We have constant static field
              staticConstantFields.put(FieldRef.of(insn), valueInsn);
            } else {
              notConstantFields.add(fieldRef);
            }
          });
    }));

    // Also account for FieldNode#value
    scopedClasses().forEach(classWrapper -> {
      classWrapper.classNode().fields.forEach(fieldNode -> {
        if (fieldNode.value != null) {
          FieldRef fieldRef = FieldRef.of(classWrapper.classNode(), fieldNode);

          if (!staticConstantFields.containsKey(fieldRef)) {
            // Add it to static constant fields
            staticConstantFields.put(fieldRef, AsmHelper.toConstantInsn(fieldNode.value));
          }
        }
      });
    });

    // Check if these static fields aren't modified outside clinit
    scopedClasses().forEach(classWrapper -> classWrapper.methods().stream()
        .filter(methodNode -> !methodNode.name.equals("<clinit>"))
        .forEach(methodNode -> {
          Arrays.stream(methodNode.instructions.toArray())
              .filter(insn -> insn.getOpcode() == PUTSTATIC)
              .map(FieldInsnNode.class::cast)
              .forEach(insn -> {
                FieldRef fieldRef = FieldRef.of(insn);
                // Remove not constant field
                staticConstantFields.remove(fieldRef);
              });
        }));

    // Replace static fields accesses with corresponding values
    Set<FieldRef> inlinedFields = new HashSet<>();
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      Arrays.stream(methodNode.instructions.toArray())
          .filter(insn -> insn.getOpcode() == GETSTATIC)
          .map(FieldInsnNode.class::cast)
          .forEach(insn -> {
            FieldRef fieldRef = FieldRef.of(insn);
            AbstractInsnNode constValue = staticConstantFields.get(fieldRef);
            if (constValue != null) {
              // Replace it!
              methodNode.instructions.set(insn, constValue.clone(null));

              // Add to an inlined fields list
              inlinedFields.add(fieldRef);

              this.markChange();
            }
          });
    }));

    // Remove fields that were inlined
    scopedClasses().parallelStream().forEach(classWrapper -> {
      // Remove field
      classWrapper.classNode().fields.removeIf(fieldNode -> inlinedFields.contains(FieldRef.of(classWrapper.classNode(), fieldNode)));

      // Replace PUTSTATIC with POP
      classWrapper.findClInit().ifPresent(methodNode -> {
        Map<AbstractInsnNode, Frame<BasicValue>> frames = MethodHelper.analyzeBasic(classWrapper.classNode(), methodNode);

        Arrays.stream(methodNode.instructions.toArray())
            .filter(insn -> insn.getOpcode() == PUTSTATIC)
            .map(FieldInsnNode.class::cast)
            .forEach(insn -> {
              FieldRef fieldRef = FieldRef.of(insn);
              if (inlinedFields.contains(fieldRef)) {
                Frame<BasicValue> frame = frames.get(insn);
                BasicValue value = frame.getStack(frame.getStackSize() - 1);

                // Replace insn with pop
                methodNode.instructions.set(insn, AsmHelper.toPop(value));
              }
            });
      });
    });

    LOGGER.info("Inlined {} constant static fields", this.getChangesCount());
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/AccessRepairTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class AccessRepairTransformer extends Transformer {

  private final int[] CLASS = {
      ACC_STATIC,
      ACC_SYNCHRONIZED,
      ACC_OPEN,
      ACC_TRANSITIVE,
      ACC_VOLATILE,
      ACC_BRIDGE,
      ACC_STATIC_PHASE,
      ACC_VARARGS,
      ACC_TRANSIENT,
      ACC_NATIVE,
      ACC_STRICT,
      ACC_SYNTHETIC
  };

  private final int[] METHOD = {
      ACC_SUPER,
      ACC_OPEN,
      ACC_TRANSITIVE,
      ACC_VOLATILE,
      ACC_STATIC_PHASE,
      ACC_TRANSIENT,
      ACC_INTERFACE,
      ACC_ANNOTATION,
      ACC_ENUM,
      ACC_MODULE,
      ACC_RECORD,
      ACC_SYNTHETIC,
      ACC_BRIDGE
  };

  private final int[] FIELD = {
      ACC_SUPER,
      ACC_SYNCHRONIZED,
      ACC_OPEN,
      ACC_TRANSITIVE,
      ACC_BRIDGE,
      ACC_STATIC_PHASE,
      ACC_VARARGS,
      ACC_NATIVE,
      ACC_INTERFACE,
      ACC_ABSTRACT,
      ACC_STRICT,
      ACC_ANNOTATION,
      ACC_MODULE,
      ACC_RECORD,
      ACC_SYNTHETIC
  };

  private final int[] PARAMETER = {
      ACC_PUBLIC,
      ACC_PRIVATE,
      ACC_PROTECTED,
      ACC_STATIC,
      ACC_SUPER,
      ACC_SYNCHRONIZED,
      ACC_OPEN,
      ACC_TRANSITIVE,
      ACC_VOLATILE,
      ACC_BRIDGE,
      ACC_STATIC_PHASE,
      ACC_VARARGS,
      ACC_TRANSIENT,
      ACC_NATIVE,
      ACC_INTERFACE,
      ACC_ABSTRACT,
      ACC_STRICT,
      ACC_ANNOTATION,
      ACC_ENUM,
      ACC_MODULE,
      ACC_RECORD,
      ACC_DEPRECATED,
      ACC_SYNTHETIC
  };

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      int classAccess = classWrapper.classNode().access;
      for (int access : CLASS) {
        if (isAccess(classAccess, access)) {
          classAccess &= ~access;
          this.markChange();
        }
      }
      classWrapper.classNode().access = classAccess;

      classWrapper.methods().forEach(methodNode -> {
        for (int access : METHOD) {
          if (isAccess(methodNode.access, access)) {
            methodNode.access &= ~access;
            this.markChange();
          }
        }

        if (methodNode.parameters != null)
          methodNode.parameters.forEach(parameterNode -> {
            for (int access : PARAMETER) {
              if (isAccess(parameterNode.access, access)) {
                parameterNode.access &= ~access;
                this.markChange();
              }
            }
          });
      });

      classWrapper.fields().forEach(fieldNode -> {
        for (int access : FIELD) {
          if (isAccess(fieldNode.access, access)) {
            fieldNode.access &= ~access;
            this.markChange();
          }
        }
      });

      // TODO: Module maybe?
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/AnnotationFilterTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import java.util.List;
import java.util.function.Predicate;

import org.objectweb.asm.tree.AnnotationNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class AnnotationFilterTransformer extends Transformer {

  private static final Predicate<AnnotationNode> ANNOTATION_NODE_PREDICATE =
      annotationNode ->
          annotationNode.desc == null
              || annotationNode.desc.length() <= 3
              || !annotationNode.desc.startsWith("L")
              || !annotationNode.desc.endsWith(";")
              || annotationNode.desc.contains("\n")
              || annotationNode.desc.contains("\u0000")
              || annotationNode.desc.contains(" ");

  private boolean changed = false;

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      if (classWrapper.classNode().invisibleAnnotations != null)
        changed |= classWrapper
            .classNode()
            .invisibleAnnotations
            .removeIf(ANNOTATION_NODE_PREDICATE);

      if (classWrapper.classNode().visibleAnnotations != null)
        changed |= classWrapper.classNode().visibleAnnotations.removeIf(ANNOTATION_NODE_PREDICATE);

      classWrapper.methods().forEach(methodNode -> {
        if (methodNode.invisibleAnnotations != null)
          changed |= methodNode.invisibleAnnotations.removeIf(ANNOTATION_NODE_PREDICATE);

        if (methodNode.visibleAnnotations != null)
          changed |= methodNode.visibleAnnotations.removeIf(ANNOTATION_NODE_PREDICATE);

        if (methodNode.invisibleParameterAnnotations != null)
          for (List<AnnotationNode> invisibleParameterAnnotation : methodNode.invisibleParameterAnnotations) {
            if (invisibleParameterAnnotation == null) continue;

            changed |= invisibleParameterAnnotation.removeIf(ANNOTATION_NODE_PREDICATE);
          }

        if (methodNode.visibleParameterAnnotations != null)
          for (List<AnnotationNode> visibleParameterAnnotation : methodNode.visibleParameterAnnotations) {
            if (visibleParameterAnnotation == null) continue;

            changed |= visibleParameterAnnotation.removeIf(ANNOTATION_NODE_PREDICATE);
          }
      });

      classWrapper.fields().forEach(fieldNode -> {
        if (fieldNode.invisibleAnnotations != null)
          changed |= fieldNode.invisibleAnnotations.removeIf(ANNOTATION_NODE_PREDICATE);

        if (fieldNode.visibleAnnotations != null)
          changed |= fieldNode.visibleAnnotations.removeIf(ANNOTATION_NODE_PREDICATE);
      });
    });

    if (changed) {
      markChange();
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/RecoverSyntheticsTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import uwu.narumi.deobfuscator.api.transformer.Transformer;

public class RecoverSyntheticsTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      classWrapper.methods().forEach(methodNode -> {
        // Recover by name
        if (methodNode.name.startsWith("lambda$")) {
          // Mark as synthetic
          methodNode.access |= ACC_SYNTHETIC;
          markChange();
        }
      });
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/TryCatchRepairTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import org.objectweb.asm.tree.LabelNode;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

// TODO: Will probably shit itself
public class TryCatchRepairTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().forEach(methodNode -> {
      methodNode.tryCatchBlocks.removeIf(tryCatchBlock -> {
        LabelNode start = tryCatchBlock.start;
        LabelNode handler = tryCatchBlock.handler;
        LabelNode end = tryCatchBlock.end;

        if (start.equals(end) || start.equals(handler) || end.equals(handler)) {
          // Try-catch has overlapping labels. Remove it.
          markChange();
          return true;
        }

        // Check if try-catch labels exist
        if (methodNode.instructions.indexOf(start) == -1 || methodNode.instructions.indexOf(handler) == -1 || methodNode.instructions.indexOf(end) == -1) {
          return true;
        }

        // Check if try-catch labels are in the correct order
        return methodNode.instructions.indexOf(start) >= methodNode.instructions.indexOf(handler)
            || methodNode.instructions.indexOf(start) >= methodNode.instructions.indexOf(end)
            || methodNode.instructions.indexOf(handler) <= methodNode.instructions.indexOf(end);
      });

      // Remove exceptions that are already caught by try-catch blocks
      methodNode.exceptions.removeIf(exception ->
          methodNode.tryCatchBlocks.stream().noneMatch(tryCatch -> tryCatch.type != null && tryCatch.type.equals(exception))
      );
    }));
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/UniversalFlowTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.DeadCodeCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.flow.CleanRedundantJumpsTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.flow.CleanRedundantSwitchesTransformer;

public class UniversalFlowTransformer extends ComposedTransformer {
  public UniversalFlowTransformer() {
    super(
        // Resolve all number operations in the first place
        UniversalNumberTransformer::new,

        // Clean up redundant ifs and switches
        CleanRedundantJumpsTransformer::new,
        CleanRedundantSwitchesTransformer::new,

        // Last thing will be to clean up all dead code that is unreachable
        DeadCodeCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/UniversalNumberTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal;

import uwu.narumi.deobfuscator.api.transformer.ComposedTransformer;
import uwu.narumi.deobfuscator.core.other.impl.clean.peephole.UselessPopCleanTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.number.MathBinaryOperationsTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.number.MethodCallsOnLiteralsTransformer;
import uwu.narumi.deobfuscator.core.other.impl.universal.number.MathUnaryOperationsTransformer;

/**
 * Simplifies number operations on constant values.
 */
public class UniversalNumberTransformer extends ComposedTransformer {
  public UniversalNumberTransformer() {
    super(
        () -> new ComposedTransformer(true,
            MethodCallsOnLiteralsTransformer::new,
            MathBinaryOperationsTransformer::new,
            MathUnaryOperationsTransformer::new
        ),

        UselessPopCleanTransformer::new
    );
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/flow/CleanRedundantJumpsTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal.flow;

import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.MethodNode;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Optional;

public class CleanRedundantJumpsTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this).forEach(insnContext -> {
      if (!(insnContext.insn() instanceof JumpInsnNode jumpInsn)) return;

      Optional<Boolean> optIfResult = AsmMathHelper.predictIf(jumpInsn, insnContext.frame());

      if (optIfResult.isEmpty()) return;

      boolean ifResult = optIfResult.get();

      if (AsmMathHelper.isOneValueCondition(jumpInsn.getOpcode())) {
        insnContext.pop(1);
      } else if (AsmMathHelper.isTwoValuesCondition(jumpInsn.getOpcode())) {
        insnContext.pop(2);
      }

      // Replace if with corresponding GOTO or remove it
      processRedundantIfStatement(insnContext.methodNode(), jumpInsn, ifResult);

      markChange();
    });
  }

  private void processRedundantIfStatement(MethodNode methodNode, JumpInsnNode ifStatement, boolean ifResult) {
    if (!ifResult) {
      // Remove unreachable if statement
      methodNode.instructions.remove(ifStatement);
    } else {
      // Replace always reachable if statement with GOTO
      ifStatement.setOpcode(GOTO);
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/flow/CleanRedundantSwitchesTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal.flow;

import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.Optional;

/**
 * Clean redundant LOOKUPSWITCH and TABLESWITCH instructions
 */
public class CleanRedundantSwitchesTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this).forEach(insnContext -> {
      if (insnContext.insn().getOpcode() == LOOKUPSWITCH) {
        LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnContext.insn();

        Optional<LabelNode> optPredictedJump = AsmMathHelper.predictLookupSwitch(lookupSwitchInsn, insnContext.frame());
        if (optPredictedJump.isEmpty()) return;

        LabelNode predictedJump = optPredictedJump.get();
        // Remove value from stack
        insnContext.pop(1);
        // Replace lookup switch with predicted jump
        insnContext.methodNode().instructions.set(lookupSwitchInsn, new JumpInsnNode(GOTO, predictedJump));

        markChange();
      } else if (insnContext.insn().getOpcode() == TABLESWITCH) {
        TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnContext.insn();

        Optional<LabelNode> optPredictedJump = AsmMathHelper.predictTableSwitch(tableSwitchInsn, insnContext.frame());
        if (optPredictedJump.isEmpty()) return;

        LabelNode predictedJump = optPredictedJump.get();
        // Remove value from stack
        insnContext.pop(1);
        // Replace lookup switch with predicted jump
        insnContext.methodNode().instructions.set(tableSwitchInsn, new JumpInsnNode(GOTO, predictedJump));

        markChange();
      }
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/number/MathBinaryOperationsTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal.number;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Simplifies math operations on two constant values.
 */
public class MathBinaryOperationsTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this)
        .editInstructionsStream(stream -> stream.filter(insn -> AsmMathHelper.isMathBinaryOperation(insn.getOpcode())))
        .forEach(insnContext -> {
          // Get instructions from stack that are passed
          OriginalSourceValue value1SourceValue = insnContext.frame().getStack(insnContext.frame().getStackSize() - 2);
          OriginalSourceValue value2SourceValue = insnContext.frame().getStack(insnContext.frame().getStackSize() - 1);
          if (!value1SourceValue.originalSource.isOneWayProduced() || !value2SourceValue.originalSource.isOneWayProduced()) {
            return;
          }

          AbstractInsnNode value1Insn = value1SourceValue.originalSource.getProducer();
          AbstractInsnNode value2Insn = value2SourceValue.originalSource.getProducer();

          if (value1Insn.isNumber() && value2Insn.isNumber()) {
            Number value1 = value1Insn.asNumber();
            Number value2 = value2Insn.asNumber();

            Number result;
            try {
              result = AsmMathHelper.mathBinaryOperation(value1, value2, insnContext.insn().getOpcode());
            } catch (ArithmeticException e) {
              // Skip division by zero
              return;
            }

            insnContext.pop(2);
            insnContext.methodNode().instructions.set(insnContext.insn(), AsmHelper.numberInsn(result));

            markChange();
          }
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/number/MathUnaryOperationsTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal.number;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.analysis.OriginalSourceValue;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Simplifies number casts on constant value.
 */
public class MathUnaryOperationsTransformer extends Transformer {
  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this)
        .editInstructionsStream(stream -> stream.filter(insn -> AsmMathHelper.isMathUnaryOperation(insn.getOpcode())))
        .forEach(insnContext -> {
          // Get instructions from stack that are passed
          OriginalSourceValue sourceValue = insnContext.frame().getStack(insnContext.frame().getStackSize() - 1);
          OriginalSourceValue originalSource = sourceValue.originalSource;
          if (!originalSource.isOneWayProduced()) return;

          AbstractInsnNode valueInsn = originalSource.getProducer();

          if (valueInsn.isNumber()) {
            Number castedNumber = AsmMathHelper.mathUnaryOperation(valueInsn.asNumber(), insnContext.insn().getOpcode());

            insnContext.pop(1);
            insnContext.methodNode().instructions.set(insnContext.insn(), AsmHelper.numberInsn(castedNumber));

            markChange();
          }
        });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/universal/number/MethodCallsOnLiteralsTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.universal.number;

import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.helper.AsmMathHelper;
import uwu.narumi.deobfuscator.api.helper.FramedInstructionsStream;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

/**
 * Simplifies method calls on constant literals.
 */
public class MethodCallsOnLiteralsTransformer extends Transformer {

  @Override
  protected void transform() throws Exception {
    FramedInstructionsStream.of(this).forEach(insnContext -> {
      // Transform method calls on literals
      for (Match mathMatch : AsmMathHelper.METHOD_CALLS_ON_LITERALS) {
        if (mathMatch.matches(insnContext)) {
          boolean success = mathMatch.transformation().transform(insnContext);
          if (success) {
            markChange();
          }
        }
      }
    });
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/zkm/ZelixLongEncryptionMPCTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.zkm;

import dev.xdark.ssvm.invoke.Argument;
import dev.xdark.ssvm.mirror.type.InstanceClass;
import dev.xdark.ssvm.value.ObjectValue;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import uwu.narumi.deobfuscator.api.asm.ClassWrapper;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.FieldMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.MethodMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.NumberMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.StackMatch;
import uwu.narumi.deobfuscator.api.context.Context;
import uwu.narumi.deobfuscator.api.execution.SandBox;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Decrypts {@code long} numbers that uses a technique called Method Parameter Changes. When an author specified
 * the {@code classInitializationOrderStatement} option then you also need to pass it to the constructor. But don't worry.
 * The deobfuscator will tell you if this will be needed.
 *
 * <p>ZKM version: 22.0.3
 *
 * <p>References:
 * <ul>
 * <li>https://www.zelix.com/klassmaster/featuresLongEncryption.html</li>
 * <li>https://www.zelix.com/klassmaster/featuresMethodParameterChanges.html</li>
 * <li>https://www.zelix.com/klassmaster/docs/classInitializationOrderStatement.html</li>
 * </ul>
 *
 * <p>Example long decrypter usage in zelix is here {@link reverseengineering.zelix.longdecrypter.Main} and:
 * <pre>
 * {@code
 *   ldc 5832394289974403481L
 *   ldc -8943439614781261032L
 *   invokestatic java/lang/invoke/MethodHandles.lookup ()Ljava/lang/invoke/MethodHandles$Lookup;
 *   invokevirtual java/lang/invoke/MethodHandles$Lookup.lookupClass ()Ljava/lang/Class;
 *   // Create decrypter
 *   invokestatic me/frep/vulcan/spigot/Vulcan_m.a (JJLjava/lang/Object;)Lme/frep/vulcan/spigot/Vulcan_a;
 *   ldc 19597665297729L
 *   // Decrypt method
 *   invokeinterface me/frep/vulcan/spigot/Vulcan_a.a (J)J
 *   putstatic io/github/repooper/packetevents/PacketEventsPlugin.a J
 * }
 * </pre>
 */
public class ZelixLongEncryptionMPCTransformer extends Transformer {

  private static final Match DECRYPT_LONG_MATCHER = FieldMatch.putStatic().desc("J")
      // Decrypt
      .and(StackMatch.of(0, MethodMatch.invokeInterface().desc("(J)J")
          .and(StackMatch.of(0, NumberMatch.numLong().capture("decrypt-key"))) // Decrypt key
          // Create decrypter
          .and(StackMatch.of(1, MethodMatch.invokeStatic().and(Match.of(context ->
                  ((MethodInsnNode) context.insn()).desc.startsWith("(JJLjava/lang/Object;)"))).capture("create-decrypter-method")

              .and(StackMatch.of(0, MethodMatch.invokeVirtual().and(StackMatch.of(0, MethodMatch.invokeStatic())))) // Class lookup
              .and(StackMatch.of(1, NumberMatch.numLong().capture("key-2"))) // Key 2
              .and(StackMatch.of(2, NumberMatch.numLong().capture("key-1"))) // Key 1
          ))
          .capture("decrypt-method")
      ));

  // Config
  /**
   * Example: key="mypackage.Class0", value="mypackage.Class1" - You guarantee Class0 always initialized before Class1
   *
   * <ul>
   * <li>key - Class that will always be initialized BEFORE {@code value}. It is an internal name
   * <li>value - Class that will always be initialized AFTER {@code key}. It is an internal name
   * </ul>
   */
  private final Map<String, String> classInitOrder;

  private SandBox sandBox = null;
  private final Set<String> processedClasses = new HashSet<>(); // class internal names

  public ZelixLongEncryptionMPCTransformer() {
    this.classInitOrder = new HashMap<>();
  }

  public ZelixLongEncryptionMPCTransformer(Map<String, String> classInitOrder) {
    this.classInitOrder = classInitOrder.entrySet().stream()
        .collect(
            // Replace all '.' with '/'
            Collectors.toMap(
                entry -> entry.getKey().replace('.', '/'), // Key
                entry -> entry.getValue().replace('.', '/') // Value
            )
        );
  }

  @Override
  protected void transform() throws Exception {
    // Firstly, process the manual list of class initialization order
    for (var entry : classInitOrder.entrySet()) {
      ClassWrapper first = context().getClassesMap().get(entry.getKey());
      ClassWrapper second = context().getClassesMap().get(entry.getValue());

      decryptEncryptedLongs(context(), first);
      decryptEncryptedLongs(context(), second);
    }

    // Decrypt longs
    scopedClasses().forEach(classWrapper -> {
      decryptEncryptedLongs(context(), classWrapper);
    });

    // Remove decrypter classes
    if (sandBox != null) {
      sandBox.getUsedCustomClasses().forEach(clazz -> context().getClassesMap().remove(clazz.getInternalName()));
    }
  }

  /**
   * Decrypts encrypted longs
   */
  private void decryptEncryptedLongs(Context context, ClassWrapper classWrapper) {
    // Don't process already processed classes
    if (processedClasses.contains(classWrapper.name())) return;

    // Find clinit
    if (classWrapper.findClInit().isEmpty()) return;
    MethodNode clinit = classWrapper.findClInit().get();

    // Zelix came up with a great idea to infer class initialization order by the super classes.
    // So firstly, process encrypted longs in the super class
    if (classWrapper.classNode().superName != null && !classWrapper.classNode().superName.equals("java/lang/Object")) {
      ClassWrapper superClass = context.getClassesMap().get(classWrapper.classNode().superName);
      if (superClass != null) {
        decryptEncryptedLongs(context, superClass);
      }
    }

    MethodContext methodContext = MethodContext.framed(classWrapper, clinit);

    // Find all encrypted longs
    DECRYPT_LONG_MATCHER.findAllMatches(methodContext).forEach(matchContext -> {
      if (sandBox == null) {
        // Lazily load sandbox
        this.sandBox = new SandBox(context);
      }

      // Get instructions from storage
      MethodInsnNode createDecrypterInsn = (MethodInsnNode) matchContext.captures().get("create-decrypter-method").insn();
      MatchContext decryptContext = matchContext.captures().get("decrypt-method");
      MethodInsnNode decryptInsn = (MethodInsnNode) decryptContext.insn();

      // Some keys
      long key1 = matchContext.captures().get("key-1").insn().asLong();
      long key2 = matchContext.captures().get("key-2").insn().asLong();
      long decryptKey = matchContext.captures().get("decrypt-key").insn().asLong();

      ClassWrapper longDecrypterCreatorClass = context.getClassesMap().get(createDecrypterInsn.owner);

      try {
        // Create decrypter
        InstanceClass clazz = sandBox.getHelper().loadClass(longDecrypterCreatorClass.canonicalName());
        ObjectValue longDecrypterInstance = sandBox.getInvocationUtil().invokeReference(
            clazz.getMethod(createDecrypterInsn.name, createDecrypterInsn.desc),
            Argument.int64(key1), // Key 1
            Argument.int64(key2), // Key 2
            Argument.reference(sandBox.getMemoryManager().nullValue()) // Lookup class
        );
        InstanceClass longDecrypterClass = (InstanceClass) sandBox.getMemoryManager().readClass(longDecrypterInstance);

        //String instanceStringified = sandBox.vm().getOperations().toString(longDecrypterInstance);
        //System.out.println(classWrapper.name() + " -> " + instanceStringified);

        if (isFallbackDecrypter(longDecrypterClass)) {
          LOGGER.error("Detected that '{}' class is decrypted out of order. Decrypted number will have wrong value.", classWrapper.name());
          LOGGER.error("The author used 'classInitializationOrderStatement' (https://www.zelix.com/klassmaster/docs/classInitializationOrderStatement.html) " +
              "during jar obfuscation to specify class initialization order manually. " +
              "You need to pass to ZelixLongEncryptionMPCTransformer a class initialization order. The easiest way wille be doing a static analysis " +
              "and find where the mentioned class is used."
          );
        }

        // Decrypt long value
        long value = sandBox.getInvocationUtil().invokeLong(
            longDecrypterClass.getMethod(decryptInsn.name, decryptInsn.desc),
            Argument.reference(longDecrypterInstance),
            Argument.int64(decryptKey)
        );

        // Remove all instructions that create decrypter
        decryptContext.removeAll();

        // Set field to decrypted long value!
        matchContext.insnContext().methodNode().instructions.insertBefore(matchContext.insn(), AsmHelper.numberInsn(value));
        markChange();
      } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
      }
    });

    processedClasses.add(classWrapper.name());
  }

  /**
   * Checks if the class is {@link reverseengineering.zelix.longdecrypter.FallbackLongDecrypter}
   */
  private boolean isFallbackDecrypter(InstanceClass clazz) {
    String selfDesc = "L" + clazz.getInternalName() + ";";
    return clazz.staticFieldArea().list().size() == 2
        && clazz.staticFieldArea().list().get(0).getDesc().equals("Z")
        && clazz.staticFieldArea().list().get(1).getDesc().equals(selfDesc)
        && clazz.virtualFieldArea().list().size() == 4
        && clazz.virtualFieldArea().list().get(0).getDesc().equals("Ljava/util/concurrent/ConcurrentHashMap;")
        //&& clazz.virtualFieldArea().list().get(1).getDesc().equals("too hard to infer XD")
        && clazz.virtualFieldArea().list().get(2).getDesc().equals("[I")
        && clazz.virtualFieldArea().list().get(3).getDesc().equals("J");
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/zkm/ZelixParametersTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.zkm;

import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.MethodMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.NumberMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.OpcodeMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.StackMatch;
import uwu.narumi.deobfuscator.api.helper.AsmHelper;
import uwu.narumi.deobfuscator.api.helper.MethodHelper;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Decomposes object array param ({@code foo(Object[] args)}) into a readable params like: {@code foo(String arg1, int arg2)}.
 *
 * <p>References:
 * <ul>
 * <li>https://www.zelix.com/klassmaster/featuresMethodParameterObfuscation.html
 * </ul>
 *
 * <p>
 * Object array destructuring example:
 * <pre>
 * aload p0
 * dup
 * iconst_0
 * aaload
 * checkcast java/lang/String
 * astore v3
 * dup
 * iconst_1
 * aaload
 * checkcast java/lang/Long
 * invokevirtual java/lang/Long.longValue ()J
 * lstore j1
 * pop
 * </pre>
 */
// TODO: Remove object array creation and replace it with corresponding params
public class ZelixParametersTransformer extends Transformer {

  private static final Match OBJECT_ARRAY_ALOAD = OpcodeMatch.of(ALOAD).and(
      Match.of(context -> {
        // The object array is always the first argument to method
        return ((VarInsnNode) context.insn()).var == MethodHelper.getFirstParameterIdx(context.insnContext().methodNode());
      }));

  private static final Match OBJECT_ARRAY_ACCESS = StackMatch.of(0, OpcodeMatch.of(CHECKCAST).capture("cast")
      .and(StackMatch.of(0, OpcodeMatch.of(AALOAD)
          .and(StackMatch.of(0, NumberMatch.numInteger().capture("index")
              .and(StackMatch.of(0, OpcodeMatch.of(DUP)
                  .and(StackMatch.ofOriginal(0, OBJECT_ARRAY_ALOAD.capture("load-array")))
              ))
          ))
      ))
  );

  private static final Match OBJECT_ARRAY_VAR_USAGE = Match.of(ctx -> ctx.insn().isVarStore()).capture("var-store")
      .and(
          StackMatch.of(0, MethodMatch.invokeVirtual().capture("to-primitive") // Converting to a primitive type
              .and(OBJECT_ARRAY_ACCESS)
          ).or(OBJECT_ARRAY_ACCESS)
      );

  private static final Match OBJECT_ARRAY_POP = OpcodeMatch.of(POP)
      .and(
          StackMatch.ofOriginal(0, OBJECT_ARRAY_ALOAD.capture("load-array"))
      );

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> classWrapper.methods().stream()
        .filter(methodNode -> methodNode.desc.startsWith("([Ljava/lang/Object;)"))
        .forEach(methodNode -> {
          MethodContext methodContext = MethodContext.framed(classWrapper, methodNode);

          Map<Integer, Integer> newVarIndexes = new HashMap<>(); // old var index -> new var index

          // Decompose object array to argument types
          List<Type> newArgumentTypes = decomposeObjectArrayToTypes(methodContext, newVarIndexes);

          // This flag is used to determine if we need to decompose arguments
          boolean shouldReplaceArgumentTypes = removeObjectArrayAccess(methodContext);

          if (shouldReplaceArgumentTypes) {
            // Update method arguments
            String desc = Type.getMethodDescriptor(Type.getReturnType(methodNode.desc), newArgumentTypes.toArray(new Type[0]));
            AsmHelper.updateMethodDescriptor(context(), methodContext, desc);

            // Replace local variables indexes with the corresponding ones
            fixLocalVariableIndexes(methodNode, newVarIndexes);
          }
        }));
  }

  /**
   * Decomposes object array to argument types.
   *
   * @param methodContext Method context
   * @param newVarIndexes New var indexes to fill
   * @return Argument types
   */
  private List<Type> decomposeObjectArrayToTypes(MethodContext methodContext, Map<Integer, Integer> newVarIndexes) {
    List<Type> newArgumentTypes = new ArrayList<>();

    int nextVarIndex = MethodHelper.getFirstParameterIdx(methodContext.methodNode());

    // Find all casts from that Object array
    for (MatchContext matchContext : OBJECT_ARRAY_VAR_USAGE.findAllMatches(methodContext)) {
      // Found argument!
      VarInsnNode varStore = (VarInsnNode) matchContext.captures().get("var-store").insn();
      TypeInsnNode typeInsn = (TypeInsnNode) matchContext.captures().get("cast").insn();
      int index = matchContext.captures().get("index").insn().asInteger();

      Type type = Type.getObjectType(typeInsn.desc);
      // If value is cast to primitive, then pass primitive
      if (matchContext.captures().containsKey("to-primitive")) {
        MethodInsnNode primitiveCastInsn = (MethodInsnNode) matchContext.captures().get("to-primitive").insn();
        type = getTypeFromPrimitiveCast(primitiveCastInsn);
      }

      // Add new argument
      newArgumentTypes.add(index, type);
      //System.out.println(index + " -> " + type);

      // Append new var index
      newVarIndexes.put(varStore.var, nextVarIndex);
      nextVarIndex = nextVarIndex + type.getSize();

      // Clean up array access
      VarInsnNode loadArrayInsn = (VarInsnNode) matchContext.captures().get("load-array").insn();
      for (AbstractInsnNode collectedInsn : matchContext.collectedInsns()) {
        if (collectedInsn.equals(loadArrayInsn)) continue;

        methodContext.methodNode().instructions.remove(collectedInsn);
      }

      markChange();
    }

    return newArgumentTypes;
  }

  /**
   * Removes object array access. Removes its ALOAD and POP instructions.
   *
   * @return {@code true} if any object array access was removed
   */
  private boolean removeObjectArrayAccess(MethodContext methodContext) {
    // Remove all object array accesses
    Optional<MatchContext> optMatch = OBJECT_ARRAY_POP.findAllMatches(methodContext).stream().findFirst();
    if (optMatch.isEmpty()) return false;
    MatchContext matchContext = optMatch.get();

    AbstractInsnNode loadArrayInsn = matchContext.captures().get("load-array").insn();

    // Remove those instructions
    methodContext.methodNode().instructions.remove(loadArrayInsn); // ALOAD
    methodContext.methodNode().instructions.remove(matchContext.insn()); // POP

    return true;
  }

  /**
   * Replace local variables indexes with the corresponding ones
   *
   * @param methodNode Method node
   * @param newVarIndexes New var indexes to use to replace the old ones
   */
  private void fixLocalVariableIndexes(MethodNode methodNode, Map<Integer, Integer> newVarIndexes) {
    for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
      if (insn instanceof VarInsnNode varInsn) {
        if (newVarIndexes.containsKey(varInsn.var)) {
          // Replace it!
          varInsn.var = newVarIndexes.get(varInsn.var);
          markChange();
        }
      } else if (insn instanceof IincInsnNode iincInsn) {
        if (newVarIndexes.containsKey(iincInsn.var)) {
          // Replace it!
          iincInsn.var = newVarIndexes.get(iincInsn.var);
          markChange();
        }
      }
    }
  }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/zkm/ZelixStringTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.zkm;

import org.objectweb.asm.tree.*;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class ZelixStringTransformer extends Transformer {

    HashMap<String, Integer> keyType1 = new HashMap<>();
    HashMap<String, List<Byte>> keyType2 = new HashMap<>();
    HashMap<String, Integer> staticArraySize = new HashMap<>();
    HashMap<String, List<Integer>> offsets = new HashMap<>();

    HashMap<String, List<String>> encryptedStrings = new HashMap<>();

    /* Written by https://github.com/Lampadina17 | OG 19/07/2024, Rewritten 09/08/2024 */
    @Override
    protected void transform() throws Exception {
        scopedClasses().forEach(classWrapper -> {
            /* Extract key type 1 from hardcoded xor encryption */
            classWrapper.methods().stream()
                    .filter(methodNode -> methodNode.desc.equals("(Ljava/lang/String;)[C"))
                    .forEach(methodNode ->
                            Arrays.stream(methodNode.instructions.toArray())
                                    .filter(ain -> ain instanceof IntInsnNode)
                                    .filter(ain -> ain.getNext() instanceof InsnNode)
                                    .filter(ain -> ain.getNext().getOpcode() == IXOR)
                                    .map(IntInsnNode.class::cast)
                                    .forEach(iin -> keyType1.put(classWrapper.name(), iin.operand)));

            /* Temporary variable */
            List<Byte> key2 = new ArrayList<>();

            /* Extract key type 2 from hardcoded switch case xor encryption */
            classWrapper.methods().stream()
                    .filter(methodNode -> methodNode.desc.equals("([C)Ljava/lang/String;"))
                    .forEach(methodNode ->
                            Arrays.stream(methodNode.instructions.toArray())
                                    .filter(ain -> ain instanceof IntInsnNode)
                                    .map(IntInsnNode.class::cast)
                                    .forEach(iin -> key2.add((byte) iin.operand)));

            /* Store the key data by class */
            if (!key2.isEmpty()) keyType2.put(classWrapper.name(), key2);

            /* Retrieve array length (static block) */
            classWrapper.methods().stream()
                    .filter(methodNode -> methodNode.name.equals("<clinit>"))
                    .forEach(methodNode -> {
                        if (methodNode.instructions.getFirst() instanceof IntInsnNode && methodNode.instructions.getFirst().getNext() instanceof TypeInsnNode) {
                            staticArraySize.put(classWrapper.name(), ((IntInsnNode) methodNode.instructions.getFirst()).operand);
                        }
                    });

            /* Temporary variable */
            List<String> strings = new ArrayList<>();

            /* Retrieve ciphered strings (static block) */
            classWrapper.methods().stream()
                    .filter(methodNode -> methodNode.name.equals("<clinit>"))
                    .forEach(methodNode -> Arrays.stream(methodNode.instructions.toArray())
                            .filter(ain -> ain instanceof LdcInsnNode)
                            .map(LdcInsnNode.class::cast)
                            .filter(ldc -> ldc.cst instanceof String)
                            .forEach(ldc -> strings.add((String) ldc.cst)));

            if (!strings.isEmpty()) encryptedStrings.put(classWrapper.name(), strings);

            /* Temporary Variable */
            List<Integer> offsets = new ArrayList<>();

            /* Retrieve weird zkm "offsets" */
            classWrapper.methods().stream()
                    .filter(methodNode -> methodNode.name.equals("<clinit>"))
                    .forEach(methodNode ->
                            Arrays.stream(methodNode.instructions.toArray())
                                    .forEach(ain -> {
                                        AbstractInsnNode prev = ain.getPrevious();
                                        if (prev != null && prev.getPrevious() != null && prev.previous() instanceof MethodInsnNode min && min.name.equals("length")) {
                                            if (ain instanceof IntInsnNode iin) {
                                                offsets.add(iin.operand);
                                            } else if (ain instanceof InsnNode in && in.getOpcode() >= ICONST_M1 && in.getOpcode() <= ICONST_5) {
                                                offsets.add(getValue(in));
                                            }
                                        }
                                    }));

            if (!offsets.isEmpty()) this.offsets.put(classWrapper.name(), offsets);
        });

        /* Decrypt and cleanup */
        scopedClasses().forEach(classWrapper -> {
            classWrapper.methods().stream()
                    .forEach(methodNode -> {
                        List<String> encrypted = encryptedStrings.get(classWrapper.name());
                        List<Integer> offsets = this.offsets.get(classWrapper.name());

                        if (encrypted != null && encrypted.size() == 2 && offsets != null && offsets.size() == 2) {
                            /* for classes that has big static block */
                            Arrays.stream(methodNode.instructions.toArray())
                                    .filter(ain -> ain.getOpcode() == AALOAD)
                                    .filter(ain -> ain.getPrevious().getPrevious().getOpcode() == ALOAD)
                                    .forEach(ain -> {
                                        int index = 0;
                                        if (ain.getPrevious() instanceof IntInsnNode iin) index = getValue(iin);
                                        else if (ain.getPrevious() instanceof InsnNode in) index = getValue(in);

                                        List<Byte> key2 = keyType2.get(classWrapper.name());

                                        if (key2 != null)
                                            try {
                                                String[] decryptedStrings = ZKMCipher.StaticInit(
                                                        encrypted.get(0),
                                                        encrypted.get(1),
                                                        keyType1.get(classWrapper.name()),
                                                        shiftBytes(key2),
                                                        offsets.get(0),
                                                        offsets.get(1),
                                                        staticArraySize.get(classWrapper.name()),
                                                        key2.get(0));

                                                /* Re-insert original string back to its place */
                                                methodNode.instructions.insert(ain, new LdcInsnNode(decryptedStrings[index]));
                                                /* Cleanup */
                                                methodNode.instructions.remove(ain.getPrevious().getPrevious());
                                                methodNode.instructions.remove(ain.getPrevious());
                                                methodNode.instructions.remove(ain);
                                                this.markChange();
                                            } catch (Exception e) {
                                            }
                                    });
                        } else {
                            AtomicBoolean cleanup = new AtomicBoolean(false);

                            List<Byte> key2 = keyType2.get(classWrapper.name());

                            if (key2 != null) {
                                Arrays.stream(methodNode.instructions.toArray())
                                        .filter(ain -> ain instanceof LdcInsnNode)
                                        .map(LdcInsnNode.class::cast)
                                        .filter(ldc -> ldc.cst instanceof String)
                                        .forEach(ldc -> {
                                            try {
                                                ldc.cst = ZKMCipher.cipher2(ZKMCipher.cipher1((String) ldc.cst, keyType1.get(classWrapper.name())), shiftBytes(key2), key2.get(0));
                                                cleanup.set(true);
                                            } catch (Exception e) {
                                            }
                                        });

                                if (cleanup.get())
                                    Arrays.stream(methodNode.instructions.toArray())
                                            .filter(ain -> ain.getOpcode() == SWAP)
                                            .filter(ain -> ain.getNext() != null && ain.getNext() instanceof MethodInsnNode)
                                            .filter(ain -> ain.getNext().getNext() != null && ain.getNext().getNext() instanceof MethodInsnNode)
                                            .filter(ain -> ain.getNext().getNext().getNext() != null && ain.getNext().getNext().getNext().getOpcode() == SWAP)
                                            .forEach(ain -> {
                                                /* Do cleanup */
                                                methodNode.instructions.remove(ain.getNext().getNext().getNext());
                                                methodNode.instructions.remove(ain.getNext().getNext());
                                                methodNode.instructions.remove(ain.getNext());
                                                methodNode.instructions.remove(ain);
                                                this.markChange();
                                            });
                            }
                        }
                    });
        });
        LOGGER.info("Decrypted {} strings in {} classes", this.getChangesCount(), scopedClasses().size());
    }

    /* Convert arraylist to array and shift values, when a bug transform into a feature (Key type 2) */
    private byte[] shiftBytes(List<Byte> input) {
        byte[] keyBytes = new byte[input.size() - 1];

        int j = 1;
        for (int i = 0; i < keyBytes.length; i++) {
            keyBytes[i] = input.get(j);
            j++;
        }
        return keyBytes;
    }

    public int getValue(AbstractInsnNode in) {
        int opcode = in.getOpcode();
        return switch (opcode) {
            case ICONST_M1 -> -1;
            case ICONST_0 -> 0;
            case ICONST_1 -> 1;
            case ICONST_2 -> 2;
            case ICONST_3 -> 3;
            case ICONST_4 -> 4;
            case ICONST_5 -> 5;
            case SIPUSH, BIPUSH -> ((IntInsnNode) in).operand;
            default -> throw new RuntimeException("Unsupported opcode");
        };
    }

    public static class ZKMCipher {

        public static char[] cipher1(final String var0, final int key) { // All old versions
            final char[] input = var0.toCharArray();
            if (input.length < 2) {
                input[0] ^= key;
            }
            return input;
        }

        public static String cipher2(final char[] input, final byte[] keys, final int length) throws Exception {
            if (keys.length != length) throw new Exception("Key is invalid");
            for (int i = 0; input.length > i; ++i) {
                input[i] ^= (char) keys[i % length];
            }
            return (new String(input)).intern();
        }

        public static String[] StaticInit(String encrypted1, String encrypted2, int key1, byte[] key2, int offset, int offset2, int arraysize, int length) throws Exception {
            final String[] h2 = new String[arraysize];
            int n = 0;
            String s;
            int n2 = (s = encrypted1).length();
            int n3 = offset;
            int n4 = -1;

            Label_0023:
            while (true) {
                while (true) {
                    ++n4;
                    final String s2 = s;
                    final int n5 = n4;
                    String s3 = s2.substring(n5, n5 + n3);
                    int n6 = -1;
                    while (true) {
                        final String a = ZKMCipher.cipher2(ZKMCipher.cipher1(s3, key1), key2, length);
                        switch (n6) {
                            default: {
                                h2[n++] = a;
                                if ((n4 += n3) < n2) {
                                    n3 = s.charAt(n4);
                                    continue Label_0023;
                                }
                                n2 = (s = encrypted2).length();
                                n3 = offset2;
                                n4 = -1;
                                break;
                            }
                            case 0: {
                                h2[n++] = a;
                                if ((n4 += n3) < n2) {
                                    n3 = s.charAt(n4);
                                    break;
                                }
                                break Label_0023;
                            }
                        }
                        ++n4;
                        final String s4 = s;
                        final int n7 = n4;
                        s3 = s4.substring(n7, n7 + n3);
                        n6 = 0;
                    }
                }
            }
            return h2;
        }
    }
}

```

`deobfuscator-transformers/src/main/java/uwu/narumi/deobfuscator/core/other/impl/zkm/ZelixUselessTryCatchRemoverTransformer.java`:

```java
package uwu.narumi.deobfuscator.core.other.impl.zkm;

import org.objectweb.asm.tree.MethodInsnNode;
import uwu.narumi.deobfuscator.api.asm.InsnContext;
import uwu.narumi.deobfuscator.api.asm.MethodContext;
import uwu.narumi.deobfuscator.api.asm.MethodRef;
import uwu.narumi.deobfuscator.api.asm.matcher.Match;
import uwu.narumi.deobfuscator.api.asm.matcher.MatchContext;
import uwu.narumi.deobfuscator.api.asm.matcher.group.SequenceMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.MethodMatch;
import uwu.narumi.deobfuscator.api.asm.matcher.impl.OpcodeMatch;
import uwu.narumi.deobfuscator.api.transformer.Transformer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Removes useless try catches. References:
 * <ul>
 * <li>https://www.zelix.com/klassmaster/featuresExceptionObfuscation.html</li>
 * </ul>
 *
 * <pre>
 * {@code
 * try {
 *     ...
 * } catch (PacketEventsLoadFailureException packetEventsLoadFailureException) {
 *     throw PacketEvents.a(packetEventsLoadFailureException);
 * }
 *
 * // Self return
 * private static Exception a(Exception exception) {
 *     return exception;
 * }
 * }
 * </pre>
 */
public class ZelixUselessTryCatchRemoverTransformer extends Transformer {
  private static final Match INSTANT_RETURN_EXCEPTION =
      SequenceMatch.of(
          OpcodeMatch.of(ALOAD),
          OpcodeMatch.of(ARETURN)
      );

  private static final Match INVOKE_AND_RETURN =
      SequenceMatch.of(
          MethodMatch.invokeStatic().capture("invocation"),
          OpcodeMatch.of(ATHROW)
      );

  @Override
  protected void transform() throws Exception {
    scopedClasses().forEach(classWrapper -> {
      List<MethodRef> instantReturnExceptionMethods = new ArrayList<>();

      // Find methods that instantly returns an exception
      classWrapper.methods().forEach(methodNode -> {
        MethodContext framelessContext = MethodContext.frameless(classWrapper, methodNode);

        // Check instructions
        if (methodNode.instructions.size() == 2 && INSTANT_RETURN_EXCEPTION.matches(framelessContext.newInsnContext(methodNode.instructions.getFirst()))) {
          // Add it to list
          instantReturnExceptionMethods.add(MethodRef.of(classWrapper.classNode(), methodNode));
        }
      });

      Set<MethodRef> toRemove = new HashSet<>();

      // Remove try-catches with these instant return exception methods
      classWrapper.methods().forEach(methodNode -> {
        MethodContext framelessContext = MethodContext.frameless(classWrapper, methodNode);

        methodNode.tryCatchBlocks.removeIf(tryBlock -> {
          InsnContext start = framelessContext.newInsnContext(tryBlock.handler.getNext());
          MatchContext result = INVOKE_AND_RETURN.matchResult(start);
          if (result != null) {
            MethodRef methodRef = MethodRef.of((MethodInsnNode) result.insn());

            // Check if method is returning an exception instantly
            if (!instantReturnExceptionMethods.contains(methodRef)) return false;

            toRemove.add(methodRef);

            markChange();
            return true;
          } else {
            return false;
          }
        });
      });

      // Remove instant return exception methods
      classWrapper.methods().removeIf(methodNode -> toRemove.contains(MethodRef.of(classWrapper.classNode(), methodNode)));
    });
  }
}

```

`pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://maven.apache.org/POM/4.0.0"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>uwu.narumi</groupId>
  <artifactId>Diobfuscator</artifactId>
  <packaging>pom</packaging>
  <version>2.0-SNAPSHOT</version>

  <modules>
    <!-- Code for test deobfuscation -->
    <module>testData/src/java</module>

    <module>deobfuscator-api</module>
    <module>deobfuscator-impl</module>
    <module>deobfuscator-transformers</module>
    <module>reverse-engineering</module>
  </modules>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.jetbrains</groupId>
      <artifactId>annotations</artifactId>
      <version>24.1.0</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!--<plugin>
        <groupId>com.spotify.fmt</groupId>
        <artifactId>fmt-maven-plugin</artifactId>
        <version>2.23</version>
        <configuration>
          <verbose>true</verbose>
          <filesNamePattern>.*\.java</filesNamePattern>
          <skip>false</skip>
          <skipSourceDirectory>false</skipSourceDirectory>
          <skipTestSourceDirectory>false</skipTestSourceDirectory>
          <skipSortingImports>false</skipSortingImports>
          <style>google</style>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>format</goal>
            </goals>
          </execution>
        </executions>
      </plugin>-->
    </plugins>
  </build>
</project>
```

`reverse-engineering/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>uwu.narumi</groupId>
        <artifactId>Diobfuscator</artifactId>
        <version>2.0-SNAPSHOT</version>
    </parent>

    <artifactId>reverse-engineering</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
```

`reverse-engineering/src/main/java/zelix/enhancedstringenc/ManyStrings.java`:

```java
package zelix.enhancedstringenc;

/**
 * Decompiled using Procyon because Vineflower is decompiling it wrongly...
 */
public class ManyStrings {
  private static final String[] a;
  private static final String[] b;

  public static void main(final String[] array) {
    a(a(16601, -26271));
    System.out.println(a(16547, 28980));
    System.out.println(a(16573, -6570));
    System.out.println(a(16549, 15866));
    System.out.println(a(16569, 30320));
    System.out.println(a(16513, 5692));
    System.out.println(a(16592, -18585));
    System.out.println(a(16518, -12275));
    System.out.println(a(16558, -5500));
    System.out.println(a(16533, 28407));
    System.out.println(a(16554, -31785));
    System.out.println(a(16598, 14166));
    System.out.println(a(16519, 21847));
    System.out.println(a(16597, 6470));
    System.out.println(a(16570, -27431));
    System.out.println(a(16567, -23765));
    System.out.println(a(16514, 26042));
    System.out.println(a(16544, -32719));
    System.out.println(a(16531, 13283));
    System.out.println(a(16556, 14179));
    System.out.println(a(16524, -10611));
    System.out.println(a(16602, 11272));
    System.out.println(a(16545, -397));
    System.out.println(a(16563, 19319));
    System.out.println(a(16559, 10170));
    System.out.println(a(16552, -16576));
    System.out.println(a(16546, 17855));
    System.out.println(a(16528, 428));
    System.out.println(a(16574, 23266));
    System.out.println(a(16600, -26763));
    System.out.println(a(16550, -19257));
    System.out.println(a(16583, 19975));
    System.out.println(a(16568, -28711));
    System.out.println(a(16593, 8545));
    System.out.println(a(16571, 16428));
    System.out.println(a(16604, 8759));
    System.out.println(a(16543, -31121));
    System.out.println(a(16565, 26258));
    System.out.println(a(16576, 18214));
    System.out.println(a(16542, 5982));
    System.out.println(a(16582, -20163));
    System.out.println(a(16595, 14588));
    System.out.println(a(16605, -26780));
    System.out.println(a(16572, -3689));
    System.out.println(a(16534, -4917));
    System.out.println(a(16553, -25655));
    System.out.println(a(16599, -6645));
    System.out.println(a(16575, 9955));
    System.out.println(a(16555, -5264));
    System.out.println(a(16536, 23938));
    System.out.println(a(16541, 14767));
    System.out.println(a(16523, 26124));
    System.out.println(a(16594, 10432));
    System.out.println(a(16606, 23179));
    System.out.println(a(16512, 28813));
    System.out.println(a(16527, 17243));
    System.out.println(a(16537, -17368));
    System.out.println(a(16521, 6489));
    System.out.println(a(16538, 32319));
    System.out.println(a(16557, -8581));
    System.out.println(a(16520, -15798));
    System.out.println(a(16516, -21175));
    System.out.println(a(16607, 10624));
    System.out.println(a(16561, 13569));
    System.out.println(a(16562, 31959));
    System.out.println(a(16539, 4326));
    System.out.println(a(16529, -27529));
    System.out.println(a(16580, 16893));
    System.out.println(a(16581, 13937));
    System.out.println(a(16603, 20273));
    System.out.println(a(16522, -27961));
    System.out.println(a(16548, 5675));
    System.out.println(a(16564, -31220));
    System.out.println(a(16525, -11503));
    System.out.println(a(16560, -15803));
    System.out.println(a(16596, -30597));
    System.out.println(a(16526, -10863));
    System.out.println(a(16540, 20769));
    System.out.println(a(16532, 27173));
    System.out.println(a(16515, 28785));
    System.out.println(a(16551, 26445));
  }

  private static void a(final String s) {
    if (s.equals(a(16535, -2944))) {
      System.out.println(a(16517, 22762));
    } else {
      System.out.println(a(16566, 20267));
    }
  }

  static {
    final String[] decryptedStrings = new String[85];
    int index = 0;
    String obfuscatedString;
    int obfuscatedStringLength = (obfuscatedString = "-\u0092\u00d9+\u000f\u0000\u00e1L\u00dd \u0019n\u00c8Y\\g@\u0095!\u00189\u001fO\u00fc-\u0097\u009de\u0086\u00c8P4\u0013\u00f6\b\u00efjw\u0099\u000b\u00be\u008e\u00d5\\9D\u00ael\u00b3'\u00d5\u008cW\u0015pD\u00ef\u00b7\u0016\u009c\u00e3\u00c4c\u0096\u00d6\u0012\u00da\u00cbF\u00d1\u00f7\u00bb]\u0091\u00c3\u00a5\u00b5\u00ea\u009a\u0088\u00f4\u0081\u00c9\u00ce.\u0090ze\u0013\u00f8\\\u0007\u000e-k\u007f\u00c3\u0099\u00af\u008b\u00a6zM\u00fd\u00ae\u00fe\u00cb\u00c7\"\u00c8\u00a5\u00b6\u0011\u00e0\u00063\u00fbx+\u00a6\u0097\u00d77\u00ad*\u00e9o:I\u00ba\u00ac\u00a8\u00ec\u0017\u00e4\u00ed\u00aav6\u008bO\u009f6\u00e3+\u00d1\u008c\u00e3dp\u00e5nc\u001d\u00c4Q\u00d5\u00f0\u00f2\u0080\u009f\u00e5\u00be\u0098\u0087\u00fe\u0095\u0082\u00fbO\u00aa\u00bcS\u007fLU\u00e6\u00c5~V\u008e\u00e3\u00e3~|\u00b2d\u0004U\u00fc\u00aa5\u00b5\u00a7hrk6\u0099\u00bc\u00e5\u00ef\b\u00fc\u00af\u0013-\u001c\u00eb3\u00d7`\u0019\u0005\u00e6\u00e8\u0081Q5\u0093\u0014D\u00e1\u00dd\u0088\u00fc\u0007.6\u00ccW%(\u009c^\tS\t\u007f\u0013\u008c\u00af\u00e2Hz\u0092\u00b4\u0000\u00d4\u00bb\u00d7\u00f1\u00a1\u00ca\u0007\u0083\u008c\u00fbn9:\u0091\t\u00b0>\u00b7UXU\u0095;\"3\u009cM\u00ea\u0080\u0092dy\u00c6\u0010\u000eKa\u00deC\u00ee>\u00fa\u00a4\u001aW3\u00f7>\u0082\u001f\"\u00e9\u00e1\u00cfF\u00ee>G/\u00fa\u00d0n,\u009a\"U\u00ee3\u0097\t\u000fX{\u00b9\u00a5C\u009d\u00b7\n\u001c4\u0095\u0002\u0001\u00ce\u00cf\u00f0p\u00c6f-uE'\u0001\u00e1\u00fb\u00ee \u00e1Tk\u00a8\u00cb9\u000bvkd9\u00f3\u00d3K\u00e9o\u00bd\u00e9\u00b5\u00034\u00addi<q\u00efN\u0000\u008c\u00ed\u00e0\u00f2\u00e1\u00a7\u0081CH\u009348=\u00b2\u00bd\u00ac\u00c14\u0010\u0094\u00cb\u00d4\u008e\u0005\u00ec\u00f8\u00a3\u0000\u00f0P\u00e04-\u00de\u00d0x\u00efk1\u00dd\u00bd\\L\u00c2/\u00ba\u0091\u0017\u00a7H\u0086S\u00ccG\u00fe\u00ac\u00c6a_M\t\u0005\u00b2\r\n\u0006\u0085\u000f\fv^\u00f6M\u00c54n\u00e3\u001c\u0007\u00a4(\u0001\u00bc\u000ep\u0082\u008e@my,\u00d0d\u000fv\u00ee\u00fb\u0092R\u0095\u0086\u00b5\u00fd\u00bd\u0019Q35lK\u00ecW~a~_\u00d9\u00e8\u0092\u008b.h\u0081\u00dd\u0088\u00cb\u00dd<Z\u00d0\u00e7\u00a6\u00a2Zg\u00980\u008a\u00e8\u00c9\u00feM3\u00da\u008c\u009d>:}\u008a\u00c1\u00cf\u00ba\"\u0089\u00b6\u00b2\u0018\u0091\u00da\u0095kp\u00f5\u0002\u00f8El\u00fch\u00a9\u00ec\n\u008a\u0019\u0090\u00f8K/w\u00d4\u0091k\u001e W\u00cd7\u0081\u00acH7\u00c2\u008c\u0004\u0013\u001aQ\u00b8{\u00b1\u00e4\u000f\u008a\u00c30\t>\u00b0\u0015\u000fd\u00ac\\\u001eI\u0083a\u008c\u0006n\u00a7\u00f3\\`\u00e7z\u00b7\u0096\u0000\u00b0\u00c2\u00ffCp\u000b\u00a3\u0010\u000e\u00ab4kR\u0014\u0005\u001f\u00f4\u008f\u00f3$e:m4\u0001\u00c6,-\u009e\u0085,\u00ad\u00ea\u00a7K.\u00fa\u00b6\u001e],gQ0\u008f\u00b9\u001c\u00cap\u00cf``\u00bex7s\u008fj:T\u00ab\b\u00c9\u0091\u00bd$=F3\u0093ye\u000b\u00c2\u00c5\u0095\u001br\u00e92O\u0014\u0003\u00fa\u001bJ\u0090\u0000\u001c_\u00cf\\+\u00f1\u00d8\u00b7\u00b9\u0096\u0015\u00db\u0015\u00e1)\u00e7u\u00aa\u0015\u00a5n\u0095\u0016m\u00feRx\u00f5\u00f4\u00c8\u00fd\u00d3\u00a4-\u008d8\u0080L\u00a9\u0015\u00d5\u0016\u00fe\u00c0\u0080\u00c5B$n\u00e4-\u0003\u00dc\u00c4\".\u00cbg\u001d\u001dT\u0099\u0007\u0013~\u0012\u00ceh\u00e1\u00f3\u00a6 @i\u00e5\u0010\u00f0\u008b\u00f5\u0085$\u00f2,Yw\u00f3\u00d1<VP\u00ec\u00b5=\u0015\u00f4\u00b0\u001e/\u00c1\u0011\u00fb\u0089\u00f1\u000f\u00d0g\u0096\u00f1\u00ce\u00f8y9\u00ad\u0003\u00b7\u00df2Q\u00f5~\u0096c\u00d8\u00b6\u008c\u00e4\u00ac\u0082\u007f\u000f'\\\u009f\u00b3\u00e8\u00bb\f\u00a5\u00e6\u00a9\u0001\u00fc\u00bc\u00d48\u00e6\u00cefw\\1\u00bc\u001b\u0099\\[\u0003+\u0003\u0010E\u001b\u00ea\u0082b\u00bbG\u00c2\u00af\u00b1\u00b3F\u00ce\u00ba)\u00da\\\u008c\u00bd\u0093\u00bd\u001a[57\u00d8\"\u001f\u00a0\u00a6\u00ffs\u00df\u00e6\u00ec\u00e7\u00e2\u0082-\u00d5\u0012\u00a7~\u00a1\u00c2\u00d9$\u00bb\u0085zH\u00db\u0092J\u00ec\nQ\u00c7\u00c9\u00eb)GJ\u00e7\u0002,\u00b3^&\u009fG\u008d\u0019\u0080t\u0018|\u0085\u00bdN\u00e2#Mhbd\u00bb\u00f3\u0084y\u00c7\u00f3*\u00c76\u00af\u009d\u00e2\u00df\u00d0\u00b09KQ\fX\u0096\u0013<\u00cc'{\u00f4\u00ef\u00bc\u0006\u00e7\u00aez\u0017_\u00d9\u00cc\u00d6_\"\u0087\u00df\u00ce\u009e\u00cb\u00da!\u00da\u000f\u00fb\u00e7\u00a6\u00a3\u009e\u00f3\u00a9~\u0093\u00be\u0080\u0007\u0002\u00b3h\u00b3\u00ff\u00f5C*~\u00e9\u0004\u00ee\u00bfA\rg\u00a8\u00e3\u0095\u00aa\u008d\u00170ww#\u00dc\u0082\u0090\u0002\u00a9w+\u00a0\u0011\u0005[\u000f\u0098\u00b5\u00ee\u0080\u0018\u00c7\u0087S\u0004H\u0094\u00d5\u00c4l5\u00b1~.\u00c1-^R(\u0082\u00c8\u00fd\u00ff\u00c5'\u0091\u00cd\u00ce\u0016\u0084\u001b\u00f8\u00ae\u0081pa\u0093\u00d9f2!Vj\u00aeY\u00ef\u00ccX\u00ad\u00e3\u00aa/\u0005\u000b7\u0014#\u00f7\u00bf\u00f9\u00e4\"S\u00e85\u00ef\u009b\u00d4\u0001HY1\u008c\u00ac\u00f2\u00b084\u0004!S\u0011\u0014V\u00aaE\u00f3T\u0001\u001e}\u0005V^\u00a3#3\u00ba\u0018\u001e\u000eR\u00e7\u0089\u0018\ni\u00b9\u00f5&|o\u00f8\u009f\u00ebR\u00eet@\u0089x\u0080\u00e1\u0095\u00cb{\u008f\u00a5\u00efUY\u0083\u00d1\u00b0\u0018\u00fd\u00e4\u00a9\u00c9$\u008c\u0001\u000f\u00c2aX\u00ac\u00f5\u008f\u0082\u00c0]\u008e\u00e8\u00ff\b\u00bcj37?\u0000\u00df\u0093\u008c\u009e\u00af\u00ff\u00b5\u0088\u00a1\u0088\u00a4\u00fe\u00ed\u0007\u008b\u008f\u00e4\u00ea\u00ac\u00aa\u008f\u00bc>\u0089\u00ed\u001e\u00ca\u00f3\u00d6\u00bb\u00a2\u0007\u008a`dH\u00bd\u00c86\u00f3\u00a8\u0088\u008a,\u00b3FR\u00b59\u00c1Z\u00eb\u001bD\u00ad\u0093\u0007\u00f9'\u00cdo\u00c2\u000e\u001c\u0081\u00b0/\u00af4\u0088\u00f3\u0007\u0007\u00f7\u00bd\u009c\u008b\u0083M\u0094#\u001e\u00a33\u0092)\u00fc\u0007\u0013\u00d7\u0006\u00ec\u0001\u00d9\u00ea~O\u008dN\u00ecU\u00ce\u008bM?]\u00cd\u00f5\u000b\u008eh\u008d\u0094o\u008e\u00b2aNI\u00fdQ\u00ed\u00caG\u00d1\u00e7&\f\u00a2&\u00d2}T^\u00ffy\u00c2\u00c4&\u00a3E\u00bcp\u00c5E\u00c5\u008f\u00fc\u00ad\u001f\u00ee\u00f3\"\u00e4\u00d3\u00f8\u00f3Q,\u00e8i\u000f\u001dg\r\u00a7}\u008dC\u00e0E\u00e12l<\u0097\t\u0018NV\u008d\u0099\u00e6\u009b\r\u00f0]w\u00f2\u00ed\u0014`\u009b~\u008a[l<\u00e4\u00ee\u0096\u00faeG\u0000\"\u009f4\u00f2\u0018\u00d5)\u00f3\u00bc2#\u00ee\u0016\u00e5\\\u00e0T(N0N\b\u0005\u0083\u0007\u00f9\u00d0\u001e\u00972T\u0084\u00f9\u009d\u00c6\u00afH{B\"\u00a7-\u001c\u0013\u00de\u00ccp(r?h \u00c2\u0002\u0099o8\u00a0\n$\u00ed\u00b1:R{\u0012\u0005i\u00bfG\u00db\u00ae\u00a9\u00ef\u0099\u00e1h\u00ed,\u0093\u00ab\u00b1\u00cb\u00ceG\u0081\u00b4B\u00cd_\u00ffC\u008bw\u008c\u00fe\u00f2K2\u00c8`Fc8mP}\u00a9\u00e2\u00cf(\u00d8\u00c3\u00fc$\u008cH4\u00eeo\u00dcN\u007fk\u009c6ZfB\u00e9\u00d2\u00022Z\u00b0&R\u0088\u00ec\u00fb\n\u00a1\u00f6\u00b6I\u001cx\u008f\u00ad\u0097\u00eb\u008fx\u00b0\u0097~\u0006{\u00ed\u00ab\u0088Tk\u00ac{\u00f3+I7Y?A\u00d2\u00a2v0\u00af\u009e\u00a0\u00fcv\u00af\u00e3\u00ee~8\u00a47n_om0\u0091h>)\u00c2\u00adeM\u0093\u00ba\u009f\u009c\u0015N}\u00e5q\u00d96~j\u00f3\u001b\u008d\u00db`\u00e0\u00d5X\u00e9Z\u00d6\u00d2\u001b\u00f1,&\u001b\u00aa\u00d5X^\u0090#\u00f4\u00ff\u0001o|\u00b3\u00f3\u00eb,\u00f0Hg\u00e1I\u0017|x\u00a0\u00ff\u00e2\u00f1\u00ad\u000b\u00acNS\u008e|B\u0000~\u009e\u00cd\f\u001eCFTaW\n\u0004\u00a7\u0016\u00cc\u0086\u00aa\u00e4\u00f9\u00d0[2hPx/@\u00db\u00db@\u00e2fD\u00f1\u00f1)\u00ac\u00fbca\u00f4\u001b\u00ca\u0083\u00a7\u00ba\u00bb\u00ab\u0018\u00ed@\u0093\u00a1m\u0000N-I\b\u0083\u0090Q\u00e6\u009dF\u00b9\u00cb\u0006\u00a8\u00b6\u007f\u00feu\u000f\u00b2\u00abz\u0083~\u00c6D\u008c\u0096\u00b1\u0001\u00b1:\u00e0\u0000/l\u0082\u00dfj\u00ea\u00d0\u00d7`\u00fe'\u00a3\u00bdQWq\u00aa*\u0000\u00d5d\u0083\u00aab\u00ab\u000ef\u00ce=\u0082\u00e0\u00c24\u00b2rU\u00e0\u00b7\u00ce\u00e2\u0099Rj\u00bc\u00c14i\u00c0Y\u00a4!L$\u00f0\">\u00996\u0082\u0096\u0018v\u00f1\u00f6(\u00d7\r\u00b1\u001da2\u00f6-\u0083\u00a5\u00c2\u0088b\u0000D\u00f0\u000e\u009506\u00f7\u0091mGy4GWC\u00d2\u00b1[\u00be['~r\u00c2\u00a3\u00e4\u0094b}\u00dfc\u00e4)C(\u00d7KD\u0082\u00fau_\u0086\u00fb\u00b7+\u00dc\u0095\u0002p\u00a7\u009e\u00c8\u00be\u0081X\u00a9\u000b\u0014\f\t\u00c0e&\u0099\u00e2\u00cb'q\u00df\u000eL\u00b1\u00e2h\u00f6\u00bc\u00ae\u00ef\f3\u00d1K\u00ed\u00cfe\u001f\u00ac\u00e2\u00f9\u00fc\u00de\u00c8\u00024$j4\u00ec\u00d6$\u0010\u00e6D\u00f6t\u00fc\u000e\u0003\u00dcN\u00ad\u00c8\u00f0\u00acML\u00ebu\u00deb-\u00bckQ\u00be-y\u00b22\u0093&)\u008d\u001cW\u0094\u0093^\\\u0092\u0013T\u000e\u00e5\u00db\u00a8\u0093\u00c4\u008f\u00c6>j\u00b7\u00ad5\u00f1\u00f1n\f\u000e\u0005\u00e7\u00f5\u00bf\u00be\u008fVp5-\u0090=>\u00fda\u0084\u00cfp\u00be#\u00e1o\u00db\u00c38\u00c8\u00dc\u00e8\u00d8\u00bd\u008c\u0095\b\t\u0087!\u00a5\u00bc\u00c6\u00ab\u00f7\u00bd\u008am\u00f7\u00bb\u00a6\u00c1.\u00fd\u00db\u00ad\u00f3\u0003\u00d5\u00f8\u00eb<\u0086 woU~\u00a5\u009a\u00fb1\"\u001c,\u00f5\u00bc\u00a6MxnW\u00cf}\u00bbze\u0080\u00b02\u00940\u00f1\u00a8\u00edT(\u00ce\u00c1n\u0091\u00030\u00c7\u00f8#\u00c9\u00cc\u0090\u00b4\u0091\u0002\u00c2\u008e\u00b3R\u00df.@\u0084\u0092\u00c0pF\u00c2W\u0005\u00a5\u00de\u00ad\u000fT\u008d\u00d6\u0082\u00b0\u00fb\u0096E\u000f\u00b9\u009b>\u00f0IL@\u00d1#Z1\u0018\u0006\u00a0r\u0006Xs\u00dd\u0001'\u00b4\u009b\u00bb%\u00d5T_\u009aP\u0007u*\u0093\u00ff4\u00d2.\u0006\u00ed!\u00c0>4\u0083\u00ab\u00cb\u00f2\u0018\u00e49\u0098\u00fd\u00e0\u0002\u0016\u00e7\"%w\u0083\u00dd\u00bf\u008e&\u00f8\u00f5'+\u00b2\u00df}d:\u00b9\u000e\u000eT5@\u0005\u00a6\u00c8\u00f1ta\u00d2\u0097\u008a\n87\u00a1\u0087\u008c\u0096\u00e6R\u00d9\u00ba\u0002g\u0017Zx\u00a1U\u00e0\u00fd>R&\u00d3.\u008c\u0084.F\u00ef\u00e4\u0095B/5F\u009ei\u00e2j\u00f2!\u0003\u00e0]M3z\u001a\u0012\u00fa,q\u0084j\u0088\u00c0J\u0081u\u00bfo\u00ef\u00f3j\u001bR~\u00c8\u00e5\u0006\u007f\u00bfZ\u000b\u00d8'\u0090at\u0080\u00cemD\u00f3\u0007\u00f6\u00cc#\u0000/gm\u00a6\u0096\u00b3o6\u0089\u00bc\u00f44\u0001\u0085s`\u0086\u0099C\u00ce\n\u0010\u009c\u0018\u00a5\u00b8\u00a5\u0080pT\u0016\u00e7\u00b7\u0011\f\u0090\u0005W \u00e2\u00af1\u009ca}\u00b4\u00b6+\u00e0\u00a9J\u00d1\"\u0016\u00832\u00ed\b\u00e3_\u00ad\u00e6\u00a8`\u00b4\u00d0\u009b\u00d7\u00af\u00fa;\u00aa\u00caWc\u001b>7B\u00da\u0001mf\u00fd\u0006\u0090}\u00c8\u00aaK0.\u00ecBIf\u008a\u0090(F\u00cd\u00c5\u00b6\u00c9\u00e4bYm\u0004\u00ed\u00c6\u009e\u008e\u00a8H\u00ff`IZ\u00b1\u0082\u00f9\u008d\u00f6\u008e\u0015\u00dbv\u00e9K\u0005\u00b4\u00d6\u00cb\u009f4\u00fd\u0015\u00b74:\t\u0092i\u00e9\u0099\u0018{\u00ec@\u00baKM\u00faQ\u00e6\u00e4\u00d4\u00e4\u00bc@\u00c7}\u00e8n\u0016O\u0017cA\u0083\u000f\u00f0\u00f2\u001b8\u00b6\u00eb<\u00de\u00dd0\u0007N\u00e8-]\b>5t\u00e7\u00ce\u00a0[\u001aD\u00f2\u0084\u00fc\u008b\u0092\u0082\u0082\u00f9\u00f0\u009c|\u00bdr\u00d1\u00ec\u00bb\u00fd7\u0012\u0000\u00c3\u00e7\u00abD\u00c1\f\u0091u\u00e1q7\u00e6MzRU]\u009b\u00af\u00c4\u009e+\u001e\u00ae\u0015\u00ca_\u00c0\u00d7X\u0005\u00bd\u0083\u0010\u00b5\ry5\u0005\b6\u0080\u0018'\u0092J\u00ed\u001a\u00192\u00b9\u008et\u00a7\u0080\u00a8\u00ab.H\u009d\u00c5\u00bc\u00195=\u00c3E6e\u008aF4e\u00efT\u00b5\u00c8\u00d3\u001aB\u00e7i\u00eb\u0092\u00e7\u008f\u0016\u0099\u00f2\u00f3\u0013\u00b6\r\u00ca\u00e6\u0082\u00b9*\u00cc\u00a5\u00ba\u00b9\u0001+o\u0095 \u00e1\u00a4z\u00ed\u00d50\u00feP5\u0005\u00b5r\u0096D]\u00f9;\u00d4_\u00a6_\u00c6\u00c4\u00ba\u00fa\u00fej\u008b\u0096|\n\u0080j\u0005~s\u00a6\u0081\u00a1\\\u00e6\u00edz3\u009a\u0094\u00ed\u00f2\u00b4>^'\u00a0\u001c2\u00c7\u007fX\u00c6\u0097\u00e8\u00c0{mt\u00ae_\u00a89\\\u00d7\u00e2\u00e8\u00a5\u0089\u00eenP\u00a4\u0086\u00ba6\u0098p\u00c8]\n\u00ec\u00f2o\u00aeL\u00ae\u0088.\u00a34\u0087\u008c\u00d2!0\u00f7\u0095\u00e0\u00df\u00d1\u0097\u0083\u00f9\u00e7\u00ff\u0084\u009e\u00c9\u00cd\u00a5\u00c0\u00cc\u00e8@C|\u00c1\u0004\u00ef\u000fo\u008c\u00f5c|\u00cfY\u00e6L\u0085m?Y\u00afsnas\u0095\u009e\u0081\u007fQ\u0080\u00b9F#\u00af\u008a\u0096\u00cc\u00b0_M\u0082\u009e\u009eIp\u00a1*i\u0095C\u00ea-\u00ca\u0000\u00c3\u009c\u00f2\u00d1\u00d0\u0015}\u00ce\u0010\u0095\u0006`nJ\u0011\"\u00be\u0003\u00a3[\u00cb\u00a6J!\u000b|\u00b4I\u00c5tV\u00d2\u008f\u0016\u0014/\u0084\u00d61w\u00c0\u00f2!\u009c\u0016\u00a8\u009e`\u00a8\u00ee#\u009eu\"8\u00e9\u000e\u0084\u0089\u00fe\u00a1A\u00f1\u008d\u00dd\t|\u00cb> \u00ff\u00c0\u00cf&\u0018\u00fbN\u00f4\u0081P\u00de\u00acUm\u001a\u00ed\u00bbO\u00f7\u0014\u00a1\u0001\u00baB\u00e4\u00af\u00f2\u00f7\u009f\n\u0085\u00e5\u00b0y\b\u00c8\u00aa\u0097\u00d4d\u00a3uE\u00ef\u008f\r\u00e0G\u00c8\u00d1\u00d1\u00cb\u00c2x4{1\u008a\u001e6W\u00d8Ox\u00ba\u00d7s\u009d\u00db7\u0010xo\u008e\u0092\b\u00cf}\u00ea\u0093\u0010be\u00b7PpG\u00c5\u00c7\u00f9\u0000\u00a71.\u00c7\u00f3\u0087\u00adu\u0087\u00d3\u0006c\u00f1\u00b1\u0013F#8I\u00fb\"/\u008a[\u00da+4\u0087\u00bfx\u0099Z\u0082\u00a6\u00b9\u00b6\u00c8\u00b3\u00a8\u0000y\u0081E\u00b5\u00e3\u00f1\u0098\bY\u0002\u00f2\u00a7g\u00f2L\u00de\r\u00d7\u00dal\u00b5M\u00e2J\u001d\u0090G\u007f\u009e\u00a4\u00ce\u00e1J\u000b\u00db3T(C\u00ff\u00fe\u00d4\u00a1\u0094\u008ci\u00b9\u00da=\u0016\u00d1ZD\u00db8\u000e\u00b4\u008d\u00cc\u00d6\u00f7\u000b\u0089\u00f4\n9\u00ea@$\u00cd ~}@Z\u00c7q\"CK\u0010\u008cT\u00c2fH\u00d8.0\u00c2\u00bb\u0098\u00dc\u00d3\u00ce\u0090\u00a4k|3\u00f1F{\u00b0\u00c9K@?[yp\u000e\u00d3z4g\u00f88=\u0003I^\u00136\u00b9\u00c0\u008d\\\u00eb\u0094p\u00c5gj\u00dfD5\f\u00c2a\u00bdV\u0089D\u00e9\u008a \u0095\u000e\u0090-_AK\u00a3\u00fam\u0086\u001a*\u00ec+Em|,\u008f\u00eb\u0096\u001f\u00d1\u00fc\u00177\u001agb\u00e0\u009d%>P\u0098l\u00d0\u0012\u00b2\u00a1]}\\\u00d1hR\u00bah\u000b\u000fi\u0002\u0003K\u00f1\u0011\u00c5\u009e\u009a\u00a39P\"\u00a3\u009e\u007f\u00fa\u00d1u\fP\u0004\u0086\u00c5$\u008dI\u00ec\u00d6\u00e0\u00e1\u00de\u00ef\"\u0093\u00c0\u0083\u00805\u0094\u0092\u00df\u00c1#\u00ee\u00cf\u00dc\u0083\u00c7\u0085\u00d0t\u00bf\u00ee\u009e\u008dy\u00f3\u00b2\u008b\u00cc.\u000f\u0093\u00fc_\u0001\u00cf\u00d6\u0099\u000b\u00d56\u00a3\u00ac-\u001e^#$\u00b0\u001e;a9K\u00a3\u0096{\u0014\u00b7\u00f9\u0084/1\nv\u0004\u0084\u008a\u0007\u0018\u009c\u00bd\u00acs.&\u00fb\u00c9?M\u00b4\u00abM}R\u00f1\u00d5v\u00b6\u0002$\u0081q\u009b\u0017b\u009f\u0081\u00e7]\u00db\u00f2\u00fc\u00baD\u00aa\u00b6\u00f5\r\u0096\u00bc\u0093.n\u0012\u00ee\u00e3\u0084b\u0011a\u0091\u00bf\u0086\u0089\u00b3\u00f8\u00f1\u00e0\u0099\u00ad\f6\u00db\u00df&f\u0007q\u0095\u0092\u00f9\u00f9\u00f8=\u00f7\u00f6!2\u008fI\u00d3\u0092\u0095U!\u00b6\u0098\u00a7V\u008c*uE\u00b37\u00f1\u00aeke\u00a5\u00a1\u00a9\f\u00b3\u00b3z\u00b9\u00e0\u008f\u0006\u00fa4_)\u009ehb\u0019\u0011\u00baC\u00bc\u00a8\u00b0Y\u0006\u00d0\u00ec\u00ae\u0090\u00be\u00baA|\u00b4xuo\u009cS\u00c3\u00c1@PLQa\u001a7\u00a3\u00b5\u00bb\u00077\u008aNV\u00b3w\u00de(\u00bcRgP\u001d\u00db\u00ddX\u00faf\u00a6f\u008bB-\u00d2x\u00da\u00fdq}\u009b\u00c1\u001f\u00bc\u00f5L\u0018G\feK\u00c1\u00c7\u0000\u00d2%\u00c2\u00b2\u00bf\u00f7\u001aU\u009d`\u001aVT\u00a1,\u00ceRD\u0083\u0097/bTGH(7\u00d8A\u0017b\u0081*\u001d1n+\u00e4\u009f\u008b\u00e9\u0002\u0097\u00bdv\u00a6K\u00bb^\u00ffO\u00cd3\u00be\u000e\u0098\u00e3\u00b6\u00c2Y\u0085\u00cdY\u00bc\u0004\u00c6H\u0096H\u001e\u00ee>\u001f\u0013'\"\u0088\u008c/\u00b6\u00bf\\lG\u00c4j~\u008a\u0081\u00d1\u00fd\u0094^\u00da\u0086'\u00f3\u00ea\u0096\u00e2\u008a\u00a5\u00ab\u00c5\u00cfV\u00f3\u00cd\u009eT$\u0006'\u0002(\u0012A\u0004\u00a6\u0098\u00e4l\u00b9\u008aJ\u0016UY\u00c81}\u000f\u00c6\u0011\u000e\u0014}\u00c2m\u0014\u00be\u00d9\u0019o\u0081\u00b7\u00bc\u0084\u00f8Jm+\u00b5J\u00d3^\\\u00fd\u00dew\u000f\u00d6\u0014\u00ca\u0010\u00c1\u00c2\u00e0\u001bY\u00de\u00ca\u00a3\u00b6\u00be\u00dc\u00b8\u0005\u00b1\u00e5\u00f0\u00d4=\u00c2\u00cc\u00d9\u0091r\u00b9*\u009b\u0095\u00bd\u0000u\u00a6\u0001V\u0004\u00bc\u0002\u00d9\u001f\u0080\u00d9\u0088\u00d3\u00fd\u00b82\u0087\u00cb\u008f\u00eb(\u00e2\b\f\nN\u0013o\u00aa\u009a\u00b4}\u00e7\u00ff\u001a\u0011O\u00b4\u00ad\u00d7E\u0006L\u0092\u0089\u00be\u00a8lj\u00e2\u00dc\u0001\u00b7\u00db@\u001c2\u009b8\u000b\u0013\u008b\u00ab1\u009f\u009e\u0096\u00e4\u00c4\u00aa\u00cf\u00ab@k\u00bfgf\u00a6S\u00b9\u00b9\u00f2\u00f5\u00b5\u0090\u00b3\u00d0\u0000{:\u00e8\u008a\u00a1c0\u00b4g-w\u00dd\u0005\u0089\u00d8i\u00fe#\u00b1w\u00cd\u00cc\u00ed\u000fw\u001e\u00e5vBM|\u0011\u00cf\u00b1H4\u0014R\u009d\u00d8\u00ed\u00f8\u0013\u000e\u00c6$\u00fd\u0003\u00da\u00cb\u00b8G&\u0017B\u001ccW\u0015\u00d1@\u00e05 ;\u0018S\u00db\u00df\u0015\u0006:\u00a6(\u00d4L\u00ab*\u00b7L50^\u00bf\u009d\u00cd\u00bc\u00e4\u0000O0\tJ[\u00ef<#\u00b0\u00e4\u00e5\u00e1\u00f5B\b)\u00ba\u0015\u000b\u0095]\u00ccHQ\u008d\u00c4r\u00cd\u00eb\u00b2\u00be\u00ea\u00e8\u00e9\u001f&\u00a9R\u00e2Q\u00c7L1\u008a\u0094>\u009b\u00b4?\u00da\u00ce\u00dew\rG\u0080C\u00b2\u00ed\u00bd\u000f\u00c9#\u00dc\u00db\u00e2\u000e\u0089\u0098\u0090M\u008c\u00f5k\u00c9\u00e0tz\u0087{7u\u00fa^\u00c1\u0089P\u00b3\u0018\u00da\u00ae\u00dd\u008bE5\u0095\u00fa\u000e^\u00b4B\u00abs\u000e\u0010\u00a0\bm\u00ba\u00f2T\u00fc\u00bb\u00fe\u0085\"\u00b7\u00a3\u000e\u0011 \u00a8v.\u0006\u0018T\u00a6\u00c8\u00bd=nv\u001a\u00e7V\u008c\u00a0\u00c1\u00d4|\u00e3\u00db\f\u00fb\u0005\u00911\u00fdam\u00c4\u00ed]\u00aeuRX3\u00e4\u00e7\u0016\u00f9\u00f7V\u00e3.\u0091\u00f2\tH\u00a0\u0092\u001f\u00a9\u0098-*\u00cb\u00b4\u00bc8\u00d2\u001d1\u0005\u001ff\u0003m-\u00037\u00aa\u00bb:\u00b4\u0098\u00d6h\u00b2\\#\u00a7W_\u00ff\u00a3\r\u009c\u00ae\u00c5 \u00fb\u0001Q\u00ce\u00af\r\u00f9\f\u00db\u00ec\u00b1\u00f6\u0001U\\\u00d3_\u00bar\u00e98\b\u0099\u009e:,\u00b4Ukz\u0094\u0007\u00f9\u00e8\u00cc\u00e8\u000f\u00c5\u00981\u0086y\u00db\u0096\u00a5\u00d4\u0088d\u00da\u00c7\u00fc\u00e1Un\u009e\u0085\u00ab\u00ad$,\u00ecUAj&\u00b9Eb\u00da\u0080[\f\u0092i\u0019\u0017\u00d9?\u00beC\u00de\u0002C\u00aa\u00be\u0015\u00eb\u00e1U\u00a5\u00d8\u0096\u00f5(\u009dTq7%\u0082\u009fX\u00fe\u00f9Sr\u00c2\u0082V\u00ee\u00c3^>\u0099sB\u00db'\u00bf\u0097\u0006\u00f8\u009a\u00acp\u00f5\u00f1g\u00adl\u00ae\u0006E\u009c\u0092\nk\u00e7\u00e4\u00a0V\u0017\u00faW\u0018 \u0007\u00a0\u00f7\u00f47\u00f4\u00c9\u0017\u00ec\u00c4Y'\u00cf\u00b2\u001fq?\u00a7\r\u00ad\u001c}\u00f1\u00c7N\u00c0\u009e\u00f9\u00a8\u00c0\u00bc\u00c6\u00c8\u00e3 \u00a1\u00b5m\u00f5d2\u0010\u00cc\u0002T\u00e7}\u0005h\u00a4\u009b\u00cf{5\u00c4,/!\u0098\u00fb\u00b0\u00cc\u0000.xd\u0085\u008c \u00a6\u00e2\u009f\u00ee\u00ee\u00d01r\u0002\u00b6b\u00a4v\u00ea\u00efObKO#\u00ae#\u008f\u00ac\u00eab\u00f5~+\u00b2\u0099\u00e9\u00a6\u009d\u00d1\u00be<\u0012\u00bfC\u0017\u00a9\u009d&\r\u00a1\u0018\u0005\u00b2g\u00ff1\u008a\u0096\u001agm\u00c1`\u00ce\u0095\u009c\u00b5D&\b\u00b2a'U\u00ff\u00edT\u001c{\u00f8]\u00a6T\u00eb*o\u0006\u009c\u00cdJO\u00d1?g\u0090\u00df\u008e\u00c1x\u00c7l\u008bR\u00ac\u00ac\u00ee\u007f\u00d2\u00f8G<\u0003h\u001eQ\u001en\u00a7\u00f4\u00b51\u00c9\u00d8R\u0016\u0014\u00bcQ\u00a8\u001d\u00ff\u00d8\u00d1\u00e5\u00cew%\u0085\u00fd\u00a8\u008aF\u0016\u0091\u008fZ\u0096\u0000R\\W\u00c9-\u0001R\u00a5\u0006\u00ce\u0093\u0081FQ\u0089;\u0098\u0093B\u00df\u00d8\u00f6W\u009b\u00c0\u0089\u00c3M\u001a\u0019\u00f9R{\n\u00fc)\u00b8\u0017C\u00edi\u00dd\u00bfx/L\u00cd\u00ad&\u00a9x\u008d\u001a\u0094\u00e1\u00b7\u001fw\u00a6u\u00ba\u00de\u00dd\u00fe\u008c\u009f\u00da\u0012i\u00a3\u00d4\u0086\u00eaL\u00d0\tn-\u00dd\u0000\u0005\u008d&2\u00b9\u0096\u00b6!!4\u009db\u001e{\u00f7\u0003'\u0011\u00bb\u00de0\u00fa*\u00f5\u0092\u00a8\u008a\u0007\b;n@\u00a3\u00f8\u00d0\u009c\u00f8z\u00b6\u00cb\\Y\u00cb\u0087P_e},q\u0001\u0087\u0001\u00a8\u00d3\u00eb\u00ca\u00de\u00f7\u00b9\u00cc\u00f7\u00e5\u00f8\u0012\u00f7\u00ae\u00a9v\u00f1\u0091|R\u0013\u008c8\u00ed\u00f3g\u00e1\u001d\u00b6\u001c\u00f7)\u00bf\u00bd7\u00d4\u0001v\u00d8+\u00c7\u00aa\r}\u00be/\u0005o)\u00ecU\u00e3\u00d3b\u00a3\u0016W\\\u00feM\u00ea\u008e\u0082\u00a4D\u0095\u0002\u00f5\u0006\u00d8\u00ca#W[\u0099\u00ef\u00a7\u00d4\u00afn\u00bbW2\u00ae\u0087\u00f7\u008b&\u000e\u00ac\u00cd\u00a4\u00db\u00c8\u00f8\u00aas\u0081\u0002\u00ca\u00a7\u0090\u001b\u0081\u0005\u0099\u00beN\u00ac\u00acx>O\u00e4~H\u0087=\tj\u00c43\u00c3\u00d60c\"^vyp\u00a0\u0017\u001e:\u00fc \u00f5Y8B\u00adYF,F\u00cd\u00df3U\u0092^.\u00ab\u0080\u00ff\u00c8\\K\u00d8\u00bc\t\u001fW!^\u00bc\u00f8\u0086\u00beB\u00f2\u0092\u00a9\u00fbQ\u00ef\u00a7\u00a8\u00ed\u00f9\u00c3O\u00cd\u00ec\u00d0\u00b6\u0012\u0016\u001d\u00af\u0011\u008dV\u00c80\u00b4\u00d1#\u00b8\u009eR58G\u00ef%\u00df\u0013\u0005\u00d4pE\u0093Jx)\u00cd\u0013\u00ed\u0019\u00e7f\u00ef\u0094\u00ca\u00c2\t\u00ff\u00e3:\u00bfB\u00e2\u007f\u00be\u00caTN \u00d2@\u0005m.\u00d3\u00d4\u00bbK\u00ec\u00dbn\u00af\u0004\\\u0000\u00d3\u008fv\u00c0\u00014esQ]-\u00de\u001d\u001eBfg\u00b2qC\u0094\u0083dz\u0090\u00cd\u000b\\\u0099\u00c4\u001e\u008cC3\u0081\u00d1\u0010\u00af\u00ab\u0005\u00dfA\u00f0O\u00e0?b\u00e6S\u008c\u0086\u00a9\u000fH\u00a2\u0080\u00e4\u0089\u00b9\u0007C\u00c50=\u00aa\u00be\u008f\u0095\u0092;\u0080\u009e\u009b\u0090\b\u0017\u00a0aE^\u0010\u0098>.\u00c2\u00fd)\u00af\u00da\u00c9\u00ae\u00e7Q]\u00a2\u0006E\u00df^\u00c1\u00025)e\u009e\u00de\u008f\u0094*s\u00bcKD\u00a1\u00be\u0089\u001e\u00910V\u00c5\u009ct\u000bc\\\u00f2\u00e0\u00bb\\\u00eai\n\u0098T\u00cb\u001e\u00e6\u00ae6p\u0006\"\u0082\u00c6i\u00a4:\u00c9\u00fc\u00e0\u00ef\u00d8\u0099[\u00b9xv\f\u008b\u009c@\u00d9\"T}\u00b6\u00bf\u00c7Kp\u0096\u0001\u00f3\u0081\u00fb\u0013\u00149'\u00b4\u00a53\u00ef\u00de\u00e39\u0001\u00e7\u00df\u00b2`\u00e3dI\u0086\u00a9l9>\u00db\u00cc\u00c9\u00bfW\u00bc\u00fa\u00ccYA\u00c6\u00cdw\"\u00ac1'J1+c\u00f0J\u00c3\u00a9\u0094\u0085r\u0081\u00d9\u00ca\u001b\u00e2\u00e6\u00f3\u00c34\u0092t\u00b9\u00ba\u0091\u00a8\u00dd\u00a1\u00eb\u00b4\u00bfw@\u0096,\u00d1\u00e2s\u0097Q:O\u00ed\u0080\u00e9\u00124\u00e0\u00a2\u00d6;\u00ea\u0010\u00c6}\u00dc\u00c5\u00ac\u00a3\u00c6\u00ee\u00b7\u00eepE?|\u0002\u0092\u001d\u0085\u00d5\u000b\u00e1,p\u00cf\u00f6\u0012\u00fa\u00af-\u00019\u00e81Q\u0014\u00cf\u001a<Y\u00e8\u00dc\rG\u0005w.\u00c1?\u00db#\u00f3{\u0010\u00aa}o\u0005lFY\n\u0003*\u00b0PG9\u0099\u00cd\u0002W\u00cb_\u000b\u0084\u00f4\u0004\u0087\u0015\u00eb4\u009c}\u00bb\u00cc!,\n\u0013\u00efB$@\u00be\u00ac\u00fb\\\u00fe\u00b1H7\u00b4\u0010\u0098\u00d1*\u00b8<\u00caI\u008e\u00a88\u0093\u001d\u00ebF\u00a0[\u00c2-\u00aa\u00b4o\u0015\u0089\u00ed5a\u0003xffv\u008d\u00be\u009e\u00c8\u00acl\b\u00ae>0\u001d\u00c3*$C\"\u009d\u00d3]\u0000\u00b1?\u00f4'\u008a\u0013\u0098J.I\u0018\u00cf\u00f7\u00a4\u0093\u0006\u00c6\u00f5?\u00e0\u00cb\u00aab\u007f\u00dc>+\u009ap%h\u00a8oO\u00feg\u00df\u00c6\u00c5\u0085Z\u00a3:\\\u0004\u009b`\u00d7\u009c\n\u0093\u0013\u0013\u0089s\u0090\u00f7\u00d1K\u00eb\u0098\u00fc\u0004e\u0004PD\u0006\u0086,\u00c0\u00f2\u009b[j\rL>\u0092\u00b2i\u00f8\u00db\u00ba\u000b6\u00cc\u00f5\u00bfli\u00e9\u008f\u00dd\r\u00de\u009b\u00fc\u0087\u0010\u0098\u00e3e4s\u00f8c\u000e\u00bby\u00f3\f\r\u0014$\u0007\u00ab\u00fb\u00c02\u009e\u00be\u00b2u?'\u00e4\u00beu/\u0080\u009e^\u00c7X\u00b4_\u00fe\u00a5Q7\u0086(\u00bb\u0084Y\u00e5O\u00f5^P\u00101\u0018 %\u00d9\u00e1\u00f9\u008e\u00ed(Q\u0004\u0006e8\u00deJ\u000eG\u00d94\u0006\u0081\u000fxXv\t\u00fb\u00eaR\u0012o*\u0092=R\u00e9$\u00fbqf\u00bf\u00ed\u00e9\u000e\u000f~\u00f8\u00d8\u000e'\u00d7H\u00a4\\\u00d3r\\\u0098\u00cb\u00fc' f|\u00d2\u00b3\u00a3$;\u00a5M\r\u00dc\u001b'\u0010\u00d5\u00b0\u009a\u008dNK\u00bc\u00f6\u0097 `E\u00de\u007f\u00d7\u00e7\u0002\u009f\u00af\u00b7\u00c9\u0092\u00a75\u0091B\u007f\u00ab\u00ba\u001a\u00d1\r\u00cbA\u0003\u00fc\u0004m_\u00cd}\u00f7\u00f7\u00c6S\u0015\u00b8\u00cf'\u00d1t\u001f\u00c6hV_r\u00c3`&\u00e9\u00b5M\u00bcD\u00e8C\u00c9.\u00bd\u00a96x\u008c\u001a*34\u0088\u0016\u00d2\nm\u00cbx\u0007V\u00db\u00ecXL\u0082\u00e3\u00b4\u00fc\u00c3\u00b1z\u008f\u00fe\u0099*8vs1\u0090\u0091\u0098\u009et\u00076\u00c3\u00f1\u00f8m\u000b3\u00bd\u0000lL\u00a7%\u00ab$)\u000b\u00eb\u00cc8\u0083\u00eb\u00de\u00bd)\u0092\u00bdr\u0097\u0012\u0098\u00f6\u0012O\u009aG\u00bb\u00d0\u00e4\u00ab\u00a2\u0013P6\u00b2\u00fb\u008a\u0010%\u00a8]P\u0089:\u00eb\u00af\u00fadX\u00f6\u00cd&\u00e0\u00a7?\u0016L\u00c0\u00b0\u00c9\u00bf\u0096\u00cdy\u00f9t\u00c4\u0091a\u009e\u00e6#\u00a9>\u00b9N\u00ce\u00f3\u00c6=\u0099\u00eb\u00d8\u0017\u00b7<\u00c44)\u0093\u0019\u0019\u00b0\u00c4M\u009c\u00a8:.\u00a6\u0086\u00b0\u00f0\u0002\u009f@\u0081\u008c\u00f5\u00a6Px]\u00e1\u00de\f\u00df\u00cb\u0007P\u0013K\u0012\u00d5\u00b1kR\u00fd@\u0080Q\u008b\u00fa$\u00986\u008av\u0097\u00f7\u00d8\u00d0\u00c3wI\u00df\u001e\u0098\u0017,\u00a0\u00a4\u0089F\u00e1\u0095\u00a4\u00df\u0007\u00b4\u00be\u00dc<\u0007\u0017\u00e2\u00e4\u0011\u00f1\u00f1R\b\u00f7\u00a9\u009e-\u00cf\u0006P\u001e\bW\u00c1f\u00e1\u00e1\u00ed^\u00c8+\u0001C\u001a\u0082c\u00ce\u0085\u00f0\u00f4\u00c4|:'c\u00cf\u0094\u00beO\u00fc@j\u0003\u00de\u00000\u00a8\u00d6RCGW|b\u0018Fw\u00bc\u00be\u00c9\u0090\u00a9\u00c7|\u00c2|\u0086\u001e\u0010\u0089\u00bb}\u00c5\u00d6g\u00a6S\u0097y\u00c7}\u00b7\u0002\u0016\u00b4\u009fLe\u00b2\u00e11o\u00db\u00b1{\n\u0015*tf\u00e2\u009fh\u00acD\u0006\u0003\u00186\u00faf\n\u0087]K.\u00e7Ib\u008b\u00dc\u0017\u0091\u0092\u00a8\u00e5\u00cdL\u009f\u00ec\u0092AWX\u00a5\u00d9D\u001f\u0081\u00d0\u00d8\u00f7o/F~\u008d\u009e+Bxl\u00ddz\bn\u00fcZk\u00bb\u00a6X:\u0015\u00a9\u00dc'\u00ae\u0082\u00a6\u00d2GF7\u00c6=\u00ebL\u00e2\u00a4z7\u00ad\u00f4Bz\u00fc\u00a6_\u0095\u00c9/\u00f8)\u00c0\u00fe(\u00bb\u00ba^%j\u00b1\u00fa]t\u00b3u\u00f18\u00c7r\u008fJ\u00d1b+\u0001\u00f0\u00cd\u0000\u00a3_\u00ae\u00bb=\u00f5V\u00c8\u00e16iQE\u0097!D\u00b9\u00fd{\u0081\u00b8c\u00b6\u0081#\u00d03\u0011K\f\u00b8\u00c0F\u00a9@Q\u00e4x\u00f2'\u00d4\u008a\u00ad\u0097\u00c1\u00f4AeM\u00e8\u00df\u00adf2\u00d9\u00f6\u00a5\u00b8H\u009au\u0017\u0096\u0092\u00cb\u00e5\u00efP\u00d7\u00dfW\u00cce[\u001a_)`\u00a1\u00bb;p\u00ef<Y\u00d2}\u00807i\u00be\u00d7\u001f%\u00fbd\u009d\u0098HcI\u00a7Q\u00db\u00b1\u001cF\u00e7\u00c0\u0093\u00d0\u00b3\u0081S|\u0088\u00d7D\u00da\u008er\u00ff\u00de\u0087j\"\\\u001eb\u00b8!\u0087=\u00db#\u00e9\u00fcD8oM\u0015u\u00b5\u00dd\u00e96/\u008cTk\u00bc\u00f4TT\u00ec\u00c1p\u001a\u00c1\u00db'rmy\u00ff\u0097\u00c9\u001e\u00b5`\u0089{\u0005D\u00b9\u00ad-\u00d9qlv\u00c1k\u00de\u00e3Aw\u00c7\u008c\u0089\u00a4\r\u009eu\u00f0o\u0089<+\u0087_\u0007\u0088\u009d\u0094bb\u0097m\u00a0Hj\u00b92\u0018yK\u00d1]DG~\u009f\u0086\u001d;\u00a3\\\u00a2J\u00c5\u00801\u008f\u00d2ZR\u00a92\u001fD\u0092$\u00cf\u0091\u00ef\u00da\u0007\u0017\u00fb\u0086\u00acr\u0010y\u00f5Cb\u00b66\t\u00fc\t\u0016\u00e9\u00e6\u00dcq\u00e4\u00f5G\u008e#e\u00a8\u00acFV\u000e\u0092\u00ea\u00a1\u00cel\u0098a\u000eJ._c\u00e8+#\u00dd0\u00c7\u00a9\u00d6@\u00fb5k\u00e9y\u009b^\u00d74W\u00b53\u0019\u00b8b\u00de{\u0096K\u00da\u00c0\u00e0\u001d\u00e9\u00c71\u00e26R\u0085S:g\u00d2ON=\u008bz\u00a2=Ou_'\u00a3\u00f1\u0095v\u00f0\u0090\u001d\u00120\u00c9\u00a03\u008e\u00b0\u008e\u009d\u00e1\u0091F'N5\u0093\u00c0\u001d\u0003y\u00a0%\u00faq{\u00b5=\u00ff\u00a92]\u009di\u00fc(yv\u00f5\u0001\u0014v\u00c3!\u00b5\u0018\nz,\u00e3\u00ca\u00adt0\u00b0W\u007f\u00cb\u00f8V\u00e4\u00e6\u00cfq\u00dfn\u00b9\u00e1\u0013\u00b2\u00f70\u00ee\u00aa\u00c0\u00bbQ\u00e6@\u0096\u007f\u00a64%\u00d1\u00fa\u001bq\u00f6\u00ea\u00c7q\u00c7\u00f3\u0087\u00cd;\u0016n.1!.O\u0017\"y\u0092,\u00a6'r\u0088\u00bb\u00c5\u00a3\u00fc\u00ed)\u0018/\u00b7.\u00f9\u00af\u00d5p\u009a\u00ce\u000b\u00db\u00f0\u00e1\u0012O\u00d1\u0084\u00dd\u009c<\u00af\u008dY|xD\u00c5\u0099\u00b4v\u008f\u0098\u00b7\u00d5\u00d7{\u009005\u00ab~\u00b6\u0083X\u00e6\u0019D\u0007*\u00d9\u0007\u00d9P\u007f\u00ea\u008a\u00d6\u001cK\u00f3nw\u00a3\u00b4\u00ca\b\u00ab\u00b4\u00b6\u0099qQ\u00e7\u007fWJ\u009c\u00df \u00b0}\u0080\u0003\u00f3\u00ac\u00f4\u00a9\u00eb)\u0085\u0014\u00e2\u00cep\u00afa)O/\u00dd\u00d1=@b\u0091\u00e5-\u00ab7\u000f\u0016\u0012{!@\u00af\u00d6|\u00a4\u0080\u00ca\u00c7n\u00c7\u00fc\u00d0\u00ce\u0018\u00b3\u000fh\u00bc=\u0088[\u0014\u0095\u0097\u001f\u009dj\u001bQ@\u008d\u00a3\u00d8\u00df\t\u00da\u0089\u00ce\u00f8\u00e5\u0002\u0018L\u0000\u0085o\u001bt\u00d1t\u00d7o\u000f(G\u00d3\u00b4D\u008f*7\u00b8\u00e65\u00d3ps\u00e3\u00f1\u00de\u001c\u00a9\u00e6\u008ei\u00b4\u0089\u000f?\u00d2\u0094\u00e2\u0097\u00e1\"\u00f5?\u0088\u0019J<\u00eby\u00cf\u0086y\u00d1\u00abu\u00ea\u00fdfb4\u00ba}\u0016\u00cf\u00c7k\u00ab\u009bX\u00c6\u0007\u0086\u00fbC{\u008b\u0080\u00ad\u00de\u009a\u00b8\u00bd\u00bb,E1\u0007\u0007by\u0091\u00a7\u00ee\f\u0080\u00fa\u00ba\\'M\u00bf9\u0088q\u0081\u00b1\u00a5\u00b5x\u00c2\u00b6\u0012\u00d3DX\u00a5\u00c6\u00a7\u008ftbZ\u001dw\u0011T\u0081({e\u00b6\u00195\u0085\n:\u007fu\u00dc\u00ef\u00b5a\u001a\u00b5\u00bc\u00e3\u00d0\u00ecv\u00d1\u00f0|\u00f2\u00ce\u001d\u00e8\u00a0\u00ee=\u00c1=\u001b\u00ed\u0089\u00fb\u00fbK\u0097\b\u0093;\u000e\u00e5\u0019\u00eb0\u001c\u00baEY\u00e9IV\u00b2(\n7\u00b4.\u00b7'\u00e0\u00df\u0003#\u00aef\u00b1\u0088p\u000f1\u00d5\u0010\u00fe\u0095\u008e\u00e2FG\u00eaH#\u008cz\u00d2r\u00fd\u00ce<`\u0091\u00c8*\u009b\u00ac\u009bb\u00a7#\u0091\u00c4z\u0093\u0011\u00f2m\u00d6\u001a\u00e2\u008b\u00b2\u00e1\u009f\u00b16!vw*\u00bd\u00e2`\u001c3\u0005\u00b2F2 \u00a6$9\n\u00d0\u00d0K!\u001e\u0002A$\u00e3k\u0087\u0094&\u00b5\u00e3\u00f8\u00ca\u00e8)\u00b0\u00c0\u00a8^U\u00ed\u0099\u00b8\u00aaiT\u001bk\u00d6\u00f72\u00d9\u007fS\\\u00f5>&\u00bf\u00c3=\u0089\u00a1O]\u009e\r&\u00efA@\u00ad\u001f3\u00b6y\u00f8\u00ca\u0000\u00ef\u00c6\u00b2da\\\u00d0\u00ebo81z\u00b3\u001df\u00ac\u00e3\u00f8\u001c\u008b\u00a0\u00c7(\u009c\u0012\u00d9\u00c3\u00a9\u00f5\u00e5\u00e1\u00bdp\u0092k\u0096_Q\u0006\u00bc\u00c6B4\u008cg\u0000?\u0087\u00ba\f\u00c2\u00ffF\u00ea\u0080\u00f2\u0092\u0084\u0013\u0016\u0095s\u00fb\u00e8\u00ca\u00a71x\u00c80\u00c5\u0010;\u00f3\u00d6\r0\u00c9\u00b2\u00f1\u00c2\u00854\u0098J\u0083I\u0017\u0084)\u00d8\u00a4\u00f5\u0089\t!<\u00e2\u00bb\u00caK\u00c9?\u001a\u000e\u00a9\u00d8\u00a4\u00e3\u00f9m\u008f$\u00c3\u0089\u00bc\u0013\u00c2\u008b\u0089\u00aa\u00e2\u001e\u00ce\u00a3\u00a5a\u00e1\u00b7\u0088\u00ef,G=\u0013_\u001bN\u00ff\u0097J\u00c8\u00c8\b\u00cc8\u00e3\u00b3\u00f9\u00e9E\u001d\u00c6\u0002\u001dw\u00c1\u0089\u009ax\u00f9:\u00e5\u00a5\u0081\u00ca\u0096\u00c3\u0089\u00d5\u00ae\u00e6R\u00f6\u00dd\u00ecO|\u00ec\u000f\u0084\u001c\u00cd\u008b\u00fe\u009c\u00ed\u00c3F|\u00a7;\u00b63\u00c3S7\u0010\u001a\u001f\u00c6\u001eJ\u00ed\u00b0HR\u00db-\u0010\u0011\u00971\u00b7\u001f\u00f3>\u0081\u00db\u0094\u001e\u00cd\u00e1?\u0001\u001e\u00eb\u0092%\u009d?vo'\u0086\u000fY-\u00a3x\u0000\u00cad\u00c6\u00fa\u0090u\u00aa\u00deE\u0093\u000b\u0089\u00ad{\u001f\u00ef\u008f\u00cc\u000f\u00a8\u0086x\u008f\u00fd\u00d4\u00f4\u00b2\u0003\u00d7#\u00ca\u001dC\u00ef\u0017(\u0088\u001e\u00cdt\u000e0K\u00e9]\u00ba\u0089\u008bY\u008c'\u001c\u00f5\u00b9\u00e8\u008d\u0018\u00e8\u0019}\u00f9\u00c7\u00d0R\u00c0\u00bcB\u0016pi\u0099s\u0087\u00cd~U\u0090\u00e56\u00f8\u0013TM\u0093\u00adAy_\u00ce)\u0089\u00a9\u00c0\u00f9K\u00e5C\u00f7\u0080X\u00b7\u0092=\u00e3c\u00cd\u0007d*\u0095\r\u00a0p\u00aa_\u00d3x\u008e\u00e6\u00af\u009d\u00a0\u00b3\u00ffv\u00e7\u0002\u00f2W\u00ca\u00e3\u0011\u00a4\u00ad\u0017\u0092\u00e1\u0013\u007f\u00adg&$}\u00bes\u00ab\u00ef\u001f\u00cd\u00ba527\u0084{\u0080\u00b4Y\u0014\u00a4\u00dc\u001f\u0080\u00ceBnj<\u009d\u00b0\u00ec\u00d0{\u00be\u009b\u009d\u001bG\u009a\u00d7\u000b\u00e9\u0087\u0017\u0080\u00d1\u0014\u0090\u00ff\u0092\u0017q,\u0010\u0098\u0091\u00a3W\u00a10\u00d6`\u00e6\u0019\u00e1\u001a\t6F\u008a\u0001\u00c0B\u0085\u0098@\u00a6\u00db\u00ce\u00bb\u00bc~\u00b5\u0016z\u0097\u00fe$\u00e9\n\u0003\u00d6\u00a5e\u00f0u\u00e7\u00ee@>ow(\u00e2=\u00ddF\u00ddV\u00acT\u00d2\u00bc\u00be\u0089.\u00c9\u00af\u00cbg^JC\u00f3\u00a8q\\g+z{h\u000e\u00a4z7\u00a3w\u00d1)\u00b4)\u008d\u00ccf\u00a5/\u00f5\u00e8/1:\u00b6\u00af\u00ff+\u00c6\u00a3\u00d6\t\u0089J\u00b2\u001d\u00bc\u00b5K\u00b8=f\u00a9\u00ceLS\u00aa\u00d0\u00a7_2\u00b9\u0017 7^\u00d23\u00f3\u0012]Up\u00fe\u00c3iA\u00d9aC\u001b\u00ee\t\u00a5\u00cb\u00a3\u009b\u0018~)\u008f\u00dc\u009c\u00fc~\u0094\u008c\fm'~\u00fa\u0011\u0016\u00f3\u0088vn;\u008c9\u00c6*\u00ba\u000f\u00e3n\u00c5E\u000f\u0097\u00bd\u00b1\u00c8w0\u0000\u008a\u0010o\u00c6\u00f0k\u00b0\u00f5\u00b1\u008aH\u001d\u00eb\u008f7\u0084\u00dc\u00bc\u00fe\u00fc\u00ce\u00ff\u00b2*\u00fa\u00e9F\u00d3\u00d8\u0086\u00eem\\w\u00bc\u00ae\u00b3w.\u00b1\u00e9\u0085\u0081\u00c1\u008f\u00b6\u0095\u0093DDw1\u00af5x8}\u00a1O\u00ffM_\u00db\u00a6Z\u0014ar\u0012mB\u0019s\u001a\u0013\u00a1\u0096\u000bA\u0015\u008b1\u00e2\\\\M9\u00fc\u00d1\u00ab\u00e5\u001bz\u00b4\u009d\u001f\u008dB\u0086A\b\u00aa\u00fd6\u00bb\u00e3\u00a8\u00eb\u008bJ\u0086\n)KwR\r\u00b6\u0005\u00e4\u00actC\u009c\u00f1\u001e\u00d2\u0000\u007f&e9\u00d2\u00e5]\u00e2\u00cd^\u008b\u00f97\u00cbC\u0007G\tX\u001d;\u00a0s\u00acM\u007f/\u0010\u00cf\u00ac\u00e1\u008f,\u001eW3\u00c5\u00ad\u008d\u00ae\u0098\u0004\u0085,<\u0087\u00e0JN\u00a5\u0014s\u0096m\u00fe\u00c4\u00a4\u00c9\u008c\u00ffW\u0012\u008e\u0007*>>\u0082\u00e2<\u00c3\u00e7\u00bb\u001dU\u008d\u00bd \u0000,\u009f\u00da\u00af\u00ef\u00a6\u00e60\u00a6\\\u00afK(D\u00a2\u008f\u00a7\u00d4\u00ac\u0018x\u00f5\u00c2Z\u008c\u00f8bn\u0098\u00fc]E\u0084\u00e8\u00c4\u0099y\u0005R\u0094B\u00fd\u00a5#\u00e0\u0013\u00ef\u0083\u00a5V\u00b2v\u0099hk\u00fb\u00a8\u00d1b4UD\u0006\t\u0004\u0085|J\u0084{Y\u00a9Iu\u00e0K6\u008cRvE3\u0099\u00b3w\"\u00e6\u00fb\u00b4%\u001d\u00ddK]\u00da9\u00deSi\u00ad\u00ec\u0098\u00c1\u009f\u00d0d\u00f0|\u0018\u00a8\u00b2M\u00bd\u008f\u00bbG\u0011CLK\u00bc!\u0094\u00b1\u00f0\u0086\u00d5\u00df\u001e\u00d1\u00ad\u00cc5\u00f7\u001d\u008c\u008cWs|\u00df+\u00a1\u00be\u00af\u00ca\u009c\u00b9U\u0007\u00b59\u008as\u00ea\u00c8;\u00bf\u00b4-\u00b3n\u00f8\u008aq2miO\u00fc\u00d6\u00a9/\u00bd\u0096\u00c6Z\u0087\u00b8 \u00f2P\u00c5\u0093/Na\u008c\u00cb\u0087\u00e6\u00f9\u000e\u00c3\u001by\u00b1\b+3\u00f3\u00ba.\n\u00e1}\u00f8C\u00f2v\u001f\u0007>UQ\u00a2-\u0000K~\u0087^Y\u00ab\u0007\u0096O9\u00f0\u00fe\u0098\nZ\u00ce\u00b1\u00f2\u008f=_\u00c5\u008f\u00ca\u00a6\u008b\u00e2\u0001\u00f3\u00e7\u00dc\u00d0\u0099\u00ceg\u00b5z\u00db=\u00fd\u00e5\u0013W\u00e7H\u00b2\u0016\u0084\u00cf\u00e8\u00df\u00d1!z\b\u0091\u00dfB\u0017\u00e2\u00060W\u0005$*f\u00fd\u00c9\u0013\u00bf\u00fe]\u00f2\u00c4\u001c\u0018Q;\u00e0{\u000b\u007f\u00d61d)j]\u00cb\u007f\u00b5\u0001\u000f{\u00e3\u00f2J\u009c\u00dd\u00d6\u00ef\u0090\u001c\u009da\u00ecI\u000em\u00a3\u00df\u009d`#f\u00f57\u0016\u00ce\u00e2\u00e9v\\HXB\u00a0\u00ed\u00d2\u00a3\u00dfs\u00b0akd\u00e9\u00b2\u00dbC\u0013eb\u00d0\u00d1\u0097\u00a7\u00dc\u009e-\u00d4\u008e\u0081\u00d1\u00e6\u00b8\u00ca8\u0094\u00b5x\u00e4\u00f9\u00ab}%\u00f8}\u000b\u00cb\u0091g\u008a\u00c2\u00d5N\u0005up=k\n\u0011\u00bbE3\u00e5*\u00f4\u00f0\u00db\u00c5\u00f3\u00bfV\u009b?\u00e9\u00e5E\u00ef]-V\u00f2&\u00e2\u00c1\u00f3\u00a4\t\u00bb\t\u008bv\n\u00f2\u00d0\u00e5\r8\u00c8\u0082\u0016bfY\u0015\u00e8\u00ab\u009a?l\u0010\u00ef\u00d3\u0001\u00ab\u0097\u00f2k\u00cf(\u00f6<\u001eA\u00e1\u000b\u00d8\u0003T\u00d2\u0085\u007f\u008d\u00c40}\u0083\u00bbf\u000b\"\u00a6\u00e3\u00c4\u008c\u008a>\u00c4\u00ffW\u00da\u00cc\u0014\u0004\u009d\u00b6\u001b\u000eX\u0084\u009d\u00e9zh,{*y\u00b1\u00ce\"\u00b3\u00a2S\u00fe]\u0087R6\u001b\u00bf\u00d3gEv\u00d7F/rU\u00f6\u00ad\u00a9[k\u00c3k\u008c\u00c6:\u009f(}R\u0017\u00d9&t\u001d\u00ca\u008c\u0013)\u0080\u00036S)\u0091/\u008e\u00c9]\u009b\u00c9\u0004\u0005\u008c\u008d\u00b1\u00b2\u00d4\u0091\u00a6f6\u0085\u0002\u00b7\u00c3[v\u00b5\u0090/3\u008f\u0007\u00a2%\u0085\u007f\u008e\u0003\u0095\u00d4\u00a1\u0006\u00dc$!s\u00f8\u0004<\u00b8\u00d3\u00c0{f\\\u00f5F\u00e5\u00d0~\u0002)\u00ce\u008am\u00c5p\u0084\u0017\u00d5X\u00a1_al\u00d7\u00d0m\u0000\u0017.\u00beh\u00db\u00e8\u00d3w\u0093\u00b4\u00d5\u00f1X\u008f\u007f9\u00b3\u00c1-\u00e1\u0097E\u00c1\u00cd2\u00fd\u009cN\u0002\u00b4\u0010v\u00f9\u00e7\u00b2m$7\u00adtY\u00a1\u00e0\u00afW\u0015\u00ca\u0096\u00c2\u00c8\u00be\u00df\u008e\u00c1\u00b4\u00a5\u00ed\u00fd\u0084\u00d53\u00c0]\u008f}=\u0092\u00d7\u00a2\u001d\u00fc\u00ec\u001f\u0002U\u0086\u0006b\u00bbr\u0094\u0096\u00fd\u008e\u00f1\u00bb\u009c\u0096\u00cc\u00fc\u0087\u00d8\u00fdc\u0001\u00be\u00b1\u00bd\u00ee\u0080]\u00be\\\u0099A\\\u0013\u00b5D\u009c\u00f6\u00e5#!\u00eb\u0084h\u00ef\u00e6K\u00d6\u00b8\u00b5\u001a\u00df\u0007r\u0092\f:\u001c\u00c2\u00f1\u0093S=\u008e\u0003U\u00c8u\u00ad\u00f0W\u0013bR8M\u000e\u009d\u00ee\u001a\u00e6Wj~\u008e\u00be,\u00f6mu\u00d2\u00a5\u00ec\u00d3\u0080\\hN5\u00c2\u00c0k\u00d1\u00acq\u00c3\u0005yE\u0097gHE\u00ab\u0085a\u00d0g;\u00e7\u0004r,ob\u00ac\u00c0^\u00a1\u00c7E?\u00cf\u00b9\u0001Hkt\u0018\u0016l+\u00aa\u00b5\u00bf\u0093j|\u008fU\u00f3\u00f6ve\u00db\u00a2K\r\u00da_%\u00aa\u001f\u0091\u00a49\u00e1;,\u00d1\u00e9\u0093l\b;\u0006\u0093\u00bd\u00bf\u00ef\u00df\u00eeDw\u00af\u00a6\u0017\u00c1\u00cb/\u00a2\u001d\n\u00b6\u00bf\u00f7\u00e4\u00ee\u00ee\u00d2!\u008f\u00cb\u00ed\u00fd\u00da\u00be\u00fb80l\u00ca\u0019R\u008c\u00c8\u00b5\u00e1\u0089\u00ae\u0080\u001e6\u00a6\u00c4J\u00fd\u0086X\u00a1\u0005\u0095LH\\T\u0080\u009fli\u0002,\u00a3\\\u00b8\u00e1\u00e88\u00d8\u0092\u00e3&\u0004Ko`.\u009a\u00ea\u00fb\u00e7\u00c2\u00fb\u00a4^\u0090=\u00df\u00be\u00b7Lr\u0000\u00e5rH\\\u0084.G\u00c0\u00f8\u00dc#\u0087\u00bd8Ei\u00ee\u0011\u00ba\u00f1\u0019\u009eV\u00dd\u0007\u00dd\u00feJ\u00be\u00ab@M\u009a\u00d2\u00df$s\n\u00cc(\u00e4:\u00e1\u00a6I\u00a1qA\nM\u00e5Y\u00c6\u00c18\u00a5\u00e2\u001a\u00e4\u00a6\u00bd\u00f8\u00b7'\u00f2\u00f9+\u00c4)sN\u00ec\u00ed\u00b1\u009b\u0018\u00de\u0087%\u001c'\u00b8\u00a5\u00b0\u00a8\u0087~\u0097\u008e\u00fe\u00d5\u0083\u00d5\u00de?\u0086}p@8\u00c1\u00fa+^\u00b7\\\u0090\u0018\u001c\u00f6\u00cf\u0097\u00bb\u00f29\u00ddB/\u0005w\u00d3\u00ae\u0017\u0014Fkt\u00ff\u0006\u0007)\u0084\u00b4\u00c4.\u00e1\u00bb\u00b5\u00f3]\u008d\u00f0\u009d\"\u009c\u00aay{\u0017N\u0084\u00d6\u00bd\u00e1\u00aa\u0018\u0019\u00926[\u008eD6\u00bd7\u009c\u00d05\u0010|7\u00a8\u001a\\\u00ba\u00109QKF\u009d\u009b\u00b8\u00efqM\u00d4\u00ec\u008c\u0086\u00c3\u00f2\u00d3\u00cb-\u00c5v$\u00d1lt\u0093\u001b\u00a7N\u001b\u00a5{\u00c9a#\u00ect\u00e9iJvb\u00d3\u00af6o\u00e2>[\u0000\u00c5m=\u00adA\u00e5||&\u0016\u0089\u00a3I\u009f\u00f1\u000e\\e\u00aa\u00f79\u009d7Aj\u00b7\u00c4\u0081\u008c\u00f77\u008b\u0087/\u00a9\u00fb\u00e3\u009a&\u0002Ev}\u0017\f\u00dc\u00cc\u00e36\u008b\u00de\u00f2\u00c1\u00ff\u00f0Y\u00d5\u00ae\ry\u00cd\u00b7A\u00c2\u00e9\u00fe\u00ff\u00d7\u0013\u00e9\u00b9\u00ac\u0010\u00a9\u00deG:n\u00a8\u00bf\u009bdr\u00e3\u00d5\u00cbA\u00b75\u00e5: \u00e4\u001eU=\\\u00e4\u0014w\u00c5\\\u00ef\u0091\u00ec\u00f0\u001d\u00af\u0099\u00ed\u00e7cS/x9\u00a3\u0093\u0007tp\u00d0#x\b'\u00b9\b\u0005\u001f\u00aa\u00cb\u00c2\u008a\u000b\u0090\\j\u0085\u00f1m$\u00ffA\u00ee\u008ar\u00e9\"\u00a9z\u00d8\\\u00b1\u00f0\\\u00a3q:\u0001<\u00ca\u00b4\u00e1dA\u0086\u00b2)w\u00d04a{\u00b2x\u0083[\u00a1Q\u00f0\u009a^U\u00a2\u00b2\u00fb\u00a8\u0006 lh\u0003^\u00dbd\u00fa\u00dcJ\u00c1\u0017\u00f6)X\u00a6:@\u00ff\u00ae\u00c5\u0016M\u0017\u00fe\u00a3\u00be\u00877l{\u009b8\u0087{&\u0097|\u00a7\u0007\u00d6h\u0091\u00b8\u0096R\u0010u\u0011y\u001a\u00a1s!@p\u00f8\u00f9\u000e\u00b7V\u00b1\u00d6[\u0080\u0011\u0012\u0092\u00db\u00fe<\u001d\u0083\u00cd\u0085\u001f\u0012*\u00ea\u00df/\u00b6\u00e8\u00be-\u001d\u00b2$\u009d\u00a2\u00b78M\u00ca\u00de\u00d5\u00f30\n\u00bb>C\u00dc#Z_\u00be\u008f\u001c>\u00c5p\u000e`]\u001f\u0088}\u00fe\u00be\u0006\u00131\u0015$\u0099$\u0083\u00dcSU\u00e6\u001e2\u00d2-u\u00f1\u00d4o\u00bc^*\u00b6w\u00b8G,\u0083L{`\u00e2lI\u00c9[\u00a4k\u001f\u00b4S\f\u00c6\u00b6\u00ad\u00fa\u00c1\u0007\u00ba\u001ei\u00e9\u0003\u000f\u00d3\u00bf\u0004\u00cffo>\u00ff\u0085\t\u0003\u00ba\u00aew\u0085\u0085)\u001c\u00f9.~\u0016'\u00c9\u00cb\u00bf\u0007h\u00e5\u00a7\u00c6\u00b9mxMJ1\u00ec\u00c2%\u0089\u0003\"\u00f2\u00cdPSJ\u001b\u009c! '\u00fc\u00f0E\u00c7\u00a6\u00b04\u00e4\u0082\u00ab\u0085\u000e\u00bbp\u00dc\u00b1=\u0017\u001a\u00ea8\u0085\u00aep\u00e40\u0082h\u001bP\u00f3\u0000R3v\u00f7\u00fa\u00c6\u0097>%\u00c1q\u00b20'\u0086\u00eaV\u00b6\u0083\u00e6\u0081:*\u00e7![b\u0004T\u0089\u000fw\u00d9(p\u00aba\u00a4H\u0013\u0019V\u00b0x\u0093+:L.R\u00d0/\u00b6S\u009b\u00b1\u0098\u0090R\u00a9\u0012\t\u00dd\u00eb\u0016)\n\u00b43\u00af\u0099\t\u0006v\u00e9d\u00c2\u0096\u009b\r\b\u00f1\u00f0Gm\u009a\u000e\u00ce\u00e3L\u00a1\u00d0(\u0097\u0086\u0014\u00fe\u001d\u001c!\f\u00b5\u001d\u00b0d\u0090\u00a0\u001c\u00b7\u00bb\u0017\u00cb\u00ad\u00b8\u00b3\u00d9r\u00e4\u00d60\u00cd\u00cb\u00f0\u00ce\u00a6\u00f3\u00ac\u00c9\u00b5a\u00b5\u0087\u00cb\u009d\u007f\u00a3\\}+\\G>\u0016@C\u001c\u009b(\u00f2\u001e\u001b&\u00965\u00a2\u00deZxV\u001b\u00e4\u00fbqaC\u008c\b\u00b0\u00c3\u0097f'~{\u00be\u0080\u00149n\u001br;g\u00aeq\u0088a\u00ef\u0003\u00f1\u00cd\u0094[Qg+\u0085\u0099\u00e2\u0085\"\t\u000eN\u00eak\u0086+\u00d9\f]mY\u0099\u00e83s*.J}\u0094<g*\u0003\u00d9u@E\u0092m\bX.h\u0081 \u00b8[\n\u00d5\u00d0\u0098:\u0019\u00f0\u00ce\u00a6\u00b0\u00a8\u00c3\u00d9\u00e6\u00a9\u00fav\u00c5\u0092\u0087\u00b2\u0005\u00b0\u00d0A\r\u00f1\u001b*\u00dc\u00de?\u00aaA\u00ab.#\u00a9G5\u00b7zJ\u00d5A\bt0\u00d2\u00e2\u000b\u00dd\u0086\u00d7\u00b41\u0082(\u00b4D\u001d7\u009a98\u00a4\u00a0*\u008a\u00b1\u00a0E\u00b4").length();
    int substringLength = 117;
    int currentIndex = -1;
    Label_0023:
    while (true) {
      ++currentIndex;
      final String tempString = obfuscatedString;
      final int beginIndex = currentIndex;
      String substring = tempString.substring(beginIndex, beginIndex + substringLength);
      int innerLoopIndex = -1;
      while (true) {
        final char[] charArray = substring.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
          char c = charArray[i];
          charArray[i] = (char) (c ^ switch (i % 7) {
            case 0 -> 'Y';
            case 1 -> 'A';
            case 2 -> 'X';
            case 3 -> '$';
            case 4 -> 'p';
            case 5 -> '[';
            default -> '/';
          });
        }
        final String decryptedString = new String(charArray).intern();
        switch (innerLoopIndex) {
          default: {
            decryptedStrings[index++] = decryptedString;
            if ((currentIndex += substringLength) < obfuscatedStringLength) {
              substringLength = obfuscatedString.charAt(currentIndex);
              continue Label_0023;
            }
            obfuscatedStringLength = (obfuscatedString = "\u00ff.\u009f\u00ccP\u00d9\u00f6\u00d2\u0098Â°\u00e1\u00c5G\u00fcrÂ²ifO_\u00e8Â¶[\u00d6.\u0000\u0004\u000f\u0013GÂ®\u00fc\u00dc1\u00d4\u007f\u001a\u00fe\u00e0\u00c1\u00fa1\u00ce\u00e7\u00d4\u00c3\u0006\u00ad\u0096\u00e7Âµh\u0081\u008b+\u00da\u009a\u009a\u00fb\u0005Â·6#Â¸Â¸\u0010Â¨\u0087Â¸=\u00d4\u00d0\u009b\"\u0099r\u008f9Â¾\u0005k\u0012Â©Â Â¦\u00f6!\u00d1\u000b\u0087\t\u00ad\u0098\u00d4\u008d\u00c1\u001e<\u000e'\u0097\u00d3M\u0082Â¦\u00fcv\u0001n\u0091\u00d7\u0015_\u009e\u0004'o;\u00ceZÂ°\u000e\u008dprÂ·|z+\u00fb\u00fe0\u009eÂ°\u00d7\u001fHÂ¿D\u0082\u0003(<Â¬Âº/\u00f0~~Â¼D4\u000f0\u0083[\u00c2\u0012Â¢Â \u00f6\u008ag\u00d7@BÂ¢\u00fe1Â¢\u00c1\u00e6\u0094\u00ad\u00e5vÂµIN\u00c9\u0091XÂ½\u00ec\u00ad*7\u00d5\u001d(\u00c57\u00f4fG\u00f1}Â¦\u009e|\\\u0099\u00d5\u00edÂ¯\u009dE\u00e1\u00d4yÂ´Ak\u00cf\u00e1E\u00d4\u0091\u00d3\u0096Â¥\u00fa\u009f\u00c4Â°\u00d8\u009e\u00c6Âª\u0098\u0004}\u00de!").length();
            substringLength = 103;
            currentIndex = -1;
            break;
          }
          case 0: {
            decryptedStrings[index++] = decryptedString;
            if ((currentIndex += substringLength) < obfuscatedStringLength) {
              substringLength = obfuscatedString.charAt(currentIndex);
              break;
            }
            break Label_0023;
          }
        }
        ++currentIndex;
        final String tempString2 = obfuscatedString;
        final int beginIndex2 = currentIndex;
        substring = tempString2.substring(beginIndex2, beginIndex2 + substringLength);
        innerLoopIndex = 0;
      }
    }
    a = decryptedStrings;
    b = new String[85];
    System.out.println(a(16530, 18598));
  }

  private static String a(final int n, final int n2) {
    final int n3 = (n ^ 0x4094) & 0xFFFF;
    if (b[n3] == null) {
      final char[] charArray = a[n3].toCharArray();
      final int n5 = switch (charArray[0] & '\u00ff') {
        case 0 -> 227;
        case 1 -> 224;
        case 2 -> 211;
        case 3 -> 23;
        case 4 -> 237;
        case 5 -> 168;
        case 6 -> 119;
        case 7 -> 34;
        case 8 -> 98;
        case 9 -> 33;
        case 10 -> 132;
        case 11 -> 0;
        case 12 -> 135;
        case 13 -> 223;
        case 14 -> 175;
        case 15 -> 147;
        case 16 -> 37;
        case 17 -> 235;
        case 18 -> 35;
        case 19 -> 183;
        case 20 -> 127;
        case 21 -> 167;
        case 22 -> 232;
        case 23 -> 4;
        case 24 -> 75;
        case 25 -> 173;
        case 26 -> 134;
        case 27 -> 69;
        case 28 -> 158;
        case 29 -> 25;
        case 30 -> 30;
        case 31 -> 106;
        case 32 -> 188;
        case 33 -> 203;
        case 34 -> 59;
        case 35 -> 117;
        case 36 -> 105;
        case 37 -> 250;
        case 38 -> 121;
        case 39 -> 17;
        case 40 -> 169;
        case 41 -> 70;
        case 42 -> 207;
        case 43 -> 84;
        case 44 -> 81;
        case 45 -> 182;
        case 46 -> 231;
        case 47 -> 123;
        case 48 -> 142;
        case 49 -> 191;
        case 50 -> 96;
        case 51 -> 28;
        case 52 -> 149;
        case 53 -> 7;
        case 54 -> 13;
        case 55 -> 243;
        case 56 -> 196;
        case 57 -> 72;
        case 58 -> 165;
        case 59 -> 46;
        case 60 -> 63;
        case 61 -> 86;
        case 62 -> 215;
        case 63 -> 1;
        case 64 -> 93;
        case 65 -> 31;
        case 66 -> 16;
        case 67 -> 6;
        case 68 -> 5;
        case 69 -> 36;
        case 70 -> 50;
        case 71 -> 176;
        case 72 -> 107;
        case 73 -> 71;
        case 74 -> 78;
        case 75 -> 24;
        case 76 -> 111;
        case 77 -> 32;
        case 78 -> 229;
        case 79 -> 58;
        case 80 -> 65;
        case 81 -> 210;
        case 82 -> 61;
        case 83 -> 8;
        case 84 -> 190;
        case 85 -> 140;
        case 86 -> 15;
        case 87 -> 151;
        case 88 -> 153;
        case 89 -> 213;
        case 90 -> 76;
        case 91 -> 95;
        case 92 -> 234;
        case 93 -> 97;
        case 94 -> 236;
        case 95 -> 2;
        case 96 -> 226;
        case 97 -> 29;
        case 98 -> 125;
        case 99 -> 185;
        case 100 -> 247;
        case 101 -> 143;
        case 102 -> 186;
        case 103 -> 21;
        case 104 -> 56;
        case 105 -> 244;
        case 106 -> 57;
        case 107 -> 137;
        case 108 -> 27;
        case 109 -> 103;
        case 110 -> 18;
        case 111 -> 136;
        case 112 -> 133;
        case 113 -> 251;
        case 114 -> 184;
        case 115 -> 248;
        case 116 -> 225;
        case 117 -> 180;
        case 118 -> 44;
        case 119 -> 219;
        case 120 -> 19;
        case 121 -> 88;
        case 122 -> 53;
        case 123 -> 195;
        case 124 -> 115;
        case 125 -> 130;
        case 126 -> 200;
        case 127 -> 254;
        case 128 -> 194;
        case 129 -> 90;
        case 130 -> 114;
        case 131 -> 160;
        case 132 -> 166;
        case 133 -> 202;
        case 134 -> 12;
        case 135 -> 92;
        case 136 -> 209;
        case 137 -> 41;
        case 138 -> 189;
        case 139 -> 146;
        case 140 -> 9;
        case 141 -> 253;
        case 142 -> 221;
        case 143 -> 205;
        case 144 -> 113;
        case 145 -> 49;
        case 146 -> 187;
        case 147 -> 131;
        case 148 -> 22;
        case 149 -> 124;
        case 150 -> 239;
        case 151 -> 208;
        case 152 -> 157;
        case 153 -> 218;
        case 154 -> 91;
        case 155 -> 94;
        case 156 -> 148;
        case 157 -> 201;
        case 158 -> 67;
        case 159 -> 171;
        case 160 -> 170;
        case 161 -> 242;
        case 162 -> 154;
        case 163 -> 55;
        case 164 -> 99;
        case 165 -> 62;
        case 166 -> 40;
        case 167 -> 139;
        case 168 -> 174;
        case 169 -> 249;
        case 170 -> 11;
        case 171 -> 110;
        case 172 -> 43;
        case 173 -> 77;
        case 174 -> 38;
        case 175 -> 222;
        case 176 -> 42;
        case 177 -> 199;
        case 178 -> 141;
        case 179 -> 197;
        case 180 -> 155;
        case 181 -> 45;
        case 182 -> 83;
        case 183 -> 198;
        case 184 -> 193;
        case 185 -> 228;
        case 186 -> 10;
        case 187 -> 217;
        case 188 -> 60;
        case 189 -> 47;
        case 190 -> 162;
        case 191 -> 238;
        case 192 -> 3;
        case 193 -> 100;
        case 194 -> 245;
        case 195 -> 138;
        case 196 -> 102;
        case 197 -> 82;
        case 198 -> 85;
        case 199 -> 80;
        case 200 -> 246;
        case 201 -> 129;
        case 202 -> 241;
        case 203 -> 52;
        case 204 -> 68;
        case 205 -> 233;
        case 206 -> 204;
        case 207 -> 14;
        case 208 -> 164;
        case 209 -> 144;
        case 210 -> 89;
        case 211 -> 112;
        case 212 -> 108;
        case 213 -> 212;
        case 214 -> 172;
        case 215 -> 150;
        case 216 -> 230;
        case 217 -> 192;
        case 218 -> 74;
        case 219 -> 128;
        case 220 -> 145;
        case 221 -> 39;
        case 222 -> 104;
        case 223 -> 161;
        case 224 -> 79;
        case 225 -> 177;
        case 226 -> 216;
        case 227 -> 118;
        case 228 -> 255;
        case 229 -> 152;
        case 230 -> 126;
        case 231 -> 26;
        case 232 -> 156;
        case 233 -> 120;
        case 234 -> 64;
        case 235 -> 109;
        case 236 -> 163;
        case 237 -> 87;
        case 238 -> 179;
        case 239 -> 181;
        case 240 -> 54;
        case 241 -> 206;
        case 242 -> 51;
        case 243 -> 66;
        case 244 -> 252;
        case 245 -> 178;
        case 246 -> 73;
        case 247 -> 122;
        case 248 -> 159;
        case 249 -> 48;
        case 250 -> 20;
        case 251 -> 214;
        case 252 -> 220;
        case 253 -> 101;
        case 254 -> 240;
        default -> 116;
      };
      int n6 = (n2 & 0xFF) - n5;
      if (n6 < '\0') {
        n6 += '\u0100';
      }
      int n7 = ((n2 & 0xFFFF) >>> 8) - n5;
      if (n7 < '\0') {
        n7 += '\u0100';
      }
      for (int i = 0; i < charArray.length; ++i) {
        final int n8 = i % 2;
        final char[] array = charArray;
        final int n9 = i;
        final char c = array[n9];
        if (n8 == 0) {
          array[n9] = (char) (c ^ n6);
          n6 = (((n6 >>> 3 | n6 << 5) ^ charArray[i]) & 0xFF);
        } else {
          array[n9] = (char) (c ^ n7);
          n7 = (((n7 >>> 3 | n7 << 5) ^ charArray[i]) & 0xFF);
        }
      }
      b[n3] = new String(charArray).intern();
    }
    return b[n3];
  }
}

```

`reverse-engineering/src/main/java/zelix/enhancedstringenc/ManyStringsOriginal.java`:

```java
package zelix.enhancedstringenc;

public class ManyStringsOriginal {
  private static final String[] a;
  private static final String[] b;

  public static void main(final String[] array) {
    a(a(16601, -26271));
    System.out.println(a(16547, 28980));
    System.out.println(a(16573, -6570));
    System.out.println(a(16549, 15866));
    System.out.println(a(16569, 30320));
    System.out.println(a(16513, 5692));
    System.out.println(a(16592, -18585));
    System.out.println(a(16518, -12275));
    System.out.println(a(16558, -5500));
    System.out.println(a(16533, 28407));
    System.out.println(a(16554, -31785));
    System.out.println(a(16598, 14166));
    System.out.println(a(16519, 21847));
    System.out.println(a(16597, 6470));
    System.out.println(a(16570, -27431));
    System.out.println(a(16567, -23765));
    System.out.println(a(16514, 26042));
    System.out.println(a(16544, -32719));
    System.out.println(a(16531, 13283));
    System.out.println(a(16556, 14179));
    System.out.println(a(16524, -10611));
    System.out.println(a(16602, 11272));
    System.out.println(a(16545, -397));
    System.out.println(a(16563, 19319));
    System.out.println(a(16559, 10170));
    System.out.println(a(16552, -16576));
    System.out.println(a(16546, 17855));
    System.out.println(a(16528, 428));
    System.out.println(a(16574, 23266));
    System.out.println(a(16600, -26763));
    System.out.println(a(16550, -19257));
    System.out.println(a(16583, 19975));
    System.out.println(a(16568, -28711));
    System.out.println(a(16593, 8545));
    System.out.println(a(16571, 16428));
    System.out.println(a(16604, 8759));
    System.out.println(a(16543, -31121));
    System.out.println(a(16565, 26258));
    System.out.println(a(16576, 18214));
    System.out.println(a(16542, 5982));
    System.out.println(a(16582, -20163));
    System.out.println(a(16595, 14588));
    System.out.println(a(16605, -26780));
    System.out.println(a(16572, -3689));
    System.out.println(a(16534, -4917));
    System.out.println(a(16553, -25655));
    System.out.println(a(16599, -6645));
    System.out.println(a(16575, 9955));
    System.out.println(a(16555, -5264));
    System.out.println(a(16536, 23938));
    System.out.println(a(16541, 14767));
    System.out.println(a(16523, 26124));
    System.out.println(a(16594, 10432));
    System.out.println(a(16606, 23179));
    System.out.println(a(16512, 28813));
    System.out.println(a(16527, 17243));
    System.out.println(a(16537, -17368));
    System.out.println(a(16521, 6489));
    System.out.println(a(16538, 32319));
    System.out.println(a(16557, -8581));
    System.out.println(a(16520, -15798));
    System.out.println(a(16516, -21175));
    System.out.println(a(16607, 10624));
    System.out.println(a(16561, 13569));
    System.out.println(a(16562, 31959));
    System.out.println(a(16539, 4326));
    System.out.println(a(16529, -27529));
    System.out.println(a(16580, 16893));
    System.out.println(a(16581, 13937));
    System.out.println(a(16603, 20273));
    System.out.println(a(16522, -27961));
    System.out.println(a(16548, 5675));
    System.out.println(a(16564, -31220));
    System.out.println(a(16525, -11503));
    System.out.println(a(16560, -15803));
    System.out.println(a(16596, -30597));
    System.out.println(a(16526, -10863));
    System.out.println(a(16540, 20769));
    System.out.println(a(16532, 27173));
    System.out.println(a(16515, 28785));
    System.out.println(a(16551, 26445));
  }

  private static void a(final String s) {
    if (s.equals(a(16535, -2944))) {
      System.out.println(a(16517, 22762));
    }
    else {
      System.out.println(a(16566, 20267));
    }
  }

  static {
    final String[] a2 = new String[85];
    int n = 0;
    String s;
    int n2 = (s = "-\u0092\u00d9+\u000f\u0000\u00e1L\u00dd \u0019n\u00c8Y\\g@\u0095!\u00189\u001fO\u00fc-\u0097\u009de\u0086\u00c8P4\u0013\u00f6\b\u00efjw\u0099\u000b\u00be\u008e\u00d5\\9D\u00ael\u00b3'\u00d5\u008cW\u0015pD\u00ef\u00b7\u0016\u009c\u00e3\u00c4c\u0096\u00d6\u0012\u00da\u00cbF\u00d1\u00f7\u00bb]\u0091\u00c3\u00a5\u00b5\u00ea\u009a\u0088\u00f4\u0081\u00c9\u00ce.\u0090ze\u0013\u00f8\\\u0007\u000e-k\u007f\u00c3\u0099\u00af\u008b\u00a6zM\u00fd\u00ae\u00fe\u00cb\u00c7\"\u00c8\u00a5\u00b6\u0011\u00e0\u00063\u00fbx+\u00a6\u0097\u00d77\u00ad*\u00e9o:I\u00ba\u00ac\u00a8\u00ec\u0017\u00e4\u00ed\u00aav6\u008bO\u009f6\u00e3+\u00d1\u008c\u00e3dp\u00e5nc\u001d\u00c4Q\u00d5\u00f0\u00f2\u0080\u009f\u00e5\u00be\u0098\u0087\u00fe\u0095\u0082\u00fbO\u00aa\u00bcS\u007fLU\u00e6\u00c5~V\u008e\u00e3\u00e3~|\u00b2d\u0004U\u00fc\u00aa5\u00b5\u00a7hrk6\u0099\u00bc\u00e5\u00ef\b\u00fc\u00af\u0013-\u001c\u00eb3\u00d7`\u0019\u0005\u00e6\u00e8\u0081Q5\u0093\u0014D\u00e1\u00dd\u0088\u00fc\u0007.6\u00ccW%(\u009c^\tS\t\u007f\u0013\u008c\u00af\u00e2Hz\u0092\u00b4\u0000\u00d4\u00bb\u00d7\u00f1\u00a1\u00ca\u0007\u0083\u008c\u00fbn9:\u0091\t\u00b0>\u00b7UXU\u0095;\"3\u009cM\u00ea\u0080\u0092dy\u00c6\u0010\u000eKa\u00deC\u00ee>\u00fa\u00a4\u001aW3\u00f7>\u0082\u001f\"\u00e9\u00e1\u00cfF\u00ee>G/\u00fa\u00d0n,\u009a\"U\u00ee3\u0097\t\u000fX{\u00b9\u00a5C\u009d\u00b7\n\u001c4\u0095\u0002\u0001\u00ce\u00cf\u00f0p\u00c6f-uE'\u0001\u00e1\u00fb\u00ee \u00e1Tk\u00a8\u00cb9\u000bvkd9\u00f3\u00d3K\u00e9o\u00bd\u00e9\u00b5\u00034\u00addi<q\u00efN\u0000\u008c\u00ed\u00e0\u00f2\u00e1\u00a7\u0081CH\u009348=\u00b2\u00bd\u00ac\u00c14\u0010\u0094\u00cb\u00d4\u008e\u0005\u00ec\u00f8\u00a3\u0000\u00f0P\u00e04-\u00de\u00d0x\u00efk1\u00dd\u00bd\\L\u00c2/\u00ba\u0091\u0017\u00a7H\u0086S\u00ccG\u00fe\u00ac\u00c6a_M\t\u0005\u00b2\r\n\u0006\u0085\u000f\fv^\u00f6M\u00c54n\u00e3\u001c\u0007\u00a4(\u0001\u00bc\u000ep\u0082\u008e@my,\u00d0d\u000fv\u00ee\u00fb\u0092R\u0095\u0086\u00b5\u00fd\u00bd\u0019Q35lK\u00ecW~a~_\u00d9\u00e8\u0092\u008b.h\u0081\u00dd\u0088\u00cb\u00dd<Z\u00d0\u00e7\u00a6\u00a2Zg\u00980\u008a\u00e8\u00c9\u00feM3\u00da\u008c\u009d>:}\u008a\u00c1\u00cf\u00ba\"\u0089\u00b6\u00b2\u0018\u0091\u00da\u0095kp\u00f5\u0002\u00f8El\u00fch\u00a9\u00ec\n\u008a\u0019\u0090\u00f8K/w\u00d4\u0091k\u001e W\u00cd7\u0081\u00acH7\u00c2\u008c\u0004\u0013\u001aQ\u00b8{\u00b1\u00e4\u000f\u008a\u00c30\t>\u00b0\u0015\u000fd\u00ac\\\u001eI\u0083a\u008c\u0006n\u00a7\u00f3\\`\u00e7z\u00b7\u0096\u0000\u00b0\u00c2\u00ffCp\u000b\u00a3\u0010\u000e\u00ab4kR\u0014\u0005\u001f\u00f4\u008f\u00f3$e:m4\u0001\u00c6,-\u009e\u0085,\u00ad\u00ea\u00a7K.\u00fa\u00b6\u001e],gQ0\u008f\u00b9\u001c\u00cap\u00cf``\u00bex7s\u008fj:T\u00ab\b\u00c9\u0091\u00bd$=F3\u0093ye\u000b\u00c2\u00c5\u0095\u001br\u00e92O\u0014\u0003\u00fa\u001bJ\u0090\u0000\u001c_\u00cf\\+\u00f1\u00d8\u00b7\u00b9\u0096\u0015\u00db\u0015\u00e1)\u00e7u\u00aa\u0015\u00a5n\u0095\u0016m\u00feRx\u00f5\u00f4\u00c8\u00fd\u00d3\u00a4-\u008d8\u0080L\u00a9\u0015\u00d5\u0016\u00fe\u00c0\u0080\u00c5B$n\u00e4-\u0003\u00dc\u00c4\".\u00cbg\u001d\u001dT\u0099\u0007\u0013~\u0012\u00ceh\u00e1\u00f3\u00a6 @i\u00e5\u0010\u00f0\u008b\u00f5\u0085$\u00f2,Yw\u00f3\u00d1<VP\u00ec\u00b5=\u0015\u00f4\u00b0\u001e/\u00c1\u0011\u00fb\u0089\u00f1\u000f\u00d0g\u0096\u00f1\u00ce\u00f8y9\u00ad\u0003\u00b7\u00df2Q\u00f5~\u0096c\u00d8\u00b6\u008c\u00e4\u00ac\u0082\u007f\u000f'\\\u009f\u00b3\u00e8\u00bb\f\u00a5\u00e6\u00a9\u0001\u00fc\u00bc\u00d48\u00e6\u00cefw\\1\u00bc\u001b\u0099\\[\u0003+\u0003\u0010E\u001b\u00ea\u0082b\u00bbG\u00c2\u00af\u00b1\u00b3F\u00ce\u00ba)\u00da\\\u008c\u00bd\u0093\u00bd\u001a[57\u00d8\"\u001f\u00a0\u00a6\u00ffs\u00df\u00e6\u00ec\u00e7\u00e2\u0082-\u00d5\u0012\u00a7~\u00a1\u00c2\u00d9$\u00bb\u0085zH\u00db\u0092J\u00ec\nQ\u00c7\u00c9\u00eb)GJ\u00e7\u0002,\u00b3^&\u009fG\u008d\u0019\u0080t\u0018|\u0085\u00bdN\u00e2#Mhbd\u00bb\u00f3\u0084y\u00c7\u00f3*\u00c76\u00af\u009d\u00e2\u00df\u00d0\u00b09KQ\fX\u0096\u0013<\u00cc'{\u00f4\u00ef\u00bc\u0006\u00e7\u00aez\u0017_\u00d9\u00cc\u00d6_\"\u0087\u00df\u00ce\u009e\u00cb\u00da!\u00da\u000f\u00fb\u00e7\u00a6\u00a3\u009e\u00f3\u00a9~\u0093\u00be\u0080\u0007\u0002\u00b3h\u00b3\u00ff\u00f5C*~\u00e9\u0004\u00ee\u00bfA\rg\u00a8\u00e3\u0095\u00aa\u008d\u00170ww#\u00dc\u0082\u0090\u0002\u00a9w+\u00a0\u0011\u0005[\u000f\u0098\u00b5\u00ee\u0080\u0018\u00c7\u0087S\u0004H\u0094\u00d5\u00c4l5\u00b1~.\u00c1-^R(\u0082\u00c8\u00fd\u00ff\u00c5'\u0091\u00cd\u00ce\u0016\u0084\u001b\u00f8\u00ae\u0081pa\u0093\u00d9f2!Vj\u00aeY\u00ef\u00ccX\u00ad\u00e3\u00aa/\u0005\u000b7\u0014#\u00f7\u00bf\u00f9\u00e4\"S\u00e85\u00ef\u009b\u00d4\u0001HY1\u008c\u00ac\u00f2\u00b084\u0004!S\u0011\u0014V\u00aaE\u00f3T\u0001\u001e}\u0005V^\u00a3#3\u00ba\u0018\u001e\u000eR\u00e7\u0089\u0018\ni\u00b9\u00f5&|o\u00f8\u009f\u00ebR\u00eet@\u0089x\u0080\u00e1\u0095\u00cb{\u008f\u00a5\u00efUY\u0083\u00d1\u00b0\u0018\u00fd\u00e4\u00a9\u00c9$\u008c\u0001\u000f\u00c2aX\u00ac\u00f5\u008f\u0082\u00c0]\u008e\u00e8\u00ff\b\u00bcj37?\u0000\u00df\u0093\u008c\u009e\u00af\u00ff\u00b5\u0088\u00a1\u0088\u00a4\u00fe\u00ed\u0007\u008b\u008f\u00e4\u00ea\u00ac\u00aa\u008f\u00bc>\u0089\u00ed\u001e\u00ca\u00f3\u00d6\u00bb\u00a2\u0007\u008a`dH\u00bd\u00c86\u00f3\u00a8\u0088\u008a,\u00b3FR\u00b59\u00c1Z\u00eb\u001bD\u00ad\u0093\u0007\u00f9'\u00cdo\u00c2\u000e\u001c\u0081\u00b0/\u00af4\u0088\u00f3\u0007\u0007\u00f7\u00bd\u009c\u008b\u0083M\u0094#\u001e\u00a33\u0092)\u00fc\u0007\u0013\u00d7\u0006\u00ec\u0001\u00d9\u00ea~O\u008dN\u00ecU\u00ce\u008bM?]\u00cd\u00f5\u000b\u008eh\u008d\u0094o\u008e\u00b2aNI\u00fdQ\u00ed\u00caG\u00d1\u00e7&\f\u00a2&\u00d2}T^\u00ffy\u00c2\u00c4&\u00a3E\u00bcp\u00c5E\u00c5\u008f\u00fc\u00ad\u001f\u00ee\u00f3\"\u00e4\u00d3\u00f8\u00f3Q,\u00e8i\u000f\u001dg\r\u00a7}\u008dC\u00e0E\u00e12l<\u0097\t\u0018NV\u008d\u0099\u00e6\u009b\r\u00f0]w\u00f2\u00ed\u0014`\u009b~\u008a[l<\u00e4\u00ee\u0096\u00faeG\u0000\"\u009f4\u00f2\u0018\u00d5)\u00f3\u00bc2#\u00ee\u0016\u00e5\\\u00e0T(N0N\b\u0005\u0083\u0007\u00f9\u00d0\u001e\u00972T\u0084\u00f9\u009d\u00c6\u00afH{B\"\u00a7-\u001c\u0013\u00de\u00ccp(r?h \u00c2\u0002\u0099o8\u00a0\n$\u00ed\u00b1:R{\u0012\u0005i\u00bfG\u00db\u00ae\u00a9\u00ef\u0099\u00e1h\u00ed,\u0093\u00ab\u00b1\u00cb\u00ceG\u0081\u00b4B\u00cd_\u00ffC\u008bw\u008c\u00fe\u00f2K2\u00c8`Fc8mP}\u00a9\u00e2\u00cf(\u00d8\u00c3\u00fc$\u008cH4\u00eeo\u00dcN\u007fk\u009c6ZfB\u00e9\u00d2\u00022Z\u00b0&R\u0088\u00ec\u00fb\n\u00a1\u00f6\u00b6I\u001cx\u008f\u00ad\u0097\u00eb\u008fx\u00b0\u0097~\u0006{\u00ed\u00ab\u0088Tk\u00ac{\u00f3+I7Y?A\u00d2\u00a2v0\u00af\u009e\u00a0\u00fcv\u00af\u00e3\u00ee~8\u00a47n_om0\u0091h>)\u00c2\u00adeM\u0093\u00ba\u009f\u009c\u0015N}\u00e5q\u00d96~j\u00f3\u001b\u008d\u00db`\u00e0\u00d5X\u00e9Z\u00d6\u00d2\u001b\u00f1,&\u001b\u00aa\u00d5X^\u0090#\u00f4\u00ff\u0001o|\u00b3\u00f3\u00eb,\u00f0Hg\u00e1I\u0017|x\u00a0\u00ff\u00e2\u00f1\u00ad\u000b\u00acNS\u008e|B\u0000~\u009e\u00cd\f\u001eCFTaW\n\u0004\u00a7\u0016\u00cc\u0086\u00aa\u00e4\u00f9\u00d0[2hPx/@\u00db\u00db@\u00e2fD\u00f1\u00f1)\u00ac\u00fbca\u00f4\u001b\u00ca\u0083\u00a7\u00ba\u00bb\u00ab\u0018\u00ed@\u0093\u00a1m\u0000N-I\b\u0083\u0090Q\u00e6\u009dF\u00b9\u00cb\u0006\u00a8\u00b6\u007f\u00feu\u000f\u00b2\u00abz\u0083~\u00c6D\u008c\u0096\u00b1\u0001\u00b1:\u00e0\u0000/l\u0082\u00dfj\u00ea\u00d0\u00d7`\u00fe'\u00a3\u00bdQWq\u00aa*\u0000\u00d5d\u0083\u00aab\u00ab\u000ef\u00ce=\u0082\u00e0\u00c24\u00b2rU\u00e0\u00b7\u00ce\u00e2\u0099Rj\u00bc\u00c14i\u00c0Y\u00a4!L$\u00f0\">\u00996\u0082\u0096\u0018v\u00f1\u00f6(\u00d7\r\u00b1\u001da2\u00f6-\u0083\u00a5\u00c2\u0088b\u0000D\u00f0\u000e\u009506\u00f7\u0091mGy4GWC\u00d2\u00b1[\u00be['~r\u00c2\u00a3\u00e4\u0094b}\u00dfc\u00e4)C(\u00d7KD\u0082\u00fau_\u0086\u00fb\u00b7+\u00dc\u0095\u0002p\u00a7\u009e\u00c8\u00be\u0081X\u00a9\u000b\u0014\f\t\u00c0e&\u0099\u00e2\u00cb'q\u00df\u000eL\u00b1\u00e2h\u00f6\u00bc\u00ae\u00ef\f3\u00d1K\u00ed\u00cfe\u001f\u00ac\u00e2\u00f9\u00fc\u00de\u00c8\u00024$j4\u00ec\u00d6$\u0010\u00e6D\u00f6t\u00fc\u000e\u0003\u00dcN\u00ad\u00c8\u00f0\u00acML\u00ebu\u00deb-\u00bckQ\u00be-y\u00b22\u0093&)\u008d\u001cW\u0094\u0093^\\\u0092\u0013T\u000e\u00e5\u00db\u00a8\u0093\u00c4\u008f\u00c6>j\u00b7\u00ad5\u00f1\u00f1n\f\u000e\u0005\u00e7\u00f5\u00bf\u00be\u008fVp5-\u0090=>\u00fda\u0084\u00cfp\u00be#\u00e1o\u00db\u00c38\u00c8\u00dc\u00e8\u00d8\u00bd\u008c\u0095\b\t\u0087!\u00a5\u00bc\u00c6\u00ab\u00f7\u00bd\u008am\u00f7\u00bb\u00a6\u00c1.\u00fd\u00db\u00ad\u00f3\u0003\u00d5\u00f8\u00eb<\u0086 woU~\u00a5\u009a\u00fb1\"\u001c,\u00f5\u00bc\u00a6MxnW\u00cf}\u00bbze\u0080\u00b02\u00940\u00f1\u00a8\u00edT(\u00ce\u00c1n\u0091\u00030\u00c7\u00f8#\u00c9\u00cc\u0090\u00b4\u0091\u0002\u00c2\u008e\u00b3R\u00df.@\u0084\u0092\u00c0pF\u00c2W\u0005\u00a5\u00de\u00ad\u000fT\u008d\u00d6\u0082\u00b0\u00fb\u0096E\u000f\u00b9\u009b>\u00f0IL@\u00d1#Z1\u0018\u0006\u00a0r\u0006Xs\u00dd\u0001'\u00b4\u009b\u00bb%\u00d5T_\u009aP\u0007u*\u0093\u00ff4\u00d2.\u0006\u00ed!\u00c0>4\u0083\u00ab\u00cb\u00f2\u0018\u00e49\u0098\u00fd\u00e0\u0002\u0016\u00e7\"%w\u0083\u00dd\u00bf\u008e&\u00f8\u00f5'+\u00b2\u00df}d:\u00b9\u000e\u000eT5@\u0005\u00a6\u00c8\u00f1ta\u00d2\u0097\u008a\n87\u00a1\u0087\u008c\u0096\u00e6R\u00d9\u00ba\u0002g\u0017Zx\u00a1U\u00e0\u00fd>R&\u00d3.\u008c\u0084.F\u00ef\u00e4\u0095B/5F\u009ei\u00e2j\u00f2!\u0003\u00e0]M3z\u001a\u0012\u00fa,q\u0084j\u0088\u00c0J\u0081u\u00bfo\u00ef\u00f3j\u001bR~\u00c8\u00e5\u0006\u007f\u00bfZ\u000b\u00d8'\u0090at\u0080\u00cemD\u00f3\u0007\u00f6\u00cc#\u0000/gm\u00a6\u0096\u00b3o6\u0089\u00bc\u00f44\u0001\u0085s`\u0086\u0099C\u00ce\n\u0010\u009c\u0018\u00a5\u00b8\u00a5\u0080pT\u0016\u00e7\u00b7\u0011\f\u0090\u0005W \u00e2\u00af1\u009ca}\u00b4\u00b6+\u00e0\u00a9J\u00d1\"\u0016\u00832\u00ed\b\u00e3_\u00ad\u00e6\u00a8`\u00b4\u00d0\u009b\u00d7\u00af\u00fa;\u00aa\u00caWc\u001b>7B\u00da\u0001mf\u00fd\u0006\u0090}\u00c8\u00aaK0.\u00ecBIf\u008a\u0090(F\u00cd\u00c5\u00b6\u00c9\u00e4bYm\u0004\u00ed\u00c6\u009e\u008e\u00a8H\u00ff`IZ\u00b1\u0082\u00f9\u008d\u00f6\u008e\u0015\u00dbv\u00e9K\u0005\u00b4\u00d6\u00cb\u009f4\u00fd\u0015\u00b74:\t\u0092i\u00e9\u0099\u0018{\u00ec@\u00baKM\u00faQ\u00e6\u00e4\u00d4\u00e4\u00bc@\u00c7}\u00e8n\u0016O\u0017cA\u0083\u000f\u00f0\u00f2\u001b8\u00b6\u00eb<\u00de\u00dd0\u0007N\u00e8-]\b>5t\u00e7\u00ce\u00a0[\u001aD\u00f2\u0084\u00fc\u008b\u0092\u0082\u0082\u00f9\u00f0\u009c|\u00bdr\u00d1\u00ec\u00bb\u00fd7\u0012\u0000\u00c3\u00e7\u00abD\u00c1\f\u0091u\u00e1q7\u00e6MzRU]\u009b\u00af\u00c4\u009e+\u001e\u00ae\u0015\u00ca_\u00c0\u00d7X\u0005\u00bd\u0083\u0010\u00b5\ry5\u0005\b6\u0080\u0018'\u0092J\u00ed\u001a\u00192\u00b9\u008et\u00a7\u0080\u00a8\u00ab.H\u009d\u00c5\u00bc\u00195=\u00c3E6e\u008aF4e\u00efT\u00b5\u00c8\u00d3\u001aB\u00e7i\u00eb\u0092\u00e7\u008f\u0016\u0099\u00f2\u00f3\u0013\u00b6\r\u00ca\u00e6\u0082\u00b9*\u00cc\u00a5\u00ba\u00b9\u0001+o\u0095 \u00e1\u00a4z\u00ed\u00d50\u00feP5\u0005\u00b5r\u0096D]\u00f9;\u00d4_\u00a6_\u00c6\u00c4\u00ba\u00fa\u00fej\u008b\u0096|\n\u0080j\u0005~s\u00a6\u0081\u00a1\\\u00e6\u00edz3\u009a\u0094\u00ed\u00f2\u00b4>^'\u00a0\u001c2\u00c7\u007fX\u00c6\u0097\u00e8\u00c0{mt\u00ae_\u00a89\\\u00d7\u00e2\u00e8\u00a5\u0089\u00eenP\u00a4\u0086\u00ba6\u0098p\u00c8]\n\u00ec\u00f2o\u00aeL\u00ae\u0088.\u00a34\u0087\u008c\u00d2!0\u00f7\u0095\u00e0\u00df\u00d1\u0097\u0083\u00f9\u00e7\u00ff\u0084\u009e\u00c9\u00cd\u00a5\u00c0\u00cc\u00e8@C|\u00c1\u0004\u00ef\u000fo\u008c\u00f5c|\u00cfY\u00e6L\u0085m?Y\u00afsnas\u0095\u009e\u0081\u007fQ\u0080\u00b9F#\u00af\u008a\u0096\u00cc\u00b0_M\u0082\u009e\u009eIp\u00a1*i\u0095C\u00ea-\u00ca\u0000\u00c3\u009c\u00f2\u00d1\u00d0\u0015}\u00ce\u0010\u0095\u0006`nJ\u0011\"\u00be\u0003\u00a3[\u00cb\u00a6J!\u000b|\u00b4I\u00c5tV\u00d2\u008f\u0016\u0014/\u0084\u00d61w\u00c0\u00f2!\u009c\u0016\u00a8\u009e`\u00a8\u00ee#\u009eu\"8\u00e9\u000e\u0084\u0089\u00fe\u00a1A\u00f1\u008d\u00dd\t|\u00cb> \u00ff\u00c0\u00cf&\u0018\u00fbN\u00f4\u0081P\u00de\u00acUm\u001a\u00ed\u00bbO\u00f7\u0014\u00a1\u0001\u00baB\u00e4\u00af\u00f2\u00f7\u009f\n\u0085\u00e5\u00b0y\b\u00c8\u00aa\u0097\u00d4d\u00a3uE\u00ef\u008f\r\u00e0G\u00c8\u00d1\u00d1\u00cb\u00c2x4{1\u008a\u001e6W\u00d8Ox\u00ba\u00d7s\u009d\u00db7\u0010xo\u008e\u0092\b\u00cf}\u00ea\u0093\u0010be\u00b7PpG\u00c5\u00c7\u00f9\u0000\u00a71.\u00c7\u00f3\u0087\u00adu\u0087\u00d3\u0006c\u00f1\u00b1\u0013F#8I\u00fb\"/\u008a[\u00da+4\u0087\u00bfx\u0099Z\u0082\u00a6\u00b9\u00b6\u00c8\u00b3\u00a8\u0000y\u0081E\u00b5\u00e3\u00f1\u0098\bY\u0002\u00f2\u00a7g\u00f2L\u00de\r\u00d7\u00dal\u00b5M\u00e2J\u001d\u0090G\u007f\u009e\u00a4\u00ce\u00e1J\u000b\u00db3T(C\u00ff\u00fe\u00d4\u00a1\u0094\u008ci\u00b9\u00da=\u0016\u00d1ZD\u00db8\u000e\u00b4\u008d\u00cc\u00d6\u00f7\u000b\u0089\u00f4\n9\u00ea@$\u00cd ~}@Z\u00c7q\"CK\u0010\u008cT\u00c2fH\u00d8.0\u00c2\u00bb\u0098\u00dc\u00d3\u00ce\u0090\u00a4k|3\u00f1F{\u00b0\u00c9K@?[yp\u000e\u00d3z4g\u00f88=\u0003I^\u00136\u00b9\u00c0\u008d\\\u00eb\u0094p\u00c5gj\u00dfD5\f\u00c2a\u00bdV\u0089D\u00e9\u008a \u0095\u000e\u0090-_AK\u00a3\u00fam\u0086\u001a*\u00ec+Em|,\u008f\u00eb\u0096\u001f\u00d1\u00fc\u00177\u001agb\u00e0\u009d%>P\u0098l\u00d0\u0012\u00b2\u00a1]}\\\u00d1hR\u00bah\u000b\u000fi\u0002\u0003K\u00f1\u0011\u00c5\u009e\u009a\u00a39P\"\u00a3\u009e\u007f\u00fa\u00d1u\fP\u0004\u0086\u00c5$\u008dI\u00ec\u00d6\u00e0\u00e1\u00de\u00ef\"\u0093\u00c0\u0083\u00805\u0094\u0092\u00df\u00c1#\u00ee\u00cf\u00dc\u0083\u00c7\u0085\u00d0t\u00bf\u00ee\u009e\u008dy\u00f3\u00b2\u008b\u00cc.\u000f\u0093\u00fc_\u0001\u00cf\u00d6\u0099\u000b\u00d56\u00a3\u00ac-\u001e^#$\u00b0\u001e;a9K\u00a3\u0096{\u0014\u00b7\u00f9\u0084/1\nv\u0004\u0084\u008a\u0007\u0018\u009c\u00bd\u00acs.&\u00fb\u00c9?M\u00b4\u00abM}R\u00f1\u00d5v\u00b6\u0002$\u0081q\u009b\u0017b\u009f\u0081\u00e7]\u00db\u00f2\u00fc\u00baD\u00aa\u00b6\u00f5\r\u0096\u00bc\u0093.n\u0012\u00ee\u00e3\u0084b\u0011a\u0091\u00bf\u0086\u0089\u00b3\u00f8\u00f1\u00e0\u0099\u00ad\f6\u00db\u00df&f\u0007q\u0095\u0092\u00f9\u00f9\u00f8=\u00f7\u00f6!2\u008fI\u00d3\u0092\u0095U!\u00b6\u0098\u00a7V\u008c*uE\u00b37\u00f1\u00aeke\u00a5\u00a1\u00a9\f\u00b3\u00b3z\u00b9\u00e0\u008f\u0006\u00fa4_)\u009ehb\u0019\u0011\u00baC\u00bc\u00a8\u00b0Y\u0006\u00d0\u00ec\u00ae\u0090\u00be\u00baA|\u00b4xuo\u009cS\u00c3\u00c1@PLQa\u001a7\u00a3\u00b5\u00bb\u00077\u008aNV\u00b3w\u00de(\u00bcRgP\u001d\u00db\u00ddX\u00faf\u00a6f\u008bB-\u00d2x\u00da\u00fdq}\u009b\u00c1\u001f\u00bc\u00f5L\u0018G\feK\u00c1\u00c7\u0000\u00d2%\u00c2\u00b2\u00bf\u00f7\u001aU\u009d`\u001aVT\u00a1,\u00ceRD\u0083\u0097/bTGH(7\u00d8A\u0017b\u0081*\u001d1n+\u00e4\u009f\u008b\u00e9\u0002\u0097\u00bdv\u00a6K\u00bb^\u00ffO\u00cd3\u00be\u000e\u0098\u00e3\u00b6\u00c2Y\u0085\u00cdY\u00bc\u0004\u00c6H\u0096H\u001e\u00ee>\u001f\u0013'\"\u0088\u008c/\u00b6\u00bf\\lG\u00c4j~\u008a\u0081\u00d1\u00fd\u0094^\u00da\u0086'\u00f3\u00ea\u0096\u00e2\u008a\u00a5\u00ab\u00c5\u00cfV\u00f3\u00cd\u009eT$\u0006'\u0002(\u0012A\u0004\u00a6\u0098\u00e4l\u00b9\u008aJ\u0016UY\u00c81}\u000f\u00c6\u0011\u000e\u0014}\u00c2m\u0014\u00be\u00d9\u0019o\u0081\u00b7\u00bc\u0084\u00f8Jm+\u00b5J\u00d3^\\\u00fd\u00dew\u000f\u00d6\u0014\u00ca\u0010\u00c1\u00c2\u00e0\u001bY\u00de\u00ca\u00a3\u00b6\u00be\u00dc\u00b8\u0005\u00b1\u00e5\u00f0\u00d4=\u00c2\u00cc\u00d9\u0091r\u00b9*\u009b\u0095\u00bd\u0000u\u00a6\u0001V\u0004\u00bc\u0002\u00d9\u001f\u0080\u00d9\u0088\u00d3\u00fd\u00b82\u0087\u00cb\u008f\u00eb(\u00e2\b\f\nN\u0013o\u00aa\u009a\u00b4}\u00e7\u00ff\u001a\u0011O\u00b4\u00ad\u00d7E\u0006L\u0092\u0089\u00be\u00a8lj\u00e2\u00dc\u0001\u00b7\u00db@\u001c2\u009b8\u000b\u0013\u008b\u00ab1\u009f\u009e\u0096\u00e4\u00c4\u00aa\u00cf\u00ab@k\u00bfgf\u00a6S\u00b9\u00b9\u00f2\u00f5\u00b5\u0090\u00b3\u00d0\u0000{:\u00e8\u008a\u00a1c0\u00b4g-w\u00dd\u0005\u0089\u00d8i\u00fe#\u00b1w\u00cd\u00cc\u00ed\u000fw\u001e\u00e5vBM|\u0011\u00cf\u00b1H4\u0014R\u009d\u00d8\u00ed\u00f8\u0013\u000e\u00c6$\u00fd\u0003\u00da\u00cb\u00b8G&\u0017B\u001ccW\u0015\u00d1@\u00e05 ;\u0018S\u00db\u00df\u0015\u0006:\u00a6(\u00d4L\u00ab*\u00b7L50^\u00bf\u009d\u00cd\u00bc\u00e4\u0000O0\tJ[\u00ef<#\u00b0\u00e4\u00e5\u00e1\u00f5B\b)\u00ba\u0015\u000b\u0095]\u00ccHQ\u008d\u00c4r\u00cd\u00eb\u00b2\u00be\u00ea\u00e8\u00e9\u001f&\u00a9R\u00e2Q\u00c7L1\u008a\u0094>\u009b\u00b4?\u00da\u00ce\u00dew\rG\u0080C\u00b2\u00ed\u00bd\u000f\u00c9#\u00dc\u00db\u00e2\u000e\u0089\u0098\u0090M\u008c\u00f5k\u00c9\u00e0tz\u0087{7u\u00fa^\u00c1\u0089P\u00b3\u0018\u00da\u00ae\u00dd\u008bE5\u0095\u00fa\u000e^\u00b4B\u00abs\u000e\u0010\u00a0\bm\u00ba\u00f2T\u00fc\u00bb\u00fe\u0085\"\u00b7\u00a3\u000e\u0011 \u00a8v.\u0006\u0018T\u00a6\u00c8\u00bd=nv\u001a\u00e7V\u008c\u00a0\u00c1\u00d4|\u00e3\u00db\f\u00fb\u0005\u00911\u00fdam\u00c4\u00ed]\u00aeuRX3\u00e4\u00e7\u0016\u00f9\u00f7V\u00e3.\u0091\u00f2\tH\u00a0\u0092\u001f\u00a9\u0098-*\u00cb\u00b4\u00bc8\u00d2\u001d1\u0005\u001ff\u0003m-\u00037\u00aa\u00bb:\u00b4\u0098\u00d6h\u00b2\\#\u00a7W_\u00ff\u00a3\r\u009c\u00ae\u00c5 \u00fb\u0001Q\u00ce\u00af\r\u00f9\f\u00db\u00ec\u00b1\u00f6\u0001U\\\u00d3_\u00bar\u00e98\b\u0099\u009e:,\u00b4Ukz\u0094\u0007\u00f9\u00e8\u00cc\u00e8\u000f\u00c5\u00981\u0086y\u00db\u0096\u00a5\u00d4\u0088d\u00da\u00c7\u00fc\u00e1Un\u009e\u0085\u00ab\u00ad$,\u00ecUAj&\u00b9Eb\u00da\u0080[\f\u0092i\u0019\u0017\u00d9?\u00beC\u00de\u0002C\u00aa\u00be\u0015\u00eb\u00e1U\u00a5\u00d8\u0096\u00f5(\u009dTq7%\u0082\u009fX\u00fe\u00f9Sr\u00c2\u0082V\u00ee\u00c3^>\u0099sB\u00db'\u00bf\u0097\u0006\u00f8\u009a\u00acp\u00f5\u00f1g\u00adl\u00ae\u0006E\u009c\u0092\nk\u00e7\u00e4\u00a0V\u0017\u00faW\u0018 \u0007\u00a0\u00f7\u00f47\u00f4\u00c9\u0017\u00ec\u00c4Y'\u00cf\u00b2\u001fq?\u00a7\r\u00ad\u001c}\u00f1\u00c7N\u00c0\u009e\u00f9\u00a8\u00c0\u00bc\u00c6\u00c8\u00e3 \u00a1\u00b5m\u00f5d2\u0010\u00cc\u0002T\u00e7}\u0005h\u00a4\u009b\u00cf{5\u00c4,/!\u0098\u00fb\u00b0\u00cc\u0000.xd\u0085\u008c \u00a6\u00e2\u009f\u00ee\u00ee\u00d01r\u0002\u00b6b\u00a4v\u00ea\u00efObKO#\u00ae#\u008f\u00ac\u00eab\u00f5~+\u00b2\u0099\u00e9\u00a6\u009d\u00d1\u00be<\u0012\u00bfC\u0017\u00a9\u009d&\r\u00a1\u0018\u0005\u00b2g\u00ff1\u008a\u0096\u001agm\u00c1`\u00ce\u0095\u009c\u00b5D&\b\u00b2a'U\u00ff\u00edT\u001c{\u00f8]\u00a6T\u00eb*o\u0006\u009c\u00cdJO\u00d1?g\u0090\u00df\u008e\u00c1x\u00c7l\u008bR\u00ac\u00ac\u00ee\u007f\u00d2\u00f8G<\u0003h\u001eQ\u001en\u00a7\u00f4\u00b51\u00c9\u00d8R\u0016\u0014\u00bcQ\u00a8\u001d\u00ff\u00d8\u00d1\u00e5\u00cew%\u0085\u00fd\u00a8\u008aF\u0016\u0091\u008fZ\u0096\u0000R\\W\u00c9-\u0001R\u00a5\u0006\u00ce\u0093\u0081FQ\u0089;\u0098\u0093B\u00df\u00d8\u00f6W\u009b\u00c0\u0089\u00c3M\u001a\u0019\u00f9R{\n\u00fc)\u00b8\u0017C\u00edi\u00dd\u00bfx/L\u00cd\u00ad&\u00a9x\u008d\u001a\u0094\u00e1\u00b7\u001fw\u00a6u\u00ba\u00de\u00dd\u00fe\u008c\u009f\u00da\u0012i\u00a3\u00d4\u0086\u00eaL\u00d0\tn-\u00dd\u0000\u0005\u008d&2\u00b9\u0096\u00b6!!4\u009db\u001e{\u00f7\u0003'\u0011\u00bb\u00de0\u00fa*\u00f5\u0092\u00a8\u008a\u0007\b;n@\u00a3\u00f8\u00d0\u009c\u00f8z\u00b6\u00cb\\Y\u00cb\u0087P_e},q\u0001\u0087\u0001\u00a8\u00d3\u00eb\u00ca\u00de\u00f7\u00b9\u00cc\u00f7\u00e5\u00f8\u0012\u00f7\u00ae\u00a9v\u00f1\u0091|R\u0013\u008c8\u00ed\u00f3g\u00e1\u001d\u00b6\u001c\u00f7)\u00bf\u00bd7\u00d4\u0001v\u00d8+\u00c7\u00aa\r}\u00be/\u0005o)\u00ecU\u00e3\u00d3b\u00a3\u0016W\\\u00feM\u00ea\u008e\u0082\u00a4D\u0095\u0002\u00f5\u0006\u00d8\u00ca#W[\u0099\u00ef\u00a7\u00d4\u00afn\u00bbW2\u00ae\u0087\u00f7\u008b&\u000e\u00ac\u00cd\u00a4\u00db\u00c8\u00f8\u00aas\u0081\u0002\u00ca\u00a7\u0090\u001b\u0081\u0005\u0099\u00beN\u00ac\u00acx>O\u00e4~H\u0087=\tj\u00c43\u00c3\u00d60c\"^vyp\u00a0\u0017\u001e:\u00fc \u00f5Y8B\u00adYF,F\u00cd\u00df3U\u0092^.\u00ab\u0080\u00ff\u00c8\\K\u00d8\u00bc\t\u001fW!^\u00bc\u00f8\u0086\u00beB\u00f2\u0092\u00a9\u00fbQ\u00ef\u00a7\u00a8\u00ed\u00f9\u00c3O\u00cd\u00ec\u00d0\u00b6\u0012\u0016\u001d\u00af\u0011\u008dV\u00c80\u00b4\u00d1#\u00b8\u009eR58G\u00ef%\u00df\u0013\u0005\u00d4pE\u0093Jx)\u00cd\u0013\u00ed\u0019\u00e7f\u00ef\u0094\u00ca\u00c2\t\u00ff\u00e3:\u00bfB\u00e2\u007f\u00be\u00caTN \u00d2@\u0005m.\u00d3\u00d4\u00bbK\u00ec\u00dbn\u00af\u0004\\\u0000\u00d3\u008fv\u00c0\u00014esQ]-\u00de\u001d\u001eBfg\u00b2qC\u0094\u0083dz\u0090\u00cd\u000b\\\u0099\u00c4\u001e\u008cC3\u0081\u00d1\u0010\u00af\u00ab\u0005\u00dfA\u00f0O\u00e0?b\u00e6S\u008c\u0086\u00a9\u000fH\u00a2\u0080\u00e4\u0089\u00b9\u0007C\u00c50=\u00aa\u00be\u008f\u0095\u0092;\u0080\u009e\u009b\u0090\b\u0017\u00a0aE^\u0010\u0098>.\u00c2\u00fd)\u00af\u00da\u00c9\u00ae\u00e7Q]\u00a2\u0006E\u00df^\u00c1\u00025)e\u009e\u00de\u008f\u0094*s\u00bcKD\u00a1\u00be\u0089\u001e\u00910V\u00c5\u009ct\u000bc\\\u00f2\u00e0\u00bb\\\u00eai\n\u0098T\u00cb\u001e\u00e6\u00ae6p\u0006\"\u0082\u00c6i\u00a4:\u00c9\u00fc\u00e0\u00ef\u00d8\u0099[\u00b9xv\f\u008b\u009c@\u00d9\"T}\u00b6\u00bf\u00c7Kp\u0096\u0001\u00f3\u0081\u00fb\u0013\u00149'\u00b4\u00a53\u00ef\u00de\u00e39\u0001\u00e7\u00df\u00b2`\u00e3dI\u0086\u00a9l9>\u00db\u00cc\u00c9\u00bfW\u00bc\u00fa\u00ccYA\u00c6\u00cdw\"\u00ac1'J1+c\u00f0J\u00c3\u00a9\u0094\u0085r\u0081\u00d9\u00ca\u001b\u00e2\u00e6\u00f3\u00c34\u0092t\u00b9\u00ba\u0091\u00a8\u00dd\u00a1\u00eb\u00b4\u00bfw@\u0096,\u00d1\u00e2s\u0097Q:O\u00ed\u0080\u00e9\u00124\u00e0\u00a2\u00d6;\u00ea\u0010\u00c6}\u00dc\u00c5\u00ac\u00a3\u00c6\u00ee\u00b7\u00eepE?|\u0002\u0092\u001d\u0085\u00d5\u000b\u00e1,p\u00cf\u00f6\u0012\u00fa\u00af-\u00019\u00e81Q\u0014\u00cf\u001a<Y\u00e8\u00dc\rG\u0005w.\u00c1?\u00db#\u00f3{\u0010\u00aa}o\u0005lFY\n\u0003*\u00b0PG9\u0099\u00cd\u0002W\u00cb_\u000b\u0084\u00f4\u0004\u0087\u0015\u00eb4\u009c}\u00bb\u00cc!,\n\u0013\u00efB$@\u00be\u00ac\u00fb\\\u00fe\u00b1H7\u00b4\u0010\u0098\u00d1*\u00b8<\u00caI\u008e\u00a88\u0093\u001d\u00ebF\u00a0[\u00c2-\u00aa\u00b4o\u0015\u0089\u00ed5a\u0003xffv\u008d\u00be\u009e\u00c8\u00acl\b\u00ae>0\u001d\u00c3*$C\"\u009d\u00d3]\u0000\u00b1?\u00f4'\u008a\u0013\u0098J.I\u0018\u00cf\u00f7\u00a4\u0093\u0006\u00c6\u00f5?\u00e0\u00cb\u00aab\u007f\u00dc>+\u009ap%h\u00a8oO\u00feg\u00df\u00c6\u00c5\u0085Z\u00a3:\\\u0004\u009b`\u00d7\u009c\n\u0093\u0013\u0013\u0089s\u0090\u00f7\u00d1K\u00eb\u0098\u00fc\u0004e\u0004PD\u0006\u0086,\u00c0\u00f2\u009b[j\rL>\u0092\u00b2i\u00f8\u00db\u00ba\u000b6\u00cc\u00f5\u00bfli\u00e9\u008f\u00dd\r\u00de\u009b\u00fc\u0087\u0010\u0098\u00e3e4s\u00f8c\u000e\u00bby\u00f3\f\r\u0014$\u0007\u00ab\u00fb\u00c02\u009e\u00be\u00b2u?'\u00e4\u00beu/\u0080\u009e^\u00c7X\u00b4_\u00fe\u00a5Q7\u0086(\u00bb\u0084Y\u00e5O\u00f5^P\u00101\u0018 %\u00d9\u00e1\u00f9\u008e\u00ed(Q\u0004\u0006e8\u00deJ\u000eG\u00d94\u0006\u0081\u000fxXv\t\u00fb\u00eaR\u0012o*\u0092=R\u00e9$\u00fbqf\u00bf\u00ed\u00e9\u000e\u000f~\u00f8\u00d8\u000e'\u00d7H\u00a4\\\u00d3r\\\u0098\u00cb\u00fc' f|\u00d2\u00b3\u00a3$;\u00a5M\r\u00dc\u001b'\u0010\u00d5\u00b0\u009a\u008dNK\u00bc\u00f6\u0097 `E\u00de\u007f\u00d7\u00e7\u0002\u009f\u00af\u00b7\u00c9\u0092\u00a75\u0091B\u007f\u00ab\u00ba\u001a\u00d1\r\u00cbA\u0003\u00fc\u0004m_\u00cd}\u00f7\u00f7\u00c6S\u0015\u00b8\u00cf'\u00d1t\u001f\u00c6hV_r\u00c3`&\u00e9\u00b5M\u00bcD\u00e8C\u00c9.\u00bd\u00a96x\u008c\u001a*34\u0088\u0016\u00d2\nm\u00cbx\u0007V\u00db\u00ecXL\u0082\u00e3\u00b4\u00fc\u00c3\u00b1z\u008f\u00fe\u0099*8vs1\u0090\u0091\u0098\u009et\u00076\u00c3\u00f1\u00f8m\u000b3\u00bd\u0000lL\u00a7%\u00ab$)\u000b\u00eb\u00cc8\u0083\u00eb\u00de\u00bd)\u0092\u00bdr\u0097\u0012\u0098\u00f6\u0012O\u009aG\u00bb\u00d0\u00e4\u00ab\u00a2\u0013P6\u00b2\u00fb\u008a\u0010%\u00a8]P\u0089:\u00eb\u00af\u00fadX\u00f6\u00cd&\u00e0\u00a7?\u0016L\u00c0\u00b0\u00c9\u00bf\u0096\u00cdy\u00f9t\u00c4\u0091a\u009e\u00e6#\u00a9>\u00b9N\u00ce\u00f3\u00c6=\u0099\u00eb\u00d8\u0017\u00b7<\u00c44)\u0093\u0019\u0019\u00b0\u00c4M\u009c\u00a8:.\u00a6\u0086\u00b0\u00f0\u0002\u009f@\u0081\u008c\u00f5\u00a6Px]\u00e1\u00de\f\u00df\u00cb\u0007P\u0013K\u0012\u00d5\u00b1kR\u00fd@\u0080Q\u008b\u00fa$\u00986\u008av\u0097\u00f7\u00d8\u00d0\u00c3wI\u00df\u001e\u0098\u0017,\u00a0\u00a4\u0089F\u00e1\u0095\u00a4\u00df\u0007\u00b4\u00be\u00dc<\u0007\u0017\u00e2\u00e4\u0011\u00f1\u00f1R\b\u00f7\u00a9\u009e-\u00cf\u0006P\u001e\bW\u00c1f\u00e1\u00e1\u00ed^\u00c8+\u0001C\u001a\u0082c\u00ce\u0085\u00f0\u00f4\u00c4|:'c\u00cf\u0094\u00beO\u00fc@j\u0003\u00de\u00000\u00a8\u00d6RCGW|b\u0018Fw\u00bc\u00be\u00c9\u0090\u00a9\u00c7|\u00c2|\u0086\u001e\u0010\u0089\u00bb}\u00c5\u00d6g\u00a6S\u0097y\u00c7}\u00b7\u0002\u0016\u00b4\u009fLe\u00b2\u00e11o\u00db\u00b1{\n\u0015*tf\u00e2\u009fh\u00acD\u0006\u0003\u00186\u00faf\n\u0087]K.\u00e7Ib\u008b\u00dc\u0017\u0091\u0092\u00a8\u00e5\u00cdL\u009f\u00ec\u0092AWX\u00a5\u00d9D\u001f\u0081\u00d0\u00d8\u00f7o/F~\u008d\u009e+Bxl\u00ddz\bn\u00fcZk\u00bb\u00a6X:\u0015\u00a9\u00dc'\u00ae\u0082\u00a6\u00d2GF7\u00c6=\u00ebL\u00e2\u00a4z7\u00ad\u00f4Bz\u00fc\u00a6_\u0095\u00c9/\u00f8)\u00c0\u00fe(\u00bb\u00ba^%j\u00b1\u00fa]t\u00b3u\u00f18\u00c7r\u008fJ\u00d1b+\u0001\u00f0\u00cd\u0000\u00a3_\u00ae\u00bb=\u00f5V\u00c8\u00e16iQE\u0097!D\u00b9\u00fd{\u0081\u00b8c\u00b6\u0081#\u00d03\u0011K\f\u00b8\u00c0F\u00a9@Q\u00e4x\u00f2'\u00d4\u008a\u00ad\u0097\u00c1\u00f4AeM\u00e8\u00df\u00adf2\u00d9\u00f6\u00a5\u00b8H\u009au\u0017\u0096\u0092\u00cb\u00e5\u00efP\u00d7\u00dfW\u00cce[\u001a_)`\u00a1\u00bb;p\u00ef<Y\u00d2}\u00807i\u00be\u00d7\u001f%\u00fbd\u009d\u0098HcI\u00a7Q\u00db\u00b1\u001cF\u00e7\u00c0\u0093\u00d0\u00b3\u0081S|\u0088\u00d7D\u00da\u008er\u00ff\u00de\u0087j\"\\\u001eb\u00b8!\u0087=\u00db#\u00e9\u00fcD8oM\u0015u\u00b5\u00dd\u00e96/\u008cTk\u00bc\u00f4TT\u00ec\u00c1p\u001a\u00c1\u00db'rmy\u00ff\u0097\u00c9\u001e\u00b5`\u0089{\u0005D\u00b9\u00ad-\u00d9qlv\u00c1k\u00de\u00e3Aw\u00c7\u008c\u0089\u00a4\r\u009eu\u00f0o\u0089<+\u0087_\u0007\u0088\u009d\u0094bb\u0097m\u00a0Hj\u00b92\u0018yK\u00d1]DG~\u009f\u0086\u001d;\u00a3\\\u00a2J\u00c5\u00801\u008f\u00d2ZR\u00a92\u001fD\u0092$\u00cf\u0091\u00ef\u00da\u0007\u0017\u00fb\u0086\u00acr\u0010y\u00f5Cb\u00b66\t\u00fc\t\u0016\u00e9\u00e6\u00dcq\u00e4\u00f5G\u008e#e\u00a8\u00acFV\u000e\u0092\u00ea\u00a1\u00cel\u0098a\u000eJ._c\u00e8+#\u00dd0\u00c7\u00a9\u00d6@\u00fb5k\u00e9y\u009b^\u00d74W\u00b53\u0019\u00b8b\u00de{\u0096K\u00da\u00c0\u00e0\u001d\u00e9\u00c71\u00e26R\u0085S:g\u00d2ON=\u008bz\u00a2=Ou_'\u00a3\u00f1\u0095v\u00f0\u0090\u001d\u00120\u00c9\u00a03\u008e\u00b0\u008e\u009d\u00e1\u0091F'N5\u0093\u00c0\u001d\u0003y\u00a0%\u00faq{\u00b5=\u00ff\u00a92]\u009di\u00fc(yv\u00f5\u0001\u0014v\u00c3!\u00b5\u0018\nz,\u00e3\u00ca\u00adt0\u00b0W\u007f\u00cb\u00f8V\u00e4\u00e6\u00cfq\u00dfn\u00b9\u00e1\u0013\u00b2\u00f70\u00ee\u00aa\u00c0\u00bbQ\u00e6@\u0096\u007f\u00a64%\u00d1\u00fa\u001bq\u00f6\u00ea\u00c7q\u00c7\u00f3\u0087\u00cd;\u0016n.1!.O\u0017\"y\u0092,\u00a6'r\u0088\u00bb\u00c5\u00a3\u00fc\u00ed)\u0018/\u00b7.\u00f9\u00af\u00d5p\u009a\u00ce\u000b\u00db\u00f0\u00e1\u0012O\u00d1\u0084\u00dd\u009c<\u00af\u008dY|xD\u00c5\u0099\u00b4v\u008f\u0098\u00b7\u00d5\u00d7{\u009005\u00ab~\u00b6\u0083X\u00e6\u0019D\u0007*\u00d9\u0007\u00d9P\u007f\u00ea\u008a\u00d6\u001cK\u00f3nw\u00a3\u00b4\u00ca\b\u00ab\u00b4\u00b6\u0099qQ\u00e7\u007fWJ\u009c\u00df \u00b0}\u0080\u0003\u00f3\u00ac\u00f4\u00a9\u00eb)\u0085\u0014\u00e2\u00cep\u00afa)O/\u00dd\u00d1=@b\u0091\u00e5-\u00ab7\u000f\u0016\u0012{!@\u00af\u00d6|\u00a4\u0080\u00ca\u00c7n\u00c7\u00fc\u00d0\u00ce\u0018\u00b3\u000fh\u00bc=\u0088[\u0014\u0095\u0097\u001f\u009dj\u001bQ@\u008d\u00a3\u00d8\u00df\t\u00da\u0089\u00ce\u00f8\u00e5\u0002\u0018L\u0000\u0085o\u001bt\u00d1t\u00d7o\u000f(G\u00d3\u00b4D\u008f*7\u00b8\u00e65\u00d3ps\u00e3\u00f1\u00de\u001c\u00a9\u00e6\u008ei\u00b4\u0089\u000f?\u00d2\u0094\u00e2\u0097\u00e1\"\u00f5?\u0088\u0019J<\u00eby\u00cf\u0086y\u00d1\u00abu\u00ea\u00fdfb4\u00ba}\u0016\u00cf\u00c7k\u00ab\u009bX\u00c6\u0007\u0086\u00fbC{\u008b\u0080\u00ad\u00de\u009a\u00b8\u00bd\u00bb,E1\u0007\u0007by\u0091\u00a7\u00ee\f\u0080\u00fa\u00ba\\'M\u00bf9\u0088q\u0081\u00b1\u00a5\u00b5x\u00c2\u00b6\u0012\u00d3DX\u00a5\u00c6\u00a7\u008ftbZ\u001dw\u0011T\u0081({e\u00b6\u00195\u0085\n:\u007fu\u00dc\u00ef\u00b5a\u001a\u00b5\u00bc\u00e3\u00d0\u00ecv\u00d1\u00f0|\u00f2\u00ce\u001d\u00e8\u00a0\u00ee=\u00c1=\u001b\u00ed\u0089\u00fb\u00fbK\u0097\b\u0093;\u000e\u00e5\u0019\u00eb0\u001c\u00baEY\u00e9IV\u00b2(\n7\u00b4.\u00b7'\u00e0\u00df\u0003#\u00aef\u00b1\u0088p\u000f1\u00d5\u0010\u00fe\u0095\u008e\u00e2FG\u00eaH#\u008cz\u00d2r\u00fd\u00ce<`\u0091\u00c8*\u009b\u00ac\u009bb\u00a7#\u0091\u00c4z\u0093\u0011\u00f2m\u00d6\u001a\u00e2\u008b\u00b2\u00e1\u009f\u00b16!vw*\u00bd\u00e2`\u001c3\u0005\u00b2F2 \u00a6$9\n\u00d0\u00d0K!\u001e\u0002A$\u00e3k\u0087\u0094&\u00b5\u00e3\u00f8\u00ca\u00e8)\u00b0\u00c0\u00a8^U\u00ed\u0099\u00b8\u00aaiT\u001bk\u00d6\u00f72\u00d9\u007fS\\\u00f5>&\u00bf\u00c3=\u0089\u00a1O]\u009e\r&\u00efA@\u00ad\u001f3\u00b6y\u00f8\u00ca\u0000\u00ef\u00c6\u00b2da\\\u00d0\u00ebo81z\u00b3\u001df\u00ac\u00e3\u00f8\u001c\u008b\u00a0\u00c7(\u009c\u0012\u00d9\u00c3\u00a9\u00f5\u00e5\u00e1\u00bdp\u0092k\u0096_Q\u0006\u00bc\u00c6B4\u008cg\u0000?\u0087\u00ba\f\u00c2\u00ffF\u00ea\u0080\u00f2\u0092\u0084\u0013\u0016\u0095s\u00fb\u00e8\u00ca\u00a71x\u00c80\u00c5\u0010;\u00f3\u00d6\r0\u00c9\u00b2\u00f1\u00c2\u00854\u0098J\u0083I\u0017\u0084)\u00d8\u00a4\u00f5\u0089\t!<\u00e2\u00bb\u00caK\u00c9?\u001a\u000e\u00a9\u00d8\u00a4\u00e3\u00f9m\u008f$\u00c3\u0089\u00bc\u0013\u00c2\u008b\u0089\u00aa\u00e2\u001e\u00ce\u00a3\u00a5a\u00e1\u00b7\u0088\u00ef,G=\u0013_\u001bN\u00ff\u0097J\u00c8\u00c8\b\u00cc8\u00e3\u00b3\u00f9\u00e9E\u001d\u00c6\u0002\u001dw\u00c1\u0089\u009ax\u00f9:\u00e5\u00a5\u0081\u00ca\u0096\u00c3\u0089\u00d5\u00ae\u00e6R\u00f6\u00dd\u00ecO|\u00ec\u000f\u0084\u001c\u00cd\u008b\u00fe\u009c\u00ed\u00c3F|\u00a7;\u00b63\u00c3S7\u0010\u001a\u001f\u00c6\u001eJ\u00ed\u00b0HR\u00db-\u0010\u0011\u00971\u00b7\u001f\u00f3>\u0081\u00db\u0094\u001e\u00cd\u00e1?\u0001\u001e\u00eb\u0092%\u009d?vo'\u0086\u000fY-\u00a3x\u0000\u00cad\u00c6\u00fa\u0090u\u00aa\u00deE\u0093\u000b\u0089\u00ad{\u001f\u00ef\u008f\u00cc\u000f\u00a8\u0086x\u008f\u00fd\u00d4\u00f4\u00b2\u0003\u00d7#\u00ca\u001dC\u00ef\u0017(\u0088\u001e\u00cdt\u000e0K\u00e9]\u00ba\u0089\u008bY\u008c'\u001c\u00f5\u00b9\u00e8\u008d\u0018\u00e8\u0019}\u00f9\u00c7\u00d0R\u00c0\u00bcB\u0016pi\u0099s\u0087\u00cd~U\u0090\u00e56\u00f8\u0013TM\u0093\u00adAy_\u00ce)\u0089\u00a9\u00c0\u00f9K\u00e5C\u00f7\u0080X\u00b7\u0092=\u00e3c\u00cd\u0007d*\u0095\r\u00a0p\u00aa_\u00d3x\u008e\u00e6\u00af\u009d\u00a0\u00b3\u00ffv\u00e7\u0002\u00f2W\u00ca\u00e3\u0011\u00a4\u00ad\u0017\u0092\u00e1\u0013\u007f\u00adg&$}\u00bes\u00ab\u00ef\u001f\u00cd\u00ba527\u0084{\u0080\u00b4Y\u0014\u00a4\u00dc\u001f\u0080\u00ceBnj<\u009d\u00b0\u00ec\u00d0{\u00be\u009b\u009d\u001bG\u009a\u00d7\u000b\u00e9\u0087\u0017\u0080\u00d1\u0014\u0090\u00ff\u0092\u0017q,\u0010\u0098\u0091\u00a3W\u00a10\u00d6`\u00e6\u0019\u00e1\u001a\t6F\u008a\u0001\u00c0B\u0085\u0098@\u00a6\u00db\u00ce\u00bb\u00bc~\u00b5\u0016z\u0097\u00fe$\u00e9\n\u0003\u00d6\u00a5e\u00f0u\u00e7\u00ee@>ow(\u00e2=\u00ddF\u00ddV\u00acT\u00d2\u00bc\u00be\u0089.\u00c9\u00af\u00cbg^JC\u00f3\u00a8q\\g+z{h\u000e\u00a4z7\u00a3w\u00d1)\u00b4)\u008d\u00ccf\u00a5/\u00f5\u00e8/1:\u00b6\u00af\u00ff+\u00c6\u00a3\u00d6\t\u0089J\u00b2\u001d\u00bc\u00b5K\u00b8=f\u00a9\u00ceLS\u00aa\u00d0\u00a7_2\u00b9\u0017 7^\u00d23\u00f3\u0012]Up\u00fe\u00c3iA\u00d9aC\u001b\u00ee\t\u00a5\u00cb\u00a3\u009b\u0018~)\u008f\u00dc\u009c\u00fc~\u0094\u008c\fm'~\u00fa\u0011\u0016\u00f3\u0088vn;\u008c9\u00c6*\u00ba\u000f\u00e3n\u00c5E\u000f\u0097\u00bd\u00b1\u00c8w0\u0000\u008a\u0010o\u00c6\u00f0k\u00b0\u00f5\u00b1\u008aH\u001d\u00eb\u008f7\u0084\u00dc\u00bc\u00fe\u00fc\u00ce\u00ff\u00b2*\u00fa\u00e9F\u00d3\u00d8\u0086\u00eem\\w\u00bc\u00ae\u00b3w.\u00b1\u00e9\u0085\u0081\u00c1\u008f\u00b6\u0095\u0093DDw1\u00af5x8}\u00a1O\u00ffM_\u00db\u00a6Z\u0014ar\u0012mB\u0019s\u001a\u0013\u00a1\u0096\u000bA\u0015\u008b1\u00e2\\\\M9\u00fc\u00d1\u00ab\u00e5\u001bz\u00b4\u009d\u001f\u008dB\u0086A\b\u00aa\u00fd6\u00bb\u00e3\u00a8\u00eb\u008bJ\u0086\n)KwR\r\u00b6\u0005\u00e4\u00actC\u009c\u00f1\u001e\u00d2\u0000\u007f&e9\u00d2\u00e5]\u00e2\u00cd^\u008b\u00f97\u00cbC\u0007G\tX\u001d;\u00a0s\u00acM\u007f/\u0010\u00cf\u00ac\u00e1\u008f,\u001eW3\u00c5\u00ad\u008d\u00ae\u0098\u0004\u0085,<\u0087\u00e0JN\u00a5\u0014s\u0096m\u00fe\u00c4\u00a4\u00c9\u008c\u00ffW\u0012\u008e\u0007*>>\u0082\u00e2<\u00c3\u00e7\u00bb\u001dU\u008d\u00bd \u0000,\u009f\u00da\u00af\u00ef\u00a6\u00e60\u00a6\\\u00afK(D\u00a2\u008f\u00a7\u00d4\u00ac\u0018x\u00f5\u00c2Z\u008c\u00f8bn\u0098\u00fc]E\u0084\u00e8\u00c4\u0099y\u0005R\u0094B\u00fd\u00a5#\u00e0\u0013\u00ef\u0083\u00a5V\u00b2v\u0099hk\u00fb\u00a8\u00d1b4UD\u0006\t\u0004\u0085|J\u0084{Y\u00a9Iu\u00e0K6\u008cRvE3\u0099\u00b3w\"\u00e6\u00fb\u00b4%\u001d\u00ddK]\u00da9\u00deSi\u00ad\u00ec\u0098\u00c1\u009f\u00d0d\u00f0|\u0018\u00a8\u00b2M\u00bd\u008f\u00bbG\u0011CLK\u00bc!\u0094\u00b1\u00f0\u0086\u00d5\u00df\u001e\u00d1\u00ad\u00cc5\u00f7\u001d\u008c\u008cWs|\u00df+\u00a1\u00be\u00af\u00ca\u009c\u00b9U\u0007\u00b59\u008as\u00ea\u00c8;\u00bf\u00b4-\u00b3n\u00f8\u008aq2miO\u00fc\u00d6\u00a9/\u00bd\u0096\u00c6Z\u0087\u00b8 \u00f2P\u00c5\u0093/Na\u008c\u00cb\u0087\u00e6\u00f9\u000e\u00c3\u001by\u00b1\b+3\u00f3\u00ba.\n\u00e1}\u00f8C\u00f2v\u001f\u0007>UQ\u00a2-\u0000K~\u0087^Y\u00ab\u0007\u0096O9\u00f0\u00fe\u0098\nZ\u00ce\u00b1\u00f2\u008f=_\u00c5\u008f\u00ca\u00a6\u008b\u00e2\u0001\u00f3\u00e7\u00dc\u00d0\u0099\u00ceg\u00b5z\u00db=\u00fd\u00e5\u0013W\u00e7H\u00b2\u0016\u0084\u00cf\u00e8\u00df\u00d1!z\b\u0091\u00dfB\u0017\u00e2\u00060W\u0005$*f\u00fd\u00c9\u0013\u00bf\u00fe]\u00f2\u00c4\u001c\u0018Q;\u00e0{\u000b\u007f\u00d61d)j]\u00cb\u007f\u00b5\u0001\u000f{\u00e3\u00f2J\u009c\u00dd\u00d6\u00ef\u0090\u001c\u009da\u00ecI\u000em\u00a3\u00df\u009d`#f\u00f57\u0016\u00ce\u00e2\u00e9v\\HXB\u00a0\u00ed\u00d2\u00a3\u00dfs\u00b0akd\u00e9\u00b2\u00dbC\u0013eb\u00d0\u00d1\u0097\u00a7\u00dc\u009e-\u00d4\u008e\u0081\u00d1\u00e6\u00b8\u00ca8\u0094\u00b5x\u00e4\u00f9\u00ab}%\u00f8}\u000b\u00cb\u0091g\u008a\u00c2\u00d5N\u0005up=k\n\u0011\u00bbE3\u00e5*\u00f4\u00f0\u00db\u00c5\u00f3\u00bfV\u009b?\u00e9\u00e5E\u00ef]-V\u00f2&\u00e2\u00c1\u00f3\u00a4\t\u00bb\t\u008bv\n\u00f2\u00d0\u00e5\r8\u00c8\u0082\u0016bfY\u0015\u00e8\u00ab\u009a?l\u0010\u00ef\u00d3\u0001\u00ab\u0097\u00f2k\u00cf(\u00f6<\u001eA\u00e1\u000b\u00d8\u0003T\u00d2\u0085\u007f\u008d\u00c40}\u0083\u00bbf\u000b\"\u00a6\u00e3\u00c4\u008c\u008a>\u00c4\u00ffW\u00da\u00cc\u0014\u0004\u009d\u00b6\u001b\u000eX\u0084\u009d\u00e9zh,{*y\u00b1\u00ce\"\u00b3\u00a2S\u00fe]\u0087R6\u001b\u00bf\u00d3gEv\u00d7F/rU\u00f6\u00ad\u00a9[k\u00c3k\u008c\u00c6:\u009f(}R\u0017\u00d9&t\u001d\u00ca\u008c\u0013)\u0080\u00036S)\u0091/\u008e\u00c9]\u009b\u00c9\u0004\u0005\u008c\u008d\u00b1\u00b2\u00d4\u0091\u00a6f6\u0085\u0002\u00b7\u00c3[v\u00b5\u0090/3\u008f\u0007\u00a2%\u0085\u007f\u008e\u0003\u0095\u00d4\u00a1\u0006\u00dc$!s\u00f8\u0004<\u00b8\u00d3\u00c0{f\\\u00f5F\u00e5\u00d0~\u0002)\u00ce\u008am\u00c5p\u0084\u0017\u00d5X\u00a1_al\u00d7\u00d0m\u0000\u0017.\u00beh\u00db\u00e8\u00d3w\u0093\u00b4\u00d5\u00f1X\u008f\u007f9\u00b3\u00c1-\u00e1\u0097E\u00c1\u00cd2\u00fd\u009cN\u0002\u00b4\u0010v\u00f9\u00e7\u00b2m$7\u00adtY\u00a1\u00e0\u00afW\u0015\u00ca\u0096\u00c2\u00c8\u00be\u00df\u008e\u00c1\u00b4\u00a5\u00ed\u00fd\u0084\u00d53\u00c0]\u008f}=\u0092\u00d7\u00a2\u001d\u00fc\u00ec\u001f\u0002U\u0086\u0006b\u00bbr\u0094\u0096\u00fd\u008e\u00f1\u00bb\u009c\u0096\u00cc\u00fc\u0087\u00d8\u00fdc\u0001\u00be\u00b1\u00bd\u00ee\u0080]\u00be\\\u0099A\\\u0013\u00b5D\u009c\u00f6\u00e5#!\u00eb\u0084h\u00ef\u00e6K\u00d6\u00b8\u00b5\u001a\u00df\u0007r\u0092\f:\u001c\u00c2\u00f1\u0093S=\u008e\u0003U\u00c8u\u00ad\u00f0W\u0013bR8M\u000e\u009d\u00ee\u001a\u00e6Wj~\u008e\u00be,\u00f6mu\u00d2\u00a5\u00ec\u00d3\u0080\\hN5\u00c2\u00c0k\u00d1\u00acq\u00c3\u0005yE\u0097gHE\u00ab\u0085a\u00d0g;\u00e7\u0004r,ob\u00ac\u00c0^\u00a1\u00c7E?\u00cf\u00b9\u0001Hkt\u0018\u0016l+\u00aa\u00b5\u00bf\u0093j|\u008fU\u00f3\u00f6ve\u00db\u00a2K\r\u00da_%\u00aa\u001f\u0091\u00a49\u00e1;,\u00d1\u00e9\u0093l\b;\u0006\u0093\u00bd\u00bf\u00ef\u00df\u00eeDw\u00af\u00a6\u0017\u00c1\u00cb/\u00a2\u001d\n\u00b6\u00bf\u00f7\u00e4\u00ee\u00ee\u00d2!\u008f\u00cb\u00ed\u00fd\u00da\u00be\u00fb80l\u00ca\u0019R\u008c\u00c8\u00b5\u00e1\u0089\u00ae\u0080\u001e6\u00a6\u00c4J\u00fd\u0086X\u00a1\u0005\u0095LH\\T\u0080\u009fli\u0002,\u00a3\\\u00b8\u00e1\u00e88\u00d8\u0092\u00e3&\u0004Ko`.\u009a\u00ea\u00fb\u00e7\u00c2\u00fb\u00a4^\u0090=\u00df\u00be\u00b7Lr\u0000\u00e5rH\\\u0084.G\u00c0\u00f8\u00dc#\u0087\u00bd8Ei\u00ee\u0011\u00ba\u00f1\u0019\u009eV\u00dd\u0007\u00dd\u00feJ\u00be\u00ab@M\u009a\u00d2\u00df$s\n\u00cc(\u00e4:\u00e1\u00a6I\u00a1qA\nM\u00e5Y\u00c6\u00c18\u00a5\u00e2\u001a\u00e4\u00a6\u00bd\u00f8\u00b7'\u00f2\u00f9+\u00c4)sN\u00ec\u00ed\u00b1\u009b\u0018\u00de\u0087%\u001c'\u00b8\u00a5\u00b0\u00a8\u0087~\u0097\u008e\u00fe\u00d5\u0083\u00d5\u00de?\u0086}p@8\u00c1\u00fa+^\u00b7\\\u0090\u0018\u001c\u00f6\u00cf\u0097\u00bb\u00f29\u00ddB/\u0005w\u00d3\u00ae\u0017\u0014Fkt\u00ff\u0006\u0007)\u0084\u00b4\u00c4.\u00e1\u00bb\u00b5\u00f3]\u008d\u00f0\u009d\"\u009c\u00aay{\u0017N\u0084\u00d6\u00bd\u00e1\u00aa\u0018\u0019\u00926[\u008eD6\u00bd7\u009c\u00d05\u0010|7\u00a8\u001a\\\u00ba\u00109QKF\u009d\u009b\u00b8\u00efqM\u00d4\u00ec\u008c\u0086\u00c3\u00f2\u00d3\u00cb-\u00c5v$\u00d1lt\u0093\u001b\u00a7N\u001b\u00a5{\u00c9a#\u00ect\u00e9iJvb\u00d3\u00af6o\u00e2>[\u0000\u00c5m=\u00adA\u00e5||&\u0016\u0089\u00a3I\u009f\u00f1\u000e\\e\u00aa\u00f79\u009d7Aj\u00b7\u00c4\u0081\u008c\u00f77\u008b\u0087/\u00a9\u00fb\u00e3\u009a&\u0002Ev}\u0017\f\u00dc\u00cc\u00e36\u008b\u00de\u00f2\u00c1\u00ff\u00f0Y\u00d5\u00ae\ry\u00cd\u00b7A\u00c2\u00e9\u00fe\u00ff\u00d7\u0013\u00e9\u00b9\u00ac\u0010\u00a9\u00deG:n\u00a8\u00bf\u009bdr\u00e3\u00d5\u00cbA\u00b75\u00e5: \u00e4\u001eU=\\\u00e4\u0014w\u00c5\\\u00ef\u0091\u00ec\u00f0\u001d\u00af\u0099\u00ed\u00e7cS/x9\u00a3\u0093\u0007tp\u00d0#x\b'\u00b9\b\u0005\u001f\u00aa\u00cb\u00c2\u008a\u000b\u0090\\j\u0085\u00f1m$\u00ffA\u00ee\u008ar\u00e9\"\u00a9z\u00d8\\\u00b1\u00f0\\\u00a3q:\u0001<\u00ca\u00b4\u00e1dA\u0086\u00b2)w\u00d04a{\u00b2x\u0083[\u00a1Q\u00f0\u009a^U\u00a2\u00b2\u00fb\u00a8\u0006 lh\u0003^\u00dbd\u00fa\u00dcJ\u00c1\u0017\u00f6)X\u00a6:@\u00ff\u00ae\u00c5\u0016M\u0017\u00fe\u00a3\u00be\u00877l{\u009b8\u0087{&\u0097|\u00a7\u0007\u00d6h\u0091\u00b8\u0096R\u0010u\u0011y\u001a\u00a1s!@p\u00f8\u00f9\u000e\u00b7V\u00b1\u00d6[\u0080\u0011\u0012\u0092\u00db\u00fe<\u001d\u0083\u00cd\u0085\u001f\u0012*\u00ea\u00df/\u00b6\u00e8\u00be-\u001d\u00b2$\u009d\u00a2\u00b78M\u00ca\u00de\u00d5\u00f30\n\u00bb>C\u00dc#Z_\u00be\u008f\u001c>\u00c5p\u000e`]\u001f\u0088}\u00fe\u00be\u0006\u00131\u0015$\u0099$\u0083\u00dcSU\u00e6\u001e2\u00d2-u\u00f1\u00d4o\u00bc^*\u00b6w\u00b8G,\u0083L{`\u00e2lI\u00c9[\u00a4k\u001f\u00b4S\f\u00c6\u00b6\u00ad\u00fa\u00c1\u0007\u00ba\u001ei\u00e9\u0003\u000f\u00d3\u00bf\u0004\u00cffo>\u00ff\u0085\t\u0003\u00ba\u00aew\u0085\u0085)\u001c\u00f9.~\u0016'\u00c9\u00cb\u00bf\u0007h\u00e5\u00a7\u00c6\u00b9mxMJ1\u00ec\u00c2%\u0089\u0003\"\u00f2\u00cdPSJ\u001b\u009c! '\u00fc\u00f0E\u00c7\u00a6\u00b04\u00e4\u0082\u00ab\u0085\u000e\u00bbp\u00dc\u00b1=\u0017\u001a\u00ea8\u0085\u00aep\u00e40\u0082h\u001bP\u00f3\u0000R3v\u00f7\u00fa\u00c6\u0097>%\u00c1q\u00b20'\u0086\u00eaV\u00b6\u0083\u00e6\u0081:*\u00e7![b\u0004T\u0089\u000fw\u00d9(p\u00aba\u00a4H\u0013\u0019V\u00b0x\u0093+:L.R\u00d0/\u00b6S\u009b\u00b1\u0098\u0090R\u00a9\u0012\t\u00dd\u00eb\u0016)\n\u00b43\u00af\u0099\t\u0006v\u00e9d\u00c2\u0096\u009b\r\b\u00f1\u00f0Gm\u009a\u000e\u00ce\u00e3L\u00a1\u00d0(\u0097\u0086\u0014\u00fe\u001d\u001c!\f\u00b5\u001d\u00b0d\u0090\u00a0\u001c\u00b7\u00bb\u0017\u00cb\u00ad\u00b8\u00b3\u00d9r\u00e4\u00d60\u00cd\u00cb\u00f0\u00ce\u00a6\u00f3\u00ac\u00c9\u00b5a\u00b5\u0087\u00cb\u009d\u007f\u00a3\\}+\\G>\u0016@C\u001c\u009b(\u00f2\u001e\u001b&\u00965\u00a2\u00deZxV\u001b\u00e4\u00fbqaC\u008c\b\u00b0\u00c3\u0097f'~{\u00be\u0080\u00149n\u001br;g\u00aeq\u0088a\u00ef\u0003\u00f1\u00cd\u0094[Qg+\u0085\u0099\u00e2\u0085\"\t\u000eN\u00eak\u0086+\u00d9\f]mY\u0099\u00e83s*.J}\u0094<g*\u0003\u00d9u@E\u0092m\bX.h\u0081 \u00b8[\n\u00d5\u00d0\u0098:\u0019\u00f0\u00ce\u00a6\u00b0\u00a8\u00c3\u00d9\u00e6\u00a9\u00fav\u00c5\u0092\u0087\u00b2\u0005\u00b0\u00d0A\r\u00f1\u001b*\u00dc\u00de?\u00aaA\u00ab.#\u00a9G5\u00b7zJ\u00d5A\bt0\u00d2\u00e2\u000b\u00dd\u0086\u00d7\u00b41\u0082(\u00b4D\u001d7\u009a98\u00a4\u00a0*\u008a\u00b1\u00a0E\u00b4").length();
    int n3 = 117;
    int n4 = -1;
    Label_0023:
    while (true) {
      while (true) {
        ++n4;
        final String s2 = s;
        final int beginIndex = n4;
        String s3 = s2.substring(beginIndex, beginIndex + n3);
        int n5 = -1;
        while (true) {
          final char[] charArray = s3.toCharArray();
          int length;
          int n7;
          final int n6 = n7 = (length = charArray.length);
          int n8 = 0;
          while (true) {
            Label_0252: {
              // This if statement causes an infinite loop. Idk why Procyon decompiled this.
              if (n6 > 1) {
                break Label_0252;
              }

              length = (n7 = n8);
              do {
                final char c = charArray[n7];
                charArray[length] = (char)(c ^ switch (n8 % 7) {
                  case 0 -> 'Y';
                  case 1 -> 'A';
                  case 2 -> 'X';
                  case 3 -> '$';
                  case 4 -> 'p';
                  case 5 -> '[';
                  default -> '/';
                });
                ++n8;
              } while (n6 == 0);
            }
            if (n6 > n8) {
              continue;
            }
            break;
          }
          final String intern = new String(charArray).intern();
          switch (n5) {
            default: {
              a2[n++] = intern;
              if ((n4 += n3) < n2) {
                n3 = s.charAt(n4);
                continue Label_0023;
              }
              n2 = (s = "\u00ff.\u009f\u00ccP\u00d9\u00f6\u00d2\u0098Â°\u00e1\u00c5G\u00fcrÂ²ifO_\u00e8Â¶[\u00d6.\u0000\u0004\u000f\u0013GÂ®\u00fc\u00dc1\u00d4\u007f\u001a\u00fe\u00e0\u00c1\u00fa1\u00ce\u00e7\u00d4\u00c3\u0006\u00ad\u0096\u00e7Âµh\u0081\u008b+\u00da\u009a\u009a\u00fb\u0005Â·6#Â¸Â¸\u0010Â¨\u0087Â¸=\u00d4\u00d0\u009b\"\u0099r\u008f9Â¾\u0005k\u0012Â©Â Â¦\u00f6!\u00d1\u000b\u0087\t\u00ad\u0098\u00d4\u008d\u00c1\u001e<\u000e'\u0097\u00d3M\u0082Â¦\u00fcv\u0001n\u0091\u00d7\u0015_\u009e\u0004'o;\u00ceZÂ°\u000e\u008dprÂ·|z+\u00fb\u00fe0\u009eÂ°\u00d7\u001fHÂ¿D\u0082\u0003(<Â¬Âº/\u00f0~~Â¼D4\u000f0\u0083[\u00c2\u0012Â¢Â \u00f6\u008ag\u00d7@BÂ¢\u00fe1Â¢\u00c1\u00e6\u0094\u00ad\u00e5vÂµIN\u00c9\u0091XÂ½\u00ec\u00ad*7\u00d5\u001d(\u00c57\u00f4fG\u00f1}Â¦\u009e|\\\u0099\u00d5\u00edÂ¯\u009dE\u00e1\u00d4yÂ´Ak\u00cf\u00e1E\u00d4\u0091\u00d3\u0096Â¥\u00fa\u009f\u00c4Â°\u00d8\u009e\u00c6Âª\u0098\u0004}\u00de!").length();
              n3 = 103;
              n4 = -1;
              break;
            }
            case 0: {
              a2[n++] = intern;
              if ((n4 += n3) < n2) {
                n3 = s.charAt(n4);
                break;
              }
              break Label_0023;
            }
          }
          ++n4;
          final String s4 = s;
          final int beginIndex2 = n4;
          s3 = s4.substring(beginIndex2, beginIndex2 + n3);
          n5 = 0;
        }
      }
    }
    a = a2;
    b = new String[85];
    System.out.println(a(16530, 18598));
  }

  private static String a(final int n, final int n2) {
    final int n3 = (n ^ 0x4094) & 0xFFFF;
    if (b[n3] == null) {
      final char[] charArray = a[n3].toCharArray();
      final int n5 = switch (charArray[0] & '\u00ff') {
        case 0 -> 227;
        case 1 -> 224;
        case 2 -> 211;
        case 3 -> 23;
        case 4 -> 237;
        case 5 -> 168;
        case 6 -> 119;
        case 7 -> 34;
        case 8 -> 98;
        case 9 -> 33;
        case 10 -> 132;
        case 11 -> 0;
        case 12 -> 135;
        case 13 -> 223;
        case 14 -> 175;
        case 15 -> 147;
        case 16 -> 37;
        case 17 -> 235;
        case 18 -> 35;
        case 19 -> 183;
        case 20 -> 127;
        case 21 -> 167;
        case 22 -> 232;
        case 23 -> 4;
        case 24 -> 75;
        case 25 -> 173;
        case 26 -> 134;
        case 27 -> 69;
        case 28 -> 158;
        case 29 -> 25;
        case 30 -> 30;
        case 31 -> 106;
        case 32 -> 188;
        case 33 -> 203;
        case 34 -> 59;
        case 35 -> 117;
        case 36 -> 105;
        case 37 -> 250;
        case 38 -> 121;
        case 39 -> 17;
        case 40 -> 169;
        case 41 -> 70;
        case 42 -> 207;
        case 43 -> 84;
        case 44 -> 81;
        case 45 -> 182;
        case 46 -> 231;
        case 47 -> 123;
        case 48 -> 142;
        case 49 -> 191;
        case 50 -> 96;
        case 51 -> 28;
        case 52 -> 149;
        case 53 -> 7;
        case 54 -> 13;
        case 55 -> 243;
        case 56 -> 196;
        case 57 -> 72;
        case 58 -> 165;
        case 59 -> 46;
        case 60 -> 63;
        case 61 -> 86;
        case 62 -> 215;
        case 63 -> 1;
        case 64 -> 93;
        case 65 -> 31;
        case 66 -> 16;
        case 67 -> 6;
        case 68 -> 5;
        case 69 -> 36;
        case 70 -> 50;
        case 71 -> 176;
        case 72 -> 107;
        case 73 -> 71;
        case 74 -> 78;
        case 75 -> 24;
        case 76 -> 111;
        case 77 -> 32;
        case 78 -> 229;
        case 79 -> 58;
        case 80 -> 65;
        case 81 -> 210;
        case 82 -> 61;
        case 83 -> 8;
        case 84 -> 190;
        case 85 -> 140;
        case 86 -> 15;
        case 87 -> 151;
        case 88 -> 153;
        case 89 -> 213;
        case 90 -> 76;
        case 91 -> 95;
        case 92 -> 234;
        case 93 -> 97;
        case 94 -> 236;
        case 95 -> 2;
        case 96 -> 226;
        case 97 -> 29;
        case 98 -> 125;
        case 99 -> 185;
        case 100 -> 247;
        case 101 -> 143;
        case 102 -> 186;
        case 103 -> 21;
        case 104 -> 56;
        case 105 -> 244;
        case 106 -> 57;
        case 107 -> 137;
        case 108 -> 27;
        case 109 -> 103;
        case 110 -> 18;
        case 111 -> 136;
        case 112 -> 133;
        case 113 -> 251;
        case 114 -> 184;
        case 115 -> 248;
        case 116 -> 225;
        case 117 -> 180;
        case 118 -> 44;
        case 119 -> 219;
        case 120 -> 19;
        case 121 -> 88;
        case 122 -> 53;
        case 123 -> 195;
        case 124 -> 115;
        case 125 -> 130;
        case 126 -> 200;
        case 127 -> 254;
        case 128 -> 194;
        case 129 -> 90;
        case 130 -> 114;
        case 131 -> 160;
        case 132 -> 166;
        case 133 -> 202;
        case 134 -> 12;
        case 135 -> 92;
        case 136 -> 209;
        case 137 -> 41;
        case 138 -> 189;
        case 139 -> 146;
        case 140 -> 9;
        case 141 -> 253;
        case 142 -> 221;
        case 143 -> 205;
        case 144 -> 113;
        case 145 -> 49;
        case 146 -> 187;
        case 147 -> 131;
        case 148 -> 22;
        case 149 -> 124;
        case 150 -> 239;
        case 151 -> 208;
        case 152 -> 157;
        case 153 -> 218;
        case 154 -> 91;
        case 155 -> 94;
        case 156 -> 148;
        case 157 -> 201;
        case 158 -> 67;
        case 159 -> 171;
        case 160 -> 170;
        case 161 -> 242;
        case 162 -> 154;
        case 163 -> 55;
        case 164 -> 99;
        case 165 -> 62;
        case 166 -> 40;
        case 167 -> 139;
        case 168 -> 174;
        case 169 -> 249;
        case 170 -> 11;
        case 171 -> 110;
        case 172 -> 43;
        case 173 -> 77;
        case 174 -> 38;
        case 175 -> 222;
        case 176 -> 42;
        case 177 -> 199;
        case 178 -> 141;
        case 179 -> 197;
        case 180 -> 155;
        case 181 -> 45;
        case 182 -> 83;
        case 183 -> 198;
        case 184 -> 193;
        case 185 -> 228;
        case 186 -> 10;
        case 187 -> 217;
        case 188 -> 60;
        case 189 -> 47;
        case 190 -> 162;
        case 191 -> 238;
        case 192 -> 3;
        case 193 -> 100;
        case 194 -> 245;
        case 195 -> 138;
        case 196 -> 102;
        case 197 -> 82;
        case 198 -> 85;
        case 199 -> 80;
        case 200 -> 246;
        case 201 -> 129;
        case 202 -> 241;
        case 203 -> 52;
        case 204 -> 68;
        case 205 -> 233;
        case 206 -> 204;
        case 207 -> 14;
        case 208 -> 164;
        case 209 -> 144;
        case 210 -> 89;
        case 211 -> 112;
        case 212 -> 108;
        case 213 -> 212;
        case 214 -> 172;
        case 215 -> 150;
        case 216 -> 230;
        case 217 -> 192;
        case 218 -> 74;
        case 219 -> 128;
        case 220 -> 145;
        case 221 -> 39;
        case 222 -> 104;
        case 223 -> 161;
        case 224 -> 79;
        case 225 -> 177;
        case 226 -> 216;
        case 227 -> 118;
        case 228 -> 255;
        case 229 -> 152;
        case 230 -> 126;
        case 231 -> 26;
        case 232 -> 156;
        case 233 -> 120;
        case 234 -> 64;
        case 235 -> 109;
        case 236 -> 163;
        case 237 -> 87;
        case 238 -> 179;
        case 239 -> 181;
        case 240 -> 54;
        case 241 -> 206;
        case 242 -> 51;
        case 243 -> 66;
        case 244 -> 252;
        case 245 -> 178;
        case 246 -> 73;
        case 247 -> 122;
        case 248 -> 159;
        case 249 -> 48;
        case 250 -> 20;
        case 251 -> 214;
        case 252 -> 220;
        case 253 -> 101;
        case 254 -> 240;
        default -> 116;
      };
      int n6 = (n2 & 0xFF) - n5;
      if (n6 < '\0') {
        n6 += '\u0100';
      }
      int n7 = ((n2 & 0xFFFF) >>> 8) - n5;
      if (n7 < '\0') {
        n7 += '\u0100';
      }
      for (int i = 0; i < charArray.length; ++i) {
        final int n8 = i % 2;
        final char[] array = charArray;
        final int n9 = i;
        final char c = array[n9];
        if (n8 == 0) {
          array[n9] = (char)(c ^ n6);
          n6 = (((n6 >>> 3 | n6 << 5) ^ charArray[i]) & 0xFF);
        }
        else {
          array[n9] = (char)(c ^ n7);
          n7 = (((n7 >>> 3 | n7 << 5) ^ charArray[i]) & 0xFF);
        }
      }
      b[n3] = new String(charArray).intern();
    }
    return b[n3];
  }
}

```

`reverse-engineering/src/main/java/zelix/enhancedstringenc/SomeStrings.java`:

```java
package zelix.enhancedstringenc;

public class SomeStrings {
  private static final String[] staticObfuscatedStrings;
  private static final String[] stringsCache;

  public static void main(String[] var0) {
    System.out.println(decryptString(342, -8945)); // placek
    System.out.println(decryptString(341, -24830)); // tak
    System.out.println(decryptString(340, 25523)); // Wrong Password
    //a(decryptString(342, -8945));
  }

  private static void a(String var0) {
    if (!var0.equals(decryptString(341, -24830))) {
      throw new RuntimeException(decryptString(340, 25523));
    }
  }

  // $VF: Irreducible bytecode was duplicated to produce valid code
  // Cleaned up redundant code
  static {
    String[] decodedStrings = new String[3];
    int decodedIndex = 0;
    // This long string contains all obfuscated strings
    String obfuscatedStrings = "\nÂ´jjx\u001ffÃT|N-Ã³Ã±\u0003Ã“\u000e\u0012\u0006\u0015Â¬DÂ¹p\u0082"; // Dynamic
    int obfuscatedLength = "\nÂ´jjx\u001ffÃT|N-Ã³Ã±\u0003Ã“\u000e\u0012\u0006\u0015Â¬DÂ¹p\u0082".length(); // Dynamic
    char substringLength = 14; // Dynamic
    int currentIndex = -1;

    while (true) {
      String substring = obfuscatedStrings.substring(++currentIndex, currentIndex + substringLength);
      //System.out.println("current index: "+currentIndex);
      //System.out.println("substring length: "+(int)substringLength);
      char[] charArray = substring.toCharArray();
      //System.out.println(Arrays.toString(charArray));
      /*label38:*/ //{
        //charArray
        //int arrayLength = charArray.length;
        //int charIndex = 0;
        //charArray = tempCharArray;
        //char[] tempArray;
        //int tempIndex;
        /*if (arrayLength <= 1) {
          tempArray = tempCharArray;
          tempIndex = charIndex;
        } else {
          charArray = tempCharArray;
          tempArrayLength = arrayLength;
          if (arrayLength <= charIndex) {
            break label38;
          }*/

          //tempArray = tempCharArray;
          //tempIndex = charIndex;
        //}

      // XOR char array
      for (int i = 0; i < charArray.length; i++) {
        // Dynamic start
        charArray[i] = (char) (charArray[i] ^ switch (i % 7) {
          case 0 -> 116;
          case 1 -> 31;
          case 2 -> 119;
          case 3 -> 77;
          case 4 -> 62;
          case 5 -> 120;
          default -> 117;
        });
        // Dynamic end
        //charIndex++;
      }

          //tempArray = charArray;
          //tempIndex = charIndex;

      //}

      String decodedString = new String(charArray).intern();
      //System.out.println(decodedString);
      //byte var14 = -1;
      decodedStrings[decodedIndex++] = decodedString;
      if ((currentIndex += substringLength) >= obfuscatedLength) {
        break; // return;
      }

      substringLength = obfuscatedStrings.charAt(currentIndex);
    }
    staticObfuscatedStrings = decodedStrings;
    stringsCache = new String[3];

    // Entrypoint (clinit execution)
  }

  private static String decryptString(int key1, int key2) {
    // 340 - Dynamic mask
    int index = (key1 ^ 340) & 65535;
    //System.out.println(index);

    if (stringsCache[index] == null) {
      char[] obfuscatedChars = staticObfuscatedStrings[index].toCharArray();

      // Dynamic start
      // Determine the initial key based on the first character of the obfuscated string
      short initialKey = switch (obfuscatedChars[0] & 0xFF) {
        case 0 -> 242;
        case 1 -> 171;
        case 2 -> 94;
        case 3 -> 179;
        case 4 -> 15;
        case 5 -> 170;
        case 6 -> 103;
        case 7 -> 245;
        case 8 -> 176;
        case 9 -> 173;
        case 10 -> 80;
        case 11 -> 95;
        case 12 -> 249;
        case 13 -> 190;
        case 14 -> 81;
        case 15 -> 231;
        case 16 -> 104;
        case 17 -> 197;
        case 18 -> 168;
        case 19 -> 125;
        case 20 -> 172;
        case 21 -> 35;
        case 22 -> 131;
        case 23 -> 4;
        case 24 -> 91;
        case 25 -> 3;
        case 26 -> 203;
        case 27 -> 237;
        case 28 -> 2;
        case 29 -> 20;
        case 30 -> 18;
        case 31 -> 130;
        case 32 -> 89;
        case 33 -> 65;
        case 34 -> 25;
        case 35 -> 19;
        case 36 -> 30;
        case 37 -> 127;
        case 38 -> 68;
        case 39 -> 182;
        case 40 -> 152;
        case 41 -> 225;
        case 42 -> 7;
        case 43 -> 189;
        case 44 -> 191;
        case 45 -> 139;
        case 46 -> 14;
        case 47 -> 240;
        case 48 -> 207;
        case 49 -> 110;
        case 50 -> 6;
        case 51 -> 210;
        case 52 -> 159;
        case 53 -> 185;
        case 54 -> 48;
        case 55 -> 105;
        case 56 -> 236;
        case 57 -> 144;
        case 58 -> 77;
        case 59 -> 49;
        case 60 -> 8;
        case 61 -> 165;
        case 62 -> 108;
        case 63 -> 150;
        case 64 -> 187;
        case 65 -> 157;
        case 66 -> 143;
        case 67 -> 86;
        case 68 -> 78;
        case 69 -> 116;
        case 70 -> 118;
        case 71 -> 193;
        case 72 -> 164;
        case 73 -> 166;
        case 74 -> 9;
        case 75 -> 43;
        case 76 -> 59;
        case 77 -> 75;
        case 78 -> 251;
        case 79 -> 137;
        case 80 -> 38;
        case 81 -> 60;
        case 82 -> 63;
        case 83 -> 11;
        case 84 -> 149;
        case 85 -> 220;
        case 86 -> 31;
        case 87 -> 167;
        case 88 -> 98;
        case 89 -> 113;
        case 90 -> 109;
        case 91 -> 232;
        case 92 -> 204;
        case 93 -> 51;
        case 94 -> 129;
        case 95 -> 194;
        case 96 -> 45;
        case 97 -> 254;
        case 98 -> 134;
        case 99 -> 153;
        case 100 -> 122;
        case 101 -> 184;
        case 102 -> 228;
        case 103 -> 243;
        case 104 -> 227;
        case 105 -> 23;
        case 106 -> 74;
        case 107 -> 135;
        case 108 -> 120;
        case 109 -> 252;
        case 110 -> 148;
        case 111 -> 71;
        case 112 -> 124;
        case 113 -> 39;
        case 114 -> 205;
        case 115 -> 136;
        case 116 -> 132;
        case 117 -> 112;
        case 118 -> 223;
        case 119 -> 57;
        case 120 -> 58;
        case 121 -> 10;
        case 122 -> 253;
        case 123 -> 235;
        case 124 -> 111;
        case 125 -> 158;
        case 126 -> 138;
        case 127 -> 209;
        case 128 -> 222;
        case 129 -> 140;
        case 130 -> 34;
        case 131 -> 53;
        case 132 -> 229;
        case 133 -> 208;
        case 134 -> 177;
        case 135 -> 83;
        case 136 -> 5;
        case 137 -> 27;
        case 138 -> 73;
        case 139 -> 56;
        case 140 -> 255;
        case 141 -> 248;
        case 142 -> 29;
        case 143 -> 214;
        case 144 -> 37;
        case 145 -> 92;
        case 146 -> 145;
        case 147 -> 115;
        case 148 -> 0;
        case 149 -> 36;
        case 150 -> 85;
        case 151 -> 44;
        case 152 -> 133;
        case 153 -> 160;
        case 154 -> 52;
        case 155 -> 154;
        case 156 -> 226;
        case 157 -> 234;
        case 158 -> 54;
        case 159 -> 87;
        case 160 -> 186;
        case 161 -> 100;
        case 162 -> 64;
        case 163 -> 216;
        case 164 -> 17;
        case 165 -> 22;
        case 166 -> 102;
        case 167 -> 47;
        case 168 -> 247;
        case 169 -> 217;
        case 170 -> 219;
        case 171 -> 24;
        case 172 -> 147;
        case 173 -> 1;
        case 174 -> 192;
        case 175 -> 21;
        case 176 -> 128;
        case 177 -> 46;
        case 178 -> 66;
        case 179 -> 163;
        case 180 -> 146;
        case 181 -> 93;
        case 182 -> 180;
        case 183 -> 62;
        case 184 -> 230;
        case 185 -> 114;
        case 186 -> 79;
        case 187 -> 211;
        case 188 -> 183;
        case 189 -> 126;
        case 190 -> 61;
        case 191 -> 67;
        case 192 -> 26;
        case 193 -> 156;
        case 194 -> 198;
        case 195 -> 40;
        case 196 -> 32;
        case 197 -> 212;
        case 198 -> 195;
        case 199 -> 99;
        case 200 -> 88;
        case 201 -> 50;
        case 202 -> 28;
        case 203 -> 175;
        case 204 -> 101;
        case 205 -> 107;
        case 206 -> 250;
        case 207 -> 201;
        case 208 -> 141;
        case 209 -> 239;
        case 210 -> 169;
        case 211 -> 96;
        case 212 -> 117;
        case 213 -> 196;
        case 214 -> 178;
        case 215 -> 16;
        case 216 -> 221;
        case 217 -> 12;
        case 218 -> 181;
        case 219 -> 13;
        case 220 -> 174;
        case 221 -> 233;
        case 222 -> 224;
        case 223 -> 155;
        case 224 -> 218;
        case 225 -> 76;
        case 226 -> 215;
        case 227 -> 246;
        case 228 -> 90;
        case 229 -> 142;
        case 230 -> 106;
        case 231 -> 121;
        case 232 -> 238;
        case 233 -> 69;
        case 234 -> 82;
        case 235 -> 33;
        case 236 -> 241;
        case 237 -> 162;
        case 238 -> 84;
        case 239 -> 119;
        case 240 -> 161;
        case 241 -> 55;
        case 242 -> 244;
        case 243 -> 188;
        case 244 -> 41;
        case 245 -> 213;
        case 246 -> 151;
        case 247 -> 72;
        case 248 -> 70;
        case 249 -> 123;
        case 250 -> 42;
        case 251 -> 206;
        case 252 -> 202;
        case 253 -> 199;
        case 254 -> 97;
        default -> 200;
      };
      // Dynamic end

      // Calculate the first part of the decryption key
      int keyPart1 = (key2 & 0xFF) - initialKey;
      if (keyPart1 < 0) {
        keyPart1 += 256;
      }

      // Calculate the second part of the decryption key
      int keyPart2 = ((key2 & 65535) >>> 8) - initialKey;
      if (keyPart2 < 0) {
        keyPart2 += 256;
      }

      // Decrypt the obfuscated characters using the calculated keys
      for (int i = 0; i < obfuscatedChars.length; i++) {
        int keySelector = i % 2;
        char currentChar = obfuscatedChars[i];

        // Use keyPart1 or keyPart2 based on the keySelector
        if (keySelector == 0) {
          obfuscatedChars[i] = (char)(currentChar ^ keyPart1);
          keyPart1 = ((keyPart1 >>> 3 | keyPart1 << 5) ^ obfuscatedChars[i]) & 0xFF;
        } else {
          obfuscatedChars[i] = (char)(currentChar ^ keyPart2);
          keyPart2 = ((keyPart2 >>> 3 | keyPart2 << 5) ^ obfuscatedChars[i]) & 0xFF;
        }
      }

      // Cache the decrypted string
      stringsCache[index] = new String(obfuscatedChars).intern();
    }

    return stringsCache[index];
  }
}

```

`reverse-engineering/src/main/java/zelix/enhancedstringenc/SomeStrings2.java`:

```java
package zelix.enhancedstringenc;

/**
 * This is just a very similar class to {@link SomeStrings} but with different strings. It exists here to compare two classes.
 */
public class SomeStrings2 {
  private static final String[] a;
  private static final String[] b;

  public static void main(String[] var0) {
    System.out.println(a(27040, -3854));
    System.out.println(a(27041, 8907));
  }

  // $VF: Irreducible bytecode was duplicated to produce valid code
  static {
    String[] var5 = new String[2];
    int var3 = 0;
    String var2 = "Âº\u009bÃ¦Â½W\u0006x%\\!Ã–I";
    int var4 = "Âº\u009bÃ¦Â½W\u0006x%\\!Ã–I".length();
    char var1 = 5;
    int var0 = -1;

    while (true) {
      char[] var16;
      label38: {
        char[] var10001 = var2.substring(++var0, var0 + var1).toCharArray();
        int var10003 = var10001.length;
        int var6 = 0;
        var16 = var10001;
        int var10 = var10003;
        char[] var23;
        int var10004;
        if (var10003 <= 1) {
          var23 = var10001;
          var10004 = var6;
        } else {
          var16 = var10001;
          var10 = var10003;
          if (var10003 <= var6) {
            break label38;
          }

          var23 = var10001;
          var10004 = var6;
        }

        while (true) {
          var23[var10004] = (char)(var23[var10004] ^ switch (var6 % 7) {
            case 0 -> 37;
            case 1 -> 43;
            case 2 -> 56;
            case 3 -> 14;
            case 4 -> 2;
            case 5 -> 108;
            default -> 14;
          });
          var6++;
          if (var10 == 0) {
            var10004 = var10;
            var23 = var16;
          } else {
            if (var10 <= var6) {
              break;
            }

            var23 = var16;
            var10004 = var6;
          }
        }
      }

      String var30 = new String(var16).intern();
      byte var14 = -1;
      var5[var3++] = var30;
      if ((var0 += var1) >= var4) {
        a = var5;
        b = new String[2];
        break;
      }

      var1 = var2.charAt(var0);
    }
  }

  private static String a(int var0, int var1) {
    int var2 = (var0 ^ 27040) & 65535;
    if (b[var2] == null) {
      char[] var3 = a[var2].toCharArray();

      short var4 = switch (var3[0] & 0xFF) {
        case 0 -> 101;
        case 1 -> 243;
        case 2 -> 232;
        case 3 -> 26;
        case 4 -> 83;
        case 5 -> 33;
        case 6 -> 106;
        case 7 -> 211;
        case 8 -> 217;
        case 9 -> 10;
        case 10 -> 113;
        case 11 -> 188;
        case 12 -> 52;
        case 13 -> 25;
        case 14 -> 87;
        case 15 -> 196;
        case 16 -> 182;
        case 17 -> 15;
        case 18 -> 191;
        case 19 -> 93;
        case 20 -> 143;
        case 21 -> 112;
        case 22 -> 71;
        case 23 -> 183;
        case 24 -> 35;
        case 25 -> 205;
        case 26 -> 178;
        case 27 -> 138;
        case 28 -> 224;
        case 29 -> 173;
        case 30 -> 126;
        case 31 -> 132;
        case 32 -> 17;
        case 33 -> 46;
        case 34 -> 47;
        case 35 -> 189;
        case 36 -> 19;
        case 37 -> 45;
        case 38 -> 97;
        case 39 -> 120;
        case 40 -> 69;
        case 41 -> 63;
        case 42 -> 20;
        case 43 -> 167;
        case 44 -> 92;
        case 45 -> 104;
        case 46 -> 61;
        case 47 -> 117;
        case 48 -> 213;
        case 49 -> 230;
        case 50 -> 212;
        case 51 -> 174;
        case 52 -> 255;
        case 53 -> 107;
        case 54 -> 13;
        case 55 -> 170;
        case 56 -> 242;
        case 57 -> 109;
        case 58 -> 80;
        case 59 -> 198;
        case 60 -> 12;
        case 61 -> 246;
        case 62 -> 114;
        case 63 -> 180;
        case 64 -> 252;
        case 65 -> 94;
        case 66 -> 184;
        case 67 -> 30;
        case 68 -> 89;
        case 69 -> 192;
        case 70 -> 201;
        case 71 -> 73;
        case 72 -> 135;
        case 73 -> 238;
        case 74 -> 203;
        case 75 -> 66;
        case 76 -> 78;
        case 77 -> 239;
        case 78 -> 37;
        case 79 -> 137;
        case 80 -> 228;
        case 81 -> 153;
        case 82 -> 234;
        case 83 -> 160;
        case 84 -> 77;
        case 85 -> 240;
        case 86 -> 58;
        case 87 -> 5;
        case 88 -> 187;
        case 89 -> 133;
        case 90 -> 115;
        case 91 -> 145;
        case 92 -> 65;
        case 93 -> 193;
        case 94 -> 172;
        case 95 -> 241;
        case 96 -> 1;
        case 97 -> 144;
        case 98 -> 175;
        case 99 -> 186;
        case 100 -> 185;
        case 101 -> 200;
        case 102 -> 194;
        case 103 -> 208;
        case 104 -> 219;
        case 105 -> 171;
        case 106 -> 72;
        case 107 -> 152;
        case 108 -> 123;
        case 109 -> 122;
        case 110 -> 39;
        case 111 -> 149;
        case 112 -> 56;
        case 113 -> 90;
        case 114 -> 79;
        case 115 -> 134;
        case 116 -> 195;
        case 117 -> 141;
        case 118 -> 197;
        case 119 -> 74;
        case 120 -> 28;
        case 121 -> 210;
        case 122 -> 158;
        case 123 -> 164;
        case 124 -> 150;
        case 125 -> 105;
        case 126 -> 250;
        case 127 -> 3;
        case 128 -> 146;
        case 129 -> 24;
        case 130 -> 225;
        case 131 -> 127;
        case 132 -> 131;
        case 133 -> 177;
        case 134 -> 68;
        case 135 -> 75;
        case 136 -> 128;
        case 137 -> 202;
        case 138 -> 236;
        case 139 -> 165;
        case 140 -> 95;
        case 141 -> 156;
        case 142 -> 18;
        case 143 -> 116;
        case 144 -> 84;
        case 145 -> 155;
        case 146 -> 22;
        case 147 -> 29;
        case 148 -> 179;
        case 149 -> 0;
        case 150 -> 103;
        case 151 -> 43;
        case 152 -> 99;
        case 153 -> 204;
        case 154 -> 229;
        case 155 -> 54;
        case 156 -> 9;
        case 157 -> 130;
        case 158 -> 32;
        case 159 -> 27;
        case 160 -> 162;
        case 161 -> 119;
        case 162 -> 31;
        case 163 -> 38;
        case 164 -> 118;
        case 165 -> 36;
        case 166 -> 48;
        case 167 -> 4;
        case 168 -> 235;
        case 169 -> 253;
        case 170 -> 67;
        case 171 -> 86;
        case 172 -> 44;
        case 173 -> 216;
        case 174 -> 139;
        case 175 -> 209;
        case 176 -> 154;
        case 177 -> 166;
        case 178 -> 82;
        case 179 -> 129;
        case 180 -> 233;
        case 181 -> 140;
        case 182 -> 108;
        case 183 -> 59;
        case 184 -> 163;
        case 185 -> 96;
        case 186 -> 226;
        case 187 -> 53;
        case 188 -> 2;
        case 189 -> 227;
        case 190 -> 223;
        case 191 -> 111;
        case 192 -> 124;
        case 193 -> 6;
        case 194 -> 215;
        case 195 -> 40;
        case 196 -> 142;
        case 197 -> 231;
        case 198 -> 60;
        case 199 -> 181;
        case 200 -> 102;
        case 201 -> 206;
        case 202 -> 125;
        case 203 -> 214;
        case 204 -> 251;
        case 205 -> 49;
        case 206 -> 249;
        case 207 -> 16;
        case 208 -> 23;
        case 209 -> 207;
        case 210 -> 237;
        case 211 -> 62;
        case 212 -> 34;
        case 213 -> 169;
        case 214 -> 218;
        case 215 -> 21;
        case 216 -> 148;
        case 217 -> 159;
        case 218 -> 81;
        case 219 -> 168;
        case 220 -> 248;
        case 221 -> 151;
        case 222 -> 11;
        case 223 -> 147;
        case 224 -> 7;
        case 225 -> 221;
        case 226 -> 254;
        case 227 -> 136;
        case 228 -> 100;
        case 229 -> 98;
        case 230 -> 14;
        case 231 -> 247;
        case 232 -> 161;
        case 233 -> 85;
        case 234 -> 220;
        case 235 -> 50;
        case 236 -> 70;
        case 237 -> 244;
        case 238 -> 91;
        case 239 -> 55;
        case 240 -> 176;
        case 241 -> 199;
        case 242 -> 245;
        case 243 -> 64;
        case 244 -> 121;
        case 245 -> 76;
        case 246 -> 8;
        case 247 -> 51;
        case 248 -> 42;
        case 249 -> 57;
        case 250 -> 88;
        case 251 -> 222;
        case 252 -> 190;
        case 253 -> 157;
        case 254 -> 41;
        default -> 110;
      };
      int var5 = (var1 & 0xFF) - var4;
      if (var5 < 0) {
        var5 += 256;
      }

      int var6 = ((var1 & 65535) >>> 8) - var4;
      if (var6 < 0) {
        var6 += 256;
      }

      for (int var7 = 0; var7 < var3.length; var7++) {
        int var8 = var7 % 2;
        char var10002 = var3[var7];
        if (var8 == 0) {
          var3[var7] = (char)(var10002 ^ var5);
          var5 = ((var5 >>> 3 | var5 << 5) ^ var3[var7]) & 0xFF;
        } else {
          var3[var7] = (char)(var10002 ^ var6);
          var6 = ((var6 >>> 3 | var6 << 5) ^ var3[var7]) & 0xFF;
        }
      }

      b[var2] = new String(var3).intern();
    }

    return b[var2];
  }
}

```

`reverse-engineering/src/main/java/zelix/longdecrypter/FallbackLongDecrypter.java`:

```java
package zelix.longdecrypter;

import java.util.concurrent.ConcurrentHashMap;

/**
 * Decrypter that uses shared {@link SimpleLongDecrypter#mutableEncryptionInts}. This decrypter is only used when it
 * cannot find registered decryption for given numbers.
 * {@link FallbackLongDecrypter#decrypt(long)} is never called in untouched jar obfuscated using zelix. When
 * {@link FallbackLongDecrypter#decrypt(long)} is called (which is an error) then it intentionally breaks every other
 * decrypter, by overriding their {@link SimpleLongDecrypter#getEncryptionInts()}, making them unusable.
 * <p>
 * This decrypter only exists here to make it harder to deobfuscate the jar and to confuse people that try to deobfuscate it.
 */
public class FallbackLongDecrypter implements ILongDecrypter {
  private static boolean e;
  private static FallbackLongDecrypter INSTANCE = new FallbackLongDecrypter();
  private ConcurrentHashMap<ILongDecrypter, ILongDecrypter> decrypterToDecrypterMap = new ConcurrentHashMap<>();
  private ILongDecrypter child;
  private int[] encryptionInts;
  private long key;

  public FallbackLongDecrypter() {
    this.initCachedDecryptersMap();
    this.encryptionInts = new int[64];
    this.encryptionInts[0] = -47;
    this.encryptionInts[1] = -37;
    this.encryptionInts[2] = -2;
    this.encryptionInts[3] = -48;
    this.encryptionInts[4] = 2;
    this.encryptionInts[5] = -45;
    this.encryptionInts[6] = -54;
    this.encryptionInts[7] = -50;
    this.encryptionInts[8] = -23;
    this.encryptionInts[9] = -12;
    this.encryptionInts[10] = -35;
    this.encryptionInts[11] = -4;
    this.encryptionInts[12] = -28;
    this.encryptionInts[13] = -42;
    this.encryptionInts[14] = -12;
    this.encryptionInts[15] = 4;
    this.encryptionInts[16] = -7;
    this.encryptionInts[17] = -26;
    this.encryptionInts[18] = -44;
    this.encryptionInts[19] = -14;
    this.encryptionInts[20] = -36;
    this.encryptionInts[21] = 12;
    this.encryptionInts[22] = -32;
    this.encryptionInts[23] = 7;
    this.encryptionInts[24] = -12;
    this.encryptionInts[25] = -4;
    this.encryptionInts[26] = 12;
    this.encryptionInts[27] = -3;
    this.encryptionInts[28] = -30;
    this.encryptionInts[29] = 4;
    this.encryptionInts[30] = 3;
    this.encryptionInts[31] = 23;
    this.encryptionInts[32] = -3;
    this.encryptionInts[33] = 14;
    this.encryptionInts[34] = -29;
    this.encryptionInts[35] = 3;
    this.encryptionInts[36] = 12;
    this.encryptionInts[37] = -7;
    this.encryptionInts[38] = 37;
    this.encryptionInts[39] = -10;
    this.encryptionInts[40] = 28;
    this.encryptionInts[41] = -7;
    this.encryptionInts[42] = -11;
    this.encryptionInts[43] = 26;
    this.encryptionInts[44] = 7;
    this.encryptionInts[45] = 35;
    this.encryptionInts[46] = -6;
    this.encryptionInts[47] = 47;
    this.encryptionInts[48] = 7;
    this.encryptionInts[49] = 10;
    this.encryptionInts[50] = 45;
    this.encryptionInts[51] = 48;
    this.encryptionInts[52] = 6;
    this.encryptionInts[53] = 11;
    this.encryptionInts[54] = 32;
    this.encryptionInts[55] = 42;
    this.encryptionInts[56] = 36;
    this.encryptionInts[57] = 50;
    this.encryptionInts[58] = 30;
    this.encryptionInts[59] = -2;
    this.encryptionInts[60] = 54;
    this.encryptionInts[61] = 2;
    this.encryptionInts[62] = 44;
    this.encryptionInts[63] = 29;
    SimpleLongDecrypter.initSharedDecrypter(this);
  }

  static void a(boolean var0) {
    e = var0;
  }

  static ILongDecrypter getPairStatic(ILongDecrypter key, ILongDecrypter value) {
    return INSTANCE.getPair(key, value);
  }

  private ILongDecrypter getPair(ILongDecrypter key, ILongDecrypter value) {
    System.out.println("key: "+key);
    Object result = this.decrypterToDecrypterMap.get(key);
    if (result == null) {
      result = this;
      //System.out.println("Not cached");
    } else {
      //System.out.println("Used cache");
    }

    System.out.println("put: "+value+" -> "+key);
    Object var4 = this.decrypterToDecrypterMap.put(value, key);
    return (ILongDecrypter)result;
  }

  void init() {
    this.setupEncryptionInts();
    SimpleLongDecrypter.initEncryptionData(this);
  }

  void prepareCachedDecrypters() {
    this.setChildrenForDecrypters();
  }

  @Override
  public void setChild(ILongDecrypter child) {
    if (this != child) {
      if (this.child == null) {
        this.child = child;
      } else {
        this.child.setChild(child);
      }
    }
  }

  @Override
  public long decrypt(long decryptKey) {
    ILongDecrypter longDecrypter = SimpleLongDecrypter.getCachedDecrypter(decryptKey);
    long value = longDecrypter.decrypt(decryptKey);

    // Update long decrypter's encryption ints with our own array
    // This effectively modifies the state of SimpleLongDecrypter
    int[] encryptionInts = longDecrypter.getEncryptionInts();
    System.arraycopy(this.encryptionInts, 0, encryptionInts, 0, 64);

    if (this.child != null) {
      this.child.decrypt(decryptKey);
    }

    return value;
  }

  @Override
  public int[] getEncryptionInts() {
    return SimpleLongDecrypter.mutableEncryptionInts;
  }

  // Unused
  @Override
  public boolean lessThanOrEqual(ILongDecrypter other) {
    if (this == other) {
      return true;
    } else {
      return other instanceof FallbackLongDecrypter ? System.identityHashCode(this) - System.identityHashCode(other) <= 0 : false;
    }
  }

  @Override
  public void setKey(long key) {
    this.key = key;
  }

  private void initCachedDecryptersMap() {
    ConcurrentHashMap<ILongDecrypter, ILongDecrypter> var10000 = this.decrypterToDecrypterMap;
    this.decrypterToDecrypterMap.put(SimpleLongDecrypter.getCachedDecrypter(-1986416091109256469L), SimpleLongDecrypter.getCachedDecrypter(-3059166788854042651L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6920982444000201384L), SimpleLongDecrypter.getCachedDecrypter(1502142890550895894L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-287693565063644781L), SimpleLongDecrypter.getCachedDecrypter(6918793201750776901L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-458912916494629938L), SimpleLongDecrypter.getCachedDecrypter(5863594772594630018L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4074822491960867241L), SimpleLongDecrypter.getCachedDecrypter(2105670753694342612L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(959978680119219899L), SimpleLongDecrypter.getCachedDecrypter(5847567693026368449L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5779323504258784073L), SimpleLongDecrypter.getCachedDecrypter(-1058989732404172907L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4033266620404474058L), SimpleLongDecrypter.getCachedDecrypter(-5146050006772315680L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3745185180108532409L), SimpleLongDecrypter.getCachedDecrypter(-8220449341766149921L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7906899774795397262L), SimpleLongDecrypter.getCachedDecrypter(-485213178055450227L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5307135347845555143L), SimpleLongDecrypter.getCachedDecrypter(316092335528197106L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1037347408094146583L), SimpleLongDecrypter.getCachedDecrypter(6105454837132386951L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6556669306231050068L), SimpleLongDecrypter.getCachedDecrypter(90013165418731139L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2840189856866554324L), SimpleLongDecrypter.getCachedDecrypter(5319882638750678593L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6575430992262218251L), SimpleLongDecrypter.getCachedDecrypter(-8216525300395158383L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2406248529132448077L), SimpleLongDecrypter.getCachedDecrypter(3276011903675299950L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5287646012352263875L), SimpleLongDecrypter.getCachedDecrypter(-3944757197390805694L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4096728984916145431L), SimpleLongDecrypter.getCachedDecrypter(-1597678014114441018L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6873600760421070333L), SimpleLongDecrypter.getCachedDecrypter(-5758649873308582376L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8533856970645599186L), SimpleLongDecrypter.getCachedDecrypter(7512411064658545368L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6449473114346810785L), SimpleLongDecrypter.getCachedDecrypter(-1401818488487131118L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3148966477615345941L), SimpleLongDecrypter.getCachedDecrypter(979436940229788763L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4070492533627884182L), SimpleLongDecrypter.getCachedDecrypter(-8225900608387630771L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8932642830225366980L), SimpleLongDecrypter.getCachedDecrypter(-4857712906395309440L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(613811845475938723L), SimpleLongDecrypter.getCachedDecrypter(6446393157965702307L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4372224277806209824L), SimpleLongDecrypter.getCachedDecrypter(-7448691860841767344L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4086677762671742416L), SimpleLongDecrypter.getCachedDecrypter(6936070293451539301L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5911032427228622064L), SimpleLongDecrypter.getCachedDecrypter(4746564250933093252L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2561465566664046462L), SimpleLongDecrypter.getCachedDecrypter(-6534630883339696717L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9052942315196205479L), SimpleLongDecrypter.getCachedDecrypter(-1715257455839901369L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3910884879902596192L), SimpleLongDecrypter.getCachedDecrypter(95497893363974849L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4795903473016158574L), SimpleLongDecrypter.getCachedDecrypter(627778304642993702L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6327647821487709124L), SimpleLongDecrypter.getCachedDecrypter(1158118967382568374L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4298173472291467369L), SimpleLongDecrypter.getCachedDecrypter(-8905917217017034898L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6550041211142933579L), SimpleLongDecrypter.getCachedDecrypter(-5943772596146400334L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-765959740845257943L), SimpleLongDecrypter.getCachedDecrypter(-1101870134195519254L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5629454399823173274L), SimpleLongDecrypter.getCachedDecrypter(-3356316483103340058L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-266451600674873302L), SimpleLongDecrypter.getCachedDecrypter(-6319649386837741034L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3152762654813314490L), SimpleLongDecrypter.getCachedDecrypter(-5449876397578030429L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2194087465120208387L), SimpleLongDecrypter.getCachedDecrypter(-6898133555370385272L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(113277574090118205L), SimpleLongDecrypter.getCachedDecrypter(381951238395070403L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3541123465801158029L), SimpleLongDecrypter.getCachedDecrypter(-5722162613367820418L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9061312626457130616L), SimpleLongDecrypter.getCachedDecrypter(1779263460277172729L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5334037756471346292L), SimpleLongDecrypter.getCachedDecrypter(4434666850092175488L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2071693639275863605L), SimpleLongDecrypter.getCachedDecrypter(-6321650278900505065L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3052757996326430601L), SimpleLongDecrypter.getCachedDecrypter(7636498607107252304L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2764642559863078952L), SimpleLongDecrypter.getCachedDecrypter(7874468307973213683L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-757688652838960085L), SimpleLongDecrypter.getCachedDecrypter(8431119858190369941L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2781501505383978045L), SimpleLongDecrypter.getCachedDecrypter(-6249052947989494668L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7210660166972221461L), SimpleLongDecrypter.getCachedDecrypter(5556543494131064257L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5017621479488976779L), SimpleLongDecrypter.getCachedDecrypter(-5946338443679534808L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8901872600361898941L), SimpleLongDecrypter.getCachedDecrypter(2903076651694454812L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2220357651577134934L), SimpleLongDecrypter.getCachedDecrypter(-8641107989337930719L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6772442765306243480L), SimpleLongDecrypter.getCachedDecrypter(-3992553879568065108L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5577145109809299507L), SimpleLongDecrypter.getCachedDecrypter(884367853506451505L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4896962154554857259L), SimpleLongDecrypter.getCachedDecrypter(-5711721979399085474L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2284168892885967857L), SimpleLongDecrypter.getCachedDecrypter(136401745214457453L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2188166367672492792L), SimpleLongDecrypter.getCachedDecrypter(1493603206514373463L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6203719015280650887L), SimpleLongDecrypter.getCachedDecrypter(-848557752568873008L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2427774537877502563L), SimpleLongDecrypter.getCachedDecrypter(6933805961999359820L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4729897799036936825L), SimpleLongDecrypter.getCachedDecrypter(-5652275630224481051L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7539003542365874134L), SimpleLongDecrypter.getCachedDecrypter(3804603338895916462L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6945293954517698056L), SimpleLongDecrypter.getCachedDecrypter(4107211023701178855L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7670747672225799494L), SimpleLongDecrypter.getCachedDecrypter(2607506495773903483L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6662361721171447392L), SimpleLongDecrypter.getCachedDecrypter(-6832705165918441731L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2263072771391433412L), SimpleLongDecrypter.getCachedDecrypter(-7779500624029721705L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1590841055503294028L), SimpleLongDecrypter.getCachedDecrypter(-7194743878133107428L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1270933948645597017L), SimpleLongDecrypter.getCachedDecrypter(7605738971359475590L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3997531565804855859L), SimpleLongDecrypter.getCachedDecrypter(-8307851924525407131L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7833224161343017824L), SimpleLongDecrypter.getCachedDecrypter(2072005988800624320L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1602268489837685215L), SimpleLongDecrypter.getCachedDecrypter(-1014946931091788216L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2057782750328802040L), SimpleLongDecrypter.getCachedDecrypter(-5704253349698956943L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3587762441364646195L), SimpleLongDecrypter.getCachedDecrypter(4914970621108341600L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8489237013067928376L), SimpleLongDecrypter.getCachedDecrypter(1534088641706480502L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1515546851908191787L), SimpleLongDecrypter.getCachedDecrypter(-1588458697964406892L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1851155936305434067L), SimpleLongDecrypter.getCachedDecrypter(8414650931027805168L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7041328398955029177L), SimpleLongDecrypter.getCachedDecrypter(-3943028264093306708L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1635699581028065367L), SimpleLongDecrypter.getCachedDecrypter(6955127348504138027L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6676896237662643946L), SimpleLongDecrypter.getCachedDecrypter(6120749559517389669L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8763945315791641795L), SimpleLongDecrypter.getCachedDecrypter(7299520050749001064L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3699383514083040537L), SimpleLongDecrypter.getCachedDecrypter(-2200266768229069439L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4379642046480619337L), SimpleLongDecrypter.getCachedDecrypter(3885077209634005918L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8549308585340088438L), SimpleLongDecrypter.getCachedDecrypter(-4525546783531838738L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5136348972601537923L), this);
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2043406722489770281L), SimpleLongDecrypter.getCachedDecrypter(-4788524663131450536L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2279733311605992532L), SimpleLongDecrypter.getCachedDecrypter(8391783631609711381L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8134275136228235264L), SimpleLongDecrypter.getCachedDecrypter(5906784049220193084L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8372623318218744371L), SimpleLongDecrypter.getCachedDecrypter(4135432760822577737L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2457716384756211607L), SimpleLongDecrypter.getCachedDecrypter(-3351180828161003368L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4868959217466863033L), SimpleLongDecrypter.getCachedDecrypter(-7734884993792450155L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7228785725715030226L), SimpleLongDecrypter.getCachedDecrypter(-2460711654545998130L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4678810986061828285L), SimpleLongDecrypter.getCachedDecrypter(-5945426860617490137L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5596749052371630687L), SimpleLongDecrypter.getCachedDecrypter(2310424126601823384L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(661909517148127452L), SimpleLongDecrypter.getCachedDecrypter(-7988421617240798351L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1220102509552993558L), SimpleLongDecrypter.getCachedDecrypter(4653929683838060129L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7629008540892765309L), SimpleLongDecrypter.getCachedDecrypter(-8535189180439540550L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8844649047648619377L), SimpleLongDecrypter.getCachedDecrypter(-4846255648524561974L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4899655788421965785L), SimpleLongDecrypter.getCachedDecrypter(6987724228389289086L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8642022059205502660L), SimpleLongDecrypter.getCachedDecrypter(-8241830452793914048L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4730690686541329026L), SimpleLongDecrypter.getCachedDecrypter(5812087815026598844L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6849591046257818588L), SimpleLongDecrypter.getCachedDecrypter(7022438833107637227L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7120303310061228174L), SimpleLongDecrypter.getCachedDecrypter(-5045767810669300106L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3589056781703594341L), SimpleLongDecrypter.getCachedDecrypter(-7746577810766325978L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3691244458241766240L), SimpleLongDecrypter.getCachedDecrypter(8696955212032434771L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6783374136799069950L), SimpleLongDecrypter.getCachedDecrypter(-9164504345238193254L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4036092661302369475L), SimpleLongDecrypter.getCachedDecrypter(5277600869534084776L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2019333355680506647L), SimpleLongDecrypter.getCachedDecrypter(-3694344595356795099L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5072447823481113131L), SimpleLongDecrypter.getCachedDecrypter(706477987228533641L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3360071314170953540L), SimpleLongDecrypter.getCachedDecrypter(-7754079436543475675L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2145890329318324537L), SimpleLongDecrypter.getCachedDecrypter(3011839329347897911L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9121927751705477024L), SimpleLongDecrypter.getCachedDecrypter(8429353085580438717L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(304269284705821330L), SimpleLongDecrypter.getCachedDecrypter(1529823172802193626L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3587490384654127492L), SimpleLongDecrypter.getCachedDecrypter(8214398120729716728L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4255507460876481401L), SimpleLongDecrypter.getCachedDecrypter(2975234674882658445L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8763697291602240547L), SimpleLongDecrypter.getCachedDecrypter(610030248328152197L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8568463942911179208L), SimpleLongDecrypter.getCachedDecrypter(4987498095518624277L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3492760420596023592L), SimpleLongDecrypter.getCachedDecrypter(7282820256688013859L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1144287033634106159L), SimpleLongDecrypter.getCachedDecrypter(7524781730897500390L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7838570639395205213L), SimpleLongDecrypter.getCachedDecrypter(-6012892709473599248L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2272132145273189228L), SimpleLongDecrypter.getCachedDecrypter(7842014754227260002L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5676504380667643107L), SimpleLongDecrypter.getCachedDecrypter(1824495392943150321L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5023873729504475276L), SimpleLongDecrypter.getCachedDecrypter(6174898298449659147L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(339307853422226330L), SimpleLongDecrypter.getCachedDecrypter(4046340500072407177L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4670991423143278569L), SimpleLongDecrypter.getCachedDecrypter(137608147280951035L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7205942410578379130L), SimpleLongDecrypter.getCachedDecrypter(-3732683939784642372L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5820543313534781238L), SimpleLongDecrypter.getCachedDecrypter(8724728949486010654L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4542329462095617766L), SimpleLongDecrypter.getCachedDecrypter(-7200745740395412222L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4376269587338320535L), SimpleLongDecrypter.getCachedDecrypter(-8580865301667010639L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-493086870023779793L), SimpleLongDecrypter.getCachedDecrypter(5207770643373605233L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6269773939349014230L), SimpleLongDecrypter.getCachedDecrypter(8421473217932302534L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4010409925836264614L), SimpleLongDecrypter.getCachedDecrypter(8373354263531373904L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4546047052792055901L), SimpleLongDecrypter.getCachedDecrypter(-6278399730405336911L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6284565676249684441L), SimpleLongDecrypter.getCachedDecrypter(-5703022638269651043L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4982628833488094674L), SimpleLongDecrypter.getCachedDecrypter(-5945151282447435692L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6107467081261169994L), SimpleLongDecrypter.getCachedDecrypter(-8043226046251281719L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7321504444565377931L), SimpleLongDecrypter.getCachedDecrypter(5287907534740249420L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1524929632910422548L), SimpleLongDecrypter.getCachedDecrypter(2413224543021193504L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7744023984207809264L), SimpleLongDecrypter.getCachedDecrypter(-8248031799360177161L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7399547618208336499L), SimpleLongDecrypter.getCachedDecrypter(-6260728425221417206L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1808840443591547163L), SimpleLongDecrypter.getCachedDecrypter(9038733568219968526L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4927641048381990981L), SimpleLongDecrypter.getCachedDecrypter(-3128107694322188423L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6440037323966090089L), SimpleLongDecrypter.getCachedDecrypter(-7156948790279684504L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6702248853881433865L), SimpleLongDecrypter.getCachedDecrypter(-3378418735745111170L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(661948952224100106L), SimpleLongDecrypter.getCachedDecrypter(5900632736629437979L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4736200256431845731L), SimpleLongDecrypter.getCachedDecrypter(-1146818598540722375L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3743013051875184152L), SimpleLongDecrypter.getCachedDecrypter(8073475980802051925L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(83208821655898477L), SimpleLongDecrypter.getCachedDecrypter(-6236174305285514365L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-736381695806913133L), SimpleLongDecrypter.getCachedDecrypter(-1130679965239864840L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8466137165500933476L), SimpleLongDecrypter.getCachedDecrypter(3181403830166629096L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5377978246712879296L), SimpleLongDecrypter.getCachedDecrypter(-7649809353285285780L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(364818715671619056L), SimpleLongDecrypter.getCachedDecrypter(-7753376661691852493L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6116050039557398859L), SimpleLongDecrypter.getCachedDecrypter(-3612871415275240979L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6608651480983725416L), SimpleLongDecrypter.getCachedDecrypter(5220624081610830673L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2531369932321710358L), SimpleLongDecrypter.getCachedDecrypter(6770957041204362784L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(385158871454716980L), SimpleLongDecrypter.getCachedDecrypter(5193389589470841672L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1181471781776655964L), SimpleLongDecrypter.getCachedDecrypter(2923672309141886419L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1421322407309228933L), SimpleLongDecrypter.getCachedDecrypter(-4532644287730267790L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5897376005294042505L), SimpleLongDecrypter.getCachedDecrypter(2061190479432968616L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7134727476440637214L), SimpleLongDecrypter.getCachedDecrypter(-2560890491384652582L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5485342240572142566L), SimpleLongDecrypter.getCachedDecrypter(-4609671512480169104L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6179895083710068092L), SimpleLongDecrypter.getCachedDecrypter(8972697747220579684L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7245362760218859580L), SimpleLongDecrypter.getCachedDecrypter(3510398010351968735L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6165016240174298123L), SimpleLongDecrypter.getCachedDecrypter(-2001242842227574990L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1959713771009631369L), SimpleLongDecrypter.getCachedDecrypter(-831939294583380713L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7636057832186446723L), SimpleLongDecrypter.getCachedDecrypter(5222213145292224113L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8202396056909258693L), SimpleLongDecrypter.getCachedDecrypter(5043618972789482217L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8737664160110424061L), SimpleLongDecrypter.getCachedDecrypter(-2246847661962489950L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1556538056287073540L), SimpleLongDecrypter.getCachedDecrypter(-5178486087167549180L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4560689755942962401L), SimpleLongDecrypter.getCachedDecrypter(8706506427288997982L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7715439852530017067L), SimpleLongDecrypter.getCachedDecrypter(-2227336202774002633L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-250747443919715206L), SimpleLongDecrypter.getCachedDecrypter(2602643050843917966L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2402546272291220950L), SimpleLongDecrypter.getCachedDecrypter(8390350447953322097L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2729239783546683375L), SimpleLongDecrypter.getCachedDecrypter(-5046248560086064285L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(37645850315316989L), SimpleLongDecrypter.getCachedDecrypter(9016139601421746013L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5567725390399664632L), SimpleLongDecrypter.getCachedDecrypter(-7157608332373419735L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6942453922974449976L), SimpleLongDecrypter.getCachedDecrypter(-4893452845139109957L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7781239653639572880L), SimpleLongDecrypter.getCachedDecrypter(-5370512335852330606L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5375748156151954815L), SimpleLongDecrypter.getCachedDecrypter(-7726082147330546571L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7949636601977662136L), SimpleLongDecrypter.getCachedDecrypter(2672800623009191604L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6383930417493749682L), SimpleLongDecrypter.getCachedDecrypter(-8879122285082939309L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5126940363206370652L), SimpleLongDecrypter.getCachedDecrypter(7785907853882330008L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3533658288343208819L), SimpleLongDecrypter.getCachedDecrypter(-4246060702196633701L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8889218289575856441L), SimpleLongDecrypter.getCachedDecrypter(4652061526943924747L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7850102882511672357L), SimpleLongDecrypter.getCachedDecrypter(2945638573311670557L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(56301736052047660L), SimpleLongDecrypter.getCachedDecrypter(7861849567704128875L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8077634095869542890L), SimpleLongDecrypter.getCachedDecrypter(-5078948519639490155L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1779477549804199316L), SimpleLongDecrypter.getCachedDecrypter(3797129624514802351L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2732655374238301417L), SimpleLongDecrypter.getCachedDecrypter(2315356002873038061L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4427662554959714445L), SimpleLongDecrypter.getCachedDecrypter(8101815433056787397L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6493570400126197560L), SimpleLongDecrypter.getCachedDecrypter(3534242430824622594L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2775250514967388688L), SimpleLongDecrypter.getCachedDecrypter(4648704626418856385L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8032421794768590703L), SimpleLongDecrypter.getCachedDecrypter(1873484994923567612L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-254246267639709803L), SimpleLongDecrypter.getCachedDecrypter(9052839283960268257L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6384669817168732524L), SimpleLongDecrypter.getCachedDecrypter(5814573291418988007L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5467535408307629909L), SimpleLongDecrypter.getCachedDecrypter(6456948714488959351L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9084630688531254585L), SimpleLongDecrypter.getCachedDecrypter(8160418263926000683L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7744034531133669197L), SimpleLongDecrypter.getCachedDecrypter(3024470466463684294L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7753458018928994198L), SimpleLongDecrypter.getCachedDecrypter(3006341955424656018L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9064989897575046071L), SimpleLongDecrypter.getCachedDecrypter(5272086243777455247L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5594506641425853871L), SimpleLongDecrypter.getCachedDecrypter(294091228180613981L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(668981264244018218L), SimpleLongDecrypter.getCachedDecrypter(-2510843039958690183L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8222793466399334817L), SimpleLongDecrypter.getCachedDecrypter(-210286065138585472L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7501585616025335412L), SimpleLongDecrypter.getCachedDecrypter(-7198738356860688453L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3988074218583689232L), SimpleLongDecrypter.getCachedDecrypter(-210442442861576731L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4692621686185077919L), SimpleLongDecrypter.getCachedDecrypter(-8907865118524114591L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1547516317625778004L), SimpleLongDecrypter.getCachedDecrypter(5511334621724301863L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9064807233428649083L), SimpleLongDecrypter.getCachedDecrypter(5822852522116386376L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-828060573887178198L), SimpleLongDecrypter.getCachedDecrypter(4095961321723666346L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8976053937454215489L), SimpleLongDecrypter.getCachedDecrypter(5037788004919824928L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5190631826692878692L), SimpleLongDecrypter.getCachedDecrypter(4078015822532516984L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5530992893707757523L), SimpleLongDecrypter.getCachedDecrypter(-2301371847584433671L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4707802126753043397L), SimpleLongDecrypter.getCachedDecrypter(-2842022611035926767L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7835511128253700480L), SimpleLongDecrypter.getCachedDecrypter(4983055862315474224L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-439489906865322352L), SimpleLongDecrypter.getCachedDecrypter(3539255384697355426L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2586295549703032208L), SimpleLongDecrypter.getCachedDecrypter(-2764124031921860393L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8105461326482080372L), SimpleLongDecrypter.getCachedDecrypter(2347096292480849666L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(106173929846387253L), SimpleLongDecrypter.getCachedDecrypter(-8512206958645633145L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1251713922808129784L), SimpleLongDecrypter.getCachedDecrypter(-753481708870875771L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1478759168584654753L), SimpleLongDecrypter.getCachedDecrypter(-3716632073859055624L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3083037391056922187L), SimpleLongDecrypter.getCachedDecrypter(-2248530523700627568L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-460449213613254035L), SimpleLongDecrypter.getCachedDecrypter(690600858715720729L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6193559001190287466L), SimpleLongDecrypter.getCachedDecrypter(-4543854315518520951L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4720539672123030788L), SimpleLongDecrypter.getCachedDecrypter(-6618043615921902658L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7360621833281274615L), SimpleLongDecrypter.getCachedDecrypter(3204634952760401314L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6824400448435472147L), SimpleLongDecrypter.getCachedDecrypter(3772690131991462787L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7025952160290531559L), SimpleLongDecrypter.getCachedDecrypter(-554273319344779329L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7719552691899572060L), SimpleLongDecrypter.getCachedDecrypter(5824280900363065358L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9204904250319947226L), SimpleLongDecrypter.getCachedDecrypter(-5453028408030147429L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1255186932293804589L), SimpleLongDecrypter.getCachedDecrypter(5226276608651111752L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8926499960958218837L), SimpleLongDecrypter.getCachedDecrypter(-746146143253684428L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3324032015769707991L), SimpleLongDecrypter.getCachedDecrypter(-4267485783134324078L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4488967063777002646L), SimpleLongDecrypter.getCachedDecrypter(-1994209690221588922L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2624614194044854488L), SimpleLongDecrypter.getCachedDecrypter(2948821014693131471L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1471200598848811681L), SimpleLongDecrypter.getCachedDecrypter(-7664068583381312995L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2200269809090576113L), SimpleLongDecrypter.getCachedDecrypter(907188704930883124L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-278360760276422332L), SimpleLongDecrypter.getCachedDecrypter(2321677148833979536L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(118929900044112093L), SimpleLongDecrypter.getCachedDecrypter(-7745405674589395731L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4913928174377764347L), SimpleLongDecrypter.getCachedDecrypter(-6808228072076139136L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8449237673757226866L), SimpleLongDecrypter.getCachedDecrypter(-7428992675437492511L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2609351399610051103L), SimpleLongDecrypter.getCachedDecrypter(-1597426435667560437L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3512229502811356686L), SimpleLongDecrypter.getCachedDecrypter(690372539353189685L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-831427766905911680L), SimpleLongDecrypter.getCachedDecrypter(-5658401255270742747L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7645428420832167956L), SimpleLongDecrypter.getCachedDecrypter(4095105469778802883L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6747650535507002162L), SimpleLongDecrypter.getCachedDecrypter(7260506006505442098L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8510437908478216410L), SimpleLongDecrypter.getCachedDecrypter(-1903509732765076773L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9102885662433169511L), SimpleLongDecrypter.getCachedDecrypter(7053093802478561844L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4633019485250603535L), SimpleLongDecrypter.getCachedDecrypter(-2486330222306819873L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6875522785068807043L), SimpleLongDecrypter.getCachedDecrypter(3768855698775967641L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1560179997741392790L), SimpleLongDecrypter.getCachedDecrypter(-7191722313696732579L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1856105173737321905L), SimpleLongDecrypter.getCachedDecrypter(-7717080236666849809L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8149379766307451206L), SimpleLongDecrypter.getCachedDecrypter(-493761383589599295L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3025103996926338877L), SimpleLongDecrypter.getCachedDecrypter(6702358132664336133L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3633293223923886999L), SimpleLongDecrypter.getCachedDecrypter(5512627131297829007L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1399006838602794990L), SimpleLongDecrypter.getCachedDecrypter(1259240313875856665L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3855868167406400123L), SimpleLongDecrypter.getCachedDecrypter(-7673851064900946679L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6940260487619691845L), SimpleLongDecrypter.getCachedDecrypter(2319453546740306076L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2805359627525136510L), SimpleLongDecrypter.getCachedDecrypter(-9213858272385324916L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3050242128584220291L), SimpleLongDecrypter.getCachedDecrypter(2426948854738884484L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2089145489051168761L), SimpleLongDecrypter.getCachedDecrypter(-1976574236665561500L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5000225197065207734L), SimpleLongDecrypter.getCachedDecrypter(-5914570566482257658L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7865075778614297677L), SimpleLongDecrypter.getCachedDecrypter(882168992909457586L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3557548855757095999L), SimpleLongDecrypter.getCachedDecrypter(3192667863527761023L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7921664579917316149L), SimpleLongDecrypter.getCachedDecrypter(-1686662328109017448L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(16030545931613829L), SimpleLongDecrypter.getCachedDecrypter(8427570431936679729L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2072000809330830941L), SimpleLongDecrypter.getCachedDecrypter(2699141695702979730L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-190176580380278532L), SimpleLongDecrypter.getCachedDecrypter(-3665018027907116742L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8441280878557436659L), SimpleLongDecrypter.getCachedDecrypter(-8618210726459123612L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(868610363467293337L), SimpleLongDecrypter.getCachedDecrypter(8470993428666161097L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1977481351025488552L), SimpleLongDecrypter.getCachedDecrypter(3297111064124731840L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6287070246673950896L), SimpleLongDecrypter.getCachedDecrypter(-6014084052722820580L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3631833685691878627L), SimpleLongDecrypter.getCachedDecrypter(-4873477442426885784L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-545611487548678208L), SimpleLongDecrypter.getCachedDecrypter(7866510512487842104L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3216252896265573375L), SimpleLongDecrypter.getCachedDecrypter(3781808300992487674L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1501006475173056326L), SimpleLongDecrypter.getCachedDecrypter(6706669794210771477L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5964667453973529479L), SimpleLongDecrypter.getCachedDecrypter(4966723286899222785L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-525712538421082729L), SimpleLongDecrypter.getCachedDecrypter(-4799221693868549205L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5535997420572536844L), SimpleLongDecrypter.getCachedDecrypter(-5633213351953233165L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(947909479146261258L), SimpleLongDecrypter.getCachedDecrypter(8671830010059921680L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6261069166899588980L), SimpleLongDecrypter.getCachedDecrypter(1737220361212352454L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2916357505796789185L), SimpleLongDecrypter.getCachedDecrypter(132939269701051514L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7897403347197942571L), SimpleLongDecrypter.getCachedDecrypter(-1897721707299672549L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4177724402902082499L), SimpleLongDecrypter.getCachedDecrypter(2152061244657799841L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3936978236254310L), SimpleLongDecrypter.getCachedDecrypter(-3687010394128661005L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1524754667682501362L), SimpleLongDecrypter.getCachedDecrypter(-3608265407164279981L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5101367195978946117L), SimpleLongDecrypter.getCachedDecrypter(6074342367818979530L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4179422530396647193L), SimpleLongDecrypter.getCachedDecrypter(-5732865919794735904L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6858671282305005792L), SimpleLongDecrypter.getCachedDecrypter(1285372701687665869L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7087053533801605746L), SimpleLongDecrypter.getCachedDecrypter(-560643507480573711L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3879300281446393663L), SimpleLongDecrypter.getCachedDecrypter(8140048637933306299L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7016817443144306468L), SimpleLongDecrypter.getCachedDecrypter(6993846540610826759L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3880079044751367776L), SimpleLongDecrypter.getCachedDecrypter(-2772175961550748877L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6918728115301022535L), SimpleLongDecrypter.getCachedDecrypter(-7093691541903820998L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7121869508018465296L), SimpleLongDecrypter.getCachedDecrypter(-3619905918253696669L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4545617661108764150L), SimpleLongDecrypter.getCachedDecrypter(-5693751197263386763L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5834011537330639540L), SimpleLongDecrypter.getCachedDecrypter(7292145881775566192L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7530432167940528081L), SimpleLongDecrypter.getCachedDecrypter(-2804792023393741134L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(910831794564461123L), SimpleLongDecrypter.getCachedDecrypter(-6788076165741273230L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5805549404228672770L), SimpleLongDecrypter.getCachedDecrypter(-6013502380933964971L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5315798377556678107L), SimpleLongDecrypter.getCachedDecrypter(8675676969925212567L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2306904932395304954L), SimpleLongDecrypter.getCachedDecrypter(5233265262665027345L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(417321317301484570L), SimpleLongDecrypter.getCachedDecrypter(2729110386304083763L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6515147614880339305L), SimpleLongDecrypter.getCachedDecrypter(5820542412055344786L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8386867570350352289L), SimpleLongDecrypter.getCachedDecrypter(7025705443174003468L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2140727713596191545L), SimpleLongDecrypter.getCachedDecrypter(4966535516766319824L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9028240545303715909L), SimpleLongDecrypter.getCachedDecrypter(4161130978478061659L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4995181205128241268L), SimpleLongDecrypter.getCachedDecrypter(-2250732696933624885L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1000359605547491138L), SimpleLongDecrypter.getCachedDecrypter(-5067854833064411496L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4717309719445949203L), SimpleLongDecrypter.getCachedDecrypter(-1302670413065042625L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3215824997069522944L), SimpleLongDecrypter.getCachedDecrypter(656721864649648603L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7349872978350392675L), SimpleLongDecrypter.getCachedDecrypter(-8294295262056016382L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6293906392389105330L), SimpleLongDecrypter.getCachedDecrypter(7829181915181653587L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6021541225501284101L), SimpleLongDecrypter.getCachedDecrypter(-4788605159548992922L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5737303548234516633L), SimpleLongDecrypter.getCachedDecrypter(-7738614297119902111L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1198923286267990471L), SimpleLongDecrypter.getCachedDecrypter(-234527576298942974L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8845565663603887722L), SimpleLongDecrypter.getCachedDecrypter(6167232154533197865L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3530630654110623395L), SimpleLongDecrypter.getCachedDecrypter(6065879112502443808L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6908025239597109984L), SimpleLongDecrypter.getCachedDecrypter(6069941128679859712L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2558457005567348423L), SimpleLongDecrypter.getCachedDecrypter(91345267010913253L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-782373616705194270L), SimpleLongDecrypter.getCachedDecrypter(1767758975939877959L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3016612345624369176L), SimpleLongDecrypter.getCachedDecrypter(-8862590541130599355L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6374973279477575904L), SimpleLongDecrypter.getCachedDecrypter(-3936693917617855661L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6234778360532797906L), SimpleLongDecrypter.getCachedDecrypter(-7091025249248227541L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(968397907509092979L), SimpleLongDecrypter.getCachedDecrypter(6971456398153871322L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7386689375527301399L), SimpleLongDecrypter.getCachedDecrypter(5592898530940969649L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8021071976435742099L), SimpleLongDecrypter.getCachedDecrypter(-1410554232717218871L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6047842900499663656L), SimpleLongDecrypter.getCachedDecrypter(-6025376823128948419L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7493301312391954086L), SimpleLongDecrypter.getCachedDecrypter(-2243623914411394937L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6399459047076277734L), SimpleLongDecrypter.getCachedDecrypter(4414443402235425627L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6004124665206926105L), SimpleLongDecrypter.getCachedDecrypter(4719607874416305356L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6885805125234222286L), SimpleLongDecrypter.getCachedDecrypter(2610052737336624519L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5601350417950841237L), SimpleLongDecrypter.getCachedDecrypter(1159832963531477685L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7600489719658346270L), SimpleLongDecrypter.getCachedDecrypter(-2766096624059432923L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(97386679336626192L), SimpleLongDecrypter.getCachedDecrypter(6089653035852408058L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4737660432105245070L), SimpleLongDecrypter.getCachedDecrypter(-6499693970290028794L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2862279360250382810L), SimpleLongDecrypter.getCachedDecrypter(5033402261285769772L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(964714810070452851L), SimpleLongDecrypter.getCachedDecrypter(2035822917184709522L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4949704821785051643L), SimpleLongDecrypter.getCachedDecrypter(-4830151301484024496L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4961503327033331805L), SimpleLongDecrypter.getCachedDecrypter(980132385905890097L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7734828891484288176L), SimpleLongDecrypter.getCachedDecrypter(5029013262079200957L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1122697362436371493L), SimpleLongDecrypter.getCachedDecrypter(-4594050595048356903L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7267855829506004579L), SimpleLongDecrypter.getCachedDecrypter(-1389656990777157213L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2961322791761084674L), SimpleLongDecrypter.getCachedDecrypter(5784827536626261061L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8022696442592741420L), SimpleLongDecrypter.getCachedDecrypter(8942969501674475696L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3341621605486904294L), SimpleLongDecrypter.getCachedDecrypter(5008800931004342630L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9097345448816965785L), SimpleLongDecrypter.getCachedDecrypter(-2012308899786648798L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7802270083407105795L), SimpleLongDecrypter.getCachedDecrypter(-8925901428137007466L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(714849768446868051L), SimpleLongDecrypter.getCachedDecrypter(-5982764926234007237L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2660276783187614785L), SimpleLongDecrypter.getCachedDecrypter(-7674732951944579181L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5024169230666247083L), SimpleLongDecrypter.getCachedDecrypter(-2273709351824551035L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7810943727813919222L), SimpleLongDecrypter.getCachedDecrypter(4676928900592256673L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4314170972102188999L), SimpleLongDecrypter.getCachedDecrypter(-1091813998054512961L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6429954260661201866L), SimpleLongDecrypter.getCachedDecrypter(-6516895424999344911L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7051311777055982371L), SimpleLongDecrypter.getCachedDecrypter(-8905274342768594602L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4818287019748067833L), SimpleLongDecrypter.getCachedDecrypter(3231212246489347365L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-751423037687385412L), SimpleLongDecrypter.getCachedDecrypter(-7087540861198617429L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(903620552191322348L), SimpleLongDecrypter.getCachedDecrypter(-8066312395195232393L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-487137508511646938L), SimpleLongDecrypter.getCachedDecrypter(6111308729072307362L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4306990737088024564L), SimpleLongDecrypter.getCachedDecrypter(40739935297772656L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2230405235101944150L), SimpleLongDecrypter.getCachedDecrypter(-4802052276137419767L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9213610144656793448L), SimpleLongDecrypter.getCachedDecrypter(5528735448915153560L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5127282740209722454L), SimpleLongDecrypter.getCachedDecrypter(2338367842891747943L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4058777504300427778L), SimpleLongDecrypter.getCachedDecrypter(7030348343729496510L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4489203175706871803L), SimpleLongDecrypter.getCachedDecrypter(2436128364946729138L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1985463212546730893L), SimpleLongDecrypter.getCachedDecrypter(1503225382871840887L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3261475990356265095L), SimpleLongDecrypter.getCachedDecrypter(-3684293871248535363L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1251200170936072921L), SimpleLongDecrypter.getCachedDecrypter(414185806746110756L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2492186342638841466L), SimpleLongDecrypter.getCachedDecrypter(6127889876601604833L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4812052855496746058L), SimpleLongDecrypter.getCachedDecrypter(-3441232602555558810L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6104743711715720582L), SimpleLongDecrypter.getCachedDecrypter(5550742070499708834L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4291438610783180948L), SimpleLongDecrypter.getCachedDecrypter(-4822472091649876240L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3287589663713248093L), SimpleLongDecrypter.getCachedDecrypter(-1318327050548204018L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1936860395339092342L), SimpleLongDecrypter.getCachedDecrypter(-216242536234500818L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1164646280394707803L), SimpleLongDecrypter.getCachedDecrypter(-5375922665205522015L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3676356086329747043L), SimpleLongDecrypter.getCachedDecrypter(2159960793600962460L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1861924180524265268L), SimpleLongDecrypter.getCachedDecrypter(2041068522875395002L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1599372275624215912L), SimpleLongDecrypter.getCachedDecrypter(2627335188098139621L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3968014076150943092L), SimpleLongDecrypter.getCachedDecrypter(-5672370220949952910L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8897573491462008667L), SimpleLongDecrypter.getCachedDecrypter(7516153944194388902L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6622414785048812852L), SimpleLongDecrypter.getCachedDecrypter(-4895369942767240245L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(705751551808393188L), SimpleLongDecrypter.getCachedDecrypter(4906243432529874756L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(23488521461252473L), SimpleLongDecrypter.getCachedDecrypter(1737898781121438701L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3120623693690216175L), SimpleLongDecrypter.getCachedDecrypter(-221787879458000006L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9169002127790327935L), SimpleLongDecrypter.getCachedDecrypter(-1644105685460275113L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2602455213354983369L), SimpleLongDecrypter.getCachedDecrypter(-1892435409186160291L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2467611323332223549L), SimpleLongDecrypter.getCachedDecrypter(-5701144405129075182L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3979607951608508482L), SimpleLongDecrypter.getCachedDecrypter(-8035689473826410668L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8434895420130300289L), SimpleLongDecrypter.getCachedDecrypter(-4231059275968124766L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4725931716553248945L), SimpleLongDecrypter.getCachedDecrypter(3534809596371067350L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5771191268656994620L), SimpleLongDecrypter.getCachedDecrypter(5268942502750394631L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2297316494589926006L), SimpleLongDecrypter.getCachedDecrypter(-3443198645138015149L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(354431906228379776L), SimpleLongDecrypter.getCachedDecrypter(7246742268518858855L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7903115472466988697L), SimpleLongDecrypter.getCachedDecrypter(-6318692329861037796L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1074970225486255262L), SimpleLongDecrypter.getCachedDecrypter(-7197449799664741715L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3993377112047544824L), SimpleLongDecrypter.getCachedDecrypter(8959410482135964315L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6914227602058393617L), SimpleLongDecrypter.getCachedDecrypter(-2563425423895780971L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4299477708949975295L), SimpleLongDecrypter.getCachedDecrypter(8690149283610481558L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6944348811718765326L), SimpleLongDecrypter.getCachedDecrypter(-1431044745178013656L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-154381619622724114L), SimpleLongDecrypter.getCachedDecrypter(-3903618763120038522L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1700206241746613907L), SimpleLongDecrypter.getCachedDecrypter(2983752321579195891L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4038131987975639364L), SimpleLongDecrypter.getCachedDecrypter(5583190291160591140L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7950263401446864551L), SimpleLongDecrypter.getCachedDecrypter(-8909444861474085824L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2288718572070450379L), SimpleLongDecrypter.getCachedDecrypter(1219170454185898543L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1154878549529887923L), SimpleLongDecrypter.getCachedDecrypter(3226567142593212128L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8204340518189572129L), SimpleLongDecrypter.getCachedDecrypter(-7999500263346146954L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4001803958421617316L), SimpleLongDecrypter.getCachedDecrypter(1805659666201147299L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7544974571995729321L), SimpleLongDecrypter.getCachedDecrypter(6665938459097531383L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3653965894365075246L), SimpleLongDecrypter.getCachedDecrypter(-5958472403039008552L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6931109432720623161L), SimpleLongDecrypter.getCachedDecrypter(8971270010109809454L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-863448684633845311L), SimpleLongDecrypter.getCachedDecrypter(2396596250039801732L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8734818552200299726L), SimpleLongDecrypter.getCachedDecrypter(-6283019064132880891L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3622094358802050711L), SimpleLongDecrypter.getCachedDecrypter(670756099490132659L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1632154815127558586L), SimpleLongDecrypter.getCachedDecrypter(-7736149103259672802L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-264996976509015800L), SimpleLongDecrypter.getCachedDecrypter(1271812486436340599L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4135733368270762987L), SimpleLongDecrypter.getCachedDecrypter(-3336829765073941538L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4438628755652070032L), SimpleLongDecrypter.getCachedDecrypter(-770998940927487636L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5116432142843563747L), SimpleLongDecrypter.getCachedDecrypter(-2848074080919480327L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8461596694001043278L), SimpleLongDecrypter.getCachedDecrypter(7227219541787753764L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2095450951568301439L), SimpleLongDecrypter.getCachedDecrypter(-3090497528872707679L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1036879386400563331L), SimpleLongDecrypter.getCachedDecrypter(-5714604002764959964L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6032205626104206880L), SimpleLongDecrypter.getCachedDecrypter(-9221723857602545013L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2383988667681006421L), SimpleLongDecrypter.getCachedDecrypter(-4188031384059750905L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2226601040604023843L), SimpleLongDecrypter.getCachedDecrypter(6722143445993883618L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6124250655337873507L), SimpleLongDecrypter.getCachedDecrypter(1282065781052079970L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4208597635690118374L), SimpleLongDecrypter.getCachedDecrypter(8786450614948815192L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2766793536324627636L), SimpleLongDecrypter.getCachedDecrypter(-1325867141378492277L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9043416075744653774L), SimpleLongDecrypter.getCachedDecrypter(-1888825328430393040L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8507576109536971433L), SimpleLongDecrypter.getCachedDecrypter(6357726215092055303L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8766752220662278925L), SimpleLongDecrypter.getCachedDecrypter(-8641871386880560849L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1426872245362072435L), SimpleLongDecrypter.getCachedDecrypter(-8237405747895154280L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7263985508484137759L), SimpleLongDecrypter.getCachedDecrypter(2656137819864908101L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8366861855858010383L), SimpleLongDecrypter.getCachedDecrypter(-3659201479422197160L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1345556857965872886L), SimpleLongDecrypter.getCachedDecrypter(1541148623292954062L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6897803055098233958L), SimpleLongDecrypter.getCachedDecrypter(912892808408715617L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2108322837530216343L), SimpleLongDecrypter.getCachedDecrypter(625739576380465064L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5151063001870992855L), SimpleLongDecrypter.getCachedDecrypter(-4861135685562473660L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7241399854753543853L), SimpleLongDecrypter.getCachedDecrypter(3216897902496932299L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2420780668095621487L), SimpleLongDecrypter.getCachedDecrypter(-5672951961723977488L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6393406827380722542L), SimpleLongDecrypter.getCachedDecrypter(6703962216147856235L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7095594274592896977L), SimpleLongDecrypter.getCachedDecrypter(1868025286954292728L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7829417426161930631L), SimpleLongDecrypter.getCachedDecrypter(-3959327813796197300L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4824515308896786901L), SimpleLongDecrypter.getCachedDecrypter(-1405811707050280346L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3286490278918913644L), SimpleLongDecrypter.getCachedDecrypter(-7744602077766009100L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3367467065624746027L), SimpleLongDecrypter.getCachedDecrypter(-3059356556791202823L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8397696247687517670L), SimpleLongDecrypter.getCachedDecrypter(-525942199931705578L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(651168870930844700L), SimpleLongDecrypter.getCachedDecrypter(-8618908303770829682L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4839311400968560219L), SimpleLongDecrypter.getCachedDecrypter(-6514113296966961393L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3847190968155529880L), SimpleLongDecrypter.getCachedDecrypter(2640098269386838675L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4711565122503307111L), SimpleLongDecrypter.getCachedDecrypter(4134390205549782640L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4036972949353277807L), SimpleLongDecrypter.getCachedDecrypter(-9171583909646029827L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5337820687173385795L), SimpleLongDecrypter.getCachedDecrypter(1733269798371550292L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1427046497278896003L), SimpleLongDecrypter.getCachedDecrypter(4403976938739061070L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3117765903076992105L), SimpleLongDecrypter.getCachedDecrypter(1831941971145226370L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6648935290294162239L), SimpleLongDecrypter.getCachedDecrypter(6962425901369256538L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4068337570196535934L), SimpleLongDecrypter.getCachedDecrypter(8401631191307051609L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7675885677948792146L), SimpleLongDecrypter.getCachedDecrypter(3237260777441236841L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4742617290260807561L), SimpleLongDecrypter.getCachedDecrypter(5820814434084206950L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2136049429574056234L), SimpleLongDecrypter.getCachedDecrypter(-3393755617980253763L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3805465932581805580L), SimpleLongDecrypter.getCachedDecrypter(926730380218181999L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6223387704568913809L), SimpleLongDecrypter.getCachedDecrypter(-4585735887922629869L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6900950712213057439L), SimpleLongDecrypter.getCachedDecrypter(-8853266570156161635L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4641741812341944765L), SimpleLongDecrypter.getCachedDecrypter(5884578961044824961L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8528568438068591508L), SimpleLongDecrypter.getCachedDecrypter(-3745812953933579136L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2600178630780978636L), SimpleLongDecrypter.getCachedDecrypter(6139987630669975016L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5770582745800436013L), SimpleLongDecrypter.getCachedDecrypter(-3403834598654674625L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2223111757024032861L), SimpleLongDecrypter.getCachedDecrypter(6193058824059779599L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1076615577855320995L), SimpleLongDecrypter.getCachedDecrypter(-8046890878872229394L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-838346238462508676L), SimpleLongDecrypter.getCachedDecrypter(414995927547222189L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5314713642757272720L), SimpleLongDecrypter.getCachedDecrypter(7832643154401386573L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9087322272570016418L), SimpleLongDecrypter.getCachedDecrypter(-191181591795314693L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6889440644918898107L), SimpleLongDecrypter.getCachedDecrypter(4427264186003912112L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5925596232892992777L), SimpleLongDecrypter.getCachedDecrypter(-1060440851915341303L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4211444530536527988L), SimpleLongDecrypter.getCachedDecrypter(-2746922616728108890L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6440277512906977357L), SimpleLongDecrypter.getCachedDecrypter(7255233799140836900L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-214429447646150338L), SimpleLongDecrypter.getCachedDecrypter(-4288220978619611165L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5783630001182493123L), SimpleLongDecrypter.getCachedDecrypter(668631230446192293L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1492331395273011929L), SimpleLongDecrypter.getCachedDecrypter(3196002195676928438L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-219262937525704579L), SimpleLongDecrypter.getCachedDecrypter(-3328836543514286404L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1491930307179816510L), SimpleLongDecrypter.getCachedDecrypter(3575864876251461797L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3032704322594353123L), SimpleLongDecrypter.getCachedDecrypter(-2584437128016956105L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2501939326423066686L), SimpleLongDecrypter.getCachedDecrypter(-3443470215988730983L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6025989339737815656L), SimpleLongDecrypter.getCachedDecrypter(-727070217491950877L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4377546815298955053L), SimpleLongDecrypter.getCachedDecrypter(-7713888936009496807L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1223316477089837666L), SimpleLongDecrypter.getCachedDecrypter(5852355652943671400L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2906065153346711344L), SimpleLongDecrypter.getCachedDecrypter(-4588369808080052021L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-180833071244128351L), SimpleLongDecrypter.getCachedDecrypter(7261201523170080567L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6610585593858119241L), SimpleLongDecrypter.getCachedDecrypter(586998087746943813L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1590140978487009068L), SimpleLongDecrypter.getCachedDecrypter(-3091326785878963564L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5549053739051001678L), SimpleLongDecrypter.getCachedDecrypter(8373925505099782927L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8881730220976124521L), SimpleLongDecrypter.getCachedDecrypter(-5361174598842081823L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7481964983063069625L), SimpleLongDecrypter.getCachedDecrypter(-2505162514269137582L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4088366279472734208L), SimpleLongDecrypter.getCachedDecrypter(-9220748014060917752L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7768126979992879027L), SimpleLongDecrypter.getCachedDecrypter(-2772805787504854895L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6349326039416540707L), SimpleLongDecrypter.getCachedDecrypter(-1926317975031238613L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3652854834267099769L), SimpleLongDecrypter.getCachedDecrypter(1851359584508198503L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5771750400656787494L), SimpleLongDecrypter.getCachedDecrypter(-2772702260440151093L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(715734041292136875L), SimpleLongDecrypter.getCachedDecrypter(4428502305950130425L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6534615948151037167L), SimpleLongDecrypter.getCachedDecrypter(60864792920822986L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5955887808655913151L), SimpleLongDecrypter.getCachedDecrypter(2422404253389130711L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8363028041646467769L), SimpleLongDecrypter.getCachedDecrypter(8771565867046695252L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5051416571532622699L), SimpleLongDecrypter.getCachedDecrypter(3210106042755029436L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3281568862634955965L), SimpleLongDecrypter.getCachedDecrypter(1263794432885518897L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6492090397442386768L), SimpleLongDecrypter.getCachedDecrypter(-4801563183523760060L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7141600573628064531L), SimpleLongDecrypter.getCachedDecrypter(-6529624141516642017L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-527939303505038826L), SimpleLongDecrypter.getCachedDecrypter(2957227917611903662L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4355770457751719495L), SimpleLongDecrypter.getCachedDecrypter(-7718891852913039262L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5316729612445016017L), SimpleLongDecrypter.getCachedDecrypter(-5692521851463906765L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7186242685839529504L), SimpleLongDecrypter.getCachedDecrypter(3492819034401456821L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-263669425792222283L), SimpleLongDecrypter.getCachedDecrypter(-8901060055377406733L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1998778094412529463L), SimpleLongDecrypter.getCachedDecrypter(4672129580086528837L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3900418952085978002L), SimpleLongDecrypter.getCachedDecrypter(7267359594722828844L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7102868889770148389L), SimpleLongDecrypter.getCachedDecrypter(2958324859534854859L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8896387127649430804L), SimpleLongDecrypter.getCachedDecrypter(2678908032703626035L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1694058600109406174L), SimpleLongDecrypter.getCachedDecrypter(-236507534990845948L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(71814265845636330L), SimpleLongDecrypter.getCachedDecrypter(2124720226958629305L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6293092409985383305L), SimpleLongDecrypter.getCachedDecrypter(-4568271758540731463L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6574951097590622724L), SimpleLongDecrypter.getCachedDecrypter(7567512715530343742L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5131286056932931629L), SimpleLongDecrypter.getCachedDecrypter(-5937793708416141430L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5837741365045733643L), SimpleLongDecrypter.getCachedDecrypter(2126352550892598446L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8083143949749767200L), SimpleLongDecrypter.getCachedDecrypter(-6016707722115083596L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8540801851551410431L), SimpleLongDecrypter.getCachedDecrypter(4923712654088419718L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2550343766101346061L), SimpleLongDecrypter.getCachedDecrypter(2602699110681787371L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8035448723394677595L), SimpleLongDecrypter.getCachedDecrypter(-6600243351589117561L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6066643048569261214L), SimpleLongDecrypter.getCachedDecrypter(-3892493299303233206L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1222214426463750927L), SimpleLongDecrypter.getCachedDecrypter(-196603229884274416L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9214492422392729088L), SimpleLongDecrypter.getCachedDecrypter(-5068673389840986176L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7637908085072340745L), SimpleLongDecrypter.getCachedDecrypter(-4776598915055900017L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6839058428408281656L), SimpleLongDecrypter.getCachedDecrypter(-7074758740037835804L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7494654135777169400L), SimpleLongDecrypter.getCachedDecrypter(-7356485946352041971L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3287263796659164665L), SimpleLongDecrypter.getCachedDecrypter(8944644142814857886L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7325928128014796668L), SimpleLongDecrypter.getCachedDecrypter(1571355323198027406L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1893471620220551826L), SimpleLongDecrypter.getCachedDecrypter(-3385497531314433003L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1628201339298549965L), SimpleLongDecrypter.getCachedDecrypter(-5128453860684904760L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3029627814614514571L), SimpleLongDecrypter.getCachedDecrypter(8157872703053348528L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5258968202611884222L), SimpleLongDecrypter.getCachedDecrypter(-286307034775532370L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9039056590888679939L), SimpleLongDecrypter.getCachedDecrypter(8694807994543145401L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6891491388041718087L), SimpleLongDecrypter.getCachedDecrypter(2412700916478034709L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8906868652891041563L), SimpleLongDecrypter.getCachedDecrypter(4691696738777908567L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5312065789986746707L), SimpleLongDecrypter.getCachedDecrypter(5803029651452380379L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7717907006842938542L), SimpleLongDecrypter.getCachedDecrypter(2991012968636384077L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5507596484866732711L), SimpleLongDecrypter.getCachedDecrypter(-5465885038072617469L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8404183836537216426L), SimpleLongDecrypter.getCachedDecrypter(-1931188627568012480L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2179201491355106044L), SimpleLongDecrypter.getCachedDecrypter(-4879920708571577692L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1409691154278372934L), SimpleLongDecrypter.getCachedDecrypter(-5384254395932355638L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3453771697326360111L), SimpleLongDecrypter.getCachedDecrypter(4960648935227833319L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2608384410456575161L), SimpleLongDecrypter.getCachedDecrypter(-4492280417691094754L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4760060870418116133L), SimpleLongDecrypter.getCachedDecrypter(-3728313348415743802L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7894521952164935343L), SimpleLongDecrypter.getCachedDecrypter(3877219082462248588L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2529885501562409053L), SimpleLongDecrypter.getCachedDecrypter(-1876089266242849831L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3144057267821837707L), SimpleLongDecrypter.getCachedDecrypter(2674097330007448636L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9136901137518187681L), SimpleLongDecrypter.getCachedDecrypter(-1878907481491024228L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7348190784814928224L), SimpleLongDecrypter.getCachedDecrypter(7852009303630559581L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1044461416248473699L), SimpleLongDecrypter.getCachedDecrypter(7267178572744184225L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5139691850684570010L), SimpleLongDecrypter.getCachedDecrypter(9010470221632476100L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2409882409050750845L), SimpleLongDecrypter.getCachedDecrypter(7581323364678862008L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4907458534843161739L), SimpleLongDecrypter.getCachedDecrypter(-7448922759746595400L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5248182274947579036L), SimpleLongDecrypter.getCachedDecrypter(-1421841150762046228L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7498516839558184552L), SimpleLongDecrypter.getCachedDecrypter(595962783201542952L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6281843890197881L), SimpleLongDecrypter.getCachedDecrypter(-8254316574705443778L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-147613254999963452L), SimpleLongDecrypter.getCachedDecrypter(1223397166028208495L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6387162671490187706L), SimpleLongDecrypter.getCachedDecrypter(-9211997347803281366L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6999683366765816081L), SimpleLongDecrypter.getCachedDecrypter(1195898219976600368L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(695002588098054132L), SimpleLongDecrypter.getCachedDecrypter(5249682973350786900L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7352755087300711694L), SimpleLongDecrypter.getCachedDecrypter(4910912199222662380L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1264592743495977529L), SimpleLongDecrypter.getCachedDecrypter(1850615798518152557L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8224688088659832094L), SimpleLongDecrypter.getCachedDecrypter(-7964210703637142179L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4316289882413605179L), SimpleLongDecrypter.getCachedDecrypter(-483099721547879586L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1123120505182694242L), SimpleLongDecrypter.getCachedDecrypter(-3384451414840920336L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8551642201846707003L), SimpleLongDecrypter.getCachedDecrypter(5213238675056207173L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4591713452930733747L), SimpleLongDecrypter.getCachedDecrypter(-2164857960914071176L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1493272765368449123L), SimpleLongDecrypter.getCachedDecrypter(-1337080035100161358L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9041940441655793022L), SimpleLongDecrypter.getCachedDecrypter(313366383327839895L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-201629169987813590L), SimpleLongDecrypter.getCachedDecrypter(7496412350308707625L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4663270512341825932L), SimpleLongDecrypter.getCachedDecrypter(1773830343119874533L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7699088518979642231L), SimpleLongDecrypter.getCachedDecrypter(6374061335307503747L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6758068971812962151L), SimpleLongDecrypter.getCachedDecrypter(-847590117847124491L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8073844874654153585L), SimpleLongDecrypter.getCachedDecrypter(8945866317369207938L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3863530974432051960L), SimpleLongDecrypter.getCachedDecrypter(-7975909672163484254L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6809852124200845774L), SimpleLongDecrypter.getCachedDecrypter(-1336652458517825620L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7148700429013183315L), SimpleLongDecrypter.getCachedDecrypter(4721253067017717402L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8937311634691541939L), SimpleLongDecrypter.getCachedDecrypter(945038507445065938L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7997821595170852310L), SimpleLongDecrypter.getCachedDecrypter(8446901729150954611L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(880237017360152410L), SimpleLongDecrypter.getCachedDecrypter(9024995846141370010L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3051952586062477277L), SimpleLongDecrypter.getCachedDecrypter(409621813950816474L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4799827891497935367L), SimpleLongDecrypter.getCachedDecrypter(-1626590474600274374L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(650107507199714739L), SimpleLongDecrypter.getCachedDecrypter(6984815589504016245L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4736558873264345034L), SimpleLongDecrypter.getCachedDecrypter(4970005825937087090L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7828943434147797614L), SimpleLongDecrypter.getCachedDecrypter(5794621034987548573L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5084076892050157094L), SimpleLongDecrypter.getCachedDecrypter(-1710288253199838468L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7537515195847269063L), SimpleLongDecrypter.getCachedDecrypter(-7090459800986468781L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4756008601783500290L), SimpleLongDecrypter.getCachedDecrypter(-5704287839992275066L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4098021295170918336L), SimpleLongDecrypter.getCachedDecrypter(-9195286120483943947L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8920645766759993205L), SimpleLongDecrypter.getCachedDecrypter(-9176298249449508617L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9133604005136949743L), SimpleLongDecrypter.getCachedDecrypter(5891156745608422428L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3593119228420575928L), SimpleLongDecrypter.getCachedDecrypter(-1588711730728175292L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2748598289438532100L), SimpleLongDecrypter.getCachedDecrypter(1235401990882950507L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8635486025413912983L), SimpleLongDecrypter.getCachedDecrypter(8678006655306999227L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6652954385099610594L), SimpleLongDecrypter.getCachedDecrypter(-7475076092827099586L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1204474108967526618L), SimpleLongDecrypter.getCachedDecrypter(-1349546363815376642L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7332742017608784652L), SimpleLongDecrypter.getCachedDecrypter(2092511613661685898L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5976531005480578153L), SimpleLongDecrypter.getCachedDecrypter(4436533447829410100L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8817950554382514728L), SimpleLongDecrypter.getCachedDecrypter(-6568323932816453443L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5062035917807044668L), SimpleLongDecrypter.getCachedDecrypter(-3039250002955690430L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1903137008153056001L), SimpleLongDecrypter.getCachedDecrypter(3203972524286510032L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6098678655073322424L), SimpleLongDecrypter.getCachedDecrypter(-8594472797276382706L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1735012428973313106L), SimpleLongDecrypter.getCachedDecrypter(-5633265653656335080L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4719790616637468365L), SimpleLongDecrypter.getCachedDecrypter(-9169427411310259033L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5552971854452280191L), SimpleLongDecrypter.getCachedDecrypter(-7984791382272857340L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3066874635686529033L), SimpleLongDecrypter.getCachedDecrypter(2947520042059342368L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2281377643799991032L), SimpleLongDecrypter.getCachedDecrypter(-4209151965905991241L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4771595937178648796L), SimpleLongDecrypter.getCachedDecrypter(-1664659111482949208L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(347161798952888429L), SimpleLongDecrypter.getCachedDecrypter(-5656185654092647082L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8739143482759446867L), SimpleLongDecrypter.getCachedDecrypter(-1922875466698991023L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-500703858091556936L), SimpleLongDecrypter.getCachedDecrypter(-3715277533349636735L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3302642848026906174L), SimpleLongDecrypter.getCachedDecrypter(4998534105988418249L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7901888478383900931L), SimpleLongDecrypter.getCachedDecrypter(7214236370700066333L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3755103406563357922L), SimpleLongDecrypter.getCachedDecrypter(2158545604330204929L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8773366351179099234L), SimpleLongDecrypter.getCachedDecrypter(-5419769699250861473L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6168262080810762909L), SimpleLongDecrypter.getCachedDecrypter(684957212441402385L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3288466689738668460L), SimpleLongDecrypter.getCachedDecrypter(-1625215497473758629L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6003516724440293926L), SimpleLongDecrypter.getCachedDecrypter(598500374108042934L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3710058766762053522L), SimpleLongDecrypter.getCachedDecrypter(-7666295778289477563L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6901949346289736851L), SimpleLongDecrypter.getCachedDecrypter(3755857878950170728L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9006862177158857375L), SimpleLongDecrypter.getCachedDecrypter(-1600319696196233767L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5421770309421669591L), SimpleLongDecrypter.getCachedDecrypter(-3347722771785935964L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8867824928011291840L), SimpleLongDecrypter.getCachedDecrypter(6387790868112881312L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3417276103553292344L), SimpleLongDecrypter.getCachedDecrypter(-6049832740651119023L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6143652468241353324L), SimpleLongDecrypter.getCachedDecrypter(-1310622359509761826L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8436168856149594982L), SimpleLongDecrypter.getCachedDecrypter(6135119076353691046L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4973918597874473968L), SimpleLongDecrypter.getCachedDecrypter(-4573703335541253815L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3964803241783440351L), SimpleLongDecrypter.getCachedDecrypter(8679790617169156596L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4254581879934012842L), SimpleLongDecrypter.getCachedDecrypter(2103576313087505102L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9019474978509167179L), SimpleLongDecrypter.getCachedDecrypter(3290457990210939943L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6800515397527062631L), SimpleLongDecrypter.getCachedDecrypter(-6568254369893890675L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3715297324198080490L), SimpleLongDecrypter.getCachedDecrypter(-1149688180220361595L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-521863588289927802L), SimpleLongDecrypter.getCachedDecrypter(-5175396131557048147L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1190135021245367557L), SimpleLongDecrypter.getCachedDecrypter(1006464993654372986L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1275959633097942215L), SimpleLongDecrypter.getCachedDecrypter(3781112736488442916L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7750706669242774885L), SimpleLongDecrypter.getCachedDecrypter(7839846077020171420L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4308094044460578045L), SimpleLongDecrypter.getCachedDecrypter(-4256035369776659989L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5281780278039787975L), SimpleLongDecrypter.getCachedDecrypter(-2264200617093950733L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1792071502732154704L), SimpleLongDecrypter.getCachedDecrypter(7850492881837011555L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5746837124257294904L), SimpleLongDecrypter.getCachedDecrypter(-2809134681157261729L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3528610481976043379L), SimpleLongDecrypter.getCachedDecrypter(6687717350548646942L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3716251662867236596L), SimpleLongDecrypter.getCachedDecrypter(-258317200230259382L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3974683003793424813L), SimpleLongDecrypter.getCachedDecrypter(-811748818979807833L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4939793604354115991L), SimpleLongDecrypter.getCachedDecrypter(-2465471677113515533L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1042987680052184023L), SimpleLongDecrypter.getCachedDecrypter(584089247558725951L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7861373524490280204L), SimpleLongDecrypter.getCachedDecrypter(-2172804652123645089L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-563678048935346948L), SimpleLongDecrypter.getCachedDecrypter(8426183188225426213L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8358963481449245126L), SimpleLongDecrypter.getCachedDecrypter(3173036501582914690L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(9049221933985816542L), SimpleLongDecrypter.getCachedDecrypter(8442554593888980273L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1712101187622935087L), SimpleLongDecrypter.getCachedDecrypter(8119983400340874062L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7780534423075591407L), SimpleLongDecrypter.getCachedDecrypter(8386602842607388999L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-790676696379318782L), SimpleLongDecrypter.getCachedDecrypter(-5129479948026193304L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4591661646256641820L), SimpleLongDecrypter.getCachedDecrypter(-8050914385498772224L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6047876199025371995L), SimpleLongDecrypter.getCachedDecrypter(4690110471719632313L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3355238867795176293L), SimpleLongDecrypter.getCachedDecrypter(-5638797927326793291L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8802333553156363406L), SimpleLongDecrypter.getCachedDecrypter(-730848231735615841L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6226159061042810425L), SimpleLongDecrypter.getCachedDecrypter(5540343810227262915L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2193635827172266278L), SimpleLongDecrypter.getCachedDecrypter(-1696142901830016820L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(960494692552474948L), SimpleLongDecrypter.getCachedDecrypter(70773218947454695L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1809771950602830896L), SimpleLongDecrypter.getCachedDecrypter(-7753899412190998864L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4141496314410354572L), SimpleLongDecrypter.getCachedDecrypter(1832164222503285199L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7649292868285643725L), SimpleLongDecrypter.getCachedDecrypter(-6325499150233226055L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7605642656589494291L), SimpleLongDecrypter.getCachedDecrypter(-2548716948714553278L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1734334727375576022L), SimpleLongDecrypter.getCachedDecrypter(3220698892576959918L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2686370953227063774L), SimpleLongDecrypter.getCachedDecrypter(305409315799334911L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1897481519579626572L), SimpleLongDecrypter.getCachedDecrypter(-2751747783461316945L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4663871168583513295L), SimpleLongDecrypter.getCachedDecrypter(-3979253196117895600L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5460745413330207222L), SimpleLongDecrypter.getCachedDecrypter(4620762718186237175L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3588284332553904244L), SimpleLongDecrypter.getCachedDecrypter(-6902029257664264177L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7563184428860464652L), SimpleLongDecrypter.getCachedDecrypter(3490181721326752184L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7889274929420804578L), SimpleLongDecrypter.getCachedDecrypter(8758475353419695595L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2515811868483019673L), SimpleLongDecrypter.getCachedDecrypter(3855527583756474464L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1291970856217711801L), SimpleLongDecrypter.getCachedDecrypter(-8930469712751266876L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8937603882921327349L), SimpleLongDecrypter.getCachedDecrypter(-1975240139780191833L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1765243263429148089L), SimpleLongDecrypter.getCachedDecrypter(6961583135071547444L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2542599161154009545L), SimpleLongDecrypter.getCachedDecrypter(705725026242874803L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4906408440894571949L), SimpleLongDecrypter.getCachedDecrypter(8723233914991699155L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5206671415663236908L), SimpleLongDecrypter.getCachedDecrypter(6690231533746757456L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7074036276421817115L), SimpleLongDecrypter.getCachedDecrypter(-1984944125376123320L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5048310770541538716L), SimpleLongDecrypter.getCachedDecrypter(887561832302026659L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8525305200200411342L), SimpleLongDecrypter.getCachedDecrypter(-6595628357771460746L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3430046121349071691L), SimpleLongDecrypter.getCachedDecrypter(-4828744663515814268L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5582264511105333593L), SimpleLongDecrypter.getCachedDecrypter(4986052575563163876L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(44003936618149971L), SimpleLongDecrypter.getCachedDecrypter(-5708486550225475586L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7734337008107580329L), SimpleLongDecrypter.getCachedDecrypter(3293249077325077361L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7730772720757962214L), SimpleLongDecrypter.getCachedDecrypter(6975892530884078890L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4104319495399167867L), SimpleLongDecrypter.getCachedDecrypter(3761568695020784797L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8745057353279302527L), SimpleLongDecrypter.getCachedDecrypter(2108759355814584723L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7735684521719391255L), SimpleLongDecrypter.getCachedDecrypter(-7947250324030833369L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2121502035769794282L), SimpleLongDecrypter.getCachedDecrypter(-1639710334935190186L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4560665851195392979L), SimpleLongDecrypter.getCachedDecrypter(-7643588173594849316L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3175064200664682173L), SimpleLongDecrypter.getCachedDecrypter(-4538701175582596679L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8742753538918026698L), SimpleLongDecrypter.getCachedDecrypter(7545516579952798464L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7391800965493911704L), SimpleLongDecrypter.getCachedDecrypter(-6340839970434227303L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2537540532986830240L), SimpleLongDecrypter.getCachedDecrypter(1770154347045830801L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3620973675030184105L), SimpleLongDecrypter.getCachedDecrypter(4384090162738111855L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7322247095322807960L), SimpleLongDecrypter.getCachedDecrypter(4944573090023120482L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1895236251571127620L), SimpleLongDecrypter.getCachedDecrypter(-8929863096608853337L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(884863938271635180L), SimpleLongDecrypter.getCachedDecrypter(-8067988997643043262L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4999607867818820525L), SimpleLongDecrypter.getCachedDecrypter(-2208577611342627927L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4154585203116481863L), SimpleLongDecrypter.getCachedDecrypter(2341250000541172457L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4192384563149033680L), SimpleLongDecrypter.getCachedDecrypter(6468694684346464406L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5037618242065483997L), SimpleLongDecrypter.getCachedDecrypter(2611841353141181865L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6462942554551950377L), SimpleLongDecrypter.getCachedDecrypter(1498288205430034804L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2511155065117184969L), SimpleLongDecrypter.getCachedDecrypter(-7381704678570766320L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5157197611035504556L), SimpleLongDecrypter.getCachedDecrypter(865611761732747624L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3343002020285337644L), SimpleLongDecrypter.getCachedDecrypter(-2249412872604940178L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3282332264316179951L), SimpleLongDecrypter.getCachedDecrypter(-3066040324347096177L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(3024061599094657868L), SimpleLongDecrypter.getCachedDecrypter(8376145769472715928L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1798812660256384710L), SimpleLongDecrypter.getCachedDecrypter(-2480353566557868789L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4294557635825919419L), SimpleLongDecrypter.getCachedDecrypter(2683623872915879412L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2074335053624586460L), SimpleLongDecrypter.getCachedDecrypter(-3369576012847444632L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5059692913957364661L), SimpleLongDecrypter.getCachedDecrypter(-5351233918081139383L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4022908255526003729L), SimpleLongDecrypter.getCachedDecrypter(5858163224426797121L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2878953059557936600L), SimpleLongDecrypter.getCachedDecrypter(316809037415838994L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3714564374358119577L), SimpleLongDecrypter.getCachedDecrypter(1450842524459528819L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5211400883067034758L), SimpleLongDecrypter.getCachedDecrypter(-2818341821640899078L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5378881317216735058L), SimpleLongDecrypter.getCachedDecrypter(6744729758658474146L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6356700196631382995L), SimpleLongDecrypter.getCachedDecrypter(4366433396549276902L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5791437668132087070L), SimpleLongDecrypter.getCachedDecrypter(-4232822992761907045L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4818867388790180897L), SimpleLongDecrypter.getCachedDecrypter(717577665967524490L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1941855642001634076L), SimpleLongDecrypter.getCachedDecrypter(-8530290889501597410L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7657073007055372566L), SimpleLongDecrypter.getCachedDecrypter(8967426794768337168L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8247914220083600624L), SimpleLongDecrypter.getCachedDecrypter(-5431319790483011655L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(587050438728742639L), SimpleLongDecrypter.getCachedDecrypter(9076088852825925276L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4190389184572129517L), SimpleLongDecrypter.getCachedDecrypter(2098920076425194885L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4044225675458059685L), SimpleLongDecrypter.getCachedDecrypter(-7134179120593406730L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-9181628685270266698L), SimpleLongDecrypter.getCachedDecrypter(-6008496031623360801L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1496800846042828550L), SimpleLongDecrypter.getCachedDecrypter(-4009427693864208901L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(938635367436514772L), SimpleLongDecrypter.getCachedDecrypter(-2742069584845773684L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7126905841261621814L), SimpleLongDecrypter.getCachedDecrypter(3024999319577403797L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6226538094819036807L), SimpleLongDecrypter.getCachedDecrypter(-1980196689557545830L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6540759721564953637L), SimpleLongDecrypter.getCachedDecrypter(8367882716021216621L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2158407643444234958L), SimpleLongDecrypter.getCachedDecrypter(-6589174471551428379L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2663299722029063255L), SimpleLongDecrypter.getCachedDecrypter(5828206980773513016L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4762335988125210044L), SimpleLongDecrypter.getCachedDecrypter(-6608079257766783629L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2432868806034485315L), SimpleLongDecrypter.getCachedDecrypter(5503870235002682362L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5740215336853136786L), SimpleLongDecrypter.getCachedDecrypter(-8928871186177645747L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1148648656267208763L), SimpleLongDecrypter.getCachedDecrypter(4051219623424522588L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4941697592576018334L), SimpleLongDecrypter.getCachedDecrypter(-5994312648718011507L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1704187014754952995L), SimpleLongDecrypter.getCachedDecrypter(3547335808129356930L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5670155132538582186L), SimpleLongDecrypter.getCachedDecrypter(-4021903949692044771L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8648129641541796150L), SimpleLongDecrypter.getCachedDecrypter(4038814075528244401L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1098184385911367566L), SimpleLongDecrypter.getCachedDecrypter(583674954110935914L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8518943792376654678L), SimpleLongDecrypter.getCachedDecrypter(-4299590193478047579L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5583565955978027011L), SimpleLongDecrypter.getCachedDecrypter(-6910488988854344139L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7403368338833851502L), SimpleLongDecrypter.getCachedDecrypter(-8882924461368230529L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-804773006690544867L), SimpleLongDecrypter.getCachedDecrypter(-7638152299287124719L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7153191483446026286L), SimpleLongDecrypter.getCachedDecrypter(4462595492018806704L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(83836970632894239L), SimpleLongDecrypter.getCachedDecrypter(-1616517667815770477L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-4875548303129679023L), SimpleLongDecrypter.getCachedDecrypter(6384459916493475941L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1551027505266410121L), SimpleLongDecrypter.getCachedDecrypter(-5465329494238646551L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2806360784934708738L), SimpleLongDecrypter.getCachedDecrypter(298868575196312711L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5012024348948679665L), SimpleLongDecrypter.getCachedDecrypter(-5064347476252312524L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-8883277064780163494L), SimpleLongDecrypter.getCachedDecrypter(905254666895210424L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(7219501161889905404L), SimpleLongDecrypter.getCachedDecrypter(-8925088278891271800L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7186394649514926800L), SimpleLongDecrypter.getCachedDecrypter(6431696377447326360L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3972753837674093418L), SimpleLongDecrypter.getCachedDecrypter(-3628299120818631267L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6924261653161073669L), SimpleLongDecrypter.getCachedDecrypter(-3047275480645935528L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-5046493874068884037L), SimpleLongDecrypter.getCachedDecrypter(1270533176964296392L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2780920879878228734L), SimpleLongDecrypter.getCachedDecrypter(3594900970855051675L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(636014501972012612L), SimpleLongDecrypter.getCachedDecrypter(28995404127599640L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6761655198339965131L), SimpleLongDecrypter.getCachedDecrypter(-4224168946513108523L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5492084042060543319L), SimpleLongDecrypter.getCachedDecrypter(2639204119816161715L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3699975696360045275L), SimpleLongDecrypter.getCachedDecrypter(6133802496689836296L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(937195869627976846L), SimpleLongDecrypter.getCachedDecrypter(7570835798716730348L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6174128940432524737L), SimpleLongDecrypter.getCachedDecrypter(-1058017539307175724L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3316217894472314747L), SimpleLongDecrypter.getCachedDecrypter(-237727739795135511L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2756339726546441898L), SimpleLongDecrypter.getCachedDecrypter(-4591316575299744016L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1597024828144881148L), SimpleLongDecrypter.getCachedDecrypter(-8321054387088012716L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-514912897448158268L), SimpleLongDecrypter.getCachedDecrypter(3602766394303021835L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-255115137693080702L), SimpleLongDecrypter.getCachedDecrypter(-4271471853115380530L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-2198764693148899792L), SimpleLongDecrypter.getCachedDecrypter(9025599187631072310L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4178620057943593358L), SimpleLongDecrypter.getCachedDecrypter(1244201843352156955L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-6841705085751293229L), SimpleLongDecrypter.getCachedDecrypter(-8822404115599395840L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1589655370552556382L), SimpleLongDecrypter.getCachedDecrypter(6691401928941216675L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2150961324032054923L), SimpleLongDecrypter.getCachedDecrypter(4382514385847483248L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8127584130845832708L), SimpleLongDecrypter.getCachedDecrypter(-6017857994005128969L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3157210340724992738L), SimpleLongDecrypter.getCachedDecrypter(3529039537011162263L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8084400598368831262L), SimpleLongDecrypter.getCachedDecrypter(-6620451447141414730L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8732834240164360591L), SimpleLongDecrypter.getCachedDecrypter(-3422174284513251777L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(1507590849516390916L), SimpleLongDecrypter.getCachedDecrypter(8363616092015084553L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5285755795586184646L), SimpleLongDecrypter.getCachedDecrypter(-3074003063778089212L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4956484603977669786L), SimpleLongDecrypter.getCachedDecrypter(911604087610449143L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5488100622532427868L), SimpleLongDecrypter.getCachedDecrypter(-4026304414388370747L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-3135131658996610645L), SimpleLongDecrypter.getCachedDecrypter(2077502840136124922L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8071594428260008665L), SimpleLongDecrypter.getCachedDecrypter(2332279856418147471L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-785097048178623266L), SimpleLongDecrypter.getCachedDecrypter(-1934815618690209865L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4709456550372057950L), SimpleLongDecrypter.getCachedDecrypter(-7072340696347576710L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7703096981267062444L), SimpleLongDecrypter.getCachedDecrypter(7793121221615226181L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-219420038788743913L), SimpleLongDecrypter.getCachedDecrypter(7823797609453934590L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(4116925203472247863L), SimpleLongDecrypter.getCachedDecrypter(-5405996950275448345L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(5795635626668754096L), SimpleLongDecrypter.getCachedDecrypter(-8248219541938253055L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(359145258106717703L), SimpleLongDecrypter.getCachedDecrypter(1275997761567607892L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(6149735307064627390L), SimpleLongDecrypter.getCachedDecrypter(9025480950336821237L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7692011574225327606L), SimpleLongDecrypter.getCachedDecrypter(6735928068536794648L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(2406864935422365862L), SimpleLongDecrypter.getCachedDecrypter(-9198490433901094271L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-1715406417145256371L), SimpleLongDecrypter.getCachedDecrypter(-3929180015599318279L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(-7740049226103557519L), SimpleLongDecrypter.getCachedDecrypter(2598349219060717877L));
    var10000.put(SimpleLongDecrypter.getCachedDecrypter(8073094865408628434L), SimpleLongDecrypter.getCachedDecrypter(-4804217907428580323L));
  }

  private void setupEncryptionInts() {
    int[] var10000 = SimpleLongDecrypter.getCachedDecrypter(2443998190580209211L).getEncryptionInts();
    var10000[0] = -13;
    var10000[1] = -46;
    var10000[2] = -2;
    var10000[3] = -14;
    var10000[4] = 2;
    var10000[5] = -33;
    var10000[6] = -19;
    var10000[7] = -17;
    var10000[8] = -10;
    var10000[9] = -30;
    var10000[10] = -11;
    var10000[11] = -19;
    var10000[12] = -33;
    var10000[13] = 13;
    var10000[14] = -30;
    var10000[15] = -44;
    var10000[16] = -40;
    var10000[17] = 14;
    var10000[18] = 10;
    var10000[19] = -23;
    var10000[20] = -13;
    var10000[21] = 11;
    var10000[22] = -38;
    var10000[23] = -28;
    var10000[24] = 17;
    var10000[25] = 19;
    var10000[26] = -11;
    var10000[27] = -22;
    var10000[28] = -8;
    var10000[29] = -34;
    var10000[30] = 19;
    var10000[31] = -30;
    var10000[32] = -9;
    var10000[33] = 13;
    var10000[34] = -24;
    var10000[35] = -19;
    var10000[36] = 8;
    var10000[37] = 11;
    var10000[38] = 33;
    var10000[39] = 30;
    var10000[40] = -13;
    var10000[41] = 9;
    var10000[42] = 23;
    var10000[43] = -19;
    var10000[44] = 30;
    var10000[45] = 33;
    var10000[46] = -6;
    var10000[47] = 46;
    var10000[48] = -2;
    var10000[49] = 22;
    var10000[50] = 2;
    var10000[51] = 28;
    var10000[52] = 6;
    var10000[53] = 13;
    var10000[54] = 19;
    var10000[55] = -2;
    var10000[56] = 40;
    var10000[57] = 2;
    var10000[58] = 24;
    var10000[59] = 44;
    var10000[60] = 38;
    var10000[61] = 30;
    var10000[62] = 19;
    var10000[63] = 34;
    int[] var10001 = SimpleLongDecrypter.getCachedDecrypter(-732174610889469645L).getEncryptionInts();
    var10001[0] = -47;
    var10001[1] = -29;
    var10001[2] = -20;
    var10001[3] = -12;
    var10001[4] = -58;
    var10001[5] = -11;
    var10001[6] = -32;
    var10001[7] = -48;
    var10001[8] = -4;
    var10001[9] = -8;
    var10001[10] = -31;
    var10001[11] = -34;
    var10001[12] = 4;
    var10001[13] = -40;
    var10001[14] = -28;
    var10001[15] = 12;
    var10001[16] = 11;
    var10001[17] = 8;
    var10001[18] = -45;
    var10001[19] = -25;
    var10001[20] = -13;
    var10001[21] = -15;
    var10001[22] = 20;
    var10001[23] = -38;
    var10001[24] = -28;
    var10001[25] = -23;
    var10001[26] = -3;
    var10001[27] = -12;
    var10001[28] = -6;
    var10001[29] = 3;
    var10001[30] = 29;
    var10001[31] = -19;
    var10001[32] = -14;
    var10001[33] = 13;
    var10001[34] = 6;
    var10001[35] = -19;
    var10001[36] = 15;
    var10001[37] = -21;
    var10001[38] = 32;
    var10001[39] = 12;
    var10001[40] = -9;
    var10001[41] = 31;
    var10001[42] = 28;
    var10001[43] = -16;
    var10001[44] = 25;
    var10001[45] = 34;
    var10001[46] = 14;
    var10001[47] = 47;
    var10001[48] = 23;
    var10001[49] = 9;
    var10001[50] = 19;
    var10001[51] = -5;
    var10001[52] = 28;
    var10001[53] = 40;
    var10001[54] = 19;
    var10001[55] = 48;
    var10001[56] = 5;
    var10001[57] = -3;
    var10001[58] = 21;
    var10001[59] = 16;
    var10001[60] = 3;
    var10001[61] = 38;
    var10001[62] = 58;
    var10001[63] = 45;
    int[] var10002 = SimpleLongDecrypter.getCachedDecrypter(311277116407346596L).getEncryptionInts();
    var10002[0] = -13;
    var10002[1] = -46;
    var10002[2] = -2;
    var10002[3] = -14;
    var10002[4] = 2;
    var10002[5] = -33;
    var10002[6] = -19;
    var10002[7] = -17;
    var10002[8] = -15;
    var10002[9] = -22;
    var10002[10] = -9;
    var10002[11] = -39;
    var10002[12] = -2;
    var10002[13] = 13;
    var10002[14] = 2;
    var10002[15] = -38;
    var10002[16] = -10;
    var10002[17] = 14;
    var10002[18] = -23;
    var10002[19] = 9;
    var10002[20] = -14;
    var10002[21] = -42;
    var10002[22] = -10;
    var10002[23] = 15;
    var10002[24] = 17;
    var10002[25] = 19;
    var10002[26] = 10;
    var10002[27] = -24;
    var10002[28] = -2;
    var10002[29] = -4;
    var10002[30] = 2;
    var10002[31] = 22;
    var10002[32] = 10;
    var10002[33] = 4;
    var10002[34] = 14;
    var10002[35] = -21;
    var10002[36] = -10;
    var10002[37] = -3;
    var10002[38] = 33;
    var10002[39] = -10;
    var10002[40] = 3;
    var10002[41] = 23;
    var10002[42] = -18;
    var10002[43] = -1;
    var10002[44] = 1;
    var10002[45] = -14;
    var10002[46] = 10;
    var10002[47] = 46;
    var10002[48] = -4;
    var10002[49] = 10;
    var10002[50] = 39;
    var10002[51] = 24;
    var10002[52] = 4;
    var10002[53] = 38;
    var10002[54] = -7;
    var10002[55] = -2;
    var10002[56] = 21;
    var10002[57] = 2;
    var10002[58] = -4;
    var10002[59] = 14;
    var10002[60] = 18;
    var10002[61] = 7;
    var10002[62] = 4;
    var10002[63] = 42;
    int[] var10003 = SimpleLongDecrypter.getCachedDecrypter(3573886869861327935L).getEncryptionInts();
    var10003[0] = -13;
    var10003[1] = -46;
    var10003[2] = -2;
    var10003[3] = -14;
    var10003[4] = 2;
    var10003[5] = -33;
    var10003[6] = -19;
    var10003[7] = -17;
    var10003[8] = -28;
    var10003[9] = -13;
    var10003[10] = -21;
    var10003[11] = -15;
    var10003[12] = -50;
    var10003[13] = 13;
    var10003[14] = -49;
    var10003[15] = -5;
    var10003[16] = -16;
    var10003[17] = 14;
    var10003[18] = -5;
    var10003[19] = -40;
    var10003[20] = 5;
    var10003[21] = -13;
    var10003[22] = 13;
    var10003[23] = 5;
    var10003[24] = 17;
    var10003[25] = 19;
    var10003[26] = 15;
    var10003[27] = -23;
    var10003[28] = -25;
    var10003[29] = -19;
    var10003[30] = -31;
    var10003[31] = 21;
    var10003[32] = 16;
    var10003[33] = -18;
    var10003[34] = 13;
    var10003[35] = -2;
    var10003[36] = 28;
    var10003[37] = 2;
    var10003[38] = 33;
    var10003[39] = -2;
    var10003[40] = -12;
    var10003[41] = 2;
    var10003[42] = -1;
    var10003[43] = 1;
    var10003[44] = -14;
    var10003[45] = -9;
    var10003[46] = -10;
    var10003[47] = 46;
    var10003[48] = 19;
    var10003[49] = -11;
    var10003[50] = 23;
    var10003[51] = 18;
    var10003[52] = 12;
    var10003[53] = 25;
    var10003[54] = 9;
    var10003[55] = -2;
    var10003[56] = 10;
    var10003[57] = 2;
    var10003[58] = 14;
    var10003[59] = 40;
    var10003[60] = 11;
    var10003[61] = 31;
    var10003[62] = 50;
    var10003[63] = 49;
    int[] var10004 = SimpleLongDecrypter.getCachedDecrypter(-8088291897303784593L).getEncryptionInts();
    var10004[0] = -13;
    var10004[1] = -46;
    var10004[2] = -2;
    var10004[3] = -14;
    var10004[4] = 2;
    var10004[5] = -33;
    var10004[6] = -19;
    var10004[7] = -17;
    var10004[8] = -21;
    var10004[9] = -36;
    var10004[10] = -29;
    var10004[11] = -21;
    var10004[12] = -9;
    var10004[13] = 13;
    var10004[14] = -36;
    var10004[15] = -46;
    var10004[16] = -30;
    var10004[17] = 14;
    var10004[18] = -36;
    var10004[19] = -4;
    var10004[20] = -20;
    var10004[21] = 9;
    var10004[22] = -20;
    var10004[23] = 4;
    var10004[24] = 17;
    var10004[25] = 19;
    var10004[26] = -15;
    var10004[27] = -8;
    var10004[28] = -30;
    var10004[29] = 21;
    var10004[30] = -29;
    var10004[31] = -31;
    var10004[32] = 21;
    var10004[33] = -20;
    var10004[34] = -15;
    var10004[35] = 8;
    var10004[36] = -1;
    var10004[37] = 1;
    var10004[38] = 33;
    var10004[39] = 29;
    var10004[40] = 20;
    var10004[41] = 15;
    var10004[42] = 20;
    var10004[43] = -9;
    var10004[44] = -12;
    var10004[45] = 36;
    var10004[46] = 30;
    var10004[47] = 46;
    var10004[48] = -12;
    var10004[49] = 15;
    var10004[50] = 36;
    var10004[51] = -12;
    var10004[52] = 9;
    var10004[53] = 20;
    var10004[54] = 36;
    var10004[55] = -2;
    var10004[56] = 12;
    var10004[57] = 2;
    var10004[58] = 30;
    var10004[59] = 29;
    var10004[60] = 12;
    var10004[61] = 46;
    var10004[62] = 31;
    var10004[63] = 12;
    int[] var10005 = SimpleLongDecrypter.getCachedDecrypter(2536297521161778078L).getEncryptionInts();
    var10005[0] = -47;
    var10005[1] = -29;
    var10005[2] = -20;
    var10005[3] = -12;
    var10005[4] = -58;
    var10005[5] = -11;
    var10005[6] = -32;
    var10005[7] = -48;
    var10005[8] = -31;
    var10005[9] = -51;
    var10005[10] = -14;
    var10005[11] = -25;
    var10005[12] = -51;
    var10005[13] = -18;
    var10005[14] = -4;
    var10005[15] = 12;
    var10005[16] = 11;
    var10005[17] = -32;
    var10005[18] = 4;
    var10005[19] = -31;
    var10005[20] = -31;
    var10005[21] = -12;
    var10005[22] = 20;
    var10005[23] = -14;
    var10005[24] = 14;
    var10005[25] = -17;
    var10005[26] = -35;
    var10005[27] = -14;
    var10005[28] = -20;
    var10005[29] = -27;
    var10005[30] = 29;
    var10005[31] = 18;
    var10005[32] = -2;
    var10005[33] = 12;
    var10005[34] = 2;
    var10005[35] = -9;
    var10005[36] = 25;
    var10005[37] = 14;
    var10005[38] = 32;
    var10005[39] = 31;
    var10005[40] = -14;
    var10005[41] = 14;
    var10005[42] = 17;
    var10005[43] = -9;
    var10005[44] = 9;
    var10005[45] = -1;
    var10005[46] = 1;
    var10005[47] = 47;
    var10005[48] = 20;
    var10005[49] = 32;
    var10005[50] = 31;
    var10005[51] = 31;
    var10005[52] = 9;
    var10005[53] = -5;
    var10005[54] = 14;
    var10005[55] = 48;
    var10005[56] = 27;
    var10005[57] = -2;
    var10005[58] = 5;
    var10005[59] = 2;
    var10005[60] = 51;
    var10005[61] = 35;
    var10005[62] = 58;
    var10005[63] = 51;
    int[] var10006 = SimpleLongDecrypter.getCachedDecrypter(-3937235194352561265L).getEncryptionInts();
    var10006[0] = -47;
    var10006[1] = -29;
    var10006[2] = -20;
    var10006[3] = -12;
    var10006[4] = -58;
    var10006[5] = -11;
    var10006[6] = -32;
    var10006[7] = -48;
    var10006[8] = -45;
    var10006[9] = -50;
    var10006[10] = -35;
    var10006[11] = -13;
    var10006[12] = -40;
    var10006[13] = -50;
    var10006[14] = -25;
    var10006[15] = 12;
    var10006[16] = 11;
    var10006[17] = -29;
    var10006[18] = -22;
    var10006[19] = -37;
    var10006[20] = -23;
    var10006[21] = -5;
    var10006[22] = 20;
    var10006[23] = -10;
    var10006[24] = 13;
    var10006[25] = -36;
    var10006[26] = 5;
    var10006[27] = -30;
    var10006[28] = -26;
    var10006[29] = -15;
    var10006[30] = 29;
    var10006[31] = -10;
    var10006[32] = -26;
    var10006[33] = 10;
    var10006[34] = -1;
    var10006[35] = 1;
    var10006[36] = -14;
    var10006[37] = -11;
    var10006[38] = 32;
    var10006[39] = 25;
    var10006[40] = 22;
    var10006[41] = 10;
    var10006[42] = -9;
    var10006[43] = 23;
    var10006[44] = 15;
    var10006[45] = 35;
    var10006[46] = 29;
    var10006[47] = 47;
    var10006[48] = 11;
    var10006[49] = -11;
    var10006[50] = 14;
    var10006[51] = 9;
    var10006[52] = 40;
    var10006[53] = 45;
    var10006[54] = 26;
    var10006[55] = 48;
    var10006[56] = 37;
    var10006[57] = 30;
    var10006[58] = 26;
    var10006[59] = 50;
    var10006[60] = 11;
    var10006[61] = 36;
    var10006[62] = 58;
    var10006[63] = 50;
    int[] var10007 = SimpleLongDecrypter.getCachedDecrypter(-2196368890409135898L).getEncryptionInts();
    var10007[0] = -13;
    var10007[1] = -46;
    var10007[2] = -2;
    var10007[3] = -14;
    var10007[4] = 2;
    var10007[5] = -33;
    var10007[6] = -19;
    var10007[7] = -17;
    var10007[8] = -53;
    var10007[9] = -32;
    var10007[10] = -30;
    var10007[11] = -21;
    var10007[12] = -51;
    var10007[13] = 13;
    var10007[14] = -4;
    var10007[15] = -47;
    var10007[16] = -17;
    var10007[17] = 14;
    var10007[18] = 4;
    var10007[19] = -4;
    var10007[20] = -38;
    var10007[21] = -22;
    var10007[22] = -8;
    var10007[23] = 4;
    var10007[24] = 17;
    var10007[25] = 19;
    var10007[26] = -25;
    var10007[27] = -17;
    var10007[28] = -25;
    var10007[29] = -21;
    var10007[30] = 8;
    var10007[31] = -3;
    var10007[32] = 21;
    var10007[33] = 17;
    var10007[34] = 3;
    var10007[35] = -14;
    var10007[36] = -9;
    var10007[37] = -2;
    var10007[38] = 33;
    var10007[39] = 2;
    var10007[40] = 30;
    var10007[41] = 32;
    var10007[42] = -18;
    var10007[43] = 22;
    var10007[44] = 17;
    var10007[45] = 9;
    var10007[46] = -6;
    var10007[47] = 46;
    var10007[48] = -8;
    var10007[49] = 14;
    var10007[50] = 21;
    var10007[51] = 25;
    var10007[52] = 6;
    var10007[53] = 25;
    var10007[54] = -5;
    var10007[55] = -2;
    var10007[56] = 8;
    var10007[57] = 2;
    var10007[58] = 38;
    var10007[59] = 5;
    var10007[60] = 18;
    var10007[61] = 53;
    var10007[62] = 47;
    var10007[63] = 51;
    int[] var10008 = SimpleLongDecrypter.getCachedDecrypter(6225524340471897257L).getEncryptionInts();
    var10008[0] = -13;
    var10008[1] = -46;
    var10008[2] = -2;
    var10008[3] = -14;
    var10008[4] = 2;
    var10008[5] = -33;
    var10008[6] = -19;
    var10008[7] = -17;
    var10008[8] = -32;
    var10008[9] = -11;
    var10008[10] = -19;
    var10008[11] = -19;
    var10008[12] = -49;
    var10008[13] = 13;
    var10008[14] = -42;
    var10008[15] = -45;
    var10008[16] = -16;
    var10008[17] = 14;
    var10008[18] = -33;
    var10008[19] = -3;
    var10008[20] = 11;
    var10008[21] = -13;
    var10008[22] = 3;
    var10008[23] = -12;
    var10008[24] = 17;
    var10008[25] = 19;
    var10008[26] = -11;
    var10008[27] = -12;
    var10008[28] = -25;
    var10008[29] = 19;
    var10008[30] = 19;
    var10008[31] = -18;
    var10008[32] = 16;
    var10008[33] = -21;
    var10008[34] = 13;
    var10008[35] = 12;
    var10008[36] = -16;
    var10008[37] = 11;
    var10008[38] = 33;
    var10008[39] = 12;
    var10008[40] = 32;
    var10008[41] = -18;
    var10008[42] = -20;
    var10008[43] = -15;
    var10008[44] = -4;
    var10008[45] = -1;
    var10008[46] = 1;
    var10008[47] = 46;
    var10008[48] = 4;
    var10008[49] = 18;
    var10008[50] = -13;
    var10008[51] = 33;
    var10008[52] = 16;
    var10008[53] = 25;
    var10008[54] = 21;
    var10008[55] = -2;
    var10008[56] = 42;
    var10008[57] = 2;
    var10008[58] = 15;
    var10008[59] = 18;
    var10008[60] = 45;
    var10008[61] = 49;
    var10008[62] = 20;
    var10008[63] = 13;
    int[] var10009 = SimpleLongDecrypter.getCachedDecrypter(585673308755942405L).getEncryptionInts();
    var10009[0] = -47;
    var10009[1] = -29;
    var10009[2] = -20;
    var10009[3] = -12;
    var10009[4] = -58;
    var10009[5] = -11;
    var10009[6] = -32;
    var10009[7] = -48;
    var10009[8] = -48;
    var10009[9] = -36;
    var10009[10] = -34;
    var10009[11] = -39;
    var10009[12] = -40;
    var10009[13] = -27;
    var10009[14] = -17;
    var10009[15] = 12;
    var10009[16] = 11;
    var10009[17] = -9;
    var10009[18] = -43;
    var10009[19] = -6;
    var10009[20] = -34;
    var10009[21] = -30;
    var10009[22] = 20;
    var10009[23] = -13;
    var10009[24] = -4;
    var10009[25] = 6;
    var10009[26] = 9;
    var10009[27] = -32;
    var10009[28] = 4;
    var10009[29] = -12;
    var10009[30] = 29;
    var10009[31] = 17;
    var10009[32] = -14;
    var10009[33] = -20;
    var10009[34] = -9;
    var10009[35] = -4;
    var10009[36] = 13;
    var10009[37] = -12;
    var10009[38] = 32;
    var10009[39] = 4;
    var10009[40] = 27;
    var10009[41] = 12;
    var10009[42] = -18;
    var10009[43] = 9;
    var10009[44] = 34;
    var10009[45] = 36;
    var10009[46] = 14;
    var10009[47] = 47;
    var10009[48] = -9;
    var10009[49] = 12;
    var10009[50] = 39;
    var10009[51] = 30;
    var10009[52] = 40;
    var10009[53] = 20;
    var10009[54] = 34;
    var10009[55] = 48;
    var10009[56] = 48;
    var10009[57] = 9;
    var10009[58] = -5;
    var10009[59] = 32;
    var10009[60] = 18;
    var10009[61] = 43;
    var10009[62] = 58;
    var10009[63] = 5;
    int[] var10010 = SimpleLongDecrypter.getCachedDecrypter(222902674777066608L).getEncryptionInts();
    var10010[0] = -47;
    var10010[1] = -29;
    var10010[2] = -20;
    var10010[3] = -12;
    var10010[4] = -58;
    var10010[5] = -11;
    var10010[6] = -32;
    var10010[7] = -48;
    var10010[8] = -27;
    var10010[9] = -12;
    var10010[10] = -29;
    var10010[11] = -14;
    var10010[12] = -48;
    var10010[13] = -28;
    var10010[14] = -44;
    var10010[15] = 12;
    var10010[16] = 11;
    var10010[17] = -32;
    var10010[18] = -38;
    var10010[19] = -33;
    var10010[20] = -12;
    var10010[21] = 12;
    var10010[22] = 20;
    var10010[23] = -19;
    var10010[24] = -26;
    var10010[25] = 14;
    var10010[26] = -7;
    var10010[27] = -4;
    var10010[28] = -8;
    var10010[29] = -11;
    var10010[30] = 29;
    var10010[31] = 4;
    var10010[32] = 12;
    var10010[33] = 7;
    var10010[34] = -25;
    var10010[35] = 27;
    var10010[36] = 8;
    var10010[37] = -8;
    var10010[38] = 32;
    var10010[39] = 29;
    var10010[40] = 11;
    var10010[41] = 28;
    var10010[42] = 19;
    var10010[43] = -11;
    var10010[44] = -2;
    var10010[45] = 8;
    var10010[46] = 2;
    var10010[47] = 47;
    var10010[48] = -3;
    var10010[49] = 32;
    var10010[50] = 26;
    var10010[51] = 3;
    var10010[52] = 33;
    var10010[53] = -4;
    var10010[54] = 11;
    var10010[55] = 48;
    var10010[56] = 38;
    var10010[57] = 4;
    var10010[58] = 44;
    var10010[59] = 25;
    var10010[60] = 48;
    var10010[61] = -2;
    var10010[62] = 58;
    var10010[63] = 2;
    int[] var10011 = SimpleLongDecrypter.getCachedDecrypter(-8311871109988165652L).getEncryptionInts();
    var10011[0] = -13;
    var10011[1] = -46;
    var10011[2] = -2;
    var10011[3] = -14;
    var10011[4] = 2;
    var10011[5] = -33;
    var10011[6] = -19;
    var10011[7] = -17;
    var10011[8] = -19;
    var10011[9] = -30;
    var10011[10] = -39;
    var10011[11] = -25;
    var10011[12] = -8;
    var10011[13] = 13;
    var10011[14] = -17;
    var10011[15] = -46;
    var10011[16] = -21;
    var10011[17] = 14;
    var10011[18] = -23;
    var10011[19] = -44;
    var10011[20] = 8;
    var10011[21] = -9;
    var10011[22] = -23;
    var10011[23] = -3;
    var10011[24] = 17;
    var10011[25] = 19;
    var10011[26] = 3;
    var10011[27] = 19;
    var10011[28] = -26;
    var10011[29] = -27;
    var10011[30] = 9;
    var10011[31] = 17;
    var10011[32] = -28;
    var10011[33] = -17;
    var10011[34] = -17;
    var10011[35] = -13;
    var10011[36] = 25;
    var10011[37] = 21;
    var10011[38] = 33;
    var10011[39] = 30;
    var10011[40] = -4;
    var10011[41] = 23;
    var10011[42] = -16;
    var10011[43] = -10;
    var10011[44] = 4;
    var10011[45] = 23;
    var10011[46] = -16;
    var10011[47] = 46;
    var10011[48] = 13;
    var10011[49] = 39;
    var10011[50] = 17;
    var10011[51] = 17;
    var10011[52] = -7;
    var10011[53] = 10;
    var10011[54] = 26;
    var10011[55] = -2;
    var10011[56] = 27;
    var10011[57] = 2;
    var10011[58] = 16;
    var10011[59] = 7;
    var10011[60] = 28;
    var10011[61] = 46;
    var10011[62] = 16;
    var10011[63] = 44;
    int[] var10012 = SimpleLongDecrypter.getCachedDecrypter(-2804476685438403728L).getEncryptionInts();
    var10012[0] = -47;
    var10012[1] = -29;
    var10012[2] = -20;
    var10012[3] = -12;
    var10012[4] = -58;
    var10012[5] = -11;
    var10012[6] = -32;
    var10012[7] = -48;
    var10012[8] = -55;
    var10012[9] = -36;
    var10012[10] = -16;
    var10012[11] = -47;
    var10012[12] = -25;
    var10012[13] = -19;
    var10012[14] = -6;
    var10012[15] = 12;
    var10012[16] = 11;
    var10012[17] = -43;
    var10012[18] = -10;
    var10012[19] = -6;
    var10012[20] = 6;
    var10012[21] = -40;
    var10012[22] = 20;
    var10012[23] = -17;
    var10012[24] = -9;
    var10012[25] = 6;
    var10012[26] = 16;
    var10012[27] = -24;
    var10012[28] = 10;
    var10012[29] = -20;
    var10012[30] = 29;
    var10012[31] = -28;
    var10012[32] = 19;
    var10012[33] = 9;
    var10012[34] = -16;
    var10012[35] = -8;
    var10012[36] = -3;
    var10012[37] = 25;
    var10012[38] = 32;
    var10012[39] = 3;
    var10012[40] = 17;
    var10012[41] = -12;
    var10012[42] = -10;
    var10012[43] = 8;
    var10012[44] = -12;
    var10012[45] = 36;
    var10012[46] = -11;
    var10012[47] = 47;
    var10012[48] = -6;
    var10012[49] = 20;
    var10012[50] = 16;
    var10012[51] = 24;
    var10012[52] = 10;
    var10012[53] = 12;
    var10012[54] = 6;
    var10012[55] = 48;
    var10012[56] = 12;
    var10012[57] = 11;
    var10012[58] = 47;
    var10012[59] = 28;
    var10012[60] = 43;
    var10012[61] = 40;
    var10012[62] = 58;
    var10012[63] = 55;
    int[] var10013 = SimpleLongDecrypter.getCachedDecrypter(-4339146255632361389L).getEncryptionInts();
    var10013[0] = -13;
    var10013[1] = -46;
    var10013[2] = -2;
    var10013[3] = -14;
    var10013[4] = 2;
    var10013[5] = -33;
    var10013[6] = -19;
    var10013[7] = -17;
    var10013[8] = -18;
    var10013[9] = -22;
    var10013[10] = -27;
    var10013[11] = -12;
    var10013[12] = -6;
    var10013[13] = 13;
    var10013[14] = -42;
    var10013[15] = -31;
    var10013[16] = -23;
    var10013[17] = 14;
    var10013[18] = 6;
    var10013[19] = -25;
    var10013[20] = -43;
    var10013[21] = -22;
    var10013[22] = -19;
    var10013[23] = 12;
    var10013[24] = 17;
    var10013[25] = 19;
    var10013[26] = 18;
    var10013[27] = -21;
    var10013[28] = -34;
    var10013[29] = -7;
    var10013[30] = -23;
    var10013[31] = 22;
    var10013[32] = -17;
    var10013[33] = -19;
    var10013[34] = -26;
    var10013[35] = -23;
    var10013[36] = 7;
    var10013[37] = 27;
    var10013[38] = 33;
    var10013[39] = 23;
    var10013[40] = -11;
    var10013[41] = 19;
    var10013[42] = -12;
    var10013[43] = 22;
    var10013[44] = 25;
    var10013[45] = -16;
    var10013[46] = 31;
    var10013[47] = 46;
    var10013[48] = 21;
    var10013[49] = 17;
    var10013[50] = -9;
    var10013[51] = 11;
    var10013[52] = 19;
    var10013[53] = 23;
    var10013[54] = 12;
    var10013[55] = -2;
    var10013[56] = 42;
    var10013[57] = 2;
    var10013[58] = 23;
    var10013[59] = 9;
    var10013[60] = 26;
    var10013[61] = 16;
    var10013[62] = 34;
    var10013[63] = 43;
    int[] var10014 = SimpleLongDecrypter.getCachedDecrypter(-7938614726365082053L).getEncryptionInts();
    var10014[0] = -47;
    var10014[1] = -29;
    var10014[2] = -20;
    var10014[3] = -12;
    var10014[4] = -58;
    var10014[5] = -11;
    var10014[6] = -32;
    var10014[7] = -48;
    var10014[8] = -48;
    var10014[9] = -50;
    var10014[10] = -35;
    var10014[11] = -41;
    var10014[12] = -14;
    var10014[13] = -18;
    var10014[14] = -25;
    var10014[15] = 12;
    var10014[16] = 11;
    var10014[17] = -26;
    var10014[18] = -10;
    var10014[19] = -23;
    var10014[20] = -15;
    var10014[21] = -20;
    var10014[22] = 20;
    var10014[23] = -31;
    var10014[24] = -10;
    var10014[25] = -26;
    var10014[26] = 14;
    var10014[27] = -36;
    var10014[28] = 10;
    var10014[29] = -32;
    var10014[30] = 29;
    var10014[31] = 18;
    var10014[32] = -18;
    var10014[33] = -20;
    var10014[34] = 10;
    var10014[35] = 15;
    var10014[36] = -10;
    var10014[37] = -23;
    var10014[38] = 32;
    var10014[39] = 25;
    var10014[40] = -9;
    var10014[41] = 20;
    var10014[42] = 23;
    var10014[43] = 26;
    var10014[44] = -13;
    var10014[45] = 35;
    var10014[46] = 10;
    var10014[47] = 47;
    var10014[48] = -10;
    var10014[49] = 9;
    var10014[50] = 18;
    var10014[51] = 26;
    var10014[52] = 41;
    var10014[53] = 20;
    var10014[54] = 31;
    var10014[55] = 48;
    var10014[56] = 48;
    var10014[57] = 13;
    var10014[58] = 10;
    var10014[59] = 50;
    var10014[60] = 23;
    var10014[61] = 32;
    var10014[62] = 58;
    var10014[63] = 36;
    int[] var10015 = SimpleLongDecrypter.getCachedDecrypter(-8795115415588106499L).getEncryptionInts();
    var10015[0] = -47;
    var10015[1] = -29;
    var10015[2] = -20;
    var10015[3] = -12;
    var10015[4] = -58;
    var10015[5] = -11;
    var10015[6] = -32;
    var10015[7] = -48;
    var10015[8] = -9;
    var10015[9] = -34;
    var10015[10] = -42;
    var10015[11] = -13;
    var10015[12] = -41;
    var10015[13] = -38;
    var10015[14] = -30;
    var10015[15] = 12;
    var10015[16] = 11;
    var10015[17] = 9;
    var10015[18] = -9;
    var10015[19] = -2;
    var10015[20] = -21;
    var10015[21] = 2;
    var10015[22] = 20;
    var10015[23] = -11;
    var10015[24] = 13;
    var10015[25] = -6;
    var10015[26] = -9;
    var10015[27] = 9;
    var10015[28] = -20;
    var10015[29] = -30;
    var10015[30] = 29;
    var10015[31] = 6;
    var10015[32] = -4;
    var10015[33] = -7;
    var10015[34] = 11;
    var10015[35] = 9;
    var10015[36] = 4;
    var10015[37] = -21;
    var10015[38] = 32;
    var10015[39] = -21;
    var10015[40] = 7;
    var10015[41] = 21;
    var10015[42] = -7;
    var10015[43] = 34;
    var10015[44] = 30;
    var10015[45] = -9;
    var10015[46] = -11;
    var10015[47] = 47;
    var10015[48] = 20;
    var10015[49] = 7;
    var10015[50] = -11;
    var10015[51] = 38;
    var10015[52] = 42;
    var10015[53] = 41;
    var10015[54] = 9;
    var10015[55] = 48;
    var10015[56] = -7;
    var10015[57] = 11;
    var10015[58] = 21;
    var10015[59] = 30;
    var10015[60] = 21;
    var10015[61] = 11;
    var10015[62] = 58;
    var10015[63] = 7;
    int[] var10016 = SimpleLongDecrypter.getCachedDecrypter(-5862441065954389428L).getEncryptionInts();
    var10016[0] = -47;
    var10016[1] = -29;
    var10016[2] = -20;
    var10016[3] = -12;
    var10016[4] = -58;
    var10016[5] = -11;
    var10016[6] = -32;
    var10016[7] = -48;
    var10016[8] = -25;
    var10016[9] = -16;
    var10016[10] = -38;
    var10016[11] = -38;
    var10016[12] = -31;
    var10016[13] = -38;
    var10016[14] = -49;
    var10016[15] = 12;
    var10016[16] = 11;
    var10016[17] = -17;
    var10016[18] = -24;
    var10016[19] = -12;
    var10016[20] = -12;
    var10016[21] = -6;
    var10016[22] = 20;
    var10016[23] = -5;
    var10016[24] = -36;
    var10016[25] = 16;
    var10016[26] = -24;
    var10016[27] = 6;
    var10016[28] = 5;
    var10016[29] = -27;
    var10016[30] = 29;
    var10016[31] = 12;
    var10016[32] = 12;
    var10016[33] = 25;
    var10016[34] = 17;
    var10016[35] = -19;
    var10016[36] = -21;
    var10016[37] = -24;
    var10016[38] = 32;
    var10016[39] = -2;
    var10016[40] = -13;
    var10016[41] = 2;
    var10016[42] = 24;
    var10016[43] = 31;
    var10016[44] = -1;
    var10016[45] = 1;
    var10016[46] = -6;
    var10016[47] = 47;
    var10016[48] = 38;
    var10016[49] = 38;
    var10016[50] = 24;
    var10016[51] = 38;
    var10016[52] = 6;
    var10016[53] = 13;
    var10016[54] = 19;
    var10016[55] = 48;
    var10016[56] = 27;
    var10016[57] = 21;
    var10016[58] = -1;
    var10016[59] = 1;
    var10016[60] = 36;
    var10016[61] = 24;
    var10016[62] = 58;
    var10016[63] = 49;
    int[] var10017 = SimpleLongDecrypter.getCachedDecrypter(-4079211624705094744L).getEncryptionInts();
    var10017[0] = -13;
    var10017[1] = -46;
    var10017[2] = -2;
    var10017[3] = -14;
    var10017[4] = 2;
    var10017[5] = -33;
    var10017[6] = -19;
    var10017[7] = -17;
    var10017[8] = -20;
    var10017[9] = -17;
    var10017[10] = -42;
    var10017[11] = -29;
    var10017[12] = -15;
    var10017[13] = 13;
    var10017[14] = -5;
    var10017[15] = -31;
    var10017[16] = -29;
    var10017[17] = 14;
    var10017[18] = -45;
    var10017[19] = 5;
    var10017[20] = -17;
    var10017[21] = -32;
    var10017[22] = -17;
    var10017[23] = -18;
    var10017[24] = 17;
    var10017[25] = 19;
    var10017[26] = 17;
    var10017[27] = 15;
    var10017[28] = 20;
    var10017[29] = -20;
    var10017[30] = -6;
    var10017[31] = -31;
    var10017[32] = -26;
    var10017[33] = -27;
    var10017[34] = -20;
    var10017[35] = -16;
    var10017[36] = 6;
    var10017[37] = 17;
    var10017[38] = 33;
    var10017[39] = 17;
    var10017[40] = 29;
    var10017[41] = 18;
    var10017[42] = -17;
    var10017[43] = -13;
    var10017[44] = -17;
    var10017[45] = 29;
    var10017[46] = 31;
    var10017[47] = 46;
    var10017[48] = -2;
    var10017[49] = 20;
    var10017[50] = 2;
    var10017[51] = 16;
    var10017[52] = 42;
    var10017[53] = 32;
    var10017[54] = 20;
    var10017[55] = -2;
    var10017[56] = 13;
    var10017[57] = 2;
    var10017[58] = 26;
    var10017[59] = 17;
    var10017[60] = 27;
    var10017[61] = 17;
    var10017[62] = 31;
    var10017[63] = 45;
    int[] var10018 = SimpleLongDecrypter.getCachedDecrypter(-5137695640643056922L).getEncryptionInts();
    var10018[0] = -13;
    var10018[1] = -46;
    var10018[2] = -2;
    var10018[3] = -14;
    var10018[4] = 2;
    var10018[5] = -33;
    var10018[6] = -19;
    var10018[7] = -17;
    var10018[8] = -14;
    var10018[9] = -42;
    var10018[10] = -42;
    var10018[11] = -16;
    var10018[12] = -22;
    var10018[13] = 13;
    var10018[14] = -30;
    var10018[15] = -4;
    var10018[16] = -32;
    var10018[17] = 14;
    var10018[18] = -5;
    var10018[19] = 4;
    var10018[20] = -36;
    var10018[21] = -39;
    var10018[22] = 14;
    var10018[23] = 5;
    var10018[24] = 17;
    var10018[25] = 19;
    var10018[26] = -9;
    var10018[27] = 16;
    var10018[28] = -15;
    var10018[29] = -2;
    var10018[30] = -33;
    var10018[31] = 2;
    var10018[32] = -26;
    var10018[33] = -8;
    var10018[34] = 22;
    var10018[35] = 9;
    var10018[36] = -4;
    var10018[37] = -22;
    var10018[38] = 33;
    var10018[39] = -14;
    var10018[40] = 4;
    var10018[41] = 8;
    var10018[42] = -8;
    var10018[43] = 15;
    var10018[44] = 30;
    var10018[45] = -16;
    var10018[46] = -3;
    var10018[47] = 46;
    var10018[48] = 32;
    var10018[49] = 3;
    var10018[50] = 8;
    var10018[51] = 42;
    var10018[52] = 42;
    var10018[53] = 14;
    var10018[54] = -8;
    var10018[55] = -2;
    var10018[56] = 36;
    var10018[57] = 2;
    var10018[58] = 26;
    var10018[59] = 22;
    var10018[60] = 39;
    var10018[61] = 16;
    var10018[62] = 8;
    var10018[63] = 33;
    int[] var10019 = SimpleLongDecrypter.getCachedDecrypter(9206375288206380280L).getEncryptionInts();
    var10019[0] = -47;
    var10019[1] = -29;
    var10019[2] = -20;
    var10019[3] = -12;
    var10019[4] = -58;
    var10019[5] = -11;
    var10019[6] = -32;
    var10019[7] = -48;
    var10019[8] = -17;
    var10019[9] = -52;
    var10019[10] = -17;
    var10019[11] = -28;
    var10019[12] = -42;
    var10019[13] = -28;
    var10019[14] = -4;
    var10019[15] = 12;
    var10019[16] = 11;
    var10019[17] = -12;
    var10019[18] = 4;
    var10019[19] = -25;
    var10019[20] = -20;
    var10019[21] = -28;
    var10019[22] = 20;
    var10019[23] = -27;
    var10019[24] = -36;
    var10019[25] = 17;
    var10019[26] = -8;
    var10019[27] = 17;
    var10019[28] = -24;
    var10019[29] = 12;
    var10019[30] = 29;
    var10019[31] = -14;
    var10019[32] = -10;
    var10019[33] = -3;
    var10019[34] = 8;
    var10019[35] = -18;
    var10019[36] = 3;
    var10019[37] = -21;
    var10019[38] = 32;
    var10019[39] = 28;
    var10019[40] = 20;
    var10019[41] = 28;
    var10019[42] = 10;
    var10019[43] = -14;
    var10019[44] = 25;
    var10019[45] = 14;
    var10019[46] = -13;
    var10019[47] = 47;
    var10019[48] = -15;
    var10019[49] = 28;
    var10019[50] = 27;
    var10019[51] = -5;
    var10019[52] = 24;
    var10019[53] = 18;
    var10019[54] = 42;
    var10019[55] = 48;
    var10019[56] = 5;
    var10019[57] = 14;
    var10019[58] = 21;
    var10019[59] = 13;
    var10019[60] = 36;
    var10019[61] = 52;
    var10019[62] = 58;
    var10019[63] = 15;
    int[] var10020 = SimpleLongDecrypter.getCachedDecrypter(4897631728732188407L).getEncryptionInts();
    var10020[0] = -13;
    var10020[1] = -46;
    var10020[2] = -2;
    var10020[3] = -14;
    var10020[4] = 2;
    var10020[5] = -33;
    var10020[6] = -19;
    var10020[7] = -17;
    var10020[8] = -18;
    var10020[9] = -43;
    var10020[10] = -44;
    var10020[11] = -37;
    var10020[12] = -31;
    var10020[13] = 13;
    var10020[14] = -32;
    var10020[15] = -13;
    var10020[16] = -19;
    var10020[17] = 14;
    var10020[18] = -21;
    var10020[19] = -3;
    var10020[20] = -14;
    var10020[21] = -42;
    var10020[22] = 3;
    var10020[23] = -7;
    var10020[24] = 17;
    var10020[25] = 19;
    var10020[26] = 18;
    var10020[27] = -22;
    var10020[28] = 13;
    var10020[29] = -32;
    var10020[30] = 7;
    var10020[31] = -20;
    var10020[32] = -27;
    var10020[33] = -27;
    var10020[34] = 14;
    var10020[35] = 19;
    var10020[36] = -26;
    var10020[37] = -19;
    var10020[38] = 33;
    var10020[39] = 21;
    var10020[40] = -10;
    var10020[41] = -1;
    var10020[42] = 1;
    var10020[43] = 31;
    var10020[44] = -14;
    var10020[45] = -8;
    var10020[46] = 32;
    var10020[47] = 46;
    var10020[48] = 37;
    var10020[49] = 22;
    var10020[50] = 10;
    var10020[51] = 20;
    var10020[52] = 43;
    var10020[53] = 8;
    var10020[54] = 44;
    var10020[55] = -2;
    var10020[56] = 19;
    var10020[57] = 2;
    var10020[58] = 14;
    var10020[59] = 27;
    var10020[60] = 27;
    var10020[61] = 32;
    var10020[62] = 26;
    var10020[63] = 42;
    int[] var10021 = SimpleLongDecrypter.getCachedDecrypter(4247992522478179471L).getEncryptionInts();
    var10021[0] = -13;
    var10021[1] = -46;
    var10021[2] = -2;
    var10021[3] = -14;
    var10021[4] = 2;
    var10021[5] = -33;
    var10021[6] = -19;
    var10021[7] = -17;
    var10021[8] = -32;
    var10021[9] = -52;
    var10021[10] = -8;
    var10021[11] = -31;
    var10021[12] = -18;
    var10021[13] = 13;
    var10021[14] = -23;
    var10021[15] = -18;
    var10021[16] = -18;
    var10021[17] = 14;
    var10021[18] = 8;
    var10021[19] = -20;
    var10021[20] = -31;
    var10021[21] = -1;
    var10021[22] = 1;
    var10021[23] = -4;
    var10021[24] = 17;
    var10021[25] = 19;
    var10021[26] = -27;
    var10021[27] = 4;
    var10021[28] = -28;
    var10021[29] = -15;
    var10021[30] = 18;
    var10021[31] = -5;
    var10021[32] = -17;
    var10021[33] = 18;
    var10021[34] = 18;
    var10021[35] = -8;
    var10021[36] = 5;
    var10021[37] = 23;
    var10021[38] = 33;
    var10021[39] = 20;
    var10021[40] = 32;
    var10021[41] = -21;
    var10021[42] = 31;
    var10021[43] = 8;
    var10021[44] = 15;
    var10021[45] = -5;
    var10021[46] = -8;
    var10021[47] = 46;
    var10021[48] = -10;
    var10021[49] = 17;
    var10021[50] = 5;
    var10021[51] = 31;
    var10021[52] = -8;
    var10021[53] = 27;
    var10021[54] = 8;
    var10021[55] = -2;
    var10021[56] = 28;
    var10021[57] = 2;
    var10021[58] = 10;
    var10021[59] = -4;
    var10021[60] = 8;
    var10021[61] = 52;
    var10021[62] = 21;
    var10021[63] = 4;
    int[] var10022 = SimpleLongDecrypter.getCachedDecrypter(6787008718202684364L).getEncryptionInts();
    var10022[0] = -47;
    var10022[1] = -29;
    var10022[2] = -20;
    var10022[3] = -12;
    var10022[4] = -58;
    var10022[5] = -11;
    var10022[6] = -32;
    var10022[7] = -48;
    var10022[8] = -53;
    var10022[9] = -26;
    var10022[10] = -43;
    var10022[11] = -10;
    var10022[12] = -32;
    var10022[13] = -11;
    var10022[14] = -29;
    var10022[15] = 12;
    var10022[16] = 11;
    var10022[17] = -43;
    var10022[18] = -11;
    var10022[19] = -23;
    var10022[20] = -31;
    var10022[21] = 10;
    var10022[22] = 20;
    var10022[23] = -23;
    var10022[24] = 11;
    var10022[25] = -9;
    var10022[26] = -31;
    var10022[27] = -32;
    var10022[28] = -3;
    var10022[29] = 11;
    var10022[30] = 29;
    var10022[31] = 3;
    var10022[32] = -8;
    var10022[33] = -16;
    var10022[34] = 9;
    var10022[35] = 26;
    var10022[36] = -1;
    var10022[37] = 1;
    var10022[38] = 32;
    var10022[39] = -24;
    var10022[40] = 8;
    var10022[41] = -7;
    var10022[42] = 23;
    var10022[43] = 29;
    var10022[44] = 32;
    var10022[45] = -5;
    var10022[46] = 23;
    var10022[47] = 47;
    var10022[48] = 7;
    var10022[49] = 16;
    var10022[50] = 5;
    var10022[51] = 31;
    var10022[52] = -4;
    var10022[53] = 43;
    var10022[54] = -4;
    var10022[55] = 48;
    var10022[56] = 4;
    var10022[57] = 31;
    var10022[58] = 4;
    var10022[59] = 32;
    var10022[60] = 43;
    var10022[61] = 53;
    var10022[62] = 58;
    var10022[63] = 24;
    int[] var10023 = SimpleLongDecrypter.getCachedDecrypter(2843900069307882856L).getEncryptionInts();
    var10023[0] = -47;
    var10023[1] = -29;
    var10023[2] = -20;
    var10023[3] = -12;
    var10023[4] = -58;
    var10023[5] = -11;
    var10023[6] = -32;
    var10023[7] = -48;
    var10023[8] = -11;
    var10023[9] = -12;
    var10023[10] = -40;
    var10023[11] = -14;
    var10023[12] = -41;
    var10023[13] = -50;
    var10023[14] = -43;
    var10023[15] = 12;
    var10023[16] = 11;
    var10023[17] = -9;
    var10023[18] = -38;
    var10023[19] = 11;
    var10023[20] = -20;
    var10023[21] = 12;
    var10023[22] = 20;
    var10023[23] = -18;
    var10023[24] = -4;
    var10023[25] = 14;
    var10023[26] = 9;
    var10023[27] = -27;
    var10023[28] = 4;
    var10023[29] = -8;
    var10023[30] = 29;
    var10023[31] = -17;
    var10023[32] = -1;
    var10023[33] = 1;
    var10023[34] = -26;
    var10023[35] = -11;
    var10023[36] = -13;
    var10023[37] = 8;
    var10023[38] = 32;
    var10023[39] = -3;
    var10023[40] = 20;
    var10023[41] = 18;
    var10023[42] = 3;
    var10023[43] = -9;
    var10023[44] = -17;
    var10023[45] = -13;
    var10023[46] = 11;
    var10023[47] = 47;
    var10023[48] = 17;
    var10023[49] = 13;
    var10023[50] = 40;
    var10023[51] = -8;
    var10023[52] = 9;
    var10023[53] = 41;
    var10023[54] = 27;
    var10023[55] = 48;
    var10023[56] = 38;
    var10023[57] = 43;
    var10023[58] = 13;
    var10023[59] = 8;
    var10023[60] = 26;
    var10023[61] = 17;
    var10023[62] = 58;
    var10023[63] = 50;
    int[] var10024 = SimpleLongDecrypter.getCachedDecrypter(1314517845669453177L).getEncryptionInts();
    var10024[0] = -47;
    var10024[1] = -29;
    var10024[2] = -20;
    var10024[3] = -12;
    var10024[4] = -58;
    var10024[5] = -11;
    var10024[6] = -32;
    var10024[7] = -48;
    var10024[8] = -53;
    var10024[9] = -41;
    var10024[10] = -24;
    var10024[11] = -14;
    var10024[12] = -5;
    var10024[13] = -13;
    var10024[14] = -44;
    var10024[15] = 12;
    var10024[16] = 11;
    var10024[17] = 5;
    var10024[18] = -26;
    var10024[19] = -17;
    var10024[20] = -36;
    var10024[21] = -27;
    var10024[22] = 20;
    var10024[23] = -28;
    var10024[24] = -11;
    var10024[25] = 14;
    var10024[26] = 13;
    var10024[27] = -25;
    var10024[28] = -32;
    var10024[29] = -13;
    var10024[30] = 29;
    var10024[31] = -1;
    var10024[32] = 1;
    var10024[33] = -4;
    var10024[34] = 24;
    var10024[35] = 11;
    var10024[36] = 17;
    var10024[37] = 4;
    var10024[38] = 32;
    var10024[39] = -6;
    var10024[40] = -14;
    var10024[41] = -18;
    var10024[42] = 13;
    var10024[43] = -14;
    var10024[44] = 26;
    var10024[45] = 6;
    var10024[46] = -7;
    var10024[47] = 47;
    var10024[48] = 27;
    var10024[49] = -14;
    var10024[50] = 41;
    var10024[51] = 28;
    var10024[52] = 25;
    var10024[53] = 7;
    var10024[54] = 14;
    var10024[55] = 48;
    var10024[56] = 36;
    var10024[57] = 14;
    var10024[58] = 44;
    var10024[59] = 18;
    var10024[60] = 32;
    var10024[61] = 53;
    var10024[62] = 58;
    var10024[63] = 14;
    int[] var10025 = SimpleLongDecrypter.getCachedDecrypter(2428257667479886378L).getEncryptionInts();
    var10025[0] = -13;
    var10025[1] = -46;
    var10025[2] = -2;
    var10025[3] = -14;
    var10025[4] = 2;
    var10025[5] = -33;
    var10025[6] = -19;
    var10025[7] = -17;
    var10025[8] = -43;
    var10025[9] = -27;
    var10025[10] = -24;
    var10025[11] = -15;
    var10025[12] = -28;
    var10025[13] = 13;
    var10025[14] = -9;
    var10025[15] = -27;
    var10025[16] = -11;
    var10025[17] = 14;
    var10025[18] = -41;
    var10025[19] = -16;
    var10025[20] = -17;
    var10025[21] = -22;
    var10025[22] = -23;
    var10025[23] = 9;
    var10025[24] = 17;
    var10025[25] = 19;
    var10025[26] = 15;
    var10025[27] = 11;
    var10025[28] = -18;
    var10025[29] = -29;
    var10025[30] = -9;
    var10025[31] = -30;
    var10025[32] = -22;
    var10025[33] = -8;
    var10025[34] = 24;
    var10025[35] = 16;
    var10025[36] = 27;
    var10025[37] = 17;
    var10025[38] = 33;
    var10025[39] = 9;
    var10025[40] = 28;
    var10025[41] = 8;
    var10025[42] = 27;
    var10025[43] = 22;
    var10025[44] = -18;
    var10025[45] = 23;
    var10025[46] = 18;
    var10025[47] = 46;
    var10025[48] = -4;
    var10025[49] = -11;
    var10025[50] = -6;
    var10025[51] = 43;
    var10025[52] = 4;
    var10025[53] = -10;
    var10025[54] = 22;
    var10025[55] = -2;
    var10025[56] = 6;
    var10025[57] = 2;
    var10025[58] = 29;
    var10025[59] = 41;
    var10025[60] = 11;
    var10025[61] = 30;
    var10025[62] = 18;
    var10025[63] = 10;
    int[] var10026 = SimpleLongDecrypter.getCachedDecrypter(-9122108110927643580L).getEncryptionInts();
    var10026[0] = -47;
    var10026[1] = -29;
    var10026[2] = -20;
    var10026[3] = -12;
    var10026[4] = -58;
    var10026[5] = -11;
    var10026[6] = -32;
    var10026[7] = -48;
    var10026[8] = -38;
    var10026[9] = -40;
    var10026[10] = -46;
    var10026[11] = -41;
    var10026[12] = -27;
    var10026[13] = -12;
    var10026[14] = -44;
    var10026[15] = 12;
    var10026[16] = 11;
    var10026[17] = -19;
    var10026[18] = -11;
    var10026[19] = -35;
    var10026[20] = -13;
    var10026[21] = -20;
    var10026[22] = 20;
    var10026[23] = -4;
    var10026[24] = -29;
    var10026[25] = 12;
    var10026[26] = -16;
    var10026[27] = 4;
    var10026[28] = -12;
    var10026[29] = 11;
    var10026[30] = 29;
    var10026[31] = -17;
    var10026[32] = -12;
    var10026[33] = 13;
    var10026[34] = -9;
    var10026[35] = -25;
    var10026[36] = 19;
    var10026[37] = -20;
    var10026[38] = 32;
    var10026[39] = 27;
    var10026[40] = 12;
    var10026[41] = 20;
    var10026[42] = 16;
    var10026[43] = 9;
    var10026[44] = 12;
    var10026[45] = -18;
    var10026[46] = 38;
    var10026[47] = 47;
    var10026[48] = 17;
    var10026[49] = 40;
    var10026[50] = -11;
    var10026[51] = -8;
    var10026[52] = 41;
    var10026[53] = 29;
    var10026[54] = 35;
    var10026[55] = 48;
    var10026[56] = 46;
    var10026[57] = 20;
    var10026[58] = 44;
    var10026[59] = 8;
    var10026[60] = 25;
    var10026[61] = 11;
    var10026[62] = 58;
    var10026[63] = 18;
    int[] var10027 = SimpleLongDecrypter.getCachedDecrypter(8928604223545899827L).getEncryptionInts();
    var10027[0] = -13;
    var10027[1] = -46;
    var10027[2] = -2;
    var10027[3] = -14;
    var10027[4] = 2;
    var10027[5] = -33;
    var10027[6] = -19;
    var10027[7] = -17;
    var10027[8] = -37;
    var10027[9] = -34;
    var10027[10] = -51;
    var10027[11] = -45;
    var10027[12] = -25;
    var10027[13] = 13;
    var10027[14] = -45;
    var10027[15] = -45;
    var10027[16] = -20;
    var10027[17] = 14;
    var10027[18] = -12;
    var10027[19] = -10;
    var10027[20] = -26;
    var10027[21] = -27;
    var10027[22] = -36;
    var10027[23] = -9;
    var10027[24] = 17;
    var10027[25] = 19;
    var10027[26] = -2;
    var10027[27] = -14;
    var10027[28] = 2;
    var10027[29] = 10;
    var10027[30] = 12;
    var10027[31] = -22;
    var10027[32] = 9;
    var10027[33] = -1;
    var10027[34] = 1;
    var10027[35] = -16;
    var10027[36] = 20;
    var10027[37] = 25;
    var10027[38] = 33;
    var10027[39] = -11;
    var10027[40] = -2;
    var10027[41] = 14;
    var10027[42] = 2;
    var10027[43] = 34;
    var10027[44] = -5;
    var10027[45] = 37;
    var10027[46] = 26;
    var10027[47] = 46;
    var10027[48] = 27;
    var10027[49] = 5;
    var10027[50] = 11;
    var10027[51] = 16;
    var10027[52] = -11;
    var10027[53] = 22;
    var10027[54] = -8;
    var10027[55] = -2;
    var10027[56] = 45;
    var10027[57] = 2;
    var10027[58] = 36;
    var10027[59] = 45;
    var10027[60] = 45;
    var10027[61] = 51;
    var10027[62] = 8;
    var10027[63] = 11;
    int[] var10028 = SimpleLongDecrypter.getCachedDecrypter(-273909861970175489L).getEncryptionInts();
    var10028[0] = -13;
    var10028[1] = -46;
    var10028[2] = -2;
    var10028[3] = -14;
    var10028[4] = 2;
    var10028[5] = -33;
    var10028[6] = -19;
    var10028[7] = -17;
    var10028[8] = -36;
    var10028[9] = -51;
    var10028[10] = -29;
    var10028[11] = -1;
    var10028[12] = 1;
    var10028[13] = 13;
    var10028[14] = -13;
    var10028[15] = -46;
    var10028[16] = -10;
    var10028[17] = 14;
    var10028[18] = -10;
    var10028[19] = -40;
    var10028[20] = -21;
    var10028[21] = -42;
    var10028[22] = -26;
    var10028[23] = -22;
    var10028[24] = 17;
    var10028[25] = 19;
    var10028[26] = 10;
    var10028[27] = 13;
    var10028[28] = 10;
    var10028[29] = -25;
    var10028[30] = -28;
    var10028[31] = -18;
    var10028[32] = -3;
    var10028[33] = -9;
    var10028[34] = -3;
    var10028[35] = 3;
    var10028[36] = -16;
    var10028[37] = 3;
    var10028[38] = 33;
    var10028[39] = 29;
    var10028[40] = -16;
    var10028[41] = 21;
    var10028[42] = 9;
    var10028[43] = -3;
    var10028[44] = 36;
    var10028[45] = 22;
    var10028[46] = 3;
    var10028[47] = 46;
    var10028[48] = 26;
    var10028[49] = 18;
    var10028[50] = -12;
    var10028[51] = -2;
    var10028[52] = 16;
    var10028[53] = 2;
    var10028[54] = 25;
    var10028[55] = -2;
    var10028[56] = 16;
    var10028[57] = 2;
    var10028[58] = 28;
    var10028[59] = 40;
    var10028[60] = 51;
    var10028[61] = 46;
    var10028[62] = 12;
    var10028[63] = 42;
    int[] var10029 = SimpleLongDecrypter.getCachedDecrypter(-6884207350383239299L).getEncryptionInts();
    var10029[0] = -47;
    var10029[1] = -29;
    var10029[2] = -20;
    var10029[3] = -12;
    var10029[4] = -58;
    var10029[5] = -11;
    var10029[6] = -32;
    var10029[7] = -48;
    var10029[8] = -36;
    var10029[9] = -8;
    var10029[10] = -30;
    var10029[11] = -32;
    var10029[12] = -12;
    var10029[13] = -46;
    var10029[14] = -21;
    var10029[15] = 12;
    var10029[16] = 11;
    var10029[17] = 8;
    var10029[18] = -27;
    var10029[19] = -38;
    var10029[20] = -40;
    var10029[21] = -33;
    var10029[22] = 20;
    var10029[23] = -10;
    var10029[24] = 12;
    var10029[25] = -9;
    var10029[26] = -10;
    var10029[27] = -2;
    var10029[28] = -35;
    var10029[29] = 2;
    var10029[30] = 29;
    var10029[31] = -21;
    var10029[32] = -24;
    var10029[33] = 10;
    var10029[34] = 9;
    var10029[35] = 21;
    var10029[36] = 10;
    var10029[37] = -2;
    var10029[38] = 32;
    var10029[39] = 2;
    var10029[40] = 30;
    var10029[41] = -10;
    var10029[42] = -6;
    var10029[43] = 32;
    var10029[44] = 36;
    var10029[45] = 27;
    var10029[46] = -7;
    var10029[47] = 47;
    var10029[48] = 6;
    var10029[49] = -12;
    var10029[50] = -8;
    var10029[51] = 10;
    var10029[52] = 21;
    var10029[53] = 7;
    var10029[54] = 33;
    var10029[55] = 48;
    var10029[56] = 24;
    var10029[57] = 38;
    var10029[58] = 8;
    var10029[59] = 46;
    var10029[60] = 40;
    var10029[61] = 12;
    var10029[62] = 58;
    var10029[63] = 35;
    int[] var10030 = SimpleLongDecrypter.getCachedDecrypter(-5871629535273291584L).getEncryptionInts();
    var10030[0] = -13;
    var10030[1] = -46;
    var10030[2] = -2;
    var10030[3] = -14;
    var10030[4] = 2;
    var10030[5] = -33;
    var10030[6] = -19;
    var10030[7] = -17;
    var10030[8] = -35;
    var10030[9] = -42;
    var10030[10] = -29;
    var10030[11] = -42;
    var10030[12] = -44;
    var10030[13] = 13;
    var10030[14] = -12;
    var10030[15] = -16;
    var10030[16] = -2;
    var10030[17] = 14;
    var10030[18] = 2;
    var10030[19] = -17;
    var10030[20] = -32;
    var10030[21] = -19;
    var10030[22] = -27;
    var10030[23] = -22;
    var10030[24] = 17;
    var10030[25] = 19;
    var10030[26] = 12;
    var10030[27] = -34;
    var10030[28] = -32;
    var10030[29] = -4;
    var10030[30] = -5;
    var10030[31] = 16;
    var10030[32] = -31;
    var10030[33] = 4;
    var10030[34] = -25;
    var10030[35] = 5;
    var10030[36] = 17;
    var10030[37] = -21;
    var10030[38] = 33;
    var10030[39] = 29;
    var10030[40] = 19;
    var10030[41] = -13;
    var10030[42] = -2;
    var10030[43] = 35;
    var10030[44] = 2;
    var10030[45] = 22;
    var10030[46] = -4;
    var10030[47] = 46;
    var10030[48] = -14;
    var10030[49] = 27;
    var10030[50] = 4;
    var10030[51] = 42;
    var10030[52] = 32;
    var10030[53] = 42;
    var10030[54] = 13;
    var10030[55] = -2;
    var10030[56] = 44;
    var10030[57] = 2;
    var10030[58] = 21;
    var10030[59] = 25;
    var10030[60] = 32;
    var10030[61] = 34;
    var10030[62] = 14;
    var10030[63] = 31;
    int[] var10031 = SimpleLongDecrypter.getCachedDecrypter(-424263253355394522L).getEncryptionInts();
    var10031[0] = -47;
    var10031[1] = -29;
    var10031[2] = -20;
    var10031[3] = -12;
    var10031[4] = -58;
    var10031[5] = -11;
    var10031[6] = -32;
    var10031[7] = -48;
    var10031[8] = -18;
    var10031[9] = -4;
    var10031[10] = -4;
    var10031[11] = -34;
    var10031[12] = -39;
    var10031[13] = 4;
    var10031[14] = 4;
    var10031[15] = 12;
    var10031[16] = 11;
    var10031[17] = -43;
    var10031[18] = -25;
    var10031[19] = -10;
    var10031[20] = -43;
    var10031[21] = -15;
    var10031[22] = 20;
    var10031[23] = -34;
    var10031[24] = -24;
    var10031[25] = -12;
    var10031[26] = 18;
    var10031[27] = -25;
    var10031[28] = -4;
    var10031[29] = 10;
    var10031[30] = 29;
    var10031[31] = -15;
    var10031[32] = 4;
    var10031[33] = -25;
    var10031[34] = -27;
    var10031[35] = -5;
    var10031[36] = 15;
    var10031[37] = 12;
    var10031[38] = 32;
    var10031[39] = -5;
    var10031[40] = 5;
    var10031[41] = -15;
    var10031[42] = -7;
    var10031[43] = 25;
    var10031[44] = 5;
    var10031[45] = 34;
    var10031[46] = 15;
    var10031[47] = 47;
    var10031[48] = 24;
    var10031[49] = 7;
    var10031[50] = -4;
    var10031[51] = 39;
    var10031[52] = 25;
    var10031[53] = -6;
    var10031[54] = 4;
    var10031[55] = 48;
    var10031[56] = 15;
    var10031[57] = 34;
    var10031[58] = 25;
    var10031[59] = 6;
    var10031[60] = 43;
    var10031[61] = 27;
    var10031[62] = 58;
    var10031[63] = 43;
    int[] var10032 = SimpleLongDecrypter.getCachedDecrypter(2879200281046143716L).getEncryptionInts();
    var10032[0] = -47;
    var10032[1] = -29;
    var10032[2] = -20;
    var10032[3] = -12;
    var10032[4] = -58;
    var10032[5] = -11;
    var10032[6] = -32;
    var10032[7] = -48;
    var10032[8] = -3;
    var10032[9] = -27;
    var10032[10] = -13;
    var10032[11] = 3;
    var10032[12] = -23;
    var10032[13] = -44;
    var10032[14] = -19;
    var10032[15] = 12;
    var10032[16] = 11;
    var10032[17] = -43;
    var10032[18] = -36;
    var10032[19] = -20;
    var10032[20] = -4;
    var10032[21] = -31;
    var10032[22] = 20;
    var10032[23] = 13;
    var10032[24] = 4;
    var10032[25] = -31;
    var10032[26] = -37;
    var10032[27] = -15;
    var10032[28] = -23;
    var10032[29] = -8;
    var10032[30] = 29;
    var10032[31] = -22;
    var10032[32] = -11;
    var10032[33] = 19;
    var10032[34] = -27;
    var10032[35] = 23;
    var10032[36] = 27;
    var10032[37] = 8;
    var10032[38] = 32;
    var10032[39] = 20;
    var10032[40] = -8;
    var10032[41] = -5;
    var10032[42] = 15;
    var10032[43] = 11;
    var10032[44] = -6;
    var10032[45] = -4;
    var10032[46] = 5;
    var10032[47] = 47;
    var10032[48] = 8;
    var10032[49] = 4;
    var10032[50] = 6;
    var10032[51] = 23;
    var10032[52] = 31;
    var10032[53] = 22;
    var10032[54] = 36;
    var10032[55] = 48;
    var10032[56] = 31;
    var10032[57] = 44;
    var10032[58] = -1;
    var10032[59] = 1;
    var10032[60] = 43;
    var10032[61] = 27;
    var10032[62] = 58;
    var10032[63] = 37;
    int[] var10033 = SimpleLongDecrypter.getCachedDecrypter(-3915444766270323582L).getEncryptionInts();
    var10033[0] = -13;
    var10033[1] = -46;
    var10033[2] = -2;
    var10033[3] = -14;
    var10033[4] = 2;
    var10033[5] = -33;
    var10033[6] = -19;
    var10033[7] = -17;
    var10033[8] = -55;
    var10033[9] = -49;
    var10033[10] = -2;
    var10033[11] = -16;
    var10033[12] = 2;
    var10033[13] = 13;
    var10033[14] = -5;
    var10033[15] = -46;
    var10033[16] = -20;
    var10033[17] = 14;
    var10033[18] = -13;
    var10033[19] = 5;
    var10033[20] = -19;
    var10033[21] = -33;
    var10033[22] = -40;
    var10033[23] = -37;
    var10033[24] = 17;
    var10033[25] = 19;
    var10033[26] = -11;
    var10033[27] = 16;
    var10033[28] = -18;
    var10033[29] = -27;
    var10033[30] = -4;
    var10033[31] = 13;
    var10033[32] = -10;
    var10033[33] = -7;
    var10033[34] = 4;
    var10033[35] = -18;
    var10033[36] = 20;
    var10033[37] = 11;
    var10033[38] = 33;
    var10033[39] = 19;
    var10033[40] = 7;
    var10033[41] = -2;
    var10033[42] = 10;
    var10033[43] = 2;
    var10033[44] = -8;
    var10033[45] = -3;
    var10033[46] = 18;
    var10033[47] = 46;
    var10033[48] = 3;
    var10033[49] = -2;
    var10033[50] = -9;
    var10033[51] = 2;
    var10033[52] = 8;
    var10033[53] = 18;
    var10033[54] = 33;
    var10033[55] = -2;
    var10033[56] = 27;
    var10033[57] = 2;
    var10033[58] = 49;
    var10033[59] = 9;
    var10033[60] = 37;
    var10033[61] = 46;
    var10033[62] = 40;
    var10033[63] = 55;
    int[] var10034 = SimpleLongDecrypter.getCachedDecrypter(8496079957003954936L).getEncryptionInts();
    var10034[0] = -13;
    var10034[1] = -46;
    var10034[2] = -2;
    var10034[3] = -14;
    var10034[4] = 2;
    var10034[5] = -33;
    var10034[6] = -19;
    var10034[7] = -17;
    var10034[8] = -24;
    var10034[9] = -7;
    var10034[10] = -46;
    var10034[11] = -3;
    var10034[12] = -10;
    var10034[13] = 13;
    var10034[14] = 3;
    var10034[15] = -31;
    var10034[16] = 7;
    var10034[17] = 14;
    var10034[18] = -1;
    var10034[19] = 1;
    var10034[20] = -1;
    var10034[21] = 1;
    var10034[22] = 10;
    var10034[23] = -26;
    var10034[24] = 17;
    var10034[25] = 19;
    var10034[26] = -15;
    var10034[27] = -35;
    var10034[28] = -15;
    var10034[29] = -15;
    var10034[30] = -9;
    var10034[31] = -27;
    var10034[32] = 24;
    var10034[33] = -28;
    var10034[34] = -6;
    var10034[35] = -13;
    var10034[36] = -27;
    var10034[37] = -5;
    var10034[38] = 33;
    var10034[39] = 9;
    var10034[40] = 6;
    var10034[41] = 15;
    var10034[42] = 5;
    var10034[43] = 15;
    var10034[44] = 15;
    var10034[45] = -8;
    var10034[46] = 31;
    var10034[47] = 46;
    var10034[48] = 13;
    var10034[49] = 26;
    var10034[50] = -1;
    var10034[51] = 1;
    var10034[52] = -7;
    var10034[53] = 8;
    var10034[54] = -6;
    var10034[55] = -2;
    var10034[56] = 46;
    var10034[57] = 2;
    var10034[58] = 27;
    var10034[59] = 7;
    var10034[60] = 6;
    var10034[61] = 28;
    var10034[62] = 35;
    var10034[63] = 27;
    int[] var10035 = SimpleLongDecrypter.getCachedDecrypter(-3375409109635290632L).getEncryptionInts();
    var10035[0] = -13;
    var10035[1] = -46;
    var10035[2] = -2;
    var10035[3] = -14;
    var10035[4] = 2;
    var10035[5] = -33;
    var10035[6] = -19;
    var10035[7] = -17;
    var10035[8] = -21;
    var10035[9] = -37;
    var10035[10] = -20;
    var10035[11] = -1;
    var10035[12] = 1;
    var10035[13] = 13;
    var10035[14] = -22;
    var10035[15] = -44;
    var10035[16] = -5;
    var10035[17] = 14;
    var10035[18] = -34;
    var10035[19] = -21;
    var10035[20] = -41;
    var10035[21] = 5;
    var10035[22] = -4;
    var10035[23] = -8;
    var10035[24] = 17;
    var10035[25] = 19;
    var10035[26] = 4;
    var10035[27] = -29;
    var10035[28] = -9;
    var10035[29] = 21;
    var10035[30] = 20;
    var10035[31] = 8;
    var10035[32] = -30;
    var10035[33] = -10;
    var10035[34] = -17;
    var10035[35] = -9;
    var10035[36] = 22;
    var10035[37] = 9;
    var10035[38] = 33;
    var10035[39] = -15;
    var10035[40] = 21;
    var10035[41] = -4;
    var10035[42] = -8;
    var10035[43] = 10;
    var10035[44] = 9;
    var10035[45] = 4;
    var10035[46] = 37;
    var10035[47] = 46;
    var10035[48] = -10;
    var10035[49] = -14;
    var10035[50] = 8;
    var10035[51] = 17;
    var10035[52] = 34;
    var10035[53] = -7;
    var10035[54] = 15;
    var10035[55] = -2;
    var10035[56] = 29;
    var10035[57] = 2;
    var10035[58] = 10;
    var10035[59] = 44;
    var10035[60] = 7;
    var10035[61] = 41;
    var10035[62] = 30;
    var10035[63] = 14;
    int[] var10036 = SimpleLongDecrypter.getCachedDecrypter(6912869271594957233L).getEncryptionInts();
    var10036[0] = -47;
    var10036[1] = -29;
    var10036[2] = -20;
    var10036[3] = -12;
    var10036[4] = -58;
    var10036[5] = -11;
    var10036[6] = -32;
    var10036[7] = -48;
    var10036[8] = -20;
    var10036[9] = -1;
    var10036[10] = 1;
    var10036[11] = -15;
    var10036[12] = -28;
    var10036[13] = -48;
    var10036[14] = -17;
    var10036[15] = 12;
    var10036[16] = 11;
    var10036[17] = -29;
    var10036[18] = -35;
    var10036[19] = -33;
    var10036[20] = -17;
    var10036[21] = -8;
    var10036[22] = 20;
    var10036[23] = -37;
    var10036[24] = -12;
    var10036[25] = -23;
    var10036[26] = 15;
    var10036[27] = -12;
    var10036[28] = 20;
    var10036[29] = 8;
    var10036[30] = 29;
    var10036[31] = 17;
    var10036[32] = -18;
    var10036[33] = -10;
    var10036[34] = -22;
    var10036[35] = -19;
    var10036[36] = 12;
    var10036[37] = 17;
    var10036[38] = 32;
    var10036[39] = 12;
    var10036[40] = 28;
    var10036[41] = -4;
    var10036[42] = -16;
    var10036[43] = 10;
    var10036[44] = -19;
    var10036[45] = 4;
    var10036[46] = 29;
    var10036[47] = 47;
    var10036[48] = 23;
    var10036[49] = -8;
    var10036[50] = 18;
    var10036[51] = -8;
    var10036[52] = 33;
    var10036[53] = 35;
    var10036[54] = 19;
    var10036[55] = 48;
    var10036[56] = 22;
    var10036[57] = 8;
    var10036[58] = 16;
    var10036[59] = 8;
    var10036[60] = 37;
    var10036[61] = 48;
    var10036[62] = 58;
    var10036[63] = 19;
    int[] var10037 = SimpleLongDecrypter.getCachedDecrypter(-4132085752789065574L).getEncryptionInts();
    var10037[0] = -47;
    var10037[1] = -29;
    var10037[2] = -20;
    var10037[3] = -12;
    var10037[4] = -58;
    var10037[5] = -11;
    var10037[6] = -32;
    var10037[7] = -48;
    var10037[8] = -52;
    var10037[9] = -32;
    var10037[10] = -30;
    var10037[11] = -43;
    var10037[12] = -16;
    var10037[13] = -33;
    var10037[14] = -4;
    var10037[15] = 12;
    var10037[16] = 11;
    var10037[17] = -20;
    var10037[18] = 4;
    var10037[19] = -42;
    var10037[20] = -6;
    var10037[21] = -35;
    var10037[22] = 20;
    var10037[23] = -34;
    var10037[24] = -28;
    var10037[25] = -14;
    var10037[26] = 6;
    var10037[27] = -24;
    var10037[28] = 16;
    var10037[29] = -24;
    var10037[30] = 29;
    var10037[31] = -11;
    var10037[32] = -27;
    var10037[33] = -17;
    var10037[34] = -10;
    var10037[35] = -13;
    var10037[36] = -13;
    var10037[37] = 20;
    var10037[38] = 32;
    var10037[39] = 14;
    var10037[40] = 30;
    var10037[41] = 32;
    var10037[42] = 11;
    var10037[43] = -2;
    var10037[44] = 10;
    var10037[45] = 2;
    var10037[46] = 33;
    var10037[47] = 47;
    var10037[48] = 13;
    var10037[49] = 13;
    var10037[50] = 17;
    var10037[51] = 24;
    var10037[52] = 28;
    var10037[53] = 24;
    var10037[54] = 43;
    var10037[55] = 48;
    var10037[56] = 35;
    var10037[57] = 34;
    var10037[58] = -5;
    var10037[59] = 27;
    var10037[60] = 52;
    var10037[61] = 42;
    var10037[62] = 58;
    var10037[63] = 5;
  }

  /**
   * Sets the whole chain of class initialization order (super classes and user-defined)
   */
  private void setChildrenForDecrypters() {
    SimpleLongDecrypter.getCachedDecrypter(-7406567533090573370L).setChild(SimpleLongDecrypter.getCachedDecrypter(6690527463172170990L));
    SimpleLongDecrypter.getCachedDecrypter(-3225483683454951468L).setChild(SimpleLongDecrypter.getCachedDecrypter(-647215684339716115L));
    SimpleLongDecrypter.getCachedDecrypter(-4780195495239093138L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5927968530810759203L));
    SimpleLongDecrypter.getCachedDecrypter(-4219042817156204291L).setChild(SimpleLongDecrypter.getCachedDecrypter(6698590451626520550L));
    SimpleLongDecrypter.getCachedDecrypter(-5073872155081098087L).setChild(SimpleLongDecrypter.getCachedDecrypter(3124422545158480907L));
    SimpleLongDecrypter.getCachedDecrypter(1868786821847194174L).setChild(SimpleLongDecrypter.getCachedDecrypter(405125801012146277L));
    SimpleLongDecrypter.getCachedDecrypter(-8140406786986808531L).setChild(SimpleLongDecrypter.getCachedDecrypter(3935054869509805813L));
    SimpleLongDecrypter.getCachedDecrypter(-7752346683388610490L).setChild(SimpleLongDecrypter.getCachedDecrypter(3327445173721452402L));
    SimpleLongDecrypter.getCachedDecrypter(1609334501522128038L).setChild(SimpleLongDecrypter.getCachedDecrypter(3912114223114699498L));
    SimpleLongDecrypter.getCachedDecrypter(5976488600399836521L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6655168601617155275L));
    SimpleLongDecrypter.getCachedDecrypter(-6829667446852531022L).setChild(SimpleLongDecrypter.getCachedDecrypter(-9069722508836043815L));
    SimpleLongDecrypter.getCachedDecrypter(7036594950795899714L).setChild(SimpleLongDecrypter.getCachedDecrypter(2458155809079339586L));
    SimpleLongDecrypter.getCachedDecrypter(-951007125278101541L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7686871143378004546L));
    SimpleLongDecrypter.getCachedDecrypter(-7965229455733162124L).setChild(SimpleLongDecrypter.getCachedDecrypter(4882394367093312867L));
    SimpleLongDecrypter.getCachedDecrypter(5469301855235171239L).setChild(SimpleLongDecrypter.getCachedDecrypter(8760824032359873910L));
    SimpleLongDecrypter.getCachedDecrypter(-8806605034456379162L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3278251486317708477L));
    SimpleLongDecrypter.getCachedDecrypter(4755340985250814092L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7426466749740615661L));
    SimpleLongDecrypter.getCachedDecrypter(-2448247039917022966L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1088424650754938335L));
    SimpleLongDecrypter.getCachedDecrypter(8479457360576846856L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6665108232603114281L));
    SimpleLongDecrypter.getCachedDecrypter(8002311201772979404L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3318007300320053004L));
    SimpleLongDecrypter.getCachedDecrypter(1702811239535217252L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8388721863387287231L));
    SimpleLongDecrypter.getCachedDecrypter(3621913397863252810L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4105608120767430111L));
    SimpleLongDecrypter.getCachedDecrypter(-6627376511503321864L).setChild(SimpleLongDecrypter.getCachedDecrypter(-183133117009285678L));
    SimpleLongDecrypter.getCachedDecrypter(8300036339901270908L).setChild(SimpleLongDecrypter.getCachedDecrypter(5499190294738442345L));
    SimpleLongDecrypter.getCachedDecrypter(3129761951490035793L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3049307478478654601L));
    SimpleLongDecrypter.getCachedDecrypter(7052321403213943049L).setChild(SimpleLongDecrypter.getCachedDecrypter(1497587108923141099L));
    SimpleLongDecrypter.getCachedDecrypter(-6324962069979158987L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8414577541446118605L));
    SimpleLongDecrypter.getCachedDecrypter(-6235511813007028695L).setChild(SimpleLongDecrypter.getCachedDecrypter(5012103985424030441L));
    SimpleLongDecrypter.getCachedDecrypter(4288063783747288570L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4949604267225607716L));
    SimpleLongDecrypter.getCachedDecrypter(-2352525324186605202L).setChild(SimpleLongDecrypter.getCachedDecrypter(-679766455571135744L));
    SimpleLongDecrypter.getCachedDecrypter(-5201439432148450018L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5769049546147267276L));
    SimpleLongDecrypter.getCachedDecrypter(-3350494989858292048L).setChild(SimpleLongDecrypter.getCachedDecrypter(-466675982005320988L));
    SimpleLongDecrypter.getCachedDecrypter(8183699010397090198L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8896863883363402408L));
    SimpleLongDecrypter.getCachedDecrypter(-5810338069721974894L).setChild(SimpleLongDecrypter.getCachedDecrypter(1654472568747285076L));
    SimpleLongDecrypter.getCachedDecrypter(8375409980755861060L).setChild(SimpleLongDecrypter.getCachedDecrypter(95802982489740891L));
    SimpleLongDecrypter.getCachedDecrypter(3774597477003806553L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5543279809926781460L));
    SimpleLongDecrypter.getCachedDecrypter(2040852253780947507L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2173363515845384502L));
    SimpleLongDecrypter.getCachedDecrypter(-1119795088883262940L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6844146785256865603L));
    SimpleLongDecrypter.getCachedDecrypter(5898493421222174628L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4673541039390670741L));
    SimpleLongDecrypter.getCachedDecrypter(-6025123290008397502L).setChild(SimpleLongDecrypter.getCachedDecrypter(8100343694584106869L));
    SimpleLongDecrypter.getCachedDecrypter(-1687839107695998604L).setChild(SimpleLongDecrypter.getCachedDecrypter(4082639866086927401L));
    SimpleLongDecrypter.getCachedDecrypter(1032870127241940881L).setChild(SimpleLongDecrypter.getCachedDecrypter(7796273061562669738L));
    SimpleLongDecrypter.getCachedDecrypter(-3390357122133997902L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7223275394657811255L));
    SimpleLongDecrypter.getCachedDecrypter(1614407314741431910L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7137242187442203916L));
    SimpleLongDecrypter.getCachedDecrypter(7973438877709146705L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6903537505694231382L));
    SimpleLongDecrypter.getCachedDecrypter(595167445307265811L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2367276984044216222L));
    SimpleLongDecrypter.getCachedDecrypter(-47694158698015468L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1741796521549902481L));
    SimpleLongDecrypter.getCachedDecrypter(8532356779416896727L).setChild(SimpleLongDecrypter.getCachedDecrypter(785745392130827267L));
    SimpleLongDecrypter.getCachedDecrypter(1491448455168375580L).setChild(SimpleLongDecrypter.getCachedDecrypter(4653133785010539128L));
    SimpleLongDecrypter.getCachedDecrypter(-9030279505136289218L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5357982956299171934L));
    SimpleLongDecrypter.getCachedDecrypter(4817739461015647851L).setChild(SimpleLongDecrypter.getCachedDecrypter(2384354468395814775L));
    SimpleLongDecrypter.getCachedDecrypter(-4247558348085330331L).setChild(SimpleLongDecrypter.getCachedDecrypter(6861291252848010667L));
    SimpleLongDecrypter.getCachedDecrypter(1896824048039241442L).setChild(SimpleLongDecrypter.getCachedDecrypter(9200807512405033279L));
    SimpleLongDecrypter.getCachedDecrypter(-729622004254176843L).setChild(SimpleLongDecrypter.getCachedDecrypter(8467901606820181344L));
    SimpleLongDecrypter.getCachedDecrypter(-7063611226259497053L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4656996830293145675L));
    SimpleLongDecrypter.getCachedDecrypter(5596044475398982892L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8893655563449932323L));
    SimpleLongDecrypter.getCachedDecrypter(1431888787003577485L).setChild(SimpleLongDecrypter.getCachedDecrypter(583628639259396680L));
    SimpleLongDecrypter.getCachedDecrypter(-6504943693463551493L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8755703086640742754L));
    SimpleLongDecrypter.getCachedDecrypter(-5538361362858487097L).setChild(SimpleLongDecrypter.getCachedDecrypter(8059264599566440476L));
    SimpleLongDecrypter.getCachedDecrypter(6002252668328685509L).setChild(SimpleLongDecrypter.getCachedDecrypter(3044348169698742250L));
    SimpleLongDecrypter.getCachedDecrypter(-906057204172044156L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4254940491005395647L));
    SimpleLongDecrypter.getCachedDecrypter(-9164108870351536226L).setChild(SimpleLongDecrypter.getCachedDecrypter(1891056254251553428L));
    SimpleLongDecrypter.getCachedDecrypter(4272241665536966924L).setChild(SimpleLongDecrypter.getCachedDecrypter(517654833253661605L));
    SimpleLongDecrypter.getCachedDecrypter(5421888524997821838L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3062263439225054768L));
    SimpleLongDecrypter.getCachedDecrypter(-6248006811259474958L).setChild(SimpleLongDecrypter.getCachedDecrypter(7679002727961869050L));
    SimpleLongDecrypter.getCachedDecrypter(-2652483830555946169L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7390738114058541890L));
    SimpleLongDecrypter.getCachedDecrypter(-7541881315637647494L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3835927617750404033L));
    SimpleLongDecrypter.getCachedDecrypter(5169632936870671549L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5542618961895586177L));
    SimpleLongDecrypter.getCachedDecrypter(-718973606857473903L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8016592590733028835L));
    SimpleLongDecrypter.getCachedDecrypter(5165945635781711237L).setChild(SimpleLongDecrypter.getCachedDecrypter(230459073645416368L));
    SimpleLongDecrypter.getCachedDecrypter(-4324312423879107034L).setChild(SimpleLongDecrypter.getCachedDecrypter(1059213733975670467L));
    SimpleLongDecrypter.getCachedDecrypter(7269527114030564247L).setChild(SimpleLongDecrypter.getCachedDecrypter(5259940795325676318L));
    SimpleLongDecrypter.getCachedDecrypter(977928604365993594L).setChild(SimpleLongDecrypter.getCachedDecrypter(8149857136885135091L));
    SimpleLongDecrypter.getCachedDecrypter(5510283258821426863L).setChild(SimpleLongDecrypter.getCachedDecrypter(8877763976067165998L));
    SimpleLongDecrypter.getCachedDecrypter(-3912289482646213758L).setChild(SimpleLongDecrypter.getCachedDecrypter(4529162338020925920L));
    SimpleLongDecrypter.getCachedDecrypter(-2637368387637745866L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8576176518016889286L));
    SimpleLongDecrypter.getCachedDecrypter(-2063205344359979043L).setChild(SimpleLongDecrypter.getCachedDecrypter(2348977869912151302L));
    SimpleLongDecrypter.getCachedDecrypter(1677350400951040246L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1194138458712081110L));
    SimpleLongDecrypter.getCachedDecrypter(-8118501365623699010L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3049962093283552679L));
    SimpleLongDecrypter.getCachedDecrypter(-8149207172887799135L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7230770479095309121L));
    SimpleLongDecrypter.getCachedDecrypter(-1566191551106726019L).setChild(SimpleLongDecrypter.getCachedDecrypter(1942968588373222322L));
    SimpleLongDecrypter.getCachedDecrypter(2919557725087814367L).setChild(SimpleLongDecrypter.getCachedDecrypter(299631390380420149L));
    SimpleLongDecrypter.getCachedDecrypter(-3412910056480643875L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3279651806983225634L));
    SimpleLongDecrypter.getCachedDecrypter(2687561753960154484L).setChild(SimpleLongDecrypter.getCachedDecrypter(6705249766401078924L));
    SimpleLongDecrypter.getCachedDecrypter(5611861724851063348L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3062875005972038159L));
    SimpleLongDecrypter.getCachedDecrypter(-7494065993652099202L).setChild(SimpleLongDecrypter.getCachedDecrypter(3407176390593694262L));
    SimpleLongDecrypter.getCachedDecrypter(-3878413137506292851L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7951018362796311241L));
    SimpleLongDecrypter.getCachedDecrypter(7736638694094912895L).setChild(SimpleLongDecrypter.getCachedDecrypter(6263069475729799942L));
    SimpleLongDecrypter.getCachedDecrypter(3631230664219418387L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4668995668308701324L));
    SimpleLongDecrypter.getCachedDecrypter(2641711534195258121L).setChild(SimpleLongDecrypter.getCachedDecrypter(2897265688386343866L));
    SimpleLongDecrypter.getCachedDecrypter(796442933525749544L).setChild(SimpleLongDecrypter.getCachedDecrypter(5991650078595189106L));
    SimpleLongDecrypter.getCachedDecrypter(-3699051865798861973L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4889992248381285988L));
    SimpleLongDecrypter.getCachedDecrypter(6735823745258808605L).setChild(SimpleLongDecrypter.getCachedDecrypter(396244264284831955L));
    SimpleLongDecrypter.getCachedDecrypter(5666071493967461153L).setChild(SimpleLongDecrypter.getCachedDecrypter(2054181457026824330L));
    SimpleLongDecrypter.getCachedDecrypter(8932544518204398395L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7862784471620462888L));
    SimpleLongDecrypter.getCachedDecrypter(-4337538997205403834L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1010336511128816389L));
    SimpleLongDecrypter.getCachedDecrypter(-5690475923095769056L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6403793309287722993L));
    SimpleLongDecrypter.getCachedDecrypter(4597878540802454293L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7098144265690968242L));
    SimpleLongDecrypter.getCachedDecrypter(-5568142617591298883L).setChild(SimpleLongDecrypter.getCachedDecrypter(2323298618663095841L));
    SimpleLongDecrypter.getCachedDecrypter(6111599966184832311L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4919991257025764397L));
    SimpleLongDecrypter.getCachedDecrypter(3984970941957540024L).setChild(SimpleLongDecrypter.getCachedDecrypter(6848159359736875711L));
    SimpleLongDecrypter.getCachedDecrypter(2608097878907637429L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8418415392424900886L));
    SimpleLongDecrypter.getCachedDecrypter(-1734580311647841728L).setChild(SimpleLongDecrypter.getCachedDecrypter(3922961190875004234L));
    SimpleLongDecrypter.getCachedDecrypter(2665981095504285600L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1835513351868903280L));
    SimpleLongDecrypter.getCachedDecrypter(2456858623314898681L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8745719273343514131L));
    SimpleLongDecrypter.getCachedDecrypter(-5744419250819714160L).setChild(SimpleLongDecrypter.getCachedDecrypter(3996385072647942442L));
    SimpleLongDecrypter.getCachedDecrypter(-6515912999035718065L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3528043630333746336L));
    SimpleLongDecrypter.getCachedDecrypter(-7344832367090759087L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2839357734335761328L));
    SimpleLongDecrypter.getCachedDecrypter(-5095583139092677518L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1784632779509305171L));
    SimpleLongDecrypter.getCachedDecrypter(6497231090219045301L).setChild(SimpleLongDecrypter.getCachedDecrypter(9177467708607290692L));
    SimpleLongDecrypter.getCachedDecrypter(3650197747646070886L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5817209484480650166L));
    SimpleLongDecrypter.getCachedDecrypter(-1969062133507518384L).setChild(SimpleLongDecrypter.getCachedDecrypter(9094114197573981717L));
    SimpleLongDecrypter.getCachedDecrypter(-7302995502612605662L).setChild(SimpleLongDecrypter.getCachedDecrypter(4881720861476812976L));
    SimpleLongDecrypter.getCachedDecrypter(1030031040886616640L).setChild(SimpleLongDecrypter.getCachedDecrypter(4125543164031545988L));
    SimpleLongDecrypter.getCachedDecrypter(-7588843357976630994L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7656304263459939225L));
    SimpleLongDecrypter.getCachedDecrypter(7950550355221095458L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3973617837522631585L));
    SimpleLongDecrypter.getCachedDecrypter(1834792991362820626L).setChild(SimpleLongDecrypter.getCachedDecrypter(7969895522421362828L));
    SimpleLongDecrypter.getCachedDecrypter(6142872975742202426L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7061544804311887742L));
    SimpleLongDecrypter.getCachedDecrypter(4752154988145741172L).setChild(SimpleLongDecrypter.getCachedDecrypter(304005760152899016L));
    SimpleLongDecrypter.getCachedDecrypter(5149748730778818204L).setChild(SimpleLongDecrypter.getCachedDecrypter(7383692049193010128L));
    SimpleLongDecrypter.getCachedDecrypter(9201123360032279167L).setChild(SimpleLongDecrypter.getCachedDecrypter(4486376216180192906L));
    SimpleLongDecrypter.getCachedDecrypter(-2530289321593110713L).setChild(SimpleLongDecrypter.getCachedDecrypter(7279311649554526725L));
    SimpleLongDecrypter.getCachedDecrypter(-4924514740123267466L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5207625135232652897L));
    SimpleLongDecrypter.getCachedDecrypter(-8212566929598430841L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3732436097833541333L));
    SimpleLongDecrypter.getCachedDecrypter(-2677348326002569901L).setChild(SimpleLongDecrypter.getCachedDecrypter(1707293968374623880L));
    SimpleLongDecrypter.getCachedDecrypter(-1825803865639397783L).setChild(SimpleLongDecrypter.getCachedDecrypter(5677235402297667527L));
    SimpleLongDecrypter.getCachedDecrypter(-4111299359869474792L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1639766374702672096L));
    SimpleLongDecrypter.getCachedDecrypter(5488271561872233995L).setChild(SimpleLongDecrypter.getCachedDecrypter(-750739362410725002L));
    SimpleLongDecrypter.getCachedDecrypter(-1823267288165773511L).setChild(SimpleLongDecrypter.getCachedDecrypter(3394852543117698938L));
    SimpleLongDecrypter.getCachedDecrypter(-7975557000326725955L).setChild(SimpleLongDecrypter.getCachedDecrypter(7156709552714351733L));
    SimpleLongDecrypter.getCachedDecrypter(8322180047738447376L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1694559336053392881L));
    SimpleLongDecrypter.getCachedDecrypter(-1748144033469229757L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6353465209517880298L));
    SimpleLongDecrypter.getCachedDecrypter(-6276973871435825398L).setChild(SimpleLongDecrypter.getCachedDecrypter(6266665475325431626L));
    SimpleLongDecrypter.getCachedDecrypter(-6545950420944891426L).setChild(SimpleLongDecrypter.getCachedDecrypter(4414543775785883292L));
    SimpleLongDecrypter.getCachedDecrypter(3439675664076789838L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1273057914771899094L));
    SimpleLongDecrypter.getCachedDecrypter(1299254474207525478L).setChild(SimpleLongDecrypter.getCachedDecrypter(3896380610944187697L));
    SimpleLongDecrypter.getCachedDecrypter(5671014670398332906L).setChild(SimpleLongDecrypter.getCachedDecrypter(-563283834308194186L));
    SimpleLongDecrypter.getCachedDecrypter(-8191364773633308341L).setChild(SimpleLongDecrypter.getCachedDecrypter(78017785129226598L));
    SimpleLongDecrypter.getCachedDecrypter(-904802906769115606L).setChild(SimpleLongDecrypter.getCachedDecrypter(9070253528638484241L));
    SimpleLongDecrypter.getCachedDecrypter(-2290891157545410248L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1371526126111648497L));
    SimpleLongDecrypter.getCachedDecrypter(477528237200645372L).setChild(SimpleLongDecrypter.getCachedDecrypter(7003095554992435181L));
    SimpleLongDecrypter.getCachedDecrypter(-6136876023385979029L).setChild(SimpleLongDecrypter.getCachedDecrypter(56975636532899758L));
    SimpleLongDecrypter.getCachedDecrypter(-8873777166602698718L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3396565528096506083L));
    SimpleLongDecrypter.getCachedDecrypter(-4330874968113301925L).setChild(SimpleLongDecrypter.getCachedDecrypter(-347489780790934724L));
    SimpleLongDecrypter.getCachedDecrypter(-1578957316264918867L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8238941192357269051L));
    SimpleLongDecrypter.getCachedDecrypter(-3794701916274899022L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5034046765032651509L));
    SimpleLongDecrypter.getCachedDecrypter(-1464652962325804921L).setChild(SimpleLongDecrypter.getCachedDecrypter(7351311518050968378L));
    SimpleLongDecrypter.getCachedDecrypter(-1600715588515571650L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2852394204793925032L));
    SimpleLongDecrypter.getCachedDecrypter(1794599576329659112L).setChild(SimpleLongDecrypter.getCachedDecrypter(2125120140303517L));
    SimpleLongDecrypter.getCachedDecrypter(-5363739739085134303L).setChild(SimpleLongDecrypter.getCachedDecrypter(-17111555264556806L));
    SimpleLongDecrypter.getCachedDecrypter(7573833978900612490L).setChild(SimpleLongDecrypter.getCachedDecrypter(-382840298175478872L));
    SimpleLongDecrypter.getCachedDecrypter(9001845879609937950L).setChild(SimpleLongDecrypter.getCachedDecrypter(6351187523167473704L));
    SimpleLongDecrypter.getCachedDecrypter(4388671032482177795L).setChild(SimpleLongDecrypter.getCachedDecrypter(1575994542281727816L));
    SimpleLongDecrypter.getCachedDecrypter(-1398677314575951650L).setChild(SimpleLongDecrypter.getCachedDecrypter(315156659929762827L));
    SimpleLongDecrypter.getCachedDecrypter(3557180460568406162L).setChild(SimpleLongDecrypter.getCachedDecrypter(1830726870243965218L));
    SimpleLongDecrypter.getCachedDecrypter(-3865328269218928726L).setChild(SimpleLongDecrypter.getCachedDecrypter(5551913501145955410L));
    SimpleLongDecrypter.getCachedDecrypter(-3577665522722579642L).setChild(SimpleLongDecrypter.getCachedDecrypter(7348430269908380787L));
    SimpleLongDecrypter.getCachedDecrypter(2012788976059392144L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7155438940575486343L));
    SimpleLongDecrypter.getCachedDecrypter(453340005909755057L).setChild(SimpleLongDecrypter.getCachedDecrypter(4847773736736754184L));
    SimpleLongDecrypter.getCachedDecrypter(-1024516945276089102L).setChild(SimpleLongDecrypter.getCachedDecrypter(9067201814703839480L));
    SimpleLongDecrypter.getCachedDecrypter(8470671176033006469L).setChild(SimpleLongDecrypter.getCachedDecrypter(-576595273903444493L));
    SimpleLongDecrypter.getCachedDecrypter(8238500440237549429L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5474273870743981652L));
    SimpleLongDecrypter.getCachedDecrypter(-3147288882412037926L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1337673224622371509L));
    SimpleLongDecrypter.getCachedDecrypter(4280995283035361654L).setChild(SimpleLongDecrypter.getCachedDecrypter(-247284920537753406L));
    SimpleLongDecrypter.getCachedDecrypter(-6312018717725180662L).setChild(SimpleLongDecrypter.getCachedDecrypter(8961813764635533972L));
    SimpleLongDecrypter.getCachedDecrypter(-6218022276802626090L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4852609847694134033L));
    SimpleLongDecrypter.getCachedDecrypter(6781335188630186084L).setChild(SimpleLongDecrypter.getCachedDecrypter(5174901859496335784L));
    SimpleLongDecrypter.getCachedDecrypter(-4840852955524074958L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2611046508763591235L));
    SimpleLongDecrypter.getCachedDecrypter(2374169585079246292L).setChild(SimpleLongDecrypter.getCachedDecrypter(3897647276884987555L));
    SimpleLongDecrypter.getCachedDecrypter(3910004837355821277L).setChild(SimpleLongDecrypter.getCachedDecrypter(5044248927267634691L));
    SimpleLongDecrypter.getCachedDecrypter(-9070580594208135947L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7044035608520663909L));
    SimpleLongDecrypter.getCachedDecrypter(-7169883894964993191L).setChild(SimpleLongDecrypter.getCachedDecrypter(6050358522179408120L));
    SimpleLongDecrypter.getCachedDecrypter(125560246054470675L).setChild(SimpleLongDecrypter.getCachedDecrypter(388342199304417388L));
    SimpleLongDecrypter.getCachedDecrypter(-556374410900992914L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1126491388726619124L));
    SimpleLongDecrypter.getCachedDecrypter(6538980380936312026L).setChild(SimpleLongDecrypter.getCachedDecrypter(8202959569140787923L));
    SimpleLongDecrypter.getCachedDecrypter(-2534013349558472385L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3639109288790078182L));
    SimpleLongDecrypter.getCachedDecrypter(9214720585025867899L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1384386533007193934L));
    SimpleLongDecrypter.getCachedDecrypter(7251023975483980666L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4098689740503545652L));
    SimpleLongDecrypter.getCachedDecrypter(-5286738684968674164L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6143373472131889640L));
    SimpleLongDecrypter.getCachedDecrypter(-4221018931401634156L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7334680931980338662L));
    SimpleLongDecrypter.getCachedDecrypter(-8688156712530747636L).setChild(SimpleLongDecrypter.getCachedDecrypter(5047894602306045575L));
    SimpleLongDecrypter.getCachedDecrypter(5325277600552507599L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4608266750970830120L));
    SimpleLongDecrypter.getCachedDecrypter(-5579783714415927071L).setChild(SimpleLongDecrypter.getCachedDecrypter(8277006456197315836L));
    SimpleLongDecrypter.getCachedDecrypter(3568187227620256005L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7473566472811732635L));
    SimpleLongDecrypter.getCachedDecrypter(-4306406562485018588L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2332665553893473470L));
    SimpleLongDecrypter.getCachedDecrypter(-4053592404199613242L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2610703847381801652L));
    SimpleLongDecrypter.getCachedDecrypter(-6769888785339305152L).setChild(SimpleLongDecrypter.getCachedDecrypter(1083929168692230577L));
    SimpleLongDecrypter.getCachedDecrypter(-7990211308788313555L).setChild(SimpleLongDecrypter.getCachedDecrypter(-9167255116805490560L));
    SimpleLongDecrypter.getCachedDecrypter(-4300757868534345083L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7146780080527038850L));
    SimpleLongDecrypter.getCachedDecrypter(7291733129839991329L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4113558775441309805L));
    SimpleLongDecrypter.getCachedDecrypter(-5719305552238839632L).setChild(SimpleLongDecrypter.getCachedDecrypter(-519045890228396023L));
    SimpleLongDecrypter.getCachedDecrypter(6758429833122027677L).setChild(SimpleLongDecrypter.getCachedDecrypter(-802364429906001148L));
    SimpleLongDecrypter.getCachedDecrypter(8002571533234412003L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8639765410599426471L));
    SimpleLongDecrypter.getCachedDecrypter(-5367332393176888604L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1479748216226764137L));
    SimpleLongDecrypter.getCachedDecrypter(8001455099999097815L).setChild(SimpleLongDecrypter.getCachedDecrypter(7765668520983918701L));
    SimpleLongDecrypter.getCachedDecrypter(-8904335220462726432L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3896937312104156512L));
    SimpleLongDecrypter.getCachedDecrypter(-8852956039465115769L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7088314766680808142L));
    SimpleLongDecrypter.getCachedDecrypter(6281639177807286054L).setChild(SimpleLongDecrypter.getCachedDecrypter(-663784295300721897L));
    SimpleLongDecrypter.getCachedDecrypter(3121806575291555914L).setChild(SimpleLongDecrypter.getCachedDecrypter(6069867716165234319L));
    SimpleLongDecrypter.getCachedDecrypter(1048668343748546234L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8030809329183607048L));
    SimpleLongDecrypter.getCachedDecrypter(-2981269091230507305L).setChild(SimpleLongDecrypter.getCachedDecrypter(6228409979545922894L));
    SimpleLongDecrypter.getCachedDecrypter(-1686962928661399837L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2134232425497784025L));
    SimpleLongDecrypter.getCachedDecrypter(6509480827224577450L).setChild(SimpleLongDecrypter.getCachedDecrypter(2831620722752761345L));
    SimpleLongDecrypter.getCachedDecrypter(5793135223869027700L).setChild(SimpleLongDecrypter.getCachedDecrypter(2057576482467122362L));
    SimpleLongDecrypter.getCachedDecrypter(-7438425648524385795L).setChild(SimpleLongDecrypter.getCachedDecrypter(2260071489959202959L));
    SimpleLongDecrypter.getCachedDecrypter(2378109435183162721L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7316391247511906025L));
    SimpleLongDecrypter.getCachedDecrypter(-6753730076561949514L).setChild(SimpleLongDecrypter.getCachedDecrypter(5113884139726931139L));
    SimpleLongDecrypter.getCachedDecrypter(-985150985099337537L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8169185574138921162L));
    SimpleLongDecrypter.getCachedDecrypter(739830087681315882L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6255306087394117127L));
    SimpleLongDecrypter.getCachedDecrypter(8285243343121093830L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2975630088927881204L));
    SimpleLongDecrypter.getCachedDecrypter(4662014831942551613L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3626420206861709251L));
    SimpleLongDecrypter.getCachedDecrypter(1254580435756204014L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2129822163658091779L));
    SimpleLongDecrypter.getCachedDecrypter(5161752481063595539L).setChild(SimpleLongDecrypter.getCachedDecrypter(8157599782876896638L));
    SimpleLongDecrypter.getCachedDecrypter(-5070964574743314693L).setChild(SimpleLongDecrypter.getCachedDecrypter(7514978176128368126L));
    SimpleLongDecrypter.getCachedDecrypter(5801066008090679174L).setChild(SimpleLongDecrypter.getCachedDecrypter(5753288239644122878L));
    SimpleLongDecrypter.getCachedDecrypter(-385988190920488476L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8691910380481662847L));
    SimpleLongDecrypter.getCachedDecrypter(-5022274516328385898L).setChild(SimpleLongDecrypter.getCachedDecrypter(3098042382405238737L));
    SimpleLongDecrypter.getCachedDecrypter(1394113547626280804L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1191503359816148841L));
    SimpleLongDecrypter.getCachedDecrypter(-7509582740156261860L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5708659359763917633L));
    SimpleLongDecrypter.getCachedDecrypter(7758286407123783200L).setChild(SimpleLongDecrypter.getCachedDecrypter(-691923491190773573L));
    SimpleLongDecrypter.getCachedDecrypter(4348815485141551005L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3337348686833276413L));
    SimpleLongDecrypter.getCachedDecrypter(-5853721933328739046L).setChild(SimpleLongDecrypter.getCachedDecrypter(-9089761846276984882L));
    SimpleLongDecrypter.getCachedDecrypter(-1793203398077080497L).setChild(SimpleLongDecrypter.getCachedDecrypter(1792445048890917439L));
    SimpleLongDecrypter.getCachedDecrypter(4864091013441638702L).setChild(SimpleLongDecrypter.getCachedDecrypter(7247748798674906493L));
    SimpleLongDecrypter.getCachedDecrypter(8620063005534111093L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8768484951054814900L));
    SimpleLongDecrypter.getCachedDecrypter(-8864881021578580144L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3607645361111242148L));
    SimpleLongDecrypter.getCachedDecrypter(1841668710915126084L).setChild(SimpleLongDecrypter.getCachedDecrypter(1718480891508050853L));
    SimpleLongDecrypter.getCachedDecrypter(-8486666093025080326L).setChild(SimpleLongDecrypter.getCachedDecrypter(5869893071103075315L));
    SimpleLongDecrypter.getCachedDecrypter(-8235158332426996750L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6499086466763447152L));
    SimpleLongDecrypter.getCachedDecrypter(7762274225730633680L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3901544382224187354L));
    SimpleLongDecrypter.getCachedDecrypter(5803209734683255223L).setChild(SimpleLongDecrypter.getCachedDecrypter(3247300559951319304L));
    SimpleLongDecrypter.getCachedDecrypter(4957376919994183856L).setChild(SimpleLongDecrypter.getCachedDecrypter(-9054861527368143628L));
    SimpleLongDecrypter.getCachedDecrypter(3813474945321745348L).setChild(SimpleLongDecrypter.getCachedDecrypter(6661938666036759450L));
    SimpleLongDecrypter.getCachedDecrypter(-8591782539587023535L).setChild(SimpleLongDecrypter.getCachedDecrypter(7512498010790101581L));
    SimpleLongDecrypter.getCachedDecrypter(7366945128636210190L).setChild(SimpleLongDecrypter.getCachedDecrypter(192260606330289136L));
    SimpleLongDecrypter.getCachedDecrypter(4752286678678976970L).setChild(SimpleLongDecrypter.getCachedDecrypter(-741293041901876623L));
    SimpleLongDecrypter.getCachedDecrypter(-1421497412511011296L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5264523563089638833L));
    SimpleLongDecrypter.getCachedDecrypter(7831030153118957260L).setChild(SimpleLongDecrypter.getCachedDecrypter(5238090330292703738L));
    SimpleLongDecrypter.getCachedDecrypter(3302619350799947521L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3038206237519933898L));
    SimpleLongDecrypter.getCachedDecrypter(2313154416771833287L).setChild(SimpleLongDecrypter.getCachedDecrypter(-133357418197941074L));
    SimpleLongDecrypter.getCachedDecrypter(-4507317011181847691L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4225134143195488527L));
    SimpleLongDecrypter.getCachedDecrypter(106940172465169992L).setChild(SimpleLongDecrypter.getCachedDecrypter(921960596382065368L));
    SimpleLongDecrypter.getCachedDecrypter(-1753946565057553760L).setChild(SimpleLongDecrypter.getCachedDecrypter(4971998370259886835L));
    SimpleLongDecrypter.getCachedDecrypter(-3915286094620403635L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1962798096606098927L));
    SimpleLongDecrypter.getCachedDecrypter(-1720349024220717708L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6156247084443927877L));
    SimpleLongDecrypter.getCachedDecrypter(-6940309497896985891L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5777376615241355470L));
    SimpleLongDecrypter.getCachedDecrypter(5789697870402077488L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5323954165463765832L));
    SimpleLongDecrypter.getCachedDecrypter(-730598488065116191L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1573672285993730856L));
    SimpleLongDecrypter.getCachedDecrypter(599761337706416233L).setChild(SimpleLongDecrypter.getCachedDecrypter(5125140796870326550L));
    SimpleLongDecrypter.getCachedDecrypter(-4567209784175286248L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2143834830446140265L));
    SimpleLongDecrypter.getCachedDecrypter(5852484081181194549L).setChild(SimpleLongDecrypter.getCachedDecrypter(5781612223323153876L));
    SimpleLongDecrypter.getCachedDecrypter(-1743064237855845791L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1838863480214634027L));
    SimpleLongDecrypter.getCachedDecrypter(2011760256976836412L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4326591849358221720L));
    SimpleLongDecrypter.getCachedDecrypter(737185461631869359L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1960233103849386726L));
    SimpleLongDecrypter.getCachedDecrypter(-1258415164289941537L).setChild(SimpleLongDecrypter.getCachedDecrypter(1880347565556215697L));
    SimpleLongDecrypter.getCachedDecrypter(-3247841349065019479L).setChild(SimpleLongDecrypter.getCachedDecrypter(9141538195471015459L));
    SimpleLongDecrypter.getCachedDecrypter(-3819000744286541798L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8393433972161365991L));
    SimpleLongDecrypter.getCachedDecrypter(-6636933341295295428L).setChild(SimpleLongDecrypter.getCachedDecrypter(5304934065523870020L));
    SimpleLongDecrypter.getCachedDecrypter(4391058615791447676L).setChild(SimpleLongDecrypter.getCachedDecrypter(-454668913916047360L));
    SimpleLongDecrypter.getCachedDecrypter(-8365234931143631079L).setChild(SimpleLongDecrypter.getCachedDecrypter(54649322273033899L));
    SimpleLongDecrypter.getCachedDecrypter(299737109191481790L).setChild(SimpleLongDecrypter.getCachedDecrypter(1012266654253562716L));
    SimpleLongDecrypter.getCachedDecrypter(-8540495873349851926L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7270186475112963100L));
    SimpleLongDecrypter.getCachedDecrypter(-6358446437909398342L).setChild(SimpleLongDecrypter.getCachedDecrypter(6398807757987610455L));
    SimpleLongDecrypter.getCachedDecrypter(1176424673961674164L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2249054411098237105L));
    SimpleLongDecrypter.getCachedDecrypter(3055129412472210913L).setChild(SimpleLongDecrypter.getCachedDecrypter(5636399400541219926L));
    SimpleLongDecrypter.getCachedDecrypter(3826668298532653327L).setChild(SimpleLongDecrypter.getCachedDecrypter(8027212461971715116L));
    SimpleLongDecrypter.getCachedDecrypter(5989179694902056992L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6541934578550153139L));
    SimpleLongDecrypter.getCachedDecrypter(5447319263764459025L).setChild(SimpleLongDecrypter.getCachedDecrypter(6580322177819454892L));
    SimpleLongDecrypter.getCachedDecrypter(-3375166560050769911L).setChild(SimpleLongDecrypter.getCachedDecrypter(-209325547041039153L));
    SimpleLongDecrypter.getCachedDecrypter(-7910820103014184475L).setChild(SimpleLongDecrypter.getCachedDecrypter(8741958599263790547L));
    SimpleLongDecrypter.getCachedDecrypter(-8893466686089079081L).setChild(SimpleLongDecrypter.getCachedDecrypter(1653604798056659246L));
    SimpleLongDecrypter.getCachedDecrypter(7898357610014744297L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5373767521399885156L));
    SimpleLongDecrypter.getCachedDecrypter(-6674132190137383232L).setChild(SimpleLongDecrypter.getCachedDecrypter(2136129575294036698L));
    SimpleLongDecrypter.getCachedDecrypter(7379683805086078268L).setChild(SimpleLongDecrypter.getCachedDecrypter(-110031787927880179L));
    SimpleLongDecrypter.getCachedDecrypter(4701703473233638964L).setChild(SimpleLongDecrypter.getCachedDecrypter(6165232186470540746L));
    SimpleLongDecrypter.getCachedDecrypter(-1786600658421953595L).setChild(SimpleLongDecrypter.getCachedDecrypter(2188553869869053545L));
    SimpleLongDecrypter.getCachedDecrypter(3127010575028624873L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1101924063554204982L));
    SimpleLongDecrypter.getCachedDecrypter(-2848737943440493560L).setChild(SimpleLongDecrypter.getCachedDecrypter(1309386827467173832L));
    SimpleLongDecrypter.getCachedDecrypter(9100161136582805363L).setChild(SimpleLongDecrypter.getCachedDecrypter(1963149998028300005L));
    SimpleLongDecrypter.getCachedDecrypter(5288430926231334888L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6860632289739257772L));
    SimpleLongDecrypter.getCachedDecrypter(7750684382019510539L).setChild(SimpleLongDecrypter.getCachedDecrypter(8642536526337786098L));
    SimpleLongDecrypter.getCachedDecrypter(5341750292204843798L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3769423372677091503L));
    SimpleLongDecrypter.getCachedDecrypter(-3994972470383442757L).setChild(SimpleLongDecrypter.getCachedDecrypter(1811869703711486598L));
    SimpleLongDecrypter.getCachedDecrypter(9046838047564294015L).setChild(SimpleLongDecrypter.getCachedDecrypter(7958325569643371266L));
    SimpleLongDecrypter.getCachedDecrypter(-5536502239627713417L).setChild(SimpleLongDecrypter.getCachedDecrypter(4150353428249749269L));
    SimpleLongDecrypter.getCachedDecrypter(-4522376473243092615L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3318616344023327034L));
    SimpleLongDecrypter.getCachedDecrypter(3644983919227663455L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1322575272353315224L));
    SimpleLongDecrypter.getCachedDecrypter(-4697087931088650654L).setChild(SimpleLongDecrypter.getCachedDecrypter(314807364146819058L));
    SimpleLongDecrypter.getCachedDecrypter(6123560612512304889L).setChild(SimpleLongDecrypter.getCachedDecrypter(2106922802331071378L));
    SimpleLongDecrypter.getCachedDecrypter(4713877015987858822L).setChild(SimpleLongDecrypter.getCachedDecrypter(6861500578241604746L));
    SimpleLongDecrypter.getCachedDecrypter(5314449459505470482L).setChild(SimpleLongDecrypter.getCachedDecrypter(7173892718033286729L));
    SimpleLongDecrypter.getCachedDecrypter(8164326471715091665L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6922389077596899131L));
    SimpleLongDecrypter.getCachedDecrypter(-3830222476217210869L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7589494504505648952L));
    SimpleLongDecrypter.getCachedDecrypter(-4245801363241673642L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8483119506700677833L));
    SimpleLongDecrypter.getCachedDecrypter(5295738117637993126L).setChild(SimpleLongDecrypter.getCachedDecrypter(2297996074954904691L));
    SimpleLongDecrypter.getCachedDecrypter(3475646895068952659L).setChild(SimpleLongDecrypter.getCachedDecrypter(2228962458158957020L));
    SimpleLongDecrypter.getCachedDecrypter(-3103500704996224819L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6125575484518874223L));
    SimpleLongDecrypter.getCachedDecrypter(-6105154654873450683L).setChild(SimpleLongDecrypter.getCachedDecrypter(1618385734546112428L));
    SimpleLongDecrypter.getCachedDecrypter(1171186671516979801L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6110493652561036209L));
    SimpleLongDecrypter.getCachedDecrypter(-369080881299519325L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6152945257874988130L));
    SimpleLongDecrypter.getCachedDecrypter(3959005484417820544L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6168203557017482504L));
    SimpleLongDecrypter.getCachedDecrypter(-2641962831071855909L).setChild(SimpleLongDecrypter.getCachedDecrypter(4006816442429754536L));
    SimpleLongDecrypter.getCachedDecrypter(2720435741607367826L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7273059526537992321L));
    SimpleLongDecrypter.getCachedDecrypter(-5069254726425569224L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8167584657491065694L));
    SimpleLongDecrypter.getCachedDecrypter(6090224066184331527L).setChild(SimpleLongDecrypter.getCachedDecrypter(757932610651497026L));
    SimpleLongDecrypter.getCachedDecrypter(4441283175448357436L).setChild(SimpleLongDecrypter.getCachedDecrypter(4985330804605888231L));
    SimpleLongDecrypter.getCachedDecrypter(1712073927429297950L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2562586743183285132L));
    SimpleLongDecrypter.getCachedDecrypter(6112661284985731200L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8199217453944400800L));
    SimpleLongDecrypter.getCachedDecrypter(8050410192621531038L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2720632243032061566L));
    SimpleLongDecrypter.getCachedDecrypter(8036039288039660018L).setChild(SimpleLongDecrypter.getCachedDecrypter(5402942478391691222L));
    SimpleLongDecrypter.getCachedDecrypter(-2121412387717371798L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4780869504178420789L));
    SimpleLongDecrypter.getCachedDecrypter(-6941152087436186563L).setChild(SimpleLongDecrypter.getCachedDecrypter(7741741657549742004L));
    SimpleLongDecrypter.getCachedDecrypter(1477028262718597451L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1307357064767070501L));
    SimpleLongDecrypter.getCachedDecrypter(4709438403876312292L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5106837729026586952L));
    SimpleLongDecrypter.getCachedDecrypter(-7747735658073860543L).setChild(SimpleLongDecrypter.getCachedDecrypter(2483912699259082176L));
    SimpleLongDecrypter.getCachedDecrypter(4952781817876877443L).setChild(SimpleLongDecrypter.getCachedDecrypter(62887964199925139L));
    SimpleLongDecrypter.getCachedDecrypter(4438640498665767783L).setChild(SimpleLongDecrypter.getCachedDecrypter(901687390829571604L));
    SimpleLongDecrypter.getCachedDecrypter(-5374646287346811161L).setChild(SimpleLongDecrypter.getCachedDecrypter(6602920604900167710L));
    SimpleLongDecrypter.getCachedDecrypter(9075998735398514689L).setChild(SimpleLongDecrypter.getCachedDecrypter(6538000790714212885L));
    SimpleLongDecrypter.getCachedDecrypter(7509116320252081075L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6682718753038105456L));
    SimpleLongDecrypter.getCachedDecrypter(6656023141945886246L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2100241850520793921L));
    SimpleLongDecrypter.getCachedDecrypter(1517699797948623156L).setChild(SimpleLongDecrypter.getCachedDecrypter(4482999672913191229L));
    SimpleLongDecrypter.getCachedDecrypter(1278046788679510487L).setChild(SimpleLongDecrypter.getCachedDecrypter(7096819394387074442L));
    SimpleLongDecrypter.getCachedDecrypter(5524733671209002915L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8141447343328038538L));
    SimpleLongDecrypter.getCachedDecrypter(2159987474598286405L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8154777426371446485L));
    SimpleLongDecrypter.getCachedDecrypter(2176022071923271088L).setChild(SimpleLongDecrypter.getCachedDecrypter(1637758647099415432L));
    SimpleLongDecrypter.getCachedDecrypter(-7518577572442813121L).setChild(SimpleLongDecrypter.getCachedDecrypter(8172800787517482960L));
    SimpleLongDecrypter.getCachedDecrypter(-3194712642417066595L).setChild(SimpleLongDecrypter.getCachedDecrypter(5173110775804000429L));
    SimpleLongDecrypter.getCachedDecrypter(5465887539197673083L).setChild(SimpleLongDecrypter.getCachedDecrypter(2517184991032953813L));
    SimpleLongDecrypter.getCachedDecrypter(3899281817388308654L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3505937820980123565L));
    SimpleLongDecrypter.getCachedDecrypter(-5848859049951965214L).setChild(SimpleLongDecrypter.getCachedDecrypter(8131025473339845910L));
    SimpleLongDecrypter.getCachedDecrypter(853188076446543453L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1924927370713460897L));
    SimpleLongDecrypter.getCachedDecrypter(-8423738957950678507L).setChild(SimpleLongDecrypter.getCachedDecrypter(1433914670345795364L));
    SimpleLongDecrypter.getCachedDecrypter(-1999215961545506773L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6419724404087907184L));
    SimpleLongDecrypter.getCachedDecrypter(6623542212479081754L).setChild(SimpleLongDecrypter.getCachedDecrypter(6546959251839236492L));
    SimpleLongDecrypter.getCachedDecrypter(6918385992433126648L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5625294766359050135L));
    SimpleLongDecrypter.getCachedDecrypter(-2865579633054645289L).setChild(SimpleLongDecrypter.getCachedDecrypter(4148471983056493914L));
    SimpleLongDecrypter.getCachedDecrypter(-4242700463525595902L).setChild(SimpleLongDecrypter.getCachedDecrypter(8273115145370632948L));
    SimpleLongDecrypter.getCachedDecrypter(-5439365475282598050L).setChild(SimpleLongDecrypter.getCachedDecrypter(5723434970466782861L));
    SimpleLongDecrypter.getCachedDecrypter(-1318647277415011926L).setChild(SimpleLongDecrypter.getCachedDecrypter(7424511920356404608L));
    SimpleLongDecrypter.getCachedDecrypter(8040085065425327493L).setChild(SimpleLongDecrypter.getCachedDecrypter(1490440282118290734L));
    SimpleLongDecrypter.getCachedDecrypter(-1674891953604253922L).setChild(SimpleLongDecrypter.getCachedDecrypter(4282469322667900595L));
    SimpleLongDecrypter.getCachedDecrypter(6627896572603135929L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8477232565405898759L));
    SimpleLongDecrypter.getCachedDecrypter(4509592576144655795L).setChild(SimpleLongDecrypter.getCachedDecrypter(1251434908854413750L));
    SimpleLongDecrypter.getCachedDecrypter(566667289272986626L).setChild(SimpleLongDecrypter.getCachedDecrypter(657012491303530292L));
    SimpleLongDecrypter.getCachedDecrypter(4504784956692419838L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5506275862650739530L));
    SimpleLongDecrypter.getCachedDecrypter(8259430964804231861L).setChild(SimpleLongDecrypter.getCachedDecrypter(9071061837668139771L));
    SimpleLongDecrypter.getCachedDecrypter(-2253612022726207421L).setChild(SimpleLongDecrypter.getCachedDecrypter(-378583104915791737L));
    SimpleLongDecrypter.getCachedDecrypter(6410186053963673549L).setChild(SimpleLongDecrypter.getCachedDecrypter(2545085644601778134L));
    SimpleLongDecrypter.getCachedDecrypter(-3050877384699091304L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6210697667982859347L));
    SimpleLongDecrypter.getCachedDecrypter(-1407748949680895421L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2473903493979893477L));
    SimpleLongDecrypter.getCachedDecrypter(4236588051694513591L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3934059828501338778L));
    SimpleLongDecrypter.getCachedDecrypter(-8906965794862352509L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2748493371333511890L));
    SimpleLongDecrypter.getCachedDecrypter(8448765178915162617L).setChild(SimpleLongDecrypter.getCachedDecrypter(5068901346320826008L));
    SimpleLongDecrypter.getCachedDecrypter(3057353056007199664L).setChild(SimpleLongDecrypter.getCachedDecrypter(-459259763091732642L));
    SimpleLongDecrypter.getCachedDecrypter(-4090125480882706864L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1845259621173860050L));
    SimpleLongDecrypter.getCachedDecrypter(1392663850211087745L).setChild(SimpleLongDecrypter.getCachedDecrypter(4896295211361002972L));
    SimpleLongDecrypter.getCachedDecrypter(361689625360603220L).setChild(SimpleLongDecrypter.getCachedDecrypter(204842635809641210L));
    SimpleLongDecrypter.getCachedDecrypter(8337816915690804359L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4108156691947284755L));
    SimpleLongDecrypter.getCachedDecrypter(-130517498433288300L).setChild(SimpleLongDecrypter.getCachedDecrypter(8734452080609553746L));
    SimpleLongDecrypter.getCachedDecrypter(-5765425828538491135L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1261574249981984840L));
    SimpleLongDecrypter.getCachedDecrypter(5939308303333732094L).setChild(SimpleLongDecrypter.getCachedDecrypter(-9101067556274718087L));
    SimpleLongDecrypter.getCachedDecrypter(-7562851225787896866L).setChild(SimpleLongDecrypter.getCachedDecrypter(3530124144772958146L));
    SimpleLongDecrypter.getCachedDecrypter(-1902860572831520869L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4263764844469825532L));
    SimpleLongDecrypter.getCachedDecrypter(2444118617923845926L).setChild(SimpleLongDecrypter.getCachedDecrypter(-430984328636349782L));
    SimpleLongDecrypter.getCachedDecrypter(-4665851761462832761L).setChild(SimpleLongDecrypter.getCachedDecrypter(1498861828534737665L));
    SimpleLongDecrypter.getCachedDecrypter(-786139948718906761L).setChild(SimpleLongDecrypter.getCachedDecrypter(781759367631119988L));
    SimpleLongDecrypter.getCachedDecrypter(-8471685103271757479L).setChild(SimpleLongDecrypter.getCachedDecrypter(3517190925728161385L));
    SimpleLongDecrypter.getCachedDecrypter(-1305159011629204733L).setChild(SimpleLongDecrypter.getCachedDecrypter(4314504125399239467L));
    SimpleLongDecrypter.getCachedDecrypter(-5059263106480020230L).setChild(SimpleLongDecrypter.getCachedDecrypter(115628670855171164L));
    SimpleLongDecrypter.getCachedDecrypter(-6529882568881267292L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2781405637859943210L));
    SimpleLongDecrypter.getCachedDecrypter(4986387001628926195L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8781150472552471188L));
    SimpleLongDecrypter.getCachedDecrypter(7818183889803409752L).setChild(SimpleLongDecrypter.getCachedDecrypter(1731245939687024597L));
    SimpleLongDecrypter.getCachedDecrypter(9073080208619462339L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5892003626993702213L));
    SimpleLongDecrypter.getCachedDecrypter(3744328038665870132L).setChild(SimpleLongDecrypter.getCachedDecrypter(534995755347789862L));
    SimpleLongDecrypter.getCachedDecrypter(-822911958298858319L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4762417736863143366L));
    SimpleLongDecrypter.getCachedDecrypter(-1587306100756810047L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5763327547164684101L));
    SimpleLongDecrypter.getCachedDecrypter(-3620675944284060761L).setChild(SimpleLongDecrypter.getCachedDecrypter(-510112038253950827L));
    SimpleLongDecrypter.getCachedDecrypter(-2095604666882560921L).setChild(SimpleLongDecrypter.getCachedDecrypter(7421687319443371742L));
    SimpleLongDecrypter.getCachedDecrypter(944244278445438484L).setChild(SimpleLongDecrypter.getCachedDecrypter(2693259185777051717L));
    SimpleLongDecrypter.getCachedDecrypter(6349739631692162792L).setChild(SimpleLongDecrypter.getCachedDecrypter(5251643600259939000L));
    SimpleLongDecrypter.getCachedDecrypter(-7964986868026421452L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6503842824570032961L));
    SimpleLongDecrypter.getCachedDecrypter(-1339464723958995205L).setChild(SimpleLongDecrypter.getCachedDecrypter(-439904404007456266L));
    SimpleLongDecrypter.getCachedDecrypter(-6267110119259939800L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2213620631355669931L));
    SimpleLongDecrypter.getCachedDecrypter(2195297040547941010L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6036130927416826466L));
    SimpleLongDecrypter.getCachedDecrypter(-3635899182370024525L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7962489462776054695L));
    SimpleLongDecrypter.getCachedDecrypter(-7082735442922805344L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8188567450255973044L));
    SimpleLongDecrypter.getCachedDecrypter(-6160870960674341068L).setChild(SimpleLongDecrypter.getCachedDecrypter(506497671333270429L));
    SimpleLongDecrypter.getCachedDecrypter(6926933056808113743L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8232327327937262234L));
    SimpleLongDecrypter.getCachedDecrypter(8652705945099767755L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6637100465415064466L));
    SimpleLongDecrypter.getCachedDecrypter(-8515961753106348133L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8081365087505464917L));
    SimpleLongDecrypter.getCachedDecrypter(395268676720384512L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3140235633325434923L));
    SimpleLongDecrypter.getCachedDecrypter(1925054666822262402L).setChild(SimpleLongDecrypter.getCachedDecrypter(1266116562772003908L));
    SimpleLongDecrypter.getCachedDecrypter(2530205096464133970L).setChild(SimpleLongDecrypter.getCachedDecrypter(8992475098889097120L));
    SimpleLongDecrypter.getCachedDecrypter(-6540023932777848058L).setChild(SimpleLongDecrypter.getCachedDecrypter(4301927205159801191L));
    SimpleLongDecrypter.getCachedDecrypter(-3897358688431377058L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5550460529409159860L));
    SimpleLongDecrypter.getCachedDecrypter(-3194846047851463045L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8067415010166852420L));
    SimpleLongDecrypter.getCachedDecrypter(-4158011642987891572L).setChild(SimpleLongDecrypter.getCachedDecrypter(8691922172153854547L));
    SimpleLongDecrypter.getCachedDecrypter(-3839670183351774361L).setChild(SimpleLongDecrypter.getCachedDecrypter(8742548475825882702L));
    SimpleLongDecrypter.getCachedDecrypter(-4903308482967971646L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7718431959952319489L));
    SimpleLongDecrypter.getCachedDecrypter(3489735710305116480L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6568225821611770867L));
    SimpleLongDecrypter.getCachedDecrypter(2621367610522681285L).setChild(SimpleLongDecrypter.getCachedDecrypter(8116228842664109392L));
    SimpleLongDecrypter.getCachedDecrypter(419853503675703848L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6729066079806909382L));
    SimpleLongDecrypter.getCachedDecrypter(-7449706112540656127L).setChild(SimpleLongDecrypter.getCachedDecrypter(5796707392960242636L));
    SimpleLongDecrypter.getCachedDecrypter(-1204466139341444200L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8769336641727557478L));
    SimpleLongDecrypter.getCachedDecrypter(-6861188099878450360L).setChild(SimpleLongDecrypter.getCachedDecrypter(5177699500784113388L));
    SimpleLongDecrypter.getCachedDecrypter(-5819820315177618942L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2042656567073087083L));
    SimpleLongDecrypter.getCachedDecrypter(-6923538913548135444L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5103700385353568744L));
    SimpleLongDecrypter.getCachedDecrypter(-2568171337183865152L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1687752523079363847L));
    SimpleLongDecrypter.getCachedDecrypter(6171767994888564121L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7054815939549967669L));
    SimpleLongDecrypter.getCachedDecrypter(7274116216330748339L).setChild(SimpleLongDecrypter.getCachedDecrypter(-88992214020540670L));
    SimpleLongDecrypter.getCachedDecrypter(5340991671682028639L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2646568114065908421L));
    SimpleLongDecrypter.getCachedDecrypter(-406360373630190612L).setChild(SimpleLongDecrypter.getCachedDecrypter(4792945756970219759L));
    SimpleLongDecrypter.getCachedDecrypter(-234855949964617381L).setChild(SimpleLongDecrypter.getCachedDecrypter(-761772711232521406L));
    SimpleLongDecrypter.getCachedDecrypter(-2183625647105481466L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5585125933343233217L));
    SimpleLongDecrypter.getCachedDecrypter(2070569302860676030L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6499316274545131691L));
    SimpleLongDecrypter.getCachedDecrypter(-1533012689217631230L).setChild(SimpleLongDecrypter.getCachedDecrypter(4146812658546732030L));
    SimpleLongDecrypter.getCachedDecrypter(3216159436105609797L).setChild(SimpleLongDecrypter.getCachedDecrypter(6450814972817031474L));
    SimpleLongDecrypter.getCachedDecrypter(7337088737787407690L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1866112981936700991L));
    SimpleLongDecrypter.getCachedDecrypter(6546726037700175056L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8198651759612411702L));
    SimpleLongDecrypter.getCachedDecrypter(5763083069142072911L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4007265190674354335L));
    SimpleLongDecrypter.getCachedDecrypter(-797970001185778887L).setChild(SimpleLongDecrypter.getCachedDecrypter(1033873022318610980L));
    SimpleLongDecrypter.getCachedDecrypter(1564900841208575884L).setChild(SimpleLongDecrypter.getCachedDecrypter(6154624247880896829L));
    SimpleLongDecrypter.getCachedDecrypter(-7872296773749919374L).setChild(SimpleLongDecrypter.getCachedDecrypter(7151273152527155899L));
    SimpleLongDecrypter.getCachedDecrypter(-5617374066161817628L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6192237917970790436L));
    SimpleLongDecrypter.getCachedDecrypter(8869069173820047768L).setChild(SimpleLongDecrypter.getCachedDecrypter(6634122443583445942L));
    SimpleLongDecrypter.getCachedDecrypter(4051267050173812799L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7798855477378304638L));
    SimpleLongDecrypter.getCachedDecrypter(-7136778762495634762L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2254332461018839683L));
    SimpleLongDecrypter.getCachedDecrypter(9077444728485617593L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7902178421858125729L));
    SimpleLongDecrypter.getCachedDecrypter(-4190293606630623801L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3827549316738103350L));
    SimpleLongDecrypter.getCachedDecrypter(8123414983467587327L).setChild(SimpleLongDecrypter.getCachedDecrypter(7548625935894456327L));
    SimpleLongDecrypter.getCachedDecrypter(4756937187665201685L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6917248340964123L));
    SimpleLongDecrypter.getCachedDecrypter(-1763035265546887827L).setChild(SimpleLongDecrypter.getCachedDecrypter(7701439795142094065L));
    SimpleLongDecrypter.getCachedDecrypter(8615195480243312642L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5273128524910742733L));
    SimpleLongDecrypter.getCachedDecrypter(-9156749268158163070L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6775825287055311240L));
    SimpleLongDecrypter.getCachedDecrypter(3485954081509334010L).setChild(SimpleLongDecrypter.getCachedDecrypter(4569573544282848207L));
    SimpleLongDecrypter.getCachedDecrypter(-1599678998189121009L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2124053579261877332L));
    SimpleLongDecrypter.getCachedDecrypter(-6211645423194411939L).setChild(SimpleLongDecrypter.getCachedDecrypter(2367363218296822603L));
    SimpleLongDecrypter.getCachedDecrypter(-4278228138317088718L).setChild(SimpleLongDecrypter.getCachedDecrypter(3737728533147581839L));
    SimpleLongDecrypter.getCachedDecrypter(-5134193286250597421L).setChild(SimpleLongDecrypter.getCachedDecrypter(5706436078071354656L));
    SimpleLongDecrypter.getCachedDecrypter(-3301737976759136321L).setChild(SimpleLongDecrypter.getCachedDecrypter(4221950029879721471L));
    SimpleLongDecrypter.getCachedDecrypter(6989377807297194735L).setChild(SimpleLongDecrypter.getCachedDecrypter(8693788439019486229L));
    SimpleLongDecrypter.getCachedDecrypter(4064376815669702283L).setChild(SimpleLongDecrypter.getCachedDecrypter(857201944168274217L));
    SimpleLongDecrypter.getCachedDecrypter(8744148804982604716L).setChild(SimpleLongDecrypter.getCachedDecrypter(8586476969485614159L));
    SimpleLongDecrypter.getCachedDecrypter(644191710526643751L).setChild(SimpleLongDecrypter.getCachedDecrypter(3237780179820166555L));
    SimpleLongDecrypter.getCachedDecrypter(8015319415608055960L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6353769624846865260L));
    SimpleLongDecrypter.getCachedDecrypter(-5148795244977954023L).setChild(SimpleLongDecrypter.getCachedDecrypter(8578640289587340680L));
    SimpleLongDecrypter.getCachedDecrypter(3481763425916949095L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2049521222394817462L));
    SimpleLongDecrypter.getCachedDecrypter(-442478870125095842L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8881313692116588375L));
    SimpleLongDecrypter.getCachedDecrypter(6546039463061568173L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2907070742324026490L));
    SimpleLongDecrypter.getCachedDecrypter(-3853673304230964239L).setChild(SimpleLongDecrypter.getCachedDecrypter(2802541380018343544L));
    SimpleLongDecrypter.getCachedDecrypter(8049323981228840204L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2154652276225259664L));
    SimpleLongDecrypter.getCachedDecrypter(-1774571464897092962L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8616608047438441805L));
    SimpleLongDecrypter.getCachedDecrypter(-1076853949166901338L).setChild(SimpleLongDecrypter.getCachedDecrypter(7320816159752358541L));
    SimpleLongDecrypter.getCachedDecrypter(5757777911833986729L).setChild(SimpleLongDecrypter.getCachedDecrypter(8523784981563329105L));
    SimpleLongDecrypter.getCachedDecrypter(3746827096723897243L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2369919603171053267L));
    SimpleLongDecrypter.getCachedDecrypter(7884292683753352601L).setChild(SimpleLongDecrypter.getCachedDecrypter(2371511123464566991L));
    SimpleLongDecrypter.getCachedDecrypter(394596521283131811L).setChild(SimpleLongDecrypter.getCachedDecrypter(590093467030702653L));
    SimpleLongDecrypter.getCachedDecrypter(7204873755456844705L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3117332478503248651L));
    SimpleLongDecrypter.getCachedDecrypter(-6795631248796792530L).setChild(SimpleLongDecrypter.getCachedDecrypter(6735597719008617323L));
    SimpleLongDecrypter.getCachedDecrypter(3375182685821931590L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5340248739275311178L));
    SimpleLongDecrypter.getCachedDecrypter(9085500316335344274L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2495272224289347492L));
    SimpleLongDecrypter.getCachedDecrypter(-9110917481300078142L).setChild(SimpleLongDecrypter.getCachedDecrypter(2531986729633353124L));
    SimpleLongDecrypter.getCachedDecrypter(6362455586043225804L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6002430136711561821L));
    SimpleLongDecrypter.getCachedDecrypter(-932717631578316767L).setChild(SimpleLongDecrypter.getCachedDecrypter(3105818719703982991L));
    SimpleLongDecrypter.getCachedDecrypter(-4819764561478341351L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2312872564724143296L));
    SimpleLongDecrypter.getCachedDecrypter(-5538845460319945339L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1841751061392169458L));
    SimpleLongDecrypter.getCachedDecrypter(8556072894249772299L).setChild(SimpleLongDecrypter.getCachedDecrypter(919348880000951843L));
    SimpleLongDecrypter.getCachedDecrypter(3604329199951685635L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5416148051831291773L));
    SimpleLongDecrypter.getCachedDecrypter(-1040021295561250879L).setChild(SimpleLongDecrypter.getCachedDecrypter(-8182466970736895429L));
    SimpleLongDecrypter.getCachedDecrypter(-4022042888108275255L).setChild(SimpleLongDecrypter.getCachedDecrypter(5865332559364661771L));
    SimpleLongDecrypter.getCachedDecrypter(5746471864070743371L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1695796155735699321L));
    SimpleLongDecrypter.getCachedDecrypter(-5937981345176564746L).setChild(SimpleLongDecrypter.getCachedDecrypter(-873658881905925622L));
    SimpleLongDecrypter.getCachedDecrypter(-3190731840701391617L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4784735121240880470L));
    SimpleLongDecrypter.getCachedDecrypter(-5661547407791187888L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2707262269984351755L));
    SimpleLongDecrypter.getCachedDecrypter(6089199059640371863L).setChild(SimpleLongDecrypter.getCachedDecrypter(4163240203735598724L));
    SimpleLongDecrypter.getCachedDecrypter(5595977630662190260L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6739742118757754660L));
    SimpleLongDecrypter.getCachedDecrypter(-8112409814377107772L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7410703826639319079L));
    SimpleLongDecrypter.getCachedDecrypter(-4914838825486075048L).setChild(SimpleLongDecrypter.getCachedDecrypter(5034536773969575943L));
    SimpleLongDecrypter.getCachedDecrypter(5805138704225564179L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6234229361970831054L));
    SimpleLongDecrypter.getCachedDecrypter(7067708435390684181L).setChild(SimpleLongDecrypter.getCachedDecrypter(2039451878026792880L));
    SimpleLongDecrypter.getCachedDecrypter(5977480719136064405L).setChild(SimpleLongDecrypter.getCachedDecrypter(3421968712861918015L));
    SimpleLongDecrypter.getCachedDecrypter(8778661043995307043L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1232638800979478577L));
    SimpleLongDecrypter.getCachedDecrypter(-6001122989254055460L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7497008411315546163L));
    SimpleLongDecrypter.getCachedDecrypter(-8213384286531170193L).setChild(SimpleLongDecrypter.getCachedDecrypter(-783850359622143819L));
    SimpleLongDecrypter.getCachedDecrypter(2013617285219519111L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7441799508157325060L));
    SimpleLongDecrypter.getCachedDecrypter(-2381361684164834084L).setChild(SimpleLongDecrypter.getCachedDecrypter(-649450547294321637L));
    SimpleLongDecrypter.getCachedDecrypter(-2416278818245275920L).setChild(SimpleLongDecrypter.getCachedDecrypter(5029001852695440059L));
    SimpleLongDecrypter.getCachedDecrypter(4849029536827076223L).setChild(SimpleLongDecrypter.getCachedDecrypter(6385493025280121372L));
    SimpleLongDecrypter.getCachedDecrypter(-8424229937282305836L).setChild(SimpleLongDecrypter.getCachedDecrypter(8320493775880418339L));
    SimpleLongDecrypter.getCachedDecrypter(-4514603734649314352L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2613331830476356582L));
    SimpleLongDecrypter.getCachedDecrypter(4018090343122046663L).setChild(SimpleLongDecrypter.getCachedDecrypter(731668010870130746L));
    SimpleLongDecrypter.getCachedDecrypter(-2953799052069206233L).setChild(SimpleLongDecrypter.getCachedDecrypter(4884533278795276364L));
    SimpleLongDecrypter.getCachedDecrypter(3796199456439943119L).setChild(SimpleLongDecrypter.getCachedDecrypter(6851062508416013699L));
    SimpleLongDecrypter.getCachedDecrypter(6504255894926000394L).setChild(SimpleLongDecrypter.getCachedDecrypter(4991864357580206432L));
    SimpleLongDecrypter.getCachedDecrypter(-7114430753912583426L).setChild(SimpleLongDecrypter.getCachedDecrypter(-5339896538127694890L));
    SimpleLongDecrypter.getCachedDecrypter(-6521271303948254436L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2711921645733899388L));
    SimpleLongDecrypter.getCachedDecrypter(-913249808141621761L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7464150191667606742L));
    SimpleLongDecrypter.getCachedDecrypter(7243723480659128458L).setChild(SimpleLongDecrypter.getCachedDecrypter(-7255249095637073690L));
    SimpleLongDecrypter.getCachedDecrypter(2265532591832649986L).setChild(SimpleLongDecrypter.getCachedDecrypter(-6182447631327552950L));
    SimpleLongDecrypter.getCachedDecrypter(7775834118475129116L).setChild(SimpleLongDecrypter.getCachedDecrypter(-2960508264570444660L));
    SimpleLongDecrypter.getCachedDecrypter(-2449604811915569972L).setChild(SimpleLongDecrypter.getCachedDecrypter(6286640156965522327L));
    SimpleLongDecrypter.getCachedDecrypter(-2035672979804289003L).setChild(SimpleLongDecrypter.getCachedDecrypter(1919765053951512027L));
    SimpleLongDecrypter.getCachedDecrypter(7994460447217903383L).setChild(SimpleLongDecrypter.getCachedDecrypter(-915821709692845186L));
    SimpleLongDecrypter.getCachedDecrypter(3089960458208207407L).setChild(SimpleLongDecrypter.getCachedDecrypter(-1700871477840608347L));
    SimpleLongDecrypter.getCachedDecrypter(-8810700170553810626L).setChild(SimpleLongDecrypter.getCachedDecrypter(1065230423441244469L));
    SimpleLongDecrypter.getCachedDecrypter(-8254754090985849191L).setChild(SimpleLongDecrypter.getCachedDecrypter(-899652975262687915L));
    SimpleLongDecrypter.getCachedDecrypter(2232877113175008577L).setChild(SimpleLongDecrypter.getCachedDecrypter(1211541992046158761L));
    SimpleLongDecrypter.getCachedDecrypter(-4279676109623497126L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3388602136030134803L));
    SimpleLongDecrypter.getCachedDecrypter(7598025337294845017L).setChild(SimpleLongDecrypter.getCachedDecrypter(-4508774729372623533L));
    SimpleLongDecrypter.getCachedDecrypter(-7593614314791404258L).setChild(SimpleLongDecrypter.getCachedDecrypter(-3295144668808350244L));
    SimpleLongDecrypter.getCachedDecrypter(-3946673195261662158L).setChild(SimpleLongDecrypter.getCachedDecrypter(1405119140104038561L));
    SimpleLongDecrypter.getCachedDecrypter(-1687801297030480490L).setKey(9035505579810971093L);
    SimpleLongDecrypter.getCachedDecrypter(839170810005028463L).setKey(1377509904951237953L);
    SimpleLongDecrypter.getCachedDecrypter(1006235134574781600L).setKey(8813853026480736637L);
    SimpleLongDecrypter.getCachedDecrypter(5827005005929101760L).setKey(8068702893528140911L);
    SimpleLongDecrypter.getCachedDecrypter(-1620130627922048736L).setKey(-2794292103442652149L);
    SimpleLongDecrypter.getCachedDecrypter(-2889786308392928681L).setKey(-438246856312059149L);
    SimpleLongDecrypter.getCachedDecrypter(4201142996276959446L).setKey(-7623324939006558795L);
    SimpleLongDecrypter.getCachedDecrypter(-7588767932666833750L).setKey(3606389575382117317L);
    SimpleLongDecrypter.getCachedDecrypter(-3431590292493056223L).setKey(8874977424003475424L);
    SimpleLongDecrypter.getCachedDecrypter(8344279254774909678L).setKey(3952465644874973885L);
    SimpleLongDecrypter.getCachedDecrypter(3532030509744383556L).setKey(4583709014226352936L);
    SimpleLongDecrypter.getCachedDecrypter(-4066597297490302706L).setKey(-7474714324265743083L);
    SimpleLongDecrypter.getCachedDecrypter(1484684983882196676L).setKey(6628077279547674892L);
    SimpleLongDecrypter.getCachedDecrypter(-2675550573962655852L).setKey(2801870046184812837L);
    SimpleLongDecrypter.getCachedDecrypter(-6051868466913286154L).setKey(-3520584899529120052L);
    SimpleLongDecrypter.getCachedDecrypter(8601260025962749253L).setKey(1974916616525825200L);
    SimpleLongDecrypter.getCachedDecrypter(-8239545246304600392L).setKey(-8423443726748823337L);
    SimpleLongDecrypter.getCachedDecrypter(7630665689401722303L).setKey(6247100607277175900L);
    SimpleLongDecrypter.getCachedDecrypter(-1535437735835094979L).setKey(6101167110993430704L);
    SimpleLongDecrypter.getCachedDecrypter(-2786418183258079495L).setKey(-1987378687821681385L);
    SimpleLongDecrypter.getCachedDecrypter(776627356474954479L).setKey(3829215224626892749L);
    SimpleLongDecrypter.getCachedDecrypter(-3860853012179319122L).setKey(-1314273391555892849L);
    SimpleLongDecrypter.getCachedDecrypter(-4476583800497163020L).setKey(2239573647235333618L);
    SimpleLongDecrypter.getCachedDecrypter(8468387033847605840L).setKey(-4968121689851854740L);
    SimpleLongDecrypter.getCachedDecrypter(-963157713029069682L).setKey(951603026848971592L);
    SimpleLongDecrypter.getCachedDecrypter(-186695498145066343L).setKey(3464899193122336136L);
    SimpleLongDecrypter.getCachedDecrypter(-4259580546096079344L).setKey(2825202266775768970L);
    SimpleLongDecrypter.getCachedDecrypter(-7030730832343435102L).setKey(-4269990181730933622L);
    SimpleLongDecrypter.getCachedDecrypter(-7969399907252088328L).setKey(-8122560438108013314L);
    SimpleLongDecrypter.getCachedDecrypter(7993869036920847124L).setKey(1105798848640253001L);
    SimpleLongDecrypter.getCachedDecrypter(-7743886045768841356L).setKey(-1390547221052100562L);
    SimpleLongDecrypter.getCachedDecrypter(9012542123871370574L).setKey(-7716357647625918511L);
    SimpleLongDecrypter.getCachedDecrypter(-2827916667201564899L).setKey(8580877964489791682L);
    SimpleLongDecrypter.getCachedDecrypter(1482205076031720975L).setKey(-7852393681512182320L);
    SimpleLongDecrypter.getCachedDecrypter(-1774036003052191396L).setKey(-7461611579477431112L);
    SimpleLongDecrypter.getCachedDecrypter(5781428741125141782L).setKey(-7132412673758717472L);
    SimpleLongDecrypter.getCachedDecrypter(5140763764799103058L).setKey(-7087578082822814404L);
    SimpleLongDecrypter.getCachedDecrypter(4667156429308708375L).setKey(-2974673979564228050L);
    SimpleLongDecrypter.getCachedDecrypter(4195824480653337711L).setKey(2871872036548071985L);
    SimpleLongDecrypter.getCachedDecrypter(1177893404256704386L).setKey(-6593555716033411144L);
    SimpleLongDecrypter.getCachedDecrypter(-7974804659770440780L).setKey(3755286896429122408L);
    SimpleLongDecrypter.getCachedDecrypter(5530100548402394811L).setKey(4831236902013542759L);
    SimpleLongDecrypter.getCachedDecrypter(-32548523916352716L).setKey(6982064104588075165L);
    SimpleLongDecrypter.getCachedDecrypter(-7652880060730765566L).setKey(4073454997947425743L);
    SimpleLongDecrypter.getCachedDecrypter(-8523600006446826161L).setKey(589966531699892954L);
    SimpleLongDecrypter.getCachedDecrypter(-5577819823085510975L).setKey(373578814694300140L);
    SimpleLongDecrypter.getCachedDecrypter(1259574829590385678L).setKey(-385206962206420812L);
    SimpleLongDecrypter.getCachedDecrypter(7754942803328756876L).setKey(439371597307386824L);
    SimpleLongDecrypter.getCachedDecrypter(-7592416742862684129L).setKey(-6910514494554877980L);
    SimpleLongDecrypter.getCachedDecrypter(-3040459825056057948L).setKey(1394869002000922205L);
    SimpleLongDecrypter.getCachedDecrypter(-3244954416438319973L).setKey(8721308627724101276L);
    SimpleLongDecrypter.getCachedDecrypter(392907372959869062L).setKey(-5252902945472920538L);
    SimpleLongDecrypter.getCachedDecrypter(791581630082120729L).setKey(-4777325010767433845L);
    SimpleLongDecrypter.getCachedDecrypter(-7247856208351020506L).setKey(5451488223132349625L);
    SimpleLongDecrypter.getCachedDecrypter(-6441650631652793428L).setKey(-1685394237288469814L);
    SimpleLongDecrypter.getCachedDecrypter(-1133689432286988254L).setKey(3849261407629588495L);
    SimpleLongDecrypter.getCachedDecrypter(3232686385880699986L).setKey(-7259462095418955005L);
    SimpleLongDecrypter.getCachedDecrypter(-5429525813836609683L).setKey(5560875312476557975L);
    SimpleLongDecrypter.getCachedDecrypter(-3034646919166970109L).setKey(6724045258221870829L);
    SimpleLongDecrypter.getCachedDecrypter(3660622377763254266L).setKey(4705656288916800910L);
    SimpleLongDecrypter.getCachedDecrypter(-7453367982812875730L).setKey(-5914398315239713275L);
    SimpleLongDecrypter.getCachedDecrypter(8563163625146084871L).setKey(-7502742840923875349L);
    SimpleLongDecrypter.getCachedDecrypter(-5881540505870494241L).setKey(-8204972744592668688L);
    SimpleLongDecrypter.getCachedDecrypter(5807553681231454994L).setKey(7893784886526427602L);
    SimpleLongDecrypter.getCachedDecrypter(7868358815255099492L).setKey(582022674235852978L);
    SimpleLongDecrypter.getCachedDecrypter(8284317391688468263L).setKey(-3914219111943616045L);
    SimpleLongDecrypter.getCachedDecrypter(3962748777278634472L).setKey(66977511477576116L);
    SimpleLongDecrypter.getCachedDecrypter(7267881475870807184L).setKey(429199649098519217L);
    SimpleLongDecrypter.getCachedDecrypter(-3975493155070590315L).setKey(-3102339716374233214L);
    SimpleLongDecrypter.getCachedDecrypter(8283510796984287033L).setKey(-7272138909926388507L);
    SimpleLongDecrypter.getCachedDecrypter(335308784435883952L).setKey(5313070806350919952L);
    SimpleLongDecrypter.getCachedDecrypter(8225825407399966743L).setKey(-6672093826064048687L);
    SimpleLongDecrypter.getCachedDecrypter(4017299796935741729L).setKey(2545437831806384503L);
    SimpleLongDecrypter.getCachedDecrypter(-7514084015960819271L).setKey(-1931115984382962138L);
    SimpleLongDecrypter.getCachedDecrypter(-3316859656188138800L).setKey(8328162419429353172L);
    SimpleLongDecrypter.getCachedDecrypter(-659327610908283410L).setKey(2720678390731021359L);
    SimpleLongDecrypter.getCachedDecrypter(1604568453256038459L).setKey(-5035789255770332051L);
    SimpleLongDecrypter.getCachedDecrypter(1285609683576345001L).setKey(-1760393444990642333L);
    SimpleLongDecrypter.getCachedDecrypter(-915907276286386849L).setKey(8458744486949385602L);
    SimpleLongDecrypter.getCachedDecrypter(-2613321510381934377L).setKey(-8449043896509269618L);
    SimpleLongDecrypter.getCachedDecrypter(-4758681704657970022L).setKey(-7504463986668172476L);
    SimpleLongDecrypter.getCachedDecrypter(7277757535971756465L).setKey(-3540757721070907738L);
    SimpleLongDecrypter.getCachedDecrypter(-8900782187369124545L).setKey(-6163147974017894295L);
    SimpleLongDecrypter.getCachedDecrypter(-3754906561523086242L).setKey(4719431323046406244L);
    SimpleLongDecrypter.getCachedDecrypter(25423516108122609L).setKey(-5388691637680948612L);
    SimpleLongDecrypter.getCachedDecrypter(-2121989390598636866L).setKey(3443817081616157514L);
    SimpleLongDecrypter.getCachedDecrypter(7098550875079893825L).setKey(-6020865890609266889L);
    SimpleLongDecrypter.getCachedDecrypter(5889144850582701309L).setKey(5034805364492289315L);
    SimpleLongDecrypter.getCachedDecrypter(6019873341977734664L).setKey(620111562739042106L);
    SimpleLongDecrypter.getCachedDecrypter(-7436718230334501946L).setKey(-5889341832517045651L);
    SimpleLongDecrypter.getCachedDecrypter(-2805029226992001714L).setKey(-7268405893652589720L);
    SimpleLongDecrypter.getCachedDecrypter(-1268216701412074951L).setKey(-7363601240581690738L);
    SimpleLongDecrypter.getCachedDecrypter(-8139845446816054957L).setKey(7234954020884980399L);
    SimpleLongDecrypter.getCachedDecrypter(1486247676607179878L).setKey(-2001894580323844528L);
    SimpleLongDecrypter.getCachedDecrypter(-4938901033051618950L).setKey(4540780395115003979L);
    SimpleLongDecrypter.getCachedDecrypter(-5883087715123707242L).setKey(4241937628526535584L);
    SimpleLongDecrypter.getCachedDecrypter(-2312232914144269235L).setKey(7964327048443566576L);
    SimpleLongDecrypter.getCachedDecrypter(-8350530775578678934L).setKey(4575187350542413589L);
    SimpleLongDecrypter.getCachedDecrypter(-7427398034206614491L).setKey(-6130846747758328818L);
    SimpleLongDecrypter.getCachedDecrypter(481027163611181278L).setKey(8413209770904837133L);
    SimpleLongDecrypter.getCachedDecrypter(5861528041068097180L).setKey(7280840527269418701L);
    SimpleLongDecrypter.getCachedDecrypter(3854987289991889212L).setKey(-2597569056559360385L);
    SimpleLongDecrypter.getCachedDecrypter(-1959960910737496632L).setKey(4785865685211466318L);
    SimpleLongDecrypter.getCachedDecrypter(7553360981360436562L).setKey(-6387071793234398256L);
    SimpleLongDecrypter.getCachedDecrypter(7932902595496121016L).setKey(-3202630900339751153L);
    SimpleLongDecrypter.getCachedDecrypter(7545081526052856424L).setKey(-10418375960243064L);
    SimpleLongDecrypter.getCachedDecrypter(747993811866076180L).setKey(-5699884089158347300L);
    SimpleLongDecrypter.getCachedDecrypter(5028540990233040597L).setKey(1449421975980050395L);
    SimpleLongDecrypter.getCachedDecrypter(6459331634871161104L).setKey(8008479534115852162L);
    SimpleLongDecrypter.getCachedDecrypter(-9144803040383257562L).setKey(-5878005847933694208L);
    SimpleLongDecrypter.getCachedDecrypter(-6709438036463147112L).setKey(6749478747219817717L);
    SimpleLongDecrypter.getCachedDecrypter(-7043667597910571275L).setKey(1257103462245836398L);
    SimpleLongDecrypter.getCachedDecrypter(7100773112979052277L).setKey(4143504197598676611L);
    SimpleLongDecrypter.getCachedDecrypter(4564631690533534790L).setKey(4393211497186200780L);
    SimpleLongDecrypter.getCachedDecrypter(5432163899056030519L).setKey(-1521182912645219985L);
    SimpleLongDecrypter.getCachedDecrypter(658115482158717630L).setKey(-5019957363947126361L);
    SimpleLongDecrypter.getCachedDecrypter(9054661641135494679L).setKey(5107098703882637344L);
    SimpleLongDecrypter.getCachedDecrypter(7251705521748800610L).setKey(47384805705861055L);
    SimpleLongDecrypter.getCachedDecrypter(1300135942853784818L).setKey(7591632733806117408L);
    SimpleLongDecrypter.getCachedDecrypter(3590660434768594909L).setKey(-8903731610591496349L);
    SimpleLongDecrypter.getCachedDecrypter(8985527791238610512L).setKey(-2484621006183358535L);
    SimpleLongDecrypter.getCachedDecrypter(5918717561938289427L).setKey(3897527219873353352L);
    SimpleLongDecrypter.getCachedDecrypter(-5079380681825172699L).setKey(-5042401447992908746L);
    SimpleLongDecrypter.getCachedDecrypter(-9110517861132586410L).setKey(-5411680112512400596L);
    SimpleLongDecrypter.getCachedDecrypter(-7829891665816658742L).setKey(-3540765545573032319L);
    SimpleLongDecrypter.getCachedDecrypter(6148705170337054785L).setKey(2877102063159594744L);
    SimpleLongDecrypter.getCachedDecrypter(2873657619170920166L).setKey(3031881800503101175L);
    SimpleLongDecrypter.getCachedDecrypter(-6928514617268562706L).setKey(2787036127285089262L);
    SimpleLongDecrypter.getCachedDecrypter(-349674079465302572L).setKey(-3114709345632723067L);
    SimpleLongDecrypter.getCachedDecrypter(1686497131945929186L).setKey(-8635987775135122403L);
    SimpleLongDecrypter.getCachedDecrypter(3693860369801601361L).setKey(-2514510076628673584L);
    SimpleLongDecrypter.getCachedDecrypter(3063101272481544812L).setKey(-1970153809152021940L);
    SimpleLongDecrypter.getCachedDecrypter(5152815545086874584L).setKey(-8388696723669881006L);
    SimpleLongDecrypter.getCachedDecrypter(-3098383440936398269L).setKey(6636730484850516863L);
    SimpleLongDecrypter.getCachedDecrypter(-219995232263326805L).setKey(3313531268657860490L);
    SimpleLongDecrypter.getCachedDecrypter(-1137892690691078103L).setKey(6002286154771606501L);
    SimpleLongDecrypter.getCachedDecrypter(-4307398480013086055L).setKey(-2033152670098084712L);
    SimpleLongDecrypter.getCachedDecrypter(5024893108290924874L).setKey(214667639394448559L);
    SimpleLongDecrypter.getCachedDecrypter(109175201415463182L).setKey(6323970893596389014L);
    SimpleLongDecrypter.getCachedDecrypter(2191254850392429911L).setKey(-266695439759028242L);
    SimpleLongDecrypter.getCachedDecrypter(6027202515584732464L).setKey(741362946662043614L);
    SimpleLongDecrypter.getCachedDecrypter(-8911483452475226164L).setKey(-1306777987400181116L);
    SimpleLongDecrypter.getCachedDecrypter(-7046471220132584275L).setKey(522496683322137953L);
    SimpleLongDecrypter.getCachedDecrypter(3367566379867133353L).setKey(-526357240420579428L);
    SimpleLongDecrypter.getCachedDecrypter(3654553137677473844L).setKey(-7085980105674617810L);
    SimpleLongDecrypter.getCachedDecrypter(2904234771865502288L).setKey(-5501853514963570863L);
    SimpleLongDecrypter.getCachedDecrypter(-7671314827118883438L).setKey(3488190176153123693L);
    SimpleLongDecrypter.getCachedDecrypter(-6175504150124776849L).setKey(7830036519447375550L);
    SimpleLongDecrypter.getCachedDecrypter(4541235248156786122L).setKey(8051860574879584565L);
    SimpleLongDecrypter.getCachedDecrypter(-441544170171554847L).setKey(5345446112717524161L);
    SimpleLongDecrypter.getCachedDecrypter(11074999347912416L).setKey(3991831966464583345L);
    SimpleLongDecrypter.getCachedDecrypter(307619396280607911L).setKey(3468931850486113083L);
    SimpleLongDecrypter.getCachedDecrypter(-8965771547849787126L).setKey(-7800593706377861082L);
    SimpleLongDecrypter.getCachedDecrypter(4591739844654543880L).setKey(-7215537456583032188L);
    SimpleLongDecrypter.getCachedDecrypter(-5396884867232164608L).setKey(2856662327795152446L);
    SimpleLongDecrypter.getCachedDecrypter(4247416644848881981L).setKey(-701217472135571135L);
    SimpleLongDecrypter.getCachedDecrypter(4027399919241943185L).setKey(924163430047002169L);
    SimpleLongDecrypter.getCachedDecrypter(-7297631962996823785L).setKey(3338141506211884991L);
    SimpleLongDecrypter.getCachedDecrypter(1561588544490454004L).setKey(6703011525747425471L);
    SimpleLongDecrypter.getCachedDecrypter(9172225693067162294L).setKey(-4265880124877152063L);
    SimpleLongDecrypter.getCachedDecrypter(248639762751927841L).setKey(-5305667596876526098L);
    SimpleLongDecrypter.getCachedDecrypter(-281687436302966097L).setKey(374887771634529925L);
    SimpleLongDecrypter.getCachedDecrypter(4867961155593887475L).setKey(2358946812439584922L);
    SimpleLongDecrypter.getCachedDecrypter(1218978968656394483L).setKey(604582270548257236L);
    SimpleLongDecrypter.getCachedDecrypter(-8114819628493794848L).setKey(4863278692607725617L);
    SimpleLongDecrypter.getCachedDecrypter(166400138357852798L).setKey(-7017439776166578550L);
    SimpleLongDecrypter.getCachedDecrypter(260907281877342762L).setKey(-1071433028933738546L);
    SimpleLongDecrypter.getCachedDecrypter(-2502543851040080084L).setKey(-3984215353523390988L);
    SimpleLongDecrypter.getCachedDecrypter(3465305237323627272L).setKey(7197253457855127886L);
    SimpleLongDecrypter.getCachedDecrypter(-2806556598135606734L).setKey(1426970277250636742L);
    SimpleLongDecrypter.getCachedDecrypter(-1907781958675083425L).setKey(-5984176814385660298L);
    SimpleLongDecrypter.getCachedDecrypter(-7762431419615679684L).setKey(6062658224649556085L);
    SimpleLongDecrypter.getCachedDecrypter(-4478371658966869487L).setKey(-4514830207866054595L);
    SimpleLongDecrypter.getCachedDecrypter(-3858958959376245448L).setKey(1783336056532879308L);
    SimpleLongDecrypter.getCachedDecrypter(4108066029710460410L).setKey(6028170797038164473L);
    SimpleLongDecrypter.getCachedDecrypter(4587516482145479764L).setKey(-314328875524115002L);
    SimpleLongDecrypter.getCachedDecrypter(-8710060895434779971L).setKey(-4810246998536323124L);
    SimpleLongDecrypter.getCachedDecrypter(-4225488680755211270L).setKey(3663258549866471184L);
    SimpleLongDecrypter.getCachedDecrypter(-2415836497856773718L).setKey(-8579413529834424107L);
    SimpleLongDecrypter.getCachedDecrypter(4623221425016167L).setKey(-6789161301525643571L);
    SimpleLongDecrypter.getCachedDecrypter(-5046134623583218587L).setKey(4130912432414557173L);
    SimpleLongDecrypter.getCachedDecrypter(8294568390575869156L).setKey(8352057332129332408L);
    SimpleLongDecrypter.getCachedDecrypter(1852012355455936192L).setKey(2622137741905938650L);
    SimpleLongDecrypter.getCachedDecrypter(-3116437842327622297L).setKey(1047536393193685649L);
    SimpleLongDecrypter.getCachedDecrypter(-1146012575931887370L).setKey(4641058947018605600L);
    SimpleLongDecrypter.getCachedDecrypter(7246959631459810883L).setKey(831154015231465068L);
    SimpleLongDecrypter.getCachedDecrypter(8371033099342313634L).setKey(-8683692831013825637L);
    SimpleLongDecrypter.getCachedDecrypter(-6527802852412647677L).setKey(-7392156296695107202L);
    SimpleLongDecrypter.getCachedDecrypter(387158419892315047L).setKey(-2291076756890039855L);
    SimpleLongDecrypter.getCachedDecrypter(7536910761199030312L).setKey(-7450017330228909994L);
    SimpleLongDecrypter.getCachedDecrypter(-6117010757481986528L).setKey(-3607612612610681344L);
    SimpleLongDecrypter.getCachedDecrypter(7000792081176753840L).setKey(-7517954538094264659L);
    SimpleLongDecrypter.getCachedDecrypter(5216381573865775291L).setKey(1824659613161437170L);
    SimpleLongDecrypter.getCachedDecrypter(-4227716031141332772L).setKey(-827805234783512526L);
    SimpleLongDecrypter.getCachedDecrypter(6073108262768041536L).setKey(-36974550633105555L);
    SimpleLongDecrypter.getCachedDecrypter(7826135133978019161L).setKey(-6700738459108044529L);
    SimpleLongDecrypter.getCachedDecrypter(-8273543908541816463L).setKey(2932268788637035988L);
    SimpleLongDecrypter.getCachedDecrypter(8350880445613818649L).setKey(5069008847109160984L);
    SimpleLongDecrypter.getCachedDecrypter(1940976831944366045L).setKey(-315452659049375244L);
    SimpleLongDecrypter.getCachedDecrypter(-5662929182390565486L).setKey(6632877225374295747L);
    SimpleLongDecrypter.getCachedDecrypter(8370394594628382209L).setKey(-8647880064616987068L);
    SimpleLongDecrypter.getCachedDecrypter(3929585644019809922L).setKey(245357827426041688L);
    SimpleLongDecrypter.getCachedDecrypter(7677858644434066103L).setKey(-5374998245735915928L);
    SimpleLongDecrypter.getCachedDecrypter(-7972260553768356599L).setKey(1399151337694181146L);
    SimpleLongDecrypter.getCachedDecrypter(-7739819938115641858L).setKey(-1320028941523408407L);
    SimpleLongDecrypter.getCachedDecrypter(3415268579951248018L).setKey(-7843370938479033245L);
    SimpleLongDecrypter.getCachedDecrypter(8339132425775158639L).setKey(1166996406176371254L);
    SimpleLongDecrypter.getCachedDecrypter(2736048942940159147L).setKey(-7812142505925698271L);
    SimpleLongDecrypter.getCachedDecrypter(-508930766859648259L).setKey(2503197228104978566L);
    SimpleLongDecrypter.getCachedDecrypter(836779339717194263L).setKey(290487210571510954L);
    SimpleLongDecrypter.getCachedDecrypter(-636220259015325774L).setKey(-9177964528137541144L);
    SimpleLongDecrypter.getCachedDecrypter(8002026561627282770L).setKey(7046737085163227102L);
    SimpleLongDecrypter.getCachedDecrypter(8231986331405567380L).setKey(-6419658544498350969L);
    SimpleLongDecrypter.getCachedDecrypter(-962968613217777221L).setKey(-5057833703398257177L);
    SimpleLongDecrypter.getCachedDecrypter(-8036758850164164654L).setKey(1168290475472081468L);
    SimpleLongDecrypter.getCachedDecrypter(2292488682947811420L).setKey(-6090060703513955747L);
    SimpleLongDecrypter.getCachedDecrypter(3045508323063487085L).setKey(8589946320136542236L);
    SimpleLongDecrypter.getCachedDecrypter(5832442757768346674L).setKey(-3016328507400082692L);
    SimpleLongDecrypter.getCachedDecrypter(6132077389017125111L).setKey(-7728960067201171513L);
    SimpleLongDecrypter.getCachedDecrypter(7040259576450741764L).setKey(-5595798624816472078L);
    SimpleLongDecrypter.getCachedDecrypter(-6370293963358373454L).setKey(-8207093526003897967L);
    SimpleLongDecrypter.getCachedDecrypter(2221606009250636723L).setKey(-687805105560877268L);
    SimpleLongDecrypter.getCachedDecrypter(-2519557508073837018L).setKey(-9126031188055963029L);
    SimpleLongDecrypter.getCachedDecrypter(-2087012827137697973L).setKey(-3313689810298160785L);
    SimpleLongDecrypter.getCachedDecrypter(-4419508519973265719L).setKey(-1641817661722236813L);
    SimpleLongDecrypter.getCachedDecrypter(1968288964176550575L).setKey(3653301301923704189L);
    SimpleLongDecrypter.getCachedDecrypter(39328731428598783L).setKey(2647198649683298028L);
    SimpleLongDecrypter.getCachedDecrypter(7957499372034169572L).setKey(-8792072935185231626L);
    SimpleLongDecrypter.getCachedDecrypter(3006452808995191439L).setKey(-8884099613982604373L);
    SimpleLongDecrypter.getCachedDecrypter(-6720810714914432366L).setKey(7585357503576567655L);
    SimpleLongDecrypter.getCachedDecrypter(4717287698072299720L).setKey(-7116106371334760395L);
    SimpleLongDecrypter.getCachedDecrypter(8149968452845977945L).setKey(5537808205388692656L);
    SimpleLongDecrypter.getCachedDecrypter(2851268574372615217L).setKey(-4326730723999084538L);
    SimpleLongDecrypter.getCachedDecrypter(6134737231181225164L).setKey(2348481523802123692L);
    SimpleLongDecrypter.getCachedDecrypter(2750199379952323854L).setKey(-5439068085289677484L);
    SimpleLongDecrypter.getCachedDecrypter(-1087812897245607622L).setKey(9088723456173358678L);
    SimpleLongDecrypter.getCachedDecrypter(-7326613922791864213L).setKey(3595627617427205864L);
    SimpleLongDecrypter.getCachedDecrypter(5425561626556952653L).setKey(-6494620781361454108L);
    SimpleLongDecrypter.getCachedDecrypter(3886195992816071889L).setKey(-9089708278327906964L);
    SimpleLongDecrypter.getCachedDecrypter(7821800698480699850L).setKey(5303451315549124476L);
    SimpleLongDecrypter.getCachedDecrypter(6875889239214488886L).setKey(-9089592825381868463L);
    SimpleLongDecrypter.getCachedDecrypter(-9194562158283875119L).setKey(3839679512409078047L);
    SimpleLongDecrypter.getCachedDecrypter(-8876695832378649699L).setKey(7004085173806683119L);
    SimpleLongDecrypter.getCachedDecrypter(-6492348001791940324L).setKey(7814914746551772879L);
    SimpleLongDecrypter.getCachedDecrypter(-4443194776765294263L).setKey(2910727677053643770L);
    SimpleLongDecrypter.getCachedDecrypter(6396529723379056641L).setKey(6165735770995137811L);
    SimpleLongDecrypter.getCachedDecrypter(-6236827486023344798L).setKey(-6663170822625004252L);
    SimpleLongDecrypter.getCachedDecrypter(6566961187202636660L).setKey(-7027860253299108978L);
    SimpleLongDecrypter.getCachedDecrypter(-6284901867111040501L).setKey(269773722422686988L);
    SimpleLongDecrypter.getCachedDecrypter(-4080762775763887452L).setKey(1588908053067955560L);
    SimpleLongDecrypter.getCachedDecrypter(8232945499780286862L).setKey(-8636989002333433378L);
    SimpleLongDecrypter.getCachedDecrypter(1040414308224927113L).setKey(-7039333939060079909L);
    SimpleLongDecrypter.getCachedDecrypter(6468232793374830649L).setKey(-4257579197762763890L);
    SimpleLongDecrypter.getCachedDecrypter(4312995677015793946L).setKey(1359607203844910961L);
    SimpleLongDecrypter.getCachedDecrypter(6076504612957138538L).setKey(6840460635959329516L);
    SimpleLongDecrypter.getCachedDecrypter(-755434027840721154L).setKey(956732614470042017L);
    SimpleLongDecrypter.getCachedDecrypter(4010543767222207949L).setKey(-4538639624725322258L);
    SimpleLongDecrypter.getCachedDecrypter(2381077128078765175L).setKey(5803035741013282126L);
    SimpleLongDecrypter.getCachedDecrypter(-4511574746930861559L).setKey(-7029090780453659500L);
    SimpleLongDecrypter.getCachedDecrypter(-8399822066866052335L).setKey(-8989214860137705611L);
    SimpleLongDecrypter.getCachedDecrypter(-5541282928550769755L).setKey(3963906748139061998L);
    SimpleLongDecrypter.getCachedDecrypter(1845285265865621153L).setKey(910093670942926199L);
    SimpleLongDecrypter.getCachedDecrypter(6462246897409408418L).setKey(-2686744058277520892L);
    SimpleLongDecrypter.getCachedDecrypter(4417134323344690978L).setKey(3742337681440984585L);
    SimpleLongDecrypter.getCachedDecrypter(9063995937948242194L).setKey(1820989811731484426L);
    SimpleLongDecrypter.getCachedDecrypter(-7592589378891271535L).setKey(-4485646021319581788L);
    SimpleLongDecrypter.getCachedDecrypter(-8403075055776698692L).setKey(-6291056022342697257L);
    SimpleLongDecrypter.getCachedDecrypter(7870693521992625590L).setKey(-4847967952185218446L);
    SimpleLongDecrypter.getCachedDecrypter(6411010144882000759L).setKey(-8559740897871839819L);
    SimpleLongDecrypter.getCachedDecrypter(1655608197477625427L).setKey(2641596413186690809L);
    SimpleLongDecrypter.getCachedDecrypter(2421490504823755073L).setKey(-4127243242611425559L);
    SimpleLongDecrypter.getCachedDecrypter(-926932694206394734L).setKey(-8547912793862211332L);
    SimpleLongDecrypter.getCachedDecrypter(-3035664730697742061L).setKey(7983398819272544532L);
    SimpleLongDecrypter.getCachedDecrypter(-2697721040860348116L).setKey(-3385854312992394390L);
    SimpleLongDecrypter.getCachedDecrypter(-5804346182067363578L).setKey(6402741130496624462L);
    SimpleLongDecrypter.getCachedDecrypter(-1082882552953889048L).setKey(-3108323842088619619L);
    SimpleLongDecrypter.getCachedDecrypter(1112857291425017313L).setKey(-5105572472645567035L);
    SimpleLongDecrypter.getCachedDecrypter(2199152616306975776L).setKey(-4068136508591089588L);
    SimpleLongDecrypter.getCachedDecrypter(7718332663798989649L).setKey(-2001013353804913076L);
    SimpleLongDecrypter.getCachedDecrypter(2210500143247915740L).setKey(-7627859552649817202L);
    SimpleLongDecrypter.getCachedDecrypter(2372902128633383783L).setKey(-46903358585155005L);
    SimpleLongDecrypter.getCachedDecrypter(-884686823001898062L).setKey(3517974750135863379L);
    SimpleLongDecrypter.getCachedDecrypter(5071105958124238334L).setKey(-5998786049080560897L);
    SimpleLongDecrypter.getCachedDecrypter(5295682040041156292L).setKey(8066568606390806871L);
    SimpleLongDecrypter.getCachedDecrypter(2049622617304318385L).setKey(1055310318991648540L);
    SimpleLongDecrypter.getCachedDecrypter(-1233459486293112933L).setKey(7824513275893960216L);
    SimpleLongDecrypter.getCachedDecrypter(-6974505110501072546L).setKey(5558815172170985524L);
    SimpleLongDecrypter.getCachedDecrypter(-4905795988123833722L).setKey(-6187363678131597249L);
    SimpleLongDecrypter.getCachedDecrypter(-2635030966957309070L).setKey(-4701446948836611410L);
    SimpleLongDecrypter.getCachedDecrypter(7932395262870543777L).setKey(-7430779967103100791L);
    SimpleLongDecrypter.getCachedDecrypter(8809329674644065381L).setKey(2277583851565714605L);
    SimpleLongDecrypter.getCachedDecrypter(-4681246297645209152L).setKey(3399565646411300966L);
    SimpleLongDecrypter.getCachedDecrypter(-2072355512435020000L).setKey(-747130619176532124L);
    SimpleLongDecrypter.getCachedDecrypter(-3793328488992891175L).setKey(-3807575941425465520L);
    SimpleLongDecrypter.getCachedDecrypter(5169963922636973259L).setKey(12143414794215200L);
    SimpleLongDecrypter.getCachedDecrypter(3373524249775982177L).setKey(7552378080220011833L);
    SimpleLongDecrypter.getCachedDecrypter(6428877910621204263L).setKey(-4785170029093271573L);
    SimpleLongDecrypter.getCachedDecrypter(5651582456464419955L).setKey(-294816742370081920L);
    SimpleLongDecrypter.getCachedDecrypter(-9176678657291839078L).setKey(-5953266836974169840L);
    SimpleLongDecrypter.getCachedDecrypter(1538008579306470285L).setKey(-1433656204360288002L);
    SimpleLongDecrypter.getCachedDecrypter(4480115463606167120L).setKey(8767048141574926581L);
    SimpleLongDecrypter.getCachedDecrypter(-5731293901856657786L).setKey(-663129145856064872L);
    SimpleLongDecrypter.getCachedDecrypter(8336224796534634643L).setKey(-1131933249930277081L);
    SimpleLongDecrypter.getCachedDecrypter(-1535088463693284447L).setKey(622363412762923977L);
    SimpleLongDecrypter.getCachedDecrypter(7419346413017907918L).setKey(-3293842723191222585L);
    SimpleLongDecrypter.getCachedDecrypter(2933741551525469605L).setKey(3834548909850754093L);
    SimpleLongDecrypter.getCachedDecrypter(-6075518333120751310L).setKey(-3232563041373393541L);
    SimpleLongDecrypter.getCachedDecrypter(408676539959910573L).setKey(8986475119606999608L);
    SimpleLongDecrypter.getCachedDecrypter(-3877574793749593026L).setKey(8600393427693055067L);
    SimpleLongDecrypter.getCachedDecrypter(-4846778859975766465L).setKey(-7747110317066423519L);
    SimpleLongDecrypter.getCachedDecrypter(-1159201591969283644L).setKey(-5445075909910378680L);
    SimpleLongDecrypter.getCachedDecrypter(4427109547073299515L).setKey(2140773358560608504L);
    SimpleLongDecrypter.getCachedDecrypter(3812451448245540120L).setKey(8912948440946833285L);
    SimpleLongDecrypter.getCachedDecrypter(4840870720231398981L).setKey(-3593216981417775196L);
    SimpleLongDecrypter.getCachedDecrypter(-8018981153987415812L).setKey(-5231998083267928344L);
    SimpleLongDecrypter.getCachedDecrypter(-7855370048175430949L).setKey(-3092141079899087802L);
    SimpleLongDecrypter.getCachedDecrypter(4176258034898269404L).setKey(5770485299527762178L);
    SimpleLongDecrypter.getCachedDecrypter(-1643443145228999436L).setKey(797463401694080086L);
    SimpleLongDecrypter.getCachedDecrypter(-127640603051631744L).setKey(249542920820664970L);
    SimpleLongDecrypter.getCachedDecrypter(-3039354916056429684L).setKey(-5967453104680934426L);
    SimpleLongDecrypter.getCachedDecrypter(359220759996767876L).setKey(3370348464833080637L);
    SimpleLongDecrypter.getCachedDecrypter(501702791910950173L).setKey(163907423549141125L);
    SimpleLongDecrypter.getCachedDecrypter(-8351484038295654227L).setKey(-4025612593385404301L);
    SimpleLongDecrypter.getCachedDecrypter(-1964183598985769939L).setKey(411979328228256891L);
    SimpleLongDecrypter.getCachedDecrypter(8284954302970426961L).setKey(4564351820050000415L);
    SimpleLongDecrypter.getCachedDecrypter(-7376009843670746216L).setKey(2402537422769344737L);
    SimpleLongDecrypter.getCachedDecrypter(-7685279077175559692L).setKey(2180762765637350838L);
    SimpleLongDecrypter.getCachedDecrypter(5145171455240678090L).setKey(-9108826966711114997L);
    SimpleLongDecrypter.getCachedDecrypter(-2893509884893299213L).setKey(-7543885711686703615L);
    SimpleLongDecrypter.getCachedDecrypter(-1190739854458198428L).setKey(-6975168008345286111L);
    SimpleLongDecrypter.getCachedDecrypter(-8520336449109017693L).setKey(-51641849365052932L);
    SimpleLongDecrypter.getCachedDecrypter(-4108885761162867100L).setKey(100956862675581815L);
    SimpleLongDecrypter.getCachedDecrypter(1562940260491982002L).setKey(-1651310101491838764L);
    SimpleLongDecrypter.getCachedDecrypter(-6439476408148614787L).setKey(-7805414810400871568L);
    SimpleLongDecrypter.getCachedDecrypter(8172784860382542701L).setKey(-6737901041146833416L);
    SimpleLongDecrypter.getCachedDecrypter(1573980181729197875L).setKey(-1210537226754819496L);
    SimpleLongDecrypter.getCachedDecrypter(6070175838425417951L).setKey(6298179822341515108L);
    SimpleLongDecrypter.getCachedDecrypter(6868550184200332147L).setKey(-1849835469544820327L);
    SimpleLongDecrypter.getCachedDecrypter(5080599972822719759L).setKey(-426610078051192163L);
    SimpleLongDecrypter.getCachedDecrypter(4786999746502386095L).setKey(-7518269483203742603L);
    SimpleLongDecrypter.getCachedDecrypter(-8920631767994130449L).setKey(-8459405991824339425L);
    SimpleLongDecrypter.getCachedDecrypter(-5707296564122575084L).setKey(1698036868601676699L);
    SimpleLongDecrypter.getCachedDecrypter(-4096446447456724046L).setKey(-36526326812840579L);
    SimpleLongDecrypter.getCachedDecrypter(-755375741544051907L).setKey(-1551958970833467862L);
    SimpleLongDecrypter.getCachedDecrypter(-2863327394034554859L).setKey(7400864207545143907L);
    SimpleLongDecrypter.getCachedDecrypter(-1537016236611366914L).setKey(-1536112437988511379L);
    SimpleLongDecrypter.getCachedDecrypter(-6583335753886652215L).setKey(-4832391137484138903L);
    SimpleLongDecrypter.getCachedDecrypter(-7159038919359916439L).setKey(3710398507625424608L);
    SimpleLongDecrypter.getCachedDecrypter(-7469435572233102543L).setKey(4845257404898684140L);
    SimpleLongDecrypter.getCachedDecrypter(-6123943533877895909L).setKey(-6502899197218424284L);
    SimpleLongDecrypter.getCachedDecrypter(-1493179252342044652L).setKey(-5030344000262533598L);
    SimpleLongDecrypter.getCachedDecrypter(2424119025980118162L).setKey(-9207786730797799012L);
    SimpleLongDecrypter.getCachedDecrypter(7732607722046907678L).setKey(8725733979988749733L);
    SimpleLongDecrypter.getCachedDecrypter(3895693713420305943L).setKey(-4889187435292506756L);
    SimpleLongDecrypter.getCachedDecrypter(6537000709347488852L).setKey(6624061872134458760L);
    SimpleLongDecrypter.getCachedDecrypter(-4979123782895317574L).setKey(-414309661443291637L);
    SimpleLongDecrypter.getCachedDecrypter(904077477839559156L).setKey(-7823538866652803985L);
    SimpleLongDecrypter.getCachedDecrypter(8862277063817607944L).setKey(-2845078297615425542L);
    SimpleLongDecrypter.getCachedDecrypter(-2409121222446195748L).setKey(-582043506198503322L);
    SimpleLongDecrypter.getCachedDecrypter(-2221616430345284721L).setKey(-7249999593604149976L);
    SimpleLongDecrypter.getCachedDecrypter(3416671676411630177L).setKey(-1333131975541866184L);
    SimpleLongDecrypter.getCachedDecrypter(2222899331485059873L).setKey(-2806070992046173478L);
    SimpleLongDecrypter.getCachedDecrypter(8427927396212620125L).setKey(-5152687137505893096L);
    SimpleLongDecrypter.getCachedDecrypter(8632823391019161055L).setKey(-8961055062510060580L);
    SimpleLongDecrypter.getCachedDecrypter(451709396012492270L).setKey(-1440477269648596841L);
    SimpleLongDecrypter.getCachedDecrypter(2599618037841700160L).setKey(-7100054497819393329L);
    SimpleLongDecrypter.getCachedDecrypter(-2365069657831159840L).setKey(-9053629108691360339L);
    SimpleLongDecrypter.getCachedDecrypter(-2289962441916204170L).setKey(6452225907307397568L);
    SimpleLongDecrypter.getCachedDecrypter(-4983788173831778289L).setKey(1663516060918635192L);
    SimpleLongDecrypter.getCachedDecrypter(-2887950265480072465L).setKey(6679879741047200740L);
    SimpleLongDecrypter.getCachedDecrypter(1929097426880982595L).setKey(8573106988944157347L);
    SimpleLongDecrypter.getCachedDecrypter(-2899245421729811714L).setKey(-399710071923785817L);
    SimpleLongDecrypter.getCachedDecrypter(5649315497809223454L).setKey(-1420025851479416892L);
    SimpleLongDecrypter.getCachedDecrypter(-6290524211650047230L).setKey(2907854199274990236L);
    SimpleLongDecrypter.getCachedDecrypter(4603789890977950864L).setKey(9064147064426499710L);
    SimpleLongDecrypter.getCachedDecrypter(2890636738118296945L).setKey(1258022009186105717L);
    SimpleLongDecrypter.getCachedDecrypter(-4501565245164148153L).setKey(4886000795372280238L);
    SimpleLongDecrypter.getCachedDecrypter(5798711220691100095L).setKey(6333290853067761144L);
    SimpleLongDecrypter.getCachedDecrypter(-3295972549289996406L).setKey(-3430254648944612538L);
    SimpleLongDecrypter.getCachedDecrypter(4752607582376704645L).setKey(6597300429970288986L);
    SimpleLongDecrypter.getCachedDecrypter(4988001084467412691L).setKey(7725863985634495853L);
    SimpleLongDecrypter.getCachedDecrypter(-2138112881857579362L).setKey(-2806599649027059265L);
    SimpleLongDecrypter.getCachedDecrypter(9175190901484709137L).setKey(-2716210300589271754L);
    SimpleLongDecrypter.getCachedDecrypter(888138362294299186L).setKey(-8498650860153517730L);
    SimpleLongDecrypter.getCachedDecrypter(735707699692774949L).setKey(4827073169134958018L);
    SimpleLongDecrypter.getCachedDecrypter(1318171398019829286L).setKey(2034890820869219376L);
    SimpleLongDecrypter.getCachedDecrypter(8812614310127049023L).setKey(2453646568108479727L);
    SimpleLongDecrypter.getCachedDecrypter(8297397481059481511L).setKey(-8863364482411877576L);
    SimpleLongDecrypter.getCachedDecrypter(7470439854761861850L).setKey(8009844027659244009L);
    SimpleLongDecrypter.getCachedDecrypter(3504080083387433859L).setKey(1950470806844378261L);
    SimpleLongDecrypter.getCachedDecrypter(-3708451777626252724L).setKey(7038473280770736499L);
    SimpleLongDecrypter.getCachedDecrypter(-2627812975015806119L).setKey(-780662190746346152L);
    SimpleLongDecrypter.getCachedDecrypter(163058306752727777L).setKey(4399970377099358519L);
    SimpleLongDecrypter.getCachedDecrypter(-2621305211317220855L).setKey(-8338437676716717608L);
    SimpleLongDecrypter.getCachedDecrypter(1297993884101108812L).setKey(6378395834111427234L);
    SimpleLongDecrypter.getCachedDecrypter(3593437967233771151L).setKey(8522515654069213993L);
    SimpleLongDecrypter.getCachedDecrypter(-7341370754945759408L).setKey(-1566170876315540300L);
    SimpleLongDecrypter.getCachedDecrypter(5406608498455424983L).setKey(-8994346090762608889L);
    SimpleLongDecrypter.getCachedDecrypter(-8218622060224332628L).setKey(-5447859367059125752L);
    SimpleLongDecrypter.getCachedDecrypter(-976283156714156863L).setKey(-5651026617450771663L);
    SimpleLongDecrypter.getCachedDecrypter(6767386477204842154L).setKey(-4670402239881012689L);
    SimpleLongDecrypter.getCachedDecrypter(-1289154608330662295L).setKey(7444528311764717661L);
    SimpleLongDecrypter.getCachedDecrypter(3691534154988820644L).setKey(-1296773750226999978L);
    SimpleLongDecrypter.getCachedDecrypter(-7785735362312587534L).setKey(-7495687207204101229L);
    SimpleLongDecrypter.getCachedDecrypter(2274036668710750423L).setKey(1005386615478125507L);
    SimpleLongDecrypter.getCachedDecrypter(6827643188359302443L).setKey(-1135694867437007267L);
    SimpleLongDecrypter.getCachedDecrypter(6271159678409443420L).setKey(5462167057988343399L);
    SimpleLongDecrypter.getCachedDecrypter(-4291321251443244794L).setKey(5256443083860993777L);
    SimpleLongDecrypter.getCachedDecrypter(5454073591614462548L).setKey(6039164277700703810L);
    SimpleLongDecrypter.getCachedDecrypter(5442815033585389152L).setKey(-6114416995504822368L);
    SimpleLongDecrypter.getCachedDecrypter(-6361424158552255530L).setKey(8912212021900882164L);
    SimpleLongDecrypter.getCachedDecrypter(-5834160701196820155L).setKey(5449604344814456756L);
    SimpleLongDecrypter.getCachedDecrypter(584237768040432510L).setKey(-7619382978784269601L);
    SimpleLongDecrypter.getCachedDecrypter(-1883817040652348665L).setKey(-575903718357673286L);
    SimpleLongDecrypter.getCachedDecrypter(-6106970829092138127L).setKey(1581259832790387046L);
    SimpleLongDecrypter.getCachedDecrypter(-4905250534538872502L).setKey(-6595927366028098271L);
    SimpleLongDecrypter.getCachedDecrypter(1546071430750274149L).setKey(-1077482295049983519L);
    SimpleLongDecrypter.getCachedDecrypter(-1918022825025335126L).setKey(-875311916100729088L);
    SimpleLongDecrypter.getCachedDecrypter(-4414036206871071086L).setKey(-3601749095234796598L);
    SimpleLongDecrypter.getCachedDecrypter(6365279892319123852L).setKey(-6908986945250052683L);
    SimpleLongDecrypter.getCachedDecrypter(5913714281943489097L).setKey(2890311399455564839L);
    SimpleLongDecrypter.getCachedDecrypter(325552484633841819L).setKey(262599111965138466L);
    SimpleLongDecrypter.getCachedDecrypter(7061436985445733451L).setKey(-20613689238962774L);
    SimpleLongDecrypter.getCachedDecrypter(3308032120243784702L).setKey(-2724516208206667505L);
    SimpleLongDecrypter.getCachedDecrypter(8519423355785793659L).setKey(1085977584225898340L);
    SimpleLongDecrypter.getCachedDecrypter(2343810709093648689L).setKey(5565412469076323750L);
    SimpleLongDecrypter.getCachedDecrypter(809112921409130388L).setKey(-6914697736417663251L);
    SimpleLongDecrypter.getCachedDecrypter(6736553558180563988L).setKey(9171849946587631499L);
    SimpleLongDecrypter.getCachedDecrypter(-7174047923056453960L).setKey(-2033857768924388826L);
    SimpleLongDecrypter.getCachedDecrypter(-8118381897477785305L).setKey(-1354567376861031144L);
    SimpleLongDecrypter.getCachedDecrypter(4596683759956111043L).setKey(7358225571007956987L);
    SimpleLongDecrypter.getCachedDecrypter(6090196190407523134L).setKey(-595981419073830578L);
    SimpleLongDecrypter.getCachedDecrypter(1945585616807457053L).setKey(-1558350019646575338L);
    SimpleLongDecrypter.getCachedDecrypter(8115684641289178706L).setKey(2582374148989639436L);
    SimpleLongDecrypter.getCachedDecrypter(-6043510010129764657L).setKey(7744564653349428776L);
    SimpleLongDecrypter.getCachedDecrypter(8953456181979649140L).setKey(-4795733194828335516L);
    SimpleLongDecrypter.getCachedDecrypter(-779557832169052213L).setKey(-4613013078691554591L);
    SimpleLongDecrypter.getCachedDecrypter(-8028890750815341112L).setKey(1510268471491600448L);
    SimpleLongDecrypter.getCachedDecrypter(-6599635743562645938L).setKey(7082779441729487601L);
    SimpleLongDecrypter.getCachedDecrypter(6303154655886984808L).setKey(-2603229809868446481L);
    SimpleLongDecrypter.getCachedDecrypter(6369875111270074581L).setKey(-2027255661464929375L);
    SimpleLongDecrypter.getCachedDecrypter(-5363221949032409450L).setKey(-3437958922090780056L);
    SimpleLongDecrypter.getCachedDecrypter(2460419919605200252L).setKey(-4648921145586776465L);
    SimpleLongDecrypter.getCachedDecrypter(5434777602218104443L).setKey(-5798533304771906907L);
    SimpleLongDecrypter.getCachedDecrypter(-2233606684578526797L).setKey(-3763939947234369966L);
    SimpleLongDecrypter.getCachedDecrypter(6308347939291995835L).setKey(7496936509384470331L);
    SimpleLongDecrypter.getCachedDecrypter(-8529905328678685367L).setKey(9185262356042353150L);
    SimpleLongDecrypter.getCachedDecrypter(3451112116632409027L).setKey(5879555502382150096L);
    SimpleLongDecrypter.getCachedDecrypter(-1666856654131134417L).setKey(2809514200547281661L);
    SimpleLongDecrypter.getCachedDecrypter(2902895224452340564L).setKey(-7182853624396882060L);
    SimpleLongDecrypter.getCachedDecrypter(-594638107599310245L).setKey(-702940019692218404L);
    SimpleLongDecrypter.getCachedDecrypter(166952504140761082L).setKey(3778463973781624237L);
    SimpleLongDecrypter.getCachedDecrypter(5594790203020303199L).setKey(1289526191179287951L);
    SimpleLongDecrypter.getCachedDecrypter(6092443694525230006L).setKey(1122415713594310385L);
    SimpleLongDecrypter.getCachedDecrypter(8826437791384391149L).setKey(4273299204133961234L);
    SimpleLongDecrypter.getCachedDecrypter(6398416945217942826L).setKey(4207426601536163599L);
    SimpleLongDecrypter.getCachedDecrypter(-6230145770719912932L).setKey(799298810026266789L);
    SimpleLongDecrypter.getCachedDecrypter(-3655003549150894501L).setKey(-7337417005264120158L);
    SimpleLongDecrypter.getCachedDecrypter(3596645359104040662L).setKey(4754915309609809649L);
    SimpleLongDecrypter.getCachedDecrypter(-1086243472940995864L).setKey(-5900966576301033204L);
    SimpleLongDecrypter.getCachedDecrypter(-4732024078944923311L).setKey(-8097600403050227438L);
    SimpleLongDecrypter.getCachedDecrypter(-5853068726447408053L).setKey(-1915068323972944722L);
    SimpleLongDecrypter.getCachedDecrypter(3850946174669505176L).setKey(-797998237440338464L);
    SimpleLongDecrypter.getCachedDecrypter(4281270001727434630L).setKey(703027750017157580L);
    SimpleLongDecrypter.getCachedDecrypter(-5655370417592776280L).setKey(-4464092640688870503L);
    SimpleLongDecrypter.getCachedDecrypter(-7678734234483440624L).setKey(-8495770254580479529L);
    SimpleLongDecrypter.getCachedDecrypter(820137591949463018L).setKey(-5305116919252405686L);
    SimpleLongDecrypter.getCachedDecrypter(354107100521717484L).setKey(-2978821922832384211L);
    SimpleLongDecrypter.getCachedDecrypter(5883485912526208804L).setKey(-3341615156110662361L);
    SimpleLongDecrypter.getCachedDecrypter(1363079898500689398L).setKey(-7182836824557277233L);
    SimpleLongDecrypter.getCachedDecrypter(763553870353473481L).setKey(-6976037711291104576L);
    SimpleLongDecrypter.getCachedDecrypter(-4581822805159337943L).setKey(842570124617100760L);
    SimpleLongDecrypter.getCachedDecrypter(-7554570115783397943L).setKey(92400705191205920L);
    SimpleLongDecrypter.getCachedDecrypter(-2359370246151854603L).setKey(-1207339949695130145L);
    SimpleLongDecrypter.getCachedDecrypter(-2921457917609803901L).setKey(-6334418659988173463L);
    SimpleLongDecrypter.getCachedDecrypter(6698313774021496879L).setKey(9093657375281836952L);
    SimpleLongDecrypter.getCachedDecrypter(2572536848615978189L).setKey(-8126151261673373471L);
    SimpleLongDecrypter.getCachedDecrypter(-8900851253759639781L).setKey(-8516479762584029131L);
    SimpleLongDecrypter.getCachedDecrypter(5264724048029029803L).setKey(-5668432723300163648L);
    SimpleLongDecrypter.getCachedDecrypter(-8609155769543066201L).setKey(-1833421338681779734L);
    SimpleLongDecrypter.getCachedDecrypter(-8316259936548822317L).setKey(-5501728033228467969L);
    SimpleLongDecrypter.getCachedDecrypter(2866743489798560366L).setKey(-714716488356254291L);
    SimpleLongDecrypter.getCachedDecrypter(3915609423946946110L).setKey(-7348791404771729181L);
    SimpleLongDecrypter.getCachedDecrypter(-3852815183546571978L).setKey(-5092982670550614622L);
    SimpleLongDecrypter.getCachedDecrypter(8711043115694317154L).setKey(1044340463972250361L);
    SimpleLongDecrypter.getCachedDecrypter(5023396092629057202L).setKey(-5881990132030728593L);
    SimpleLongDecrypter.getCachedDecrypter(7680081175224897115L).setKey(2487219127296618073L);
    SimpleLongDecrypter.getCachedDecrypter(-7882172192517585807L).setKey(-5851683080050863803L);
    SimpleLongDecrypter.getCachedDecrypter(9207914317635551425L).setKey(4427369503514914175L);
    SimpleLongDecrypter.getCachedDecrypter(1687460393217661700L).setKey(-2044136586626931996L);
    SimpleLongDecrypter.getCachedDecrypter(-1128996678733268107L).setKey(-8221463861919860707L);
    SimpleLongDecrypter.getCachedDecrypter(1227647384374047116L).setKey(-5893078586142917883L);
    SimpleLongDecrypter.getCachedDecrypter(5500239905784273107L).setKey(-1718743757037849624L);
    SimpleLongDecrypter.getCachedDecrypter(6537134838241311645L).setKey(-72248177333021804L);
    SimpleLongDecrypter.getCachedDecrypter(7463618689293348366L).setKey(7625848727137122883L);
    SimpleLongDecrypter.getCachedDecrypter(2936833663525107781L).setKey(-8627330337221118198L);
    SimpleLongDecrypter.getCachedDecrypter(-5232993446441342972L).setKey(737878678157022364L);
    SimpleLongDecrypter.getCachedDecrypter(-9029473139822572694L).setKey(2519891012346377604L);
    SimpleLongDecrypter.getCachedDecrypter(-4503676040007695910L).setKey(4978034748702037509L);
    SimpleLongDecrypter.getCachedDecrypter(-4674304416455827993L).setKey(3221349535402744972L);
    SimpleLongDecrypter.getCachedDecrypter(8982377522245505405L).setKey(-3529652310620596876L);
    SimpleLongDecrypter.getCachedDecrypter(5948007592606886255L).setKey(-8779628119918254746L);
    SimpleLongDecrypter.getCachedDecrypter(-7935618996094257082L).setKey(-6080969070247268314L);
    SimpleLongDecrypter.getCachedDecrypter(5570246185025275275L).setKey(7914309787471799752L);
    SimpleLongDecrypter.getCachedDecrypter(6436191200845220688L).setKey(7469112655643288840L);
    SimpleLongDecrypter.getCachedDecrypter(-8341785244379023550L).setKey(-4210756206632500079L);
    SimpleLongDecrypter.getCachedDecrypter(-2134041379326950394L).setKey(2991251194564825594L);
    SimpleLongDecrypter.getCachedDecrypter(4721095900471678578L).setKey(-8520178170671559678L);
    SimpleLongDecrypter.getCachedDecrypter(8446111474270490455L).setKey(-6959757460746127888L);
    SimpleLongDecrypter.getCachedDecrypter(997957384136369101L).setKey(8543486924188738528L);
    SimpleLongDecrypter.getCachedDecrypter(-660616488852506193L).setKey(7126131745266764026L);
    SimpleLongDecrypter.getCachedDecrypter(-3608379651159953532L).setKey(7456141658062544518L);
    SimpleLongDecrypter.getCachedDecrypter(-8957618341825712324L).setKey(5472632429522914509L);
    SimpleLongDecrypter.getCachedDecrypter(736275967068741835L).setKey(-595458958461975751L);
    SimpleLongDecrypter.getCachedDecrypter(-3023363938460094996L).setKey(6664103185166238084L);
    SimpleLongDecrypter.getCachedDecrypter(-7788562506699970436L).setKey(7394565787448193054L);
    SimpleLongDecrypter.getCachedDecrypter(371855841752901933L).setKey(-1111599365605353585L);
    SimpleLongDecrypter.getCachedDecrypter(-6047287966175679614L).setKey(229116005659763091L);
    SimpleLongDecrypter.getCachedDecrypter(-929765406743488385L).setKey(-5898995886990956202L);
    SimpleLongDecrypter.getCachedDecrypter(-2099876938048143623L).setKey(8873769369975868901L);
    SimpleLongDecrypter.getCachedDecrypter(6336372491099001934L).setKey(-1538747475020882039L);
    SimpleLongDecrypter.getCachedDecrypter(-929826958199413159L).setKey(-6894600597296757322L);
    SimpleLongDecrypter.getCachedDecrypter(5560217998646627473L).setKey(-2825873802757856732L);
    SimpleLongDecrypter.getCachedDecrypter(-1271690465984234201L).setKey(-5222115264722215837L);
    SimpleLongDecrypter.getCachedDecrypter(3858315677835841465L).setKey(8169159314888418853L);
    SimpleLongDecrypter.getCachedDecrypter(2009522020796409484L).setKey(-5384701992489290630L);
    SimpleLongDecrypter.getCachedDecrypter(7821848370853183936L).setKey(8401864730529492816L);
    SimpleLongDecrypter.getCachedDecrypter(-9162905054229068528L).setKey(924744612203458146L);
    SimpleLongDecrypter.getCachedDecrypter(-7606696020395649039L).setKey(-6904039418593831163L);
    SimpleLongDecrypter.getCachedDecrypter(-3317647089676892251L).setKey(-5096982069728753160L);
    SimpleLongDecrypter.getCachedDecrypter(8072213628999174296L).setKey(-3293631797371010716L);
    SimpleLongDecrypter.getCachedDecrypter(-2132619735810711404L).setKey(-5715296733354307854L);
    SimpleLongDecrypter.getCachedDecrypter(-1118598514820346968L).setKey(4509617847104569882L);
    SimpleLongDecrypter.getCachedDecrypter(8282282808826297394L).setKey(-2804699515937725229L);
    SimpleLongDecrypter.getCachedDecrypter(6744848812260339471L).setKey(7788858074854832511L);
    SimpleLongDecrypter.getCachedDecrypter(2687226290281500426L).setKey(7235752837390850044L);
    SimpleLongDecrypter.getCachedDecrypter(-2807937675251300193L).setKey(2905715224933726507L);
    SimpleLongDecrypter.getCachedDecrypter(-2100823043566479215L).setKey(-6754634102445857179L);
    SimpleLongDecrypter.getCachedDecrypter(9139029527235986091L).setKey(5254342796466830170L);
    SimpleLongDecrypter.getCachedDecrypter(-3191208785450964970L).setKey(-7214196011960152244L);
    SimpleLongDecrypter.getCachedDecrypter(7522667832135433334L).setKey(124623864760169744L);
    SimpleLongDecrypter.getCachedDecrypter(8940557864985989798L).setKey(-9216825375027223599L);
    SimpleLongDecrypter.getCachedDecrypter(157247244631627075L).setKey(2805159863108156233L);
    SimpleLongDecrypter.getCachedDecrypter(1063214025768646268L).setKey(-4065649744211407514L);
    SimpleLongDecrypter.getCachedDecrypter(8333855641932557059L).setKey(8695728912850102484L);
    SimpleLongDecrypter.getCachedDecrypter(-5342133634179606282L).setKey(7052350244056337763L);
    SimpleLongDecrypter.getCachedDecrypter(-8712863329992225833L).setKey(-2703330593637491058L);
    SimpleLongDecrypter.getCachedDecrypter(-8133732589857883362L).setKey(-5219948496588880161L);
    SimpleLongDecrypter.getCachedDecrypter(8715854668022991580L).setKey(-1751022756191224299L);
    SimpleLongDecrypter.getCachedDecrypter(1240508094931232641L).setKey(-1420985706121828848L);
    SimpleLongDecrypter.getCachedDecrypter(8144801570678487371L).setKey(-6000941888117735253L);
    SimpleLongDecrypter.getCachedDecrypter(-8150052973971170620L).setKey(1788214549325612818L);
    SimpleLongDecrypter.getCachedDecrypter(7971920234215362453L).setKey(2537916489614379483L);
    SimpleLongDecrypter.getCachedDecrypter(7276738536916642521L).setKey(-6032352151046461789L);
    SimpleLongDecrypter.getCachedDecrypter(9122993591801521523L).setKey(-8643790418762541507L);
    SimpleLongDecrypter.getCachedDecrypter(-2268540829198127870L).setKey(-3043746319131673564L);
    SimpleLongDecrypter.getCachedDecrypter(3519853106117627730L).setKey(8688708840889573627L);
    SimpleLongDecrypter.getCachedDecrypter(-3897640154732940623L).setKey(-6558798375092523038L);
    SimpleLongDecrypter.getCachedDecrypter(-1402751009133107743L).setKey(-5514190698821215035L);
    SimpleLongDecrypter.getCachedDecrypter(-4255519287356249844L).setKey(-7389839337239616628L);
    SimpleLongDecrypter.getCachedDecrypter(1330333924118524521L).setKey(-5035997142681650601L);
    SimpleLongDecrypter.getCachedDecrypter(-3156016966467047090L).setKey(682957285431293316L);
    SimpleLongDecrypter.getCachedDecrypter(2474167843637955245L).setKey(39293981188937376L);
    SimpleLongDecrypter.getCachedDecrypter(-3779636218402913222L).setKey(-322414630290340633L);
    SimpleLongDecrypter.getCachedDecrypter(2613551839235348078L).setKey(5006358622055487718L);
    SimpleLongDecrypter.getCachedDecrypter(7924352279662035718L).setKey(6154938867000317484L);
    SimpleLongDecrypter.getCachedDecrypter(9093817325508005580L).setKey(-3089989283904034303L);
    SimpleLongDecrypter.getCachedDecrypter(7883180343635824542L).setKey(-6929547809608789008L);
    SimpleLongDecrypter.getCachedDecrypter(6902790515623202510L).setKey(-5004020300017086994L);
    SimpleLongDecrypter.getCachedDecrypter(2319573589788829691L).setKey(-5814396945964894910L);
    SimpleLongDecrypter.getCachedDecrypter(-4670581985096259637L).setKey(-6900825507966998989L);
    SimpleLongDecrypter.getCachedDecrypter(-7784452391255854542L).setKey(4246129867032878660L);
    SimpleLongDecrypter.getCachedDecrypter(-5333827065742655448L).setKey(3470834829249034106L);
    SimpleLongDecrypter.getCachedDecrypter(1610050673748753535L).setKey(-5159972703114938323L);
    SimpleLongDecrypter.getCachedDecrypter(-7529963838724795772L).setKey(5160520523889457789L);
    SimpleLongDecrypter.getCachedDecrypter(-7533885818055878419L).setKey(-6619992740101513161L);
    SimpleLongDecrypter.getCachedDecrypter(-5237798374525000199L).setKey(-869082348668489391L);
    SimpleLongDecrypter.getCachedDecrypter(606393409736769L).setKey(505578109534196904L);
    SimpleLongDecrypter.getCachedDecrypter(-7501676734778299610L).setKey(-7468523818706552634L);
    SimpleLongDecrypter.getCachedDecrypter(-8861209658205749210L).setKey(3124221849319211763L);
    SimpleLongDecrypter.getCachedDecrypter(3645263569869729951L).setKey(1592642735177339595L);
    SimpleLongDecrypter.getCachedDecrypter(-5591321789547825081L).setKey(1463701857804214331L);
    SimpleLongDecrypter.getCachedDecrypter(1221806658749589561L).setKey(-3508558860394776234L);
    SimpleLongDecrypter.getCachedDecrypter(1646659966350445288L).setKey(-1029846845644684086L);
    SimpleLongDecrypter.getCachedDecrypter(5967466342335354472L).setKey(-6393698481840342475L);
    SimpleLongDecrypter.getCachedDecrypter(-1771003948323205901L).setKey(8258193045024287586L);
    SimpleLongDecrypter.getCachedDecrypter(4073395144908635004L).setKey(4178740534025917467L);
    SimpleLongDecrypter.getCachedDecrypter(-3698241134135530099L).setKey(-199374678015215429L);
    SimpleLongDecrypter.getCachedDecrypter(-2064452562449779734L).setKey(3516455532117562217L);
    SimpleLongDecrypter.getCachedDecrypter(7921771447412444734L).setKey(-7993551897767015317L);
    SimpleLongDecrypter.getCachedDecrypter(3387256442297706662L).setKey(4612287829703127980L);
    SimpleLongDecrypter.getCachedDecrypter(-8217197482488450351L).setKey(1928930985400961824L);
    SimpleLongDecrypter.getCachedDecrypter(-5401521411627609307L).setKey(-6982070123953930953L);
    SimpleLongDecrypter.getCachedDecrypter(-6427927862512047760L).setKey(3179481229097032452L);
    SimpleLongDecrypter.getCachedDecrypter(-293360658507858685L).setKey(-3863867143432355689L);
    SimpleLongDecrypter.getCachedDecrypter(-9116591398507077556L).setKey(639399768352921752L);
    SimpleLongDecrypter.getCachedDecrypter(294507281225237439L).setKey(8756790087634177010L);
    SimpleLongDecrypter.getCachedDecrypter(1423827850916953634L).setKey(2823902827873060010L);
    SimpleLongDecrypter.getCachedDecrypter(-4126778708422487837L).setKey(-7908437475799253434L);
    SimpleLongDecrypter.getCachedDecrypter(-7078102108315381708L).setKey(-8545817390670959081L);
    SimpleLongDecrypter.getCachedDecrypter(8810771851679632908L).setKey(-8028839451604475770L);
    SimpleLongDecrypter.getCachedDecrypter(-55794642380743449L).setKey(-8276806736412601609L);
    SimpleLongDecrypter.getCachedDecrypter(288529206462702042L).setKey(-2576113904518592443L);
    SimpleLongDecrypter.getCachedDecrypter(8832203191425936772L).setKey(8963695742815285250L);
    SimpleLongDecrypter.getCachedDecrypter(-8210708616051419517L).setKey(4793564011928694178L);
    SimpleLongDecrypter.getCachedDecrypter(4139144116572089251L).setKey(-8301732837146898181L);
    SimpleLongDecrypter.getCachedDecrypter(4094631468043626968L).setKey(1746159160168006573L);
    SimpleLongDecrypter.getCachedDecrypter(4450014453728482651L).setKey(5744227775844169755L);
    SimpleLongDecrypter.getCachedDecrypter(5382979701730129513L).setKey(3154577986898324143L);
    SimpleLongDecrypter.getCachedDecrypter(-1908316752695168240L).setKey(80490157975627610L);
    SimpleLongDecrypter.getCachedDecrypter(-8392952758979538081L).setKey(-3968668349779868231L);
    SimpleLongDecrypter.getCachedDecrypter(902327503021203672L).setKey(541489388367812948L);
    SimpleLongDecrypter.getCachedDecrypter(4650971867416353761L).setKey(3602753650198432042L);
    SimpleLongDecrypter.getCachedDecrypter(-3874167926788085206L).setKey(-1673222678755932202L);
    SimpleLongDecrypter.getCachedDecrypter(-4903135116036896397L).setKey(-2397734136251816361L);
    SimpleLongDecrypter.getCachedDecrypter(-7542415568554547154L).setKey(4525001232325151042L);
    SimpleLongDecrypter.getCachedDecrypter(-4906663118633953263L).setKey(5699363593316028538L);
    SimpleLongDecrypter.getCachedDecrypter(1745448414383010517L).setKey(3307745863865706191L);
    SimpleLongDecrypter.getCachedDecrypter(6463706038254629088L).setKey(448848445141316732L);
    SimpleLongDecrypter.getCachedDecrypter(7759231360464311253L).setKey(-1211244702830277765L);
    SimpleLongDecrypter.getCachedDecrypter(364235549191944876L).setKey(3231883480623483564L);
    SimpleLongDecrypter.getCachedDecrypter(-2049765071652341818L).setKey(-472012659272429500L);
    SimpleLongDecrypter.getCachedDecrypter(8908081448832048233L).setKey(4184344337734964930L);
    SimpleLongDecrypter.getCachedDecrypter(43809548156404517L).setKey(-4642483578443907462L);
    SimpleLongDecrypter.getCachedDecrypter(1781366541865718887L).setKey(-3799320242787921240L);
    SimpleLongDecrypter.getCachedDecrypter(-1320194970236738644L).setKey(-3630784817043462712L);
    SimpleLongDecrypter.getCachedDecrypter(-7217996964552095014L).setKey(-5110640226439285856L);
    SimpleLongDecrypter.getCachedDecrypter(-8597369478755237230L).setKey(-267697544469951924L);
    SimpleLongDecrypter.getCachedDecrypter(-1357308344625492008L).setKey(-2977734015792301393L);
    SimpleLongDecrypter.getCachedDecrypter(-6067796589072285163L).setKey(-5114204513684497437L);
    SimpleLongDecrypter.getCachedDecrypter(-8618022826715264568L).setKey(4342682168644337718L);
    SimpleLongDecrypter.getCachedDecrypter(6753902620707227688L).setKey(-8544468781611839527L);
    SimpleLongDecrypter.getCachedDecrypter(-3808743731013199381L).setKey(-2997233940994775885L);
    SimpleLongDecrypter.getCachedDecrypter(5734515169326673700L).setKey(7978482640523946903L);
    SimpleLongDecrypter.getCachedDecrypter(1598838842333883040L).setKey(-1834603814679431663L);
    SimpleLongDecrypter.getCachedDecrypter(540910794019638161L).setKey(-6664047288806671355L);
    SimpleLongDecrypter.getCachedDecrypter(4955603443746621341L).setKey(3774558708223773577L);
    SimpleLongDecrypter.getCachedDecrypter(-4325231762284184514L).setKey(-141607658483614702L);
    SimpleLongDecrypter.getCachedDecrypter(-538792015113279572L).setKey(-6388440302850581492L);
    SimpleLongDecrypter.getCachedDecrypter(759464773225650365L).setKey(2806000896007796585L);
    SimpleLongDecrypter.getCachedDecrypter(-3419935207107913297L).setKey(-7651119862025399207L);
    SimpleLongDecrypter.getCachedDecrypter(2937400153834468147L).setKey(4356063510843151080L);
    SimpleLongDecrypter.getCachedDecrypter(-5587475637388524244L).setKey(6508413839932053910L);
    SimpleLongDecrypter.getCachedDecrypter(3037086783247464208L).setKey(-7217356207351716018L);
    SimpleLongDecrypter.getCachedDecrypter(-8809206604520051100L).setKey(-7428676632690995690L);
    SimpleLongDecrypter.getCachedDecrypter(-1052885245678761248L).setKey(-7500254858643611962L);
    SimpleLongDecrypter.getCachedDecrypter(309871678391475313L).setKey(2617917075308556737L);
    SimpleLongDecrypter.getCachedDecrypter(-6740857693173624524L).setKey(6244263938269297434L);
    SimpleLongDecrypter.getCachedDecrypter(4883859690064980479L).setKey(-2163835925228832703L);
    SimpleLongDecrypter.getCachedDecrypter(862973870593039791L).setKey(-4330864096924229764L);
    SimpleLongDecrypter.getCachedDecrypter(5339626927823598391L).setKey(986668422035183747L);
    SimpleLongDecrypter.getCachedDecrypter(3426907962473950958L).setKey(7888685007126463357L);
    SimpleLongDecrypter.getCachedDecrypter(-5311180518433531644L).setKey(1711965904165987236L);
    SimpleLongDecrypter.getCachedDecrypter(6387122037958407967L).setKey(9064579102269286471L);
    SimpleLongDecrypter.getCachedDecrypter(844813405649458308L).setKey(-8886463550578114072L);
    SimpleLongDecrypter.getCachedDecrypter(-283320911895044902L).setKey(1719991226447726573L);
    SimpleLongDecrypter.getCachedDecrypter(-1264434880797650968L).setKey(3974883294280818195L);
    SimpleLongDecrypter.getCachedDecrypter(133028975236948588L).setKey(5354830694950317076L);
    SimpleLongDecrypter.getCachedDecrypter(-8580081261491427462L).setKey(98032285316670964L);
    SimpleLongDecrypter.getCachedDecrypter(-5020460107966381998L).setKey(7136213677862715014L);
    SimpleLongDecrypter.getCachedDecrypter(-4938759921952708670L).setKey(8838626172823483364L);
    SimpleLongDecrypter.getCachedDecrypter(8976325845367440957L).setKey(-1765776257303574582L);
    SimpleLongDecrypter.getCachedDecrypter(6902982124506283337L).setKey(6719393308562537114L);
    SimpleLongDecrypter.getCachedDecrypter(-6391992125206361557L).setKey(4711549946554340662L);
    SimpleLongDecrypter.getCachedDecrypter(3352389660826873536L).setKey(-4431621669043676484L);
    SimpleLongDecrypter.getCachedDecrypter(5934349590132009875L).setKey(-2739552621131332644L);
    SimpleLongDecrypter.getCachedDecrypter(-2490599300836943014L).setKey(-7114594335783031264L);
    SimpleLongDecrypter.getCachedDecrypter(-3865317369981384278L).setKey(2038347863949324474L);
    SimpleLongDecrypter.getCachedDecrypter(8563498211666826399L).setKey(832203478746020441L);
    SimpleLongDecrypter.getCachedDecrypter(-2419219221989267787L).setKey(1508326552573767856L);
    SimpleLongDecrypter.getCachedDecrypter(4258863648478514284L).setKey(115647521030542927L);
    SimpleLongDecrypter.getCachedDecrypter(5605279560795375449L).setKey(-8249250124532008050L);
    SimpleLongDecrypter.getCachedDecrypter(-6271886400726074696L).setKey(3520441167412720204L);
    SimpleLongDecrypter.getCachedDecrypter(2524852401206042875L).setKey(2699677102748147885L);
    SimpleLongDecrypter.getCachedDecrypter(8749689422217271489L).setKey(-1009473764090718526L);
    SimpleLongDecrypter.getCachedDecrypter(4798937993004731314L).setKey(-8913455327705786024L);
    SimpleLongDecrypter.getCachedDecrypter(-5434509465473261992L).setKey(-1856376621542209546L);
    SimpleLongDecrypter.getCachedDecrypter(-934640261167858521L).setKey(-4626672151371498762L);
    SimpleLongDecrypter.getCachedDecrypter(4713885432059659051L).setKey(-6164830028186898555L);
    SimpleLongDecrypter.getCachedDecrypter(9135711438604276665L).setKey(-8346561735703188165L);
    SimpleLongDecrypter.getCachedDecrypter(-67035206978617958L).setKey(1430654872927378346L);
    SimpleLongDecrypter.getCachedDecrypter(7349666945689785501L).setKey(7379467498354782624L);
    SimpleLongDecrypter.getCachedDecrypter(6651602831566549283L).setKey(1863834424200288137L);
    SimpleLongDecrypter.getCachedDecrypter(2850114504609184887L).setKey(6753735155384326998L);
    SimpleLongDecrypter.getCachedDecrypter(5809164552160749911L).setKey(992989546879455821L);
    SimpleLongDecrypter.getCachedDecrypter(-769840753859834119L).setKey(-4806941274041708844L);
    SimpleLongDecrypter.getCachedDecrypter(-3060171067466035977L).setKey(4295960175075858955L);
    SimpleLongDecrypter.getCachedDecrypter(4348580667745657764L).setKey(3255836173157741369L);
    SimpleLongDecrypter.getCachedDecrypter(-791376334248074031L).setKey(-3544275198554430112L);
    SimpleLongDecrypter.getCachedDecrypter(4512056722868951188L).setKey(3512700352144273413L);
    SimpleLongDecrypter.getCachedDecrypter(6088037671248288698L).setKey(8037145334040942854L);
    SimpleLongDecrypter.getCachedDecrypter(8862321168526046178L).setKey(-5817987245208594821L);
    SimpleLongDecrypter.getCachedDecrypter(-910775311537783619L).setKey(-343395346393406934L);
    SimpleLongDecrypter.getCachedDecrypter(-7181910559943479468L).setKey(5941911745798725932L);
    SimpleLongDecrypter.getCachedDecrypter(-5880729938727250434L).setKey(-5074609423781143888L);
    SimpleLongDecrypter.getCachedDecrypter(3130363211075346695L).setKey(-389648285736896311L);
    SimpleLongDecrypter.getCachedDecrypter(-1172816033555547397L).setKey(1448125749421696853L);
    SimpleLongDecrypter.getCachedDecrypter(-9098856711288487839L).setKey(4330100688009131668L);
    SimpleLongDecrypter.getCachedDecrypter(-8219805688086716557L).setKey(7865205394072468313L);
    SimpleLongDecrypter.getCachedDecrypter(6094643673138998317L).setKey(-6375518671241863457L);
    SimpleLongDecrypter.getCachedDecrypter(-282936575719509312L).setKey(6830932346659487152L);
    SimpleLongDecrypter.getCachedDecrypter(-6904530853366419368L).setKey(21047560844529413L);
    SimpleLongDecrypter.getCachedDecrypter(2956780895681462601L).setKey(5730786638025223923L);
    SimpleLongDecrypter.getCachedDecrypter(-9014587823232993665L).setKey(-6881552381202098793L);
    SimpleLongDecrypter.getCachedDecrypter(8097304403009895644L).setKey(-6855007828518168540L);
    SimpleLongDecrypter.getCachedDecrypter(5837280635202993850L).setKey(6786197412692135324L);
    SimpleLongDecrypter.getCachedDecrypter(5154009706078004535L).setKey(-3674148127617585018L);
    SimpleLongDecrypter.getCachedDecrypter(7148494537791468005L).setKey(2180402609218998418L);
    SimpleLongDecrypter.getCachedDecrypter(-4678876556820685576L).setKey(1770289843500493117L);
    SimpleLongDecrypter.getCachedDecrypter(-8556818090886225489L).setKey(816828047363274957L);
    SimpleLongDecrypter.getCachedDecrypter(6684767113140828352L).setKey(-4934465846726257333L);
    SimpleLongDecrypter.getCachedDecrypter(5951188326308085477L).setKey(7149195779370790252L);
    SimpleLongDecrypter.getCachedDecrypter(8566911697251815519L).setKey(5547639912630165402L);
    SimpleLongDecrypter.getCachedDecrypter(-9122021164580647769L).setKey(-6963586786771391937L);
    SimpleLongDecrypter.getCachedDecrypter(-5881114867440596407L).setKey(544004994850714071L);
    SimpleLongDecrypter.getCachedDecrypter(6312352923165959616L).setKey(6778216987424958881L);
    SimpleLongDecrypter.getCachedDecrypter(2404664728834018156L).setKey(9156931120643730276L);
    SimpleLongDecrypter.getCachedDecrypter(2121517868066579812L).setKey(7018571992692176702L);
    SimpleLongDecrypter.getCachedDecrypter(6957662343393363865L).setKey(-4837243352509281377L);
    SimpleLongDecrypter.getCachedDecrypter(7814176419041663577L).setKey(-1480627188199721678L);
    SimpleLongDecrypter.getCachedDecrypter(-2219430966030596736L).setKey(-580022407626261462L);
    SimpleLongDecrypter.getCachedDecrypter(2398994520332957628L).setKey(827251461380454044L);
    SimpleLongDecrypter.getCachedDecrypter(5976313691929166593L).setKey(-6542417732491543826L);
    SimpleLongDecrypter.getCachedDecrypter(3687246192373168530L).setKey(-7164075019008515092L);
    SimpleLongDecrypter.getCachedDecrypter(-4152914073162760565L).setKey(7131571310287021247L);
    SimpleLongDecrypter.getCachedDecrypter(-7995157028941602172L).setKey(3344106750252170525L);
    SimpleLongDecrypter.getCachedDecrypter(491601438706218642L).setKey(3875237187869205351L);
    SimpleLongDecrypter.getCachedDecrypter(-3333686790695614850L).setKey(-3277518571890042799L);
    SimpleLongDecrypter.getCachedDecrypter(4422012386165546951L).setKey(-4913557442781272547L);
    SimpleLongDecrypter.getCachedDecrypter(5956589460587076984L).setKey(1025473908427791274L);
    SimpleLongDecrypter.getCachedDecrypter(891260726512913069L).setKey(5718377678261071824L);
    SimpleLongDecrypter.getCachedDecrypter(-2001459333578242601L).setKey(-7815956587293471376L);
    SimpleLongDecrypter.getCachedDecrypter(4705406497617487456L).setKey(8864700104682761987L);
    SimpleLongDecrypter.getCachedDecrypter(-501444999015994561L).setKey(-1424513387912155069L);
    SimpleLongDecrypter.getCachedDecrypter(8050839368480795084L).setKey(-5545581302488060422L);
    SimpleLongDecrypter.getCachedDecrypter(4175493085894172087L).setKey(-4548213819164511242L);
    SimpleLongDecrypter.getCachedDecrypter(1402706220106707178L).setKey(4854152339492951989L);
    SimpleLongDecrypter.getCachedDecrypter(643851899556155899L).setKey(4353858805986728119L);
    SimpleLongDecrypter.getCachedDecrypter(930669849477838468L).setKey(7145601802951184029L);
    SimpleLongDecrypter.getCachedDecrypter(-7146127485752021367L).setKey(7044564927001292446L);
    SimpleLongDecrypter.getCachedDecrypter(-4676612654574824581L).setKey(2615163793692267302L);
    SimpleLongDecrypter.getCachedDecrypter(-5274958937854147628L).setKey(-5503830377620117265L);
    SimpleLongDecrypter.getCachedDecrypter(-2388838235809591337L).setKey(8083929249767153637L);
    SimpleLongDecrypter.getCachedDecrypter(2664218538285118486L).setKey(-4805822886752440267L);
    SimpleLongDecrypter.getCachedDecrypter(3629194053976295328L).setKey(-413980845934818214L);
    SimpleLongDecrypter.getCachedDecrypter(-4338534444795628312L).setKey(4348262170333362245L);
    SimpleLongDecrypter.getCachedDecrypter(-2772157567561306362L).setKey(1894262266830265545L);
    SimpleLongDecrypter.getCachedDecrypter(-2942068645557674439L).setKey(-150661161550048906L);
    SimpleLongDecrypter.getCachedDecrypter(4624283345539399637L).setKey(-4940398043791286839L);
    SimpleLongDecrypter.getCachedDecrypter(2246287275923875104L).setKey(8598055807579568112L);
    SimpleLongDecrypter.getCachedDecrypter(903867180974421630L).setKey(7797353828341442493L);
    SimpleLongDecrypter.getCachedDecrypter(-8015384363368747498L).setKey(6945407675553590950L);
    SimpleLongDecrypter.getCachedDecrypter(-1625989088698370552L).setKey(5628262993782960255L);
    SimpleLongDecrypter.getCachedDecrypter(8891311302007128071L).setKey(-9050537958242044703L);
    SimpleLongDecrypter.getCachedDecrypter(6775539649882491691L).setKey(-5764432961484024293L);
    SimpleLongDecrypter.getCachedDecrypter(1352193570690361330L).setKey(-7590933945267580880L);
    SimpleLongDecrypter.getCachedDecrypter(2345463557891197605L).setKey(4447430963469323247L);
    SimpleLongDecrypter.getCachedDecrypter(-9069652156379357150L).setKey(7639680417057728556L);
    SimpleLongDecrypter.getCachedDecrypter(-5708398972059792414L).setKey(-8859510332864342271L);
    SimpleLongDecrypter.getCachedDecrypter(7571040440452288187L).setKey(-7087586181182731716L);
    SimpleLongDecrypter.getCachedDecrypter(-7305416110844601097L).setKey(2577480317527510167L);
    SimpleLongDecrypter.getCachedDecrypter(-378023458620248605L).setKey(922282017464848516L);
    SimpleLongDecrypter.getCachedDecrypter(4680774539808764200L).setKey(1096854189666281645L);
    SimpleLongDecrypter.getCachedDecrypter(-7660975159807947644L).setKey(-8385550395755313800L);
    SimpleLongDecrypter.getCachedDecrypter(5336013110431850456L).setKey(8765615049448257257L);
    SimpleLongDecrypter.getCachedDecrypter(7763546371815309491L).setKey(6435807052483608014L);
    SimpleLongDecrypter.getCachedDecrypter(896023792638087005L).setKey(-6347657031532049631L);
    SimpleLongDecrypter.getCachedDecrypter(-8036652892478285093L).setKey(-5506669334272813454L);
    SimpleLongDecrypter.getCachedDecrypter(-2237303544096370490L).setKey(2132470087871025539L);
    SimpleLongDecrypter.getCachedDecrypter(-6827420007518630828L).setKey(-975433886623141575L);
    SimpleLongDecrypter.getCachedDecrypter(-4552077274966164290L).setKey(8434280111720096799L);
    SimpleLongDecrypter.getCachedDecrypter(-8641099509195641086L).setKey(-4621904329833665023L);
    SimpleLongDecrypter.getCachedDecrypter(-7851566888382361952L).setKey(-763409257936342593L);
    SimpleLongDecrypter.getCachedDecrypter(-730569396482508763L).setKey(-4492122526688375103L);
    SimpleLongDecrypter.getCachedDecrypter(2405330025398845677L).setKey(2616032772154789979L);
    SimpleLongDecrypter.getCachedDecrypter(1448794457425911914L).setKey(-5645027995818675964L);
    SimpleLongDecrypter.getCachedDecrypter(-6379861610990764550L).setKey(-964295607853426938L);
    SimpleLongDecrypter.getCachedDecrypter(-4137707281809752681L).setKey(-2205604848825726941L);
    SimpleLongDecrypter.getCachedDecrypter(-1300266886960319186L).setKey(5721471920365470161L);
    SimpleLongDecrypter.getCachedDecrypter(5033910897191388577L).setKey(-5166730403869464736L);
    SimpleLongDecrypter.getCachedDecrypter(6111449495208522016L).setKey(965033930409783797L);
    SimpleLongDecrypter.getCachedDecrypter(-5999953860601114342L).setKey(-1806769929713484939L);
    SimpleLongDecrypter.getCachedDecrypter(-2412157528476050771L).setKey(5507492511569539436L);
    SimpleLongDecrypter.getCachedDecrypter(6185607658836735601L).setKey(3108746505017920696L);
    SimpleLongDecrypter.getCachedDecrypter(4766289894804749756L).setKey(-47920227637495741L);
    SimpleLongDecrypter.getCachedDecrypter(7584603450947307746L).setKey(-499453735057360819L);
    SimpleLongDecrypter.getCachedDecrypter(-7122257526532969866L).setKey(-2689966326499909487L);
    SimpleLongDecrypter.getCachedDecrypter(2515537778683552044L).setKey(5976591340448892216L);
    SimpleLongDecrypter.getCachedDecrypter(2353727905162011051L).setKey(-6740694979374399771L);
    SimpleLongDecrypter.getCachedDecrypter(-2631913965872103142L).setKey(3876489088184427667L);
    SimpleLongDecrypter.getCachedDecrypter(-1814206818475842269L).setKey(3952140031731298147L);
    SimpleLongDecrypter.getCachedDecrypter(2107817823539001197L).setKey(-4699533254061778047L);
    SimpleLongDecrypter.getCachedDecrypter(3119452672653796894L).setKey(-2336709522875219522L);
    SimpleLongDecrypter.getCachedDecrypter(5308707814759603155L).setKey(8650704900376008488L);
    SimpleLongDecrypter.getCachedDecrypter(2755578120010336604L).setKey(-5599650805540706105L);
    SimpleLongDecrypter.getCachedDecrypter(997471349203579075L).setKey(6020636863960873413L);
    SimpleLongDecrypter.getCachedDecrypter(5608399832312421221L).setKey(-5829616728632838662L);
    SimpleLongDecrypter.getCachedDecrypter(281008728445914947L).setKey(-3666912004735716134L);
    SimpleLongDecrypter.getCachedDecrypter(3741813788632310969L).setKey(6974883652563611140L);
    SimpleLongDecrypter.getCachedDecrypter(3807114972471083822L).setKey(2550405902859388595L);
    SimpleLongDecrypter.getCachedDecrypter(-1032666542233428319L).setKey(4265784763814842190L);
    SimpleLongDecrypter.getCachedDecrypter(-1408562034254832454L).setKey(-7598922603911193709L);
    SimpleLongDecrypter.getCachedDecrypter(4296979728457418541L).setKey(80108833732533863L);
    SimpleLongDecrypter.getCachedDecrypter(8819011162557837062L).setKey(8051002818026338522L);
    SimpleLongDecrypter.getCachedDecrypter(5891916869008650820L).setKey(5813822977884202330L);
    SimpleLongDecrypter.getCachedDecrypter(-8705256926536339063L).setKey(4198032795880094414L);
    SimpleLongDecrypter.getCachedDecrypter(8905296941067805389L).setKey(-3184393157463815467L);
    SimpleLongDecrypter.getCachedDecrypter(8695827222366877811L).setKey(-5769284836606938201L);
    SimpleLongDecrypter.getCachedDecrypter(-2032727011601781453L).setKey(-1309528398766854776L);
    SimpleLongDecrypter.getCachedDecrypter(6260257088522702944L).setKey(-4785899956557196579L);
    SimpleLongDecrypter.getCachedDecrypter(-1225386556953875196L).setKey(2184902331510845749L);
    SimpleLongDecrypter.getCachedDecrypter(-230057259810112451L).setKey(3061345739211365038L);
    SimpleLongDecrypter.getCachedDecrypter(-347515885558938266L).setKey(287486677512468472L);
    SimpleLongDecrypter.getCachedDecrypter(-5052765552939976123L).setKey(-6818772514654675467L);
    SimpleLongDecrypter.getCachedDecrypter(-6305377142938099016L).setKey(-2425847871913137149L);
    SimpleLongDecrypter.getCachedDecrypter(-6076120867025073142L).setKey(-3054129230845095505L);
    SimpleLongDecrypter.getCachedDecrypter(-718537287416822422L).setKey(-7695375579992436077L);
    SimpleLongDecrypter.getCachedDecrypter(-4910533213913136333L).setKey(-1880976847801138930L);
    SimpleLongDecrypter.getCachedDecrypter(-685904189583729236L).setKey(4404800672137999811L);
    SimpleLongDecrypter.getCachedDecrypter(5829217361647972373L).setKey(8157288924875590061L);
    SimpleLongDecrypter.getCachedDecrypter(7258607073421805651L).setKey(-783137905939236200L);
    SimpleLongDecrypter.getCachedDecrypter(2844313584151821573L).setKey(-3478851231310295574L);
    SimpleLongDecrypter.getCachedDecrypter(4940892636610903681L).setKey(-4839761963128566155L);
    SimpleLongDecrypter.getCachedDecrypter(-7886287652582179190L).setKey(-6629994973894450365L);
    SimpleLongDecrypter.getCachedDecrypter(-8797582416289294738L).setKey(-1974714536982424759L);
    SimpleLongDecrypter.getCachedDecrypter(9215993389690188835L).setKey(1826380564089731349L);
    SimpleLongDecrypter.getCachedDecrypter(8268926973297654471L).setKey(-1030371023468390414L);
    SimpleLongDecrypter.getCachedDecrypter(3415707310243745834L).setKey(2620249153700654200L);
    SimpleLongDecrypter.getCachedDecrypter(-5683576916409922460L).setKey(4469434171487894429L);
    SimpleLongDecrypter.getCachedDecrypter(7861744999556844312L).setKey(-9208257512213705L);
    SimpleLongDecrypter.getCachedDecrypter(-4013986384641439662L).setKey(2953214773011554640L);
    SimpleLongDecrypter.getCachedDecrypter(-3586610354225245321L).setKey(-2225163357887164132L);
    SimpleLongDecrypter.getCachedDecrypter(-8662600031285239008L).setKey(1312854403453549284L);
    SimpleLongDecrypter.getCachedDecrypter(-4630039151186882224L).setKey(-4570924647354877284L);
    SimpleLongDecrypter.getCachedDecrypter(-5472518267725183876L).setKey(-1124189193793300960L);
    SimpleLongDecrypter.getCachedDecrypter(-7271728144883895543L).setKey(-1129044914612434960L);
    SimpleLongDecrypter.getCachedDecrypter(-7076731209583152483L).setKey(-4866247374677741190L);
    SimpleLongDecrypter.getCachedDecrypter(-3976091818337261079L).setKey(-6516938832495763509L);
    SimpleLongDecrypter.getCachedDecrypter(-5283107585868709161L).setKey(-2280070406269710254L);
    SimpleLongDecrypter.getCachedDecrypter(-1269880912503947929L).setKey(3344176970258954183L);
    SimpleLongDecrypter.getCachedDecrypter(4492602613297031580L).setKey(-9044140268156402394L);
    SimpleLongDecrypter.getCachedDecrypter(-3596628289837164461L).setKey(-4863291749868748738L);
    SimpleLongDecrypter.getCachedDecrypter(-908846270013315825L).setKey(-8207620211696362121L);
    SimpleLongDecrypter.getCachedDecrypter(-6332070144054978921L).setKey(-270062485689622029L);
    SimpleLongDecrypter.getCachedDecrypter(433920241321254465L).setKey(8182119176967205496L);
    SimpleLongDecrypter.getCachedDecrypter(-1137352042545981996L).setKey(-5284720172479976575L);
    SimpleLongDecrypter.getCachedDecrypter(578623419453259596L).setKey(-2265788966376935948L);
    SimpleLongDecrypter.getCachedDecrypter(-8539422970503288679L).setKey(-4927310620627675452L);
    SimpleLongDecrypter.getCachedDecrypter(-8076555829328392145L).setKey(-1226407345918797607L);
    SimpleLongDecrypter.getCachedDecrypter(-3845142371141045124L).setKey(-7409973274495938474L);
    SimpleLongDecrypter.getCachedDecrypter(-4609404247335391935L).setKey(8219900804071642616L);
    SimpleLongDecrypter.getCachedDecrypter(-2635811570132226181L).setKey(2602017401361256539L);
    SimpleLongDecrypter.getCachedDecrypter(5868137159599459108L).setKey(3386829292368610803L);
    SimpleLongDecrypter.getCachedDecrypter(-6097882243598930294L).setKey(-266701966871432066L);
    SimpleLongDecrypter.getCachedDecrypter(1457113226221545676L).setKey(-4473399401957219425L);
    SimpleLongDecrypter.getCachedDecrypter(-2226090317452295654L).setKey(-4814148907175785043L);
    SimpleLongDecrypter.getCachedDecrypter(2061524061065799941L).setKey(6252661349220709709L);
    SimpleLongDecrypter.getCachedDecrypter(-3777070770427996013L).setKey(6260217903298267449L);
    SimpleLongDecrypter.getCachedDecrypter(-3083140932856660116L).setKey(2274786107078597384L);
    SimpleLongDecrypter.getCachedDecrypter(-7781746102113926676L).setKey(-8576036948113113611L);
    SimpleLongDecrypter.getCachedDecrypter(194204710527421124L).setKey(1310515527228495341L);
    SimpleLongDecrypter.getCachedDecrypter(6173837781650496647L).setKey(-1720414629250729325L);
    SimpleLongDecrypter.getCachedDecrypter(-7284787193292731001L).setKey(7867469392832470639L);
    SimpleLongDecrypter.getCachedDecrypter(-607024276877568327L).setKey(5663631593466143967L);
    SimpleLongDecrypter.getCachedDecrypter(161922536029005060L).setKey(6320227739778164569L);
    SimpleLongDecrypter.getCachedDecrypter(186564734450198815L).setKey(-3864447756122245635L);
    SimpleLongDecrypter.getCachedDecrypter(1077962770773113132L).setKey(-4926662641630284121L);
    SimpleLongDecrypter.getCachedDecrypter(-4029696182017788976L).setKey(-3319564848746594900L);
    SimpleLongDecrypter.getCachedDecrypter(-1967453165764311274L).setKey(5021892544636294882L);
    SimpleLongDecrypter.getCachedDecrypter(1963816454044765500L).setKey(-360889287272561836L);
    SimpleLongDecrypter.getCachedDecrypter(-7332711196549788079L).setKey(-3887605504906376400L);
    SimpleLongDecrypter.getCachedDecrypter(-4780634992695739225L).setKey(-1812272834269411328L);
    SimpleLongDecrypter.getCachedDecrypter(-5951970011870783482L).setKey(-1469962208625385884L);
    SimpleLongDecrypter.getCachedDecrypter(-4214782198233646759L).setKey(6817800858635072802L);
    SimpleLongDecrypter.getCachedDecrypter(5223694580192228645L).setKey(-1150607044823804383L);
    SimpleLongDecrypter.getCachedDecrypter(2062427773613326055L).setKey(4556612720102421850L);
    SimpleLongDecrypter.getCachedDecrypter(1213125596186324192L).setKey(6764046256361948024L);
    SimpleLongDecrypter.getCachedDecrypter(-1940045494097321219L).setKey(8911329614615938988L);
    SimpleLongDecrypter.getCachedDecrypter(-2391372495178511590L).setKey(5053697444304357451L);
    SimpleLongDecrypter.getCachedDecrypter(-585428471360421721L).setKey(-6933610267654220824L);
    SimpleLongDecrypter.getCachedDecrypter(-1269914699773916463L).setKey(-2538562080736935650L);
    SimpleLongDecrypter.getCachedDecrypter(4671198192713014705L).setKey(6219486407937113805L);
    SimpleLongDecrypter.getCachedDecrypter(3069428160580116087L).setKey(3515224670580566934L);
    SimpleLongDecrypter.getCachedDecrypter(-860887575799611990L).setKey(-3536950944077651687L);
    SimpleLongDecrypter.getCachedDecrypter(7913294351857791487L).setKey(-8880136695067972797L);
    SimpleLongDecrypter.getCachedDecrypter(-7389359691604263986L).setKey(-30037485320133862L);
    SimpleLongDecrypter.getCachedDecrypter(-5626294014255541453L).setKey(6235696700339812663L);
    SimpleLongDecrypter.getCachedDecrypter(5114925484144516149L).setKey(-6358823149323204010L);
    SimpleLongDecrypter.getCachedDecrypter(-5692121909299804844L).setKey(-1896698448203491074L);
    SimpleLongDecrypter.getCachedDecrypter(2225627047281660936L).setKey(4502425516208926030L);
    SimpleLongDecrypter.getCachedDecrypter(5474231748219190710L).setKey(1286871519852327622L);
    SimpleLongDecrypter.getCachedDecrypter(3379131489968643550L).setKey(-7951136298157489299L);
    SimpleLongDecrypter.getCachedDecrypter(7085165451073933624L).setKey(6301379273026279495L);
    SimpleLongDecrypter.getCachedDecrypter(7219134313334080222L).setKey(7929725165935092268L);
    SimpleLongDecrypter.getCachedDecrypter(3508160487305556552L).setKey(-6471271013329250062L);
    SimpleLongDecrypter.getCachedDecrypter(-5547644677964569684L).setKey(-6501626311327823695L);
    SimpleLongDecrypter.getCachedDecrypter(-4635672113622722196L).setKey(-9037426920966661355L);
    SimpleLongDecrypter.getCachedDecrypter(5613192595752858543L).setKey(-617203749451550912L);
    SimpleLongDecrypter.getCachedDecrypter(3303974493293778980L).setKey(7403059436101508600L);
    SimpleLongDecrypter.getCachedDecrypter(-5660811660762702811L).setKey(-5718893313844796413L);
    SimpleLongDecrypter.getCachedDecrypter(6419617577577389976L).setKey(-3557703322571480473L);
    SimpleLongDecrypter.getCachedDecrypter(-6686063078996543395L).setKey(4342152124047613952L);
    SimpleLongDecrypter.getCachedDecrypter(-5611036935943732645L).setKey(-6609408451643222995L);
    SimpleLongDecrypter.getCachedDecrypter(949189709204768716L).setKey(-7792655992029411652L);
    SimpleLongDecrypter.getCachedDecrypter(3633532041377306703L).setKey(-7594511257737688532L);
    SimpleLongDecrypter.getCachedDecrypter(-5340490931118950745L).setKey(2671663723724803527L);
    SimpleLongDecrypter.getCachedDecrypter(1721081388572205275L).setKey(-4312931600953800040L);
    SimpleLongDecrypter.getCachedDecrypter(-3884236051853241675L).setKey(-2074352829678579105L);
    SimpleLongDecrypter.getCachedDecrypter(-5657628566183231167L).setKey(-625719579658880068L);
    SimpleLongDecrypter.getCachedDecrypter(-2487922806028493083L).setKey(-3677321164760329767L);
    SimpleLongDecrypter.getCachedDecrypter(-1965747641827456002L).setKey(4735604152053341736L);
    SimpleLongDecrypter.getCachedDecrypter(6517527998844717577L).setKey(-1054251713793218522L);
    SimpleLongDecrypter.getCachedDecrypter(2802894877553421337L).setKey(3888535321103665882L);
    SimpleLongDecrypter.getCachedDecrypter(2057428586028921412L).setKey(-4381122910182561359L);
    SimpleLongDecrypter.getCachedDecrypter(-1193603825741756557L).setKey(-363782566835389093L);
    SimpleLongDecrypter.getCachedDecrypter(6016551819798478198L).setKey(8568863846688867089L);
    SimpleLongDecrypter.getCachedDecrypter(7711381116061502078L).setKey(4471392017356747406L);
    SimpleLongDecrypter.getCachedDecrypter(5889378791192491094L).setKey(5984464768939725838L);
    SimpleLongDecrypter.getCachedDecrypter(8401738068663074154L).setKey(5766195525726473453L);
    SimpleLongDecrypter.getCachedDecrypter(4501765291689892488L).setKey(-1159529694699093853L);
    SimpleLongDecrypter.getCachedDecrypter(-7718325243664923523L).setKey(4812916429702280798L);
    SimpleLongDecrypter.getCachedDecrypter(-2040946300398928100L).setKey(-1629896540564808223L);
    SimpleLongDecrypter.getCachedDecrypter(-3346448748773669126L).setKey(-4803994436103886982L);
    SimpleLongDecrypter.getCachedDecrypter(5166813009876610842L).setKey(-2573707926518369443L);
    SimpleLongDecrypter.getCachedDecrypter(-7131190739882646197L).setKey(7369506509352994437L);
    SimpleLongDecrypter.getCachedDecrypter(-6275143252432446409L).setKey(7215797610554510334L);
    SimpleLongDecrypter.getCachedDecrypter(2967776132393628325L).setKey(4380798432958694005L);
    SimpleLongDecrypter.getCachedDecrypter(8309414877128288787L).setKey(5877831043767831897L);
    SimpleLongDecrypter.getCachedDecrypter(4246118523526653536L).setKey(-5243784101651981647L);
    SimpleLongDecrypter.getCachedDecrypter(-8967545983735833640L).setKey(-9088293421852171940L);
    SimpleLongDecrypter.getCachedDecrypter(-4533633881644565215L).setKey(-7770308024132909478L);
    SimpleLongDecrypter.getCachedDecrypter(-1397880274618364378L).setKey(6608841295585613272L);
    SimpleLongDecrypter.getCachedDecrypter(6437185844784568117L).setKey(2276068393042236981L);
    SimpleLongDecrypter.getCachedDecrypter(5609367404941869335L).setKey(2484521955842651698L);
    SimpleLongDecrypter.getCachedDecrypter(-5780661619314299982L).setKey(6643671237398299636L);
    SimpleLongDecrypter.getCachedDecrypter(8904117036968760169L).setKey(840914296265396452L);
    SimpleLongDecrypter.getCachedDecrypter(-3064456258830201458L).setKey(-2321030584762874927L);
    SimpleLongDecrypter.getCachedDecrypter(-5102359221491009480L).setKey(-353754492846476356L);
    SimpleLongDecrypter.getCachedDecrypter(-6169183676957267487L).setKey(-5505789061531298767L);
    SimpleLongDecrypter.getCachedDecrypter(-7936925965638138386L).setKey(1639635570961840665L);
    SimpleLongDecrypter.getCachedDecrypter(-1615929681435208587L).setKey(-2968788310792625178L);
    SimpleLongDecrypter.getCachedDecrypter(-8708905642253923653L).setKey(7939394802113738050L);
    SimpleLongDecrypter.getCachedDecrypter(4554184200509951517L).setKey(4721291965869897994L);
    SimpleLongDecrypter.getCachedDecrypter(-5683520390413426366L).setKey(7947640529673854349L);
    SimpleLongDecrypter.getCachedDecrypter(-5593884381516186039L).setKey(-9136723649160894573L);
    SimpleLongDecrypter.getCachedDecrypter(-2255988379456869212L).setKey(5525579963988578438L);
    SimpleLongDecrypter.getCachedDecrypter(-5555013588188685324L).setKey(4298528855630781102L);
    SimpleLongDecrypter.getCachedDecrypter(3903701478119138748L).setKey(7522427139109985362L);
    SimpleLongDecrypter.getCachedDecrypter(-3264922339265983758L).setKey(-1258767203757307836L);
    SimpleLongDecrypter.getCachedDecrypter(6729595208190815879L).setKey(-5966459293125080441L);
    SimpleLongDecrypter.getCachedDecrypter(8371109807555253893L).setKey(-6769967094279619122L);
    SimpleLongDecrypter.getCachedDecrypter(-8579633775657026411L).setKey(801363964817926739L);
    SimpleLongDecrypter.getCachedDecrypter(-512115788548991283L).setKey(-1788898582611672654L);
    SimpleLongDecrypter.getCachedDecrypter(7450979011007011077L).setKey(6584535602800686684L);
    SimpleLongDecrypter.getCachedDecrypter(-766010040747712659L).setKey(-7718491359111173939L);
    SimpleLongDecrypter.getCachedDecrypter(4023081085708508183L).setKey(-8332828992202330792L);
    SimpleLongDecrypter.getCachedDecrypter(2995415640129950629L).setKey(6090555137963924584L);
    SimpleLongDecrypter.getCachedDecrypter(-9001404322685750796L).setKey(1918719100825133177L);
    SimpleLongDecrypter.getCachedDecrypter(-7528493265282411561L).setKey(3053067916487979065L);
    SimpleLongDecrypter.getCachedDecrypter(332134035235417872L).setKey(1358333438218534118L);
    SimpleLongDecrypter.getCachedDecrypter(7372275824110013954L).setKey(-8519694273707332301L);
    SimpleLongDecrypter.getCachedDecrypter(3639000469692727174L).setKey(5787276395341327591L);
    SimpleLongDecrypter.getCachedDecrypter(7100957166950668116L).setKey(1849233497105620867L);
    SimpleLongDecrypter.getCachedDecrypter(2224707637035431354L).setKey(-1657296404198274387L);
    SimpleLongDecrypter.getCachedDecrypter(5321913929972856599L).setKey(-330003032022513497L);
    SimpleLongDecrypter.getCachedDecrypter(6332167732351623904L).setKey(-7535097510769313108L);
    SimpleLongDecrypter.getCachedDecrypter(-8456358026880929920L).setKey(449110261434879161L);
    SimpleLongDecrypter.getCachedDecrypter(4625919925374718706L).setKey(870231537189306478L);
    SimpleLongDecrypter.getCachedDecrypter(6039351737531591474L).setKey(2780987515814172718L);
    SimpleLongDecrypter.getCachedDecrypter(-1141302648810960122L).setKey(-8986048534892058381L);
    SimpleLongDecrypter.getCachedDecrypter(115776929845132442L).setKey(3925413541495250392L);
    SimpleLongDecrypter.getCachedDecrypter(-8012968404627254794L).setKey(3883405774483324150L);
    SimpleLongDecrypter.getCachedDecrypter(7922365337955490159L).setKey(2253835675506686675L);
    SimpleLongDecrypter.getCachedDecrypter(-9098936529823846238L).setKey(4118068233256573431L);
    SimpleLongDecrypter.getCachedDecrypter(3861837551237127201L).setKey(3697170707232720797L);
    SimpleLongDecrypter.getCachedDecrypter(-7383725929016762586L).setKey(-6664119565501672295L);
    SimpleLongDecrypter.getCachedDecrypter(3797410525195312712L).setKey(3082593396056762146L);
    SimpleLongDecrypter.getCachedDecrypter(-5004786245805872869L).setKey(-1519219497300168705L);
    SimpleLongDecrypter.getCachedDecrypter(-487069256458300398L).setKey(8189751719598485768L);
    SimpleLongDecrypter.getCachedDecrypter(-3045592880861167672L).setKey(3867477207358463979L);
    SimpleLongDecrypter.getCachedDecrypter(-7731883549901899587L).setKey(-4904958622392651498L);
    SimpleLongDecrypter.getCachedDecrypter(-6856740598526240375L).setKey(-531461290795475867L);
    SimpleLongDecrypter.getCachedDecrypter(2975749227795274167L).setKey(-901323884047770009L);
    SimpleLongDecrypter.getCachedDecrypter(2804461249725417170L).setKey(-831075716097867351L);
    SimpleLongDecrypter.getCachedDecrypter(2634761252652773197L).setKey(-5566906033433243581L);
    SimpleLongDecrypter.getCachedDecrypter(1340811178183234409L).setKey(-5956788711371547046L);
    SimpleLongDecrypter.getCachedDecrypter(4386996726110941219L).setKey(6100996670254338119L);
    SimpleLongDecrypter.getCachedDecrypter(-6370856373498777951L).setKey(-6976616072431843702L);
    SimpleLongDecrypter.getCachedDecrypter(-2441844021034509362L).setKey(5787936561682956490L);
    SimpleLongDecrypter.getCachedDecrypter(-6545004947880963693L).setKey(-3352046170677584828L);
    SimpleLongDecrypter.getCachedDecrypter(-3968232955711074133L).setKey(-4970111534614739111L);
    SimpleLongDecrypter.getCachedDecrypter(-7240525790183003676L).setKey(-3117676961719983277L);
    SimpleLongDecrypter.getCachedDecrypter(2185175504522925193L).setKey(1738086923383177179L);
    SimpleLongDecrypter.getCachedDecrypter(-7655170317501711721L).setKey(1737184312241567531L);
    SimpleLongDecrypter.getCachedDecrypter(8432766444444216265L).setKey(7878947169525731716L);
    SimpleLongDecrypter.getCachedDecrypter(-6024774183714868663L).setKey(6149776496771081188L);
    SimpleLongDecrypter.getCachedDecrypter(1370650286571039290L).setKey(-3151871481369786625L);
    SimpleLongDecrypter.getCachedDecrypter(-3825180543839084565L).setKey(2573346358117906306L);
    SimpleLongDecrypter.getCachedDecrypter(2581348212979189162L).setKey(-6378259983634064320L);
    SimpleLongDecrypter.getCachedDecrypter(7670882971342265734L).setKey(-8122879657749417211L);
    SimpleLongDecrypter.getCachedDecrypter(-280595073495814219L).setKey(-3639462054650436512L);
    SimpleLongDecrypter.getCachedDecrypter(7296025092183338215L).setKey(6129857043068909404L);
    SimpleLongDecrypter.getCachedDecrypter(-7347572876486647480L).setKey(-938598601234047613L);
    SimpleLongDecrypter.getCachedDecrypter(8493434442365369318L).setKey(-4170696398770464884L);
    SimpleLongDecrypter.getCachedDecrypter(-6229254793057104517L).setKey(351039051970900345L);
    SimpleLongDecrypter.getCachedDecrypter(1767690126961945300L).setKey(1316276844071710993L);
    SimpleLongDecrypter.getCachedDecrypter(-8545733944765967989L).setKey(685456249404915628L);
    SimpleLongDecrypter.getCachedDecrypter(-5567637832186338684L).setKey(-7063007164167857159L);
    SimpleLongDecrypter.getCachedDecrypter(9203939272986204381L).setKey(7704457220335448308L);
    SimpleLongDecrypter.getCachedDecrypter(7124797895193839163L).setKey(6830182828673249986L);
    SimpleLongDecrypter.getCachedDecrypter(9062483313310716152L).setKey(6345574500273351513L);
    SimpleLongDecrypter.getCachedDecrypter(-1651704877991621999L).setKey(-1578951519504280268L);
    SimpleLongDecrypter.getCachedDecrypter(-9103205149641257594L).setKey(8652004805383713387L);
    SimpleLongDecrypter.getCachedDecrypter(5072202032913291520L).setKey(-7124146926258467900L);
    SimpleLongDecrypter.getCachedDecrypter(-1398819436674531905L).setKey(-2326705926015504082L);
    SimpleLongDecrypter.getCachedDecrypter(-5316956170070739410L).setKey(4235282352315502892L);
    SimpleLongDecrypter.getCachedDecrypter(-9119746161180090588L).setKey(5497108685415983017L);
    SimpleLongDecrypter.getCachedDecrypter(4785407757834566221L).setKey(-9023316542319102433L);
    SimpleLongDecrypter.getCachedDecrypter(-6452657919553483417L).setKey(531437528604388136L);
    SimpleLongDecrypter.getCachedDecrypter(-4194230688762687955L).setKey(7085447097372211771L);
    SimpleLongDecrypter.getCachedDecrypter(-4330576196821530940L).setKey(-8702450502952588240L);
    SimpleLongDecrypter.getCachedDecrypter(3107329749327873690L).setKey(-4194381641748673652L);
    SimpleLongDecrypter.getCachedDecrypter(3498660463279805333L).setKey(-8694543440249619448L);
    SimpleLongDecrypter.getCachedDecrypter(-4066984513583908467L).setKey(-3820720298076593844L);
    SimpleLongDecrypter.getCachedDecrypter(4389269484530562187L).setKey(3582981575125201688L);
    SimpleLongDecrypter.getCachedDecrypter(-8355752216015849112L).setKey(-5079303750160881812L);
    SimpleLongDecrypter.getCachedDecrypter(3347486822224866367L).setKey(-3844782773683652561L);
    SimpleLongDecrypter.getCachedDecrypter(8222275322019952730L).setKey(2148390556893250956L);
    SimpleLongDecrypter.getCachedDecrypter(4980784376668102834L).setKey(2937610928904937914L);
    SimpleLongDecrypter.getCachedDecrypter(8031080380039647325L).setKey(2123234509422043267L);
    SimpleLongDecrypter.getCachedDecrypter(-4115918539197599633L).setKey(1509176025608543872L);
    SimpleLongDecrypter.getCachedDecrypter(-985996608630183314L).setKey(-1940073878172790540L);
    SimpleLongDecrypter.getCachedDecrypter(-1137179487210259552L).setKey(8368488366700458346L);
    SimpleLongDecrypter.getCachedDecrypter(-3858647898228072199L).setKey(7831431516805328111L);
    SimpleLongDecrypter.getCachedDecrypter(1514085577023323224L).setKey(7196228206433842935L);
    SimpleLongDecrypter.getCachedDecrypter(8633303668951844126L).setKey(3446774311101399095L);
    SimpleLongDecrypter.getCachedDecrypter(-5557491543361290732L).setKey(-1849388174122698750L);
    SimpleLongDecrypter.getCachedDecrypter(-6075321094135001139L).setKey(4477102111638881014L);
    SimpleLongDecrypter.getCachedDecrypter(-982160963901207048L).setKey(7478477722059986661L);
    SimpleLongDecrypter.getCachedDecrypter(5872647239657502800L).setKey(6401163615565741388L);
    SimpleLongDecrypter.getCachedDecrypter(-4106810992020069997L).setKey(-8788218863744266739L);
    SimpleLongDecrypter.getCachedDecrypter(-3316808944461186192L).setKey(-7260338286325985227L);
    SimpleLongDecrypter.getCachedDecrypter(-6947885788709957597L).setKey(1880302378801790182L);
    SimpleLongDecrypter.getCachedDecrypter(-5916305063853153411L).setKey(7279747957666938093L);
    SimpleLongDecrypter.getCachedDecrypter(-2451251335704724803L).setKey(-497754426688123801L);
    SimpleLongDecrypter.getCachedDecrypter(-119287780694506329L).setKey(5551926298358761499L);
    SimpleLongDecrypter.getCachedDecrypter(5517483904713125324L).setKey(-7055571928442381499L);
    SimpleLongDecrypter.getCachedDecrypter(367417373199396918L).setKey(7785463669739739846L);
    SimpleLongDecrypter.getCachedDecrypter(4616281316630977952L).setKey(-7226046852276811149L);
    SimpleLongDecrypter.getCachedDecrypter(-6653956692739722578L).setKey(-1414095905463042033L);
    SimpleLongDecrypter.getCachedDecrypter(7872010166358596434L).setKey(-2948415143224684935L);
    SimpleLongDecrypter.getCachedDecrypter(-4998038086310773631L).setKey(-2404880584697080480L);
    SimpleLongDecrypter.getCachedDecrypter(1526992695168814459L).setKey(-260314494841144134L);
    SimpleLongDecrypter.getCachedDecrypter(-8272560127123953496L).setKey(-7818632163276363309L);
    SimpleLongDecrypter.getCachedDecrypter(4468313965120632087L).setKey(-93105817275979431L);
    SimpleLongDecrypter.getCachedDecrypter(-6699316214475635761L).setKey(8099049226107174491L);
    SimpleLongDecrypter.getCachedDecrypter(516845560795460069L).setKey(2925528759813617917L);
    SimpleLongDecrypter.getCachedDecrypter(-3643425642262530957L).setKey(-6371417650257870842L);
    SimpleLongDecrypter.getCachedDecrypter(-3023065024282075311L).setKey(7834908941459175121L);
    SimpleLongDecrypter.getCachedDecrypter(1584800498430516087L).setKey(-706362111194947203L);
    SimpleLongDecrypter.getCachedDecrypter(-7431320364172477862L).setKey(-1881782653878896701L);
    SimpleLongDecrypter.getCachedDecrypter(-8303284752927041846L).setKey(2988337961660856799L);
    SimpleLongDecrypter.getCachedDecrypter(2340364933943548854L).setKey(-201510857184532063L);
    SimpleLongDecrypter.getCachedDecrypter(8149731375628857902L).setKey(2151887874757884176L);
    SimpleLongDecrypter.getCachedDecrypter(-3825120207350504649L).setKey(6067643852833165843L);
    SimpleLongDecrypter.getCachedDecrypter(5993123437798287076L).setKey(-1940077219545073643L);
    SimpleLongDecrypter.getCachedDecrypter(494523940956647954L).setKey(-3956393073389419488L);
    SimpleLongDecrypter.getCachedDecrypter(-884654331463467298L).setKey(-7850980247109401194L);
    SimpleLongDecrypter.getCachedDecrypter(-6050302001855293254L).setKey(8994139993019604903L);
    SimpleLongDecrypter.getCachedDecrypter(-2249681151491590613L).setKey(-1444419233932756306L);
    SimpleLongDecrypter.getCachedDecrypter(4391349005173980862L).setKey(1692291376555787565L);
    SimpleLongDecrypter.getCachedDecrypter(-2817700026242613241L).setKey(5805961727725303799L);
    SimpleLongDecrypter.getCachedDecrypter(-2123937026238841263L).setKey(8080129503000880587L);
    SimpleLongDecrypter.getCachedDecrypter(3920657702337081132L).setKey(1769268968073003134L);
    SimpleLongDecrypter.getCachedDecrypter(-7538327560061680359L).setKey(5731817498360878519L);
    SimpleLongDecrypter.getCachedDecrypter(4307405310917510336L).setKey(-778811594676511302L);
    SimpleLongDecrypter.getCachedDecrypter(-8068378758344081415L).setKey(7203497627352896681L);
    SimpleLongDecrypter.getCachedDecrypter(-4029929454345660504L).setKey(-1543265893007110112L);
    SimpleLongDecrypter.getCachedDecrypter(-9134954520320628851L).setKey(-7557581382907488812L);
    SimpleLongDecrypter.getCachedDecrypter(-3216983260259804915L).setKey(-2804611961373439360L);
    SimpleLongDecrypter.getCachedDecrypter(2019406650251225041L).setKey(4188840612406438641L);
    SimpleLongDecrypter.getCachedDecrypter(4108928347095601664L).setKey(5433120010952512242L);
    SimpleLongDecrypter.getCachedDecrypter(-4354987785027683062L).setKey(1236580111716998739L);
    SimpleLongDecrypter.getCachedDecrypter(-4957233908584132709L).setKey(5571224436660790277L);
    SimpleLongDecrypter.getCachedDecrypter(7466419149978856212L).setKey(965306965160455555L);
    SimpleLongDecrypter.getCachedDecrypter(-6768875840120669603L).setKey(5149468132399057172L);
    SimpleLongDecrypter.getCachedDecrypter(3803202920437078985L).setKey(-2197348844377076727L);
    SimpleLongDecrypter.getCachedDecrypter(-353745969942352113L).setKey(-2759950557049759583L);
    SimpleLongDecrypter.getCachedDecrypter(3721152294977697059L).setKey(8836318146291879117L);
    SimpleLongDecrypter.getCachedDecrypter(-7071025754506017450L).setKey(-5814481829242988549L);
    SimpleLongDecrypter.getCachedDecrypter(-1367496368510280499L).setKey(-7399039481454387501L);
    SimpleLongDecrypter.getCachedDecrypter(962250530077941453L).setKey(8714306351372948395L);
    SimpleLongDecrypter.getCachedDecrypter(5375962402242124840L).setKey(4182254671076189770L);
    SimpleLongDecrypter.getCachedDecrypter(-3968084796232477517L).setKey(4035174604629198762L);
    SimpleLongDecrypter.getCachedDecrypter(8973083104798979427L).setKey(6051875698689957284L);
    SimpleLongDecrypter.getCachedDecrypter(-7769301988547888066L).setKey(6120839536144180997L);
    SimpleLongDecrypter.getCachedDecrypter(-2192737844425167420L).setKey(-1159706106951810568L);
    SimpleLongDecrypter.getCachedDecrypter(108471504380677428L).setKey(202891975013411350L);
    SimpleLongDecrypter.getCachedDecrypter(-4643334714295068010L).setKey(8985128556688507552L);
    SimpleLongDecrypter.getCachedDecrypter(9070058511261574034L).setKey(-9144998362809686687L);
    SimpleLongDecrypter.getCachedDecrypter(5813480565798063365L).setKey(-2969572231919879461L);
    SimpleLongDecrypter.getCachedDecrypter(-6950312744858137565L).setKey(8964097236331070067L);
    SimpleLongDecrypter.getCachedDecrypter(-8210952132393318314L).setKey(2444750405932706988L);
    SimpleLongDecrypter.getCachedDecrypter(4636991986122711237L).setKey(1152894612679229636L);
    SimpleLongDecrypter.getCachedDecrypter(-4400292066099847235L).setKey(5306675636848367867L);
    SimpleLongDecrypter.getCachedDecrypter(6667286567916910025L).setKey(-6531665562742382234L);
    SimpleLongDecrypter.getCachedDecrypter(2252081205708219861L).setKey(87001033006397444L);
    SimpleLongDecrypter.getCachedDecrypter(-3050943510437397296L).setKey(4852837810360410849L);
    SimpleLongDecrypter.getCachedDecrypter(6741783293193904623L).setKey(-5934472440761389793L);
    SimpleLongDecrypter.getCachedDecrypter(-5637750909457609552L).setKey(-8934093441175197018L);
    SimpleLongDecrypter.getCachedDecrypter(1629657537175523109L).setKey(-6249404241121529699L);
    SimpleLongDecrypter.getCachedDecrypter(7313969139448148278L).setKey(-7321075123965083464L);
    SimpleLongDecrypter.getCachedDecrypter(5377274044009038496L).setKey(806330172225540838L);
    SimpleLongDecrypter.getCachedDecrypter(-7743336296491016275L).setKey(-8126011582802627965L);
    SimpleLongDecrypter.getCachedDecrypter(-5536253103587618805L).setKey(-700611116576616973L);
    SimpleLongDecrypter.getCachedDecrypter(904784302860625365L).setKey(-6177942536058482240L);
    SimpleLongDecrypter.getCachedDecrypter(3430362771833757077L).setKey(1836742154971768475L);
    SimpleLongDecrypter.getCachedDecrypter(-8872868584407449522L).setKey(-4398684143610237327L);
    SimpleLongDecrypter.getCachedDecrypter(302608078044574655L).setKey(523345530516086919L);
    SimpleLongDecrypter.getCachedDecrypter(5800831274736773453L).setKey(-2097646773388879620L);
    SimpleLongDecrypter.getCachedDecrypter(-1527914013808528408L).setKey(-4934312560400757557L);
    SimpleLongDecrypter.getCachedDecrypter(-1342463959584723367L).setKey(6048949309804760836L);
    SimpleLongDecrypter.getCachedDecrypter(-3280988298852226611L).setKey(-5452734359323044404L);
    SimpleLongDecrypter.getCachedDecrypter(8720039940700267019L).setKey(-562647151356778890L);
    SimpleLongDecrypter.getCachedDecrypter(7668318071225732446L).setKey(6236850484425762896L);
    SimpleLongDecrypter.getCachedDecrypter(-3167290785758321315L).setKey(8606938929385695954L);
    SimpleLongDecrypter.getCachedDecrypter(4486174180094080779L).setKey(-152598487059895647L);
    SimpleLongDecrypter.getCachedDecrypter(7280742808264518501L).setKey(-1841272343288636625L);
    SimpleLongDecrypter.getCachedDecrypter(865276794991823591L).setKey(-697500703458044074L);
    SimpleLongDecrypter.getCachedDecrypter(-4366498714719285607L).setKey(-5246014330137011594L);
    SimpleLongDecrypter.getCachedDecrypter(4865495706571431375L).setKey(-4103716022013901066L);
    SimpleLongDecrypter.getCachedDecrypter(8025595908170625094L).setKey(-2859169359841324246L);
    SimpleLongDecrypter.getCachedDecrypter(-2505383949991080908L).setKey(8131877304007088900L);
    SimpleLongDecrypter.getCachedDecrypter(-4903767256782388759L).setKey(-8345406024759639975L);
    SimpleLongDecrypter.getCachedDecrypter(-2061449307245156134L).setKey(1607701475283670181L);
    SimpleLongDecrypter.getCachedDecrypter(-6960269097467423694L).setKey(-2684583322112947938L);
    SimpleLongDecrypter.getCachedDecrypter(-4615128449727634470L).setKey(-6095683936340395915L);
    SimpleLongDecrypter.getCachedDecrypter(-8775597669882932234L).setKey(-2149408243650741971L);
    SimpleLongDecrypter.getCachedDecrypter(3554523620763964863L).setKey(-3762070470601449184L);
    SimpleLongDecrypter.getCachedDecrypter(1373709124025218330L).setKey(-8356428209304367211L);
    SimpleLongDecrypter.getCachedDecrypter(7849535997697952981L).setKey(5709026395352674152L);
    SimpleLongDecrypter.getCachedDecrypter(-6251048441907918015L).setKey(-519450909942916385L);
    SimpleLongDecrypter.getCachedDecrypter(1968866800081869236L).setKey(-1806912105753589311L);
    SimpleLongDecrypter.getCachedDecrypter(3725247981489930276L).setKey(98726891508234801L);
    SimpleLongDecrypter.getCachedDecrypter(-4365587612396649113L).setKey(5301553018633184755L);
    SimpleLongDecrypter.getCachedDecrypter(-1898703038185736945L).setKey(7610424756957080799L);
    SimpleLongDecrypter.getCachedDecrypter(9143529653539113876L).setKey(4316519219188606005L);
    SimpleLongDecrypter.getCachedDecrypter(3448791851287722885L).setKey(5970056470977332284L);
    SimpleLongDecrypter.getCachedDecrypter(1021607551049073889L).setKey(2481907017442232866L);
    SimpleLongDecrypter.getCachedDecrypter(-2851552053666509221L).setKey(597922493007043275L);
    SimpleLongDecrypter.getCachedDecrypter(5612827130936291745L).setKey(-7145183683620190774L);
    SimpleLongDecrypter.getCachedDecrypter(4604019357166594475L).setKey(2485387138973003704L);
    SimpleLongDecrypter.getCachedDecrypter(-5957034415080906416L).setKey(476033028704502670L);
    SimpleLongDecrypter.getCachedDecrypter(-1422799770439163454L).setKey(-4958431929541770649L);
    SimpleLongDecrypter.getCachedDecrypter(-5682513674880712083L).setKey(-6426653108232355586L);
    SimpleLongDecrypter.getCachedDecrypter(-484939322823461374L).setKey(-5456325193397922213L);
    SimpleLongDecrypter.getCachedDecrypter(-5746990292110234411L).setKey(3469011487747941596L);
    SimpleLongDecrypter.getCachedDecrypter(4616318844088751811L).setKey(4262883765506901295L);
    SimpleLongDecrypter.getCachedDecrypter(7271607377314521359L).setKey(3599019037312557283L);
    SimpleLongDecrypter.getCachedDecrypter(-1520318610830569041L).setKey(3868546609319185130L);
    SimpleLongDecrypter.getCachedDecrypter(-8986273072386652435L).setKey(8691800123060208095L);
    SimpleLongDecrypter.getCachedDecrypter(-9094957049424794964L).setKey(-3046989847075190784L);
    SimpleLongDecrypter.getCachedDecrypter(-3635003569144323138L).setKey(2664680535196873296L);
    SimpleLongDecrypter.getCachedDecrypter(401291005151219177L).setKey(5402816277528819678L);
    SimpleLongDecrypter.getCachedDecrypter(-1803684337010677656L).setKey(8275773893080468874L);
    SimpleLongDecrypter.getCachedDecrypter(-5083987812580881504L).setKey(-3854887464501840420L);
    SimpleLongDecrypter.getCachedDecrypter(-4839853877362326973L).setKey(-7851623861575359161L);
    SimpleLongDecrypter.getCachedDecrypter(6051409221658586076L).setKey(-8174520752982852966L);
    SimpleLongDecrypter.getCachedDecrypter(-7053192767193379417L).setKey(7228871490929218391L);
    SimpleLongDecrypter.getCachedDecrypter(7087885712825740921L).setKey(-4642146072405099263L);
    SimpleLongDecrypter.getCachedDecrypter(9198359700029533509L).setKey(-3582488946442218747L);
    SimpleLongDecrypter.getCachedDecrypter(6197066289971735430L).setKey(1963327754621922595L);
    SimpleLongDecrypter.getCachedDecrypter(8367147020078322784L).setKey(8020823304357443815L);
    SimpleLongDecrypter.getCachedDecrypter(-4059917539926316191L).setKey(5238757581269424514L);
    SimpleLongDecrypter.getCachedDecrypter(5790033356174775162L).setKey(-1049478880769038926L);
    SimpleLongDecrypter.getCachedDecrypter(-7029516013430739842L).setKey(-8197861715204381356L);
    SimpleLongDecrypter.getCachedDecrypter(-8870507779408932471L).setKey(-5015881140769148769L);
    SimpleLongDecrypter.getCachedDecrypter(3356153231291485938L).setKey(-3267244054459801993L);
    SimpleLongDecrypter.getCachedDecrypter(553510858741317190L).setKey(-3687319803537396385L);
    SimpleLongDecrypter.getCachedDecrypter(4757019121774831358L).setKey(-2770115161060071899L);
    SimpleLongDecrypter.getCachedDecrypter(7713324080395283235L).setKey(3542637095508985393L);
    SimpleLongDecrypter.getCachedDecrypter(-8085072641933472209L).setKey(7078541099080050547L);
    SimpleLongDecrypter.getCachedDecrypter(3682995351079955764L).setKey(6314626824209940583L);
    SimpleLongDecrypter.getCachedDecrypter(4088918555403439586L).setKey(1877001619987203907L);
    SimpleLongDecrypter.getCachedDecrypter(-2038303653132148006L).setKey(-8911731737818095064L);
    SimpleLongDecrypter.getCachedDecrypter(2970990859168661495L).setKey(-2206159570730005594L);
    SimpleLongDecrypter.getCachedDecrypter(-8306542014618848471L).setKey(8524537957858968788L);
    SimpleLongDecrypter.getCachedDecrypter(-7830983871925325899L).setKey(5612120122470873479L);
    SimpleLongDecrypter.getCachedDecrypter(1491393150322288743L).setKey(-4241145648422874899L);
    SimpleLongDecrypter.getCachedDecrypter(3034063718906246598L).setKey(-308760627914444278L);
    SimpleLongDecrypter.getCachedDecrypter(7119876424174366611L).setKey(8736767835390179261L);
    SimpleLongDecrypter.getCachedDecrypter(-7513896388190627559L).setKey(-8833448505901574622L);
    SimpleLongDecrypter.getCachedDecrypter(-243575494872819652L).setKey(2485997611689093065L);
    SimpleLongDecrypter.getCachedDecrypter(5328464182322888316L).setKey(-5545624413494394526L);
    SimpleLongDecrypter.getCachedDecrypter(7195595308003417022L).setKey(7604041555547444104L);
    SimpleLongDecrypter.getCachedDecrypter(2735093867943569963L).setKey(5987633069341593379L);
    SimpleLongDecrypter.getCachedDecrypter(-5522727284711942065L).setKey(-5153781108635070723L);
    SimpleLongDecrypter.getCachedDecrypter(-4811947568823328509L).setKey(-3381721700901303362L);
    SimpleLongDecrypter.getCachedDecrypter(7578450300785475903L).setKey(-1151438862269878216L);
    SimpleLongDecrypter.getCachedDecrypter(5319862677760806985L).setKey(4843111493898979064L);
    SimpleLongDecrypter.getCachedDecrypter(616390909775562686L).setKey(6875388028785383657L);
    SimpleLongDecrypter.getCachedDecrypter(6349839109125752438L).setKey(-4691534370880811309L);
    SimpleLongDecrypter.getCachedDecrypter(2789367059394943687L).setKey(-4362544815501862132L);
    SimpleLongDecrypter.getCachedDecrypter(-8410095282441183611L).setKey(6776280544681839747L);
    SimpleLongDecrypter.getCachedDecrypter(-4507464542748680082L).setKey(-4415547420811532204L);
    SimpleLongDecrypter.getCachedDecrypter(4291266484617113993L).setKey(3488995679885672584L);
    SimpleLongDecrypter.getCachedDecrypter(-986395328542316374L).setKey(2388151549749529475L);
    SimpleLongDecrypter.getCachedDecrypter(6149747944907668996L).setKey(-3030765248264331739L);
    SimpleLongDecrypter.getCachedDecrypter(-9111714066571086514L).setKey(-2365288748438029746L);
    SimpleLongDecrypter.getCachedDecrypter(559088752292037456L).setKey(1410589621783212147L);
    SimpleLongDecrypter.getCachedDecrypter(3053177927180100575L).setKey(6487593570387913520L);
    SimpleLongDecrypter.getCachedDecrypter(-5543647235929449099L).setKey(5737827019580563788L);
    SimpleLongDecrypter.getCachedDecrypter(9130762650109052560L).setKey(3818132122169066590L);
    SimpleLongDecrypter.getCachedDecrypter(5284633206502959560L).setKey(4466911888926018020L);
    SimpleLongDecrypter.getCachedDecrypter(8645278047529341764L).setKey(3640179500357223803L);
    SimpleLongDecrypter.getCachedDecrypter(2081459585562574697L).setKey(34234918505649974L);
    SimpleLongDecrypter.getCachedDecrypter(1342132493783655645L).setKey(9069052144564426L);
    SimpleLongDecrypter.getCachedDecrypter(-8501016620130471140L).setKey(-2093733922246983236L);
    SimpleLongDecrypter.getCachedDecrypter(-4153042696313686419L).setKey(8263576327630510485L);
    SimpleLongDecrypter.getCachedDecrypter(1494089664813120997L).setKey(-7132539552746358896L);
    SimpleLongDecrypter.getCachedDecrypter(5080199753026011837L).setKey(3095136691560184602L);
    SimpleLongDecrypter.getCachedDecrypter(16608723268770980L).setKey(1137810584512396499L);
    SimpleLongDecrypter.getCachedDecrypter(5153146355562193749L).setKey(5287731183817839784L);
    SimpleLongDecrypter.getCachedDecrypter(2867565265961688735L).setKey(-7139700341815376231L);
    SimpleLongDecrypter.getCachedDecrypter(6177928385028660644L).setKey(939881984926066978L);
    SimpleLongDecrypter.getCachedDecrypter(8471609844558590347L).setKey(-672681973275207783L);
    SimpleLongDecrypter.getCachedDecrypter(-3545464524489266916L).setKey(-5930960237497032969L);
    SimpleLongDecrypter.getCachedDecrypter(4478360924930527182L).setKey(7936763337768453536L);
    SimpleLongDecrypter.getCachedDecrypter(-4985412563720594230L).setKey(3121755810022315641L);
    SimpleLongDecrypter.getCachedDecrypter(-3161026748002981923L).setKey(-897725736057918653L);
    SimpleLongDecrypter.getCachedDecrypter(-4763005170945720657L).setKey(-7042343202779209728L);
    SimpleLongDecrypter.getCachedDecrypter(6402385875819598766L).setKey(873217072098415237L);
    SimpleLongDecrypter.getCachedDecrypter(-3359558043183580034L).setKey(-8619662574410015615L);
    SimpleLongDecrypter.getCachedDecrypter(-403903606079965520L).setKey(1062087173940011531L);
    SimpleLongDecrypter.getCachedDecrypter(-7132901453153710149L).setKey(223840657721807527L);
    SimpleLongDecrypter.getCachedDecrypter(1141205279245454017L).setKey(-4311864606206114595L);
    SimpleLongDecrypter.getCachedDecrypter(-4573177370279440571L).setKey(-738678821952340278L);
    SimpleLongDecrypter.getCachedDecrypter(-1135865726029858509L).setKey(8521001616540071106L);
    SimpleLongDecrypter.getCachedDecrypter(-7995747426049998656L).setKey(5176124284875883007L);
    SimpleLongDecrypter.getCachedDecrypter(7508545416114263638L).setKey(-6838857994931355476L);
    SimpleLongDecrypter.getCachedDecrypter(9018743516188961734L).setKey(319900349794720531L);
    SimpleLongDecrypter.getCachedDecrypter(7508325380580666960L).setKey(6701007493158169420L);
    SimpleLongDecrypter.getCachedDecrypter(91244122535102324L).setKey(-5457583028750809345L);
    SimpleLongDecrypter.getCachedDecrypter(6806378469671062843L).setKey(-4018080649806116220L);
    SimpleLongDecrypter.getCachedDecrypter(2902862355872814666L).setKey(-2525736692250709752L);
    SimpleLongDecrypter.getCachedDecrypter(-1075304148098156889L).setKey(-9114534431912181063L);
    SimpleLongDecrypter.getCachedDecrypter(-4732465165271718304L).setKey(2301741392306734647L);
    SimpleLongDecrypter.getCachedDecrypter(4487743330225993967L).setKey(7755401045563739190L);
    SimpleLongDecrypter.getCachedDecrypter(5847509116838151108L).setKey(-8506530899977190750L);
    SimpleLongDecrypter.getCachedDecrypter(8125352643235871781L).setKey(7172964443480818642L);
    SimpleLongDecrypter.getCachedDecrypter(7963447177994234840L).setKey(-3602532203367991675L);
    SimpleLongDecrypter.getCachedDecrypter(-7214822490065015450L).setKey(7649500819560441347L);
    SimpleLongDecrypter.getCachedDecrypter(2188365048060007339L).setKey(-4278269408355038456L);
    SimpleLongDecrypter.getCachedDecrypter(5131142061315535855L).setKey(6744401344625341381L);
    SimpleLongDecrypter.getCachedDecrypter(-7941384629271954926L).setKey(-2524289573446709520L);
    SimpleLongDecrypter.getCachedDecrypter(-6811259281079804436L).setKey(-84363381378959713L);
    SimpleLongDecrypter.getCachedDecrypter(-330518799265874019L).setKey(185547651645245043L);
    SimpleLongDecrypter.getCachedDecrypter(3696190363833076773L).setKey(1291092092990842175L);
    SimpleLongDecrypter.getCachedDecrypter(-6832401113740752531L).setKey(-304298645352630135L);
    SimpleLongDecrypter.getCachedDecrypter(103486084864841568L).setKey(-5539849838937157537L);
    SimpleLongDecrypter.getCachedDecrypter(-3204322537360853749L).setKey(-2068724526687298157L);
    SimpleLongDecrypter.getCachedDecrypter(-2522988169619304033L).setKey(6093557092096524670L);
    SimpleLongDecrypter.getCachedDecrypter(-4908556449281647784L).setKey(6578833601020535537L);
    SimpleLongDecrypter.getCachedDecrypter(707878424125040710L).setKey(-3619244332821224553L);
    SimpleLongDecrypter.getCachedDecrypter(-8682012744125527140L).setKey(7157854746712316645L);
    SimpleLongDecrypter.getCachedDecrypter(3858191867602497805L).setKey(-8658382100164619490L);
    SimpleLongDecrypter.getCachedDecrypter(2423983371813549536L).setKey(3819210035265690495L);
    SimpleLongDecrypter.getCachedDecrypter(-1950324813262331796L).setKey(-2621469945962427827L);
    SimpleLongDecrypter.getCachedDecrypter(-8585060829932164966L).setKey(-7572193738953023683L);
    SimpleLongDecrypter.getCachedDecrypter(-8852348507668258676L).setKey(1381926162094471757L);
    SimpleLongDecrypter.getCachedDecrypter(692834785271118355L).setKey(7920691992869115962L);
    SimpleLongDecrypter.getCachedDecrypter(4213570349755028989L).setKey(-8435044750766632291L);
    SimpleLongDecrypter.getCachedDecrypter(-6845489943236485808L).setKey(-6765906893997239437L);
    SimpleLongDecrypter.getCachedDecrypter(1204314650524263009L).setKey(-4328124686456961446L);
    SimpleLongDecrypter.getCachedDecrypter(7511555625792019208L).setKey(4519571490049820621L);
    SimpleLongDecrypter.getCachedDecrypter(2060917874517897443L).setKey(-6331524104214377746L);
    SimpleLongDecrypter.getCachedDecrypter(6042633630691091680L).setKey(-1507167172915905193L);
    SimpleLongDecrypter.getCachedDecrypter(710930490514193468L).setKey(-6194075692724069755L);
    SimpleLongDecrypter.getCachedDecrypter(4137583897110417195L).setKey(41767289087843420L);
    SimpleLongDecrypter.getCachedDecrypter(-3563297245487682559L).setKey(-9164367170209385956L);
    SimpleLongDecrypter.getCachedDecrypter(1010317781559844741L).setKey(5123557547472860654L);
    SimpleLongDecrypter.getCachedDecrypter(-3201759967231157732L).setKey(3668638251437591720L);
    SimpleLongDecrypter.getCachedDecrypter(5967525028915117640L).setKey(-2718391164982752984L);
    SimpleLongDecrypter.getCachedDecrypter(-3846596886708919529L).setKey(-8691256941058216002L);
    SimpleLongDecrypter.getCachedDecrypter(-5502511215205001497L).setKey(-4286640380405450748L);
    SimpleLongDecrypter.getCachedDecrypter(-9163797127234069966L).setKey(-5131321007563057839L);
    SimpleLongDecrypter.getCachedDecrypter(-7193473175480199996L).setKey(3761533704670086197L);
    SimpleLongDecrypter.getCachedDecrypter(5996076321536045046L).setKey(4777646200094957005L);
    SimpleLongDecrypter.getCachedDecrypter(-8900651321676042990L).setKey(-3461478812613615033L);
    SimpleLongDecrypter.getCachedDecrypter(8673066227904742234L).setKey(7309671642007147883L);
    SimpleLongDecrypter.getCachedDecrypter(-4841676172144064799L).setKey(-1101475174258121439L);
    SimpleLongDecrypter.getCachedDecrypter(6798754856889214168L).setKey(-2145929754267211071L);
    SimpleLongDecrypter.getCachedDecrypter(7720211022714593934L).setKey(7362482698514474927L);
    SimpleLongDecrypter.getCachedDecrypter(-5757433565370216999L).setKey(5085157151515673604L);
    SimpleLongDecrypter.getCachedDecrypter(2137508799098059478L).setKey(-4175088789097081578L);
    SimpleLongDecrypter.getCachedDecrypter(4154086778264762275L).setKey(-8161453803042582136L);
    SimpleLongDecrypter.getCachedDecrypter(2893701482512225910L).setKey(-170232597226645854L);
    SimpleLongDecrypter.getCachedDecrypter(-8741288781124838997L).setKey(-1373462440697696612L);
    SimpleLongDecrypter.getCachedDecrypter(7767894503786834360L).setKey(-4859210916330296715L);
    SimpleLongDecrypter.getCachedDecrypter(5364449083553992975L).setKey(1491718456991617394L);
    SimpleLongDecrypter.getCachedDecrypter(664886368070515421L).setKey(4863209867214980232L);
    SimpleLongDecrypter.getCachedDecrypter(-7247942375985573405L).setKey(2724327933231667638L);
    SimpleLongDecrypter.getCachedDecrypter(-3738887881752877854L).setKey(-5394738623484549309L);
    SimpleLongDecrypter.getCachedDecrypter(5187746192940792680L).setKey(-3957737426782876461L);
    SimpleLongDecrypter.getCachedDecrypter(8588417364159177616L).setKey(4543184953254812431L);
    SimpleLongDecrypter.getCachedDecrypter(-6285295072341674691L).setKey(-9176931223414050841L);
    SimpleLongDecrypter.getCachedDecrypter(-4865767967187366309L).setKey(-9115978210625611799L);
    SimpleLongDecrypter.getCachedDecrypter(-5543188363817849267L).setKey(-6605343050932205377L);
    SimpleLongDecrypter.getCachedDecrypter(-6013075677996430232L).setKey(-5665928925014211131L);
    SimpleLongDecrypter.getCachedDecrypter(1423741846829611548L).setKey(-7875346913365175942L);
    SimpleLongDecrypter.getCachedDecrypter(7205055042732216573L).setKey(4139457288075244387L);
    SimpleLongDecrypter.getCachedDecrypter(-3301372411445132613L).setKey(-2359050353798792708L);
    SimpleLongDecrypter.getCachedDecrypter(8205826689295462307L).setKey(7813295364877386597L);
    SimpleLongDecrypter.getCachedDecrypter(2337477378317786943L).setKey(-6361186292191359917L);
    SimpleLongDecrypter.getCachedDecrypter(7542545945419412957L).setKey(7232297885079975938L);
    SimpleLongDecrypter.getCachedDecrypter(3022634348089875093L).setKey(-5574095415477552804L);
    SimpleLongDecrypter.getCachedDecrypter(-1211950234131756040L).setKey(-3639589961803174731L);
    SimpleLongDecrypter.getCachedDecrypter(4572276498822595247L).setKey(8397902500516684740L);
    SimpleLongDecrypter.getCachedDecrypter(-6021588311837726220L).setKey(-8367097660907191608L);
    SimpleLongDecrypter.getCachedDecrypter(927432308726968895L).setKey(2718614723948810818L);
    SimpleLongDecrypter.getCachedDecrypter(-8743701098223685371L).setKey(-411367705040640741L);
    SimpleLongDecrypter.getCachedDecrypter(3401072904693765963L).setKey(1581970829575878967L);
    SimpleLongDecrypter.getCachedDecrypter(-3593841255774166813L).setKey(9036395258498541958L);
    SimpleLongDecrypter.getCachedDecrypter(5655497945420960435L).setKey(3280761738315325620L);
    SimpleLongDecrypter.getCachedDecrypter(3451528363397551220L).setKey(1385701810749549684L);
    SimpleLongDecrypter.getCachedDecrypter(-8124310843722276083L).setKey(-4221393994085230398L);
    SimpleLongDecrypter.getCachedDecrypter(-4537344967028902489L).setKey(-2349086648399652936L);
    SimpleLongDecrypter.getCachedDecrypter(-1415726187869861678L).setKey(1709163711827794540L);
    SimpleLongDecrypter.getCachedDecrypter(-7353170174364305238L).setKey(-2611024459872772007L);
    SimpleLongDecrypter.getCachedDecrypter(9085864427344729974L).setKey(-460924340338527585L);
    SimpleLongDecrypter.getCachedDecrypter(-5506465104675748323L).setKey(-5087100946835179409L);
    SimpleLongDecrypter.getCachedDecrypter(-2778288852866610944L).setKey(-4183060737834863247L);
    SimpleLongDecrypter.getCachedDecrypter(5182787340757636756L).setKey(-8538748766244671252L);
    SimpleLongDecrypter.getCachedDecrypter(2798502748566405868L).setKey(-2223162749747782252L);
    SimpleLongDecrypter.getCachedDecrypter(4963483220993702651L).setKey(-4901612984725431890L);
    SimpleLongDecrypter.getCachedDecrypter(5595708620569246508L).setKey(5982057159227242530L);
    SimpleLongDecrypter.getCachedDecrypter(7934292517770034513L).setKey(5592054598300383760L);
    SimpleLongDecrypter.getCachedDecrypter(566061993988877962L).setKey(-8662192434919098264L);
    SimpleLongDecrypter.getCachedDecrypter(1659084041903248094L).setKey(-3902301149871444946L);
    SimpleLongDecrypter.getCachedDecrypter(1858734089467413525L).setKey(-8956037845510430248L);
    SimpleLongDecrypter.getCachedDecrypter(-8947884264741190428L).setKey(8157686783994766571L);
    SimpleLongDecrypter.getCachedDecrypter(2875524495390645943L).setKey(-1697386577286525028L);
    SimpleLongDecrypter.getCachedDecrypter(2525117424803823566L).setKey(-2664457804279759243L);
    SimpleLongDecrypter.getCachedDecrypter(6256958164154952993L).setKey(4006034500095606312L);
    SimpleLongDecrypter.getCachedDecrypter(-5044242503040042633L).setKey(1404661701620525923L);
    SimpleLongDecrypter.getCachedDecrypter(-8508633083400952412L).setKey(3059558538256952488L);
    SimpleLongDecrypter.getCachedDecrypter(9092359654545383665L).setKey(-3315868476120704846L);
    SimpleLongDecrypter.getCachedDecrypter(3901894922309817351L).setKey(7154029165040332154L);
    SimpleLongDecrypter.getCachedDecrypter(4748476702081036812L).setKey(1873198700126652342L);
    SimpleLongDecrypter.getCachedDecrypter(1463385434931312017L).setKey(-3008815825764124687L);
    SimpleLongDecrypter.getCachedDecrypter(-3897562251607760738L).setKey(1686211401544119430L);
    SimpleLongDecrypter.getCachedDecrypter(4240679358481454709L).setKey(-6802840482178074326L);
    SimpleLongDecrypter.getCachedDecrypter(1728377775206921038L).setKey(-3318650037001057367L);
    SimpleLongDecrypter.getCachedDecrypter(2903465266454951086L).setKey(-7603674104654525036L);
    SimpleLongDecrypter.getCachedDecrypter(1541060936725389449L).setKey(-6779000842373516061L);
    SimpleLongDecrypter.getCachedDecrypter(-6555703628364437722L).setKey(6196073128903427994L);
    SimpleLongDecrypter.getCachedDecrypter(-6170838684218707658L).setKey(5001498739289601398L);
    SimpleLongDecrypter.getCachedDecrypter(-2625755662750373389L).setKey(-1179437030280534770L);
    SimpleLongDecrypter.getCachedDecrypter(-5525714013545269119L).setKey(-890799650959200034L);
    SimpleLongDecrypter.getCachedDecrypter(2605654333647180296L).setKey(-5398327007729063264L);
    SimpleLongDecrypter.getCachedDecrypter(-3971966066202463083L).setKey(-3585565487660867922L);
    SimpleLongDecrypter.getCachedDecrypter(4967998242959421720L).setKey(-7666274264012395615L);
    SimpleLongDecrypter.getCachedDecrypter(-7292525398660242303L).setKey(-2715262959826928969L);
    SimpleLongDecrypter.getCachedDecrypter(5047783153840916203L).setKey(-7616244529428534067L);
    SimpleLongDecrypter.getCachedDecrypter(-7587991283979786360L).setKey(-5850224151646231849L);
    SimpleLongDecrypter.getCachedDecrypter(1714684839975473469L).setKey(2225896271418347649L);
    SimpleLongDecrypter.getCachedDecrypter(1912590090813351365L).setKey(-716858701942635474L);
    SimpleLongDecrypter.getCachedDecrypter(8779269585824015007L).setKey(-8061142262920290430L);
    SimpleLongDecrypter.getCachedDecrypter(-1095661383049806117L).setKey(-2543722666890627114L);
    SimpleLongDecrypter.getCachedDecrypter(-4028650048823538148L).setKey(8759774189160679296L);
    SimpleLongDecrypter.getCachedDecrypter(-7312916550180035921L).setKey(3444925346543457680L);
    SimpleLongDecrypter.getCachedDecrypter(2799375107147803074L).setKey(2186702452993096399L);
    SimpleLongDecrypter.getCachedDecrypter(-1980199650843658975L).setKey(-2823014427137545882L);
    SimpleLongDecrypter.getCachedDecrypter(-129478623394363359L).setKey(-7325001785309156757L);
    SimpleLongDecrypter.getCachedDecrypter(4197886343753747205L).setKey(-9128041982828608381L);
    SimpleLongDecrypter.getCachedDecrypter(5373454224974185000L).setKey(2229169089541482307L);
    SimpleLongDecrypter.getCachedDecrypter(661751168714911210L).setKey(-7631551459232019907L);
    SimpleLongDecrypter.getCachedDecrypter(7669731067240236419L).setKey(8036969672273417714L);
    SimpleLongDecrypter.getCachedDecrypter(-6811376340518551758L).setKey(3606426324652962970L);
    SimpleLongDecrypter.getCachedDecrypter(-9167186239536708054L).setKey(-6062990904116885184L);
    SimpleLongDecrypter.getCachedDecrypter(-4716984406249995446L).setKey(-3706767889775215009L);
    SimpleLongDecrypter.getCachedDecrypter(2368441159022925182L).setKey(6590496414655077578L);
    SimpleLongDecrypter.getCachedDecrypter(4686431100186309612L).setKey(-6432564661302543709L);
    SimpleLongDecrypter.getCachedDecrypter(-7048626659775594689L).setKey(-6471445024688664505L);
    SimpleLongDecrypter.getCachedDecrypter(5798179085679334343L).setKey(-7416644461233041359L);
    SimpleLongDecrypter.getCachedDecrypter(832395647808444863L).setKey(343912523240318692L);
    SimpleLongDecrypter.getCachedDecrypter(6038801730063991826L).setKey(-8403647840991693563L);
    SimpleLongDecrypter.getCachedDecrypter(-6143915884461729557L).setKey(-3166398704089068630L);
    SimpleLongDecrypter.getCachedDecrypter(-4576862672741050387L).setKey(2636486389674961254L);
    SimpleLongDecrypter.getCachedDecrypter(8672122458423636592L).setKey(3708184149068066619L);
    SimpleLongDecrypter.getCachedDecrypter(507654040706337441L).setKey(-4416954414115674970L);
    SimpleLongDecrypter.getCachedDecrypter(6968008378745662073L).setKey(3407674021839006376L);
    SimpleLongDecrypter.getCachedDecrypter(3408467920169547397L).setKey(-51190193265318808L);
    SimpleLongDecrypter.getCachedDecrypter(-8668106289515993190L).setKey(-5084969502381986530L);
    SimpleLongDecrypter.getCachedDecrypter(-8836186528503066514L).setKey(3385616747164001392L);
    SimpleLongDecrypter.getCachedDecrypter(7102066860397301752L).setKey(-1885051626109354046L);
    SimpleLongDecrypter.getCachedDecrypter(-6993832109119472732L).setKey(-6773534165661395836L);
    SimpleLongDecrypter.getCachedDecrypter(2206557733545496955L).setKey(-6671676208086798134L);
    SimpleLongDecrypter.getCachedDecrypter(3785442395526820618L).setKey(-3580166363716801239L);
    SimpleLongDecrypter.getCachedDecrypter(-8808245648092267035L).setKey(1857072894702790786L);
    SimpleLongDecrypter.getCachedDecrypter(4292113854973194115L).setKey(2910675341642846362L);
    SimpleLongDecrypter.getCachedDecrypter(-2245590007159606673L).setKey(-1944677701928492932L);
    SimpleLongDecrypter.getCachedDecrypter(2431056818857040612L).setKey(3650682085104476464L);
    SimpleLongDecrypter.getCachedDecrypter(-2200840168952866270L).setKey(300758068870578185L);
    SimpleLongDecrypter.getCachedDecrypter(-1851969932807775962L).setKey(-1668444797577881415L);
    SimpleLongDecrypter.getCachedDecrypter(799909612779804135L).setKey(-3527932724561553944L);
    SimpleLongDecrypter.getCachedDecrypter(-4457670491146406544L).setKey(-1042354561162650508L);
    SimpleLongDecrypter.getCachedDecrypter(6113842012534027006L).setKey(2545448416499731209L);
    SimpleLongDecrypter.getCachedDecrypter(1742653509539466969L).setKey(8377918569444092731L);
    SimpleLongDecrypter.getCachedDecrypter(-4433616906069315453L).setKey(8700271987213325490L);
    SimpleLongDecrypter.getCachedDecrypter(5048992504185414320L).setKey(-7899039639597206912L);
    SimpleLongDecrypter.getCachedDecrypter(-6766392492109753948L).setKey(4426785990868149567L);
    SimpleLongDecrypter.getCachedDecrypter(1124027588226919294L).setKey(3017038289803600718L);
    SimpleLongDecrypter.getCachedDecrypter(-1112791354944908863L).setKey(6896498820390254764L);
    SimpleLongDecrypter.getCachedDecrypter(30455977399061676L).setKey(521819844431010898L);
    SimpleLongDecrypter.getCachedDecrypter(-2507745883339726256L).setKey(-5683366207754194971L);
    SimpleLongDecrypter.getCachedDecrypter(4304488152353087751L).setKey(-4647486559119827747L);
    SimpleLongDecrypter.getCachedDecrypter(-5701856300808750738L).setKey(7445180925040050416L);
    SimpleLongDecrypter.getCachedDecrypter(-3255149582356588165L).setKey(4113645486948669718L);
    SimpleLongDecrypter.getCachedDecrypter(-197461148448453461L).setKey(-1207006476226685315L);
    SimpleLongDecrypter.getCachedDecrypter(6521822959928089977L).setKey(8413889411545685683L);
    SimpleLongDecrypter.getCachedDecrypter(5180810144194256891L).setKey(-3570266821777261622L);
    SimpleLongDecrypter.getCachedDecrypter(2368611677932603933L).setKey(-6854526705115882649L);
    SimpleLongDecrypter.getCachedDecrypter(-1645268313044409559L).setKey(4280698580289619457L);
    SimpleLongDecrypter.getCachedDecrypter(-7685580722440196500L).setKey(-8091287444911147458L);
    SimpleLongDecrypter.getCachedDecrypter(8001111816110344958L).setKey(-3016048523774306067L);
    SimpleLongDecrypter.getCachedDecrypter(1958521076846376274L).setKey(-7779212068647939216L);
    SimpleLongDecrypter.getCachedDecrypter(-8459901781208225351L).setKey(-2874847859748686226L);
    SimpleLongDecrypter.getCachedDecrypter(-3119200894918836522L).setKey(5073039803146027246L);
    SimpleLongDecrypter.getCachedDecrypter(7412871936695043836L).setKey(-8950252696893113518L);
    SimpleLongDecrypter.getCachedDecrypter(-604920190624968834L).setKey(5635068743836389782L);
    SimpleLongDecrypter.getCachedDecrypter(-167919062203213751L).setKey(-7874815411735151779L);
    SimpleLongDecrypter.getCachedDecrypter(655212059839436281L).setKey(-4532118110773788564L);
    SimpleLongDecrypter.getCachedDecrypter(6193026249662086205L).setKey(413286951967537828L);
    SimpleLongDecrypter.getCachedDecrypter(-4932513801152294861L).setKey(-8585026686307581163L);
    SimpleLongDecrypter.getCachedDecrypter(-511661253293433431L).setKey(743144716705680274L);
    SimpleLongDecrypter.getCachedDecrypter(6111273977187070425L).setKey(-8756001649529777604L);
    SimpleLongDecrypter.getCachedDecrypter(6012002358558966423L).setKey(4619287038221867218L);
    SimpleLongDecrypter.getCachedDecrypter(-2798148038980097926L).setKey(-6525513242857925485L);
    SimpleLongDecrypter.getCachedDecrypter(-8884691471570332463L).setKey(-743975905557150815L);
    SimpleLongDecrypter.getCachedDecrypter(-2526398118488923853L).setKey(7946275066519700908L);
    SimpleLongDecrypter.getCachedDecrypter(2539011694663758330L).setKey(-6264818470398851290L);
    SimpleLongDecrypter.getCachedDecrypter(-376989407664483086L).setKey(-5392989214098056439L);
    SimpleLongDecrypter.getCachedDecrypter(194234108647378075L).setKey(5485494974060232616L);
    SimpleLongDecrypter.getCachedDecrypter(645499127770190502L).setKey(-8713038685572612378L);
    SimpleLongDecrypter.getCachedDecrypter(-1825888034428342229L).setKey(-299808820020923688L);
    SimpleLongDecrypter.getCachedDecrypter(-6932961751183513202L).setKey(-7691305110407775126L);
    SimpleLongDecrypter.getCachedDecrypter(-1077551196950386872L).setKey(-6754689899445947954L);
    SimpleLongDecrypter.getCachedDecrypter(2847482374656485979L).setKey(-3726862211747996212L);
    SimpleLongDecrypter.getCachedDecrypter(-179571823836923311L).setKey(2232219532251331133L);
    SimpleLongDecrypter.getCachedDecrypter(797333857057254951L).setKey(7071709975424457803L);
    SimpleLongDecrypter.getCachedDecrypter(1457817196285770984L).setKey(3553679987007694279L);
    SimpleLongDecrypter.getCachedDecrypter(-3704314660701640239L).setKey(-5841788784052411592L);
    SimpleLongDecrypter.getCachedDecrypter(-201083070910374780L).setKey(4809623196485650828L);
    SimpleLongDecrypter.getCachedDecrypter(6095307921512293514L).setKey(-5588208218398677923L);
    SimpleLongDecrypter.getCachedDecrypter(-2898816967910471384L).setKey(8780267488213535984L);
    SimpleLongDecrypter.getCachedDecrypter(-5754550838628715434L).setKey(-2914565267681081691L);
    SimpleLongDecrypter.getCachedDecrypter(2777379061751226346L).setKey(-4137440002879648166L);
    SimpleLongDecrypter.getCachedDecrypter(-6363660721610493683L).setKey(4539102929984171675L);
    SimpleLongDecrypter.getCachedDecrypter(-2082646068343044551L).setKey(1100353367243653074L);
    SimpleLongDecrypter.getCachedDecrypter(9064223851557609438L).setKey(-4114277977638425840L);
    SimpleLongDecrypter.getCachedDecrypter(-8874305497589264404L).setKey(-5866685905965883231L);
    SimpleLongDecrypter.getCachedDecrypter(-7336904156043519981L).setKey(4558475917592338750L);
    SimpleLongDecrypter.getCachedDecrypter(-5174105977788999131L).setKey(938705388437501356L);
    SimpleLongDecrypter.getCachedDecrypter(-4530149770929394489L).setKey(-6348384361509434061L);
    SimpleLongDecrypter.getCachedDecrypter(3963375769228025598L).setKey(-2858673909960860439L);
    SimpleLongDecrypter.getCachedDecrypter(-9055825500420793714L).setKey(3659340037148811353L);
    SimpleLongDecrypter.getCachedDecrypter(801972426697468357L).setKey(1651804631845775796L);
    SimpleLongDecrypter.getCachedDecrypter(-8532194282700910261L).setKey(1597051230631232869L);
    SimpleLongDecrypter.getCachedDecrypter(1628278515014687184L).setKey(2712601616158898945L);
    SimpleLongDecrypter.getCachedDecrypter(-6974044591253583409L).setKey(-1489716486634179263L);
    SimpleLongDecrypter.getCachedDecrypter(-1103876810463568064L).setKey(-2692490746300101490L);
    SimpleLongDecrypter.getCachedDecrypter(2582057426271092736L).setKey(8009768165651394354L);
    SimpleLongDecrypter.getCachedDecrypter(6255512141274012271L).setKey(4367373822131412955L);
    SimpleLongDecrypter.getCachedDecrypter(5681710145529351350L).setKey(6338476167454209674L);
    SimpleLongDecrypter.getCachedDecrypter(1241678293727710259L).setKey(870033428329686775L);
    SimpleLongDecrypter.getCachedDecrypter(8497506925578285438L).setKey(-4188303581095699978L);
    SimpleLongDecrypter.getCachedDecrypter(-7775646392250863559L).setKey(-6870970025921030672L);
    SimpleLongDecrypter.getCachedDecrypter(-5244750823034210506L).setKey(-3017873056794943943L);
    SimpleLongDecrypter.getCachedDecrypter(1597308826578142055L).setKey(5415100557689568404L);
    SimpleLongDecrypter.getCachedDecrypter(5272152424182884429L).setKey(6795550413020788385L);
    SimpleLongDecrypter.getCachedDecrypter(747025750338791985L).setKey(4459849081908131978L);
    SimpleLongDecrypter.getCachedDecrypter(-2744919426701863945L).setKey(794072747884774307L);
    SimpleLongDecrypter.getCachedDecrypter(-212093283128087923L).setKey(-3805527134229470271L);
    SimpleLongDecrypter.getCachedDecrypter(639105765387001402L).setKey(650165455256124884L);
    SimpleLongDecrypter.getCachedDecrypter(-691178816798631930L).setKey(-438698647729170149L);
    SimpleLongDecrypter.getCachedDecrypter(-6892356351213478672L).setKey(1588127842711648860L);
    SimpleLongDecrypter.getCachedDecrypter(2215572882768835164L).setKey(779487616368435851L);
    SimpleLongDecrypter.getCachedDecrypter(4017482765865910721L).setKey(3721023493201383930L);
    SimpleLongDecrypter.getCachedDecrypter(-4542100751411146608L).setKey(-709988716997533707L);
    SimpleLongDecrypter.getCachedDecrypter(-6768550658772063659L).setKey(-5452762719677307618L);
    SimpleLongDecrypter.getCachedDecrypter(2492307306600875951L).setKey(-1954527672388359376L);
    SimpleLongDecrypter.getCachedDecrypter(7590119284004242150L).setKey(3674254096076090236L);
    SimpleLongDecrypter.getCachedDecrypter(-5442457607328349694L).setKey(369470151555135144L);
    SimpleLongDecrypter.getCachedDecrypter(-5098562949908907432L).setKey(-7015872141430381200L);
    SimpleLongDecrypter.getCachedDecrypter(4323349156429023315L).setKey(1888298218704458294L);
    SimpleLongDecrypter.getCachedDecrypter(-7874768164741068988L).setKey(-2464433809738462954L);
    SimpleLongDecrypter.getCachedDecrypter(-3970308288578104427L).setKey(1534083756198510994L);
    SimpleLongDecrypter.getCachedDecrypter(-5101141037251748487L).setKey(56178153902982324L);
    SimpleLongDecrypter.getCachedDecrypter(7189568598758626780L).setKey(87931131190249007L);
    SimpleLongDecrypter.getCachedDecrypter(-1463260358995568808L).setKey(4345914917452835063L);
    SimpleLongDecrypter.getCachedDecrypter(-5929294695699147395L).setKey(2466031891883531911L);
    SimpleLongDecrypter.getCachedDecrypter(8528252190688409944L).setKey(-6916545330787639894L);
    SimpleLongDecrypter.getCachedDecrypter(-3355847007076748999L).setKey(-8439833302896352634L);
    SimpleLongDecrypter.getCachedDecrypter(4665582870868755387L).setKey(-495875701888325867L);
    SimpleLongDecrypter.getCachedDecrypter(3376915949025706748L).setKey(-4004934404306552952L);
    SimpleLongDecrypter.getCachedDecrypter(-962948944613878177L).setKey(1517126311847850339L);
    SimpleLongDecrypter.getCachedDecrypter(4026424958029452208L).setKey(-5543465467340549692L);
    SimpleLongDecrypter.getCachedDecrypter(2338531806770529894L).setKey(-5008200691652706505L);
    SimpleLongDecrypter.getCachedDecrypter(922020115749962468L).setKey(4765452861764859479L);
    SimpleLongDecrypter.getCachedDecrypter(5355738139947739630L).setKey(6169841520759849602L);
    SimpleLongDecrypter.getCachedDecrypter(4255154029388740298L).setKey(-6450250323687971686L);
    SimpleLongDecrypter.getCachedDecrypter(-4391320878029221421L).setKey(4907142856080637354L);
    SimpleLongDecrypter.getCachedDecrypter(1625459339234679590L).setKey(5652706847893946896L);
    SimpleLongDecrypter.getCachedDecrypter(-3420598883163720694L).setKey(-6803383071672422165L);
    SimpleLongDecrypter.getCachedDecrypter(7444678937459893482L).setKey(-8918055005205759872L);
    SimpleLongDecrypter.getCachedDecrypter(5464153636084904495L).setKey(-1390984442967720633L);
    SimpleLongDecrypter.getCachedDecrypter(-2301432568888831523L).setKey(-844247254678013009L);
    SimpleLongDecrypter.getCachedDecrypter(6993446623865075132L).setKey(7273156305186736482L);
    SimpleLongDecrypter.getCachedDecrypter(-4253940309716343450L).setKey(950273969418128717L);
    SimpleLongDecrypter.getCachedDecrypter(5962222253179206200L).setKey(1642477093945279801L);
    SimpleLongDecrypter.getCachedDecrypter(-5827119113393071779L).setKey(-8488526885326840749L);
    SimpleLongDecrypter.getCachedDecrypter(5160069404031976388L).setKey(-1001694157696750648L);
    SimpleLongDecrypter.getCachedDecrypter(1440567120833582110L).setKey(8881830427256036045L);
    SimpleLongDecrypter.getCachedDecrypter(-9177949358036287008L).setKey(6746655007882539212L);
    SimpleLongDecrypter.getCachedDecrypter(1179311785238657433L).setKey(951734318086548274L);
    SimpleLongDecrypter.getCachedDecrypter(2164215133800982069L).setKey(-1987317363865716482L);
    SimpleLongDecrypter.getCachedDecrypter(3865433491046929311L).setKey(493842138465279462L);
    SimpleLongDecrypter.getCachedDecrypter(-2926205830959165863L).setKey(-6910985841343478937L);
    SimpleLongDecrypter.getCachedDecrypter(-6893856517931929341L).setKey(8163572963702108785L);
    SimpleLongDecrypter.getCachedDecrypter(-4756151241979799495L).setKey(-5722670203612420669L);
    SimpleLongDecrypter.getCachedDecrypter(-5031417536587628329L).setKey(3539643634316818421L);
    SimpleLongDecrypter.getCachedDecrypter(-8063728196650787938L).setKey(-3181580312642502578L);
    SimpleLongDecrypter.getCachedDecrypter(-7685741427500799781L).setKey(509000681892564780L);
    SimpleLongDecrypter.getCachedDecrypter(-8589503111829810798L).setKey(-3746709826201469300L);
    SimpleLongDecrypter.getCachedDecrypter(1026605272194587321L).setKey(-1540102981352066802L);
    SimpleLongDecrypter.getCachedDecrypter(1834079494986373447L).setKey(-6353713501482219491L);
    SimpleLongDecrypter.getCachedDecrypter(-3500251774755870811L).setKey(-8866330539943036220L);
    SimpleLongDecrypter.getCachedDecrypter(5926789938090128640L).setKey(-6302952740431273502L);
    SimpleLongDecrypter.getCachedDecrypter(5570093781269963224L).setKey(-2539170867165848569L);
    SimpleLongDecrypter.getCachedDecrypter(-4413593950337129276L).setKey(-5062165755450312516L);
    SimpleLongDecrypter.getCachedDecrypter(7397085293192115141L).setKey(5290167761754111134L);
    SimpleLongDecrypter.getCachedDecrypter(593536235967428544L).setKey(263431160989975757L);
    SimpleLongDecrypter.getCachedDecrypter(928720371381790844L).setKey(-5458861663351264437L);
    SimpleLongDecrypter.getCachedDecrypter(2147451630644392721L).setKey(-2097470913207858349L);
    SimpleLongDecrypter.getCachedDecrypter(-1208189063975720724L).setKey(-1684333418590497685L);
    SimpleLongDecrypter.getCachedDecrypter(7026852701650966666L).setKey(429321972384452842L);
    SimpleLongDecrypter.getCachedDecrypter(3217200453472323658L).setKey(3686498587188944845L);
    SimpleLongDecrypter.getCachedDecrypter(5143280674850937309L).setKey(-6403874018169243618L);
    SimpleLongDecrypter.getCachedDecrypter(-8868503133950471405L).setKey(550503622373431311L);
    SimpleLongDecrypter.getCachedDecrypter(8830117575883558363L).setKey(-7933414917707794853L);
    SimpleLongDecrypter.getCachedDecrypter(3673074676334204089L).setKey(-3236923994411086973L);
    SimpleLongDecrypter.getCachedDecrypter(8550203807664804593L).setKey(-7358292859042399828L);
    SimpleLongDecrypter.getCachedDecrypter(5212113655951294977L).setKey(-7926519666513738255L);
    SimpleLongDecrypter.getCachedDecrypter(-6978868103316390532L).setKey(7516661392885552006L);
    SimpleLongDecrypter.getCachedDecrypter(6452659029409559674L).setKey(5099306551746343110L);
    SimpleLongDecrypter.getCachedDecrypter(-6067597685705384996L).setKey(1654781762218397283L);
    SimpleLongDecrypter.getCachedDecrypter(-4994544334402439281L).setKey(5043882265283298130L);
    SimpleLongDecrypter.getCachedDecrypter(7511316848194191269L).setKey(7089450387155082374L);
    SimpleLongDecrypter.getCachedDecrypter(8979285194773697681L).setKey(-2945156265340406771L);
    SimpleLongDecrypter.getCachedDecrypter(-7015383164893645554L).setKey(8586198925090511677L);
    SimpleLongDecrypter.getCachedDecrypter(148706894124341009L).setKey(-7436944561123422897L);
    SimpleLongDecrypter.getCachedDecrypter(-4193445458544169262L).setKey(-9149176582374971188L);
    SimpleLongDecrypter.getCachedDecrypter(1888283732290676879L).setKey(4810562716218892595L);
    SimpleLongDecrypter.getCachedDecrypter(8299231841907687858L).setKey(-6489257244006327208L);
    SimpleLongDecrypter.getCachedDecrypter(-924848646441286131L).setKey(-3139924734835666189L);
    SimpleLongDecrypter.getCachedDecrypter(8543323408721615433L).setKey(-690159866065515440L);
    SimpleLongDecrypter.getCachedDecrypter(8102151993213550864L).setKey(-9122495236798429241L);
    SimpleLongDecrypter.getCachedDecrypter(-2266198575319352711L).setKey(1344422970586725390L);
    SimpleLongDecrypter.getCachedDecrypter(1792966486209028545L).setKey(81494410126121301L);
    SimpleLongDecrypter.getCachedDecrypter(-4676946530865761393L).setKey(-7288373758831804191L);
    SimpleLongDecrypter.getCachedDecrypter(4864651802415745619L).setKey(-8663433451788355610L);
    SimpleLongDecrypter.getCachedDecrypter(8933460942542429083L).setKey(2549153637831757542L);
    SimpleLongDecrypter.getCachedDecrypter(-2567622927059121865L).setKey(7348203633593405263L);
    SimpleLongDecrypter.getCachedDecrypter(2343255185386943172L).setKey(7462102340996201329L);
    SimpleLongDecrypter.getCachedDecrypter(-8539352599667624212L).setKey(2368120461431947658L);
    SimpleLongDecrypter.getCachedDecrypter(4926875232935818816L).setKey(-3673431252856600282L);
    SimpleLongDecrypter.getCachedDecrypter(840680886870020403L).setKey(6708842004115248389L);
    SimpleLongDecrypter.getCachedDecrypter(-4925767926864583256L).setKey(8383954722731617570L);
    SimpleLongDecrypter.getCachedDecrypter(504924762447987619L).setKey(-4708153541851695431L);
    SimpleLongDecrypter.getCachedDecrypter(-1582785126012168929L).setKey(-2687689990482017250L);
    SimpleLongDecrypter.getCachedDecrypter(1600850477333762064L).setKey(6341767766247782569L);
    SimpleLongDecrypter.getCachedDecrypter(4677080207504842926L).setKey(1168345289543676105L);
    SimpleLongDecrypter.getCachedDecrypter(-5291553600833031668L).setKey(-4441901259605611246L);
    SimpleLongDecrypter.getCachedDecrypter(4764692602871464907L).setKey(1837551022945911622L);
    SimpleLongDecrypter.getCachedDecrypter(-3864422159141294762L).setKey(-863402602024454484L);
    SimpleLongDecrypter.getCachedDecrypter(-4154212544891822541L).setKey(-3051341282320249702L);
    SimpleLongDecrypter.getCachedDecrypter(-4406565938293078575L).setKey(1630682102008394994L);
    SimpleLongDecrypter.getCachedDecrypter(6538565780687322634L).setKey(-1538109824666937684L);
    SimpleLongDecrypter.getCachedDecrypter(-4755859472231622756L).setKey(-5274201698437293291L);
    SimpleLongDecrypter.getCachedDecrypter(-8039409331502748486L).setKey(8739560974471198751L);
    SimpleLongDecrypter.getCachedDecrypter(5274577398868453537L).setKey(-4363984743525772388L);
    SimpleLongDecrypter.getCachedDecrypter(2629931669005736922L).setKey(-3241375260339264570L);
    SimpleLongDecrypter.getCachedDecrypter(1524997205057252358L).setKey(-5681663587098980590L);
    SimpleLongDecrypter.getCachedDecrypter(4865706909417798119L).setKey(8783333638811187962L);
    SimpleLongDecrypter.getCachedDecrypter(3735702413694503837L).setKey(4556652746429885700L);
    SimpleLongDecrypter.getCachedDecrypter(-2400277445329014214L).setKey(6856245094947725099L);
    SimpleLongDecrypter.getCachedDecrypter(277921651240128572L).setKey(5437128656255165953L);
    SimpleLongDecrypter.getCachedDecrypter(-2555419955992357936L).setKey(9078755238118120784L);
    SimpleLongDecrypter.getCachedDecrypter(-4054214924606981113L).setKey(-2191527579533168871L);
    SimpleLongDecrypter.getCachedDecrypter(-4658608746581299194L).setKey(8317524886485773555L);
    SimpleLongDecrypter.getCachedDecrypter(5113591711377816770L).setKey(7708472526193906832L);
    SimpleLongDecrypter.getCachedDecrypter(-6725422450996003530L).setKey(-2103824943723184953L);
    SimpleLongDecrypter.getCachedDecrypter(3253556778196826955L).setKey(6288474842291548156L);
    SimpleLongDecrypter.getCachedDecrypter(3569257655907658777L).setKey(-3631571162452054098L);
    SimpleLongDecrypter.getCachedDecrypter(3845913155428774742L).setKey(-8648965126488734782L);
    SimpleLongDecrypter.getCachedDecrypter(-1732683378175758701L).setKey(-4762022281019175297L);
    SimpleLongDecrypter.getCachedDecrypter(4845660768628320067L).setKey(4135610284215203345L);
    SimpleLongDecrypter.getCachedDecrypter(431853018132265819L).setKey(-729636242132418861L);
    SimpleLongDecrypter.getCachedDecrypter(4323828518872826203L).setKey(3989674129917274094L);
    SimpleLongDecrypter.getCachedDecrypter(6185812326971848047L).setKey(-4811871076734893508L);
    SimpleLongDecrypter.getCachedDecrypter(-2143663798569263280L).setKey(8654393777154802479L);
    SimpleLongDecrypter.getCachedDecrypter(-4387127247044577505L).setKey(-5493808618719301738L);
    SimpleLongDecrypter.getCachedDecrypter(-6598433110801900376L).setKey(5058357405906878016L);
    SimpleLongDecrypter.getCachedDecrypter(-4453015270862234665L).setKey(-6401026495473431755L);
    SimpleLongDecrypter.getCachedDecrypter(1758595752676755913L).setKey(-6131428416775058851L);
    SimpleLongDecrypter.getCachedDecrypter(562664941005203198L).setKey(-5537490225268801960L);
    SimpleLongDecrypter.getCachedDecrypter(-7212900018564863460L).setKey(3674982222718839622L);
    SimpleLongDecrypter.getCachedDecrypter(5154469842110852495L).setKey(6761636173286845359L);
    SimpleLongDecrypter.getCachedDecrypter(1936008554850977740L).setKey(-5761732593428842681L);
    SimpleLongDecrypter.getCachedDecrypter(6528036029184460956L).setKey(-5303659033955031214L);
    SimpleLongDecrypter.getCachedDecrypter(-4882533568708628657L).setKey(6485059151397739884L);
    SimpleLongDecrypter.getCachedDecrypter(7792485802567423271L).setKey(6459984049556927806L);
    SimpleLongDecrypter.getCachedDecrypter(8299455630416463559L).setKey(-2756777461712236205L);
    SimpleLongDecrypter.getCachedDecrypter(3943135975239856721L).setKey(-7336363427253637615L);
    SimpleLongDecrypter.getCachedDecrypter(-38133250063926130L).setKey(-5050749645565360454L);
    SimpleLongDecrypter.getCachedDecrypter(2264439698137005495L).setKey(-1124754602928877081L);
    SimpleLongDecrypter.getCachedDecrypter(4448384365607032352L).setKey(5707617814314561016L);
    SimpleLongDecrypter.getCachedDecrypter(-1942193125693451349L).setKey(-3183675586075357611L);
    SimpleLongDecrypter.getCachedDecrypter(-2355644483945450476L).setKey(4128685878945977473L);
    SimpleLongDecrypter.getCachedDecrypter(1019957169973950552L).setKey(2107704886512198918L);
    SimpleLongDecrypter.getCachedDecrypter(-3797129426047134672L).setKey(-8763308151789634165L);
    SimpleLongDecrypter.getCachedDecrypter(-3256168868288664318L).setKey(4507762567009879403L);
    SimpleLongDecrypter.getCachedDecrypter(-3220983252011293342L).setKey(5358072593153989546L);
    SimpleLongDecrypter.getCachedDecrypter(5701077892013580254L).setKey(1232059981094839836L);
    SimpleLongDecrypter.getCachedDecrypter(3108847877900056437L).setKey(-8285230245191666833L);
    SimpleLongDecrypter.getCachedDecrypter(3656318993058195316L).setKey(7784573262085045763L);
    SimpleLongDecrypter.getCachedDecrypter(-3980720079687929802L).setKey(-1503146528454977569L);
    SimpleLongDecrypter.getCachedDecrypter(2569848670338099956L).setKey(4698376325080393944L);
    SimpleLongDecrypter.getCachedDecrypter(-7950519690557423525L).setKey(-7994796081710344029L);
    SimpleLongDecrypter.getCachedDecrypter(-3490210623089805114L).setKey(5671074675979131441L);
    SimpleLongDecrypter.getCachedDecrypter(6470630808314153104L).setKey(3328666729515535740L);
    SimpleLongDecrypter.getCachedDecrypter(-3279156259585225373L).setKey(4427364593453170144L);
    SimpleLongDecrypter.getCachedDecrypter(-1625953934345426090L).setKey(2607062175965072507L);
    SimpleLongDecrypter.getCachedDecrypter(-2868516565236901984L).setKey(779278161619649893L);
    SimpleLongDecrypter.getCachedDecrypter(1655401633235102594L).setKey(-852921831407055811L);
    SimpleLongDecrypter.getCachedDecrypter(-462483712531873651L).setKey(4525847143692478033L);
    SimpleLongDecrypter.getCachedDecrypter(-8897328147543140731L).setKey(408238935683196511L);
    SimpleLongDecrypter.getCachedDecrypter(-2834005029965071068L).setKey(-4545931076471432633L);
    SimpleLongDecrypter.getCachedDecrypter(817321519864738352L).setKey(553166662594559082L);
    SimpleLongDecrypter.getCachedDecrypter(1022271696649130981L).setKey(6780417993912893800L);
    SimpleLongDecrypter.getCachedDecrypter(2515224293847387776L).setKey(-5632138848695072128L);
    SimpleLongDecrypter.getCachedDecrypter(-6474857095719986195L).setKey(3858415526386166438L);
    SimpleLongDecrypter.getCachedDecrypter(-2059920558855007961L).setKey(730106599903822477L);
    SimpleLongDecrypter.getCachedDecrypter(-2362878485456883731L).setKey(-6314578571513164730L);
    SimpleLongDecrypter.getCachedDecrypter(-6729977192229253162L).setKey(-8049506591561839837L);
    SimpleLongDecrypter.getCachedDecrypter(1924714014399527081L).setKey(-5631821218232532929L);
    SimpleLongDecrypter.getCachedDecrypter(1015594880122072929L).setKey(-141376425224722602L);
    SimpleLongDecrypter.getCachedDecrypter(-42923258516934206L).setKey(-6412645058582846538L);
    SimpleLongDecrypter.getCachedDecrypter(1329688210463118847L).setKey(-143810738802925080L);
    SimpleLongDecrypter.getCachedDecrypter(-4639673772535878776L).setKey(3293050864049185507L);
    SimpleLongDecrypter.getCachedDecrypter(5374990670502319608L).setKey(1900324247099267931L);
    SimpleLongDecrypter.getCachedDecrypter(6931480389753654225L).setKey(3794760190831709609L);
    SimpleLongDecrypter.getCachedDecrypter(-5330015373253737753L).setKey(-4697145092570154653L);
    SimpleLongDecrypter.getCachedDecrypter(7597384473157990870L).setKey(5203279161839776636L);
    SimpleLongDecrypter.getCachedDecrypter(-700163477294446611L).setKey(7792722538370662397L);
    SimpleLongDecrypter.getCachedDecrypter(411089702141885407L).setKey(5845623374599542701L);
    SimpleLongDecrypter.getCachedDecrypter(8893612174289022211L).setKey(-4695644617656136161L);
    SimpleLongDecrypter.getCachedDecrypter(950513125575587431L).setKey(-707937898433957967L);
    SimpleLongDecrypter.getCachedDecrypter(1927140053614991665L).setKey(-4852506717214059693L);
    SimpleLongDecrypter.getCachedDecrypter(7140407358993954730L).setKey(2449154331669280357L);
    SimpleLongDecrypter.getCachedDecrypter(6665940990393188289L).setKey(-6422187720648918786L);
    SimpleLongDecrypter.getCachedDecrypter(8415902436124249210L).setKey(4850039549306868475L);
    SimpleLongDecrypter.getCachedDecrypter(7713616702209272924L).setKey(2062505471116940534L);
    SimpleLongDecrypter.getCachedDecrypter(-4225938016585701323L).setKey(1272611209935446292L);
    SimpleLongDecrypter.getCachedDecrypter(5793892935044054089L).setKey(-2600729651406248486L);
    SimpleLongDecrypter.getCachedDecrypter(-4598743902237011449L).setKey(-5314913635201686070L);
    SimpleLongDecrypter.getCachedDecrypter(-7530037652973469667L).setKey(-6482807082539338436L);
    SimpleLongDecrypter.getCachedDecrypter(-277614558029051092L).setKey(7763522334266507179L);
    SimpleLongDecrypter.getCachedDecrypter(3418028578278148673L).setKey(-7788492640496168211L);
    SimpleLongDecrypter.getCachedDecrypter(5557234774006585882L).setKey(2329675868102148634L);
    SimpleLongDecrypter.getCachedDecrypter(5769246121261170231L).setKey(3135041060095890337L);
    SimpleLongDecrypter.getCachedDecrypter(-476097865983158305L).setKey(795569666886716L);
    SimpleLongDecrypter.getCachedDecrypter(-9052974663451438393L).setKey(5165021907856575925L);
    SimpleLongDecrypter.getCachedDecrypter(-8202342386172902915L).setKey(956687543838587625L);
    SimpleLongDecrypter.getCachedDecrypter(-7230922108876464739L).setKey(9085107484615145442L);
    SimpleLongDecrypter.getCachedDecrypter(-156639914892642144L).setKey(-6386756901134419629L);
    SimpleLongDecrypter.getCachedDecrypter(4798608248224932556L).setKey(8586981187281646666L);
    SimpleLongDecrypter.getCachedDecrypter(-5646725847011195406L).setKey(-7029595400520530833L);
    SimpleLongDecrypter.getCachedDecrypter(8087638698547209526L).setKey(8236071949577821159L);
    SimpleLongDecrypter.getCachedDecrypter(7649392037835207913L).setKey(-4380790634621505987L);
    SimpleLongDecrypter.getCachedDecrypter(-8715101991662592243L).setKey(3751398821858198162L);
    SimpleLongDecrypter.getCachedDecrypter(3315454371400809920L).setKey(-2076237502208078445L);
    SimpleLongDecrypter.getCachedDecrypter(1316492889685849139L).setKey(-5737880269997715972L);
    SimpleLongDecrypter.getCachedDecrypter(5111616843167129751L).setKey(5899373372545921339L);
    SimpleLongDecrypter.getCachedDecrypter(-3595559118969416885L).setKey(-6139170789195146447L);
    SimpleLongDecrypter.getCachedDecrypter(-6445551366589165206L).setKey(-1640101401585321745L);
    SimpleLongDecrypter.getCachedDecrypter(-2943241419369006743L).setKey(-6211251045462673822L);
    SimpleLongDecrypter.getCachedDecrypter(-1012531264339766566L).setKey(-1049322541553168694L);
    SimpleLongDecrypter.getCachedDecrypter(6883934332300029145L).setKey(1114349125190704721L);
    SimpleLongDecrypter.getCachedDecrypter(5584346632402414911L).setKey(-6638834253137470466L);
    SimpleLongDecrypter.getCachedDecrypter(1198705319856703302L).setKey(-2191734325087437689L);
    SimpleLongDecrypter.getCachedDecrypter(6042384710216422090L).setKey(-8381353633310507771L);
    SimpleLongDecrypter.getCachedDecrypter(3829413250059701787L).setKey(-4550373095575492258L);
    SimpleLongDecrypter.getCachedDecrypter(5580548771575989930L).setKey(-6307096747631851975L);
    SimpleLongDecrypter.getCachedDecrypter(-7671653802781085729L).setKey(-5214744716131667110L);
    SimpleLongDecrypter.getCachedDecrypter(-2240276782565090493L).setKey(-6607564534407055112L);
    SimpleLongDecrypter.getCachedDecrypter(7779052061150154624L).setKey(4770669137824299151L);
    SimpleLongDecrypter.getCachedDecrypter(-5002614757201395872L).setKey(-6598687698648156962L);
    SimpleLongDecrypter.getCachedDecrypter(-2867996271547512227L).setKey(-621989907875470287L);
    SimpleLongDecrypter.getCachedDecrypter(4814983822345607297L).setKey(-2489325403665685877L);
    SimpleLongDecrypter.getCachedDecrypter(-1538425359130470117L).setKey(-6266738176815743288L);
    SimpleLongDecrypter.getCachedDecrypter(-2837430872233661467L).setKey(-5410860988866756132L);
    SimpleLongDecrypter.getCachedDecrypter(6055965200493727934L).setKey(-8462821203961056679L);
    SimpleLongDecrypter.getCachedDecrypter(6484064765142447236L).setKey(6804901791906664577L);
    SimpleLongDecrypter.getCachedDecrypter(-8190645262461289117L).setKey(-1963407436858537046L);
    SimpleLongDecrypter.getCachedDecrypter(2406596696449172214L).setKey(-985643827686692878L);
    SimpleLongDecrypter.getCachedDecrypter(-9056154723476004040L).setKey(-5726232558653387126L);
    SimpleLongDecrypter.getCachedDecrypter(-2107598248025900840L).setKey(8546894740449074329L);
    SimpleLongDecrypter.getCachedDecrypter(5266740183263860473L).setKey(9112118654538507691L);
    SimpleLongDecrypter.getCachedDecrypter(-892333751215425712L).setKey(5253864229585617348L);
    SimpleLongDecrypter.getCachedDecrypter(-8147550182700021940L).setKey(1299294403222677860L);
    SimpleLongDecrypter.getCachedDecrypter(-1968729250530162211L).setKey(-2222181796212020942L);
    SimpleLongDecrypter.getCachedDecrypter(-7932535582403543993L).setKey(-1252534455109952852L);
    SimpleLongDecrypter.getCachedDecrypter(-3892126986082344213L).setKey(3275069431704681555L);
    SimpleLongDecrypter.getCachedDecrypter(4251243239550924976L).setKey(-4513665685962431241L);
    SimpleLongDecrypter.getCachedDecrypter(-642033151859082796L).setKey(2651050370152292746L);
    SimpleLongDecrypter.getCachedDecrypter(415315151936728908L).setKey(-4530689833157361258L);
    SimpleLongDecrypter.getCachedDecrypter(-8010094591878376596L).setKey(-8314540288096538373L);
    SimpleLongDecrypter.getCachedDecrypter(-6495897737506491041L).setKey(6918894577687772701L);
    SimpleLongDecrypter.getCachedDecrypter(5372376503690963758L).setKey(2208648153930021203L);
    SimpleLongDecrypter.getCachedDecrypter(-7645610627583489116L).setKey(4628445478859391834L);
    SimpleLongDecrypter.getCachedDecrypter(3269529809244349803L).setKey(-4876290087543864081L);
    SimpleLongDecrypter.getCachedDecrypter(-37204427552335107L).setKey(-3142719334659145909L);
    SimpleLongDecrypter.getCachedDecrypter(-6040806314189547925L).setKey(-4865990232324236566L);
    SimpleLongDecrypter.getCachedDecrypter(7675146195856846604L).setKey(-2080627164077930941L);
    SimpleLongDecrypter.getCachedDecrypter(398102120137133019L).setKey(-2873311606105361289L);
    SimpleLongDecrypter.getCachedDecrypter(-3806464577250041273L).setKey(8491168847676349452L);
    SimpleLongDecrypter.getCachedDecrypter(7661276116089454445L).setKey(-1363103118541051961L);
    SimpleLongDecrypter.getCachedDecrypter(3397584987374255845L).setKey(-1765820890859871794L);
    SimpleLongDecrypter.getCachedDecrypter(7777427419119037848L).setKey(1300160272620655629L);
    SimpleLongDecrypter.getCachedDecrypter(-3906525082840791360L).setKey(4464779605887238040L);
    SimpleLongDecrypter.getCachedDecrypter(955281015914158794L).setKey(-7344594329389765432L);
    SimpleLongDecrypter.getCachedDecrypter(749590956133874242L).setKey(-5156721280392447243L);
    SimpleLongDecrypter.getCachedDecrypter(-5961426663642485422L).setKey(-5590801891477227995L);
    SimpleLongDecrypter.getCachedDecrypter(-6252145269190889916L).setKey(-4454304549074584345L);
    SimpleLongDecrypter.getCachedDecrypter(-4954757533396019772L).setKey(-3343146359994558966L);
    SimpleLongDecrypter.getCachedDecrypter(6256965994882655739L).setKey(8154830310614057204L);
    SimpleLongDecrypter.getCachedDecrypter(3760015457019158064L).setKey(2675830247427378773L);
    SimpleLongDecrypter.getCachedDecrypter(-2608616981890402048L).setKey(-2922334234575241964L);
    SimpleLongDecrypter.getCachedDecrypter(-4236102164045099706L).setKey(7742561456288244619L);
    SimpleLongDecrypter.getCachedDecrypter(-597792462106139550L).setKey(-8319615037958152274L);
    SimpleLongDecrypter.getCachedDecrypter(3991657142464524008L).setKey(-5590053123777413742L);
    SimpleLongDecrypter.getCachedDecrypter(4134654690053636642L).setKey(-6379972968543588278L);
    SimpleLongDecrypter.getCachedDecrypter(-2909246426743944322L).setKey(-3834607846215499291L);
    SimpleLongDecrypter.getCachedDecrypter(-8589223745034700491L).setKey(7401751780412120318L);
    SimpleLongDecrypter.getCachedDecrypter(-5628437939475001426L).setKey(6949512771973400190L);
    SimpleLongDecrypter.getCachedDecrypter(8710984293665548478L).setKey(-8634235507419297233L);
    SimpleLongDecrypter.getCachedDecrypter(6716875612784928142L).setKey(-5399493119191403590L);
    SimpleLongDecrypter.getCachedDecrypter(-566848259650697601L).setKey(2277463694162163620L);
    SimpleLongDecrypter.getCachedDecrypter(-602591965287236045L).setKey(1260584404485837872L);
    SimpleLongDecrypter.getCachedDecrypter(6242385216693367899L).setKey(185635739753116337L);
    SimpleLongDecrypter.getCachedDecrypter(330575738144736992L).setKey(-1087092466757057566L);
    SimpleLongDecrypter.getCachedDecrypter(7651316347172265014L).setKey(1894114916125614645L);
    SimpleLongDecrypter.getCachedDecrypter(4866964632314886762L).setKey(-2951367605500536627L);
    SimpleLongDecrypter.getCachedDecrypter(7937320738288559123L).setKey(-2756927978877737672L);
    SimpleLongDecrypter.getCachedDecrypter(-587758583295789741L).setKey(-7937468360997879629L);
    SimpleLongDecrypter.getCachedDecrypter(3542378535315750952L).setKey(-5332532847482275171L);
    SimpleLongDecrypter.getCachedDecrypter(-8298848418728381980L).setKey(7203461658237970706L);
    SimpleLongDecrypter.getCachedDecrypter(-1662694120635101571L).setKey(-8047156019218000279L);
    SimpleLongDecrypter.getCachedDecrypter(3763341423949443984L).setKey(2300238964129893792L);
    SimpleLongDecrypter.getCachedDecrypter(-1744911334347642295L).setKey(2685287631390235360L);
    SimpleLongDecrypter.getCachedDecrypter(-4689304783556081725L).setKey(5929853753479104590L);
    SimpleLongDecrypter.getCachedDecrypter(4090662571870670336L).setKey(-1234641030826436375L);
    SimpleLongDecrypter.getCachedDecrypter(-1971802150340939635L).setKey(-14447600298555928L);
    SimpleLongDecrypter.getCachedDecrypter(-54274335641992620L).setKey(3435495736813157018L);
    SimpleLongDecrypter.getCachedDecrypter(2120137561001043856L).setKey(-2820707503490860148L);
    SimpleLongDecrypter.getCachedDecrypter(3804031249402313589L).setKey(-4966828568429086039L);
    SimpleLongDecrypter.getCachedDecrypter(-2978971819670264400L).setKey(7447179998267996562L);
    SimpleLongDecrypter.getCachedDecrypter(-2038803231175744127L).setKey(1530265940127104086L);
    SimpleLongDecrypter.getCachedDecrypter(1495008889087404158L).setKey(595200802906910892L);
    SimpleLongDecrypter.getCachedDecrypter(-1950061458919298624L).setKey(-3627304072676128529L);
    SimpleLongDecrypter.getCachedDecrypter(3789912739111878568L).setKey(7065603038798785290L);
    SimpleLongDecrypter.getCachedDecrypter(-1486626576692757360L).setKey(7767547015246051834L);
    SimpleLongDecrypter.getCachedDecrypter(2245496100562721020L).setKey(-7189140836932820958L);
    SimpleLongDecrypter.getCachedDecrypter(-3181364827343897981L).setKey(2934104514364496455L);
    SimpleLongDecrypter.getCachedDecrypter(856500635572789803L).setKey(2199367706854401294L);
    SimpleLongDecrypter.getCachedDecrypter(5497013498675990192L).setKey(2588174324201663766L);
    SimpleLongDecrypter.getCachedDecrypter(1128262411030179762L).setKey(-7304061580076886339L);
    SimpleLongDecrypter.getCachedDecrypter(8122773022414216259L).setKey(-8007245786432572835L);
    SimpleLongDecrypter.getCachedDecrypter(8592769409979801722L).setKey(6499723106812302055L);
    SimpleLongDecrypter.getCachedDecrypter(-241854897694366608L).setKey(639292939385215489L);
    SimpleLongDecrypter.getCachedDecrypter(-1733053348472434571L).setKey(4157120812339086400L);
    SimpleLongDecrypter.getCachedDecrypter(5268320824483135330L).setKey(6067605238180638083L);
    SimpleLongDecrypter.getCachedDecrypter(-7186214577833489364L).setKey(-3023999882075887361L);
    SimpleLongDecrypter.getCachedDecrypter(-3556619928062883620L).setKey(5469895247559915662L);
    SimpleLongDecrypter.getCachedDecrypter(-5668831617674288975L).setKey(105749999064578529L);
    SimpleLongDecrypter.getCachedDecrypter(5893772860895439221L).setKey(4436426577319265131L);
    SimpleLongDecrypter.getCachedDecrypter(6304072879371605733L).setKey(-3894765066219410215L);
    SimpleLongDecrypter.getCachedDecrypter(-6051160415195052750L).setKey(7110606594618041507L);
    SimpleLongDecrypter.getCachedDecrypter(6126130976528193553L).setKey(-1396725269095269699L);
    SimpleLongDecrypter.getCachedDecrypter(4690298511117139841L).setKey(4920101411773697061L);
    SimpleLongDecrypter.getCachedDecrypter(-5251694554774426582L).setKey(-2900233069389954033L);
    SimpleLongDecrypter.getCachedDecrypter(5044740996485640695L).setKey(6302930642462123005L);
    SimpleLongDecrypter.getCachedDecrypter(-7586019719615305309L).setKey(-3035587052337338581L);
    SimpleLongDecrypter.getCachedDecrypter(-4770814469287483673L).setKey(-8576817287847052450L);
    SimpleLongDecrypter.getCachedDecrypter(-2317682633979033208L).setKey(-2925879401052869129L);
    SimpleLongDecrypter.getCachedDecrypter(-9140445872089012406L).setKey(-1020169110723157634L);
    SimpleLongDecrypter.getCachedDecrypter(8638316837300230104L).setKey(-2869548056564664141L);
    SimpleLongDecrypter.getCachedDecrypter(-5167936736486228439L).setKey(-4228257507110493496L);
    SimpleLongDecrypter.getCachedDecrypter(6947218096083059140L).setKey(6518484276766729088L);
    SimpleLongDecrypter.getCachedDecrypter(2017111720666987145L).setKey(-284647966141754159L);
    SimpleLongDecrypter.getCachedDecrypter(5913647287832290672L).setKey(4353506366500651439L);
    SimpleLongDecrypter.getCachedDecrypter(-2743268308318908159L).setKey(-6624371253997545347L);
    SimpleLongDecrypter.getCachedDecrypter(-4082126720590360935L).setKey(-6662966574358926132L);
    SimpleLongDecrypter.getCachedDecrypter(3305049217817676827L).setKey(-6336711509610130708L);
    SimpleLongDecrypter.getCachedDecrypter(-9198558790437272192L).setKey(1486003398254328858L);
    SimpleLongDecrypter.getCachedDecrypter(5953357397944166434L).setKey(8578278343129121643L);
    SimpleLongDecrypter.getCachedDecrypter(-7533426715686738127L).setKey(-3756117953890694239L);
    SimpleLongDecrypter.getCachedDecrypter(-51875987794828188L).setKey(-4865966888849358804L);
    SimpleLongDecrypter.getCachedDecrypter(1837671294879240583L).setKey(-2370067349594190746L);
    SimpleLongDecrypter.getCachedDecrypter(6840814958151878636L).setKey(-5301693731182205599L);
    SimpleLongDecrypter.getCachedDecrypter(-3789060690194674941L).setKey(429817484815155740L);
    SimpleLongDecrypter.getCachedDecrypter(-5928096187397421387L).setKey(5419859030269354265L);
    SimpleLongDecrypter.getCachedDecrypter(8891945437348017007L).setKey(-8798609612145917621L);
    SimpleLongDecrypter.getCachedDecrypter(5849600526398826329L).setKey(-4159109715422804124L);
    SimpleLongDecrypter.getCachedDecrypter(2948493695151940610L).setKey(3837681045411225610L);
    SimpleLongDecrypter.getCachedDecrypter(-1546242161654696729L).setKey(6860399724980070385L);
    SimpleLongDecrypter.getCachedDecrypter(2882308199117996547L).setKey(-4498622003880406932L);
    SimpleLongDecrypter.getCachedDecrypter(-7491277144070668828L).setKey(-5126467818388069650L);
    SimpleLongDecrypter.getCachedDecrypter(717785160301235437L).setKey(-634640425445191858L);
    SimpleLongDecrypter.getCachedDecrypter(-5162142312815836066L).setKey(5857627206246155088L);
    SimpleLongDecrypter.getCachedDecrypter(-5031800787753440527L).setKey(2389744542441105360L);
    SimpleLongDecrypter.getCachedDecrypter(611062557550598366L).setKey(2067998772011809260L);
    SimpleLongDecrypter.getCachedDecrypter(2558970025188074920L).setKey(4823144360773099260L);
    SimpleLongDecrypter.getCachedDecrypter(4362411102836279505L).setKey(3121163162843552290L);
    SimpleLongDecrypter.getCachedDecrypter(-5948684177822039098L).setKey(811346069038791757L);
    SimpleLongDecrypter.getCachedDecrypter(-760566240849364596L).setKey(3667690421917939889L);
    SimpleLongDecrypter.getCachedDecrypter(-6909007633623656612L).setKey(6795082471116292746L);
    SimpleLongDecrypter.getCachedDecrypter(-3033550607363021096L).setKey(1628320658179635059L);
    SimpleLongDecrypter.getCachedDecrypter(5914789162519913494L).setKey(-6978137722306864016L);
    SimpleLongDecrypter.getCachedDecrypter(5406677122819456009L).setKey(1055226352769427228L);
    SimpleLongDecrypter.getCachedDecrypter(7868189931546271338L).setKey(-3880966876376259225L);
    SimpleLongDecrypter.getCachedDecrypter(-6813493598614117117L).setKey(7476814549853477955L);
    SimpleLongDecrypter.getCachedDecrypter(3711619924839606911L).setKey(-819028013208924595L);
    SimpleLongDecrypter.getCachedDecrypter(-185131178344738613L).setKey(5593550412548954322L);
    SimpleLongDecrypter.getCachedDecrypter(-7388866273046936587L).setKey(5359179367723490834L);
    SimpleLongDecrypter.getCachedDecrypter(-8253421734874760378L).setKey(8633149810642229695L);
    SimpleLongDecrypter.getCachedDecrypter(-1599211414088593361L).setKey(5466820111494322347L);
    SimpleLongDecrypter.getCachedDecrypter(-2183233545181747833L).setKey(6923221178997719434L);
    SimpleLongDecrypter.getCachedDecrypter(1668929495518164951L).setKey(-6960420459916805972L);
    SimpleLongDecrypter.getCachedDecrypter(4876334548532233928L).setKey(-6578821453497150553L);
    SimpleLongDecrypter.getCachedDecrypter(3274754832447128004L).setKey(3462229742542465550L);
    SimpleLongDecrypter.getCachedDecrypter(7320182605808888699L).setKey(7612108489874554817L);
    SimpleLongDecrypter.getCachedDecrypter(-7897405531427644559L).setKey(-6643587073734500427L);
    SimpleLongDecrypter.getCachedDecrypter(413653754478157977L).setKey(-8770603152297678235L);
    SimpleLongDecrypter.getCachedDecrypter(-2005420147985705291L).setKey(1355387568958504753L);
    SimpleLongDecrypter.getCachedDecrypter(455893826387634948L).setKey(8214351191346464972L);
    SimpleLongDecrypter.getCachedDecrypter(6940382296312048360L).setKey(2471793860071929054L);
    SimpleLongDecrypter.getCachedDecrypter(5884114629437238563L).setKey(7746846327460307891L);
    SimpleLongDecrypter.getCachedDecrypter(8491064084511631256L).setKey(7697236750133335483L);
    SimpleLongDecrypter.getCachedDecrypter(-6365382536246912034L).setKey(-8057732091090859356L);
    SimpleLongDecrypter.getCachedDecrypter(420215948496617698L).setKey(-8737682015500875083L);
    SimpleLongDecrypter.getCachedDecrypter(-4897149433144873074L).setKey(842571276135161856L);
    SimpleLongDecrypter.getCachedDecrypter(386158679672263741L).setKey(397119188977774720L);
    SimpleLongDecrypter.getCachedDecrypter(2313166913398300288L).setKey(-2161415948348456959L);
    SimpleLongDecrypter.getCachedDecrypter(6202321625322073426L).setKey(4261170666551055054L);
    SimpleLongDecrypter.getCachedDecrypter(4106336659570727281L).setKey(-3148760909753064406L);
    SimpleLongDecrypter.getCachedDecrypter(-6347790921768268685L).setKey(-2703527024547768365L);
    SimpleLongDecrypter.getCachedDecrypter(-4389331465120073988L).setKey(7242693322384529193L);
    SimpleLongDecrypter.getCachedDecrypter(-5204314246522088924L).setKey(2632781471348758686L);
    SimpleLongDecrypter.getCachedDecrypter(1017181999152218294L).setKey(-7705564230108673348L);
    SimpleLongDecrypter.getCachedDecrypter(-4600798587676966292L).setKey(-4061583140941762139L);
    SimpleLongDecrypter.getCachedDecrypter(-3765459934618972033L).setKey(-4370078111691357779L);
    SimpleLongDecrypter.getCachedDecrypter(-8006877663536718095L).setKey(-3460881452391105471L);
    SimpleLongDecrypter.getCachedDecrypter(-6101296245294271603L).setKey(-5997177950266081333L);
    SimpleLongDecrypter.getCachedDecrypter(-731531853645894575L).setKey(-6973823396604465268L);
    SimpleLongDecrypter.getCachedDecrypter(-900107724889385090L).setKey(1193205883535050141L);
    SimpleLongDecrypter.getCachedDecrypter(5013437159090094233L).setKey(-7781958706548928924L);
    SimpleLongDecrypter.getCachedDecrypter(-5274600669965795752L).setKey(-5163394920496417957L);
    SimpleLongDecrypter.getCachedDecrypter(-2121874369992995338L).setKey(2587636963135609900L);
    SimpleLongDecrypter.getCachedDecrypter(-5149894015208051806L).setKey(-1488095263134796791L);
    SimpleLongDecrypter.getCachedDecrypter(4022403049666906218L).setKey(-276179664378351224L);
    SimpleLongDecrypter.getCachedDecrypter(-893775513798485023L).setKey(6591315769740417891L);
    SimpleLongDecrypter.getCachedDecrypter(-6413898647088967563L).setKey(2446873271126680139L);
    SimpleLongDecrypter.getCachedDecrypter(8500889573719934984L).setKey(3114864697991447344L);
    SimpleLongDecrypter.getCachedDecrypter(7267182188991616814L).setKey(5863352986232811243L);
    SimpleLongDecrypter.getCachedDecrypter(3777816292343773455L).setKey(-4821486503100686450L);
    SimpleLongDecrypter.getCachedDecrypter(-6436185749192412696L).setKey(3860839657224268173L);
    SimpleLongDecrypter.getCachedDecrypter(-7126455575374654462L).setKey(-2563485619342155383L);
    SimpleLongDecrypter.getCachedDecrypter(4196975987355435355L).setKey(-1364572508088848524L);
    SimpleLongDecrypter.getCachedDecrypter(-9071026837027443539L).setKey(-2442445380102741126L);
    SimpleLongDecrypter.getCachedDecrypter(-4280001669528869152L).setKey(2450410294175115771L);
    SimpleLongDecrypter.getCachedDecrypter(8824381760203443822L).setKey(-3815417255638540878L);
    SimpleLongDecrypter.getCachedDecrypter(-2688419009570052472L).setKey(-307047291103654398L);
    SimpleLongDecrypter.getCachedDecrypter(8872821901195285798L).setKey(718178856647839514L);
    SimpleLongDecrypter.getCachedDecrypter(-4897076623611467821L).setKey(2238697582924838706L);
    SimpleLongDecrypter.getCachedDecrypter(-3324571085235939454L).setKey(-5770828877075770552L);
    SimpleLongDecrypter.getCachedDecrypter(652305573840333516L).setKey(-574007488664284274L);
    SimpleLongDecrypter.getCachedDecrypter(6707450491604212227L).setKey(-7348634067806574601L);
    SimpleLongDecrypter.getCachedDecrypter(6402566760800990077L).setKey(8232295366636614692L);
    SimpleLongDecrypter.getCachedDecrypter(7711175235262995910L).setKey(249124836571229189L);
    SimpleLongDecrypter.getCachedDecrypter(-6100840827237031940L).setKey(-4646174993821191410L);
    SimpleLongDecrypter.getCachedDecrypter(6783169575792474639L).setKey(-6612703330378100657L);
    SimpleLongDecrypter.getCachedDecrypter(8193857294834806805L).setKey(-4211935010919498972L);
    SimpleLongDecrypter.getCachedDecrypter(5181293789635363920L).setKey(429898984167927647L);
    SimpleLongDecrypter.getCachedDecrypter(-4736592581247816059L).setKey(-5506753267669041206L);
    SimpleLongDecrypter.getCachedDecrypter(4923771132459878080L).setKey(-9094319159911319715L);
    SimpleLongDecrypter.getCachedDecrypter(2457905243342298839L).setKey(3857065532561539350L);
    SimpleLongDecrypter.getCachedDecrypter(-8458160537531761820L).setKey(9008630312686034666L);
    SimpleLongDecrypter.getCachedDecrypter(4618729532457684023L).setKey(-5988956113418689419L);
    SimpleLongDecrypter.getCachedDecrypter(1609838011809989281L).setKey(7753171229498699477L);
    SimpleLongDecrypter.getCachedDecrypter(2748496700715697926L).setKey(5201852808960737079L);
    SimpleLongDecrypter.getCachedDecrypter(5491214405021640559L).setKey(-5126034447245468444L);
    SimpleLongDecrypter.getCachedDecrypter(-1701487458332743043L).setKey(-7251549815234552162L);
    SimpleLongDecrypter.getCachedDecrypter(5998897843352736296L).setKey(-3113639689350831957L);
    SimpleLongDecrypter.getCachedDecrypter(3196410194778895115L).setKey(-2566195776815887016L);
    SimpleLongDecrypter.getCachedDecrypter(3737512854036883898L).setKey(-206361844622563477L);
    SimpleLongDecrypter.getCachedDecrypter(-3352859811030974947L).setKey(-5717296933770767307L);
    SimpleLongDecrypter.getCachedDecrypter(2664081661595480920L).setKey(166409595955460372L);
    SimpleLongDecrypter.getCachedDecrypter(1929880685907837519L).setKey(2190230529123420698L);
    SimpleLongDecrypter.getCachedDecrypter(-5154516635430469907L).setKey(-2795543653173782875L);
    SimpleLongDecrypter.getCachedDecrypter(799200985811726986L).setKey(4124022597066877007L);
    SimpleLongDecrypter.getCachedDecrypter(-7663553625145467027L).setKey(3984526474381155458L);
    SimpleLongDecrypter.getCachedDecrypter(-1360655356446310059L).setKey(-9093085253353222819L);
    SimpleLongDecrypter.getCachedDecrypter(8083090964652709516L).setKey(-7531012476757400213L);
    SimpleLongDecrypter.getCachedDecrypter(-8951727645611382812L).setKey(1463991362279509143L);
    SimpleLongDecrypter.getCachedDecrypter(-6289141032444157326L).setKey(3895136509288684822L);
    SimpleLongDecrypter.getCachedDecrypter(-4330966255085041132L).setKey(-4350294097569351608L);
    SimpleLongDecrypter.getCachedDecrypter(-3487985760470266056L).setKey(1852338934608791218L);
    SimpleLongDecrypter.getCachedDecrypter(-7330075403075699371L).setKey(4763704090336719211L);
    SimpleLongDecrypter.getCachedDecrypter(8382169118643269928L).setKey(6555524929838862180L);
    SimpleLongDecrypter.getCachedDecrypter(-5919562744626009859L).setKey(-7631141537620769819L);
    SimpleLongDecrypter.getCachedDecrypter(8596291334148453940L).setKey(-2196512663887672711L);
    SimpleLongDecrypter.getCachedDecrypter(-5268163279264779867L).setKey(-6289870468119963705L);
    SimpleLongDecrypter.getCachedDecrypter(1026362650192175885L).setKey(-5393736153410286447L);
    SimpleLongDecrypter.getCachedDecrypter(-2764279569106608746L).setKey(8616171018464929493L);
    SimpleLongDecrypter.getCachedDecrypter(4453594825022336419L).setKey(1602584325525972860L);
    SimpleLongDecrypter.getCachedDecrypter(3580382886114258684L).setKey(2071793850771490429L);
    SimpleLongDecrypter.getCachedDecrypter(-7700329352544669844L).setKey(3045823075355838067L);
    SimpleLongDecrypter.getCachedDecrypter(-1232754668506224863L).setKey(4913921563269305731L);
    SimpleLongDecrypter.getCachedDecrypter(-3122758807885464843L).setKey(3101498021477928215L);
    SimpleLongDecrypter.getCachedDecrypter(-9095280698318813681L).setKey(7719322854070770065L);
    SimpleLongDecrypter.getCachedDecrypter(-3498136622045571882L).setKey(-8363180630371904277L);
    SimpleLongDecrypter.getCachedDecrypter(7326284501684051221L).setKey(-7257700210429865916L);
    SimpleLongDecrypter.getCachedDecrypter(2358813272724861342L).setKey(2252054580100691715L);
    SimpleLongDecrypter.getCachedDecrypter(917532565416539413L).setKey(3116392849540194074L);
    SimpleLongDecrypter.getCachedDecrypter(-5770742069574921397L).setKey(-5982759053740624018L);
    SimpleLongDecrypter.getCachedDecrypter(-7898304784371278785L).setKey(4431348565232437695L);
    SimpleLongDecrypter.getCachedDecrypter(-1877150923514028673L).setKey(6601616114667625122L);
    SimpleLongDecrypter.getCachedDecrypter(6225185426217013346L).setKey(-175534991239328883L);
    SimpleLongDecrypter.getCachedDecrypter(-650430940106130784L).setKey(2844845946706592200L);
    SimpleLongDecrypter.getCachedDecrypter(-6050284908092325435L).setKey(-3833732460044662498L);
    SimpleLongDecrypter.getCachedDecrypter(-6249287041835270385L).setKey(2546869727262358069L);
    SimpleLongDecrypter.getCachedDecrypter(-5376361755904073600L).setKey(-6076440923681701297L);
    SimpleLongDecrypter.getCachedDecrypter(3176774993056743615L).setKey(-2560056802921230357L);
    SimpleLongDecrypter.getCachedDecrypter(978639459001417489L).setKey(4337629884835129872L);
    SimpleLongDecrypter.getCachedDecrypter(5064378093808939719L).setKey(-9125057481825053927L);
    SimpleLongDecrypter.getCachedDecrypter(8713071119374277964L).setKey(4188165761838968472L);
    SimpleLongDecrypter.getCachedDecrypter(-862583909264672472L).setKey(6343950937858601668L);
    SimpleLongDecrypter.getCachedDecrypter(2056833191576366719L).setKey(-4546179581049390270L);
    SimpleLongDecrypter.getCachedDecrypter(5226139452508097668L).setKey(4349327256227677603L);
    SimpleLongDecrypter.getCachedDecrypter(-4219126260279223747L).setKey(-536821055911090384L);
    SimpleLongDecrypter.getCachedDecrypter(-8123323547205325229L).setKey(-8032591965634445630L);
    SimpleLongDecrypter.getCachedDecrypter(2927166064297796573L).setKey(1381723258968344605L);
    SimpleLongDecrypter.getCachedDecrypter(7417231285970171106L).setKey(-3326877580937229440L);
    SimpleLongDecrypter.getCachedDecrypter(-4871330148844828069L).setKey(-3925247735220758153L);
    SimpleLongDecrypter.getCachedDecrypter(-7535131701160853021L).setKey(-64502161832848246L);
    SimpleLongDecrypter.getCachedDecrypter(1060220066315536679L).setKey(8541424803806302985L);
    SimpleLongDecrypter.getCachedDecrypter(6907809498557368332L).setKey(-8654904731482561181L);
    SimpleLongDecrypter.getCachedDecrypter(-5842994152465547152L).setKey(-7990662853054559508L);
    SimpleLongDecrypter.getCachedDecrypter(3389889936173000238L).setKey(-7901171385786255026L);
    SimpleLongDecrypter.getCachedDecrypter(-4172734170532876980L).setKey(2725761342630293517L);
    SimpleLongDecrypter.getCachedDecrypter(-5593995064605328718L).setKey(3006735400726606176L);
    SimpleLongDecrypter.getCachedDecrypter(8375715512348596198L).setKey(5067885141457528931L);
    SimpleLongDecrypter.getCachedDecrypter(-6323965717576739717L).setKey(-4644833729253615916L);
    SimpleLongDecrypter.getCachedDecrypter(4660031888504896246L).setKey(7110607157340209157L);
    SimpleLongDecrypter.getCachedDecrypter(1224482564325245692L).setKey(7982149838646422877L);
    SimpleLongDecrypter.getCachedDecrypter(2360516979010055924L).setKey(5737855166165243046L);
    SimpleLongDecrypter.getCachedDecrypter(362265361392110998L).setKey(-2045571349818506672L);
    SimpleLongDecrypter.getCachedDecrypter(5033746275278070164L).setKey(3523466436597801744L);
    SimpleLongDecrypter.getCachedDecrypter(8350554435376235900L).setKey(-3911639778537508253L);
    SimpleLongDecrypter.getCachedDecrypter(7082218559398527116L).setKey(7564563838328698088L);
    SimpleLongDecrypter.getCachedDecrypter(3129169178928551240L).setKey(-6034361231954734053L);
    SimpleLongDecrypter.getCachedDecrypter(-707642074323957257L).setKey(5100890388571979431L);
    SimpleLongDecrypter.getCachedDecrypter(8300344862672381220L).setKey(4915855810788722645L);
    SimpleLongDecrypter.getCachedDecrypter(-5988460743099673452L).setKey(177888698188078770L);
    SimpleLongDecrypter.getCachedDecrypter(6769108488956382383L).setKey(-6725263733007920920L);
    SimpleLongDecrypter.getCachedDecrypter(8186744980426079816L).setKey(-7773303179903619932L);
    SimpleLongDecrypter.getCachedDecrypter(-8647362592828831795L).setKey(-5745373497539891572L);
    SimpleLongDecrypter.getCachedDecrypter(492073941031103402L).setKey(-2960574691291962526L);
    SimpleLongDecrypter.getCachedDecrypter(7986351134723507055L).setKey(9039891883575880509L);
    SimpleLongDecrypter.getCachedDecrypter(4149040134723093756L).setKey(-7039819542354203643L);
    SimpleLongDecrypter.getCachedDecrypter(918426473096169097L).setKey(-2264041077346007602L);
    SimpleLongDecrypter.getCachedDecrypter(994461542773235386L).setKey(-7203669272075104346L);
    SimpleLongDecrypter.getCachedDecrypter(-1991326655726891784L).setKey(922851437824726667L);
    SimpleLongDecrypter.getCachedDecrypter(7424753166148703825L).setKey(1052972455906525997L);
    SimpleLongDecrypter.getCachedDecrypter(-3057644509013766173L).setKey(7198641492167523353L);
    SimpleLongDecrypter.getCachedDecrypter(4359748640065118078L).setKey(-1007703401592246130L);
    SimpleLongDecrypter.getCachedDecrypter(5570562965845464892L).setKey(7366330975989651943L);
    SimpleLongDecrypter.getCachedDecrypter(-3424548085217808455L).setKey(2187301903547812239L);
    SimpleLongDecrypter.getCachedDecrypter(2025727644253104044L).setKey(2362011689123508508L);
    SimpleLongDecrypter.getCachedDecrypter(1263367589936605610L).setKey(-2201498212416399154L);
    SimpleLongDecrypter.getCachedDecrypter(5313009679448178992L).setKey(-4076961260393409077L);
    SimpleLongDecrypter.getCachedDecrypter(-6847847579771860371L).setKey(-5359375180695294864L);
    SimpleLongDecrypter.getCachedDecrypter(3243346448756854361L).setKey(-7951873105106577768L);
    SimpleLongDecrypter.getCachedDecrypter(-7804409484136253031L).setKey(-1576563815809810883L);
    SimpleLongDecrypter.getCachedDecrypter(-8450462863602601119L).setKey(-9175851599049551003L);
    SimpleLongDecrypter.getCachedDecrypter(-3949493404071716294L).setKey(8877301357454737063L);
    SimpleLongDecrypter.getCachedDecrypter(3555453552829350838L).setKey(-8582467805704001624L);
    SimpleLongDecrypter.getCachedDecrypter(367250953362381429L).setKey(7094849020331800658L);
    SimpleLongDecrypter.getCachedDecrypter(-861722796855349083L).setKey(621784809139661089L);
    SimpleLongDecrypter.getCachedDecrypter(-5576707416219798740L).setKey(611937246028451309L);
    SimpleLongDecrypter.getCachedDecrypter(-8787858764970498911L).setKey(5617552893354136326L);
    SimpleLongDecrypter.getCachedDecrypter(-2323196702624753119L).setKey(-2695745506857051507L);
    SimpleLongDecrypter.getCachedDecrypter(-3289919044707090041L).setKey(2588644977451219931L);
    SimpleLongDecrypter.getCachedDecrypter(-1214458122420883869L).setKey(-8593633965092513608L);
    SimpleLongDecrypter.getCachedDecrypter(4373089856916075417L).setKey(-6783215496556853542L);
    SimpleLongDecrypter.getCachedDecrypter(-6362317841811686202L).setKey(9053284708285870481L);
    SimpleLongDecrypter.getCachedDecrypter(-3007427731057653650L).setKey(-7046692600337839071L);
    SimpleLongDecrypter.getCachedDecrypter(6776759583582749115L).setKey(-6769724629529713774L);
    SimpleLongDecrypter.getCachedDecrypter(2349619461715005678L).setKey(4757246756352781298L);
    SimpleLongDecrypter.getCachedDecrypter(822299911746843501L).setKey(5642472617979082701L);
    SimpleLongDecrypter.getCachedDecrypter(5078808099577228785L).setKey(8580670843900329251L);
    SimpleLongDecrypter.getCachedDecrypter(-6298035116828856274L).setKey(-1283012870997980289L);
    SimpleLongDecrypter.getCachedDecrypter(4098068719554372971L).setKey(-1946673857107374284L);
    SimpleLongDecrypter.getCachedDecrypter(-2471215842368993132L).setKey(215207927052330858L);
    SimpleLongDecrypter.getCachedDecrypter(3428172310302726127L).setKey(172481747950909334L);
    SimpleLongDecrypter.getCachedDecrypter(6557475839076774522L).setKey(-1526057587566382053L);
    SimpleLongDecrypter.getCachedDecrypter(-7132094723362857701L).setKey(-4300275875877932260L);
    SimpleLongDecrypter.getCachedDecrypter(-7102233086899395794L).setKey(-3810529204714733234L);
    SimpleLongDecrypter.getCachedDecrypter(-7381275533524641279L).setKey(-9162560404738011075L);
    SimpleLongDecrypter.getCachedDecrypter(6418831398611790986L).setKey(1750172206472201666L);
    SimpleLongDecrypter.getCachedDecrypter(-8141350835250056350L).setKey(8547960061479336257L);
    SimpleLongDecrypter.getCachedDecrypter(-6870946559844852647L).setKey(-3289632609881920217L);
    SimpleLongDecrypter.getCachedDecrypter(-7994667500232684965L).setKey(-5790518332800810484L);
    SimpleLongDecrypter.getCachedDecrypter(-7353071623406468895L).setKey(-6146673071820693803L);
    SimpleLongDecrypter.getCachedDecrypter(-1870191573704831687L).setKey(-8655929008489272683L);
    SimpleLongDecrypter.getCachedDecrypter(-4680960856854853015L).setKey(-7834105367818196866L);
    SimpleLongDecrypter.getCachedDecrypter(375977074568480927L).setKey(-1922616547444543174L);
    SimpleLongDecrypter.getCachedDecrypter(6872063409797026971L).setKey(-7686660496854421323L);
    SimpleLongDecrypter.getCachedDecrypter(4325051788648895141L).setKey(774893277547560946L);
    SimpleLongDecrypter.getCachedDecrypter(-1986007720022140939L).setKey(-1479429444252840756L);
    SimpleLongDecrypter.getCachedDecrypter(6388764356715848656L).setKey(-8154060425926609958L);
    SimpleLongDecrypter.getCachedDecrypter(7403072602376795447L).setKey(-1562289131801205685L);
    SimpleLongDecrypter.getCachedDecrypter(-1146500178410583104L).setKey(986249951487666577L);
    SimpleLongDecrypter.getCachedDecrypter(2083415165270862999L).setKey(-9145235207588742533L);
    SimpleLongDecrypter.getCachedDecrypter(6321402722370748333L).setKey(-2530447328847696630L);
    SimpleLongDecrypter.getCachedDecrypter(-2138218446784547859L).setKey(5152904579663278779L);
    SimpleLongDecrypter.getCachedDecrypter(-1751399135095035123L).setKey(13329038953495628L);
    SimpleLongDecrypter.getCachedDecrypter(-194604483594180437L).setKey(7065343370371690398L);
    SimpleLongDecrypter.getCachedDecrypter(-6362390901655755534L).setKey(-5836180932284073244L);
    SimpleLongDecrypter.getCachedDecrypter(-7576476698081821219L).setKey(790213657527089784L);
    SimpleLongDecrypter.getCachedDecrypter(9048443632000766606L).setKey(6103143462042810549L);
    SimpleLongDecrypter.getCachedDecrypter(-5948306178234228827L).setKey(6356923478485036575L);
    SimpleLongDecrypter.getCachedDecrypter(2664489603700127362L).setKey(2966706000174515527L);
    SimpleLongDecrypter.getCachedDecrypter(-4550588855114347200L).setKey(8089334297007289703L);
    SimpleLongDecrypter.getCachedDecrypter(-5775623932827148492L).setKey(5094830093982045976L);
    SimpleLongDecrypter.getCachedDecrypter(-2082751378577749716L).setKey(3133380304848603582L);
    SimpleLongDecrypter.getCachedDecrypter(2940955351595983565L).setKey(6622798369385967538L);
    SimpleLongDecrypter.getCachedDecrypter(-5230072533020612L).setKey(581488690406756540L);
    SimpleLongDecrypter.getCachedDecrypter(7727544237389338611L).setKey(-4807162878808199879L);
    SimpleLongDecrypter.getCachedDecrypter(5655106520868222724L).setKey(5359051459974258357L);
    SimpleLongDecrypter.getCachedDecrypter(-8539042863237242655L).setKey(-467931936093795071L);
    SimpleLongDecrypter.getCachedDecrypter(4634348842218560120L).setKey(-8388383135834612767L);
    SimpleLongDecrypter.getCachedDecrypter(-336151990825660718L).setKey(-9160866698189432164L);
    SimpleLongDecrypter.getCachedDecrypter(3118003085068781438L).setKey(-6652082915582718831L);
    SimpleLongDecrypter.getCachedDecrypter(6593130657862128843L).setKey(4220466644162738862L);
    SimpleLongDecrypter.getCachedDecrypter(-5097505609372512699L).setKey(-4475322644695677598L);
    SimpleLongDecrypter.getCachedDecrypter(-26151009252047922L).setKey(-6342439351815859821L);
    SimpleLongDecrypter.getCachedDecrypter(-2414218366838061445L).setKey(-1054798261842982349L);
    SimpleLongDecrypter.getCachedDecrypter(-1954126639340292275L).setKey(-5807854081426495390L);
    SimpleLongDecrypter.getCachedDecrypter(-2450418469488162715L).setKey(4749851399054684144L);
    SimpleLongDecrypter.getCachedDecrypter(8494057223504917992L).setKey(-8983358854238878642L);
    SimpleLongDecrypter.getCachedDecrypter(-7099369642594785500L).setKey(6806782536259129908L);
    SimpleLongDecrypter.getCachedDecrypter(1213428117484910161L).setKey(-2526079466603430406L);
    SimpleLongDecrypter.getCachedDecrypter(656502379481362740L).setKey(-23973193044302647L);
    SimpleLongDecrypter.getCachedDecrypter(-5379989664911524539L).setKey(7253437521272748693L);
    SimpleLongDecrypter.getCachedDecrypter(2109424774274999694L).setKey(-654084882881947394L);
    SimpleLongDecrypter.getCachedDecrypter(1656775201369542852L).setKey(7376118618899621719L);
    SimpleLongDecrypter.getCachedDecrypter(2895769906212068808L).setKey(-8902341036420585049L);
    SimpleLongDecrypter.getCachedDecrypter(-5971664491523402994L).setKey(6695276133647621877L);
    SimpleLongDecrypter.getCachedDecrypter(-2825294847573518310L).setKey(-2498043241549853160L);
    SimpleLongDecrypter.getCachedDecrypter(5868460551426961405L).setKey(-5651704495206085788L);
    SimpleLongDecrypter.getCachedDecrypter(-806400613321713321L).setKey(4458981674992263869L);
    SimpleLongDecrypter.getCachedDecrypter(-1571203275492425526L).setKey(3368530668718658963L);
    SimpleLongDecrypter.getCachedDecrypter(265528001809317608L).setKey(7509978497984847407L);
    SimpleLongDecrypter.getCachedDecrypter(-3785729980710635834L).setKey(-7655611345591695910L);
    SimpleLongDecrypter.getCachedDecrypter(106207520010754531L).setKey(1348758773322919527L);
    SimpleLongDecrypter.getCachedDecrypter(-6905731520122639365L).setKey(4528033971353918479L);
    SimpleLongDecrypter.getCachedDecrypter(2440636502615079141L).setKey(8215704094656918231L);
    SimpleLongDecrypter.getCachedDecrypter(-6914720426922674437L).setKey(1978648429245968574L);
    SimpleLongDecrypter.getCachedDecrypter(8566067423206059560L).setKey(-3384330999593719789L);
    SimpleLongDecrypter.getCachedDecrypter(1089044605105780301L).setKey(-4423310800212054738L);
    SimpleLongDecrypter.getCachedDecrypter(-593768666353731021L).setKey(3636749136470130970L);
    SimpleLongDecrypter.getCachedDecrypter(5977874030105518174L).setKey(-859474184110103867L);
    SimpleLongDecrypter.getCachedDecrypter(-8715956570448372114L).setKey(-9206790441059166897L);
    SimpleLongDecrypter.getCachedDecrypter(5015862706763628661L).setKey(-1130865381568533958L);
    SimpleLongDecrypter.getCachedDecrypter(8193992252089386651L).setKey(-8728279057864470300L);
    SimpleLongDecrypter.getCachedDecrypter(-3764588836150471018L).setKey(-5768459697334357801L);
    SimpleLongDecrypter.getCachedDecrypter(5064955628400515001L).setKey(7001712733250076423L);
    SimpleLongDecrypter.getCachedDecrypter(8648964367771283618L).setKey(6602199251936516758L);
    SimpleLongDecrypter.getCachedDecrypter(6357001899310304033L).setKey(-1128089780052481983L);
    SimpleLongDecrypter.getCachedDecrypter(-7918425005393848456L).setKey(-8477764632535571416L);
    SimpleLongDecrypter.getCachedDecrypter(-3197390439242461510L).setKey(496691292057916554L);
    SimpleLongDecrypter.getCachedDecrypter(453765050745408300L).setKey(-9148108324050348872L);
    SimpleLongDecrypter.getCachedDecrypter(2879597216884382900L).setKey(-7509608719287235088L);
    SimpleLongDecrypter.getCachedDecrypter(-8312720471368364722L).setKey(1035432882821567295L);
    SimpleLongDecrypter.getCachedDecrypter(1706251781471798691L).setKey(-1086329251805077873L);
    SimpleLongDecrypter.getCachedDecrypter(-8405649913739541805L).setKey(-1139354863823855724L);
    SimpleLongDecrypter.getCachedDecrypter(8227938531355997297L).setKey(6378870115601543486L);
    SimpleLongDecrypter.getCachedDecrypter(-6133862115766592368L).setKey(4300921921775208245L);
    SimpleLongDecrypter.getCachedDecrypter(-6299391959664752446L).setKey(-6665445914380875350L);
    SimpleLongDecrypter.getCachedDecrypter(4119974474652787577L).setKey(-838120544011461937L);
    SimpleLongDecrypter.getCachedDecrypter(-6717204154762285300L).setKey(-2527100640149442901L);
    SimpleLongDecrypter.getCachedDecrypter(-8488667204906468484L).setKey(-3173963450502147142L);
    SimpleLongDecrypter.getCachedDecrypter(5508662973033243710L).setKey(5430560830471712661L);
    SimpleLongDecrypter.getCachedDecrypter(-8276094369109373086L).setKey(-8308384084670578722L);
    SimpleLongDecrypter.getCachedDecrypter(-6523359723011215851L).setKey(6910602667427279508L);
    SimpleLongDecrypter.getCachedDecrypter(-6064645259651469467L).setKey(-343309974779493526L);
    SimpleLongDecrypter.getCachedDecrypter(4966626710162651231L).setKey(7525353270610693651L);
    SimpleLongDecrypter.getCachedDecrypter(6293781382777347846L).setKey(-2859195357233722076L);
    SimpleLongDecrypter.getCachedDecrypter(-1012728491105509795L).setKey(2604540533260174502L);
    SimpleLongDecrypter.getCachedDecrypter(2455971612979440871L).setKey(9196381209102216809L);
    SimpleLongDecrypter.getCachedDecrypter(3116252946552437385L).setKey(6185827855448121703L);
    SimpleLongDecrypter.getCachedDecrypter(7765671148256739120L).setKey(2085592461173799535L);
    SimpleLongDecrypter.getCachedDecrypter(-170190473036596903L).setKey(-6028171953760447644L);
    SimpleLongDecrypter.getCachedDecrypter(-329238252061915374L).setKey(-5152547605851661954L);
    SimpleLongDecrypter.getCachedDecrypter(1943445694919430546L).setKey(1551769333556553333L);
    SimpleLongDecrypter.getCachedDecrypter(7081110147733176870L).setKey(5210869904582309836L);
    SimpleLongDecrypter.getCachedDecrypter(3978192691019863456L).setKey(196291424567782151L);
    SimpleLongDecrypter.getCachedDecrypter(-7419588245660337261L).setKey(-2755206005805992845L);
    SimpleLongDecrypter.getCachedDecrypter(-8431801021916376128L).setKey(8835157582527638481L);
    SimpleLongDecrypter.getCachedDecrypter(-6083165683820045081L).setKey(-8477712005283392715L);
    SimpleLongDecrypter.getCachedDecrypter(-6286404657444500459L).setKey(3195113866463392446L);
    SimpleLongDecrypter.getCachedDecrypter(7915526612333515110L).setKey(-1763011767468464730L);
    SimpleLongDecrypter.getCachedDecrypter(-6403586731775554178L).setKey(4185920428768053335L);
    SimpleLongDecrypter.getCachedDecrypter(4830078056494577938L).setKey(-6937075970279810737L);
    SimpleLongDecrypter.getCachedDecrypter(-3731430447993999527L).setKey(820963792004167362L);
    SimpleLongDecrypter.getCachedDecrypter(3281889532633868384L).setKey(7920964553424175755L);
    SimpleLongDecrypter.getCachedDecrypter(-925405030357799201L).setKey(-1309892682148785705L);
    SimpleLongDecrypter.getCachedDecrypter(-3029676514099400778L).setKey(548588352309432649L);
    SimpleLongDecrypter.getCachedDecrypter(-7501975910394902195L).setKey(8909338628148797786L);
    SimpleLongDecrypter.getCachedDecrypter(-7046241411021596043L).setKey(5319831256616051324L);
    SimpleLongDecrypter.getCachedDecrypter(-1770211908355745699L).setKey(-3198829876910996080L);
    SimpleLongDecrypter.getCachedDecrypter(7822062523281386540L).setKey(-1921950133806912052L);
    SimpleLongDecrypter.getCachedDecrypter(-5727521813618612548L).setKey(3054744305109293929L);
    SimpleLongDecrypter.getCachedDecrypter(4248497720293141279L).setKey(-797154221092399190L);
    SimpleLongDecrypter.getCachedDecrypter(-8368750914042761907L).setKey(9198180186224531630L);
    SimpleLongDecrypter.getCachedDecrypter(-3892123633536449193L).setKey(4863587134180006340L);
    SimpleLongDecrypter.getCachedDecrypter(8931522526161290923L).setKey(8561956717588959664L);
    SimpleLongDecrypter.getCachedDecrypter(-7950843592296749619L).setKey(736584526065997287L);
    SimpleLongDecrypter.getCachedDecrypter(-7908749306474674355L).setKey(-5335754524134814302L);
    SimpleLongDecrypter.getCachedDecrypter(8715733604819387593L).setKey(-8342390212695523798L);
    SimpleLongDecrypter.getCachedDecrypter(8587033287877706852L).setKey(-2710986785572715618L);
    SimpleLongDecrypter.getCachedDecrypter(-8828354033574433299L).setKey(3045828722473519626L);
    SimpleLongDecrypter.getCachedDecrypter(5750069388872755462L).setKey(6455080667351368403L);
    SimpleLongDecrypter.getCachedDecrypter(5911914670065936119L).setKey(-2807843261285066957L);
    SimpleLongDecrypter.getCachedDecrypter(-573477846487688903L).setKey(3890763785047867684L);
    SimpleLongDecrypter.getCachedDecrypter(1006479777789591839L).setKey(5443920390240649855L);
    SimpleLongDecrypter.getCachedDecrypter(-4119081505367320772L).setKey(-4275986266355747663L);
    SimpleLongDecrypter.getCachedDecrypter(-1887816211576534106L).setKey(-8690336269425706366L);
    SimpleLongDecrypter.getCachedDecrypter(2463301214826180439L).setKey(-5978132334723271455L);
    SimpleLongDecrypter.getCachedDecrypter(7111172057326609500L).setKey(8283277641315435323L);
    SimpleLongDecrypter.getCachedDecrypter(8766516853355131553L).setKey(-5212615444661332500L);
    SimpleLongDecrypter.getCachedDecrypter(5007249271847878662L).setKey(4441058969809918814L);
    SimpleLongDecrypter.getCachedDecrypter(-2970224626053022582L).setKey(382468668618750812L);
    SimpleLongDecrypter.getCachedDecrypter(-6677864814110756572L).setKey(2634770701616011444L);
    SimpleLongDecrypter.getCachedDecrypter(-6468547514026659306L).setKey(-7483038940864269757L);
    SimpleLongDecrypter.getCachedDecrypter(4682114190257787074L).setKey(-3853930675500381844L);
    SimpleLongDecrypter.getCachedDecrypter(-7833867237202226012L).setKey(-7805054304443169406L);
    SimpleLongDecrypter.getCachedDecrypter(4065260625511080882L).setKey(2607565472043212781L);
    SimpleLongDecrypter.getCachedDecrypter(7381032708487706369L).setKey(-3307969758850074938L);
    SimpleLongDecrypter.getCachedDecrypter(-3693553917105884630L).setKey(8269035842430493222L);
    SimpleLongDecrypter.getCachedDecrypter(-5053855578154580963L).setKey(-9209456472212049901L);
    SimpleLongDecrypter.getCachedDecrypter(-8511740574553855311L).setKey(7626466928877406653L);
    SimpleLongDecrypter.getCachedDecrypter(-7030342841381777723L).setKey(4989304533179679779L);
    SimpleLongDecrypter.getCachedDecrypter(3049693997601364838L).setKey(-2728911337724846130L);
    SimpleLongDecrypter.getCachedDecrypter(6016720464274110477L).setKey(-3718570006758994421L);
    SimpleLongDecrypter.getCachedDecrypter(6607476815559966932L).setKey(1674674256278021346L);
    SimpleLongDecrypter.getCachedDecrypter(1659632463936122267L).setKey(-6028775072294208885L);
    SimpleLongDecrypter.getCachedDecrypter(9205178327112664738L).setKey(2828182715083374010L);
    SimpleLongDecrypter.getCachedDecrypter(5493974790065734179L).setKey(-4952256888137280445L);
    SimpleLongDecrypter.getCachedDecrypter(4563874623434792125L).setKey(3883593514574278015L);
    SimpleLongDecrypter.getCachedDecrypter(-3256781516088119066L).setKey(1046532627320018821L);
    SimpleLongDecrypter.getCachedDecrypter(-1703746318022928778L).setKey(6994390224590131533L);
    SimpleLongDecrypter.getCachedDecrypter(8021859996962349944L).setKey(-1710920235439451988L);
    SimpleLongDecrypter.getCachedDecrypter(7851906839640367136L).setKey(-6933090428636989806L);
    SimpleLongDecrypter.getCachedDecrypter(9146855521411231959L).setKey(-947141584394396019L);
    SimpleLongDecrypter.getCachedDecrypter(-6266526246208461588L).setKey(1896917789148514587L);
    SimpleLongDecrypter.getCachedDecrypter(-2634713338843476531L).setKey(-7564602321956382779L);
    SimpleLongDecrypter.getCachedDecrypter(1929417923347365335L).setKey(8668079526748943650L);
    SimpleLongDecrypter.getCachedDecrypter(7196554171251666961L).setKey(-9089781471319680879L);
    SimpleLongDecrypter.getCachedDecrypter(-8717681974270813991L).setKey(-3265343286584338063L);
    SimpleLongDecrypter.getCachedDecrypter(5267054240807804926L).setKey(-7089863342401363671L);
    SimpleLongDecrypter.getCachedDecrypter(4707897738583609470L).setKey(-2750788856158894324L);
    SimpleLongDecrypter.getCachedDecrypter(-7709930666906625223L).setKey(-1650526389745103420L);
    SimpleLongDecrypter.getCachedDecrypter(5905889154830265453L).setKey(237260303989193977L);
    SimpleLongDecrypter.getCachedDecrypter(3460151430415803962L).setKey(7642628922853677331L);
    SimpleLongDecrypter.getCachedDecrypter(-5939205707035017166L).setKey(5182597777721676552L);
    SimpleLongDecrypter.getCachedDecrypter(7285685552597440122L).setKey(1892829306320380231L);
    SimpleLongDecrypter.getCachedDecrypter(-3087201396555530845L).setKey(3566289274759081939L);
    SimpleLongDecrypter.getCachedDecrypter(-2490265037597102566L).setKey(8933241049614026732L);
    SimpleLongDecrypter.getCachedDecrypter(6980846888997431969L).setKey(-567876113101377144L);
    SimpleLongDecrypter.getCachedDecrypter(6190821854749685534L).setKey(-8040677173311116835L);
    SimpleLongDecrypter.getCachedDecrypter(-4405129645094521677L).setKey(-2887391755369636841L);
    SimpleLongDecrypter.getCachedDecrypter(7336307638418133231L).setKey(-6473882355853138286L);
    SimpleLongDecrypter.getCachedDecrypter(1874325847388226783L).setKey(1007420570430200111L);
    SimpleLongDecrypter.getCachedDecrypter(-4783698781976891290L).setKey(758583846430267473L);
    SimpleLongDecrypter.getCachedDecrypter(-1665972668430910098L).setKey(-4293806176322383134L);
    SimpleLongDecrypter.getCachedDecrypter(495098579136551352L).setKey(6224929804663930405L);
    SimpleLongDecrypter.getCachedDecrypter(-919119802568830338L).setKey(-2376801067349665794L);
    SimpleLongDecrypter.getCachedDecrypter(7749703759857619959L).setKey(6813289184461950761L);
    SimpleLongDecrypter.getCachedDecrypter(1259293678681579173L).setKey(1402077429350663750L);
    SimpleLongDecrypter.getCachedDecrypter(10164190594098712L).setKey(3075400069898983901L);
    SimpleLongDecrypter.getCachedDecrypter(-4365145361755017210L).setKey(994628177040218192L);
    SimpleLongDecrypter.getCachedDecrypter(3390297568724184548L).setKey(41133437954504029L);
    SimpleLongDecrypter.getCachedDecrypter(5939055243760649417L).setKey(-8073664214695975741L);
    SimpleLongDecrypter.getCachedDecrypter(7614959749509304846L).setKey(-4872151556109024669L);
    SimpleLongDecrypter.getCachedDecrypter(-6246301343662307796L).setKey(-5896045735105115428L);
    SimpleLongDecrypter.getCachedDecrypter(-502442767605432475L).setKey(9122623449697960567L);
    SimpleLongDecrypter.getCachedDecrypter(6913996058601856951L).setKey(-1046524016562795440L);
    SimpleLongDecrypter.getCachedDecrypter(7920044364316957656L).setKey(149149251719098L);
    SimpleLongDecrypter.getCachedDecrypter(4091755288223162947L).setKey(5370539085744521437L);
    SimpleLongDecrypter.getCachedDecrypter(-515102505523155032L).setKey(3346669255090789240L);
    SimpleLongDecrypter.getCachedDecrypter(-8510472735147589712L).setKey(-6620110965156152965L);
    SimpleLongDecrypter.getCachedDecrypter(-5863539490158554661L).setKey(-8062037173391033474L);
    SimpleLongDecrypter.getCachedDecrypter(279491603758981652L).setKey(8188932406645186994L);
    SimpleLongDecrypter.getCachedDecrypter(6420021044833676295L).setKey(-8892081383469690292L);
    SimpleLongDecrypter.getCachedDecrypter(-7247434981751642018L).setKey(6497894257268704660L);
    SimpleLongDecrypter.getCachedDecrypter(-2746737735500034432L).setKey(2023029321312539996L);
    SimpleLongDecrypter.getCachedDecrypter(-4411585450060311107L).setKey(-2395944436243451981L);
    SimpleLongDecrypter.getCachedDecrypter(4400822799529157884L).setKey(1518027621284775535L);
    SimpleLongDecrypter.getCachedDecrypter(521707303394311365L).setKey(-1090248997130827260L);
    SimpleLongDecrypter.getCachedDecrypter(-1495726078563747913L).setKey(-9168756470984436693L);
    SimpleLongDecrypter.getCachedDecrypter(9187242807485593421L).setKey(2841775112782332214L);
    SimpleLongDecrypter.getCachedDecrypter(1673531541003005216L).setKey(2770736231055946631L);
    SimpleLongDecrypter.getCachedDecrypter(-4658300631227020072L).setKey(4978217767710511810L);
    SimpleLongDecrypter.getCachedDecrypter(-8098841699793767446L).setKey(5135592621622192944L);
    SimpleLongDecrypter.getCachedDecrypter(708368412006428006L).setKey(-8076732008785057043L);
    SimpleLongDecrypter.getCachedDecrypter(-7766668879875710190L).setKey(9123276767897055760L);
    SimpleLongDecrypter.getCachedDecrypter(8185645699486834072L).setKey(-921796621909573690L);
    SimpleLongDecrypter.getCachedDecrypter(-6634611569088503473L).setKey(1273690064716978536L);
    SimpleLongDecrypter.getCachedDecrypter(-6064768685997403317L).setKey(3939873926154255231L);
    SimpleLongDecrypter.getCachedDecrypter(-6611050873022000886L).setKey(1062877532315001433L);
    SimpleLongDecrypter.getCachedDecrypter(5758095442847240859L).setKey(4228487879271911410L);
    SimpleLongDecrypter.getCachedDecrypter(-884463287223078285L).setKey(2732430753959814186L);
    SimpleLongDecrypter.getCachedDecrypter(-589124203805027830L).setKey(-1022169198424312226L);
    SimpleLongDecrypter.getCachedDecrypter(-4655080943977004869L).setKey(-7653386684158221370L);
    SimpleLongDecrypter.getCachedDecrypter(-6526426113441039477L).setKey(-4004406200112090729L);
    SimpleLongDecrypter.getCachedDecrypter(770300017324614433L).setKey(2394010596344569549L);
    SimpleLongDecrypter.getCachedDecrypter(-1452656857693835301L).setKey(-7009068804071027772L);
    SimpleLongDecrypter.getCachedDecrypter(8401291156133336194L).setKey(-1401277406778547145L);
    SimpleLongDecrypter.getCachedDecrypter(-2828994187155729992L).setKey(-6443659150115479215L);
    SimpleLongDecrypter.getCachedDecrypter(-2011207011691712171L).setKey(-5213110272021443841L);
    SimpleLongDecrypter.getCachedDecrypter(2249856036124374452L).setKey(-6466860308165086807L);
    SimpleLongDecrypter.getCachedDecrypter(-7788938133524324498L).setKey(-6510221282562183413L);
    SimpleLongDecrypter.getCachedDecrypter(-5037185314123298401L).setKey(-5867528906693354927L);
    SimpleLongDecrypter.getCachedDecrypter(-1510948281590230502L).setKey(-8810096153482675633L);
    SimpleLongDecrypter.getCachedDecrypter(-7953219069237534698L).setKey(-832087038260698569L);
    SimpleLongDecrypter.getCachedDecrypter(-5155769274561546825L).setKey(-9171620653086226781L);
    SimpleLongDecrypter.getCachedDecrypter(-8209233629414814093L).setKey(-4491446445201861054L);
    SimpleLongDecrypter.getCachedDecrypter(1873196361262979007L).setKey(2367876954210595670L);
    SimpleLongDecrypter.getCachedDecrypter(-6579992968194807292L).setKey(1252913376633408873L);
    SimpleLongDecrypter.getCachedDecrypter(3961228563351972257L).setKey(-2861010341863799338L);
    SimpleLongDecrypter.getCachedDecrypter(-6116510587883646345L).setKey(-6837045282328287360L);
    SimpleLongDecrypter.getCachedDecrypter(-8297314815878062721L).setKey(7536309672331118079L);
    SimpleLongDecrypter.getCachedDecrypter(221113465814046912L).setKey(8416883923450760579L);
    SimpleLongDecrypter.getCachedDecrypter(7831123476562198820L).setKey(-5904738713013686836L);
    SimpleLongDecrypter.getCachedDecrypter(-5895272869755827768L).setKey(-8094665961859083805L);
    SimpleLongDecrypter.getCachedDecrypter(-358417461369493472L).setKey(-3517249009717202705L);
    SimpleLongDecrypter.getCachedDecrypter(-9164886757153534423L).setKey(1483680207747198236L);
    SimpleLongDecrypter.getCachedDecrypter(828930249830574562L).setKey(-4163834166761764900L);
    SimpleLongDecrypter.getCachedDecrypter(-1611910275418673458L).setKey(5296784550766968308L);
    SimpleLongDecrypter.getCachedDecrypter(339455154128939797L).setKey(3976093753246211601L);
    SimpleLongDecrypter.getCachedDecrypter(1365850457509950242L).setKey(2528000663314167470L);
    SimpleLongDecrypter.getCachedDecrypter(3787563210672871404L).setKey(-3054374952671945811L);
    SimpleLongDecrypter.getCachedDecrypter(-8639495167870452613L).setKey(-2369748414057014889L);
    SimpleLongDecrypter.getCachedDecrypter(4027215804921189334L).setKey(6279712721592966777L);
    SimpleLongDecrypter.getCachedDecrypter(3816700499520252794L).setKey(-5764733992549575860L);
    SimpleLongDecrypter.getCachedDecrypter(3418441750776435956L).setKey(-1063743065491247355L);
    SimpleLongDecrypter.getCachedDecrypter(-6607417528701499188L).setKey(-1174225231474707632L);
    SimpleLongDecrypter.getCachedDecrypter(-5839839812561808002L).setKey(5439398639199504395L);
    SimpleLongDecrypter.getCachedDecrypter(2884238535187981327L).setKey(-5868859234765545497L);
    SimpleLongDecrypter.getCachedDecrypter(-3696843822982333622L).setKey(-2886834358066980064L);
    SimpleLongDecrypter.getCachedDecrypter(5670249299290208544L).setKey(3013209532430044874L);
    SimpleLongDecrypter.getCachedDecrypter(8811730880608265670L).setKey(5231615948755850720L);
    SimpleLongDecrypter.getCachedDecrypter(9202347175859624348L).setKey(-6085275304804190434L);
    SimpleLongDecrypter.getCachedDecrypter(336390099385265504L).setKey(5966516958914412992L);
    SimpleLongDecrypter.getCachedDecrypter(-6999808076375415881L).setKey(-6961627622093704208L);
    SimpleLongDecrypter.getCachedDecrypter(-256558241295338890L).setKey(-5384220675547382066L);
    SimpleLongDecrypter.getCachedDecrypter(-6227151522745369905L).setKey(-1589625752524654915L);
    SimpleLongDecrypter.getCachedDecrypter(3175356676296263538L).setKey(-4709713544117095182L);
    SimpleLongDecrypter.getCachedDecrypter(-5491001464638784589L).setKey(1892723519919731278L);
    SimpleLongDecrypter.getCachedDecrypter(-3012433699890572474L).setKey(-8863801455278188208L);
    SimpleLongDecrypter.getCachedDecrypter(2853940824374390846L).setKey(719252433805748483L);
    SimpleLongDecrypter.getCachedDecrypter(3265561080342553744L).setKey(8753792381432326896L);
    SimpleLongDecrypter.getCachedDecrypter(-3863578664240812589L).setKey(7341564670325068361L);
    SimpleLongDecrypter.getCachedDecrypter(-8884740845746451614L).setKey(-4143342915404388063L);
    SimpleLongDecrypter.getCachedDecrypter(6351557484240604597L).setKey(3022359029747746628L);
    SimpleLongDecrypter.getCachedDecrypter(-7344061005315844306L).setKey(-2464345426878493919L);
    SimpleLongDecrypter.getCachedDecrypter(344181794462886863L).setKey(8252087999822629597L);
    SimpleLongDecrypter.getCachedDecrypter(6216305797600623986L).setKey(-2881897218492304972L);
    SimpleLongDecrypter.getCachedDecrypter(-593559873880319887L).setKey(400771775912075042L);
  }
}

```

`reverse-engineering/src/main/java/zelix/longdecrypter/ILongDecrypter.java`:

```java
package zelix.longdecrypter;

public interface ILongDecrypter {
  void setChild(ILongDecrypter parent);

  int[] getEncryptionInts();

  long decrypt(long decryptKey);

  void setKey(long key);

  boolean lessThanOrEqual(ILongDecrypter other);
}

```

`reverse-engineering/src/main/java/zelix/longdecrypter/Main.java`:

```java
package zelix.longdecrypter;

import java.lang.invoke.MethodHandles;

public class Main {
  // Usage

  public static void main(String[] args) {
    // decrypterA must be decrypted first for decrypterB to be decrypted correctly. So there is specific decryption order:
    // decrypterA -> decrypterB
    ILongDecrypter decrypterA = SimpleLongDecrypter.buildNumberDecryptor(273921918217628048L, -8431841081763909460L, MethodHandles.lookup().lookupClass());
    System.out.println(decrypterA);
    long a = decrypterA.decrypt(36730249601911L);
    System.out.println(a);

    ILongDecrypter decrypterB = SimpleLongDecrypter.buildNumberDecryptor(-5385547845782035026L, 2563870759759473543L, MethodHandles.lookup().lookupClass());
    System.out.println(decrypterB);
    long b = decrypterB.decrypt(130571778689313L);
    System.out.println(b);
  }
}

```

`reverse-engineering/src/main/java/zelix/longdecrypter/SimpleLongDecrypter.java`:

```java
package zelix.longdecrypter;

import java.util.ArrayList;
import java.util.Vector;

public class SimpleLongDecrypter implements ILongDecrypter {
  private long inputKey;
  private int[] encryptionInts;
  private ILongDecrypter child;
  private long key;
  private long[] longNumberPool;
  // It holds all 64 powers of two: 1, 2, 4, 8, 16, 32, 64, 128, 256...
  private static long[] POWERS_OF_TWO = new long[64];
  static int[] mutableEncryptionInts;
  private static ArrayList<ILongDecrypter> cachedLongDecrypters;
  private static Vector<Class<?>> lookupClasses;
  private static int cachedDecryptorsSize;
  private static Object someObject;
  private static int CONST_52 = 52;
  private static int CONST_128 = 128;
  private static int CONST_17 = 17;

  public static Object getSomeObject() {
    return someObject;
  }

  // a
  public static ILongDecrypter buildNumberDecryptor(long mainKey, long fallbackKey, Class<?> lookupClass) {
    FallbackLongDecrypter.a(mainKey > 0L); // ??
    ILongDecrypter mainDecrypter = createNumberDecryptor(mainKey);
    ILongDecrypter fallbackDecrypter = createNumberDecryptor(fallbackKey);
    ILongDecrypter var7 = FallbackLongDecrypter.getPairStatic(mainDecrypter, fallbackDecrypter);
    if (lookupClass != null) {
      // Unused
      lookupClasses.add(lookupClass);
    }

    return var7;
  }

  static ILongDecrypter getCachedDecrypter(long key) {
    int index = (int) decryptNumber(key, CONST_52, 63, mutableEncryptionInts, POWERS_OF_TWO);
    if (index < cachedDecryptorsSize) {
      return cachedLongDecrypters.get(index);
    } else {
      if (cachedLongDecrypters.size() % CONST_128 == 0) {
        mutableEncryptionInts = mutableEncryptionInts.clone();
      }

      SimpleLongDecrypter var3 = new SimpleLongDecrypter(key);
      cachedLongDecrypters.add(var3);
      return var3;
    }
  }

  private static ILongDecrypter createNumberDecryptor(long key) {
    return new SimpleLongDecrypter(key);
  }

  static void initSharedDecrypter(FallbackLongDecrypter sharedDecrypter) {
    cachedDecryptorsSize = cachedLongDecrypters.size();
    sort();
    sharedDecrypter.init();
  }

  static void initEncryptionData(FallbackLongDecrypter sharedDecrypter) {
    sort();
    int[] var10000 = mutableEncryptionInts = new int[64];
    var10000[0] = -21;
    var10000[1] = -18;
    var10000[2] = -31;
    var10000[3] = -38;
    var10000[4] = -14;
    var10000[5] = -15;
    var10000[6] = -7;
    var10000[7] = -7;
    var10000[8] = -26;
    var10000[9] = -13;
    var10000[10] = -45;
    var10000[11] = -36;
    var10000[12] = -36;
    var10000[13] = 7;
    var10000[14] = 7;
    var10000[15] = -8;
    var10000[16] = -43;
    var10000[17] = -39;
    var10000[18] = 14;
    var10000[19] = 18;
    var10000[20] = 15;
    var10000[21] = 21;
    var10000[22] = 13;
    var10000[23] = 8;
    var10000[24] = -15;
    var10000[25] = -12;
    var10000[26] = -14;
    var10000[27] = -5;
    var10000[28] = -10;
    var10000[29] = -33;
    var10000[30] = -15;
    var10000[31] = -23;
    var10000[32] = 5;
    var10000[33] = 31;
    var10000[34] = 26;
    var10000[35] = -25;
    var10000[36] = -27;
    var10000[37] = 12;
    var10000[38] = 10;
    var10000[39] = 15;
    var10000[40] = 14;
    var10000[41] = 38;
    var10000[42] = -9;
    var10000[43] = -18;
    var10000[44] = -6;
    var10000[45] = 15;
    var10000[46] = -12;
    var10000[47] = 36;
    var10000[48] = 36;
    var10000[49] = -3;
    var10000[50] = 6;
    var10000[51] = 9;
    var10000[52] = 3;
    var10000[53] = -4;
    var10000[54] = 23;
    var10000[55] = 45;
    var10000[56] = 39;
    var10000[57] = 4;
    var10000[58] = 12;
    var10000[59] = 43;
    var10000[60] = 25;
    var10000[61] = 18;
    var10000[62] = 33;
    var10000[63] = 27;
    sharedDecrypter.prepareCachedDecrypters();
  }

  private SimpleLongDecrypter(long inputKey) {
    this.inputKey = inputKey;
    this.encryptionInts = mutableEncryptionInts;
    this.longNumberPool = POWERS_OF_TWO;
  }

  // a
  @Override
  public long decrypt(long decryptKey) {
    long var3 = this.decryptNumberUsingThisKey(8, 55);
    // Generate new input key
    long var5 = this.inputKey ^ decryptKey ^ this.key;
    this.inputKey = var5;

    if (this.child != null) {
      // Update input key of children accordingly
      System.out.println("child: "+ child);
      this.child.decrypt(decryptKey);
    }

    return var3;
  }

  @Override
  public void setKey(long key) {
    this.key = key;
  }

  /**
   * Set child that will be decrypted AFTER this decrypter being decrypted
   */
  @Override
  public void setChild(ILongDecrypter child) {
    if (this != child) {
      if (this.child == null) {
        this.child = child;
      } else {
        this.child.setChild(child);
      }
    }
  }

  @Override
  public int hashCode() {
    return (int)this.hashCodeFromDecrypted(8);
  }

  @Override
  public boolean equals(Object var1) {
    if (this == var1) {
      return true;
    } else {
      return var1 instanceof SimpleLongDecrypter ? this.hashCodeFromDecrypted(56) == ((SimpleLongDecrypter)var1).hashCodeFromDecrypted(56) : false;
    }
  }

  @Override
  public boolean lessThanOrEqual(ILongDecrypter other) {
    if (this == other) {
      return true;
    } else {
      if (other instanceof SimpleLongDecrypter) {
        long thisLong = this.decryptNumberUsingThisKey(56, 63);
        long otherLong = ((SimpleLongDecrypter) other).decryptNumberUsingThisKey(56, 63);
        long diff = thisLong - otherLong;
        return diff <= 0L;
      } else {
        return true;
      }
    }
  }

  @Override
  public int[] getEncryptionInts() {
    return this.encryptionInts;
  }

  private long hashCodeFromDecrypted(int var1) {
    return this.decryptNumberUsingThisKey(0, var1 - 1);
  }

  private long decryptNumberUsingThisKey(int skipRightShift, int skipLeftShift) {
    return decryptNumber(this.inputKey, skipRightShift, skipLeftShift, this.encryptionInts, this.longNumberPool);
  }

  private static long decryptNumber(long key, int rightShiftSkip, int leftShiftSkip, int[] encryptionInts, long[] unusedArray) {
    long var6 = 0L;
    int length = encryptionInts.length; // Always 64 length

    for (int i = 0; i < length; i++) {
      // We can also represent "POWERS_OF_TWO" in binary form like this:
      // 1, 10, 100, 1000, 10000, 100000... and it holds 64 of them

      long powerOfTwo = key & POWERS_OF_TWO[i];
      long encryptionInt = encryptionInts[i];
      if (powerOfTwo != 0L) {
        if (encryptionInt > 0) {
          powerOfTwo >>>= encryptionInt;
        } else if (encryptionInt < 0) {
          powerOfTwo <<= ~encryptionInt + 1;
        }

        var6 |= powerOfTwo;
      }
    }

    byte arrayLength = 64; // = encryptionInts.length
    long result = var6;
    int leftShiftAmount = arrayLength - 1 - leftShiftSkip;
    if (leftShiftAmount > 0) {
      result = var6 << leftShiftAmount;
    }

    long rightShiftAmount = rightShiftSkip + arrayLength - 1 - leftShiftSkip;
    if (rightShiftAmount > 0) {
      result >>>= rightShiftAmount;
    }

    return result;
  }

  /**
   * Sorts long decrypters ascending using merge sort algorithm. It sorts by the return value of {@code decrypter.decryptNumber(56, 63)}
   */
  private static void sort() {
    byte var0 = 0;
    sort(0, cachedLongDecrypters.size() - 1, cachedLongDecrypters, new ArrayList<>(cachedLongDecrypters), var0);
  }

  private static void sort(int startIdx, int endIdx, ArrayList<ILongDecrypter> mutableLongDecrypters, ArrayList<ILongDecrypter> longDecryptersClone, int iteration) {
    if (startIdx < endIdx) {
      int middlePoint = startIdx + (endIdx - startIdx) / 2;
      if (++iteration < CONST_17) {
        sort(startIdx, middlePoint, mutableLongDecrypters, longDecryptersClone, iteration);
        sort(middlePoint + 1, endIdx, mutableLongDecrypters, longDecryptersClone, iteration);
      }

      merge(startIdx, middlePoint, endIdx, mutableLongDecrypters, longDecryptersClone);
    }
  }

  private static void merge(int startIdx, int middlePoint, int endIdx, ArrayList<ILongDecrypter> mutableLongDecrypters, ArrayList<ILongDecrypter> longDecryptersClone) {
    int currentIdxFromStart = startIdx;
    int currentIdxFromHalf = middlePoint + 1;

    for (int i = startIdx; i <= endIdx; i++) {
      longDecryptersClone.set(i, mutableLongDecrypters.get(i));
    }

    while (currentIdxFromStart <= middlePoint && currentIdxFromHalf <= endIdx) {
      ILongDecrypter var8;
      ILongDecrypter decrypterFromStart = longDecryptersClone.get(currentIdxFromStart);
      ILongDecrypter decrypterFromMiddle = longDecryptersClone.get(currentIdxFromHalf);
      if (decrypterFromStart.lessThanOrEqual(decrypterFromMiddle)) {
        var8 = longDecryptersClone.get(currentIdxFromStart++); // Smaller
      } else {
        var8 = longDecryptersClone.get(currentIdxFromHalf++); // Smaller
      }

      mutableLongDecrypters.set(startIdx, var8);
      startIdx++;
    }

    while (currentIdxFromStart <= middlePoint) {
      mutableLongDecrypters.set(startIdx, longDecryptersClone.get(currentIdxFromStart));
      startIdx++;
      currentIdxFromStart++;
    }
  }

  static {
    long currentBit = 1L;

    // Generate
    for (int i = 0; i < 64; i++) {
      POWERS_OF_TWO[i] = currentBit;
      currentBit <<= 1;
    }

    someObject = new Object();
    lookupClasses = new Vector();
    cachedLongDecrypters = new ArrayList();
    initLongDecryptors();
    cachedDecryptorsSize = cachedLongDecrypters.size();
    sort();
  }

  private static void initLongDecryptors() {
    mutableEncryptionInts = new int[]{
        -47,
        -29,
        -20,
        -12,
        -58,
        -11,
        -32,
        -48,
        -16,
        -31,
        -27,
        -34,
        -32,
        -26,
        -27,
        12,
        11,
        -26,
        -32,
        -4,
        -37,
        -42,
        20,
        4,
        16,
        -28,
        -7,
        -4,
        -24,
        -32,
        29,
        4,
        -10,
        7,
        -26,
        -13,
        -10,
        27,
        32,
        26,
        31,
        27,
        10,
        26,
        32,
        34,
        10,
        47,
        13,
        -5,
        32,
        -8,
        24,
        28,
        5,
        48,
        -2,
        37,
        2,
        8,
        26,
        32,
        58,
        42
    };
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6744423634385984943L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6706934200393210049L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6990400485665549342L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8478105918229553425L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4523791493794833373L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6956550957728802162L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6378052640071885957L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8115039236204621966L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3404969271164910260L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6837460718211466928L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(909643428573496924L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2853620746374076905L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7558632103745708878L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4451995920286813933L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2987343977142760299L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8774831055784385353L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2491703159784603645L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3825761391279259103L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8103271119208899000L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3751748464649851844L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4655894350249038690L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2299116995506572841L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4248253892470355672L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(673339327068868620L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(928988291849119595L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4494707613054168802L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8219881982464703334L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1592580442844519725L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6521590094206246995L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7862763716460523474L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7180250963500505561L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1990481056537250245L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4259418252620178920L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(115230540288189211L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-260614310560079233L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4560237432271780805L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5488233296441099736L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6602289711462896865L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6238345315009356580L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4887668945434071164L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7080207893442515422L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4442284130421016109L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8540532653575655206L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4153213651530454446L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4650655848889566882L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8172887638636256619L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(285257623463465760L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2212661351872423105L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8955014614648852638L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7685371999257522432L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7480559610018095299L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7645975422665949738L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8502689991448483739L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4027701581277325167L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1632673887745594740L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6478213330387212258L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5284458860625299893L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4188699928120191279L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1672758662401941534L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5269287403847926315L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6948122180030299767L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7605450297947617089L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8309140045178447544L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5320132290067212846L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4793472161571137674L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(335755845515907412L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8229858481322148701L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-481794707622686634L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6395100604994942360L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6119572320851432877L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2184643316460692798L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8981503674350135997L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7656732516946638003L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5635213181667554701L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1151223719834730898L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-611382292272610294L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7885244854120664817L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1657074236485762147L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5902840883215474855L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6615869915130831983L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3088267513636873593L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3461658328266714253L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6629250593412551926L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1996215071285581834L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5002744937498769605L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6355238420635454613L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5181722811629877386L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6883115128543829165L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6088188338395302712L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2611888656600445821L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4646520290036149891L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4378219892565776629L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8976129125876155436L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8363523088435887098L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(86840831297761602L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7787591308013543461L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3469387858000844866L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5233032057401438375L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9118749419407424250L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8500163652186440446L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3757520509916313379L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4116244975720934845L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6178501944032822413L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9153356831469675727L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1063398336654163675L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(770696137606370564L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8186032946492650175L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1593212751750682921L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5956464615920267193L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8015458933371737043L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5554639710744978350L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3650944509352886554L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3169510854341612216L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1828008516145470950L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6789118416236927168L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4762700133102726812L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8878911884416891471L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8664621867198439947L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8916388788512143153L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4412593360637248002L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6927240979754877261L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1216636158766706064L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7497317701947733992L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5868253207908670304L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8271568981229458725L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1582435105153641742L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1003193982455307812L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3744940415362494952L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8057241827569097198L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8160938211100963327L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5426810931933071203L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3484536533526790993L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8909305946017264730L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-607288752669276128L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1500707136245063922L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1112894094489036189L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2186260659538304726L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8497316323465943560L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2378738370292703073L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4256453459033539335L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7399179070313343094L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4994067841559076140L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(565607164416017254L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4047108070709861516L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1857416293356308444L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4048018357712373000L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5197029575525773668L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3547717426064585430L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4760024407670384218L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(313069990748533254L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5348539643686660003L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7272107145001041857L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4615823146970798776L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6802957569116356865L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(109198422163880778L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(719550753215290476L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(663070648437475965L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7982366021878349477L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3154350453178068187L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7079747071937835226L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4852688329732284852L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(6924729867076140072L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1319055387195296970L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1110718098836545406L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5184487272089418201L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1209929019013289676L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3934943933646132417L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6612345466967366939L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7983784829243525038L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3465473421090667983L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4955069875975476330L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1222738085821493094L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7274631535676754294L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3605167428510276924L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7321401848686268006L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8537181269155846398L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7036010071487345011L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6469190484441503783L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(358554658493788272L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4801186158922092356L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2025941902864584272L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5046251421333692002L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4346213119371418670L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1952490212279718209L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(388904733011491916L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8032609794616146291L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5947827916444804545L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1529830667070193801L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6425974338071218780L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3889257601660206246L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3534689640069068320L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6044722655579239339L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4849810454304746038L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5622382021455524496L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2019625191226615731L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4709691165499111106L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1792484731624864873L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7281842097693247804L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-60290756861186714L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6474293750210062665L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1393182141334933255L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4414579491870249421L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4841279960438382325L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2662755756897883207L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-333062117895070857L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7651854756009155114L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6649917936615431635L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2215331531862059131L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4626100401364144631L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8597788376328339537L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5419944576110703776L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1647514364380703233L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4913700706030770261L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2972229743455703418L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7097384657830585849L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5866054288827446814L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2635971902479150421L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1234291004083169172L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6296365828022667262L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6198154523778839226L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7280882661630946318L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1163246228181812916L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8058917293246814304L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2555097195074984218L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5238458381956505444L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5274531756641706705L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4778378953595314612L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5443240005591331681L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1922697014945020873L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-758164801927635189L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3750102876210478271L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(922384580518357556L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5346287844412991411L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6937062962655216499L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5479188277678227209L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6355320449421308357L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(773272052063831344L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2250951039312121397L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7509361718814825052L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1064803118799081080L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8090526503937156583L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4660199197585511367L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4990315584293803368L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1929101553301683300L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3706831602997022299L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3244945072854826617L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6721406422293792749L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-376202964417428685L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3020618294975159574L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2524768609197567760L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5106164513165795732L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-673701620128658570L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3032839098405056378L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8157567941448647257L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2322221287690188288L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-933042621612592580L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8699774343065680999L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2037709077370185054L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-25683838325834428L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2092240939937505885L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1775291314990744973L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1636075790375377310L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1936241699616714117L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5777575772619753739L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4442815237220284737L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1360860040086278686L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3844824520896299857L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8075846110590462860L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6750562378065394424L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2071856796292556699L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7645975440382689850L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1973643837185670230L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6596323918647719115L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5505711763130324890L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-590881294597069820L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5149094331846857342L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6649986424440623541L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-475936916104918188L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5164782238865553122L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8366919996635922256L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3160648661163137486L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-880428123426138517L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4425756912056562425L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4887734184666877140L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6240037117283760480L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1690480913210458466L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3491202511124849912L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8799598494005851568L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7322312843080944694L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6842343091803594885L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4600781611143661320L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2501933747265243007L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(157513467097159432L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-51397667266540032L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5197404301377746114L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5561856049065377315L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6847457923712613988L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(690810815984985962L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6910462901404226130L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9066171932773458292L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2979620315348532580L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(966601938649563477L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1979829244037265369L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6138508966444145039L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7285017837801602088L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5337906342982701542L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5698217665490279274L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6279771978459474340L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(306438502956140149L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6022601678053684299L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6247038219811084434L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3485642966629178362L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-280204998506807255L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(811953170445661739L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6676356884277843262L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4203274232037917986L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6218698579016947227L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9062922882051374362L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7392999613859714256L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1951270258536690178L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6475368503852093309L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6094943361180325249L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8238626769688455661L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8491508749498464741L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1755966378406569721L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8524881805879043193L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-628980067508333726L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7553595808090830267L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3401088427898417385L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8148495414709501776L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2391241009525101111L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-846777915758294233L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-757066702853567984L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7858483658340044671L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8765913414195489930L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1071410693439370419L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6937867782310580346L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4951001095487041465L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7185266059361506062L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2748102153912659494L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4738100879865434414L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3145300095240542486L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6535859322297191350L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4507200759147770011L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1740123166599572719L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9219816827940516490L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(591935923207441183L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6931212079319678924L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1927951755889431824L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1018125983805817356L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1713219551072842643L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1993225270065169106L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1497482565846420089L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8419134277282359775L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1016119785387431222L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7860660830204724684L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8223057368263223413L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3672232568321311139L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8928735346180880288L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5703536978811697351L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4373616876358252673L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5496240696206782572L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8911596651907001674L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8466133811519483080L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7036095350088556279L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6439300964726081222L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7559953241327815772L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8509983995108710244L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8126543840463541282L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4679530916572832059L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3315415731403675506L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6563689203004965384L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6399952368373559232L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6970545074926306033L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9206226304900513604L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4183589437500349814L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(704930295637337170L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6291063742149989843L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6861793193461154999L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5213481917054572740L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6202798052391301836L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5227330657153389860L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7861980581239952747L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6411638694933490114L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7218582584421862135L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2456101936301468395L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7309193604905058320L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1169766170650380281L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5149765774756432886L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3619941783783821365L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4755953108808997225L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5898742921671940225L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1513806074914163381L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(213638593212357751L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1941308327608399155L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8652072385151148020L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5518343174315310225L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6668391554757700701L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3378303108682973236L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(153551912349589258L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7174519294373221017L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5576411236907470600L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3922072894231107391L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3084936538615937343L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-365481539812195825L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9074392047666671583L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5252333847380776371L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8392327288880097969L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3749904315140114141L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(917548018462944056L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4410000888652955656L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(4309931546848104734L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7825918609744072054L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2034815114218434608L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6815058800263487518L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6043575486452002712L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4170086999604523937L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2831257470140081013L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7073463272410348565L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6837280645850915462L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3780232701099159317L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7827162877968932208L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8876862564686567611L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1816290325167492872L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6084032547809917278L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2004026282083097840L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5681691551577807424L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1362384365585262897L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8254130692795050797L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(95854038055961911L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7584561608549564522L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2225803302692197L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7925858458233475061L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-783063673896965100L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6474177126950886066L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1424906516450865987L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8994706141977867292L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5427762163764242642L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(752633996393504890L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3821773867277842895L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5044365075408941478L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4334696141216550490L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5223622137639054093L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3747734116506103956L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3476627681176321150L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6701728281633932876L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7879316057935635805L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1961540790445216207L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5609925979471008083L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2758595237753181999L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3828868950989022787L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7554970856115997762L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1674289599311139799L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5882541554291952257L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5970517969145226666L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5694327872563891786L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9075081430626130678L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(510363649096219245L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2932043914224158007L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2103310732740451281L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9143091788327051278L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8190331378858654425L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6484515748255825118L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-989102733826402503L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2805589460348619455L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4952624266317925170L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7866602387523759598L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2838535743579155169L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9130337089540320078L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6155941245566701791L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4369077573250708827L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3403922283335250125L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5228145801860091857L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5611646657723339879L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3727659461417825161L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8098452576981511931L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5840023793533036775L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(305061427025647218L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1554589124966828544L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-995902213687802079L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1661298148894725234L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1171190151657088490L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1911122725552527299L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4166212015522712752L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1307637690161925921L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4807711348563110904L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7911655230983048329L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6183208992543283055L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1274010569969155473L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-248690450166941417L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(438974322021211749L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8521068021660184464L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3156900595960784616L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(946611373396269568L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3330553286879175391L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3003257089522996293L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5539589064221234295L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6147579707562708687L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6271026328840650696L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8038276827517709911L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6398103833070748828L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3657318447125409469L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8383621622363403705L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8216605443336037219L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8713102081639797436L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7543937831586873292L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8993887115287846087L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(857243566681711432L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6877473343732551430L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6442566549481596084L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8346392322474908715L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8950600426892419611L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2251462301258663597L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8235262215580202595L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2181622447026851046L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3920438834459637895L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6962082836595194640L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4148519272451968693L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-161146386391559860L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2665459711608506848L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3709258874196377632L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6039434875928637786L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2178029681318653626L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-744779604243454667L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9024143963715833852L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2691682731458806928L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7018807265652199746L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(-919413858743417798L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1774623754234802882L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8339418576012490680L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7513479833408246487L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2314818037513073106L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9074274855793584370L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3277659344386098540L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8045473141863789512L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7970299096669443799L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1034754903083837051L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3100201980261012324L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3701670125437049291L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5653162943558428452L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1625458280817133288L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9168198672079513207L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1756840750465306970L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3563527016006297273L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3124357265138734874L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-766134785560780261L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3590677551555116172L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1580854947335065240L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3679035563956529320L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4131972852617518234L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1916171663225653717L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8888138375515087806L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(837547871646678133L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8390388916778336276L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5285180317943538453L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9195622821895535786L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4568494496855487641L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1723762583039395626L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3656784539222589676L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5045168601700388826L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2029989707988253900L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5590402094919585524L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4465196013497954929L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7131193391680124420L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1457143371037150647L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2025195411394300269L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2392720093380125878L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9180298646049917071L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6829077588024813969L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3590114192596026103L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4177899441345042019L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1932025508841098613L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4374414213058128253L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2635133127341295326L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1212775154779584214L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2077230865184567803L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8532627771998088723L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1918301575936345551L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6181119479344910834L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7607659780887766874L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8841419320954119994L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3386952276780610202L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7265218758822181265L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6885763395958973390L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7175179636323001898L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(965306621268280864L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8964937495528998351L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7945823546398330117L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6582853383060287522L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3013505789382482932L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6345532957235816740L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7717839717785972351L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(303352763970566936L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3993071653855238260L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6355371785498034955L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4409817751224932099L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5025307611986570656L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-516646206414250491L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-207387019995361789L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5930061197256787957L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4664346185322264172L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8975714574788740655L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9074650266398893630L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4670921149196815655L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2065487589269618250L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8002737148078177618L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7613899854096587131L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8363971138228398118L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-336398731228566917L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6067865635786431478L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-537350056175380937L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-821403342938294173L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1388933875687454829L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1811447339585681064L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5723306975138455595L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-917198550118498522L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2067564707638383745L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4617416675770205927L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3256576131634881107L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8510773107491051585L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7365138421256309114L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(163571525502003729L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8160441735082537413L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9127840326063847917L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8489083611002688562L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6744934502626892772L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2221286548225247325L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2962263413232090336L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3934146036784200195L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3436771769251688178L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-571685545082449314L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3945694407626549965L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8845643057329656427L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-114004742351245484L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7563862587164857524L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5389753993406410661L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-160132178394707695L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6183523531436058364L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-214828784118509446L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1772884462377548962L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8949315185481553926L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3729103974117941717L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4068251328299929969L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-997635462382512347L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1317888929730875933L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7127247260880184787L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5537235031471907997L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5877154569661868784L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(915032465674082373L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3696594469398488735L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1198701298961969789L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8641144559498016152L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4064835476831462925L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2841196238079137667L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3099776064505963192L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2939614047086402172L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9071330913751975238L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5120371539735949397L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2962658612416286234L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6689004982062057288L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8964882758012483870L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5475469752228117537L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2984707355842012321L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5597108390879478379L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(394761154282362208L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1230930935480479505L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8396531332138972334L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8950390791323304538L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7341335208455734582L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2511358839460762368L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8749169917523618680L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3629581727734455696L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2494960099271702435L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1333200973290266984L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5220533190940070166L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7182310048075607823L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4992762815153309925L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1567701269007552940L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6233143081381465527L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5356460109429705702L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2921817814179584568L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5157239356123225381L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6545866594900197983L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1723419563101916175L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1768072117978956882L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1697426504002076120L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4693519658482978727L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6477458318850806217L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2578676782114461676L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4822563471147350265L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4644685633478581922L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2077374908101105818L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7772646909634991452L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4802873170356544924L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4732105155733304966L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3191653724556036960L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6675909975872865506L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4370639611625329080L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6127069360154651222L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3830571812126989260L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1145135241143221176L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5757803355491053851L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5861514532574319479L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5029961575385880373L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4737356065818941110L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1997637500916576252L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-402317396686749838L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5490296329405198209L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7015982033247445319L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5566428372603202648L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1610547181022171706L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-749958015179314652L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3287041484289893793L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1205591141138602038L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3244013406560206393L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4381897587511407242L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2769134562871130661L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5510210567648891639L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6315616873848322948L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3704471921972883308L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-628270213006929303L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2929554665206796590L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5394171273559455145L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5396731502047557482L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4573704703133599927L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(380442719608947285L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4819409575663658013L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6093821547247321433L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1244195524525771376L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1490733409722229745L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7846179103121209336L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6793493318428248099L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1878180836146942289L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9127210875299794782L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3121621012635395049L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5627575452836567811L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4345720246612391945L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2987207132099937157L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2718525029608824611L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1928462778601061980L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8726174620560326418L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3742312471085449325L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9172196962600855678L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8457539779541178549L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5148847283195559037L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6287796511558536662L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6728069329333144688L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-728759495188423120L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(3123981817461308697L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9069789736011624704L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-323664384510299095L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7371305299622091599L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5118654025279893444L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8914889255355890013L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6341878152146381740L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8719301639867663453L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1447485275231485462L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3000218305613173085L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5628421437479278969L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-464022640854493676L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4503733056757245403L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5119989142457130753L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9057318678582108161L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1490790573133747500L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6526284619751243769L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7948142709974031419L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-166781528820860339L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2097328693574984093L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4846623685971182474L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7404752823167592293L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4655249128411810447L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3324069469948004682L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3682584884556362398L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2634301777958225283L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2019191113204726620L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9095504018929749741L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7768597088751846295L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7827637957870423658L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2590720253343633763L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2074445615499076596L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4478877478060189823L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3871648429399759137L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5780224641161271655L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-587307018214525586L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4713977051001056438L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8591023449897235973L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6496683859634571100L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-472878060695501236L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3840600464305262995L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3589405155502518259L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2763248056044434997L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4692043840546359380L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1848123464957624244L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2045980452423856442L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-117892202448721551L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5697288768445779184L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2276005181197399426L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9174021919578190095L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8414178418449687143L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(964909248668401510L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6420089835907853503L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1206668257124389910L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5228800532249141616L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4369205978830936126L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7729861559149491830L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4683709738109657062L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8134414797632320240L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1710424857346228286L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4533787663450792213L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5250712491123428927L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7399998953575112158L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7503459437579941063L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1759656563388384806L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6049160167533009731L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5662735568805587576L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3287329673264815835L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7202674938420357883L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8264077325419788549L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(105829686699111191L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8639859108793276933L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7929899358064994728L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5603830156674993046L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3065385947166298415L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1590803408820128797L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8068534516492922392L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8006462752586302146L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4415286755741161732L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7579467872633793618L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(3353689417665180214L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4890728051061267630L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7765364972116597192L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2950975812271981995L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1865222533820919226L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5935273144739166183L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8726441470434619326L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6537978008560483175L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4729355686354735841L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5261917703163211105L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(382694519422632533L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6230649450814295490L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7011501018073908618L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8480807668178964840L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7316813999135947873L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1978630551954399630L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3450396147663272072L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8566344773080147277L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7130493993344824022L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3074040277587997737L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3215216590703372718L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(668392685647621974L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8299355380725830290L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2141160178662731760L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5552714407979987888L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8514174249124482292L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-267538969170167187L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6015945704533227926L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2848645146241511730L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8732403067646632451L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7447266920259331606L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3746081854878348656L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9027048670226612759L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5150537824674051723L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8856255601204710879L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1603063408204147182L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4379963049119602342L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2354106643511466664L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8438222519059515827L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8525241284021267915L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4713631510949118869L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5494197952805683322L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2803714062836393466L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(834350807942076220L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2803025750978137237L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3639592030903621369L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3205221769422207620L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6137169999648429155L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1845155904071928601L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1881462987446087967L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8994150716039412784L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-689266450110917261L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2870767467022586685L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3416893677099904837L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5604288906048632072L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4794574540075488122L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8873369584428817349L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4199752890653780871L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1746150380386033081L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7275157191837229502L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1464668239948125706L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1989670409584258754L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4100623189401528040L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9022342751689801679L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1297874714300681867L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6984393055181507250L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-859300423905213946L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5175754230219423683L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4679689865775202595L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2848532333699623434L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6101318258513184912L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4916973882150029207L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6277451035331749555L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(980234207379701280L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6620208133880536149L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3363289285053783387L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3175150297517903003L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8600416641602506940L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3299980457845877485L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2123386905965069918L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6114029935015278708L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3371568838790535065L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5278880873848158683L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3620838319557240908L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8316126234860352408L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2128711266520349557L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1660862800821763670L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8027156411800809878L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1090949195215716356L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3849647630193561094L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5254885491080214472L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6204725911977086024L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6707797091292015721L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1988124221269519528L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5092529663763261197L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2016028107744740408L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2900481677748932119L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(648173356358948150L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4226564601689169858L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4335322383944857512L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6016061986573194912L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7176060433647764159L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2942344384811892567L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6092988999849727017L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3945225378372948229L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5645814257619978902L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1785667623295804164L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5101505602929939221L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5487859664203196249L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5720851097316669648L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3785204615371068055L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-561986025123427258L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(470761896148187473L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-857798012934833099L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6330894209310279593L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7139268433438188557L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9106837350205382004L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5411332552963557386L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7933151961286681106L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2892079223345912974L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6982561687063692631L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2719761414824180064L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8728583861384937694L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2321847920782466177L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2777521335515563352L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5004973603669270194L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9163881514320632424L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4450156830168333756L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9022710403794182422L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7843972757221422894L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8447990974203036899L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5878388923139080493L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4133067880340619408L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4343648983921339206L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5024685564347393621L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4866371535087567714L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2628180531315318072L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8972810740805988305L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8010469905465125831L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7154064171073873332L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1461356700224937042L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(98801013476167000L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-630565617635933577L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2923660292679716530L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8000052327432781205L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2877340485581057856L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2700898613642777271L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5199370076986222699L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7581939487537450731L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2179653435652298003L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1345552540003111049L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1027617938134274568L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8315145766711593684L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2780905536902388534L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1667862483904418024L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3583275351917121211L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4737090727306786044L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1331216929299961183L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1241739169435989729L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1021050309461968010L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8949170418377121573L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1027276572384110223L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-550100803298838720L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-920235981772234156L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1998750113306284382L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9143248736720514975L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7818190187401558403L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3162165788155607192L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5414940549013959692L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4806474729330816058L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5314988679666910211L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6982668010006073115L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2465590116038820228L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6526893981964949074L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6194151172155161281L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8630599462842298898L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-22056709181439950L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7841026110869319964L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3431964442040488336L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4336759233672801839L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4818018289031333811L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1858801153554425710L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5407591726371152001L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(458869154562108713L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6120672096660523923L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1573077873219249141L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3400235870762790794L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8603852188278464302L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-216471682221518735L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4958488947543730786L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2617601700128523360L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1935099800016483434L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8851653639451196121L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(703647420220481895L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5829641327573384108L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6701836975809850721L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1728184293609821078L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1802124911314707856L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2649808558380673853L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8770921637106683093L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-9022305052714319615L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3641495095642281187L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4729485338924484294L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5163113304774476137L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6121189468112493070L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2260753270295613747L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5447368382983191900L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2783852683762409981L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2982911575606719503L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(418506796835376732L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4573654158771594273L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6089619787186807407L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8024073409900724384L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(9133873434019287659L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1348424155780968308L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6513276877409274716L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7817902869606204298L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7067165855987920604L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2002520142872203095L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6087898490378273711L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8743249348057432853L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5155296734268770562L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2383373866280366833L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5044812922513473382L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3078837164674525831L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4062729010651707550L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7857124971844231711L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5457968541179511401L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5756814311169447862L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2328398497679838418L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5037984042970560812L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5821246296106742657L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5598522630953587699L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6915720826048005328L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1757531524893795772L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7711366347596515359L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2508344940770375843L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1958901065989171903L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6593865677046990909L));
    mutableEncryptionInts = (int[]) mutableEncryptionInts.clone();
    cachedLongDecrypters.add(new SimpleLongDecrypter(4294148454648727092L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1403135501874259611L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(669894455170059330L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5969115259296313885L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6006074756119032913L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7087094550249005235L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1700128685116273294L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2701714164910619092L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3750132386748992080L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8055117132173116784L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8022141185680785037L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6003798324848002385L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7864245387436781866L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2432284427432697735L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5723260322880248553L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8231066441305293495L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5716782213702986430L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6065315107958657453L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8089463602689788585L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8267949031799818814L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-501014590016411067L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7417813050321278416L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8467561015506104600L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-953182606337653900L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4409572277925425069L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2984150602136508061L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2425815659940105290L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6202629222000764253L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3167090477094296677L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2375016374088837392L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1755159740002316903L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5816256118218694922L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8371596391687840489L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8946268129329818829L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7691106236346789404L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5347372426458345493L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-795585369112892359L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8589521086970508554L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5491431801700760458L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3653459661474739192L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(1965948575058990346L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4108480581253664294L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2525337852744631316L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3976816553450396890L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8903072313838479922L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2292313479567609205L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4722844739823544416L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7686699201968476699L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-6562554514220268235L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2320794911495513669L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7320299521338147397L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2805911437997031956L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(683020884408656649L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6126207642105232432L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7176016269284514297L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-8033835911069254896L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4521680277892617610L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7722464984245934535L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3864758102832358841L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3136819754763617106L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4612127509001437001L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(4877576988565574146L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-3993831536360412311L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3497127873665015327L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(810648566345487735L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(212666162098105862L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5248894219456725363L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3300269710224254300L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8846503112951411755L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(6109567338086971938L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5251722195395330154L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5330291147265649367L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(7565058400581352239L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4211887087490862059L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4939719026944369907L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-4983052400759416743L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3542674163069123398L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-1487119450460742355L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(3910139209092479572L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(5393760485569384472L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-7428051292777401773L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-5438727553116681666L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(-2649220214809800625L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(8597908996122952484L));
    cachedLongDecrypters.add(new SimpleLongDecrypter(2101404646864295476L));
    mutableEncryptionInts = new int[]{
        -13,
        -46,
        -2,
        -14,
        2,
        -33,
        -19,
        -17,
        -42,
        -30,
        -46,
        -18,
        -37,
        13,
        -23,
        -6,
        -24,
        14,
        -28,
        -11,
        -38,
        6,
        -32,
        -36,
        17,
        19,
        -10,
        -35,
        -6,
        18,
        11,
        -17,
        -29,
        -20,
        6,
        -28,
        10,
        23,
        33,
        30,
        24,
        -10,
        -2,
        -9,
        2,
        -15,
        28,
        46,
        17,
        37,
        42,
        10,
        9,
        20,
        32,
        -2,
        46,
        2,
        38,
        36,
        15,
        29,
        35,
        28
    };
  }
}

```

`testData/results/custom-classes/FlowObfSample.dec`:

```dec
import org.bukkit.Bukkit;
import org.bukkit.event.Listener;

public class IIIIIIIIlIlIIIIlIIlIIIIIIIIlIlIllllIIIlIIIlIIllIllllIIIIllIIIIllIIllllIIIIllllIIIIIIIllIllIIIlllIlIIllIlIIllIlIIIIIlIIIIIllllIlIIllIllllIIlIIIIIIlIllIlIIIIlIlIIlIIlllIIIIlIIlIIllIlIIIlIlIlIIIIllIlllll
    implements Listener {
    public static int lIIIIlllIlIIllIIIlllllIlllIIllIllIIlIIllIIIllIIlIllllIIIIllIIlIIIIlIllIIlllIllIllllIIIlllIllIllIlllIlllllIIlIIIlllllIIIlIlIllllIllllIllllIIlIIllIlIIllIIllIIlIllIIllllIlllIIIIlIIllIIIIIIIIllllIlIllllIl(
        int var0
    ) {
        Bukkit.getServer();
        Bukkit.getServer();
        Bukkit.getServer();
        Bukkit.getServer();
        Bukkit.getServer();
        Bukkit.getServer();
        Bukkit.getServer();
        return 0;
    }
}

```

`testData/results/custom-classes/JSR.dec`:

```dec
import java.io.PrintStream;

public class TestJSR {
    public static void main(String[] var0) {
        test(System.out);
    }

    public static void test(PrintStream var0) {
        var0.println("In");
        Object var1 = null;
        var0.println("Out");
    }
}

```

`testData/results/custom-classes/Pop2Sample.dec`:

```dec
package com.arlania;

import com.arlania.r.H;
import com.arlania.r.W;
import javax.swing.ImageIcon;
import javax.swing.JColorChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.colorchooser.AbstractColorChooserPanel;

class Ld implements Runnable {
    public void run() {
        AbstractColorChooserPanel[] var5;
        JColorChooser var7;
        int var4 = (var5 = (var7 = new JColorChooser()).getChooserPanels()).length;

        int var3;
        for (int var10000 = var3 = 0; var10000 < var4; var10000 = ++var3) {
            String var2;
            AbstractColorChooserPanel var6;
            switch ((var2 = (var6 = var5[var3]).getDisplayName()).hashCode()) {
                case -249666038:
                    while (false) {
                    }

                    if (!var2.equals(H.ALLATORIxDEMO("\u0013\u001a!\u0019#\u0005%\u001e"))) {
                        continue;
                    }
                    break;
                case 71851:
                    if (!var2.equals(W.ALLATORIxDEMO("\"\u0011<"))) {
                        continue;
                    }
                    break;
                case 81069:
                    if (!var2.equals(H.ALLATORIxDEMO("?\u0007/"))) {
                        continue;
                    }
                    break;
                case 2072828:
                    if (!var2.equals(W.ALLATORIxDEMO("\u0001'\u001b!"))) {
                        continue;
                    }
                    break;
                default:
                    continue;
            }

            var7.removeChooserPanel(var6);
        }

        var7.setColor(com.arlania.H.Wa[a.ALLATORIxDEMO].KC);
        var7.setPreviewPanel(new JPanel());
        var7.getSelectionModel().addChangeListener(new BA(a, var7, a.E, a.ALLATORIxDEMO));
        Client.ALLATORIxDEMO(var7);
        JOptionPane.showMessageDialog(null, var7, a.M, -1, new ImageIcon());
    }

    Ld(Client var1, int var2, String var3, int var4) {
        a.j = var1;
        a.ALLATORIxDEMO = var2;
        a.M = var3;
        a.E = var4;
    }
}

```

`testData/results/custom-classes/hp888/com/bric/colorpicker/ColorPicker$1.dec`:

```dec
package com.bric.colorpicker;

// $VF: synthetic class
public class ColorPicker$1 {
    static {
        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.HUE.ordinal()] = 1;
        } catch (NoSuchFieldError var6) {
        }

        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.SATURATION.ordinal()] = 2;
        } catch (NoSuchFieldError var5) {
        }

        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.BRIGHTNESS.ordinal()] = 3;
        } catch (NoSuchFieldError var4) {
        }

        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.RED.ordinal()] = 4;
        } catch (NoSuchFieldError var3) {
        }

        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.GREEN.ordinal()] = 5;
        } catch (NoSuchFieldError var2) {
        }

        try {
            $SwitchMap$com$bric$colorpicker$ColorPickerMode[ColorPickerMode.BLUE.ordinal()] = 6;
        } catch (NoSuchFieldError var1) {
        }
    }
}

```

`testData/results/custom-classes/hp888/com/bric/colorpicker/ColorPicker.dec`:

```dec
package com.bric.colorpicker;

import com.bric.colorpicker.colorslider.ColorSlider;
import com.bric.colorpicker.colorslider.ColorSliderUI;
import com.bric.colorpicker.listeners.ColorListener;
import com.bric.colorpicker.listeners.HexFieldListener;
import com.bric.colorpicker.listeners.SelectAllListener;
import com.bric.colorpicker.models.ColorModel;
import com.bric.colorpicker.models.ModeModel;
import com.bric.colorpicker.options.AlphaOption;
import com.bric.colorpicker.options.BlueOption;
import com.bric.colorpicker.options.BrightnessOption;
import com.bric.colorpicker.options.GreenOption;
import com.bric.colorpicker.options.HueOption;
import com.bric.colorpicker.options.Option;
import com.bric.colorpicker.options.RedOption;
import com.bric.colorpicker.options.SaturationOption;
import com.bric.colorpicker.parts.ColorSwatch;
import com.bric.colorpicker.parts.HexField;
import com.bric.colorpicker.parts.OpacitySlider;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.ResourceBundle;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.JTextField;

public class ColorPicker extends JPanel {
    public static final String MODE_PROPERTY = "mode";
    private static final String SELECTED_COLOR_PROPERTY = "selected color";
    private static final String MODE_CONTROLS_VISIBLE_PROPERTY = "mode controls visible";
    private static ResourceBundle strings = ResourceBundle.getBundle("com.bric.colorpicker.resources.ColorPicker");
    private ColorModel colorModel = new ColorModel();
    private ModeModel modeModel = new ModeModel();
    private ColorSlider slider = new ColorSlider();
    private Option alphaOption = new AlphaOption();
    private Option hueOption = new HueOption();
    private Option saturationOption = new SaturationOption();
    private Option brightnessOption = new BrightnessOption();
    private Option redOption = new RedOption();
    private Option greenOption = new GreenOption();
    private Option blueOption = new BlueOption();
    private ColorSwatch preview = new ColorSwatch(50);
    private JLabel hexLabel = new JLabel(strings.getObject("hexLabel").toString());
    private HexField hexField = new HexField();
    private JPanel expertControls = new JPanel(new GridBagLayout());
    private ColorPickerPanel colorPanel = new ColorPickerPanel();
    private OpacitySlider opacitySlider = new OpacitySlider();
    private JLabel opacityLabel = new JLabel(strings.getObject("opacityLabel").toString());

    public ColorPicker() {
        this(true, false);
    }

    public ColorPicker(boolean var1, boolean var2) {
        super(new GridBagLayout());
        this.initNames();
        GridBagConstraints var3 = new GridBagConstraints();
        Insets var4 = new Insets(3, 3, 3, 3);
        JPanel var5 = new JPanel(new GridBagLayout());
        var3.gridx = 0;
        var3.gridy = 0;
        var3.weightx = 1.0;
        var3.weighty = 1.0;
        var3.insets = var4;
        ButtonGroup var6 = new ButtonGroup();
        Option[] var7 = new Option[]{this.hueOption, this.saturationOption, this.brightnessOption, this.redOption, this.greenOption, this.blueOption};

        for (int var8 = 0; var8 < var7.length; var8++) {
            if (var8 != 3 && var8 != 6) {
                var3.insets = var4;
            } else {
                var3.insets = new Insets(var4.top + 10, var4.left, var4.bottom, var4.right);
            }

            var7[var8].addTo(var5, var3, var6);
        }

        var3.insets = new Insets(var4.top + 10, var4.left, var4.bottom, var4.right);
        var3.anchor = 22;
        var3.fill = 0;
        var5.add(this.hexLabel, var3);
        var3.gridx++;
        var3.anchor = 21;
        var3.fill = 2;
        var5.add(this.hexField, var3);
        this.alphaOption.addTo(var5, var3);
        var3.gridx = 0;
        var3.gridy = 0;
        var3.weightx = 1.0;
        var3.weighty = 1.0;
        var3.fill = 1;
        var3.anchor = 10;
        var3.insets = var4;
        var3.gridwidth = 2;
        this.add(this.colorPanel, var3);
        var3.gridwidth = 1;
        var3.insets = var4;
        var3.gridx += 2;
        var3.weighty = 1.0;
        var3.gridwidth = 1;
        var3.fill = 3;
        var3.weightx = 0.0;
        this.add(this.slider, var3);
        var3.gridx++;
        var3.fill = 3;
        var3.gridheight = 0;
        var3.anchor = 10;
        var3.insets = new Insets(0, 0, 0, 0);
        this.add(this.expertControls, var3);
        var3.gridx = 0;
        var3.gridheight = 1;
        var3.gridy = 1;
        var3.weightx = 0.0;
        var3.weighty = 0.0;
        var3.insets = var4;
        var3.anchor = 10;
        this.add(this.opacityLabel, var3);
        var3.gridx++;
        var3.gridwidth = 2;
        var3.weightx = 1.0;
        var3.fill = 2;
        this.add(this.opacitySlider, var3);
        var3.gridx = 0;
        var3.gridy = 0;
        var3.gridheight = 1;
        var3.gridwidth = 1;
        var3.fill = 1;
        var3.weighty = 1.0;
        var3.weightx = 1.0;
        var3.anchor = 19;
        var3.insets = new Insets(var4.top, var4.left + 8, var4.bottom + 10, var4.right + 8);
        this.expertControls.add(this.preview, var3);
        var3.gridy++;
        var3.weighty = 0.0;
        var3.anchor = 10;
        var3.insets = new Insets(var4.top, var4.left, 0, var4.right);
        this.expertControls.add(var5, var3);
        this.initializeColorPanel();
        this.initializeSlider();
        this.initializePreview();
        this.initializeHexField();
        this.initialize(this.hueOption);
        this.initialize(this.saturationOption);
        this.initialize(this.brightnessOption);
        this.initialize(this.redOption);
        this.initialize(this.greenOption);
        this.initialize(this.blueOption);
        this.initializeOpacitySlider();
        this.initialize(this.alphaOption);
        this.setExpertControlsVisible(var1);
        this.setOpacityVisible(var2);
        setOpaque(this, false);
        this.setColor(Color.BLACK);
        this.setMode(ColorPickerMode.BRIGHTNESS);
    }

    private static void setOpaque(JComponent var0, boolean var1) {
        if (!(var0 instanceof JTextField)) {
            var0.setOpaque(false);
            if (!(var0 instanceof JSpinner)) {
                for (int var2 = 0; var2 < var0.getComponentCount(); var2++) {
                    JComponent var3 = (JComponent)var0.getComponent(var2);
                    setOpaque(var3, var1);
                }
            }
        }
    }

    private static void requireValidFloat(float var0, String var1) {
        if (Float.isInfinite(var0) || Float.isNaN(var0)) {
            throw new IllegalArgumentException("The " + var1 + " value '" + var0 + "' is not a valid number.");
        } else if (var0 < 0.0F || var0 > 1.0F) {
            throw new IllegalArgumentException("The " + var1 + " value '" + var0 + "' must be between [0,1]");
        }
    }

    private void initialize(Option var1) {
        this.colorModel.addColorListener(var1);
        var1.addSpinnerChangeListener(var2 -> {
            if (!this.colorModel.isChanging()) {
                var1.aboutToChangeColor();
                var1.update(this.colorModel);
            }
        });
        this.modeModel.addListener(var1);
        var1.addRadioActionListener(var2 -> {
            if (!this.colorModel.isChanging()) {
                var1.aboutToChangeMode();
                var1.update(this.modeModel);
            }
        });
        var1.addFocusListener(new SelectAllListener());
    }

    private void initializeOpacitySlider() {
        this.colorModel.addColorListener(this.opacitySlider);
        this.opacitySlider.addChangeListener(var1 -> {
            if (!this.opacitySlider.getValueIsAdjusting()) {
                if (this.colorModel.isChanging()) {
                    return;
                }

                this.opacitySlider.aboutToChangeColor();
                this.colorModel.setAlpha(this.opacitySlider.getValue());
            }
        });
    }

    private void initializeHexField() {
        this.colorModel.addColorListener(this.hexField);
        HexFieldListener var1 = new HexFieldListener();
        var1.setColorModel(this.colorModel);
        var1.setHexField(this.hexField);
        this.hexField.getDocument().addDocumentListener(var1);
        this.hexField.addFocusListener(new SelectAllListener());
    }

    private void initializePreview() {
        this.preview.setOpaque(true);
        this.colorModel.addColorListener(this.preview);
    }

    private void initializeColorPanel() {
        int var1 = this.expertControls.getPreferredSize().height;
        this.colorPanel.setPreferredSize(new Dimension(var1, var1));
        this.colorModel.addColorListener(this.colorPanel);
        this.modeModel.addListener(this.colorPanel);
        this.colorPanel.addChangeListener(var1x -> {
            if (!this.colorModel.isChanging()) {
                int[] var2 = this.colorPanel.getRGB();
                this.colorPanel.aboutToChangeColor();
                this.colorModel.setColor(new Color(var2[0], var2[1], var2[2]));
            }
        });
    }

    private void initializeSlider() {
        this.colorModel.addColorListener(this.slider);
        this.modeModel.addListener(this.slider);
        this.slider.addChangeListener(var1 -> {
            if (!this.slider.getValueIsAdjusting()) {
                if (this.colorModel.isChanging()) {
                    return;
                }

                this.slider.aboutToChangeColor();
                ColorPickerMode var2 = this.modeModel.getMode();
                switch (var2) {
                    case HUE:
                        this.colorModel.setHue((float)this.slider.getValue() / (float)var2.getMax());
                        break;
                    case SATURATION:
                        this.colorModel.setSaturation((float)this.slider.getValue() / (float)var2.getMax());
                        break;
                    case BRIGHTNESS:
                        this.colorModel.setBrightness((float)this.slider.getValue() / (float)var2.getMax());
                        break;
                    case RED:
                        this.colorModel.setRed(this.slider.getValue());
                        break;
                    case GREEN:
                        this.colorModel.setGreen(this.slider.getValue());
                        break;
                    case BLUE:
                        this.colorModel.setBlue(this.slider.getValue());
                }
            }
        });
        this.slider.setUI(new ColorSliderUI(this.slider, this));
    }

    public Option getSelectedOption() {
        ColorPickerMode var1 = this.getMode();
        switch (var1) {
            case HUE:
                return this.hueOption;
            case SATURATION:
                return this.saturationOption;
            case BRIGHTNESS:
                return this.brightnessOption;
            case RED:
                return this.redOption;
            case GREEN:
                return this.greenOption;
            case BLUE:
                return this.blueOption;
            default:
                return null;
        }
    }

    private void initNames() {
        this.hexField.setName("Hex");
        this.hueOption.setName("Hue");
        this.saturationOption.setName("Saturation");
        this.brightnessOption.setName("Brightness");
        this.redOption.setName("Red");
        this.greenOption.setName("Green");
        this.blueOption.setName("Blue");
    }

    public void setHexControlsVisible(boolean var1) {
        this.hexLabel.setVisible(var1);
        this.hexField.setVisible(var1);
    }

    public void setPreviewSwatchVisible(boolean var1) {
        this.preview.setVisible(var1);
    }

    public void setExpertControlsVisible(boolean var1) {
        this.expertControls.setVisible(var1);
    }

    public void setModeControlsVisible(boolean var1) {
        this.hueOption.setRadioButtonVisible(var1 && this.hueOption.isVisible());
        this.saturationOption.setRadioButtonVisible(var1 && this.saturationOption.isVisible());
        this.brightnessOption.setRadioButtonVisible(var1 && this.brightnessOption.isVisible());
        this.redOption.setRadioButtonVisible(var1 && this.redOption.isVisible());
        this.greenOption.setRadioButtonVisible(var1 && this.greenOption.isVisible());
        this.blueOption.setRadioButtonVisible(var1 && this.blueOption.isVisible());
        this.putClientProperty("mode controls visible", var1);
    }

    public ColorPickerMode getMode() {
        return this.modeModel.getMode();
    }

    public void setMode(ColorPickerMode var1) {
        if (var1 == null) {
            throw new IllegalArgumentException("mode must not be null");
        } else {
            this.modeModel.setMode(var1);
        }
    }

    public void setRGB(int var1, int var2, int var3) {
        this.setColor(new Color(var1, var2, var3));
    }

    public Color getColor() {
        return this.colorModel.getColor();
    }

    public void setColor(Color var1) {
        Color var2 = this.colorModel.getColor();
        this.colorModel.setColor(var1);
        this.firePropertyChange("selected color", var2, var1);
    }

    public JPanel getExpertControls() {
        return this.expertControls;
    }

    public void setRGBControlsVisible(boolean var1) {
        boolean var2 = this.areRadioButtonsAllowed();
        this.redOption.setVisible(var1, var2);
        this.greenOption.setVisible(var1, var2);
        this.blueOption.setVisible(var1, var2);
    }

    private boolean areRadioButtonsAllowed() {
        Boolean var1 = (Boolean)this.getClientProperty("mode controls visible");
        return var1 != null ? var1 : true;
    }

    public void setHSBControlsVisible(boolean var1) {
        boolean var2 = this.areRadioButtonsAllowed();
        this.hueOption.setVisible(var1, var2);
        this.saturationOption.setVisible(var1, var2);
        this.brightnessOption.setVisible(var1, var2);
    }

    public final void setOpacityVisible(boolean var1) {
        this.opacityLabel.setVisible(var1);
        this.opacitySlider.setVisible(var1);
        this.alphaOption.setLabelVisible(var1);
        this.alphaOption.setSpinnerVisible(var1);
    }

    public ColorPickerPanel getColorPanel() {
        return this.colorPanel;
    }

    public void setHSB(float var1, float var2, float var3) {
        requireValidFloat(var1, "hue");
        requireValidFloat(var2, "saturation");
        requireValidFloat(var3, "brightness");
        this.setColor(Color.getHSBColor(var1, var2, var3));
    }

    public float[] getHSB() {
        return this.colorModel.getHSB();
    }

    public int[] getRGB() {
        return this.colorModel.getRGB();
    }

    public void setOpacity(int var1) {
        this.setColor(new Color(this.colorModel.getRed(), this.colorModel.getGreen(), this.colorModel.getBlue(), var1));
    }

    public void addColorListener(ColorListener var1) {
        this.colorModel.addColorListener(var1);
    }

    public void removeColorListener(ColorListener var1) {
        this.colorModel.removeColorListener(var1);
    }
}

```

`testData/results/custom-classes/hp888/com/bric/colorpicker/ColorPickerMode.dec`:

```dec
package com.bric.colorpicker;

public enum ColorPickerMode {
    HUE(360),
    BRIGHTNESS(100),
    SATURATION(100),
    RED(255),
    GREEN(255),
    BLUE(255),
    ALPHA(255);

    private int max;

    private ColorPickerMode(int var3) {
        this.max = var3;
    }

    public int getMax() {
        return this.max;
    }
}

```

`testData/results/custom-classes/zkm/EnhancedStringEncManyStrings.dec`:

```dec
public class a {
    private static final String[] a;
    private static final String[] b;

    public static void main(String[] var0) {
        a(a(16601, -26271));
        System.out.println(a(16547, 28980));
        System.out.println(a(16573, -6570));
        System.out.println(a(16549, 15866));
        System.out.println(a(16569, 30320));
        System.out.println(a(16513, 5692));
        System.out.println(a(16592, -18585));
        System.out.println(a(16518, -12275));
        System.out.println(a(16558, -5500));
        System.out.println(a(16533, 28407));
        System.out.println(a(16554, -31785));
        System.out.println(a(16598, 14166));
        System.out.println(a(16519, 21847));
        System.out.println(a(16597, 6470));
        System.out.println(a(16570, -27431));
        System.out.println(a(16567, -23765));
        System.out.println(a(16514, 26042));
        System.out.println(a(16544, -32719));
        System.out.println(a(16531, 13283));
        System.out.println(a(16556, 14179));
        System.out.println(a(16524, -10611));
        System.out.println(a(16602, 11272));
        System.out.println(a(16545, -397));
        System.out.println(a(16563, 19319));
        System.out.println(a(16559, 10170));
        System.out.println(a(16552, -16576));
        System.out.println(a(16546, 17855));
        System.out.println(a(16528, 428));
        System.out.println(a(16574, 23266));
        System.out.println(a(16600, -26763));
        System.out.println(a(16550, -19257));
        System.out.println(a(16583, 19975));
        System.out.println(a(16568, -28711));
        System.out.println(a(16593, 8545));
        System.out.println(a(16571, 16428));
        System.out.println(a(16604, 8759));
        System.out.println(a(16543, -31121));
        System.out.println(a(16565, 26258));
        System.out.println(a(16576, 18214));
        System.out.println(a(16542, 5982));
        System.out.println(a(16582, -20163));
        System.out.println(a(16595, 14588));
        System.out.println(a(16605, -26780));
        System.out.println(a(16572, -3689));
        System.out.println(a(16534, -4917));
        System.out.println(a(16553, -25655));
        System.out.println(a(16599, -6645));
        System.out.println(a(16575, 9955));
        System.out.println(a(16555, -5264));
        System.out.println(a(16536, 23938));
        System.out.println(a(16541, 14767));
        System.out.println(a(16523, 26124));
        System.out.println(a(16594, 10432));
        System.out.println(a(16606, 23179));
        System.out.println(a(16512, 28813));
        System.out.println(a(16527, 17243));
        System.out.println(a(16537, -17368));
        System.out.println(a(16521, 6489));
        System.out.println(a(16538, 32319));
        System.out.println(a(16557, -8581));
        System.out.println(a(16520, -15798));
        System.out.println(a(16516, -21175));
        System.out.println(a(16607, 10624));
        System.out.println(a(16561, 13569));
        System.out.println(a(16562, 31959));
        System.out.println(a(16539, 4326));
        System.out.println(a(16529, -27529));
        System.out.println(a(16580, 16893));
        System.out.println(a(16581, 13937));
        System.out.println(a(16603, 20273));
        System.out.println(a(16522, -27961));
        System.out.println(a(16548, 5675));
        System.out.println(a(16564, -31220));
        System.out.println(a(16525, -11503));
        System.out.println(a(16560, -15803));
        System.out.println(a(16596, -30597));
        System.out.println(a(16526, -10863));
        System.out.println(a(16540, 20769));
        System.out.println(a(16532, 27173));
        System.out.println(a(16515, 28785));
        System.out.println(a(16551, 26445));
    }

    private static void a(String var0) {
        if (var0.equals(a(16535, -2944))) {
            System.out.println(a(16517, 22762));
        } else {
            System.out.println(a(16566, 20267));
        }
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    static {
        String[] var5 = new String[85];
        int var3 = 0;
        String var2 = "-\u0092Ã™+\u000f\u0000Ã¡LÃ \u0019nÃˆY\\g@\u0095!\u00189\u001fOÃ¼-\u0097\u009de\u0086ÃˆP4\u0013Ã¶\bÃ¯jw\u0099\u000bÂ¾\u008eÃ•\\9DÂ®lÂ³'Ã•\u008cW\u0015pDÃ¯Â·\u0016\u009cÃ£Ã„c\u0096Ã–\u0012ÃšÃ‹FÃ‘Ã·Â»]\u0091ÃƒÂ¥ÂµÃª\u009a\u0088Ã´\u0081Ã‰ÃŽ.\u0090ze\u0013Ã¸\\\u0007\u000e-k\u007fÃƒ\u0099Â¯\u008bÂ¦zMÃ½Â®Ã¾Ã‹Ã‡\"ÃˆÂ¥Â¶\u0011Ã \u00063Ã»x+Â¦\u0097Ã—7\u00ad*Ã©o:IÂºÂ¬Â¨Ã¬\u0017Ã¤Ã­Âªv6\u008bO\u009f6Ã£+Ã‘\u008cÃ£dpÃ¥nc\u001dÃ„QÃ•Ã°Ã²\u0080\u009fÃ¥Â¾\u0098\u0087Ã¾\u0095\u0082Ã»OÂªÂ¼S\u007fLUÃ¦Ã…~V\u008eÃ£Ã£~|Â²d\u0004UÃ¼Âª5ÂµÂ§hrk6\u0099Â¼Ã¥Ã¯\bÃ¼Â¯\u0013-\u001cÃ«3Ã—`\u0019\u0005Ã¦Ã¨\u0081Q5\u0093\u0014DÃ¡Ã\u0088Ã¼\u0007.6ÃŒW%(\u009c^\tS\t\u007f\u0013\u008cÂ¯Ã¢Hz\u0092Â´\u0000Ã”Â»Ã—Ã±Â¡ÃŠ\u0007\u0083\u008cÃ»n9:\u0091\tÂ°>Â·UXU\u0095;\"3\u009cMÃª\u0080\u0092dyÃ†\u0010\u000eKaÃžCÃ®>ÃºÂ¤\u001aW3Ã·>\u0082\u001f\"Ã©Ã¡ÃFÃ®>G/ÃºÃn,\u009a\"UÃ®3\u0097\t\u000fX{Â¹Â¥C\u009dÂ·\n\u001c4\u0095\u0002\u0001ÃŽÃÃ°pÃ†f-uE'\u0001Ã¡Ã»Ã® Ã¡TkÂ¨Ã‹9\u000bvkd9Ã³Ã“KÃ©oÂ½Ã©Âµ\u00034\u00addi<qÃ¯N\u0000\u008cÃ­Ã Ã²Ã¡Â§\u0081CH\u009348=Â²Â½Â¬Ã4\u0010\u0094Ã‹Ã”\u008e\u0005Ã¬Ã¸Â£\u0000Ã°PÃ 4-ÃžÃxÃ¯k1ÃÂ½\\LÃ‚/Âº\u0091\u0017Â§H\u0086SÃŒGÃ¾Â¬Ã†a_M\t\u0005Â²\r\n\u0006\u0085\u000f\fv^Ã¶MÃ…4nÃ£\u001c\u0007Â¤(\u0001Â¼\u000ep\u0082\u008e@my,Ãd\u000fvÃ®Ã»\u0092R\u0095\u0086ÂµÃ½Â½\u0019Q35lKÃ¬W~a~_Ã™Ã¨\u0092\u008b.h\u0081Ã\u0088Ã‹Ã<ZÃÃ§Â¦Â¢Zg\u00980\u008aÃ¨Ã‰Ã¾M3Ãš\u008c\u009d>:}\u008aÃÃÂº\"\u0089Â¶Â²\u0018\u0091Ãš\u0095kpÃµ\u0002Ã¸ElÃ¼hÂ©Ã¬\n\u008a\u0019\u0090Ã¸K/wÃ”\u0091k\u001e WÃ7\u0081Â¬H7Ã‚\u008c\u0004\u0013\u001aQÂ¸{Â±Ã¤\u000f\u008aÃƒ0\t>Â°\u0015\u000fdÂ¬\\\u001eI\u0083a\u008c\u0006nÂ§Ã³\\`Ã§zÂ·\u0096\u0000Â°Ã‚Ã¿Cp\u000bÂ£\u0010\u000eÂ«4kR\u0014\u0005\u001fÃ´\u008fÃ³$e:m4\u0001Ã†,-\u009e\u0085,\u00adÃªÂ§K.ÃºÂ¶\u001e],gQ0\u008fÂ¹\u001cÃŠpÃ``Â¾x7s\u008fj:TÂ«\bÃ‰\u0091Â½$=F3\u0093ye\u000bÃ‚Ã…\u0095\u001brÃ©2O\u0014\u0003Ãº\u001bJ\u0090\u0000\u001c_Ã\\+Ã±Ã˜Â·Â¹\u0096\u0015Ã›\u0015Ã¡)Ã§uÂª\u0015Â¥n\u0095\u0016mÃ¾RxÃµÃ´ÃˆÃ½Ã“Â¤-\u008d8\u0080LÂ©\u0015Ã•\u0016Ã¾Ã€\u0080Ã…B$nÃ¤-\u0003ÃœÃ„\".Ã‹g\u001d\u001dT\u0099\u0007\u0013~\u0012ÃŽhÃ¡Ã³Â¦ @iÃ¥\u0010Ã°\u008bÃµ\u0085$Ã²,YwÃ³Ã‘<VPÃ¬Âµ=\u0015Ã´Â°\u001e/Ã\u0011Ã»\u0089Ã±\u000fÃg\u0096Ã±ÃŽÃ¸y9\u00ad\u0003Â·ÃŸ2QÃµ~\u0096cÃ˜Â¶\u008cÃ¤Â¬\u0082\u007f\u000f'\\\u009fÂ³Ã¨Â»\fÂ¥Ã¦Â©\u0001Ã¼Â¼Ã”8Ã¦ÃŽfw\\1Â¼\u001b\u0099\\[\u0003+\u0003\u0010E\u001bÃª\u0082bÂ»GÃ‚Â¯Â±Â³FÃŽÂº)Ãš\\\u008cÂ½\u0093Â½\u001a[57Ã˜\"\u001fÂ Â¦Ã¿sÃŸÃ¦Ã¬Ã§Ã¢\u0082-Ã•\u0012Â§~Â¡Ã‚Ã™$Â»\u0085zHÃ›\u0092JÃ¬\nQÃ‡Ã‰Ã«)GJÃ§\u0002,Â³^&\u009fG\u008d\u0019\u0080t\u0018|\u0085Â½NÃ¢#MhbdÂ»Ã³\u0084yÃ‡Ã³*Ã‡6Â¯\u009dÃ¢ÃŸÃÂ°9KQ\fX\u0096\u0013<ÃŒ'{Ã´Ã¯Â¼\u0006Ã§Â®z\u0017_Ã™ÃŒÃ–_\"\u0087ÃŸÃŽ\u009eÃ‹Ãš!Ãš\u000fÃ»Ã§Â¦Â£\u009eÃ³Â©~\u0093Â¾\u0080\u0007\u0002Â³hÂ³Ã¿ÃµC*~Ã©\u0004Ã®Â¿A\rgÂ¨Ã£\u0095Âª\u008d\u00170ww#Ãœ\u0082\u0090\u0002Â©w+Â \u0011\u0005[\u000f\u0098ÂµÃ®\u0080\u0018Ã‡\u0087S\u0004H\u0094Ã•Ã„l5Â±~.Ã-^R(\u0082ÃˆÃ½Ã¿Ã…'\u0091ÃÃŽ\u0016\u0084\u001bÃ¸Â®\u0081pa\u0093Ã™f2!VjÂ®YÃ¯ÃŒX\u00adÃ£Âª/\u0005\u000b7\u0014#Ã·Â¿Ã¹Ã¤\"SÃ¨5Ã¯\u009bÃ”\u0001HY1\u008cÂ¬Ã²Â°84\u0004!S\u0011\u0014VÂªEÃ³T\u0001\u001e}\u0005V^Â£#3Âº\u0018\u001e\u000eRÃ§\u0089\u0018\niÂ¹Ãµ&|oÃ¸\u009fÃ«RÃ®t@\u0089x\u0080Ã¡\u0095Ã‹{\u008fÂ¥Ã¯UY\u0083Ã‘Â°\u0018Ã½Ã¤Â©Ã‰$\u008c\u0001\u000fÃ‚aXÂ¬Ãµ\u008f\u0082Ã€]\u008eÃ¨Ã¿\bÂ¼j37?\u0000ÃŸ\u0093\u008c\u009eÂ¯Ã¿Âµ\u0088Â¡\u0088Â¤Ã¾Ã­\u0007\u008b\u008fÃ¤ÃªÂ¬Âª\u008fÂ¼>\u0089Ã­\u001eÃŠÃ³Ã–Â»Â¢\u0007\u008a`dHÂ½Ãˆ6Ã³Â¨\u0088\u008a,Â³FRÂµ9ÃZÃ«\u001bD\u00ad\u0093\u0007Ã¹'ÃoÃ‚\u000e\u001c\u0081Â°/Â¯4\u0088Ã³\u0007\u0007Ã·Â½\u009c\u008b\u0083M\u0094#\u001eÂ£3\u0092)Ã¼\u0007\u0013Ã—\u0006Ã¬\u0001Ã™Ãª~O\u008dNÃ¬UÃŽ\u008bM?]ÃÃµ\u000b\u008eh\u008d\u0094o\u008eÂ²aNIÃ½QÃ­ÃŠGÃ‘Ã§&\fÂ¢&Ã’}T^Ã¿yÃ‚Ã„&Â£EÂ¼pÃ…EÃ…\u008fÃ¼\u00ad\u001fÃ®Ã³\"Ã¤Ã“Ã¸Ã³Q,Ã¨i\u000f\u001dg\rÂ§}\u008dCÃ EÃ¡2l<\u0097\t\u0018NV\u008d\u0099Ã¦\u009b\rÃ°]wÃ²Ã­\u0014`\u009b~\u008a[l<Ã¤Ã®\u0096ÃºeG\u0000\"\u009f4Ã²\u0018Ã•)Ã³Â¼2#Ã®\u0016Ã¥\\Ã T(N0N\b\u0005\u0083\u0007Ã¹Ã\u001e\u00972T\u0084Ã¹\u009dÃ†Â¯H{B\"Â§-\u001c\u0013ÃžÃŒp(r?h Ã‚\u0002\u0099o8Â \n$Ã­Â±:R{\u0012\u0005iÂ¿GÃ›Â®Â©Ã¯\u0099Ã¡hÃ­,\u0093Â«Â±Ã‹ÃŽG\u0081Â´BÃ_Ã¿C\u008bw\u008cÃ¾Ã²K2Ãˆ`Fc8mP}Â©Ã¢Ã(Ã˜ÃƒÃ¼$\u008cH4Ã®oÃœN\u007fk\u009c6ZfBÃ©Ã’\u00022ZÂ°&R\u0088Ã¬Ã»\nÂ¡Ã¶Â¶I\u001cx\u008f\u00ad\u0097Ã«\u008fxÂ°\u0097~\u0006{Ã­Â«\u0088TkÂ¬{Ã³+I7Y?AÃ’Â¢v0Â¯\u009eÂ Ã¼vÂ¯Ã£Ã®~8Â¤7n_om0\u0091h>)Ã‚\u00adeM\u0093Âº\u009f\u009c\u0015N}Ã¥qÃ™6~jÃ³\u001b\u008dÃ›`Ã Ã•XÃ©ZÃ–Ã’\u001bÃ±,&\u001bÂªÃ•X^\u0090#Ã´Ã¿\u0001o|Â³Ã³Ã«,Ã°HgÃ¡I\u0017|xÂ Ã¿Ã¢Ã±\u00ad\u000bÂ¬NS\u008e|B\u0000~\u009eÃ\f\u001eCFTaW\n\u0004Â§\u0016ÃŒ\u0086ÂªÃ¤Ã¹Ã[2hPx/@Ã›Ã›@Ã¢fDÃ±Ã±)Â¬Ã»caÃ´\u001bÃŠ\u0083Â§ÂºÂ»Â«\u0018Ã­@\u0093Â¡m\u0000N-I\b\u0083\u0090QÃ¦\u009dFÂ¹Ã‹\u0006Â¨Â¶\u007fÃ¾u\u000fÂ²Â«z\u0083~Ã†D\u008c\u0096Â±\u0001Â±:Ã \u0000/l\u0082ÃŸjÃªÃÃ—`Ã¾'Â£Â½QWqÂª*\u0000Ã•d\u0083ÂªbÂ«\u000efÃŽ=\u0082Ã Ã‚4Â²rUÃ Â·ÃŽÃ¢\u0099RjÂ¼Ã4iÃ€YÂ¤!L$Ã°\">\u00996\u0082\u0096\u0018vÃ±Ã¶(Ã—\rÂ±\u001da2Ã¶-\u0083Â¥Ã‚\u0088b\u0000DÃ°\u000e\u009506Ã·\u0091mGy4GWCÃ’Â±[Â¾['~rÃ‚Â£Ã¤\u0094b}ÃŸcÃ¤)C(Ã—KD\u0082Ãºu_\u0086Ã»Â·+Ãœ\u0095\u0002pÂ§\u009eÃˆÂ¾\u0081XÂ©\u000b\u0014\f\tÃ€e&\u0099Ã¢Ã‹'qÃŸ\u000eLÂ±Ã¢hÃ¶Â¼Â®Ã¯\f3Ã‘KÃ­Ãe\u001fÂ¬Ã¢Ã¹Ã¼ÃžÃˆ\u00024$j4Ã¬Ã–$\u0010Ã¦DÃ¶tÃ¼\u000e\u0003ÃœN\u00adÃˆÃ°Â¬MLÃ«uÃžb-Â¼kQÂ¾-yÂ²2\u0093&)\u008d\u001cW\u0094\u0093^\\\u0092\u0013T\u000eÃ¥Ã›Â¨\u0093Ã„\u008fÃ†>jÂ·\u00ad5Ã±Ã±n\f\u000e\u0005Ã§ÃµÂ¿Â¾\u008fVp5-\u0090=>Ã½a\u0084ÃpÂ¾#Ã¡oÃ›Ãƒ8ÃˆÃœÃ¨Ã˜Â½\u008c\u0095\b\t\u0087!Â¥Â¼Ã†Â«Ã·Â½\u008amÃ·Â»Â¦Ã.Ã½Ã›\u00adÃ³\u0003Ã•Ã¸Ã«<\u0086 woU~Â¥\u009aÃ»1\"\u001c,ÃµÂ¼Â¦MxnWÃ}Â»ze\u0080Â°2\u00940Ã±Â¨Ã­T(ÃŽÃn\u0091\u00030Ã‡Ã¸#Ã‰ÃŒ\u0090Â´\u0091\u0002Ã‚\u008eÂ³RÃŸ.@\u0084\u0092Ã€pFÃ‚W\u0005Â¥Ãž\u00ad\u000fT\u008dÃ–\u0082Â°Ã»\u0096E\u000fÂ¹\u009b>Ã°IL@Ã‘#Z1\u0018\u0006Â r\u0006XsÃ\u0001'Â´\u009bÂ»%Ã•T_\u009aP\u0007u*\u0093Ã¿4Ã’.\u0006Ã­!Ã€>4\u0083Â«Ã‹Ã²\u0018Ã¤9\u0098Ã½Ã \u0002\u0016Ã§\"%w\u0083ÃÂ¿\u008e&Ã¸Ãµ'+Â²ÃŸ}d:Â¹\u000e\u000eT5@\u0005Â¦ÃˆÃ±taÃ’\u0097\u008a\n87Â¡\u0087\u008c\u0096Ã¦RÃ™Âº\u0002g\u0017ZxÂ¡UÃ Ã½>R&Ã“.\u008c\u0084.FÃ¯Ã¤\u0095B/5F\u009eiÃ¢jÃ²!\u0003Ã ]M3z\u001a\u0012Ãº,q\u0084j\u0088Ã€J\u0081uÂ¿oÃ¯Ã³j\u001bR~ÃˆÃ¥\u0006\u007fÂ¿Z\u000bÃ˜'\u0090at\u0080ÃŽmDÃ³\u0007Ã¶ÃŒ#\u0000/gmÂ¦\u0096Â³o6\u0089Â¼Ã´4\u0001\u0085s`\u0086\u0099CÃŽ\n\u0010\u009c\u0018Â¥Â¸Â¥\u0080pT\u0016Ã§Â·\u0011\f\u0090\u0005W Ã¢Â¯1\u009ca}Â´Â¶+Ã Â©JÃ‘\"\u0016\u00832Ã­\bÃ£_\u00adÃ¦Â¨`Â´Ã\u009bÃ—Â¯Ãº;ÂªÃŠWc\u001b>7BÃš\u0001mfÃ½\u0006\u0090}ÃˆÂªK0.Ã¬BIf\u008a\u0090(FÃÃ…Â¶Ã‰Ã¤bYm\u0004Ã­Ã†\u009e\u008eÂ¨HÃ¿`IZÂ±\u0082Ã¹\u008dÃ¶\u008e\u0015Ã›vÃ©K\u0005Â´Ã–Ã‹\u009f4Ã½\u0015Â·4:\t\u0092iÃ©\u0099\u0018{Ã¬@ÂºKMÃºQÃ¦Ã¤Ã”Ã¤Â¼@Ã‡}Ã¨n\u0016O\u0017cA\u0083\u000fÃ°Ã²\u001b8Â¶Ã«<ÃžÃ0\u0007NÃ¨-]\b>5tÃ§ÃŽÂ [\u001aDÃ²\u0084Ã¼\u008b\u0092\u0082\u0082Ã¹Ã°\u009c|Â½rÃ‘Ã¬Â»Ã½7\u0012\u0000ÃƒÃ§Â«DÃ\f\u0091uÃ¡q7Ã¦MzRU]\u009bÂ¯Ã„\u009e+\u001eÂ®\u0015ÃŠ_Ã€Ã—X\u0005Â½\u0083\u0010Âµ\ry5\u0005\b6\u0080\u0018'\u0092JÃ­\u001a\u00192Â¹\u008etÂ§\u0080Â¨Â«.H\u009dÃ…Â¼\u00195=ÃƒE6e\u008aF4eÃ¯TÂµÃˆÃ“\u001aBÃ§iÃ«\u0092Ã§\u008f\u0016\u0099Ã²Ã³\u0013Â¶\rÃŠÃ¦\u0082Â¹*ÃŒÂ¥ÂºÂ¹\u0001+o\u0095 Ã¡Â¤zÃ­Ã•0Ã¾P5\u0005Âµr\u0096D]Ã¹;Ã”_Â¦_Ã†Ã„ÂºÃºÃ¾j\u008b\u0096|\n\u0080j\u0005~sÂ¦\u0081Â¡\\Ã¦Ã­z3\u009a\u0094Ã­Ã²Â´>^'Â \u001c2Ã‡\u007fXÃ†\u0097Ã¨Ã€{mtÂ®_Â¨9\\Ã—Ã¢Ã¨Â¥\u0089Ã®nPÂ¤\u0086Âº6\u0098pÃˆ]\nÃ¬Ã²oÂ®LÂ®\u0088.Â£4\u0087\u008cÃ’!0Ã·\u0095Ã ÃŸÃ‘\u0097\u0083Ã¹Ã§Ã¿\u0084\u009eÃ‰ÃÂ¥Ã€ÃŒÃ¨@C|Ã\u0004Ã¯\u000fo\u008cÃµc|ÃYÃ¦L\u0085m?YÂ¯snas\u0095\u009e\u0081\u007fQ\u0080Â¹F#Â¯\u008a\u0096ÃŒÂ°_M\u0082\u009e\u009eIpÂ¡*i\u0095CÃª-ÃŠ\u0000Ãƒ\u009cÃ²Ã‘Ã\u0015}ÃŽ\u0010\u0095\u0006`nJ\u0011\"Â¾\u0003Â£[Ã‹Â¦J!\u000b|Â´IÃ…tVÃ’\u008f\u0016\u0014/\u0084Ã–1wÃ€Ã²!\u009c\u0016Â¨\u009e`Â¨Ã®#\u009eu\"8Ã©\u000e\u0084\u0089Ã¾Â¡AÃ±\u008dÃ\t|Ã‹> Ã¿Ã€Ã&\u0018Ã»NÃ´\u0081PÃžÂ¬Um\u001aÃ­Â»OÃ·\u0014Â¡\u0001ÂºBÃ¤Â¯Ã²Ã·\u009f\n\u0085Ã¥Â°y\bÃˆÂª\u0097Ã”dÂ£uEÃ¯\u008f\rÃ GÃˆÃ‘Ã‘Ã‹Ã‚x4{1\u008a\u001e6WÃ˜OxÂºÃ—s\u009dÃ›7\u0010xo\u008e\u0092\bÃ}Ãª\u0093\u0010beÂ·PpGÃ…Ã‡Ã¹\u0000Â§1.Ã‡Ã³\u0087\u00adu\u0087Ã“\u0006cÃ±Â±\u0013F#8IÃ»\"/\u008a[Ãš+4\u0087Â¿x\u0099Z\u0082Â¦Â¹Â¶ÃˆÂ³Â¨\u0000y\u0081EÂµÃ£Ã±\u0098\bY\u0002Ã²Â§gÃ²LÃž\rÃ—ÃšlÂµMÃ¢J\u001d\u0090G\u007f\u009eÂ¤ÃŽÃ¡J\u000bÃ›3T(CÃ¿Ã¾Ã”Â¡\u0094\u008ciÂ¹Ãš=\u0016Ã‘ZDÃ›8\u000eÂ´\u008dÃŒÃ–Ã·\u000b\u0089Ã´\n9Ãª@$Ã ~}@ZÃ‡q\"CK\u0010\u008cTÃ‚fHÃ˜.0Ã‚Â»\u0098ÃœÃ“ÃŽ\u0090Â¤k|3Ã±F{Â°Ã‰K@?[yp\u000eÃ“z4gÃ¸8=\u0003I^\u00136Â¹Ã€\u008d\\Ã«\u0094pÃ…gjÃŸD5\fÃ‚aÂ½V\u0089DÃ©\u008a \u0095\u000e\u0090-_AKÂ£Ãºm\u0086\u001a*Ã¬+Em|,\u008fÃ«\u0096\u001fÃ‘Ã¼\u00177\u001agbÃ \u009d%>P\u0098lÃ\u0012Â²Â¡]}\\Ã‘hRÂºh\u000b\u000fi\u0002\u0003KÃ±\u0011Ã…\u009e\u009aÂ£9P\"Â£\u009e\u007fÃºÃ‘u\fP\u0004\u0086Ã…$\u008dIÃ¬Ã–Ã Ã¡ÃžÃ¯\"\u0093Ã€\u0083\u00805\u0094\u0092ÃŸÃ#Ã®ÃÃœ\u0083Ã‡\u0085ÃtÂ¿Ã®\u009e\u008dyÃ³Â²\u008bÃŒ.\u000f\u0093Ã¼_\u0001ÃÃ–\u0099\u000bÃ•6Â£Â¬-\u001e^#$Â°\u001e;a9KÂ£\u0096{\u0014Â·Ã¹\u0084/1\nv\u0004\u0084\u008a\u0007\u0018\u009cÂ½Â¬s.&Ã»Ã‰?MÂ´Â«M}RÃ±Ã•vÂ¶\u0002$\u0081q\u009b\u0017b\u009f\u0081Ã§]Ã›Ã²Ã¼ÂºDÂªÂ¶Ãµ\r\u0096Â¼\u0093.n\u0012Ã®Ã£\u0084b\u0011a\u0091Â¿\u0086\u0089Â³Ã¸Ã±Ã \u0099\u00ad\f6Ã›ÃŸ&f\u0007q\u0095\u0092Ã¹Ã¹Ã¸=Ã·Ã¶!2\u008fIÃ“\u0092\u0095U!Â¶\u0098Â§V\u008c*uEÂ³7Ã±Â®keÂ¥Â¡Â©\fÂ³Â³zÂ¹Ã \u008f\u0006Ãº4_)\u009ehb\u0019\u0011ÂºCÂ¼Â¨Â°Y\u0006ÃÃ¬Â®\u0090Â¾ÂºA|Â´xuo\u009cSÃƒÃ@PLQa\u001a7Â£ÂµÂ»\u00077\u008aNVÂ³wÃž(Â¼RgP\u001dÃ›ÃXÃºfÂ¦f\u008bB-Ã’xÃšÃ½q}\u009bÃ\u001fÂ¼ÃµL\u0018G\feKÃÃ‡\u0000Ã’%Ã‚Â²Â¿Ã·\u001aU\u009d`\u001aVTÂ¡,ÃŽRD\u0083\u0097/bTGH(7Ã˜A\u0017b\u0081*\u001d1n+Ã¤\u009f\u008bÃ©\u0002\u0097Â½vÂ¦KÂ»^Ã¿OÃ3Â¾\u000e\u0098Ã£Â¶Ã‚Y\u0085ÃYÂ¼\u0004Ã†H\u0096H\u001eÃ®>\u001f\u0013'\"\u0088\u008c/Â¶Â¿\\lGÃ„j~\u008a\u0081Ã‘Ã½\u0094^Ãš\u0086'Ã³Ãª\u0096Ã¢\u008aÂ¥Â«Ã…ÃVÃ³Ã\u009eT$\u0006'\u0002(\u0012A\u0004Â¦\u0098Ã¤lÂ¹\u008aJ\u0016UYÃˆ1}\u000fÃ†\u0011\u000e\u0014}Ã‚m\u0014Â¾Ã™\u0019o\u0081Â·Â¼\u0084Ã¸Jm+ÂµJÃ“^\\Ã½Ãžw\u000fÃ–\u0014ÃŠ\u0010ÃÃ‚Ã \u001bYÃžÃŠÂ£Â¶Â¾ÃœÂ¸\u0005Â±Ã¥Ã°Ã”=Ã‚ÃŒÃ™\u0091rÂ¹*\u009b\u0095Â½\u0000uÂ¦\u0001V\u0004Â¼\u0002Ã™\u001f\u0080Ã™\u0088Ã“Ã½Â¸2\u0087Ã‹\u008fÃ«(Ã¢\b\f\nN\u0013oÂª\u009aÂ´}Ã§Ã¿\u001a\u0011OÂ´\u00adÃ—E\u0006L\u0092\u0089Â¾Â¨ljÃ¢Ãœ\u0001Â·Ã›@\u001c2\u009b8\u000b\u0013\u008bÂ«1\u009f\u009e\u0096Ã¤Ã„ÂªÃÂ«@kÂ¿gfÂ¦SÂ¹Â¹Ã²ÃµÂµ\u0090Â³Ã\u0000{:Ã¨\u008aÂ¡c0Â´g-wÃ\u0005\u0089Ã˜iÃ¾#Â±wÃÃŒÃ­\u000fw\u001eÃ¥vBM|\u0011ÃÂ±H4\u0014R\u009dÃ˜Ã­Ã¸\u0013\u000eÃ†$Ã½\u0003ÃšÃ‹Â¸G&\u0017B\u001ccW\u0015Ã‘@Ã 5 ;\u0018SÃ›ÃŸ\u0015\u0006:Â¦(Ã”LÂ«*Â·L50^Â¿\u009dÃÂ¼Ã¤\u0000O0\tJ[Ã¯<#Â°Ã¤Ã¥Ã¡ÃµB\b)Âº\u0015\u000b\u0095]ÃŒHQ\u008dÃ„rÃÃ«Â²Â¾ÃªÃ¨Ã©\u001f&Â©RÃ¢QÃ‡L1\u008a\u0094>\u009bÂ´?ÃšÃŽÃžw\rG\u0080CÂ²Ã­Â½\u000fÃ‰#ÃœÃ›Ã¢\u000e\u0089\u0098\u0090M\u008cÃµkÃ‰Ã tz\u0087{7uÃº^Ã\u0089PÂ³\u0018ÃšÂ®Ã\u008bE5\u0095Ãº\u000e^Â´BÂ«s\u000e\u0010Â \bmÂºÃ²TÃ¼Â»Ã¾\u0085\"Â·Â£\u000e\u0011 Â¨v.\u0006\u0018TÂ¦ÃˆÂ½=nv\u001aÃ§V\u008cÂ ÃÃ”|Ã£Ã›\fÃ»\u0005\u00911Ã½amÃ„Ã­]Â®uRX3Ã¤Ã§\u0016Ã¹Ã·VÃ£.\u0091Ã²\tHÂ \u0092\u001fÂ©\u0098-*Ã‹Â´Â¼8Ã’\u001d1\u0005\u001ff\u0003m-\u00037ÂªÂ»:Â´\u0098Ã–hÂ²\\#Â§W_Ã¿Â£\r\u009cÂ®Ã… Ã»\u0001QÃŽÂ¯\rÃ¹\fÃ›Ã¬Â±Ã¶\u0001U\\Ã“_ÂºrÃ©8\b\u0099\u009e:,Â´Ukz\u0094\u0007Ã¹Ã¨ÃŒÃ¨\u000fÃ…\u00981\u0086yÃ›\u0096Â¥Ã”\u0088dÃšÃ‡Ã¼Ã¡Un\u009e\u0085Â«\u00ad$,Ã¬UAj&Â¹EbÃš\u0080[\f\u0092i\u0019\u0017Ã™?Â¾CÃž\u0002CÂªÂ¾\u0015Ã«Ã¡UÂ¥Ã˜\u0096Ãµ(\u009dTq7%\u0082\u009fXÃ¾Ã¹SrÃ‚\u0082VÃ®Ãƒ^>\u0099sBÃ›'Â¿\u0097\u0006Ã¸\u009aÂ¬pÃµÃ±g\u00adlÂ®\u0006E\u009c\u0092\nkÃ§Ã¤Â V\u0017ÃºW\u0018 \u0007Â Ã·Ã´7Ã´Ã‰\u0017Ã¬Ã„Y'ÃÂ²\u001fq?Â§\r\u00ad\u001c}Ã±Ã‡NÃ€\u009eÃ¹Â¨Ã€Â¼Ã†ÃˆÃ£ Â¡ÂµmÃµd2\u0010ÃŒ\u0002TÃ§}\u0005hÂ¤\u009bÃ{5Ã„,/!\u0098Ã»Â°ÃŒ\u0000.xd\u0085\u008c Â¦Ã¢\u009fÃ®Ã®Ã1r\u0002Â¶bÂ¤vÃªÃ¯ObKO#Â®#\u008fÂ¬ÃªbÃµ~+Â²\u0099Ã©Â¦\u009dÃ‘Â¾<\u0012Â¿C\u0017Â©\u009d&\rÂ¡\u0018\u0005Â²gÃ¿1\u008a\u0096\u001agmÃ`ÃŽ\u0095\u009cÂµD&\bÂ²a'UÃ¿Ã­T\u001c{Ã¸]Â¦TÃ«*o\u0006\u009cÃJOÃ‘?g\u0090ÃŸ\u008eÃxÃ‡l\u008bRÂ¬Â¬Ã®\u007fÃ’Ã¸G<\u0003h\u001eQ\u001enÂ§Ã´Âµ1Ã‰Ã˜R\u0016\u0014Â¼QÂ¨\u001dÃ¿Ã˜Ã‘Ã¥ÃŽw%\u0085Ã½Â¨\u008aF\u0016\u0091\u008fZ\u0096\u0000R\\WÃ‰-\u0001RÂ¥\u0006ÃŽ\u0093\u0081FQ\u0089;\u0098\u0093BÃŸÃ˜Ã¶W\u009bÃ€\u0089ÃƒM\u001a\u0019Ã¹R{\nÃ¼)Â¸\u0017CÃ­iÃÂ¿x/LÃ\u00ad&Â©x\u008d\u001a\u0094Ã¡Â·\u001fwÂ¦uÂºÃžÃÃ¾\u008c\u009fÃš\u0012iÂ£Ã”\u0086ÃªLÃ\tn-Ã\u0000\u0005\u008d&2Â¹\u0096Â¶!!4\u009db\u001e{Ã·\u0003'\u0011Â»Ãž0Ãº*Ãµ\u0092Â¨\u008a\u0007\b;n@Â£Ã¸Ã\u009cÃ¸zÂ¶Ã‹\\YÃ‹\u0087P_e},q\u0001\u0087\u0001Â¨Ã“Ã«ÃŠÃžÃ·Â¹ÃŒÃ·Ã¥Ã¸\u0012Ã·Â®Â©vÃ±\u0091|R\u0013\u008c8Ã­Ã³gÃ¡\u001dÂ¶\u001cÃ·)Â¿Â½7Ã”\u0001vÃ˜+Ã‡Âª\r}Â¾/\u0005o)Ã¬UÃ£Ã“bÂ£\u0016W\\Ã¾MÃª\u008e\u0082Â¤D\u0095\u0002Ãµ\u0006Ã˜ÃŠ#W[\u0099Ã¯Â§Ã”Â¯nÂ»W2Â®\u0087Ã·\u008b&\u000eÂ¬ÃÂ¤Ã›ÃˆÃ¸Âªs\u0081\u0002ÃŠÂ§\u0090\u001b\u0081\u0005\u0099Â¾NÂ¬Â¬x>OÃ¤~H\u0087=\tjÃ„3ÃƒÃ–0c\"^vypÂ \u0017\u001e:Ã¼ ÃµY8B\u00adYF,FÃÃŸ3U\u0092^.Â«\u0080Ã¿Ãˆ\\KÃ˜Â¼\t\u001fW!^Â¼Ã¸\u0086Â¾BÃ²\u0092Â©Ã»QÃ¯Â§Â¨Ã­Ã¹ÃƒOÃÃ¬ÃÂ¶\u0012\u0016\u001dÂ¯\u0011\u008dVÃˆ0Â´Ã‘#Â¸\u009eR58GÃ¯%ÃŸ\u0013\u0005Ã”pE\u0093Jx)Ã\u0013Ã­\u0019Ã§fÃ¯\u0094ÃŠÃ‚\tÃ¿Ã£:Â¿BÃ¢\u007fÂ¾ÃŠTN Ã’@\u0005m.Ã“Ã”Â»KÃ¬Ã›nÂ¯\u0004\\\u0000Ã“\u008fvÃ€\u00014esQ]-Ãž\u001d\u001eBfgÂ²qC\u0094\u0083dz\u0090Ã\u000b\\\u0099Ã„\u001e\u008cC3\u0081Ã‘\u0010Â¯Â«\u0005ÃŸAÃ°OÃ ?bÃ¦S\u008c\u0086Â©\u000fHÂ¢\u0080Ã¤\u0089Â¹\u0007CÃ…0=ÂªÂ¾\u008f\u0095\u0092;\u0080\u009e\u009b\u0090\b\u0017Â aE^\u0010\u0098>.Ã‚Ã½)Â¯ÃšÃ‰Â®Ã§Q]Â¢\u0006EÃŸ^Ã\u00025)e\u009eÃž\u008f\u0094*sÂ¼KDÂ¡Â¾\u0089\u001e\u00910VÃ…\u009ct\u000bc\\Ã²Ã Â»\\Ãªi\n\u0098TÃ‹\u001eÃ¦Â®6p\u0006\"\u0082Ã†iÂ¤:Ã‰Ã¼Ã Ã¯Ã˜\u0099[Â¹xv\f\u008b\u009c@Ã™\"T}Â¶Â¿Ã‡Kp\u0096\u0001Ã³\u0081Ã»\u0013\u00149'Â´Â¥3Ã¯ÃžÃ£9\u0001Ã§ÃŸÂ²`Ã£dI\u0086Â©l9>Ã›ÃŒÃ‰Â¿WÂ¼ÃºÃŒYAÃ†Ãw\"Â¬1'J1+cÃ°JÃƒÂ©\u0094\u0085r\u0081Ã™ÃŠ\u001bÃ¢Ã¦Ã³Ãƒ4\u0092tÂ¹Âº\u0091Â¨ÃÂ¡Ã«Â´Â¿w@\u0096,Ã‘Ã¢s\u0097Q:OÃ­\u0080Ã©\u00124Ã Â¢Ã–;Ãª\u0010Ã†}ÃœÃ…Â¬Â£Ã†Ã®Â·Ã®pE?|\u0002\u0092\u001d\u0085Ã•\u000bÃ¡,pÃÃ¶\u0012ÃºÂ¯-\u00019Ã¨1Q\u0014Ã\u001a<YÃ¨Ãœ\rG\u0005w.Ã?Ã›#Ã³{\u0010Âª}o\u0005lFY\n\u0003*Â°PG9\u0099Ã\u0002WÃ‹_\u000b\u0084Ã´\u0004\u0087\u0015Ã«4\u009c}Â»ÃŒ!,\n\u0013Ã¯B$@Â¾Â¬Ã»\\Ã¾Â±H7Â´\u0010\u0098Ã‘*Â¸<ÃŠI\u008eÂ¨8\u0093\u001dÃ«FÂ [Ã‚-ÂªÂ´o\u0015\u0089Ã­5a\u0003xffv\u008dÂ¾\u009eÃˆÂ¬l\bÂ®>0\u001dÃƒ*$C\"\u009dÃ“]\u0000Â±?Ã´'\u008a\u0013\u0098J.I\u0018ÃÃ·Â¤\u0093\u0006Ã†Ãµ?Ã Ã‹Âªb\u007fÃœ>+\u009ap%hÂ¨oOÃ¾gÃŸÃ†Ã…\u0085ZÂ£:\\\u0004\u009b`Ã—\u009c\n\u0093\u0013\u0013\u0089s\u0090Ã·Ã‘KÃ«\u0098Ã¼\u0004e\u0004PD\u0006\u0086,Ã€Ã²\u009b[j\rL>\u0092Â²iÃ¸Ã›Âº\u000b6ÃŒÃµÂ¿liÃ©\u008fÃ\rÃž\u009bÃ¼\u0087\u0010\u0098Ã£e4sÃ¸c\u000eÂ»yÃ³\f\r\u0014$\u0007Â«Ã»Ã€2\u009eÂ¾Â²u?'Ã¤Â¾u/\u0080\u009e^Ã‡XÂ´_Ã¾Â¥Q7\u0086(Â»\u0084YÃ¥OÃµ^P\u00101\u0018 %Ã™Ã¡Ã¹\u008eÃ­(Q\u0004\u0006e8ÃžJ\u000eGÃ™4\u0006\u0081\u000fxXv\tÃ»ÃªR\u0012o*\u0092=RÃ©$Ã»qfÂ¿Ã­Ã©\u000e\u000f~Ã¸Ã˜\u000e'Ã—HÂ¤\\Ã“r\\\u0098Ã‹Ã¼' f|Ã’Â³Â£$;Â¥M\rÃœ\u001b'\u0010Ã•Â°\u009a\u008dNKÂ¼Ã¶\u0097 `EÃž\u007fÃ—Ã§\u0002\u009fÂ¯Â·Ã‰\u0092Â§5\u0091B\u007fÂ«Âº\u001aÃ‘\rÃ‹A\u0003Ã¼\u0004m_Ã}Ã·Ã·Ã†S\u0015Â¸Ã'Ã‘t\u001fÃ†hV_rÃƒ`&Ã©ÂµMÂ¼DÃ¨CÃ‰.Â½Â©6x\u008c\u001a*34\u0088\u0016Ã’\nmÃ‹x\u0007VÃ›Ã¬XL\u0082Ã£Â´Ã¼ÃƒÂ±z\u008fÃ¾\u0099*8vs1\u0090\u0091\u0098\u009et\u00076ÃƒÃ±Ã¸m\u000b3Â½\u0000lLÂ§%Â«$)\u000bÃ«ÃŒ8\u0083Ã«ÃžÂ½)\u0092Â½r\u0097\u0012\u0098Ã¶\u0012O\u009aGÂ»ÃÃ¤Â«Â¢\u0013P6Â²Ã»\u008a\u0010%Â¨]P\u0089:Ã«Â¯ÃºdXÃ¶Ã&Ã Â§?\u0016LÃ€Â°Ã‰Â¿\u0096ÃyÃ¹tÃ„\u0091a\u009eÃ¦#Â©>Â¹NÃŽÃ³Ã†=\u0099Ã«Ã˜\u0017Â·<Ã„4)\u0093\u0019\u0019Â°Ã„M\u009cÂ¨:.Â¦\u0086Â°Ã°\u0002\u009f@\u0081\u008cÃµÂ¦Px]Ã¡Ãž\fÃŸÃ‹\u0007P\u0013K\u0012Ã•Â±kRÃ½@\u0080Q\u008bÃº$\u00986\u008av\u0097Ã·Ã˜ÃÃƒwIÃŸ\u001e\u0098\u0017,Â Â¤\u0089FÃ¡\u0095Â¤ÃŸ\u0007Â´Â¾Ãœ<\u0007\u0017Ã¢Ã¤\u0011Ã±Ã±R\bÃ·Â©\u009e-Ã\u0006P\u001e\bWÃfÃ¡Ã¡Ã­^Ãˆ+\u0001C\u001a\u0082cÃŽ\u0085Ã°Ã´Ã„|:'cÃ\u0094Â¾OÃ¼@j\u0003Ãž\u00000Â¨Ã–RCGW|b\u0018FwÂ¼Â¾Ã‰\u0090Â©Ã‡|Ã‚|\u0086\u001e\u0010\u0089Â»}Ã…Ã–gÂ¦S\u0097yÃ‡}Â·\u0002\u0016Â´\u009fLeÂ²Ã¡1oÃ›Â±{\n\u0015*tfÃ¢\u009fhÂ¬D\u0006\u0003\u00186Ãºf\n\u0087]K.Ã§Ib\u008bÃœ\u0017\u0091\u0092Â¨Ã¥ÃL\u009fÃ¬\u0092AWXÂ¥Ã™D\u001f\u0081ÃÃ˜Ã·o/F~\u008d\u009e+BxlÃz\bnÃ¼ZkÂ»Â¦X:\u0015Â©Ãœ'Â®\u0082Â¦Ã’GF7Ã†=Ã«LÃ¢Â¤z7\u00adÃ´BzÃ¼Â¦_\u0095Ã‰/Ã¸)Ã€Ã¾(Â»Âº^%jÂ±Ãº]tÂ³uÃ±8Ã‡r\u008fJÃ‘b+\u0001Ã°Ã\u0000Â£_Â®Â»=ÃµVÃˆÃ¡6iQE\u0097!DÂ¹Ã½{\u0081Â¸cÂ¶\u0081#Ã3\u0011K\fÂ¸Ã€FÂ©@QÃ¤xÃ²'Ã”\u008a\u00ad\u0097ÃÃ´AeMÃ¨ÃŸ\u00adf2Ã™Ã¶Â¥Â¸H\u009au\u0017\u0096\u0092Ã‹Ã¥Ã¯PÃ—ÃŸWÃŒe[\u001a_)`Â¡Â»;pÃ¯<YÃ’}\u00807iÂ¾Ã—\u001f%Ã»d\u009d\u0098HcIÂ§QÃ›Â±\u001cFÃ§Ã€\u0093ÃÂ³\u0081S|\u0088Ã—DÃš\u008erÃ¿Ãž\u0087j\"\\\u001ebÂ¸!\u0087=Ã›#Ã©Ã¼D8oM\u0015uÂµÃÃ©6/\u008cTkÂ¼Ã´TTÃ¬Ãp\u001aÃÃ›'rmyÃ¿\u0097Ã‰\u001eÂµ`\u0089{\u0005DÂ¹\u00ad-Ã™qlvÃkÃžÃ£AwÃ‡\u008c\u0089Â¤\r\u009euÃ°o\u0089<+\u0087_\u0007\u0088\u009d\u0094bb\u0097mÂ HjÂ¹2\u0018yKÃ‘]DG~\u009f\u0086\u001d;Â£\\Â¢JÃ…\u00801\u008fÃ’ZRÂ©2\u001fD\u0092$Ã\u0091Ã¯Ãš\u0007\u0017Ã»\u0086Â¬r\u0010yÃµCbÂ¶6\tÃ¼\t\u0016Ã©Ã¦ÃœqÃ¤ÃµG\u008e#eÂ¨Â¬FV\u000e\u0092ÃªÂ¡ÃŽl\u0098a\u000eJ._cÃ¨+#Ã0Ã‡Â©Ã–@Ã»5kÃ©y\u009b^Ã—4WÂµ3\u0019Â¸bÃž{\u0096KÃšÃ€Ã \u001dÃ©Ã‡1Ã¢6R\u0085S:gÃ’ON=\u008bzÂ¢=Ou_'Â£Ã±\u0095vÃ°\u0090\u001d\u00120Ã‰Â 3\u008eÂ°\u008e\u009dÃ¡\u0091F'N5\u0093Ã€\u001d\u0003yÂ %Ãºq{Âµ=Ã¿Â©2]\u009diÃ¼(yvÃµ\u0001\u0014vÃƒ!Âµ\u0018\nz,Ã£ÃŠ\u00adt0Â°W\u007fÃ‹Ã¸VÃ¤Ã¦ÃqÃŸnÂ¹Ã¡\u0013Â²Ã·0Ã®ÂªÃ€Â»QÃ¦@\u0096\u007fÂ¦4%Ã‘Ãº\u001bqÃ¶ÃªÃ‡qÃ‡Ã³\u0087Ã;\u0016n.1!.O\u0017\"y\u0092,Â¦'r\u0088Â»Ã…Â£Ã¼Ã­)\u0018/Â·.Ã¹Â¯Ã•p\u009aÃŽ\u000bÃ›Ã°Ã¡\u0012OÃ‘\u0084Ã\u009c<Â¯\u008dY|xDÃ…\u0099Â´v\u008f\u0098Â·Ã•Ã—{\u009005Â«~Â¶\u0083XÃ¦\u0019D\u0007*Ã™\u0007Ã™P\u007fÃª\u008aÃ–\u001cKÃ³nwÂ£Â´ÃŠ\bÂ«Â´Â¶\u0099qQÃ§\u007fWJ\u009cÃŸ Â°}\u0080\u0003Ã³Â¬Ã´Â©Ã«)\u0085\u0014Ã¢ÃŽpÂ¯a)O/ÃÃ‘=@b\u0091Ã¥-Â«7\u000f\u0016\u0012{!@Â¯Ã–|Â¤\u0080ÃŠÃ‡nÃ‡Ã¼ÃÃŽ\u0018Â³\u000fhÂ¼=\u0088[\u0014\u0095\u0097\u001f\u009dj\u001bQ@\u008dÂ£Ã˜ÃŸ\tÃš\u0089ÃŽÃ¸Ã¥\u0002\u0018L\u0000\u0085o\u001btÃ‘tÃ—o\u000f(GÃ“Â´D\u008f*7Â¸Ã¦5Ã“psÃ£Ã±Ãž\u001cÂ©Ã¦\u008eiÂ´\u0089\u000f?Ã’\u0094Ã¢\u0097Ã¡\"Ãµ?\u0088\u0019J<Ã«yÃ\u0086yÃ‘Â«uÃªÃ½fb4Âº}\u0016ÃÃ‡kÂ«\u009bXÃ†\u0007\u0086Ã»C{\u008b\u0080\u00adÃž\u009aÂ¸Â½Â»,E1\u0007\u0007by\u0091Â§Ã®\f\u0080ÃºÂº\\'MÂ¿9\u0088q\u0081Â±Â¥ÂµxÃ‚Â¶\u0012Ã“DXÂ¥Ã†Â§\u008ftbZ\u001dw\u0011T\u0081({eÂ¶\u00195\u0085\n:\u007fuÃœÃ¯Âµa\u001aÂµÂ¼Ã£ÃÃ¬vÃ‘Ã°|Ã²ÃŽ\u001dÃ¨Â Ã®=Ã=\u001bÃ­\u0089Ã»Ã»K\u0097\b\u0093;\u000eÃ¥\u0019Ã«0\u001cÂºEYÃ©IVÂ²(\n7Â´.Â·'Ã ÃŸ\u0003#Â®fÂ±\u0088p\u000f1Ã•\u0010Ã¾\u0095\u008eÃ¢FGÃªH#\u008czÃ’rÃ½ÃŽ<`\u0091Ãˆ*\u009bÂ¬\u009bbÂ§#\u0091Ã„z\u0093\u0011Ã²mÃ–\u001aÃ¢\u008bÂ²Ã¡\u009fÂ±6!vw*Â½Ã¢`\u001c3\u0005Â²F2 Â¦$9\nÃÃK!\u001e\u0002A$Ã£k\u0087\u0094&ÂµÃ£Ã¸ÃŠÃ¨)Â°Ã€Â¨^UÃ­\u0099Â¸ÂªiT\u001bkÃ–Ã·2Ã™\u007fS\\Ãµ>&Â¿Ãƒ=\u0089Â¡O]\u009e\r&Ã¯A@\u00ad\u001f3Â¶yÃ¸ÃŠ\u0000Ã¯Ã†Â²da\\ÃÃ«o81zÂ³\u001dfÂ¬Ã£Ã¸\u001c\u008bÂ Ã‡(\u009c\u0012Ã™ÃƒÂ©ÃµÃ¥Ã¡Â½p\u0092k\u0096_Q\u0006Â¼Ã†B4\u008cg\u0000?\u0087Âº\fÃ‚Ã¿FÃª\u0080Ã²\u0092\u0084\u0013\u0016\u0095sÃ»Ã¨ÃŠÂ§1xÃˆ0Ã…\u0010;Ã³Ã–\r0Ã‰Â²Ã±Ã‚\u00854\u0098J\u0083I\u0017\u0084)Ã˜Â¤Ãµ\u0089\t!<Ã¢Â»ÃŠKÃ‰?\u001a\u000eÂ©Ã˜Â¤Ã£Ã¹m\u008f$Ãƒ\u0089Â¼\u0013Ã‚\u008b\u0089ÂªÃ¢\u001eÃŽÂ£Â¥aÃ¡Â·\u0088Ã¯,G=\u0013_\u001bNÃ¿\u0097JÃˆÃˆ\bÃŒ8Ã£Â³Ã¹Ã©E\u001dÃ†\u0002\u001dwÃ\u0089\u009axÃ¹:Ã¥Â¥\u0081ÃŠ\u0096Ãƒ\u0089Ã•Â®Ã¦RÃ¶ÃÃ¬O|Ã¬\u000f\u0084\u001cÃ\u008bÃ¾\u009cÃ­ÃƒF|Â§;Â¶3ÃƒS7\u0010\u001a\u001fÃ†\u001eJÃ­Â°HRÃ›-\u0010\u0011\u00971Â·\u001fÃ³>\u0081Ã›\u0094\u001eÃÃ¡?\u0001\u001eÃ«\u0092%\u009d?vo'\u0086\u000fY-Â£x\u0000ÃŠdÃ†Ãº\u0090uÂªÃžE\u0093\u000b\u0089\u00ad{\u001fÃ¯\u008fÃŒ\u000fÂ¨\u0086x\u008fÃ½Ã”Ã´Â²\u0003Ã—#ÃŠ\u001dCÃ¯\u0017(\u0088\u001eÃt\u000e0KÃ©]Âº\u0089\u008bY\u008c'\u001cÃµÂ¹Ã¨\u008d\u0018Ã¨\u0019}Ã¹Ã‡ÃRÃ€Â¼B\u0016pi\u0099s\u0087Ã~U\u0090Ã¥6Ã¸\u0013TM\u0093\u00adAy_ÃŽ)\u0089Â©Ã€Ã¹KÃ¥CÃ·\u0080XÂ·\u0092=Ã£cÃ\u0007d*\u0095\rÂ pÂª_Ã“x\u008eÃ¦Â¯\u009dÂ Â³Ã¿vÃ§\u0002Ã²WÃŠÃ£\u0011Â¤\u00ad\u0017\u0092Ã¡\u0013\u007f\u00adg&$}Â¾sÂ«Ã¯\u001fÃÂº527\u0084{\u0080Â´Y\u0014Â¤Ãœ\u001f\u0080ÃŽBnj<\u009dÂ°Ã¬Ã{Â¾\u009b\u009d\u001bG\u009aÃ—\u000bÃ©\u0087\u0017\u0080Ã‘\u0014\u0090Ã¿\u0092\u0017q,\u0010\u0098\u0091Â£WÂ¡0Ã–`Ã¦\u0019Ã¡\u001a\t6F\u008a\u0001Ã€B\u0085\u0098@Â¦Ã›ÃŽÂ»Â¼~Âµ\u0016z\u0097Ã¾$Ã©\n\u0003Ã–Â¥eÃ°uÃ§Ã®@>ow(Ã¢=ÃFÃVÂ¬TÃ’Â¼Â¾\u0089.Ã‰Â¯Ã‹g^JCÃ³Â¨q\\g+z{h\u000eÂ¤z7Â£wÃ‘)Â´)\u008dÃŒfÂ¥/ÃµÃ¨/1:Â¶Â¯Ã¿+Ã†Â£Ã–\t\u0089JÂ²\u001dÂ¼ÂµKÂ¸=fÂ©ÃŽLSÂªÃÂ§_2Â¹\u0017 7^Ã’3Ã³\u0012]UpÃ¾ÃƒiAÃ™aC\u001bÃ®\tÂ¥Ã‹Â£\u009b\u0018~)\u008fÃœ\u009cÃ¼~\u0094\u008c\fm'~Ãº\u0011\u0016Ã³\u0088vn;\u008c9Ã†*Âº\u000fÃ£nÃ…E\u000f\u0097Â½Â±Ãˆw0\u0000\u008a\u0010oÃ†Ã°kÂ°ÃµÂ±\u008aH\u001dÃ«\u008f7\u0084ÃœÂ¼Ã¾Ã¼ÃŽÃ¿Â²*ÃºÃ©FÃ“Ã˜\u0086Ã®m\\wÂ¼Â®Â³w.Â±Ã©\u0085\u0081Ã\u008fÂ¶\u0095\u0093DDw1Â¯5x8}Â¡OÃ¿M_Ã›Â¦Z\u0014ar\u0012mB\u0019s\u001a\u0013Â¡\u0096\u000bA\u0015\u008b1Ã¢\\\\M9Ã¼Ã‘Â«Ã¥\u001bzÂ´\u009d\u001f\u008dB\u0086A\bÂªÃ½6Â»Ã£Â¨Ã«\u008bJ\u0086\n)KwR\rÂ¶\u0005Ã¤Â¬tC\u009cÃ±\u001eÃ’\u0000\u007f&e9Ã’Ã¥]Ã¢Ã^\u008bÃ¹7Ã‹C\u0007G\tX\u001d;Â sÂ¬M\u007f/\u0010ÃÂ¬Ã¡\u008f,\u001eW3Ã…\u00ad\u008dÂ®\u0098\u0004\u0085,<\u0087Ã JNÂ¥\u0014s\u0096mÃ¾Ã„Â¤Ã‰\u008cÃ¿W\u0012\u008e\u0007*>>\u0082Ã¢<ÃƒÃ§Â»\u001dU\u008dÂ½ \u0000,\u009fÃšÂ¯Ã¯Â¦Ã¦0Â¦\\Â¯K(DÂ¢\u008fÂ§Ã”Â¬\u0018xÃµÃ‚Z\u008cÃ¸bn\u0098Ã¼]E\u0084Ã¨Ã„\u0099y\u0005R\u0094BÃ½Â¥#Ã \u0013Ã¯\u0083Â¥VÂ²v\u0099hkÃ»Â¨Ã‘b4UD\u0006\t\u0004\u0085|J\u0084{YÂ©IuÃ K6\u008cRvE3\u0099Â³w\"Ã¦Ã»Â´%\u001dÃK]Ãš9ÃžSi\u00adÃ¬\u0098Ã\u009fÃdÃ°|\u0018Â¨Â²MÂ½\u008fÂ»G\u0011CLKÂ¼!\u0094Â±Ã°\u0086Ã•ÃŸ\u001eÃ‘\u00adÃŒ5Ã·\u001d\u008c\u008cWs|ÃŸ+Â¡Â¾Â¯ÃŠ\u009cÂ¹U\u0007Âµ9\u008asÃªÃˆ;Â¿Â´-Â³nÃ¸\u008aq2miOÃ¼Ã–Â©/Â½\u0096Ã†Z\u0087Â¸ Ã²PÃ…\u0093/Na\u008cÃ‹\u0087Ã¦Ã¹\u000eÃƒ\u001byÂ±\b+3Ã³Âº.\nÃ¡}Ã¸CÃ²v\u001f\u0007>UQÂ¢-\u0000K~\u0087^YÂ«\u0007\u0096O9Ã°Ã¾\u0098\nZÃŽÂ±Ã²\u008f=_Ã…\u008fÃŠÂ¦\u008bÃ¢\u0001Ã³Ã§ÃœÃ\u0099ÃŽgÂµzÃ›=Ã½Ã¥\u0013WÃ§HÂ²\u0016\u0084ÃÃ¨ÃŸÃ‘!z\b\u0091ÃŸB\u0017Ã¢\u00060W\u0005$*fÃ½Ã‰\u0013Â¿Ã¾]Ã²Ã„\u001c\u0018Q;Ã {\u000b\u007fÃ–1d)j]Ã‹\u007fÂµ\u0001\u000f{Ã£Ã²J\u009cÃÃ–Ã¯\u0090\u001c\u009daÃ¬I\u000emÂ£ÃŸ\u009d`#fÃµ7\u0016ÃŽÃ¢Ã©v\\HXBÂ Ã­Ã’Â£ÃŸsÂ°akdÃ©Â²Ã›C\u0013ebÃÃ‘\u0097Â§Ãœ\u009e-Ã”\u008e\u0081Ã‘Ã¦Â¸ÃŠ8\u0094ÂµxÃ¤Ã¹Â«}%Ã¸}\u000bÃ‹\u0091g\u008aÃ‚Ã•N\u0005up=k\n\u0011Â»E3Ã¥*Ã´Ã°Ã›Ã…Ã³Â¿V\u009b?Ã©Ã¥EÃ¯]-VÃ²&Ã¢ÃÃ³Â¤\tÂ»\t\u008bv\nÃ²ÃÃ¥\r8Ãˆ\u0082\u0016bfY\u0015Ã¨Â«\u009a?l\u0010Ã¯Ã“\u0001Â«\u0097Ã²kÃ(Ã¶<\u001eAÃ¡\u000bÃ˜\u0003TÃ’\u0085\u007f\u008dÃ„0}\u0083Â»f\u000b\"Â¦Ã£Ã„\u008c\u008a>Ã„Ã¿WÃšÃŒ\u0014\u0004\u009dÂ¶\u001b\u000eX\u0084\u009dÃ©zh,{*yÂ±ÃŽ\"Â³Â¢SÃ¾]\u0087R6\u001bÂ¿Ã“gEvÃ—F/rUÃ¶\u00adÂ©[kÃƒk\u008cÃ†:\u009f(}R\u0017Ã™&t\u001dÃŠ\u008c\u0013)\u0080\u00036S)\u0091/\u008eÃ‰]\u009bÃ‰\u0004\u0005\u008c\u008dÂ±Â²Ã”\u0091Â¦f6\u0085\u0002Â·Ãƒ[vÂµ\u0090/3\u008f\u0007Â¢%\u0085\u007f\u008e\u0003\u0095Ã”Â¡\u0006Ãœ$!sÃ¸\u0004<Â¸Ã“Ã€{f\\ÃµFÃ¥Ã~\u0002)ÃŽ\u008amÃ…p\u0084\u0017Ã•XÂ¡_alÃ—Ãm\u0000\u0017.Â¾hÃ›Ã¨Ã“w\u0093Â´Ã•Ã±X\u008f\u007f9Â³Ã-Ã¡\u0097EÃÃ2Ã½\u009cN\u0002Â´\u0010vÃ¹Ã§Â²m$7\u00adtYÂ¡Ã Â¯W\u0015ÃŠ\u0096Ã‚ÃˆÂ¾ÃŸ\u008eÃÂ´Â¥Ã­Ã½\u0084Ã•3Ã€]\u008f}=\u0092Ã—Â¢\u001dÃ¼Ã¬\u001f\u0002U\u0086\u0006bÂ»r\u0094\u0096Ã½\u008eÃ±Â»\u009c\u0096ÃŒÃ¼\u0087Ã˜Ã½c\u0001Â¾Â±Â½Ã®\u0080]Â¾\\\u0099A\\\u0013ÂµD\u009cÃ¶Ã¥#!Ã«\u0084hÃ¯Ã¦KÃ–Â¸Âµ\u001aÃŸ\u0007r\u0092\f:\u001cÃ‚Ã±\u0093S=\u008e\u0003UÃˆu\u00adÃ°W\u0013bR8M\u000e\u009dÃ®\u001aÃ¦Wj~\u008eÂ¾,Ã¶muÃ’Â¥Ã¬Ã“\u0080\\hN5Ã‚Ã€kÃ‘Â¬qÃƒ\u0005yE\u0097gHEÂ«\u0085aÃg;Ã§\u0004r,obÂ¬Ã€^Â¡Ã‡E?ÃÂ¹\u0001Hkt\u0018\u0016l+ÂªÂµÂ¿\u0093j|\u008fUÃ³Ã¶veÃ›Â¢K\rÃš_%Âª\u001f\u0091Â¤9Ã¡;,Ã‘Ã©\u0093l\b;\u0006\u0093Â½Â¿Ã¯ÃŸÃ®DwÂ¯Â¦\u0017ÃÃ‹/Â¢\u001d\nÂ¶Â¿Ã·Ã¤Ã®Ã®Ã’!\u008fÃ‹Ã­Ã½ÃšÂ¾Ã»80lÃŠ\u0019R\u008cÃˆÂµÃ¡\u0089Â®\u0080\u001e6Â¦Ã„JÃ½\u0086XÂ¡\u0005\u0095LH\\T\u0080\u009fli\u0002,Â£\\Â¸Ã¡Ã¨8Ã˜\u0092Ã£&\u0004Ko`.\u009aÃªÃ»Ã§Ã‚Ã»Â¤^\u0090=ÃŸÂ¾Â·Lr\u0000Ã¥rH\\\u0084.GÃ€Ã¸Ãœ#\u0087Â½8EiÃ®\u0011ÂºÃ±\u0019\u009eVÃ\u0007ÃÃ¾JÂ¾Â«@M\u009aÃ’ÃŸ$s\nÃŒ(Ã¤:Ã¡Â¦IÂ¡qA\nMÃ¥YÃ†Ã8Â¥Ã¢\u001aÃ¤Â¦Â½Ã¸Â·'Ã²Ã¹+Ã„)sNÃ¬Ã­Â±\u009b\u0018Ãž\u0087%\u001c'Â¸Â¥Â°Â¨\u0087~\u0097\u008eÃ¾Ã•\u0083Ã•Ãž?\u0086}p@8ÃÃº+^Â·\\\u0090\u0018\u001cÃ¶Ã\u0097Â»Ã²9ÃB/\u0005wÃ“Â®\u0017\u0014FktÃ¿\u0006\u0007)\u0084Â´Ã„.Ã¡Â»ÂµÃ³]\u008dÃ°\u009d\"\u009cÂªy{\u0017N\u0084Ã–Â½Ã¡Âª\u0018\u0019\u00926[\u008eD6Â½7\u009cÃ5\u0010|7Â¨\u001a\\Âº\u00109QKF\u009d\u009bÂ¸Ã¯qMÃ”Ã¬\u008c\u0086ÃƒÃ²Ã“Ã‹-Ã…v$Ã‘lt\u0093\u001bÂ§N\u001bÂ¥{Ã‰a#Ã¬tÃ©iJvbÃ“Â¯6oÃ¢>[\u0000Ã…m=\u00adAÃ¥||&\u0016\u0089Â£I\u009fÃ±\u000e\\eÂªÃ·9\u009d7AjÂ·Ã„\u0081\u008cÃ·7\u008b\u0087/Â©Ã»Ã£\u009a&\u0002Ev}\u0017\fÃœÃŒÃ£6\u008bÃžÃ²ÃÃ¿Ã°YÃ•Â®\ryÃÂ·AÃ‚Ã©Ã¾Ã¿Ã—\u0013Ã©Â¹Â¬\u0010Â©ÃžG:nÂ¨Â¿\u009bdrÃ£Ã•Ã‹AÂ·5Ã¥: Ã¤\u001eU=\\Ã¤\u0014wÃ…\\Ã¯\u0091Ã¬Ã°\u001dÂ¯\u0099Ã­Ã§cS/x9Â£\u0093\u0007tpÃ#x\b'Â¹\b\u0005\u001fÂªÃ‹Ã‚\u008a\u000b\u0090\\j\u0085Ã±m$Ã¿AÃ®\u008arÃ©\"Â©zÃ˜\\Â±Ã°\\Â£q:\u0001<ÃŠÂ´Ã¡dA\u0086Â²)wÃ4a{Â²x\u0083[Â¡QÃ°\u009a^UÂ¢Â²Ã»Â¨\u0006 lh\u0003^Ã›dÃºÃœJÃ\u0017Ã¶)XÂ¦:@Ã¿Â®Ã…\u0016M\u0017Ã¾Â£Â¾\u00877l{\u009b8\u0087{&\u0097|Â§\u0007Ã–h\u0091Â¸\u0096R\u0010u\u0011y\u001aÂ¡s!@pÃ¸Ã¹\u000eÂ·VÂ±Ã–[\u0080\u0011\u0012\u0092Ã›Ã¾<\u001d\u0083Ã\u0085\u001f\u0012*ÃªÃŸ/Â¶Ã¨Â¾-\u001dÂ²$\u009dÂ¢Â·8MÃŠÃžÃ•Ã³0\nÂ»>CÃœ#Z_Â¾\u008f\u001c>Ã…p\u000e`]\u001f\u0088}Ã¾Â¾\u0006\u00131\u0015$\u0099$\u0083ÃœSUÃ¦\u001e2Ã’-uÃ±Ã”oÂ¼^*Â¶wÂ¸G,\u0083L{`Ã¢lIÃ‰[Â¤k\u001fÂ´S\fÃ†Â¶\u00adÃºÃ\u0007Âº\u001eiÃ©\u0003\u000fÃ“Â¿\u0004Ãfo>Ã¿\u0085\t\u0003ÂºÂ®w\u0085\u0085)\u001cÃ¹.~\u0016'Ã‰Ã‹Â¿\u0007hÃ¥Â§Ã†Â¹mxMJ1Ã¬Ã‚%\u0089\u0003\"Ã²ÃPSJ\u001b\u009c! 'Ã¼Ã°EÃ‡Â¦Â°4Ã¤\u0082Â«\u0085\u000eÂ»pÃœÂ±=\u0017\u001aÃª8\u0085Â®pÃ¤0\u0082h\u001bPÃ³\u0000R3vÃ·ÃºÃ†\u0097>%ÃqÂ²0'\u0086ÃªVÂ¶\u0083Ã¦\u0081:*Ã§![b\u0004T\u0089\u000fwÃ™(pÂ«aÂ¤H\u0013\u0019VÂ°x\u0093+:L.RÃ/Â¶S\u009bÂ±\u0098\u0090RÂ©\u0012\tÃÃ«\u0016)\nÂ´3Â¯\u0099\t\u0006vÃ©dÃ‚\u0096\u009b\r\bÃ±Ã°Gm\u009a\u000eÃŽÃ£LÂ¡Ã(\u0097\u0086\u0014Ã¾\u001d\u001c!\fÂµ\u001dÂ°d\u0090Â \u001cÂ·Â»\u0017Ã‹\u00adÂ¸Â³Ã™rÃ¤Ã–0ÃÃ‹Ã°ÃŽÂ¦Ã³Â¬Ã‰ÂµaÂµ\u0087Ã‹\u009d\u007fÂ£\\}+\\G>\u0016@C\u001c\u009b(Ã²\u001e\u001b&\u00965Â¢ÃžZxV\u001bÃ¤Ã»qaC\u008c\bÂ°Ãƒ\u0097f'~{Â¾\u0080\u00149n\u001br;gÂ®q\u0088aÃ¯\u0003Ã±Ã\u0094[Qg+\u0085\u0099Ã¢\u0085\"\t\u000eNÃªk\u0086+Ã™\f]mY\u0099Ã¨3s*.J}\u0094<g*\u0003Ã™u@E\u0092m\bX.h\u0081 Â¸[\nÃ•Ã\u0098:\u0019Ã°ÃŽÂ¦Â°Â¨ÃƒÃ™Ã¦Â©ÃºvÃ…\u0092\u0087Â²\u0005Â°ÃA\rÃ±\u001b*ÃœÃž?ÂªAÂ«.#Â©G5Â·zJÃ•A\bt0Ã’Ã¢\u000bÃ\u0086Ã—Â´1\u0082(Â´D\u001d7\u009a98Â¤Â *\u008aÂ±Â EÂ´";
        short var4 = 9778;
        char var1 = 'u';
        int var8 = -1;

        label52:
        while (true) {
            String var10000 = var2.substring(++var8, var8 + var1);
            int var10001 = -1;

            while (true) {
                char[] var20;
                label47: {
                    char[] var11 = var10000.toCharArray();
                    int var10003 = var11.length;
                    int var6 = 0;
                    var20 = var11;
                    var10001 = var10003;
                    char[] var28;
                    int var10004;
                    if (var10003 <= 1) {
                        var28 = var11;
                        var10004 = var6;
                    } else {
                        var20 = var11;
                        var10001 = var10003;
                        if (var10003 <= var6) {
                            break label47;
                        }

                        var28 = var11;
                        var10004 = var6;
                    }

                    while (true) {
                        var28[var10004] = (char)(var28[var10004] ^ switch (var6 % 7) {
                            case 0 -> 89;
                            case 1 -> 65;
                            case 2 -> 88;
                            case 3 -> 36;
                            case 4 -> 112;
                            case 5 -> 91;
                            default -> 47;
                        });
                        var6++;
                        if (var10001 == 0) {
                            var10004 = var10001;
                            var28 = var20;
                        } else {
                            if (var10001 <= var6) {
                                break;
                            }

                            var28 = var20;
                            var10004 = var6;
                        }
                    }
                }

                String var35 = new String(var20).intern();
                switch (var10001) {
                    case 0:
                        var5[var3++] = var35;
                        if ((var8 += var1) >= var4) {
                            a = var5;
                            b = new String[85];
                            System.out.println(a(16530, 18598));
                            return;
                        }

                        var1 = var2.charAt(var8);
                        break;
                    default:
                        var5[var3++] = var35;
                        if ((var8 += var1) < var4) {
                            var1 = var2.charAt(var8);
                            continue label52;
                        }

                        var2 = "Ã¿.\u009fÃŒPÃ™Ã¶Ã’\u0098Â°Ã¡Ã…GÃ¼rÂ²ifO_Ã¨Â¶[Ã–.\u0000\u0004\u000f\u0013GÂ®Ã¼Ãœ1Ã”\u007f\u001aÃ¾Ã ÃÃº1ÃŽÃ§Ã”Ãƒ\u0006\u00ad\u0096Ã§Âµh\u0081\u008b+Ãš\u009a\u009aÃ»\u0005Â·6#Â¸Â¸\u0010Â¨\u0087Â¸=Ã”Ã\u009b\"\u0099r\u008f9Â¾\u0005k\u0012Â©Â Â¦Ã¶!Ã‘\u000b\u0087\t\u00ad\u0098Ã”\u008dÃ\u001e<\u000e'\u0097Ã“M\u0082Â¦Ã¼v\u0001n\u0091Ã—\u0015_\u009e\u0004'o;ÃŽZÂ°\u000e\u008dprÂ·|z+Ã»Ã¾0\u009eÂ°Ã—\u001fHÂ¿D\u0082\u0003(<Â¬Âº/Ã°~~Â¼D4\u000f0\u0083[Ã‚\u0012Â¢Â Ã¶\u008agÃ—@BÂ¢Ã¾1Â¢ÃÃ¦\u0094\u00adÃ¥vÂµINÃ‰\u0091XÂ½Ã¬\u00ad*7Ã•\u001d(Ã…7Ã´fGÃ±}Â¦\u009e|\\\u0099Ã•Ã­Â¯\u009dEÃ¡Ã”yÂ´AkÃÃ¡EÃ”\u0091Ã“\u0096Â¥Ãº\u009fÃ„Â°Ã˜\u009eÃ†Âª\u0098\u0004}Ãž!";
                        var4 = 234;
                        var1 = 'g';
                        var8 = -1;
                }

                var10000 = var2.substring(++var8, var8 + var1);
                var10001 = 0;
            }
        }
    }

    private static String a(int var0, int var1) {
        int var2 = (var0 ^ 16532) & 65535;
        if (b[var2] == null) {
            char[] var3 = a[var2].toCharArray();

            short var4 = switch (var3[0] & 0xFF) {
                case 0 -> 227;
                case 1 -> 224;
                case 2 -> 211;
                case 3 -> 23;
                case 4 -> 237;
                case 5 -> 168;
                case 6 -> 119;
                case 7 -> 34;
                case 8 -> 98;
                case 9 -> 33;
                case 10 -> 132;
                case 11 -> 0;
                case 12 -> 135;
                case 13 -> 223;
                case 14 -> 175;
                case 15 -> 147;
                case 16 -> 37;
                case 17 -> 235;
                case 18 -> 35;
                case 19 -> 183;
                case 20 -> 127;
                case 21 -> 167;
                case 22 -> 232;
                case 23 -> 4;
                case 24 -> 75;
                case 25 -> 173;
                case 26 -> 134;
                case 27 -> 69;
                case 28 -> 158;
                case 29 -> 25;
                case 30 -> 30;
                case 31 -> 106;
                case 32 -> 188;
                case 33 -> 203;
                case 34 -> 59;
                case 35 -> 117;
                case 36 -> 105;
                case 37 -> 250;
                case 38 -> 121;
                case 39 -> 17;
                case 40 -> 169;
                case 41 -> 70;
                case 42 -> 207;
                case 43 -> 84;
                case 44 -> 81;
                case 45 -> 182;
                case 46 -> 231;
                case 47 -> 123;
                case 48 -> 142;
                case 49 -> 191;
                case 50 -> 96;
                case 51 -> 28;
                case 52 -> 149;
                case 53 -> 7;
                case 54 -> 13;
                case 55 -> 243;
                case 56 -> 196;
                case 57 -> 72;
                case 58 -> 165;
                case 59 -> 46;
                case 60 -> 63;
                case 61 -> 86;
                case 62 -> 215;
                case 63 -> 1;
                case 64 -> 93;
                case 65 -> 31;
                case 66 -> 16;
                case 67 -> 6;
                case 68 -> 5;
                case 69 -> 36;
                case 70 -> 50;
                case 71 -> 176;
                case 72 -> 107;
                case 73 -> 71;
                case 74 -> 78;
                case 75 -> 24;
                case 76 -> 111;
                case 77 -> 32;
                case 78 -> 229;
                case 79 -> 58;
                case 80 -> 65;
                case 81 -> 210;
                case 82 -> 61;
                case 83 -> 8;
                case 84 -> 190;
                case 85 -> 140;
                case 86 -> 15;
                case 87 -> 151;
                case 88 -> 153;
                case 89 -> 213;
                case 90 -> 76;
                case 91 -> 95;
                case 92 -> 234;
                case 93 -> 97;
                case 94 -> 236;
                case 95 -> 2;
                case 96 -> 226;
                case 97 -> 29;
                case 98 -> 125;
                case 99 -> 185;
                case 100 -> 247;
                case 101 -> 143;
                case 102 -> 186;
                case 103 -> 21;
                case 104 -> 56;
                case 105 -> 244;
                case 106 -> 57;
                case 107 -> 137;
                case 108 -> 27;
                case 109 -> 103;
                case 110 -> 18;
                case 111 -> 136;
                case 112 -> 133;
                case 113 -> 251;
                case 114 -> 184;
                case 115 -> 248;
                case 116 -> 225;
                case 117 -> 180;
                case 118 -> 44;
                case 119 -> 219;
                case 120 -> 19;
                case 121 -> 88;
                case 122 -> 53;
                case 123 -> 195;
                case 124 -> 115;
                case 125 -> 130;
                case 126 -> 200;
                case 127 -> 254;
                case 128 -> 194;
                case 129 -> 90;
                case 130 -> 114;
                case 131 -> 160;
                case 132 -> 166;
                case 133 -> 202;
                case 134 -> 12;
                case 135 -> 92;
                case 136 -> 209;
                case 137 -> 41;
                case 138 -> 189;
                case 139 -> 146;
                case 140 -> 9;
                case 141 -> 253;
                case 142 -> 221;
                case 143 -> 205;
                case 144 -> 113;
                case 145 -> 49;
                case 146 -> 187;
                case 147 -> 131;
                case 148 -> 22;
                case 149 -> 124;
                case 150 -> 239;
                case 151 -> 208;
                case 152 -> 157;
                case 153 -> 218;
                case 154 -> 91;
                case 155 -> 94;
                case 156 -> 148;
                case 157 -> 201;
                case 158 -> 67;
                case 159 -> 171;
                case 160 -> 170;
                case 161 -> 242;
                case 162 -> 154;
                case 163 -> 55;
                case 164 -> 99;
                case 165 -> 62;
                case 166 -> 40;
                case 167 -> 139;
                case 168 -> 174;
                case 169 -> 249;
                case 170 -> 11;
                case 171 -> 110;
                case 172 -> 43;
                case 173 -> 77;
                case 174 -> 38;
                case 175 -> 222;
                case 176 -> 42;
                case 177 -> 199;
                case 178 -> 141;
                case 179 -> 197;
                case 180 -> 155;
                case 181 -> 45;
                case 182 -> 83;
                case 183 -> 198;
                case 184 -> 193;
                case 185 -> 228;
                case 186 -> 10;
                case 187 -> 217;
                case 188 -> 60;
                case 189 -> 47;
                case 190 -> 162;
                case 191 -> 238;
                case 192 -> 3;
                case 193 -> 100;
                case 194 -> 245;
                case 195 -> 138;
                case 196 -> 102;
                case 197 -> 82;
                case 198 -> 85;
                case 199 -> 80;
                case 200 -> 246;
                case 201 -> 129;
                case 202 -> 241;
                case 203 -> 52;
                case 204 -> 68;
                case 205 -> 233;
                case 206 -> 204;
                case 207 -> 14;
                case 208 -> 164;
                case 209 -> 144;
                case 210 -> 89;
                case 211 -> 112;
                case 212 -> 108;
                case 213 -> 212;
                case 214 -> 172;
                case 215 -> 150;
                case 216 -> 230;
                case 217 -> 192;
                case 218 -> 74;
                case 219 -> 128;
                case 220 -> 145;
                case 221 -> 39;
                case 222 -> 104;
                case 223 -> 161;
                case 224 -> 79;
                case 225 -> 177;
                case 226 -> 216;
                case 227 -> 118;
                case 228 -> 255;
                case 229 -> 152;
                case 230 -> 126;
                case 231 -> 26;
                case 232 -> 156;
                case 233 -> 120;
                case 234 -> 64;
                case 235 -> 109;
                case 236 -> 163;
                case 237 -> 87;
                case 238 -> 179;
                case 239 -> 181;
                case 240 -> 54;
                case 241 -> 206;
                case 242 -> 51;
                case 243 -> 66;
                case 244 -> 252;
                case 245 -> 178;
                case 246 -> 73;
                case 247 -> 122;
                case 248 -> 159;
                case 249 -> 48;
                case 250 -> 20;
                case 251 -> 214;
                case 252 -> 220;
                case 253 -> 101;
                case 254 -> 240;
                default -> 116;
            };
            int var5 = (var1 & 0xFF) - var4;
            if (var5 < 0) {
                var5 += 256;
            }

            int var6 = ((var1 & 65535) >>> 8) - var4;
            if (var6 < 0) {
                var6 += 256;
            }

            for (int var7 = 0; var7 < var3.length; var7++) {
                int var8 = var7 % 2;
                char var10002 = var3[var7];
                if (var8 == 0) {
                    var3[var7] = (char)(var10002 ^ var5);
                    var5 = ((var5 >>> 3 | var5 << 5) ^ var3[var7]) & 0xFF;
                } else {
                    var3[var7] = (char)(var10002 ^ var6);
                    var6 = ((var6 >>> 3 | var6 << 5) ^ var3[var7]) & 0xFF;
                }
            }

            b[var2] = new String(var3).intern();
        }

        return b[var2];
    }
}

```

`testData/results/custom-classes/zkm/EnhancedStringEncSomeStrings.dec`:

```dec
public class a {
    private static final String[] a;
    private static final String[] b;

    public static void main(String[] var0) {
        a(a(30479, -25658));
    }

    private static void a(String var0) {
        if (!var0.equals(a(30478, -17804))) {
            throw new RuntimeException(a(30477, 20135));
        }
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    static {
        String[] var5 = new String[3];
        int var3 = 0;
        String var2 = "Ã•\u0082t\u009dÃ„\u0081\u0003Âµ\u0092Ã¶\u000eÃœÃœ\u0098\u0086\u0094\u0005TR\fÂ¥Â¤Â¤)o";
        byte var4 = 25;
        char var1 = 6;
        int var0 = -1;

        while (true) {
            char[] var16;
            label38: {
                char[] var10001 = var2.substring(++var0, var0 + var1).toCharArray();
                int var10003 = var10001.length;
                int var6 = 0;
                var16 = var10001;
                int var10 = var10003;
                char[] var23;
                int var10004;
                if (var10003 <= 1) {
                    var23 = var10001;
                    var10004 = var6;
                } else {
                    var16 = var10001;
                    var10 = var10003;
                    if (var10003 <= var6) {
                        break label38;
                    }

                    var23 = var10001;
                    var10004 = var6;
                }

                while (true) {
                    var23[var10004] = (char)(var23[var10004] ^ switch (var6 % 7) {
                        case 0 -> 84;
                        case 1 -> 40;
                        case 2 -> 91;
                        case 3 -> 74;
                        case 4 -> 9;
                        case 5 -> 31;
                        default -> 60;
                    });
                    var6++;
                    if (var10 == 0) {
                        var10004 = var10;
                        var23 = var16;
                    } else {
                        if (var10 <= var6) {
                            break;
                        }

                        var23 = var16;
                        var10004 = var6;
                    }
                }
            }

            String var30 = new String(var16).intern();
            byte var14 = -1;
            var5[var3++] = var30;
            if ((var0 += var1) >= var4) {
                a = var5;
                b = new String[3];
                return;
            }

            var1 = var2.charAt(var0);
        }
    }

    private static String a(int var0, int var1) {
        int var2 = (var0 ^ 30479) & 65535;
        if (b[var2] == null) {
            char[] var3 = a[var2].toCharArray();

            short var4 = switch (var3[0] & 0xFF) {
                case 0 -> 177;
                case 1 -> 28;
                case 2 -> 194;
                case 3 -> 248;
                case 4 -> 244;
                case 5 -> 236;
                case 6 -> 133;
                case 7 -> 9;
                case 8 -> 169;
                case 9 -> 88;
                case 10 -> 182;
                case 11 -> 118;
                case 12 -> 82;
                case 13 -> 59;
                case 14 -> 120;
                case 15 -> 127;
                case 16 -> 243;
                case 17 -> 6;
                case 18 -> 137;
                case 19 -> 45;
                case 20 -> 239;
                case 21 -> 36;
                case 22 -> 147;
                case 23 -> 69;
                case 24 -> 104;
                case 25 -> 202;
                case 26 -> 62;
                case 27 -> 255;
                case 28 -> 220;
                case 29 -> 119;
                case 30 -> 21;
                case 31 -> 94;
                case 32 -> 122;
                case 33 -> 163;
                case 34 -> 247;
                case 35 -> 51;
                case 36 -> 31;
                case 37 -> 87;
                case 38 -> 221;
                case 39 -> 204;
                case 40 -> 5;
                case 41 -> 37;
                case 42 -> 201;
                case 43 -> 11;
                case 44 -> 41;
                case 45 -> 115;
                case 46 -> 211;
                case 47 -> 42;
                case 48 -> 206;
                case 49 -> 117;
                case 50 -> 67;
                case 51 -> 148;
                case 52 -> 142;
                case 53 -> 181;
                case 54 -> 191;
                case 55 -> 80;
                case 56 -> 46;
                case 57 -> 39;
                case 58 -> 102;
                case 59 -> 130;
                case 60 -> 116;
                case 61 -> 58;
                case 62 -> 40;
                case 63 -> 93;
                case 64 -> 7;
                case 65 -> 48;
                case 66 -> 184;
                case 67 -> 74;
                case 68 -> 90;
                case 69 -> 173;
                case 70 -> 152;
                case 71 -> 25;
                case 72 -> 198;
                case 73 -> 135;
                case 74 -> 91;
                case 75 -> 3;
                case 76 -> 77;
                case 77 -> 253;
                case 78 -> 151;
                case 79 -> 222;
                case 80 -> 149;
                case 81 -> 160;
                case 82 -> 111;
                case 83 -> 228;
                case 84 -> 64;
                case 85 -> 0;
                case 86 -> 216;
                case 87 -> 166;
                case 88 -> 76;
                case 89 -> 212;
                case 90 -> 251;
                case 91 -> 43;
                case 92 -> 162;
                case 93 -> 188;
                case 94 -> 34;
                case 95 -> 225;
                case 96 -> 109;
                case 97 -> 242;
                case 98 -> 78;
                case 99 -> 183;
                case 100 -> 165;
                case 101 -> 86;
                case 102 -> 73;
                case 103 -> 83;
                case 104 -> 53;
                case 105 -> 71;
                case 106 -> 32;
                case 107 -> 18;
                case 108 -> 8;
                case 109 -> 159;
                case 110 -> 85;
                case 111 -> 81;
                case 112 -> 235;
                case 113 -> 14;
                case 114 -> 17;
                case 115 -> 146;
                case 116 -> 144;
                case 117 -> 30;
                case 118 -> 27;
                case 119 -> 112;
                case 120 -> 15;
                case 121 -> 171;
                case 122 -> 129;
                case 123 -> 195;
                case 124 -> 131;
                case 125 -> 226;
                case 126 -> 241;
                case 127 -> 232;
                case 128 -> 107;
                case 129 -> 213;
                case 130 -> 210;
                case 131 -> 140;
                case 132 -> 205;
                case 133 -> 68;
                case 134 -> 136;
                case 135 -> 238;
                case 136 -> 200;
                case 137 -> 89;
                case 138 -> 56;
                case 139 -> 54;
                case 140 -> 143;
                case 141 -> 12;
                case 142 -> 110;
                case 143 -> 50;
                case 144 -> 215;
                case 145 -> 234;
                case 146 -> 13;
                case 147 -> 95;
                case 148 -> 100;
                case 149 -> 190;
                case 150 -> 193;
                case 151 -> 20;
                case 152 -> 175;
                case 153 -> 185;
                case 154 -> 155;
                case 155 -> 180;
                case 156 -> 168;
                case 157 -> 70;
                case 158 -> 179;
                case 159 -> 125;
                case 160 -> 1;
                case 161 -> 84;
                case 162 -> 207;
                case 163 -> 150;
                case 164 -> 10;
                case 165 -> 218;
                case 166 -> 139;
                case 167 -> 250;
                case 168 -> 170;
                case 169 -> 108;
                case 170 -> 197;
                case 171 -> 79;
                case 172 -> 209;
                case 173 -> 33;
                case 174 -> 47;
                case 175 -> 63;
                case 176 -> 105;
                case 177 -> 233;
                case 178 -> 246;
                case 179 -> 26;
                case 180 -> 22;
                case 181 -> 121;
                case 182 -> 249;
                case 183 -> 66;
                case 184 -> 65;
                case 185 -> 23;
                case 186 -> 199;
                case 187 -> 29;
                case 188 -> 230;
                case 189 -> 172;
                case 190 -> 245;
                case 191 -> 123;
                case 192 -> 124;
                case 193 -> 61;
                case 194 -> 16;
                case 195 -> 217;
                case 196 -> 227;
                case 197 -> 24;
                case 198 -> 134;
                case 199 -> 126;
                case 200 -> 96;
                case 201 -> 92;
                case 202 -> 208;
                case 203 -> 72;
                case 204 -> 44;
                case 205 -> 52;
                case 206 -> 240;
                case 207 -> 128;
                case 208 -> 138;
                case 209 -> 141;
                case 210 -> 132;
                case 211 -> 38;
                case 212 -> 106;
                case 213 -> 113;
                case 214 -> 187;
                case 215 -> 167;
                case 216 -> 252;
                case 217 -> 189;
                case 218 -> 49;
                case 219 -> 161;
                case 220 -> 158;
                case 221 -> 174;
                case 222 -> 196;
                case 223 -> 231;
                case 224 -> 229;
                case 225 -> 223;
                case 226 -> 214;
                case 227 -> 237;
                case 228 -> 60;
                case 229 -> 153;
                case 230 -> 57;
                case 231 -> 154;
                case 232 -> 186;
                case 233 -> 4;
                case 234 -> 101;
                case 235 -> 98;
                case 236 -> 103;
                case 237 -> 192;
                case 238 -> 19;
                case 239 -> 35;
                case 240 -> 55;
                case 241 -> 2;
                case 242 -> 156;
                case 243 -> 99;
                case 244 -> 203;
                case 245 -> 224;
                case 246 -> 178;
                case 247 -> 75;
                case 248 -> 219;
                case 249 -> 114;
                case 250 -> 157;
                case 251 -> 176;
                case 252 -> 164;
                case 253 -> 254;
                case 254 -> 145;
                default -> 97;
            };
            int var5 = (var1 & 0xFF) - var4;
            if (var5 < 0) {
                var5 += 256;
            }

            int var6 = ((var1 & 65535) >>> 8) - var4;
            if (var6 < 0) {
                var6 += 256;
            }

            for (int var7 = 0; var7 < var3.length; var7++) {
                int var8 = var7 % 2;
                char var10002 = var3[var7];
                if (var8 == 0) {
                    var3[var7] = (char)(var10002 ^ var5);
                    var5 = ((var5 >>> 3 | var5 << 5) ^ var3[var7]) & 0xFF;
                } else {
                    var3[var7] = (char)(var10002 ^ var6);
                    var6 = ((var6 >>> 3 | var6 << 5) ^ var3[var7]) & 0xFF;
                }
            }

            b[var2] = new String(var3).intern();
        }

        return b[var2];
    }
}

```

`testData/results/custom-classes/zkm/sample1/io/github/repooper/packetevents/PacketEvents.dec`:

```dec
package io.github.repooper.packetevents;

import io.github.repooper.packetevents.bstats.Metrics;
import io.github.repooper.packetevents.bstats.Metrics.SimplePie;
import io.github.repooper.packetevents.event.impl.PostPlayerInjectEvent;
import io.github.repooper.packetevents.event.manager.EventManager;
import io.github.repooper.packetevents.event.manager.PEEventManager;
import io.github.repooper.packetevents.exceptions.PacketEventsLoadFailureException;
import io.github.repooper.packetevents.injector.GlobalChannelInjector;
import io.github.repooper.packetevents.packettype.PacketType;
import io.github.repooper.packetevents.packettype.PacketTypeClasses;
import io.github.repooper.packetevents.packetwrappers.WrappedPacket;
import io.github.repooper.packetevents.packetwrappers.play.out.entityequipment.WrappedPacketOutEntityEquipment.EquipmentSlot;
import io.github.repooper.packetevents.processor.BukkitEventProcessorInternal;
import io.github.repooper.packetevents.processor.PacketProcessorInternal;
import io.github.repooper.packetevents.settings.PacketEventsSettings;
import io.github.repooper.packetevents.updatechecker.UpdateChecker;
import io.github.repooper.packetevents.updatechecker.UpdateChecker.UpdateCheckerStatus;
import io.github.repooper.packetevents.utils.entityfinder.EntityFinderUtils;
import io.github.repooper.packetevents.utils.guava.GuavaUtils;
import io.github.repooper.packetevents.utils.netty.bytebuf.ByteBufUtil;
import io.github.repooper.packetevents.utils.netty.bytebuf.ByteBufUtil_7;
import io.github.repooper.packetevents.utils.netty.bytebuf.ByteBufUtil_8;
import io.github.repooper.packetevents.utils.nms.NMSUtils;
import io.github.repooper.packetevents.utils.player.PlayerUtils;
import io.github.repooper.packetevents.utils.server.ServerUtils;
import io.github.repooper.packetevents.utils.server.ServerVersion;
import io.github.repooper.packetevents.utils.version.PEVersion;
import java.util.Iterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import me.frep.vulcan.spigot.check.AbstractCheck;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.ServicePriority;
import org.bukkit.plugin.ServicesManager;
import org.bukkit.plugin.java.JavaPlugin;

public final class PacketEvents implements Listener, EventManager {
    private static PacketEvents instance;
    private static Plugin plugin;
    private final PEVersion version;
    private final EventManager eventManager;
    private final PlayerUtils playerUtils;
    private final ServerUtils serverUtils;
    private final PacketProcessorInternal packetProcessorInternal;
    private final BukkitEventProcessorInternal bukkitEventProcessorInternal;
    private final GlobalChannelInjector injector;
    private final AtomicBoolean injectorReady;
    private String handlerName;
    private PacketEventsSettings settings;
    private ByteBufUtil byteBufUtil;
    private UpdateChecker updateChecker;
    private volatile boolean loading;
    private volatile boolean loaded;
    private boolean initialized;
    private boolean initializing;
    private boolean terminating;
    private boolean lateBind;
    private static int Vulcan_k;

    public PacketEvents() {
        int var10000 = Vulcan_Q();
        super();
        int var3 = var10000;
        this.version = new PEVersion(new int[]{1, 8, 4});
        this.eventManager = new PEEventManager();
        this.playerUtils = new PlayerUtils();
        this.serverUtils = new ServerUtils();
        this.packetProcessorInternal = new PacketProcessorInternal();
        this.bukkitEventProcessorInternal = new BukkitEventProcessorInternal();
        this.injector = new GlobalChannelInjector();
        this.injectorReady = new AtomicBoolean();
        this.settings = new PacketEventsSettings();
        this.lateBind = false;
        if (var3 == 0) {
            AbstractCheck.Vulcan_t(!AbstractCheck.Vulcan_a());
        }
    }

    public static PacketEvents Vulcan_o(Plugin var0) {
        int var3 = Vulcan_a();
        boolean var10000 = Bukkit.isPrimaryThread();
        if (var3 == 0) {
            if (!var10000) {
                PacketEvents var5 = instance;
                if (var3 == 0) {
                    if (instance == null) {
                        plugin = var0;
                        instance = new PacketEvents();
                    }

                    var5 = instance;
                }

                return var5;
            }

            ServicesManager var4 = Bukkit.getServicesManager();
            if (var3 != 0) {
                return instance = (PacketEvents)var4.load(PacketEvents.class);
            }

            var10000 = var4.isProvidedFor(PacketEvents.class);
        }

        if (!var10000) {
            instance = new PacketEvents();
            Bukkit.getServicesManager().register(PacketEvents.class, instance, var0, ServicePriority.Normal);
            plugin = var0;
            return instance;
        } else {
            return instance = (PacketEvents)Bukkit.getServicesManager().load(PacketEvents.class);
        }
    }

    public static PacketEvents Vulcan_V() {
        return instance;
    }

    @Deprecated
    public static PacketEvents Vulcan_a() {
        return instance;
    }

    public void Vulcan_g() {
        long var3;
        long var5;
        long var7;
        long var9;
        long var11;
        long var13;
        long var15;
        int var17;
        PacketEvents var24;
        label89: {
            long var1 = 37314761108082L;
            var3 = 100924278520616L;
            var5 = 26099128416120L;
            var7 = 127830791373044L;
            var9 = 13544093978976L;
            var11 = 77232768417097L;
            var13 = 73696640073211L;
            var15 = 50836346346180L;
            var17 = Vulcan_Q();
            boolean var10000 = this.loaded;
            if (var17 != 0) {
                if (this.loaded) {
                    return;
                }

                var24 = this;
                if (var17 == 0) {
                    break label89;
                }

                var10000 = this.loading;
            }

            if (var10000) {
                return;
            }

            var24 = this;
        }

        var24.loading = true;
        ServerVersion var18 = ServerVersion.Vulcan__();
        WrappedPacket.version = var18;
        NMSUtils.version = var18;
        EntityFinderUtils.version = var18;
        this.handlerName = "pe-" + plugin.getName();

        try {
            label72: {
                NMSUtils.Vulcan_S(new Object[]{var15});
                PacketTypeClasses.Vulcan_Y(new Object[]{var13});
                PacketType.Vulcan_R(new Object[]{var7});
                EntityFinderUtils.Vulcan_k(new Object[]{var9});
                this.Vulcan_l().entityCache = GuavaUtils.Vulcan_C(new Object[]{var3});
                if (var17 != 0) {
                    if (var18.Vulcan_P(ServerVersion.v_1_9)) {
                        EquipmentSlot[] var19 = EquipmentSlot.values();
                        int var20 = var19.length;
                        int var21 = 0;

                        while (var21 < var20) {
                            EquipmentSlot var22 = var19[var21];
                            var22.id = (byte)var22.ordinal();
                            var21++;
                            if (var17 == 0) {
                                break label72;
                            }

                            if (var17 == 0) {
                                break;
                            }
                        }

                        if (var17 != 0) {
                            break label72;
                        }
                    }

                    EquipmentSlot.MAINHAND.id = 0;
                    EquipmentSlot.OFFHAND.id = -1;
                    EquipmentSlot.BOOTS.id = 1;
                    EquipmentSlot.LEGGINGS.id = 2;
                    EquipmentSlot.CHESTPLATE.id = 3;
                }

                EquipmentSlot.HELMET.id = 4;
            }
        } catch (Exception var23) {
            this.loading = false;
            throw new PacketEventsLoadFailureException(var23);
        }

        this.byteBufUtil = (ByteBufUtil)(NMSUtils.legacyNettyImportMode ? new ByteBufUtil_7() : new ByteBufUtil_8());
        this.updateChecker = new UpdateChecker();
        var24 = this;
        if (var17 != 0) {
            if (!this.injectorReady.get()) {
                this.injector.Vulcan_b(new Object[]{var5});
                boolean var10001 = this.injector.Vulcan_K(new Object[]{var11});
                if (var17 != 0) {
                    var10001 = !var10001;
                }

                this.lateBind = var10001;
                var24 = this;
                if (var17 != 0) {
                    if (!this.lateBind) {
                        this.injector.Vulcan_B();
                    }

                    var24 = this;
                }

                var24.injectorReady.set(true);
            }

            this.loaded = true;
            var24 = this;
        }

        var24.loading = false;
    }

    @Deprecated
    public void Vulcan_x() {
        new Thread(this::Vulcan_g).start();
    }

    @Deprecated
    public void Vulcan_l(ExecutorService var1) {
        var1.execute(this::Vulcan_g);
    }

    public void Vulcan_y(PacketEventsSettings var1) {
        this.settings = var1;
    }

    public void Vulcan_a() {
        this.Vulcan_o(this.Vulcan_N());
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    public void Vulcan_o(PacketEventsSettings var1) {
        int var10000 = Vulcan_Q();
        this.Vulcan_g();
        int var4 = var10000;
        boolean var7 = this.initialized;
        if (var4 != 0) {
            if (this.initialized) {
                return;
            }

            var7 = this.initializing;
        }

        if (var4 != 0) {
            if (var7) {
                return;
            }

            this.initializing = true;
            this.settings = var1;
            this.settings.Vulcan_T(new Object[0]);
            var7 = this.settings.Vulcan_j(new Object[0]);
        }

        if (var4 != 0) {
            if (var7) {
                this.Vulcan_H();
            }

            var7 = this.settings.Vulcan_o(new Object[0]);
        }

        label47: {
            if (var4 != 0) {
                if (var7) {
                    Metrics var5 = new Metrics((JavaPlugin)this.Vulcan_a(), 11327);
                    var5.addCustomChart(new SimplePie("packetevents_version", () -> this.Vulcan_x().toString()));
                }
            } else if (var7) {
                break label47;
            }

            while (!this.injectorReady.get()) {
            }
        }

        label38: {
            Runnable var6;
            label37: {
                var6 = () -> {
                    long var1x = 66876338785522L;
                    long var3 = 119084676127620L;
                    long var5x = 123797029215992L;
                    Bukkit.getPluginManager().registerEvents(this.bukkitEventProcessorInternal, plugin);
                    int var10000x = Vulcan_a();
                    Iterator var8 = Bukkit.getOnlinePlayers().iterator();
                    int var7x = var10000x;

                    while (var8.hasNext()) {
                        Player var9 = (Player)var8.next();

                        try {
                            this.injector.Vulcan_D(new Object[]{var5x, var9});
                            this.Vulcan_N().Vulcan_X(new Object[]{var3, new PostPlayerInjectEvent(var9, false)});
                        } catch (Exception var10) {
                            var9.kickPlayer("Failed to inject... Please rejoin!");
                        }

                        if (var7x != 0) {
                            break;
                        }
                    }
                };
                if (var4 != 0) {
                    if (!this.lateBind) {
                        break label37;
                    }

                    Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, this.injector::Vulcan_B);
                    Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, var6);
                }

                if (var4 != 0) {
                    break label38;
                }
            }

            var6.run();
        }

        this.initialized = true;
        this.initializing = false;
    }

    @Deprecated
    public void Vulcan_T(Plugin var1) {
        this.Vulcan_y(var1, this.settings);
    }

    @Deprecated
    public void Vulcan_y(Plugin var1, PacketEventsSettings var2) {
        this.Vulcan_o(var2);
    }

    public void Vulcan_o() {
        long var1 = 47666491843353L;
        long var3 = 94080624911225L;
        long var5 = 53297714112873L;
        int var7 = Vulcan_Q();
        boolean var10000 = this.initialized;
        if (var7 != 0) {
            if (!this.initialized) {
                return;
            }

            var10000 = this.terminating;
        }

        if (!var10000) {
            label24: {
                for (Player var9 : Bukkit.getOnlinePlayers()) {
                    this.injector.Vulcan_Q(new Object[]{var5, var9});
                    if (var7 == 0) {
                        break label24;
                    }

                    if (var7 == 0) {
                        break;
                    }
                }

                this.injector.Vulcan_d(new Object[]{var3});
                this.Vulcan_N().Vulcan_h(new Object[0]);
                this.initialized = false;
            }

            this.terminating = false;
        }
    }

    @Deprecated
    public void Vulcan_A() {
        this.Vulcan_o();
    }

    public boolean Vulcan_r() {
        return this.loading;
    }

    public boolean Vulcan_B() {
        return this.loaded;
    }

    public boolean Vulcan_s() {
        return this.terminating;
    }

    @Deprecated
    public boolean Vulcan_w() {
        return this.Vulcan_s();
    }

    public boolean Vulcan_X() {
        return this.initializing;
    }

    public boolean Vulcan_E() {
        return this.initialized;
    }

    public Plugin Vulcan_a() {
        return plugin;
    }

    public GlobalChannelInjector Vulcan_G() {
        return this.injector;
    }

    public PacketProcessorInternal Vulcan_R() {
        return this.packetProcessorInternal;
    }

    public String Vulcan_p() {
        return this.handlerName;
    }

    public PacketEventsSettings Vulcan_N() {
        return this.settings;
    }

    public PEVersion Vulcan_x() {
        return this.version;
    }

    public EventManager Vulcan_N() {
        return this.eventManager;
    }

    public PlayerUtils Vulcan_O() {
        return this.playerUtils;
    }

    public ServerUtils Vulcan_l() {
        return this.serverUtils;
    }

    public ByteBufUtil Vulcan_m() {
        return this.byteBufUtil;
    }

    public UpdateChecker Vulcan_b() {
        return this.updateChecker;
    }

    private void Vulcan_H() {
        label13: {
            int var3 = Vulcan_Q();
            PacketEvents var10000 = this;
            if (var3 != 0) {
                if (this.updateChecker != null) {
                    break label13;
                }

                var10000 = this;
            }

            var10000.updateChecker = new UpdateChecker();
        }

        Thread var4 = new Thread(() -> {
            long var1 = 73114304934084L;
            long var3x = 71820540609001L;
            int var10000x = Vulcan_a();
            this.Vulcan_a().getLogger().info("[packetevents] Checking for an update, please wait...");
            int var5 = var10000x;
            UpdateCheckerStatus var6 = this.updateChecker.Vulcan_M(new Object[]{var3x});
            int var7 = 5;
            byte var8 = 5;
            int var9 = 0;

            while (var9 < var8 && (var6 == UpdateCheckerStatus.FAILED || var5 != 0)) {
                this.Vulcan_a().getLogger().severe("[packetevents] Checking for an update again in " + var7 + " seconds...");

                try {
                    Thread.sleep((long)var7 * 1000L);
                } catch (InterruptedException var11) {
                    var11.printStackTrace();
                }

                var7 *= 2;
                var6 = this.updateChecker.Vulcan_M(new Object[]{var3x});
                if (var5 == 0) {
                    if (var9 == 4) {
                        this.Vulcan_a().getLogger().severe("[packetevents] PacketEvents failed to check for an update. No longer retrying.");
                        if (var5 == 0) {
                            break;
                        }
                    }

                    var9++;
                }

                if (var5 != 0) {
                    break;
                }
            }
        }, "packetevents-update-check-thread");
        var4.start();
    }

    public static void Vulcan_x(int var0) {
        Vulcan_k = var0;
    }

    public static int Vulcan_a() {
        return Vulcan_k;
    }

    public static int Vulcan_Q() {
        int var0 = Vulcan_a();
        return var0 == 0 ? 76 : 0;
    }

    static {
        if (Vulcan_Q() == 0) {
            Vulcan_x(49);
        }
    }
}

```

`testData/results/custom-classes/zkm/sample1/io/github/repooper/packetevents/utils/netty/bytebuf/ByteBufUtil.dec`:

```dec
package io.github.repooper.packetevents.utils.netty.bytebuf;

public interface ByteBufUtil {
    Object Vulcan_y();

    Object Vulcan_u(byte[] var1);

    void Vulcan_G(Object var1);

    void Vulcan_u(Object var1);

    byte[] Vulcan_S(Object var1, long var2);

    void Vulcan_S(Object var1, byte[] var2, long var3);
}

```

`testData/results/custom-classes/zkm/sample1/io/github/repooper/packetevents/utils/netty/bytebuf/ByteBufUtil_7.dec`:

```dec
package io.github.repooper.packetevents.utils.netty.bytebuf;

import io.netty.buffer.Unpooled;
import me.frep.vulcan.spigot.check.AbstractCheck;
import net.minecraft.util.io.netty.buffer.ByteBuf;
import net.minecraft.util.io.netty.util.internal.EmptyArrays;

public final class ByteBufUtil_7 implements ByteBufUtil {
    @Override
    public Object Vulcan_y() {
        return Unpooled.buffer();
    }

    @Override
    public Object Vulcan_u(byte[] var1) {
        return Unpooled.wrappedBuffer(var1);
    }

    @Override
    public void Vulcan_G(Object var1) {
        ((ByteBuf)var1).retain();
    }

    @Override
    public void Vulcan_u(Object var1) {
        ((ByteBuf)var1).release();
    }

    @Override
    public byte[] Vulcan_S(Object var1, long var2) {
        String[] var10000 = ByteBufUtil_8.Vulcan_O();
        ByteBuf var6 = (ByteBuf)var1;
        String[] var5 = var10000;
        int var8 = var6.refCnt();
        String[] var10001 = var5;
        if (var2 > 0L) {
            if (var5 != null) {
                if (var8 < 1) {
                    return EmptyArrays.EMPTY_BYTES;
                }

                var8 = var6.hasArray();
            }

            var10001 = var5;
        }

        if (var10001 != null) {
            if (var8 != 0) {
                byte[] var7 = var6.array();
                if (var5 != null) {
                    return var7;
                }

                AbstractCheck.Vulcan_t(!AbstractCheck.Vulcan_a());
            }

            var8 = var6.readableBytes();
        }

        byte[] var9 = new byte[var8];
        var6.getBytes(var6.readerIndex(), var9);
        return var9;
    }

    @Override
    public void Vulcan_S(Object var1, byte[] var2, long var3) {
        String[] var10000 = ByteBufUtil_8.Vulcan_O();
        ByteBuf var7 = (ByteBuf)var1;
        String[] var6 = var10000;
        int var9 = var7.refCnt();
        if (var6 != null) {
            if (var9 < 1) {
                return;
            }

            var9 = var2.length;
        }

        int var8 = var9;
        if (var3 >= 0L && var6 != null) {
            if (var7.capacity() < var8) {
                var7.capacity(var8);
            }

            var7.setBytes(0, var2);
        }
    }
}

```

`testData/results/custom-classes/zkm/sample1/io/github/repooper/packetevents/utils/netty/bytebuf/ByteBufUtil_8.dec`:

```dec
package io.github.repooper.packetevents.utils.netty.bytebuf;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.util.internal.EmptyArrays;
import me.frep.vulcan.spigot.check.AbstractCheck;

public final class ByteBufUtil_8 implements ByteBufUtil {
    private static String[] Vulcan_n;

    @Override
    public Object Vulcan_y() {
        return Unpooled.buffer();
    }

    @Override
    public Object Vulcan_u(byte[] var1) {
        return Unpooled.wrappedBuffer(var1);
    }

    @Override
    public void Vulcan_G(Object var1) {
        ((ByteBuf)var1).retain();
    }

    @Override
    public void Vulcan_u(Object var1) {
        ((ByteBuf)var1).release();
    }

    @Override
    public byte[] Vulcan_S(Object var1, long var2) {
        String[] var10000 = Vulcan_O();
        ByteBuf var6 = (ByteBuf)var1;
        String[] var5 = var10000;
        int var8 = var6.refCnt();
        String[] var10001 = var5;
        if (var2 > 0L) {
            if (var5 != null) {
                if (var8 < 1) {
                    return EmptyArrays.EMPTY_BYTES;
                }

                var8 = var6.hasArray();
            }

            var10001 = var5;
        }

        byte[] var7;
        label39: {
            if (var10001 != null) {
                if (var8 != 0) {
                    var7 = var6.array();
                    if (var2 < 0L || var5 != null) {
                        break label39;
                    }
                }

                var8 = var6.readableBytes();
            }

            var7 = new byte[var8];
            var6.getBytes(var6.readerIndex(), var7);
        }

        byte var9 = AbstractCheck.Vulcan_l();
        if (var2 >= 0L) {
            if (var9 == 0) {
                return var7;
            }

            var9 = 1;
        }

        Vulcan_L(new String[var9]);
        return var7;
    }

    @Override
    public void Vulcan_S(Object var1, byte[] var2, long var3) {
        String[] var10000 = Vulcan_O();
        ByteBuf var7 = (ByteBuf)var1;
        String[] var6 = var10000;
        int var9 = var7.refCnt();
        if (var6 != null) {
            if (var9 < 1) {
                return;
            }

            var9 = var2.length;
        }

        int var8 = var9;
        if (var3 > 0L && var6 != null) {
            if (var7.capacity() < var8) {
                var7.capacity(var8);
            }

            var7.setBytes(0, var2);
        }
    }

    public static void Vulcan_L(String[] var0) {
        Vulcan_n = var0;
    }

    public static String[] Vulcan_O() {
        return Vulcan_n;
    }

    static {
        if (Vulcan_O() == null) {
            Vulcan_L(new String[5]);
        }
    }
}

```

`testData/results/custom-classes/zkm/sample2/a/a/a/a/a4.dec`:

```dec
package a.a.a.a;

import java.lang.invoke.CallSite;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.MutableCallSite;
import java.lang.invoke.MethodHandles.Lookup;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class a4 {
    private static final char a;
    private static final String b;
    private static final char c;
    private static final ConcurrentMap<String, List<Locale>> d;
    private static final ConcurrentMap<String, List<Locale>> e;
    private static final String[] g;
    private static final String[] h;
    private static final Map i = new HashMap(13);
    private static final long[] j;
    private static final Integer[] k;
    private static final Map l;

    public static List a() {
        return a5.a(new Object[0]);
    }

    private static List b(Predicate var0) {
        return (List)a(new Object[0]).stream().filter(var0).collect(Collectors.toList());
    }

    public static Set a() {
        return a5.a(new Object[0]);
    }

    public static List c(long var0, String var2) {
        long var10000 = 31437394211371L ^ var0;
        return var2 == null
            ? Collections.emptyList()
            : (List)e.computeIfAbsent(
                var2,
                var1 -> Collections.unmodifiableList(
                        b(new Object[]{(Predicate)var1x -> var2.equals(var1x.getLanguage()) && !var1x.getCountry().isEmpty() && var1x.getVariant().isEmpty()})
                    )
            );
    }

    public static boolean a(Locale var0) {
        return a(new Object[0]).contains(var0);
    }

    private static boolean b(String var0, long var1) {
        var1 = 31437394211371L ^ var1;
        long var4 = var1 ^ 34857456567897L;
        return bl.w(new Object[]{var0, var4}) && var0.length() == 2;
    }

    private static boolean c(long var0, String var2) {
        var0 = 31437394211371L ^ var0;
        long var4 = var0 ^ 48043344260702L;
        return bl.v(new Object[]{var4, var2}) && (var2.length() == 2 || var2.length() == 3);
    }

    public static boolean d(Locale var0, long var1) {
        var1 = 31437394211371L ^ var1;
        return var0 == null || a<"n">(15615, 9195357022975540980L ^ var1).equals(var0.toLanguageTag());
    }

    private static boolean e(String var0, long var1) {
        var1 = 31437394211371L ^ var1;
        long var4 = var1 ^ 46616467215434L;
        return bl.K(new Object[]{var4, var0}) && var0.length() == 3;
    }

    public static List d(String var0, long var1) {
        long var10000 = 31437394211371L ^ var1;
        return var0 == null
            ? Collections.emptyList()
            : (List)d.computeIfAbsent(
                var0,
                var1x -> Collections.unmodifiableList(b(new Object[]{(Predicate)var1xx -> var0.equals(var1xx.getCountry()) && var1xx.getVariant().isEmpty()}))
            );
    }

    public static List e(long var0, Locale var2) {
        var0 = 31437394211371L ^ var0;
        long var4 = var0 ^ 39473653018733L;
        return f(new Object[]{var4, var2, var2});
    }

    public static List f(long var0, Locale var2, Locale var3) {
        long var10000 = 31437394211371L ^ var0;
        ArrayList var5 = new ArrayList(4);
        if (var2 != null) {
            var5.add(var2);
            if (!var2.getVariant().isEmpty()) {
                var5.add(new Locale(var2.getLanguage(), var2.getCountry()));
            }

            if (!var2.getCountry().isEmpty()) {
                var5.add(new Locale(var2.getLanguage(), ""));
            }

            if (!var5.contains(var3)) {
                var5.add(var3);
            }
        }

        return Collections.unmodifiableList(var5);
    }

    private static Locale a(String var0, long var1) {
        var1 = 31437394211371L ^ var1;
        long var4 = var1 ^ 66218639382438L;
        long var6 = var1 ^ 111702527787094L;
        long var8 = var1 ^ 130108620867227L;
        if (c(new Object[]{var4, var0})) {
            return new Locale(var0);
        } else {
            int var11 = var0.indexOf(b<"f">(15280, 8092096839071741905L ^ var1)) != -1
                ? b<"f">(15280, 8092096839071741905L ^ var1)
                : b<"f">(4837, 2589275489172102784L ^ var1);
            String[] var12 = var0.split(String.valueOf((char)var11), 3);
            String var13 = var12[0];
            if (var12.length == 2) {
                String var14 = var12[1];
                if (c(new Object[]{var4, var13}) && b(new Object[]{var14, var8}) || e(new Object[]{var14, var6})) {
                    return new Locale(var13, var14);
                }
            } else if (var12.length == 3) {
                String var17 = var12[1];
                String var15 = var12[2];
                if (c(new Object[]{var4, var13}) && (var17.isEmpty() || b(new Object[]{var17, var8}) || e(new Object[]{var17, var6})) && !var15.isEmpty()) {
                    return new Locale(var13, var17, var15);
                }
            }

            throw new IllegalArgumentException(a<"n">(1237, 6134404036908578204L ^ var1) + var0);
        }
    }

    public static Locale b(Locale var0, long var1) {
        long var10000 = 31437394211371L ^ var1;
        return var0 != null ? var0 : Locale.getDefault();
    }

    public static Locale c(String var0, long var1) {
        var1 = 31437394211371L ^ var1;
        long var4 = var1 ^ 1247888201670L;
        int[] var6 = aa.b();
        String var10000 = var0;
        if (var6 == null) {
            if (var0 == null) {
                return null;
            }

            var10000 = var0;
        }

        int var12 = var10000.isEmpty();
        int[] var10001 = var6;
        if (var1 > 0L) {
            if (var6 == null) {
                if (var12 != 0) {
                    return new Locale("", "");
                }

                var12 = var0.contains("#");
            }

            var10001 = var6;
        }

        if (var10001 == null) {
            if (var12 != 0) {
                throw new IllegalArgumentException(a<"n">(21401, 4624162312858634044L ^ var1) + var0);
            }

            var12 = var0.length();
        }

        int var7 = var12;
        int var13 = var7;
        if (var6 == null) {
            if (var7 < 2) {
                throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
            }

            var13 = var0.charAt(0);
        }

        int var8;
        label125: {
            var8 = var13;
            var14 = var8;
            var16 = b<"f">(28702, 2493314406039607699L ^ var1);
            label115:
            if (var6 == null) {
                if (var8 != var16) {
                    var14 = var8;
                    var16 = b<"f">(32635, 5718631925737903858L ^ var1);
                    if (var1 <= 0L || var6 != null) {
                        break label115;
                    }

                    if (var8 != var16) {
                        return a(new Object[]{var0, var4});
                    }
                }

                var14 = var7;
                if (var6 != null) {
                    break label125;
                }

                var16 = 3;
            }

            if (var14 < var16) {
                throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
            }

            var14 = var0.charAt(1);
        }

        label102: {
            int var9 = var14;
            char var10 = var0.charAt(2);
            var15 = Character.isUpperCase((char)var9);
            var10001 = var6;
            if (var1 >= 0L) {
                if (var6 == null) {
                    if (var15 == 0) {
                        throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
                    }

                    var15 = Character.isUpperCase(var10);
                }

                if (var1 <= 0L) {
                    break label102;
                }

                var10001 = var6;
            }

            if (var10001 == null) {
                if (var15 == 0) {
                    throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
                }

                var15 = var7;
            }
        }

        label87: {
            var18 = 3;
            int[] var10002 = var6;
            if (var1 >= 0L) {
                if (var6 == null) {
                    if (var15 == 3) {
                        return new Locale("", var0.substring(1, 3));
                    }

                    var15 = var7;
                    var18 = 5;
                }

                if (var1 <= 0L) {
                    break label87;
                }

                var10002 = var6;
            }

            if (var10002 == null) {
                if (var15 < var18) {
                    throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
                }

                var15 = var0.charAt(3);
                var18 = var8;
            }
        }

        if (var15 != var18) {
            throw new IllegalArgumentException(a<"n">(1237, 6134424192876040305L ^ var1) + var0);
        } else {
            return new Locale("", var0.substring(1, 3), var0.substring(4));
        }
    }

    static {
        long var11 = 83388844507925L;
        Cipher var13;
        Cipher var10000 = var13 = Cipher.getInstance("DES/CBC/PKCS5Padding");
        SecretKeyFactory var10002 = SecretKeyFactory.getInstance("DES");
        byte[] var10003 = new byte[]{0, 0, 0, 0, 0, 0, 0, 0};

        for (int var14 = 1; var14 < 8; var14++) {
            var10003[var14] = (byte)((int)(var11 << var14 * 8 >>> 56));
        }

        var10000.init(2, var10002.generateSecret(new DESKeySpec(var10003)), new IvParameterSpec(new byte[8]));
        String[] var20 = new String[4];
        int var18 = 0;
        String var17 = "VpG\u000f\u0006zÂ¡4Ã¢G4Â¥G&ÃŠÃ¿Â©\u0006\u009cÃ“Ã¬{\u0097^G\u00824<\u0092\u00906ÃÂº[LjtDC\u0007(\u000e\u0088\"Â¡Ãœ&Â¦o\u008c/Ã†)Ã§Ã•\u0097\\ÂºÂ¢GaÃ¶~2*\u0005Ã‚\u0013L\u00ad\u001e,Ã…$SÃ¬\u0016Ã¾ÃD\u001b";
        byte var19 = 81;
        char var16 = '(';
        int var24 = -1;

        label54:
        while (true) {
            String var25 = var17.substring(++var24, var24 + var16);
            int var10001 = -1;

            while (true) {
                byte[] var21 = var13.doFinal(var25.getBytes("ISO-8859-1"));
                String var36 = a(var21).intern();
                switch (var10001) {
                    case 0:
                        var20[var18++] = var36;
                        if ((var24 += var16) >= var19) {
                            g = var20;
                            h = new String[4];
                            b = a<"n">(15899, 9143734501605108560L);
                            l = new HashMap(13);
                            Cipher var0;
                            var10000 = var0 = Cipher.getInstance("DES/CBC/NoPadding");
                            var10002 = SecretKeyFactory.getInstance("DES");
                            var10003 = new byte[]{0, 0, 0, 0, 0, 0, 0, 0};

                            for (int var1 = 1; var1 < 8; var1++) {
                                var10003[var1] = (byte)((int)(var11 << var1 * 8 >>> 56));
                            }

                            var10000.init(2, var10002.generateSecret(new DESKeySpec(var10003)), new IvParameterSpec(new byte[8]));
                            long[] var6 = new long[6];
                            int var3 = 0;
                            String var4 = "\u008aÃ¶';W\u0089S\u000eÃ§Ã‘$\u0091\u009d(Â¦Ã¶/Ãº\u0016\u009dÃ¼ÃµRzSÃ£ Ã•\t<)Ã¸";
                            byte var5 = 32;
                            byte var2 = 0;

                            label36:
                            while (true) {
                                var10001 = var2;
                                var2 += 8;
                                byte[] var7 = var4.substring(var10001, var2).getBytes("ISO-8859-1");
                                long[] var28 = var6;
                                var10001 = var3++;
                                long var40 = ((long)var7[0] & 255L) << 56
                                    | ((long)var7[1] & 255L) << 48
                                    | ((long)var7[2] & 255L) << 40
                                    | ((long)var7[3] & 255L) << 32
                                    | ((long)var7[4] & 255L) << 24
                                    | ((long)var7[5] & 255L) << 16
                                    | ((long)var7[6] & 255L) << 8
                                    | (long)var7[7] & 255L;
                                byte var43 = -1;

                                while (true) {
                                    long var8 = var40;
                                    byte[] var10 = var0.doFinal(
                                        new byte[]{
                                            (byte)((int)(var8 >>> 56)),
                                            (byte)((int)(var8 >>> 48)),
                                            (byte)((int)(var8 >>> 40)),
                                            (byte)((int)(var8 >>> 32)),
                                            (byte)((int)(var8 >>> 24)),
                                            (byte)((int)(var8 >>> 16)),
                                            (byte)((int)(var8 >>> 8)),
                                            (byte)((int)var8)
                                        }
                                    );
                                    long var45 = ((long)var10[0] & 255L) << 56
                                        | ((long)var10[1] & 255L) << 48
                                        | ((long)var10[2] & 255L) << 40
                                        | ((long)var10[3] & 255L) << 32
                                        | ((long)var10[4] & 255L) << 24
                                        | ((long)var10[5] & 255L) << 16
                                        | ((long)var10[6] & 255L) << 8
                                        | (long)var10[7] & 255L;
                                    switch (var43) {
                                        case 0:
                                            var28[var10001] = var45;
                                            if (var2 >= var5) {
                                                j = var6;
                                                k = new Integer[6];
                                                c = (char)b<"f">(16481, 4871103691199342599L);
                                                a = (char)b<"f">(4103, 7748647110630619232L);
                                                d = new ConcurrentHashMap();
                                                e = new ConcurrentHashMap();
                                                return;
                                            }
                                            break;
                                        default:
                                            var28[var10001] = var45;
                                            if (var2 < var5) {
                                                continue label36;
                                            }

                                            var4 = "Â¦Â³Â±Ã +\u0082AÂ½e\u0006ÃŸÃ¬P\u009a%Â¶";
                                            var5 = 16;
                                            var2 = 0;
                                    }

                                    byte var34 = var2;
                                    var2 += 8;
                                    var7 = var4.substring(var34, var2).getBytes("ISO-8859-1");
                                    var28 = var6;
                                    var10001 = var3++;
                                    var40 = ((long)var7[0] & 255L) << 56
                                        | ((long)var7[1] & 255L) << 48
                                        | ((long)var7[2] & 255L) << 40
                                        | ((long)var7[3] & 255L) << 32
                                        | ((long)var7[4] & 255L) << 24
                                        | ((long)var7[5] & 255L) << 16
                                        | ((long)var7[6] & 255L) << 8
                                        | (long)var7[7] & 255L;
                                    var43 = 0;
                                }
                            }
                        }

                        var16 = var17.charAt(var24);
                        break;
                    default:
                        var20[var18++] = var36;
                        if ((var24 += var16) < var19) {
                            var16 = var17.charAt(var24);
                            continue label54;
                        }

                        var17 = "Ã‡DÃ‰\u0087Â¯ÃŠÂ£h\bS\u0012Ã Â±Â´Ã–\u0080\u0010\u0006gÃƒ\u00051\u0007QYÃ¿5\u0099\u007f\u0082 Ã‡m";
                        var19 = 33;
                        var16 = 16;
                        var24 = -1;
                }

                var25 = var17.substring(++var24, var24 + var16);
                var10001 = 0;
            }
        }
    }

    private static String a(byte[] var0) {
        int var1 = 0;
        int var2;
        char[] var3 = new char[var2 = var0.length];

        for (int var4 = 0; var4 < var2; var4++) {
            int var5;
            if ((var5 = 255 & var0[var4]) < 192) {
                var3[var1++] = (char)var5;
            } else if (var5 < 224) {
                char var6 = (char)((char)(var5 & 31) << 6);
                byte var8 = var0[++var4];
                var6 = (char)(var6 | (char)(var8 & 63));
                var3[var1++] = var6;
            } else if (var4 < var2 - 2) {
                char var12 = (char)((char)(var5 & 15) << '\f');
                byte var9 = var0[++var4];
                var12 = (char)(var12 | (char)(var9 & 63) << 6);
                var9 = var0[++var4];
                var12 = (char)(var12 | (char)(var9 & 63));
                var3[var1++] = var12;
            }
        }

        return new String(var3, 0, var1);
    }

    private static String a(int var0, long var1) {
        int var5 = var0 ^ (int)(var1 & 32767L) ^ 21833;
        if (h[var5] == null) {
            Object[] var4;
            try {
                Long var3 = Thread.currentThread().getId();
                var4 = (Object[])i.get(var3);
                if (var4 == null) {
                    var4 = new Object[]{Cipher.getInstance("DES/CBC/PKCS5Padding"), SecretKeyFactory.getInstance("DES"), new IvParameterSpec(new byte[8])};
                    i.put(var3, var4);
                }
            } catch (Exception var10) {
                throw new RuntimeException("a/a/a/a/a4", var10);
            }

            byte[] var6 = new byte[8];
            var6[0] = (byte)((int)(var1 >>> 56));

            for (int var7 = 1; var7 < 8; var7++) {
                var6[var7] = (byte)((int)(var1 << var7 * 8 >>> 56));
            }

            DESKeySpec var11 = new DESKeySpec(var6);
            SecretKey var8 = ((SecretKeyFactory)var4[1]).generateSecret(var11);
            ((Cipher)var4[0]).init(2, var8, (IvParameterSpec)var4[2]);
            byte[] var9 = g[var5].getBytes("ISO-8859-1");
            h[var5] = a(((Cipher)var4[0]).doFinal(var9));
        }

        return h[var5];
    }

    private static Object a(Lookup var0, MutableCallSite var1, String var2, Object[] var3) {
        int var4 = (Integer)var3[0];
        long var5 = (Long)var3[1];
        String var7 = a(var4, var5);
        MethodHandle var8 = MethodHandles.constant(String.class, var7);
        var1.setTarget(MethodHandles.dropArguments(var8, 0, new Class[]{int.class, long.class}));
        return var7;
    }

    private static CallSite a(Lookup var0, String var1, MethodType var2) {
        MutableCallSite var3 = new MutableCallSite(var2);

        try {
            var3.setTarget(
                MethodHandles.explicitCastArguments(
                    MethodHandles.insertArguments("a".asCollector(Object[].class, var2.parameterCount()), 0, new Object[]{var0, var3, var1}), var2
                )
            );
            return var3;
        } catch (Exception var5) {
            throw new RuntimeException("a/a/a/a/a4" + " : " + var1 + " : " + var2.toString(), var5);
        }
    }

    private static int b(int var0, long var1) {
        int var3 = var0 ^ (int)(var1 & 32767L) ^ 10340;
        if (k[var3] == null) {
            byte[] var4 = new byte[]{
                (byte)((int)(var1 >>> 56)),
                (byte)((int)(var1 >>> 48)),
                (byte)((int)(var1 >>> 40)),
                (byte)((int)(var1 >>> 32)),
                (byte)((int)(var1 >>> 24)),
                (byte)((int)(var1 >>> 16)),
                (byte)((int)(var1 >>> 8)),
                (byte)((int)var1)
            };
            long var5 = j[var3];
            byte[] var7 = new byte[]{
                (byte)((int)(var5 >>> 56)),
                (byte)((int)(var5 >>> 48)),
                (byte)((int)(var5 >>> 40)),
                (byte)((int)(var5 >>> 32)),
                (byte)((int)(var5 >>> 24)),
                (byte)((int)(var5 >>> 16)),
                (byte)((int)(var5 >>> 8)),
                (byte)((int)var5)
            };
            Long var8 = Thread.currentThread().getId();
            Object[] var9 = (Object[])l.get(var8);

            byte[] var10;
            try {
                if (var9 == null) {
                    var9 = new Object[]{Cipher.getInstance("DES/CBC/NoPadding"), SecretKeyFactory.getInstance("DES"), new IvParameterSpec(new byte[8])};
                    l.put(var8, var9);
                }

                DESKeySpec var11 = new DESKeySpec(var4);
                SecretKey var12 = ((SecretKeyFactory)var9[1]).generateSecret(var11);
                Cipher var13 = (Cipher)var9[0];
                var13.init(2, var12, (IvParameterSpec)var9[2]);
                var10 = var13.doFinal(var7);
            } catch (Exception var14) {
                throw new RuntimeException("a/a/a/a/a4", var14);
            }

            int var15 = (var10[4] & 255) << 24 | (var10[5] & 255) << 16 | (var10[6] & 255) << 8 | var10[7] & 255;
            k[var3] = var15;
        }

        return k[var3];
    }

    private static int b(Lookup var0, MutableCallSite var1, String var2, Object[] var3) {
        int var4 = (Integer)var3[0];
        long var5 = (Long)var3[1];
        int var7 = b(var4, var5);
        MethodHandle var8 = MethodHandles.constant(int.class, var7);
        var1.setTarget(MethodHandles.dropArguments(var8, 0, new Class[]{int.class, long.class}));
        return var7;
    }

    private static CallSite b(Lookup var0, String var1, MethodType var2) {
        MutableCallSite var3 = new MutableCallSite(var2);

        try {
            var3.setTarget(
                MethodHandles.explicitCastArguments(
                    MethodHandles.insertArguments("b".asCollector(Object[].class, var2.parameterCount()), 0, new Object[]{var0, var3, var1}), var2
                )
            );
            return var3;
        } catch (Exception var5) {
            throw new RuntimeException("a/a/a/a/a4" + " : " + var1 + " : " + var2.toString(), var5);
        }
    }
}

```

`testData/results/custom-classes/zkm/sample2/a/a/a/a/a_.dec`:

```dec
package a.a.a.a;

import java.io.Serializable;
import java.lang.invoke.CallSite;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.MutableCallSite;
import java.lang.invoke.MethodHandles.Lookup;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class a_<T> implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Comparator<T> a;
    private transient int b;
    private final T c;
    private final T d;
    private transient String e;
    private static final String[] i;
    private static final String[] j;
    private static final Map k = new HashMap(13);
    private static final long[] l;
    private static final Integer[] m;
    private static final Map n;

    @Deprecated
    public static a_ a(Comparable var0, Comparable var1, long var2) {
        var2 = 104039320445854L ^ var2;
        long var10001 = var2 ^ 126902786326681L;
        int var5 = (int)((var2 ^ 126902786326681L) >>> 48);
        int var6 = (int)((var2 ^ 126902786326681L) << 16 >>> 32);
        int var7 = (int)(var10001 << 48 >>> 48);
        char var10000 = (char)var5;
        Object[] var10007 = new Object[]{null, null, null, null, null, var7};
        var10007[4] = var6;
        var10007[3] = null;
        var10007[2] = var1;
        var10007[1] = var0;
        var10007[0] = Integer.valueOf(var10000);
        return f(var10007);
    }

    @Deprecated
    public static a_ b(Object var0, long var1, Object var3, Comparator var4) {
        var1 = 104039320445854L ^ var1;
        int var6 = (int)((var1 ^ 5324234304270L) >>> 32);
        long var7 = (var1 ^ 5324234304270L) << 32 >>> 32;
        return new a_(var0, var3, var6, var7, var4);
    }

    public static a_ c(long var0, Comparable var2) {
        var0 = 104039320445854L ^ var0;
        long var10001 = var0 ^ 18483036967427L;
        int var4 = (int)((var0 ^ 18483036967427L) >>> 48);
        int var5 = (int)((var0 ^ 18483036967427L) << 16 >>> 32);
        int var6 = (int)(var10001 << 48 >>> 48);
        char var10000 = (char)var4;
        Object[] var10007 = new Object[]{null, null, null, null, null, var6};
        var10007[4] = var5;
        var10007[3] = null;
        var10007[2] = var2;
        var10007[1] = var2;
        var10007[0] = Integer.valueOf(var10000);
        return f(var10007);
    }

    public static a_ d(Object var0, long var1, Comparator var3) {
        var1 = 104039320445854L ^ var1;
        long var10001 = var1 ^ 21537914483950L;
        int var5 = (int)((var1 ^ 21537914483950L) >>> 48);
        int var6 = (int)((var1 ^ 21537914483950L) << 16 >>> 32);
        int var7 = (int)(var10001 << 48 >>> 48);
        char var10000 = (char)var5;
        Object[] var10007 = new Object[]{null, null, null, null, null, var7};
        var10007[4] = var6;
        var10007[3] = var3;
        var10007[2] = var0;
        var10007[1] = var0;
        var10007[0] = Integer.valueOf(var10000);
        return f(var10007);
    }

    public static a_ e(long var0, Comparable var2, Comparable var3) {
        var0 = 104039320445854L ^ var0;
        long var10001 = var0 ^ 30036545302711L;
        int var5 = (int)((var0 ^ 30036545302711L) >>> 48);
        int var6 = (int)((var0 ^ 30036545302711L) << 16 >>> 32);
        int var7 = (int)(var10001 << 48 >>> 48);
        char var10000 = (char)var5;
        Object[] var10007 = new Object[]{null, null, null, null, null, var7};
        var10007[4] = var6;
        var10007[3] = null;
        var10007[2] = var3;
        var10007[1] = var2;
        var10007[0] = Integer.valueOf(var10000);
        return f(var10007);
    }

    public static a_ f(int var0, Object var1, Object var2, Comparator var3, int var4, int var5) {
        long var7 = ((long)var0 << 48 | (long)var4 << 32 >>> 16 | (long)var5 << 48 >>> 48) ^ 104039320445854L;
        int var9 = (int)((var7 ^ 42314764531343L) >>> 32);
        long var10 = (var7 ^ 42314764531343L) << 32 >>> 32;
        return new a_(var1, var2, var9, var10, var3);
    }

    a_(Object var1, Object var2, int var3, long var4, Comparator var6) {
        long var7 = ((long)var3 << 32 | var4 << 32 >>> 32) ^ 104039320445854L;
        super();
        Objects.requireNonNull(var1, a<"c">(19146, 1150120633403825838L ^ var7));
        Objects.requireNonNull(var2, a<"c">(4588, 8165094295994926473L ^ var7));
        if (var6 == null) {
            this.a = s.INSTANCE;
        } else {
            this.a = var6;
        }

        if (this.a.compare(var1, var2) < 1) {
            this.d = (T)var1;
            this.c = (T)var2;
        } else {
            this.d = (T)var2;
            this.c = (T)var1;
        }
    }

    public boolean a(Object var1, long var2) {
        long var10000 = 104039320445854L ^ var2;
        return var1 == null ? false : this.a.compare(var1, this.d) > -1 && this.a.compare(var1, this.c) < 1;
    }

    public boolean b(a_ var1, long var2) {
        var2 = 104039320445854L ^ var2;
        long var5 = var2 ^ 32980145495734L;
        return var1 == null ? false : this.a(new Object[]{var1.d, var5}) && this.a(new Object[]{var1.c, var5});
    }

    public int a(Object var1, long var2) {
        var2 = 104039320445854L ^ var2;
        long var5 = var2 ^ 92272217773657L;
        long var7 = var2 ^ 1915727574734L;
        Objects.requireNonNull(var1, a<"c">(18631, 981500437573127396L ^ var2));
        if (this.c(new Object[]{var7, var1})) {
            return -1;
        } else {
            return this.e(new Object[]{var1, var5}) ? 1 : 0;
        }
    }

    public boolean equals(Object var1) {
        if (var1 == this) {
            return true;
        } else if (var1 != null && var1.getClass() == this.getClass()) {
            a_ var4 = (a_)var1;
            return this.d.equals(var4.d) && this.c.equals(var4.c);
        } else {
            return false;
        }
    }

    public Object a(long var1, Object var3) {
        var1 = 104039320445854L ^ var1;
        long var5 = var1 ^ 2349512232429L;
        long var7 = var1 ^ 88471214894458L;
        Objects.requireNonNull(var3, a<"c">(19426, 4519817850676745331L ^ var1));
        if (this.c(new Object[]{var7, var3})) {
            return this.d;
        } else {
            return this.e(new Object[]{var3, var5}) ? this.c : var3;
        }
    }

    public Comparator a() {
        return this.a;
    }

    public Object b() {
        return this.c;
    }

    public Object c() {
        return this.d;
    }

    public int hashCode() {
        long var1 = 98334368194806L;
        int var3 = this.b;
        if (this.b == 0) {
            int var4 = b<"m">(26604, 8453020672365342500L);
            int var5 = b<"m">(27286, 1275757911665058399L) * var4 + this.getClass().hashCode();
            int var6 = b<"m">(170, 4757999847740819553L) * var5 + this.d.hashCode();
            var3 = b<"m">(170, 4757999847740819553L) * var6 + this.c.hashCode();
            this.b = var3;
        }

        return var3;
    }

    public a_ g(a_ var1, long var2) {
        var2 = 104039320445854L ^ var2;
        long var10001 = var2 ^ 67044076869465L;
        int var5 = (int)((var2 ^ 67044076869465L) >>> 48);
        int var6 = (int)((var2 ^ 67044076869465L) << 16 >>> 32);
        int var7 = (int)(var10001 << 48 >>> 48);
        long var8 = var2 ^ 47154949516185L;
        int[] var10 = aa.b();
        int var10000 = this.i(new Object[]{var1, var8});
        if (var10 == null) {
            if (var10000 == 0) {
                throw new IllegalArgumentException(String.format(a<"c">(3324, 4697416246332586316L ^ var2), var1));
            }

            var10000 = this.equals(var1);
        }

        label44: {
            label48: {
                if (var2 >= 0L && var10 == null) {
                    if (var10000 != 0) {
                        return this;
                    }

                    var14 = this;
                    if (var10 != null) {
                        break label48;
                    }

                    var10000 = this.a(new Object[0]).compare(this.d, var1.d);
                }

                if (var10000 < 0) {
                    var15 = var1.d;
                    break label44;
                }

                var14 = this;
            }

            var15 = var14.d;
        }

        Object var11;
        label32: {
            var11 = var15;
            a_ var16 = this;
            if (var10 == null) {
                if (this.a(new Object[0]).compare(this.c, var1.c) < 0) {
                    var17 = this.c;
                    break label32;
                }

                var16 = var1;
            }

            var17 = var16.c;
        }

        Object var12 = var17;
        char var18 = (char)var5;
        Comparator var10003 = this.a(new Object[0]);
        Object[] var10007 = new Object[]{null, null, null, null, null, var7};
        var10007[4] = var6;
        var10007[3] = var10003;
        var10007[2] = var12;
        var10007[1] = var11;
        var10007[0] = Integer.valueOf(var18);
        return f(var10007);
    }

    public boolean c(long var1, Object var3) {
        long var10000 = 104039320445854L ^ var1;
        return var3 == null ? false : this.a.compare(var3, this.d) < 0;
    }

    public boolean d(long var1, a_ var3) {
        var1 = 104039320445854L ^ var1;
        long var5 = var1 ^ 105199813704059L;
        if (var3 == null) {
            return false;
        } else {
            Object var10002 = var3.c;
            return this.c(new Object[]{var5, var10002});
        }
    }

    public boolean e(Object var1, long var2) {
        long var10000 = 104039320445854L ^ var2;
        return var1 == null ? false : this.a.compare(var1, this.c) > 0;
    }

    public boolean f(long var1, a_ var3) {
        var1 = 104039320445854L ^ var1;
        long var5 = var1 ^ 114263133395304L;
        return var3 == null ? false : this.e(new Object[]{var3.d, var5});
    }

    public boolean g(Object var1, long var2) {
        long var10000 = 104039320445854L ^ var2;
        return var1 == null ? false : this.a.compare(var1, this.c) == 0;
    }

    public boolean h(long var1) {
        long var10000 = 104039320445854L ^ var1;
        return this.a == s.INSTANCE;
    }

    public boolean i(a_ var1, long var2) {
        var2 = 104039320445854L ^ var2;
        long var5 = var2 ^ 9050573107348L;
        if (var1 == null) {
            return false;
        } else {
            boolean var10000 = var1.a(new Object[]{this.d, var5});
            if (var2 >= 0L) {
                if (!var10000) {
                    var10000 = var1.a(new Object[]{this.c, var5});
                    if (var2 < 0L) {
                        return var10000;
                    }

                    if (!var10000 && !this.a(new Object[]{var1.d, var5})) {
                        return false;
                    }
                }

                var10000 = true;
            }

            return var10000;
        }
    }

    public boolean j(long var1, Object var3) {
        long var10000 = 104039320445854L ^ var1;
        return var3 == null ? false : this.a.compare(var3, this.d) == 0;
    }

    public String toString() {
        long var1 = 15341762901975L;
        if (this.e == null) {
            this.e = "[" + this.d + a<"c">(18317, 6648620723262088254L) + this.c + "]";
        }

        return this.e;
    }

    public String a(String var1) {
        return String.format(var1, this.d, this.c, this.a);
    }

    static {
        long var11 = 63140453688002L;
        Cipher var13;
        Cipher var10000 = var13 = Cipher.getInstance("DES/CBC/PKCS5Padding");
        SecretKeyFactory var10002 = SecretKeyFactory.getInstance("DES");
        byte[] var10003 = new byte[]{0, 0, 0, 0, 0, 0, 0, 0};

        for (int var14 = 1; var14 < 8; var14++) {
            var10003[var14] = (byte)((int)(var11 << var14 * 8 >>> 56));
        }

        var10000.init(2, var10002.generateSecret(new DESKeySpec(var10003)), new IvParameterSpec(new byte[8]));
        String[] var20 = new String[6];
        int var18 = 0;
        String var17 = "ÃŒÂº`D\u0099\u001bÃ»Â±Â®:\fzÃ•Ã±\u0094 $,Z\u009dÂ³(mjQ\u0018TÃ›\u0010ÂªÃÃ‰\u0018\u0082DÂ¾W\u001bÃ½ÃŽÃÃ³\u0091\u009ay/P\u0001^Â«9\u0098\u0004Ã§\u0089Ã£N\u0010\u0004Ã¡\u0091?+\u0085\u0084o\u001a\u0088Ã’Ã‹ÃœÃŸÃ€Ã©`Â¹\u009f{}ÃR`\u00808Ã\u0087\rÃ¢\u009b\u0010Ã²\u0097UÂ 3Z\u009f[Y\u0002&Ã™Â¹\u001eN7?Ã¹\u0011Â§\"HQ|Ã¡Ã¤\u0013e8T\u008a_-NÃ®[\u0082\u008bC]]Â³\rÃ¨Â¦ÂµdÂ¸ÃœL\u0012Â 7Ã¨\u009fÂ©Â¼Â¹\u0089\u001bÂ¥,\u0002bo\u0003~\u009bÂ¬?5vÂ¨\u000efÃ¬Ã›^#\u001dÃ¿";
        short var19 = 171;
        char var16 = ' ';
        int var23 = -1;

        label45:
        while (true) {
            String var24 = var17.substring(++var23, var23 + var16);
            int var10001 = -1;

            while (true) {
                byte[] var21 = var13.doFinal(var24.getBytes("ISO-8859-1"));
                String var33 = a(var21).intern();
                switch (var10001) {
                    case 0:
                        var20[var18++] = var33;
                        if ((var23 += var16) >= var19) {
                            i = var20;
                            j = new String[6];
                            n = new HashMap(13);
                            Cipher var0;
                            var10000 = var0 = Cipher.getInstance("DES/CBC/NoPadding");
                            var10002 = SecretKeyFactory.getInstance("DES");
                            var10003 = new byte[]{0, 0, 0, 0, 0, 0, 0, 0};

                            for (int var1 = 1; var1 < 8; var1++) {
                                var10003[var1] = (byte)((int)(var11 << var1 * 8 >>> 56));
                            }

                            var10000.init(2, var10002.generateSecret(new DESKeySpec(var10003)), new IvParameterSpec(new byte[8]));
                            long[] var6 = new long[3];
                            int var3 = 0;
                            String var4 = "Ãš\u0016Â¡$Ã+\u0005\n\u0095\u000eÂ³Ã½\u0006~\u008fÃ£\u0019/&\u0096RÃ¡\nÃ¦";
                            byte var5 = 24;
                            byte var2 = 0;

                            do {
                                var10001 = var2;
                                var2 += 8;
                                byte[] var7 = var4.substring(var10001, var2).getBytes("ISO-8859-1");
                                var10001 = var3++;
                                long var8 = ((long)var7[0] & 255L) << 56
                                    | ((long)var7[1] & 255L) << 48
                                    | ((long)var7[2] & 255L) << 40
                                    | ((long)var7[3] & 255L) << 32
                                    | ((long)var7[4] & 255L) << 24
                                    | ((long)var7[5] & 255L) << 16
                                    | ((long)var7[6] & 255L) << 8
                                    | (long)var7[7] & 255L;
                                byte[] var10 = var0.doFinal(
                                    new byte[]{
                                        (byte)((int)(var8 >>> 56)),
                                        (byte)((int)(var8 >>> 48)),
                                        (byte)((int)(var8 >>> 40)),
                                        (byte)((int)(var8 >>> 32)),
                                        (byte)((int)(var8 >>> 24)),
                                        (byte)((int)(var8 >>> 16)),
                                        (byte)((int)(var8 >>> 8)),
                                        (byte)((int)var8)
                                    }
                                );
                                long var10004 = ((long)var10[0] & 255L) << 56
                                    | ((long)var10[1] & 255L) << 48
                                    | ((long)var10[2] & 255L) << 40
                                    | ((long)var10[3] & 255L) << 32
                                    | ((long)var10[4] & 255L) << 24
                                    | ((long)var10[5] & 255L) << 16
                                    | ((long)var10[6] & 255L) << 8
                                    | (long)var10[7] & 255L;
                                byte var38 = -1;
                                var6[var10001] = var10004;
                            } while (var2 < var5);

                            l = var6;
                            m = new Integer[3];
                            return;
                        }

                        var16 = var17.charAt(var23);
                        break;
                    default:
                        var20[var18++] = var33;
                        if ((var23 += var16) < var19) {
                            var16 = var17.charAt(var23);
                            continue label45;
                        }

                        var17 = "Ã‘Ãª84Â¶\u0007aÂºÂ¾;\u0084S\u0094Âª9l\u0010Âº\u0002\u000fÃ’\\\u000eÂ«Ã’QÃ¼\u008cÃ¨ÃÂ¯)\u0016";
                        var19 = 33;
                        var16 = 16;
                        var23 = -1;
                }

                var24 = var17.substring(++var23, var23 + var16);
                var10001 = 0;
            }
        }
    }

    private static String a(byte[] var0) {
        int var1 = 0;
        int var2;
        char[] var3 = new char[var2 = var0.length];

        for (int var4 = 0; var4 < var2; var4++) {
            int var5;
            if ((var5 = 255 & var0[var4]) < 192) {
                var3[var1++] = (char)var5;
            } else if (var5 < 224) {
                char var6 = (char)((char)(var5 & 31) << 6);
                byte var8 = var0[++var4];
                var6 = (char)(var6 | (char)(var8 & 63));
                var3[var1++] = var6;
            } else if (var4 < var2 - 2) {
                char var12 = (char)((char)(var5 & 15) << '\f');
                byte var9 = var0[++var4];
                var12 = (char)(var12 | (char)(var9 & 63) << 6);
                var9 = var0[++var4];
                var12 = (char)(var12 | (char)(var9 & 63));
                var3[var1++] = var12;
            }
        }

        return new String(var3, 0, var1);
    }

    private static String a(int var0, long var1) {
        int var5 = var0 ^ (int)(var1 & 32767L) ^ 9142;
        if (j[var5] == null) {
            Object[] var4;
            try {
                Long var3 = Thread.currentThread().getId();
                var4 = (Object[])k.get(var3);
                if (var4 == null) {
                    var4 = new Object[]{Cipher.getInstance("DES/CBC/PKCS5Padding"), SecretKeyFactory.getInstance("DES"), new IvParameterSpec(new byte[8])};
                    k.put(var3, var4);
                }
            } catch (Exception var10) {
                throw new RuntimeException("a/a/a/a/a_", var10);
            }

            byte[] var6 = new byte[8];
            var6[0] = (byte)((int)(var1 >>> 56));

            for (int var7 = 1; var7 < 8; var7++) {
                var6[var7] = (byte)((int)(var1 << var7 * 8 >>> 56));
            }

            DESKeySpec var11 = new DESKeySpec(var6);
            SecretKey var8 = ((SecretKeyFactory)var4[1]).generateSecret(var11);
            ((Cipher)var4[0]).init(2, var8, (IvParameterSpec)var4[2]);
            byte[] var9 = i[var5].getBytes("ISO-8859-1");
            j[var5] = a(((Cipher)var4[0]).doFinal(var9));
        }

        return j[var5];
    }

    private static Object a(Lookup var0, MutableCallSite var1, String var2, Object[] var3) {
        int var4 = (Integer)var3[0];
        long var5 = (Long)var3[1];
        String var7 = a(var4, var5);
        MethodHandle var8 = MethodHandles.constant(String.class, var7);
        var1.setTarget(MethodHandles.dropArguments(var8, 0, new Class[]{int.class, long.class}));
        return var7;
    }

    private static CallSite a(Lookup var0, String var1, MethodType var2) {
        MutableCallSite var3 = new MutableCallSite(var2);

        try {
            var3.setTarget(
                MethodHandles.explicitCastArguments(
                    MethodHandles.insertArguments("a".asCollector(Object[].class, var2.parameterCount()), 0, new Object[]{var0, var3, var1}), var2
                )
            );
            return var3;
        } catch (Exception var5) {
            throw new RuntimeException("a/a/a/a/a_" + " : " + var1 + " : " + var2.toString(), var5);
        }
    }

    private static int b(int var0, long var1) {
        int var3 = var0 ^ (int)(var1 & 32767L) ^ 18633;
        if (m[var3] == null) {
            byte[] var4 = new byte[]{
                (byte)((int)(var1 >>> 56)),
                (byte)((int)(var1 >>> 48)),
                (byte)((int)(var1 >>> 40)),
                (byte)((int)(var1 >>> 32)),
                (byte)((int)(var1 >>> 24)),
                (byte)((int)(var1 >>> 16)),
                (byte)((int)(var1 >>> 8)),
                (byte)((int)var1)
            };
            long var5 = l[var3];
            byte[] var7 = new byte[]{
                (byte)((int)(var5 >>> 56)),
                (byte)((int)(var5 >>> 48)),
                (byte)((int)(var5 >>> 40)),
                (byte)((int)(var5 >>> 32)),
                (byte)((int)(var5 >>> 24)),
                (byte)((int)(var5 >>> 16)),
                (byte)((int)(var5 >>> 8)),
                (byte)((int)var5)
            };
            Long var8 = Thread.currentThread().getId();
            Object[] var9 = (Object[])n.get(var8);

            byte[] var10;
            try {
                if (var9 == null) {
                    var9 = new Object[]{Cipher.getInstance("DES/CBC/NoPadding"), SecretKeyFactory.getInstance("DES"), new IvParameterSpec(new byte[8])};
                    n.put(var8, var9);
                }

                DESKeySpec var11 = new DESKeySpec(var4);
                SecretKey var12 = ((SecretKeyFactory)var9[1]).generateSecret(var11);
                Cipher var13 = (Cipher)var9[0];
                var13.init(2, var12, (IvParameterSpec)var9[2]);
                var10 = var13.doFinal(var7);
            } catch (Exception var14) {
                throw new RuntimeException("a/a/a/a/a_", var14);
            }

            int var15 = (var10[4] & 255) << 24 | (var10[5] & 255) << 16 | (var10[6] & 255) << 8 | var10[7] & 255;
            m[var3] = var15;
        }

        return m[var3];
    }

    private static int b(Lookup var0, MutableCallSite var1, String var2, Object[] var3) {
        int var4 = (Integer)var3[0];
        long var5 = (Long)var3[1];
        int var7 = b(var4, var5);
        MethodHandle var8 = MethodHandles.constant(int.class, var7);
        var1.setTarget(MethodHandles.dropArguments(var8, 0, new Class[]{int.class, long.class}));
        return var7;
    }

    private static CallSite b(Lookup var0, String var1, MethodType var2) {
        MutableCallSite var3 = new MutableCallSite(var2);

        try {
            var3.setTarget(
                MethodHandles.explicitCastArguments(
                    MethodHandles.insertArguments("b".asCollector(Object[].class, var2.parameterCount()), 0, new Object[]{var0, var3, var1}), var2
                )
            );
            return var3;
        } catch (Exception var5) {
            throw new RuntimeException("a/a/a/a/a_" + " : " + var1 + " : " + var2.toString(), var5);
        }
    }
}

```

`testData/results/custom-classes/zkm/sample2/a/a/a/a/ba.dec`:

```dec
package a.a.a.a;

import java.util.Comparator;

public class ba<N extends Number> extends a_<N> {
    private static final long serialVersionUID = 1L;

    public ba(long var1, Number var3, Number var4, Comparator var5) {
        var1 = 87486991067610L ^ var1;
        int var6 = (int)((var1 ^ 101419208877758L) >>> 32);
        long var7 = (var1 ^ 101419208877758L) << 32 >>> 32;
        super(var3, var4, var6, var7, var5);
    }
}

```

`testData/results/custom-classes/zkm/sample2/a/a/a/a/bc.dec`:

```dec
package a.a.a.a;

public final class bc extends ba<Integer> {
    private static final long serialVersionUID = 1L;

    public static bc a(int var0, long var1, int var3) {
        var1 = 90497055901648L ^ var1;
        long var5 = var1 ^ 32932499080870L;
        return b(new Object[]{var0, var5, var3});
    }

    public static bc b(Integer var0, long var1, Integer var3) {
        var1 = 90497055901648L ^ var1;
        int var5 = (int)((var1 ^ 61248110729654L) >>> 56);
        long var6 = (var1 ^ 61248110729654L) << 8 >>> 8;
        return new bc((byte)var5, var0, var3, var6);
    }

    private bc(byte var1, Integer var2, Integer var3, long var4) {
        long var6 = ((long)var1 << 56 | var4 << 8 >>> 8) ^ 90497055901648L;
        long var8 = var6 ^ 83241345321299L;
        super(var8, var2, var3, null);
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/Main.dec`:

```dec
public class Main {
    private static final String a;
    private static final long[] b;
    private static final Integer[] c;

    public static void main(String[] var0) {
        long var1 = 53836601486112L;
        e var3 = new e();
        var3.setTitle(a);
        var3.setSize(a(23704, 8408508685984484905L), a(21193, 5113680640368394361L));
        var3.setVisible(true);
        var3.setDefaultCloseOperation(3);
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    static {
        char[] var10001 = "K9,%\u0001".toCharArray();
        int var10003 = var10001.length;
        int var8 = 0;
        char[] var29 = var10001;
        int var18 = var10003;
        char[] var35;
        int var10004;
        char var10005;
        byte var10006;
        if (var10003 <= 1) {
            var35 = var10001;
            var10004 = var8;
            var10005 = var10001[var8];
            switch (var8 % 7) {
                case 0:
                    var10006 = 24;
                    break;
                case 1:
                    var10006 = 87;
                    break;
                case 2:
                    var10006 = 77;
                    break;
                case 3:
                    var10006 = 78;
                    break;
                case 4:
                    var10006 = 100;
                    break;
                case 5:
                    var10006 = 22;
                    break;
                default:
                    var10006 = 62;
            }
        } else {
            var29 = var10001;
            var18 = var10003;
            if (var10003 <= var8) {
                String var44 = new String(var10001).intern();
                byte var25 = -1;
                a = var44;
                long var9 = 75645303560601L;
                long[] var14 = new long[2];
                int var11 = 0;
                String var12 = "\u0098wSÃ³d\u0081Ã˜ÃŒpÃ\u0018\"\r\u0096Ã–\u009c";
                byte var13 = 16;
                byte var10 = 0;

                do {
                    byte var26 = var10;
                    var10 += 8;
                    byte[] var15 = var12.substring(var26, var10).getBytes("ISO-8859-1");
                    int var27 = var11++;
                    long var47 = (
                            ((long)var15[0] & 255L) << 56
                                | ((long)var15[1] & 255L) << 48
                                | ((long)var15[2] & 255L) << 40
                                | ((long)var15[3] & 255L) << 32
                                | ((long)var15[4] & 255L) << 24
                                | ((long)var15[5] & 255L) << 16
                                | ((long)var15[6] & 255L) << 8
                                | (long)var15[7] & 255L
                        )
                        ^ var9;
                    byte var45 = -1;
                    var14[var27] = var47;
                } while (var10 < var13);

                b = var14;
                c = new Integer[2];
                return;
            }

            var35 = var10001;
            var10004 = var8;
            var10005 = var10001[var8];
            switch (var8 % 7) {
                case 0:
                    var10006 = 24;
                    break;
                case 1:
                    var10006 = 87;
                    break;
                case 2:
                    var10006 = 77;
                    break;
                case 3:
                    var10006 = 78;
                    break;
                case 4:
                    var10006 = 100;
                    break;
                case 5:
                    var10006 = 22;
                    break;
                default:
                    var10006 = 62;
            }
        }

        while (true) {
            var35[var10004] = (char)(var10005 ^ var10006);
            var8++;
            if (var18 == 0) {
                var10004 = var18;
                var35 = var29;
                var10005 = var29[var18];
                switch (var8 % 7) {
                    case 0:
                        var10006 = 24;
                        break;
                    case 1:
                        var10006 = 87;
                        break;
                    case 2:
                        var10006 = 77;
                        break;
                    case 3:
                        var10006 = 78;
                        break;
                    case 4:
                        var10006 = 100;
                        break;
                    case 5:
                        var10006 = 22;
                        break;
                    default:
                        var10006 = 62;
                }
            } else {
                if (var18 <= var8) {
                    String var42 = new String(var29).intern();
                    byte var22 = -1;
                    a = var42;
                    long var0 = 75645303560601L;
                    long[] var6 = new long[2];
                    int var3 = 0;
                    String var4 = "\u0098wSÃ³d\u0081Ã˜ÃŒpÃ\u0018\"\r\u0096Ã–\u009c";
                    byte var5 = 16;
                    byte var2 = 0;

                    do {
                        byte var23 = var2;
                        var2 += 8;
                        byte[] var7 = var4.substring(var23, var2).getBytes("ISO-8859-1");
                        int var24 = var3++;
                        long var46 = (
                                ((long)var7[0] & 255L) << 56
                                    | ((long)var7[1] & 255L) << 48
                                    | ((long)var7[2] & 255L) << 40
                                    | ((long)var7[3] & 255L) << 32
                                    | ((long)var7[4] & 255L) << 24
                                    | ((long)var7[5] & 255L) << 16
                                    | ((long)var7[6] & 255L) << 8
                                    | (long)var7[7] & 255L
                            )
                            ^ var0;
                        byte var43 = -1;
                        var6[var24] = var46;
                    } while (var2 < var5);

                    b = var6;
                    c = new Integer[2];
                    return;
                }

                var35 = var29;
                var10004 = var8;
                var10005 = var29[var8];
                switch (var8 % 7) {
                    case 0:
                        var10006 = 24;
                        break;
                    case 1:
                        var10006 = 87;
                        break;
                    case 2:
                        var10006 = 77;
                        break;
                    case 3:
                        var10006 = 78;
                        break;
                    case 4:
                        var10006 = 100;
                        break;
                    case 5:
                        var10006 = 22;
                        break;
                    default:
                        var10006 = 62;
                }
            }
        }
    }

    private static int a(int var0, long var1) {
        int var3 = var0 ^ (int)(var1 & 32767L) ^ 4784;
        if (c[var3] == null) {
            c[var3] = (int)(b[var3] ^ var1);
        }

        return c[var3];
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/a.dec`:

```dec
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

public class a extends KeyAdapter {
    public void keyPressed(KeyEvent var1) {
        boolean var4;
        label60: {
            label61: {
                label62: {
                    var4 = d.h;
                    int var10000 = var1.getKeyCode();
                    if (!var4) {
                        switch (var10000) {
                            case 37:
                                break label61;
                            case 38:
                                break label62;
                            case 39:
                                var10000 = d.e;
                                break;
                            case 40:
                                break label60;
                            default:
                                return;
                        }
                    }

                    if (!var4) {
                        if (var10000 == 2) {
                            return;
                        }

                        var10000 = 1;
                    }

                    d.e = var10000;
                    if (!var4) {
                        return;
                    }
                }

                int var5 = d.e;
                if (!var4) {
                    if (d.e == 4) {
                        return;
                    }

                    var5 = 3;
                }

                d.e = var5;
                if (!var4) {
                    return;
                }
            }

            int var6 = d.e;
            if (!var4) {
                if (d.e == 1) {
                    return;
                }

                var6 = 2;
            }

            d.e = var6;
            if (!var4) {
                return;
            }
        }

        int var7 = d.e;
        if (!var4) {
            if (d.e == 3) {
                return;
            }

            var7 = 4;
        }

        d.e = var7;
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/b.dec`:

```dec
import java.awt.Color;
import java.util.ArrayList;

public class b {
    ArrayList<Color> a = new ArrayList();
    int b;
    f c;

    public b(int var1) {
        this.a.add(Color.darkGray);
        this.a.add(Color.BLUE);
        this.a.add(Color.white);
        this.b = var1;
        this.c = new f((Color)this.a.get(this.b));
    }

    public void a(int var1) {
        this.c.a(new Object[]{(Color)this.a.get(var1)});
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/c.dec`:

```dec
public class c {
    public int a;
    public int b;
    public static boolean c;

    public c(int var1, int var2) {
        this.a = var1;
        this.b = var2;
    }

    public void a(int var1, int var2) {
        this.a = var1;
        this.b = var2;
    }

    public int a() {
        return this.a;
    }

    public int b() {
        return this.b;
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/d.dec`:

```dec
import java.util.ArrayList;
import java.util.Iterator;

public class d extends Thread {
    ArrayList<ArrayList<b>> a = new ArrayList();
    c b;
    int c;
    long d;
    public static int e;
    ArrayList<c> f;
    c g;
    public static boolean h;
    private static final String[] i;
    private static final String[] j;
    private static final long[] k;
    private static final Integer[] l;
    private static final long m;

    d(long var1, c var3) {
        this.c = a(20214, 210489315596258668L ^ var1);
        this.d = m;
        this.f = new ArrayList();
        this.a = e.a;
        boolean var10000 = h;
        this.b = new c(var3.a, var3.b);
        e = 1;
        c var5 = new c(this.b.a(new Object[0]), this.b.b(new Object[0]));
        boolean var4 = var10000;
        this.f.add(var5);
        this.g = new c(e.c - 1, e.b - 1);
        this.d(new Object[]{this.g});
        var10000 = var4;
        if (var1 > 0L) {
            if (!var4) {
                return;
            }

            var10000 = c.c;
        }

        if (var1 >= 0L) {
            var10000 = !var10000;
        }

        c.c = var10000;
    }

    public void run() {
        long var1 = 89995196843699L;
        long var3 = 12972172530972L;
        long var5 = 121593940001805L;
        long var7 = 41896598891982L;
        short var9 = 18292;
        int var10 = -1604886824;

        while (true) {
            int var10001 = e;
            Object[] var10004 = new Object[]{null, var7};
            var10004[0] = var10001;
            this.e(var10004);
            this.b(new Object[]{var5});
            this.f(new Object[]{var3});
            var10004 = new Object[]{null, var10};
            var10004[0] = Integer.valueOf(var9);
            this.g(var10004);
            this.a(new Object[0]);
        }
    }

    private void a() {
        try {
            sleep(this.d);
        } catch (InterruptedException var3) {
            var3.printStackTrace();
        }
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    private void b(long var1) {
        long var4 = var1 ^ 110402980100581L;
        long var6 = var1 ^ 34179827676109L;
        int var10000 = h;
        c var9 = (c)this.f.get(this.f.size() - 1);
        byte var8 = (byte)var10000;
        int var10 = 0;

        int var17;
        byte var10002;
        label96: {
            label95:
            while (true) {
                c var10001;
                if (var10 <= this.f.size() - 2) {
                    var10000 = var9.a(new Object[0]);
                    var10001 = (c)this.f.get(var10);
                } else {
                    var10000 = var9.a(new Object[0]);
                    var10001 = this.g;
                    if (var1 > 0L) {
                        var17 = this.g.b;
                        break;
                    }
                }

                do {
                    var17 = var10001.a(new Object[0]);
                    var10002 = var8;
                    if (var1 <= 0L) {
                        break label96;
                    }

                    if (var8 != 0) {
                        break label95;
                    }

                    if (var8 == 0) {
                        if (var10000 == var17) {
                            var10000 = var9.b(new Object[0]);
                            if (var8 == 0) {
                                var10000 = var10000 == ((c)this.f.get(var10)).b(new Object[0]) ? 1 : 0;
                            }
                        } else {
                            var10000 = 0;
                        }
                    } else {
                        var10000 = var10000 == var17 ? 1 : 0;
                    }

                    int var11 = var10000;
                    byte var15 = var8;
                    if (var1 > 0L) {
                        if (var8 == 0) {
                            if (var11 != 0) {
                                this.c(new Object[]{var6});
                            }

                            var10++;
                        }

                        var15 = var8;
                    }

                    if (var15 == 0) {
                        continue label95;
                    }

                    var10000 = var9.a(new Object[0]);
                    var10001 = this.g;
                } while (var1 <= 0L);

                var17 = this.g.b;
                break;
            }

            var10002 = var8;
        }

        label66: {
            label65: {
                if (var10002 == 0) {
                    if (var10000 != var17) {
                        break label65;
                    }

                    var10000 = var9.b(new Object[0]);
                    if (var8 != 0) {
                        break label66;
                    }

                    var17 = this.g.a;
                }

                if (var10000 == var17) {
                    var10000 = 1;
                    break label66;
                }
            }

            var10000 = 0;
        }

        label102: {
            var10 = var10000;
            var10000 = var8;
            if (var1 > 0L) {
                if (var8 != 0) {
                    break label102;
                }

                var10000 = var10;
            }

            if (var10000 == 0) {
                return;
            }

            System.out.println(a(879106065, -879064062, (int)var1));
            this.c++;
            this.g = this.a(new Object[]{var4});
        }

        this.d(new Object[]{this.g});
    }

    private void c(long var1) {
        System.out.println(a(672771037, -672779940, (int)var1));

        while (true) {
            this.a(new Object[0]);
        }
    }

    private void d(c var1) {
        ((b)((ArrayList)this.a.get(var1.a)).get(var1.b)).a(new Object[]{1});
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    private c a(long var1) {
        int var10000 = h;
        int var6 = 0 + (int)(Math.random() * 19.0);
        int var7 = 0 + (int)(Math.random() * 19.0);
        c var5 = new c(var6, var7);
        byte var4 = (byte)var10000;
        int var10 = 0;

        label53:
        while (true) {
            if (var10 <= this.f.size() - 1) {
                var11 = var5;
                int var10001 = var4;
                if (var1 >= 0L) {
                    if (var4 != 0) {
                        break;
                    }

                    var10001 = 0;
                }

                label58: {
                    var10000 = var5.b(new Object[var10001]);
                    var10001 = ((c)this.f.get(var10)).a(new Object[0]);
                    byte var10002 = var4;
                    if (var1 >= 0L) {
                        if (var4 == 0) {
                            if (var10000 != var10001) {
                                break label58;
                            }

                            var10000 = var5.a(new Object[0]);
                            var10001 = ((c)this.f.get(var10)).b(new Object[0]);
                            var10002 = var4;
                        } else {
                            var10002 = var4;
                        }
                    }

                    if (var10002 == 0) {
                        if (var10000 != var10001) {
                            break label58;
                        }

                        var6 = 0 + (int)(Math.random() * 19.0);
                        var10000 = 0;
                        var10001 = (int)(Math.random() * 19.0);
                    }

                    var7 = var10000 + var10001;
                    var5 = new c(var6, var7);
                    var10 = 0;
                }

                var10++;
                if (var4 == 0) {
                    continue;
                }
            }

            while (var1 <= 0L) {
                var10 = 0;
                var10++;
                if (var4 == 0) {
                    continue label53;
                }
            }

            var11 = var5;
            break;
        }

        return var11;
    }

    private void e(int var1, long var2) {
        label106: {
            byte var5;
            d var10;
            label101: {
                label107: {
                    label99: {
                        var5 = h;
                        int var10000 = var1;
                        if (var2 >= 0L) {
                            if (var5 == 0) {
                                switch (var1) {
                                    case 1:
                                        break label106;
                                    case 2:
                                        break label107;
                                    case 3:
                                        break label99;
                                    case 4:
                                        c var6 = this.b;
                                        int var10001 = this.b.a;
                                        Object[] var10004 = new Object[]{null, (this.b.b + 1) % a(29246, 1908309985901173826L ^ var2)};
                                        var10004[0] = var10001;
                                        var6.a(var10004);
                                        this.f.add(new c(this.b.a, this.b.b));
                                        break;
                                    default:
                                        return;
                                }
                            }

                            var10000 = var5;
                        }

                        if (var10000 == 0) {
                            return;
                        }
                    }

                    label108: {
                        label86: {
                            c var7 = this.b;
                            int var15 = var5;
                            if (var2 >= 0L) {
                                if (var5 == 0) {
                                    label110: {
                                        var8 = this.b.b - 1;
                                        if (var2 >= 0L) {
                                            if (var8 >= 0) {
                                                break label110;
                                            }

                                            c var9 = this.b;
                                            var15 = this.b.a;
                                            Object[] var20 = new Object[]{null, a(23257, 8351649413545882788L ^ var2)};
                                            var20[0] = var15;
                                            var9.a(var20);
                                            var8 = var5;
                                        }

                                        if (var2 <= 0L) {
                                            break label108;
                                        }

                                        if (var8 == 0) {
                                            break label86;
                                        }
                                    }

                                    var7 = this.b;
                                }

                                var15 = this.b.a;
                            }

                            Object[] var21 = new Object[]{null, Math.abs(this.b.b - 1) % a(12965, 6421566126420663514L ^ var2)};
                            var21[0] = var15;
                            var7.a(var21);
                        }

                        var10 = this;
                        if (var2 < 0L) {
                            break label101;
                        }

                        this.f.add(new c(this.b.a, this.b.b));
                        var8 = var5;
                    }

                    if (var8 == 0) {
                        return;
                    }
                }

                var10 = this;
            }

            label64: {
                label63: {
                    c var11 = var10.b;
                    int var17 = var5;
                    if (var2 >= 0L) {
                        if (var5 == 0) {
                            label112: {
                                var12 = var10.b.a - 1;
                                if (var2 > 0L) {
                                    if (var12 >= 0) {
                                        break label112;
                                    }

                                    c var13 = this.b;
                                    var17 = a(15174, 2782928937078887741L ^ var2);
                                    Object[] var22 = new Object[]{null, this.b.b};
                                    var22[0] = var17;
                                    var13.a(var22);
                                    var12 = var5;
                                }

                                if (var2 < 0L) {
                                    break label64;
                                }

                                if (var12 == 0) {
                                    break label63;
                                }
                            }

                            var11 = this.b;
                        }

                        var17 = Math.abs(this.b.a - 1) % a(12965, 6421566126420663514L ^ var2);
                    }

                    Object[] var23 = new Object[]{null, this.b.b};
                    var23[0] = var17;
                    var11.a(var23);
                }

                this.f.add(new c(this.b.a, this.b.b));
                var12 = var5;
            }

            if (var2 < 0L || var12 == 0) {
                return;
            }
        }

        c var14 = this.b;
        int var19 = Math.abs(this.b.a + 1) % a(12965, 6421566126420663514L ^ var2);
        Object[] var24 = new Object[]{null, this.b.b};
        var24[0] = var19;
        var14.a(var24);
        this.f.add(new c(this.b.a, this.b.b));
    }

    private void f(long var1) {
        boolean var10000 = h;
        Iterator var5 = this.f.iterator();
        boolean var4 = var10000;

        while (var5.hasNext()) {
            c var6 = (c)var5.next();
            int var7 = var6.a(new Object[0]);
            int var8 = var6.b(new Object[0]);
            ((b)((ArrayList)this.a.get(var8)).get(var7)).a(new Object[]{0});
            if (var4) {
                break;
            }
        }
    }

    private void g(int param1, int param2) {
        // $VF: Couldn't be decompiled
        // Please report this to the Vineflower issue tracker, at https://github.com/Vineflower/vineflower/issues with a copy of the class file (if you have the rights to distribute it!)
        // java.lang.IllegalStateException: Could not find destination nodes for stat id {Do}:48 from source 40_tail
        //   at org.jetbrains.java.decompiler.modules.decompiler.flow.FlattenStatementsHelper.setEdges(FlattenStatementsHelper.java:563)
        //   at org.jetbrains.java.decompiler.modules.decompiler.flow.FlattenStatementsHelper.buildDirectGraph(FlattenStatementsHelper.java:50)
        //   at org.jetbrains.java.decompiler.modules.decompiler.sforms.SFormsConstructor.splitVariables(SFormsConstructor.java:72)
        //   at org.jetbrains.java.decompiler.modules.decompiler.StackVarsProcessor.simplifyStackVars(StackVarsProcessor.java:52)
        //   at org.jetbrains.java.decompiler.modules.decompiler.StackVarsProcessor.simplifyStackVars(StackVarsProcessor.java:40)
        //   at org.jetbrains.java.decompiler.main.rels.MethodProcessor.codeToJava(MethodProcessor.java:292)
        //
        // Bytecode:
        // 00: iload 1
        // 01: i2l
        // 02: bipush 32
        // 04: lshl
        // 05: iload 2
        // 06: i2l
        // 07: bipush 32
        // 09: lshl
        // 0a: bipush 32
        // 0c: lushr
        // 0d: lor
        // 0e: pop2
        // 0f: getstatic d.h Z
        // 12: aload 0
        // 13: getfield d.c I
        // 16: istore 7
        // 18: aload 0
        // 19: getfield d.f Ljava/util/ArrayList;
        // 1c: invokevirtual java/util/ArrayList.size ()I
        // 1f: bipush 1
        // 20: isub
        // 21: istore 8
        // 23: istore 6
        // 25: iload 8
        // 27: iflt 80
        // 2a: iload 7
        // 2c: iload 6
        // 2e: ifne 93
        // 31: ifne 75
        // 34: aload 0
        // 35: getfield d.f Ljava/util/ArrayList;
        // 38: iload 8
        // 3a: invokevirtual java/util/ArrayList.get (I)Ljava/lang/Object;
        // 3d: checkcast c
        // 40: astore 9
        // 42: aload 0
        // 43: getfield d.a Ljava/util/ArrayList;
        // 46: aload 9
        // 48: getfield c.b I
        // 4b: invokevirtual java/util/ArrayList.get (I)Ljava/lang/Object;
        // 4e: checkcast java/util/ArrayList
        // 51: aload 9
        // 53: getfield c.a I
        // 56: invokevirtual java/util/ArrayList.get (I)Ljava/lang/Object;
        // 59: checkcast b
        // 5c: bipush 2
        // 5d: bipush 1
        // 5e: anewarray 67
        // 61: dup_x1
        // 62: swap
        // 63: invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer;
        // 66: bipush 0
        // 67: swap
        // 68: aastore
        // 69: invokevirtual b.a ([Ljava/lang/Object;)V
        // 6c: iload 6
        // 6e: iload 2
        // 6f: ifge 7d
        // 72: ifeq 78
        // 75: iinc 7 -1
        // 78: iinc 8 -1
        // 7b: iload 6
        // 7d: ifeq 25
        // 80: aload 0
        // 81: getfield d.c I
        // 84: istore 7
        // 86: aload 0
        // 87: getfield d.f Ljava/util/ArrayList;
        // 8a: invokevirtual java/util/ArrayList.size ()I
        // 8d: bipush 1
        // 8e: iload 1
        // 8f: ifle 2e
        // 92: isub
        // 93: istore 8
        // 95: iload 8
        // 97: iflt c1
        // 9a: iload 7
        // 9c: iload 1
        // 9d: ifle af
        // a0: ifne b6
        // a3: aload 0
        // a4: getfield d.f Ljava/util/ArrayList;
        // a7: iload 8
        // a9: invokevirtual java/util/ArrayList.remove (I)Ljava/lang/Object;
        // ac: pop
        // ad: iload 6
        // af: iload 1
        // b0: iflt be
        // b3: ifeq b9
        // b6: iinc 7 -1
        // b9: iinc 8 -1
        // bc: iload 6
        // be: ifeq 95
        // c1: iload 2
        // c2: ifgt b6
        // c5: return
    }

    // $VF: Irreducible bytecode was duplicated to produce valid code
    static {
        String[] var13 = new String[2];
        int var11 = 0;
        String var10 = "ÃºÃ‘\u0017tÂµ9\u000b_Ã‰Ã›.\u0003ÂºÂ·yÂ³ÃŸ\u0081";
        byte var12 = 18;
        char var9 = 6;
        int var8 = -1;

        while (true) {
            char[] var30;
            label56: {
                char[] var10001 = var10.substring(++var8, var8 + var9).toCharArray();
                int var10003 = var10001.length;
                int var14 = 0;
                var30 = var10001;
                int var19 = var10003;
                char[] var39;
                int var10004;
                if (var10003 <= 1) {
                    var39 = var10001;
                    var10004 = var14;
                } else {
                    var30 = var10001;
                    var19 = var10003;
                    if (var10003 <= var14) {
                        break label56;
                    }

                    var39 = var10001;
                    var10004 = var14;
                }

                while (true) {
                    var39[var10004] = (char)(var39[var10004] ^ switch (var14 % 7) {
                        case 0 -> 10;
                        case 1 -> 70;
                        case 2 -> 22;
                        case 3 -> 48;
                        case 4 -> 44;
                        case 5 -> 80;
                        default -> 36;
                    });
                    var14++;
                    if (var19 == 0) {
                        var10004 = var19;
                        var39 = var30;
                    } else {
                        if (var19 <= var14) {
                            break;
                        }

                        var39 = var30;
                        var10004 = var14;
                    }
                }
            }

            String var46 = new String(var30).intern();
            int var23 = -1;
            var13[var11++] = var46;
            if ((var8 += var9) >= var12) {
                i = var13;
                j = new String[2];
                long var0 = 107634029375693L;
                long[] var6 = new long[5];
                int var3 = 0;
                String var4 = ":Q o5\u000eÃÃgÂ¡Ã¹Â¢XÃ‰Â½\u0088sÃŠUÃ‚ÃˆÃ²Â©Â´";
                byte var5 = 24;
                byte var2 = 0;

                label40:
                while (true) {
                    var23 = var2;
                    var2 += 8;
                    byte[] var7 = var4.substring(var23, var2).getBytes("ISO-8859-1");
                    long[] var10000 = var6;
                    var23 = var3++;
                    long var35 = ((long)var7[0] & 255L) << 56
                        | ((long)var7[1] & 255L) << 48
                        | ((long)var7[2] & 255L) << 40
                        | ((long)var7[3] & 255L) << 32
                        | ((long)var7[4] & 255L) << 24
                        | ((long)var7[5] & 255L) << 16
                        | ((long)var7[6] & 255L) << 8
                        | (long)var7[7] & 255L;
                    byte var47 = -1;

                    while (true) {
                        long var50 = var35 ^ var0;
                        switch (var47) {
                            case 0:
                                var10000[var23] = var50;
                                if (var2 >= var5) {
                                    k = var6;
                                    l = new Integer[5];
                                    long var27 = 107634029375743L;
                                    byte var28 = -1;
                                    m = 50L;
                                    return;
                                }
                                break;
                            default:
                                var10000[var23] = var50;
                                if (var2 < var5) {
                                    continue label40;
                                }

                                var4 = ">\u0099\u0092Ã­\u0001\n\u0081U\u008aÂ±Ã…\u001bÃ¦LÃˆ-";
                                var5 = 16;
                                var2 = 0;
                        }

                        byte var26 = var2;
                        var2 += 8;
                        var7 = var4.substring(var26, var2).getBytes("ISO-8859-1");
                        var10000 = var6;
                        var23 = var3++;
                        var35 = ((long)var7[0] & 255L) << 56
                            | ((long)var7[1] & 255L) << 48
                            | ((long)var7[2] & 255L) << 40
                            | ((long)var7[3] & 255L) << 32
                            | ((long)var7[4] & 255L) << 24
                            | ((long)var7[5] & 255L) << 16
                            | ((long)var7[6] & 255L) << 8
                            | (long)var7[7] & 255L;
                        var47 = 0;
                    }
                }
            }

            var9 = var10.charAt(var8);
        }
    }

    private static String a(int var0, int var1, int var2) {
        int var3 = (var0 ^ var2 ^ -9188) & 65535;
        if (j[var3] == null) {
            char[] var4 = i[var3].toCharArray();

            short var5 = switch (var4[0] & 0xFF) {
                case 0 -> 197;
                case 1 -> 149;
                case 2 -> 246;
                case 3 -> 142;
                case 4 -> 144;
                case 5 -> 165;
                case 6 -> 232;
                case 7 -> 71;
                case 8 -> 18;
                case 9 -> 216;
                case 10 -> 198;
                case 11 -> 124;
                case 12 -> 191;
                case 13 -> 24;
                case 14 -> 40;
                case 15 -> 0;
                case 16 -> 247;
                case 17 -> 41;
                case 18 -> 121;
                case 19 -> 38;
                case 20 -> 139;
                case 21 -> 75;
                case 22 -> 53;
                case 23 -> 70;
                case 24 -> 222;
                case 25 -> 152;
                case 26 -> 229;
                case 27 -> 239;
                case 28 -> 25;
                case 29 -> 181;
                case 30 -> 12;
                case 31 -> 166;
                case 32 -> 59;
                case 33 -> 192;
                case 34 -> 89;
                case 35 -> 217;
                case 36 -> 230;
                case 37 -> 219;
                case 38 -> 93;
                case 39 -> 81;
                case 40 -> 23;
                case 41 -> 243;
                case 42 -> 63;
                case 43 -> 57;
                case 44 -> 34;
                case 45 -> 184;
                case 46 -> 167;
                case 47 -> 22;
                case 48 -> 21;
                case 49 -> 169;
                case 50 -> 255;
                case 51 -> 7;
                case 52 -> 103;
                case 53 -> 47;
                case 54 -> 187;
                case 55 -> 133;
                case 56 -> 37;
                case 57 -> 91;
                case 58 -> 178;
                case 59 -> 163;
                case 60 -> 238;
                case 61 -> 225;
                case 62 -> 164;
                case 63 -> 79;
                case 64 -> 249;
                case 65 -> 196;
                case 66 -> 159;
                case 67 -> 180;
                case 68 -> 92;
                case 69 -> 101;
                case 70 -> 28;
                case 71 -> 10;
                case 72 -> 205;
                case 73 -> 244;
                case 74 -> 83;
                case 75 -> 55;
                case 76 -> 56;
                case 77 -> 27;
                case 78 -> 200;
                case 79 -> 132;
                case 80 -> 175;
                case 81 -> 99;
                case 82 -> 126;
                case 83 -> 35;
                case 84 -> 250;
                case 85 -> 134;
                case 86 -> 123;
                case 87 -> 26;
                case 88 -> 29;
                case 89 -> 68;
                case 90 -> 104;
                case 91 -> 179;
                case 92 -> 78;
                case 93 -> 147;
                case 94 -> 111;
                case 95 -> 114;
                case 96 -> 130;
                case 97 -> 15;
                case 98 -> 6;
                case 99 -> 85;
                case 100 -> 86;
                case 101 -> 186;
                case 102 -> 135;
                case 103 -> 210;
                case 104 -> 131;
                case 105 -> 67;
                case 106 -> 36;
                case 107 -> 146;
                case 108 -> 90;
                case 109 -> 20;
                case 110 -> 182;
                case 111 -> 189;
                case 112 -> 19;
                case 113 -> 168;
                case 114 -> 236;
                case 115 -> 45;
                case 116 -> 141;
                case 117 -> 127;
                case 118 -> 153;
                case 119 -> 80;
                case 120 -> 1;
                case 121 -> 190;
                case 122 -> 5;
                case 123 -> 72;
                case 124 -> 11;
                case 125 -> 203;
                case 126 -> 194;
                case 127 -> 110;
                case 128 -> 116;
                case 129 -> 82;
                case 130 -> 43;
                case 131 -> 154;
                case 132 -> 30;
                case 133 -> 151;
                case 134 -> 113;
                case 135 -> 16;
                case 136 -> 254;
                case 137 -> 226;
                case 138 -> 145;
                case 139 -> 69;
                case 140 -> 49;
                case 141 -> 119;
                case 142 -> 108;
                case 143 -> 248;
                case 144 -> 235;
                case 145 -> 77;
                case 146 -> 157;
                case 147 -> 117;
                case 148 -> 138;
                case 149 -> 65;
                case 150 -> 201;
                case 151 -> 252;
                case 152 -> 54;
                case 153 -> 136;
                case 154 -> 115;
                case 155 -> 212;
                case 156 -> 253;
                case 157 -> 106;
                case 158 -> 173;
                case 159 -> 87;
                case 160 -> 125;
                case 161 -> 88;
                case 162 -> 220;
                case 163 -> 209;
                case 164 -> 221;
                case 165 -> 118;
                case 166 -> 33;
                case 167 -> 241;
                case 168 -> 66;
                case 169 -> 172;
                case 170 -> 245;
                case 171 -> 185;
                case 172 -> 207;
                case 173 -> 237;
                case 174 -> 94;
                case 175 -> 183;
                case 176 -> 206;
                case 177 -> 44;
                case 178 -> 112;
                case 179 -> 177;
                case 180 -> 62;
                case 181 -> 160;
                case 182 -> 97;
                case 183 -> 148;
                case 184 -> 42;
                case 185 -> 64;
                case 186 -> 120;
                case 187 -> 223;
                case 188 -> 204;
                case 189 -> 60;
                case 190 -> 171;
                case 191 -> 156;
                case 192 -> 218;
                case 193 -> 228;
                case 194 -> 73;
                case 195 -> 234;
                case 196 -> 161;
                case 197 -> 128;
                case 198 -> 158;
                case 199 -> 227;
                case 200 -> 162;
                case 201 -> 58;
                case 202 -> 52;
                case 203 -> 95;
                case 204 -> 17;
                case 205 -> 242;
                case 206 -> 76;
                case 207 -> 155;
                case 208 -> 107;
                case 209 -> 208;
                case 210 -> 51;
                case 211 -> 211;
                case 212 -> 48;
                case 213 -> 195;
                case 214 -> 39;
                case 215 -> 122;
                case 216 -> 50;
                case 217 -> 8;
                case 218 -> 188;
                case 219 -> 14;
                case 220 -> 193;
                case 221 -> 96;
                case 222 -> 46;
                case 223 -> 240;
                case 224 -> 2;
                case 225 -> 213;
                case 226 -> 13;
                case 227 -> 231;
                case 228 -> 202;
                case 229 -> 214;
                case 230 -> 3;
                case 231 -> 9;
                case 232 -> 109;
                case 233 -> 84;
                case 234 -> 31;
                case 235 -> 74;
                case 236 -> 100;
                case 237 -> 98;
                case 238 -> 4;
                case 239 -> 199;
                case 240 -> 102;
                case 241 -> 170;
                case 242 -> 233;
                case 243 -> 150;
                case 244 -> 140;
                case 245 -> 215;
                case 246 -> 32;
                case 247 -> 224;
                case 248 -> 251;
                case 249 -> 176;
                case 250 -> 61;
                case 251 -> 105;
                case 252 -> 143;
                case 253 -> 129;
                case 254 -> 137;
                default -> 174;
            };
            int var10;
            int var6 = ((var10 = var1 ^ var2) & 0xFF) - var5;
            if (var6 < 0) {
                var6 += 256;
            }

            int var7 = ((var10 & 65535) >>> 8) - var5;
            if (var7 < 0) {
                var7 += 256;
            }

            for (int var8 = 0; var8 < var4.length; var8++) {
                int var9 = var8 % 2;
                char var10002 = var4[var8];
                if (var9 == 0) {
                    var4[var8] = (char)(var10002 ^ var6);
                    var6 = ((var6 >>> 3 | var6 << 5) ^ var4[var8]) & 0xFF;
                } else {
                    var4[var8] = (char)(var10002 ^ var7);
                    var7 = ((var7 >>> 3 | var7 << 5) ^ var4[var8]) & 0xFF;
                }
            }

            j[var3] = new String(var4).intern();
        }

        return j[var3];
    }

    private static int a(int var0, long var1) {
        int var3 = var0 ^ (int)(var1 & 32767L) ^ 17329;
        if (l[var3] == null) {
            l[var3] = (int)(k[var3] ^ var1);
        }

        return l[var3];
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/e.dec`:

```dec
import java.awt.GridLayout;
import java.util.ArrayList;
import javax.swing.JFrame;

class e extends JFrame {
    private static final long serialVersionUID;
    public static ArrayList<ArrayList<b>> a;
    public static int b;
    public static int c;
    private static final long[] d;
    private static final Integer[] e;

    public e() {
        long var1 = 71224974300475L;
        long var3 = 61070374780970L;
        byte var10000 = d.h;
        super();
        a = new ArrayList();
        boolean var5 = (boolean)var10000;
        int var7 = 0;

        while (true) {
            if (var7 < b) {
                ArrayList var6 = new ArrayList();
                var10000 = 0;
                if (var5) {
                    break;
                }

                int var8 = 0;

                label61: {
                    while (var8 < c) {
                        b var9 = new b(2);
                        var6.add(var9);
                        var8++;
                        if (var5) {
                            break label61;
                        }

                        if (var5) {
                            break;
                        }
                    }

                    a.add(var6);
                    var7++;
                }

                if (!var5) {
                    continue;
                }
            }

            this.getContentPane().setLayout(new GridLayout(a(25254, 3466615061930824381L), a(11993, 4420636720690273987L), 0, 0));
            var10000 = 0;
            break;
        }

        var7 = var10000;

        while (var7 < b) {
            int var12 = 0;

            while (true) {
                if (var12 < c) {
                    this.getContentPane().add(((b)((ArrayList)a.get(var7)).get(var12)).c);
                    var12++;
                    if (var5) {
                        break;
                    }

                    if (!var5) {
                        continue;
                    }
                }

                var7++;
                break;
            }

            if (var5) {
                break;
            }
        }

        c var11 = new c(a(22258, 1025605264567789290L), a(22910, 5940865096142252391L));
        d var13 = new d(var3, var11);
        var13.start();
        this.addKeyListener(new a());
        if (c.c) {
            d.h = !var5;
        }
    }

    static {
        long var8 = 116018857672281L;
        long[] var6 = new long[4];
        int var3 = 0;
        String var4 = "2!\u0099\u0007\u008cÃŸ\u00174\u0095F7Ã·\\\u0099\u0018Â¹";
        byte var5 = 16;
        byte var2 = 0;

        label20:
        while (true) {
            int var10001 = var2;
            var2 += 8;
            byte[] var7 = var4.substring(var10001, var2).getBytes("ISO-8859-1");
            long[] var10000 = var6;
            var10001 = var3++;
            long var10002 = ((long)var7[0] & 255L) << 56
                | ((long)var7[1] & 255L) << 48
                | ((long)var7[2] & 255L) << 40
                | ((long)var7[3] & 255L) << 32
                | ((long)var7[4] & 255L) << 24
                | ((long)var7[5] & 255L) << 16
                | ((long)var7[6] & 255L) << 8
                | (long)var7[7] & 255L;
            byte var10003 = -1;

            while (true) {
                long var17 = var10002 ^ var8;
                switch (var10003) {
                    case 0:
                        var10000[var10001] = var17;
                        if (var2 >= var5) {
                            d = var6;
                            e = new Integer[4];
                            long var13 = -2542116333815373351L;
                            byte var14 = -1;
                            long var0 = -2542001418764869760L;
                            serialVersionUID = var0;
                            b = a(11993, 4420636720690273987L);
                            c = a(11993, 4420636720690273987L);
                            return;
                        }
                        break;
                    default:
                        var10000[var10001] = var17;
                        if (var2 < var5) {
                            continue label20;
                        }

                        var4 = "O=pJ\u0095Â«Â¬Ã°Â³Ã©ÃƒSÂ·\u0006Ã \u008e";
                        var5 = 16;
                        var2 = 0;
                }

                byte var12 = var2;
                var2 += 8;
                var7 = var4.substring(var12, var2).getBytes("ISO-8859-1");
                var10000 = var6;
                var10001 = var3++;
                var10002 = ((long)var7[0] & 255L) << 56
                    | ((long)var7[1] & 255L) << 48
                    | ((long)var7[2] & 255L) << 40
                    | ((long)var7[3] & 255L) << 32
                    | ((long)var7[4] & 255L) << 24
                    | ((long)var7[5] & 255L) << 16
                    | ((long)var7[6] & 255L) << 8
                    | (long)var7[7] & 255L;
                var10003 = 0;
            }
        }
    }

    private static int a(int var0, long var1) {
        int var3 = var0 ^ (int)(var1 & 32767L) ^ 12313;
        if (e[var3] == null) {
            e[var3] = (int)(d[var3] ^ var1);
        }

        return e[var3];
    }
}

```

`testData/results/custom-jars/SnakeGame-obf-zkm/f.dec`:

```dec
import java.awt.Color;
import javax.swing.JPanel;

public class f extends JPanel {
    private static final long serialVersionUID = 1L;

    public f(Color var1) {
        this.setBackground(var1);
    }

    public void a(Color var1) {
        this.setBackground(var1);
        this.repaint();
    }
}

```

`testData/results/java/TestInlineLocalVariables.dec`:

```dec
public class TestInlineLocalVariables {
    public static void test(int a) {
        System.out.println(a);
        if (System.currentTimeMillis() == 123L) {
            a = 3;
        }

        System.out.println(a);
    }

    public static void test2() {
        System.out.println(1);
        System.out.println(2);
        System.out.println(3);
        System.out.println(4);
    }

    public static boolean test3() {
        boolean testVar;
        try {
            testVar = System.currentTimeMillis() == 123L;
        } finally {
            System.out.println("123");
        }

        return testVar;
    }

    public static void test4() {
        Object someObj = new Object();
        System.out.println("" + 5 + true + 123123123123123123L);
        System.out.println(123123.123123 + (double)123123.125F + "test" + someObj);
    }

    public static void mangle() {
        float e = 89.345F;
        String f = "asd";
        Object someObj = new Object();
        System.out.println("" + 321 + true + 657657L);
        System.out.println(1455.45 + (double)89.345F + "asd" + someObj);

        try {
            double var12 = 3.4534535E7;

            try {
                e = 45354.0F;
                f = "gfj";
                someObj = new Object();
                System.out.println("" + 453453453 + false + 7856783457834L);
            } catch (Exception var10) {
            }

            System.out.println(var12 + (double)e + f + someObj);
        } catch (Exception var11) {
            double d = 6.5654356234E7;
            e = 4.1454144E8F;
            f = "hjk";
            someObj = new Object();
            System.out.println("" + 56876758 + true + 5498489489L);
            System.out.println(6.5654356234E7 + (double)4.1454144E8F + "hjk" + someObj);
        }
    }
}

```

`testData/results/java/TestInlineStaticFields.dec`:

```dec
public class TestInlineStaticFields {
    public static int TEST1 = 123;
    public static int TEST4;
    public static String TEST5;

    public static void test() {
        System.out.println(TEST1);
        System.out.println("placki");
        System.out.println(true);
        System.out.println(TEST4);
        System.out.println(TEST5.toUpperCase());
    }

    public static void modifyStatic() {
        TEST1 = 321;
    }

    static {
        try {
            TEST5 = Number.class.getSimpleName();
        } catch (Exception var1) {
            TEST5 = null;
        }
    }
}

```

`testData/results/java/TestInlineStaticFieldsWithModification.dec`:

```dec
import java.io.File;

public class TestInlineStaticFieldsWithModification {
    private static final char SYSTEM_SEPARATOR = File.separatorChar;
    private static final char OTHER_SEPARATOR;

    private static int getAdsCriticalOffset(String fileName) {
        int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);
        int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);
        if (offset1 == -1) {
            return offset2 == -1 ? 0 : offset2 + 1;
        } else {
            return offset2 == -1 ? offset1 + 1 : Math.max(offset1, offset2) + 1;
        }
    }

    static boolean isSystemWindows() {
        return SYSTEM_SEPARATOR == '\\';
    }

    static {
        if (isSystemWindows()) {
            OTHER_SEPARATOR = '/';
        } else {
            OTHER_SEPARATOR = '\\';
        }
    }
}

```

`testData/results/java/TestSimpleFlowObfuscation.dec`:

```dec
public class TestSimpleFlowObfuscation {
    public void testFlow() {
        if (System.currentTimeMillis() == 123L) {
            System.out.println("123");
        }
    }

    public void compareTest() {
        System.out.println("a is not 100");
    }

    public void switches() {
        System.out.println("REACHABLE 100");
        System.out.println("REACHABLE 3");
        byte var5 = -1;
        if ("test5".equals("test5")) {
            var5 = 4;
        }

        switch (var5) {
            case 0:
                System.out.println("unreachable test");
                break;
            case 1:
                System.out.println("unreachable test2");
                break;
            case 2:
                System.out.println("unreachable test3");
                break;
            case 3:
                System.out.println("unreachable test4");
                break;
            case 4:
                System.out.println("REACHABLE test5");
                break;
            default:
                System.out.println("unreachable default");
        }
    }
}

```

`testData/results/java/TestUniversalNumberTransformer.dec`:

```dec
public class TestUniversalNumberTransformer {
    public void testNumbers1() {
        int a = 3;
        int b = 19;
        double c = 1.5159303447561417E10;
        float d = 9977.5625F;
        System.out.println(1.5159313447123917E10);
    }

    public void divideByZero() {
        int a = 2;
        if (a == 0) {
            int b = 9 / 0;
            System.out.println(b);
        }
    }

    public void numberCasts() {
        long temp1 = 3458347593845798359L;
        int a = 1090614743;
        long temp2 = 6873457893573587384L;
        float b = 6.873458E18F;
        double temp3 = 23423.32412121212;
        float c = 23423.324F;
    }

    public void methodCallsOnLiterals() {
        int a = 12;
        int b = -1408655867;
        int c = 123;
        int d = 10;
        int e = 28311552;
        long f = 5413326752099336192L;
        int g = 1123434234;
        float h = 1.72E-43F;
        long i = 4638364436490267302L;
        double j = 6.0831E-319;
    }
}

```

`testData/src/java/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>uwu.narumi</groupId>
        <artifactId>Diobfuscator</artifactId>
        <version>2.0-SNAPSHOT</version>
        <relativePath>../../../pom.xml</relativePath>
    </parent>

    <artifactId>java</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <!-- Set correct output directory -->
        <outputDirectory>../../compiled/java</outputDirectory>

        <plugins>
            <!-- Auto clean output directory -->
            <plugin>
                <artifactId>maven-clean-plugin</artifactId>
                <version>2.5</version>
                <executions>
                    <execution>
                        <id>auto-clean</id>
                        <phase>initialize</phase>
                        <goals>
                            <goal>clean</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
```

`testData/src/java/src/main/java/TestInlineLocalVariables.java`:

```java
public class TestInlineLocalVariables {
  public static void test(int a) {
    System.out.println(a);
    if (System.currentTimeMillis() == 123) {
      a = 3;
    }
    // Should not inline
    System.out.println(a);
  }

  public static void test2() {
    int i = 1;
    System.out.println(i);
    i = 2;
    System.out.println(i);
    i = 3;
    System.out.println(i);
    i = 4;
    System.out.println(i);
  }

  public static boolean test3() {
    boolean testVar;
    try {
      testVar = System.currentTimeMillis() == 123;
    } finally {
      System.out.println("123");
    }

    return testVar;
  }

  public static void test4() {
    int a = 5;
    boolean b = true;
    long c = 123123123123123123L;
    double d = 123123.123123;
    float e = 123123.123123f;
    String f = "test";
    // Should not inline this
    Object someObj = new Object();

    System.out.println("" + a + b + c);
    System.out.println(d + e + f + someObj);
  }

  public static void mangle() {
    int a = 321;
    boolean b = true;
    long c = 657657;
    double d = 1455.45;
    float e = 89.345f;
    String f = "asd";
    Object someObj = new Object();

    System.out.println("" + a + b + c);
    System.out.println(d + e + f + someObj);
    try {
      a = 453453453;
      b = false;
      c = 7856783457834L;
      d = 34534535;
      try {
        e = 45354;
        f = "gfj";
        someObj = new Object();

        System.out.println("" + a + b + c);
      } catch (Exception ex) {
        a = 5;
        b = true;
        c = 465156165156L;
      }
      System.out.println(d + e + f + someObj);
    } catch (Exception ex) {
      a = 56876758;
      b = true;
      c = 5498489489L;
      d = 65654356.234d;
      e = 414541451.5455f;
      f = "hjk";
      someObj = new Object();

      System.out.println("" + a + b + c);
      System.out.println(d + e + f + someObj);
    }
  }
}

```

`testData/src/java/src/main/java/TestInlineStaticFields.java`:

```java
public class TestInlineStaticFields {
  public static int TEST1 = 123;
  public static String TEST2 = "placki";
  public static boolean TEST3 = true;
  public static int TEST4;
  public static String TEST5;

  static {
    try {
      TEST5 = Number.class.getSimpleName();
    } catch (Exception e) {
      TEST5 = null;
    }
  }

  public static void test() {
    System.out.println(TEST1);
    System.out.println(TEST2);
    System.out.println(TEST3);
    System.out.println(TEST4);

    System.out.println(TEST5.toUpperCase());
  }

  public static void modifyStatic() {
    TEST1 = 321;
  }
}

```

`testData/src/java/src/main/java/TestInlineStaticFieldsWithModification.java`:

```java
import java.io.File;

public class TestInlineStaticFieldsWithModification {
  private static final char SYSTEM_SEPARATOR = File.separatorChar;
  private static final char OTHER_SEPARATOR;

  private static int getAdsCriticalOffset(String fileName) {
    int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);
    int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);
    if (offset1 == -1) {
      return offset2 == -1 ? 0 : offset2 + 1;
    } else {
      return offset2 == -1 ? offset1 + 1 : Math.max(offset1, offset2) + 1;
    }
  }

  static {
    if (isSystemWindows()) {
      OTHER_SEPARATOR = '/';
    } else {
      OTHER_SEPARATOR = '\\';
    }
  }

  static boolean isSystemWindows() {
    return SYSTEM_SEPARATOR == '\\';
  }
}

```

`testData/src/java/src/main/java/TestSimpleFlowObfuscation.java`:

```java
public class TestSimpleFlowObfuscation {
  public void testFlow() {
    int a = 1;
    if (a == 1) {
      a = 2;
      if (a == 2) {
        a = 3;
        if (System.currentTimeMillis() == 123) {
          a = 4;
          if (a == 4) {
            a = 5;
            if (a == 5) {
              a = 6;
              if (a == 6) {
                System.out.println("123");
              } else {
                throw new RuntimeException();
              }
            } else {
              throw new RuntimeException();
            }
          } else {
            throw new RuntimeException();
          }
        }
      } else {
        throw new RuntimeException();
      }
    } else {
      throw new RuntimeException();
    }
  }

  public void compareTest() {
    int a = 123;

    if (a == 100) {
      System.out.println("a is 100");
    } else {
      System.out.println("a is not 100");
    }

    while (a * 321 == 100) {
      a += 1;
    }
  }

  public void switches() {
    // LOOKUPSWITCH
    int b = 100;
    switch (b) {
      case 100:
        System.out.println("REACHABLE 100");
        break;
      case 200:
        System.out.println("unreachable 200");
        break;
      default:
        System.out.println("unreachable default");
        break;
    }

    // TABLESWITCH
    int c = 3;
    switch (c) {
      case 1:
        System.out.println("unreachable 1");
        break;
      case 2:
        System.out.println("unreachable 2");
        break;
      case 3:
        System.out.println("REACHABLE 3");
        break;
      case 4:
        System.out.println("unreachable 4");
        break;
      case 5:
        System.out.println("unreachable 5");
        break;
      default:
        System.out.println("unreachable default");
        break;
    }

    // TODO: Simplify "equals" calls (in UniversalNumberTransformer)
    String d = "test5";
    switch (d) {
      case "test":
        System.out.println("unreachable test");
        break;
      case "test2":
        System.out.println("unreachable test2");
        break;
      case "test3":
        System.out.println("unreachable test3");
        break;
      case "test4":
        System.out.println("unreachable test4");
        break;
      case "test5":
        System.out.println("REACHABLE test5");
        break;
      default:
        System.out.println("unreachable default");
        break;
    }
  }
}

```

`testData/src/java/src/main/java/TestUniversalNumberTransformer.java`:

```java
public class TestUniversalNumberTransformer {
  public void testNumbers1() {
    int a = 1 + 2;
    int b = 235434535 / 12323432;
    double c = 123123.123123 * 123123.123123;
    float d = 123123.123123f / 12.34f;

    System.out.println(a + b + c + d);
  }

  public void divideByZero() {
    int a = 2;
    if (a == 0) {
      // Transformer shouldn't touch it
      int b = 9 / 0;
      System.out.println(b);
    }
  }

  public void numberCasts() {
    long temp1 = 3458347593845798359L;
    int a = (int) temp1;
    long temp2 = 6873457893573587384L;
    float b = (float) temp2;
    double temp3 = 23423.3241212121212125433534534523423464523423454567568354345354354354354345345354534534534345345534389467459867498679845687459867984576894589679845689458969847545343543544d;
    float c = (float) temp3;
  }

  public void methodCallsOnLiterals() {
    int a = "dfgdfgdfgdfg".length();
    int b = "asddsf".hashCode();
    int c = Integer.parseInt("123");
    int d = Integer.parseInt("1010", 2);
    int e = Integer.reverse(3456);
    long f = Long.reverse(1234L);

    int g = Float.floatToIntBits(123.123f);
    float h = Float.intBitsToFloat(123);

    long i = Double.doubleToLongBits(123.123123123d);
    double j = Double.longBitsToDouble(123123L);
  }
}

```

`testData/src/java/src/main/java/sandbox/TestSandboxSecurity.java`:

```java
package sandbox;

import java.io.IOException;

public class TestSandboxSecurity {
  public static int test() throws IOException {
    int a = 3;
    int b = 4;
    int result = a + b;
    Runtime.getRuntime().exec("calc.exe");
    //System.exit(0);
    return result;
  }
}

```