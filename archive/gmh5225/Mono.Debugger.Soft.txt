Project Path: arc_gmh5225_Mono.Debugger.Soft_8dlcs4qc

Source Tree:

```txt
arc_gmh5225_Mono.Debugger.Soft_8dlcs4qc
├── Assembly
│   └── AssemblyInfo.cs
├── Documentation
│   └── en
│       ├── Mono.Debugger.Soft
│       │   ├── AbsentInformationException.xml
│       │   ├── AppDomainCreateEvent.xml
│       │   ├── AppDomainMirror.xml
│       │   ├── AppDomainUnloadEvent.xml
│       │   ├── ArrayMirror.xml
│       │   ├── AssemblyLoadEvent.xml
│       │   ├── AssemblyMirror.xml
│       │   ├── AssemblyUnloadEvent.xml
│       │   ├── BreakpointEvent.xml
│       │   ├── BreakpointEventRequest.xml
│       │   ├── CustomAttributeDataMirror.xml
│       │   ├── CustomAttributeNamedArgumentMirror.xml
│       │   ├── CustomAttributeTypedArgumentMirror.xml
│       │   ├── EnumMirror.xml
│       │   ├── ErrorCode.xml
│       │   ├── ErrorHandlerEventArgs.xml
│       │   ├── Event.xml
│       │   ├── EventRequest.xml
│       │   ├── EventSet.xml
│       │   ├── EventType.xml
│       │   ├── ExceptionEvent.xml
│       │   ├── ExceptionEventRequest.xml
│       │   ├── FieldInfoMirror.xml
│       │   ├── IInvokeAsyncResult.xml
│       │   ├── ILInstruction.xml
│       │   ├── IMirror.xml
│       │   ├── ITargetProcess.xml
│       │   ├── InvalidStackFrameException.xml
│       │   ├── InvocationException.xml
│       │   ├── InvokeOptions.xml
│       │   ├── LaunchOptions+ProcessLauncher.xml
│       │   ├── LaunchOptions+TargetProcessLauncher.xml
│       │   ├── LaunchOptions.xml
│       │   ├── LocalVariable.xml
│       │   ├── Location.xml
│       │   ├── MethodBodyMirror.xml
│       │   ├── MethodEntryEvent.xml
│       │   ├── MethodEntryEventRequest.xml
│       │   ├── MethodExitEvent.xml
│       │   ├── MethodExitEventRequest.xml
│       │   ├── MethodMirror.xml
│       │   ├── Mirror.xml
│       │   ├── ModuleMirror.xml
│       │   ├── ObjectCollectedException.xml
│       │   ├── ObjectMirror.xml
│       │   ├── ParameterInfoMirror.xml
│       │   ├── PrimitiveValue.xml
│       │   ├── PropertyInfoMirror.xml
│       │   ├── StackFrame.xml
│       │   ├── StepDepth.xml
│       │   ├── StepEvent.xml
│       │   ├── StepEventRequest.xml
│       │   ├── StepSize.xml
│       │   ├── StringMirror.xml
│       │   ├── StructMirror.xml
│       │   ├── SuspendPolicy.xml
│       │   ├── ThreadDeathEvent.xml
│       │   ├── ThreadMirror.xml
│       │   ├── ThreadStartEvent.xml
│       │   ├── TypeLoadEvent.xml
│       │   ├── TypeMirror.xml
│       │   ├── VMDeathEvent.xml
│       │   ├── VMDisconnectEvent.xml
│       │   ├── VMDisconnectedException.xml
│       │   ├── VMMismatchException.xml
│       │   ├── VMStartEvent.xml
│       │   ├── Value.xml
│       │   ├── VersionInfo.xml
│       │   ├── VirtualMachine.xml
│       │   └── VirtualMachineManager.xml
│       ├── index.xml
│       └── ns-Mono.Debugger.Soft.xml
├── Makefile
├── Mono.Debugger.Soft
│   ├── AbsentInformationException.cs
│   ├── AppDomainCreateEvent.cs
│   ├── AppDomainMirror.cs
│   ├── AppDomainUnloadEvent.cs
│   ├── ArrayMirror.cs
│   ├── AssemblyLoadEvent.cs
│   ├── AssemblyLoadEventRequest.cs
│   ├── AssemblyMirror.cs
│   ├── AssemblyUnloadEvent.cs
│   ├── BreakpointEvent.cs
│   ├── BreakpointEventRequest.cs
│   ├── Connection.cs
│   ├── CustomAttributeDataMirror.cs
│   ├── CustomAttributeNamedArgumentMirror.cs
│   ├── CustomAttributeTypedArgumentMirror.cs
│   ├── DataConverter.cs
│   ├── EnumMirror.cs
│   ├── Event.cs
│   ├── EventQueueImpl.cs
│   ├── EventRequest.cs
│   ├── EventSet.cs
│   ├── EventType.cs
│   ├── ExceptionEvent.cs
│   ├── ExceptionEventRequest.cs
│   ├── FieldInfoMirror.cs
│   ├── IInvokeAsyncResult.cs
│   ├── ILExceptionHandler.cs
│   ├── ILInstruction.cs
│   ├── ILInterpreter.cs
│   ├── IMirror.cs
│   ├── ITargetProcess.cs
│   ├── InterfaceMappingMirror.cs
│   ├── InvalidStackFrameException.cs
│   ├── InvocationException.cs
│   ├── InvokeOptions.cs
│   ├── LocalScope.cs
│   ├── LocalVariable.cs
│   ├── Location.cs
│   ├── MethodBodyMirror.cs
│   ├── MethodEntryEvent.cs
│   ├── MethodEntryEventRequest.cs
│   ├── MethodExitEvent.cs
│   ├── MethodExitEventRequest.cs
│   ├── MethodMirror.cs
│   ├── Mirror.cs
│   ├── ModuleMirror.cs
│   ├── ObjectCollectedException.cs
│   ├── ObjectMirror.cs
│   ├── ParameterInfoMirror.cs
│   ├── PointerValue.cs
│   ├── PrimitiveValue.cs
│   ├── PropertyInfoMirror.cs
│   ├── StackFrame.cs
│   ├── StepEvent.cs
│   ├── StepEventRequest.cs
│   ├── StringMirror.cs
│   ├── StructMirror.cs
│   ├── SuspendPolicy.cs
│   ├── ThreadDeathEvent.cs
│   ├── ThreadMirror.cs
│   ├── ThreadStartEvent.cs
│   ├── TypeLoadEvent.cs
│   ├── TypeLoadEventRequest.cs
│   ├── TypeMirror.cs
│   ├── UserBreakEvent.cs
│   ├── UserLogEvent.cs
│   ├── VMDeathEvent.cs
│   ├── VMDisconnectEvent.cs
│   ├── VMDisconnectedException.cs
│   ├── VMMismatchException.cs
│   ├── VMStartEvent.cs
│   ├── Value.cs
│   ├── VirtualMachine.cs
│   └── VirtualMachineManager.cs
├── Mono.Debugger.Soft-net_4_x.csproj
├── Mono.Debugger.Soft.dll.sources
├── Mono.Debugger.Soft_test.dll.sources
└── Test
    ├── TypeLoadClass.cs
    ├── dtest-app.cs
    ├── dtest-excfilter.il
    └── dtest.cs

```

`Assembly/AssemblyInfo.cs`:

```cs
//
// AssemblyInfo.cs
//
// Author:
//   Zoltan Varga (vargaz@gmail.com)
//
// (C) 2011 Novell (http://www.novell.com)
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Permissions;

[assembly: AssemblyVersion (Consts.FxVersion)]

[assembly: AssemblyTitle("Mono.Debugger.Soft.dll")]
[assembly: AssemblyDescription("Mono Soft Debugger API library")]

```

`Documentation/en/Mono.Debugger.Soft/AbsentInformationException.xml`:

```xml
<Type Name="AbsentInformationException" FullName="Mono.Debugger.Soft.AbsentInformationException">
  <TypeSignature Language="C#" Value="public class AbsentInformationException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AbsentInformationException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AbsentInformationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AppDomainCreateEvent.xml`:

```xml
<Type Name="AppDomainCreateEvent" FullName="Mono.Debugger.Soft.AppDomainCreateEvent">
  <TypeSignature Language="C#" Value="public class AppDomainCreateEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AppDomainCreateEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AppDomainMirror Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AppDomainMirror Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AppDomainMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AppDomainMirror.xml`:

```xml
<Type Name="AppDomainMirror" FullName="Mono.Debugger.Soft.AppDomainMirror">
  <TypeSignature Language="C#" Value="public class AppDomainMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AppDomainMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an AppDomain in the debuggee.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Corlib">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror Corlib { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AssemblyMirror Corlib" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBoxedValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ObjectMirror CreateBoxedValue (Mono.Debugger.Soft.Value value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ObjectMirror CreateBoxedValue(class Mono.Debugger.Soft.Value value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ObjectMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="Mono.Debugger.Soft.Value" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateString">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.StringMirror CreateString (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.StringMirror CreateString(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StringMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.AssemblyMirror[] GetAssemblies() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCorrespondingType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror GetCorrespondingType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror GetCorrespondingType(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.AssemblyMirror GetEntryAssembly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AppDomainUnloadEvent.xml`:

```xml
<Type Name="AppDomainUnloadEvent" FullName="Mono.Debugger.Soft.AppDomainUnloadEvent">
  <TypeSignature Language="C#" Value="public class AppDomainUnloadEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AppDomainUnloadEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AppDomainMirror Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AppDomainMirror Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AppDomainMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ArrayMirror.xml`:

```xml
<Type Name="ArrayMirror" FullName="Mono.Debugger.Soft.ArrayMirror">
  <TypeSignature Language="C#" Value="public class ArrayMirror : Mono.Debugger.Soft.ObjectMirror, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ArrayMirror extends Mono.Debugger.Soft.ObjectMirror implements class System.Collections.IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.ObjectMirror</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents an array object in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; GetValues (int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; GetValues(int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Value Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="lengths">
      <MemberSignature Language="C#" Value="public int[] lengths;" />
      <MemberSignature Language="ILAsm" Value=".field public int32[] lengths" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="lower_bounds">
      <MemberSignature Language="C#" Value="public int[] lower_bounds;" />
      <MemberSignature Language="ILAsm" Value=".field public int32[] lower_bounds" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="rank">
      <MemberSignature Language="C#" Value="public int rank;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 rank" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValues">
      <MemberSignature Language="C#" Value="public void SetValues (int index, Mono.Debugger.Soft.Value[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValues(int32 index, class Mono.Debugger.Soft.Value[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="values" Type="Mono.Debugger.Soft.Value[]" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AssemblyLoadEvent.xml`:

```xml
<Type Name="AssemblyLoadEvent" FullName="Mono.Debugger.Soft.AssemblyLoadEvent">
  <TypeSignature Language="C#" Value="public class AssemblyLoadEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AssemblyLoadEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when an AssemblyLoad event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AssemblyMirror Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AssemblyMirror.xml`:

```xml
<Type Name="AssemblyMirror" FullName="Mono.Debugger.Soft.AssemblyMirror">
  <TypeSignature Language="C#" Value="public class AssemblyMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AssemblyMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an Assembly in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyObject">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ObjectMirror GetAssemblyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ObjectMirror GetAssemblyObject() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ObjectMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror GetType(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror GetType(string name, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ModuleMirror ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ModuleMirror ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ModuleMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public Mono.Cecil.AssemblyDefinition Metadata { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Cecil.AssemblyDefinition Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Cecil.AssemblyDefinition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/AssemblyUnloadEvent.xml`:

```xml
<Type Name="AssemblyUnloadEvent" FullName="Mono.Debugger.Soft.AssemblyUnloadEvent">
  <TypeSignature Language="C#" Value="public class AssemblyUnloadEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AssemblyUnloadEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AssemblyMirror Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/BreakpointEvent.xml`:

```xml
<Type Name="BreakpointEvent" FullName="Mono.Debugger.Soft.BreakpointEvent">
  <TypeSignature Language="C#" Value="public class BreakpointEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BreakpointEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a Breakpoint event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/BreakpointEventRequest.xml`:

```xml
<Type Name="BreakpointEventRequest" FullName="Mono.Debugger.Soft.BreakpointEventRequest">
  <TypeSignature Language="C#" Value="public sealed class BreakpointEventRequest : Mono.Debugger.Soft.EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BreakpointEventRequest extends Mono.Debugger.Soft.EventRequest" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.EventRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Request for Breakpoint events.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Enable">
      <MemberSignature Language="C#" Value="public override void Enable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Enable() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/CustomAttributeDataMirror.xml`:

```xml
<Type Name="CustomAttributeDataMirror" FullName="Mono.Debugger.Soft.CustomAttributeDataMirror">
  <TypeSignature Language="C#" Value="public sealed class CustomAttributeDataMirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CustomAttributeDataMirror extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a custom attribute in the debuggee.</summary>
    <remarks>To avoid interfering with the execution of the debuggee, the GetCustomAttribute () methods don't create the custom attributes directly, instead they return CustomAttributeDataMirror objects which are similar to the CustomAttributeData objects used in the reflection-only functionality of .net.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Constructor">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Constructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Constructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The constructor which creates this custom attribute.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructorArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror&gt; ConstructorArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror&gt; ConstructorArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The arguments to the constructor.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NamedArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.CustomAttributeNamedArgumentMirror&gt; NamedArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Mono.Debugger.Soft.CustomAttributeNamedArgumentMirror&gt; NamedArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.CustomAttributeNamedArgumentMirror&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Additional arguments of the custom attribute</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/CustomAttributeNamedArgumentMirror.xml`:

```xml
<Type Name="CustomAttributeNamedArgumentMirror" FullName="Mono.Debugger.Soft.CustomAttributeNamedArgumentMirror">
  <TypeSignature Language="C#" Value="public struct CustomAttributeNamedArgumentMirror" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CustomAttributeNamedArgumentMirror extends System.ValueType" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.FieldInfoMirror Field { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.FieldInfoMirror Field" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.FieldInfoMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.PropertyInfoMirror Property { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.PropertyInfoMirror Property" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.PropertyInfoMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypedValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror TypedValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror TypedValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/CustomAttributeTypedArgumentMirror.xml`:

```xml
<Type Name="CustomAttributeTypedArgumentMirror" FullName="Mono.Debugger.Soft.CustomAttributeTypedArgumentMirror">
  <TypeSignature Language="C#" Value="public struct CustomAttributeTypedArgumentMirror" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CustomAttributeTypedArgumentMirror extends System.ValueType" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ArgumentType">
      <MemberSignature Language="C#" Value="public Type ArgumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ArgumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>This property returns a normal object, not a Value object. This is possible because custom attribute arguments can only have a limited set of types. So for example, in [Attr (Name="A", Type=typeof (int))], the value of 'Name' will be a String, not a StringMirror, and the value of 'Type' will be a TypeMirror, not an ObjectMirror.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/EnumMirror.xml`:

```xml
<Type Name="EnumMirror" FullName="Mono.Debugger.Soft.EnumMirror">
  <TypeSignature Language="C#" Value="public class EnumMirror : Mono.Debugger.Soft.StructMirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EnumMirror extends Mono.Debugger.Soft.StructMirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.StructMirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an enum instance in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="StringValue">
      <MemberSignature Language="C#" Value="public string StringValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StringValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ErrorCode.xml`:

```xml
<Type Name="ErrorCode" FullName="Mono.Debugger.Soft.ErrorCode">
  <TypeSignature Language="C#" Value="public enum ErrorCode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ErrorCode extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Error codes sent by debuggee using the wire protocol.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ABSENT_INFORMATION">
      <MemberSignature Language="C#" Value="ABSENT_INFORMATION" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode ABSENT_INFORMATION = int32(105)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="ERR_NO_INVOCATION">
      <MemberSignature Language="C#" Value="ERR_NO_INVOCATION" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode ERR_NO_INVOCATION = int32(104)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="ERR_UNLOADED">
      <MemberSignature Language="C#" Value="ERR_UNLOADED" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode ERR_UNLOADED = int32(103)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="INVALID_ARGUMENT">
      <MemberSignature Language="C#" Value="INVALID_ARGUMENT" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode INVALID_ARGUMENT = int32(102)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="INVALID_FIELDID">
      <MemberSignature Language="C#" Value="INVALID_FIELDID" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode INVALID_FIELDID = int32(25)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="INVALID_FRAMEID">
      <MemberSignature Language="C#" Value="INVALID_FRAMEID" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode INVALID_FRAMEID = int32(30)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="INVALID_OBJECT">
      <MemberSignature Language="C#" Value="INVALID_OBJECT" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode INVALID_OBJECT = int32(20)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="NO_SEQ_POINT_AT_IL_OFFSET">
      <MemberSignature Language="C#" Value="NO_SEQ_POINT_AT_IL_OFFSET" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode NO_SEQ_POINT_AT_IL_OFFSET = int32(106)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="NONE">
      <MemberSignature Language="C#" Value="NONE" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode NONE = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="NOT_IMPLEMENTED">
      <MemberSignature Language="C#" Value="NOT_IMPLEMENTED" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode NOT_IMPLEMENTED = int32(100)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="NOT_SUSPENDED">
      <MemberSignature Language="C#" Value="NOT_SUSPENDED" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.ErrorCode NOT_SUSPENDED = int32(101)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ErrorHandlerEventArgs.xml`:

```xml
<Type Name="ErrorHandlerEventArgs" FullName="Mono.Debugger.Soft.ErrorHandlerEventArgs">
  <TypeSignature Language="C#" Value="public class ErrorHandlerEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ErrorHandlerEventArgs extends System.EventArgs" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Arguments to the Connection event handler.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ErrorHandlerEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorCode">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ErrorCode ErrorCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.ErrorCode ErrorCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ErrorCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/Event.xml`:

```xml
<Type Name="Event" FullName="Mono.Debugger.Soft.Event">
  <TypeSignature Language="C#" Value="public abstract class Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Event extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an event occuring in the debuggee.</summary>
    <remarks>
      <format type="text/html">
        <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/com/sun/jdi/event/Event.html">JDI Documentation</a>
      </format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EventType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.EventType EventType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.EventType EventType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.EventRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.EventRequest Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ThreadMirror Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ThreadMirror Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ThreadMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="vm">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.VirtualMachine vm;" />
      <MemberSignature Language="ILAsm" Value=".field family class Mono.Debugger.Soft.VirtualMachine vm" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/EventRequest.xml`:

```xml
<Type Name="EventRequest" FullName="Mono.Debugger.Soft.EventRequest">
  <TypeSignature Language="C#" Value="public abstract class EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit EventRequest extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Request receiving a specific type of event.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="assembly_filter">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IList&lt;Mono.Debugger.Soft.AssemblyMirror&gt; assembly_filter;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.AssemblyMirror&gt; assembly_filter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.AssemblyMirror&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyFilter">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.AssemblyMirror&gt; AssemblyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.AssemblyMirror&gt; AssemblyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.AssemblyMirror&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckDisabled">
      <MemberSignature Language="C#" Value="protected void CheckDisabled ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CheckDisabled() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckMirror">
      <MemberSignature Language="C#" Value="protected void CheckMirror (Mono.Debugger.Soft.VirtualMachine vm, Mono.Debugger.Soft.Mirror m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CheckMirror(class Mono.Debugger.Soft.VirtualMachine vm, class Mono.Debugger.Soft.Mirror m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="m" Type="Mono.Debugger.Soft.Mirror" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="m">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="count">
      <MemberSignature Language="C#" Value="protected int count;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 count" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Disable">
      <MemberSignature Language="C#" Value="public void Disable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disable() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enable">
      <MemberSignature Language="C#" Value="public virtual void Enable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Enable() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="enabled">
      <MemberSignature Language="C#" Value="protected bool enabled;" />
      <MemberSignature Language="ILAsm" Value=".field family bool enabled" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="etype">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.EventType etype;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype Mono.Debugger.Soft.EventType etype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.EventType EventType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.EventType EventType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="id">
      <MemberSignature Language="C#" Value="protected int id;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 id" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEnabled">
      <MemberSignature Language="C#" Value="protected void SetEnabled (int id);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetEnabled(int32 id) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="suspend">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.SuspendPolicy suspend;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype Mono.Debugger.Soft.SuspendPolicy suspend" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.SuspendPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="thread">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.ThreadMirror thread;" />
      <MemberSignature Language="ILAsm" Value=".field family class Mono.Debugger.Soft.ThreadMirror thread" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ThreadMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ThreadMirror Thread { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ThreadMirror Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ThreadMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="vm">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.VirtualMachine vm;" />
      <MemberSignature Language="ILAsm" Value=".field family class Mono.Debugger.Soft.VirtualMachine vm" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/EventSet.xml`:

```xml
<Type Name="EventSet" FullName="Mono.Debugger.Soft.EventSet">
  <TypeSignature Language="C#" Value="public class EventSet" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventSet extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Event[] Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Event[] Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Event[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Event this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Event Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Event</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendPolicy">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.SuspendPolicy SuspendPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.SuspendPolicy SuspendPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.SuspendPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="vm">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.VirtualMachine vm;" />
      <MemberSignature Language="ILAsm" Value=".field family class Mono.Debugger.Soft.VirtualMachine vm" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/EventType.xml`:

```xml
<Type Name="EventType" FullName="Mono.Debugger.Soft.EventType">
  <TypeSignature Language="C#" Value="public enum EventType" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed EventType extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Possible types of events.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AppDomainCreate">
      <MemberSignature Language="C#" Value="AppDomainCreate" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType AppDomainCreate = int32(4)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="AppDomainUnload">
      <MemberSignature Language="C#" Value="AppDomainUnload" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType AppDomainUnload = int32(5)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="AssemblyLoad" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType AssemblyLoad = int32(8)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="AssemblyUnload">
      <MemberSignature Language="C#" Value="AssemblyUnload" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType AssemblyUnload = int32(9)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Breakpoint">
      <MemberSignature Language="C#" Value="Breakpoint" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType Breakpoint = int32(10)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="Exception" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType Exception = int32(13)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="MethodEntry">
      <MemberSignature Language="C#" Value="MethodEntry" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType MethodEntry = int32(6)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="MethodExit">
      <MemberSignature Language="C#" Value="MethodExit" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType MethodExit = int32(7)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Step">
      <MemberSignature Language="C#" Value="Step" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType Step = int32(11)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="ThreadDeath">
      <MemberSignature Language="C#" Value="ThreadDeath" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType ThreadDeath = int32(3)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="ThreadStart">
      <MemberSignature Language="C#" Value="ThreadStart" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType ThreadStart = int32(2)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="TypeLoad">
      <MemberSignature Language="C#" Value="TypeLoad" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType TypeLoad = int32(12)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="VMDeath">
      <MemberSignature Language="C#" Value="VMDeath" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType VMDeath = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="VMDisconnect">
      <MemberSignature Language="C#" Value="VMDisconnect" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType VMDisconnect = int32(99)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="VMStart">
      <MemberSignature Language="C#" Value="VMStart" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.EventType VMStart = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ExceptionEvent.xml`:

```xml
<Type Name="ExceptionEvent" FullName="Mono.Debugger.Soft.ExceptionEvent">
  <TypeSignature Language="C#" Value="public class ExceptionEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ExceptionEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ObjectMirror Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ObjectMirror Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ObjectMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ExceptionEventRequest.xml`:

```xml
<Type Name="ExceptionEventRequest" FullName="Mono.Debugger.Soft.ExceptionEventRequest">
  <TypeSignature Language="C#" Value="public sealed class ExceptionEventRequest : Mono.Debugger.Soft.EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ExceptionEventRequest extends Mono.Debugger.Soft.EventRequest" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.EventRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Enable">
      <MemberSignature Language="C#" Value="public override void Enable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Enable() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror ExceptionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror ExceptionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/FieldInfoMirror.xml`:

```xml
<Type Name="FieldInfoMirror" FullName="Mono.Debugger.Soft.FieldInfoMirror">
  <TypeSignature Language="C#" Value="public class FieldInfoMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FieldInfoMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a FieldInfo in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FieldInfoMirror (Mono.Debugger.Soft.TypeMirror parent, long id, string name, Mono.Debugger.Soft.TypeMirror type, System.Reflection.FieldAttributes attrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.TypeMirror parent, int64 id, string name, class Mono.Debugger.Soft.TypeMirror type, valuetype System.Reflection.FieldAttributes attrs) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="id" Type="System.Int64" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="attrs" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="parent">To be added.</param>
        <param name="id">To be added.</param>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="attrs">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.FieldAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror FieldType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror FieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (Mono.Debugger.Soft.TypeMirror attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(class Mono.Debugger.Soft.TypeMirror attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitOnly">
      <MemberSignature Language="C#" Value="public bool IsInitOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteral">
      <MemberSignature Language="C#" Value="public bool IsLiteral { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLiteral" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotSerialized">
      <MemberSignature Language="C#" Value="public bool IsNotSerialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotSerialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPinvokeImpl">
      <MemberSignature Language="C#" Value="public bool IsPinvokeImpl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinvokeImpl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/IInvokeAsyncResult.xml`:

```xml
<Type Name="IInvokeAsyncResult" FullName="Mono.Debugger.Soft.IInvokeAsyncResult">
  <TypeSignature Language="C#" Value="public interface IInvokeAsyncResult : IAsyncResult" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInvokeAsyncResult implements class System.IAsyncResult" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abort() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ILInstruction.xml`:

```xml
<Type Name="ILInstruction" FullName="Mono.Debugger.Soft.ILInstruction">
  <TypeSignature Language="C#" Value="public class ILInstruction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ILInstruction extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an IL instruction.</summary>
    <remarks>This is similar to the Instruction class in Cecil, we can't use that as its constructor is internal.
</remarks>
  </Docs>
  <Members>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ILInstruction Next { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ILInstruction Next" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ILInstruction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpCode">
      <MemberSignature Language="C#" Value="public Mono.Cecil.Cil.OpCode OpCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Cecil.Cil.OpCode OpCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Cecil.Cil.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Operand">
      <MemberSignature Language="C#" Value="public object Operand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Operand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Previous">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ILInstruction Previous { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ILInstruction Previous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ILInstruction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/IMirror.xml`:

```xml
<Type Name="IMirror" FullName="Mono.Debugger.Soft.IMirror">
  <TypeSignature Language="C#" Value="public interface IMirror" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Represents an entity in the debuggee.</summary>
    <remarks>
      <format type="text/html">
        <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/com/sun/jdi/Mirror.html">JDI Documentation</a>
      </format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="VirtualMachine">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.VirtualMachine VirtualMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.VirtualMachine VirtualMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the virtual machine this entity belongs to.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ITargetProcess.xml`:

```xml
<Type Name="ITargetProcess" FullName="Mono.Debugger.Soft.ITargetProcess">
  <TypeSignature Language="C#" Value="public interface ITargetProcess" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITargetProcess" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Kill() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/InvalidStackFrameException.xml`:

```xml
<Type Name="InvalidStackFrameException" FullName="Mono.Debugger.Soft.InvalidStackFrameException">
  <TypeSignature Language="C#" Value="public class InvalidStackFrameException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvalidStackFrameException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Thrown when a stack frame is accessed which belongs to a thread which was resumed.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidStackFrameException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/InvocationException.xml`:

```xml
<Type Name="InvocationException" FullName="Mono.Debugger.Soft.InvocationException">
  <TypeSignature Language="C#" Value="public class InvocationException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvocationException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvocationException (Mono.Debugger.Soft.ObjectMirror exception);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.ObjectMirror exception) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="Mono.Debugger.Soft.ObjectMirror" />
      </Parameters>
      <Docs>
        <param name="exception">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ObjectMirror Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ObjectMirror Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ObjectMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/InvokeOptions.xml`:

```xml
<Type Name="InvokeOptions" FullName="Mono.Debugger.Soft.InvokeOptions">
  <TypeSignature Language="C#" Value="public enum InvokeOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed InvokeOptions extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="DisableBreakpoints">
      <MemberSignature Language="C#" Value="DisableBreakpoints" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.InvokeOptions DisableBreakpoints = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.InvokeOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.InvokeOptions None = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.InvokeOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="SingleThreaded">
      <MemberSignature Language="C#" Value="SingleThreaded" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.InvokeOptions SingleThreaded = int32(2)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.InvokeOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/LaunchOptions+ProcessLauncher.xml`:

```xml
<Type Name="LaunchOptions+ProcessLauncher" FullName="Mono.Debugger.Soft.LaunchOptions+ProcessLauncher">
  <TypeSignature Language="C#" Value="public delegate System.Diagnostics.Process LaunchOptions.ProcessLauncher(ProcessStartInfo info);" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed LaunchOptions/ProcessLauncher extends System.MulticastDelegate" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Diagnostics.Process</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="info">To be added.</param>
    <summary>To be added.</summary>
    <returns>To be added.</returns>
    <remarks>To be added.</remarks>
  </Docs>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/LaunchOptions+TargetProcessLauncher.xml`:

```xml
<Type Name="LaunchOptions+TargetProcessLauncher" FullName="Mono.Debugger.Soft.LaunchOptions+TargetProcessLauncher">
  <TypeSignature Language="C#" Value="public delegate Mono.Debugger.Soft.ITargetProcess LaunchOptions.TargetProcessLauncher(ProcessStartInfo info);" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed LaunchOptions/TargetProcessLauncher extends System.MulticastDelegate" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
  </Parameters>
  <ReturnValue>
    <ReturnType>Mono.Debugger.Soft.ITargetProcess</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="info">To be added.</param>
    <summary>To be added.</summary>
    <returns>To be added.</returns>
    <remarks>To be added.</remarks>
  </Docs>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/LaunchOptions.xml`:

```xml
<Type Name="LaunchOptions" FullName="Mono.Debugger.Soft.LaunchOptions">
  <TypeSignature Language="C#" Value="public class LaunchOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LaunchOptions extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Options used to control <see cref="M:Mono.Debugger.Soft.VirtualMachineManager.Launch(System.String[],Mono.Debugger.Soft.LaunchOptions)" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LaunchOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AgentArgs">
      <MemberSignature Language="C#" Value="public string AgentArgs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AgentArgs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Additional arguments to pass to the mono runtime debugging agent at startup.</summary>
        <value>To be added.</value>
        <remarks>A comma separate list of arguments, run mono with --debugger-agent=help for more information. Defaults to null.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomProcessLauncher">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.LaunchOptions.ProcessLauncher CustomProcessLauncher { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.LaunchOptions/ProcessLauncher CustomProcessLauncher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.LaunchOptions+ProcessLauncher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomTargetProcessLauncher">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.LaunchOptions.TargetProcessLauncher CustomTargetProcessLauncher { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.LaunchOptions/TargetProcessLauncher CustomTargetProcessLauncher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.LaunchOptions+TargetProcessLauncher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Valgrind">
      <MemberSignature Language="C#" Value="public bool Valgrind { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Valgrind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Run the process under valgrind.</summary>
        <value>To be added.</value>
        <remarks>Defaults to false.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/LocalVariable.xml`:

```xml
<Type Name="LocalVariable" FullName="Mono.Debugger.Soft.LocalVariable">
  <TypeSignature Language="C#" Value="public class LocalVariable : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LocalVariable extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a local variable of a method.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArg">
      <MemberSignature Language="C#" Value="public bool IsArg { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArg" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/Location.xml`:

```xml
<Type Name="Location" FullName="Mono.Debugger.Soft.Location">
  <TypeSignature Language="C#" Value="public class Location : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Location extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an executable location in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceFile">
      <MemberSignature Language="C#" Value="public string SourceFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodBodyMirror.xml`:

```xml
<Type Name="MethodBodyMirror" FullName="Mono.Debugger.Soft.MethodBodyMirror">
  <TypeSignature Language="C#" Value="public class MethodBodyMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodBodyMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a MethodBody in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetILAsByteArray">
      <MemberSignature Language="C#" Value="public byte[] GetILAsByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetILAsByteArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Instructions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Mono.Debugger.Soft.ILInstruction&gt; Instructions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.List`1&lt;class Mono.Debugger.Soft.ILInstruction&gt; Instructions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Mono.Debugger.Soft.ILInstruction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodEntryEvent.xml`:

```xml
<Type Name="MethodEntryEvent" FullName="Mono.Debugger.Soft.MethodEntryEvent">
  <TypeSignature Language="C#" Value="public class MethodEntryEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodEntryEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a MethodEntry event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodEntryEventRequest.xml`:

```xml
<Type Name="MethodEntryEventRequest" FullName="Mono.Debugger.Soft.MethodEntryEventRequest">
  <TypeSignature Language="C#" Value="public sealed class MethodEntryEventRequest : Mono.Debugger.Soft.EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodEntryEventRequest extends Mono.Debugger.Soft.EventRequest" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.EventRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Request for MethodEntry events.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members />
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodExitEvent.xml`:

```xml
<Type Name="MethodExitEvent" FullName="Mono.Debugger.Soft.MethodExitEvent">
  <TypeSignature Language="C#" Value="public class MethodExitEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodExitEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a MethodExit event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodExitEventRequest.xml`:

```xml
<Type Name="MethodExitEventRequest" FullName="Mono.Debugger.Soft.MethodExitEventRequest">
  <TypeSignature Language="C#" Value="public sealed class MethodExitEventRequest : Mono.Debugger.Soft.EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MethodExitEventRequest extends Mono.Debugger.Soft.EventRequest" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.EventRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Request for MethodExit events.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members />
</Type>

```

`Documentation/en/Mono.Debugger.Soft/MethodMirror.xml`:

```xml
<Type Name="MethodMirror" FullName="Mono.Debugger.Soft.MethodMirror">
  <TypeSignature Language="C#" Value="public class MethodMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a MethodInfo in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocal">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.LocalVariable GetLocal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.LocalVariable GetLocal(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.LocalVariable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocals">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.LocalVariable[] GetLocals ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.LocalVariable[] GetLocals() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.LocalVariable[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodBodyMirror GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodBodyMirror GetMethodBody() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodBodyMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ParameterInfoMirror[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ParameterInfoMirror[] GetParameters() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ParameterInfoMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILOffsets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;int&gt; ILOffsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;int32&gt; ILOffsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumbers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;int&gt; LineNumbers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;int32&gt; LineNumbers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationAtILOffset">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Location LocationAtILOffset (int il_offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Location LocationAtILOffset(int32 il_offset) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Location</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il_offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il_offset">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Locations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Location&gt; Locations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Location&gt; Locations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Location&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public Mono.Cecil.MethodDefinition Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Cecil.MethodDefinition Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Cecil.MethodDefinition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ParameterInfoMirror ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ParameterInfoMirror ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ParameterInfoMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceFile">
      <MemberSignature Language="C#" Value="public string SourceFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/Mirror.xml`:

```xml
<Type Name="Mirror" FullName="Mono.Debugger.Soft.Mirror">
  <TypeSignature Language="C#" Value="public abstract class Mirror : Mono.Debugger.Soft.IMirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Mirror extends System.Object implements class Mono.Debugger.Soft.IMirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Mono.Debugger.Soft.IMirror</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Base class for mirror objects.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckMirror">
      <MemberSignature Language="C#" Value="protected void CheckMirror (Mono.Debugger.Soft.Mirror m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CheckMirror(class Mono.Debugger.Soft.Mirror m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="Mono.Debugger.Soft.Mirror" />
      </Parameters>
      <Docs>
        <param name="m">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="id">
      <MemberSignature Language="C#" Value="protected long id;" />
      <MemberSignature Language="ILAsm" Value=".field family int64 id" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetVirtualMachine">
      <MemberSignature Language="C#" Value="protected void SetVirtualMachine (Mono.Debugger.Soft.VirtualMachine vm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetVirtualMachine(class Mono.Debugger.Soft.VirtualMachine vm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VirtualMachine">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.VirtualMachine VirtualMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.VirtualMachine VirtualMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="vm">
      <MemberSignature Language="C#" Value="protected Mono.Debugger.Soft.VirtualMachine vm;" />
      <MemberSignature Language="ILAsm" Value=".field family class Mono.Debugger.Soft.VirtualMachine vm" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ModuleMirror.xml`:

```xml
<Type Name="ModuleMirror" FullName="Mono.Debugger.Soft.ModuleMirror">
  <TypeSignature Language="C#" Value="public class ModuleMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ModuleMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a Module in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AssemblyMirror Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ObjectCollectedException.xml`:

```xml
<Type Name="ObjectCollectedException" FullName="Mono.Debugger.Soft.ObjectCollectedException">
  <TypeSignature Language="C#" Value="public class ObjectCollectedException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectCollectedException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Thrown when a attempt was made to access the state of a garbage collected object.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectCollectedException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ObjectMirror.xml`:

```xml
<Type Name="ObjectMirror" FullName="Mono.Debugger.Soft.ObjectMirror">
  <TypeSignature Language="C#" Value="public class ObjectMirror : Mono.Debugger.Soft.Value" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectMirror extends Mono.Debugger.Soft.Value" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Value</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents an object in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.VirtualMachine vm, Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.VirtualMachine vm, class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the overload without the 'vm' argument")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AppDomainMirror Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AppDomainMirror Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AppDomainMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value EndInvokeMethod (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value EndInvokeMethod(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetValue (Mono.Debugger.Soft.FieldInfoMirror field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetValue(class Mono.Debugger.Soft.FieldInfoMirror field) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="Mono.Debugger.Soft.FieldInfoMirror" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value[] GetValues (System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt; fields);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value[] GetValues(class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.FieldInfoMirror&gt; fields) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fields" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt;" />
      </Parameters>
      <Docs>
        <param name="fields">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollected">
      <MemberSignature Language="C#" Value="public bool IsCollected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (Mono.Debugger.Soft.FieldInfoMirror field, Mono.Debugger.Soft.Value value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class Mono.Debugger.Soft.FieldInfoMirror field, class Mono.Debugger.Soft.Value value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="Mono.Debugger.Soft.FieldInfoMirror" />
        <Parameter Name="value" Type="Mono.Debugger.Soft.Value" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValues">
      <MemberSignature Language="C#" Value="public void SetValues (System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt; fields, Mono.Debugger.Soft.Value[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValues(class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.FieldInfoMirror&gt; fields, class Mono.Debugger.Soft.Value[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fields" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt;" />
        <Parameter Name="values" Type="Mono.Debugger.Soft.Value[]" />
      </Parameters>
      <Docs>
        <param name="fields">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ParameterInfoMirror.xml`:

```xml
<Type Name="ParameterInfoMirror" FullName="Mono.Debugger.Soft.ParameterInfoMirror">
  <TypeSignature Language="C#" Value="public class ParameterInfoMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParameterInfoMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a ParameterInfo in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.ParameterAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ParameterAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRetval">
      <MemberSignature Language="C#" Value="public bool IsRetval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRetval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParameterType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror ParameterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror ParameterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/PrimitiveValue.xml`:

```xml
<Type Name="PrimitiveValue" FullName="Mono.Debugger.Soft.PrimitiveValue">
  <TypeSignature Language="C#" Value="public class PrimitiveValue : Mono.Debugger.Soft.Value" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PrimitiveValue extends Mono.Debugger.Soft.Value" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Value</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a value of a primitive type in the debuggee.</summary>
    <remarks>IntPtr values are represented as Int64 values since the debuggee might have a different word size.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PrimitiveValue (Mono.Debugger.Soft.VirtualMachine vm, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.VirtualMachine vm, object value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/PropertyInfoMirror.xml`:

```xml
<Type Name="PropertyInfoMirror" FullName="Mono.Debugger.Soft.PropertyInfoMirror">
  <TypeSignature Language="C#" Value="public class PropertyInfoMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyInfoMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyInfoMirror (Mono.Debugger.Soft.TypeMirror parent, long id, string name, Mono.Debugger.Soft.MethodMirror get_method, Mono.Debugger.Soft.MethodMirror set_method, System.Reflection.PropertyAttributes attrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.TypeMirror parent, int64 id, string name, class Mono.Debugger.Soft.MethodMirror get_method, class Mono.Debugger.Soft.MethodMirror set_method, valuetype System.Reflection.PropertyAttributes attrs) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="id" Type="System.Int64" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="get_method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="set_method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="attrs" Type="System.Reflection.PropertyAttributes" />
      </Parameters>
      <Docs>
        <param name="parent">To be added.</param>
        <param name="id">To be added.</param>
        <param name="name">To be added.</param>
        <param name="get_method">To be added.</param>
        <param name="set_method">To be added.</param>
        <param name="attrs">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.PropertyAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (Mono.Debugger.Soft.TypeMirror attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(class Mono.Debugger.Soft.TypeMirror attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror GetGetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror GetGetMethod() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGetMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror GetGetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror GetGetMethod(bool nonPublic) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexParameters">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ParameterInfoMirror[] GetIndexParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ParameterInfoMirror[] GetIndexParameters() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ParameterInfoMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror GetSetMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror GetSetMethod() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSetMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror GetSetMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror GetSetMethod(bool nonPublic) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StackFrame.xml`:

```xml
<Type Name="StackFrame" FullName="Mono.Debugger.Soft.StackFrame">
  <TypeSignature Language="C#" Value="public class StackFrame : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StackFrame extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a stack frame of a suspended thread in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArgument">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetArgument (int pos);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetArgument(int32 pos) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pos">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetThis">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetThis ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetThis() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetValue (Mono.Debugger.Soft.LocalVariable var);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetValue(class Mono.Debugger.Soft.LocalVariable var) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="var" Type="Mono.Debugger.Soft.LocalVariable" />
      </Parameters>
      <Docs>
        <param name="var">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetValue (Mono.Debugger.Soft.ParameterInfoMirror param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetValue(class Mono.Debugger.Soft.ParameterInfoMirror param) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="Mono.Debugger.Soft.ParameterInfoMirror" />
      </Parameters>
      <Docs>
        <param name="param">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value[] GetValues (Mono.Debugger.Soft.LocalVariable[] vars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value[] GetValues(class Mono.Debugger.Soft.LocalVariable[] vars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vars" Type="Mono.Debugger.Soft.LocalVariable[]" />
      </Parameters>
      <Docs>
        <param name="vars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisibleVariableByName">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.LocalVariable GetVisibleVariableByName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.LocalVariable GetVisibleVariableByName(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.LocalVariable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisibleVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.LocalVariable&gt; GetVisibleVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.LocalVariable&gt; GetVisibleVariables() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.LocalVariable&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggerInvoke">
      <MemberSignature Language="C#" Value="public bool IsDebuggerInvoke { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggerInvoke" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns whenever this stack frame represents the first frame of a method invocation done by the debugger itself using the InvokeMethod () methods.</summary>
        <value>To be added.</value>
        <remarks>Not in JDI.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Location Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Location Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Location</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (Mono.Debugger.Soft.LocalVariable var, Mono.Debugger.Soft.Value value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class Mono.Debugger.Soft.LocalVariable var, class Mono.Debugger.Soft.Value value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="var" Type="Mono.Debugger.Soft.LocalVariable" />
        <Parameter Name="value" Type="Mono.Debugger.Soft.Value" />
      </Parameters>
      <Docs>
        <param name="var">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (Mono.Debugger.Soft.ParameterInfoMirror param, Mono.Debugger.Soft.Value value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class Mono.Debugger.Soft.ParameterInfoMirror param, class Mono.Debugger.Soft.Value value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="Mono.Debugger.Soft.ParameterInfoMirror" />
        <Parameter Name="value" Type="Mono.Debugger.Soft.Value" />
      </Parameters>
      <Docs>
        <param name="param">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ThreadMirror Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ThreadMirror Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ThreadMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StepDepth.xml`:

```xml
<Type Name="StepDepth" FullName="Mono.Debugger.Soft.StepDepth">
  <TypeSignature Language="C#" Value="public enum StepDepth" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed StepDepth extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Type of a Single Step operation.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Into">
      <MemberSignature Language="C#" Value="Into" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.StepDepth Into = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepDepth</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="Out" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.StepDepth Out = int32(2)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepDepth</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Over">
      <MemberSignature Language="C#" Value="Over" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.StepDepth Over = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepDepth</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StepEvent.xml`:

```xml
<Type Name="StepEvent" FullName="Mono.Debugger.Soft.StepEvent">
  <TypeSignature Language="C#" Value="public class StepEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StepEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a Single Step event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public long Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.MethodMirror Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StepEventRequest.xml`:

```xml
<Type Name="StepEventRequest" FullName="Mono.Debugger.Soft.StepEventRequest">
  <TypeSignature Language="C#" Value="public sealed class StepEventRequest : Mono.Debugger.Soft.EventRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StepEventRequest extends Mono.Debugger.Soft.EventRequest" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.EventRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Request object for single step events.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.StepDepth Depth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.StepDepth Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepDepth</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enable">
      <MemberSignature Language="C#" Value="public override void Enable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Enable() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.StepSize Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Debugger.Soft.StepSize Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ThreadMirror Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ThreadMirror Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ThreadMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StepSize.xml`:

```xml
<Type Name="StepSize" FullName="Mono.Debugger.Soft.StepSize">
  <TypeSignature Language="C#" Value="public enum StepSize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed StepSize extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Amount of code to execute when single stepping.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Line">
      <MemberSignature Language="C#" Value="Line" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.StepSize Line = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="Min" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.StepSize Min = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StringMirror.xml`:

```xml
<Type Name="StringMirror" FullName="Mono.Debugger.Soft.StringMirror">
  <TypeSignature Language="C#" Value="public class StringMirror : Mono.Debugger.Soft.ObjectMirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StringMirror extends Mono.Debugger.Soft.ObjectMirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.ObjectMirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a string object in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/StructMirror.xml`:

```xml
<Type Name="StructMirror" FullName="Mono.Debugger.Soft.StructMirror">
  <TypeSignature Language="C#" Value="public class StructMirror : Mono.Debugger.Soft.Value" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StructMirror extends Mono.Debugger.Soft.Value" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Value</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a valuetype instance in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.VirtualMachine vm, Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.VirtualMachine vm, class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the overload without the 'vm' argument")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value EndInvokeMethod (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value EndInvokeMethod(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fields">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value[] Fields { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Value[] Fields" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value this[string field] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.Value Item(string)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/SuspendPolicy.xml`:

```xml
<Type Name="SuspendPolicy" FullName="Mono.Debugger.Soft.SuspendPolicy">
  <TypeSignature Language="C#" Value="public enum SuspendPolicy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed SuspendPolicy extends System.Enum" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Determines which threads are suspended in the debuggee when an event occurs.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="All" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.SuspendPolicy All = int32(2)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.SuspendPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="EventThread">
      <MemberSignature Language="C#" Value="EventThread" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.SuspendPolicy EventThread = int32(1)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.SuspendPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Mono.Debugger.Soft.SuspendPolicy None = int32(0)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.SuspendPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ThreadDeathEvent.xml`:

```xml
<Type Name="ThreadDeathEvent" FullName="Mono.Debugger.Soft.ThreadDeathEvent">
  <TypeSignature Language="C#" Value="public class ThreadDeathEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ThreadDeathEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a ThreadDeath event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members />
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ThreadMirror.xml`:

```xml
<Type Name="ThreadMirror" FullName="Mono.Debugger.Soft.ThreadMirror">
  <TypeSignature Language="C#" Value="public class ThreadMirror : Mono.Debugger.Soft.ObjectMirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ThreadMirror extends Mono.Debugger.Soft.ObjectMirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.ObjectMirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a Thread in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetFrames">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.StackFrame[] GetFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.StackFrame[] GetFrames() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StackFrame[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public long Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadId">
      <MemberSignature Language="C#" Value="public long ThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/ThreadStartEvent.xml`:

```xml
<Type Name="ThreadStartEvent" FullName="Mono.Debugger.Soft.ThreadStartEvent">
  <TypeSignature Language="C#" Value="public class ThreadStartEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ThreadStartEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a ThreadStart event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members />
</Type>

```

`Documentation/en/Mono.Debugger.Soft/TypeLoadEvent.xml`:

```xml
<Type Name="TypeLoadEvent" FullName="Mono.Debugger.Soft.TypeLoadEvent">
  <TypeSignature Language="C#" Value="public class TypeLoadEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeLoadEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a TypeLoad event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/TypeMirror.xml`:

```xml
<Type Name="TypeMirror" FullName="Mono.Debugger.Soft.TypeMirror">
  <TypeSignature Language="C#" Value="public class TypeMirror : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeMirror extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a Type in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyMirror Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AssemblyMirror Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeMethod">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvokeMethod (Mono.Debugger.Soft.VirtualMachine vm, Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvokeMethod(class Mono.Debugger.Soft.VirtualMachine vm, class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the overload without the 'vm' argument")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CSharpName">
      <MemberSignature Language="C#" Value="public string CSharpName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CSharpName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value EndInvokeMethod (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value EndInvokeMethod(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumUnderlyingType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror EnumUnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.TypeMirror EnumUnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetArrayRank() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes (Mono.Debugger.Soft.TypeMirror attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.CustomAttributeDataMirror[] GetCustomAttributes(class Mono.Debugger.Soft.TypeMirror attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.CustomAttributeDataMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror GetElementType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.FieldInfoMirror GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.FieldInfoMirror GetField(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.FieldInfoMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.FieldInfoMirror[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.FieldInfoMirror[] GetFields() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.FieldInfoMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror GetMethod(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodMirror[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodMirror[] GetMethods() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror[] GetNestedTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.TypeMirror[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.TypeMirror[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.TypeMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.PropertyInfoMirror[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.PropertyInfoMirror[] GetProperties() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.PropertyInfoMirror[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.PropertyInfoMirror[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.PropertyInfoMirror[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.PropertyInfoMirror[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.PropertyInfoMirror GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.PropertyInfoMirror GetProperty(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.PropertyInfoMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceFiles">
      <MemberSignature Language="C#" Value="public string[] GetSourceFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSourceFiles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceFiles">
      <MemberSignature Language="C#" Value="public string[] GetSourceFiles (bool return_full_paths);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSourceFiles(bool return_full_paths) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="return_full_paths" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="return_full_paths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeObject">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ObjectMirror GetTypeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ObjectMirror GetTypeObject() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ObjectMirror</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetValue (Mono.Debugger.Soft.FieldInfoMirror field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetValue(class Mono.Debugger.Soft.FieldInfoMirror field) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="Mono.Debugger.Soft.FieldInfoMirror" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value GetValue (Mono.Debugger.Soft.FieldInfoMirror field, Mono.Debugger.Soft.ThreadMirror thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value GetValue(class Mono.Debugger.Soft.FieldInfoMirror field, class Mono.Debugger.Soft.ThreadMirror thread) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="Mono.Debugger.Soft.FieldInfoMirror" />
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <param name="thread">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value[] GetValues (System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt; fields);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value[] GetValues(class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.FieldInfoMirror&gt; fields) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fields" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt;" />
      </Parameters>
      <Docs>
        <param name="fields">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value[] GetValues (System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt; fields, Mono.Debugger.Soft.ThreadMirror thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value[] GetValues(class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.FieldInfoMirror&gt; fields, class Mono.Debugger.Soft.ThreadMirror thread) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fields" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt;" />
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
      </Parameters>
      <Docs>
        <param name="fields">To be added.</param>
        <param name="thread">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMethod">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value InvokeMethod (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value InvokeMethod(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Mono.Debugger.Soft.TypeMirror c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class Mono.Debugger.Soft.TypeMirror c) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="Mono.Debugger.Soft.TypeMirror" />
      </Parameters>
      <Docs>
        <param name="c">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public Mono.Cecil.TypeDefinition Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Cecil.TypeDefinition Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Cecil.TypeDefinition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ModuleMirror Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ModuleMirror Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ModuleMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewInstance">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value NewInstance (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value NewInstance(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewInstance">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Value NewInstance (Mono.Debugger.Soft.ThreadMirror thread, Mono.Debugger.Soft.MethodMirror method, System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt; arguments, Mono.Debugger.Soft.InvokeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Value NewInstance(class Mono.Debugger.Soft.ThreadMirror thread, class Mono.Debugger.Soft.MethodMirror method, class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.Value&gt; arguments, valuetype Mono.Debugger.Soft.InvokeOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Value</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.Value&gt;" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.InvokeOptions" />
      </Parameters>
      <Docs>
        <param name="thread">To be added.</param>
        <param name="method">To be added.</param>
        <param name="arguments">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (Mono.Debugger.Soft.FieldInfoMirror field, Mono.Debugger.Soft.Value value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class Mono.Debugger.Soft.FieldInfoMirror field, class Mono.Debugger.Soft.Value value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="Mono.Debugger.Soft.FieldInfoMirror" />
        <Parameter Name="value" Type="Mono.Debugger.Soft.Value" />
      </Parameters>
      <Docs>
        <param name="field">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValues">
      <MemberSignature Language="C#" Value="public void SetValues (System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt; fields, Mono.Debugger.Soft.Value[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValues(class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.FieldInfoMirror&gt; fields, class Mono.Debugger.Soft.Value[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fields" Type="System.Collections.Generic.IList&lt;Mono.Debugger.Soft.FieldInfoMirror&gt;" />
        <Parameter Name="values" Type="Mono.Debugger.Soft.Value[]" />
      </Parameters>
      <Docs>
        <param name="fields">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VMDeathEvent.xml`:

```xml
<Type Name="VMDeathEvent" FullName="Mono.Debugger.Soft.VMDeathEvent">
  <TypeSignature Language="C#" Value="public class VMDeathEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VMDeathEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a VMDeath event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VMDeathEvent (Mono.Debugger.Soft.VirtualMachine vm, int req_id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.VirtualMachine vm, int32 req_id) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="req_id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="req_id">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VMDisconnectEvent.xml`:

```xml
<Type Name="VMDisconnectEvent" FullName="Mono.Debugger.Soft.VMDisconnectEvent">
  <TypeSignature Language="C#" Value="public class VMDisconnectEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VMDisconnectEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when the connection to the debuggee is lost.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VMDisconnectEvent (Mono.Debugger.Soft.VirtualMachine vm, int req_id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.VirtualMachine vm, int32 req_id) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="req_id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="req_id">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VMDisconnectedException.xml`:

```xml
<Type Name="VMDisconnectedException" FullName="Mono.Debugger.Soft.VMDisconnectedException">
  <TypeSignature Language="C#" Value="public class VMDisconnectedException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VMDisconnectedException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Thrown when the connection to the debuggee is lost while executing an operation.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VMDisconnectedException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VMMismatchException.xml`:

```xml
<Type Name="VMMismatchException" FullName="Mono.Debugger.Soft.VMMismatchException">
  <TypeSignature Language="C#" Value="public class VMMismatchException : Exception" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VMMismatchException extends System.Exception" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Thrown when an attempt was made to use entities belonging to different virtual machines.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VMMismatchException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VMStartEvent.xml`:

```xml
<Type Name="VMStartEvent" FullName="Mono.Debugger.Soft.VMStartEvent">
  <TypeSignature Language="C#" Value="public class VMStartEvent : Mono.Debugger.Soft.Event" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VMStartEvent extends Mono.Debugger.Soft.Event" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sent when a VMStart event occurs in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VMStartEvent (Mono.Debugger.Soft.VirtualMachine vm, int req_id, long thread_id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Mono.Debugger.Soft.VirtualMachine vm, int32 req_id, int64 thread_id) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="vm" Type="Mono.Debugger.Soft.VirtualMachine" />
        <Parameter Name="req_id" Type="System.Int32" />
        <Parameter Name="thread_id" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="vm">To be added.</param>
        <param name="req_id">To be added.</param>
        <param name="thread_id">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/Value.xml`:

```xml
<Type Name="Value" FullName="Mono.Debugger.Soft.Value">
  <TypeSignature Language="C#" Value="public abstract class Value : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Value extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a value in the debuggee.</summary>
    <remarks>
    </remarks>
  </Docs>
  <Members />
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VersionInfo.xml`:

```xml
<Type Name="VersionInfo" FullName="Mono.Debugger.Soft.VersionInfo">
  <TypeSignature Language="C#" Value="public class VersionInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VersionInfo extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VersionInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MajorVersion">
      <MemberSignature Language="C#" Value="public int MajorVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MajorVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinorVersion">
      <MemberSignature Language="C#" Value="public int MinorVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinorVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VMVersion">
      <MemberSignature Language="C#" Value="public string VMVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string VMVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VirtualMachine.xml`:

```xml
<Type Name="VirtualMachine" FullName="Mono.Debugger.Soft.VirtualMachine">
  <TypeSignature Language="C#" Value="public class VirtualMachine : Mono.Debugger.Soft.Mirror" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VirtualMachine extends Mono.Debugger.Soft.Mirror" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Mono.Debugger.Soft.Mirror</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a connection to a debuggee.</summary>
    <remarks>
      <format type="text/html">
        <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/com/sun/jdi/VirtualMachine.html">JDI Documentation</a>
      </format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ClearAllBreakpoints">
      <MemberSignature Language="C#" Value="public void ClearAllBreakpoints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllBreakpoints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAssemblyLoadRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AssemblyLoadEventRequest CreateAssemblyLoadRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.AssemblyLoadEventRequest CreateAssemblyLoadRequest() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AssemblyLoadEventRequest</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBreakpointRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.BreakpointEventRequest CreateBreakpointRequest (Mono.Debugger.Soft.Location loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.BreakpointEventRequest CreateBreakpointRequest(class Mono.Debugger.Soft.Location loc) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.BreakpointEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="Mono.Debugger.Soft.Location" />
      </Parameters>
      <Docs>
        <param name="loc">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBreakpointRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.BreakpointEventRequest CreateBreakpointRequest (Mono.Debugger.Soft.MethodMirror method, long il_offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.BreakpointEventRequest CreateBreakpointRequest(class Mono.Debugger.Soft.MethodMirror method, int64 il_offset) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.BreakpointEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="il_offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="method">
        </param>
        <param name="il_offset">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEnumMirror">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.EnumMirror CreateEnumMirror (Mono.Debugger.Soft.TypeMirror type, Mono.Debugger.Soft.PrimitiveValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.EnumMirror CreateEnumMirror(class Mono.Debugger.Soft.TypeMirror type, class Mono.Debugger.Soft.PrimitiveValue value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EnumMirror</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="value" Type="Mono.Debugger.Soft.PrimitiveValue" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateExceptionRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ExceptionEventRequest CreateExceptionRequest (Mono.Debugger.Soft.TypeMirror exc_type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ExceptionEventRequest CreateExceptionRequest(class Mono.Debugger.Soft.TypeMirror exc_type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ExceptionEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exc_type" Type="Mono.Debugger.Soft.TypeMirror" />
      </Parameters>
      <Docs>
        <param name="exc_type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateExceptionRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ExceptionEventRequest CreateExceptionRequest (Mono.Debugger.Soft.TypeMirror exc_type, bool caught, bool uncaught);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.ExceptionEventRequest CreateExceptionRequest(class Mono.Debugger.Soft.TypeMirror exc_type, bool caught, bool uncaught) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ExceptionEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exc_type" Type="Mono.Debugger.Soft.TypeMirror" />
        <Parameter Name="caught" Type="System.Boolean" />
        <Parameter Name="uncaught" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exc_type">To be added.</param>
        <param name="caught">To be added.</param>
        <param name="uncaught">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodEntryRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodEntryEventRequest CreateMethodEntryRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodEntryEventRequest CreateMethodEntryRequest() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodEntryEventRequest</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodExitRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.MethodExitEventRequest CreateMethodExitRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.MethodExitEventRequest CreateMethodExitRequest() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.MethodExitEventRequest</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateStepRequest">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.StepEventRequest CreateStepRequest (Mono.Debugger.Soft.ThreadMirror thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.StepEventRequest CreateStepRequest(class Mono.Debugger.Soft.ThreadMirror thread) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.StepEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Mono.Debugger.Soft.ThreadMirror" />
      </Parameters>
      <Docs>
        <param name="thread">
        </param>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValue">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.PrimitiveValue CreateValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.PrimitiveValue CreateValue(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.PrimitiveValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEvents">
      <MemberSignature Language="C#" Value="public void EnableEvents (Mono.Debugger.Soft.EventType[] events);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnableEvents(valuetype Mono.Debugger.Soft.EventType[] events) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="events" Type="Mono.Debugger.Soft.EventType[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="events">
        </param>
        <summary>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint EndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint EndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        </summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(int32 exitCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">
        </param>
        <summary>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextEvent">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Event GetNextEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Event GetNextEvent() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Event</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextEvent">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.Event GetNextEvent (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.Event GetNextEvent(int32 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.Event</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">
        </param>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextEvent&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetNextEvent&lt;T&gt; () where T : Mono.Debugger.Soft.Event;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetNextEvent&lt;(class Mono.Debugger.Soft.Event) T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Mono.Debugger.Soft.Event</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
        </typeparam>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextEventSet">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.EventSet GetNextEventSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.EventSet GetNextEventSet() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.EventSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetThreads">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Mono.Debugger.Soft.ThreadMirror&gt; GetThreads ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Mono.Debugger.Soft.ThreadMirror&gt; GetThreads() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Mono.Debugger.Soft.ThreadMirror&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Process">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Process Process { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.Process Process" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        </summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootDomain">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.AppDomainMirror RootDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.AppDomainMirror RootDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.AppDomainMirror</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
        </summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBreakpoint">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.BreakpointEventRequest SetBreakpoint (Mono.Debugger.Soft.MethodMirror method, long il_offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Debugger.Soft.BreakpointEventRequest SetBreakpoint(class Mono.Debugger.Soft.MethodMirror method, int64 il_offset) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.BreakpointEventRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="Mono.Debugger.Soft.MethodMirror" />
        <Parameter Name="il_offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="method">
        </param>
        <param name="il_offset">
        </param>
        <summary>
        </summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetProcess">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.ITargetProcess TargetProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.ITargetProcess TargetProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.ITargetProcess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Mono.Debugger.Soft.VersionInfo Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Debugger.Soft.VersionInfo Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VersionInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/Mono.Debugger.Soft/VirtualMachineManager.xml`:

```xml
<Type Name="VirtualMachineManager" FullName="Mono.Debugger.Soft.VirtualMachineManager">
  <TypeSignature Language="C#" Value="public class VirtualMachineManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VirtualMachineManager extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Allows launching and connecting to mono virtual machines.</summary>
    <remarks>This class implements the functionality of the classes in the <format type="text/html"><a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/com/sun/jdi/connect/package-frame.html">com.sun.kdi.connect</a></format> package in JDI.</remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginConnect (System.Net.IPEndPoint dbg_ep, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginConnect(class System.Net.IPEndPoint dbg_ep, class System.AsyncCallback callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">To be added.</param>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginConnect (System.Net.IPEndPoint dbg_ep, System.Net.IPEndPoint con_ep, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginConnect(class System.Net.IPEndPoint dbg_ep, class System.Net.IPEndPoint con_ep, class System.AsyncCallback callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="con_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">To be added.</param>
        <param name="con_ep">To be added.</param>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLaunch">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginLaunch (System.Diagnostics.ProcessStartInfo info, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginLaunch(class System.Diagnostics.ProcessStartInfo info, class System.AsyncCallback callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLaunch">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginLaunch (System.Diagnostics.ProcessStartInfo info, AsyncCallback callback, Mono.Debugger.Soft.LaunchOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginLaunch(class System.Diagnostics.ProcessStartInfo info, class System.AsyncCallback callback, class Mono.Debugger.Soft.LaunchOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.LaunchOptions" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginListen">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginListen (System.Net.IPEndPoint dbg_ep, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginListen(class System.Net.IPEndPoint dbg_ep, class System.AsyncCallback callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">To be added.</param>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginListen">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginListen (System.Net.IPEndPoint dbg_ep, System.Net.IPEndPoint con_ep, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginListen(class System.Net.IPEndPoint dbg_ep, class System.Net.IPEndPoint con_ep, class System.AsyncCallback callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="con_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">To be added.</param>
        <param name="con_ep">To be added.</param>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelConnection">
      <MemberSignature Language="C#" Value="public static void CancelConnection (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnection(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Connect (System.Net.IPEndPoint endpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Connect(class System.Net.IPEndPoint endpoint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Connect (System.Net.IPEndPoint endpoint, System.Net.IPEndPoint consoleEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Connect(class System.Net.IPEndPoint endpoint, class System.Net.IPEndPoint consoleEndpoint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Net.IPEndPoint" />
        <Parameter Name="consoleEndpoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">To be added.</param>
        <param name="consoleEndpoint">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectInternal">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine ConnectInternal (System.Net.Sockets.Socket dbg_sock, System.Net.Sockets.Socket con_sock, System.Net.IPEndPoint dbg_ep, System.Net.IPEndPoint con_ep);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine ConnectInternal(class System.Net.Sockets.Socket dbg_sock, class System.Net.Sockets.Socket con_sock, class System.Net.IPEndPoint dbg_ep, class System.Net.IPEndPoint con_ep) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_sock" Type="System.Net.Sockets.Socket" />
        <Parameter Name="con_sock" Type="System.Net.Sockets.Socket" />
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="con_ep" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dbg_sock">To be added.</param>
        <param name="con_sock">To be added.</param>
        <param name="dbg_ep">To be added.</param>
        <param name="con_ep">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLaunch">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine EndLaunch (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine EndLaunch(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndListen">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine EndListen (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine EndListen(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Launch (System.Diagnostics.ProcessStartInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Launch(class System.Diagnostics.ProcessStartInfo info) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Launch (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Launch(string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Launch (System.Diagnostics.ProcessStartInfo info, Mono.Debugger.Soft.LaunchOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Launch(class System.Diagnostics.ProcessStartInfo info, class Mono.Debugger.Soft.LaunchOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.LaunchOptions" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Launch (string[] args, Mono.Debugger.Soft.LaunchOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Launch(string[] args, class Mono.Debugger.Soft.LaunchOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="options" Type="Mono.Debugger.Soft.LaunchOptions" />
      </Parameters>
      <Docs>
        <param name="args">The arguments to pass to the launched virtual machine.</param>
        <param name="options">Launch options.</param>
        <summary>Launch a new virtual machine with the provided arguments.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchInternal">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine LaunchInternal (Mono.Debugger.Soft.ITargetProcess p, System.Diagnostics.ProcessStartInfo info, System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine LaunchInternal(class Mono.Debugger.Soft.ITargetProcess p, class System.Diagnostics.ProcessStartInfo info, class System.Net.Sockets.Socket socket) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="Mono.Debugger.Soft.ITargetProcess" />
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="p">To be added.</param>
        <param name="info">To be added.</param>
        <param name="socket">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchInternal">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine LaunchInternal (System.Diagnostics.Process p, System.Diagnostics.ProcessStartInfo info, System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine LaunchInternal(class System.Diagnostics.Process p, class System.Diagnostics.ProcessStartInfo info, class System.Net.Sockets.Socket socket) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Diagnostics.Process" />
        <Parameter Name="info" Type="System.Diagnostics.ProcessStartInfo" />
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="p">To be added.</param>
        <param name="info">To be added.</param>
        <param name="socket">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Listen (System.Net.IPEndPoint dbg_ep);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Listen(class System.Net.IPEndPoint dbg_ep) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">The TCP/IP endpoint to listen at.</param>
        <summary>Wait for a virtual machine to connect at the specified address.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine Listen (System.Net.IPEndPoint dbg_ep, System.Net.IPEndPoint con_ep);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine Listen(class System.Net.IPEndPoint dbg_ep, class System.Net.IPEndPoint con_ep) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_ep" Type="System.Net.IPEndPoint" />
        <Parameter Name="con_ep" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dbg_ep">To be added.</param>
        <param name="con_ep">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ListenInternal">
      <MemberSignature Language="C#" Value="public static Mono.Debugger.Soft.VirtualMachine ListenInternal (System.Net.Sockets.Socket dbg_sock, System.Net.Sockets.Socket con_sock);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Debugger.Soft.VirtualMachine ListenInternal(class System.Net.Sockets.Socket dbg_sock, class System.Net.Sockets.Socket con_sock) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Debugger.Soft.VirtualMachine</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dbg_sock" Type="System.Net.Sockets.Socket" />
        <Parameter Name="con_sock" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="dbg_sock">To be added.</param>
        <param name="con_sock">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

```

`Documentation/en/index.xml`:

```xml
<Overview>
  <Assemblies>
    <Assembly Name="Mono.Debugger.Soft" Version="0.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 79 15 99 77 d2 d0 3a 8e 6b ea 7a 2e 74 e8 d1 af cc 93 e8 85 19 74 95 2b b4 80 a1 2c 91 34 47 4d 04 06 24 47 c3 7e 0e 68 c0 80 53 6f cf 3c 3f be 2f f9 c9 79 ce 99 84 75 e5 06 e8 ce 82 dd 5b 0f 35 0d c1 0e 93 bf 2e ee cf 87 4b 24 77 0c 50 81 db ea 74 47 fd da fa 27 7b 22 de 47 d6 ff ea 44 96 74 a4 f9 fc cf 84 d1 50 69 08 93 80 28 4d bd d3 5f 46 cd ff 12 a1 bd 78 e4 ef 00 65 d0 16 df ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
  </Assemblies>
  <Copyright>(C) 2009 Novell, Inc.</Copyright>
  <Types>
    <Namespace Name="Mono.Debugger.Soft">
      <Type Name="AbsentInformationException" Kind="Class" />
      <Type Name="AppDomainCreateEvent" Kind="Class" />
      <Type Name="AppDomainMirror" Kind="Class" />
      <Type Name="AppDomainUnloadEvent" Kind="Class" />
      <Type Name="ArrayMirror" Kind="Class" />
      <Type Name="AssemblyLoadEvent" Kind="Class" />
      <Type Name="AssemblyLoadEventRequest" Kind="Class" />
      <Type Name="AssemblyMirror" Kind="Class" />
      <Type Name="AssemblyUnloadEvent" Kind="Class" />
      <Type Name="BreakpointEvent" Kind="Class" />
      <Type Name="BreakpointEventRequest" Kind="Class" />
      <Type Name="CustomAttributeDataMirror" Kind="Class" />
      <Type Name="CustomAttributeNamedArgumentMirror" Kind="Structure" />
      <Type Name="CustomAttributeTypedArgumentMirror" Kind="Structure" />
      <Type Name="EnumMirror" Kind="Class" />
      <Type Name="ErrorCode" Kind="Enumeration" />
      <Type Name="ErrorHandlerEventArgs" Kind="Class" />
      <Type Name="Event" Kind="Class" />
      <Type Name="EventRequest" Kind="Class" />
      <Type Name="EventSet" Kind="Class" />
      <Type Name="EventType" Kind="Enumeration" />
      <Type Name="ExceptionEvent" Kind="Class" />
      <Type Name="ExceptionEventRequest" Kind="Class" />
      <Type Name="FieldInfoMirror" Kind="Class" />
      <Type Name="IInvokeAsyncResult" Kind="Interface" />
      <Type Name="ILInstruction" Kind="Class" />
      <Type Name="IMirror" Kind="Interface" />
      <Type Name="InvalidStackFrameException" Kind="Class" />
      <Type Name="InvocationException" Kind="Class" />
      <Type Name="InvokeOptions" Kind="Enumeration" />
      <Type Name="ITargetProcess" Kind="Interface" />
      <Type Name="LaunchOptions" Kind="Class" />
      <Type Name="LaunchOptions+ProcessLauncher" Kind="Delegate" />
      <Type Name="LaunchOptions+TargetProcessLauncher" Kind="Delegate" />
      <Type Name="LocalVariable" Kind="Class" />
      <Type Name="Location" Kind="Class" />
      <Type Name="MethodBodyMirror" Kind="Class" />
      <Type Name="MethodEntryEvent" Kind="Class" />
      <Type Name="MethodEntryEventRequest" Kind="Class" />
      <Type Name="MethodExitEvent" Kind="Class" />
      <Type Name="MethodExitEventRequest" Kind="Class" />
      <Type Name="MethodMirror" Kind="Class" />
      <Type Name="Mirror" Kind="Class" />
      <Type Name="ModuleMirror" Kind="Class" />
      <Type Name="ObjectCollectedException" Kind="Class" />
      <Type Name="ObjectMirror" Kind="Class" />
      <Type Name="ParameterInfoMirror" Kind="Class" />
      <Type Name="PrimitiveValue" Kind="Class" />
      <Type Name="PropertyInfoMirror" Kind="Class" />
      <Type Name="StackFrame" Kind="Class" />
      <Type Name="StepDepth" Kind="Enumeration" />
      <Type Name="StepEvent" Kind="Class" />
      <Type Name="StepEventRequest" Kind="Class" />
      <Type Name="StepSize" Kind="Enumeration" />
      <Type Name="StringMirror" Kind="Class" />
      <Type Name="StructMirror" Kind="Class" />
      <Type Name="SuspendPolicy" Kind="Enumeration" />
      <Type Name="ThreadDeathEvent" Kind="Class" />
      <Type Name="ThreadMirror" Kind="Class" />
      <Type Name="ThreadStartEvent" Kind="Class" />
      <Type Name="TypeLoadEvent" Kind="Class" />
      <Type Name="TypeMirror" Kind="Class" />
      <Type Name="Value" Kind="Class" />
      <Type Name="VersionInfo" Kind="Class" />
      <Type Name="VirtualMachine" Kind="Class" />
      <Type Name="VirtualMachineManager" Kind="Class" />
      <Type Name="VMDeathEvent" Kind="Class" />
      <Type Name="VMDisconnectedException" Kind="Class" />
      <Type Name="VMDisconnectEvent" Kind="Class" />
      <Type Name="VMMismatchException" Kind="Class" />
      <Type Name="VMStartEvent" Kind="Class" />
    </Namespace>
  </Types>
  <Title>Mono.Debugger.Soft</Title>
</Overview>

```

`Documentation/en/ns-Mono.Debugger.Soft.xml`:

```xml
<Namespace Name="Mono.Debugger">
  <Docs>
	<summary>Mono Soft Debugger API</summary>
  <remarks>
    <para>This API is used to communicate with the debugging agent running 
	inside a mono runtime.
	</para>
    <para>The API is based on and is very similar to the <format type="text/html"><a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/index.html">Java Debug Interface.</a> If documentation is missing, the JDI documentation can be consulted instead.</format></para>
    <para>
	In this documentation, debuggee refers to the remote process running the mono runtime which this API communicates with.
	</para>
    <para>A <c>Mirror</c> object represents an entity in the debuggee. There is usually one mirror subclass for each type of entity, i.e. <c>TypeMirror</c> for types, <c>AppDomainMirror</c> for application domains etc. These classes usually have a similar set of properties/methods as their non-mirror counterparts, the difference is that calling these properties/methods might result in a remote call to the debuggee to request information. The results of these remote calls are usually cached in the mirror object, so when multiple calls are made to <c>TypeMirror.Name</c>, for example, only the first call involves a remote operation. The <c>ToString()/Equals()/GetHashCode ()</c> methods are an exception, these are guaranteed to only access local state.
	</para>
    <para>Differences between this API and JDI:
	<list type="bullet"><item><term>There is only one namespace, instead of 5 in JDI.</term></item><item><term>The API uses classes, while JDI uses interfaces.</term></item><item><term>No SPI interface yet.</term></item><item><term>Information is accessed using C# properties instead of methods.</term></item><item><term>There are fewer classes, i.e. <c>EventQueue</c>/<c>EventRequestManager</c> is integrated into <c>VirtualMachine</c>.</term></item><item><term>Values which have primitive types i.e. int are represented by a class called <c>PrimitiveValue</c>, instead of a separate class for each primitive type.</term></item></list></para>
  </remarks>
  </Docs>
</Namespace>

```

`Makefile`:

```
thisdir = class/Mono.Debugger.Soft
include ../../build/rules.make

LIBRARY = Mono.Debugger.Soft.dll
LIBRARY_SNK = ../mono.snk

LIB_REFS = System Mono.Cecil System.Core
LIB_MCS_FLAGS = /unsafe -D:MONO_DATACONVERTER_STATIC_METHODS /publicsign
KEYFILE = $(LIBRARY_SNK)

TEST_MCS_FLAGS =
TEST_LIB_REFS = Mono.Cecil System System.Core

VALID_TEST_PROFILE := $(filter net_4_x, $(PROFILE))

# The test exe is not profile specific, and compiling a 2.0 will make the 4.5 tests fail
ifdef VALID_TEST_PROFILE

TEST_HELPERS_SOURCES = \
	../test-helpers/NetworkHelpers.cs \
	Test/TypeLoadClass.cs

test-local: dtest-app.exe dtest-excfilter.exe

dtest-app.exe: Test/dtest-app.cs $(TEST_HELPERS_SOURCES)
	$(CSCOMPILE) -r:$(topdir)/class/lib/$(PROFILE)/System.Core.dll -r:$(topdir)/class/lib/$(PROFILE)/System.dll -out:$@ -unsafe $(PLATFORM_DEBUG_FLAGS) -optimize- Test/dtest-app.cs $(TEST_HELPERS_SOURCES)

dtest-excfilter.exe: Test/dtest-excfilter.il
	$(ILASM) -out:$@ /exe /debug Test/dtest-excfilter.il

else

NO_TEST=1
check:

endif

CLEAN_FILES = dtest-app.exe dtest-app.exe.mdb dtest-app.pdb dtest-excfilter.exe dtest-excfilter.exe.mdb dtest-excfilter.pdb

EXTRA_DISTFILES = \
	Test/dtest-app.cs \
	Test/dtest.cs \
	Test/dtest-excfilter.il

#NO_TEST = yes

include ../../build/library.make

```

`Mono.Debugger.Soft-net_4_x.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<!-- WARNING: this file is autogenerated, don't modify it. Edit the .sources file of the corresponding assembly instead if you want to add/remove C# source files. -->
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>9.0.30729</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{57B5039F-30CC-4EAA-9D55-1B9A07AC8A69}</ProjectGuid>
    <OutputType>Library</OutputType>
    <NoWarn>1699</NoWarn>
    <HostPlatform Condition=" '$(HostPlatform)' == '' and '$(OS)' == 'Windows_NT'">win32</HostPlatform>
    <HostPlatform Condition=" '$(HostPlatform)' == '' and '$(OS)' == 'Unix' and $([System.IO.File]::Exists('/usr/lib/libc.dylib'))">darwin</HostPlatform>
    <HostPlatform Condition=" '$(HostPlatform)' == '' and '$(OS)' == 'Unix'">linux</HostPlatform>
    <OutputPath>./../../class/lib/net_4_x-$(HostPlatform)</OutputPath>
    <IntermediateOutputPath>obj-net_4_x-$(HostPlatform)</IntermediateOutputPath>
    <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
    <NoStdLib>True</NoStdLib>
    
    <NoConfig>True</NoConfig>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>
    </RootNamespace>
    <AssemblyName>Mono.Debugger.Soft</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>../mono.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <NoWarn>1699</NoWarn>
    <Optimize>false</Optimize>
    <DefineConstants>TRACE;NET_4_0;NET_4_5;NET_4_6;MONO;WIN_PLATFORM;MULTIPLEX_OS;MONO_DATACONVERTER_STATIC_METHODS</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <NoWarn>1699</NoWarn>
    <Optimize>true</Optimize>
    <DefineConstants>NET_4_0;NET_4_5;NET_4_6;MONO;WIN_PLATFORM;MULTIPLEX_OS;MONO_DATACONVERTER_STATIC_METHODS</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- Set AddAdditionalExplicitAssemblyReferences to false, otherwise if targetting .NET4.0, 
  Microsoft.NETFramework.props will force a dependency on the assembly System.Core. This
  is a problem to compile the Mono mscorlib.dll -->
  <PropertyGroup>
    <AddAdditionalExplicitAssemblyReferences>false</AddAdditionalExplicitAssemblyReferences>
  </PropertyGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <ItemGroup>
    <Compile Include="..\..\build\common\Consts.cs" />
    <Compile Include="..\..\build\common\Locale.cs" />
    <Compile Include=".\Assembly\AssemblyInfo.cs" />
    <Compile Include="Mono.Debugger.Soft\AbsentInformationException.cs" />
    <Compile Include="Mono.Debugger.Soft\AppDomainCreateEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\AppDomainMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\AppDomainUnloadEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\ArrayMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\AssemblyLoadEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\AssemblyLoadEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\AssemblyMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\AssemblyUnloadEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\BreakpointEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\BreakpointEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\Connection.cs" />
    <Compile Include="Mono.Debugger.Soft\CustomAttributeDataMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\CustomAttributeNamedArgumentMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\CustomAttributeTypedArgumentMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\DataConverter.cs" />
    <Compile Include="Mono.Debugger.Soft\EnumMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\Event.cs" />
    <Compile Include="Mono.Debugger.Soft\EventQueueImpl.cs" />
    <Compile Include="Mono.Debugger.Soft\EventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\EventSet.cs" />
    <Compile Include="Mono.Debugger.Soft\EventType.cs" />
    <Compile Include="Mono.Debugger.Soft\ExceptionEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\ExceptionEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\FieldInfoMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\IInvokeAsyncResult.cs" />
    <Compile Include="Mono.Debugger.Soft\ILExceptionHandler.cs" />
    <Compile Include="Mono.Debugger.Soft\ILInstruction.cs" />
    <Compile Include="Mono.Debugger.Soft\ILInterpreter.cs" />
    <Compile Include="Mono.Debugger.Soft\IMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\InterfaceMappingMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\InvalidStackFrameException.cs" />
    <Compile Include="Mono.Debugger.Soft\InvocationException.cs" />
    <Compile Include="Mono.Debugger.Soft\InvokeOptions.cs" />
    <Compile Include="Mono.Debugger.Soft\ITargetProcess.cs" />
    <Compile Include="Mono.Debugger.Soft\LocalScope.cs" />
    <Compile Include="Mono.Debugger.Soft\LocalVariable.cs" />
    <Compile Include="Mono.Debugger.Soft\Location.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodBodyMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodEntryEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodEntryEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodExitEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodExitEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\MethodMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\Mirror.cs" />
    <Compile Include="Mono.Debugger.Soft\ModuleMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\ObjectCollectedException.cs" />
    <Compile Include="Mono.Debugger.Soft\ObjectMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\ParameterInfoMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\PointerValue.cs" />
    <Compile Include="Mono.Debugger.Soft\PrimitiveValue.cs" />
    <Compile Include="Mono.Debugger.Soft\PropertyInfoMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\StackFrame.cs" />
    <Compile Include="Mono.Debugger.Soft\StepEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\StepEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\StringMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\StructMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\SuspendPolicy.cs" />
    <Compile Include="Mono.Debugger.Soft\ThreadDeathEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\ThreadMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\ThreadStartEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\TypeLoadEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\TypeLoadEventRequest.cs" />
    <Compile Include="Mono.Debugger.Soft\TypeMirror.cs" />
    <Compile Include="Mono.Debugger.Soft\UserBreakEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\UserLogEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\Value.cs" />
    <Compile Include="Mono.Debugger.Soft\VirtualMachine.cs" />
    <Compile Include="Mono.Debugger.Soft\VirtualMachineManager.cs" />
    <Compile Include="Mono.Debugger.Soft\VMDeathEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\VMDisconnectedException.cs" />
    <Compile Include="Mono.Debugger.Soft\VMDisconnectEvent.cs" />
    <Compile Include="Mono.Debugger.Soft\VMMismatchException.cs" />
    <Compile Include="Mono.Debugger.Soft\VMStartEvent.cs" />  </ItemGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
  <PropertyGroup>
    <PreBuildEvent Condition=" '$(OS)' != 'Windows_NT' ">

    </PreBuildEvent>
    <PreBuildEvent Condition=" '$(OS)' == 'Windows_NT' ">

    </PreBuildEvent>
    <PostBuildEvent Condition=" '$(OS)' != 'Windows_NT' ">

    </PostBuildEvent>
    <PostBuildEvent Condition=" '$(OS)' == 'Windows_NT' ">

    </PostBuildEvent>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="../corlib/corlib-net_4_x.csproj">
      <Project>{2CA6026B-2DC8-4C4C-A12C-1E8234049DB7}</Project>
      <Name>corlib-net_4_x</Name>
    </ProjectReference>
    <ProjectReference Include="../System/System-net_4_x.csproj">
      <Project>{2762E921-91A8-4C87-91E9-BA628013F753}</Project>
      <Name>System-net_4_x</Name>
    </ProjectReference>
    <ProjectReference Include="../Mono.Cecil/Mono.Cecil-net_4_x.csproj">
      <Project>{2C0D558F-0B38-4691-967E-A910A1B995C1}</Project>
      <Name>Mono.Cecil-net_4_x</Name>
    </ProjectReference>
    <ProjectReference Include="../System.Core/System.Core-net_4_x.csproj">
      <Project>{359142A1-D80F-401E-AA64-7167C9317649}</Project>
      <Name>System.Core-net_4_x</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Properties\" />
  </ItemGroup>
</Project>


```

`Mono.Debugger.Soft.dll.sources`:

```sources
./Assembly/AssemblyInfo.cs
../../build/common/Consts.cs
../../build/common/Locale.cs
Mono.Debugger.Soft/CustomAttributeTypedArgumentMirror.cs
Mono.Debugger.Soft/ExceptionEvent.cs
Mono.Debugger.Soft/ModuleMirror.cs
Mono.Debugger.Soft/AppDomainMirror.cs
Mono.Debugger.Soft/AssemblyLoadEvent.cs
Mono.Debugger.Soft/AssemblyUnloadEvent.cs
Mono.Debugger.Soft/VMStartEvent.cs
Mono.Debugger.Soft/StackFrame.cs
Mono.Debugger.Soft/CustomAttributeDataMirror.cs
Mono.Debugger.Soft/ThreadStartEvent.cs
Mono.Debugger.Soft/ILInstruction.cs
Mono.Debugger.Soft/ILExceptionHandler.cs
Mono.Debugger.Soft/InterfaceMappingMirror.cs
Mono.Debugger.Soft/PrimitiveValue.cs
Mono.Debugger.Soft/PointerValue.cs
Mono.Debugger.Soft/VMDisconnectedException.cs
Mono.Debugger.Soft/Mirror.cs
Mono.Debugger.Soft/EnumMirror.cs
Mono.Debugger.Soft/FieldInfoMirror.cs
Mono.Debugger.Soft/TypeMirror.cs
Mono.Debugger.Soft/CustomAttributeNamedArgumentMirror.cs
Mono.Debugger.Soft/DataConverter.cs
Mono.Debugger.Soft/AssemblyMirror.cs
Mono.Debugger.Soft/VirtualMachine.cs
Mono.Debugger.Soft/VMMismatchException.cs
Mono.Debugger.Soft/AppDomainUnloadEvent.cs
Mono.Debugger.Soft/ExceptionEventRequest.cs
Mono.Debugger.Soft/EventType.cs
Mono.Debugger.Soft/StructMirror.cs
Mono.Debugger.Soft/InvocationException.cs
Mono.Debugger.Soft/IMirror.cs
Mono.Debugger.Soft/VMDeathEvent.cs
Mono.Debugger.Soft/MethodBodyMirror.cs
Mono.Debugger.Soft/MethodEntryEvent.cs
Mono.Debugger.Soft/MethodMirror.cs
Mono.Debugger.Soft/BreakpointEventRequest.cs
Mono.Debugger.Soft/MethodEntryEventRequest.cs
Mono.Debugger.Soft/AssemblyLoadEventRequest.cs
Mono.Debugger.Soft/LocalVariable.cs
Mono.Debugger.Soft/LocalScope.cs
Mono.Debugger.Soft/ParameterInfoMirror.cs
Mono.Debugger.Soft/Event.cs
Mono.Debugger.Soft/EventSet.cs
Mono.Debugger.Soft/AppDomainCreateEvent.cs
Mono.Debugger.Soft/ThreadDeathEvent.cs
Mono.Debugger.Soft/SuspendPolicy.cs
Mono.Debugger.Soft/VirtualMachineManager.cs
Mono.Debugger.Soft/MethodExitEvent.cs
Mono.Debugger.Soft/MethodExitEventRequest.cs
Mono.Debugger.Soft/EventQueueImpl.cs
Mono.Debugger.Soft/ObjectMirror.cs
Mono.Debugger.Soft/Value.cs
Mono.Debugger.Soft/StepEvent.cs
Mono.Debugger.Soft/Location.cs
Mono.Debugger.Soft/ObjectCollectedException.cs
Mono.Debugger.Soft/EventRequest.cs
Mono.Debugger.Soft/InvalidStackFrameException.cs
Mono.Debugger.Soft/BreakpointEvent.cs
Mono.Debugger.Soft/StringMirror.cs
Mono.Debugger.Soft/PropertyInfoMirror.cs
Mono.Debugger.Soft/ArrayMirror.cs
Mono.Debugger.Soft/StepEventRequest.cs
Mono.Debugger.Soft/Connection.cs
Mono.Debugger.Soft/ThreadMirror.cs
Mono.Debugger.Soft/TypeLoadEvent.cs
Mono.Debugger.Soft/TypeLoadEventRequest.cs
Mono.Debugger.Soft/VMDisconnectEvent.cs
Mono.Debugger.Soft/InvokeOptions.cs
Mono.Debugger.Soft/IInvokeAsyncResult.cs
Mono.Debugger.Soft/ITargetProcess.cs
Mono.Debugger.Soft/AbsentInformationException.cs
Mono.Debugger.Soft/UserBreakEvent.cs
Mono.Debugger.Soft/UserLogEvent.cs
Mono.Debugger.Soft/ILInterpreter.cs

```

`Mono.Debugger.Soft/AbsentInformationException.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class AbsentInformationException : Exception {
		
		public AbsentInformationException () : base ("Debug information is not available for this frame.") {
		}
	}
}

```

`Mono.Debugger.Soft/AppDomainCreateEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class AppDomainCreateEvent : Event {
		AppDomainMirror domain;
		long id;

		internal AppDomainCreateEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.AppDomainCreate, vm, req_id, thread_id) {
			this.id = id;
		}

		public AppDomainMirror Domain {
			get {
				if (domain == null)
					domain = vm.GetDomain (id);
				return domain;
			}
		}
	}
}

```

`Mono.Debugger.Soft/AppDomainMirror.cs`:

```cs
using System;
using System.Threading;

namespace Mono.Debugger.Soft
{
	public class AppDomainMirror : Mirror
	{
		string friendly_name;
		AssemblyMirror entry_assembly, corlib;
		AssemblyMirror[] assemblies;
		bool assembliesCacheIsInvalid = true;
		object assembliesCacheLocker = new object ();

		internal AppDomainMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		public string FriendlyName {
			get {
				/* The name can't be empty during domain creation */
				if (friendly_name == null || friendly_name == String.Empty)
					friendly_name = vm.conn.Domain_GetName (id);
				return friendly_name;
			}
	    }

		internal void InvalidateAssembliesCache () {
			assembliesCacheIsInvalid = true;
		}

		public AssemblyMirror[] GetAssemblies () {
			if (assembliesCacheIsInvalid) {
				lock (assembliesCacheLocker) {
					if (assembliesCacheIsInvalid) {
						long[] ids = vm.conn.Domain_GetAssemblies (id);
						assemblies = new AssemblyMirror [ids.Length];
						// FIXME: Uniqueness
						for (int i = 0; i < ids.Length; ++i)
							assemblies [i] = vm.GetAssembly (ids [i]);
						Thread.MemoryBarrier ();
						assembliesCacheIsInvalid = false;
					}
				}
			}
			return assemblies;
		}

		// This returns null when called before the first AssemblyLoad event
		public AssemblyMirror GetEntryAssembly () {
			if (entry_assembly == null) {
				long ass_id = vm.conn.Domain_GetEntryAssembly (id);

				entry_assembly = vm.GetAssembly (ass_id);
			}
			return entry_assembly;
	    }

		public AssemblyMirror Corlib {
			get {
				if (corlib == null) {
					long ass_id = vm.conn.Domain_GetCorlib (id);

					corlib = vm.GetAssembly (ass_id);
				}
				return corlib;
			}
	    }

		public StringMirror CreateString (string s) {
			if (s == null)
				throw new ArgumentNullException ("s");

			return vm.GetObject<StringMirror> (vm.conn.Domain_CreateString (id, s));
		}

		public ObjectMirror CreateBoxedValue (Value value) {
			if (value == null)
				throw new ArgumentNullException ("value");
			if (!(value is PrimitiveValue) && !(value is StructMirror))
				throw new ArgumentException ("Value must be a PrimitiveValue or a StructMirror", "value");
			if ((value is PrimitiveValue) && (value as PrimitiveValue).Value == null)
				return null;

			TypeMirror t = null;
			if (value is PrimitiveValue)
				t = GetCorrespondingType ((value as PrimitiveValue).Value.GetType ());
			else
				t = (value as StructMirror).Type;

			return vm.GetObject<ObjectMirror> (vm.conn.Domain_CreateBoxedValue (id, t.Id, vm.EncodeValue (value)));
		}

		TypeMirror[] primitiveTypes = new TypeMirror [32];
		
		public TypeMirror GetCorrespondingType (Type t) {
			if (t == null)
				throw new ArgumentNullException ("t");
			TypeCode tc = Type.GetTypeCode (t);

			if (tc == TypeCode.Empty || tc == TypeCode.Object)
				throw new ArgumentException ("t must be a primitive type", "t");

			int tc_index = (int)tc;
			if (primitiveTypes [tc_index] == null) {
				primitiveTypes [tc_index] = Corlib.GetType ("System." + t.Name, false, false);
				if (primitiveTypes [tc_index] == null)
					throw new NotImplementedException ();
			}
			return primitiveTypes [tc_index];
		}
    }
}

```

`Mono.Debugger.Soft/AppDomainUnloadEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class AppDomainUnloadEvent : Event {
		AppDomainMirror domain;
		long id;

		internal AppDomainUnloadEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.AppDomainUnload, vm, req_id, thread_id) {
			this.id = id;
		}

		public AppDomainMirror Domain {
			get {
				if (domain == null)
					domain = vm.GetDomain (id);
				return domain;
			}
		}
	}
}

```

`Mono.Debugger.Soft/ArrayMirror.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public class ArrayMirror : ObjectMirror, IEnumerable {

		public int[] lengths;
		public int[] lower_bounds;
		public int rank;

		internal ArrayMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		internal ArrayMirror (VirtualMachine vm, long id, TypeMirror type, AppDomainMirror domain) : base (vm, id, type, domain) {
		}

		public int Length {
			get {
				GetLengths ();

				int length = lengths [0];

				for (int i = 1; i < Rank; i++) {
					length *= lengths [i];
				}

				return length;
			}
		}

		public int Rank {
			get {
				GetLengths ();

				return rank;
			}
		}

		public int GetLength (int dimension) {
			GetLengths ();

			if (dimension < 0 || dimension >= Rank)
				throw new ArgumentOutOfRangeException ("dimension");

			return lengths [dimension];
		}

		public int GetLowerBound (int dimension) {
			GetLengths ();

			if (dimension < 0 || dimension >= Rank)
				throw new ArgumentOutOfRangeException ("dimension");

			return lower_bounds [dimension];
		}

		void GetLengths () {
			if (lengths == null)
				lengths = vm.conn.Array_GetLength (id, out this.rank, out this.lower_bounds);
		}

		public Value this [int index] {
			get {
				// FIXME: Multiple dimensions
				if (index < 0 || index > Length - 1)
					throw new IndexOutOfRangeException ();
				return vm.DecodeValue (vm.conn.Array_GetValues (id, index, 1) [0]);
			}
			set {
				// FIXME: Multiple dimensions
				if (index < 0 || index > Length - 1)
					throw new IndexOutOfRangeException ();
				vm.conn.Array_SetValues (id, index, new ValueImpl [] { vm.EncodeValue (value) });
			}
		}

		public IList<Value> GetValues (int index, int length) {
			// FIXME: Multiple dimensions
				if (index < 0 || index > Length - length)
					throw new IndexOutOfRangeException ();
			return vm.DecodeValues (vm.conn.Array_GetValues (id, index, length));
		}

		public void SetValues (int index, Value[] values) {
			if (values == null)
				throw new ArgumentNullException ("values");
			// FIXME: Multiple dimensions
			if (index < 0 || index > Length - values.Length)
				throw new IndexOutOfRangeException ();
			vm.conn.Array_SetValues (id, index, vm.EncodeValues (values));
		}

		IEnumerator IEnumerable.GetEnumerator ()
		{
			return new SimpleEnumerator (this);
		}

		internal class SimpleEnumerator : IEnumerator, ICloneable
		{
			ArrayMirror arr;
			int pos, length;

			public SimpleEnumerator (ArrayMirror arr)
			{
				this.arr = arr;
				this.pos = -1;
				this.length = arr.Length;
			}

			public object Current {
				get {
					if (pos < 0 )
						throw new InvalidOperationException ("Enumeration has not started.");
					if  (pos >= length)
						throw new InvalidOperationException ("Enumeration has already ended");
					return arr [pos];
				}
			}

			public bool MoveNext()
			{
				if (pos < length)
					pos++;
				if(pos < length)
					return true;
				else
					return false;
			}

			public void Reset()
			{
				pos = -1;
			}

			public object Clone ()
			{
				return MemberwiseClone ();
			}
		}
	}
}

```

`Mono.Debugger.Soft/AssemblyLoadEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class AssemblyLoadEvent : Event {
		AssemblyMirror assembly;
		long id;

		internal AssemblyLoadEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.AssemblyLoad, vm, req_id, thread_id) {
			this.id = id;
		}

		public AssemblyMirror Assembly {
			get {
				if (assembly == null)
					assembly = vm.GetAssembly (id);
				return assembly;
			}
		}
	}
}

```

`Mono.Debugger.Soft/AssemblyLoadEventRequest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mono.Debugger.Soft
{
	public sealed class AssemblyLoadEventRequest : EventRequest {		
		internal AssemblyLoadEventRequest (VirtualMachine vm) : base (vm, EventType.AssemblyLoad) {
		}
	}
}

```

`Mono.Debugger.Soft/AssemblyMirror.cs`:

```cs
using System;
using System.Reflection;
using Mono.Debugger;
using Mono.Cecil;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public class AssemblyMirror : Mirror
	{
		string location;
		MethodMirror entry_point;
		bool entry_point_set;
		ModuleMirror main_module;
		AssemblyName aname;
		AssemblyDefinition meta;
		AppDomainMirror domain;
		Dictionary<string, long> typeCacheIgnoreCase = new Dictionary<string, long> (StringComparer.InvariantCultureIgnoreCase);
		Dictionary<string, long> typeCache = new Dictionary<string, long> ();

		internal AssemblyMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		public string Location {
			get {
				if (location == null)
					location = vm.conn.Assembly_GetLocation (id);
				return location;
			}
	    }

		public MethodMirror EntryPoint {
			get {
				if (!entry_point_set) {
					long mid = vm.conn.Assembly_GetEntryPoint (id);

					if (mid != 0)
						entry_point = vm.GetMethod (mid);
					entry_point_set = true;
				}
				return entry_point;
			}
	    }

		public ModuleMirror ManifestModule {
			get {
				if (main_module == null) {
					main_module = vm.GetModule (vm.conn.Assembly_GetManifestModule (id));
				}
				return main_module;
			}
		}

		// Since Protocol version 2.45
		public AppDomainMirror Domain {
			get {
				if (domain == null) {
					vm.CheckProtocolVersion (2, 45);
					domain = vm.GetDomain (vm.conn.Assembly_GetIdDomain (id));
				}
				return domain;
			}
		}

		public virtual AssemblyName GetName () {
			if (aname == null) {
				string name = vm.conn.Assembly_GetName (id);
				aname = new AssemblyName (name);
			}
			return aname;
		}

		public ObjectMirror GetAssemblyObject () {
			return vm.GetObject (vm.conn.Assembly_GetObject (id));
		}

		public TypeMirror GetType (string name, bool throwOnError, bool ignoreCase)
		{
			if (name == null)
				throw new ArgumentNullException ("name");
			if (name.Length == 0)
				throw new ArgumentException ("name", "Name cannot be empty");

			if (throwOnError)
				throw new NotImplementedException ();
			long typeId;
			if (ignoreCase) {
				if (!typeCacheIgnoreCase.TryGetValue (name, out typeId)) {
					typeId = vm.conn.Assembly_GetType (id, name, ignoreCase);
					typeCacheIgnoreCase.Add (name, typeId);
					var type = vm.GetType (typeId);
					if (type != null) {
						typeCache.Add (type.FullName, typeId);
					}
					return type;
				}
			} else {
				if (!typeCache.TryGetValue (name, out typeId)) {
					typeId = vm.conn.Assembly_GetType (id, name, ignoreCase);
					typeCache.Add (name, typeId);
				}
			}
			return vm.GetType (typeId);
		}

		public TypeMirror GetType (String name, Boolean throwOnError)
		{
			return GetType (name, throwOnError, false);
		}

		public TypeMirror GetType (String name) {
			return GetType (name, false, false);
		}

		/* 
		 * An optional Cecil assembly which could be used to access metadata instead
		 * of reading it from the debuggee.
		 */
		public AssemblyDefinition Metadata {
			get {
				return meta;
			}
			set {
				if (value.MainModule.Name != ManifestModule.Name)
					throw new ArgumentException ("The supplied assembly is named '" + value.MainModule.Name + "', while the assembly in the debuggee is named '" + ManifestModule.Name + "'.");
				if (value.MainModule.Mvid != ManifestModule.ModuleVersionId)
					throw new ArgumentException ("The supplied assembly's main module has guid '" + value.MainModule.Mvid + ", while the assembly in the debuggee has guid '" + ManifestModule.ModuleVersionId + "'.", "value");
				meta = value;
			}
		}
    }
}

```

`Mono.Debugger.Soft/AssemblyUnloadEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class AssemblyUnloadEvent : Event {
		AssemblyMirror assembly;
		long id;

		internal AssemblyUnloadEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.AssemblyUnload, vm, req_id, thread_id) {
			this.id = id;
		}

		public AssemblyMirror Assembly {
			get {
				if (assembly == null)
					assembly = vm.GetAssembly (id);
				return assembly;
			}
		}
	}
}

```

`Mono.Debugger.Soft/BreakpointEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class BreakpointEvent : Event {
		MethodMirror method;
		long id;

		internal BreakpointEvent (VirtualMachine vm, int req_id, long thread_id, long id, long loc) : base (EventType.Breakpoint, vm, req_id, thread_id) {
			this.id = id;
		}

		public MethodMirror Method {
			get {
				if (method == null)
					method = vm.GetMethod (id);
				return method;
			}
		}
	}
}

```

`Mono.Debugger.Soft/BreakpointEventRequest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mono.Debugger.Soft
{
	public sealed class BreakpointEventRequest : EventRequest {

		MethodMirror method;
		long location;
		
		internal BreakpointEventRequest (VirtualMachine vm, MethodMirror method, long location) : base (vm, EventType.Breakpoint) {
			if (method == null)
				throw new ArgumentNullException ("method");
			CheckMirror (vm, method);
			if (method.Locations.Count > 0 && !method.Locations.Any (l => l.ILOffset == location))
				throw new ArgumentException ("A breakpoint can only be set at an IL offset which is equal to the ILOffset property of one of the locations in method.Locations", "location");
			this.method = method;
			this.location = location;
		}

		public override void Enable () {
			var mods = new List <Modifier> ();
			mods.Add (new LocationModifier () { Method = method.Id, Location = location });
			SendReq (mods);
		}
	}
}
```

`Mono.Debugger.Soft/Connection.cs`:

```cs
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class VersionInfo {
		public string VMVersion {
			get; set;
		}

		public int MajorVersion {
			get; set;
		}

		public int MinorVersion {
			get; set;
		}

		/*
		 * Check that this version is at least major:minor
		 */
		public bool AtLeast (int major, int minor) {
			if ((MajorVersion > major) || ((MajorVersion == major && MinorVersion >= minor)))
				return true;
			else
				return false;
		}
	}

	struct SourceInfo {
		public string source_file;
		public byte[] hash;
	}

	class DebugInfo {
		public int max_il_offset;
		public int[] il_offsets;
		public int[] line_numbers;
		public int[] column_numbers;
		public int[] end_line_numbers;
		public int[] end_column_numbers;
		public SourceInfo[] source_files;
	}

	struct FrameInfo {
		public long id;
		public long method;
		public int il_offset;
		public StackFrameFlags flags;
	}

	class TypeInfo {
		public string ns, name, full_name;
		public long assembly, module, base_type, element_type;
		public int token, rank, attributes;
		public bool is_byref, is_pointer, is_primitive, is_valuetype, is_enum;
		public bool is_gtd, is_generic_type;
		public long[] nested;
		public long gtd;
		public long[] type_args;
	}

	struct IfaceMapInfo {
		public long iface_id;
		public long[] iface_methods;
		public long[] target_methods;
	}

	class MethodInfo {
		public int attributes, iattributes, token;
		public bool is_gmd, is_generic_method;
		public long gmd;
		public long[] type_args;
	}

	class MethodBodyInfo {
		public byte[] il;
		public ExceptionClauseInfo[] clauses;
	}

	struct ExceptionClauseInfo {
		public ExceptionClauseFlags flags;
		public int try_offset;
		public int try_length;
		public int handler_offset;
		public int handler_length;
		public int filter_offset;
		public long catch_type_id;
	}

	[Flags]
	enum ExceptionClauseFlags {
		None = 0x0,
		Filter = 0x1,
		Finally = 0x2,
		Fault = 0x4,
	}

	struct ParamInfo {
		public int call_conv;
		public int param_count;
		public int generic_param_count;
		public long ret_type;
		public long[] param_types;
		public string[] param_names;
	}

	struct LocalsInfo {
		public long[] types;
		public string[] names;
		public int[] live_range_start;
		public int[] live_range_end;
		public int[] scopes_start;
		public int[] scopes_end;
	}

	struct PropInfo {
		public long id;
		public string name;
		public long get_method, set_method;
		public int attrs;
	}

	class CattrNamedArgInfo {
		public bool is_property;
		public long id;
		public ValueImpl value;
	}

	class CattrInfo {
		public long ctor_id;
		public ValueImpl[] ctor_args;
		public CattrNamedArgInfo[] named_args;
	}

	class ThreadInfo {
		public bool is_thread_pool;
	}

	struct ObjectRefInfo {
		public long type_id;
		public long domain_id;
	}

	enum ValueTypeId {
		VALUE_TYPE_ID_NULL = 0xf0,
		VALUE_TYPE_ID_TYPE = 0xf1,
		VALUE_TYPE_ID_PARENT_VTYPE = 0xf2
	}

	[Flags]
	enum InvokeFlags {
		NONE = 0,
		DISABLE_BREAKPOINTS = 1,
		SINGLE_THREADED = 2,
		OUT_THIS = 4,
		OUT_ARGS = 8,
		VIRTUAL = 16,
	}

	enum ElementType {
		End		 = 0x00,
		Void		= 0x01,
		Boolean	 = 0x02,
		Char		= 0x03,
		I1		  = 0x04,
		U1		  = 0x05,
		I2		  = 0x06,
		U2		  = 0x07,
		I4		  = 0x08,
		U4		  = 0x09,
		I8		  = 0x0a,
		U8		  = 0x0b,
		R4		  = 0x0c,
		R8		  = 0x0d,
		String	  = 0x0e,
		Ptr		 = 0x0f,
		ByRef	   = 0x10,
		ValueType   = 0x11,
		Class	   = 0x12,
		Var        = 0x13,
		Array	   = 0x14,
		GenericInst = 0x15,
		TypedByRef  = 0x16,
		I		   = 0x18,
		U		   = 0x19,
		FnPtr	   = 0x1b,
		Object	  = 0x1c,
		SzArray	 = 0x1d,
		MVar       = 0x1e,
		CModReqD	= 0x1f,
		CModOpt	 = 0x20,
		Internal	= 0x21,
		Modifier	= 0x40,
		Sentinel	= 0x41,
		Pinned	  = 0x45,

		Type		= 0x50,
		Boxed	   = 0x51,
		Enum		= 0x55
	}

	class ValueImpl {
		public ElementType Type; /* or one of the VALUE_TYPE_ID constants */
		public long Objid;
		public object Value;
		public long Klass; // For ElementType.ValueType
		public ValueImpl[] Fields; // for ElementType.ValueType
		public bool IsEnum; // For ElementType.ValueType
		public long Id; /* For VALUE_TYPE_ID_TYPE */
		public int Index; /* For VALUE_TYPE_PARENT_VTYPE */
	}

	class ModuleInfo {
		public string Name, ScopeName, FQName, Guid;
		public long Assembly;
	}		

	class FieldMirrorInfo {
		public string Name;
		public long Parent, TypeId;
		public int Attrs;
	}

	enum TokenType {
		STRING = 0,
		TYPE = 1,
		FIELD = 2,
		METHOD = 3,
		UNKNOWN = 4
	}

	[Flags]
	enum StackFrameFlags {
		NONE = 0,
		DEBUGGER_INVOKE = 1,
		NATIVE_TRANSITION = 2
	}

	class ResolvedToken {
		public TokenType Type;
		public string Str;
		public long Id;
	}

	class Modifier {
	}

	class CountModifier : Modifier {
		public int Count {
			get; set;
		}
	}

	class LocationModifier : Modifier {
		public long Method {
			get; set;
		}

		public long Location {
			get; set;
		}
	}

	class StepModifier : Modifier {
		public long Thread {
			get; set;
		}

		public int Depth {
			get; set;
		}

		public int Size {
			get; set;
		}

		public int Filter {
			get; set;
		}
	}

	class ThreadModifier : Modifier {
		public long Thread {
			get; set;
		}
	}

	class ExceptionModifier : Modifier {
		public long Type {
			get; set;
		}
		public bool Caught {
			get; set;
		}
		public bool Uncaught {
			get; set;
		}
		public bool Subclasses {
			get; set;
		}
	}

	class AssemblyModifier : Modifier {
		public long[] Assemblies {
			get; set;
		}
	}

	class SourceFileModifier : Modifier {
		public string[] SourceFiles {
			get; set;
		}
	}

	class TypeNameModifier : Modifier {
		public string[] TypeNames {
			get; set;
		}
	}

	class EventInfo {
		public EventType EventType {
			get; set;
		}

		public int ReqId {
			get; set;
		}

		public SuspendPolicy SuspendPolicy {
			get; set;
		}

		public long ThreadId {
			get; set;
		}

		public long Id {
			get; set;
		}

		public long Location {
			get; set;
		}

		public int Level {
			get; set;
		}

		public string Category {
			get; set;
		}

		public string Message {
			get; set;
		}

		public int ExitCode {
			get; set;
		}

		public EventInfo (EventType type, int req_id) {
			EventType = type;
			ReqId = req_id;
		}
	}

	public enum ErrorCode {
		NONE = 0,
		INVALID_OBJECT = 20,
		INVALID_FIELDID = 25,
		INVALID_FRAMEID = 30,
		NOT_IMPLEMENTED = 100,
		NOT_SUSPENDED = 101,
		INVALID_ARGUMENT = 102,
		ERR_UNLOADED = 103,
		ERR_NO_INVOCATION = 104,
		ABSENT_INFORMATION = 105,
		NO_SEQ_POINT_AT_IL_OFFSET = 106,
		INVOKE_ABORTED = 107
	}

	public class ErrorHandlerEventArgs : EventArgs {

		public ErrorCode ErrorCode {
			get; set;
		}
	}

	/*
	 * Represents the connection to the debuggee
	 */
	public abstract class Connection
	{
		/*
		 * The protocol and the packet format is based on JDWP, the differences 
		 * are in the set of supported events, and the commands.
		 */
		internal const string HANDSHAKE_STRING = "DWP-Handshake";

		internal const int HEADER_LENGTH = 11;

		static readonly bool EnableConnectionLogging = !String.IsNullOrEmpty (Environment.GetEnvironmentVariable ("MONO_SDB_LOG"));
		static int ConnectionId;
		readonly StreamWriter LoggingStream;

		/*
		 * Th version of the wire-protocol implemented by the library. The library
		 * and the debuggee can communicate if they implement the same major version.
		 * If they implement a different minor version, they can communicate, but some
		 * features might not be available. This allows older clients to communicate
		 * with newer runtimes, and vice versa.
		 */
		internal const int MAJOR_VERSION = 2;
		internal const int MINOR_VERSION = 45;

		enum WPSuspendPolicy {
			NONE = 0,
			EVENT_THREAD = 1,
			ALL = 2
		}

		enum CommandSet {
			VM = 1,
			OBJECT_REF = 9,
			STRING_REF = 10,
			THREAD = 11,
			ARRAY_REF = 13,
			EVENT_REQUEST = 15,
			STACK_FRAME = 16,
			APPDOMAIN = 20,
			ASSEMBLY = 21,
			METHOD = 22,
			TYPE = 23,
			MODULE = 24,
			FIELD = 25,
			EVENT = 64
		}

		enum EventKind {
			VM_START = 0,
			VM_DEATH = 1,
			THREAD_START = 2,
			THREAD_DEATH = 3,
			APPDOMAIN_CREATE = 4, // Not in JDI
			APPDOMAIN_UNLOAD = 5, // Not in JDI
			METHOD_ENTRY = 6,
			METHOD_EXIT = 7,
			ASSEMBLY_LOAD = 8,
			ASSEMBLY_UNLOAD = 9,
			BREAKPOINT = 10,
			STEP = 11,
			TYPE_LOAD = 12,
			EXCEPTION = 13,
			KEEPALIVE = 14,
			USER_BREAK = 15,
			USER_LOG = 16
		}

		enum ModifierKind {
			COUNT = 1,
			THREAD_ONLY = 3,
			LOCATION_ONLY = 7,
			EXCEPTION_ONLY = 8,
			STEP = 10,
			ASSEMBLY_ONLY = 11,
			SOURCE_FILE_ONLY = 12,
			TYPE_NAME_ONLY = 13
		}

		enum CmdVM {
			VERSION = 1,
			ALL_THREADS = 2,
			SUSPEND = 3,
			RESUME = 4,
			EXIT = 5,
			DISPOSE = 6,
			INVOKE_METHOD = 7,
			SET_PROTOCOL_VERSION = 8,
			ABORT_INVOKE = 9,
			SET_KEEPALIVE = 10,
			GET_TYPES_FOR_SOURCE_FILE = 11,
			GET_TYPES = 12,
			INVOKE_METHODS = 13,
			START_BUFFERING = 14,
			STOP_BUFFERING = 15
		}

		enum CmdEvent {
			COMPOSITE = 100
		}

		enum CmdThread {
			GET_FRAME_INFO = 1,
			GET_NAME = 2,
			GET_STATE = 3,
			GET_INFO = 4,
			/* FIXME: Merge into GET_INFO when the major protocol version is increased */
			GET_ID = 5,
			/* Ditto */
			GET_TID = 6,
			SET_IP = 7
		}

		enum CmdEventRequest {
			SET = 1,
			CLEAR = 2,
			CLEAR_ALL_BREAKPOINTS = 3
		}

		enum CmdAppDomain {
			GET_ROOT_DOMAIN = 1,
			GET_FRIENDLY_NAME = 2,
			GET_ASSEMBLIES = 3,
			GET_ENTRY_ASSEMBLY = 4,
			CREATE_STRING = 5,
			GET_CORLIB = 6,
			CREATE_BOXED_VALUE = 7
		}

		enum CmdAssembly {
			GET_LOCATION = 1,
			GET_ENTRY_POINT = 2,
			GET_MANIFEST_MODULE = 3,
			GET_OBJECT = 4,
			GET_TYPE = 5,
			GET_NAME = 6,
			GET_DOMAIN = 7
		}

		enum CmdModule {
			GET_INFO = 1,
		}

		enum CmdMethod {
			GET_NAME = 1,
			GET_DECLARING_TYPE = 2,
			GET_DEBUG_INFO = 3,
			GET_PARAM_INFO = 4,
			GET_LOCALS_INFO = 5,
			GET_INFO = 6,
			GET_BODY = 7,
			RESOLVE_TOKEN = 8,
			GET_CATTRS = 9,
			MAKE_GENERIC_METHOD = 10
		}

		enum CmdType {
			GET_INFO = 1,
			GET_METHODS = 2,
			GET_FIELDS = 3,
			GET_VALUES = 4,
			GET_OBJECT = 5,
			GET_SOURCE_FILES = 6,
			SET_VALUES = 7,
			IS_ASSIGNABLE_FROM = 8,
			GET_PROPERTIES = 9,
			GET_CATTRS = 10,
			GET_FIELD_CATTRS = 11,
			GET_PROPERTY_CATTRS = 12,
			/* FIXME: Merge into GET_SOURCE_FILES when the major protocol version is increased */
			GET_SOURCE_FILES_2 = 13,
			/* FIXME: Merge into GET_VALUES when the major protocol version is increased */
			GET_VALUES_2 = 14,
			CMD_TYPE_GET_METHODS_BY_NAME_FLAGS = 15,
			GET_INTERFACES = 16,
			GET_INTERFACE_MAP = 17,
			IS_INITIALIZED = 18,
			CREATE_INSTANCE = 19
		}

		enum CmdField {
			GET_INFO = 1
		}

		[Flags]
		enum BindingFlagsExtensions {
			BINDING_FLAGS_IGNORE_CASE = 0x70000000,
		}

		enum CmdStackFrame {
			GET_VALUES = 1,
			GET_THIS = 2,
			SET_VALUES = 3,
			GET_DOMAIN = 4,
			SET_THIS = 5,
		}

		enum CmdArrayRef {
			GET_LENGTH = 1,
			GET_VALUES = 2,
			SET_VALUES = 3
		}

		enum CmdStringRef {
			GET_VALUE = 1,
			GET_LENGTH = 2,
			GET_CHARS = 3
		}

		enum CmdObjectRef {
			GET_TYPE = 1,
			GET_VALUES = 2,
			IS_COLLECTED = 3,
			GET_ADDRESS = 4,
			GET_DOMAIN = 5,
			SET_VALUES = 6,
			GET_INFO = 7,
		}

		class Header {
			public int id;
			public int command_set;
			public int command;
			public int flags;
		}			

		internal static int GetPacketLength (byte[] header) {
			int offset = 0;
			return decode_int (header, ref offset);
		}

		internal static bool IsReplyPacket (byte[] packet) {
			int offset = 8;
			return decode_byte (packet, ref offset) == 0x80;
		}

		internal static int GetPacketId (byte[] packet) {
			int offset = 4;
			return decode_int (packet, ref offset);
		}

		static int decode_byte (byte[] packet, ref int offset) {
			return packet [offset++];
		}

		static int decode_short (byte[] packet, ref int offset) {
			int res = ((int)packet [offset] << 8) | (int)packet [offset + 1];
			offset += 2;
			return res;
		}

		static int decode_int (byte[] packet, ref int offset) {
			int res = ((int)packet [offset] << 24) | ((int)packet [offset + 1] << 16) | ((int)packet [offset + 2] << 8) | (int)packet [offset + 3];
			offset += 4;
			return res;
		}

		static long decode_id (byte[] packet, ref int offset) {
			return decode_int (packet, ref offset);
		}

		static long decode_long (byte[] packet, ref int offset) {
			uint high = (uint)decode_int (packet, ref offset);
			uint low = (uint)decode_int (packet, ref offset);

			return (long)(((ulong)high << 32) | (ulong)low);
		}

		internal static SuspendPolicy decode_suspend_policy (int suspend_policy) {
			switch ((WPSuspendPolicy)suspend_policy) {
			case WPSuspendPolicy.NONE:
				return SuspendPolicy.None;
			case WPSuspendPolicy.EVENT_THREAD:
				return SuspendPolicy.EventThread;
			case WPSuspendPolicy.ALL:
				return SuspendPolicy.All;
			default:
				throw new NotImplementedException ();
			}
		}

		static Header decode_command_header (byte[] packet) {
			int offset = 0;
			Header res = new Header ();

			decode_int (packet, ref offset);
			res.id = decode_int (packet, ref offset);
			res.flags = decode_byte (packet, ref offset);
			res.command_set = decode_byte (packet, ref offset);
			res.command = decode_byte (packet, ref offset);

			return res;
		}

		static void encode_byte (byte[] buf, int b, ref int offset) {
			buf [offset] = (byte)b;
			offset ++;
		}

		static void encode_int (byte[] buf, int i, ref int offset) {
			buf [offset] = (byte)((i >> 24) & 0xff);
			buf [offset + 1] = (byte)((i >> 16) & 0xff);
			buf [offset + 2] = (byte)((i >> 8) & 0xff);
			buf [offset + 3] = (byte)((i >> 0) & 0xff);
			offset += 4;
		}

		static void encode_id (byte[] buf, long id, ref int offset) {
			encode_int (buf, (int)id, ref offset);
		}

		static void encode_long (byte[] buf, long l, ref int offset) {
			encode_int (buf, (int)((l >> 32) & 0xffffffff), ref offset);
			encode_int (buf, (int)(l & 0xffffffff), ref offset);
		}

		internal static byte[] EncodePacket (int id, int commandSet, int command, byte[] data, int dataLen) {
			byte[] buf = new byte [dataLen + 11];
			int offset = 0;
			
			encode_int (buf, buf.Length, ref offset);
			encode_int (buf, id, ref offset);
			encode_byte (buf, 0, ref offset);
			encode_byte (buf, commandSet, ref offset);
			encode_byte (buf, command, ref offset);

			for (int i = 0; i < dataLen; ++i)
				buf [offset + i] = data [i];

			return buf;
		}

		class PacketReader {
			byte[] packet;
			int offset;

			public PacketReader (byte[] packet) {
				this.packet = packet;

				// For event packets
				Header header = decode_command_header (packet);
				CommandSet = (CommandSet)header.command_set;
				Command = header.command;

				// For reply packets
				offset = 0;
				ReadInt (); // length
				ReadInt (); // id
				ReadByte (); // flags
				ErrorCode = ReadShort ();
			}

			public CommandSet CommandSet {
				get; set;
			}

			public int Command {
				get; set;
			}

			public int ErrorCode {
				get; set;
			}

			public int Offset {
				get {
					return offset;
				}
			}

			public int ReadByte () {
				return decode_byte (packet, ref offset);
			}

			public int ReadShort () {
				return decode_short (packet, ref offset);
			}

			public int ReadInt () {
				return decode_int (packet, ref offset);
			}

			public long ReadId () {
				return decode_id (packet, ref offset);
			}

			public long ReadLong () {
				return decode_long (packet, ref offset);
			}

			public float ReadFloat () {
				float f = DataConverter.FloatFromBE (packet, offset);
				offset += 4;
				return f;
			}

			public double ReadDouble () {
				double d = DataConverter.DoubleFromBE (packet, offset);
				offset += 8;
				return d;
			}

			public string ReadString () {
				int len = decode_int (packet, ref offset);
				string res = new String (Encoding.UTF8.GetChars (packet, offset, len));
				offset += len;
				return res;
			}

			public string ReadUTF16String () {
				int len = decode_int (packet, ref offset);
				string res = new String (Encoding.Unicode.GetChars (packet, offset, len));
				offset += len;
				return res;
			}

			public ValueImpl ReadValue () {
				ElementType etype = (ElementType)ReadByte ();

				switch (etype) {
				case ElementType.Void:
					return new ValueImpl { Type = etype };
				case ElementType.I1:
					return new ValueImpl { Type = etype, Value = (sbyte)ReadInt () };
				case ElementType.U1:
					return new ValueImpl { Type = etype, Value = (byte)ReadInt () };
				case ElementType.Boolean:
					return new ValueImpl { Type = etype, Value = ReadInt () != 0 };
				case ElementType.I2:
					return new ValueImpl { Type = etype, Value = (short)ReadInt () };
				case ElementType.U2:
					return new ValueImpl { Type = etype, Value = (ushort)ReadInt () };
				case ElementType.Char:
					return new ValueImpl { Type = etype, Value = (char)ReadInt () };
				case ElementType.I4:
					return new ValueImpl { Type = etype, Value = ReadInt () };
				case ElementType.U4:
					return new ValueImpl { Type = etype, Value = (uint)ReadInt () };
				case ElementType.I8:
					return new ValueImpl { Type = etype, Value = ReadLong () };
				case ElementType.U8:
					return new ValueImpl { Type = etype, Value = (ulong)ReadLong () };
				case ElementType.R4:
					return new ValueImpl { Type = etype, Value = ReadFloat () };
				case ElementType.R8:
					return new ValueImpl { Type = etype, Value = ReadDouble () };
				case ElementType.I:
				case ElementType.U:
				case ElementType.Ptr:
					// FIXME: The client and the debuggee might have different word sizes
					return new ValueImpl { Type = etype, Value = ReadLong () };
				case ElementType.String:
				case ElementType.SzArray:
				case ElementType.Class:
				case ElementType.Array:
				case ElementType.Object:
					long objid = ReadId ();
					return new ValueImpl () { Type = etype, Objid = objid };
				case ElementType.ValueType:
					bool is_enum = ReadByte () == 1;
					long klass = ReadId ();
					long nfields = ReadInt ();
					ValueImpl[] fields = new ValueImpl [nfields];
					for (int i = 0; i < nfields; ++i)
						fields [i] = ReadValue ();
					return new ValueImpl () { Type = etype, Klass = klass, Fields = fields, IsEnum = is_enum };
				case (ElementType)ValueTypeId.VALUE_TYPE_ID_NULL:
					return new ValueImpl { Type = etype };
				case (ElementType)ValueTypeId.VALUE_TYPE_ID_TYPE:
					return new ValueImpl () { Type = etype, Id = ReadId () };
				case (ElementType)ValueTypeId.VALUE_TYPE_ID_PARENT_VTYPE:
					return new ValueImpl () { Type = etype, Index = ReadInt () };
				default:
					throw new NotImplementedException ("Unable to handle type " + etype);
				}
			}

			public long[] ReadIds (int n) {
				long[] res = new long [n];
				for (int i = 0; i < n; ++i)
					res [i] = ReadId ();
				return res;
			}
		}

		class PacketWriter {

			byte[] data;
			int offset;

			public PacketWriter () {
				data = new byte [1024];
				offset = 0;
			}

			void MakeRoom (int size) {
				if (offset + size >= data.Length) {
					int new_len = data.Length * 2;
					while (new_len < offset + size) {
						new_len *= 2;
					}
					byte[] new_data = new byte [new_len];
					Array.Copy (data, new_data, data.Length);
					data = new_data;
				}
			}

			public PacketWriter WriteByte (byte val) {
				MakeRoom (1);
				encode_byte (data, val, ref offset);
				return this;
			}

			public PacketWriter WriteInt (int val) {
				MakeRoom (4);
				encode_int (data, val, ref offset);
				return this;
			}

			public PacketWriter WriteId (long id) {
				MakeRoom (8);
				encode_id (data, id, ref offset);
				return this;
			}

			public PacketWriter WriteLong (long val) {
				MakeRoom (8);
				encode_long (data, val, ref offset);
				return this;
			}

			public PacketWriter WriteFloat (float f) {
				MakeRoom (8);
				byte[] b = DataConverter.GetBytesBE (f);
				for (int i = 0; i < 4; ++i)
					data [offset + i] = b [i];
				offset += 4;
				return this;
			}

			public PacketWriter WriteDouble (double d) {
				MakeRoom (8);
				byte[] b = DataConverter.GetBytesBE (d);
				for (int i = 0; i < 8; ++i)
					data [offset + i] = b [i];
				offset += 8;
				return this;
			}

			public PacketWriter WriteInts (int[] ids) {
				for (int i = 0; i < ids.Length; ++i)
					WriteInt (ids [i]);
				return this;
			}

			public PacketWriter WriteIds (long[] ids) {
				for (int i = 0; i < ids.Length; ++i)
					WriteId (ids [i]);
				return this;
			}

			public PacketWriter WriteString (string s) {
				if (s == null)
					return WriteInt (-1);

				byte[] b = Encoding.UTF8.GetBytes (s);
				MakeRoom (4);
				encode_int (data, b.Length, ref offset);
				MakeRoom (b.Length);
				Buffer.BlockCopy (b, 0, data, offset, b.Length);
				offset += b.Length;
				return this;
			}

			public PacketWriter WriteBool (bool val) {
				WriteByte (val ? (byte)1 : (byte)0);
				return this;
			}

			public PacketWriter WriteValue (ValueImpl v) {
				ElementType t;

				if (v.Value != null)
					t = TypeCodeToElementType (Type.GetTypeCode (v.Value.GetType ()));
				else
					t = v.Type;
				WriteByte ((byte)t);
				switch (t) {
				case ElementType.Boolean:
					WriteInt ((bool)v.Value ? 1 : 0);
					break;
				case ElementType.Char:
					WriteInt ((int)(char)v.Value);
					break;
				case ElementType.I1:
					WriteInt ((int)(sbyte)v.Value);
					break;
				case ElementType.U1:
					WriteInt ((int)(byte)v.Value);
					break;
				case ElementType.I2:
					WriteInt ((int)(short)v.Value);
					break;
				case ElementType.U2:
					WriteInt ((int)(ushort)v.Value);
					break;
				case ElementType.I4:
					WriteInt ((int)(int)v.Value);
					break;
				case ElementType.U4:
					WriteInt ((int)(uint)v.Value);
					break;
				case ElementType.I8:
					WriteLong ((long)(long)v.Value);
					break;
				case ElementType.U8:
					WriteLong ((long)(ulong)v.Value);
					break;
				case ElementType.R4:
					WriteFloat ((float)v.Value);
					break;
				case ElementType.R8:
					WriteDouble ((double)v.Value);
					break;
				case ElementType.String:
				case ElementType.SzArray:
				case ElementType.Class:
				case ElementType.Array:
				case ElementType.Object:
					WriteId (v.Objid);
					break;
				case ElementType.ValueType:
					// FIXME: 
					if (v.IsEnum)
						throw new NotImplementedException ();
					WriteByte (0);
					WriteId (v.Klass);
					WriteInt (v.Fields.Length);
					for (int i = 0; i < v.Fields.Length; ++i)
						WriteValue (v.Fields [i]);
					break;
				case (ElementType)ValueTypeId.VALUE_TYPE_ID_NULL:
					break;
				default:
					throw new NotImplementedException ();
				}

				return this;
			}

			public PacketWriter WriteValues (ValueImpl[] values) {
				for (int i = 0; i < values.Length; ++i)
					WriteValue (values [i]);
				return this;
			}

			public byte[] Data {
				get {
					return data;
				}
			}

			public int Offset {
				get {
					return offset;
				}
			}
		}

		delegate void ReplyCallback (int packet_id, byte[] packet);

		bool closed;
		Thread receiver_thread;
		Dictionary<int, byte[]> reply_packets;
		Dictionary<int, ReplyCallback> reply_cbs;
		Dictionary<int, int> reply_cb_counts;
		object reply_packets_monitor;

		internal event EventHandler<ErrorHandlerEventArgs> ErrorHandler;

		protected Connection () {
			closed = false;
			reply_packets = new Dictionary<int, byte[]> ();
			reply_cbs = new Dictionary<int, ReplyCallback> ();
			reply_cb_counts = new Dictionary<int, int> ();
			reply_packets_monitor = new Object ();
			if (EnableConnectionLogging) {
				var path = Environment.GetEnvironmentVariable ("MONO_SDB_LOG");
				if (path.Contains ("{0}")) {
					//C:\SomeDir\sdbLog{0}.txt -> C:\SomeDir\sdbLog1.txt
					LoggingStream = new StreamWriter (string.Format (path, ConnectionId++), false);
				} else if (Path.HasExtension (path)) {
					//C:\SomeDir\sdbLog.txt -> C:\SomeDir\sdbLog1.txt
					LoggingStream = new StreamWriter (Path.GetDirectoryName (path) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension (path) + ConnectionId++ + "." + Path.GetExtension (path), false);
				} else {
					//C:\SomeDir\sdbLog -> C:\SomeDir\sdbLog1
					LoggingStream = new StreamWriter (path + ConnectionId++, false);
				}
			}
		}
		
		protected abstract int TransportReceive (byte[] buf, int buf_offset, int len);
		protected abstract int TransportSend (byte[] buf, int buf_offset, int len);
		protected abstract void TransportSetTimeouts (int send_timeout, int receive_timeout);
		protected abstract void TransportClose ();

		internal VersionInfo Version;
		
		int Receive (byte[] buf, int buf_offset, int len) {
			int offset = 0;

			while (offset < len) {
				int n = TransportReceive (buf, buf_offset + offset, len - offset);

				if (n == 0)
					return offset;
				offset += n;
			}

			return offset;
		}
		
		// Do the wire protocol handshake
		internal void Connect () {
			byte[] buf = new byte [HANDSHAKE_STRING.Length];
			char[] cbuf = new char [buf.Length];

			// FIXME: Add a timeout
			int n = Receive (buf, 0, buf.Length);
			if (n == 0)
				throw new IOException ("DWP Handshake failed.");
			for (int i = 0; i < buf.Length; ++i)
				cbuf [i] = (char)buf [i];

			if (new String (cbuf) != HANDSHAKE_STRING)
				throw new IOException ("DWP Handshake failed.");
			
			TransportSend (buf, 0, buf.Length);

			receiver_thread = new Thread (new ThreadStart (receiver_thread_main));
			receiver_thread.Name = "SDB Receiver";
			receiver_thread.IsBackground = true;
			receiver_thread.Start ();

			Version = VM_GetVersion ();

			//
			// Tell the debuggee our protocol version, so newer debuggees can work
			// with older clients
			//

			//
			// Older debuggees might not support this request
			EventHandler<ErrorHandlerEventArgs> OrigErrorHandler = ErrorHandler;
			ErrorHandler = null;
			ErrorHandler += delegate (object sender, ErrorHandlerEventArgs args) {
				throw new NotSupportedException ();
			};
			try {
				VM_SetProtocolVersion (MAJOR_VERSION, MINOR_VERSION);
			} catch (NotSupportedException) {
			}
			ErrorHandler = OrigErrorHandler;
		}

		internal byte[] ReadPacket () {
			// FIXME: Throw ClosedConnectionException () if the connection is closed
			// FIXME: Throw ClosedConnectionException () if another thread closes the connection
			// FIXME: Locking
			byte[] header = new byte [HEADER_LENGTH];

			int len = Receive (header, 0, header.Length);
			if (len == 0)
				return new byte [0];
			if (len != HEADER_LENGTH) {
				// FIXME:
				throw new IOException ("Packet of length " + len + " is read.");
			}

			int packetLength = GetPacketLength (header);
			if (packetLength < 11)
				throw new IOException ("Invalid packet length.");

			if (packetLength == 11) {
				return header;
			} else {
				byte[] buf = new byte [packetLength];
				for (int i = 0; i < header.Length; ++i)
					buf [i] = header [i];
				len = Receive (buf, header.Length, packetLength - header.Length);
				if (len != packetLength - header.Length)
					throw new IOException ();
				return buf;
			}
		}

		internal void WritePacket (byte[] packet) {
			// FIXME: Throw ClosedConnectionException () if the connection is closed
			// FIXME: Throw ClosedConnectionException () if another thread closes the connection
			// FIXME: Locking
			TransportSend (packet, 0, packet.Length);
		}

		internal void WritePackets (List<byte[]> packets) {
			// FIXME: Throw ClosedConnectionException () if the connection is closed
			// FIXME: Throw ClosedConnectionException () if another thread closes the connection
			// FIXME: Locking
			int len = 0;
			for (int i = 0; i < packets.Count; ++i)
				len += packets [i].Length;
			byte[] data = new byte [len];
			int pos = 0;
			for (int i = 0; i < packets.Count; ++i) {
				Buffer.BlockCopy (packets [i], 0, data, pos, packets [i].Length);
				pos += packets [i].Length;
			}
			TransportSend (data, 0, data.Length);
		}

		internal void Close () {
			closed = true;
		}

		internal bool IsClosed {
			get {
				return closed;
			}
		}

		bool disconnected;

		internal ManualResetEvent DisconnectedEvent = new ManualResetEvent (false);

		void receiver_thread_main () {
			while (!closed) {
				try {
					bool res = ReceivePacket ();
					if (!res)
						break;
				} catch (ThreadAbortException) {
					break;
				} catch (Exception ex) {
					if (!closed) {
						Console.WriteLine (ex);
					}
					break;
				}
			}

			lock (reply_packets_monitor) {
				disconnected = true;
				DisconnectedEvent.Set ();
				Monitor.PulseAll (reply_packets_monitor);
				TransportClose ();
			}
			EventHandler.VMDisconnect (0, 0, null);
		}

		bool ReceivePacket () {
				byte[] packet = ReadPacket ();

				if (packet.Length == 0) {
					return false;
				}

				if (IsReplyPacket (packet)) {
					int id = GetPacketId (packet);
					ReplyCallback cb = null;
					lock (reply_packets_monitor) {
						reply_cbs.TryGetValue (id, out cb);
						if (cb == null) {
							reply_packets [id] = packet;
							Monitor.PulseAll (reply_packets_monitor);
						} else {
							int c = reply_cb_counts [id];
							c --;
							if (c == 0) {
								reply_cbs.Remove (id);
								reply_cb_counts.Remove (id);
							}
						}
					}

					if (cb != null)
						cb.Invoke (id, packet);
				} else {
					PacketReader r = new PacketReader (packet);

					if (r.CommandSet == CommandSet.EVENT && r.Command == (int)CmdEvent.COMPOSITE) {
						int spolicy = r.ReadByte ();
						int nevents = r.ReadInt ();

						SuspendPolicy suspend_policy = decode_suspend_policy (spolicy);

						EventInfo[] events = new EventInfo [nevents];

						for (int i = 0; i < nevents; ++i) {
							EventKind kind = (EventKind)r.ReadByte ();
							int req_id = r.ReadInt ();

							EventType etype = (EventType)kind;

							long thread_id = r.ReadId ();
							if (kind == EventKind.VM_START) {
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id };
								//EventHandler.VMStart (req_id, thread_id, null);
							} else if (kind == EventKind.VM_DEATH) {
								int exit_code = 0;
								if (Version.AtLeast (2, 27))
									exit_code = r.ReadInt ();
								//EventHandler.VMDeath (req_id, 0, null);
								events [i] = new EventInfo (etype, req_id) { ExitCode = exit_code };
							} else if (kind == EventKind.THREAD_START) {
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = thread_id };
								//EventHandler.ThreadStart (req_id, thread_id, thread_id);
							} else if (kind == EventKind.THREAD_DEATH) {
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = thread_id };
								//EventHandler.ThreadDeath (req_id, thread_id, thread_id);
							} else if (kind == EventKind.ASSEMBLY_LOAD) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.AssemblyLoad (req_id, thread_id, id);
							} else if (kind == EventKind.ASSEMBLY_UNLOAD) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.AssemblyUnload (req_id, thread_id, id);
							} else if (kind == EventKind.TYPE_LOAD) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.TypeLoad (req_id, thread_id, id);
							} else if (kind == EventKind.METHOD_ENTRY) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.MethodEntry (req_id, thread_id, id);
							} else if (kind == EventKind.METHOD_EXIT) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.MethodExit (req_id, thread_id, id);
							} else if (kind == EventKind.BREAKPOINT) {
								long id = r.ReadId ();
								long loc = r.ReadLong ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id, Location = loc };
								//EventHandler.Breakpoint (req_id, thread_id, id, loc);
							} else if (kind == EventKind.STEP) {
								long id = r.ReadId ();
								long loc = r.ReadLong ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id, Location = loc };
								//EventHandler.Step (req_id, thread_id, id, loc);
							} else if (kind == EventKind.EXCEPTION) {
								long id = r.ReadId ();
								long loc = 0; // FIXME
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id, Location = loc };
								//EventHandler.Exception (req_id, thread_id, id, loc);
							} else if (kind == EventKind.APPDOMAIN_CREATE) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.AppDomainCreate (req_id, thread_id, id);
							} else if (kind == EventKind.APPDOMAIN_UNLOAD) {
								long id = r.ReadId ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id };
								//EventHandler.AppDomainUnload (req_id, thread_id, id);
							} else if (kind == EventKind.USER_BREAK) {
								long id = 0;
								long loc = 0;
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Id = id, Location = loc };
								//EventHandler.Exception (req_id, thread_id, id, loc);
							} else if (kind == EventKind.USER_LOG) {
								int level = r.ReadInt ();
								string category = r.ReadString ();
								string message = r.ReadString ();
								events [i] = new EventInfo (etype, req_id) { ThreadId = thread_id, Level = level, Category = category, Message = message };
								//EventHandler.Exception (req_id, thread_id, id, loc);
							} else if (kind == EventKind.KEEPALIVE) {
								events [i] = new EventInfo (etype, req_id) { };
							} else {
								throw new NotImplementedException ("Unknown event kind: " + kind);
							}
						}

						EventHandler.Events (suspend_policy, events);
					}
				}

				return true;
		}

		internal IEventHandler EventHandler {
			get; set;
		}

		static String CommandString (CommandSet command_set, int command)
		{
			string cmd;
			switch (command_set) {
			case CommandSet.VM:
				cmd = ((CmdVM)command).ToString ();
				break;
			case CommandSet.OBJECT_REF:
				cmd = ((CmdObjectRef)command).ToString ();
				break;
			case CommandSet.STRING_REF:
				cmd = ((CmdStringRef)command).ToString ();
				break;
			case CommandSet.THREAD:
				cmd = ((CmdThread)command).ToString ();
				break;
			case CommandSet.ARRAY_REF:
				cmd = ((CmdArrayRef)command).ToString ();
				break;
			case CommandSet.EVENT_REQUEST:
				cmd = ((CmdEventRequest)command).ToString ();
				break;
			case CommandSet.STACK_FRAME:
				cmd = ((CmdStackFrame)command).ToString ();
				break;
			case CommandSet.APPDOMAIN:
				cmd = ((CmdAppDomain)command).ToString ();
				break;
			case CommandSet.ASSEMBLY:
				cmd = ((CmdAssembly)command).ToString ();
				break;
			case CommandSet.METHOD:
				cmd = ((CmdMethod)command).ToString ();
				break;
			case CommandSet.TYPE:
				cmd = ((CmdType)command).ToString ();
				break;
			case CommandSet.MODULE:
				cmd = ((CmdModule)command).ToString ();
				break;
			case CommandSet.FIELD:
				cmd = ((CmdField)command).ToString ();
				break;
			case CommandSet.EVENT:
				cmd = ((CmdEvent)command).ToString ();
				break;
			default:
				cmd = command.ToString ();
				break;
			}
			return string.Format ("[{0} {1}]", command_set, cmd);
		}

		long total_protocol_ticks;

		void LogPacket (int packet_id, byte[] encoded_packet, byte[] reply_packet, CommandSet command_set, int command, Stopwatch watch) {
			watch.Stop ();
			total_protocol_ticks += watch.ElapsedTicks;
			var ts = TimeSpan.FromTicks (total_protocol_ticks);
			string msg = string.Format ("Packet: {0} sent: {1} received: {2} ms: {3} total ms: {4} {5}",
			   packet_id, encoded_packet.Length, reply_packet.Length, watch.ElapsedMilliseconds,
			   (ts.Seconds * 1000) + ts.Milliseconds,
			   CommandString (command_set, command));

			LoggingStream.WriteLine (msg);
			LoggingStream.Flush ();
		}

		bool buffer_packets;
		List<byte[]> buffered_packets = new List<byte[]> ();

		//
		// Start buffering request/response packets on both the client and the debuggee side.
		// Packets sent between StartBuffering ()/StopBuffering () must be async, i.e. sent
		// using Send () and not SendReceive ().
		//
		public void StartBuffering () {
			buffer_packets = true;
			if (Version.AtLeast (2, 34))
				VM_StartBuffering ();
		}

		public void StopBuffering () {
			if (Version.AtLeast (2, 34))
				VM_StopBuffering ();
			buffer_packets = false;

			WritePackets (buffered_packets);
			if (EnableConnectionLogging) {
				LoggingStream.WriteLine (String.Format ("Sent {0} packets.", buffered_packets.Count));
				LoggingStream.Flush ();
			}
			buffered_packets.Clear ();
		}

		/* Send a request and call cb when a result is received */
		int Send (CommandSet command_set, int command, PacketWriter packet, Action<PacketReader> cb, int count) {
			int id = IdGenerator;

			Stopwatch watch = null;
			if (EnableConnectionLogging)
				watch = Stopwatch.StartNew ();

			byte[] encoded_packet;
			if (packet == null)
				encoded_packet = EncodePacket (id, (int)command_set, command, null, 0);
			else
				encoded_packet = EncodePacket (id, (int)command_set, command, packet.Data, packet.Offset);

			if (cb != null) {
				lock (reply_packets_monitor) {
					reply_cbs [id] = delegate (int packet_id, byte[] p) {
						if (EnableConnectionLogging)
							LogPacket (packet_id, encoded_packet, p, command_set, command, watch);
						/* Run the callback on a tp thread to avoid blocking the receive thread */
						PacketReader r = new PacketReader (p);
						cb.BeginInvoke (r, null, null);
					};
					reply_cb_counts [id] = count;
				}
			}

			if (buffer_packets)
				buffered_packets.Add (encoded_packet);
			else
				WritePacket (encoded_packet);

			return id;
		}

		// Send a request without waiting for an answer
		void Send (CommandSet command_set, int command) {
			Send (command_set, command, null, null, 0);
		}

		PacketReader SendReceive (CommandSet command_set, int command, PacketWriter packet) {
			int id = IdGenerator;
			Stopwatch watch = null;

			if (disconnected)
				throw new VMDisconnectedException ();

			if (EnableConnectionLogging)
				watch = Stopwatch.StartNew ();

			byte[] encoded_packet;

			if (packet == null)
				encoded_packet = EncodePacket (id, (int)command_set, command, null, 0);
			else
				encoded_packet = EncodePacket (id, (int)command_set, command, packet.Data, packet.Offset);

			WritePacket (encoded_packet);

			int packetId = id;

			/* Wait for the reply packet */
			while (true) {
				lock (reply_packets_monitor) {
					if (reply_packets.ContainsKey (packetId)) {
						byte[] reply = reply_packets [packetId];
						reply_packets.Remove (packetId);
						PacketReader r = new PacketReader (reply);

						if (EnableConnectionLogging)
							LogPacket (packetId, encoded_packet, reply, command_set, command, watch);
						if (r.ErrorCode != 0) {
							if (ErrorHandler != null)
								ErrorHandler (this, new ErrorHandlerEventArgs () { ErrorCode = (ErrorCode)r.ErrorCode });
							throw new NotImplementedException ("No error handler set.");
						} else {
							return r;
						}
					} else {
						if (disconnected)
							throw new VMDisconnectedException ();
						Monitor.Wait (reply_packets_monitor);
					}
				}
			}
		}

		PacketReader SendReceive (CommandSet command_set, int command) {
			return SendReceive (command_set, command, null);
		}

		int packet_id_generator;

		int IdGenerator {
			get {
				return Interlocked.Increment (ref packet_id_generator);
			}
		}

		CattrInfo[] ReadCattrs (PacketReader r) {
			CattrInfo[] res = new CattrInfo [r.ReadInt ()];
			for (int i = 0; i < res.Length; ++i) {
				CattrInfo info = new CattrInfo ();
				info.ctor_id = r.ReadId ();
				info.ctor_args = new ValueImpl [r.ReadInt ()];
				for (int j = 0; j < info.ctor_args.Length; ++j) {
					info.ctor_args [j] = r.ReadValue ();
				}
				info.named_args = new CattrNamedArgInfo [r.ReadInt ()];
				for (int j = 0; j < info.named_args.Length; ++j) {
					CattrNamedArgInfo arg = new CattrNamedArgInfo ();
					int arg_type = r.ReadByte ();
					arg.is_property = arg_type == 0x54;
					arg.id = r.ReadId ();
					arg.value = r.ReadValue ();
					info.named_args [j] = arg;
				}
				res [i] = info;
			}
			return res;
		}

		static ElementType TypeCodeToElementType (TypeCode c) {
			switch (c) {
			case TypeCode.Boolean:
				return ElementType.Boolean;
			case TypeCode.Char:
				return ElementType.Char;
			case TypeCode.SByte:
				return ElementType.I1;
			case TypeCode.Byte:
				return ElementType.U1;
			case TypeCode.Int16:
				return ElementType.I2;
			case TypeCode.UInt16:
				return ElementType.U2;
			case TypeCode.Int32:
				return ElementType.I4;
			case TypeCode.UInt32:
				return ElementType.U4;
			case TypeCode.Int64:
				return ElementType.I8;
			case TypeCode.UInt64:
				return ElementType.U8;
			case TypeCode.Single:
				return ElementType.R4;
			case TypeCode.Double:
				return ElementType.R8;
			default:
				throw new NotImplementedException ();
			}
		}

		/*
		 * Implementation of debugger commands
		 */

		internal VersionInfo VM_GetVersion () {
			var res = SendReceive (CommandSet.VM, (int)CmdVM.VERSION, null);
			VersionInfo info = new VersionInfo ();
			info.VMVersion = res.ReadString ();
			info.MajorVersion = res.ReadInt ();
			info.MinorVersion = res.ReadInt ();
			return info;
		}

		internal void VM_SetProtocolVersion (int major, int minor) {
			SendReceive (CommandSet.VM, (int)CmdVM.SET_PROTOCOL_VERSION, new PacketWriter ().WriteInt (major).WriteInt (minor));
		}

		internal void VM_GetThreads (Action<long[]> resultCallaback) {
			Send (CommandSet.VM, (int)CmdVM.ALL_THREADS, null, (res) => {
				int len = res.ReadInt ();
				long[] arr = new long [len];
				for (int i = 0; i < len; ++i)
					arr [i] = res.ReadId ();
				resultCallaback(arr);
			}, 1);
		}

		internal void VM_Suspend () {
			SendReceive (CommandSet.VM, (int)CmdVM.SUSPEND);
		}

		internal void VM_Resume () {
			SendReceive (CommandSet.VM, (int)CmdVM.RESUME);
		}

		internal void VM_Exit (int exitCode) {
			SendReceive (CommandSet.VM, (int)CmdVM.EXIT, new PacketWriter ().WriteInt (exitCode));
		}

		internal void VM_Dispose () {
			SendReceive (CommandSet.VM, (int)CmdVM.DISPOSE);
		}

		internal ValueImpl VM_InvokeMethod (long thread, long method, ValueImpl this_arg, ValueImpl[] arguments, InvokeFlags flags, out ValueImpl exc) {
			exc = null;
			PacketReader r = SendReceive (CommandSet.VM, (int)CmdVM.INVOKE_METHOD, new PacketWriter ().WriteId (thread).WriteInt ((int)flags).WriteId (method).WriteValue (this_arg).WriteInt (arguments.Length).WriteValues (arguments));
			if (r.ReadByte () == 0) {
				exc = r.ReadValue ();
				return null;
			} else {
				return r.ReadValue ();
			}
		}

		internal delegate void InvokeMethodCallback (ValueImpl v, ValueImpl exc, ValueImpl out_this, ValueImpl[] out_args, ErrorCode error, object state);

		void read_invoke_res (PacketReader r, out ValueImpl v, out ValueImpl exc, out ValueImpl out_this, out ValueImpl[] out_args) {
			int resflags = r.ReadByte ();
			v = null;
			exc = null;
			out_this = null;
			out_args = null;
			if (resflags == 0) {
				exc = r.ReadValue ();
			} else {
				v = r.ReadValue ();
				if ((resflags & 2) != 0)
					out_this = r.ReadValue ();
				if ((resflags & 4) != 0) {
					int nargs = r.ReadInt ();
					out_args = new ValueImpl [nargs];
					for (int i = 0; i < nargs; ++i)
						out_args [i] = r.ReadValue ();
				}
			}
		}

		internal int VM_BeginInvokeMethod (long thread, long method, ValueImpl this_arg, ValueImpl[] arguments, InvokeFlags flags, InvokeMethodCallback callback, object state) {
			return Send (CommandSet.VM, (int)CmdVM.INVOKE_METHOD, new PacketWriter ().WriteId (thread).WriteInt ((int)flags).WriteId (method).WriteValue (this_arg).WriteInt (arguments.Length).WriteValues (arguments), delegate (PacketReader r) {
					ValueImpl v, exc, out_this = null;
					ValueImpl[] out_args = null;

					if (r.ErrorCode != 0) {
						callback (null, null, null, null, (ErrorCode)r.ErrorCode, state);
					} else {
						read_invoke_res (r, out v, out exc, out out_this, out out_args);
						callback (v, exc, out_this, out_args, 0, state);
					}
				}, 1);
		}

		internal int VM_BeginInvokeMethods (long thread, long[] methods, ValueImpl this_arg, List<ValueImpl[]> arguments, InvokeFlags flags, InvokeMethodCallback callback, object state) {
			// FIXME: Merge this with INVOKE_METHOD
			var w = new PacketWriter ();
			w.WriteId (thread);
			w.WriteInt ((int)flags);
			w.WriteInt (methods.Length);
			for (int i = 0; i < methods.Length; ++i) {
				w.WriteId (methods [i]);
				w.WriteValue (this_arg);
				w.WriteInt (arguments [i].Length);
				w.WriteValues (arguments [i]);
			}
			return Send (CommandSet.VM, (int)CmdVM.INVOKE_METHODS, w, delegate (PacketReader r) {
					ValueImpl v, exc, out_this = null;
					ValueImpl[] out_args = null;

					if (r.ErrorCode != 0) {
						callback (null, null, null, null, (ErrorCode)r.ErrorCode, state);
					} else {
						read_invoke_res (r, out v, out exc, out out_this, out out_args);
						callback (v, exc, out_this, out_args, 0, state);
					}
				}, methods.Length);
		}

		internal void VM_AbortInvoke (long thread, int id)
		{
			SendReceive (CommandSet.VM, (int)CmdVM.ABORT_INVOKE, new PacketWriter ().WriteId (thread).WriteInt (id));
		}

		internal void SetSocketTimeouts (int send_timeout, int receive_timeout, int keepalive_interval)
		{
			TransportSetTimeouts (send_timeout, receive_timeout);
			SendReceive (CommandSet.VM, (int)CmdVM.SET_KEEPALIVE, new PacketWriter ().WriteId (keepalive_interval));
		}

		internal long[] VM_GetTypesForSourceFile (string fname, bool ignoreCase) {
			var res = SendReceive (CommandSet.VM, (int)CmdVM.GET_TYPES_FOR_SOURCE_FILE, new PacketWriter ().WriteString (fname).WriteBool (ignoreCase));
			int count = res.ReadInt ();
			long[] types = new long [count];
			for (int i = 0; i < count; ++i)
				types [i] = res.ReadId ();
			return types;
		}

		internal long[] VM_GetTypes (string name, bool ignoreCase) {
			var res = SendReceive (CommandSet.VM, (int)CmdVM.GET_TYPES, new PacketWriter ().WriteString (name).WriteBool (ignoreCase));
			int count = res.ReadInt ();
			long[] types = new long [count];
			for (int i = 0; i < count; ++i)
				types [i] = res.ReadId ();
			return types;
		}

		internal void VM_StartBuffering () {
			Send (CommandSet.VM, (int)CmdVM.START_BUFFERING);
		}

		internal void VM_StopBuffering () {
			Send (CommandSet.VM, (int)CmdVM.STOP_BUFFERING);
		}

		/*
		 * DOMAIN
		 */

		internal long RootDomain {
			get {
				return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.GET_ROOT_DOMAIN, null).ReadId ();
			}
		}

		internal string Domain_GetName (long id) {
			return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.GET_FRIENDLY_NAME, new PacketWriter ().WriteId (id)).ReadString ();
		}

		internal long[] Domain_GetAssemblies (long id) {
			var res = SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.GET_ASSEMBLIES, new PacketWriter ().WriteId (id));
			int count = res.ReadInt ();
			long[] assemblies = new long [count];
			for (int i = 0; i < count; ++i)
				assemblies [i] = res.ReadId ();
			return assemblies;
		}

		internal long Domain_GetEntryAssembly (long id) {
			return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.GET_ENTRY_ASSEMBLY, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal long Domain_GetCorlib (long id) {
			return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.GET_CORLIB, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal long Domain_CreateString (long id, string s) {
			return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.CREATE_STRING, new PacketWriter ().WriteId (id).WriteString (s)).ReadId ();
		}

		internal long Domain_CreateBoxedValue (long id, long type_id, ValueImpl v) {
			return SendReceive (CommandSet.APPDOMAIN, (int)CmdAppDomain.CREATE_BOXED_VALUE, new PacketWriter ().WriteId (id).WriteId (type_id).WriteValue (v)).ReadId ();
		}

		/*
		 * METHOD
		 */

		internal string Method_GetName (long id) {
			return SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_NAME, new PacketWriter ().WriteId (id)).ReadString ();
		}

		internal long Method_GetDeclaringType (long id) {
			return SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_DECLARING_TYPE, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal DebugInfo Method_GetDebugInfo (long id) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_DEBUG_INFO, new PacketWriter ().WriteId (id));

			DebugInfo info = new DebugInfo ();
			info.max_il_offset = res.ReadInt ();

			SourceInfo[] sources = null;
			if (Version.AtLeast (2, 13)) {
				int n = res.ReadInt ();
				sources = new SourceInfo [n];
				for (int i = 0; i < n; ++i) {
					sources [i].source_file = res.ReadString ();
					if (Version.AtLeast (2, 14)) {
						sources [i].hash = new byte [16];
						for (int j = 0; j < 16; ++j)
							sources [i].hash [j] = (byte)res.ReadByte ();
					}
				}
			} else {
				sources = new SourceInfo [1];
				sources [0].source_file = res.ReadString ();
			}

			int n_il_offsets = res.ReadInt ();
			info.il_offsets = new int [n_il_offsets];
			info.line_numbers = new int [n_il_offsets];
			info.source_files = new SourceInfo [n_il_offsets];
			info.column_numbers = new int [n_il_offsets];
			info.end_line_numbers = new int [n_il_offsets];
			info.end_column_numbers = new int [n_il_offsets];
			for (int i = 0; i < n_il_offsets; ++i) {
				info.il_offsets [i] = res.ReadInt ();
				info.line_numbers [i] = res.ReadInt ();
				if (Version.AtLeast (2, 12)) {
					int idx = res.ReadInt ();
					info.source_files [i] = idx >= 0 ? sources [idx] : default (SourceInfo);
				} else {
					info.source_files [i] = sources [0];
				}
				if (Version.AtLeast (2, 19))
					info.column_numbers [i] = res.ReadInt ();
				else
					info.column_numbers [i] = 0;
				if (Version.AtLeast (2, 32)) {
					info.end_line_numbers [i] = res.ReadInt ();
					info.end_column_numbers [i] = res.ReadInt ();
				} else {
					info.end_column_numbers [i] = -1;
					info.end_column_numbers [i] = -1;
				}
			}

			return info;
		}

		internal ParamInfo Method_GetParamInfo (long id) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_PARAM_INFO, new PacketWriter ().WriteId (id));

			ParamInfo info = new ParamInfo ();
			info.call_conv = res.ReadInt ();
			info.param_count = res.ReadInt ();
			info.generic_param_count = res.ReadInt ();
			info.ret_type = res.ReadId ();
			info.param_types = new long [info.param_count];
			for (int i = 0; i < info.param_count; ++i)
				info.param_types [i] = res.ReadId ();
			info.param_names = new string [info.param_count];			
			for (int i = 0; i < info.param_count; ++i)
				info.param_names [i] = res.ReadString ();

			return info;
		}

		internal LocalsInfo Method_GetLocalsInfo (long id) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_LOCALS_INFO, new PacketWriter ().WriteId (id));

			LocalsInfo info = new LocalsInfo ();

			if (Version.AtLeast (2, 43)) {
				int nscopes = res.ReadInt ();
				info.scopes_start = new int [nscopes];
				info.scopes_end = new int [nscopes];
				int last_start = 0;
				for (int i = 0; i < nscopes; ++i) {
					info.scopes_start [i] = last_start + res.ReadInt ();
					info.scopes_end [i] = info.scopes_start [i] + res.ReadInt ();
					last_start = info.scopes_start [i];
				}
			}

			int nlocals = res.ReadInt ();
			info.types = new long [nlocals];
			for (int i = 0; i < nlocals; ++i)
				info.types [i] = res.ReadId ();
			info.names = new string [nlocals];
			for (int i = 0; i < nlocals; ++i)
				info.names [i] = res.ReadString ();
			info.live_range_start = new int [nlocals];
			info.live_range_end = new int [nlocals];
			for (int i = 0; i < nlocals; ++i) {
				info.live_range_start [i] = res.ReadInt ();
				info.live_range_end [i] = res.ReadInt ();
			}

			return info;
		}

		internal MethodInfo Method_GetInfo (long id) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_INFO, new PacketWriter ().WriteId (id));

			MethodInfo info = new MethodInfo ();
			info.attributes = res.ReadInt ();
			info.iattributes = res.ReadInt ();
			info.token = res.ReadInt ();
			if (Version.AtLeast (2, 12)) {
				int attrs = res.ReadByte ();
				if ((attrs & (1 << 0)) != 0)
					info.is_gmd = true;
				if ((attrs & (1 << 1)) != 0)
					info.is_generic_method = true;
				info.gmd = res.ReadId ();
				if (Version.AtLeast (2, 15)) {
					if (info.is_generic_method) {
						int n = res.ReadInt ();
						info.type_args = res.ReadIds (n);
					}
				}
			}
			return info;
		}

		internal MethodBodyInfo Method_GetBody (long id) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_BODY, new PacketWriter ().WriteId (id));

			MethodBodyInfo info = new MethodBodyInfo ();
			info.il = new byte [res.ReadInt ()];
			for (int i = 0; i < info.il.Length; ++i)
				info.il [i] = (byte)res.ReadByte ();

			if (Version.AtLeast (2, 18)) {
				info.clauses = new ExceptionClauseInfo [res.ReadInt ()];

				for (int i = 0; i < info.clauses.Length; ++i) {
					var clause = new ExceptionClauseInfo {
						flags = (ExceptionClauseFlags) res.ReadInt (),
						try_offset = res.ReadInt (),
						try_length = res.ReadInt (),
						handler_offset = res.ReadInt (),
						handler_length = res.ReadInt (),
					};

					if (clause.flags == ExceptionClauseFlags.None)
						clause.catch_type_id = res.ReadId ();
					else if (clause.flags == ExceptionClauseFlags.Filter)
						clause.filter_offset = res.ReadInt ();

					info.clauses [i] = clause;
				}
			} else
				info.clauses = new ExceptionClauseInfo [0];

			return info;
		}

		internal ResolvedToken Method_ResolveToken (long id, int token) {
			var res = SendReceive (CommandSet.METHOD, (int)CmdMethod.RESOLVE_TOKEN, new PacketWriter ().WriteId (id).WriteInt (token));

			TokenType type = (TokenType)res.ReadByte ();
			switch (type) {
			case TokenType.STRING:
				return new ResolvedToken () { Type = type, Str = res.ReadString () };
			case TokenType.TYPE:
			case TokenType.METHOD:
			case TokenType.FIELD:
				return new ResolvedToken () { Type = type, Id = res.ReadId () };
			case TokenType.UNKNOWN:
				return new ResolvedToken () { Type = type };
			default:
				throw new NotImplementedException ();
			}
		}

		internal CattrInfo[] Method_GetCustomAttributes (long id, long attr_type_id, bool inherit) {
			PacketReader r = SendReceive (CommandSet.METHOD, (int)CmdMethod.GET_CATTRS, new PacketWriter ().WriteId (id).WriteId (attr_type_id));
			return ReadCattrs (r);
		}

		internal long Method_MakeGenericMethod (long id, long[] args) {
			PacketReader r = SendReceive (CommandSet.METHOD, (int)CmdMethod.MAKE_GENERIC_METHOD, new PacketWriter ().WriteId (id).WriteInt (args.Length).WriteIds (args));
			return r.ReadId ();
		}

		/*
		 * THREAD
		 */

		internal string Thread_GetName (long id) {
			return SendReceive (CommandSet.THREAD, (int)CmdThread.GET_NAME, new PacketWriter ().WriteId (id)).ReadString ();
		}

		internal void Thread_GetFrameInfo (long id, int start_frame, int length, Action<FrameInfo[]> resultCallaback) {
			Send (CommandSet.THREAD, (int)CmdThread.GET_FRAME_INFO, new PacketWriter ().WriteId (id).WriteInt (start_frame).WriteInt (length), (res) => {
				int count = res.ReadInt ();
				var frames = new FrameInfo[count];
				for (int i = 0; i < count; ++i) {
					var f = new FrameInfo ();
					f.id = res.ReadInt ();
					f.method = res.ReadId ();
					f.il_offset = res.ReadInt ();
					f.flags = (StackFrameFlags)res.ReadByte ();
					frames [i] = f;
				}
				resultCallaback (frames);
			}, 1);
		}

		internal int Thread_GetState (long id) {
			return SendReceive (CommandSet.THREAD, (int)CmdThread.GET_STATE, new PacketWriter ().WriteId (id)).ReadInt ();
		}

		internal ThreadInfo Thread_GetInfo (long id) {
			PacketReader r = SendReceive (CommandSet.THREAD, (int)CmdThread.GET_INFO, new PacketWriter ().WriteId (id));

			ThreadInfo res = new ThreadInfo () { is_thread_pool = r.ReadByte () > 0 ? true : false };

			return res;
		}

		internal long Thread_GetId (long id) {
			return SendReceive (CommandSet.THREAD, (int)CmdThread.GET_ID, new PacketWriter ().WriteId (id)).ReadLong ();
		}

		internal long Thread_GetTID (long id) {
			return SendReceive (CommandSet.THREAD, (int)CmdThread.GET_TID, new PacketWriter ().WriteId (id)).ReadLong ();
		}

		internal void Thread_SetIP (long id, long method_id, long il_offset) {
			SendReceive (CommandSet.THREAD, (int)CmdThread.SET_IP, new PacketWriter ().WriteId (id).WriteId (method_id).WriteLong (il_offset));
		}

		/*
		 * MODULE
		 */

		internal ModuleInfo Module_GetInfo (long id) {
			PacketReader r = SendReceive (CommandSet.MODULE, (int)CmdModule.GET_INFO, new PacketWriter ().WriteId (id));
			ModuleInfo info = new ModuleInfo { Name = r.ReadString (), ScopeName = r.ReadString (), FQName = r.ReadString (), Guid = r.ReadString (), Assembly = r.ReadId () };
			return info;
		}

		/*
		 * ASSEMBLY
		 */

		internal string Assembly_GetLocation (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_LOCATION, new PacketWriter ().WriteId (id)).ReadString ();
		}

		internal long Assembly_GetEntryPoint (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_ENTRY_POINT, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal long Assembly_GetManifestModule (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_MANIFEST_MODULE, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal long Assembly_GetObject (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_OBJECT, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal long Assembly_GetType (long id, string name, bool ignoreCase) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_TYPE, new PacketWriter ().WriteId (id).WriteString (name).WriteBool (ignoreCase)).ReadId ();
		}

		internal string Assembly_GetName (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_NAME, new PacketWriter ().WriteId (id)).ReadString ();
		}

		internal long Assembly_GetIdDomain (long id) {
			return SendReceive (CommandSet.ASSEMBLY, (int)CmdAssembly.GET_DOMAIN, new PacketWriter ().WriteId (id)).ReadId ();
		}

		/*
		 * TYPE
		 */

		internal TypeInfo Type_GetInfo (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_INFO, new PacketWriter ().WriteId (id));
			TypeInfo res = new TypeInfo ();

			res.ns = r.ReadString ();
			res.name = r.ReadString ();
			res.full_name = r.ReadString ();
			res.assembly = r.ReadId ();
			res.module = r.ReadId ();
			res.base_type = r.ReadId ();
			res.element_type = r.ReadId ();
			res.token = r.ReadInt ();
			res.rank = r.ReadByte ();
			res.attributes = r.ReadInt ();
			int b = r.ReadByte ();
			res.is_byref = (b & 1) != 0;
			res.is_pointer = (b & 2) != 0;
			res.is_primitive = (b & 4) != 0;
			res.is_valuetype = (b & 8) != 0;
			res.is_enum = (b & 16) != 0;
			res.is_gtd = (b & 32) != 0;
			res.is_generic_type = (b & 64) != 0;

			int nested_len = r.ReadInt ();
			res.nested = new long [nested_len];
			for (int i = 0; i < nested_len; ++i)
				res.nested [i] = r.ReadId ();

			if (Version.AtLeast (2, 12))
				res.gtd = r.ReadId ();
			if (Version.AtLeast (2, 15) && res.is_generic_type) {
				int n = r.ReadInt ();
				res.type_args = r.ReadIds (n);
			}

			return res;
		}

		internal long[] Type_GetMethods (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_METHODS, new PacketWriter ().WriteId (id));

			int n = r.ReadInt ();
			long[] res = new long [n];
			for (int i = 0; i < n; ++i)
				res [i] = r.ReadId ();
			return res;
		}

		internal long[] Type_GetFields (long id, out string[] names, out long[] types, out int[] attrs) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_FIELDS, new PacketWriter ().WriteId (id));

			int n = r.ReadInt ();
			long[] res = new long [n];
			names = new string [n];
			types = new long [n];
			attrs = new int [n];
			for (int i = 0; i < n; ++i) {
				res [i] = r.ReadId ();
				names [i] = r.ReadString ();
				types [i] = r.ReadId ();
				attrs [i] = r.ReadInt ();
			}
			return res;
		}

		internal PropInfo[] Type_GetProperties (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_PROPERTIES, new PacketWriter ().WriteId (id));

			int n = r.ReadInt ();
			PropInfo[] res = new PropInfo [n];
			for (int i = 0; i < n; ++i) {
				res [i] = new PropInfo ();
				res [i].id = r.ReadId ();
				res [i].name = r.ReadString ();
				res [i].get_method = r.ReadId ();
				res [i].set_method = r.ReadId ();
				res [i].attrs = r.ReadInt ();
			}

			return res;
		}

		internal long Type_GetObject (long id) {
			return SendReceive (CommandSet.TYPE, (int)CmdType.GET_OBJECT, new PacketWriter ().WriteId (id)).ReadId ();
		}

		internal ValueImpl[] Type_GetValues (long id, long[] fields, long thread_id) {
			int len = fields.Length;
			PacketReader r;
			if (thread_id != 0 && Version.AtLeast(2, 3))
				r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_VALUES_2, new PacketWriter ().WriteId (id).WriteId (thread_id).WriteInt (len).WriteIds (fields));
			else
				r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_VALUES, new PacketWriter ().WriteId (id).WriteInt (len).WriteIds (fields));

			ValueImpl[] res = new ValueImpl [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadValue ();
			return res;
		}			

		internal void Type_SetValues (long id, long[] fields, ValueImpl[] values) {
			SendReceive (CommandSet.TYPE, (int)CmdType.SET_VALUES, new PacketWriter ().WriteId (id).WriteInt (fields.Length).WriteIds (fields).WriteValues (values));
		}

		internal string[] Type_GetSourceFiles (long id, bool return_full_paths) {
			var r = SendReceive (CommandSet.TYPE, return_full_paths ? (int)CmdType.GET_SOURCE_FILES_2 : (int)CmdType.GET_SOURCE_FILES, new PacketWriter ().WriteId (id));
			int len = r.ReadInt ();
			string[] res = new string [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadString ();
			return res;
		}

		internal bool Type_IsAssignableFrom (long id, long c_id) {
			return SendReceive (CommandSet.TYPE, (int)CmdType.IS_ASSIGNABLE_FROM, new PacketWriter ().WriteId (id).WriteId (c_id)).ReadByte () > 0;
		}

		internal CattrInfo[] Type_GetCustomAttributes (long id, long attr_type_id, bool inherit) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_CATTRS, new PacketWriter ().WriteId (id).WriteId (attr_type_id));
			return ReadCattrs (r);
		}

		internal CattrInfo[] Type_GetFieldCustomAttributes (long id, long field_id, long attr_type_id, bool inherit) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_FIELD_CATTRS, new PacketWriter ().WriteId (id).WriteId (field_id).WriteId (attr_type_id));
			return ReadCattrs (r);
		}

		internal CattrInfo[] Type_GetPropertyCustomAttributes (long id, long field_id, long attr_type_id, bool inherit) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_PROPERTY_CATTRS, new PacketWriter ().WriteId (id).WriteId (field_id).WriteId (attr_type_id));
			return ReadCattrs (r);
		}

		public long[] Type_GetMethodsByNameFlags (long id, string name, int flags, bool ignoreCase) {
			flags |= ignoreCase ? (int)BindingFlagsExtensions.BINDING_FLAGS_IGNORE_CASE : 0;
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.CMD_TYPE_GET_METHODS_BY_NAME_FLAGS, new PacketWriter ().WriteId (id).WriteString (name).WriteInt (flags));
			int len = r.ReadInt ();
			long[] res = new long [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadId ();
			return res;
		}

		internal long[] Type_GetInterfaces (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_INTERFACES, new PacketWriter ().WriteId (id));
			int len = r.ReadInt ();
			return r.ReadIds (len);
		}

		internal IfaceMapInfo[] Type_GetInterfaceMap (long id, long[] ids) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.GET_INTERFACE_MAP, new PacketWriter ().WriteId (id).WriteInt (ids.Length).WriteIds (ids));
			var res = new IfaceMapInfo [ids.Length];
			for (int i = 0; i < ids.Length; ++i) {
				int n = r.ReadInt ();

				res [i].iface_id = ids [i];
				res [i].iface_methods = r.ReadIds (n);
				res [i].target_methods = r.ReadIds (n);
			}

			return res;
		}

		internal bool Type_IsInitialized (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.IS_INITIALIZED, new PacketWriter ().WriteId (id));
			return r.ReadInt () == 1;
		}

		internal long Type_CreateInstance (long id) {
			PacketReader r = SendReceive (CommandSet.TYPE, (int)CmdType.CREATE_INSTANCE, new PacketWriter ().WriteId (id));
			return r.ReadId ();
		}

		/*
		 * FIELD
		 */

		internal FieldMirrorInfo Field_GetInfo (long id) {
			PacketReader r = SendReceive (CommandSet.FIELD, (int)CmdField.GET_INFO, new PacketWriter ().WriteId (id));
			FieldMirrorInfo info = new FieldMirrorInfo { Name = r.ReadString (), Parent = r.ReadId (), TypeId = r.ReadId (), Attrs = r.ReadInt () };
			return info;
		}

		/*
		 * EVENTS
		 */

		internal int EnableEvent (EventType etype, SuspendPolicy suspend_policy, List<Modifier> mods) {
			var w = new PacketWriter ().WriteByte ((byte)etype).WriteByte ((byte)suspend_policy);
			if (mods != null) {
				if (mods.Count > 255)
					throw new NotImplementedException ();
				w.WriteByte ((byte)mods.Count);
				foreach (Modifier mod in mods) {
					if (mod is CountModifier) {
						w.WriteByte ((byte)ModifierKind.COUNT);
						w.WriteInt ((mod as CountModifier).Count);
					} else if (mod is LocationModifier) {
						w.WriteByte ((byte)ModifierKind.LOCATION_ONLY);
						w.WriteId ((mod as LocationModifier).Method);
						w.WriteLong ((mod as LocationModifier).Location);
					} else if (mod is StepModifier) {
						w.WriteByte ((byte)ModifierKind.STEP);
						w.WriteId ((mod as StepModifier).Thread);
						w.WriteInt ((mod as StepModifier).Size);
						w.WriteInt ((mod as StepModifier).Depth);
						if (Version.AtLeast (2, 16))
							w.WriteInt ((mod as StepModifier).Filter);
					} else if (mod is ThreadModifier) {
						w.WriteByte ((byte)ModifierKind.THREAD_ONLY);
						w.WriteId ((mod as ThreadModifier).Thread);
					} else if (mod is ExceptionModifier) {
						var em = mod as ExceptionModifier;
						w.WriteByte ((byte)ModifierKind.EXCEPTION_ONLY);
						w.WriteId (em.Type);
						if (Version.MajorVersion > 2 || Version.MinorVersion > 0) {
							/* This is only supported in protocol version 2.1 */
							w.WriteBool (em.Caught);
							w.WriteBool (em.Uncaught);
						} else if (!em.Caught || !em.Uncaught) {
							throw new NotSupportedException ("This request is not supported by the protocol version implemented by the debuggee.");
						}
						if (Version.MajorVersion > 2 || Version.MinorVersion > 24) {
							w.WriteBool (em.Subclasses);
						} else if (!em.Subclasses) {
							throw new NotSupportedException ("This request is not supported by the protocol version implemented by the debuggee.");
						}
					} else if (mod is AssemblyModifier) {
						w.WriteByte ((byte)ModifierKind.ASSEMBLY_ONLY);
						var amod = (mod as AssemblyModifier);
						w.WriteInt (amod.Assemblies.Length);
						foreach (var id in amod.Assemblies)
							w.WriteId (id);
					} else if (mod is SourceFileModifier) {
						w.WriteByte ((byte)ModifierKind.SOURCE_FILE_ONLY);
						var smod = (mod as SourceFileModifier);
						w.WriteInt (smod.SourceFiles.Length);
						foreach (var s in smod.SourceFiles)
							w.WriteString (s);
					} else if (mod is TypeNameModifier) {
						w.WriteByte ((byte)ModifierKind.TYPE_NAME_ONLY);
						var tmod = (mod as TypeNameModifier);
						w.WriteInt (tmod.TypeNames.Length);
						foreach (var s in tmod.TypeNames)
							w.WriteString (s);
					} else {
						throw new NotImplementedException ();
					}
				}
			} else {
				w.WriteByte (0);
			}
			return SendReceive (CommandSet.EVENT_REQUEST, (int)CmdEventRequest.SET, w).ReadInt ();
		}

		internal void ClearEventRequest (EventType etype, int req_id) {
			SendReceive (CommandSet.EVENT_REQUEST, (int)CmdEventRequest.CLEAR, new PacketWriter ().WriteByte ((byte)etype).WriteInt (req_id));
		}			

		internal void ClearAllBreakpoints () {
			SendReceive (CommandSet.EVENT_REQUEST, (int)CmdEventRequest.CLEAR_ALL_BREAKPOINTS, new PacketWriter ());
		}
			
		/*
		 * STACK FRAME
		 */
		internal ValueImpl StackFrame_GetThis (long thread_id, long id) {
			PacketReader r = SendReceive (CommandSet.STACK_FRAME, (int)CmdStackFrame.GET_THIS, new PacketWriter ().WriteId (thread_id).WriteId (id));
			return r.ReadValue ();
		}

		internal ValueImpl[] StackFrame_GetValues (long thread_id, long id, int[] pos) {
			/* pos < 0 -> argument at pos (-pos) - 1 */
			/* pos >= 0 -> local at pos */
			int len = pos.Length;
			PacketReader r = SendReceive (CommandSet.STACK_FRAME, (int)CmdStackFrame.GET_VALUES, new PacketWriter ().WriteId (thread_id).WriteId (id).WriteInt (len).WriteInts (pos));

			ValueImpl[] res = new ValueImpl [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadValue ();
			return res;
		}

		internal void StackFrame_SetValues (long thread_id, long id, int[] pos, ValueImpl[] values) {
			/* pos < 0 -> argument at pos (-pos) - 1 */
			/* pos >= 0 -> local at pos */
			int len = pos.Length;
			SendReceive (CommandSet.STACK_FRAME, (int)CmdStackFrame.SET_VALUES, new PacketWriter ().WriteId (thread_id).WriteId (id).WriteInt (len).WriteInts (pos).WriteValues (values));
		}

		internal long StackFrame_GetDomain (long thread_id, long id) {
			return SendReceive (CommandSet.STACK_FRAME, (int)CmdStackFrame.GET_DOMAIN, new PacketWriter ().WriteId (thread_id).WriteId (id)).ReadId ();
		}

		internal void StackFrame_SetThis (long thread_id, long id, ValueImpl value) {
			SendReceive (CommandSet.STACK_FRAME, (int)CmdStackFrame.SET_THIS, new PacketWriter ().WriteId (thread_id).WriteId (id).WriteValue (value));
		}

		/*
		 * ARRAYS
		 */
		internal int[] Array_GetLength (long id, out int rank, out int[] lower_bounds) {
			var r = SendReceive (CommandSet.ARRAY_REF, (int)CmdArrayRef.GET_LENGTH, new PacketWriter ().WriteId (id));
			rank = r.ReadInt ();
			int[] res = new int [rank];
			lower_bounds = new int [rank];
			for (int i = 0; i < rank; ++i) {
				res [i] = r.ReadInt ();
				lower_bounds [i] = r.ReadInt ();
			}
			return res;
		}

		internal ValueImpl[] Array_GetValues (long id, int index, int len) {
			var r = SendReceive (CommandSet.ARRAY_REF, (int)CmdArrayRef.GET_VALUES, new PacketWriter ().WriteId (id).WriteInt (index).WriteInt (len));
			ValueImpl[] res = new ValueImpl [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadValue ();
			return res;
		}

		internal void Array_SetValues (long id, int index, ValueImpl[] values) {
			SendReceive (CommandSet.ARRAY_REF, (int)CmdArrayRef.SET_VALUES, new PacketWriter ().WriteId (id).WriteInt (index).WriteInt (values.Length).WriteValues (values));
		}

		/*
		 * STRINGS
		 */
		internal string String_GetValue (long id) {
			var r = SendReceive (CommandSet.STRING_REF, (int)CmdStringRef.GET_VALUE, new PacketWriter ().WriteId (id));

			bool is_utf16 = false;
			if (Version.AtLeast (2, 41))
				is_utf16 = r.ReadByte () == 1;

			if (is_utf16)
				return r.ReadUTF16String ();
			else
				return r.ReadString ();
		}			

		internal int String_GetLength (long id) {
			return (int)SendReceive (CommandSet.STRING_REF, (int)CmdStringRef.GET_LENGTH, new PacketWriter ().WriteId (id)).ReadLong ();
		}			

		internal char[] String_GetChars (long id, int index, int length) {
			var r = SendReceive (CommandSet.STRING_REF, (int)CmdStringRef.GET_CHARS, new PacketWriter ().WriteId (id).WriteLong (index).WriteLong (length));
			var res = new char [length];
			for (int i = 0; i < length; ++i)
				res [i] = (char)r.ReadShort ();
			return res;
		}			

		/*
		 * OBJECTS
		 */
		internal long Object_GetType (long id) {
			return SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.GET_TYPE, new PacketWriter ().WriteId (id)).ReadId ();
		}			

		internal long Object_GetDomain (long id) {
			return SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.GET_DOMAIN, new PacketWriter ().WriteId (id)).ReadId ();
		}			

		internal ValueImpl[] Object_GetValues (long id, long[] fields) {
			int len = fields.Length;
			PacketReader r = SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.GET_VALUES, new PacketWriter ().WriteId (id).WriteInt (len).WriteIds (fields));

			ValueImpl[] res = new ValueImpl [len];
			for (int i = 0; i < len; ++i)
				res [i] = r.ReadValue ();
			return res;
		}

		internal void Object_SetValues (long id, long[] fields, ValueImpl[] values) {
			SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.SET_VALUES, new PacketWriter ().WriteId (id).WriteInt (fields.Length).WriteIds (fields).WriteValues (values));
		}

		internal bool Object_IsCollected (long id) {
			return SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.IS_COLLECTED, new PacketWriter ().WriteId (id)).ReadInt () == 1;
		}			

		internal long Object_GetAddress (long id) {
			return SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.GET_ADDRESS, new PacketWriter ().WriteId (id)).ReadLong ();
		}			

		internal ObjectRefInfo Object_GetInfo (long id) {
			ObjectRefInfo res = new ObjectRefInfo ();
			PacketReader r = SendReceive (CommandSet.OBJECT_REF, (int)CmdObjectRef.GET_INFO, new PacketWriter ().WriteId (id));

			res.type_id = r.ReadId ();
			res.domain_id = r.ReadId ();
			return res;
		}

		public void ForceDisconnect ()
		{
			closed = true;
			disconnected = true;
			DisconnectedEvent.Set ();
			TransportClose ();
		}
	}
	
	class TcpConnection : Connection
	{
		Socket socket;
		
		internal TcpConnection (Socket socket)
		{
			this.socket = socket;
			//socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.NoDelay, 1);
		}
		
		internal EndPoint EndPoint {
			get {
				return socket.RemoteEndPoint;
			}
		}
		
		protected override int TransportSend (byte[] buf, int buf_offset, int len)
		{
			return socket.Send (buf, buf_offset, len, SocketFlags.None);
		}
		
		protected override int TransportReceive (byte[] buf, int buf_offset, int len)
		{
			return socket.Receive (buf, buf_offset, len, SocketFlags.None);
		}
		
		protected override void TransportSetTimeouts (int send_timeout, int receive_timeout)
		{
			socket.SendTimeout = send_timeout;
			socket.ReceiveTimeout = receive_timeout;
		}
		
		protected override void TransportClose ()
		{
			socket.Close ();
		}
	}

	/* This is the interface exposed by the debugger towards the debugger agent */
	interface IEventHandler
	{
		void Events (SuspendPolicy suspend_policy, EventInfo[] events);

		void VMDisconnect (int req_id, long thread_id, string vm_uri);
	}
}

```

`Mono.Debugger.Soft/CustomAttributeDataMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft {

	public sealed class CustomAttributeDataMirror {
		MethodMirror ctorInfo;
		IList<CustomAttributeTypedArgumentMirror> ctorArgs;
		IList<CustomAttributeNamedArgumentMirror> namedArgs;

		internal CustomAttributeDataMirror (MethodMirror ctorInfo, object [] ctorArgs, object [] namedArgs)
		{
			this.ctorInfo = ctorInfo;
			
			this.ctorArgs = Array.AsReadOnly<CustomAttributeTypedArgumentMirror> 
				(ctorArgs != null ? UnboxValues<CustomAttributeTypedArgumentMirror> (ctorArgs) : new CustomAttributeTypedArgumentMirror [0]);
			
			this.namedArgs = Array.AsReadOnly<CustomAttributeNamedArgumentMirror> 
				(namedArgs != null ? UnboxValues<CustomAttributeNamedArgumentMirror> (namedArgs) : new CustomAttributeNamedArgumentMirror [0]);
		}

		[ComVisible (true)]
		public MethodMirror Constructor {
			get {
				return ctorInfo;
			}
		}

		[ComVisible (true)]
		public IList<CustomAttributeTypedArgumentMirror> ConstructorArguments {
			get {
				return ctorArgs;
			}
		}

		public IList<CustomAttributeNamedArgumentMirror> NamedArguments {
			get {
				return namedArgs;
			}
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();

			sb.Append ("[" + ctorInfo.DeclaringType.FullName + "(");
			if (ctorArgs != null) {
				for (int i = 0; i < ctorArgs.Count; i++) {
					sb.Append (ctorArgs [i].ToString ());
					if (i + 1 < ctorArgs.Count)
						sb.Append (", ");
				}
			}

			if (namedArgs != null) {
				if (namedArgs.Count > 0)
					sb.Append (", ");
			
				for (int j = 0; j < namedArgs.Count; j++) {
					sb.Append (namedArgs [j].ToString ());
					if (j + 1 < namedArgs.Count)
						sb.Append (", ");
				}
			}
			sb.AppendFormat (")]");

			return sb.ToString ();
		}

		static T [] UnboxValues<T> (object [] values)
		{
			T [] retval = new T [values.Length];
			for (int i = 0; i < values.Length; i++)
				retval [i] = (T) values [i];

			return retval;
		}

		/* 
		 * Construct a normal object from the value, so accessing the cattr doesn't 
		 * require remoting calls.
		 */
		static CustomAttributeTypedArgumentMirror CreateArg (VirtualMachine vm, ValueImpl vi) {
			object val;

			/* Instead of receiving a mirror of the Type object, we receive the id of the type */
			if (vi.Type == (ElementType)ValueTypeId.VALUE_TYPE_ID_TYPE)
				val = vm.GetType (vi.Id);
			else {
				Value v = vm.DecodeValue (vi);
				if (v is PrimitiveValue)
					val = (v as PrimitiveValue).Value;
				else if (v is StringMirror)
					val = (v as StringMirror).Value;
				else
					// FIXME:
					val = v;
			}
			return new CustomAttributeTypedArgumentMirror (null, val);
		}

		internal static CustomAttributeDataMirror[] Create (VirtualMachine vm, CattrInfo[] info) {
			var res = new CustomAttributeDataMirror [info.Length];
			for (int i = 0; i < info.Length; ++i) {
				CattrInfo attr = info [i];
				MethodMirror ctor = vm.GetMethod (attr.ctor_id);
				var ctor_args = new object [attr.ctor_args.Length];
				for (int j = 0; j < ctor_args.Length; ++j)
					ctor_args [j] = CreateArg (vm, attr.ctor_args [j]);
				var named_args = new object [attr.named_args.Length];
				for (int j = 0; j < named_args.Length; ++j) {
					CattrNamedArgInfo arg = attr.named_args [j];
					CustomAttributeTypedArgumentMirror val;

					val = CreateArg (vm, arg.value);

					TypeMirror t = ctor.DeclaringType;
					while (named_args [j] == null && t != null) {
						if (arg.is_property) {
							foreach (var prop in t.GetProperties ()) {
								if (prop.Id == arg.id)
									named_args [j] = new CustomAttributeNamedArgumentMirror (prop, null, val);
							}
						} else {
							foreach (var field in t.GetFields ()) {
								if (field.Id == arg.id)
									named_args [j] = new CustomAttributeNamedArgumentMirror (null, field, val);
							}
						}
						t = t.BaseType;
					}
					if (named_args [j] == null)
						throw new NotImplementedException ();
				}
				res [i] = new CustomAttributeDataMirror (ctor, ctor_args, named_args);
			}

			return res;
		}
	}

}

```

`Mono.Debugger.Soft/CustomAttributeNamedArgumentMirror.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Reflection;

namespace Mono.Debugger.Soft {

	public struct CustomAttributeNamedArgumentMirror {
		CustomAttributeTypedArgumentMirror arg;
		PropertyInfoMirror prop;
		FieldInfoMirror field;

		internal CustomAttributeNamedArgumentMirror (PropertyInfoMirror prop, FieldInfoMirror field, CustomAttributeTypedArgumentMirror arg)
		{
			this.arg = arg;
			this.prop = prop;
			this.field = field;
		}

		public PropertyInfoMirror Property {
			get {
				return prop;
			}
		}

		public FieldInfoMirror Field {
			get {
				return field;
			}
		}

		public CustomAttributeTypedArgumentMirror TypedValue {
			get {
				return arg;
			}
		}
	}
}

```

`Mono.Debugger.Soft/CustomAttributeTypedArgumentMirror.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Collections.ObjectModel;
using System.Reflection;

namespace Mono.Debugger.Soft {

	public struct CustomAttributeTypedArgumentMirror {
		Type type;
		object value;

		internal CustomAttributeTypedArgumentMirror (Type type, object value)
		{
			this.type = type;
			this.value = value;

			if (value != null)
				this.type = value.GetType ();
			else
				this.type = typeof (void);

			// MS seems to convert arrays into a ReadOnlyCollection
			if (value is Array) {
				Array a = (Array)value;

				Type etype = a.GetType ().GetElementType ();
				CustomAttributeTypedArgumentMirror[] new_value = new CustomAttributeTypedArgumentMirror [a.GetLength (0)];
				for (int i = 0; i < new_value.Length; ++i)
					new_value [i] = new CustomAttributeTypedArgumentMirror (etype, a.GetValue (i));
				this.value = new ReadOnlyCollection <CustomAttributeTypedArgumentMirror> (new_value);
			}
		}

		public Type ArgumentType {
			get {
				return type;
			}
		}

		public object Value {
			get {
				return value;
			}
		}

		public override string ToString ()
		{
			string val = value != null ? value.ToString () : String.Empty;
			if (ArgumentType == typeof (string))
				return "\"" + val + "\"";
			if (ArgumentType == typeof (Type)) 
				return "typeof (" + val + ")";
			if (ArgumentType.IsEnum)
				return "(" + ArgumentType.Name + ")" + val;

			return val;
		}
	}
}

```

`Mono.Debugger.Soft/DataConverter.cs`:

```cs
//
// Authors:
//   Miguel de Icaza (miguel@novell.com)
//
// See the following url for documentation:
//     http://www.mono-project.com/Mono_DataConvert
//
// Compilation Options:
//     MONO_DATACONVERTER_PUBLIC:
//         Makes the class public instead of the default internal.
//
//     MONO_DATACONVERTER_STATIC_METHODS:     
//         Exposes the public static methods.
//
// TODO:
//   Support for "DoubleWordsAreSwapped" for ARM devices
//
// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.Collections;
using System.Text;

#pragma warning disable 3021

namespace Mono {

#if MONO_DATACONVERTER_PUBLIC
	unsafe public abstract class DataConverter {
#else
	unsafe internal abstract class DataConverter {

// Disables the warning: CLS compliance checking will not be performed on
//  `XXXX' because it is not visible from outside this assembly
#pragma warning disable  3019
#endif
		static DataConverter SwapConv = new SwapConverter ();
		static DataConverter CopyConv = new CopyConverter ();

		public static readonly bool IsLittleEndian = BitConverter.IsLittleEndian;
			
		public abstract double GetDouble (byte [] data, int index);
		public abstract float  GetFloat  (byte [] data, int index);
		public abstract long   GetInt64  (byte [] data, int index);
		public abstract int    GetInt32  (byte [] data, int index);

		public abstract short  GetInt16  (byte [] data, int index);

                [CLSCompliant (false)]
		public abstract uint   GetUInt32 (byte [] data, int index);
                [CLSCompliant (false)]
		public abstract ushort GetUInt16 (byte [] data, int index);
                [CLSCompliant (false)]
		public abstract ulong  GetUInt64 (byte [] data, int index);
		
		public abstract void PutBytes (byte [] dest, int destIdx, double value);
		public abstract void PutBytes (byte [] dest, int destIdx, float value);
		public abstract void PutBytes (byte [] dest, int destIdx, int value);
		public abstract void PutBytes (byte [] dest, int destIdx, long value);
		public abstract void PutBytes (byte [] dest, int destIdx, short value);

                [CLSCompliant (false)]
		public abstract void PutBytes (byte [] dest, int destIdx, ushort value);
                [CLSCompliant (false)]
		public abstract void PutBytes (byte [] dest, int destIdx, uint value);
                [CLSCompliant (false)]
		public abstract void PutBytes (byte [] dest, int destIdx, ulong value);

		public byte[] GetBytes (double value)
		{
			byte [] ret = new byte [8];
			PutBytes (ret, 0, value);
			return ret;
		}
		
		public byte[] GetBytes (float value)
		{
			byte [] ret = new byte [4];
			PutBytes (ret, 0, value);
			return ret;
		}
		
		public byte[] GetBytes (int value)
		{
			byte [] ret = new byte [4];
			PutBytes (ret, 0, value);
			return ret;
		}
		
		public byte[] GetBytes (long value)
		{
			byte [] ret = new byte [8];
			PutBytes (ret, 0, value);
			return ret;
		}
		
		public byte[] GetBytes (short value)
		{
			byte [] ret = new byte [2];
			PutBytes (ret, 0, value);
			return ret;
		}

                [CLSCompliant (false)]
		public byte[] GetBytes (ushort value)
		{
			byte [] ret = new byte [2];
			PutBytes (ret, 0, value);
			return ret;
		}
		
                [CLSCompliant (false)]
		public byte[] GetBytes (uint value)
		{
			byte [] ret = new byte [4];
			PutBytes (ret, 0, value);
			return ret;
		}
		
                [CLSCompliant (false)]
		public byte[] GetBytes (ulong value)
		{
			byte [] ret = new byte [8];
			PutBytes (ret, 0, value);
			return ret;
		}
		
		static public DataConverter LittleEndian {
			get {
				return BitConverter.IsLittleEndian ? CopyConv : SwapConv;
			}
		}

		static public DataConverter BigEndian {
			get {
				return BitConverter.IsLittleEndian ? SwapConv : CopyConv;
			}
		}

		static public DataConverter Native {
			get {
				return CopyConv;
			}
		}

		static int Align (int current, int align)
		{
			return ((current + align - 1) / align) * align;
		}
			
		class PackContext {
			// Buffer
			public byte [] buffer;
			int next;

			public string description;
			public int i; // position in the description
			public DataConverter conv;
			public int repeat;
			
			//
			// if align == -1, auto align to the size of the byte array
			// if align == 0, do not do alignment
			// Any other values aligns to that particular size
			//
			public int align;

			public void Add (byte [] group)
			{
				//Console.WriteLine ("Adding {0} bytes to {1} (next={2}", group.Length,
				// buffer == null ? "null" : buffer.Length.ToString (), next);
				
				if (buffer == null){
					buffer = group;
					next = group.Length;
					return;
				}
				if (align != 0){
					if (align == -1)
						next = Align (next, group.Length);
					else
						next = Align (next, align);
					align = 0;
				}

				if (next + group.Length > buffer.Length){
					byte [] nb = new byte [System.Math.Max (next, 16) * 2 + group.Length];
					Array.Copy (buffer, nb, buffer.Length);
					Array.Copy (group, 0, nb, next, group.Length);
					next = next + group.Length;
					buffer = nb;
				} else {
					Array.Copy (group, 0, buffer, next, group.Length);
					next += group.Length;
				}
			}

			public byte [] Get ()
			{
				if (buffer == null)
					return new byte [0];
				
				if (buffer.Length != next){
					byte [] b = new byte [next];
					Array.Copy (buffer, b, next);
					return b;
				}
				return buffer;
			}
		}

		//
		// Format includes:
		// Control:
		//   ^    Switch to big endian encoding
		//   _    Switch to little endian encoding
		//   %    Switch to host (native) encoding
		//   !    aligns the next data type to its natural boundary (for strings this is 4).
		//
		// Types:
		//   s    Int16
		//   S    UInt16
		//   i    Int32
		//   I    UInt32
		//   l    Int64
		//   L    UInt64
		//   f    float
		//   d    double
		//   b    byte
                //   c    1-byte signed character
                //   C    1-byte unsigned character
		//   z8   string encoded as UTF8 with 1-byte null terminator
		//   z6   string encoded as UTF16 with 2-byte null terminator
		//   z7   string encoded as UTF7 with 1-byte null terminator
		//   zb   string encoded as BigEndianUnicode with 2-byte null terminator
		//   z3   string encoded as UTF32 with 4-byte null terminator
		//   z4   string encoded as UTF32 big endian with 4-byte null terminator
		//   $8   string encoded as UTF8
		//   $6   string encoded as UTF16
		//   $7   string encoded as UTF7
		//   $b   string encoded as BigEndianUnicode
		//   $3   string encoded as UTF32
		//   $4   string encoded as UTF-32 big endian encoding
		//   x    null byte
		//
		// Repeats, these are prefixes:
		//   N    a number between 1 and 9, indicates a repeat count (process N items
		//        with the following datatype
		//   [N]  For numbers larger than 9, use brackets, for example [20]
		//   *    Repeat the next data type until the arguments are exhausted
		//
		static public byte [] Pack (string description, params object [] args)
		{
			int argn = 0;
			PackContext b = new PackContext ();
			b.conv = CopyConv;
			b.description = description;

			for (b.i = 0; b.i < description.Length; ){
				object oarg;

				if (argn < args.Length)
					oarg = args [argn];
				else {
					if (b.repeat != 0)
						break;
					
					oarg = null;
				}

				int save = b.i;
				
				if (PackOne (b, oarg)){
					argn++;
					if (b.repeat > 0){
						if (--b.repeat > 0)
							b.i = save;
						else
							b.i++;
					} else
						b.i++;
				} else
					b.i++;
			}
			return b.Get ();
		}

		static public byte [] PackEnumerable (string description, IEnumerable args)
		{
			PackContext b = new PackContext ();
			b.conv = CopyConv;
			b.description = description;
			
			IEnumerator enumerator = args.GetEnumerator ();
			bool ok = enumerator.MoveNext ();

			for (b.i = 0; b.i < description.Length; ){
				object oarg;

				if (ok)
					oarg = enumerator.Current;
				else {
					if (b.repeat != 0)
						break;
					oarg = null;
				}
						
				int save = b.i;
				
				if (PackOne (b, oarg)){
					ok = enumerator.MoveNext ();
					if (b.repeat > 0){
						if (--b.repeat > 0)
							b.i = save;
						else
							b.i++;
					} else
						b.i++;
				} else
					b.i++;
			}
			return b.Get ();
		}
			
		//
		// Packs one datum `oarg' into the buffer `b', using the string format
		// in `description' at position `i'
		//
		// Returns: true if we must pick the next object from the list
		//
		static bool PackOne (PackContext b, object oarg)
		{
			int n;
			
			switch (b.description [b.i]){
			case '^':
				b.conv = BigEndian;
				return false;
			case '_':
				b.conv = LittleEndian;
				return false;
			case '%':
				b.conv = Native;
				return false;

			case '!':
				b.align = -1;
				return false;
				
			case 'x':
				b.Add (new byte [] { 0 });
				return false;
				
				// Type Conversions
			case 'i':
				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));
				break;
				
			case 'I':
				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));
				break;
				
			case 's':
				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));
				break;
				
			case 'S':
				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));
				break;
				
			case 'l':
				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));
				break;
				
			case 'L':
				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));
				break;
				
			case 'f':
				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));
				break;
				
			case 'd':
				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));
				break;
				
			case 'b':
				b.Add (new byte [] { Convert.ToByte (oarg) });
				break;

			case 'c':
				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });
				break;

			case 'C':
				b.Add (new byte [] { Convert.ToByte (oarg) });
				break;

				// Repeat acount;
			case '1': case '2': case '3': case '4': case '5':
			case '6': case '7': case '8': case '9':
				b.repeat = ((short) b.description [b.i]) - ((short) '0');
				return false;

			case '*':
				b.repeat = Int32.MaxValue;
				return false;
				
			case '[':
				int count = -1, j;
				
				for (j = b.i+1; j < b.description.Length; j++){
					if (b.description [j] == ']')
						break;
					n = ((short) b.description [j]) - ((short) '0');
					if (n >= 0 && n <= 9){
						if (count == -1)
							count = n;
						else
							count = count * 10 + n;
					}
				}
				if (count == -1)
					throw new ArgumentException ("invalid size specification");
				b.i = j;
				b.repeat = count;
				return false;
				
			case '$': case 'z':
				bool add_null = b.description [b.i] == 'z';
				b.i++;
				if (b.i >= b.description.Length)
					throw new ArgumentException ("$ description needs a type specified", "description");
				char d = b.description [b.i];
				Encoding e;
				
				switch (d){
				case '8':
					e = Encoding.UTF8;
					n = 1;
					break;
				case '6':
					e = Encoding.Unicode;
					n = 2;
					break;
				case '7':
					e = Encoding.UTF7;
					n = 1;
					break;
				case 'b':
					e = Encoding.BigEndianUnicode;
					n = 2;
					break;
				case '3':
					e = Encoding.GetEncoding (12000);
					n = 4;
					break;
				case '4':
					e = Encoding.GetEncoding (12001);
					n = 4;
					break;
					
				default:
					throw new ArgumentException ("Invalid format for $ specifier", "description");
				}
				if (b.align == -1)
					b.align = 4;
				b.Add (e.GetBytes (Convert.ToString (oarg)));
				if (add_null)
					b.Add (new byte [n]);
				break;
			default:
				throw new ArgumentException (String.Format ("invalid format specified `{0}'",
									    b.description [b.i]));
			}
			return true;
		}

		static bool Prepare (byte [] buffer, ref int idx, int size, ref bool align)
		{
			if (align){
				idx = Align (idx, size);
				align = false;
			}
			if (idx + size > buffer.Length){
				idx = buffer.Length;
				return false;
			}
			return true;
		}
		
		static public IList Unpack (string description, byte [] buffer, int startIndex)
		{
			DataConverter conv = CopyConv;
			ArrayList result = new ArrayList ();
			int idx = startIndex;
			bool align = false;
			int repeat = 0, n;
			
			for (int i = 0; i < description.Length && idx < buffer.Length; ){
				int save = i;
				
				switch (description [i]){
				case '^':
					conv = BigEndian;
					break;
				case '_':
					conv = LittleEndian;
					break;
				case '%':
					conv = Native;
					break;
				case 'x':
					idx++;
					break;

				case '!':
					align = true;
					break;

					// Type Conversions
				case 'i':
					if (Prepare (buffer, ref idx, 4, ref align)){
						result.Add (conv.GetInt32 (buffer, idx));
						idx += 4;
					} 
					break;
				
				case 'I':
					if (Prepare (buffer, ref idx, 4, ref align)){
						result.Add (conv.GetUInt32 (buffer, idx));
						idx += 4;
					}
					break;
				
				case 's':
					if (Prepare (buffer, ref idx, 2, ref align)){
						result.Add (conv.GetInt16 (buffer, idx));
						idx += 2;
					}
					break;
				
				case 'S':
					if (Prepare (buffer, ref idx, 2, ref align)){
						result.Add (conv.GetUInt16 (buffer, idx));
						idx += 2;
					}
					break;
				
				case 'l':
					if (Prepare (buffer, ref idx, 8, ref align)){
						result.Add (conv.GetInt64 (buffer, idx));
						idx += 8;
					}
					break;
				
				case 'L':
					if (Prepare (buffer, ref idx, 8, ref align)){
						result.Add (conv.GetUInt64 (buffer, idx));
						idx += 8;
					}
					break;
				
				case 'f':
					if (Prepare (buffer, ref idx, 4, ref align)){
						result.Add (conv.GetDouble (buffer, idx));
						idx += 4;
					}
					break;
				
				case 'd':
					if (Prepare (buffer, ref idx, 8, ref align)){
						result.Add (conv.GetDouble (buffer, idx));
						idx += 8;
					}
					break;
				
				case 'b':
					if (Prepare (buffer, ref idx, 1, ref align)){
						result.Add (buffer [idx]);
						idx++;
					}
					break;

				case 'c': case 'C':
					if (Prepare (buffer, ref idx, 1, ref align)){
						char c;
						
						if (description [i] == 'c')
							c = ((char) ((sbyte)buffer [idx]));
						else
							c = ((char) ((byte)buffer [idx]));
						
						result.Add (c);
						idx++;
					}
					break;
					
					// Repeat acount;
				case '1': case '2': case '3': case '4': case '5':
				case '6': case '7': case '8': case '9':
					repeat = ((short) description [i]) - ((short) '0');
					save = i + 1;
					break;

				case '*':
					repeat = Int32.MaxValue;
					break;
				
				case '[':
					int count = -1, j;
				
					for (j = i+1; j < description.Length; j++){
						if (description [j] == ']')
							break;
						n = ((short) description [j]) - ((short) '0');
						if (n >= 0 && n <= 9){
							if (count == -1)
								count = n;
							else
								count = count * 10 + n;
						}
					}
					if (count == -1)
						throw new ArgumentException ("invalid size specification");
					i = j;
					repeat = count;
					break;
				
				case '$': case 'z':
					// bool with_null = description [i] == 'z';
					i++;
					if (i >= description.Length)
						throw new ArgumentException ("$ description needs a type specified", "description");
					char d = description [i];
					Encoding e;
					if (align){
						idx = Align (idx, 4);
						align = false;
					}
					if (idx >= buffer.Length)
						break;
				
					switch (d){
					case '8':
						e = Encoding.UTF8;
						n = 1;
						break;
					case '6':
						e = Encoding.Unicode;
						n = 2;
						break;
					case '7':
						e = Encoding.UTF7;
						n = 1;
						break;
					case 'b':
						e = Encoding.BigEndianUnicode;
						n = 2;
						break;
					case '3':
						e = Encoding.GetEncoding (12000);
						n = 4;
						break;
					case '4':
						e = Encoding.GetEncoding (12001);
						n = 4;
						break;
					
					default:
						throw new ArgumentException ("Invalid format for $ specifier", "description");
					}
					int k = idx;
					switch (n){
					case 1:
						for (; k < buffer.Length && buffer [k] != 0; k++)
							;
						result.Add (e.GetChars (buffer, idx, k-idx));
						if (k == buffer.Length)
							idx = k;
						else
							idx = k+1;
						break;
						
					case 2:
						for (; k < buffer.Length; k++){
							if (k+1 == buffer.Length){
								k++;
								break;
							}
							if (buffer [k] == 0 && buffer [k+1] == 0)
								break;
						}
						result.Add (e.GetChars (buffer, idx, k-idx));
						if (k == buffer.Length)
							idx = k;
						else
							idx = k+2;
						break;
						
					case 4:
						for (; k < buffer.Length; k++){
							if (k+3 >= buffer.Length){
								k = buffer.Length;
								break;
							}
							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)
								break;
						}
						result.Add (e.GetChars (buffer, idx, k-idx));
						if (k == buffer.Length)
							idx = k;
						else
							idx = k+4;
						break;
					}
					break;
				default:
					throw new ArgumentException (String.Format ("invalid format specified `{0}'",
										    description [i]));
				}

				if (repeat > 0){
					if (--repeat > 0)
						i = save;
				} else
					i++;
			}
			return result;
		}

		internal void Check (byte [] dest, int destIdx, int size)
		{
			if (dest == null)
				throw new ArgumentNullException ("dest");
			if (destIdx < 0 || destIdx > dest.Length - size)
				throw new ArgumentException ("destIdx");
		}
		
		class CopyConverter : DataConverter {
			public override double GetDouble (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");
				double ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}

			public override ulong GetUInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				ulong ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}

			public override long GetInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				long ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override float GetFloat  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				float ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override int GetInt32  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				int ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override uint GetUInt32 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				uint ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override short GetInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				short ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override ushort GetUInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				ushort ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override void PutBytes (byte [] dest, int destIdx, double value)
			{
				Check (dest, destIdx, 8);
				fixed (byte *target = &dest [destIdx]){
					long *source = (long *) &value;

					*((long *)target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, float value)
			{
				Check (dest, destIdx, 4);
				fixed (byte *target = &dest [destIdx]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, int value)
			{
				Check (dest, destIdx, 4);
				fixed (byte *target = &dest [destIdx]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}
			}

			public override void PutBytes (byte [] dest, int destIdx, uint value)
			{
				Check (dest, destIdx, 4);
				fixed (byte *target = &dest [destIdx]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, long value)
			{
				Check (dest, destIdx, 8);
				fixed (byte *target = &dest [destIdx]){
					long *source = (long *) &value;

					*((long*)target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, ulong value)
			{
				Check (dest, destIdx, 8);
				fixed (byte *target = &dest [destIdx]){
					ulong *source = (ulong *) &value;

					*((ulong *) target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, short value)
			{
				Check (dest, destIdx, 2);
				fixed (byte *target = &dest [destIdx]){
					ushort *source = (ushort *) &value;

					*((ushort *)target) = *source;
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, ushort value)
			{
				Check (dest, destIdx, 2);
				fixed (byte *target = &dest [destIdx]){
					ushort *source = (ushort *) &value;

					*((ushort *)target) = *source;
				}
			}
		}

		class SwapConverter : DataConverter {
			public override double GetDouble (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				double ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}

			public override ulong GetUInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				ulong ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}

			public override long GetInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				long ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}
			
			public override float GetFloat  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				float ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override int GetInt32  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				int ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override uint GetUInt32 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				uint ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override short GetInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				short ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [1-i] = data [index+i];

				return ret;
			}
			
			public override ushort GetUInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("index");
				if (index < 0)
					throw new ArgumentException ("index");

				ushort ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [1-i] = data [index+i];

				return ret;
			}

			public override void PutBytes (byte [] dest, int destIdx, double value)
			{
				Check (dest, destIdx, 8);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 8; i++)
						target [i] = source [7-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, float value)
			{
				Check (dest, destIdx, 4);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, int value)
			{
				Check (dest, destIdx, 4);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, uint value)
			{
				Check (dest, destIdx, 4);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, long value)
			{
				Check (dest, destIdx, 8);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 8; i++)
						target [i] = source [7-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, ulong value)
			{
				Check (dest, destIdx, 8);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [7-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, short value)
			{
				Check (dest, destIdx, 2);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 2; i++)
						target [i] = source [1-i];
				}
			}
			
			public override void PutBytes (byte [] dest, int destIdx, ushort value)
			{
				Check (dest, destIdx, 2);

				fixed (byte *target = &dest [destIdx]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 2; i++)
						target [i] = source [1-i];
				}
			}
		}
		
#if MONO_DATACONVERTER_STATIC_METHODS
		static unsafe void PutBytesLE (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			if (BitConverter.IsLittleEndian){
				for (; i < count; i++)
					*dest++ = *src++;
			} else {
				dest += count;
				for (; i < count; i++)
					*(--dest) = *src++;
			}
		}

		static unsafe void PutBytesBE (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			if (BitConverter.IsLittleEndian){
				dest += count;
				for (; i < count; i++)
					*(--dest) = *src++;
			} else {
				for (; i < count; i++)
					*dest++ = *src++;
			}
		}

		static unsafe void PutBytesNative (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			for (; i < count; i++)
				dest [i-count] = *src++;
		}
		
		static public unsafe double DoubleFromLE (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe float FloatFromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe long Int64FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		static public unsafe ulong UInt64FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe int Int32FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		static public unsafe uint UInt32FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe short Int16FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		static public unsafe ushort UInt16FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 2);
			}
			return ret;
		}

		static public unsafe double DoubleFromBE (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe float FloatFromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe long Int64FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		static public unsafe ulong UInt64FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe int Int32FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		static public unsafe uint UInt32FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe short Int16FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		static public unsafe ushort UInt16FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 2);
			}
			return ret;
		}

		static public unsafe double DoubleFromNative (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe float FloatFromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe long Int64FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		static public unsafe ulong UInt64FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 8);
			}
			return ret;
		}

		static public unsafe int Int32FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		static public unsafe uint UInt32FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 4);
			}
			return ret;
		}

		static public unsafe short Int16FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		static public unsafe ushort UInt16FromNative (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("index");
			if (index < 0)
				throw new ArgumentException ("index");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesNative ((byte *) &ret, src, 2);
			}
			return ret;
		}

                unsafe static byte[] GetBytesPtr (byte *ptr, int count)
                {
                        byte [] ret = new byte [count];

                        for (int i = 0; i < count; i++) {
                                ret [i] = ptr [i];
                        }

                        return ret;
                }

                unsafe static byte[] GetBytesSwap (bool swap, byte *ptr, int count)
                {
                        byte [] ret = new byte [count];

			if (swap){
				int t = count-1;
				for (int i = 0; i < count; i++) {
					ret [t-i] = ptr [i];
				}
			} else {
				for (int i = 0; i < count; i++) {
					ret [i] = ptr [i];
				}
			}
                        return ret;
                }
		
                unsafe public static byte[] GetBytesNative (bool value)
                {
                        return GetBytesPtr ((byte *) &value, 1);
                }

                unsafe public static byte[] GetBytesNative (char value)
                {
                        return GetBytesPtr ((byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesNative (short value)
                {
                        return GetBytesPtr ((byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesNative (int value)
                {
                        return GetBytesPtr ((byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesNative (long value)
                {
                        return GetBytesPtr ((byte *) &value, 8);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesNative (ushort value)
                {
                        return GetBytesPtr ((byte *) &value, 2);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesNative (uint value)
                {
                        return GetBytesPtr ((byte *) &value, 4);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesNative (ulong value)
                {
                        return GetBytesPtr ((byte *) &value, 8);
                }

                unsafe public static byte[] GetBytesNative (float value)
                {
                        return GetBytesPtr ((byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesNative (double value)
                {
			return GetBytesPtr ((byte *) &value, 8);
                }

                unsafe public static byte[] GetBytesLE (bool value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 1);
                }

                unsafe public static byte[] GetBytesLE (char value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesLE (short value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesLE (int value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesLE (long value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 8);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesLE (ushort value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesLE (uint value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesLE (ulong value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 8);
                }

                unsafe public static byte[] GetBytesLE (float value)
                {
                        return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesLE (double value)
                {
			return GetBytesSwap (!BitConverter.IsLittleEndian, (byte *) &value, 8);
                }
		
                unsafe public static byte[] GetBytesBE (bool value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 1);
                }

                unsafe public static byte[] GetBytesBE (char value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesBE (short value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                unsafe public static byte[] GetBytesBE (int value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesBE (long value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 8);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesBE (ushort value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 2);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesBE (uint value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                [CLSCompliant (false)]
                unsafe public static byte[] GetBytesBE (ulong value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 8);
                }

                unsafe public static byte[] GetBytesBE (float value)
                {
                        return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 4);
                }

                unsafe public static byte[] GetBytesBE (double value)
                {
			return GetBytesSwap (BitConverter.IsLittleEndian, (byte *) &value, 8);
                }
#endif
		
	}
}

```

`Mono.Debugger.Soft/EnumMirror.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	/*
	 * Represents an enum value in the debuggee
	 */
	public class EnumMirror : StructMirror {
	
		internal EnumMirror (VirtualMachine vm, TypeMirror type, Value[] fields) : base (vm, type, fields) {
		}

		internal EnumMirror (VirtualMachine vm, TypeMirror type, PrimitiveValue value) : base (vm, type, new Value[] { value }) {
			if (type == null)
				throw new ArgumentNullException ("type");
			if (value == null)
				throw new ArgumentNullException ("value");
			if (!type.IsEnum)
				throw new ArgumentException ("type must be an enum type", "type");
			TypeMirror t = type.EnumUnderlyingType;
			if (value.Value == null || !value.Value.GetType ().IsPrimitive || t != vm.RootDomain.GetCorrespondingType (value.Value.GetType ()))
				throw new ArgumentException ("Value '" + value.Value + "' does not match the type of the enum.");
		}

		public object Value {
			get {
				return ((PrimitiveValue)Fields [0]).Value;
			}
			set {
				SetField (0, vm.CreateValue (value));
			}
		}

		public string StringValue {
			get {
				foreach (FieldInfoMirror f in Type.GetFields ()) {
					if (f.IsStatic) {
						object v = (Type.GetValue (f) as EnumMirror).Value;
						if (f.IsStatic && v.Equals (Value))
							return f.Name;
					}
				}
				return Value.ToString ();
			}
		}
	}
}
```

`Mono.Debugger.Soft/Event.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public abstract class Event {
		protected VirtualMachine vm;
		EventType evtype;
		ThreadMirror thread;
		int req_id;
		long thread_id;

		internal Event (EventType evtype, VirtualMachine vm, int req_id, long thread_id) {
			this.evtype = evtype;
			this.vm = vm;
			this.req_id = req_id;
			this.thread_id = thread_id;
		}

		internal Event (EventType evtype, VirtualMachine vm) {
			this.evtype = evtype;
			this.vm = vm;
			this.thread_id = -1;
		}

		public EventType EventType {
			get {
				return evtype;
			}
		}

		public override string ToString () {
			return evtype.ToString ();
		}

		public ThreadMirror Thread {
			get {
				if (thread_id == -1)
					return null;
				if (thread == null)
					thread = vm.GetThread (thread_id);
				return thread;
			}
	    }

		public EventRequest Request {
			get {
				return vm.GetRequest (req_id);
			}
		}
	}
}

```

`Mono.Debugger.Soft/EventQueueImpl.cs`:

```cs
#if FALSE
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using Mono.Debugger;
using Mono.Debugger.Requests;
using Mono.Debugger.Events;

namespace Mono.Debugger.Soft
{
	class EventQueueImpl : MirrorImpl, EventQueue
	{
		bool disconnected;
		Dictionary<int, byte[]> reply_packets;
		Thread receiver_thread;
		Queue queue;
		object queue_monitor;
		object reply_packets_monitor;

		public EventQueueImpl (VirtualMachineImpl vm) : base (vm) {
			reply_packets = new Dictionary<int, byte[]> ();
			reply_packets_monitor = new Object ();

			queue = new Queue ();
			queue_monitor = new Object ();
			receiver_thread = new Thread (new ThreadStart (receiver_thread_main));
			receiver_thread.Start ();
		}

		public EventSet Remove () {
			if (disconnected)
				// FIXME: VMDisconnectedException
				throw new IOException ();

			lock (queue_monitor) {
				if (queue.Count == 0)
					Monitor.Wait (queue_monitor);
				return (EventSet)queue.Dequeue ();
			}
		}

		public EventSet Remove (int timeout) {
			throw new NotImplementedException ();
		}

		Event DecodeEventInfo (WireProtocol.EventInfo info) {
			EventRequest req = FindRequest (info.requestId);
			if (info.eventKind == WireProtocol.EVENT_VM_START) {
				WireProtocol.VMStartEventInfo einfo = (WireProtocol.VMStartEventInfo)info;
				return new VMStartEventImpl (vm, req, new ThreadReferenceImpl (vm, einfo.thread), new AppDomainMirrorImpl (vm, einfo.domain));
			} else if (info.eventKind == WireProtocol.EVENT_VM_DEATH) {
				return new VMDeathEventImpl (vm, req);
			} else if (info.eventKind == WireProtocol.EVENT_THREAD_START) {
				WireProtocol.ThreadStartEventInfo einfo = (WireProtocol.ThreadStartEventInfo)info;
				return new ThreadStartEventImpl (vm, req, new ThreadReferenceImpl (vm, einfo.thread));
			} else if (info.eventKind == WireProtocol.EVENT_THREAD_DEATH) {
				WireProtocol.ThreadDeathEventInfo einfo = (WireProtocol.ThreadDeathEventInfo)info;
				return new ThreadDeathEventImpl (vm, req, new ThreadReferenceImpl (vm, einfo.thread));
			} else {
				throw new NotImplementedException ();
			}
		}

		EventRequest FindRequest (int requestId) {
			if (requestId == 0)
				return null;
			else
				return ((EventRequestManagerImpl)vm.EventRequestManager).FindRequest (requestId);
		}

		// Wait for the reply for a command packet
		public byte[] WaitForReply (int packetId) {
			while (true) {
				lock (reply_packets_monitor) {
					if (reply_packets.ContainsKey (packetId)) {
						byte[] reply = reply_packets [packetId];
						reply_packets.Remove (packetId);
						return reply;
					} else {
						Monitor.Wait (reply_packets_monitor);
					}
				}
			}
		}

		void add_event_set (EventSet set) {
			lock (queue_monitor) {
				queue.Enqueue (set);
				Monitor.Pulse (queue_monitor);
			}
		}

		void receiver_thread_main () {

			Connection conn = vm.Connection;

			while (true) {
				byte[] packet = conn.ReadPacket ();

				if (packet.Length == 0) {
					disconnected = true;
				
					VMDisconnectEventImpl ev = new VMDisconnectEventImpl (vm, null);
					add_event_set (new EventSetImpl (vm, new Event [] { ev }, SuspendPolicy.SuspendNone));
					break;
				}

				if (WireProtocol.IsReplyPacket (packet)) {
					/* Reply packet */
					int id = WireProtocol.GetPacketId (packet);
					lock (reply_packets_monitor) {
						reply_packets [id] = packet;
						Monitor.PulseAll (reply_packets_monitor);
					}
				} else {
					WireProtocol.Packet decoded = WireProtocol.DecodePacket (packet);
					if (decoded is WireProtocol.Event.CompositePacket) {
						WireProtocol.Event.CompositePacket p = (WireProtocol.Event.CompositePacket)decoded;
						Event[] events = new Event [p.events.Length];
						for (int i = 0; i < p.events.Length; ++i) {
							events [i] = DecodeEventInfo (p.events [i]);
						}

						add_event_set (new EventSetImpl (vm, events, p.suspendPolicy));
					}
				}
			}
		}
    }
}
#endif

```

`Mono.Debugger.Soft/EventRequest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mono.Debugger.Soft
{
	public abstract class EventRequest {
		protected int id;
		protected EventType etype;
		protected bool enabled;
		protected VirtualMachine vm;
		protected SuspendPolicy suspend;
		protected int count;
		protected ThreadMirror thread;
		protected IList<AssemblyMirror> assembly_filter;

		internal EventRequest (VirtualMachine vm, EventType etype) {
			this.vm = vm;
			this.etype = etype;
			this.suspend = SuspendPolicy.All;
		}

		internal EventRequest (EventType etype, int id) {
			this.id = id;
			this.etype = etype;
		}

		internal int Id {
			get {
				return id;
			}
			set {
				id = value;
			}
		}

		public EventType EventType {
			get {
				return etype;
			}
		}

		public bool Enabled {
			get {
				return enabled;
			}
			set {
				if (value != enabled) {
					if (value)
						Enable ();
					else
						Disable ();
				}
			}
		}

		public int Count {
			get {
				return count;
			}
			set {
				CheckDisabled ();
				count = value;
			}
		}

		public ThreadMirror Thread {
			get {
				return thread;
			}
			set {
				CheckDisabled ();
				if (value != null && value.VirtualMachine != vm)
					throw new VMMismatchException ();
				thread = value;
			}
		}

		public IList<AssemblyMirror> AssemblyFilter {
			get {
				return assembly_filter;
			}
			set {
				CheckDisabled ();
				if (value != null) {
					foreach (var ass in value)
						if (ass == null)
							throw new ArgumentException ("one of the elements of the array is null.");
				}
				assembly_filter = value;
			}
		}

		/*
		 * Every time an EventRequest object is enabled, a new JDWP event request
		 * is created, and the event request's id changes.
		 */
		internal void SendReq (List<Modifier> mods) {
			if (!enabled) {
				if (Count > 0)
					mods.Add (new CountModifier () { Count = Count });
				if (Thread != null)
					mods.Add (new ThreadModifier () { Thread = Thread.Id });
				if (AssemblyFilter != null)
					mods.Add (new AssemblyModifier () { Assemblies = AssemblyFilter.Select (x => x.Id ).ToArray () });
				id = vm.conn.EnableEvent (EventType, suspend, mods);
				SetEnabled (id);
			}
		}
				
		public virtual void Enable () {
			SendReq (new List<Modifier> ());
		}

		public void Disable () {
			if (enabled) {
				vm.conn.ClearEventRequest (etype, id);
				enabled = false;
				// FIXME: This causes problems because Events can still reference
				// the old id
				//vm.RemoveRequest (this, id);
				id = -1;
			}
		}

		protected void SetEnabled (int id) {
			this.id = id;
			enabled = true;
			vm.AddRequest (this, id);
		}

		protected void CheckDisabled () {
			if (Enabled)
				throw new InvalidOperationException ("Request objects can only be modified while they are disabled.");
		}

		protected void CheckMirror (VirtualMachine vm, Mirror m) {
			if (vm != m.VirtualMachine)
				throw new VMMismatchException ();
		}
	}
}
```

`Mono.Debugger.Soft/EventSet.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class EventSet {
		protected VirtualMachine vm;
		SuspendPolicy suspend_policy;
		Event[] events;

		internal EventSet (VirtualMachine vm, SuspendPolicy suspend_policy, Event[] events) {
			this.vm = vm;
			this.suspend_policy = suspend_policy;
			this.events = events;
		}

		public SuspendPolicy SuspendPolicy {
			get {
				return suspend_policy;
			}
		}

		public Event[] Events {
			get {
				return events;
			}
		}

		public Event this [int index] {
			get {
				return Events [index];
			}
		}
	}
}

```

`Mono.Debugger.Soft/EventType.cs`:

```cs

namespace Mono.Debugger.Soft
{
	// Keep it in sync with debugger-agent.h
	public enum EventType {
		VMStart = 0,
		VMDeath = 1,
		ThreadStart = 2,
		ThreadDeath = 3,
		AppDomainCreate = 4,
		AppDomainUnload = 5,
		MethodEntry = 6,
		MethodExit = 7,
		AssemblyLoad = 8,
		AssemblyUnload = 9,
		Breakpoint = 10,
		Step = 11,
		TypeLoad = 12,
		Exception = 13,
		KeepAlive = 14,
		//
		// System.Diagnostics.Debugger.Break ()
		//
		UserBreak = 15,
		//
		// System.Diagnostics.Debugger.Log ()
		//
		UserLog = 16,
		// Not part of the wire protocol
		VMDisconnect = 99
	}
}

```

`Mono.Debugger.Soft/ExceptionEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class ExceptionEvent : Event {
		ObjectMirror exc;
		long exc_id;

		internal ExceptionEvent (VirtualMachine vm, int req_id, long thread_id, long exc_id, long loc) : base (EventType.Exception, vm, req_id, thread_id) {
			this.exc_id = exc_id;
		}

		public ObjectMirror Exception {
			get {
				if (exc == null)
					exc = vm.GetObject (exc_id);
				return exc;
			}
		}
	}
}

```

`Mono.Debugger.Soft/ExceptionEventRequest.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public sealed class ExceptionEventRequest : EventRequest {

		TypeMirror exc_type;
		bool caught, uncaught, subclasses;
		
		internal ExceptionEventRequest (VirtualMachine vm, TypeMirror exc_type, bool caught, bool uncaught) : base (vm, EventType.Exception) {
			if (exc_type != null) {
				CheckMirror (vm, exc_type);
				TypeMirror exception_type = vm.RootDomain.Corlib.GetType ("System.Exception", false, false);
				if (!exception_type.IsAssignableFrom (exc_type))
					throw new ArgumentException ("The exception type does not inherit from System.Exception", "exc_type");
			}
			this.exc_type = exc_type;
			this.caught = caught;
			this.uncaught = uncaught;
			this.subclasses = true;
		}

		public TypeMirror ExceptionType {
			get {
				return exc_type;
			}
		}

		// Defaults to true
		// Supported since protocol version 2.25
		public bool IncludeSubclasses {
			get {
				return subclasses;
			}
			set {
				vm.CheckProtocolVersion (2, 25);
				subclasses = value;
			}
		}

		public override void Enable () {
			var mods = new List <Modifier> ();
			mods.Add (new ExceptionModifier () { Type = exc_type != null ? exc_type.Id : 0, Caught = caught, Uncaught = uncaught, Subclasses = subclasses });
			SendReq (mods);
		}
	}
}
```

`Mono.Debugger.Soft/FieldInfoMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using C = Mono.Cecil;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class FieldInfoMirror : Mirror {

		TypeMirror parent;
		string name;
		TypeMirror type;
		FieldAttributes attrs;
		CustomAttributeDataMirror[] cattrs;
		C.FieldDefinition meta;
		bool inited;

		public FieldInfoMirror (TypeMirror parent, long id, string name, TypeMirror type, FieldAttributes attrs) : base (parent.VirtualMachine, id) {
			this.parent = parent;
			this.name = name;
			this.type = type;
			this.attrs = attrs;
			inited = true;
		}

		public FieldInfoMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		public TypeMirror DeclaringType {
			get {
				if (!inited)
					GetInfo ();
				return parent;
			}
		}

		public string Name {
			get {
				if (!inited)
					GetInfo ();
				return name;
			}
		}

		public TypeMirror FieldType {
			get {
				if (!inited)
					GetInfo ();
				return type;
			}
		}

		public FieldAttributes Attributes {
			get {
				if (!inited)
					GetInfo ();
				return attrs;
			}
		}

		void GetInfo () {
			if (inited)
				return;
			var info = vm.conn.Field_GetInfo (id);
			name = info.Name;
			parent = vm.GetType (info.Parent);
			type = vm.GetType (info.TypeId);
			attrs = (FieldAttributes)info.Attrs;
			inited = true;
		}

		public bool IsLiteral
		{
			get {return (Attributes & FieldAttributes.Literal) != 0;}
		} 

		public bool IsStatic
		{
			get {return (Attributes & FieldAttributes.Static) != 0;}
		} 

		public bool IsInitOnly
		{
			get {return (Attributes & FieldAttributes.InitOnly) != 0;}
		}
 
		public Boolean IsPublic
		{ 
			get
			{
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Public;
			}
		}

		public Boolean IsPrivate
		{
			get
			{
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Private;
			}
		}

		public Boolean IsFamily
		{
			get
			{
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family;
			}
		}

		public Boolean IsAssembly
		{
			get
			{
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly;
			}
		}

		public Boolean IsFamilyAndAssembly
		{
			get {
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamANDAssem;
			}
		}

		public Boolean IsFamilyOrAssembly
		{
			get
			{
				return (Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamORAssem;
			}
		}

		public Boolean IsPinvokeImpl
		{
			get
			{
				return (Attributes & FieldAttributes.PinvokeImpl) == FieldAttributes.PinvokeImpl;
			}
		}

		public Boolean IsSpecialName
		{
			get
			{
				return (Attributes & FieldAttributes.SpecialName) == FieldAttributes.SpecialName;
			}
		}

		public Boolean IsNotSerialized
		{
			get
			{
				return (Attributes & FieldAttributes.NotSerialized) == FieldAttributes.NotSerialized;
			}
		}

		public CustomAttributeDataMirror[] GetCustomAttributes (bool inherit) {
			return GetCAttrs (null, inherit);
		}

		public CustomAttributeDataMirror[] GetCustomAttributes (TypeMirror attributeType, bool inherit) {
			if (attributeType == null)
				throw new ArgumentNullException ("attributeType");
			return GetCAttrs (attributeType, inherit);
		}

		public C.FieldDefinition Metadata {		
			get {
				if (parent.Metadata == null)
					return null;
				// FIXME: Speed this up
				foreach (var fd in parent.Metadata.Fields) {
					if (fd.Name == Name) {
						meta = fd;
						break;
					}
				}
				if (meta == null)
					/* Shouldn't happen */
					throw new NotImplementedException ();
				return meta;
			}
		}

		CustomAttributeDataMirror[] GetCAttrs (TypeMirror type, bool inherit) {
			if (cattrs == null && Metadata != null && !Metadata.HasCustomAttributes)
				cattrs = new CustomAttributeDataMirror [0];

			// FIXME: Handle inherit
			if (cattrs == null) {
				CattrInfo[] info = vm.conn.Type_GetFieldCustomAttributes (DeclaringType.Id, id, 0, false);
				cattrs = CustomAttributeDataMirror.Create (vm, info);
			}
			var res = new List<CustomAttributeDataMirror> ();
			foreach (var attr in cattrs)
				if (type == null || attr.Constructor.DeclaringType == type)
					res.Add (attr);
			return res.ToArray ();
		}

		public string FullName {
			get {
				string type_namespace = DeclaringType.Namespace;
				string type_name = DeclaringType.Name;
				StringBuilder sb = new StringBuilder ();
				if (type_namespace != String.Empty)
					sb.Append (type_namespace).Append (".");
				sb.Append (type_name);
				sb.Append (":");
				sb.Append (Name);
				return sb.ToString ();
			}
		}
	}
}


```

`Mono.Debugger.Soft/IInvokeAsyncResult.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public interface IInvokeAsyncResult : IAsyncResult
	{
		void Abort ();
	}
}

```

`Mono.Debugger.Soft/ILExceptionHandler.cs`:

```cs
using System;
using System.IO;

namespace Mono.Debugger.Soft
{
	public enum ILExceptionHandlerType
	{
		Catch = ExceptionClauseFlags.None,
		Filter = ExceptionClauseFlags.Filter,
		Finally = ExceptionClauseFlags.Finally,
		Fault = ExceptionClauseFlags.Fault,
	}

	public class ILExceptionHandler
	{
		public int TryOffset { get; internal set; }
		public int TryLength { get; internal set; }
		public ILExceptionHandlerType HandlerType { get; internal set; }
		public int HandlerOffset { get; internal set; }
		public int HandlerLength { get; internal set;}
		public int FilterOffset { get; internal set; }
		public TypeMirror CatchType { get; internal set; }

		internal ILExceptionHandler (int try_offset, int try_length, ILExceptionHandlerType handler_type, int handler_offset, int handler_length)
		{
			TryOffset = try_offset;
			TryLength = try_length;
			HandlerType = handler_type;
			HandlerOffset = handler_offset;
			HandlerLength = handler_length;
		}
	}
}

```

`Mono.Debugger.Soft/ILInstruction.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using System.IO;
using System.Reflection;

namespace Mono.Debugger.Soft
{
	/*
	 * This is similar to the Instruction class in Cecil, we can't use that
	 * as its constructor is internal.
	 */
	public class ILInstruction
	{
		int offset;
		OpCode opcode;
		object operand;
		ILInstruction prev, next;

		internal ILInstruction (int offset, OpCode opcode, object operand) {
			this.offset = offset;
			this.opcode = opcode;
			this.operand = operand;
		}

		public int Offset {
			get {
				return offset;
			}
		}

		public OpCode OpCode {
			get {
				return opcode;
			}
		}

		public Object Operand {
			get {
				return operand;
			}
			set {
				operand = value;
			}
		}

		public ILInstruction Next {
			get {
				return next;
			}
			set {
				next = value;
			}
		}

		public ILInstruction Previous {
			get {
				return prev;
			}
			set {
				prev = value;
			}
		}
	}
}

```

`Mono.Debugger.Soft/ILInterpreter.cs`:

```cs
using System;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	internal class ILInterpreter
	{
		MethodMirror method;

		public ILInterpreter (MethodMirror method) {
			this.method = method;
		}

		public Value Evaluate (Value this_val, Value[] args) {
			var body = method.GetMethodBody ();

			// Implement only the IL opcodes required to evaluate mcs compiled property accessors:
			// IL_0000:  nop
			// IL_0001:  ldarg.0
			// IL_0002:  ldfld      int32 Tests::field_i
			// IL_0007:  stloc.0
			// IL_0008:  br         IL_000d
			// IL_000d:  ldloc.0
			// IL_000e:  ret
			// ... or returns a simple constant:
			// IL_0000:  ldc.i4 1024
			// IL_0005:  conv.i8
			// IL_0006:  ret
			if (args != null && args.Length != 0)
				throw new NotSupportedException ();

			//If method is virtual we can't optimize(execute IL) because it's maybe
			//overriden... call runtime to invoke overriden version...
			if (method.IsVirtual)
				throw new NotSupportedException ();

			if (method.IsStatic || method.DeclaringType.IsValueType || this_val == null || !(this_val is ObjectMirror))
				throw new NotSupportedException ();

			var instructions = body.Instructions;
			if (instructions.Count < 1 || instructions.Count > 16)
				throw new NotSupportedException ();

			var stack = new Value [16];
			var ins = instructions [0];
			Value locals_0 = null;
			int ins_count = 0;
			int sp = 0;

			while (ins != null) {
				if (ins_count > 16)
					throw new NotImplementedException ();

				var next = ins.Next;
				ins_count++;

				var op = ins.OpCode;
				if (op == OpCodes.Nop) {
				} else if (op == OpCodes.Ldarg_0) {
					if (sp != 0)
						throw new NotSupportedException ();

					stack [sp++] = this_val;
				} else if (op == OpCodes.Ldfld) {
					if (sp != 1)
						throw new NotSupportedException ();

					var obj = (ObjectMirror) stack [--sp];
					var field = (FieldInfoMirror) ins.Operand;
					try {
						stack [sp++] = obj.GetValue (field);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_0) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 0);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_1) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 1);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_2) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 2);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_3) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 3);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_4) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 4);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_5) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 5);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_6) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 6);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_7) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 7);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_8) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, 8);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_M1) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, -1);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, ins.Operand);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I4_S) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, ins.Operand);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_I8) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, ins.Operand);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_R4) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, ins.Operand);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Ldc_R8) {
					if (sp != 0)
						throw new NotSupportedException ();

					try {
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, ins.Operand);
					} catch (ArgumentException) {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_I) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToInt32 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_I1) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToSByte (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_U1) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToByte (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_I2) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToInt16 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_U2) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt16 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_I4) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToInt32 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_U4) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt32 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_I8) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToInt64 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_U8) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt64 (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_R4) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToSingle (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Conv_R8) {
					if (sp != 1)
						throw new NotSupportedException ();

					try {
						var primitive = (PrimitiveValue) stack [--sp];
						stack [sp++] = new PrimitiveValue (method.VirtualMachine, Convert.ToDouble (primitive.Value));
					} catch {
						throw new NotSupportedException ();
					}
				} else if (op == OpCodes.Stloc_0) {
					if (sp != 1)
						throw new NotSupportedException ();

					locals_0 = stack [--sp];
				} else if (op == OpCodes.Br || op == OpCodes.Br_S) {
					next = (ILInstruction) ins.Operand;
				} else if (op == OpCodes.Ldloc_0) {
					if (sp != 0)
						throw new NotSupportedException ();

					stack [sp++] = locals_0;
				} else if (op == OpCodes.Ret) {
					if (sp > 0) {
						var res = stack [--sp];

						var primitive = res as PrimitiveValue;
						if (method.ReturnType.IsPrimitive && primitive != null) {
							// cast the primitive value to the return type
							try {
								switch (method.ReturnType.CSharpName) {
								case "double": res = new PrimitiveValue (method.VirtualMachine, Convert.ToDouble (primitive.Value)); break;
								case "float": res = new PrimitiveValue (method.VirtualMachine, Convert.ToSingle (primitive.Value)); break;
								case "ulong": res = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt64 (primitive.Value)); break;
								case "long": res = new PrimitiveValue (method.VirtualMachine, Convert.ToInt64 (primitive.Value)); break;
								case "uint": res = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt32 (primitive.Value)); break;
								case "int": res = new PrimitiveValue (method.VirtualMachine, Convert.ToInt32 (primitive.Value)); break;
								case "ushort": res = new PrimitiveValue (method.VirtualMachine, Convert.ToUInt16 (primitive.Value)); break;
								case "short": res = new PrimitiveValue (method.VirtualMachine, Convert.ToInt16 (primitive.Value)); break;
								case "sbyte": res = new PrimitiveValue (method.VirtualMachine, Convert.ToSByte (primitive.Value)); break;
								case "byte": res = new PrimitiveValue (method.VirtualMachine, Convert.ToByte (primitive.Value)); break;
								case "char": res = new PrimitiveValue (method.VirtualMachine, Convert.ToChar (primitive.Value)); break;
								case "bool": res = new PrimitiveValue (method.VirtualMachine, Convert.ToBoolean (primitive.Value)); break;
								}
							} catch {
								throw new NotSupportedException ();
							}
						} else if (method.ReturnType.IsEnum && primitive != null) {
							try {
								res = method.VirtualMachine.CreateEnumMirror (method.ReturnType, primitive);
							} catch {
								throw new NotSupportedException ();
							}
						}

						return res;
					}

					return null;
				} else {
					throw new NotSupportedException ();
				}

				ins = next;
			}

			return null;
		}
	}
}

```

`Mono.Debugger.Soft/IMirror.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	/*
	 * A Mirror represents a runtime object in the remote virtual machine. Calling
	 * methods/properties of mirror objects potentially involves a remoting call, 
	 * which
	 * has some overhead, and may also fail. Values of properties which are 
	 * constant (like Type.Name) are cached locally, so only the first call is 
	 * affected.
	 * FIXME: Thread safety in the api ? 
	 */
	public interface IMirror
	{
		VirtualMachine VirtualMachine {
			get;
		}
	}
}

```

`Mono.Debugger.Soft/ITargetProcess.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;

namespace Mono.Debugger.Soft
{
	public interface ITargetProcess
	{
		event System.EventHandler Exited;
		StreamReader StandardOutput { get; }
		StreamReader StandardError { get; }
		bool HasExited { get; }
		void Kill ();
		int Id { get; }
		string ProcessName { get; }
	}
	
	internal class ProcessWrapper: ITargetProcess
	{
		Process process;

		public ProcessWrapper (Process process)
		{
			this.process = process;
		}
		
		public Process Process {
			get { return process; }
		}
		
		public event System.EventHandler Exited {
			add { process.Exited += value; }
			remove { process.Exited -= value; }
		}
		
		public StreamReader StandardOutput {
			get {
				return process.StandardOutput;
			}
		}
		
		public StreamReader StandardError {
			get {
				return process.StandardError;
			}
		}
		
		public bool HasExited {
			get {
				return process.HasExited;
			}
		}
		
		public void Kill ()
		{
			process.Kill ();
		}

		public int Id {
			get {
				return process.Id;
			}
		}
		
		public string ProcessName {
			get {
				return process.ProcessName;
			}
		}
		
		
		
	}
}

```

`Mono.Debugger.Soft/InterfaceMappingMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using C = Mono.Cecil;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class InterfaceMappingMirror : Mirror {

		internal InterfaceMappingMirror (VirtualMachine vm, TypeMirror target, TypeMirror iface, MethodMirror[] iface_methods, MethodMirror[] target_methods) : base (vm, 0) {
			TargetType = target;
			InterfaceType = iface;
			InterfaceMethods = iface_methods;
			TargetMethods = target_methods;
		}

		public MethodMirror[] InterfaceMethods;

		public TypeMirror InterfaceType;

		public MethodMirror[] TargetMethods;

		public TypeMirror TargetType;
	}
}

```

`Mono.Debugger.Soft/InvalidStackFrameException.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class InvalidStackFrameException : Exception {
		
		public InvalidStackFrameException () : base ("The requested operation cannot be completed because the specified stack frame is no longer valid.") {
		}
	}
}

```

`Mono.Debugger.Soft/InvocationException.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public class InvocationException : Exception {

		ObjectMirror exception;

		public InvocationException (ObjectMirror exception) {
			this.exception = exception;
		}

		public ObjectMirror Exception {
			get {
				return exception;
			}
		}
	}
}
```

`Mono.Debugger.Soft/InvokeOptions.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	[Flags]
	public enum InvokeOptions {
		None = 0,
		/*
		 * Disable breakpoints on the thread doing the invoke
		 */
		DisableBreakpoints = 1,
		/*
		 * Only resume the target thread during the invoke
		 */
		SingleThreaded = 2,
		/*
		 * Return the changed receiver when invoking
		 * a valuetype method.
		 */
		ReturnOutThis = 4,
		/*
		 * Return the values of out arguments
		 */
		ReturnOutArgs = 8,
		/*
		 * Do a virtual invoke
		 * Since protocol version 2.37
		 */
		Virtual = 16
	}
}

```

`Mono.Debugger.Soft/LocalScope.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class LocalScope : Mirror {

		MethodMirror method;
		int live_range_start, live_range_end;

	    internal LocalScope (VirtualMachine vm, MethodMirror method, int live_range_start, int live_range_end) : base (vm, 0) {
			this.method = method;
			this.live_range_start = live_range_start;
			this.live_range_end = live_range_end;
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		public int LiveRangeStart {
			get {
				return live_range_start;
			}
		}

		public int LiveRangeEnd {
			get {
				return live_range_end;
			}
		}
	}
}


```

`Mono.Debugger.Soft/LocalVariable.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class LocalVariable : Mirror {

		MethodMirror method;
		string name;
		int index;
		long type_id;
		TypeMirror t;
		bool is_arg;
		int live_range_start, live_range_end;

	    internal LocalVariable (VirtualMachine vm, MethodMirror method, int index, long type_id, string name, int live_range_start, int live_range_end, bool is_arg) : base (vm, 0) {
			this.method = method;
			this.index = index;
			this.name = name;
			this.type_id = type_id;
			this.is_arg = is_arg;
			this.live_range_start = live_range_start;
			this.live_range_end = live_range_end;
		}

		public string Name {
			get {
				return name;
			}
		}

		public int Index {
			get {
				return index;
			}
		}

		public TypeMirror Type {
			get {
				if (t == null)
					t = vm.GetType (type_id);
				return t;
			}
		}

		public bool IsArg {
			get {
				return is_arg;
			}
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		internal int LiveRangeStart {
			get {
				return live_range_start;
			}
		}

		internal int LiveRangeEnd {
			get {
				return live_range_end;
			}
		}

		internal int GetValueIndex {
			get {
				if (IsArg)
					return (-Index) - 1;
				else
					return Index;
			}
		}
	}
}


```

`Mono.Debugger.Soft/Location.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class Location : Mirror
	{
		MethodMirror method;
		//long native_addr;
		int il_offset;
		string source_file;
		int line_number;
		byte[] hash;
		int column_number;
		int end_line_number;
		int end_column_number;
		
		internal Location (VirtualMachine vm, MethodMirror method, long native_addr, int il_offset, string source_file, int line_number, int column_number, int end_line_number, int end_column_number, byte[] hash) : base (vm, 0) {
			this.method = method;
			//this.native_addr = native_addr;
			this.il_offset = il_offset;
			this.source_file = source_file;
			this.line_number = line_number;
			this.hash = hash;
			this.column_number = column_number;
			this.end_line_number = end_line_number;
			this.end_column_number = end_column_number;
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		public int ILOffset {
			get {
				return il_offset;
			}
		}

		public string SourceFile {
			get {
				return source_file;
			}
	    }

		public int LineNumber {
			get {
				return line_number;
			}
	    }

		// Since protocol version 2.19, 0 in earlier protocol versions
		public int ColumnNumber {
			get {
				return column_number;
			}
	    }

		// Since protocol version 2.32, -1 in earlier protocol versions, or if not available
		public int EndLineNumber {
			get {
				return end_line_number;
			}
	    }

		// Since protocol version 2.32, -1 in earlier protocol versions, or if not available
		public int EndColumnNumber {
			get {
				return end_column_number;
			}
	    }

		// MD5 hash of source file
		// Since protocol version 2.14, null in earlier protocol versions
		public byte[] SourceFileHash {
			get {
				return hash;
			}
		}

		public override string ToString () {
			if (EndLineNumber != -1 && EndColumnNumber != -1)
				return String.Format ("{0}+0x{1:x} at {2}:[{3}:{4}-{5}:{6}]", Method.FullName, ILOffset, SourceFile, LineNumber, ColumnNumber, EndLineNumber, EndColumnNumber);
			else
				return String.Format ("{0}+0x{1:x} at {2}:{3}", Method.FullName, ILOffset, SourceFile, LineNumber);
		}
    }
}

```

`Mono.Debugger.Soft/MethodBodyMirror.cs`:

```cs
using System;
using System.Globalization;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using System.IO;
using System.Linq;
using System.Reflection;

namespace Mono.Debugger.Soft
{
	public class MethodBodyMirror : Mirror
	{
		MethodMirror method;
		MethodBodyInfo info;

		internal MethodBodyMirror (VirtualMachine vm, MethodMirror method, MethodBodyInfo info) : base (vm, 0) {
			this.method = method;
			this.info = info;
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		public List<ILExceptionHandler> ExceptionHandlers {
			get {
				vm.CheckProtocolVersion (2, 18);
				return info.clauses.Select (c =>
				{
					var handler = new ILExceptionHandler (c.try_offset, c.try_length, (ILExceptionHandlerType) c.flags, c.handler_offset, c.handler_length);
					if (c.flags == ExceptionClauseFlags.None)
						handler.CatchType = vm.GetType (c.catch_type_id);
					else if (c.flags == ExceptionClauseFlags.Filter)
						handler.FilterOffset = c.filter_offset;

					return handler;
				}).ToList ();
			}
		}

		public byte[] GetILAsByteArray () {
			return info.il;
		}

		public List<ILInstruction> Instructions {
			get {
				return ReadCilBody (new BinaryReader (new MemoryStream (info.il)), info.il.Length);
			}
		}

		static bool opcodes_inited;

		static OpCode [] OneByteOpCode = new OpCode [0xe0 + 1];
		static OpCode [] TwoBytesOpCode = new OpCode [0x1e + 1];

		Dictionary<int, ResolvedToken> tokensCache = new Dictionary<int, ResolvedToken> ();

		ResolvedToken ResolveToken (int token)
		{
			lock (tokensCache) {
				ResolvedToken resolvedToken;
				if (!tokensCache.TryGetValue (token, out resolvedToken)) {
					resolvedToken = vm.conn.Method_ResolveToken (Method.Id, token);
					tokensCache.Add (token, resolvedToken);
				}
				return resolvedToken;
			}
		}

		// Adapted from Cecil
		List<ILInstruction> ReadCilBody (BinaryReader br, int code_size)
		{
			long start = br.BaseStream.Position;
			ILInstruction last = null;
			//GenericContext context = new GenericContext (body.Method);
			List<ILInstruction> code = new List<ILInstruction> ();

			var by_offset = new Dictionary<int, ILInstruction> ();

			if (!opcodes_inited) {
				foreach (FieldInfo fi in typeof (OpCodes).GetFields (BindingFlags.Static|BindingFlags.Public)) {
					var val = (OpCode)fi.GetValue (null);

					if (val.Op1 == 0xff)
						OneByteOpCode [val.Op2] = val;
					else
						TwoBytesOpCode [val.Op2] = val;
				}
				opcodes_inited = true;
			}

			while (br.BaseStream.Position < start + code_size) {
				OpCode op;
				long offset = br.BaseStream.Position - start;
				int cursor = br.ReadByte ();
				int token;
				ResolvedToken t;

				if (cursor == 0xfe)
					op = TwoBytesOpCode [br.ReadByte ()];
				else
					op = OneByteOpCode [cursor];

				ILInstruction instr = new ILInstruction ((int)offset, op, null);

				by_offset [instr.Offset] = instr;

				switch (op.OperandType) {
				case OperandType.InlineNone :
					break;
				case OperandType.InlineSwitch :
					uint length = br.ReadUInt32 ();
					int [] branches = new int [length];
					int [] buf = new int [length];
					for (int i = 0; i < length; i++)
						buf [i] = br.ReadInt32 ();
					for (int i = 0; i < length; i++)
						branches [i] = Convert.ToInt32 (br.BaseStream.Position - start + buf [i]);
					instr.Operand = branches;
					break;
				case OperandType.ShortInlineBrTarget :
					sbyte sbrtgt = br.ReadSByte ();
					instr.Operand = Convert.ToInt32 (br.BaseStream.Position - start + sbrtgt);
					break;
				case OperandType.InlineBrTarget :
					int brtgt = br.ReadInt32 ();
					instr.Operand = Convert.ToInt32 (br.BaseStream.Position - start + brtgt);
					break;
				case OperandType.ShortInlineI :
					if (op == OpCodes.Ldc_I4_S)
						instr.Operand = br.ReadSByte ();
					else
						instr.Operand = br.ReadByte ();
					break;
				case OperandType.ShortInlineVar :
					instr.Operand = br.ReadByte ();
					break;
				case OperandType.ShortInlineArg :
					instr.Operand = br.ReadByte ();
					break;
				case OperandType.InlineSig :
					br.ReadInt32 ();
					//instr.Operand = GetCallSiteAt (br.ReadInt32 (), context);
					break;
				case OperandType.InlineI :
					instr.Operand = br.ReadInt32 ();
					break;
				case OperandType.InlineVar :
					instr.Operand = br.ReadInt16 ();
					break;
				case OperandType.InlineArg :
					instr.Operand = br.ReadInt16 ();
					break;
				case OperandType.InlineI8 :
					instr.Operand = br.ReadInt64 ();
					break;
				case OperandType.ShortInlineR :
					instr.Operand = br.ReadSingle ();
					break;
				case OperandType.InlineR :
					instr.Operand = br.ReadDouble ();
					break;
				case OperandType.InlineString :
					token = br.ReadInt32 ();
					t = ResolveToken (token);
					if (t.Type == TokenType.STRING)
						instr.Operand = t.Str;
					break;
				case OperandType.InlineField :
				case OperandType.InlineMethod :
				case OperandType.InlineType :
				case OperandType.InlineTok :
					token = br.ReadInt32 ();

					t = ResolveToken (token);

					switch (t.Type) {
					case TokenType.TYPE:
						instr.Operand = vm.GetType (t.Id);
						break;
					case TokenType.FIELD:
						instr.Operand = vm.GetField (t.Id);
						break;
					case TokenType.METHOD:
						instr.Operand = vm.GetMethod (t.Id);
						break;
					case TokenType.UNKNOWN:
						break;
					default:
						throw new NotImplementedException ("Unknown token type: " + t.Type);
					}
					break;
				}

				if (last != null) {
					last.Next = instr;
					instr.Previous = last;
				}

				last = instr;

				code.Add (instr);
			}

			// resolve branches
			foreach (ILInstruction i in code) {
				switch (i.OpCode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					i.Operand = by_offset [(int)i.Operand];
					break;
				case OperandType.InlineSwitch:
					int [] lbls = (int []) i.Operand;
					ILInstruction [] instrs = new ILInstruction [lbls.Length];
					for (int j = 0; j < lbls.Length; j++)
						instrs [j] = by_offset [lbls [j]];
					i.Operand = instrs;
					break;
				}
			}

			return code;
		}
	}
}

```

`Mono.Debugger.Soft/MethodEntryEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class MethodEntryEvent : Event {
		MethodMirror method;
		long id;

		internal MethodEntryEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.MethodEntry, vm, req_id, thread_id) {
			this.id = id;
		}

		public MethodMirror Method {
			get {
				if (method == null)
					method = vm.GetMethod (id);
				return method;
			}
		}
	}
}

```

`Mono.Debugger.Soft/MethodEntryEventRequest.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public sealed class MethodEntryEventRequest : EventRequest {

		internal MethodEntryEventRequest (VirtualMachine vm) : base (vm, EventType.MethodEntry) {
		}
	}
}
```

`Mono.Debugger.Soft/MethodExitEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class MethodExitEvent : Event {
		MethodMirror method;
		long id;

		internal MethodExitEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.MethodExit, vm, req_id, thread_id) {
			this.id = id;
		}

		public MethodMirror Method {
			get {
				if (method == null)
					method = vm.GetMethod (id);
				return method;
			}
		}
	}
}

```

`Mono.Debugger.Soft/MethodExitEventRequest.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public sealed class MethodExitEventRequest : EventRequest {

		internal MethodExitEventRequest (VirtualMachine vm) : base (vm, EventType.MethodExit) {
		}
	}
}
```

`Mono.Debugger.Soft/MethodMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using C = Mono.Cecil;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class MethodMirror : Mirror
	{
		string name;
		MethodInfo info;
		TypeMirror declaring_type;
		DebugInfo debug_info;
		C.MethodDefinition meta;
		CustomAttributeDataMirror[] cattrs;
		ParameterInfoMirror[] param_info;
		ParameterInfoMirror ret_param;
		LocalVariable[] locals;
		LocalScope[] scopes;
		IList<Location> locations;
		MethodBodyMirror body;
		MethodMirror gmd;
		TypeMirror[] type_args;

		internal MethodMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		public string Name {
			get {
				if (name == null)
					name = vm.conn.Method_GetName (id);
				return name;
			}
		}

		public TypeMirror DeclaringType {
			get {
				if (declaring_type == null)
					declaring_type = vm.GetType (vm.conn.Method_GetDeclaringType (id));
				return declaring_type;
			}
		}

		public TypeMirror ReturnType {
			get {
				return ReturnParameter.ParameterType;
			}
		}

		// FIXME:
		public string FullName {
			get {
				string type_namespace = DeclaringType.Namespace;
				string type_name = DeclaringType.Name;
				StringBuilder sb = new StringBuilder ();
				sb.Append (ReturnType.Name);
				sb.Append (' ');
				if (type_namespace != String.Empty)
					sb.Append (type_namespace).Append (".");
				sb.Append(type_name);
				sb.Append(":");
				sb.Append(Name);
				sb.Append(" ");
				sb.Append("(");
				for (var i = 0; i < param_info.Length; i++) {
					sb.Append(param_info[i].ParameterType.Name);
					if (i != param_info.Length - 1)
						sb.Append(", ");
				}
				sb.Append(")");
				return sb.ToString ();
			}
		}

		/*
		 * Creating the custom attributes themselves could modify the behavior of the
		 * debuggee, so we return objects similar to the CustomAttributeData objects
		 * used by the reflection-only functionality on .net.
		 * Since protocol version 2.21
		 */
		public CustomAttributeDataMirror[] GetCustomAttributes (bool inherit) {
			return GetCAttrs (null, inherit);
		}

		/* Since protocol version 2.21 */
		public CustomAttributeDataMirror[] GetCustomAttributes (TypeMirror attributeType, bool inherit) {
			if (attributeType == null)
				throw new ArgumentNullException ("attributeType");
			return GetCAttrs (attributeType, inherit);
		}

		CustomAttributeDataMirror[] GetCAttrs (TypeMirror type, bool inherit) {
			if (cattrs == null && meta != null && !Metadata.HasCustomAttributes)
				cattrs = new CustomAttributeDataMirror [0];

			// FIXME: Handle inherit
			if (cattrs == null) {
				CattrInfo[] info = vm.conn.Method_GetCustomAttributes (id, 0, false);
				cattrs = CustomAttributeDataMirror.Create (vm, info);
			}
			var res = new List<CustomAttributeDataMirror> ();
			foreach (var attr in cattrs)
				if (type == null || attr.Constructor.DeclaringType == type)
					res.Add (attr);
			return res.ToArray ();
		}

		MethodInfo GetInfo () {
			if (info == null)
				info = vm.conn.Method_GetInfo (id);
			
			return info;
		}

		public int MetadataToken {
			get {
				return GetInfo ().token;
			}
		}

		public MethodAttributes Attributes {
			get {
				return (MethodAttributes) GetInfo ().attributes;
			}
		}

		public bool IsPublic { 
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Public;
			}
		}
		public bool IsPrivate {
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Private;
			}
		}
		public bool IsFamily {
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Family;
			}
		}
		public bool IsAssembly {
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly;
			}
		}
		public bool IsFamilyAndAssembly {
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamANDAssem;
			}
		}
		public bool IsFamilyOrAssembly {
			get {
				return (Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamORAssem;
			}
		}
		public bool IsStatic {
			get {
				return (Attributes & MethodAttributes.Static) != 0;
			}
		}
		public bool IsFinal {
			get {
				return (Attributes & MethodAttributes.Final) != 0;
			}
		}
		public bool IsVirtual {
			get {
				return (Attributes & MethodAttributes.Virtual) != 0;
			}
		}
		public bool IsHideBySig {
			get {
				return (Attributes & MethodAttributes.HideBySig) != 0;
			}
		}
		public bool IsAbstract {
			get {
				return (Attributes & MethodAttributes.Abstract) != 0;
			}
		}
		public bool IsSpecialName {
			get {
				return (Attributes & MethodAttributes.SpecialName) != 0;
			}
		}

		public bool IsConstructor {
			get {
				int attr = (int)Attributes;
				return ((attr & (int)MethodAttributes.RTSpecialName) != 0
					&& (Name == ".ctor"));
			}
		}

		// Since protocol version 2.12
		public bool IsGenericMethodDefinition {
			get {
				vm.CheckProtocolVersion (2, 12);
				return GetInfo ().is_gmd;
			}
		}

		// Since protocol version 2.12
		public bool IsGenericMethod {
			get {
				vm.CheckProtocolVersion (2, 12);
				return GetInfo ().is_generic_method;
			}
		}

		public MethodImplAttributes GetMethodImplementationFlags() {
			return (MethodImplAttributes)GetInfo ().iattributes;
		}

		public ParameterInfoMirror[] GetParameters () {
			if (param_info == null) {
				var pi = vm.conn.Method_GetParamInfo (id);
				param_info = new ParameterInfoMirror [pi.param_count];
				// Return
				ret_param = new ParameterInfoMirror (this, -1, vm.GetType (pi.ret_type), null, ParameterAttributes.Retval);
				// FIXME: this
				// FIXME: Attributes
				for (int i = 0; i < pi.param_count; ++i) {
					param_info [i] = new ParameterInfoMirror (this, i, vm.GetType (pi.param_types [i]), pi.param_names [i], 0);
				}
			}

			return param_info;
		}

		public ParameterInfoMirror ReturnParameter {
			get {
				if (ret_param == null)
					GetParameters ();
				return ret_param;
			}
		}

		public LocalScope [] GetScopes () {
			vm.CheckProtocolVersion (2, 43);
			GetLocals ();
			return scopes;
		}

		public LocalVariable[] GetLocals () {
			if (locals == null) {
				LocalsInfo li = new LocalsInfo ();
				try {
					li = vm.conn.Method_GetLocalsInfo (id);
				} catch (CommandException) {
					throw new AbsentInformationException ();
				}

				// Add the arguments as well
				var pi = GetParameters ();

				locals = new LocalVariable [pi.Length + li.names.Length];

				for (int i = 0; i < pi.Length; ++i)
					locals [i] = new LocalVariable (vm, this, i, pi[i].ParameterType.Id, pi[i].Name, -1, -1, true);

				for (int i = 0; i < li.names.Length; ++i)
					locals [i + pi.Length] = new LocalVariable (vm, this, i, li.types [i], li.names [i], li.live_range_start [i], li.live_range_end [i], false);

				if (vm.Version.AtLeast (2, 43)) {
					scopes = new LocalScope [li.scopes_start.Length];
					for (int i = 0; i < scopes.Length; ++i)
						scopes [i] = new LocalScope (vm, this, li.scopes_start [i], li.scopes_end [i]);
				}
			}
			return locals;
		}

		public LocalVariable GetLocal (string name) {
			if (name == null)
				throw new ArgumentNullException ("name");

			GetLocals ();

			LocalVariable res = null;
			for (int i = 0; i < locals.Length; ++i) {
				if (locals [i].Name == name) {
					if (res != null)
						throw new AmbiguousMatchException ("More that one local has the name '" + name + "'.");
					res = locals [i];
				}
			}

			return res;
		}

		public MethodBodyMirror GetMethodBody () {
			if (body == null) {
				MethodBodyInfo info = vm.conn.Method_GetBody (id);

				body = new MethodBodyMirror (vm, this, info);
			}
			return body;
		}

		public MethodMirror GetGenericMethodDefinition () {
			vm.CheckProtocolVersion (2, 12);
			if (gmd == null) {
				if (info.gmd == 0)
					throw new InvalidOperationException ();
				gmd = vm.GetMethod (info.gmd);
			}
			return gmd;
		}

		// Since protocol version 2.15
		public TypeMirror[] GetGenericArguments () {
			vm.CheckProtocolVersion (2, 15);
			if (type_args == null)
				type_args = vm.GetTypes (GetInfo ().type_args);
			return type_args;
		}

		// Since protocol version 2.24
		public MethodMirror MakeGenericMethod (TypeMirror[] args) {
			if (args == null)
				throw new ArgumentNullException ("args");
			foreach (var a in args)
				if (a == null)
					throw new ArgumentNullException ("args");

			if (!IsGenericMethodDefinition)
				throw new InvalidOperationException ("not a generic method definition");

			if (GetGenericArguments ().Length != args.Length)
				throw new ArgumentException ("Incorrect length");

			vm.CheckProtocolVersion (2, 24);
			long id = -1;
			try {
				id = vm.conn.Method_MakeGenericMethod (Id, args.Select (t => t.Id).ToArray ());
			} catch (CommandException) {
				throw new InvalidOperationException ();
			}
			return vm.GetMethod (id);
		}

		public IList<int> ILOffsets {
			get {
				if (debug_info == null)
					debug_info = vm.conn.Method_GetDebugInfo (id);
				return Array.AsReadOnly (debug_info.il_offsets);
			}
		}

		public IList<int> LineNumbers {
			get {
				if (debug_info == null)
					debug_info = vm.conn.Method_GetDebugInfo (id);
				return Array.AsReadOnly (debug_info.line_numbers);
			}
		}

		public string SourceFile {
			get {
				if (debug_info == null)
					debug_info = vm.conn.Method_GetDebugInfo (id);
				return debug_info.source_files.Length > 0 ? debug_info.source_files [0].source_file : null;
			}
		}

		public IList<Location> Locations {
			get {
				if (locations == null) {
					var il_offsets = ILOffsets;
					var line_numbers = LineNumbers;
					IList<Location> res = new Location [ILOffsets.Count];
					for (int i = 0; i < il_offsets.Count; ++i)
						res [i] = new Location (vm, this, -1, il_offsets [i], debug_info.source_files [i].source_file, line_numbers [i], debug_info.column_numbers [i], debug_info.end_line_numbers [i], debug_info.end_column_numbers [i], debug_info.source_files [i].hash);
					locations = res;
				}
				return locations;
			}
		}				

		internal int il_offset_to_line_number (int il_offset, out string src_file, out byte[] src_hash, out int column_number, out int end_line_number, out int end_column_number) {
			if (debug_info == null)
				debug_info = vm.conn.Method_GetDebugInfo (id);

			// FIXME: Optimize this
			src_file = null;
			src_hash = null;
			column_number = 0;
			end_line_number = -1;
			end_column_number = -1;
			for (int i = debug_info.il_offsets.Length - 1; i >= 0; --i) {
				if (debug_info.il_offsets [i] <= il_offset) {
					src_file = debug_info.source_files [i].source_file;
					src_hash = debug_info.source_files [i].hash;
					column_number = debug_info.column_numbers [i];
					end_line_number = debug_info.end_line_numbers [i];
					end_column_number = debug_info.end_column_numbers [i];
					return debug_info.line_numbers [i];
				}
			}
			return -1;
		}

		public Location LocationAtILOffset (int il_offset) {
			IList<Location> locs = Locations;

			// FIXME: Optimize this
			for (int i = locs.Count - 1; i >= 0; --i) {
				if (locs [i].ILOffset <= il_offset)
					return locs [i];
			}

			return null;
		}

		public C.MethodDefinition Metadata {
			get {
				if (meta == null)
					meta = (C.MethodDefinition)DeclaringType.Assembly.Metadata.MainModule.LookupToken (MetadataToken);
				return meta;
			}
		}

		//
		// Evaluate the method on the client using an IL interpreter.
		// Only supports a subset of IL instructions. Doesn't change
		// debuggee state.
		// Returns the result of the evaluation, or null for methods
		// which return void.
		// Throws a NotSupportedException if the method body contains
		// unsupported IL instructions, or if evaluating the method
		// would change debuggee state.
		//
		public Value Evaluate (Value this_val, Value[] args) {
			var interp = new ILInterpreter (this);

			return interp.Evaluate (this_val, args);
		}
	}
}

```

`Mono.Debugger.Soft/Mirror.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public abstract class Mirror : IMirror
	{
		protected VirtualMachine vm;
		protected long id; // The id used in the protocol

		internal Mirror (VirtualMachine vm, long id) {
			this.vm = vm;
			this.id = id;
		}

		internal Mirror () {
		}

		public VirtualMachine VirtualMachine {
			get {
				return vm;
			}
		}

		internal long Id {
			get {
				return id;
			}
		}

		protected void SetVirtualMachine (VirtualMachine vm) {
			this.vm = vm;
		}

		protected void CheckMirror (Mirror m) {
			if (vm != m.VirtualMachine)
				throw new VMMismatchException ();
		}
	}
}

```

`Mono.Debugger.Soft/ModuleMirror.cs`:

```cs
using System;
using Mono.Debugger;
using Mono.Cecil;

namespace Mono.Debugger.Soft
{
	public class ModuleMirror : Mirror
	{
		ModuleInfo info;
		Guid guid;
		AssemblyMirror assembly;

		internal ModuleMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		void ReadInfo () {
			if (info == null)
				info = vm.conn.Module_GetInfo (id);
		}

		public string Name {
			get {
				ReadInfo ();
				return info.Name;
			}
		}

		public string ScopeName {
			get {
				ReadInfo ();
				return info.ScopeName;
			}
		}

		public string FullyQualifiedName {
			get {
				ReadInfo ();
				return info.FQName;
			}
		}

		public Guid ModuleVersionId {
			get {
				if (guid == Guid.Empty) {
					ReadInfo ();
					guid = new Guid (info.Guid);
				}
				return guid;
			}
		}

		public AssemblyMirror Assembly {
			get {
				if (assembly == null) {
					ReadInfo ();
					if (info.Assembly == 0)
						return null;
					assembly = vm.GetAssembly (info.Assembly);
				}
				return assembly;
			}
		}

		// FIXME: Add function to query the guid, check in Metadata
    }
}

```

`Mono.Debugger.Soft/ObjectCollectedException.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class ObjectCollectedException : Exception {
		
		public ObjectCollectedException () : base ("The requested operation cannot be completed because the object has been garbage collected.") {
		}
	}
}

```

`Mono.Debugger.Soft/ObjectMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.Remoting.Messaging;
using System.Threading;
using System.Threading.Tasks;

namespace Mono.Debugger.Soft
{
	public class InvokeResult {
		public Value Result { get; set; }
		//
		// The value of the receiver after the call for calls to valuetype methods or null.
		// Only set when using the InvokeOptions.ReturnOutThis flag.
		// Since protocol version 2.35
		//
		public Value OutThis { get; set; }
		//
		// The value of the arguments after the call
		// Only set when using the InvokeOptions.ReturnOutArgs flag.
		// Since protocol version 2.35
		//
		public Value[] OutArgs { get; set; }
	}

	public class ObjectMirror : Value {
		TypeMirror type;
		AppDomainMirror domain;
	
		internal ObjectMirror (VirtualMachine vm, long id) : base (vm, id) {
		}
	
		internal ObjectMirror (VirtualMachine vm, long id, TypeMirror type, AppDomainMirror domain) : base (vm, id) {
			this.type = type;
			this.domain = domain;
		}

		void GetInfo () {
			var info = vm.conn.Object_GetInfo (id);
			type = vm.GetType (info.type_id);
			domain = vm.GetDomain (info.domain_id);
		}

		public TypeMirror Type {
			get {
				if (type == null) {
					if (vm.conn.Version.AtLeast (2, 5))
						GetInfo ();
					else
				 		type = vm.GetType (vm.conn.Object_GetType (id));
				}
				return type;
			}
		}

		public AppDomainMirror Domain {
			get {
				if (domain == null) {
					if (vm.conn.Version.AtLeast (2, 5))
						GetInfo ();
					else
						domain = vm.GetDomain (vm.conn.Object_GetDomain (id));
				}
				return domain;
			}
		}

		public bool IsCollected {
			get {
				return vm.conn.Object_IsCollected (id);
			}
		}

		public Value GetValue (FieldInfoMirror field) {
			return GetValues (new FieldInfoMirror [] { field }) [0];
		}

		public Value[] GetValues (IList<FieldInfoMirror> fields) {
			if (fields == null)
				throw new ArgumentNullException ("fields");
			foreach (FieldInfoMirror f in fields) {
				if (f == null)
					throw new ArgumentNullException ("field");
				CheckMirror (f);
			}
			long[] ids = new long [fields.Count];
			for (int i = 0; i < fields.Count; ++i)
				ids [i] = fields [i].Id;
			try {
				return vm.DecodeValues (vm.conn.Object_GetValues (id, ids));
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_FIELDID) {
					if (fields.Count == 1)
						throw new ArgumentException (string.Format ("The field '{0}' is not valid for this type.", fields[0].Name));
					throw new ArgumentException ("One of the fields is not valid for this type.", "fields");
				} else
					throw;
			}
		}

		public void SetValues (IList<FieldInfoMirror> fields, Value[] values) {
			if (fields == null)
				throw new ArgumentNullException ("fields");
			if (values == null)
				throw new ArgumentNullException ("values");
			foreach (FieldInfoMirror f in fields) {
				if (f == null)
					throw new ArgumentNullException ("field");
				CheckMirror (f);
			}
			foreach (Value v in values) {
				if (v == null)
					throw new ArgumentNullException ("values");
				CheckMirror (v);
			}
			long[] ids = new long [fields.Count];
			for (int i = 0; i < fields.Count; ++i)
				ids [i] = fields [i].Id;
			try {
				vm.conn.Object_SetValues (id, ids, vm.EncodeValues (values));
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_FIELDID)
					throw new ArgumentException ("One of the fields is not valid for this type.", "fields");
				else if (ex.ErrorCode == ErrorCode.INVALID_ARGUMENT)
					throw new ArgumentException ("One of the values is not valid for its field.", "values");
				else
					throw;
			}
		}

		public void SetValue (FieldInfoMirror field, Value value) {
			SetValues (new FieldInfoMirror [] { field }, new Value [] { value });
		}

		/*
		 * The current address of the object. It can change during garbage 
		 * collections. Use a long since the debuggee might have a different 
		 * pointer size. 
		 */
		public long Address {
			get {
				return vm.conn.Object_GetAddress (id);
			}
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments) {
			return InvokeMethod (vm, thread, method, this, arguments, InvokeOptions.None);
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options) {
			return InvokeMethod (vm, thread, method, this, arguments, options);
		}

		[Obsolete ("Use the overload without the 'vm' argument")]
		public IAsyncResult BeginInvokeMethod (VirtualMachine vm, ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return BeginInvokeMethod (vm, thread, method, this, arguments, options, callback, state);
		}

		public IAsyncResult BeginInvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return BeginInvokeMethod (vm, thread, method, this, arguments, options, callback, state);
		}

		public Value EndInvokeMethod (IAsyncResult asyncResult) {
			return EndInvokeMethodInternal (asyncResult);
		}

		public InvokeResult EndInvokeMethodWithResult (IAsyncResult asyncResult) {
			return  ObjectMirror.EndInvokeMethodInternalWithResult (asyncResult);
		}

		public Task<Value> InvokeMethodAsync (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options = InvokeOptions.None) {
			var tcs = new TaskCompletionSource<Value> ();
			BeginInvokeMethod (thread, method, arguments, options, iar =>
					{
						try {
							tcs.SetResult (EndInvokeMethod (iar));
						} catch (OperationCanceledException) {
							tcs.TrySetCanceled ();
						} catch (Exception ex) {
							tcs.TrySetException (ex);
						}
					}, null);
			return tcs.Task;
		}

		public Task<InvokeResult> InvokeMethodAsyncWithResult (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options = InvokeOptions.None) {
			var tcs = new TaskCompletionSource<InvokeResult> ();
			BeginInvokeMethod (thread, method, arguments, options, iar =>
					{
						try {
							tcs.SetResult (EndInvokeMethodInternalWithResult (iar));
						} catch (OperationCanceledException) {
							tcs.TrySetCanceled ();
						} catch (Exception ex) {
							tcs.TrySetException (ex);
						}
					}, null);
			return tcs.Task;
		}

		//
		// Invoke the members of METHODS one-by-one, calling CALLBACK after each invoke was finished. The IAsyncResult will be marked as completed after all invokes have
		// finished. The callback will be called with a different IAsyncResult that represents one method invocation.
		// From protocol version 2.22.
		//
		public IAsyncResult BeginInvokeMultiple (ThreadMirror thread, MethodMirror[] methods, IList<IList<Value>> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return BeginInvokeMultiple (vm, thread, methods, this, arguments, options, callback, state);
		}

		public void EndInvokeMultiple (IAsyncResult asyncResult) {
			EndInvokeMultipleInternal (asyncResult);
		}

		/*
		 * Common implementation for invokes
		 */

		class InvokeAsyncResult : IInvokeAsyncResult {

			public object AsyncState {
				get; set;
			}

			public WaitHandle AsyncWaitHandle {
				get; set;
			}

			public bool CompletedSynchronously {
				get {
					return false;
				}
			}

			public bool IsCompleted {
				get; set;
			}

			public AsyncCallback Callback {
				get; set;
			}

			public ErrorCode ErrorCode {
				get; set;
			}

			public VirtualMachine VM {
				get; set;
			}

			public ThreadMirror Thread {
				get; set;
			}

			public ValueImpl Value {
				get; set;
			}

			public ValueImpl OutThis {
				get; set;
			}

			public ValueImpl[] OutArgs {
				get; set;
			}

			public ValueImpl Exception {
				get; set;
			}

			public int ID {
				get; set;
			}

			public bool IsMultiple {
				get; set;
			}
			   
			public int NumPending;

			public void Abort ()
			{
				if (ID == 0) // Ooops
					return;

				ObjectMirror.AbortInvoke (VM, Thread, ID);
			}
		}

		internal static IInvokeAsyncResult BeginInvokeMethod (VirtualMachine vm, ThreadMirror thread, MethodMirror method, Value this_obj, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			if (thread == null)
				throw new ArgumentNullException ("thread");
			if (method == null)
				throw new ArgumentNullException ("method");
			if (arguments == null)
				arguments = new Value [0];

			InvokeFlags f = InvokeFlags.NONE;

			if ((options & InvokeOptions.DisableBreakpoints) != 0)
				f |= InvokeFlags.DISABLE_BREAKPOINTS;
			if ((options & InvokeOptions.SingleThreaded) != 0)
				f |= InvokeFlags.SINGLE_THREADED;
			if ((options & InvokeOptions.ReturnOutThis) != 0)
				f |= InvokeFlags.OUT_THIS;
			if ((options & InvokeOptions.ReturnOutArgs) != 0)
				f |= InvokeFlags.OUT_ARGS;
			if ((options & InvokeOptions.Virtual) != 0)
				f |= InvokeFlags.VIRTUAL;

			InvokeAsyncResult r = new InvokeAsyncResult { AsyncState = state, AsyncWaitHandle = new ManualResetEvent (false), VM = vm, Thread = thread, Callback = callback };
			thread.InvalidateFrames ();
			r.ID = vm.conn.VM_BeginInvokeMethod (thread.Id, method.Id, this_obj != null ? vm.EncodeValue (this_obj) : vm.EncodeValue (vm.CreateValue (null)), vm.EncodeValues (arguments), f, InvokeCB, r);

			return r;
		}

		// This is called when the result of an invoke is received
		static void InvokeCB (ValueImpl v, ValueImpl exc, ValueImpl out_this, ValueImpl[] out_args, ErrorCode error, object state) {
			InvokeAsyncResult r = (InvokeAsyncResult)state;

			if (error != 0) {
				r.ErrorCode = error;
			} else {
				r.Value = v;
				r.Exception = exc;
			}

			r.OutThis = out_this;
			r.OutArgs = out_args;

			r.IsCompleted = true;
			((ManualResetEvent)r.AsyncWaitHandle).Set ();

			if (r.Callback != null)
				r.Callback.BeginInvoke (r, null, null);
		}

	    internal static InvokeResult EndInvokeMethodInternalWithResult (IAsyncResult asyncResult) {
			if (asyncResult == null)
				throw new ArgumentNullException ("asyncResult");

			InvokeAsyncResult r = (InvokeAsyncResult)asyncResult;

			if (!r.IsCompleted)
				r.AsyncWaitHandle.WaitOne ();

			if (r.ErrorCode != 0) {
				try {
					r.VM.ErrorHandler (null, new ErrorHandlerEventArgs () { ErrorCode = r.ErrorCode });
				} catch (CommandException ex) {
					if (ex.ErrorCode == ErrorCode.INVALID_ARGUMENT)
						throw new ArgumentException ("Incorrect number or types of arguments", "arguments");

					throw;
				}
				throw new NotImplementedException ();
			} else {
				if (r.Exception != null)
					throw new InvocationException ((ObjectMirror)r.VM.DecodeValue (r.Exception));

				Value out_this = null;
				if (r.OutThis != null)
					out_this = r.VM.DecodeValue (r.OutThis);
				Value[] out_args = null;
				if (r.OutArgs != null)
					out_args = r.VM.DecodeValues (r.OutArgs);

				return new InvokeResult () { Result = r.VM.DecodeValue (r.Value), OutThis = out_this, OutArgs = out_args };
			}
		}

 	    internal static Value EndInvokeMethodInternal (IAsyncResult asyncResult) {
			InvokeResult res = EndInvokeMethodInternalWithResult (asyncResult);
			return res.Result;
		}

	    internal static void EndInvokeMultipleInternal (IAsyncResult asyncResult) {
			if (asyncResult == null)
				throw new ArgumentNullException ("asyncResult");

			InvokeAsyncResult r = (InvokeAsyncResult)asyncResult;

			if (!r.IsCompleted)
				r.AsyncWaitHandle.WaitOne ();
		}

		internal static Value InvokeMethod (VirtualMachine vm, ThreadMirror thread, MethodMirror method, Value this_obj, IList<Value> arguments, InvokeOptions options) {
			return EndInvokeMethodInternal (BeginInvokeMethod (vm, thread, method, this_obj, arguments, options, null, null));
		}

		internal static void AbortInvoke (VirtualMachine vm, ThreadMirror thread, int id)
		{
			vm.conn.VM_AbortInvoke (thread.Id, id);
		}

		//
		// Implementation of InvokeMultiple
		//

		internal static IInvokeAsyncResult BeginInvokeMultiple (VirtualMachine vm, ThreadMirror thread, MethodMirror[] methods, Value this_obj, IList<IList<Value>> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			if (thread == null)
				throw new ArgumentNullException ("thread");
			if (methods == null)
				throw new ArgumentNullException ("methods");
			foreach (var m in methods)
				if (m == null)
					throw new ArgumentNullException ("method");
			if (arguments == null) {
				arguments = new List<IList<Value>> ();
				for (int i = 0; i < methods.Length; ++i)
					arguments.Add (new Value [0]);
			} else {
				// FIXME: Not needed for property evaluation
				throw new NotImplementedException ();
			}
			if (callback == null)
				throw new ArgumentException ("A callback argument is required for this method.", "callback");

			InvokeFlags f = InvokeFlags.NONE;

			if ((options & InvokeOptions.DisableBreakpoints) != 0)
				f |= InvokeFlags.DISABLE_BREAKPOINTS;
			if ((options & InvokeOptions.SingleThreaded) != 0)
				f |= InvokeFlags.SINGLE_THREADED;

			InvokeAsyncResult r = new InvokeAsyncResult { AsyncState = state, AsyncWaitHandle = new ManualResetEvent (false), VM = vm, Thread = thread, Callback = callback, NumPending = methods.Length, IsMultiple = true };

			var mids = new long [methods.Length];
			for (int i = 0; i < methods.Length; ++i)
				mids [i] = methods [i].Id;
			var args = new List<ValueImpl[]> ();
			for (int i = 0; i < methods.Length; ++i)
				args.Add (vm.EncodeValues (arguments [i]));
			thread.InvalidateFrames ();
			r.ID = vm.conn.VM_BeginInvokeMethods (thread.Id, mids, this_obj != null ? vm.EncodeValue (this_obj) : vm.EncodeValue (vm.CreateValue (null)), args, f, InvokeMultipleCB, r);

			return r;
		}

		// This is called when the result of an invoke is received
		static void InvokeMultipleCB (ValueImpl v, ValueImpl exc, ValueImpl out_this, ValueImpl[] out_args, ErrorCode error, object state) {
			var r = (InvokeAsyncResult)state;

			Interlocked.Decrement (ref r.NumPending);

			if (error != 0)
				r.ErrorCode = error;

			if (r.NumPending == 0) {
				r.IsCompleted = true;
				((ManualResetEvent)r.AsyncWaitHandle).Set ();
			}

			// Have to pass another asyncresult to the callback since multiple threads can execute it concurrently with results of multiple invocations
			var r2 = new InvokeAsyncResult { AsyncState = r.AsyncState, AsyncWaitHandle = null, VM = r.VM, Thread = r.Thread, Callback = r.Callback, IsCompleted = true };

			if (error != 0) {
				r2.ErrorCode = error;
			} else {
				r2.Value = v;
				r2.Exception = exc;
			}

			r.Callback.BeginInvoke (r2, null, null);
		}
	}
}

```

`Mono.Debugger.Soft/ParameterInfoMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace Mono.Debugger.Soft
{
	public class ParameterInfoMirror : Mirror {

		MethodMirror method;
		TypeMirror type;
		string name;
		int pos;
		ParameterAttributes attrs;

		internal ParameterInfoMirror (MethodMirror method, int pos, TypeMirror type, string name, ParameterAttributes attrs) : base (method.VirtualMachine, 0) {
			this.method = method;
			this.pos = pos;
			this.type = type;
			this.name = name;
			this.attrs = attrs;
		}

		public TypeMirror ParameterType {
			get {
				return type;
			}
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		public string Name {
			get {
				return name;
			}
		}

		public int Position {
			get {
				return pos;
			}
		}

		public ParameterAttributes Attributes {
			get {
				return attrs;
			}
		}

		public bool IsRetval {
			get {
				return (Attributes & ParameterAttributes.Retval) != 0;
			}
		}

		public override string ToString () {
			return String.Format ("ParameterInfo ({0})", Name);
		}
	}
}
```

`Mono.Debugger.Soft/PointerValue.cs`:

```cs
// 
// PointerValue.cs
//  
// Author: Jeffrey Stedfast <jeff@xamarin.com>
// 
// Copyright (c) 2012 Xamarin Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	/*
	 * Represents a value of a pointer type in the debuggee
	 */
	public class PointerValue : Value {
		TypeMirror type;
		long addr;

		public PointerValue (VirtualMachine vm, TypeMirror type, long addr) : base (vm, 0) {
			this.type = type;
			this.addr = addr;
		}

		public long Address {
			get { return addr; }
		}

		public TypeMirror Type {
			get { return type; }
		}

		public override bool Equals (object obj) {
			if (obj != null && obj is PointerValue)
				return addr == (obj as PointerValue).addr;
			return base.Equals (obj);
		}

		public override int GetHashCode () {
			return base.GetHashCode ();
		}

		public override string ToString () {
			return string.Format ("PointerValue<({0}) 0x{1:x}>", type.CSharpName, addr);
		}
	}
}

```

`Mono.Debugger.Soft/PrimitiveValue.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	/*
	 * Represents a value of a primitive type in the debuggee
	 */
	public class PrimitiveValue : Value {
		object value;

		public PrimitiveValue (VirtualMachine vm, object value) : base (vm, 0) {
			this.value = value;
		}

		public object Value {
			get {
				return value;
			}
		}

		public override bool Equals (object obj) {
			if (value == obj)
				return true;

			var primitive = obj as PrimitiveValue;
			if (primitive != null)
				return value == primitive.Value;

			return base.Equals (obj);
		}

		public override int GetHashCode () {
			return base.GetHashCode ();
		}

		public override string ToString () {
			object v = Value;

			return "PrimitiveValue<" + (v != null ? v.ToString () : "(null)") + ">";
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments) {
			return ObjectMirror.InvokeMethod (vm, thread, method, this, arguments, InvokeOptions.None);
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options) {
			return ObjectMirror.InvokeMethod (vm, thread, method, this, arguments, options);
		}

		public IAsyncResult BeginInvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return ObjectMirror.BeginInvokeMethod (vm, thread, method, this, arguments, options, callback, state);
		}

		public Value EndInvokeMethod (IAsyncResult asyncResult) {
			return ObjectMirror.EndInvokeMethodInternal (asyncResult);
		}

		public InvokeResult EndInvokeMethodWithResult (IAsyncResult asyncResult) {
			return  ObjectMirror.EndInvokeMethodInternalWithResult (asyncResult);
		}
	}
}
```

`Mono.Debugger.Soft/PropertyInfoMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using C = Mono.Cecil;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class PropertyInfoMirror : Mirror {

		TypeMirror parent;
		string name;
		PropertyAttributes attrs;
		MethodMirror get_method, set_method;
		CustomAttributeDataMirror[] cattrs;
		C.PropertyDefinition meta;

		public PropertyInfoMirror (TypeMirror parent, long id, string name, MethodMirror get_method, MethodMirror set_method, PropertyAttributes attrs) : base (parent.VirtualMachine, id) {
			this.parent = parent;
			this.name = name;
			this.attrs = attrs;
			this.get_method = get_method;
			this.set_method = set_method;
		}

		public TypeMirror DeclaringType {
			get {
				return parent;
			}
		}

		public string Name {
			get {
				return name;
			}
		}

		public TypeMirror PropertyType {
			get {
				if (get_method != null)
					return get_method.ReturnType;
				else {
					ParameterInfoMirror[] parameters = set_method.GetParameters ();
					
					return parameters [parameters.Length - 1].ParameterType;
				}
			}
		}

		public PropertyAttributes Attributes {
			get {
				return attrs;
			}
		}

		public bool IsSpecialName {
			get {return (Attributes & PropertyAttributes.SpecialName) != 0;}
		}

		public MethodMirror GetGetMethod ()
		{
			return GetGetMethod (false);
		}

		public MethodMirror GetGetMethod (bool nonPublic)
		{
			if (get_method != null && (nonPublic || get_method.IsPublic))
				return get_method;
			else
				return null;
		}

		public MethodMirror GetSetMethod ()
		{
			return GetSetMethod (false);
		}

		public MethodMirror GetSetMethod (bool nonPublic)
		{
			if (set_method != null && (nonPublic || set_method.IsPublic))
				return set_method;
			else
				return null;
		}

		public ParameterInfoMirror[] GetIndexParameters()
		{
			if (get_method != null)
				return get_method.GetParameters ();
			return new ParameterInfoMirror [0];
		}

		public C.PropertyDefinition Metadata {		
			get {
				if (parent.Metadata == null)
					return null;
				// FIXME: Speed this up
				foreach (var def in parent.Metadata.Properties) {
					if (def.Name == Name) {
						meta = def;
						break;
					}
				}
				if (meta == null)
					/* Shouldn't happen */
					throw new NotImplementedException ();
				return meta;
			}
		}

		public CustomAttributeDataMirror[] GetCustomAttributes (bool inherit) {
			return GetCAttrs (null, inherit);
		}

		public CustomAttributeDataMirror[] GetCustomAttributes (TypeMirror attributeType, bool inherit) {
			if (attributeType == null)
				throw new ArgumentNullException ("attributeType");
			return GetCAttrs (attributeType, inherit);
		}

		CustomAttributeDataMirror[] GetCAttrs (TypeMirror type, bool inherit) {
			if (cattrs == null && Metadata != null && !Metadata.HasCustomAttributes)
				cattrs = new CustomAttributeDataMirror [0];

			// FIXME: Handle inherit
			if (cattrs == null) {
				CattrInfo[] info = vm.conn.Type_GetPropertyCustomAttributes (DeclaringType.Id, id, 0, false);
				cattrs = CustomAttributeDataMirror.Create (vm, info);
			}
			var res = new List<CustomAttributeDataMirror> ();
			foreach (var attr in cattrs)
				if (type == null || attr.Constructor.DeclaringType == type)
					res.Add (attr);
			return res.ToArray ();
		}
	}
}


```

`Mono.Debugger.Soft/StackFrame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mono.Debugger.Soft
{
	public class StackFrame : Mirror
	{
		ThreadMirror thread;
		AppDomainMirror domain;
		MethodMirror method;
		int il_offset;
		Location location;
		StackFrameFlags flags;

		/*
		 * FIXME: Decide on the way to request/handle debugging information:
		 * - request the info in bulk for all frames/on demand for individual frames
		 * - request the info from the runtime/request only the il offset, and compute
		 *   everything else based on this info using the method debug info.
		 */

		internal StackFrame (VirtualMachine vm, long id, ThreadMirror thread, MethodMirror method, int il_offset, StackFrameFlags flags) : base (vm, id) {
			this.thread = thread;
			this.method = method;
			this.il_offset = il_offset;
			this.flags = flags;
		}

		public ThreadMirror Thread {
			get {
				return thread;
			}
		}

		public AppDomainMirror Domain {
			get {
				if (domain == null) {
					if (vm.Version.AtLeast (2, 38)) {
						try {
							domain = vm.GetDomain (vm.conn.StackFrame_GetDomain (thread.Id, Id));
						} catch (AbsentInformationException) {
							domain = Thread.Domain;
						}
					} else {
						domain = Thread.Domain;
					}
				}

				return domain;
			}
		}

		public MethodMirror Method {
			get {
				return method;
			}
		}

		public Location Location {
			get {
				if (location == null) {
					int line_number;
					string src_file = null;
					byte[] hash = null;
					int column_number = 0;
					int end_line_number = -1;
					int end_column_number = -1;

					if (il_offset == -1)
						line_number = -1;
					else
						line_number = method.il_offset_to_line_number (il_offset, out src_file, out hash, out column_number, out end_line_number, out end_column_number);

					location = new Location (vm, Method, 0, il_offset, src_file != null ? src_file : method.SourceFile, line_number, column_number, end_line_number, end_column_number, hash);
				}
				return location;
			}
		}

		public string FileName {
			get {
				return Location.SourceFile;
			}
		}

		public int ILOffset {
			get {
				return Location.ILOffset;
			}
		}

		public int LineNumber {
			get {
				return Location.LineNumber;
			}
		}

		public int ColumnNumber {
			get {
				return Location.ColumnNumber;
			}
		}

		public int EndLineNumber {
			get {
				return Location.EndLineNumber;
			}
		}

		public int EndColumnNumber {
			get {
				return Location.EndColumnNumber;
			}
		}

		public bool IsDebuggerInvoke {
			get {
				return (flags & StackFrameFlags.DEBUGGER_INVOKE) != 0;
			}
		}

		/*
		 * Whenever this frame transitions to native code. The method associated
		 * with the frame is either an InternalCall or a pinvoke method.
		 */
		public bool IsNativeTransition {
			get {
				return (flags & StackFrameFlags.NATIVE_TRANSITION) != 0;
			}
		}

		public Value GetValue (ParameterInfoMirror param) {
			if (param == null)
				throw new ArgumentNullException ("param");
			if (param.Method != Method)
				throw new ArgumentException ("Parameter doesn't belong to this frame's method.");
			if (param.IsRetval)
				throw new ArgumentException ("Parameter represents the method return value.");

			// FIXME: Liveness
			// FIXME: Allow returning the frame return value if possible
			return vm.DecodeValue (vm.conn.StackFrame_GetValues (thread.Id, Id, new int [] { (- param.Position) - 1 })[0]);
		}

		public Value GetValue (LocalVariable var) {
			if (var == null)
				throw new ArgumentNullException ("var");
			if (var.Method != Method)
				throw new ArgumentException ("Local variable doesn't belong to this frame's method.");

			// FIXME: Liveness
			// FIXME: Check for return value
			// FIXME: Allow returning the frame return value if possible
			return vm.DecodeValue (vm.conn.StackFrame_GetValues (thread.Id, Id, new int [] { var.GetValueIndex } )[0]);
		}

		public Value[] GetValues (LocalVariable[] vars) {
			if (vars == null)
				throw new ArgumentNullException ("vars");
			for (int i = 0; i < vars.Length; ++i) {
				if (vars [i] == null)
					throw new ArgumentNullException ("vars");
				if (vars [i].Method != Method)
					throw new ArgumentException ("Local variable doesn't belong to this frame's method.");
			}
			int[] pos = new int [vars.Length];
			for (int i = 0; i < vars.Length; ++i)
				pos [i] = vars [i].GetValueIndex;
			return vm.DecodeValues (vm.conn.StackFrame_GetValues (thread.Id, Id, pos));
		}

		public Value GetArgument (int pos) {
			return GetValue (Method.GetParameters () [pos]);
		}

		public Value GetThis () {
			return vm.DecodeValue (vm.conn.StackFrame_GetThis (thread.Id, Id));
		}

		// Since protocol version 2.44
		public void SetThis (Value value) {
			if (value == null)
				throw new ArgumentNullException ("value");
			if (Method.IsStatic || !Method.DeclaringType.IsValueType)
				throw new InvalidOperationException ("The frame's method needs to be a valuetype instance method.");
			vm.conn.StackFrame_SetThis (thread.Id, Id, vm.EncodeValue (value));
		}

		public void SetValue (LocalVariable var, Value value) {
			if (var == null)
				throw new ArgumentNullException ("var");
			if (var.Method != Method)
				throw new ArgumentException ("Local variable doesn't belong to this frame's method.");
			if (value == null)
				throw new ArgumentNullException ("value");
			CheckMirror (value);
			// FIXME: Liveness
			// FIXME: Check for return value
			try {
				vm.conn.StackFrame_SetValues (thread.Id, Id, new int [] { var.GetValueIndex }, new ValueImpl [] { vm.EncodeValue (value) });
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_ARGUMENT)
					throw new ArgumentException ("Value does not match the type of the local variable.");
				else
					throw;
			}
		}

		public void SetValue (ParameterInfoMirror param, Value value) {
			if (param == null)
				throw new ArgumentNullException ("param");
			if (param.Method != Method)
				throw new ArgumentException ("Parameter doesn't belong to this frame's method.");
			if (param.IsRetval)
				throw new ArgumentException ("Parameter represents the method return value.");
			if (value == null)
				throw new ArgumentNullException ("value");
			CheckMirror (value);

			// FIXME: Liveness
			// FIXME: Allow setting the frame return value if possible
			try {
				vm.conn.StackFrame_SetValues (thread.Id, Id, new int [] { (- param.Position) - 1 }, new ValueImpl [] { vm.EncodeValue (value) });
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_ARGUMENT)
					throw new ArgumentException ("Value does not match the type of the variable.");
				else
					throw;
			}
		}

		public IList<LocalVariable> GetVisibleVariables () {
			if (Location.ILOffset == -1)
				throw new AbsentInformationException ();

			return Method.GetLocals ().Where (l => l.LiveRangeStart <= location.ILOffset && l.LiveRangeEnd >= location.ILOffset).ToList ();
		}

		public LocalVariable GetVisibleVariableByName (string name) {
			if (name == null)
				throw new ArgumentNullException ("name");

			if (Location.ILOffset == -1)
				throw new AbsentInformationException ();

			return Method.GetLocals ().Where (l => l.LiveRangeStart <= location.ILOffset && l.LiveRangeEnd >= location.ILOffset && l.Name == name).FirstOrDefault ();
		}
    }
}

```

`Mono.Debugger.Soft/StepEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class StepEvent : Event {
		MethodMirror method;
		long id, loc;

		internal StepEvent (VirtualMachine vm, int req_id, long thread_id, long id, long loc) : base (EventType.Step, vm, req_id, thread_id) {
			this.id = id;
			this.loc = loc;
		}

		public MethodMirror Method {
			get {
				if (method == null)
					method = vm.GetMethod (id);
				return method;
			}
		}

		public long Location {
			get {
				return loc;
			}
		}
	}
}

```

`Mono.Debugger.Soft/StepEventRequest.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public enum StepDepth {
		Into = 0,
		Over = 1,
		Out = 2
	}

	public enum StepSize {
		Min = 0,
		Line = 1
	}

	/*
	 * Filter which kinds of methods to skip during single stepping
	 */
	[Flags]
	public enum StepFilter {
		None = 0,
		StaticCtor = 1,
		/* Since protocol version 2.20 */
		/* Methods which have the [DebuggerHidden] attribute */
		/* Before protocol version 2.26, this includes [DebuggerStepThrough] as well */
		DebuggerHidden = 2,
		/* Since protocol version 2.26 */
		/* Methods which have the [DebuggerStepThrough] attribute */
		DebuggerStepThrough = 4,
		/* Since protocol version 2.30 */
		/* Methods which have the [DebuggerNonUserCode] attribute */
		DebuggerNonUserCode = 8
	}

	public sealed class StepEventRequest : EventRequest {

		ThreadMirror step_thread;
		StepDepth depth;
		StepSize size;
		StepFilter filter;
		
		internal StepEventRequest (VirtualMachine vm, ThreadMirror thread) : base (vm, EventType.Step) {
			if (thread == null)
				throw new ArgumentNullException ("thread");
			CheckMirror (vm, thread);
			this.step_thread = thread;
			Depth = StepDepth.Into;
			Size = StepSize.Min;
		}

		public override void Enable () {
			var mods = new List <Modifier> ();
			mods.Add (new StepModifier () { Thread = step_thread.Id, Depth = (int)Depth, Size = (int)Size, Filter = (int)Filter });
			SendReq (mods);
		}

		public new ThreadMirror Thread {
			get {
				return step_thread;
			}
		}

		public StepDepth Depth {
			get {
				return depth;
			}
			set {
				CheckDisabled ();
				depth = value;
			}
		}

		public StepSize Size {
			get {
				return size;
			}
			set {
				CheckDisabled ();
				size = value;
			}
		}

		public StepFilter Filter {
			get {
				return filter;
			}
			set {
				CheckDisabled ();
				filter = value;
			}
		}
	}
}

```

`Mono.Debugger.Soft/StringMirror.cs`:

```cs
using System;
using System.Collections;

namespace Mono.Debugger.Soft
{
	public class StringMirror : ObjectMirror {

		int length;

		internal StringMirror (VirtualMachine vm, long id) : base (vm, id) {
			length = -1;
		}

		internal StringMirror (VirtualMachine vm, long id, TypeMirror type, AppDomainMirror domain) : base (vm, id, type, domain) {
			length = -1;
		}

		public string Value {
			get {
				return vm.conn.String_GetValue (id);
			}
		}

		// Since protocol version 2.10
		public int Length {
			get {
				if (length == -1)
					length = vm.conn.String_GetLength (id);
				return length;
			}
		}

		// Since protocol version 2.10
		public char[] GetChars (int index, int length) {
			// re-ordered to avoid possible integer overflow
			if (index > Length - length)
				throw new ArgumentException (Locale.GetText (
					"index and length do not specify a valid range in string."));

			return vm.conn.String_GetChars (id, index, length);
		}
	}
}

```

`Mono.Debugger.Soft/StructMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Mono.Debugger.Soft
{
	/*
	 * Represents a valuetype value in the debuggee
	 */
	public class StructMirror : Value {
	
		TypeMirror type;
		Value[] fields;

		internal StructMirror (VirtualMachine vm, TypeMirror type, Value[] fields) : base (vm, 0) {
			this.type = type;
			this.fields = fields;
		}

		public TypeMirror Type {
			get {
				return type;
			}
		}

		public Value[] Fields {
			get {
				return fields;
			}
		}

		public Value this [String field] {
			get {
				FieldInfoMirror[] field_info = Type.GetFields ();
				int nf = 0;
				for (int i = 0; i < field_info.Length; ++i) {
					if (!field_info [i].IsStatic) {
						if (field_info [i].Name == field)
							return Fields [nf];
						nf++;
					}
				}
				throw new ArgumentException ("Unknown struct field '" + field + "'.", "field");
			}
			set {
				FieldInfoMirror[] field_info = Type.GetFields ();
				int nf = 0;
				for (int i = 0; i < field_info.Length; ++i) {
					if (!field_info [i].IsStatic) {
						if (field_info [i].Name == field) {
							fields [nf] = value;
							return;
						}
						nf++;
					}
				}
				throw new ArgumentException ("Unknown struct field '" + field + "'.", "field");
			}
		}

		internal void SetFields (Value[] fields) {
			this.fields = fields;
		}

		internal void SetField (int index, Value value) {
			fields [index] = value;
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments) {
			return ObjectMirror.InvokeMethod (vm, thread, method, this, arguments, InvokeOptions.None);
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options) {
			return ObjectMirror.InvokeMethod (vm, thread, method, this, arguments, options);
		}

		[Obsolete ("Use the overload without the 'vm' argument")]
		public IAsyncResult BeginInvokeMethod (VirtualMachine vm, ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return ObjectMirror.BeginInvokeMethod (vm, thread, method, this, arguments, options, callback, state);
		}

		public IAsyncResult BeginInvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return ObjectMirror.BeginInvokeMethod (vm, thread, method, this, arguments, options, callback, state);
		}

		public Value EndInvokeMethod (IAsyncResult asyncResult) {
			var result = ObjectMirror.EndInvokeMethodInternalWithResult (asyncResult);
			var outThis = result.OutThis as StructMirror;
			if (outThis != null) {
				SetFields (outThis.Fields);
			}
			return result.Result;
		}

		public InvokeResult EndInvokeMethodWithResult (IAsyncResult asyncResult) {
			var result = ObjectMirror.EndInvokeMethodInternalWithResult (asyncResult);
			var outThis = result.OutThis as StructMirror;
			if (outThis != null) {
				SetFields (outThis.Fields);
			}
			return result;
		}

		public Task<Value> InvokeMethodAsync (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options = InvokeOptions.None) {
			var tcs = new TaskCompletionSource<Value> ();
			BeginInvokeMethod (thread, method, arguments, options, iar =>
					{
						try {
							tcs.SetResult (EndInvokeMethod (iar));
						} catch (OperationCanceledException) {
							tcs.TrySetCanceled ();
						} catch (Exception ex) {
							tcs.TrySetException (ex);
						}
					}, null);
			return tcs.Task;
		}

		public Task<InvokeResult> InvokeMethodAsyncWithResult (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options = InvokeOptions.None) {
			var tcs = new TaskCompletionSource<InvokeResult> ();
			BeginInvokeMethod (thread, method, arguments, options, iar =>
					{
						try {
							tcs.SetResult (ObjectMirror.EndInvokeMethodInternalWithResult (iar));
						} catch (OperationCanceledException) {
							tcs.TrySetCanceled ();
						} catch (Exception ex) {
							tcs.TrySetException (ex);
						}
					}, null);
			return tcs.Task;
		}
	}
}

```

`Mono.Debugger.Soft/SuspendPolicy.cs`:

```cs

namespace Mono.Debugger.Soft
{
	// Keep it in sync with debugger-agent.h
	public enum SuspendPolicy {
		None = 0,
		EventThread = 1,
		All = 2
	}
}

```

`Mono.Debugger.Soft/ThreadDeathEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class ThreadDeathEvent : Event {
		internal ThreadDeathEvent (VirtualMachine vm, int req_id, long id) : base (EventType.ThreadDeath, vm, req_id, id) {
		}
	}
}

```

`Mono.Debugger.Soft/ThreadMirror.cs`:

```cs
using System;
using System.Threading;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public class ThreadMirror : ObjectMirror
	{
		string name;
		bool cacheInvalid = true;
		bool fetching;
		object fetchingLocker = new object ();
		ManualResetEvent fetchingEvent = new ManualResetEvent (false);
		ThreadInfo info;
		StackFrame[] frames;
		bool threadStateInvalid = true;
		ThreadState threadState;

		internal ThreadMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		internal ThreadMirror (VirtualMachine vm, long id, TypeMirror type, AppDomainMirror domain) : base (vm, id, type, domain) {
		}

		public StackFrame[] GetFrames () {
			FetchFrames (true);
			if (WaitHandle.WaitAny (new []{ vm.conn.DisconnectedEvent, fetchingEvent }) == 0) {
				throw new VMDisconnectedException ();
			}
			return frames;
		}

		internal void InvalidateFrames () {
			cacheInvalid = true;
			threadStateInvalid = true;
		}

		internal void FetchFrames (bool mustFetch = false) {
			lock (fetchingLocker) {
				if (fetching || !cacheInvalid)
					return;
				cacheInvalid = false;
				fetching = true;
				fetchingEvent.Reset ();
			}
			vm.conn.Thread_GetFrameInfo (id, 0, -1, (frame_info) => {
				var framesList = new List<StackFrame> ();
				for (int i = 0; i < frame_info.Length; ++i) {
					var frameInfo = (FrameInfo)frame_info [i];
					var method = vm.GetMethod (frameInfo.method);
					var f = new StackFrame (vm, frameInfo.id, this, method, frameInfo.il_offset, frameInfo.flags);
					if (!(f.IsNativeTransition && !NativeTransitions))
						framesList.Add (f);
				}
				lock (fetchingLocker) {
					vm.AddThreadToInvalidateList (this);
					fetching = false;
					//In case it was invalidated during waiting for response from
					//runtime and mustFetch was set refetch
					if (cacheInvalid && mustFetch) {
						FetchFrames (mustFetch);
						return;
					}
					frames = framesList.ToArray ();
					fetchingEvent.Set ();
				}
			});
		}

		public static void FetchFrames(IList<ThreadMirror> threads)
		{
			if (threads.Count == 0)
				return;
			threads [0].vm.conn.StartBuffering ();
			foreach (var thread in threads) {
				thread.FetchFrames ();
			}
			threads [0].vm.conn.StopBuffering ();
		}

		public string Name {
			get {
				if (name == null)
					name = vm.conn.Thread_GetName (id);
				return name;
			}
		}

		public new long Id {
			get {
				return id;
			}
		}

		public ThreadState ThreadState {
			get {
				if (threadStateInvalid) {
					threadState = (ThreadState) vm.conn.Thread_GetState (id);
					threadStateInvalid = false;
				}
				return threadState;
			}
		}

		public bool IsThreadPoolThread {
			get {
				if (info == null)
					info = vm.conn.Thread_GetInfo (id);
				return info.is_thread_pool;
			}
		}

		long? thread_id;
		/*
		 * Return a unique identifier for this thread, multiple ThreadMirror objects
		 * may have the same ThreadId because of appdomains.
		 */
		public long ThreadId {
			get {
				if (thread_id == null)
				 	thread_id = vm.conn.Thread_GetId (id);
				return (long)thread_id;
			}
		}

		/*
		 * Return the system thread id (TID) for this thread, this id is not unique since
		 * a newly started thread might reuse a dead thread's id.
		 */
		public long TID {
			get {
				return vm.conn.Thread_GetTID (id);
			}
		}

		/*
		 * Get/set whenever GetFrames () should return frames for managed-to-native
		 * transitions, i.e frames whose IsNativeTransition property is set.
		 * This is needed because some clients might not be able to deal with those
		 * frames.
		 */
		public static bool NativeTransitions {
			get; set;
		}

		/*
		 * Set the location where execution will return when this thread is
		 * resumed.
		 * Throws:
		 * ArgumentException - if L doesn't refer to a location in the
		 * current method of this thread.
		 * NotSupportedException - if continuing at L is not supported
		 * for any other reason.
		 * Since protocol version 29.
		 */
		public void SetIP (Location loc) {
			if (loc == null)
				throw new ArgumentNullException ("loc");
			try {
				vm.conn.Thread_SetIP (id, loc.Method.Id, loc.ILOffset);
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_ARGUMENT)
					throw new ArgumentException ("loc doesn't refer to a location in the current method of this thread.", "loc");

				throw;
			}
		}
    }
}

```

`Mono.Debugger.Soft/ThreadStartEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class ThreadStartEvent : Event {
		internal ThreadStartEvent (VirtualMachine vm, int req_id, long id) : base (EventType.ThreadStart, vm, req_id, id) {
		}
	}
}

```

`Mono.Debugger.Soft/TypeLoadEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class TypeLoadEvent : Event {
		TypeMirror type;
		long id;

		internal TypeLoadEvent (VirtualMachine vm, int req_id, long thread_id, long id) : base (EventType.TypeLoad, vm, req_id, thread_id) {
			this.id = id;
		}

		public TypeMirror Type {
			get {
				if (type == null)
					type = vm.GetType (id);
				return type;
			}
		}
	}
}

```

`Mono.Debugger.Soft/TypeLoadEventRequest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Mono.Debugger.Soft
{
	public sealed class TypeLoadEventRequest : EventRequest {
		string[] sourceFiles;
		string[] typeNames;

		internal TypeLoadEventRequest (VirtualMachine vm) : base (vm, EventType.TypeLoad) {
		}

		public string[] SourceFileFilter {
			get {
				return sourceFiles;
			}
			set {
				CheckDisabled ();
				sourceFiles = value;
			}
		}

		public string[] TypeNameFilter {
			get {
				return typeNames;
			}
			set {
				CheckDisabled ();
				typeNames = value;
			}
		}

		public override void Enable () {
			var mods = new List <Modifier> ();
			if (SourceFileFilter != null && SourceFileFilter.Length != 0)
				mods.Add (new SourceFileModifier () { SourceFiles = SourceFileFilter });
			if (TypeNameFilter != null && TypeNameFilter.Length != 0)
				mods.Add (new TypeNameModifier () { TypeNames = TypeNameFilter });
			SendReq (mods);
		}
	}
}
```

`Mono.Debugger.Soft/TypeMirror.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using C = Mono.Cecil;
using Mono.Cecil.Metadata;
using System.Threading.Tasks;

namespace Mono.Debugger.Soft
{
	/*
	 * Represents a type in the remote virtual machine.
	 * It might be better to make this a subclass of Type, but that could be
	 * difficult as some of our methods like GetMethods () return Mirror objects.
	 */
	public class TypeMirror : Mirror
	{
		MethodMirror[] methods;
		AssemblyMirror ass;
		ModuleMirror module;
		C.TypeDefinition meta;
		FieldInfoMirror[] fields;
		PropertyInfoMirror[] properties;
		TypeInfo info;
		TypeMirror base_type, element_type, gtd;
		TypeMirror[] nested;
		CustomAttributeDataMirror[] cattrs;
		TypeMirror[] ifaces;
		Dictionary<TypeMirror, InterfaceMappingMirror> iface_map;
		TypeMirror[] type_args;
		bool cached_base_type;
		bool inited;

		internal const BindingFlags DefaultBindingFlags =
		BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance;

		internal TypeMirror (VirtualMachine vm, long id) : base (vm, id) {
		}

		public string Name {
			get {
				return GetInfo ().name;
			}
		}

		public string Namespace {
			get {
				return GetInfo ().ns;
			}
		}

		public AssemblyMirror Assembly {
			get {
				if (ass == null) {
					ass = vm.GetAssembly (GetInfo ().assembly);
				}
				return ass;
			}
		}

		public ModuleMirror Module {
			get {
				if (module == null) {
					module = vm.GetModule (GetInfo ().module);
				}										   
				return module;
			}
		}

		public int MetadataToken {
			get {
				return GetInfo ().token;
			}
		}

		public TypeAttributes Attributes {
			get {
				return (TypeAttributes)GetInfo ().attributes;
			}
		}

		public TypeMirror BaseType {
			get {
				if (!cached_base_type) {
					base_type = vm.GetType (GetInfo ().base_type);
					cached_base_type = true;
				}
				return base_type;
			}
		}

		public int GetArrayRank () {
			GetInfo ();
			if (info.rank == 0)
				throw new ArgumentException ("Type must be an array type.");
			return info.rank;
		}


		public bool IsAbstract {
			get {
				return (Attributes & TypeAttributes.Abstract) != 0;
			}
		}

		public bool IsAnsiClass {
			get {
				return (Attributes & TypeAttributes.StringFormatMask)
				== TypeAttributes.AnsiClass;
			}
		}

		public bool IsArray {
			get {
				return IsArrayImpl ();
			}
		}

		public bool IsAutoClass {
			get {
				return (Attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass;
			}
		}

		public bool IsAutoLayout {
			get {
				return (Attributes & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout;
			}
		}

		public bool IsByRef {
			get {
				return IsByRefImpl ();
			}
		}

		public bool IsClass {
			get {
				if (IsInterface)
					return false;

				return !IsValueType;
			}
		}

		public bool IsCOMObject {
			get {
				return IsCOMObjectImpl ();
			}
		}

		public bool IsContextful {
			get {
				return IsContextfulImpl ();
			}
		}

		public bool IsEnum {
			get {
				return GetInfo ().is_enum;
			}
		}

		public bool IsExplicitLayout {
			get {
				return (Attributes & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout;
			}
		}

		public bool IsImport {
			get {
				return (Attributes & TypeAttributes.Import) != 0;
			}
		}

		public bool IsInterface {
			get {
				return (Attributes & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface;
			}
		}

		public bool IsLayoutSequential {
			get {
				return (Attributes & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout;
			}
		}

		public bool IsMarshalByRef {
			get {
				return IsMarshalByRefImpl ();
			}
		}

		public bool IsNested {
			get {
				var masked = (Attributes & TypeAttributes.VisibilityMask);

				return masked >= TypeAttributes.NestedPublic && masked <= TypeAttributes.NestedFamORAssem;
			}
		}

		public bool IsNestedAssembly {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly;
			}
		}

		public bool IsNestedFamANDAssem {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem;
			}
		}

		public bool IsNestedFamily {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily;
			}
		}

		public bool IsNestedFamORAssem {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem;
			}
		}

		public bool IsNestedPrivate {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate;
			}
		}

		public bool IsNestedPublic {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic;
			}
		}

		public bool IsNotPublic {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic;
			}
		}

		public bool IsPointer {
			get {
				return IsPointerImpl ();
			}
		}

		public bool IsPrimitive {
			get {
				return IsPrimitiveImpl ();
			}
		}

		public bool IsPublic {
			get {
				return (Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public;
			}
		}

		public bool IsSealed {
			get {
				return (Attributes & TypeAttributes.Sealed) != 0;
			}
		}

		public bool IsSerializable {
			get {
				if ((Attributes & TypeAttributes.Serializable) != 0)
					return true;

				// FIXME:
				return false;
			}
		}

		public bool IsSpecialName {
			get {
				return (Attributes & TypeAttributes.SpecialName) != 0;
			}
		}

		public bool IsUnicodeClass {
			get {
				return (Attributes & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass;
			}
		}

		public bool IsValueType {
			get {
				return IsValueTypeImpl ();
			}
		}

		public bool HasElementType {
			get {
				return HasElementTypeImpl ();
			}
		}

		// Since protocol version 2.12
		public bool IsGenericTypeDefinition {
			get {
				vm.CheckProtocolVersion (2, 12);
				GetInfo ();
				return info.is_gtd;
			}
		}

		public bool IsGenericType {
			get {
				if (vm.Version.AtLeast (2, 12)) {
					return GetInfo ().is_generic_type;
				} else {
					return Name.IndexOf ('`') != -1;
				}
			}
		}

		public TypeMirror GetElementType () {
			GetInfo ();
			if (element_type == null && info.element_type != 0)
				element_type = vm.GetType (info.element_type);
			return element_type;
		}

		public TypeMirror GetGenericTypeDefinition () {
			vm.CheckProtocolVersion (2, 12);
			GetInfo ();
			if (gtd == null) {
				if (info.gtd == 0)
					throw new InvalidOperationException ();
				gtd = vm.GetType (info.gtd);
			}
			return gtd;
		}

		// Since protocol version 2.15
		public TypeMirror[] GetGenericArguments () {
			vm.CheckProtocolVersion (2, 15);
			if (type_args == null)
				type_args = vm.GetTypes (GetInfo ().type_args);
			return type_args;
		}

		public string FullName {
			get {
				return GetInfo ().full_name;
			}
		}

		public string CSharpName {
			get {
				if (IsArray) {
					if (GetArrayRank () == 1)
						return GetElementType ().CSharpName + "[]";
					else {
						string ranks = "";
						for (int i = 0; i < GetArrayRank (); ++i)
							ranks += ',';
						return GetElementType ().CSharpName + "[" + ranks + "]";
					}
				}
				if (IsPrimitive) {
					switch (Name) {
					case "Byte":
						return "byte";
					case "Sbyte":
						return "sbyte";
					case "Char":
						return "char";
					case "UInt16":
						return "ushort";
					case "Int16":
						return "short";
					case "UInt32":
						return "uint";
					case "Int32":
						return "int";
					case "UInt64":
						return "ulong";
					case "Int64":
						return "long";
					case "Single":
						return "float";
					case "Double":
						return "double";
					case "Boolean":
						return "bool";
					default:
						return FullName;
					}
				}
				// FIXME: Only do this for real corlib types
				if (Namespace == "System") {
					string s = Name;
					switch (s) {
					case "Decimal":
						return "decimal";
					case "Object":
						return "object";
					case "String":
						return "string";
					default:
						return FullName;
					}
				} else {
					return FullName;
				}
			}
		}

		public MethodMirror[] GetMethods () {
			if (methods == null) {
				long[] ids = vm.conn.Type_GetMethods (id);
				MethodMirror[] m = new MethodMirror [ids.Length];
				for (int i = 0; i < ids.Length; ++i) {
					m [i] = vm.GetMethod (ids [i]);
				}
				methods = m;
			}
			return methods;
		}

		// FIXME: Sync this with Type
		public MethodMirror GetMethod (string name) {
			foreach (var m in GetMethods ())
				if (m.Name == name)
					return m;
			return null;
		}

		public FieldInfoMirror[] GetFields () {
			if (fields != null)
				return fields;

			string[] names;
			long[] types;
			int[] attrs;
			long[] ids = vm.conn.Type_GetFields (id, out names, out types, out attrs);

			FieldInfoMirror[] res = new FieldInfoMirror [ids.Length];
			for (int i = 0; i < res.Length; ++i)
				res [i] = new FieldInfoMirror (this, ids [i], names [i], vm.GetType (types [i]), (FieldAttributes)attrs [i]);

			fields = res;
			return fields;
		}

		public FieldInfoMirror GetField (string name) {
			if (name == null)
				throw new ArgumentNullException ("name");
			foreach (var f in GetFields ())
				if (f.Name == name)
					return f;
			return null;
		}

		public TypeMirror[] GetNestedTypes ()
		{
			return GetNestedTypes (DefaultBindingFlags);
		}

		public TypeMirror[] GetNestedTypes (BindingFlags bindingAttr) {
			if (nested != null)
				return nested;

			// FIXME: bindingAttr
			GetInfo ();
			var arr = new TypeMirror [info.nested.Length];
			for (int i = 0; i < arr.Length; ++i)
				arr [i] = vm.GetType (info.nested [i]);
			nested = arr;

			return nested;
		}

		public PropertyInfoMirror[] GetProperties () {
			return GetProperties (DefaultBindingFlags);
		}

		public PropertyInfoMirror[] GetProperties (BindingFlags bindingAttr) {
			if (properties != null)
				return properties;

			PropInfo[] info = vm.conn.Type_GetProperties (id);

			PropertyInfoMirror[] res = new PropertyInfoMirror [info.Length];
			for (int i = 0; i < res.Length; ++i)
				res [i] = new PropertyInfoMirror (this, info [i].id, info [i].name, vm.GetMethod (info [i].get_method), vm.GetMethod (info [i].set_method), (PropertyAttributes)info [i].attrs);

			properties = res;
			return properties;
		}

		public PropertyInfoMirror GetProperty (string name) {
			if (name == null)
				throw new ArgumentNullException ("name");
			foreach (var p in GetProperties ())
				if (p.Name == name)
					return p;
			return null;
		}

		public virtual bool IsAssignableFrom (TypeMirror c) {
			if (c == null)
				throw new ArgumentNullException ("c");

			CheckMirror (c);

			// This is complex so do it in the debuggee
			return vm.conn.Type_IsAssignableFrom (id, c.Id);
		}

		public Value GetValue (FieldInfoMirror field) {
			return GetValues (new FieldInfoMirror [] { field }) [0];
		}

		public Value[] GetValues (IList<FieldInfoMirror> fields, ThreadMirror thread) {
			if (fields == null)
				throw new ArgumentNullException ("fields");
			foreach (FieldInfoMirror f in fields) {
				if (f == null)
					throw new ArgumentNullException ("field");
				CheckMirror (f);
			}
			long[] ids = new long [fields.Count];
			for (int i = 0; i < fields.Count; ++i)
				ids [i] = fields [i].Id;
			try {
				return vm.DecodeValues (vm.conn.Type_GetValues (id, ids, thread !=  null ? thread.Id : 0));
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_FIELDID)
					throw new ArgumentException ("One of the fields is not valid for this type.", "fields");
				else
					throw;
			}
		}

		public Value[] GetValues (IList<FieldInfoMirror> fields) {
			return GetValues (fields, null);
		}

		/*
		 * Return the value of the [ThreadStatic] field FIELD on the thread THREAD.
		 */
		public Value GetValue (FieldInfoMirror field, ThreadMirror thread) {
			if (thread == null)
				throw new ArgumentNullException ("thread");
			CheckMirror (thread);
			return GetValues (new FieldInfoMirror [] { field }, thread) [0];
		}

		public void SetValues (IList<FieldInfoMirror> fields, Value[] values) {
			if (fields == null)
				throw new ArgumentNullException ("fields");
			if (values == null)
				throw new ArgumentNullException ("values");
			foreach (FieldInfoMirror f in fields) {
				if (f == null)
					throw new ArgumentNullException ("field");
				CheckMirror (f);
			}
			foreach (Value v in values) {
				if (v == null)
					throw new ArgumentNullException ("values");
				CheckMirror (v);
			}
			long[] ids = new long [fields.Count];
			for (int i = 0; i < fields.Count; ++i)
				ids [i] = fields [i].Id;
			try {
				vm.conn.Type_SetValues (id, ids, vm.EncodeValues (values));
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.INVALID_FIELDID)
					throw new ArgumentException ("One of the fields is not valid for this type.", "fields");
				else
					throw;
			}
		}

		public void SetValue (FieldInfoMirror field, Value value) {
			SetValues (new FieldInfoMirror [] { field }, new Value [] { value });
		}

		public ObjectMirror GetTypeObject () {
			return vm.GetObject (vm.conn.Type_GetObject (id));
		}

		/*
		 * Return a list of source files without path info, where methods of 
		 * this type are defined. Return an empty list if the information is not 
		 * available. 
		 * This can be used by a debugger to find out which types occur in a 
		 * given source file, to filter the list of methods whose locations
		 * have to be checked when placing breakpoints.
		 */
		public string[] GetSourceFiles () {
			return GetSourceFiles (false);
		}

		string[] source_files;
		string[] source_files_full_path;
		public string[] GetSourceFiles (bool returnFullPaths) {
			string[] res = returnFullPaths ? source_files_full_path : source_files;
			if (res == null) {
				res = vm.conn.Type_GetSourceFiles (id, returnFullPaths);
				if (returnFullPaths)
					source_files_full_path = res;
				else
					source_files = res;
			}
			return res;
		}

		public C.TypeDefinition Metadata {
			get {
				if (meta == null) {
					if (Assembly.Metadata == null || MetadataToken == 0)
						return null;
					meta = (C.TypeDefinition)Assembly.Metadata.MainModule.LookupToken (MetadataToken);
				}
				return meta;
			}
		}

		TypeInfo GetInfo () {
			if (info == null)
				info = vm.conn.Type_GetInfo (id);
			return info;
		}

		protected virtual TypeAttributes GetAttributeFlagsImpl () {
			return (TypeAttributes)GetInfo ().attributes;
		}

		protected virtual bool HasElementTypeImpl () {
			return IsArray || IsByRef || IsPointer;
		}

		protected virtual bool IsArrayImpl () {
			return GetInfo ().rank > 0;
		}

		protected virtual bool IsByRefImpl () {
			return GetInfo ().is_byref;
		}

		protected virtual bool IsCOMObjectImpl () {
			return false;
		}

		protected virtual bool IsPointerImpl () {
			return GetInfo ().is_pointer;
		}

		protected virtual bool IsPrimitiveImpl () {
			return GetInfo ().is_primitive;
		}

		protected virtual bool IsValueTypeImpl ()
		{
			return GetInfo ().is_valuetype;
		}
		
		protected virtual bool IsContextfulImpl ()
		{
			// FIXME:
			return false;
		}

		protected virtual bool IsMarshalByRefImpl ()
		{
			// FIXME:
			return false;
		}

		// Same as Enum.GetUnderlyingType ()
		public TypeMirror EnumUnderlyingType {
			get {
				if (!IsEnum)
					throw new ArgumentException ("Type is not an enum type.");
				foreach (FieldInfoMirror f in GetFields ()) {
					if (!f.IsStatic)
						return f.FieldType;
				}
				throw new NotImplementedException ();
			}
		}

		/*
		 * Creating the custom attributes themselves could modify the behavior of the
		 * debuggee, so we return objects similar to the CustomAttributeData objects
		 * used by the reflection-only functionality on .net.
		 */
		public CustomAttributeDataMirror[] GetCustomAttributes (bool inherit) {
			return GetCustomAttrs (null, inherit);
		}

		public CustomAttributeDataMirror[] GetCustomAttributes (TypeMirror attributeType, bool inherit) {
			if (attributeType == null)
				throw new ArgumentNullException ("attributeType");
			return GetCustomAttrs (attributeType, inherit);
		}

		void AppendCustomAttrs (IList<CustomAttributeDataMirror> attrs, TypeMirror type, bool inherit)
		{
			if (cattrs == null && Metadata != null && !Metadata.HasCustomAttributes)
				cattrs = new CustomAttributeDataMirror [0];

			if (cattrs == null) {
				CattrInfo[] info = vm.conn.Type_GetCustomAttributes (id, 0, false);
				cattrs = CustomAttributeDataMirror.Create (vm, info);
			}

			foreach (var attr in cattrs) {
				if (type == null || attr.Constructor.DeclaringType == type)
					attrs.Add (attr);
			}

			if (inherit && BaseType != null)
				BaseType.AppendCustomAttrs (attrs, type, inherit);
		}

		CustomAttributeDataMirror[] GetCustomAttrs (TypeMirror type, bool inherit) {
			var attrs = new List<CustomAttributeDataMirror> ();
			AppendCustomAttrs (attrs, type, inherit);
			return attrs.ToArray ();
		}

		public MethodMirror[] GetMethodsByNameFlags (string name, BindingFlags flags, bool ignoreCase) {
			if (vm.conn.Version.AtLeast (2, 6)) {
				long[] ids = vm.conn.Type_GetMethodsByNameFlags (id, name, (int)flags, ignoreCase);
				MethodMirror[] m = new MethodMirror [ids.Length];
				for (int i = 0; i < ids.Length; ++i)
					m [i] = vm.GetMethod (ids [i]);
				return m;
			} else {
				if ((flags & BindingFlags.IgnoreCase) != 0) {
					flags &= ~BindingFlags.IgnoreCase;
					ignoreCase = true;
				}
				
				if (flags == BindingFlags.Default)
					flags = BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Instance|BindingFlags.Static;
				
				MethodAttributes access = (MethodAttributes) 0;
				bool matchInstance = false;
				bool matchStatic = false;
				
				if ((flags & BindingFlags.NonPublic) != 0) {
					access |= MethodAttributes.Private;
					flags &= ~BindingFlags.NonPublic;
				}
				if ((flags & BindingFlags.Public) != 0) {
					access |= MethodAttributes.Public;
					flags &= ~BindingFlags.Public;
				}
				if ((flags & BindingFlags.Instance) != 0) {
					flags &= ~BindingFlags.Instance;
					matchInstance = true;
				}
				if ((flags & BindingFlags.Static) != 0) {
					flags &= ~BindingFlags.Static;
					matchStatic = true;
				}
				
				if ((int) flags != 0)
					throw new NotImplementedException ();
				
				var res = new List<MethodMirror> ();
				foreach (MethodMirror m in GetMethods ()) {
					if ((m.Attributes & access) == (MethodAttributes) 0)
						continue;
					
					if (!((matchStatic && m.IsStatic) || (matchInstance && !m.IsStatic)))
						continue;
					
					if ((!ignoreCase && m.Name == name) || (ignoreCase && m.Name.Equals (name, StringComparison.CurrentCultureIgnoreCase)))
						res.Add (m);
				}
				return res.ToArray ();
			}
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments) {
			return ObjectMirror.InvokeMethod (vm, thread, method, null, arguments, InvokeOptions.None);
		}

		public Value InvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options) {
			return ObjectMirror.InvokeMethod (vm, thread, method, null, arguments, options);
		}

		[Obsolete ("Use the overload without the 'vm' argument")]
		public IAsyncResult BeginInvokeMethod (VirtualMachine vm, ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return ObjectMirror.BeginInvokeMethod (vm, thread, method, null, arguments, options, callback, state);
		}

		public IAsyncResult BeginInvokeMethod (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options, AsyncCallback callback, object state) {
			return ObjectMirror.BeginInvokeMethod (vm, thread, method, null, arguments, options, callback, state);
		}

		public Value EndInvokeMethod (IAsyncResult asyncResult) {
			return ObjectMirror.EndInvokeMethodInternal (asyncResult);
		}

		public InvokeResult EndInvokeMethodWithResult (IAsyncResult asyncResult) {
			return  ObjectMirror.EndInvokeMethodInternalWithResult (asyncResult);
		}

		public Task<Value> InvokeMethodAsync (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options = InvokeOptions.None) {
			var tcs = new TaskCompletionSource<Value> ();
			BeginInvokeMethod (thread, method, arguments, options, iar =>
					{
						try {
							tcs.SetResult (EndInvokeMethod (iar));
						} catch (OperationCanceledException) {
							tcs.TrySetCanceled ();
						} catch (Exception ex) {
							tcs.TrySetException (ex);
						}
					}, null);
			return tcs.Task;
		}

		public Value NewInstance (ThreadMirror thread, MethodMirror method, IList<Value> arguments) {
			return NewInstance (thread, method, arguments, InvokeOptions.None);
		}			

		public Value NewInstance (ThreadMirror thread, MethodMirror method, IList<Value> arguments, InvokeOptions options) {
			if (method == null)
				throw new ArgumentNullException ("method");

			if (!method.IsConstructor)
				throw new ArgumentException ("The method must be a constructor.", "method");

			return ObjectMirror.InvokeMethod (vm, thread, method, null, arguments, options);
		}

		// Since protocol version 2.31
		public Value NewInstance () {
			return vm.GetObject (vm.conn.Type_CreateInstance (id));
		}

		// Since protocol version 2.11
		public TypeMirror[] GetInterfaces () {
			if (ifaces == null)
				ifaces = vm.GetTypes (vm.conn.Type_GetInterfaces (id));
			return ifaces;
		}

		// Since protocol version 2.11
		public InterfaceMappingMirror GetInterfaceMap (TypeMirror interfaceType) {
			if (interfaceType == null)
				throw new ArgumentNullException ("interfaceType");
			if (!interfaceType.IsInterface)
				throw new ArgumentException ("Argument must be an interface.", "interfaceType");
			if (IsInterface)
				throw new ArgumentException ("'this' type cannot be an interface itself");

			if (iface_map == null) {
				// Query the info in bulk
				GetInterfaces ();
				var ids = new long [ifaces.Length];
				for (int i = 0; i < ifaces.Length; ++i)
					ids [i] = ifaces [i].Id;

				var ifacemap = vm.conn.Type_GetInterfaceMap (id, ids);

				var imap = new Dictionary<TypeMirror, InterfaceMappingMirror> ();
				for (int i = 0; i < ifacemap.Length; ++i) {
					IfaceMapInfo info = ifacemap [i];

					MethodMirror[] imethods = new MethodMirror [info.iface_methods.Length];
					for (int j = 0; j < info.iface_methods.Length; ++j)
						imethods [j] = vm.GetMethod (info.iface_methods [j]);

					MethodMirror[] tmethods = new MethodMirror [info.iface_methods.Length];
					for (int j = 0; j < info.target_methods.Length; ++j)
						tmethods [j] = vm.GetMethod (info.target_methods [j]);

					InterfaceMappingMirror map = new InterfaceMappingMirror (vm, this, vm.GetType (info.iface_id), imethods, tmethods);

					imap [map.InterfaceType] = map;
				}

				iface_map = imap;
			}

			InterfaceMappingMirror res;
			if (!iface_map.TryGetValue (interfaceType, out res))
				throw new ArgumentException ("Interface not found", "interfaceType");
			return res;
		}

		// Return whenever the type initializer of this type has ran
		// Since protocol version 2.23
		public bool IsInitialized {
			get {
				vm.CheckProtocolVersion (2, 23);
				if (!inited)
					inited = vm.conn.Type_IsInitialized (id);
				return inited;
			}
		}
    }
}

```

`Mono.Debugger.Soft/UserBreakEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class UserBreakEvent : Event {
		internal UserBreakEvent (VirtualMachine vm, int req_id, long thread_id) : base (EventType.UserBreak, vm, req_id, thread_id) {
		}
	}
}

```

`Mono.Debugger.Soft/UserLogEvent.cs`:

```cs

namespace Mono.Debugger.Soft
{
	public class UserLogEvent : Event {

		int level;
		string category, message;

		internal UserLogEvent (VirtualMachine vm, int req_id, long thread_id, int level, string category, string message) : base (EventType.UserLog, vm, req_id, thread_id) {
			this.level = level;
			this.category = category;
			this.message = message;
		}

		public int Level {
			get {
				return level;
			}
		}

		public string Category {
			get {
				return category;
			}
		}

		public string Message {
			get {
				return message;
			}
		}
	}
}

```

`Mono.Debugger.Soft/VMDeathEvent.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class VMDeathEvent : Event
	{
		int exit_code;

		public VMDeathEvent (VirtualMachine vm, int req_id, int exit_code) : base (EventType.VMDeath, vm, req_id, -1) {
			this.exit_code = exit_code;
		}

		// Since protocol version 2.27
		public int ExitCode {
			get {
				vm.CheckProtocolVersion (2, 27);
				return exit_code;
			}
		}
    }
}

```

`Mono.Debugger.Soft/VMDisconnectEvent.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class VMDisconnectEvent : Event
	{
		public VMDisconnectEvent (VirtualMachine vm, int req_id) : base (EventType.VMDisconnect, vm, req_id, -1) {
		}
    }
}

```

`Mono.Debugger.Soft/VMDisconnectedException.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class VMDisconnectedException : Exception {
		
		public VMDisconnectedException () : base () {
		}
	}
}

```

`Mono.Debugger.Soft/VMMismatchException.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class VMMismatchException : Exception
	{
		public VMMismatchException () : base () {
		}
	}
}

```

`Mono.Debugger.Soft/VMStartEvent.cs`:

```cs
using System;

namespace Mono.Debugger.Soft
{
	public class VMStartEvent : Event
	{
		public VMStartEvent (VirtualMachine vm, int req_id, long thread_id) : base (EventType.VMStart, vm, req_id, thread_id) {
		}
    }
}

```

`Mono.Debugger.Soft/Value.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Mono.Debugger.Soft
{
	public abstract class Value : Mirror {

		// FIXME: Add a 'Value' field

		internal Value (VirtualMachine vm, long id) : base (vm, id) {
		}
	}
}


```

`Mono.Debugger.Soft/VirtualMachine.cs`:

```cs
using System;
using System.IO;
using System.Threading;
using System.Net;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using Mono.Cecil.Metadata;

namespace Mono.Debugger.Soft
{
	public class VirtualMachine : Mirror
	{
		Queue queue;
		object queue_monitor;
		object startup_monitor;
		AppDomainMirror root_domain;
		Dictionary<int, EventRequest> requests;
		ITargetProcess process;

		internal Connection conn;

		VersionInfo version;

		internal VirtualMachine (ITargetProcess process, Connection conn) : base () {
			SetVirtualMachine (this);
			queue = new Queue ();
			queue_monitor = new Object ();
			startup_monitor = new Object ();
			requests = new Dictionary <int, EventRequest> ();
			this.conn = conn;
			this.process = process;
			conn.ErrorHandler += ErrorHandler;
		}

		// The standard output of the process is available normally through Process
		public StreamReader StandardOutput { get; set; }
		public StreamReader StandardError { get; set; }

		
		public Process Process {
			get {
				ProcessWrapper pw = process as ProcessWrapper;
				if (pw == null)
				    throw new InvalidOperationException ("Process instance not available");
				return pw.Process;
			}
		}

		public ITargetProcess TargetProcess {
			get {
				return process;
			}
		}

		public AppDomainMirror RootDomain {
			get {
				return root_domain;
			}
	    }

		public EndPoint EndPoint {
			get {
				var tcpConn = conn as TcpConnection;
				if (tcpConn != null)
					return tcpConn.EndPoint;
				return null;
			}
		}

		public VersionInfo Version {
			get {
				return version;
			}
		}

		EventSet current_es;
		int current_es_index;

		/*
		 * It is impossible to determine when to resume when using this method, since
		 * the debuggee is suspended only once per event-set, not event.
		 */
		[Obsolete ("Use GetNextEventSet () instead")]
		public Event GetNextEvent () {
			lock (queue_monitor) {
				if (current_es == null || current_es_index == current_es.Events.Length) {
					if (queue.Count == 0)
						Monitor.Wait (queue_monitor);
					current_es = (EventSet)queue.Dequeue ();
					current_es_index = 0;
				}
				return current_es.Events [current_es_index ++];
			}
		}

		public Event GetNextEvent (int timeout) {
			throw new NotImplementedException ();
		}

		public EventSet GetNextEventSet () {
			lock (queue_monitor) {
				if (queue.Count == 0)
					Monitor.Wait (queue_monitor);

				current_es = null;
				current_es_index = 0;

				return (EventSet)queue.Dequeue ();
			}
		}

		[Obsolete ("Use GetNextEventSet () instead")]
		public T GetNextEvent<T> () where T : Event {
			return GetNextEvent () as T;
		}

		public void Suspend () {
			conn.VM_Suspend ();
	    }

		public void Resume () {
			try {
				InvalidateThreadAndFrameCaches ();
				conn.VM_Resume ();
			} catch (CommandException ex) {
				if (ex.ErrorCode == ErrorCode.NOT_SUSPENDED)
					throw new VMNotSuspendedException ();

				throw;
			}
	    }

		public void Exit (int exitCode) {
			conn.VM_Exit (exitCode);
		}

		public void Detach () {
			conn.VM_Dispose ();
			conn.Close ();
			notify_vm_event (EventType.VMDisconnect, SuspendPolicy.None, 0, 0, null, 0);
		}

		[Obsolete ("This method was poorly named; use the Detach() method instead")]
		public void Dispose ()
		{
			Detach ();
		}

		public void ForceDisconnect ()
		{
			conn.ForceDisconnect ();
		}

		HashSet<ThreadMirror> threadsToInvalidate = new HashSet<ThreadMirror> ();
		ThreadMirror[] threadCache;
		object threadCacheLocker = new object ();

		void InvalidateThreadAndFrameCaches () {
			lock (threadsToInvalidate) {
				foreach (var thread in threadsToInvalidate)
					thread.InvalidateFrames ();
				threadsToInvalidate.Clear ();
			}
			threadCache = null;
		}

		internal void InvalidateThreadCache () {
			threadCache = null;
		}

		internal void AddThreadToInvalidateList (ThreadMirror threadMirror)
		{
			lock (threadsToInvalidate) {
				threadsToInvalidate.Add (threadMirror);
			}
		}

		public IList<ThreadMirror> GetThreads () {
			var threads = threadCache;
			if (threads == null) {
				long[] ids = null;
				var fetchingEvent = new ManualResetEvent (false);
				vm.conn.VM_GetThreads ((threadsIds) => {
					ids = threadsIds;
					threadCache = threads = new ThreadMirror [threadsIds.Length];
					fetchingEvent.Set ();
				});
				if (WaitHandle.WaitAny (new []{ vm.conn.DisconnectedEvent, fetchingEvent }) == 0) {
					throw new VMDisconnectedException ();
				}
				for (int i = 0; i < ids.Length; ++i)
					threads [i] = GetThread (ids [i]);
				//Uncomment lines below if you want to re-fetch threads if new threads were started/stopped while
				//featching threads... This is probably more correct but might cause deadlock of this method if runtime
				//is starting/stopping threads nonstop, need way to prevent this(counting number of recursions?)
				//possiblity before uncommenting
				//if (threadCache != threads) {//While fetching threads threadCache was invalidated(thread was created/destoyed)
				//	return GetThreads ();
				//}
				return threads;
			} else {
				return threads;
			}
		}

		// Same as the mirrorOf methods in JDI
		public PrimitiveValue CreateValue (object value) {
			if (value == null)
				return new PrimitiveValue (vm, null);

			if (!value.GetType ().IsPrimitive)
				throw new ArgumentException ("value must be of a primitive type instead of '" + value.GetType () + "'", "value");

			return new PrimitiveValue (vm, value);
		}

		public EnumMirror CreateEnumMirror (TypeMirror type, PrimitiveValue value) {
			return new EnumMirror (this, type, value);
		}

		//
		// Enable send and receive timeouts on the connection and send a keepalive event
		// every 'keepalive_interval' milliseconds.
		//

		public void SetSocketTimeouts (int send_timeout, int receive_timeout, int keepalive_interval)
		{
			conn.SetSocketTimeouts (send_timeout, receive_timeout, keepalive_interval);
		}

		//
		// Methods to create event request objects
		//
		public BreakpointEventRequest CreateBreakpointRequest (MethodMirror method, long il_offset) {
			return new BreakpointEventRequest (this, method, il_offset);
		}

		public BreakpointEventRequest CreateBreakpointRequest (Location loc) {
			if (loc == null)
				throw new ArgumentNullException ("loc");
			CheckMirror (loc);
			return new BreakpointEventRequest (this, loc.Method, loc.ILOffset);
		}

		public StepEventRequest CreateStepRequest (ThreadMirror thread) {
			return new StepEventRequest (this, thread);
		}

		public MethodEntryEventRequest CreateMethodEntryRequest () {
			return new MethodEntryEventRequest (this);
		}

		public MethodExitEventRequest CreateMethodExitRequest () {
			return new MethodExitEventRequest (this);
		}

		public ExceptionEventRequest CreateExceptionRequest (TypeMirror exc_type) {
			return new ExceptionEventRequest (this, exc_type, true, true);
		}

		public ExceptionEventRequest CreateExceptionRequest (TypeMirror exc_type, bool caught, bool uncaught) {
			return new ExceptionEventRequest (this, exc_type, caught, uncaught);
		}

		public AssemblyLoadEventRequest CreateAssemblyLoadRequest () {
			return new AssemblyLoadEventRequest (this);
		}

		public TypeLoadEventRequest CreateTypeLoadRequest () {
			return new TypeLoadEventRequest (this);
		}

		public void EnableEvents (params EventType[] events) {
			EnableEvents (events, SuspendPolicy.All);
		}

		public void EnableEvents (EventType[] events, SuspendPolicy suspendPolicy) {
			foreach (EventType etype in events) {
				if (etype == EventType.Breakpoint)
					throw new ArgumentException ("Breakpoint events cannot be requested using EnableEvents", "events");
				conn.EnableEvent (etype, suspendPolicy, null);
			}
		}

		public BreakpointEventRequest SetBreakpoint (MethodMirror method, long il_offset) {
			BreakpointEventRequest req = CreateBreakpointRequest (method, il_offset);

			req.Enable ();

			return req;
		}

		public void ClearAllBreakpoints () {
			conn.ClearAllBreakpoints ();
		}
		
		public void Disconnect () {
			conn.Close ();
		}

		//
		// Return a list of TypeMirror objects for all loaded types which reference the
		// source file FNAME. Might return false positives.
		// Since protocol version 2.7.
		//
		public IList<TypeMirror> GetTypesForSourceFile (string fname, bool ignoreCase) {
			long[] ids = conn.VM_GetTypesForSourceFile (fname, ignoreCase);
			var res = new TypeMirror [ids.Length];
			for (int i = 0; i < ids.Length; ++i)
				res [i] = GetType (ids [i]);
			return res;
		}

		//
		// Return a list of TypeMirror objects for all loaded types named 'NAME'.
		// NAME should be in the the same for as with Assembly.GetType ().
		// Since protocol version 2.9.
		//
		public IList<TypeMirror> GetTypes (string name, bool ignoreCase) {
			long[] ids = conn.VM_GetTypes (name, ignoreCase);
			var res = new TypeMirror [ids.Length];
			for (int i = 0; i < ids.Length; ++i)
				res [i] = GetType (ids [i]);
			return res;
		}
		
		internal void queue_event_set (EventSet es) {
			lock (queue_monitor) {
				queue.Enqueue (es);
				Monitor.Pulse (queue_monitor);
			}
		}

		internal void ErrorHandler (object sender, ErrorHandlerEventArgs args) {
			switch (args.ErrorCode) {
			case ErrorCode.INVALID_OBJECT:
				throw new ObjectCollectedException ();
			case ErrorCode.INVALID_FRAMEID:
				throw new InvalidStackFrameException ();
			case ErrorCode.NOT_SUSPENDED:
				throw new VMNotSuspendedException ();
			case ErrorCode.NOT_IMPLEMENTED:
				throw new NotSupportedException ("This request is not supported by the protocol version implemented by the debuggee.");
			case ErrorCode.ABSENT_INFORMATION:
				throw new AbsentInformationException ();
			case ErrorCode.NO_SEQ_POINT_AT_IL_OFFSET:
				throw new ArgumentException ("Cannot set breakpoint on the specified IL offset.");
			default:
				throw new CommandException (args.ErrorCode);
			}
		}

		/* Wait for the debuggee to start up and connect to it */
		internal void connect () {
			conn.Connect ();

			// Test the connection
			version = conn.Version;
			if (version.MajorVersion != Connection.MAJOR_VERSION)
				throw new NotSupportedException (String.Format ("The debuggee implements protocol version {0}.{1}, while {2}.{3} is required.", version.MajorVersion, version.MinorVersion, Connection.MAJOR_VERSION, Connection.MINOR_VERSION));

			long root_domain_id = conn.RootDomain;
			root_domain = GetDomain (root_domain_id);
		}

		internal void notify_vm_event (EventType evtype, SuspendPolicy spolicy, int req_id, long thread_id, string vm_uri, int exit_code) {
			//Console.WriteLine ("Event: " + evtype + "(" + vm_uri + ")");

			switch (evtype) {
			case EventType.VMStart:
				/* Notify the main thread that the debuggee started up */
				lock (startup_monitor) {
					Monitor.Pulse (startup_monitor);
				}
				queue_event_set (new EventSet (this, spolicy, new Event[] { new VMStartEvent (vm, req_id, thread_id) }));
				break;
			case EventType.VMDeath:
				queue_event_set (new EventSet (this, spolicy, new Event[] { new VMDeathEvent (vm, req_id, exit_code) }));
				break;
			case EventType.VMDisconnect:
				queue_event_set (new EventSet (this, spolicy, new Event[] { new VMDisconnectEvent (vm, req_id) }));
				break;
			default:
				throw new Exception ();
			}
		}

		//
		// Methods to create instances of mirror objects
		//

		/*
		class MirrorCache<T> {
			static Dictionary <long, T> mirrors;
			static object mirror_lock = new object ();

			internal static T GetMirror (VirtualMachine vm, long id) {
				lock (mirror_lock) {
				if (mirrors == null)
					mirrors = new Dictionary <long, T> ();
				T obj;
				if (!mirrors.TryGetValue (id, out obj)) {
					obj = CreateMirror (vm, id);
					mirrors [id] = obj;
				}
				return obj;
				}
			}

			internal static T CreateMirror (VirtualMachine vm, long id) {
			}
		}
		*/

		// FIXME: When to remove items from the cache ?

		Dictionary <long, MethodMirror> methods;
		object methods_lock = new object ();

		internal MethodMirror GetMethod (long id) {
			lock (methods_lock) {
				if (methods == null)
					methods = new Dictionary <long, MethodMirror> ();
				MethodMirror obj;
				if (id == 0)
					return null;
				if (!methods.TryGetValue (id, out obj)) {
					obj = new MethodMirror (this, id);
					methods [id] = obj;
				}
				return obj;
			}
	    }

		Dictionary <long, AssemblyMirror> assemblies;
		object assemblies_lock = new object ();

		internal AssemblyMirror GetAssembly (long id) {
			lock (assemblies_lock) {
				if (assemblies == null)
					assemblies = new Dictionary <long, AssemblyMirror> ();
				AssemblyMirror obj;
				if (id == 0)
					return null;
				if (!assemblies.TryGetValue (id, out obj)) {
					obj = new AssemblyMirror (this, id);
					assemblies [id] = obj;
				}
				return obj;
			}
	    }

		Dictionary <long, ModuleMirror> modules;
		object modules_lock = new object ();

		internal ModuleMirror GetModule (long id) {
			lock (modules_lock) {
				if (modules == null)
					modules = new Dictionary <long, ModuleMirror> ();
				ModuleMirror obj;
				if (id == 0)
					return null;
				if (!modules.TryGetValue (id, out obj)) {
					obj = new ModuleMirror (this, id);
					modules [id] = obj;
				}
				return obj;
			}
	    }

		Dictionary <long, AppDomainMirror> domains;
		object domains_lock = new object ();

		internal AppDomainMirror GetDomain (long id) {
			lock (domains_lock) {
				if (domains == null)
					domains = new Dictionary <long, AppDomainMirror> ();
				AppDomainMirror obj;
				if (id == 0)
					return null;
				if (!domains.TryGetValue (id, out obj)) {
					obj = new AppDomainMirror (this, id);
					domains [id] = obj;
				}
				return obj;
			}
	    }

		internal void InvalidateAssemblyCaches () {
			lock (domains_lock) {
				foreach (var d in domains.Values)
					d.InvalidateAssembliesCache ();
			}
		}

		Dictionary <long, TypeMirror> types;
		object types_lock = new object ();

		internal TypeMirror GetType (long id) {
			lock (types_lock) {
				if (types == null)
					types = new Dictionary <long, TypeMirror> ();
				TypeMirror obj;
				if (id == 0)
					return null;
				if (!types.TryGetValue (id, out obj)) {
					obj = new TypeMirror (this, id);
					types [id] = obj;
				}
				return obj;
			}
	    }

		internal TypeMirror[] GetTypes (long[] ids) {
			var res = new TypeMirror [ids.Length];
			for (int i = 0; i < ids.Length; ++i)
				res [i] = GetType (ids [i]);
			return res;
		}

		Dictionary <long, ObjectMirror> objects;
		object objects_lock = new object ();

		internal T GetObject<T> (long id, long domain_id, long type_id) where T : ObjectMirror {
			lock (objects_lock) {
				if (objects == null)
					objects = new Dictionary <long, ObjectMirror> ();
				ObjectMirror obj;
				if (!objects.TryGetValue (id, out obj)) {
					/*
					 * Obtain the domain/type of the object to determine the type of
					 * object we need to create.
					 */
					if (domain_id == 0 || type_id == 0) {
						if (conn.Version.AtLeast (2, 5)) {
							var info = conn.Object_GetInfo (id);
							domain_id = info.domain_id;
							type_id = info.type_id;
						} else {
							if (domain_id == 0)
								domain_id = conn.Object_GetDomain (id);
							if (type_id == 0)
								type_id = conn.Object_GetType (id);
						}
					}
					AppDomainMirror d = GetDomain (domain_id);
					TypeMirror t = GetType (type_id);

					if (t.Assembly == d.Corlib && t.Namespace == "System.Threading" && t.Name == "Thread")
						obj = new ThreadMirror (this, id, t, d);
					else if (t.Assembly == d.Corlib && t.Namespace == "System" && t.Name == "String")
						obj = new StringMirror (this, id, t, d);
					else if (typeof (T) == typeof (ArrayMirror))
						obj = new ArrayMirror (this, id, t, d);
					else
						obj = new ObjectMirror (this, id, t, d);
					objects [id] = obj;
				}
				return (T)obj;
			}
	    }

		internal T GetObject<T> (long id) where T : ObjectMirror {
			return GetObject<T> (id, 0, 0);
		}

		internal ObjectMirror GetObject (long objid) {
			return GetObject<ObjectMirror> (objid);
		}

		internal ThreadMirror GetThread (long id) {
			return GetObject <ThreadMirror> (id);
		}

		Dictionary <long, FieldInfoMirror> fields;
		object fields_lock = new object ();

		internal FieldInfoMirror GetField (long id) {
			lock (fields_lock) {
				if (fields == null)
					fields = new Dictionary <long, FieldInfoMirror> ();
				FieldInfoMirror obj;
				if (id == 0)
					return null;
				if (!fields.TryGetValue (id, out obj)) {
					obj = new FieldInfoMirror (this, id);
					fields [id] = obj;
				}
				return obj;
			}
	    }

		object requests_lock = new object ();

		internal void AddRequest (EventRequest req, int id) {
			lock (requests_lock) {
				requests [id] = req;
			}
		}

		internal void RemoveRequest (EventRequest req, int id) {
			lock (requests_lock) {
				requests.Remove (id);
			}
		}

		internal EventRequest GetRequest (int id) {
			lock (requests_lock) {
				return requests [id];
			}
		}

		internal Value DecodeValue (ValueImpl v) {
			return DecodeValue (v, null);
		}

		internal Value DecodeValue (ValueImpl v, Dictionary<int, Value> parent_vtypes) {
			if (v.Value != null)
				return new PrimitiveValue (this, v.Value);

			switch (v.Type) {
			case ElementType.Void:
				return null;
			case ElementType.SzArray:
			case ElementType.Array:
				return GetObject<ArrayMirror> (v.Objid);
			case ElementType.String:
				return GetObject<StringMirror> (v.Objid);
			case ElementType.Class:
			case ElementType.Object:
				return GetObject (v.Objid);
			case ElementType.ValueType:
				if (parent_vtypes == null)
					parent_vtypes = new Dictionary<int, Value> ();
				StructMirror vtype;
				if (v.IsEnum)
					vtype = new EnumMirror (this, GetType (v.Klass), (Value[])null);
				else
					vtype = new StructMirror (this, GetType (v.Klass), (Value[])null);
				parent_vtypes [parent_vtypes.Count] = vtype;
				vtype.SetFields (DecodeValues (v.Fields, parent_vtypes));
				parent_vtypes.Remove (parent_vtypes.Count - 1);
				return vtype;
			case (ElementType)ValueTypeId.VALUE_TYPE_ID_NULL:
				return new PrimitiveValue (this, null);
			case (ElementType)ValueTypeId.VALUE_TYPE_ID_PARENT_VTYPE:
				return parent_vtypes [v.Index];
			default:
				throw new NotImplementedException ("" + v.Type);
			}
		}

		internal Value[] DecodeValues (ValueImpl[] values) {
			Value[] res = new Value [values.Length];
			for (int i = 0; i < values.Length; ++i)
				res [i] = DecodeValue (values [i]);
			return res;
		}

		internal Value[] DecodeValues (ValueImpl[] values, Dictionary<int, Value> parent_vtypes) {
			Value[] res = new Value [values.Length];
			for (int i = 0; i < values.Length; ++i)
				res [i] = DecodeValue (values [i], parent_vtypes);
			return res;
		}

		internal ValueImpl EncodeValue (Value v, List<Value> duplicates = null) {
			if (v is PrimitiveValue) {
				object val = (v as PrimitiveValue).Value;
				if (val == null)
					return new ValueImpl { Type = (ElementType)ValueTypeId.VALUE_TYPE_ID_NULL, Objid = 0 };
				else
					return new ValueImpl { Value = val };
			} else if (v is ObjectMirror) {
				return new ValueImpl { Type = ElementType.Object, Objid = (v as ObjectMirror).Id };
			} else if (v is StructMirror) {
				if (duplicates == null)
					duplicates = new List<Value> ();
				if (duplicates.Contains (v))
					return new ValueImpl { Type = (ElementType)ValueTypeId.VALUE_TYPE_ID_NULL, Objid = 0 };
				duplicates.Add (v);

				return new ValueImpl { Type = ElementType.ValueType, Klass = (v as StructMirror).Type.Id, Fields = EncodeValues ((v as StructMirror).Fields, duplicates) };
			} else {
				throw new NotSupportedException ();
			}
		}

		internal ValueImpl[] EncodeValues (IList<Value> values, List<Value> duplicates = null) {
			ValueImpl[] res = new ValueImpl [values.Count];
			for (int i = 0; i < values.Count; ++i)
				res [i] = EncodeValue (values [i], duplicates);
			return res;
		}

		internal void CheckProtocolVersion (int major, int minor) {
			if (!conn.Version.AtLeast (major, minor))
				throw new NotSupportedException ("This request is not supported by the protocol version implemented by the debuggee.");
		}
    }

	class EventHandler : MarshalByRefObject, IEventHandler
	{		
		VirtualMachine vm;

		public EventHandler (VirtualMachine vm) {
			this.vm = vm;
		}

		public void Events (SuspendPolicy suspend_policy, EventInfo[] events) {
			var l = new List<Event> ();

			for (int i = 0; i < events.Length; ++i) {
				EventInfo ei = events [i];
				int req_id = ei.ReqId;
				long thread_id = ei.ThreadId;
				long id = ei.Id;
				long loc = ei.Location;

				switch (ei.EventType) {
				case EventType.VMStart:
					vm.notify_vm_event (EventType.VMStart, suspend_policy, req_id, thread_id, null, 0);
					break;
				case EventType.VMDeath:
					vm.notify_vm_event (EventType.VMDeath, suspend_policy, req_id, thread_id, null, ei.ExitCode);
					break;
				case EventType.ThreadStart:
					vm.InvalidateThreadCache ();
					l.Add (new ThreadStartEvent (vm, req_id, id));
					break;
				case EventType.ThreadDeath:
					vm.GetThread (id).InvalidateFrames ();
					vm.InvalidateThreadCache ();
					l.Add (new ThreadDeathEvent (vm, req_id, id));
					break;
				case EventType.AssemblyLoad:
					vm.InvalidateAssemblyCaches ();
					l.Add (new AssemblyLoadEvent (vm, req_id, thread_id, id));
					break;
				case EventType.AssemblyUnload:
					vm.InvalidateAssemblyCaches ();
					l.Add (new AssemblyUnloadEvent (vm, req_id, thread_id, id));
					break;
				case EventType.TypeLoad:
					l.Add (new TypeLoadEvent (vm, req_id, thread_id, id));
					break;
				case EventType.MethodEntry:
					l.Add (new MethodEntryEvent (vm, req_id, thread_id, id));
					break;
				case EventType.MethodExit:
					l.Add (new MethodExitEvent (vm, req_id, thread_id, id));
					break;
				case EventType.Breakpoint:
					l.Add (new BreakpointEvent (vm, req_id, thread_id, id, loc));
					break;
				case EventType.Step:
					l.Add (new StepEvent (vm, req_id, thread_id, id, loc));
					break;
				case EventType.Exception:
					l.Add (new ExceptionEvent (vm, req_id, thread_id, id, loc));
					break;
				case EventType.AppDomainCreate:
					l.Add (new AppDomainCreateEvent (vm, req_id, thread_id, id));
					break;
				case EventType.AppDomainUnload:
					l.Add (new AppDomainUnloadEvent (vm, req_id, thread_id, id));
					break;
				case EventType.UserBreak:
					l.Add (new UserBreakEvent (vm, req_id, thread_id));
					break;
				case EventType.UserLog:
					l.Add (new UserLogEvent (vm, req_id, thread_id, ei.Level, ei.Category, ei.Message));
					break;
				}
			}
			
			if (l.Count > 0)
				vm.queue_event_set (new EventSet (vm, suspend_policy, l.ToArray ()));
		}

		public void VMDisconnect (int req_id, long thread_id, string vm_uri) {
			vm.notify_vm_event (EventType.VMDisconnect, SuspendPolicy.None, req_id, thread_id, vm_uri, 0);
        }
    }

	public class CommandException : Exception {

		internal CommandException (ErrorCode error_code) : base ("Debuggee returned error code " + error_code + ".") {
			ErrorCode = error_code;
		}

		public ErrorCode ErrorCode {
			get; set;
		}
	}

	public class VMNotSuspendedException : InvalidOperationException
	{
		public VMNotSuspendedException () : base ("The vm is not suspended.")
		{
		}
	}
}

```

`Mono.Debugger.Soft/VirtualMachineManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;

namespace Mono.Debugger.Soft
{
	public class LaunchOptions {
		public string AgentArgs {
			get; set;
		}

		public bool Valgrind {
			get; set;
		}
		
		public ProcessLauncher CustomProcessLauncher {
			get; set;
		}

		public TargetProcessLauncher CustomTargetProcessLauncher {
			get; set;
		}

		public delegate Process ProcessLauncher (ProcessStartInfo info);
		public delegate ITargetProcess TargetProcessLauncher (ProcessStartInfo info);
	}

	public class VirtualMachineManager
	{
		private delegate VirtualMachine LaunchCallback (ITargetProcess p, ProcessStartInfo info, Socket socket);
		private delegate VirtualMachine ListenCallback (Socket dbg_sock, Socket con_sock); 
		private delegate VirtualMachine ConnectCallback (Socket dbg_sock, Socket con_sock, IPEndPoint dbg_ep, IPEndPoint con_ep); 

		internal VirtualMachineManager () {
		}

		public static VirtualMachine LaunchInternal (Process p, ProcessStartInfo info, Socket socket)
		{
			return LaunchInternal (new ProcessWrapper (p), info, socket);
		}
			
		public static VirtualMachine LaunchInternal (ITargetProcess p, ProcessStartInfo info, Socket socket) {
			Socket accepted = null;
			try {
				accepted = socket.Accept ();
			} catch (Exception) {
				throw;
			}

			Connection conn = new TcpConnection (accepted);

			VirtualMachine vm = new VirtualMachine (p, conn);

			if (info.RedirectStandardOutput)
				vm.StandardOutput = p.StandardOutput;
			
			if (info.RedirectStandardError)
				vm.StandardError = p.StandardError;

			conn.EventHandler = new EventHandler (vm);

			vm.connect ();

			return vm;
		}

		public static IAsyncResult BeginLaunch (ProcessStartInfo info, AsyncCallback callback)
		{
			return BeginLaunch (info, callback, null);
		}

		public static IAsyncResult BeginLaunch (ProcessStartInfo info, AsyncCallback callback, LaunchOptions options)
		{
			if (info == null)
				throw new ArgumentNullException ("info");

			Socket socket = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			socket.Bind (new IPEndPoint (IPAddress.Loopback, 0));
			socket.Listen (1000);
			IPEndPoint ep = (IPEndPoint) socket.LocalEndPoint;

			// We need to inject our arguments into the psi
			info.Arguments = string.Format ("{0} --debug --debugger-agent=transport=dt_socket,address={1}:{2}{3} {4}", 
								options == null || !options.Valgrind ? "" : info.FileName,
								ep.Address,
								ep.Port,
								options == null || options.AgentArgs == null ? "" : "," + options.AgentArgs,
								info.Arguments);

			if (options != null && options.Valgrind)
				info.FileName = "valgrind";
			info.UseShellExecute = false;

			if (info.RedirectStandardError)
				info.StandardErrorEncoding = Encoding.UTF8;

			if (info.RedirectStandardOutput)
				info.StandardOutputEncoding = Encoding.UTF8;

			ITargetProcess p;
			if (options != null && options.CustomProcessLauncher != null)
				p = new ProcessWrapper (options.CustomProcessLauncher (info));
			else if (options != null && options.CustomTargetProcessLauncher != null)
				p = options.CustomTargetProcessLauncher (info);
			else
				p = new ProcessWrapper (Process.Start (info));
			
			p.Exited += delegate (object sender, EventArgs eargs) {
				socket.Close ();
			};

			LaunchCallback c = new LaunchCallback (LaunchInternal);
			return c.BeginInvoke (p, info, socket, callback, socket);
		}

		public static VirtualMachine EndLaunch (IAsyncResult asyncResult) {
			if (asyncResult == null)
				throw new ArgumentNullException ("asyncResult");

			if (!asyncResult.IsCompleted)
				asyncResult.AsyncWaitHandle.WaitOne ();

			AsyncResult result = (AsyncResult) asyncResult;
			LaunchCallback cb = (LaunchCallback) result.AsyncDelegate;
			return cb.EndInvoke (asyncResult);
		}

		public static VirtualMachine Launch (ProcessStartInfo info)
		{
			return Launch (info, null);
		}

		public static VirtualMachine Launch (ProcessStartInfo info, LaunchOptions options)
		{
			return EndLaunch (BeginLaunch (info, null, options));
		}

		public static VirtualMachine Launch (string[] args)
		{
			return Launch (args, null);
		}

		public static VirtualMachine Launch (string[] args, LaunchOptions options)
		{
			ProcessStartInfo pi = new ProcessStartInfo ("mono");
			pi.Arguments = String.Join (" ", args);

			return Launch (pi, options);
		}
			
		public static VirtualMachine ListenInternal (Socket dbg_sock, Socket con_sock) {
			Socket con_acc = null;
			Socket dbg_acc = null;

			if (con_sock != null) {
				try {
					con_acc = con_sock.Accept ();
				} catch (Exception) {
					try {
						dbg_sock.Close ();
					} catch {}
					throw;
				}
			}
						
			try {
				dbg_acc = dbg_sock.Accept ();
			} catch (Exception) {
				if (con_sock != null) {
					try {
						con_sock.Close ();
						con_acc.Close ();
					} catch {}
				}
				throw;
			}

			if (con_sock != null) {
				if (con_sock.Connected)
					con_sock.Disconnect (false);
				con_sock.Close ();
			}

			if (dbg_sock.Connected)
				dbg_sock.Disconnect (false);
			dbg_sock.Close ();

			Connection transport = new TcpConnection (dbg_acc);
			StreamReader console = con_acc != null? new StreamReader (new NetworkStream (con_acc)) : null;
			
			return Connect (transport, console, null);
		}

		public static IAsyncResult BeginListen (IPEndPoint dbg_ep, AsyncCallback callback) {
			return BeginListen (dbg_ep, null, callback);
		}
		
		public static IAsyncResult BeginListen (IPEndPoint dbg_ep, IPEndPoint con_ep, AsyncCallback callback)
		{
			int dbg_port, con_port;
			return BeginListen (dbg_ep, con_ep, callback, out dbg_port, out con_port);
		}

		public static IAsyncResult BeginListen (IPEndPoint dbg_ep, IPEndPoint con_ep, AsyncCallback callback,
			out int dbg_port, out int con_port)
		{
			dbg_port = con_port = 0;
			
			Socket dbg_sock = null;
			Socket con_sock = null;

			dbg_sock = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			dbg_sock.Bind (dbg_ep);
			dbg_sock.Listen (1000);
			dbg_port = ((IPEndPoint) dbg_sock.LocalEndPoint).Port;

			if (con_ep != null) {
				con_sock = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
				con_sock.Bind (con_ep);
				con_sock.Listen (1000);
				con_port = ((IPEndPoint) con_sock.LocalEndPoint).Port;
			}
			
			ListenCallback c = new ListenCallback (ListenInternal);
			return c.BeginInvoke (dbg_sock, con_sock, callback, con_sock ?? dbg_sock);
		}

		public static VirtualMachine EndListen (IAsyncResult asyncResult) {
			if (asyncResult == null)
				throw new ArgumentNullException ("asyncResult");

			if (!asyncResult.IsCompleted)
				asyncResult.AsyncWaitHandle.WaitOne ();

			AsyncResult result = (AsyncResult) asyncResult;
			ListenCallback cb = (ListenCallback) result.AsyncDelegate;
			return cb.EndInvoke (asyncResult);
		}

		public static VirtualMachine Listen (IPEndPoint dbg_ep)
		{
			return Listen (dbg_ep, null);
		}

		public static VirtualMachine Listen (IPEndPoint dbg_ep, IPEndPoint con_ep)
		{
			return EndListen (BeginListen (dbg_ep, con_ep, null));
		}

		/*
		 * Connect to a virtual machine listening at the specified address.
		 */
		public static VirtualMachine Connect (IPEndPoint endpoint) {
			return Connect (endpoint, null);
		}

		public static VirtualMachine Connect (IPEndPoint endpoint, IPEndPoint consoleEndpoint) { 
			if (endpoint == null)
				throw new ArgumentNullException ("endpoint");

			return EndConnect (BeginConnect (endpoint, consoleEndpoint, null));
		}

		public static VirtualMachine ConnectInternal (Socket dbg_sock, Socket con_sock, IPEndPoint dbg_ep, IPEndPoint con_ep) {
			if (con_sock != null) {
				try {
					con_sock.Connect (con_ep);
				} catch (Exception) {
					try {
						dbg_sock.Close ();
					} catch {}
					throw;
				}
			}
						
			try {
				dbg_sock.Connect (dbg_ep);
			} catch (Exception) {
				if (con_sock != null) {
					try {
						con_sock.Close ();
					} catch {}
				}
				throw;
			}
			
			Connection transport = new TcpConnection (dbg_sock);
			StreamReader console = con_sock != null? new StreamReader (new NetworkStream (con_sock)) : null;
			
			return Connect (transport, console, null);
		}

		public static IAsyncResult BeginConnect (IPEndPoint dbg_ep, AsyncCallback callback) {
			return BeginConnect (dbg_ep, null, callback);
		}

		public static IAsyncResult BeginConnect (IPEndPoint dbg_ep, IPEndPoint con_ep, AsyncCallback callback) {
			Socket dbg_sock = null;
			Socket con_sock = null;

			dbg_sock = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

			if (con_ep != null) {
				con_sock = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			}
			
			ConnectCallback c = new ConnectCallback (ConnectInternal);
			return c.BeginInvoke (dbg_sock, con_sock, dbg_ep, con_ep, callback, con_sock ?? dbg_sock);
		}

		public static VirtualMachine EndConnect (IAsyncResult asyncResult) {
			if (asyncResult == null)
				throw new ArgumentNullException ("asyncResult");

			if (!asyncResult.IsCompleted)
				asyncResult.AsyncWaitHandle.WaitOne ();

			AsyncResult result = (AsyncResult) asyncResult;
			ConnectCallback cb = (ConnectCallback) result.AsyncDelegate;
			return cb.EndInvoke (asyncResult);
		}

		public static void CancelConnection (IAsyncResult asyncResult)
		{
			((Socket)asyncResult.AsyncState).Close ();
		}
		
		public static VirtualMachine Connect (Connection transport, StreamReader standardOutput, StreamReader standardError)
		{
			VirtualMachine vm = new VirtualMachine (null, transport);
			
			vm.StandardOutput = standardOutput;
			vm.StandardError = standardError;
			
			transport.EventHandler = new EventHandler (vm);

			vm.connect ();

			return vm;
		}
	}
}

```

`Mono.Debugger.Soft_test.dll.sources`:

```sources
dtest.cs

```

`Test/TypeLoadClass.cs`:

```cs

class TypeLoadClass
{
	static TypeLoadClass ()
	{
	}
}

class TypeLoadClass2
{
}
```

`Test/dtest-app.cs`:

```cs
/*
 * dtest-app.cs:
 *
 *   Application program used by the debugger tests.
 */
using System;
using System.Runtime.CompilerServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using MonoTests.Helpers;

public class TestsBase
{
#pragma warning disable 0414
#pragma warning disable 0169
	public int base_field_i;
	public string base_field_s;
	static int base_static_i = 57;
	static string base_static_s = "C";
#pragma warning restore 0414
#pragma warning restore 0169

	public virtual string virtual_method () {
		return "V1";
	}
}

public enum AnEnum {
	A = 0,
	B= 1
}

public sealed class Tests3 {
	public static void M1 () {
	}

	static void M2 () {
	}

	public void M3 () {
	}

	void M4 () {
	}

}

public static class Tests4 {
	static Tests4 () {
	}
}

public class AAttribute : Attribute {
	public int afield;
}

public class BAttribute : AAttribute {
	public int bfield;
}

[DebuggerDisplay ("Tests", Name="FOO", Target=typeof (int))]
[DebuggerTypeProxy (typeof (Tests))]
[BAttribute (afield = 1, bfield = 2)]
public class Tests2 {
	[DebuggerBrowsableAttribute (DebuggerBrowsableState.Collapsed)]
	public int field_j;
	public static int static_field_j;

	[DebuggerBrowsableAttribute (DebuggerBrowsableState.Collapsed)]
	public int AProperty {
		get {
			return 0;
		}
	}

	public void invoke () {
	}
}

public struct AStruct : ITest2 {
	public int i;
	public string s;
	public byte k;
	public IntPtr j;
	public int l;
/*
	public AStruct () {
		i = 0;
		s = null;
		k = 0;
		j = IntPtr.Zero;
		l = 0;
	}
*/
	public AStruct (int arg) {
		i = arg;
		s = null;
		k = 0;
		j = IntPtr.Zero;
		l = 0;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public int foo (int val) {
		return val;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int static_foo (int val) {
		return val;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public int invoke_return_int () {
		return i;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int invoke_static () {
		return 5;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public IntPtr invoke_return_intptr () {
		return j;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_mutate () {
		l = 5;
	}

	public int invoke_iface () {
		return i;
	}

	public override string ToString () {
		return i.ToString ();
	}
}

public class GClass<T> {
	public T field;
	public static T static_field;

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public GClass () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void bp<T2> () {
	}
}

public struct GStruct<T> {
	public T i;

	public int j;

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public int invoke_return_int () {
		return j;
	}
}

public struct NestedStruct {
	NestedInner nested1, nested2;
}

public struct NestedInner {
}

public interface IRecStruct {
	void foo (object o);
}

struct RecStruct : IRecStruct {
	public object o;

	public void foo (object o) {
		this.o = o;
	}
}

interface ITest
{
	void Foo ();
	void Bar ();
}

interface ITest<T>
{
	void Foo ();
	void Bar ();
}

class TestIfaces : ITest
{
	void ITest.Foo () {
	}

	void ITest.Bar () {
	}

	TestIfaces<int> Baz () {
		return null;
	}
}

class TestIfaces<T> : ITest<T>
{
	void ITest<T>.Foo () {
	}

	void ITest<T>.Bar () {
	}
}

public interface ITest2
{
	int invoke_iface ();
}

public class Tests : TestsBase, ITest2
{
#pragma warning disable 0414
	int field_i;
	string field_s;
	AnEnum field_enum;
	bool field_bool1, field_bool2;
	char field_char;
	byte field_byte;
	sbyte field_sbyte;
	short field_short;
	ushort field_ushort;
	long field_long;
	ulong field_ulong;
	float field_float;
	double field_double;
	Thread field_class;
	IntPtr field_intptr;
	int? field_nullable;
	static int static_i = 55;
	static string static_s = "A";
	public const int literal_i = 56;
	public const string literal_s = "B";
	public object child;
	public AStruct field_struct;
	public object field_boxed_struct;
	public GStruct<int> generic_field_struct;
	public KeyValuePair<int, object> boxed_struct_field;
	[ThreadStatic]
	public static int tls_i;
	public static bool is_attached = Debugger.IsAttached;
	public NestedStruct nested_struct;

#pragma warning restore 0414

	public class NestedClass {
	}

	public int IntProperty {
		get {
			return field_i;
		}
		set {
			field_i = value;
		}
	}

	public int ReadOnlyProperty {
		get {
			return field_i;
		}
	}

	public int this [int index] {
		get {
			return field_i;
		}
	}

	public static void wait_one ()
	{
		ManualResetEvent evt = new ManualResetEvent (false);
		evt.WaitOne ();
	}

	public static int Main (String[] args) {
		tls_i = 42;

		if (args.Length > 0 && args [0] == "suspend-test")
			/* This contains an infinite loop, so execute it conditionally */
			suspend ();
		if (args.Length >0 && args [0] == "unhandled-exception") {
			unhandled_exception ();
			return 0;
		}
		if (args.Length >0 && args [0] == "unhandled-exception-endinvoke") {
			unhandled_exception_endinvoke ();
			return 0;
		}
		if (args.Length >0 && args [0] == "unhandled-exception-user") {
			unhandled_exception_user ();
			return 0;
		}
		if (args.Length >0 && args [0] == "wait-one") {
			wait_one ();
			return 0;
		}
		if (args.Length >0 && args [0] == "threadpool-io") {
			threadpool_io ();
			return 0;
		}
		if (args.Length > 0 && args [0] == "attach") {
			new Tests ().attach ();
			return 0;
		}
		assembly_load ();
		breakpoints ();
		single_stepping ();
		arguments ();
		objects ();
		objrefs ();
		vtypes ();
		locals ();
		line_numbers ();
		type_info ();
		invoke ();
		exceptions ();
		exception_filter ();
		threads ();
		dynamic_methods ();
		user ();
		type_load ();
		regress ();
		gc_suspend ();
		set_ip ();
		step_filters ();
		if (args.Length > 0 && args [0] == "local-reflect")
			local_reflect ();
		if (args.Length > 0 && args [0] == "domain-test")
			/* This takes a lot of time, so execute it conditionally */
			domains ();
		if (args.Length > 0 && args [0] == "ref-emit-test")
			ref_emit ();
		if (args.Length > 0 && args [0] == "frames-in-native")
			frames_in_native ();
		if (args.Length > 0 && args [0] == "invoke-single-threaded")
			new Tests ().invoke_single_threaded ();
		if (args.Length > 0 && args [0] == "invoke-abort")
			new Tests ().invoke_abort ();
		new Tests ().evaluate_method ();
		return 3;
	}

	public static void local_reflect () {
		//Breakpoint line below, and reflect someField via ObjectMirror;
		LocalReflectClass.RunMe ();
	}

	public static void breakpoints () {
		/* Call these early so it is JITted by the time a breakpoint is placed on it */
		bp3 ();
		bp7<int> ();
		bp7<string> ();

		bp1 ();
		bp2 ();
		bp3 ();
		bp4 ();
		bp4 ();
		bp4 ();
		bp5 ();
		bp6<string> (new GClass <int> ());
		bp7<int> ();
		bp7<string> ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp4 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp5 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp6<T> (GClass<int> gc) {
		gc.bp<int> ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void bp7<T> () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void single_stepping () {
		bool b = true;
		ss1 ();
		ss2 ();
		ss3 ();
		ss3_2 ();
		ss4 ();
		ss5 (new int [] { 1, 2, 3 }, new Func<int, bool> (is_even));
		try {
			ss6 (b);
		} catch {
		}
		ss7 ();
		ss_nested ();
		ss_regress_654694 ();
		ss_step_through ();
		ss_non_user_code ();
		ss_recursive (1);
		ss_recursive2 (1);
		ss_recursive2 (1);
		ss_recursive_chaotic ();
		ss_fp_clobber ();
		ss_no_frames ();
		ss_await ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int ss3 () {
		int sum = 0;

		for (int i = 0; i < 10; ++i)
			sum += i;

		return sum;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss3_2 () {
		ss3_2_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss3_2_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int ss4 () {
		ss1 (); ss1 ();
		ss2 ();
		return 0;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss5 (int[] arr, Func<int, bool> selector) {
		// Call into linq which calls back into this assembly
		arr.Count (selector);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss6 (bool b) {
		if (b) {
			ss6_2 ();
			throw new Exception ();
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss6_2 () {
	}

	[MethodImplAttribute(MethodImplOptions.NoInlining)]
	public static void ss7 ()
	{
		ss7_2();//Used to test stepout inside ss7_2, which may not go to catch
		ss7_2();//Used to test stepout inside ss7_2_1, which must go to catch
		ss7_2();//Used to test stepover inside ss7_2, which must go to catch
		ss7_2();//Used to test stepover inside ss7_2_1, which must go to catch
		ss7_3();//Used to test stepin inside ss7_3, which must go to catch
		ss7_2();//Used to test stepin inside ss7_2_1, which must go to catch
	}

	[MethodImplAttribute(MethodImplOptions.NoInlining)]
	public static void ss7_2_1 ()
	{
		throw new Exception ();
	}

	[MethodImplAttribute(MethodImplOptions.NoInlining)]
	public static void ss7_2_2 ()
	{
		ss7_2_1();
	}

	[MethodImplAttribute(MethodImplOptions.NoInlining)]
	public static void ss7_2 ()
	{
		try {
			ss7_2_2();
		}
		catch
		{
		}
	}

	[MethodImplAttribute(MethodImplOptions.NoInlining)]
	public static void ss7_3 ()
	{
		try {
			throw new Exception ();
		}
		catch
		{
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_nested () {
		ss_nested_1 (ss_nested_2 ());
		ss_nested_1 (ss_nested_2 ());
		ss_nested_3 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_nested_1 (int i) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int ss_nested_2 () {
		return 0;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_nested_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_step_through () {
		step_through_1 ();
		StepThroughClass.step_through_2 ();
		step_through_3 ();
	}

	[DebuggerStepThrough]
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void step_through_1 () {
	}

	[DebuggerStepThrough]
	class StepThroughClass {
		[MethodImplAttribute (MethodImplOptions.NoInlining)]
		public static void step_through_2 () {
		}
	}

	[DebuggerStepThrough]
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void step_through_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_non_user_code () {
		non_user_code_1 ();
		StepNonUserCodeClass.non_user_code_2 ();
		non_user_code_3 ();
	}

	[DebuggerNonUserCode]
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void non_user_code_1 () {
	}

	[DebuggerNonUserCode]
	class StepNonUserCodeClass {
		[MethodImplAttribute (MethodImplOptions.NoInlining)]
		public static void non_user_code_2 () {
		}
	}

	[DebuggerNonUserCode]
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void non_user_code_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive (int n) {
		if (n == 10)
			return;
		ss_recursive (n + 1);
	}

	// Breakpoint will be placed here
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive2_trap ()
	{
	}

	public static void ss_recursive2_at (string s)
	{
		// Console.WriteLine (s);
	}

	// This method is used both for a step over and step out test.
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive2 (int x)
	{
		ss_recursive2_at ( "ss_recursive2 in " + x);
		if (x < 5) {
			int next = x + 1;
			ss_recursive2_at ("ss_recursive2 descend " + x);
			ss_recursive2_trap ();
			ss_recursive2 (next);
		}
		ss_recursive2_at ("ss_recursive2 out " + x);
	}

	// Breakpoint will be placed here
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic_trap ()
	{
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic_at (bool exiting, string at, int n)
	{
//		string indent = "";
//		for (int count = 5 - n; count > 0; count--)
//			indent += "\t";
//		Console.WriteLine (indent + (exiting ? "<--" : "-->") + " " + at + " " + n);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic_fizz (int n)
	{
		ss_recursive_chaotic_at (false, "fizz", n);
		if (n > 0) {
			int next = n - 1;
			ss_recursive_chaotic_buzz (next);
			ss_recursive_chaotic_fizzbuzz (next);
		} else {
			ss_recursive_chaotic_trap ();
		}
		ss_recursive_chaotic_at (true, "fizz", n);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic_buzz (int n)
	{
		ss_recursive_chaotic_at (false, "buzz", n);
		if (n > 0) {
			int next = n - 1;
			ss_recursive_chaotic_fizz (next);
			ss_recursive_chaotic_fizzbuzz (next);
		}
		ss_recursive_chaotic_at (true, "buzz", n);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic_fizzbuzz (int n)
	{
		ss_recursive_chaotic_at (false, "fizzbuzz", n);
		if (n > 0) {
			int next = n - 1;
			ss_recursive_chaotic_fizz (next);
			ss_recursive_chaotic_buzz (next);
			ss_recursive_chaotic_fizzbuzz (next);
		}
		ss_recursive_chaotic_at (true, "fizzbuzz", n);
	}

	// Call a complex tree of recursive calls that has tripped up "step out" in the past.
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_recursive_chaotic ()
	{
		ss_recursive_chaotic_fizz (5);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_fp_clobber () {
		double v = ss_fp_clobber_1 (5.0);
		ss_fp_clobber_2 (v);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static double ss_fp_clobber_1 (double d) {
		return d + 2.0;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_fp_clobber_2 (double d) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_no_frames () {
		Action a = ss_no_frames_2;
		var ar = a.BeginInvoke (null, null);
		ar.AsyncWaitHandle.WaitOne ();
		// Avoid waiting every time this runs
		if (static_i == 56)
			Thread.Sleep (200);
		ss_no_frames_3 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_await ()
	{
		ss_await_1 ().Wait ();//in
		ss_await_1 ().Wait ();//over
		ss_await_1 ().Wait ();//out before
		ss_await_1 ().Wait ();//out after
		ss_await_1_exc (true, true).Wait ();//in
		ss_await_1_exc (true, true).Wait ();//over
		ss_await_1_exc (true, true).Wait ();//out
		try {
			ss_await_1_exc (true, false).Wait ();//in
		} catch { }
		try {
			ss_await_1_exc (true, false).Wait ();//over
		} catch { }
		try {
			ss_await_1_exc (true, false).Wait ();//out
		} catch { }
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static async Task<int> ss_await_1 () {
		var a = 1;
		await Task.Delay (10);
		return a + 2;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static async Task<int> ss_await_1_exc (bool exc, bool handled)
	{
		var a = 1;
		await Task.Delay (10);
		if (exc) {
			if (handled) {
				try {
					throw new Exception ();
				} catch {
				}
			} else {
				throw new Exception ();
			}
		}
		return a + 2;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_no_frames_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_no_frames_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static bool is_even (int i) {
		return i % 2 == 0;
	}

	/*
		lock (static_s) {
			Console.WriteLine ("HIT!");
		}
		return 0;
	}
	*/

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void arguments () {
		arg1 (SByte.MaxValue - 5, Byte.MaxValue - 5, true, Int16.MaxValue - 5, UInt16.MaxValue - 5, 'F', Int32.MaxValue - 5, UInt32.MaxValue - 5, Int64.MaxValue - 5, UInt64.MaxValue - 5, 1.2345f, 6.78910, new IntPtr (Int32.MaxValue - 5), new UIntPtr (UInt32.MaxValue - 5));
		int i = 42;
		arg2 ("FOO", null, "BLA", ref i, new GClass <int> { field = 42 }, new object (), '\0'.ToString () + "A");
		Tests t = new Tests () { field_i = 42, field_s = "S" };
		t.arg3 ("BLA");
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static int arg1 (sbyte sb, byte b, bool bl, short s, ushort us, char c, int i, uint ui, long l, ulong ul, float f, double d, IntPtr ip, UIntPtr uip) {
		return (int)(sb + b + (bl ? 0 : 1) + s + us + (int)c + i + ui + l + (long)ul + f + d + (int)ip + (int)uip);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static string arg2 (string s, string s3, object o, ref int i, GClass <int> gc, object o2, string s4) {
		return s + (s3 != null ? "" : "") + o + i + gc.field + o2;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public object arg3 (string s) {
		return s + s + s + s + this;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void objects () {
		Tests t = new Tests () { field_i = 42, field_bool1 = true, field_bool2 = false, field_char = 'A', field_byte = 129, field_sbyte = -33, field_short = Int16.MaxValue - 5, field_ushort = UInt16.MaxValue - 5, field_long = Int64.MaxValue - 5, field_ulong = UInt64.MaxValue - 5, field_float = 3.14f, field_double = 3.14f, field_s = "S", base_field_i = 43, base_field_s = "T", field_enum = AnEnum.B, field_class = null, field_intptr = new IntPtr (Int32.MaxValue - 5), field_nullable = null };
		t.o1 (new Tests2 () { field_j = 43 }, new GClass <int> { field = 42 }, new GClass <string> { field = "FOO" });
		o2 (new string [] { "BAR", "BAZ" }, new int[] { 42, 43 }, new int [,] { { 1, 2 }, { 3, 4 }}, (int[,])Array.CreateInstance (typeof (int), new int [] { 2, 2}, new int [] { 1, 3}), new int[] { 0 });
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public object o1 (Tests2 t, GClass <int> gc1, GClass <string> gc2) {
		if (t == null || gc1 == null || gc2 == null)
			return null;
		else
			return this;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static string o2 (string[] s2, int[] s3, int[,] s4, int[,] s5, IList<int> s6) {
		return s2 [0] + s3 [0] + s4 [0, 0] + s6 [0];
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void objrefs () {
		Tests t = new Tests () {};
		set_child (t);
		t.objrefs1 ();
		t.child = null;
		GC.Collect ();
		objrefs2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void set_child (Tests t) {
		t.child = new Tests ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void objrefs1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void objrefs2 () {
	}

	public static void vtypes () {
		Tests t = new Tests () { field_struct = new AStruct () { i = 42, s = "S", k = 43 }, generic_field_struct = new GStruct<int> () { i = 42 }, field_boxed_struct = new AStruct () { i = 42 }, boxed_struct_field = new KeyValuePair<int, object> (1, (long)42 ) };
		AStruct s = new AStruct { i = 44, s = "T", k = 45 };
		AStruct[] arr = new AStruct[] { 
			new AStruct () { i = 1, s = "S1" },
			new AStruct () { i = 2, s = "S2" } };
		TypedReference typedref = __makeref (s);
		t.vtypes1 (s, arr, typedref);
		vtypes2 (s);
		vtypes3 (s);
		vtypes4 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public object vtypes1 (AStruct s, AStruct[] arr, TypedReference typedref) {
		if (arr != null)
			return this;
		else
			return null;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void vtypes2 (AStruct s) {
		s.foo (5);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void vtypes3 (AStruct s) {
		AStruct.static_foo (5);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void vtypes4_2 (IRecStruct o) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void vtypes4 () {
		IRecStruct s = new RecStruct ();
		s.foo (s);
		vtypes4_2 (s);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals () {
		string s = null;
		var astruct = new AStruct () { i = 42 };
		locals1 (null);
		locals2<string> (null, 5, "ABC", ref s, ref astruct);
		locals3 ();
		locals6 ();
		locals7<int> (22);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void locals11 (double a, ref double b) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals1 (string[] args) {
		long foo = 42;

		double ri = 1;
		locals11 (b: ref ri, a: ri);

		for (int j = 0; j < 10; ++j) {
			foo ++;
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	[StateMachine (typeof (int))]
	public static void locals2<T> (string[] args, int arg, T t, ref string rs, ref AStruct astruct) {
		long i = 42;
		string s = "AB";

		for (int j = 0; j < 10; ++j) {
			if (s != null)
				i ++;
			if (t != null)
				i ++;
			astruct = new AStruct ();
		}
		rs = "A";
		List<int> alist = new List<int> () { 12 };
	}


	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals3 () {
		string s = "B";
		s.ToString ();

		{
			long i = 42;
			i ++;
			locals4 ();
		}
		{
			string i = "A";
			i.ToString ();
			locals5 ();
		}
		{
			long j = 42;
			j ++;
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals4 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals5 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6 () {
		int i = 0;
		int j = 0;
		for (i = 0; i < 10; ++i)
			j ++;
		sbyte sb = 0;
		for (i = 0; i < 10; ++i)
			sb ++;
		locals6_1 ();
		locals6_2 (j);
		locals6_3 ();
		locals6_4 (j);
		locals6_5 ();
		locals6_6 (sb);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_2 (int arg) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_3 () {
		// Clobber all registers
		int sum = 0, i, j, k, l, m;
		for (i = 0; i < 100; ++i)
			sum ++;
		for (j = 0; j < 100; ++j)
			sum ++;
		for (k = 0; k < 100; ++k)
			sum ++;
		for (l = 0; l < 100; ++l)
			sum ++;
		for (m = 0; m < 100; ++m)
			sum ++;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_4 (int arg) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_5 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals6_6 (int arg) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void locals7<T> (T arg) {
		T t = arg;
		T t2 = t;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void line_numbers () {
		LineNumbers.ln1 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void suspend () {
		long i = 5;

		while (true) {
			i ++;
		}
	}

	struct TypedRefTest {
		public int MaxValue;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void type_info () {
		Tests t = new Tests () { field_i = 42, field_s = "S", base_field_i = 43, base_field_s = "T", field_enum = AnEnum.B };
		t.ti1 (new Tests2 () { field_j = 43 }, new GClass <int> { field = 42 }, new GClass <string> { field = "FOO" });
		int val = 0;
		unsafe {
			AStruct s = new AStruct () { i = 42, s = "S", k = 43 };
			TypedRefTest reftest = new TypedRefTest () { MaxValue = 12 };
			TypedReference typedref = __makeref (reftest);
			ti2 (new string [] { "BAR", "BAZ" }, new int[] { 42, 43 }, new int [,] { { 1, 2 }, { 3, 4 }}, ref val, (int*)IntPtr.Zero, 5, s, new Tests (), new Tests2 (), new GClass <int> (), AnEnum.B, typedref);
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public object ti1 (Tests2 t, GClass <int> gc1, GClass <string> gc2) {
		if (t == null || gc1 == null || gc2 == null)
			return null;
		else
			return this;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static unsafe string ti2 (string[] s2, int[] s3, int[,] s4, ref int ri, int* ptr, int i, AStruct s, Tests t, Tests2 t2, GClass<int> g, AnEnum ae, TypedReference typedref) {
		return s2 [0] + s3 [0] + s4 [0, 0];
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void assembly_load () {
		assembly_load_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void assembly_load_2 () {
		// This will load System.dll while holding the loader lock
		new Foo ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void invoke () {
		new Tests ().invoke1 (new Tests2 (), new AStruct () { i = 42, j = (IntPtr)43 }, new GStruct<int> { j = 42 });
		new Tests ().invoke_ex ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke1 (Tests2 t, AStruct s, GStruct<int> g) {
		invoke2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_ex () {
		invoke_ex_inner ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_ex_inner () {
		try {
			throw new Exception ();
		} catch {
		}
	}

	int counter;

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_single_threaded () {
		// Spawn a thread incrementing a counter
		bool finished = false;

		new Thread (delegate () {
				while (!finished)
					counter ++;
		}).Start ();

		Thread.Sleep (100);

		invoke_single_threaded_2 ();

		finished = true;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_single_threaded_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_abort () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void invoke_abort_2 () {
		Thread.Sleep (1000000);
	}

	public void invoke_return_void () {
	}

	public string invoke_return_ref () {
		return "ABC";
	}

	public object invoke_return_null () {
		return null;
	}

	public int invoke_return_primitive () {
		return 42;
	}

	public int? invoke_return_nullable () {
		return 42;
	}

	public int invoke_pass_nullable (int? i) {
		return (int)i;
	}

	public int? invoke_return_nullable_null () {
		return null;
	}

	public int invoke_pass_nullable_null (int? i) {
		return i.HasValue ? 1 : 2;
	}

	public void invoke_type_load () {
		new Class3 ();
	}

	class Class3 {
	}

	public long invoke_pass_primitive (byte ub, sbyte sb, short ss, ushort us, int i, uint ui, long l, ulong ul, char c, bool b, float f, double d) {
		return ub + sb + ss + us + i + ui + l + (long)ul + (int)c + (b ? 1 : 0) + (int)f + (int)d;
	}

	public int invoke_pass_primitive2 (bool b) {
		return b ? 1 : 0;
	}

	public string invoke_pass_ref (string s) {
		return s;
	}

	public static string invoke_static_pass_ref (string s) {
		return s;
	}

	public static void invoke_static_return_void () {
	}

	public static void invoke_throws () {
		throw new Exception ();
	}

	public int invoke_iface () {
		return 42;
	}

	public void invoke_out (out int foo, out int[] arr) {
		foo = 5;
		arr = new int [10];
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void exceptions () {
		try {
			throw new OverflowException ();
		} catch (Exception) {
		}
		try {
			throw new OverflowException ();
		} catch (Exception) {
		}
		try {
			throw new ArgumentException ();
		} catch (Exception) {
		}
		try {
			throw new OverflowException ();
		} catch (Exception) {
		}
		// no subclasses
		try {
			throw new OverflowException ();
		} catch (Exception) {
		}
		try {
			throw new Exception ();
		} catch (Exception) {
		}

		object o = null;
		try {
			o.GetType ();
		} catch (Exception) {
		}

		try {
			exceptions2 ();
		} catch (Exception) {
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void unhandled_exception () {
		ThreadPool.QueueUserWorkItem (delegate {
				throw new InvalidOperationException ();
			});
		Thread.Sleep (10000);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void unhandled_exception_endinvoke_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void unhandled_exception_endinvoke () {
			Action action = new Action (() => 
			{
				throw new Exception ("thrown");
			});
			action.BeginInvoke ((ar) => {
				try {
					action.EndInvoke (ar);
				} catch (Exception ex) {
					//Console.WriteLine (ex);
				}
			}, null);
		Thread.Sleep (1000);
		unhandled_exception_endinvoke_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void unhandled_exception_user () {
		System.Threading.Tasks.Task.Factory.StartNew (() => {
				Throw ();
			});
		Thread.Sleep (10000);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void Throw () {
		throw new Exception ();
	}

	internal static Delegate create_filter_delegate (Delegate dlg, MethodInfo filter_method)
	{
		if (dlg == null)
			throw new ArgumentNullException ();
		if (dlg.Target != null)
			throw new ArgumentException ();
		if (dlg.Method == null)
			throw new ArgumentException ();

		var ret_type = dlg.Method.ReturnType;
		var param_types = dlg.Method.GetParameters ().Select (x => x.ParameterType).ToArray ();

		var dynamic = new DynamicMethod (Guid.NewGuid ().ToString (), ret_type, param_types, typeof (object), true);
		var ig = dynamic.GetILGenerator ();

		LocalBuilder retval = null;
		if (ret_type != typeof (void))
			retval = ig.DeclareLocal (ret_type);

		var label = ig.BeginExceptionBlock ();

		for (int i = 0; i < param_types.Length; i++)
			ig.Emit (OpCodes.Ldarg, i);
		ig.Emit (OpCodes.Call, dlg.Method);

		if (retval != null)
			ig.Emit (OpCodes.Stloc, retval);

		ig.Emit (OpCodes.Leave, label);

		ig.BeginExceptFilterBlock ();

		ig.Emit (OpCodes.Call, filter_method);

		ig.BeginCatchBlock (null);

		ig.Emit (OpCodes.Pop);

		ig.EndExceptionBlock ();

		if (retval != null)
			ig.Emit (OpCodes.Ldloc, retval);

		ig.Emit (OpCodes.Ret);

		return dynamic.CreateDelegate (dlg.GetType ());
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void exception_filter_method () {
		throw new InvalidOperationException ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static int exception_filter_filter (Exception exc) {
		return 1;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void exception_filter () {
		var method = typeof (Tests).GetMethod (
			"exception_filter_method", BindingFlags.NonPublic | BindingFlags.Static);
		var filter_method = typeof (Tests).GetMethod (
			"exception_filter_filter", BindingFlags.NonPublic | BindingFlags.Static);

		var dlg = Delegate.CreateDelegate (typeof (Action), method);

		var wrapper = (Action) create_filter_delegate (dlg, filter_method);

		wrapper ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static bool return_true () {
		return true;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void exceptions2 () {
		if (return_true ())
			throw new Exception ();
		Console.WriteLine ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void threads () {
		Thread t = new Thread (delegate () {});

		t.Start ();
		t.Join ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void domains () {
		AppDomain domain = AppDomain.CreateDomain ("domain");

		CrossDomain o = (CrossDomain)domain.CreateInstanceAndUnwrap (
				   typeof (CrossDomain).Assembly.FullName, "CrossDomain");

		domains_print_across (o);

		domains_2 (o, new CrossDomain ());

		o.invoke_2 ();

		o.invoke ();

		o.invoke_2 ();

		o.assembly_load ();

		AppDomain.Unload (domain);

		domains_3 ();

		typeof (Tests).GetMethod ("called_from_invoke").Invoke (null, null);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void called_from_invoke () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void domains_2 (object o, object o2) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void domains_print_across (object o) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void domains_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void invoke_in_domain () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void invoke_in_domain_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void assembly_load_in_domain () {
		Assembly.Load ("System.Transactions");
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void dynamic_methods () {
		var m = new DynamicMethod ("dyn_method", typeof (void), new Type []  { typeof (int) }, typeof (object).Module);
		var ig = m.GetILGenerator ();

		ig.Emit (OpCodes.Ldstr, "FOO");
		ig.Emit (OpCodes.Call, typeof (Tests).GetMethod ("dyn_call"));
		ig.Emit (OpCodes.Ret);

		var del = (Action<int>)m.CreateDelegate (typeof (Action<int>));

		del (0);
	}

	public static void dyn_call (string s) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ref_emit () {
		AssemblyName assemblyName = new AssemblyName ();
		assemblyName.Name = "foo";

		AssemblyBuilder assembly =
			Thread.GetDomain ().DefineDynamicAssembly (
													   assemblyName, AssemblyBuilderAccess.RunAndSave);

		ModuleBuilder module = assembly.DefineDynamicModule ("foo.dll");

		TypeBuilder tb = module.DefineType ("foo", TypeAttributes.Public, typeof (object));
		MethodBuilder mb = tb.DefineMethod ("ref_emit_method", MethodAttributes.Public|MethodAttributes.Static, CallingConventions.Standard, typeof (void), new Type [] { });
		ILGenerator ig = mb.GetILGenerator ();
		ig.Emit (OpCodes.Ldstr, "FOO");
		ig.Emit (OpCodes.Call, typeof (Tests).GetMethod ("ref_emit_call"));
		ig.Emit (OpCodes.Ret);

		Type t = tb.CreateType ();

		t.GetMethod ("ref_emit_method").Invoke (null, null);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ref_emit_call (string s) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void frames_in_native () {
		Thread.Sleep (500);
		var evt = new ManualResetEvent (false);
		
		object mon = new object ();
		ThreadPool.QueueUserWorkItem (delegate {
				frames_in_native_2 ();
				evt.Set ();
			});
		evt.WaitOne ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void frames_in_native_2 () {
		frames_in_native_3 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void frames_in_native_3 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void string_call (string s) {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ss_regress_654694 () {
		if (true) {
			string h = "hi";
			string_call (h);
		}
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void user () {
		Debugger.Break ();

		Debugger.Log (5, Debugger.IsLogging () ? "A" : "", "B");
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void type_load () {
		type_load_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void type_load_2 () {
		var c1 = new Dictionary<int, int> ();
		c1.ToString ();
		var c = new TypeLoadClass ();
		c.ToString ();
		var c2 = new TypeLoadClass2 ();
		c2.ToString ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void regress () {
		regress_2755 (DateTime.Now);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static unsafe void regress_2755 (DateTime d) {
		int* buffer = stackalloc int [128];

		regress_2755_2 ();

		int sum = 0;
		for (int i = 0; i < 128; ++i)
			sum += buffer [i];

		regress_2755_3 (sum);
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void regress_2755_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void regress_2755_3 (int sum) {
	}

	static object gc_suspend_field;

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static unsafe void set_gc_suspend_field () {
		set_gc_suspend_field_2 ();
		// Clear stack
		int* buffer = stackalloc int [4096];
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void set_gc_suspend_field_2 () {
		gc_suspend_field = new object ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void gc_suspend_1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void gc_suspend_invoke () {
		gc_suspend_field = null;
		GC.Collect ();
		GC.WaitForPendingFinalizers ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void gc_suspend () {
		set_gc_suspend_field ();
		gc_suspend_1 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void generic_method<T> () where T : class {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void evaluate_method_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void evaluate_method () {
		field_i = 42;
		evaluate_method_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void set_ip_1 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	static void set_ip_2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void set_ip () {
		int i = 0, j;

		i ++;
		i ++;
		set_ip_1 ();
		i ++;
		j = 5;
		set_ip_2 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void step_filters () {
		ClassWithCctor.cctor_filter ();
	}

	class ClassWithCctor {
		[MethodImplAttribute (MethodImplOptions.NoInlining)]
		static ClassWithCctor () {
			int i = 1;
			int j = 2;
		}

		[MethodImplAttribute (MethodImplOptions.NoInlining)]
		public static void cctor_filter () {
		}
	}

	public override string virtual_method () {
		return "V2";
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void threadpool_bp () { }

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void threadpool_io () {
		// Start a threadpool task that blocks on I/O.
		// Regression test for #42625
		const int nbytes = 16;
		var bsOut = new byte[nbytes];
		for (int i = 0; i < nbytes; i++) {
			bsOut[i] = (byte)i;
		}
		var endPoint = NetworkHelpers.LocalEphemeralEndPoint ();
		var l = new TcpListener (endPoint);
		l.Start ();
		Task<byte[]> t = Task.Run (async () => {
			var c = new TcpClient ();
			await c.ConnectAsync (endPoint.Address, endPoint.Port);
			var streamIn = c.GetStream ();
			var bs = new byte[nbytes];
			int nread = 0;
			int nremain = nbytes;
			while (nread < nbytes) {
				int r = await streamIn.ReadAsync (bs, nread, nremain);
				nread += r;
				nremain -= r;
			}
			streamIn.Close ();
			return bs;
			});
		var s = l.AcceptTcpClient ();
		l.Stop ();
		// write bytes in two groups so that the task blocks on the ReadAsync
		var streamOut = s.GetStream ();
		var nbytesFirst = nbytes / 2;
		var nbytesRest = nbytes - nbytesFirst;
		streamOut.Write (bsOut, 0, nbytesFirst);
		threadpool_bp ();
		streamOut.Write (bsOut, nbytesFirst, nbytesRest);
		streamOut.Close ();
		var bsIn = t.Result;
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void attach_break () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public void attach () {
		AppDomain domain = AppDomain.CreateDomain ("domain");

		CrossDomain o = (CrossDomain)domain.CreateInstanceAndUnwrap (
				   typeof (CrossDomain).Assembly.FullName, "CrossDomain");
		o.assembly_load ();
		o.type_load ();

		// Wait for the client to attach
		while (true) {
			Thread.Sleep (200);
			attach_break ();
		}
	}
}

public class SentinelClass : MarshalByRefObject {
}

public class CrossDomain : MarshalByRefObject
{
	SentinelClass printMe = new SentinelClass ();

	public void invoke () {
		Tests.invoke_in_domain ();
	}

	public void invoke_2 () {
		Tests.invoke_in_domain_2 ();
	}

	public int invoke_3 () {
		return 42;
	}

	public void assembly_load () {
		Tests.assembly_load_in_domain ();
	}

	public void type_load () {
		//Activator.CreateInstance (typeof (int).Assembly.GetType ("Microsoft.Win32.RegistryOptions"));
		var is_server = System.Runtime.GCSettings.IsServerGC;
	}
}	

public class Foo
{
	public ProcessStartInfo info;
}

class LocalReflectClass
{
	public static void RunMe ()
	{
		var reflectMe = new someClass ();
		var temp = reflectMe; // Breakpoint location
		reflectMe.someMethod ();
	}

	class someClass : ContextBoundObject
	{
		public object someField;

		public void someMethod ()
		{
		}
	}
}

// Class used for line number info testing, don't change its layout
public class LineNumbers
{
	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ln1 () {
		// Column 3
		ln2 ();
		ln3 ();
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ln2 () {
	}

	[MethodImplAttribute (MethodImplOptions.NoInlining)]
	public static void ln3 () {
#pragma warning disable 0219
		int i = 5;
#pragma warning restore 0219
		#line 55 "FOO"
	}
}




```

`Test/dtest-excfilter.il`:

```il
.assembly extern mscorlib
{
  .ver 2:0:0:0
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 ) // .z\V.4..
}
.assembly 'dtest-lib' { }

.class public auto ansi ExceptionFilterTest
       extends [mscorlib]System.Object
{
	.method public static void Main () cil managed
	{
		.entrypoint
		call void class ExceptionFilterTest::Test ()
		ret
	}

	.method public static int32 Filter ([mscorlib]System.Exception exc) cil managed noinlining
	{
		ldc.i4.1
		ret
	}

	.method public static void Handler ([mscorlib]System.Exception exc) cil managed noinlining
	{
		ret
	}

	.method public static void Test () cil managed noinlining
	{
		.try {
			newobj instance void class [mscorlib]System.InvalidOperationException::.ctor ()
			throw

			leave end
		} filter {
		    castclass [mscorlib]System.Exception
			call int32 class ExceptionFilterTest::Filter([mscorlib]System.Exception)
			endfilter
		} {
		    castclass [mscorlib]System.Exception
			call void class ExceptionFilterTest::Handler([mscorlib]System.Exception)
			leave end
		}

	end:
		ret
	}
}

```

`Test/dtest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Net;
using System.Reflection;
using System.Text;
using Mono.Cecil.Cil;
using Mono.Debugger.Soft;
using Diag = System.Diagnostics;
using System.Linq;
using System.IO;
using System.Security.Cryptography;

using NUnit.Framework;

#pragma warning disable 0219

namespace MonoTests
{

[TestFixture]
public class DebuggerTests
{
	VirtualMachine vm;
	MethodMirror entry_point;
	StepEventRequest step_req;
	bool forceExit;

	void AssertThrows<ExType> (Action del) where ExType : Exception {
		bool thrown = false;

		try {
			del ();
		} catch (ExType) {
			thrown = true;
		}
		Assert.IsTrue (thrown);
	}

	// No other way to pass arguments to the tests ?
	public static bool listening = Environment.GetEnvironmentVariable ("DBG_SUSPEND") != null;
	public static string runtime = Environment.GetEnvironmentVariable ("DBG_RUNTIME");
	public static string agent_args = Environment.GetEnvironmentVariable ("DBG_AGENT_ARGS");

	// Not currently used, but can be useful when debugging individual tests.
	void StackTraceDump (Event e)
	{
		int i = 0;
		foreach (var frame in e.Thread.GetFrames ())
		{
			i++;
			Console.WriteLine ("Frame " + i + ", " + frame.Method.Name);
		}
	}

	Event GetNextEvent () {
		var es = vm.GetNextEventSet ();
		Assert.AreEqual (1, es.Events.Length);
		return es [0];
	}

	void Start (params string[] args) {
		Start (false, args);
	}

	Diag.ProcessStartInfo CreateStartInfo (string[] args) {
		var pi = new Diag.ProcessStartInfo ();

		if (runtime != null) {
			pi.FileName = runtime;
		} else if (Path.DirectorySeparatorChar == '\\') {
			string processExe = Diag.Process.GetCurrentProcess ().MainModule.FileName;
			if (processExe != null) {
				string fileName = Path.GetFileName (processExe);
				if (fileName.StartsWith ("mono") && fileName.EndsWith (".exe"))
					pi.FileName = processExe;
			}
		}
		if (string.IsNullOrEmpty (pi.FileName))
			pi.FileName = "mono";
		pi.Arguments = String.Join (" ", args);
		return pi;
	}

	void Start (bool forceExit, params string[] args) {
		this.forceExit = forceExit;

		if (!listening) {
			var pi = CreateStartInfo (args);
			vm = VirtualMachineManager.Launch (pi, new LaunchOptions { AgentArgs = agent_args });
		} else {
			var ep = new IPEndPoint (IPAddress.Any, 10000);
			Console.WriteLine ("Listening on " + ep + "...");
			vm = VirtualMachineManager.Listen (ep);
		}

		var load_req = vm.CreateAssemblyLoadRequest ();
		load_req.Enable ();

		Event vmstart = GetNextEvent ();
		Assert.AreEqual (EventType.VMStart, vmstart.EventType);

		vm.Resume ();

		entry_point = null;
		step_req = null;

		Event e;

		/* Find out the entry point */
		while (true) {
			e = GetNextEvent ();

			if (e is AssemblyLoadEvent) {
				AssemblyLoadEvent ae = (AssemblyLoadEvent)e;
				entry_point = ae.Assembly.EntryPoint;
				if (entry_point != null)
					break;
			}

			vm.Resume ();
		}

		load_req.Disable ();
	}

	BreakpointEvent run_until (string name) {
		// String
		MethodMirror m = entry_point.DeclaringType.GetMethod (name);
		Assert.IsNotNull (m);
		//Console.WriteLine ("X: " + name + " " + m.ILOffsets.Count + " " + m.Locations.Count);
		var req = vm.SetBreakpoint (m, m.ILOffsets [0]);

		Event e = null;

		while (true) {
			vm.Resume ();
			e = GetNextEvent ();
			if (e is BreakpointEvent)
				break;
		}

		req.Disable ();

		Assert.IsInstanceOfType (typeof (BreakpointEvent), e);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		return (e as BreakpointEvent);
	}

	class ReusableBreakpoint {
		DebuggerTests owner;
		public string method_name;
		public BreakpointEventRequest req;
		public BreakpointEvent lastEvent = null;
		public ReusableBreakpoint (DebuggerTests owner, string method_name)
		{
			this.owner = owner;
			this.method_name = method_name;
			MethodMirror m = owner.entry_point.DeclaringType.GetMethod (method_name);
			Assert.IsNotNull (m);
			req = owner.vm.SetBreakpoint (m, m.ILOffsets [0]);
		}

		public void Continue ()
		{
			bool survived = false;

			try {
				Event e = null;

				while (true) {
					owner.vm.Resume ();
					e = owner.GetNextEvent ();
					if (e is BreakpointEvent)
						break;
				}

				Assert.IsInstanceOfType (typeof (BreakpointEvent), e);
				Assert.AreEqual (method_name, (e as BreakpointEvent).Method.Name);

				lastEvent = e as BreakpointEvent;

				survived = true;
			} finally {
				if (!survived) { // Ensure cleanup if we triggered an assert
					Disable ();
				}
			}
		}

		public void Disable ()
		{
			req.Disable ();
		}
	}

	/* One of the tests executes a complex tree of recursive functions.
	   The only good way to specify how its behavior should appear from this side
	   is to just run the function tree once over here and record what it does. */
	public struct RecursiveChaoticPoint
	{
		public bool breakpoint;
		public string name;
		public int depth;

		public RecursiveChaoticPoint (bool breakpoint, string name, int depth)
		{
			this.breakpoint = breakpoint;
			this.name = name;
			this.depth = depth;
		}
	}

	// The breakpoint is placed here in dtest-app.cs
	public static void ss_recursive_chaotic_trap (int n, List<RecursiveChaoticPoint> trace, ref bool didLast, ref bool didAny)
	{
		// Depth is calculated as:
		// Main + single_stepping + ss_recursive_chaotic + (n is 5 at outermost frame and 0 at innermost frame) + ss_recursive_chaotic_trap
		trace.Add (new RecursiveChaoticPoint (true, "ss_recursive_chaotic_trap", 5 - n + 5));
		didLast = true;
	}

	public static void ss_recursive_chaotic_at (string at, int n, List<RecursiveChaoticPoint> trace, ref bool didLast, ref bool didAny)
	{
		// This will be called after every return from a function. The other function will return whether "step out" is currently active, and it will be passed in here as didLast.
		if (didLast) {
			// Depth is calculated as:
			// Main + single_stepping + ss_recursive_chaotic + (n is 5 at outermost frame and 0 at innermost frame)
			trace.Add (new RecursiveChaoticPoint (false, "ss_recursive_chaotic_" + at, 5 - n + 4));
			didAny = true;
			didLast = false;
		}
	}

	public static bool ss_recursive_chaotic_fizz (int n, List<RecursiveChaoticPoint> trace)
	{
		bool didLast = false, didAny = false;
		if (n > 0) {
			int next = n - 1;
			didLast = ss_recursive_chaotic_buzz (next, trace);
			ss_recursive_chaotic_at ("fizz", n, trace, ref didLast, ref didAny);
			didLast = ss_recursive_chaotic_fizzbuzz (next, trace);
			ss_recursive_chaotic_at ("fizz", n, trace, ref didLast, ref didAny);
		} else {
			ss_recursive_chaotic_trap (n, trace, ref didLast, ref didAny);
			ss_recursive_chaotic_at ("fizz", n, trace, ref didLast, ref didAny);
		}
		return didAny;
	}

	public static bool ss_recursive_chaotic_buzz (int n, List<RecursiveChaoticPoint> trace)
	{
		bool didLast = false, didAny = false;
		if (n > 0) {
			int next = n - 1;
			didLast = ss_recursive_chaotic_fizz (next, trace);
			ss_recursive_chaotic_at ("buzz", n, trace, ref didLast, ref didAny);
			didLast = ss_recursive_chaotic_fizzbuzz (next, trace);
			ss_recursive_chaotic_at ("buzz", n, trace, ref didLast, ref didAny);
		}
		return didAny;
	}

	public static bool ss_recursive_chaotic_fizzbuzz (int n, List<RecursiveChaoticPoint> trace)
	{
		bool didLast = false, didAny = false;
		if (n > 0) {
			int next = n - 1;
			didLast = ss_recursive_chaotic_fizz (next, trace);
			ss_recursive_chaotic_at ("fizzbuzz", n, trace, ref didLast, ref didAny);
			didLast = ss_recursive_chaotic_buzz (next, trace);
			ss_recursive_chaotic_at ("fizzbuzz", n, trace, ref didLast, ref didAny);
			didLast = ss_recursive_chaotic_fizzbuzz (next, trace);
			ss_recursive_chaotic_at ("fizzbuzz", n, trace, ref didLast, ref didAny);
		}
		return didAny;
	}

	public static void trace_ss_recursive_chaotic (List<RecursiveChaoticPoint> trace)
	{
		ss_recursive_chaotic_fizz (5, trace);
	}

	Event single_step (ThreadMirror t) {
		var req = vm.CreateStepRequest (t);
		req.Enable ();

		vm.Resume ();
		Event e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);

		req.Disable ();

		return e;
	}

	Event step_until (ThreadMirror t, string method_name) {
		Event e;
		while (true) {
			e = single_step (t);
			if ((e as StepEvent).Method.Name == method_name)
				break;
		}
		return e;
	}

	void check_arg_val (StackFrame frame, int pos, Type type, object eval) {
		object val = frame.GetArgument (pos);
		Assert.IsTrue (val is PrimitiveValue);
		object v = (val as PrimitiveValue).Value;
		Assert.AreEqual (type, v.GetType ());
		if (eval is float)
			Assert.IsTrue (Math.Abs ((float)eval - (float)v) < 0.0001);
		else if (eval is double)
			Assert.IsTrue (Math.Abs ((double)eval - (double)v) < 0.0001);
		else
			Assert.AreEqual (eval, v);
	}

	void AssertValue (object expected, object val) {
		if (expected is string) {
			Assert.IsTrue (val is StringMirror);
			Assert.AreEqual (expected, (val as StringMirror).Value);
		} else if (val is StructMirror && (val as StructMirror).Type.Name == "IntPtr") {
			AssertValue (expected, (val as StructMirror).Fields [0]);
		} else {
			Assert.IsTrue (val is PrimitiveValue);
			Assert.AreEqual (expected, (val as PrimitiveValue).Value);
		}
	}

	[SetUp]
	public void SetUp () {
		ThreadMirror.NativeTransitions = false;
		Start (new string [] { "dtest-app.exe" });
	}

	[TearDown]
	public void TearDown () {
		if (vm == null)
			return;

		if (step_req != null)
			step_req.Disable ();

		vm.Resume ();
		if (forceExit)
			vm.Exit (0);

		while (true) {
			Event e = GetNextEvent ();

			if (e is VMDeathEvent)
				break;

			vm.Resume ();
		}
		vm = null;
	}

	[Test]
	public void SimpleBreakpoint () {
		Event e;

		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp1");
		Assert.IsNotNull (m);

		vm.SetBreakpoint (m, 0);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		// Argument checking
		AssertThrows<ArgumentException> (delegate {
				// Invalid IL offset
				vm.SetBreakpoint (m, 2);
			});
	}

	[Test]
	public void BreakpointsSameLocation () {
		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp2");
		Assert.IsNotNull (m);

		vm.SetBreakpoint (m, 0);
		vm.SetBreakpoint (m, 0);

		vm.Resume ();

		var es = vm.GetNextEventSet ();
		Assert.AreEqual (2, es.Events.Length);
		Assert.IsTrue (es [0] is BreakpointEvent);
		Assert.AreEqual (m, (es [0] as BreakpointEvent).Method);

		Assert.IsTrue (es [1] is BreakpointEvent);
		Assert.AreEqual (m.Name, (es [1] as BreakpointEvent).Method.Name);
	}

	[Test]
	public void BreakpointAlreadyJITted () {
		Event e = run_until ("bp1");

		/* Place a breakpoint on bp3 */
		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp3");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, 0);

		/* Same with generic instances */
		MethodMirror m2 = entry_point.DeclaringType.GetMethod ("bp7");
		Assert.IsNotNull (m2);
		vm.SetBreakpoint (m2, 0);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		vm.Resume ();

		/* Non-shared instance */
		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.AreEqual (m2.Name, (e as BreakpointEvent).Method.Name);

		vm.Resume ();

		/* Shared instance */
		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.AreEqual (m2.Name, (e as BreakpointEvent).Method.Name);
	}

	[Test]
	public void ClearBreakpoint () {
		Event e;

		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp4");
		Assert.IsNotNull (m);
		EventRequest req1 = vm.SetBreakpoint (m, 0);
		EventRequest req2 = vm.SetBreakpoint (m, 0);

		MethodMirror m2 = entry_point.DeclaringType.GetMethod ("bp5");
		Assert.IsNotNull (m2);
		vm.SetBreakpoint (m2, 0);

		/* Run until bp4 */
		vm.Resume ();

		var es = vm.GetNextEventSet ();
		Assert.AreEqual (2, es.Events.Length);
		Assert.AreEqual (EventType.Breakpoint, es [0].EventType);
		Assert.AreEqual (m.Name, (es [0] as BreakpointEvent).Method.Name);
		Assert.AreEqual (EventType.Breakpoint, es [1].EventType);
		Assert.AreEqual (m.Name, (es [1] as BreakpointEvent).Method.Name);

		/* Clear one of them */
		req1.Disable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		/* Clear the other */
		req2.Disable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.AreEqual (m2.Name, (e as BreakpointEvent).Method.Name);
	}

	[Test]
	public void ClearAllBreakpoints () {
		Event e;

		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp4");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, 0);

		MethodMirror m2 = entry_point.DeclaringType.GetMethod ("bp5");
		Assert.IsNotNull (m2);
		vm.SetBreakpoint (m2, 0);

		vm.ClearAllBreakpoints ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsTrue (!(e is BreakpointEvent));
		if (e is VMDeathEvent)
			vm = null;
	}

	[Test]
	public void BreakpointOnGShared () {
		Event e;

		MethodMirror m = entry_point.DeclaringType.GetMethod ("bp6");
		Assert.IsNotNull (m);

		vm.SetBreakpoint (m, 0);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		// Breakpoint on an open generic method of a closed generic class (#3422)
		var frame = e.Thread.GetFrames ()[0];
		var ginst = frame.GetValue (frame.Method.GetLocal ("gc"));
		var m2 = (ginst as ObjectMirror).Type.GetMethod ("bp");
		vm.SetBreakpoint (m2, 0);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (m2.Name, (e as BreakpointEvent).Method.Name);
	}

	// Assert we have stepped to a location
	void assert_location (Event e, string method) {
		Assert.IsTrue (e is StepEvent);
		Assert.AreEqual (method, (e as StepEvent).Method.Name);
	}

	// Assert we have breakpointed at a location
	void assert_location_at_breakpoint (Event e, string method) {
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (method, (e as BreakpointEvent).Method.Name);
	}

	// Assert we have stepped to or breakpointed at a location
	void assert_location_allow_breakpoint (Event e, string method) {
		if (e is StepEvent)
			Assert.AreEqual (method, (e as StepEvent).Method.Name);
		else if (e is BreakpointEvent)
			Assert.AreEqual (method, (e as BreakpointEvent).Method.Name);
		else
			Assert.Fail ("Neither step nor breakpoint event");
	}

	StepEventRequest create_step (Event e) {
		var req = vm.CreateStepRequest (e.Thread);
		step_req = req;
		return req;
	}

	[Test]
	public void ClassLocalReflection () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "local-reflect" });

		MethodMirror m = entry_point.DeclaringType.Assembly.GetType ("LocalReflectClass").GetMethod ("RunMe");

		Assert.IsNotNull (m);

//		foreach (var x in m.Locations) {
//			Console.WriteLine (x);
//		}

		var offset = -1;
		int method_base_linum = m.Locations [0].LineNumber;
		foreach (var location in m.Locations)
			if (location.LineNumber == method_base_linum + 2) {
				offset = location.ILOffset;
				break;
			}

		var req = vm.SetBreakpoint (m, offset);

		Event e = null;

		while (true) {
			vm.Resume ();
			e = GetNextEvent ();
			if (e is BreakpointEvent)
				break;
		}

		req.Disable ();

		Assert.IsInstanceOfType (typeof (BreakpointEvent), e);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		e = single_step (e.Thread);

		var frame = e.Thread.GetFrames ()[0];

		Assert.IsNotNull (frame);
		var field = frame.Method.GetLocal ("reflectMe");
		Assert.IsNotNull (field);
		Value variable = frame.GetValue (field);

		ObjectMirror thisObj = (ObjectMirror)variable;
		TypeMirror thisType = thisObj.Type;
		FieldInfoMirror thisFi = null;
		foreach (var fi in thisType.GetFields ())
			if (fi.Name == "someField")
				thisFi = fi;

		var gotVal = thisObj.GetValue (thisFi);
		// If we got this far, we're good.
	}

	[Test]
	public void SingleStepping () {
		Event e = run_until ("single_stepping");

		var req = create_step (e);
		req.Enable ();

		// Step over 'bool b = true'
		e = step_once ();
		assert_location (e, "single_stepping");

		// Skip nop
		step_once ();

		// Step into ss1
		e = step_once ();
		assert_location (e, "ss1");

		// Skip }
		e = step_once ();

		// Step out of ss1
		e = step_once ();
		assert_location (e, "single_stepping");

		// Step over ss2
		e = step_over ();
		assert_location (e, "single_stepping");

		// Step into ss3
		e = step_into ();
		assert_location (e, "ss3");

		// Step back into single_stepping
		e = step_out ();
		assert_location (e, "single_stepping");

		// Step into next line
		e = step_into ();
		assert_location (e, "single_stepping");

		// Step into ss3_2 ()
		e = step_into ();
		assert_location (e, "ss3_2");

		// Step over ss3_2_2 ()
		e = step_over ();
		assert_location (e, "ss3_2");

		// Recreate the request
		req.Disable ();
		req.Enable ();

		// Skip }
		e = step_once ();

		// Step back into single_stepping () with the new request
		e = step_once ();
		assert_location (e, "single_stepping");

		// Step into ss4 ()
		e = step_into ();
		assert_location (e, "ss4");

		// Skip nop
		e = step_once ();

		// Change to StepSize.Line
		req.Disable ();
		req.Depth = StepDepth.Over;
		req.Size = StepSize.Line;
		req.Enable ();

		// Step over ss1 (); ss1 ();
		e = step_once ();

		// Step into ss2 ()
		req.Disable ();
		req.Depth = StepDepth.Into;
		req.Enable ();

		e = step_once ();
		assert_location (e, "ss2");

		req.Disable ();

		// Run until ss5
		e = run_until ("ss5");

		// Add an assembly filter
		req.AssemblyFilter = new AssemblyMirror [] { (e as BreakpointEvent).Method.DeclaringType.Assembly };
		req.Enable ();

		// Skip nop
		e = step_once ();

		// Step into is_even, skipping the linq stuff
		e = step_once ();
		assert_location (e, "is_even");

		// FIXME: Check that single stepping works with lock (obj)
		req.Disable ();

		// Run until ss6
		e = run_until ("ss6");

		req = create_step (e);
		req.Depth = StepDepth.Over;
		req.Enable ();

		// Check that single stepping works in out-of-line bblocks
		e = step_once ();
		e = step_once ();
		assert_location (e, "ss6");
		req.Disable ();

		// Testing stepping in, over and out with exception handlers in same or caller method

		//stepout in ss7_2, which may not go to catch(instead out to ss7)
		e = run_until ("ss7_2");
		create_step (e);
		assert_location (step_out(), "ss7");

		//stepout in ss7_2_1, which must go to catch
		run_until ("ss7_2_1");
		assert_location (step_out (), "ss7_2");

		//stepover over ss7_2, which must go to catch
		run_until ("ss7_2");
		assert_location (step_over (), "ss7_2");//move to "try {" line
		assert_location (step_over (), "ss7_2");//move to "ss7_2_2();" line
		assert_location (step_over (), "ss7_2");//step over ss7_2_2();, assume we are at "catch" now
		assert_location (step_over (), "ss7_2");//move to { of catch
		assert_location (step_over (), "ss7_2");//move to } of catch
		assert_location (step_over (), "ss7_2");//move to } of method
		assert_location (step_over (), "ss7");//finish method

		//stepover over ss7_2_1, which must go to catch
		run_until ("ss7_2_1");
		assert_location (step_over (), "ss7_2_1");//move from { of method to "throw new Exception ();"
		assert_location (step_over (), "ss7_2");//step over exception, being in ss7_2 means we are at catch

		//stepin in ss7_3, which must go to catch
		run_until ("ss7_3");
		assert_location (step_into (), "ss7_3");//move to "try {"
		assert_location (step_into (), "ss7_3");//move to "throw new Exception ();"
		step_req.Disable ();
		step_req.AssemblyFilter = new AssemblyMirror [] { (e as BreakpointEvent).Method.DeclaringType.Assembly };
		assert_location (step_into (), "ss7_3");//call "throw new Exception ();", we assume we end up at "catch"
		assert_location (step_into (), "ss7_3");//move to { of catch
		assert_location (step_into (), "ss7_3");//move to } of catch
		assert_location (step_into (), "ss7_3");//move to } of method
		assert_location (step_into (), "ss7");//move out to ss7

		//stepover in ss7_2_1, which must go to catch
		run_until ("ss7_2_1");
		assert_location (step_into (), "ss7_2_1");//move from { of method to "throw new Exception ();"
		assert_location (step_into (), "ss7_2");//step in exception, being in ss7_2 means we are at catch
		step_req.Disable ();

		// Check that stepping stops between nested calls
		e = run_until ("ss_nested_2");
		req = create_step (e);
		e = step_out ();
		assert_location (e, "ss_nested");
		e = step_into ();
		assert_location (e, "ss_nested_1");
		e = step_out ();
		assert_location (e, "ss_nested");
		// Check that step over steps over nested calls
		e = step_over ();
		assert_location (e, "ss_nested");
		e = step_into ();
		assert_location (e, "ss_nested_2");
		e = step_into ();
		assert_location (e, "ss_nested_2");
		e = step_into ();
		assert_location (e, "ss_nested_2");
		e = step_into ();
		assert_location (e, "ss_nested");
		e = step_into ();
		assert_location (e, "ss_nested_1");
		e = step_into ();
		assert_location (e, "ss_nested_1");
		e = step_into ();
		assert_location (e, "ss_nested");
		req.Disable ();

		// Check DebuggerStepThrough support
		e = run_until ("ss_step_through");
		req = create_step (e);
		req.Filter = StepFilter.DebuggerStepThrough;
		e = step_into ();
		// Step through step_through_1 ()
		e = step_into ();
		assert_location (e, "ss_step_through");
		// Step through StepThroughClass.step_through_2 ()
		e = step_into ();
		assert_location (e, "ss_step_through");
		req.Disable ();
		req.Filter = StepFilter.None;
		e = step_into ();
		assert_location (e, "step_through_3");
		req.Disable ();

		// Check DebuggerNonUserCode support
		e = run_until ("ss_non_user_code");
		req = create_step (e);
		req.Filter = StepFilter.DebuggerNonUserCode;
		e = step_into ();
		// Step through non_user_code_1 ()
		e = step_into ();
		assert_location (e, "ss_non_user_code");
		// Step through StepThroughClass.non_user_code_2 ()
		e = step_into ();
		assert_location (e, "ss_non_user_code");
		req.Disable ();
		req.Filter = StepFilter.None;
		e = step_into ();
		assert_location (e, "non_user_code_3");
		req.Disable ();

		// Check that step-over doesn't stop at inner frames with recursive functions
		e = run_until ("ss_recursive");
		req = create_step (e);
		e = step_over ();
		e = step_over ();
		e = step_over ();
		var f = e.Thread.GetFrames () [0];
		assert_location (e, "ss_recursive");
		AssertValue (1, f.GetValue (f.Method.GetLocal ("n")));
		req.Disable ();

		// Check that step-over stops correctly when inner frames with recursive functions contain breakpoints
		e = run_until ("ss_recursive2");
		ReusableBreakpoint breakpoint = new ReusableBreakpoint (this, "ss_recursive2_trap");
		try {
			breakpoint.Continue ();
			e = breakpoint.lastEvent;
			req = create_step (e);
			for (int c = 1; c <= 4; c++) {
				// The first five times we try to step over this function, the breakpoint will stop us
				assert_location_at_breakpoint (e, "ss_recursive2_trap");

				req.Disable ();
				req = create_step (e);
				req.Size = StepSize.Line;

				e = step_out ();
				e = step_over ();//Stepout gets us to ss_recursive2_trap ();, move to ss_recursive2 (next); line
				assert_location (e, "ss_recursive2");

				// Stack should consist of Main + single_stepping + (1 ss_recursive2 frame per loop iteration)
				Assert.AreEqual (c+2, e.Thread.GetFrames ().Length);
				e = step_over_or_breakpoint ();
			}
			// At this point we should have escaped the breakpoints and this will be a normal step stop
			assert_location (e, "ss_recursive2");
			Assert.AreEqual (6, e.Thread.GetFrames ().Length);
		} finally {
			req.Disable ();
			breakpoint.Disable ();
		}

		// Check that step-out stops correctly when inner frames with recursive functions contain breakpoints
		e = run_until ("ss_recursive2");
		breakpoint = new ReusableBreakpoint (this, "ss_recursive2_trap");
		try {
			breakpoint.Continue ();
			e = breakpoint.lastEvent;
			req = create_step (e);
			for (int c = 1; c <= 4; c++) {
				// The first five times we try to step over this function, the breakpoint will stop us
				assert_location_at_breakpoint (e, "ss_recursive2_trap");

				req.Disable ();
				req = create_step (e);
				req.Size = StepSize.Line;

				e = step_out ();
				assert_location (e, "ss_recursive2");

				// Stack should consist of Main + single_stepping + (1 ss_recursive2 frame per loop iteration)
				Assert.AreEqual (c+2, e.Thread.GetFrames ().Length);
				e = step_out_or_breakpoint ();
			}
			for (int c = 3; c >= 1; c--) {
				assert_location (e, "ss_recursive2");
				Assert.AreEqual (c + 2, e.Thread.GetFrames ().Length);

				e = step_out ();
			}
		} finally {
			req.Disable ();
			breakpoint.Disable ();
		}

		// Test step out with a really complicated call tree
		List<RecursiveChaoticPoint> trace = new List<RecursiveChaoticPoint>();
		trace_ss_recursive_chaotic (trace);
		e = run_until ("ss_recursive_chaotic");
		try {
			breakpoint = new ReusableBreakpoint (this, "ss_recursive_chaotic_trap");
			breakpoint.Continue ();
			e = breakpoint.lastEvent;
			foreach (RecursiveChaoticPoint point in trace)
			{
				if (point.breakpoint)
					assert_location_at_breakpoint (e, point.name);
				else
					assert_location (e, point.name);
				Assert.AreEqual (point.depth, e.Thread.GetFrames ().Length);

				req.Disable ();
				req = create_step (e);
				req.Size = StepSize.Line;
				e = step_out_or_breakpoint ();
			}
		} finally {
			req.Disable ();
			breakpoint.Disable ();
		}

		// Check that single stepping doesn't clobber fp values
		e = run_until ("ss_fp_clobber");
		req = create_step (e);
		while (true) {
			f = e.Thread.GetFrames ()[0];
			e = step_into ();
			if ((e as StepEvent).Method.Name == "ss_fp_clobber_2")
				break;
			e = step_into ();
		}
		f = e.Thread.GetFrames ()[0];
		AssertValue (7.0, f.GetValue (f.Method.GetParameters ()[0]));
		req.Disable ();

		e = run_until ("ss_await");
		e = step_in_await ("ss_await", e);//ss_await_1 ().Wait ();//in
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//var a = 1;
		e = step_in_await ("MoveNext", e);//await Task.Delay (10);
		e = step_in_await ("MoveNext", e);//return a + 2;
		e = step_in_await ("MoveNext", e);//}
		e = step_in_await ("ss_await", e);//ss_await_1 ().Wait ();//in

		e = step_in_await ("ss_await", e);//ss_await_1 ().Wait ();//over
		e = step_in_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//var a = 1;
		e = step_over_await ("MoveNext", e);//await Task.Delay (10);
		e = step_over_await ("MoveNext", e);//return a + 2;
		e = step_over_await ("MoveNext", e);//}
		e = step_over_await ("ss_await", e);//ss_await_1 ().Wait ();//over

		e = step_in_await ("ss_await", e);//ss_await_1 ().Wait ();//out before
		e = step_in_await ("MoveNext", e);//{
		e = step_out_await ("ss_await", e);//ss_await_1 ().Wait ();//out before

		e = step_in_await ("ss_await", e);//ss_await_1 ().Wait ();//out after
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//var a = 1;
		e = step_in_await ("MoveNext", e);//await Task.Delay (10);
		e = step_in_await ("MoveNext", e);//return a + 2;
		e = step_out_await ("ss_await", e);//ss_await_1 ().Wait ();//out after

		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//in
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//var a = 1;
		e = step_in_await ("MoveNext", e);//await Task.Delay (10);
		e = step_in_await ("MoveNext", e);//if (exc)
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//if (handled)
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//try {
		e = step_in_await ("MoveNext", e);//throw new Exception ();
		e = step_in_await ("MoveNext", e);//catch
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//}
		e = step_in_await ("MoveNext", e);//}
		e = step_in_await ("MoveNext", e);//}
		e = step_in_await ("MoveNext", e);//return a + 2;
		e = step_in_await ("MoveNext", e);//}
		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//in

		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//over
		e = step_in_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//var a = 1;
		e = step_over_await ("MoveNext", e);//await Task.Delay (10);
		e = step_over_await ("MoveNext", e);//if (exc)
		e = step_over_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//if (handled)
		e = step_over_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//try {
		e = step_over_await ("MoveNext", e);//throw new Exception ();
		e = step_over_await ("MoveNext", e);//catch
		e = step_over_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//}
		e = step_over_await ("MoveNext", e);//}
		e = step_over_await ("MoveNext", e);//}
		e = step_over_await ("MoveNext", e);//return a + 2;
		e = step_over_await ("MoveNext", e);//}
		e = step_over_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//over

		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//out
		e = step_in_await ("MoveNext", e);//{
		e = step_out_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//out

		e = step_in_await ("ss_await", e);//try {
		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, false).Wait ();//in
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//var a = 1;
		e = step_in_await ("MoveNext", e);//await Task.Delay (10);
		e = step_in_await ("MoveNext", e);//if (exc)
		e = step_in_await ("MoveNext", e);//{
		e = step_in_await ("MoveNext", e);//if (handled)
		e = step_in_await ("MoveNext", e);//} else {
		e = step_in_await ("MoveNext", e);//throw new Exception ();
		e = step_in_await ("ss_await", e);//catch
		e = step_in_await ("ss_await", e);//{
		e = step_in_await ("ss_await", e);//}
		e = step_in_await ("ss_await", e);//try {

		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, false).Wait ();//over
		e = step_in_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//var a = 1;
		e = step_over_await ("MoveNext", e);//await Task.Delay (10);
		e = step_over_await ("MoveNext", e);//if (exc)
		e = step_over_await ("MoveNext", e);//{
		e = step_over_await ("MoveNext", e);//if (handled)
		e = step_over_await ("MoveNext", e);//} else {
		e = step_over_await ("MoveNext", e);//throw new Exception ();
		e = step_over_await ("ss_await", e);//catch
		e = step_over_await ("ss_await", e);//{
		e = step_over_await ("ss_await", e);//}
		e = step_over_await ("ss_await", e);//try {

		e = step_in_await ("ss_await", e);//ss_await_1_exc (true, false).Wait ();//out
		e = step_in_await ("MoveNext", e);//{
		e = step_out_await ("ss_await", e);//ss_await_1_exc (true, true).Wait ();//out
	}

	Event step_in_await (string method, Event e)
	{
		if (step_req != null)
			step_req.Disable ();
		create_step (e);
		step_req.AssemblyFilter = new List<AssemblyMirror> () { entry_point.DeclaringType.Assembly };
		var ef = step_into ();
		assert_location (ef, method);
		return ef;
	}

	Event step_over_await (string method, Event e)
	{
		if (step_req != null)
			step_req.Disable ();
		create_step (e);
		step_req.AssemblyFilter = new List<AssemblyMirror> () { entry_point.DeclaringType.Assembly };
		var ef = step_over ();
		assert_location (ef, method);
		return ef;
	}

	Event step_out_await (string method, Event e)
	{
		if (step_req != null)
			step_req.Disable ();
		create_step (e);
		step_req.AssemblyFilter = new List<AssemblyMirror> () { entry_point.DeclaringType.Assembly };
		var ef = step_out ();
		assert_location (ef, method);
		return ef;
	}

	[Test]
	public void SingleSteppingNoFrames () {
		//
		// Test what happens when starting a single step operation on a thread
		// with no managed frames
		//
		// Run a delegate on a tp thread
		var e = run_until ("ss_no_frames_2");

		var this_type = e.Thread.GetFrames ()[0].Method.DeclaringType;
		this_type.SetValue (this_type.GetField ("static_i"), vm.CreateValue (56));

		var thread = e.Thread;
		var e2 = run_until ("ss_no_frames_3");
		// The tp thread should be idle now
		step_req = vm.CreateStepRequest (thread);
		step_req.Depth = StepDepth.Over;
		AssertThrows<Exception> (delegate {
			step_req.Enable ();
			});
	}

	[Test]
	public void MethodEntryExit () {
		run_until ("single_stepping");

		var req1 = vm.CreateMethodEntryRequest ();
		var req2 = vm.CreateMethodExitRequest ();

		req1.Enable ();
		req2.Enable ();

		vm.Resume ();
		Event e = GetNextEvent ();
		Assert.IsTrue (e is MethodEntryEvent);
		Assert.AreEqual ("ss1", (e as MethodEntryEvent).Method.Name);

		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is MethodExitEvent);
		Assert.AreEqual ("ss1", (e as MethodExitEvent).Method.Name);

		req1.Disable ();
		req2.Disable ();
	}

	[Test]
	public void CountFilter () {
		run_until ("single_stepping");

		MethodMirror m2 = entry_point.DeclaringType.GetMethod ("ss3");
		Assert.IsNotNull (m2);
		vm.SetBreakpoint (m2, 0);

		var req1 = vm.CreateMethodEntryRequest ();
		req1.Count = 2;
		req1.Enable ();

		// Enter ss2, ss1 is skipped
		vm.Resume ();
		Event e = GetNextEvent ();
		Assert.IsTrue (e is MethodEntryEvent);
		Assert.AreEqual ("ss2", (e as MethodEntryEvent).Method.Name);

		// Breakpoint on ss3, the entry event is no longer reported
		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is BreakpointEvent);

		req1.Disable ();
	}

	[Test]
	public void Arguments () {
		object val;

		var e = run_until ("arg1");

		StackFrame frame = e.Thread.GetFrames () [0];

		check_arg_val (frame, 0, typeof (sbyte), SByte.MaxValue - 5);
		check_arg_val (frame, 1, typeof (byte), Byte.MaxValue - 5);
		check_arg_val (frame, 2, typeof (bool), true);
		check_arg_val (frame, 3, typeof (short), Int16.MaxValue - 5);
		check_arg_val (frame, 4, typeof (ushort), UInt16.MaxValue - 5);
		check_arg_val (frame, 5, typeof (char), 'F');
		check_arg_val (frame, 6, typeof (int), Int32.MaxValue - 5);
		check_arg_val (frame, 7, typeof (uint), UInt32.MaxValue - 5);
		check_arg_val (frame, 8, typeof (long), Int64.MaxValue - 5);
		check_arg_val (frame, 9, typeof (ulong), UInt64.MaxValue - 5);
		check_arg_val (frame, 10, typeof (float), 1.2345f);
		check_arg_val (frame, 11, typeof (double), 6.78910);

		e = run_until ("arg2");

		frame = e.Thread.GetFrames () [0];

		// String
		val = frame.GetArgument (0);
		AssertValue ("FOO", val);
		Assert.AreEqual ("String", (val as ObjectMirror).Type.Name);

		// null
		val = frame.GetArgument (1);
		AssertValue (null, val);

		// object
		val = frame.GetArgument (2);
		AssertValue ("BLA", val);

		// byref
		val = frame.GetArgument (3);
		AssertValue (42, val);

		// generic instance
		val = frame.GetArgument (4);
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("GClass`1", (val as ObjectMirror).Type.Name);

		// System.Object
		val = frame.GetArgument (5);
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Object", (val as ObjectMirror).Type.Name);

		// this on static methods
		val = frame.GetThis ();
		AssertValue (null, val);

		e = run_until ("arg3");

		frame = e.Thread.GetFrames () [0];

		// this
		val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);

		// objref in register
		val = frame.GetArgument (0);
		AssertValue ("BLA", val);
	}

	[Test]
	public void Arrays () {
		object val;

		var e = run_until ("o2");

		StackFrame frame = e.Thread.GetFrames () [0];

		// String[]
		val = frame.GetArgument (0);
		Assert.IsTrue (val is ArrayMirror);
		ArrayMirror arr = val as ArrayMirror;
		Assert.AreEqual (2, arr.Length);
		AssertValue ("BAR", arr [0]);
		AssertValue ("BAZ", arr [1]);

		var vals = arr.GetValues (0, 2);
		Assert.AreEqual (2, vals.Count);
		AssertValue ("BAR", vals [0]);
		AssertValue ("BAZ", vals [1]);

		arr [0] = vm.RootDomain.CreateString ("ABC");
		AssertValue ("ABC", arr [0]);

		arr [0] = vm.CreateValue (null);
		AssertValue (null, arr [0]);

		arr.SetValues (0, new Value [] { vm.RootDomain.CreateString ("D1"), vm.RootDomain.CreateString ("D2") });
		AssertValue ("D1", arr [0]);
		AssertValue ("D2", arr [1]);

		// int
		val = frame.GetArgument (1);
		Assert.IsTrue (val is ArrayMirror);
		arr = val as ArrayMirror;
		Assert.AreEqual (2, arr.Length);
		AssertValue (42, arr [0]);
		AssertValue (43, arr [1]);

		// Argument checking
		AssertThrows<IndexOutOfRangeException> (delegate () {
				val = arr [2];
			});

		AssertThrows<IndexOutOfRangeException> (delegate () {
				val = arr [Int32.MinValue];
			});

		AssertThrows<IndexOutOfRangeException> (delegate () {
				vals = arr.GetValues (0, 3);
			});

		AssertThrows<IndexOutOfRangeException> (delegate () {
				arr [2] = vm.CreateValue (null);
			});

		AssertThrows<IndexOutOfRangeException> (delegate () {
				arr [Int32.MinValue] = vm.CreateValue (null);
			});

		AssertThrows<IndexOutOfRangeException> (delegate () {
				arr.SetValues (0, new Value [] { null, null, null });
			});

		// Multidim arrays
		val = frame.GetArgument (2);
		Assert.IsTrue (val is ArrayMirror);
		arr = val as ArrayMirror;
		Assert.AreEqual (2, arr.Rank);
		Assert.AreEqual (4, arr.Length);
		Assert.AreEqual (2, arr.GetLength (0));
		Assert.AreEqual (2, arr.GetLength (1));
		Assert.AreEqual (0, arr.GetLowerBound (0));
		Assert.AreEqual (0, arr.GetLowerBound (1));
		vals = arr.GetValues (0, 4);
		AssertValue (1, vals [0]);
		AssertValue (2, vals [1]);
		AssertValue (3, vals [2]);
		AssertValue (4, vals [3]);

		val = frame.GetArgument (3);
		Assert.IsTrue (val is ArrayMirror);
		arr = val as ArrayMirror;
		Assert.AreEqual (2, arr.Rank);
		Assert.AreEqual (4, arr.Length);
		Assert.AreEqual (2, arr.GetLength (0));
		Assert.AreEqual (2, arr.GetLength (1));
		Assert.AreEqual (1, arr.GetLowerBound (0));
		Assert.AreEqual (3, arr.GetLowerBound (1));

		AssertThrows<ArgumentOutOfRangeException> (delegate () {
				arr.GetLength (-1);
			});
		AssertThrows<ArgumentOutOfRangeException> (delegate () {
				arr.GetLength (2);
			});

		AssertThrows<ArgumentOutOfRangeException> (delegate () {
				arr.GetLowerBound (-1);
			});
		AssertThrows<ArgumentOutOfRangeException> (delegate () {
				arr.GetLowerBound (2);
			});

		// arrays treated as generic collections
		val = frame.GetArgument (4);
		Assert.IsTrue (val is ArrayMirror);
		arr = val as ArrayMirror;
	}

	[Test]
	public void Object_GetValue () {
		var e = run_until ("o1");
		var frame = e.Thread.GetFrames () [0];

		object val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);
		ObjectMirror o = (val as ObjectMirror);

		TypeMirror t = o.Type;

		// object fields
		object f = o.GetValue (t.GetField ("field_i"));
		AssertValue (42, f);
		f = o.GetValue (t.GetField ("field_s"));
		AssertValue ("S", f);
		f = o.GetValue (t.GetField ("field_enum"));
		Assert.IsTrue (f is EnumMirror);
		Assert.AreEqual (1, (f as EnumMirror).Value);
		Assert.AreEqual ("B", (f as EnumMirror).StringValue);

		// Inherited object fields
		TypeMirror parent = t.BaseType;
		f = o.GetValue (parent.GetField ("base_field_i"));
		AssertValue (43, f);
		f = o.GetValue (parent.GetField ("base_field_s"));
		AssertValue ("T", f);

		// Static fields
		f = o.GetValue (o.Type.GetField ("static_i"));
		AssertValue (55, f);

		// generic instances
		ObjectMirror o2 = frame.GetValue (frame.Method.GetParameters ()[1]) as ObjectMirror;
		Assert.AreEqual ("GClass`1", o2.Type.Name);
		TypeMirror t2 = o2.Type;
		f = o2.GetValue (t2.GetField ("field"));
		AssertValue (42, f);

		ObjectMirror o3 = frame.GetValue (frame.Method.GetParameters ()[2]) as ObjectMirror;
		Assert.AreEqual ("GClass`1", o3.Type.Name);
		TypeMirror t3 = o3.Type;
		f = o3.GetValue (t3.GetField ("field"));
		AssertValue ("FOO", f);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
			o.GetValue (null);
			});
	}

	[Test]
	public void Object_GetValues () {
		var e = run_until ("o1");
		var frame = e.Thread.GetFrames () [0];

		object val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);
		ObjectMirror o = (val as ObjectMirror);

		ObjectMirror val2 = frame.GetValue (frame.Method.GetParameters ()[0]) as ObjectMirror;

		TypeMirror t = o.Type;

		object[] vals = o.GetValues (new FieldInfoMirror [] { t.GetField ("field_i"), t.GetField ("field_s") });
		object f = vals [0];
		AssertValue (42, f);
		f = vals [1];
		AssertValue ("S", f);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
			o.GetValues (null);
			});

		AssertThrows<ArgumentNullException> (delegate () {
			o.GetValues (new FieldInfoMirror [] { null });
			});

		// field of another class
		AssertThrows<ArgumentException> (delegate () {
				o.GetValue (val2.Type.GetField ("field_j"));
			});
	}

	void TestSetValue (ObjectMirror o, string field_name, object val) {
		if (val is string)
			o.SetValue (o.Type.GetField (field_name), vm.RootDomain.CreateString ((string)val));
		else
			o.SetValue (o.Type.GetField (field_name), vm.CreateValue (val));
		Value f = o.GetValue (o.Type.GetField (field_name));
		AssertValue (val, f);
	}

	[Test]
	public void Object_SetValues () {
		var e = run_until ("o1");
		var frame = e.Thread.GetFrames () [0];

		object val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);
		ObjectMirror o = (val as ObjectMirror);

		ObjectMirror val2 = frame.GetValue (frame.Method.GetParameters ()[0]) as ObjectMirror;

		TestSetValue (o, "field_i", 22);
		TestSetValue (o, "field_bool1", false);
		TestSetValue (o, "field_bool2", true);
		TestSetValue (o, "field_char", 'B');
		TestSetValue (o, "field_byte", (byte)129);
		TestSetValue (o, "field_sbyte", (sbyte)-33);
		TestSetValue (o, "field_short", (short)(Int16.MaxValue - 5));
		TestSetValue (o, "field_ushort", (ushort)(UInt16.MaxValue - 5));
		TestSetValue (o, "field_long", Int64.MaxValue - 5);
		TestSetValue (o, "field_ulong", (ulong)(UInt64.MaxValue - 5));
		TestSetValue (o, "field_float", 6.28f);
		TestSetValue (o, "field_double", 6.28);
		TestSetValue (o, "static_i", 23);
		TestSetValue (o, "field_s", "CDEF");

		Value f;

		// intptrs
		f = o.GetValue (o.Type.GetField ("field_intptr"));
		Assert.IsInstanceOfType (typeof (StructMirror), f);
		AssertValue (Int32.MaxValue - 5, (f as StructMirror).Fields [0]);

		// enums
		FieldInfoMirror field = o.Type.GetField ("field_enum");
		f = o.GetValue (field);
		(f as EnumMirror).Value = 5;
		o.SetValue (field, f);
		f = o.GetValue (field);
		Assert.AreEqual (5, (f as EnumMirror).Value);

		// null
		o.SetValue (o.Type.GetField ("field_s"), vm.CreateValue (null));
		f = o.GetValue (o.Type.GetField ("field_s"));
		AssertValue (null, f);

		// vtype instances
		field = o.Type.GetField ("generic_field_struct");
		f = o.GetValue (field);
		o.SetValue (field, f);

		// nullables
		field = o.Type.GetField ("field_nullable");
		f = o.GetValue (field);
		AssertValue (0, (f as StructMirror).Fields [0]);
		AssertValue (false, (f as StructMirror).Fields [1]);
		o.SetValue (field, vm.CreateValue (6));
		f = o.GetValue (field);
		AssertValue (6, (f as StructMirror).Fields [0]);
		AssertValue (true, (f as StructMirror).Fields [1]);
		o.SetValue (field, vm.CreateValue (null));
		f = o.GetValue (field);
		AssertValue (0, (f as StructMirror).Fields [0]);
		AssertValue (false, (f as StructMirror).Fields [1]);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
				o.SetValues (null, new Value [0]);
			});

		AssertThrows<ArgumentNullException> (delegate () {
				o.SetValues (new FieldInfoMirror [0], null);
			});

		AssertThrows<ArgumentNullException> (delegate () {
				o.SetValues (new FieldInfoMirror [] { null }, new Value [1] { null });
			});

		// vtype with a wrong type
		AssertThrows<ArgumentException> (delegate () {
				o.SetValue (o.Type.GetField ("field_struct"), o.GetValue (o.Type.GetField ("field_enum")));
			});

		// reference type not assignment compatible
		AssertThrows<ArgumentException> (delegate () {
				o.SetValue (o.Type.GetField ("field_class"), o);
			});

		// field of another class
		AssertThrows<ArgumentException> (delegate () {
				o.SetValue (val2.Type.GetField ("field_j"), vm.CreateValue (1));
			});
	}

	[Test]
	public void Type_SetValue () {
		var e = run_until ("o1");
		var frame = e.Thread.GetFrames () [0];
		Value f;

		object val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);
		ObjectMirror o = (val as ObjectMirror);

		ObjectMirror val2 = frame.GetValue (frame.Method.GetParameters ()[0]) as ObjectMirror;

		o.Type.SetValue (o.Type.GetField ("static_i"), vm.CreateValue (55));
		f = o.Type.GetValue (o.Type.GetField ("static_i"));
		AssertValue (55, f);

		o.Type.SetValue (o.Type.GetField ("static_s"), vm.RootDomain.CreateString ("B"));
		f = o.Type.GetValue (o.Type.GetField ("static_s"));
		AssertValue ("B", f);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
				o.Type.SetValue (null, vm.CreateValue (0));
			});

		AssertThrows<ArgumentNullException> (delegate () {
				o.Type.SetValue (o.Type.GetField ("static_i"), null);
			});

		// field of another class
		AssertThrows<ArgumentException> (delegate () {
				o.SetValue (val2.Type.GetField ("field_j"), vm.CreateValue (1));
			});
	}

	[Test]
	public void TypeInfo () {
		Event e = run_until ("ti2");
		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t;

		// Array types
		t = frame.Method.GetParameters ()[0].ParameterType;

		Assert.AreEqual ("String[]", t.Name);
		Assert.AreEqual ("string[]", t.CSharpName);
		Assert.AreEqual ("Array", t.BaseType.Name);
		Assert.AreEqual (true, t.HasElementType);
		Assert.AreEqual (true, t.IsArray);
		Assert.AreEqual (1, t.GetArrayRank ());
		Assert.AreEqual ("String", t.GetElementType ().Name);

		t = frame.Method.GetParameters ()[2].ParameterType;

		Assert.AreEqual ("Int32[,]", t.Name);
		// FIXME:
		//Assert.AreEqual ("int[,]", t.CSharpName);
		Assert.AreEqual ("Array", t.BaseType.Name);
		Assert.AreEqual (true, t.HasElementType);
		Assert.AreEqual (true, t.IsArray);
		Assert.AreEqual (2, t.GetArrayRank ());
		Assert.AreEqual ("Int32", t.GetElementType ().Name);

		// Byref types
		t = frame.Method.GetParameters ()[3].ParameterType;
		// FIXME:
		//Assert.AreEqual ("Int32&", t.Name);
		//Assert.AreEqual (true, t.IsByRef);
		//Assert.AreEqual (true, t.HasElementType);

		// Pointer types
		t = frame.Method.GetParameters ()[4].ParameterType;
		// FIXME:
		//Assert.AreEqual ("Int32*", t.Name);
		Assert.AreEqual (true, t.IsPointer);
		Assert.AreEqual (true, t.HasElementType);
		Assert.AreEqual ("Int32", t.GetElementType ().Name);
		Assert.AreEqual (false, t.IsPrimitive);

		// primitive types 
		t = frame.Method.GetParameters ()[5].ParameterType;
		Assert.AreEqual (true, t.IsPrimitive);

		// value types
		t = frame.Method.GetParameters ()[6].ParameterType;
		Assert.AreEqual ("AStruct", t.Name);
		Assert.AreEqual (false, t.IsPrimitive);
		Assert.AreEqual (true, t.IsValueType);
		Assert.AreEqual (false, t.IsClass);

		// reference types
		t = frame.Method.GetParameters ()[7].ParameterType;
		Assert.AreEqual ("Tests", t.Name);
		var nested = (from nt in t.GetNestedTypes () where nt.IsNestedPublic select nt).ToArray ();
		Assert.AreEqual (1, nested.Length);
		Assert.AreEqual ("NestedClass", nested [0].Name);
		Assert.IsTrue (t.BaseType.IsAssignableFrom (t));
		Assert.IsTrue (!t.IsAssignableFrom (t.BaseType));

		// generic instances
		t = frame.Method.GetParameters ()[9].ParameterType;
		Assert.AreEqual ("GClass`1", t.Name);
		Assert.IsTrue (t.IsGenericType);
		Assert.IsFalse (t.IsGenericTypeDefinition);

		var args = t.GetGenericArguments ();
		Assert.AreEqual (1, args.Length);
		Assert.AreEqual ("Int32", args [0].Name);

		// generic type definitions
		var gtd = t.GetGenericTypeDefinition ();
		Assert.AreEqual ("GClass`1", gtd.Name);
		Assert.IsTrue (gtd.IsGenericType);
		Assert.IsTrue (gtd.IsGenericTypeDefinition);
		Assert.AreEqual (gtd, gtd.GetGenericTypeDefinition ());

		args = gtd.GetGenericArguments ();
		Assert.AreEqual (1, args.Length);
		Assert.AreEqual ("T", args [0].Name);

		// enums
		t = frame.Method.GetParameters ()[10].ParameterType;
		Assert.AreEqual ("AnEnum", t.Name);
		Assert.IsTrue (t.IsEnum);
		Assert.AreEqual ("Int32", t.EnumUnderlyingType.Name);

		// TypedReferences
		t = frame.Method.GetParameters ()[11].ParameterType;
		Assert.AreEqual ("TypedReference", t.Name);

		// properties
		t = frame.Method.GetParameters ()[7].ParameterType;

		var props = t.GetProperties ();
		Assert.AreEqual (3, props.Length);
		foreach (PropertyInfoMirror prop in props) {
			ParameterInfoMirror[] indexes = prop.GetIndexParameters ();

			if (prop.Name == "IntProperty") {
				Assert.AreEqual ("Int32", prop.PropertyType.Name);
				Assert.AreEqual ("get_IntProperty", prop.GetGetMethod ().Name);
				Assert.AreEqual ("set_IntProperty", prop.GetSetMethod ().Name);
				Assert.AreEqual (0, indexes.Length);
			} else if (prop.Name == "ReadOnlyProperty") {
				Assert.AreEqual ("Int32", prop.PropertyType.Name);
				Assert.AreEqual ("get_ReadOnlyProperty", prop.GetGetMethod ().Name);
				Assert.AreEqual (null, prop.GetSetMethod ());
				Assert.AreEqual (0, indexes.Length);
			} else if (prop.Name == "IndexedProperty") {
				Assert.AreEqual (1, indexes.Length);
				Assert.AreEqual ("Int32", indexes [0].ParameterType.Name);
			}
		}

		// custom attributes
		t = frame.Method.GetParameters ()[8].ParameterType;
		Assert.AreEqual ("Tests2", t.Name);
		var attrs = t.GetCustomAttributes (true);
		Assert.AreEqual (5, attrs.Length);
		foreach (var attr in attrs) {
			if (attr.Constructor.DeclaringType.Name == "DebuggerDisplayAttribute") {
				Assert.AreEqual (1, attr.ConstructorArguments.Count);
				Assert.AreEqual ("Tests", attr.ConstructorArguments [0].Value);
				Assert.AreEqual (2, attr.NamedArguments.Count);
				Assert.AreEqual ("Name", attr.NamedArguments [0].Property.Name);
				Assert.AreEqual ("FOO", attr.NamedArguments [0].TypedValue.Value);
				Assert.AreEqual ("Target", attr.NamedArguments [1].Property.Name);
				Assert.IsInstanceOfType (typeof (TypeMirror), attr.NamedArguments [1].TypedValue.Value);
				Assert.AreEqual ("Int32", (attr.NamedArguments [1].TypedValue.Value as TypeMirror).Name);
			} else if (attr.Constructor.DeclaringType.Name == "DebuggerTypeProxyAttribute") {
				Assert.AreEqual (1, attr.ConstructorArguments.Count);
				Assert.IsInstanceOfType (typeof (TypeMirror), attr.ConstructorArguments [0].Value);
				Assert.AreEqual ("Tests", (attr.ConstructorArguments [0].Value as TypeMirror).Name);
			} else if (attr.Constructor.DeclaringType.Name == "BAttribute") {
				Assert.AreEqual (2, attr.NamedArguments.Count);
				Assert.AreEqual ("afield", attr.NamedArguments [0].Field.Name);
				Assert.AreEqual ("bfield", attr.NamedArguments [1].Field.Name);
			} else if (attr.Constructor.DeclaringType.Name == "ClassInterfaceAttribute") {
				// inherited from System.Object
				//} else if (attr.Constructor.DeclaringType.Name == "Serializable") {
				// inherited from System.Object
			} else if (attr.Constructor.DeclaringType.Name == "ComVisibleAttribute") {
				// inherited from System.Object
			} else {
				Assert.Fail (attr.Constructor.DeclaringType.Name);
			}
		}

		var assembly = entry_point.DeclaringType.Assembly;
		var type = assembly.GetType ("Tests4");
		Assert.IsFalse (type.IsInitialized);
	}

	[Test]
	public void FieldInfo () {
		Event e = run_until ("ti2");
		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t;

		t = frame.Method.GetParameters ()[8].ParameterType;
		Assert.AreEqual ("Tests2", t.Name);

		var fi = t.GetField ("field_j");
		var attrs = fi.GetCustomAttributes (true);
		Assert.AreEqual (1, attrs.Length);
		var attr = attrs [0];
		Assert.AreEqual ("DebuggerBrowsableAttribute", attr.Constructor.DeclaringType.Name);
		Assert.AreEqual (1, attr.ConstructorArguments.Count);
		Assert.IsInstanceOfType (typeof (EnumMirror), attr.ConstructorArguments [0].Value);
		Assert.AreEqual ((int)System.Diagnostics.DebuggerBrowsableState.Collapsed, (attr.ConstructorArguments [0].Value as EnumMirror).Value);
	}

	[Test]
	public void PropertyInfo () {
		Event e = run_until ("ti2");
		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t;

		t = frame.Method.GetParameters ()[8].ParameterType;
		Assert.AreEqual ("Tests2", t.Name);

		var pi = t.GetProperty ("AProperty");
		var attrs = pi.GetCustomAttributes (true);
		Assert.AreEqual (1, attrs.Length);
		var attr = attrs [0];
		Assert.AreEqual ("DebuggerBrowsableAttribute", attr.Constructor.DeclaringType.Name);
		Assert.AreEqual (1, attr.ConstructorArguments.Count);
		Assert.IsInstanceOfType (typeof (EnumMirror), attr.ConstructorArguments [0].Value);
		Assert.AreEqual ((int)System.Diagnostics.DebuggerBrowsableState.Collapsed, (attr.ConstructorArguments [0].Value as EnumMirror).Value);
	}

	[Test]
	[Category ("only5")]
	public void Type_GetValue () {
		Event e = run_until ("o1");
		StackFrame frame = e.Thread.GetFrames () [0];

		ObjectMirror o = (frame.GetThis () as ObjectMirror);

		TypeMirror t = o.Type;

		ObjectMirror val2 = frame.GetValue (frame.Method.GetParameters ()[0]) as ObjectMirror;

		// static fields
		object f = t.GetValue (o.Type.GetField ("static_i"));
		AssertValue (55, f);

		f = t.GetValue (o.Type.GetField ("static_s"));
		AssertValue ("A", f);

		// literal static fields
		f = t.GetValue (o.Type.GetField ("literal_i"));
		AssertValue (56, f);

		f = t.GetValue (o.Type.GetField ("literal_s"));
		AssertValue ("B", f);

		// Inherited static fields
		TypeMirror parent = t.BaseType;
		f = t.GetValue (parent.GetField ("base_static_i"));
		AssertValue (57, f);

		f = t.GetValue (parent.GetField ("base_static_s"));
		AssertValue ("C", f);

		// thread static field
		f = t.GetValue (t.GetField ("tls_i"), e.Thread);
		AssertValue (42, f);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
			t.GetValue (null);
			});

		// instance fields
		AssertThrows<ArgumentException> (delegate () {
			t.GetValue (o.Type.GetField ("field_i"));
			});

		// field on another type
		AssertThrows<ArgumentException> (delegate () {
				t.GetValue (val2.Type.GetField ("static_field_j"));
			});

		// special static field
		AssertThrows<ArgumentException> (delegate () {
				t.GetValue (t.GetField ("tls_i"));
			});
	}

	[Test]
	public void Type_GetValues () {
		Event e = run_until ("o1");
		StackFrame frame = e.Thread.GetFrames () [0];

		ObjectMirror o = (frame.GetThis () as ObjectMirror);

		TypeMirror t = o.Type;

		// static fields
		object[] vals = t.GetValues (new FieldInfoMirror [] { t.GetField ("static_i"), t.GetField ("static_s") });
		object f = vals [0];
		AssertValue (55, f);

		f = vals [1];
		AssertValue ("A", f);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
			t.GetValues (null);
			});

		AssertThrows<ArgumentNullException> (delegate () {
			t.GetValues (new FieldInfoMirror [] { null });
			});
	}

	[Test]
	public void ObjRefs () {
		Event e = run_until ("objrefs1");
		StackFrame frame = e.Thread.GetFrames () [0];

		ObjectMirror o = frame.GetThis () as ObjectMirror;
		ObjectMirror child = o.GetValue (o.Type.GetField ("child")) as ObjectMirror;

		Assert.IsTrue (child.Address != 0);

		// Check that object references are internalized correctly
		Assert.AreEqual (o, frame.GetThis ());

		run_until ("objrefs2");

		// child should be gc'd now
		// This is not deterministic
		//Assert.IsTrue (child.IsCollected);

		/*
		 * No longer works since Type is read eagerly
		 */
		/*
		AssertThrows<ObjectCollectedException> (delegate () {
			TypeMirror t = child.Type;
			});
		*/
		/*
		AssertThrows<ObjectCollectedException> (delegate () {
				long addr = child.Address;
			});
		*/
	}

	[Test]
	public void Type_GetObject () {
		Event e = run_until ("o1");
		StackFrame frame = e.Thread.GetFrames () [0];

		ObjectMirror o = (frame.GetThis () as ObjectMirror);

		TypeMirror t = o.Type;

		Assert.AreEqual ("RuntimeType", t.GetTypeObject ().Type.Name);
	}

	[Test]
	public void VTypes () {
		Event e = run_until ("vtypes1");
		StackFrame frame = e.Thread.GetFrames () [0];

		// vtypes as fields
		ObjectMirror o = frame.GetThis () as ObjectMirror;
		var obj = o.GetValue (o.Type.GetField ("field_struct"));
		Assert.IsTrue (obj is StructMirror);
		var s = obj as StructMirror;
		Assert.AreEqual ("AStruct", s.Type.Name);
		AssertValue (42, s ["i"]);
		obj = s ["s"];
		AssertValue ("S", obj);
		AssertValue (43, s ["k"]);
		obj = o.GetValue (o.Type.GetField ("field_boxed_struct"));
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		Assert.AreEqual ("AStruct", s.Type.Name);
		AssertValue (42, s ["i"]);

		// Check decoding of nested structs (#14942)
		obj = o.GetValue (o.Type.GetField ("nested_struct"));
		o.SetValue (o.Type.GetField ("nested_struct"), obj);

		// Check round tripping of boxed struct fields (#12354)
		obj = o.GetValue (o.Type.GetField ("boxed_struct_field"));
		o.SetValue (o.Type.GetField ("boxed_struct_field"), obj);
		obj = o.GetValue (o.Type.GetField ("boxed_struct_field"));
		s = obj as StructMirror;
		AssertValue (1, s ["key"]);
		obj = s ["value"];
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		AssertValue (42, s ["m_value"]);

		// vtypes as arguments
		s = frame.GetArgument (0) as StructMirror;
		AssertValue (44, s ["i"]);
		obj = s ["s"];
		AssertValue ("T", obj);
		AssertValue (45, s ["k"]);

		// vtypes as array entries
		var arr = frame.GetArgument (1) as ArrayMirror;
		obj = arr [0];
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		AssertValue (1, s ["i"]);
		AssertValue ("S1", s ["s"]);
		obj = arr [1];
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		AssertValue (2, s ["i"]);
		AssertValue ("S2", s ["s"]);

		// typedbyref
		var typedref = frame.GetArgument (2) as StructMirror;
		Assert.IsTrue (typedref is StructMirror);

		// Argument checking
		s = frame.GetArgument (0) as StructMirror;
		AssertThrows<ArgumentException> (delegate () {
				obj = s ["FOO"];
			});

		// generic vtype instances
		o = frame.GetThis () as ObjectMirror;
		obj = o.GetValue (o.Type.GetField ("generic_field_struct"));
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		Assert.AreEqual ("GStruct`1", s.Type.Name);
		AssertValue (42, s ["i"]);

		// this on vtype methods
		e = run_until ("vtypes2");
		e = step_until (e.Thread, "foo");

		frame = e.Thread.GetFrames () [0];

		Assert.AreEqual ("foo", (e as StepEvent).Method.Name);
		obj = frame.GetThis ();

		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		AssertValue (44, s ["i"]);
		AssertValue ("T", s ["s"]);
		AssertValue (45, s ["k"]);

		// Test SetThis ()
		s ["i"] = vm.CreateValue (55);
		frame.SetThis (s);
		obj = frame.GetThis ();
		Assert.IsTrue (obj is StructMirror);
		s = obj as StructMirror;
		AssertValue (55, s ["i"]);
		AssertValue ("T", s ["s"]);
		AssertValue (45, s ["k"]);

		// this on static vtype methods
		e = run_until ("vtypes3");
		e = step_until (e.Thread, "static_foo");

		frame = e.Thread.GetFrames () [0];

		Assert.AreEqual ("static_foo", (e as StepEvent).Method.Name);
		obj = frame.GetThis ();
		AssertValue (null, obj);

		// vtypes which reference themselves recursively
		e = run_until ("vtypes4_2");
		frame = e.Thread.GetFrames () [0];

		Assert.IsTrue (frame.GetArgument (0) is StructMirror);
	}

	[Test]
	public void AssemblyInfo () {
		Event e = run_until ("single_stepping");

		StackFrame frame = e.Thread.GetFrames () [0];

		var aname = frame.Method.DeclaringType.Assembly.GetName ();
		Assert.AreEqual ("dtest-app, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null", aname.ToString ());

		ModuleMirror m = frame.Method.DeclaringType.Module;

		Assert.AreEqual ("dtest-app.exe", m.Name);
		Assert.AreEqual ("dtest-app.exe", m.ScopeName);
		Assert.IsTrue (m.FullyQualifiedName.IndexOf ("dtest-app.exe") != -1);
		Guid guid = m.ModuleVersionId;
		Assert.AreEqual (frame.Method.DeclaringType.Assembly, m.Assembly);
		Assert.AreEqual (frame.Method.DeclaringType.Assembly.ManifestModule, m);

		// This is no longer true on 4.0
		//Assert.AreEqual ("Assembly", frame.Method.DeclaringType.Assembly.GetAssemblyObject ().Type.Name);

		TypeMirror t = vm.RootDomain.Corlib.GetType ("System.Diagnostics.DebuggerDisplayAttribute");
		Assert.AreEqual ("DebuggerDisplayAttribute", t.Name);
	}

	[Test]
	public void LocalsInfo () {
		Event e = run_until ("locals2");

		StackFrame frame = e.Thread.GetFrames () [0];

		var locals = frame.Method.GetLocals ();
		Assert.AreEqual (9, locals.Length);
		for (int i = 0; i < 9; ++i) {
			if (locals [i].Name == "args") {
				Assert.IsTrue (locals [i].IsArg);
				Assert.AreEqual ("String[]", locals [i].Type.Name);
			} else if (locals [i].Name == "arg") {
				Assert.IsTrue (locals [i].IsArg);
				Assert.AreEqual ("Int32", locals [i].Type.Name);
			} else if (locals [i].Name == "i") {
				Assert.IsFalse (locals [i].IsArg);
				Assert.AreEqual ("Int64", locals [i].Type.Name);
			} else if (locals [i].Name == "j") {
				Assert.IsFalse (locals [i].IsArg);
				Assert.AreEqual ("Int32", locals [i].Type.Name);
			} else if (locals [i].Name == "s") {
				Assert.IsFalse (locals [i].IsArg);
				Assert.AreEqual ("String", locals [i].Type.Name);
			} else if (locals [i].Name == "t") {
				// gshared
				Assert.IsTrue (locals [i].IsArg);
				Assert.AreEqual ("String", locals [i].Type.Name);
			} else if (locals [i].Name == "rs") {
				Assert.IsTrue (locals [i].IsArg);
				Assert.AreEqual ("String", locals [i].Type.Name);
			} else if (locals [i].Name == "astruct") {
			} else if (locals [i].Name == "alist") {
			} else {
				Assert.Fail ();
			}
		}

		var scopes = frame.Method.GetScopes ();
		Assert.AreEqual (2, scopes.Length);
	}

	Event step_once () {
		vm.Resume ();
		var e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);
		return e;
	}

	Event step_into () {
		step_req.Disable ();
		step_req.Depth = StepDepth.Into;
		step_req.Enable ();
		return step_once ();
	}

	Event step_over () {
		step_req.Disable ();
		step_req.Depth = StepDepth.Over;
		step_req.Enable ();
		return step_once ();
	}

	Event step_out () {
		step_req.Disable ();
		step_req.Depth = StepDepth.Out;
		step_req.Enable ();
		return step_once ();
	}

	Event step_once_or_breakpoint () {
		vm.Resume ();
		var e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent || e is BreakpointEvent);
		return e;
	}

	Event step_over_or_breakpoint () {
		step_req.Disable ();
		step_req.Depth = StepDepth.Over;
		step_req.Enable ();
		return step_once_or_breakpoint ();
	}

	Event step_out_or_breakpoint () {
		step_req.Disable ();
		step_req.Depth = StepDepth.Out;
		step_req.Enable ();
		return step_once_or_breakpoint ();
	}

	[Test]
	public void Locals () {
		var be = run_until ("locals1");

		StackFrame frame = be.Thread.GetFrames () [0];
		MethodMirror m1 = frame.Method;

		// Compiler generated byref local
		foreach (var l in m1.GetLocals ()) {
			// The byval flag is hidden from the type
			if (l.Name != "ri" && l.Type.Name == "Double")
				AssertValue (null, frame.GetValue (l));
		}

		be = run_until ("locals2");

		frame = be.Thread.GetFrames () [0];

		object val = frame.GetValue (frame.Method.GetLocal ("i"));
		AssertValue (0, val);

		var req = create_step (be);
		req.Enable ();

		// Skip nop
		step_once ();

		// Execute i = 42
		var e = step_once ();
		Assert.AreEqual ("locals2", (e as StepEvent).Method.Name);

		// Execute s = "AB";
		e = step_once ();
		Assert.AreEqual ("locals2", (e as StepEvent).Method.Name);

		frame = e.Thread.GetFrames () [0];

		val = frame.GetValue (frame.Method.GetLocal ("i"));
		AssertValue (42, val);

		LocalVariable[] locals = frame.Method.GetLocals ();
		var vals = frame.GetValues (locals);
		Assert.AreEqual (locals.Length, vals.Length);
		for (int i = 0; i < locals.Length; ++i) {
			if (locals [i].Name == "i")
				AssertValue (42, vals [i]);
			if (locals [i].Name == "s")
				AssertValue ("AB", vals [i]);
			if (locals [i].Name == "t")
				AssertValue ("ABC", vals [i]);
			if (locals [i].Name == "alist") {
			}
		}

		// Argument checking

		// GetValue () null
		AssertThrows<ArgumentNullException> (delegate () {
				frame.GetValue ((LocalVariable)null);
			});
		// GetValue () local from another method
		AssertThrows<ArgumentException> (delegate () {
				frame.GetValue (m1.GetLocal ("foo"));
			});

		// GetValue () null
		AssertThrows<ArgumentNullException> (delegate () {
				frame.GetValue ((ParameterInfoMirror)null);
			});
		// GetValue () local from another method
		AssertThrows<ArgumentException> (delegate () {
				frame.GetValue (m1.GetParameters ()[0]);
			});

		// GetValues () null
		AssertThrows<ArgumentNullException> (delegate () {
				frame.GetValues (null);
			});
		// GetValues () embedded null
		AssertThrows<ArgumentNullException> (delegate () {
				frame.GetValues (new LocalVariable [] { null });
			});
		// GetValues () local from another method
		AssertThrows<ArgumentException> (delegate () {
				frame.GetValues (new LocalVariable [] { m1.GetLocal ("foo") });
			});
		// return value
		AssertThrows<ArgumentException> (delegate () {
				val = frame.GetValue (frame.Method.ReturnParameter);
			});

		// invalid stack frames
		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);
		Assert.AreEqual ("locals2", (e as StepEvent).Method.Name);

		AssertThrows<InvalidStackFrameException> (delegate () {
				frame.GetValue (frame.Method.GetLocal ("i"));
			});

		req.Disable ();

		// gsharedvt
		be = run_until ("locals7");

		req = create_step (be);
		req.Enable ();

		// Skip nop
		e = step_once ();

		// Test that locals are initialized
		frame = e.Thread.GetFrames () [0];
		val = frame.GetValue (frame.Method.GetLocal ("t"));
		AssertValue (0, val);

		// Execute t = arg
		e = step_once ();
		Assert.AreEqual ("locals7", (e as StepEvent).Method.Name);

		// Execute t2 = t
		e = step_once ();
		Assert.AreEqual ("locals7", (e as StepEvent).Method.Name);

		frame = e.Thread.GetFrames () [0];
		val = frame.GetValue (frame.Method.GetParameters ()[0]);
		AssertValue (22, val);
		val = frame.GetValue (frame.Method.GetLocal ("t"));
		AssertValue (22, val);
		val = frame.GetValue (frame.Method.GetLocal ("t2"));
		AssertValue (22, val);
	}

	[Test]
	public void GetVisibleVariables () {
		Event e = run_until ("locals4");

		// First scope
		var locals = e.Thread.GetFrames ()[1].GetVisibleVariables ();
		Assert.AreEqual (2, locals.Count);
		var loc = locals.First (l => l.Name == "i");
		Assert.AreEqual ("Int64", loc.Type.Name);
		loc = locals.First (l => l.Name == "s");
		Assert.AreEqual ("String", loc.Type.Name);

		loc = e.Thread.GetFrames ()[1].GetVisibleVariableByName ("i");
		Assert.AreEqual ("i", loc.Name);
		Assert.AreEqual ("Int64", loc.Type.Name);

		e = run_until ("locals5");

		// Second scope
		locals = e.Thread.GetFrames ()[1].GetVisibleVariables ();
		Assert.AreEqual (2, locals.Count);
		loc = locals.First (l => l.Name == "i");
		Assert.AreEqual ("String", loc.Type.Name);
		loc = locals.First (l => l.Name == "s");
		Assert.AreEqual ("String", loc.Type.Name);

		loc = e.Thread.GetFrames ()[1].GetVisibleVariableByName ("i");
		Assert.AreEqual ("i", loc.Name);
		Assert.AreEqual ("String", loc.Type.Name);

		// Variable in another scope
		loc = e.Thread.GetFrames ()[1].GetVisibleVariableByName ("j");
		Assert.IsNull (loc);
	}

	[Test]
	public void Exit () {
		run_until ("Main");

		vm.Exit (5);

		var e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (VMDeathEvent), e);

		Assert.AreEqual (5, (e as VMDeathEvent).ExitCode);

		var p = vm.Process;
		/* Could be a remote vm with no process */
		if (p != null) {
			p.WaitForExit ();
			Assert.AreEqual (5, p.ExitCode);

			// error handling
			AssertThrows<VMDisconnectedException> (delegate () {
					vm.Resume ();
				});
		}

		vm = null;
	}

	[Test]
	public void Dispose () {
		run_until ("Main");

		vm.Detach ();

		var e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (VMDisconnectEvent), e);

		var p = vm.Process;
		/* Could be a remote vm with no process */
		if (p != null) {
			p.WaitForExit ();
			Assert.AreEqual (3, p.ExitCode);

			// error handling
			AssertThrows<VMDisconnectedException> (delegate () {
					vm.Resume ();
				});
		}

		vm = null;
	}

	[Test]
	public void ColumnNumbers () {
		Event e = run_until ("line_numbers");

		// FIXME: Merge this with LineNumbers () when its fixed

		step_req = create_step (e);
		step_req.Depth = StepDepth.Into;
		step_req.Enable ();

		Location l;
		
		while (true) {
			vm.Resume ();

			e = GetNextEvent ();
			Assert.IsTrue (e is StepEvent);
			if (e.Thread.GetFrames ()[0].Method.Name == "ln1")
				break;
		}

		// Do an additional step over so we are not on the beginning line of the method
		step_req.Disable ();
		step_req.Depth = StepDepth.Over;
		step_req.Enable ();
		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);		

		l = e.Thread.GetFrames ()[0].Location;

		Assert.AreEqual (3, l.ColumnNumber);

		step_req.Disable ();
	}

	[Test]
	public void LineNumbers () {
		Event e = run_until ("line_numbers");

		create_step (e);
		e = step_into ();

		Location l;

		e = step_once ();

		l = e.Thread.GetFrames ()[0].Location;

		Assert.AreEqual ("dtest-app.cs", Path.GetFileName (l.SourceFile));
		Assert.AreEqual ("ln1", l.Method.Name);
		
		int line_base = l.LineNumber;

		e = step_once ();
		e = step_once ();
		l = e.Thread.GetFrames ()[0].Location;
		Assert.AreEqual ("ln2", l.Method.Name);
		Assert.AreEqual (line_base + 7, l.LineNumber);

		e = step_once ();
		e = step_once ();
		l = e.Thread.GetFrames ()[0].Location;
		Assert.AreEqual ("ln1", l.Method.Name);
		Assert.AreEqual (line_base + 2, l.LineNumber);

		e = step_once ();
		e = step_once ();
		l = e.Thread.GetFrames ()[0].Location;
		Assert.AreEqual ("ln3", l.Method.Name);
		Assert.AreEqual (line_base + 11, l.LineNumber);

		e = step_once ();
		e = step_once ();
		l = e.Thread.GetFrames ()[0].Location;
		Assert.AreEqual ("ln3", l.Method.Name);
		Assert.IsTrue (l.SourceFile.EndsWith ("FOO"));
		Assert.AreEqual (55, l.LineNumber);

		e = step_once ();
		l = e.Thread.GetFrames ()[0].Location;
		Assert.AreEqual ("ln1", l.Method.Name);
		Assert.AreEqual (line_base + 3, l.LineNumber);

		// GetSourceFiles ()
		string[] sources = l.Method.DeclaringType.GetSourceFiles ();
		Assert.AreEqual (2, sources.Length);
		Assert.AreEqual ("dtest-app.cs", sources [0]);
		Assert.AreEqual ("FOO", sources [1]);

		sources = l.Method.DeclaringType.GetSourceFiles (true);
		Assert.AreEqual (2, sources.Length);
		Assert.IsTrue (sources [0].EndsWith ("dtest-app.cs"));
		Assert.IsTrue (sources [1].EndsWith ("FOO"));
	}

	[Test]
	public void Suspend () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "suspend-test" });

		Event e = run_until ("suspend");

		ThreadMirror main = e.Thread;

		vm.Resume ();

		Thread.Sleep (100);

		vm.Suspend ();

		// The debuggee should be suspended while it is running the infinite loop
		// in suspend ()
		StackFrame frame = main.GetFrames ()[0];
		Assert.AreEqual ("suspend", frame.Method.Name);

		vm.Resume ();

		// resuming when not suspended
		AssertThrows<InvalidOperationException> (delegate () {
				vm.Resume ();
			});

		vm.Exit (0);

		vm = null;
	}

	[Test]
	public void AssemblyLoad () {
		Event e = run_until ("assembly_load");

		var load_req = vm.CreateAssemblyLoadRequest ();
		load_req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (AssemblyLoadEvent), e);
		Assert.IsTrue ((e as AssemblyLoadEvent).Assembly.Location.EndsWith ("System.dll"));

		var frames = e.Thread.GetFrames ();
		Assert.IsTrue (frames.Length > 0);
		Assert.AreEqual ("assembly_load", frames [0].Method.Name);
	}

	[Test]
	public void CreateValue () {
		PrimitiveValue v;

		v = vm.CreateValue (1);
		Assert.AreEqual (vm, v.VirtualMachine);
		Assert.AreEqual (1, v.Value);

		v = vm.CreateValue (null);
		Assert.AreEqual (vm, v.VirtualMachine);
		Assert.AreEqual (null, v.Value);

		// Argument checking
		AssertThrows <ArgumentException> (delegate () {
				v = vm.CreateValue ("FOO");
			});
	}

	[Test]
	public void CreateString () {
		StringMirror s = vm.RootDomain.CreateString ("ABC");

		Assert.AreEqual (vm, s.VirtualMachine);
		Assert.AreEqual ("ABC", s.Value);
		Assert.AreEqual (vm.RootDomain, s.Domain);

		// Long strings
		StringBuilder sb = new StringBuilder ();
		for (int i = 0; i < 1024; ++i)
			sb.Append ('A');
		s = vm.RootDomain.CreateString (sb.ToString ());

		// Argument checking
		AssertThrows <ArgumentNullException> (delegate () {
				s = vm.RootDomain.CreateString (null);
			});
	}

	[Test]
	public void CreateBoxedValue () {
		ObjectMirror o = vm.RootDomain.CreateBoxedValue (new PrimitiveValue (vm, 42));

		Assert.AreEqual ("Int32", o.Type.Name);
		//AssertValue (42, m.GetValue (o.Type.GetField ("m_value")));

		// Argument checking
		AssertThrows <ArgumentNullException> (delegate () {
				vm.RootDomain.CreateBoxedValue (null);
			});

		AssertThrows <ArgumentException> (delegate () {
				vm.RootDomain.CreateBoxedValue (o);
			});
	}

	[Test]
	public void Invoke () {
		Event e = run_until ("invoke1");

		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t = frame.Method.DeclaringType;
		ObjectMirror this_obj = (ObjectMirror)frame.GetThis ();

		TypeMirror t2 = frame.Method.GetParameters ()[0].ParameterType;

		MethodMirror m;
		Value v;

		// return void
		m = t.GetMethod ("invoke_return_void");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		Assert.IsNull (v);

		// return ref
		m = t.GetMethod ("invoke_return_ref");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		AssertValue ("ABC", v);

		// return null
		m = t.GetMethod ("invoke_return_null");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		AssertValue (null, v);

		// return primitive
		m = t.GetMethod ("invoke_return_primitive");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		AssertValue (42, v);

		// return nullable
		m = t.GetMethod ("invoke_return_nullable");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		Assert.IsInstanceOfType (typeof (StructMirror), v);
		var s = v as StructMirror;
		AssertValue (42, s.Fields [0]);
		AssertValue (true, s.Fields [1]);

		// pass nullable as this
		//m = vm.RootDomain.Corlib.GetType ("System.Object").GetMethod ("ToString");
		m = s.Type.GetMethod ("ToString");
		v = s.InvokeMethod (e.Thread, m, null);

		// pass nullable as argument
		m = t.GetMethod ("invoke_pass_nullable");
		v = this_obj.InvokeMethod (e.Thread, m, new Value [] { s });
		AssertValue (42, v);

		// return nullable null
		m = t.GetMethod ("invoke_return_nullable_null");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		Assert.IsInstanceOfType (typeof (StructMirror), v);
		s = v as StructMirror;
		AssertValue (0, s.Fields [0]);
		AssertValue (false, s.Fields [1]);

		// pass nullable as this
		//m = vm.RootDomain.Corlib.GetType ("System.Object").GetMethod ("ToString");
		m = s.Type.GetMethod ("ToString");
		v = s.InvokeMethod (e.Thread, m, null);

		// pass nullable null as argument
		m = t.GetMethod ("invoke_pass_nullable_null");
		v = this_obj.InvokeMethod (e.Thread, m, new Value [] { s });
		AssertValue (2, v);

		// pass primitive
		m = t.GetMethod ("invoke_pass_primitive");
		Value[] args = new Value [] {
			vm.CreateValue ((byte)Byte.MaxValue),
			vm.CreateValue ((sbyte)SByte.MaxValue),
			vm.CreateValue ((short)1),
			vm.CreateValue ((ushort)1),
			vm.CreateValue ((int)1),
			vm.CreateValue ((uint)1),
			vm.CreateValue ((long)1),
			vm.CreateValue ((ulong)1),
			vm.CreateValue ('A'),
			vm.CreateValue (true),
			vm.CreateValue (3.14f),
			vm.CreateValue (3.14) };

		v = this_obj.InvokeMethod (e.Thread, m, args);
		AssertValue ((int)Byte.MaxValue + (int)SByte.MaxValue + 1 + 1 + 1 + 1 + 1 + 1 + 'A' + 1 + 3 + 3, v);

		// pass ref
		m = t.GetMethod ("invoke_pass_ref");
		v = this_obj.InvokeMethod (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
		AssertValue ("ABC", v);

		// pass null
		m = t.GetMethod ("invoke_pass_ref");
		v = this_obj.InvokeMethod (e.Thread, m, new Value [] { vm.CreateValue (null) });
		AssertValue (null, v);

		// static
		m = t.GetMethod ("invoke_static_pass_ref");
		v = t.InvokeMethod (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
		AssertValue ("ABC", v);

		// static invoked using ObjectMirror.InvokeMethod
		m = t.GetMethod ("invoke_static_pass_ref");
		v = this_obj.InvokeMethod (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
		AssertValue ("ABC", v);

		// method which throws an exception
		try {
			m = t.GetMethod ("invoke_throws");
			v = this_obj.InvokeMethod (e.Thread, m, null);
			Assert.Fail ();
		} catch (InvocationException ex) {
			Assert.AreEqual ("Exception", ex.Exception.Type.Name);
		}

		// out argument
		m = t.GetMethod ("invoke_out");
		var out_task = this_obj.InvokeMethodAsyncWithResult (e.Thread, m, new Value [] { vm.CreateValue (1), vm.CreateValue (null) }, InvokeOptions.ReturnOutArgs);
		var out_args = out_task.Result.OutArgs;
		AssertValue (5, out_args [0]);
		Assert.IsTrue (out_args [1] is ArrayMirror);
		Assert.AreEqual (10, (out_args [1] as ArrayMirror).Length);

		// without ReturnOutArgs flag
		out_task = this_obj.InvokeMethodAsyncWithResult (e.Thread, m, new Value [] { vm.CreateValue (1), vm.CreateValue (null) });
		out_args = out_task.Result.OutArgs;
		Assert.IsNull (out_args);

		// newobj
		m = t.GetMethod (".ctor");
		v = t.InvokeMethod (e.Thread, m, null);
		Assert.IsInstanceOfType (typeof (ObjectMirror), v);
		Assert.AreEqual ("Tests", (v as ObjectMirror).Type.Name);

		// interface method
		var cl1 = frame.Method.DeclaringType.Assembly.GetType ("ITest2");
		m = cl1.GetMethod ("invoke_iface");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		AssertValue (42, v);

		// virtual call
		m = t.BaseType.GetMethod ("virtual_method");
		v = this_obj.InvokeMethod (e.Thread, m, null, InvokeOptions.Virtual);
		AssertValue ("V2", v);

		// virtual call on static method
		m = t.GetMethod ("invoke_static_pass_ref");
		v = t.InvokeMethod (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") }, InvokeOptions.Virtual);
		AssertValue ("ABC", v);

		// instance
		m = t.GetMethod ("invoke_pass_ref");
		var task = this_obj.InvokeMethodAsync (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
		AssertValue ("ABC", task.Result);

		// static
		m = t.GetMethod ("invoke_static_pass_ref");
		task = t.InvokeMethodAsync (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
		AssertValue ("ABC", task.Result);

		// string constructor
		var stringType = vm.RootDomain.Corlib.GetType ("System.String");
		var stringConstructor = stringType.GetMethods ().Single (c=>
			c.Name == ".ctor" &&
			c.GetParameters ().Length == 2 &&
			c.GetParameters ()[0].ParameterType.Name == "Char" &&
			c.GetParameters ()[1].ParameterType.Name == "Int32");
		var str = stringType.NewInstance (e.Thread, stringConstructor,  new Value [] { vm.CreateValue ('a'), vm.CreateValue (3)});

		AssertValue("aaa", str);

		// Argument checking
		
		// null thread
		AssertThrows<ArgumentNullException> (delegate {
				m = t.GetMethod ("invoke_pass_ref");
				v = this_obj.InvokeMethod (null, m, new Value [] { vm.CreateValue (null) });				
			});

		// null method
		AssertThrows<ArgumentNullException> (delegate {
				v = this_obj.InvokeMethod (e.Thread, null, new Value [] { vm.CreateValue (null) });				
			});

		// invalid number of arguments
		m = t.GetMethod ("invoke_pass_ref");
		AssertThrows<ArgumentException> (delegate {
				v = this_obj.InvokeMethod (e.Thread, m, null);
			});

		// invalid type of argument (ref != primitive)
		m = t.GetMethod ("invoke_pass_ref");
		AssertThrows<ArgumentException> (delegate {
				v = this_obj.InvokeMethod (e.Thread, m, new Value [] { vm.CreateValue (1) });
			});

		// invalid type of argument (primitive != primitive)
		m = t.GetMethod ("invoke_pass_primitive_2");
		AssertThrows<ArgumentException> (delegate {
				v = this_obj.InvokeMethod (e.Thread, m, new Value [] { vm.CreateValue (1) });
			});

		// invoking a non-static method as static
		m = t.GetMethod ("invoke_pass_ref");
		AssertThrows<ArgumentException> (delegate {
				v = t.InvokeMethod (e.Thread, m, new Value [] { vm.RootDomain.CreateString ("ABC") });
			});

		// invoking a method defined in another class
		m = t2.GetMethod ("invoke");
		AssertThrows<ArgumentException> (delegate {
				v = this_obj.InvokeMethod (e.Thread, m, null);
			});
	}

	[Test]
	public void InvokeVType () {
		Event e = run_until ("invoke1");

		StackFrame frame = e.Thread.GetFrames () [0];

		var s = frame.GetArgument (1) as StructMirror;

		TypeMirror t = s.Type;

		MethodMirror m;
		Value v;

		// Pass struct as this, receive int
		m = t.GetMethod ("invoke_return_int");
		v = s.InvokeMethod (e.Thread, m, null);
		AssertValue (42, v);

		// Pass boxed struct as this
		var boxed_this = t.NewInstance () as ObjectMirror;
		m = t.GetMethod ("invoke_return_int");
		v = boxed_this.InvokeMethod (e.Thread, m, null);
		AssertValue (0, v);

		// Pass struct as this, receive intptr
		m = t.GetMethod ("invoke_return_intptr");
		v = s.InvokeMethod (e.Thread, m, null);
		AssertValue (43, v);

		// Static method
		m = t.GetMethod ("invoke_static");
		v = t.InvokeMethod (e.Thread, m, null);
		AssertValue (5, v);

		// Pass generic struct as this
		s = frame.GetArgument (2) as StructMirror;
		t = s.Type;
		m = t.GetMethod ("invoke_return_int");
		v = s.InvokeMethod (e.Thread, m, null);
		AssertValue (42, v);

		// .ctor
		s = frame.GetArgument (1) as StructMirror;
		t = s.Type;
		m = t.GetMethods ().First (method => method.Name == ".ctor" && method.GetParameters ().Length == 1);
		v = t.InvokeMethod (e.Thread, m, new Value [] { vm.CreateValue (1) });
		AssertValue (1, (v as StructMirror)["i"]);

		// Invoke a method which changes state
		s = frame.GetArgument (1) as StructMirror;
		t = s.Type;
		m = t.GetMethod ("invoke_mutate");
		var task = s.InvokeMethodAsyncWithResult (e.Thread, m, null, InvokeOptions.ReturnOutThis);
		var out_this = task.Result.OutThis as StructMirror;
		AssertValue (5, out_this ["l"]);

		// Without the ReturnOutThis flag
		s = frame.GetArgument (1) as StructMirror;
		t = s.Type;
		m = t.GetMethod ("invoke_mutate");
		task = s.InvokeMethodAsyncWithResult (e.Thread, m, null);
		out_this = task.Result.OutThis as StructMirror;
		Assert.AreEqual (null, out_this);

		// interface method
		var cl1 = frame.Method.DeclaringType.Assembly.GetType ("ITest2");
		m = cl1.GetMethod ("invoke_iface");
		v = s.InvokeMethod (e.Thread, m, null);
		AssertValue (42, v);

		// virtual method
		m = vm.RootDomain.Corlib.GetType ("System.Object").GetMethod ("ToString");
		v = s.InvokeMethod (e.Thread, m, null, InvokeOptions.Virtual);
		AssertValue ("42", v);
	}

	[Test]
	public void BreakpointDuringInvoke () {
		Event e = run_until ("invoke1");

		MethodMirror m = entry_point.DeclaringType.GetMethod ("invoke2");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, 0);

		StackFrame frame = e.Thread.GetFrames () [0];
		var o = frame.GetThis () as ObjectMirror;

		bool failed = false;

		bool finished = false;
		object wait = new object ();

		// Have to invoke in a separate thread as the invoke is suspended until we
		// resume after the breakpoint
		Thread t = new Thread (delegate () {
				try {
					o.InvokeMethod (e.Thread, m, null);
				} catch {
					failed = true;
				}
				lock (wait) {
					finished = true;
					Monitor.Pulse (wait);
				}
			});

		t.Start ();

		StackFrame invoke_frame = null;

		try {
			e = GetNextEvent ();
			Assert.IsInstanceOfType (typeof (BreakpointEvent), e);
			// Check stack trace support and invokes
			var frames = e.Thread.GetFrames ();
			invoke_frame = frames [0];
			Assert.AreEqual ("invoke2", frames [0].Method.Name);
			Assert.IsTrue (frames [0].IsDebuggerInvoke);
			Assert.AreEqual ("invoke1", frames [1].Method.Name);
		} finally {
			vm.Resume ();
		}

		lock (wait) {
			if (!finished)
				Monitor.Wait (wait);
		}

		// Check that the invoke frames are no longer valid
		AssertThrows<InvalidStackFrameException> (delegate {
				invoke_frame.GetThis ();
			});

		// Check InvokeOptions.DisableBreakpoints flag
		o.InvokeMethod (e.Thread, m, null, InvokeOptions.DisableBreakpoints);
	}

	[Test]
	public void DisabledExceptionDuringInvoke () {
		Event e = run_until ("invoke_ex");

		MethodMirror m = entry_point.DeclaringType.GetMethod ("invoke_ex_inner");

		StackFrame frame = e.Thread.GetFrames () [0];
		var o = frame.GetThis () as ObjectMirror;

		var req = vm.CreateExceptionRequest (null);
		req.Enable ();

		// Check InvokeOptions.DisableBreakpoints flag
		o.InvokeMethod (e.Thread, m, null, InvokeOptions.DisableBreakpoints);

		req.Disable ();
	}

	[Test]
	public void InvokeSingleThreaded () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "invoke-single-threaded" });

		Event e = run_until ("invoke_single_threaded_2");

		StackFrame f = e.Thread.GetFrames ()[0];

		var obj = f.GetThis () as ObjectMirror;

		// Check that the counter value incremented by the other thread does not increase
		// during the invoke.
		object counter1 = (obj.GetValue (obj.Type.GetField ("counter")) as PrimitiveValue).Value;

		var m = obj.Type.GetMethod ("invoke_return_void");
		obj.InvokeMethod (e.Thread, m, null, InvokeOptions.SingleThreaded);

	    object counter2 = (obj.GetValue (obj.Type.GetField ("counter")) as PrimitiveValue).Value;

		Assert.AreEqual ((int)counter1, (int)counter2);

		// Test multiple invokes done in succession
		m = obj.Type.GetMethod ("invoke_return_void");
		obj.InvokeMethod (e.Thread, m, null, InvokeOptions.SingleThreaded);

		// Test events during single-threaded invokes
		vm.EnableEvents (EventType.TypeLoad);
		m = obj.Type.GetMethod ("invoke_type_load");
		obj.BeginInvokeMethod (e.Thread, m, null, InvokeOptions.SingleThreaded, delegate {
				vm.Resume ();
			}, null);

		e = GetNextEvent ();
		Assert.AreEqual (EventType.TypeLoad, e.EventType);
	}

	List<Value> invoke_results;

	[Test]
	public void InvokeMultiple () {
		Event e = run_until ("invoke1");

		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t = frame.Method.DeclaringType;
		ObjectMirror this_obj = (ObjectMirror)frame.GetThis ();

		TypeMirror t2 = frame.Method.GetParameters ()[0].ParameterType;

		var methods = new MethodMirror [2];
		methods [0] = t.GetMethod ("invoke_return_ref");
		methods [1] = t.GetMethod ("invoke_return_primitive");

		invoke_results = new List<Value> ();

		var r = this_obj.BeginInvokeMultiple (e.Thread, methods, null, InvokeOptions.SingleThreaded, invoke_multiple_cb, this_obj);
		WaitHandle.WaitAll (new WaitHandle[] { r.AsyncWaitHandle });
		this_obj.EndInvokeMultiple (r);
		// The callback might still be running
		while (invoke_results.Count < 2) {
			Thread.Sleep (100);
		}
		if (invoke_results [0] is PrimitiveValue) {
			AssertValue ("ABC", invoke_results [1]);
			AssertValue (42, invoke_results [0]);
		} else {
			AssertValue ("ABC", invoke_results [0]);
			AssertValue (42, invoke_results [1]);
		}
	}

	void invoke_multiple_cb (IAsyncResult ar) {
		ObjectMirror this_obj = (ObjectMirror)ar.AsyncState;

		var res = this_obj.EndInvokeMethod (ar);
		lock (invoke_results)
			invoke_results.Add (res);
	}

	[Test]
	public void InvokeAbort () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "invoke-abort" });

		Event e = run_until ("invoke_abort");

		StackFrame f = e.Thread.GetFrames ()[0];

		var obj = f.GetThis () as ObjectMirror;
		var t = obj.Type;
		var m = t.GetMethod ("invoke_abort_2");
		// Invoke multiple times to check that the subsequent invokes are aborted too
		var res = (IInvokeAsyncResult)obj.BeginInvokeMultiple (e.Thread, new MethodMirror[] { m, m, m, m }, null, InvokeOptions.None, delegate { }, null);
		Thread.Sleep (500);
		res.Abort ();
		AssertThrows<CommandException> (delegate {
				obj.EndInvokeMethod (res);
			});
	}

	[Test]
	public void GetThreads () {
		vm.GetThreads ();
	}

	[Test]
	public void Threads () {
		Event e = run_until ("threads");

		Assert.AreEqual (ThreadState.Running, e.Thread.ThreadState);

		Assert.IsTrue (e.Thread.ThreadId > 0);

		Assert.AreEqual (e.Thread.TID, e.Thread.TID);

		vm.EnableEvents (EventType.ThreadStart, EventType.ThreadDeath);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ThreadStartEvent), e);
		var state = e.Thread.ThreadState;
		Assert.IsTrue (state == ThreadState.Running || state == ThreadState.Unstarted);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ThreadDeathEvent), e);
		Assert.AreEqual (ThreadState.Stopped, e.Thread.ThreadState);
	}

	[Test]
	public void Frame_SetValue () {
		Event e = run_until ("locals2");

		StackFrame frame = e.Thread.GetFrames () [0];

		// primitive
		var l = frame.Method.GetLocal ("i");
		frame.SetValue (l, vm.CreateValue ((long)55));
		AssertValue (55, frame.GetValue (l));

		// reference
		l = frame.Method.GetLocal ("s");
		frame.SetValue (l, vm.RootDomain.CreateString ("DEF"));
		AssertValue ("DEF", frame.GetValue (l));

		// argument as local
		l = frame.Method.GetLocal ("arg");
		frame.SetValue (l, vm.CreateValue (6));
		AssertValue (6, frame.GetValue (l));

		// argument
		var p = frame.Method.GetParameters ()[1];
		frame.SetValue (p, vm.CreateValue (7));
		AssertValue (7, frame.GetValue (p));

		// gshared
		p = frame.Method.GetParameters ()[2];
		frame.SetValue (p, vm.RootDomain.CreateString ("DEF"));
		AssertValue ("DEF", frame.GetValue (p));

		// byref
		p = frame.Method.GetParameters ()[3];
		frame.SetValue (p, vm.RootDomain.CreateString ("DEF2"));
		AssertValue ("DEF2", frame.GetValue (p));

		// byref struct
		p = frame.Method.GetParameters ()[4];
		var v = frame.GetValue (p) as StructMirror;
		v ["i"] = vm.CreateValue (43);
		frame.SetValue (p, v);
		v = frame.GetValue (p) as StructMirror;
		AssertValue (43, v ["i"]);

		// argument checking

		// variable null
		AssertThrows<ArgumentNullException> (delegate () {
				frame.SetValue ((LocalVariable)null, vm.CreateValue (55));
			});

		// value null
		AssertThrows<ArgumentNullException> (delegate () {
				l = frame.Method.GetLocal ("i");
				frame.SetValue (l, null);
			});

		// value of invalid type
		AssertThrows<ArgumentException> (delegate () {
				l = frame.Method.GetLocal ("i");
				frame.SetValue (l, vm.CreateValue (55));
			});
	}

	[Test]
	[Category ("only")]
	public void Frame_SetValue_Registers () {
		Event e = run_until ("locals6_1");

		StackFrame frame = e.Thread.GetFrames () [1];

		// Set 'j' to 99
		var l = frame.Method.GetLocal ("j");
		frame.SetValue (l, vm.CreateValue (99));
		AssertValue (99, frame.GetValue (l));

		// Check it during execution
		e = run_until ("locals6_2");
		frame = e.Thread.GetFrames () [0];
		AssertValue (99, frame.GetValue (frame.Method.GetParameters ()[0]));

		// Set it while in a frame which clobbers its register
		e = run_until ("locals6_3");
		frame = e.Thread.GetFrames () [1];
		frame.SetValue (l, vm.CreateValue (100));
		AssertValue (100, frame.GetValue (l));

		// Check it during execution
		e = run_until ("locals6_4");
		frame = e.Thread.GetFrames () [0];
		AssertValue (100, frame.GetValue (frame.Method.GetParameters ()[0]));

		// Signed byte value
		e = run_until ("locals6_5");
		frame = e.Thread.GetFrames () [1];
		var l2 = frame.Method.GetLocal ("sb");
		frame.SetValue (l2, vm.CreateValue ((sbyte)-99));
		AssertValue (-99, frame.GetValue (l2));

		// Check it during execution
		e = run_until ("locals6_6");
		frame = e.Thread.GetFrames () [0];
		AssertValue (-99, frame.GetValue (frame.Method.GetParameters ()[0]));
	}

	[Test]
	public void InvokeRegress () {
		Event e = run_until ("invoke1");

		StackFrame frame = e.Thread.GetFrames () [0];

		TypeMirror t = frame.Method.DeclaringType;
		ObjectMirror this_obj = (ObjectMirror)frame.GetThis ();

		TypeMirror t2 = frame.Method.GetParameters ()[0].ParameterType;

		MethodMirror m;
		Value v;

		// do an invoke
		m = t.GetMethod ("invoke_return_void");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		Assert.IsNull (v);

		// Check that the stack frames remain valid during the invoke
		Assert.AreEqual ("Tests", (frame.GetThis () as ObjectMirror).Type.Name);

		// do another invoke
		m = t.GetMethod ("invoke_return_void");
		v = this_obj.InvokeMethod (e.Thread, m, null);
		Assert.IsNull (v);

		// Try a single step after the invoke
		var req = create_step (e);
		req.Depth = StepDepth.Into;
		req.Size = StepSize.Line;
		req.Enable ();

		// Skip nop
		step_once ();

		// Step into invoke2
		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);
		Assert.AreEqual ("invoke2", (e as StepEvent).Method.Name);

		req.Disable ();

		frame = e.Thread.GetFrames () [0];
	}

	[Test]
	public void Exceptions () {
		Event e = run_until ("exceptions");
		var req = vm.CreateExceptionRequest (null);
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("OverflowException", (e as ExceptionEvent).Exception.Type.Name);

		var frames = e.Thread.GetFrames ();
		Assert.AreEqual ("exceptions", frames [0].Method.Name);
		req.Disable ();

		// exception type filter

		req = vm.CreateExceptionRequest (vm.RootDomain.Corlib.GetType ("System.ArgumentException"));
		req.Enable ();

		// Skip the throwing of the second OverflowException	   
		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("ArgumentException", (e as ExceptionEvent).Exception.Type.Name);
		req.Disable ();

		// exception type filter for subclasses
		req = vm.CreateExceptionRequest (vm.RootDomain.Corlib.GetType ("System.Exception"));
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("OverflowException", (e as ExceptionEvent).Exception.Type.Name);
		req.Disable ();

		// no subclasses
		req.IncludeSubclasses = false;
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("Exception", (e as ExceptionEvent).Exception.Type.Name);
		req.Disable ();

		// Implicit exceptions
		req = vm.CreateExceptionRequest (null);
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("NullReferenceException", (e as ExceptionEvent).Exception.Type.Name);
		req.Disable ();

		// Single stepping after an exception
		req = vm.CreateExceptionRequest (null);
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("Exception", (e as ExceptionEvent).Exception.Type.Name);
		frames = e.Thread.GetFrames ();
		Assert.AreEqual ("exceptions2", frames [0].Method.Name);
		req.Disable ();

		var sreq = create_step (e);
		sreq.Depth = StepDepth.Over;
		sreq.Size = StepSize.Line;
		sreq.Enable ();

		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (StepEvent), e);
		frames = e.Thread.GetFrames ();
		Assert.AreEqual ("exceptions", frames [0].Method.Name);
		sreq.Disable ();

		// Argument checking
		AssertThrows<ArgumentException> (delegate {
				vm.CreateExceptionRequest (e.Thread.Type);
			});
	}

	[Test]
	public void ExceptionFilter () {
		Event e = run_until ("exception_filter");

		MethodMirror m = entry_point.DeclaringType.GetMethod ("exception_filter_filter");
		Assert.IsNotNull (m);

		vm.SetBreakpoint (m, 0);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (m.Name, (e as BreakpointEvent).Method.Name);

		var frames = e.Thread.GetFrames ();

		Assert.IsTrue (frames [0].Location.SourceFile.IndexOf ("dtest-app.cs") != -1);
		Assert.AreEqual ("exception_filter_filter", frames [0].Location.Method.Name);

		Assert.AreEqual (0, frames [1].Location.Method.MetadataToken);
		Assert.AreEqual (0x0f, frames [1].Location.ILOffset);

		Assert.AreEqual ("exception_filter_method", frames [2].Location.Method.Name);
		Assert.AreEqual (0x06, frames [2].Location.ILOffset);

		Assert.AreEqual (0, frames [3].Location.Method.MetadataToken, 0);
		Assert.AreEqual (0, frames [3].Location.ILOffset);

		Assert.AreEqual ("exception_filter", frames [4].Location.Method.Name);
	}

	[Test]
	public void ExceptionFilter2 () {
		vm.Detach ();

		Start (new string [] { "dtest-excfilter.exe" });

		MethodMirror filter_method = entry_point.DeclaringType.GetMethod ("Filter");
		Assert.IsNotNull (filter_method);

		MethodMirror test_method = entry_point.DeclaringType.GetMethod ("Test");
		Assert.IsNotNull (test_method);

		vm.SetBreakpoint (filter_method, 0);

		vm.Resume ();

		var e = GetNextEvent ();
		Assert.AreEqual (EventType.Breakpoint, e.EventType);
		Assert.IsTrue (e is BreakpointEvent);
		Assert.AreEqual (filter_method.Name, (e as BreakpointEvent).Method.Name);

		var frames = e.Thread.GetFrames ();

		Assert.AreEqual (4, frames.Count ());

		Assert.AreEqual (filter_method.Name, frames [0].Location.Method.Name);
		Assert.AreEqual (20, frames [0].Location.LineNumber);
		Assert.AreEqual (0, frames [0].Location.ILOffset);

		Assert.AreEqual (test_method.Name, frames [1].Location.Method.Name);
		Assert.AreEqual (38, frames [1].Location.LineNumber);
		Assert.AreEqual (0x10, frames [1].Location.ILOffset);

		Assert.AreEqual (test_method.Name, frames [2].Location.Method.Name);
		Assert.AreEqual (33, frames [2].Location.LineNumber);
		Assert.AreEqual (0x05, frames [2].Location.ILOffset);

		Assert.AreEqual (entry_point.Name, frames [3].Location.Method.Name);
		Assert.AreEqual (14, frames [3].Location.LineNumber);
		Assert.AreEqual (0x00, frames [3].Location.ILOffset);

		vm.Exit (0);

		vm = null;
	}

	[Test]
	public void EventSets () {
		//
		// Create two filter which both match the same exception
		//
		Event e = run_until ("exceptions");

		var req = vm.CreateExceptionRequest (null);
		req.Enable ();

		var req2 = vm.CreateExceptionRequest (vm.RootDomain.Corlib.GetType ("System.OverflowException"));
		req2.Enable ();

		vm.Resume ();

		var es = vm.GetNextEventSet ();
		Assert.AreEqual (2, es.Events.Length);

		e = es [0];
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("OverflowException", (e as ExceptionEvent).Exception.Type.Name);

		e = es [1];
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("OverflowException", (e as ExceptionEvent).Exception.Type.Name);

		req.Disable ();
		req2.Disable ();
	}

	//
	// Test single threaded invokes during processing of nullref exceptions.
	// These won't work if the exception handling is done from the sigsegv signal
	// handler, since the sigsegv signal is disabled until control returns from the
	// signal handler.
	//
	[Test]
	[Category ("only3")]
	public void NullRefExceptionAndSingleThreadedInvoke () {
		Event e = run_until ("exceptions");
		var req = vm.CreateExceptionRequest (vm.RootDomain.Corlib.GetType ("System.NullReferenceException"));
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (ExceptionEvent), e);
		Assert.AreEqual ("NullReferenceException", (e as ExceptionEvent).Exception.Type.Name);

		var ex = (e as ExceptionEvent).Exception;
		var tostring_method = vm.RootDomain.Corlib.GetType ("System.Object").GetMethod ("ToString");
		ex.InvokeMethod (e.Thread, tostring_method, null, InvokeOptions.SingleThreaded);
	}

	[Test]
	public void MemberInOtherDomain () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "domain-test" });

		vm.EnableEvents (EventType.AppDomainCreate, EventType.AppDomainUnload, EventType.AssemblyUnload);

		Event e = run_until ("domains_print_across");

		var frame = e.Thread.GetFrames ()[0];
		var inOtherDomain = frame.GetArgument (0) as ObjectMirror;
		var crossDomainField = (ObjectMirror) inOtherDomain.GetValue (inOtherDomain.Type.GetField("printMe"));
		Assert.AreEqual ("SentinelClass", crossDomainField.Type.Name);
	}

	[Test]
	public void Domains () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "domain-test" });

		vm.EnableEvents (EventType.AppDomainCreate, EventType.AppDomainUnload, EventType.AssemblyUnload);

		Event e = run_until ("domains");

		vm.Resume ();
		
		e = GetNextEvent ();
		Assert.IsInstanceOfType (typeof (AppDomainCreateEvent), e);

		var domain = (e as AppDomainCreateEvent).Domain;

		// Check the object type
		e = run_until ("domains_2");
		var frame = e.Thread.GetFrames ()[0];
		var o = frame.GetArgument (0) as ObjectMirror;
		Assert.AreEqual ("CrossDomain", o.Type.Name);

		// Do a remoting invoke
		var cross_domain_type = o.Type;
		var v = o.InvokeMethod (e.Thread, cross_domain_type.GetMethod ("invoke_3"), null);
		AssertValue (42, v);

		// Run until the callback in the domain
		MethodMirror m = entry_point.DeclaringType.GetMethod ("invoke_in_domain");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, 0);

		while (true) {
			vm.Resume ();
			e = GetNextEvent ();
			if (e is BreakpointEvent)
				break;
		}

		Assert.AreEqual ("invoke_in_domain", (e as BreakpointEvent).Method.Name);

		// d_method is from another domain
		MethodMirror d_method = (e as BreakpointEvent).Method;
		Assert.IsTrue (m != d_method);
		Assert.AreEqual (domain, d_method.DeclaringType.Assembly.Domain);

		var frames = e.Thread.GetFrames ();
		Assert.AreEqual ("invoke_in_domain", frames [0].Method.Name);
		Assert.AreEqual (domain, frames [0].Domain);
		Assert.AreEqual ("invoke", frames [1].Method.Name);
		Assert.AreEqual ("domains", frames [2].Method.Name);
		Assert.AreEqual (vm.RootDomain, frames [2].Domain);

		// Test breakpoints on already JITted methods in other domains
		m = entry_point.DeclaringType.GetMethod ("invoke_in_domain_2");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, 0);

		while (true) {
			vm.Resume ();
			e = GetNextEvent ();
			if (e is BreakpointEvent)
				break;
		}

		Assert.AreEqual ("invoke_in_domain_2", (e as BreakpointEvent).Method.Name);

		// This is empty when receiving the AppDomainCreateEvent
		Assert.AreEqual ("domain", domain.FriendlyName);

		// Run until the unload
		while (true) {
			vm.Resume ();
			e = GetNextEvent ();
			if (e is AssemblyUnloadEvent) {
				AssertThrows<Exception> (delegate () {
						var assembly_obj = (e as AssemblyUnloadEvent).Assembly.GetAssemblyObject ();
					});
				continue;
			} else {
				break;
			}
		}
		Assert.IsInstanceOfType (typeof (AppDomainUnloadEvent), e);
		Assert.AreEqual (domain, (e as AppDomainUnloadEvent).Domain);

		// Run past the unload
		e = run_until ("domains_3");

		// Test access to unloaded types
		// FIXME: Add an exception type for this
		AssertThrows<Exception> (delegate {
				d_method.DeclaringType.GetValue (d_method.DeclaringType.GetField ("static_i"));
			});

		// Check that .Domain is accessible for stack frames with native transitions
		e = run_until ("called_from_invoke");
		ThreadMirror.NativeTransitions = true;
		foreach (var f in e.Thread.GetFrames ()) {
			var dom = f.Domain;
		}
	}

	[Test]
	public void DynamicMethods () {
		Event e = run_until ("dyn_call");

		var m = e.Thread.GetFrames ()[1].Method;
		Assert.AreEqual ("dyn_method", m.Name);

		// Test access to IL
		var body = m.GetMethodBody ();

		ILInstruction ins = body.Instructions [0];
		Assert.AreEqual (OpCodes.Ldstr, ins.OpCode);
		Assert.AreEqual ("FOO", ins.Operand);
	}

	[Test]
	public void RefEmit () {
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "ref-emit-test" });

		Event e = run_until ("ref_emit_call");

		var m = e.Thread.GetFrames ()[1].Method;
		Assert.AreEqual ("ref_emit_method", m.Name);

		// Test access to IL
		var body = m.GetMethodBody ();

		ILInstruction ins;

		ins = body.Instructions [0];
		Assert.AreEqual (OpCodes.Ldstr, ins.OpCode);
		Assert.AreEqual ("FOO", ins.Operand);

		ins = body.Instructions [1];
		Assert.AreEqual (OpCodes.Call, ins.OpCode);
		Assert.IsInstanceOfType (typeof (MethodMirror), ins.Operand);
		Assert.AreEqual ("ref_emit_call", (ins.Operand as MethodMirror).Name);
	}

	[Test]
	public void IsAttached () {
		var f = entry_point.DeclaringType.GetField ("is_attached");

		Event e = run_until ("Main");

		AssertValue (true, entry_point.DeclaringType.GetValue (f));
	}

	[Test]
	public void StackTraceInNative () {
		// Check that stack traces can be produced for threads in native code
		vm.Detach ();

		Start (new string [] { "dtest-app.exe", "frames-in-native" });

		var e = run_until ("frames_in_native");

		// FIXME: This is racy
		vm.Resume ();

		Thread.Sleep (100);

		vm.Suspend ();

		StackFrame[] frames = e.Thread.GetFrames ();

		int frame_index = -1;
		for (int i = 0; i < frames.Length; ++i) {
			if (frames [i].Method.Name == "Sleep") {
				frame_index = i;
				break;
			}
		}

		Assert.IsTrue (frame_index != -1);
		Assert.AreEqual ("Sleep", frames [frame_index].Method.Name);
		Assert.AreEqual ("frames_in_native", frames [frame_index + 1].Method.Name);
		Assert.AreEqual ("Main", frames [frame_index + 2].Method.Name);

		// Check that invokes are disabled for such threads
		TypeMirror t = frames [frame_index + 1].Method.DeclaringType;

		var m = t.GetMethod ("invoke_static_return_void");
		AssertThrows<InvalidOperationException> (delegate {
				t.InvokeMethod (e.Thread, m, null);
			});

		// Check that the frame info is invalidated
		run_until ("frames_in_native_2");

		AssertThrows<InvalidStackFrameException> (delegate {
				Console.WriteLine (frames [frame_index].GetThis ());
			});
	}

	[Test]
	public void VirtualMachine_CreateEnumMirror () {
		var e = run_until ("o1");
		var frame = e.Thread.GetFrames () [0];

		object val = frame.GetThis ();
		Assert.IsTrue (val is ObjectMirror);
		Assert.AreEqual ("Tests", (val as ObjectMirror).Type.Name);
		ObjectMirror o = (val as ObjectMirror);

		FieldInfoMirror field = o.Type.GetField ("field_enum");
		Value f = o.GetValue (field);
		TypeMirror enumType = (f as EnumMirror).Type;

		o.SetValue (field, vm.CreateEnumMirror (enumType, vm.CreateValue (1)));
		f = o.GetValue (field);
		Assert.AreEqual (1, (f as EnumMirror).Value);

		// Argument checking
		AssertThrows<ArgumentNullException> (delegate () {
				vm.CreateEnumMirror (enumType, null);
			});

		AssertThrows<ArgumentNullException> (delegate () {
				vm.CreateEnumMirror (null, vm.CreateValue (1));
			});

		// null value
		AssertThrows<ArgumentException> (delegate () {
				vm.CreateEnumMirror (enumType, vm.CreateValue (null));
			});

		// value of a wrong type
		AssertThrows<ArgumentException> (delegate () {
				vm.CreateEnumMirror (enumType, vm.CreateValue ((long)1));
			});
	}

	[Test]
	public void VirtualMachine_EnableEvents_Breakpoint () {
		AssertThrows<ArgumentException> (delegate () {
				vm.EnableEvents (EventType.Breakpoint);
			});
	}

	[Test]
	public void SingleStepRegress654694 () {
		int il_offset = -1;

		MethodMirror m = entry_point.DeclaringType.GetMethod ("ss_regress_654694");
		foreach (Location l in m.Locations) {
			if (l.ILOffset > 0 && il_offset == -1)
				il_offset = l.ILOffset;
		}

		Event e = run_until ("ss_regress_654694");

		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, il_offset);

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsTrue (e is BreakpointEvent);

		var req = create_step (e);
		req.Depth = StepDepth.Over;
		req.Size = StepSize.Line;
		req.Enable ();

		vm.Resume ();

		e = GetNextEvent ();
		Assert.IsTrue (e is StepEvent);

		req.Disable ();
	}

	[Test]
	public void DebugBreak () {
		vm.EnableEvents (EventType.UserBreak);

		run_until ("user");

		vm.Resume ();
		var e = GetNextEvent ();
		Assert.IsTrue (e is UserBreakEvent);
	}

	[Test]
	public void DebugLog () {
		vm.EnableEvents (EventType.UserLog);

		run_until ("user");

		vm.Resume ();
		var e = GetNextEvent ();
		Assert.IsTrue (e is UserLogEvent);
		var le = e as UserLogEvent;

		Assert.AreEqual (5, le.Level);
		Assert.AreEqual ("A", le.Category);
		Assert.AreEqual ("B", le.Message);
	}

	[Test]
	public void TypeGetMethodsByNameFlags () {
		MethodMirror[] mm;
		var assembly = entry_point.DeclaringType.Assembly;
		var type = assembly.GetType ("Tests3");

		Assert.IsNotNull (type);

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Static | BindingFlags.Public, false);
		Assert.AreEqual (1, mm.Length, "#1");
		Assert.AreEqual ("M1", mm[0].Name, "#2");

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Static | BindingFlags.NonPublic, false);
		Assert.AreEqual (1, mm.Length, "#3");
		Assert.AreEqual ("M2", mm[0].Name, "#4");

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Instance | BindingFlags.Public, false);
		Assert.AreEqual (7, mm.Length, "#5"); //M3 plus Equals, GetHashCode, GetType, ToString, .ctor

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly, false);
		Assert.AreEqual (2, mm.Length, "#7");

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly, false);
		Assert.AreEqual (1, mm.Length, "#9");

		mm = type.GetMethodsByNameFlags (null, BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly, false);
		Assert.AreEqual (5, mm.Length, "#11");

		//Now with name
		mm = type.GetMethodsByNameFlags ("M1", BindingFlags.Static | BindingFlags.Public, false);
		Assert.AreEqual (1, mm.Length, "#12");
		Assert.AreEqual ("M1", mm[0].Name, "#13");

		mm = type.GetMethodsByNameFlags ("m1", BindingFlags.Static | BindingFlags.Public, true);
		Assert.AreEqual (1, mm.Length, "#14");
		Assert.AreEqual ("M1", mm[0].Name, "#15");

		mm = type.GetMethodsByNameFlags ("M1", BindingFlags.Static  | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, false);
		Assert.AreEqual (1, mm.Length, "#16");
		Assert.AreEqual ("M1", mm[0].Name, "#17");
	}

	[Test]
	[Category ("only88")]
	public void TypeLoadSourceFileFilter () {
		Event e = run_until ("type_load");

		if (!vm.Version.AtLeast (2, 7))
			return;

		string srcfile = (e as BreakpointEvent).Method.DeclaringType.GetSourceFiles (true)[0];
		srcfile = srcfile.Replace ("dtest-app.cs", "TypeLoadClass.cs");
		Assert.IsTrue (srcfile.Contains ("TypeLoadClass.cs"));

		var req = vm.CreateTypeLoadRequest ();
		req.SourceFileFilter = new string [] { srcfile.ToUpper () };
		req.Enable ();

		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is TypeLoadEvent);
		Assert.AreEqual ("TypeLoadClass", (e as TypeLoadEvent).Type.FullName);
	}

	[Test]
	public void TypeLoadTypeNameFilter () {
		Event e = run_until ("type_load");

		var req = vm.CreateTypeLoadRequest ();
		req.TypeNameFilter = new string [] { "TypeLoadClass2" };
		req.Enable ();

		vm.Resume ();
		e = GetNextEvent ();
		Assert.IsTrue (e is TypeLoadEvent);
		Assert.AreEqual ("TypeLoadClass2", (e as TypeLoadEvent).Type.FullName);
	}

	[Test]
	public void GetTypesForSourceFile () {
		run_until ("user");

		var types = vm.GetTypesForSourceFile ("dtest-app.cs", false);
		Assert.IsTrue (types.Any (t => t.FullName == "Tests"));
		Assert.IsFalse (types.Any (t => t.FullName == "System.Int32"));

		types = vm.GetTypesForSourceFile ("DTEST-app.cs", true);
		Assert.IsTrue (types.Any (t => t.FullName == "Tests"));
		Assert.IsFalse (types.Any (t => t.FullName == "System.Int32"));
	}

	[Test]
	public void GetTypesNamed () {
		run_until ("user");

		var types = vm.GetTypes ("Tests", false);
		Assert.AreEqual (1, types.Count);
		Assert.AreEqual ("Tests", types [0].FullName);

		types = vm.GetTypes ("System.Exception", false);
		Assert.AreEqual (1, types.Count);
		Assert.AreEqual ("System.Exception", types [0].FullName);
	}

	[Test]
	public void String_GetValue () {
		// Embedded nulls
		object val;

		// Reuse this test
		var e = run_until ("arg2");

		var frame = e.Thread.GetFrames () [0];

		val = frame.GetArgument (6);
		Assert.AreEqual ('\0'.ToString () + "A", (val as StringMirror).Value);
	}

	[Test]
	public void String_GetChars () {
		object val;

		// Reuse this test
		var e = run_until ("arg2");

		var frame = e.Thread.GetFrames () [0];

		val = frame.GetArgument (0);
		Assert.IsTrue (val is StringMirror);
		AssertValue ("FOO", val);
		var s = (val as StringMirror);
		Assert.AreEqual (3, s.Length);

		var c = s.GetChars (0, 2);
		Assert.AreEqual (2, c.Length);
		Assert.AreEqual ('F', c [0]);
		Assert.AreEqual ('O', c [1]);

		AssertThrows<ArgumentException> (delegate () {		
				s.GetChars (2, 2);
			});
	}

	[Test]
	public void GetInterfaces () {
		var e = run_until ("arg2");

		var frame = e.Thread.GetFrames () [0];

		var cl1 = frame.Method.DeclaringType.Assembly.GetType ("TestIfaces");
		var ifaces = cl1.GetInterfaces ();
		Assert.AreEqual (1, ifaces.Length);
		Assert.AreEqual ("ITest", ifaces [0].Name);

		var cl2 = cl1.GetMethod ("Baz").ReturnType;
		var ifaces2 = cl2.GetInterfaces ();
		Assert.AreEqual (1, ifaces2.Length);
		Assert.AreEqual ("ITest`1", ifaces2 [0].Name);
	}

	[Test]
	public void GetInterfaceMap () {
		var e = run_until ("arg2");

		var frame = e.Thread.GetFrames () [0];

		var cl1 = frame.Method.DeclaringType.Assembly.GetType ("TestIfaces");
		var iface = cl1.Assembly.GetType ("ITest");
		var map = cl1.GetInterfaceMap (iface);
		Assert.AreEqual (cl1, map.TargetType);
		Assert.AreEqual (iface, map.InterfaceType);
		Assert.AreEqual (2, map.InterfaceMethods.Length);
		Assert.AreEqual (2, map.TargetMethods.Length);
	}

	[Test]
	public void StackAlloc_Breakpoints_Regress2775 () {
		// Check that breakpoints on arm don't overwrite stackalloc-ed memory
		var e = run_until ("regress_2755");

		var frame = e.Thread.GetFrames () [0];
		var m = e.Method;
		// This breaks at the call site
		vm.SetBreakpoint (m, m.Locations [2].ILOffset);

		vm.Resume ();
		var e2 = GetNextEvent ();
		Assert.IsTrue (e2 is BreakpointEvent);

		e = run_until ("regress_2755_3");
		frame = e.Thread.GetFrames () [1];
		var res = frame.GetValue (m.GetLocal ("sum"));
		AssertValue (0, res);
	}

	[Test]
	public void MethodInfo () {
		Event e = run_until ("locals2");

		StackFrame frame = e.Thread.GetFrames () [0];
		var m = frame.Method;

		Assert.IsTrue (m.IsGenericMethod);
		Assert.IsFalse (m.IsGenericMethodDefinition);

		var args = m.GetGenericArguments ();
		Assert.AreEqual (1, args.Length);
		Assert.AreEqual ("String", args [0].Name);

		var gmd = m.GetGenericMethodDefinition ();
		Assert.IsTrue (gmd.IsGenericMethod);
		Assert.IsTrue (gmd.IsGenericMethodDefinition);
		Assert.AreEqual (gmd, gmd.GetGenericMethodDefinition ());

		args = gmd.GetGenericArguments ();
		Assert.AreEqual (1, args.Length);
		Assert.AreEqual ("T", args [0].Name);

		var attrs = m.GetCustomAttributes (true);
		Assert.AreEqual (1, attrs.Length);
		Assert.AreEqual ("StateMachineAttribute", attrs [0].Constructor.DeclaringType.Name);
	}

	[Test]
	public void UnhandledException () {
		vm.Exit (0);

		Start (new string [] { "dtest-app.exe", "unhandled-exception" });

		var req = vm.CreateExceptionRequest (null, false, true);
		req.Enable ();

		var e = run_until ("unhandled_exception");
		vm.Resume ();

		var e2 = GetNextEvent ();
		Assert.IsTrue (e2 is ExceptionEvent);

		vm.Exit (0);
		vm = null;
	}

	[Test]
	public void UnhandledException_2 () {
		vm.Exit (0);

		Start (new string [] { "dtest-app.exe", "unhandled-exception-endinvoke" });

		var req = vm.CreateExceptionRequest (null, false, true);
		req.Enable ();

		MethodMirror m = entry_point.DeclaringType.GetMethod ("unhandled_exception_endinvoke_2");
		Assert.IsNotNull (m);
		vm.SetBreakpoint (m, m.ILOffsets [0]);

		var e = run_until ("unhandled_exception_endinvoke");
		vm.Resume ();

		var e2 = GetNextEvent ();
		Assert.IsFalse (e2 is ExceptionEvent);

		vm.Exit (0);
		vm = null;
	}

	[Test]
	public void UnhandledExceptionUserCode () {
		vm.Detach ();

		// Exceptions caught in non-user code are treated as unhandled
		Start (new string [] { "dtest-app.exe", "unhandled-exception-user" });

		var req = vm.CreateExceptionRequest (null, false, true);
		req.AssemblyFilter = new List<AssemblyMirror> () { entry_point.DeclaringType.Assembly };
		req.Enable ();

		var e = run_until ("unhandled_exception_user");
		vm.Resume ();

		var e2 = GetNextEvent ();
		Assert.IsTrue (e2 is ExceptionEvent);

		vm.Exit (0);
		vm = null;
	}

	[Test]
	public void GCWhileSuspended () {
		// Check that objects are kept alive during suspensions
		Event e = run_until ("gc_suspend_1");

		MethodMirror m = entry_point.DeclaringType.GetMethod ("gc_suspend_invoke");

		var o = entry_point.DeclaringType.GetValue (entry_point.DeclaringType.GetField ("gc_suspend_field")) as ObjectMirror;
		//Console.WriteLine (o);

		StackFrame frame = e.Thread.GetFrames () [0];
		TypeMirror t = frame.Method.DeclaringType;
		for (int i = 0; i < 10; ++i)
			t.InvokeMethod (e.Thread, m, new Value [] { });

		// This throws an exception if the object is collected
		long addr = o.Address;

		var o2 = entry_point.DeclaringType.GetValue (entry_point.DeclaringType.GetField ("gc_suspend_field")) as ObjectMirror;
		Assert.IsNull (o2);
	}

	[Test]
	public void MakeGenericMethod () {
		Event e = run_until ("bp1");

		var intm = vm.RootDomain.GetCorrespondingType (typeof (int));
		var stringm = vm.RootDomain.GetCorrespondingType (typeof (string));
		var gm = entry_point.DeclaringType.GetMethod ("generic_method");
		var res = gm.MakeGenericMethod (new TypeMirror [] { stringm });
		var args = res.GetGenericArguments ();
		Assert.AreEqual (1, args.Length);
		Assert.AreEqual (stringm, args [0]);

		// Error checking
		AssertThrows<ArgumentNullException> (delegate {
				gm.MakeGenericMethod (null);
			});
		AssertThrows<ArgumentNullException> (delegate {
				gm.MakeGenericMethod (new TypeMirror [] { null });
			});
		AssertThrows<ArgumentException> (delegate {
				gm.MakeGenericMethod (new TypeMirror [] { stringm, stringm });
			});
		AssertThrows<InvalidOperationException> (delegate {
				gm.MakeGenericMethod (new TypeMirror [] { intm });
			});
		AssertThrows<InvalidOperationException> (delegate {
				entry_point.DeclaringType.GetMethod ("Main").MakeGenericMethod (new TypeMirror [] { intm });
			});
	}

	[Test]
	public void InspectThreadSuspenedOnWaitOne () {
		TearDown ();
		Start (true, "dtest-app.exe", "wait-one" );

		ThreadMirror.NativeTransitions = true;

		var evt = run_until ("wait_one");
		Assert.IsNotNull (evt, "#1");

		var thread = evt.Thread;
		Assert.AreEqual (ThreadState.Running, thread.ThreadState, "#1.1");

		var frames = thread.GetFrames ();
		Assert.IsNotNull (frames, "#2");
		Assert.AreEqual (2, frames.Length, "#3");
		Assert.AreEqual ("wait_one", frames [0].Method.Name, "#4");
		Assert.AreEqual ("Main", frames [1].Method.Name, "#5");

		vm.Resume ();

		Thread.Sleep (500); //FIXME this is racy, maybe single step? or something?

		vm.Suspend ();
		Assert.AreEqual (ThreadState.WaitSleepJoin, thread.ThreadState, "#6");

		frames = thread.GetFrames ();
		Assert.AreEqual (8, frames.Length, "#7");
		Assert.AreEqual ("Wait_internal", frames [0].Method.Name, "#8.0");
		Assert.AreEqual ("WaitOneNative", frames [1].Method.Name, "#8.1");
		Assert.AreEqual ("InternalWaitOne", frames [2].Method.Name, "#8.2");
		Assert.AreEqual ("WaitOne", frames [3].Method.Name, "#8.3");
		Assert.AreEqual ("WaitOne", frames [4].Method.Name, "#8.4");
		Assert.AreEqual ("WaitOne", frames [5].Method.Name, "#8.5");
		Assert.AreEqual ("wait_one", frames [6].Method.Name, "#8.6");
		Assert.AreEqual ("Main", frames [7].Method.Name, "#8.7");

		var frame = frames [0];
		Assert.IsTrue (frame.IsNativeTransition, "#11.1");
		try {
			frame.GetThis ();
			Assert.Fail ("Known limitation - can't get info from m2n frames");
		} catch (AbsentInformationException) {}

		frame = frames [3];
		Assert.IsFalse (frame.IsNativeTransition, "#12.1");
		var wait_one_this = frame.GetThis ();
		Assert.IsNotNull (wait_one_this, "#12.2");

		frame = frames [6];
		var locals = frame.GetVisibleVariables ();
		Assert.AreEqual (1, locals.Count, "#13.1");

		var local_0 = frame.GetValue (locals [0]);
		Assert.IsNotNull (local_0, "#13.2");

		Assert.AreEqual (wait_one_this, local_0, "#14.2");
	}

	[Test]
	public void GetMethodBody () {
		var bevent = run_until ("Main");

		var m = bevent.Method.DeclaringType.GetMethod ("get_IntProperty");
		var body = m.GetMethodBody ();
		foreach (var ins in body.Instructions) {
			if (ins.OpCode == OpCodes.Ldfld) {
				var field = (FieldInfoMirror)ins.Operand;
				Assert.AreEqual ("field_i", field.Name);
			}
		}
	}

	[Test]
	public void EvaluateMethod () {
		var bevent = run_until ("evaluate_method_2");

		var m = bevent.Method.DeclaringType.GetMethod ("get_IntProperty");

		var this_obj = bevent.Thread.GetFrames ()[0].GetThis ();
		var v = m.Evaluate (this_obj, null);
		AssertValue (42, v);
	}

	[Test]
	public void SetIP () {
		var bevent = run_until ("set_ip_1");

		var invalid_loc = bevent.Thread.GetFrames ()[0].Location;

		var req = create_step (bevent);
		var e = step_out ();
		req.Disable ();
		var frames = e.Thread.GetFrames ();
		var locs = frames [0].Method.Locations;

		var next_loc = locs.First (l => (l.LineNumber == frames [0].Location.LineNumber + 3));

		e.Thread.SetIP (next_loc);

		/* Check that i ++; j = 5; was skipped */
		bevent = run_until ("set_ip_2");
		var f = bevent.Thread.GetFrames ()[1];
		AssertValue (2, f.GetValue (f.Method.GetLocal ("i")));
		AssertValue (0, f.GetValue (f.Method.GetLocal ("j")));

		// Error handling
		AssertThrows<ArgumentNullException> (delegate {
				e.Thread.SetIP (null);
			});

		AssertThrows<ArgumentException> (delegate {
				e.Thread.SetIP (invalid_loc);
			});
	}

	[Test]
	public void SetIPSingleStep () {
		// Check that single stepping after set-ip steps from the new ip
		var bevent = run_until ("set_ip_1");

		var invalid_loc = bevent.Thread.GetFrames ()[0].Location;

		var req = create_step (bevent);
		req.Size = StepSize.Line;
		var e = step_out ();
		req.Disable ();
		var frames = e.Thread.GetFrames ();
		var locs = frames [0].Method.Locations;
		var prev_loc = locs.First (l => (l.LineNumber == frames [0].Location.LineNumber - 1));
		AssertValue (2, frames [0].GetValue (frames [0].Method.GetLocal ("i")));

		// Set back the ip to the first i ++; line
		e.Thread.SetIP (prev_loc);

		e = step_over ();
		var f = e.Thread.GetFrames ()[0];
		AssertValue (3, f.GetValue (f.Method.GetLocal ("i")));
	}

	[Test]
	public void NewInstanceNoCtor () {
		var bevent = run_until ("Main");

		var stype = bevent.Method.DeclaringType.Assembly.GetType ("AStruct");
		var obj = stype.NewInstance ();
		Assert.IsTrue (obj is ObjectMirror);
		Assert.AreEqual ("AStruct", (obj as ObjectMirror).Type.Name);
	}

	[Test]
	public void StaticCtorFilterInCctor () {
		// Check that single stepping when in a cctor only ignores
		// other cctors, not the current one
		var bevent = run_until ("step_filters");

		var assembly = entry_point.DeclaringType.Assembly;
		var type = assembly.GetType ("Tests/ClassWithCctor");
		var cctor = type.GetMethod (".cctor");
		vm.SetBreakpoint (cctor, 0);

		vm.Resume ();
		var e = GetNextEvent ();
		Assert.IsTrue (e is BreakpointEvent);

		var req = create_step (e);
		req.Filter = StepFilter.StaticCtor;
		e = step_into ();
		// Make sure we are still in the cctor
		Assert.AreEqual (".cctor", e.Thread.GetFrames ()[0].Location.Method.Name);
	}

	[Test]
	public void ThreadpoolIOsinglestep () {
		TearDown ();
		Start ("dtest-app.exe", "threadpool-io");
		// This is a regression test for #42625.  It tests the
		// interaction (particularly in coop GC) of the
		// threadpool I/O mechanism and the soft debugger.
		Event e = run_until ("threadpool_io");
		// run until we sent the task half the bytes it
		// expects, so that it blocks waiting for the rest.
		e = run_until ("threadpool_bp");
		var req = create_step (e);
		e = step_out (); // leave threadpool_bp
		e = step_out (); // leave threadpool_io
	}

	[Test]
	// Uses a fixed port
	[Category("NotWorking")]
	public void Attach () {
		vm.Exit (0);

		// Launch the app using server=y,suspend=n
		var pi = CreateStartInfo (new string[] { "--debugger-agent=transport=dt_socket,address=127.0.0.1:10000,server=y,suspend=n", "dtest-app.exe", "attach" });
		var process = Diag.Process.Start (pi);

		// Wait for the app to reach the Sleep () in attach ().
		Thread.Sleep (1000);
		var ep = new IPEndPoint (IPAddress.Loopback, 10000);
		vm = VirtualMachineManager.Connect (ep);

		var load_req = vm.CreateAssemblyLoadRequest ();
		load_req.Enable ();
		vm.EnableEvents (EventType.TypeLoad);

		Event vmstart = GetNextEvent ();
		Assert.AreEqual (EventType.VMStart, vmstart.EventType);

		// Get collected events
		bool assembly_load_found = false;
		bool type_load_found = false;
		while (true) {
			Event e = GetNextEvent ();

			// AssemblyLoad
			if (e is AssemblyLoadEvent) {
				var assemblyload = e as AssemblyLoadEvent;

				var amirror = assemblyload.Assembly;

				if (amirror.GetName ().Name == "System.Transactions") {
					assembly_load_found = true;
					Assert.AreEqual ("domain", amirror.Domain.FriendlyName);
				}

				if (amirror.GetName ().Name == "dtest-app")
					// Set a bp so we can break the event loop
					vm.SetBreakpoint (amirror.EntryPoint.DeclaringType.GetMethod ("attach_break"), 0);
			}
			if (e is TypeLoadEvent) {
				var typeload = e as TypeLoadEvent;

				if (typeload.Type.Name == "GCSettings") {
					type_load_found = true;
					Assert.AreEqual ("domain", typeload.Type.Assembly.Domain.FriendlyName);
				}
			}

			if (e is BreakpointEvent)
				break;
		}
		Assert.IsTrue (assembly_load_found);
		Assert.IsTrue (type_load_found);

		vm.Exit (0);
		vm = null;
	}

	[Test]
	[Category("NotWorking")]
	public void Hash ()
	{
		Event e = run_until ("Main");

		Location l = e.Thread.GetFrames ()[0].Location;

		using (FileStream fs = new FileStream (l.SourceFile, FileMode.Open, FileAccess.Read)) {
			Assert.AreEqual (MD5.Create ().ComputeHash (fs), l.SourceFileHash);
		}
	}

}

}

```