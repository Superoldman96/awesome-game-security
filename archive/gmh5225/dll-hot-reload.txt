Project Path: arc_gmh5225_dll-hot-reload_jb8u23j4

Source Tree:

```txt
arc_gmh5225_dll-hot-reload_jb8u23j4
├── CMakeLists.txt
├── LICENSE
├── README.md
├── examples
│   └── dll_loader.ini
└── src
    ├── CMakeLists.txt
    ├── configuration.cc
    ├── configuration.h
    ├── dll_mapper.h
    ├── dll_mappers
    │   ├── manual.cc
    │   ├── manual.h
    │   ├── win32.cc
    │   └── win32.h
    ├── dllmain.cc
    ├── hot_reload.cc
    ├── hot_reload.h
    ├── logging.h
    ├── scope_guard.h
    └── test_host.cc

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.14)

option(BUILD_TEST_EXE "Build test executable" OFF)

project(dll-hot-reload LANGUAGES CXX)

include(FetchContent)

if (MSVC AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 19.29.30129 AND CMAKE_VERSION VERSION_GREATER 3.20.3)
    # this change happened in CMake 3.20.4
    set(CMAKE_CXX_STANDARD 23) # /std:c++latest - unlocks the non stable cpp20 features. For new 16.11 versions
else ()
    set(CMAKE_CXX_STANDARD 20) # /std:c++latest for msvc and -std=c++20 for everyone else.
endif ()
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# inipp
FetchContent_Declare(
    inipp
    GIT_REPOSITORY https://github.com/mcmtroffaes/inipp.git
    GIT_TAG        46248e4e93a2e63f9a1d0d8d9ad40bd6b3725df5
)
FetchContent_MakeAvailable(inipp)

# Blackbone
FetchContent_Declare(
    BlackBone
    GIT_REPOSITORY https://github.com/DarthTon/Blackbone.git
    GIT_TAG        a672509b5458efeb68f65436259b96fa8cd4dcfc
)
FetchContent_MakeAvailable(BlackBone)
add_subdirectory("${blackbone_SOURCE_DIR}/src/BlackBone")
if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "8")
    target_link_libraries(BlackBone PRIVATE "${blackbone_SOURCE_DIR}/src/3rd_party/DIA/lib/amd64/diaguids.lib")
elseif("${CMAKE_SIZEOF_VOID_P}" STREQUAL "4")
    target_link_libraries(BlackBone PRIVATE "${blackbone_SOURCE_DIR}/src/3rd_party/DIA/lib/diaguids.lib")
endif()
target_include_directories(BlackBone PUBLIC "${blackbone_SOURCE_DIR}/src/3rd_party")
target_include_directories(BlackBone INTERFACE "${blackbone_SOURCE_DIR}/src")

add_subdirectory("src")

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Erwan Grelet

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# dll-hot-reload

Small utility DLL that loads and reloads a given DLL when it's updated on disk.
This can be useful when developing and debugging DLLs which are meant to be
injected (*e.g.*, game mods, in-process debugging tools).

**Features**  
* Configuration via INI file
* Can use manual mapping (with Blackbone)

## How to Build

```
$ cmake -B build
$ cmake --build build --config Release -- -maxcpucount
```


## How to Use

Create a `dll_loader.ini` file in the working directory of the host application
the DLL will be loaded into.  
An example INI file can be found in the `examples` subfolder.
```

`examples/dll_loader.ini`:

```ini
DllPath=mydll.dll
ManualMap=true
```

`src/CMakeLists.txt`:

```txt
add_library(dll_loader MODULE
  "dllmain.cc"
  "logging.h"
  "scope_guard.h"
  "configuration.h"
  "configuration.cc"
  "hot_reload.h"
  "hot_reload.cc"
  "dll_mapper.h"

  "dll_mappers/win32.h"
  "dll_mappers/win32.cc"
  "dll_mappers/manual.h"
  "dll_mappers/manual.cc"
)
target_link_libraries(dll_loader PRIVATE inipp::inipp BlackBone)
target_include_directories(dll_loader PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})

if(BUILD_TEST_EXE)
  add_executable(test_host "test_host.cc")
endif()
```

`src/configuration.cc`:

```cc
#include "configuration.h"

#include <inipp.h>

#include <fstream>

#include "logging.h"

namespace dll_loader {

namespace fs = std::filesystem;

// LoaderConfiguration

bool LoaderConfiguration::LoadFromFile(const fs::path& configuration_path) {
  std::ifstream is(configuration_path);
  if (!is.is_open()) {
    LOG("Failed to open '{}'", configuration_path.string());
    return false;
  }
  inipp::Ini<char> ini;
  ini.parse(is);

  if (!inipp::get_value(ini.sections[""], "DllPath", dll_path_str)) {
    LOG("Failed to retrieve 'DllPath' value from configuration");
    return false;
  }

  if (!inipp::get_value(ini.sections[""], "ManualMap", use_manual_mapping)) {
    LOG("Failed to retrieve 'ManualMap' value from configuration");
    return false;
  }

  return true;
}

}  // namespace dll_loader
```

`src/configuration.h`:

```h
#pragma once

#include <filesystem>
#include <string>

namespace dll_loader {

struct LoaderConfiguration {
  std::string dll_path_str{};
  bool use_manual_mapping{};

  bool LoadFromFile(const std::filesystem::path& configuration_path);
};

}  // namespace dll_loader
```

`src/dll_mapper.h`:

```h
#pragma once

#include <filesystem>
#include <memory>

namespace dll_loader {

class IDllMapper {
 public:
  using Ptr = std::unique_ptr<IDllMapper>;

  virtual ~IDllMapper() = default;
  virtual bool LoadDll(const std::filesystem::path& dll_path) = 0;
  virtual bool UnloadAllDlls() = 0;
};

}  // namespace dll_loader

```

`src/dll_mappers/manual.cc`:

```cc
#include "dll_mappers/manual.h"

#include "logging.h"

namespace dll_loader::mappers {

namespace fs = std::filesystem;

ManualDllMapper::ManualDllMapper() : current_process_() {
  current_process_.Attach(::GetCurrentProcessId());
}

bool ManualDllMapper::LoadDll(const fs::path& dll_path) {
  LOG("Entered '{}'", __FUNCTION__);
  const auto result = current_process_.mmap().MapImage(dll_path.wstring());
  return result.success();
}

bool ManualDllMapper::UnloadAllDlls() {
  LOG("Entered '{}'", __FUNCTION__);
  return NT_SUCCESS(current_process_.mmap().UnmapAllModules());
}

}  // namespace dll_loader::mappers
```

`src/dll_mappers/manual.h`:

```h
#pragma once

#include <BlackBone/Process/Process.h>

#include "dll_mapper.h"

namespace dll_loader::mappers {

class ManualDllMapper final : public IDllMapper {
 public:
  ManualDllMapper();

  bool LoadDll(const std::filesystem::path& dll_path) override;
  bool UnloadAllDlls() override;

 private:
  blackbone::Process current_process_;
};

}  // namespace dll_loader::mappers

```

`src/dll_mappers/win32.cc`:

```cc
#include "dll_mappers/win32.h"

#include "logging.h"

namespace dll_loader::mappers {

namespace fs = std::filesystem;

bool Win32DllMapper::LoadDll(const fs::path& dll_path) {
  LOG("Entered '{}'", __FUNCTION__);

  std::error_code err{};
  const auto new_dll_path = fs::temp_directory_path() / dll_path.filename();
  fs::copy_file(dll_path, new_dll_path, fs::copy_options::overwrite_existing,
                err);
  if (err) {
    LOG("copy_file failed. Error: {}", err.message());
    return false;
  }

  current_dll_handle_ = ::LoadLibraryW(new_dll_path.wstring().c_str());
  if (current_dll_handle_ == nullptr) {
    LOG("LoadLibraryW failed. LastError=0x{:x}", ::GetLastError());
    fs::remove(new_dll_path);
    return false;
  }

  current_dll_path_ = new_dll_path;
  return true;
}

bool Win32DllMapper::UnloadAllDlls() {
  LOG("Entered '{}'", __FUNCTION__);
  // Free (and unload) the DLL
  if (current_dll_handle_ != nullptr) {
    if (::FreeLibrary(current_dll_handle_) == FALSE) {
      LOG("FreeLibrary failed. LastError=0x{:x}", ::GetLastError());
      return false;
    }
    current_dll_handle_ = nullptr;
  }

  std::error_code err{};
  fs::remove(current_dll_path_, err);
  if (err) {
    LOG("remove failed. Error: {}", err.message());
    return false;
  }
  current_dll_path_.clear();

  return true;
}

}  // namespace dll_loader::mappers
```

`src/dll_mappers/win32.h`:

```h
#pragma once

#include <windows.h>

#include <filesystem>

#include "dll_mapper.h"

namespace dll_loader::mappers {

class Win32DllMapper final : public IDllMapper {
 public:
  bool LoadDll(const std::filesystem::path& dll_path) override;
  bool UnloadAllDlls() override;

 private:
  HMODULE current_dll_handle_;
  std::filesystem::path current_dll_path_;
};

}  // namespace dll_loader::mappers

```

`src/dllmain.cc`:

```cc
#include <windows.h>

#include "hot_reload.h"
#include "logging.h"

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
  LOG("Entered '{}' - Reason 0x{:x}", __FUNCTION__, fdwReason);
  static dll_loader::HotReloadService context{};

  switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
      if (!context.Initialize()) {
        return FALSE;
      }
      break;
    case DLL_PROCESS_DETACH:
      context.Cleanup();
      break;
  }
  return TRUE;
}
```

`src/hot_reload.cc`:

```cc
#include "hot_reload.h"

#include <chrono>
#include <filesystem>

#include "configuration.h"
#include "dll_mappers/manual.h"
#include "dll_mappers/win32.h"
#include "logging.h"
#include "scope_guard.h"

#undef min

namespace dll_loader {

using namespace std::chrono_literals;
namespace fs = std::filesystem;

// Used only in the main thread
struct LoaderContext {
  const fs::path watched_dll_path;
  fs::file_time_type previous_write_time;
  std::chrono::time_point<std::chrono::system_clock> last_reload_time;
  IDllMapper::Ptr p_dll_mapper;
};

static DWORD WINAPI BackgroundThreadRoutine(LPVOID p_parameter);
static DWORD HotReloadServiceRoutine(ThreadSync* p_sync);
static bool ReloadDLL(LoaderContext* p_ctx);

bool HotReloadService::Initialize() {
  LOG("Entered '{}'", __FUNCTION__);
  h_thread_ = ::CreateThread(
      nullptr, 0,
      reinterpret_cast<LPTHREAD_START_ROUTINE>(BackgroundThreadRoutine),
      &thread_sync_, 0, nullptr);
  if (h_thread_ == nullptr) {
    return false;
  }

  LOG("Exiting '{}'", __FUNCTION__);
  return true;
}

void HotReloadService::Cleanup() {
  LOG("Entered '{}'", __FUNCTION__);

  TerminateChildThreadProperly();

  LOG("Exiting '{}'", __FUNCTION__);
}

void HotReloadService::TerminateChildThreadProperly() {
  if (h_thread_ == nullptr) {
    return;
  }

  // Wait for the background thread to finish its business
  thread_sync_.should_stop.store(true);
  thread_sync_.is_stopped.wait(false);

  // Ensure the thread does not execute any more code
  ::TerminateThread(h_thread_, 0);
  ::CloseHandle(h_thread_);
  h_thread_ = nullptr;
}

static DWORD WINAPI BackgroundThreadRoutine(LPVOID p_parameter) {
  LOG("Entered 'BackgroundThreadRoutine'");
  if (p_parameter == nullptr) {
    return 1;
  }
  auto* p_sync = reinterpret_cast<ThreadSync*>(p_parameter);

  const auto on_exit = sg::make_scope_guard([p_sync]() {
    p_sync->is_stopped.store(true);
    p_sync->is_stopped.notify_one();
  });
  try {
    return HotReloadServiceRoutine(p_sync);
  } catch ([[maybe_unused]] const std::exception& ex) {
    LOG("Unhandled exception in background thread: {}", ex.what());
    return 2;
  }
}

static DWORD HotReloadServiceRoutine(ThreadSync* p_sync) {
  LoaderConfiguration configuration{};
  if (!configuration.LoadFromFile("dll_loader.ini")) {
    LOG("Failed to load configuration");
    return 1;
  }

  std::error_code err{};
  LoaderContext ctx{
      .watched_dll_path = fs::absolute(configuration.dll_path_str),
      .previous_write_time = fs::file_time_type::min(),
      .p_dll_mapper = nullptr};
  if (configuration.use_manual_mapping) {
    ctx.p_dll_mapper = std::make_unique<mappers::ManualDllMapper>();
  } else {
    ctx.p_dll_mapper = std::make_unique<mappers::Win32DllMapper>();
  }

  if (!ReloadDLL(&ctx)) {
    LOG("Failed to load '{}'.", ctx.watched_dll_path.string());
    return 1;
  }
  const auto unload_on_exit =
      sg::make_scope_guard([p_sync, &configuration, &ctx]() {
        if (!configuration.use_manual_mapping && p_sync->should_stop.load()) {
          // Note: Cannot call `FreeLibrary` here if we were asked to stop since
          // it would mean loader lock's already been taken and we would
          // deadlock.
          return;
        }
        ctx.p_dll_mapper->UnloadAllDlls();
      });

  const auto parent_directory_path = ctx.watched_dll_path.parent_path();
  LOG("Watching '{}' for modifications", parent_directory_path.string());
  const HANDLE h_change = ::FindFirstChangeNotificationA(
      parent_directory_path.string().c_str(),  // directory to watch
      FALSE,                                   // do not watch subtree
      FILE_NOTIFY_CHANGE_LAST_WRITE);
  if (h_change == INVALID_HANDLE_VALUE) {
    return 1;
  }
  const auto close_on_exit = sg::make_scope_guard([h_change]() {
    if (h_change != INVALID_HANDLE_VALUE) {
      ::FindCloseChangeNotification(h_change);
    }
  });

  while (true) {
    constexpr DWORD kWaitTimeoutMs = 200;
    const auto wait_status = ::WaitForSingleObject(h_change, kWaitTimeoutMs);
    switch (wait_status) {
      case WAIT_TIMEOUT:
        // Exit if needed
        if (p_sync->should_stop.load()) {
          return 1;
        }
        break;
      case WAIT_OBJECT_0: {
        // Change notification received, something has changed in the directory
        // we're watching
        constexpr auto kUpdateCooldown = 5s;

        std::error_code err{};
        const auto dll_last_write_time =
            fs::last_write_time(ctx.watched_dll_path, err);
        const auto current_time = std::chrono::system_clock::now();
        // Check last write time and last reload time
        if (dll_last_write_time >= ctx.previous_write_time + kUpdateCooldown &&
            current_time >= ctx.last_reload_time + kUpdateCooldown) {
          if (!ReloadDLL(&ctx)) {
            return 1;
          }
          ctx.last_reload_time = current_time;
          ctx.previous_write_time = dll_last_write_time;
        }
        // Register to future notifications
        if (::FindNextChangeNotification(h_change) == FALSE) {
          LOG("FindNextChangeNotification failed. LastError=0x{:x}",
              ::GetLastError());
          return 1;
        }
      } break;
      default:
        // Error
        return 1;
    }
  }

  return 0;
}

static bool ReloadDLL(LoaderContext* p_ctx) {
  LOG("Entered '{}'", __FUNCTION__);
  if (p_ctx == nullptr) {
    return false;
  }

  // FIXME: Only works because we watch one DLL at a time
  if (!p_ctx->p_dll_mapper->UnloadAllDlls()) {
    return false;
  }

  return p_ctx->p_dll_mapper->LoadDll(p_ctx->watched_dll_path);
}

}  // namespace dll_loader
```

`src/hot_reload.h`:

```h
#pragma once

#include <windows.h>

#include <atomic>

namespace dll_loader {

// Shared between threads
struct ThreadSync {
  std::atomic_bool should_stop;
  std::atomic_bool is_stopped;
};

class HotReloadService {
 public:
  bool Initialize();
  void Cleanup();

 private:
  void TerminateChildThreadProperly();

 private:
  HANDLE h_thread_;
  ThreadSync thread_sync_;
};

}  // namespace dll_loader

```

`src/logging.h`:

```h
#pragma once

#ifdef _DEBUG
#include <windows.h>

#include <format>

#define LOG(FMT, ...)                                    \
  {                                                      \
    const auto msg = std::format(FMT "\n", __VA_ARGS__); \
    ::OutputDebugStringA(msg.c_str());                   \
  }
#else
#define LOG(FMT, ...)
#endif

```

`src/scope_guard.h`:

```h
/*
 *  Created on: 13/02/2018
 *      Author: ricab
 *
 * See README.md for documentation of this header's public interface.
 */

#ifndef SCOPE_GUARD_HPP_
#define SCOPE_GUARD_HPP_

#include <type_traits>
#include <utility>

#if __cplusplus >= 201703L && defined(SG_REQUIRE_NOEXCEPT_IN_CPP17)
#define SG_REQUIRE_NOEXCEPT
#endif

namespace sg
{
  namespace detail
  {
    /* --- Some custom type traits --- */

    // Type trait determining whether a type is callable with no arguments
    template<typename T, typename = void>
    struct is_noarg_callable_t
      : public std::false_type
    {}; // in general, false

    template<typename T>
    struct is_noarg_callable_t<T, decltype(std::declval<T&&>()())>
      : public std::true_type
    {}; // only true when call expression valid

    // Type trait determining whether a no-argument callable returns void
    template<typename T>
    struct returns_void_t
      : public std::is_same<void, decltype(std::declval<T&&>()())>
    {};

    /* Type trait determining whether a no-arg callable is nothrow invocable if
    required. This is where SG_REQUIRE_NOEXCEPT logic is encapsulated. */
    template<typename T>
    struct is_nothrow_invocable_if_required_t
      : public
#ifdef SG_REQUIRE_NOEXCEPT
          std::is_nothrow_invocable<T> /* Note: _r variants not enough to
                                          confirm void return: any return can be
                                          discarded so all returns are
                                          compatible with void */
#else
          std::true_type
#endif
    {};

    // logic AND of two or more type traits
    template<typename A, typename B, typename... C>
    struct and_t : public and_t<A, and_t<B, C...>>
    {}; // for more than two arguments

    template<typename A, typename B>
    struct and_t<A, B> : public std::conditional<A::value, B, A>::type
    {}; // for two arguments

    // Type trait determining whether a type is a proper scope_guard callback.
    template<typename T>
    struct is_proper_sg_callback_t
      : public and_t<is_noarg_callable_t<T>,
                     returns_void_t<T>,
                     is_nothrow_invocable_if_required_t<T>,
                     std::is_nothrow_destructible<T>>
    {};


    /* --- The actual scope_guard template --- */

    template<typename Callback,
             typename = typename std::enable_if<
               is_proper_sg_callback_t<Callback>::value>::type>
    class scope_guard;


    /* --- Now the friend maker --- */

    template<typename Callback>
    detail::scope_guard<Callback> make_scope_guard(Callback&& callback)
    noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
    we need this in the inner namespace due to MSVC bugs preventing
    sg::detail::scope_guard from befriending a sg::make_scope_guard
    template instance in the parent namespace (see https://is.gd/xFfFhE). */


    /* --- The template specialization that actually defines the class --- */

    template<typename Callback>
    class scope_guard<Callback> final
    {
    public:
      typedef Callback callback_type;

      scope_guard(scope_guard&& other)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);

      ~scope_guard() noexcept; // highlight noexcept dtor

      void dismiss() noexcept;

    public:
      scope_guard() = delete;
      scope_guard(const scope_guard&) = delete;
      scope_guard& operator=(const scope_guard&) = delete;
      scope_guard& operator=(scope_guard&&) = delete;

    private:
      explicit scope_guard(Callback&& callback)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
                                                      meant for friends only */

      friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&)
      noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value); /*
      only make_scope_guard can create scope_guards from scratch (i.e. non-move)
      */

    private:
      Callback m_callback;
      bool m_active;

    };

  } // namespace detail


  /* --- Now the single public maker function --- */

  using detail::make_scope_guard; // see comment on declaration above

} // namespace sg

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
  : m_callback(std::forward<Callback>(callback)) /* use () instead of {} because
    of DR 1467 (https://is.gd/WHmWuo), which still impacts older compilers
    (e.g. GCC 4.x and clang <=3.6, see https://godbolt.org/g/TE9tPJ and
    https://is.gd/Tsmh8G) */
  , m_active{true}
{}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::~scope_guard<Callback>() noexcept
{
  if(m_active)
    m_callback();
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
  : m_callback(std::forward<Callback>(other.m_callback)) // idem
  , m_active{std::move(other.m_active)}
{
  other.m_active = false;
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
inline void sg::detail::scope_guard<Callback>::dismiss() noexcept
{
  m_active = false;
}

////////////////////////////////////////////////////////////////////////////////
template<typename Callback>
inline auto sg::detail::make_scope_guard(Callback&& callback)
noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-> detail::scope_guard<Callback>
{
  return detail::scope_guard<Callback>{std::forward<Callback>(callback)};
}

#endif /* SCOPE_GUARD_HPP_ */

```

`src/test_host.cc`:

```cc
#include <windows.h>

#include <cstdio>

int main(int argc, char* argv[]) {
  const HMODULE h_library = ::LoadLibraryA("dll_loader.dll");
  if (h_library == nullptr) {
    return 1;
  }

  ::printf("Press any key to exit...\n");
  int _res = ::getc(stdin);

  ::FreeLibrary(h_library);
  return 0;
}
```