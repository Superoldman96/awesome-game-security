Project Path: arc_gmh5225_netview__ehkpsxv

Source Tree:

```txt
arc_gmh5225_netview__ehkpsxv
├── LICENSE
├── Makefile
├── banned.h
├── netview.cpp
├── netview.sln
├── netview.vcxproj
├── netview.vcxproj.filters
└── readme.creole

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2020, Rob Fuller
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Makefile`:

```
ifdef PROCESSOR_ARCHITECTURE
  OS=NT
else
  OS=unix
endif

#This would be for the MinGW running on the NT kernel 
#No need for the wine emulation.
ifeq ($(OS),NT)

# Windows MinGW using Cgywin.
CC			= g++.exe
LD	 		= ld.exe

#WIN_INCLUDES		+= -I"/usr/i686-pc-mingw32/sys-root/mingw/include"
#WIN_LIBPATH		+= -L"/usr/i686-pc-mingw32/sys-root/mingw/lib"\
#			   -L"/usr/i686-pc-mingw32/sys-root/mingw/bin/libstdc++-6.dll"
WIN_LIBS		+= -lgcc -lodbc32 -lwsock32 -lwinspool\
			-lwinmm -lshell32 -lcomctl32 -lctl3d32\
			-lodbc32 -ladvapi32 -lodbc32 -lopengl32\
			-lglu32 -lole32 -loleaut32 -luuid\
			-lnetapi32 -lws2_32 

WIN_LDFLAGS 		+= -s 
WIN_CFLAGS		+= -static -mwindows -O2 -Wall\
			-g -DWINVER=0x0501\
			-D__WIN95__ -D__GNUWIN32__ -DSTRICT\
			-DHAVE_W32API_H -D__WXMSW__ -D__WINDOWS__\
			-DUNICODE -D_UNICODE\

LDFLAGS			= $(WIN_LDFLAGS)
CFLAGS			= $(WIN_CFLAGS)
# LIBPATH			= $(WIN_LIBPATH)
LIBS			= $(WIN_LIBS)

#This is for the BT5R3 MinGW release.
else

ADDR2LINE		= /usr/bin/i586-mingw32msvc-addr2line
AR 			= /usr/bin/i586-mingw32msvc-ar
AS			= /usr/bin/i586-mingw32msvc-as
CC			= /usr/bin/i586-mingw32msvc-cc
CCXXFILT		= /usr/bin/i586-mingw32msvc-c++filt
CPP			= /usr/bin/i586-mingw32msvc-cpp
DLLTOOL			= /usr/bin/i586-mingw32msvc-dlltool
DLLWRAP	 		= /usr/bin/i586-mingw32msvc-dllwrap
GXX			= /usr/bin/i586-mingw32msvc-g++
GCC			= /usr/bin/i586-mingw32msvc-gcc
GCC442			= /usr/bin/i586-mingw32msvc-gcc-4.4.2
GCCDEBUG		= /usr/bin/i586-mingw32msvc-gccbug
GCOV			= /usr/bin/i586-mingw32msvc-gcov
GFORTRAN		= /usr/bin/i586-mingw32msvc-gfortran
GPROF			= /usr/bin/i586-mingw32msvc-gprof
LD			= /usr/bin/i586-mingw32msvc-ld
NM			= /usr/bin/i586-mingw32msvc-nm
OBJCOPY			= /usr/bin/i586-mingw32msvc-objcopy
OBJDUMP			= /usr/bin/i586-mingw32msvc-objdump
RANLIB			= /usr/bin/i586-mingw32msvc-ranlib
READELF			= /usr/bin/i586-mingw32msvc-readelf
SIZE			= /usr/bin/i586-mingw32msvc-size
STRINGS			= /usr/bin/i586-mingw32msvc-strings
STRIP			= /usr/bin/i586-mingw32msvc-strip
WINDMC			= /usr/bin/i586-mingw32msvc-windmc
WINDRES			= /usr/bin/i586-mingw32msvc-windres

#Mingw for BT5R3

MINGW_INCLUDES		+= -I"/usr/i586-mingw32msvc/include"
MINGW_LIBPATH		+= -L"/usr/i586-mingw32msvc/lib"
MINGW_LIBS		+= -lgcc -lodbc32 -lwsock32 -lwinspool -lwinmm -lshell32 -lcomctl32\
			-lctl3d32 -lodbc32 -ladvapi32 -lodbc32 -lopengl32 -lglu32 -lole32 -loleaut32\
			-luuid -lnetapi32 -lstdc++ -lws2_32

MINGW_LDFLAGS 		+= -s 
MINGW_CFLAGS		+= -O2 -Wall -g -I. $(MINGW_INCLUDES)\
			-D__MINGW32__ -DWINVER=0x0501 -D__WIN95__ -D__GNUWIN32__\
			-DSTRICT -DHAVE_W32API_H -D__WXMSW__\
			-D__WINDOWS__ -DUNICODE -D_UNICODE\

LDFLAGS			= $(MINGW_LDFLAGS)
CFLAGS			= $(MINGW_CFLAGS)
LIBPATH			= $(MINGW_LIBPATH)
LIBS			= $(MINGW_LIBS)

endif

#==========================================================================
#Set the values of the program and source here!
#==========================================================================

OBJ_DIR			= MinGW_obj

PROGRAM			= netview.exe

SOURCE			= netview.cpp

OBJECTS			= $(addprefix $(OBJ_DIR)/, $(notdir $(SOURCE:.cpp=.o)))

none: clean
	@echo "usage:"
	@echo "make all"


all: clean $(OBJ_DIR) $(PROGRAM)
	@echo "Started to create the $(PROGRAM)"

$(OBJ_DIR):
	mkdir $(OBJ_DIR)

$(PROGRAM): $(OBJECTS)
	$(CC) $(LDFLAGS) -municode -o $@ $^  $(LIBPATH) $(LIBS)

$(OBJ_DIR)/%.o: %.cpp
	$(CC) $(CFLAGS) -o $@ -c  $<
	@echo

clean:
	rm -f $(OBJECTS) $(PROGRAM)

```

`banned.h`:

```h
/***
* banned.h - list of Microsoft Security Development Lifecycle (SDL) banned APIs
*
* Purpose:
*       This include file contains a list of banned APIs which should not be used in new code and 
*       removed from legacy code over time.
*
* History
* 01-Jan-2006 - mikehow - Initial Version
* 22-Apr-2008 - mikehow	- Updated to SDL 4.1, commented out recommendations and added memcpy
* 26-Jan-2009 - mikehow - Updated to SDL 5.0, made the list sane, added SDL compliance levels
* 10-Feb-2009 - mikehow - Updated based on feedback from MS Office
* 12-May-2009 - jpardue - Added wmemcpy
* 08-Jul-2009 - mikehow - Fixed header #ifndef/#endif logic, made the SDL recommended compliance level name more obvious
* 05-Nov-2009 - mikehow	- Added vsnprintf (ANSI version of _vsnprintf)
* 01-Jan-2010 - mikehow - Added better strsafe integration, now the following works:
*							#include "strsafe.h"
*							#include "banned.h"
* 04-Jun-2010 - mikehow - Small "#if" bug fix
* 16-Jun-2011 - mikehow	- Added the two _CRT_SECURE_xxxxx macros
* 07-Jul-2011 - mikehow - Bugfix when using recommended banned functions and StrSafe. Locally surpressed C4005 warnings
*						   
*
***/

#ifndef _INC_BANNED
#	define _INC_BANNED

#	if defined(_MSC_VER)
#		pragma once

// Flip the 'auto-migrate' functionality in VC++
// Some functions, such as strcpy() are changed to safer functions by the compiler
// More info: http://blogs.msdn.com/b/sdl/archive/2010/02/16/vc-2010-and-memcpy.aspx
#ifndef _SDL_DONT_AUTO_FIX

#	pragma warning(push)
#	pragma warning(disable: 4005)

	// strcpy etc
#	define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES			(1)

	// memcpy etc
#	define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY	(1)

#	pragma warning(pop)

#endif

		// SDL 5.0 and later Requirements
#		if defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)

			// Only deprecate what's not already deprecated by StrSafe
#			pragma deprecated (_mbscpy, _mbccpy)
#			pragma deprecated (strcatA, strcatW, _mbscat, StrCatBuff, StrCatBuffA, StrCatBuffW, StrCatChainW, _tccat, _mbccat)
#			pragma deprecated (strncpy, wcsncpy, _tcsncpy, _mbsncpy, _mbsnbcpy, StrCpyN, StrCpyNA, StrCpyNW, StrNCpy, strcpynA, StrNCpyA, StrNCpyW, lstrcpyn, lstrcpynA, lstrcpynW)
#			pragma deprecated (strncat, wcsncat, _tcsncat, _mbsncat, _mbsnbcat, lstrncat, lstrcatnA, lstrcatnW, lstrcatn)
#			pragma deprecated (IsBadWritePtr, IsBadHugeWritePtr, IsBadReadPtr, IsBadHugeReadPtr, IsBadCodePtr, IsBadStringPtr)
#			pragma deprecated (memcpy, RtlCopyMemory, CopyMemory, wmemcpy)

#		else
			// StrSafe not loaded, so deprecate everything!
#			pragma deprecated (strcpy, strcpyA, strcpyW, wcscpy, _tcscpy, _mbscpy, StrCpy, StrCpyA, StrCpyW, lstrcpy, lstrcpyA, lstrcpyW, _tccpy, _mbccpy, _ftcscpy)
#			pragma deprecated (strcat, strcatA, strcatW, wcscat, _tcscat, _mbscat, StrCat, StrCatA, StrCatW, lstrcat, lstrcatA, lstrcatW, StrCatBuff, StrCatBuffA, StrCatBuffW, StrCatChainW, _tccat, _mbccat, _ftcscat)
#			pragma deprecated (sprintfW, sprintfA, wsprintf, wsprintfW, wsprintfA, sprintf, swprintf, _stprintf)
#			pragma deprecated (wvsprintf, wvsprintfA, wvsprintfW, vsprintf, _vstprintf, vswprintf)
#			pragma deprecated (strncpy, wcsncpy, _tcsncpy, _mbsncpy, _mbsnbcpy, StrCpyN, StrCpyNA, StrCpyNW, StrNCpy, strcpynA, StrNCpyA, StrNCpyW, lstrcpyn, lstrcpynA, lstrcpynW)
#			pragma deprecated (strncat, wcsncat, _tcsncat, _mbsncat, _mbsnbcat, StrCatN, StrCatNA, StrCatNW, StrNCat, StrNCatA, StrNCatW, lstrncat, lstrcatnA, lstrcatnW, lstrcatn)
#			pragma deprecated (gets, _getts, _gettws)
#			pragma deprecated (IsBadWritePtr, IsBadHugeWritePtr, IsBadReadPtr, IsBadHugeReadPtr, IsBadCodePtr, IsBadStringPtr)
#			pragma deprecated (memcpy, RtlCopyMemory, CopyMemory, wmemcpy)
#		endif //defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)

// SDL 5.0 and later Recommendations
#		if defined(_SDL_BANNED_RECOMMENDED)
#			if defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)
				// Only deprecate what's not already deprecated by StrSafe
#				pragma deprecated (wnsprintf, wnsprintfA, wnsprintfW)
#				pragma deprecated (vsnprintf, wvnsprintf, wvnsprintfA, wvnsprintfW)
#				pragma deprecated (strtok, _tcstok, wcstok, _mbstok)
#				pragma deprecated (makepath, _tmakepath,  _makepath, _wmakepath)
#				pragma deprecated (_splitpath, _tsplitpath, _wsplitpath)
#				pragma deprecated (scanf, wscanf, _tscanf, sscanf, swscanf, _stscanf, snscanf, snwscanf, _sntscanf)
#				pragma deprecated (_itoa, _itow, _i64toa, _i64tow, _ui64toa, _ui64tot, _ui64tow, _ultoa, _ultot, _ultow)
#				pragma deprecated (CharToOem, CharToOemA, CharToOemW, OemToChar, OemToCharA, OemToCharW, CharToOemBuffA, CharToOemBuffW)
#				pragma deprecated (alloca, _alloca)
#				pragma deprecated (strlen, wcslen, _mbslen, _mbstrlen, StrLen, lstrlen)
#				pragma deprecated (ChangeWindowMessageFilter)
#			else
				// StrSafe not loaded, so deprecate everything!
#				pragma deprecated (wnsprintf, wnsprintfA, wnsprintfW, _snwprintf, _snprintf, _sntprintf)
#				pragma deprecated (_vsnprintf, vsnprintf, _vsnwprintf, _vsntprintf, wvnsprintf, wvnsprintfA, wvnsprintfW)
#				pragma deprecated (strtok, _tcstok, wcstok, _mbstok)
#				pragma deprecated (makepath, _tmakepath,  _makepath, _wmakepath)
#				pragma deprecated (_splitpath, _tsplitpath, _wsplitpath)
#				pragma deprecated (scanf, wscanf, _tscanf, sscanf, swscanf, _stscanf, snscanf, snwscanf, _sntscanf)
#				pragma deprecated (_itoa, _itow, _i64toa, _i64tow, _ui64toa, _ui64tot, _ui64tow, _ultoa, _ultot, _ultow)
#				pragma deprecated (CharToOem, CharToOemA, CharToOemW, OemToChar, OemToCharA, OemToCharW, CharToOemBuffA, CharToOemBuffW)
#				pragma deprecated (alloca, _alloca)
#				pragma deprecated (strlen, wcslen, _mbslen, _mbstrlen, StrLen, lstrlen)
#				pragma deprecated (ChangeWindowMessageFilter)
#			endif // StrSafe
#		endif // SDL recommended

#	endif // _MSC_VER_

#endif  // _INC_BANNED 



```

`netview.cpp`:

```cpp
// netview.cpp : Defines the entry point for the console application.
//
/*
             _         _               
  _ __   ___| |___   _(_) _____      __
 | '_ \ / _ \ __\ \ / / |/ _ \ \ /\ / /
 | | | |  __/ |_ \ V /| |  __/\ V  V / 
 |_| |_|\___|\__| \_/ |_|\___| \_/\_/  
                        by mubix [at] hak5.org               
                        v1.1

						*/
/*
Kali 
/usr/bin/i586-mingw32msvc-g++ netview.cpp -D__MINGW32__ -DWINVER=0x0501 -DUNICODE -D_UNICODE -s -Wl,--subsystem,windows -Wall -g -I"/usr/i586-mingw32msvc/include" -I"/usr/amd64-mingw32msvc/include/sec_api" -L"/usr/i586-mingw32msvc/lib" -lws2_32 -lnetapi32 -ladvapi32 -lmingw32 -o netview.exe
*/

#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif
// C includes
#include <vector>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <cstdlib>
#include <ctime>
#include <algorithm>
					
// Windows includes 
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h> 
#include <lm.h>
#include "./banned.h"

#pragma warning(disable:4996)

using namespace std;

#ifdef __MINGW32__
// This is if __MINGW32__ is not placed as a -D flag for the complier.
// The compiler will default to _WIN32 options. 
#else

#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "advapi32.lib")
#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_DEPRECATE 1
#endif

void print_help();
void netview_enum(vector<wstring> &hosts, wchar_t *domain);
void net_enum(wchar_t *host, wchar_t *domain);
void ip_enum(wchar_t *host);
void group_enum(vector<wstring> &users, wchar_t *group);
void share_enum(wchar_t *host, bool bCheckShareAccess);
void session_enum(vector<wstring> &users, wchar_t *host);
void loggedon_enum(vector<wstring> &users, wchar_t *host);
bool CanAccessFolder( LPCTSTR folderName, DWORD genericAccessRights );

#ifdef __MINGW32__
//This option is to handle the Unicode mangling with the wmain error.
//By default wmain's entry point is not found this is a temporary fix.
//https://github.com/coderforlife/mingw-unicode-main
#include "mingw-unicode.c"
#endif
int wmain(int argc, wchar_t * argv[])
{
	FILE *file_of_hosts;
	FILE *file_exclude_hosts;
	FILE *outputfile;
	BOOL bReadFromFile = FALSE;
	BOOL bDomainspecified = FALSE;
	BOOL bCheckShareAccess = FALSE;
	BOOL bReadFromFileArg = FALSE;
	BOOL bDomainArg = FALSE;
	BOOL bOutputToFile = FALSE;
	wchar_t *domain = NULL;
	wchar_t *group = NULL;
	wchar_t *host = NULL;
	wchar_t *tempHost = NULL;
	int interval = 0;
	double jitter = 0;
	char *filename;
	char *outputfilename;
	char line[255];
	char tmphost[255];
	vector<wstring> hosts;
	vector<wstring> users;
	vector<wstring> excludeHosts;

	// Don't buffer anything!
	setbuf(stdout, NULL);

	if (argc == 1)
	{ 
		print_help();
		return 0;
	}

	// Parse cmdline arguments
	for (int nArg=0; nArg < argc; nArg++)
	{
		if (!_wcsicmp(argv[nArg], L"-h"))
		{
			print_help();
			exit(0);
		}
		if (!_wcsicmp(argv[nArg], L"-o"))
		{
			if ((nArg + 1) > (argc - 1) || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-i") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("[-] -o used without a file name specified\n");
				return 0;
			}
			else
			{
				const size_t newsize = 255;
				char nstring[newsize];

				#ifdef __MINGW32__
					wcstombs(nstring, argv[(nArg + 1)],newsize);
				#else	
					size_t origsize = wcslen(argv[(nArg + 1)]) + 1;				
					size_t convertedChars = 0;				
					wcstombs_s(&convertedChars, nstring, origsize, argv[(nArg + 1)], _TRUNCATE);				
				#endif

				outputfilename = nstring;

				if((outputfile=freopen(outputfilename, "w" ,stdout))==NULL) {
					printf("Cannot open %s for writing\n",outputfilename);
					exit(1);
				}
			}
		}
		if (!_wcsicmp(argv[nArg], L"-f"))
		{
			bReadFromFileArg = TRUE;
			// file flag initiated, need to check if the file is there
			if ((nArg + 1) > (argc - 1) || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-i") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("[-] -f used without a file name specified\n");
				return 0;
			}
			else
			{				
				const size_t newsize = 255;
				char nstring[newsize];
				
				#ifdef __MINGW32__
					wcstombs(nstring, argv[(nArg + 1)],newsize);
				#else	
					size_t origsize = wcslen(argv[(nArg + 1)]) + 1;				
					size_t convertedChars = 0;				
					wcstombs_s(&convertedChars, nstring, origsize, argv[(nArg + 1)], _TRUNCATE);				
				#endif

				filename = nstring;
				bReadFromFile = TRUE;
			}
		}

		// check for domain argument
		if (!_wcsicmp(argv[nArg], L"-d"))
		{
			// domain flag was used
			bDomainArg = TRUE;
			// domain flag specified
			if (((nArg + 1) > (argc - 1)) || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-i") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("\n[*] -d used without domain specified - using current domain\n");
			}
			else
			{
				bDomainspecified = TRUE;
				domain = argv[(nArg + 1)];
				printf("[+] Domain Specified: %ls\n", domain);
			}
		}

		// check for exclude file argument
		if (!_wcsicmp(argv[nArg], L"-e"))
		{
			if ((nArg + 1) > (argc - 1) || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-i") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("[-] -e used without a file name specified\n");
				return 0;
			}
			else
			{				
				const size_t newsize = 255;
				char nstring[newsize];
				
				#ifdef __MINGW32__
					wcstombs(nstring, argv[(nArg + 1)],newsize);
				#else	
					size_t origsize = wcslen(argv[(nArg + 1)]) + 1;				
					size_t convertedChars = 0;				
					wcstombs_s(&convertedChars, nstring, origsize, argv[(nArg + 1)], _TRUNCATE);				
				#endif

				file_exclude_hosts = fopen(nstring,"r");
				if (file_exclude_hosts == NULL)
				{
					printf("[-] Exclude file not found as specified by -e\n");
				}
				else
				{
					while (fgets(line, sizeof(line)-1,file_exclude_hosts))
					{
						sscanf(line, "%s\n", tmphost);
						const size_t newsize = 255;
						wchar_t wcstring[newsize];
				
						#ifdef __MINGW32__
							mbstowcs(wcstring,tmphost,newsize);
						#else				
							size_t origsize = strlen(tmphost) + 1;				
							size_t convertedChars = 0;				
							mbstowcs_s(&convertedChars, wcstring, origsize, tmphost, _TRUNCATE);
						#endif

						wprintf(L"host: %ls\n", wcstring);
						excludeHosts.push_back(wstring(wcstring));
					}
					fclose(file_exclude_hosts);
				}

			}
		}

		// check for the group argument
		if (!_wcsicmp(argv[nArg], L"-g"))
		{
			if (((nArg + 1) > (argc - 1)) || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-i") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("[*] -g used without group specified - using \"Domain Admins\"\n");
				group_enum(users, L"Domain Admins");
			}
			else
			{
				group = argv[(nArg + 1)];
				group_enum(users, group);
			}
		}

		// check if we want to check access to the found shares
		if (!_wcsicmp(argv[nArg], L"-c"))
		{
			bCheckShareAccess = TRUE;
		}

		// check for the interval argument
		if (!_wcsicmp(argv[nArg], L"-i"))
		{
			if (((nArg + 1) > (argc - 1)) || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-j"))
			{
				printf("[*] -i used without interval specified - ignoring\n");
			}
			else
			{
				interval = _wtoi(argv[(nArg + 1)]);
			}
		}

		// check for the jitter argument
		if (!_wcsicmp(argv[nArg], L"-j"))
		{
			if (((nArg + 1) > (argc - 1)) || !_wcsicmp(argv[(nArg + 1)], L"-f") || !_wcsicmp(argv[(nArg + 1)], L"-o") || !_wcsicmp(argv[(nArg + 1)], L"-e") || !_wcsicmp(argv[(nArg + 1)], L"-d") || !_wcsicmp(argv[(nArg + 1)], L"-g") || !_wcsicmp(argv[(nArg + 1)], L"-c") || !_wcsicmp(argv[(nArg + 1)], L"-i"))
			{
				printf("[*] -j used without jitter specified - ignoring\n");
			}
			else
			{
				jitter = _wtof(argv[(nArg + 1)]);
			}
		}
	}
	
	printf("\n[*] Using interval: %d\n", interval);
	printf("[*] Using jitter: %.2f\n\n", jitter);

	if (bDomainArg && bReadFromFileArg)
	{
		printf("[-] Domain and File specified, can't do both - exiting...\n\n");
		return 0;
	}

	// pull file into array if read from file done
	// pull domain via NetServerEnum into array if read from domain done
	if(bReadFromFileArg)
	{
		printf("Reading from the file\n");
		
		file_of_hosts = fopen(filename,"r");
		
		if (file_of_hosts == NULL)
		{
			printf("[-] File not found as specified by -f\n");
		}
		else
		{
			while (fgets(line, sizeof(line)-1,file_of_hosts))
			{
				sscanf(line, "%s\n", tmphost);
				const size_t newsize = 255;
				wchar_t wcstring[newsize];
				
				#ifdef __MINGW32__
					mbstowcs(wcstring,tmphost,newsize);
				#else				
					size_t origsize = strlen(tmphost) + 1;				
					size_t convertedChars = 0;				
					mbstowcs_s(&convertedChars, wcstring, origsize, tmphost, _TRUNCATE);
				#endif							
				
				hosts.push_back(wstring(wcstring));
			}
			fclose(file_of_hosts);
		}
	}

	if(bDomainArg)
	{
		netview_enum(hosts,domain);
	}
	
	printf("\n[+] Number of hosts: %d\n",hosts.size());

	for (vector<wstring>::iterator it = hosts.begin(); it != hosts.end(); ++it)
	{
		fflush(stdout);
		host = const_cast<wchar_t *>(it->c_str());
		BOOL excludeHost = FALSE;

		// check if the host is in the exclude list, ignoring case
		for (vector<wstring>::iterator it = excludeHosts.begin(); it != excludeHosts.end(); ++it){
			tempHost = const_cast<wchar_t *>(it->c_str());
			if (!_wcsnicmp(host, tempHost, wcslen(host))) {
				excludeHost = TRUE;
			}
		}

		// only enumerate the host if it wasn't in the exclude list
		if (!excludeHost){
			wprintf(L"\n\n[+] Host: %ws", host);
			//wcout << "\n\n[+] Host: " << host << endl;
			net_enum(host,domain);
			ip_enum(host);
			share_enum(host,bCheckShareAccess);
			session_enum(users, host);
			loggedon_enum(users, host);

			if (interval > 0.0){
				srand( time( NULL ) );
				int min = (int) (interval * (1-jitter));
				int max = (int) (interval * (1+jitter));
				int range = max - min + 1;
				int sleep_time = rand() % range + min;
				printf("\n[*] Sleeping: %d seconds", sleep_time);
				//wcout << "\n[*] Sleeping: " << sleep_time << " seconds" << endl;
				Sleep(sleep_time*1000);
			}
		}
	}

	if (bOutputToFile)
	{
		 fclose(outputfile);
	}
	return 0;
}

void print_help(){
	printf("\nNetview Help\n"
	"--------------------------------------------------------------------\n\n"
	"-h \t\t\t: Display this help menu\n"
	"-f filename.txt \t: Specifies a file to pull a list of hosts from\n"
	"-e filename.txt \t: Specifies a file of hostnames to exclude\n"
	"-o filename.txt \t: Out to file instead of STDOUT\n"
	"-d domain \t\t: Specifies a domain to pull a list of hosts from\n"
	"\t\t\t  uses current domain if none specified\n"
	"-g group \t\t: Specify a group name for user hunting\n"
	"\t\t\t  uses 'Domain Admins' if none specified\n"
	"-c\t\t\t: Check found shares for read access\n"
	"-i interval\t\t: Seconds to wait between enumerating hosts\n"
	"-j jitter\t\t: Percent jitter to apply to the interval (0.0-1.0)\n"
	);
	printf("\n");
}

void netview_enum(vector<wstring> &hosts, wchar_t *domain)
{
	NET_API_STATUS nStatus;
	LPWSTR pszServerName = NULL;
	DWORD dwLevel = 101;
	LPSERVER_INFO_101 pBuf = NULL;
	LPSERVER_INFO_101 pTmpBuf;
	DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
	DWORD dwEntriesRead = 0;
	DWORD dwTotalEntries = 0;
	DWORD dwServerType = SV_TYPE_SERVER;
	LPWSTR pszDomainName = domain;
	DWORD dwResumeHandle = 0;


	nStatus = NetServerEnum(pszServerName,
				dwLevel,
				(LPBYTE *) & pBuf,
				dwPrefMaxLen,
				&dwEntriesRead,
				&dwTotalEntries,
				dwServerType,
				pszDomainName,
				&dwResumeHandle);

	if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
	{
		if ((pTmpBuf = pBuf) != NULL)
		{
			for (unsigned int i = 0; i < dwEntriesRead; i++)
			{
				assert(pTmpBuf != NULL);
				if (pTmpBuf == NULL)
				{
					fprintf(stderr, "An access violation has occurred\n");
					break;
				}
				else
				{
					hosts.push_back(wstring(pTmpBuf->sv101_name));
	                pTmpBuf++;
				}
			}
		}
	}

	if (pBuf != NULL)
	{
		NetApiBufferFree(pBuf);
	}
}

void net_enum(wchar_t *host, wchar_t *domain)
{
	NET_API_STATUS nStatus;
	LPWSTR pszServerName = host;
	DWORD dwLevel = 101;
	LPSERVER_INFO_101 pBuf = NULL;
	LPSERVER_INFO_101 pTmpBuf;

	wprintf(L"\nEnumerating AD Info");
	//wcout << "\nEnumerating AD Info" << endl;

	nStatus = NetServerGetInfo(pszServerName,
								dwLevel,
								(LPBYTE *) & pBuf
								);

	if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
	{
		if ((pTmpBuf = pBuf) != NULL)
		{
			assert(pTmpBuf != NULL);
			if (pTmpBuf == NULL)
			{
				fprintf(stderr, "An access violation has occurred\n");
				return;
			}
			else
			{
				wprintf(L"[+] %ws - Comment - %s\n", host, pTmpBuf->sv101_comment);
				printf("[+] %s - OS Version - %d.%d\n", (char*)host, (int)pTmpBuf->sv101_version_major, (int)pTmpBuf->sv101_version_minor);
				if (pTmpBuf->sv101_type & SV_TYPE_DOMAIN_CTRL)
				{
					wprintf(L"[+] %ws - Domain Controller\n", host);
				}
				if (pTmpBuf->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)
				{
					wprintf(L"[+] %ws - Backup Domain Controller\n", host);
				}

				if (pTmpBuf->sv101_type & SV_TYPE_SQLSERVER)
				{
					wprintf(L"[+] %ws - MSSQL Server\n", host);
				}
			}
		}
	}
	if (pBuf != NULL)
	{
		NetApiBufferFree(pBuf);
	}
}

void ip_enum(wchar_t *host)
{

	WSADATA wsaData;
	int iResult;
	int iRetval;
	DWORD dwRetval;
	
	#ifdef __MINGW32__	
	struct addrinfo *result = NULL;
   	struct addrinfo *ptr = NULL;
    	struct addrinfo hints;
	#else
	// This struct call is used for the Visual Studio Compiler and
	// does not work with the MinGW Compiler's libs as of yet.
	ADDRINFOW *result = NULL;
	ADDRINFOW *ptr = NULL;
	ADDRINFOW hints;
	#endif

	LPSOCKADDR sockaddr_ip;
	wchar_t ipstringbuffer[46];
	DWORD ipbufferlength = 46;

	printf("\nEnumerating IP Info\n");
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0)
	{
		wprintf(L"WSAStartup failed: %d\n", iResult);
		return;
	}

	ZeroMemory( &hints, sizeof(hints) );
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;


	#ifdef __MINGW32__

	char tmphost[255];
	int len = 0;
	len = wcstombs(tmphost, host, sizeof(tmphost));
	dwRetval = getaddrinfo(tmphost, 0, &hints, &result);

	#else
	// The older veriosn of getaddrinfo is used that does not support Unicode.
	dwRetval = GetAddrInfoW(host, 0, &hints, &result);
	#endif
	
	if ( dwRetval != 0 )
	{
		wprintf(L"[-] %ls - IP(s) could not be enumerated\n", host);
		WSACleanup();
		return;
	}
	else
	{
		// parse each address
		for(ptr=result; ptr != NULL ;ptr=ptr->ai_next)
		{
			switch (ptr->ai_family) {
			case AF_INET:
				wprintf(L"[+] %ls - IPv4 Address - ");
				sockaddr_ip = (LPSOCKADDR) ptr->ai_addr;
				ipbufferlength = 46;
				iRetval = WSAAddressToString(sockaddr_ip, (DWORD) ptr->ai_addrlen, NULL, ipstringbuffer, &ipbufferlength);
				if (iRetval)
					wprintf(L"WSAAddressToString failed with %u\n", WSAGetLastError() );
				else
					wprintf(L"%ls\n", ipstringbuffer);
					break;
			case AF_INET6:
				wprintf(L"[+] %ws - IPv6 Address - ");
				sockaddr_ip = (LPSOCKADDR) ptr->ai_addr;
				ipbufferlength = 46;
				iRetval = WSAAddressToString(sockaddr_ip, (DWORD) ptr->ai_addrlen, NULL, ipstringbuffer, &ipbufferlength );
				if (iRetval)
					wprintf(L"WSAAddressToString failed with %u\n", WSAGetLastError() );
				else
					wprintf(L"%ws\n", ipstringbuffer);
					break;
			default:
				wprintf(L"Other %ld\n", ptr->ai_family);
				break;
			}
		}
		#ifdef __MINGW32__
		freeaddrinfo(result);
		#else
		// The older veriosn of freeaddrinfo is used that does not support Unicode.
		FreeAddrInfoW(result);
		#endif		

		WSACleanup();
	}
}

void group_enum(vector<wstring> &users, wchar_t *group)
{
		
		NET_API_STATUS res;

		// first, get the primary DC for this machine
		LPCWSTR lpDcName = NULL;
		res = NetGetDCName(NULL, NULL, (LPBYTE *) &lpDcName);
		if (res == NERR_Success){
			wprintf(L"\n[+] Primary DC: %ls\n", lpDcName);
		}
		else{
			// return if there was an error, since we won't be able
			// to retrieve any users
			wprintf(L"\n[-] Error: could not retrieve primary DC\n");
			return;
		}

		// double check to make sure we got a DC name
		if (!lpDcName){
			wprintf(L"[-] Error: could not retrieve primary DC\n");
			return;
		}

		wprintf(L"\nEnumerating members of domain group \"%ls\"\n", group);

		// query the DC for all users from the given group
		GROUP_USERS_INFO_0 *BufPtr, *p;
		DWORD er=0,tr=0,resume=0, t;
		res = NetGroupGetUsers(lpDcName,group,0,(LPBYTE *)&BufPtr,
								MAX_PREFERRED_LENGTH,&er,&tr,NULL);

		if(res == ERROR_SUCCESS || res == ERROR_MORE_DATA)
		{
			p=BufPtr;
			for(t=1;t<=er;t++)
			{
				wprintf(L"[+] \"%ls\" user: %ls\n", group, p->grui0_name);
				users.push_back(wstring(p->grui0_name));
				p++;
			}
		}
		else if (res == NERR_GroupNotFound){
			wprintf(L"[-] Error: group name not found\n");
		}
		else
		{ 
			wprintf(L"[-] Error %d\n", res);
		}

		if (BufPtr != NULL){
			NetApiBufferFree(BufPtr);
		}
}

void share_enum(wchar_t *host, bool bCheckShareAccess)
{
	PSHARE_INFO_1 BufPtr,p;
	NET_API_STATUS res;
	DWORD er=0,tr=0,resume=0, t;

	printf("\nEnumerating Share Info\n");
	do
	{
		res = NetShareEnum (host, 1, (LPBYTE *) &BufPtr, MAX_PREFERRED_LENGTH, &er, &tr, &resume);
					
		if(res == ERROR_SUCCESS || res == ERROR_MORE_DATA)
		{
			p=BufPtr;
			for(t=1;t<=er;t++)
			{
				wprintf(L"[+] %ls - Share : %-20s : %-30s\n", host, p->shi1_netname, p->shi1_remark);
				
				// skip IPC$, and see if we want to check access to this share
				if (_wcsicmp(p->shi1_netname, L"IPC$") && bCheckShareAccess){
					wchar_t path[255];
					swprintf(path, 255, L"\\\\%s\\%s", host, p->shi1_netname);

					if(CanAccessFolder(path, GENERIC_READ)){
						wprintf(L"[+] Read access to: %ls\n", path);
					}
					else{
						wprintf(L"[-] No access to:%ls\n", path);
					}
				}
				p++;
			}
			NetApiBufferFree(BufPtr);
		} 
		else
		{ 
			wprintf(L"[-] %ls - Share - Error: %ld\n", host, res);
		}  
	} while (res==ERROR_MORE_DATA);
}

void session_enum(vector<wstring> &users, wchar_t *host)
{
	LPSESSION_INFO_10 pBuf = NULL;
	LPSESSION_INFO_10 pTmpBuf = NULL;
	DWORD dwLevel = 10;
	DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
	DWORD dwEntriesRead = 0;
	DWORD dwTotalEntries = 0;
	DWORD dwResumeHandle = 0;
	DWORD i;
	DWORD dwTotalCount = 0;
	LPTSTR pszClientName = NULL;
	LPTSTR pszUserName = NULL;
	NET_API_STATUS nStatus;
	wchar_t *user = NULL;

	printf("\nEnumerating Session Info\n");

	do
	{
		nStatus = NetSessionEnum(host,
					pszClientName,
					pszUserName,
					dwLevel,
					(LPBYTE*)&pBuf,
					dwPrefMaxLen,
					&dwEntriesRead,
					&dwTotalEntries,
					&dwResumeHandle);

		if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
		{
			if ((pTmpBuf = pBuf) != NULL)
			{
				for (i = 0; (i < dwEntriesRead); i++)
				{
					assert(pTmpBuf != NULL);
					if (pTmpBuf == NULL)
					{
						fprintf(stderr, "An access violation has occurred\n");
						break;
					}

					wprintf(L"[+] %ws - Session - %s from %s - Active: %d - Idle: %d\n",
						host,
						pTmpBuf->sesi10_username,
						pTmpBuf->sesi10_cname,
						pTmpBuf->sesi10_time,
						pTmpBuf->sesi10_idle_time
						);

					// check if the user is in the target user list if one is specified
					for (vector<wstring>::iterator it = users.begin(); it != users.end(); ++it){
						user = const_cast<wchar_t *>(it->c_str());
						if (!_wcsicmp(user, (pTmpBuf->sesi10_username))) {
							wprintf(L"[+] %ws - Target user found - %s\n", host, pTmpBuf->sesi10_username);
						}
					}
					
					pTmpBuf++;
					dwTotalCount++;
				}
			}
		}
		else
		{
			wprintf(L"[-] %ls - Session - Error: %ld\n", host, nStatus);
		}

		if (pBuf != NULL)
		{
			NetApiBufferFree(pBuf);
			pBuf = NULL;
		}
	} while (nStatus == ERROR_MORE_DATA);
   
	if (pBuf != NULL)
	{
		NetApiBufferFree(pBuf);
	}
}

void loggedon_enum(vector<wstring> &users, wchar_t *host)
{
	LPWKSTA_USER_INFO_1 pBuf = NULL;
	LPWKSTA_USER_INFO_1 pTmpBuf;
	DWORD dwLevel = 1;
	DWORD dwEntriesRead = 0;
	DWORD dwTotalEntries = 0;
	DWORD dwResumeHandle = 0;
	DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
	DWORD z;
	DWORD dwTotalCount = 0;
	NET_API_STATUS nStatus;
	wchar_t *user = NULL;
	
	printf("\nEnumerating Logged-on Users\n");
	do
	{
		nStatus = NetWkstaUserEnum(host,
					dwLevel,
					(LPBYTE*)&pBuf,
					dwPrefMaxLen,
					&dwEntriesRead,
					&dwTotalEntries,
					&dwResumeHandle);

		if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
		{
			if ((pTmpBuf = pBuf) != NULL)
			{
				for (z = 0; (z < dwEntriesRead); z++)
				{
					assert(pTmpBuf != NULL);
					if (pTmpBuf == NULL)
					{
						fprintf(stderr, "An access violation has occurred\n");
						break;
					}
						   
					if (!wcschr((wchar_t*)(pTmpBuf)->wkui1_username, L'$'))
					{
						wprintf(L"[+] %ws - Logged-on - %s\\%s\n", host, pTmpBuf->wkui1_logon_domain, pTmpBuf->wkui1_username);

						// check if the user is in the target user list if one is specified
						for (vector<wstring>::iterator it = users.begin(); it != users.end(); ++it){
							user = const_cast<wchar_t *>(it->c_str());
							if (!_wcsicmp(user, (pTmpBuf->wkui1_username))) {
								wprintf(L"[+] %ws - Target user found - %s\\%s\n", host, pTmpBuf->wkui1_logon_domain, pTmpBuf->wkui1_username);
							}
						}

					}

					pTmpBuf++;
					dwTotalCount++;
				}
			}
			else
			{
				wprintf(L"[-] %ls - Logged-on - Error: %ld\n", host, nStatus);
			}
		}

	} while (nStatus == ERROR_MORE_DATA);

	if (pBuf != NULL)
	{
		NetApiBufferFree(pBuf);
		pBuf = NULL;
	}
}

// function shamelessly stolen from Aaron Ballman's code sample
// at http://blog.aaronballman.com/2011/08/how-to-check-access-rights/
bool CanAccessFolder( LPCTSTR folderName, DWORD genericAccessRights )
{
    bool bRet = false;
    DWORD length = 0;
    if (!::GetFileSecurity( folderName, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION 
            | DACL_SECURITY_INFORMATION, NULL, NULL, &length ) && 
            ERROR_INSUFFICIENT_BUFFER == ::GetLastError()) {
        PSECURITY_DESCRIPTOR security = static_cast< PSECURITY_DESCRIPTOR >( ::malloc( length ) );
        if (security && ::GetFileSecurity( folderName, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION, security, length, &length )) {
            HANDLE hToken = NULL;
            if (::OpenProcessToken( ::GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_QUERY | 
                    TOKEN_DUPLICATE | STANDARD_RIGHTS_READ, &hToken )) {
                HANDLE hImpersonatedToken = NULL;
                if (::DuplicateToken( hToken, SecurityImpersonation, &hImpersonatedToken )) {
                    GENERIC_MAPPING mapping = { 0xFFFFFFFF };
                    PRIVILEGE_SET privileges = { 0 };
                    DWORD grantedAccess = 0, privilegesLength = sizeof( privileges );
                    BOOL result = FALSE;
 
                    mapping.GenericRead = FILE_GENERIC_READ;
                    mapping.GenericWrite = FILE_GENERIC_WRITE;
                    mapping.GenericExecute = FILE_GENERIC_EXECUTE;
                    mapping.GenericAll = FILE_ALL_ACCESS;
 
                    ::MapGenericMask( &genericAccessRights, &mapping );
                    if (::AccessCheck( security, hImpersonatedToken, genericAccessRights, 
                            &mapping, &privileges, &privilegesLength, &grantedAccess, &result )) {
                        bRet = (result == TRUE);
                    }
                    ::CloseHandle( hImpersonatedToken );
                }
                ::CloseHandle( hToken );
            }
            ::free( security );
        }
    }
 
    return bRet;
}
```

`netview.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual C++ Express 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "netview", "netview.vcxproj", "{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}.Debug|Win32.ActiveCfg = Debug|Win32
		{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}.Debug|Win32.Build.0 = Debug|Win32
		{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}.Release|Win32.ActiveCfg = Release|Win32
		{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`netview.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{12080BA9-EB6F-4D2B-9A4D-9378DDDDBE1E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>netview</RootNamespace>
    <WindowsTargetPlatformVersion>6.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="netview.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="banned.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`netview.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="netview.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="banned.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`readme.creole`:

```creole
= netview

Netview is a enumeration tool. It uses (with the -d) the current domain or a
specified domain (with the -d domain) to enumerate hosts. You can also use
the -f if you wish to specify a file with a list of hosts instead. Any
hostnames you wish to exclude can be specified in a list with -e. If you 
want to query for a domain group and highlight where those users are
logged in from, specify the group with -g.

Info: http://web.archive.org/web/20130301022254/http://www.room362.com/blog/2012/10/8/compiling-and-release-of-netview.html

Compiled version: https://github.com/mubix/netview/releases

Once a list is gathered, netview check each for the following
+ IP addresses
+ Shares
+ Sessions (users connected to the machine from a remote source)
+ and Logged on users

All output can be redirected to a file with the '-o' argument. Access to
found shares can be checked with -c.

Additionally, a delay (in seconds) between host enumerations can be
specified with -i, and a percent jitter (0.0-1.0) to randomize the
interval can be specified with -j.


== Example output

=== no arguments
{{{
C:\>netview.exe

Netview Help
--------------------------------------------------------------------

-h                      : Display this help menu
-f filename.txt         : Specifies a file to pull a list of hosts from
-e filename.txt         : Specifies a file of hostnames to exclude
-o filename.txt         : Out to file instead of STDOUT
-d domain               : Specifies a domain to pull a list of hosts from
                          uses current domain if none specified
-g group                : Specify a group name for user hunting
                          uses 'Domain Admins' if none specified
-c                      : Check found shares for read access
-i interval             : Seconds to wait between enumerating hosts
-j jitter               : Percent jitter to apply to the interval (0.0-1.0)
}}}

=== -d / -d with domain / or -f with filename
{{{
C:\>netview.exe -d

[*] -d used without domain specifed - using current domain
[+] Number of hosts: 1

[+] Host: HOST1

Enumerating AD Info
[+] HOST1 - Comment -
[+] HOST1 - OS Version - 6.1
[+] HOST1 - MSSQL Server

Enumerating IP Info
[+] HOST1 - IPv6 Address - fe80::(removed from example)%10
[+] HOST1 - IPv6 Address - fe80::(removed from example)%15
[+] HOST1 - IPv6 Address - fe80::(removed from example)%12
[+] HOST1 - IPv4 Address - 172.16.10.50
[+] HOST1 - IPv4 Address - 192.168.56.1
[+] HOST1 - IPv6 Address - 2001:(removed from example)

Enumerating Share Info
[+] HOST1 - Share - ADMIN$              Remote Admin
[+] HOST1 - Share - C$                  Default share
[+] HOST1 - Share - Backups
[+] HOST1 - Share - Finance
[+] HOST1 - Share - IPC$                Remote IPC
[+] HOST1 - Share - print$              Printer Drivers
[+] HOST1 - Share - SharedPrinter       Kyocera 5112

Enumerating Session Info
[+] HOST1 - Session - MUBIX from \\172.16.10.207 - Active: 48 - Idle: 44

Enumerating Logged-on Users
[+] HOST1 - Logged-on - HOST1\mubix
[+] HOST1 - Logged-on - HOST1\mubix

}}}
 

```