Project Path: arc_gmh5225_CoD_Hacks_mao0vfyb

Source Tree:

```txt
arc_gmh5225_CoD_Hacks_mao0vfyb
├── Desk
│   ├── README.md
│   ├── detours
│   │   ├── detours.h
│   │   ├── detours.lib
│   │   └── detours.pdb
│   ├── main.cpp
│   ├── opengl.cpp
│   ├── opengl.h
│   └── screenshot.jpg
├── Esp
│   ├── Esp.asm
│   ├── README.md
│   └── screenshot.jpg
├── Internal-OpenGL-Wallhack
│   ├── Internal-OpenGL-Wallhack.asm
│   ├── README.md
│   └── screenshot.jpg
├── Internal-Wallhack
│   ├── Internal-Wallhack.asm
│   ├── README.md
│   └── screenshot.jpg
├── LICENSE
├── No-Recoil
│   ├── No-Recoil.Asm
│   └── README.md
├── OpenGL-CountMonitor
│   ├── README.md
│   └── main.cpp
├── OpenGl-Wallhack
│   ├── README.md
│   ├── main.cpp
│   ├── opengl.cpp
│   ├── opengl.h
│   └── screenshot.jpg
├── README.md
├── idkmybffCoD
│   ├── README.md
│   ├── main.cpp
│   ├── opengl.cpp
│   ├── opengl.h
│   └── screenshot.jpg
├── screenshot_chat.jpg
├── screenshot_entities.jpg
└── screenshot_player.jpg

```

`Desk/README.md`:

```md
Desk.dll is a multi-hack for Call of Duty 1. It features:

- 3 state wallhack (all entities, flashing player models, and off). (Numpad 1)
- 6 state chams (red, blue, green, pink/violet, black, and off). (Numpad 2)
- Behind wall detection (turn on flashing models wallhack and chams, solid colors will indicate model is visible).
- Night-mode. (Numpad 3)
- No fog. (Numpad 4)
- White-walls/no textures. (Numpad 5)

Undetected by PB from 2007/08/22 to ~2009.

Compiled with VS6, but should compile with any C++ compiler.

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2007/08/22 by attilathedud.

```

`Desk/detours/detours.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.5 (Build 46)
//
//  Copyright 1995-2001, Microsoft Corporation
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

//////////////////////////////////////////////////////////////////////////////
//
#ifdef IMAGEAPI // defined by IMAGEHLP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
                                       IN HANDLE hFile,
                                       IN PSTR ImageName,
                                       IN PSTR ModuleName,
                                       IN DWORD BaseOfDll,
                                       IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
                                          IN DWORD dwAddr,
                                          OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
                                           IN LPSTR Name,
                                           OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
                                   IN LPSTR pszDllPath,
                                   IN LPSTR pszSymbolPath);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                   hProcess;
    HMODULE                  hImageHlp;
    PF_ImagehlpApiVersionEx  pfImagehlpApiVersionEx;
    PF_SymInitialize         pfSymInitialize;
    PF_SymSetOptions         pfSymSetOptions;
    PF_SymGetOptions         pfSymGetOptions;
    PF_SymLoadModule         pfSymLoadModule;
    PF_SymGetModuleInfo      pfSymGetModuleInfo;
    PF_SymGetSymFromName     pfSymGetSymFromName;
    PF_BindImage             pfBindImage;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

//////////////////////////////////////////////////////////////////////////////
//
class CDetourEnableWriteOnCodePage
{
public:
    CDetourEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
    {
        m_pbCode = pbCode;
        m_cbCode = cbCode;
        m_dwOldPerm = 0;
        m_hProcess = GetCurrentProcess();

        if (m_pbCode && m_cbCode) {
            if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
                return;
            }
            if (!VirtualProtect(pbCode,
                                cbCode,
                                PAGE_EXECUTE_READWRITE,
                                &m_dwOldPerm)) {
                return;
            }
        }
    }

    ~CDetourEnableWriteOnCodePage()
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            DWORD dwTemp = 0;
            if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
                return;
            }
            if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
                return;
            }
        }
    }

    BOOL SetPermission(DWORD dwPerms)
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            m_dwOldPerm = dwPerms;
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsValid(VOID)
    {
        return m_pbCode && m_cbCode && m_dwOldPerm;
    }

private:
    HANDLE  m_hProcess;
    PBYTE   m_pbCode;
    LONG    m_cbCode;
    DWORD   m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
inline PBYTE DetourGenMovEax(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB8;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBB;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEcx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB9;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBA;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBE;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBF;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBD;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBC;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPush(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0x68;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPushad(PBYTE pbCode)
{
    *pbCode++ = 0x60;
    return pbCode;
}

inline PBYTE DetourGenPopad(PBYTE pbCode)
{
    *pbCode++ = 0x61;
    return pbCode;
}

inline PBYTE DetourGenJmp(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE9;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenCall(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE8;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenBreak(PBYTE pbCode)
{
    *pbCode++ = 0xcc;
    return pbCode;
}

inline PBYTE DetourGenRet(PBYTE pbCode)
{
    *pbCode++ = 0xc3;
    return pbCode;
}

inline PBYTE DetourGenNop(PBYTE pbCode)
{
    *pbCode++ = 0x90;
    return pbCode;
}
#endif DETOURS_INTERAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`Desk/main.cpp`:

```cpp
/*!
*	A multihack for CoD1 that features a wallhack, chams, behind-wall detection, night-mode, no fog, and 
*	white-walls. Undetected by PB from 2007/08/22 to ~2009.
*
*	Originally written 2007/08/22 by attilathedud.
*/

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <stdio.h>
#include "detours/detours.h"
#include "opengl.h"

FARPROC (WINAPI *ori_GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);

/*!
*	When CoD looks for the address of glTextCoordPointer and glDrawElements, send it our detoured
*	functions instead of the original ones. 
*/
FARPROC __stdcall det_GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
{
	if(HIWORD(lpProcName))
	{
		if(!strcmp(lpProcName, "GetProcAddress"))				return (FARPROC)det_GetProcAddress;
		else if(!strcmp(lpProcName, "glTexCoordPointer"))		return (FARPROC)det_glTexCoordPointer;
		else if(!strcmp(lpProcName, "glDrawElements"))			return (FARPROC)det_glDrawElements;
	}
	return ori_GetProcAddress(hModule, lpProcName);
}

/*!
*	On attach, detour GetProcAddress and store the original address in ori_GetProcAddress.
*/
bool WINAPI DllMain(HINSTANCE hInstance, DWORD cReason, LPVOID lpReserved)
{
	if(cReason == DLL_PROCESS_ATTACH)
	{
		DetourFunction((unsigned char*)GetProcAddress, (unsigned char*)det_GetProcAddress);
		__asm mov [ori_GetProcAddress],eax
	}

	else
		return false;

	return true;
}
```

`Desk/opengl.cpp`:

```cpp
#include <windows.h>
#include "opengl.h"

// Current state of enabled features
bool fog = 0;
BYTE wallhack = 0;
bool keydown = 0;
BYTE chams = 0;
bool night = 0;
bool whitewalls = 0;

/*!
*	We hook glTexCoordPointer to deal with hotkeys, no fog, night-mode, white-walls, and entity wallhack.
*
*	No fog: CoD uses GL_FOG to display fog. glDisable( GL_FOG ) disables the engine's fog.
*	Night-mode: By blending all textures together, textures are rendered as black on display.
*	White-walls: By setting the texture mode to GL_DECAL, texture colors are ignored and displayed as white.
*	Wallhack: Setting the depth function to GL_ALWAYS displays all textures on the same level.
*/
void APIENTRY det_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
	// Checking for hotkey presses.
	if(GetAsyncKeyState(VK_NUMPAD1) && keydown == 0)
	{
		wallhack++;
		if(wallhack > 2)		wallhack = 0;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD3) && keydown == 0)
	{
		if(fog == 0)       fog = 1;
		else			   fog = 0;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD2) && keydown == 0)
	{
		chams++;
		if(chams > 5)	   chams = 0;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD4) && keydown == 0)
	{
		if(night == 0)		night = 1;
		else				night = 0;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD5) && keydown == 0)
	{
		if(whitewalls == 0)		whitewalls = 1;
		else					whitewalls = 0;
		keydown = 1;
	}
	else if(!GetAsyncKeyState(VK_NUMPAD3) && (!GetAsyncKeyState(VK_NUMPAD2)) && (!GetAsyncKeyState(VK_NUMPAD1)) && (!GetAsyncKeyState(VK_NUMPAD4)) && (!GetAsyncKeyState(VK_NUMPAD5)))
		keydown = 0;

	// No fog
	if(fog)
		glDisable(GL_FOG);

	// Night-mode
	if(night)
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND); 
	else if(!night || !whitewalls)
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	// White-walls
	if(whitewalls)
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);

	// Wallhack
	if(wallhack == 1)
	{
		glDepthFunc(GL_LEQUAL);
		if(size == 2)
		{
			if(type == GL_FLOAT)
			{
				if(stride == 0)
				{
					glDepthFunc(GL_ALWAYS);
				}
			}
		}
	}
	glTexCoordPointer(size, type, stride, pointer);
}

/*!
*	We hook glDrawElements to deal with player wallhacks and chams.
*
*	Wallhack: We use a list of counts to detect player models. On detection, disable the depth
*	test and set the color to full to enable behind-wall detection.
*	Chams: On indices presence, set the color mode to our desired color.
*/
void APIENTRY det_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
	glDrawElements(mode, count, type, indices);

	// Wallhack and behind-wall detection
	if(wallhack == 2)
	{
		// The count list is originally from wurzil
	   if(count == 6702 || count == 4482 || count == 3078 || count == 1902 ||		//germans
       count == 8892 || count == 6672 || count == 2928 || count == 1908 ||
       count == 6186 || count == 3966 || count == 2562 || count == 1386 ||
       count == 3306 || count == 1182 || count == 8502 || count == 1572 ||
       count == 4914 || count == 2694 || count == 1110 || count == 642  ||
       count == 3306 || count == 1182 || count == 3078 || count == 6606 ||
       count == 4158 || count == 1578 || count == 4158 || count == 6378 ||
       count == 2754 || count == 1650 || count == 1080 || count == 8892 ||
       count == 8310 || count == 6090 || count == 2562 || count == 2928 ||
       count == 5298 || count == 1644 || count == 510  || count == 1080 ||
       count == 8310 || count == 6090 || count == 2562 || count == 1458 ||
       count == 7932 || count == 5712 || count == 2184 || count == 6606 ||
       count == 3078 || count == 1974 || count == 6282 || count == 1650 ||
       count == 3588 || count == 1644 || count == 1008 || count == 3114 ||
       count == 990  || count == 1572 || count == 4722 || count == 2502 ||
       count == 918  || count == 450  || count == 2790 || count == 570  ||
       count == 8700 || count == 6480 || count == 2736 || count == 1716 ||           //russians
	   count == 8352 || count == 6132 || count == 2310 || count == 522  ||
       count == 8340 || count == 6120 || count == 1986 || count == 972  ||
       count == 3996 || count == 1458 || count == 888  || count == 678  ||           //brits
	   count == 5268 || count == 1590 || count == 486  || count == 5100 ||
       count == 1572 || count == 7320 || count == 5100 || count == 1572 ||
       count == 522  || count == 7488 || count == 5268 || count == 1590 || 
       count == 486  || count == 7062 || count == 4842 || count == 432  ||			 //americans
	   count == 516  || count == 2640 || count == 852  || count == 426  ||
       count == 2820 || count == 1032 || count == 606  || count == 426  ||
       count == 6642 || count == 4422 || count == 2028 || count == 1482 ||
       count == 6552 || count == 4332 || count == 1938 || count == 1392 ||
       count == 2442 || count == 852  || count == 6498 || count == 3594 ||
       count == 5412 || count == 3192 || count == 798  || count == 3030 ||
       count == 1440 || count == 1014 || count == 3690 || count == 3504 ||
       count == 1716 || count == 1290 || count == 6696 || count == 4476 ||
       count == 2082 || count == 1536 || count == 1296 || count == 708  ||
       count == 3006 || count == 1218 || count == 792  || count == 1884 ||
       count == 1338 || count == 1296 || count == 708  || count == 1098 ||
       count == 510  || count == 84   || count == 720  || count == 3138 ||
       count == 1350 || count == 924  || count == 3708 || count == 1110 ||
       count == 606  || count == 684  || count == 4074 || count == 1476 ||
       count == 972  || count == 606)
		{
		       if(count == 810  || count == 576  || count == 2682 || count == 2220 ||	//not players
			   count == 462  || count == 432  || count == 2124 || count == 1272 ||
			   count == 588  || count == 318  || count == 324  || count == 114  ||
			   count == 420  || count == 270  || count == 690  || count == 450  ||
			   count == 606  || count == 180  || count == 210  || count == 1380 ||
			   count == 348  || count == 336  || count == 366  || count == 216  ||
			   count == 354  || count == 966  || count == 168  || count == 234  ||
			   count == 560  || count == 948  || count == 7824 || count == 132  ||
			   count == 138  || count == 144  || count == 378  || count == 960  ||
			   count == 1104 || count == 360  || count == 1656 || count == 4134 ||
			   count == 4134 || count == 4134 || count == 3672 || count == 414  ||
			   count == 384  || count == 150  || count == 372  || count == 3672 ||
			   count == 4134 || count == 2109 || count == 5757)
			   {
				   glEnable(GL_DEPTH_TEST);
			   }

			   if(indices == NULL || mode == GL_QUADS)
				   glEnable(GL_DEPTH_TEST);

				glDisable(GL_DEPTH_TEST);
				glEnable(GL_COLOR_MATERIAL);
				glColor3f((float)(rand()%10), (float)(rand()%10), (float)(rand()%10));
				glDrawElements(mode, count, type, indices);
				glEnable(GL_DEPTH_TEST);
				glColor3f(1,1,1);
				glDisable(GL_COLOR_MATERIAL);

		}

	}

	// Chams
	if(chams > 0)
	{
		if(indices == NULL || mode == GL_QUADS)
		{
			glDisable(GL_COLOR_MATERIAL);
		}
		else
		{
			glEnable(GL_COLOR_MATERIAL);
			switch(chams)
			{
			case 1: glColor3f(.7f,.1f,.1f); break;
			case 2: glColor3f(.2f,.7f,.2f); break;
			case 3: glColor3f(.2f,.2f,.7f); break;
			case 4: glColor3f(.7f,.1f,.4f);	break;
			case 5: glColor3f(0,0,0);		break;
			}
			glDrawElements(mode, count, type, indices);
			glColor3f(1, 1, 1);
			glDisable(GL_COLOR_MATERIAL);
		}
	}
}

```

`Desk/opengl.h`:

```h
#pragma comment(lib, "opengl32.lib")
#include <gl/gl.h>

void APIENTRY det_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void APIENTRY det_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
void APIENTRY det_glCullFace(GLenum mode);

```

`Esp/Esp.asm`:

```asm
; An internal ESP that works by hooking the game loop responsible for calling world-to-screen
; and loads a custom vm_main function that prints an "X" over the current location before rendering
; the entity.
;
; Originally written 2010/03/21 by attilathedud.

; System descriptors
.386
.model flat,stdcall
option casemap:none

VirtualAlloc proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualProtect proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualFree proto stdcall :DWORD, :DWORD, :DWORD

includelib \masm32\lib\kernel32.lib

.code
	main:
		jmp @F
			ori_hook dd 4688efh
			ori_vmmain dd 30021650h
			eng_textout dd 4e3f00h

			; White in CoD engine
			colour dd 3f800000h,0,0,3f800000h
			text db "X",0
		@@:
		; Save the current state of the stack.
		push ebp
		mov ebp,esp

		; Ensure our dll was loaded validily.
		mov eax,dword ptr ss:[ebp+0ch]
		cmp eax,1
		jnz @returnf

		; Allocate memory for the old protection type.
		; Store this location in ebx.
		push eax
		push 40h
		push 1000h
		push 4h
		push 0
		call VirtualAlloc 
		mov ebx,eax

		; Unprotect the memory at 4688e6h-4688ebh
		push ebx
		push 40h
		push 8h
		push 4688e6h
		call VirtualProtect 

		; Create a codecave in the rendering routine that will jump to our hook function.
		; e9h is the opcode to jump, with the address of the jump being calculated by subtracting
		; the address of the function to jump to from our current location.
		mov byte ptr ds:[4688e6h],0e9h
		lea ecx,@hook
		sub ecx,4688ebh
		mov dword ptr ds:[4688e7h],ecx

		; Since our patched instruction is 8h bytes, loop through and nop out the remaining bytes.
		mov ecx,4688ebh
		@nop:
			mov byte ptr ds:[ecx],90h
			inc ecx
			cmp ecx,4688eeh
			jl @nop

		; Reprotect the memory we just wrote.
		push 0
		push dword ptr ds:[ebx]
		push 8h
		push 4688e6h
		call VirtualProtect 

		; Free the memory we allocated for our protection type.
		push 4000h
		push 4h
		push ebx
		call VirtualFree 

		; Restore eax and the stack.
		pop eax
		@returnf:
			leave
			retn 0ch
			
		; Hook in the world-to-screen function. At this point, eax holds the calling function,
		; so we compare eax against the address for vm_main. If vm_main is the caller, load our
		; custom function into eax for execution.
		@hook:
			pushfd
			cmp eax,30021650h
			jnz short @ncgame
			lea eax,@vm_main
			@ncgame:
				; The original instructions.
				popfd
				test eax,eax
				mov edx,dword ptr ss:[esp+164h]
				jmp ori_hook
			
		; Our custom vm_main. At this point, ebp+8h holds the player structure to be rendered
		; along with x/y coordinates in world. By loading this into the call for textout, our
		; "X" will be rendered on top of the player.
		@vm_main:
			; Save the base pointer and load the stack pointer into it.
			push ebp
			mov ebp,esp

			; Call the original vm_main to take care of rendering the player.
			push dword ptr ss:[ebp+38h]
			push dword ptr ss:[ebp+34h]
			push dword ptr ss:[ebp+30h]
			push dword ptr ss:[ebp+2ch]
			push dword ptr ss:[ebp+28h]
			push dword ptr ss:[ebp+24h]
			push dword ptr ss:[ebp+20h]
			push dword ptr ss:[ebp+1ch]
			push dword ptr ss:[ebp+18h]
			push dword ptr ss:[ebp+14h]
			push dword ptr ss:[ebp+10h]
			push dword ptr ss:[ebp+0ch]
			push dword ptr ss:[ebp+8h]
			call dword ptr ds:[ori_vmmain]
			add esp,34h

			; Save eax so we don't corrupt it.
			push eax

			; Move the player struct into eax and then compare it to an active player.
			mov eax,dword ptr ss:[ebp+8h]
			cmp eax,4h
			jnz short @nactive

			; eng_textout( unknown, unknown, 0, unknown, color_3f, text, unknown, 0, 0)
			; eax holds a reference to the player struct.
			push 0
			push 0
			push 40e00000h
			lea eax,text
			push eax
			lea eax,colour
			push eax
			push 3f800000h
			push 0
			push 42c80000h
			push 42c80000h
			call dword ptr ds:[eng_textout]
			add esp,24h
			
			; Restore eax and the stack.
			@nactive:
				pop eax
				pop ebp
				retn
			
end main
```

`Esp/README.md`:

```md
An internal ESP that works by hooking the game loop responsible for calling world-to-screen and loads a custom vm_main function that prints an "X" over the current location before rendering the entity.

The hack was written in mASM and needs to be linked as a dll. To do this:
```
\masm32\bin\ml /c /coff Esp.asm
\masm32\bin\Link /SUBSYSTEM:WINDOWS /DLL Esp.obj
```

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2010/03/21 by attilathedud.

```

`Internal-OpenGL-Wallhack/Internal-OpenGL-Wallhack.asm`:

```asm
; A OpenGL wallhack that works via hooking CoD's internal call to glDrawElements while displaying players
; and modifies the call to disable depth testing.
;
; Originally written 2008/09/24 by attilathedud.

; System descriptors.
.386
.model flat,stdcall
option casemap:none

VirtualAlloc proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualProtect proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualFree proto stdcall :DWORD, :DWORD, :DWORD

glDepthFunc proto stdcall :DWORD
glDrawElements proto stdcall :DWORD, :DWORD, :DWORD, :DWORD

includelib \masm32\lib\opengl32.lib
includelib \masm32\lib\kernel32.lib
	
.code
	main:
		; Save the current state of the stack.
		push ebp
		mov ebp,esp

		; Ensure our dll was loaded validily.
		mov eax,dword ptr ss:[ebp+0ch]
		cmp eax,1
		jnz @returnf

		; Allocate memory for the old protection type.
		; Store this location in ebx.
		push eax
		push 40h
		push 1000h
		push 4h
		push 0
		call VirtualAlloc 
		mov ebx,eax

		; Unprotect the memory at 518d5ch-518d6ch
		push ebx
		push 40h
		push 10h
		push 518d5ch
		call VirtualProtect

		; Create a codecave in the draw_elements routine that will call to our hook function.
		; e8h is the opcode to call, with the address of the jump being calculated by subtracting
		; the address of the function to jump to from our current location.
		mov byte ptr ds:[518d5ch],0e8h
		lea ecx,@wallhack
		sub ecx,518d61h
		mov dword ptr ds:[518d5dh],ecx

		; Since we are replacing 10h bytes with 5h, we need to nop out the rest of the instructions.
		mov ecx,518d61h
		@nop:
			mov byte ptr ds:[ecx],90h
			inc ecx
			cmp ecx,518d72h
			jl @nop

		; Reprotect the memory we just wrote.
		push 0
		push dword ptr ds:[ebx]
		push 10h
		push 518d5ch
		call VirtualProtect 

		; Free the memory we allocated for our protection type.
		push 4000h
		push 4h
		push ebx
		call VirtualFree 

		; Restore eax and the stack
		pop eax
		@returnf:
			leave
			retn 0ch

		; Our wallhack works by calling glDepthFunc(GL_ALWAYS), then the original glDrawElements call,
		; and then resetting everything by calling glDepthFunc(GL_LEQUAL) so that only entities are drawn
		; without respect to depth.
		@wallhack:
			; Save all the registers and set depth to GL_ALWAYS
			pushad
			push 0207h
			call glDepthFunc
			popad

			; Original instructions
			push ecx
			push 1403h
			push eax
			inc ebp
			push 4
			mov dword ptr ds:[199a2b8h],ebp
			call glDrawElements 

			; Save all the registers and set depth to GL_LEQUAL
			pushad
			push 0203h
			call glDepthFunc
			popad
			retn
			
	end main
```

`Internal-OpenGL-Wallhack/README.md`:

```md
A OpenGL wallhack that works via hooking CoD's internal call to glDrawElements while displaying players and modifies the call to disable depth testing.

The hack was written in mASM and needs to be linked as a dll. To do this:
```
\masm32\bin\ml /c /coff Internal-OpenGL-Wallhack.asm
\masm32\bin\Link /SUBSYSTEM:WINDOWS /DLL Internal-OpenGL-Wallhack.obj
```

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2008/09/24 by attilathedud.

```

`Internal-Wallhack/Internal-Wallhack.asm`:

```asm
; An internal wallhack that hooks CoD's syscall function and adjusts the render flag of entities
; that pass through for rendering.
;
; Originally written 2008/12/20 by attilathedud.

; System descriptors.
.386
.model flat,stdcall
option casemap:none

VirtualAlloc proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualProtect proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualFree proto stdcall :DWORD, :DWORD, :DWORD

includelib \masm32\lib\kernel32.lib
	
.code
	main:
		jmp @F
			ori_syscall dd 4654c6h
		@@:
		; Save the current state of the stack.
		push ebp
		mov ebp,esp

		; Ensure our dll was loaded validily.
		mov eax,dword ptr ss:[ebp+0ch]
		cmp eax,1
		jnz @returnf

		; Allocate memory for the old protection type.
		; Store this location in ebx.
		push eax
		push 40h
		push 1000h
		push 4h
		push 0
		call VirtualAlloc 
		mov ebx,eax

		; Unprotect the memory at 4654c0h-4654c5h
		push ebx
		push 40h
		push 5h
		push 4654c0h
		call VirtualProtect

		; Create a codecave in the syscall routine that will jump to our hook function.
		; e9h is the opcode to jump, with the address of the jump being calculated by subtracting
		; the address of the function to jump to from our current location.
		mov byte ptr ds:[4654c0h],0e9h
		lea ecx,@cg_syscall
		sub ecx,4654c5h
		mov dword ptr ds:[4654c1h],ecx

		; Since our patched instruction is 6 bytes, nop out the remaining byte.
		mov byte ptr ds:[4654c5h],90h

		; Reprotect the memory we just wrote.
		push 0
		push dword ptr ds:[ebx]
		push 5h
		push 4654c0h
		call VirtualProtect 

		; Free the memory we allocated for our protection type.
		push 4000h
		push 4h
		push ebx
		call VirtualFree 

		; Restore eax and the stack.
		pop eax
		@returnf:
			leave
			retn 0ch
			
		; The syscall function in Quake3 engines is used to handle a variety of system calls,
		; including rendering entities (3dh). 
		@cg_syscall:
			; Save the base pointer and move the stack pointer into it.
			push ebp
			mov ebp,esp

			; Compare the second parameter to the instruction for rendering entities.
			mov eax,dword ptr ss:[esp+8h]
			cmp eax,3dh
			jnz @ori

			; If the current ref structure is our player, skip this to avoid a crash.
			mov eax,dword ptr ss:[esp+0ch]
			cmp eax,249f960h
			jz @ori

			; At this point, eax holds arg[ 0 ], which is a *refEntity_t.
			; eax+4h is r->renderfx.
			mov ebx,dword ptr ds:[eax+4h]

			; r->renderfx |= 8h, which sets the player to display through all.
			or ebx,8h

			; Set r->renderfx to the new renderer type.
			mov dword ptr ds:[eax+4],ebx

			; The original instruction and jump back.
			@ori:
				pop ebp
				mov ecx,dword ptr ds:[1460268h]
				jmp ori_syscall
				retn
			
	end main
```

`Internal-Wallhack/README.md`:

```md
An internal wallhack that hooks CoD's syscall function and adjusts the render flag of entities that pass through for rendering.

The hack was written in mASM and needs to be linked as a dll. To do this:
```
\masm32\bin\ml /c /coff Internal-Wallhack.asm
\masm32\bin\Link /SUBSYSTEM:WINDOWS /DLL Internal-Wallhack.obj
```

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2008/09/24 by attilathedud.

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`No-Recoil/No-Recoil.Asm`:

```Asm
; A no-recoil hack for CoD single-player that works by removing the instructions for aim being punched up
; while shooting.
;
; Originally written 2008/09/20 by attilathedud.

; System descriptors
.386
.model flat,stdcall
option casemap:none

VirtualAlloc proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualProtect proto stdcall :DWORD, :DWORD, :DWORD, :DWORD
VirtualFree proto stdcall :DWORD, :DWORD, :DWORD

includelib \masm32\lib\kernel32.lib

.code
	main:
		; Save the current state of the stack.
		push ebp
		mov ebp,esp

		; Ensure our dll was loaded validily.
		mov eax,dword ptr ss:[ebp+0ch]
		cmp eax,1
		jnz @returnf

		; Allocate memory for the old protection type.
		; Store this location in ebx.
		push eax
		push 40h
		push 1000h
		push 4h
		push 0
		call VirtualAlloc 
		mov ebx,eax

		; Unprotect the memory at 3003a313h-3003a318h
		push ebx
		push 40h
		push 5h
		push 3003a313h
		call VirtualProtect 

		; Move 3003a313h into ecx and then iterate until 3003a318h, noping every instruction
		mov ecx,3003a313h
		@nop:
			mov byte ptr ds:[ecx],90h
			inc ecx
			cmp ecx,3003a317h
			jl @nop

		; Reprotect the memory we just wrote.
		push 0
		push dword ptr ds:[ebx]
		push 5h
		push 3003a313h
		call VirtualProtect 

		; Free the memory we allocated for our protection type.
		push 4000h
		push 4h
		push ebx
		call VirtualFree 

		; Restore eax and the stack
		pop eax
		@returnf:
			leave
			retn 0ch
	end main
```

`No-Recoil/README.md`:

```md
A no-recoil hack for CoD single-player that works by removing the instructions for aim being punched up while shooting.

The hack was written in mASM and needs to be linked as a dll. To do this:
```
\masm32\bin\ml /c /coff No-Recoil.asm
\masm32\bin\Link /SUBSYSTEM:WINDOWS /DLL No-Recoil.obj
```

Originally written 2008/09/20 by attilathedud.

```

`OpenGL-CountMonitor/README.md`:

```md
A utility to log the counts of displayed entities to help isolate specific counts of player models.

Compiled with VS6, but should compile with any C++ compiler.

Originally written 2017/07/03 by attilathedud.
```

`OpenGL-CountMonitor/main.cpp`:

```cpp
/*!
*   A utility to log the counts of displayed entities to help isolate specific counts of player models.
*
*   Originally written 2017/07/03 by attilathedud.
*/
#include <windows.h>
#pragma comment(lib,"opengl32.lib")
#include <gl/gl.h>
#include <stdio.h>
#include <detours.h>

FILE *countfile;
char path[256]; 

GLsizei prevCount[620] = {0};	
bool countEqual = 0; 
int currentCounts = 0;

void __stdcall att_glDrawElements(GLenum mode,  GLsizei count,  GLenum type,  const GLvoid *indices);

// Create a file to log our counts and then hook glDrawElements.
bool __stdcall DllMain(HANDLE hInstance, DWORD reason, LPVOID lpReserved)
{
	if(reason == DLL_PROCESS_ATTACH)
	{
		GetModuleFileName(0, path, sizeof(path));
		for(int i = strlen(path); path[i] != '\\' && i; i--)
			path[i] = 0;
		strcat(path, "COUNTS.TXT");
		countfile = fopen(path, "w");
		DetourFunction((unsigned char*)glDrawElements, (unsigned char*)att_glDrawElements);
		__asm mov [glDrawElements],eax
	}
	else if(reason == DLL_PROCESS_DETACH)
	{
		DetourRemove((unsigned char*)glDrawElements, (unsigned char*)att_glDrawElements);
		fclose(countfile);
	}
	else
		return 0;

	return 1;
}

// Our hook checks that we are drawing a dynamic entity and then logs the amount of indices rendered.
void __stdcall att_glDrawElements(GLenum mode,  GLsizei count,  GLenum type,  const GLvoid *indices)
{
	if(mode == GL_TRIANGLES && indices != NULL && count > 50)
	{
        countEqual = 0;
        
		for(int i = 0; i < currentCounts; i++)
		{
			if(prevCount[i] == count)
				countEqual = 1;
        }
        
		if(!countEqual)
		{
			fprintf(countfile, "%d, ", count);
			prevCount[++currentCounts] = count;
		}
	}

	glDrawElements(mode, count, type, indices);
}
		

```

`OpenGl-Wallhack/README.md`:

```md
A wallhack that uses the glTexCoordPointer method to achieve great results without logging counts.

Undetected by PB from 2007/12/23 to ~2008/02.

Compiled with VS6, but should compile with any C++ compiler.

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2007/12/23 by attilathedud.

```

`OpenGl-Wallhack/main.cpp`:

```cpp
/*!
*	A wallhack that uses the glTexCoordPointer method to achieve great results without logging counts.
*
*	Originally written 2007/12/23 by attilathedud.
*/
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <detours.h>
#include "opengl.h"

// On Dll attached, detour glTexCoordPointer to our custom function and store the original pointer.
void attach_Hook()
{
	DetourFunction((unsigned char*)glTexCoordPointer, (unsigned char*)att_glTexCoordPointer);
	__asm{ mov [glTexCoordPointer],eax }
}

// On Dll detached, remove the detour.
inline void detach_Hook()
{
	DetourRemove((unsigned char*)glTexCoordPointer, (unsigned char*)att_glTexCoordPointer);
}

bool APIENTRY DllMain(HINSTANCE hInstance, DWORD reason, LPVOID lpReserved)
{
	if(reason == DLL_PROCESS_ATTACH)
	{
		// While we are in the process of attaching our hook, make sure no processes are 
		// attempting to access external references to the old endpoint.
		DisableThreadLibraryCalls((HINSTANCE)hInstance);
		attach_Hook();
	}	
	else if(reason == DLL_PROCESS_DETACH)
		detach_Hook();
	else
	{
		MessageBox(0, "Could not attach", "dedicus", 0);
		return false;
	}

	return true;
}
```

`OpenGl-Wallhack/opengl.cpp`:

```cpp
#include <windows.h>
#include "opengl.h"

bool wallhack;
bool keydown = 0;

/*!
*	If we are drawing an entity, size = 2, type = GL_FLOAT, and stride = 0. All other cases we are
*	drawing a static object.
*/
void APIENTRY att_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{

	// Allow us to toggle with Numpad 1.
	if(GetAsyncKeyState(VK_NUMPAD1) && keydown == 0)
	{
		wallhack = !wallhack;
		keydown = 1;
	}

	else if(!GetAsyncKeyState(VK_NUMPAD1))
		keydown = 0;

	if(wallhack == 1)
	{
		glDepthFunc(GL_LEQUAL);
		if(size == 2)
		{
			if(type == GL_FLOAT)
			{
				if(stride == 0)
				{
					glDepthFunc(GL_ALWAYS);
				}
			}
		}
	}
	
	glTexCoordPointer(size, type, stride, pointer);
}
```

`OpenGl-Wallhack/opengl.h`:

```h
#pragma comment(lib, "opengl32.lib")
#include <gl\gl.h>

void APIENTRY att_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
```

`README.md`:

```md
# COD_Hacks

A collection of hacks for Call of Duty v1.5.

## Desk
Desk.dll is a multi-hack for Call of Duty 1. It features:

- 3 state wallhack (all entities, flashing player models, and off). (Numpad 1)
- 6 state chams (red, blue, green, pink/violet, black, and off). (Numpad 2)
- Behind wall detection (turn on flashing models wallhack and chams, solid colors will indicate model is visible).
- Night-mode. (Numpad 3)
- No fog. (Numpad 4)
- White-walls/no textures. (Numpad 5)

Undetected by PB from 2007/08/22 to ~2009.

![Hack Screenshot](Desk/screenshot.jpg?raw=true "Screenshot Hack")

## Esp
An internal ESP that works by hooking the game loop responsible for calling world-to-screen and loads a custom vm_main function that prints an "X" over the current location before rendering the entity.

![Hack Screenshot](Esp/screenshot.jpg?raw=true "Screenshot Hack")

## idkmybffCoD
A multihack for CoD1 that features a wallhack, chams, full-bright, no-scope, no-fog and internal ui.

![Hack Screenshot](idkmybffCoD/screenshot.jpg?raw=true "Screenshot Hack")

## Internal-OpenGL-Wallhack
A OpenGL wallhack that works via hooking CoD's internal call to glDrawElements while displaying players and modifies the call to disable depth testing.

![Hack Screenshot](Internal-OpenGL-Wallhack/screenshot.jpg?raw=true "Screenshot Hack")

## Internal-Wallhack
An internal wallhack that hooks CoD's syscall function and adjusts the render flag of entities that pass through for rendering.

![Hack Screenshot](Internal-Wallhack/screenshot.jpg?raw=true "Screenshot Hack")

## No-Recoil
A no-recoil hack for CoD single-player that works by removing the instructions for aim being punched up while shooting.

## OpenGL-CountMonitor
A utility to log the counts of displayed entities to help isolate specific counts of player models.

## OpenGL-Wallhack
A wallhack that uses the glTexCoordPointer method to achieve great results without logging counts.

Undetected by PB from 2007/12/23 to ~2008/02.

![Hack Screenshot](OpenGl-Wallhack/screenshot.jpg?raw=true "Screenshot Hack")

## Some notes

Some various reversing notes for v1.5.

### Chat-Out
```
00437C3C   8D4424 10        LEA EAX,DWORD PTR SS:[ESP+10]
00437C40   50               PUSH EAX            ; text
00437C41   6A 00            PUSH 0				; format(push 1 places middle of screen, etc.)
00437C4B   E8 F0FBFFFF      CALL CoDMP.00437840
```

![Hack Screenshot](screenshot_chat.jpg?raw=true "Screenshot Hack")

### Drawing Entities
```
004E025E     E8 AD5C0200    CALL CoDMP.00505F10    ;draw world
004E0263  |> E8 E8010000    CALL CoDMP.004E0450    
004E0268  |. E8 83FEFFFF    CALL CoDMP.004E00F0	   ;draw entities
```

Draw entities function can be found via the following string:
```
004E0190     68 EC435800    PUSH CoDMP.005843EC                      ;  ASCII "R_GetShaderByHandle: out of range hShader '%d'
"
004E0195     6A 02          PUSH 2
004E0197     FF15 000B9B01  CALL DWORD PTR DS:[19B0B00]              ;  CoDMP.00412960
```

### Drawing Bullets, Smoke, and Particles
```
004E01AE     6A 00          PUSH 0
004E01B0     6A 00          PUSH 0
004E01B2     6A 00          PUSH 0
004E01B4     8BD0           MOV EDX,EAX
004E01B6     A1 480A9B01    MOV EAX,DWORD PTR DS:[19B0A48]
004E01BB     68 B8215B00    PUSH CoDMP.005B21B8
004E01C0     E8 6BFDFFFF    CALL CoDMP.004DFF30
004E01C5     83C4 10        ADD ESP,10
```

### Drawing Player Structures
```
004E01D1   > 50             PUSH EAX                                 ; /Arg1; Case 1 of switch 004E0164
004E01D2   . E8 E9970300    CALL CoDMP.005199C0                      ; \CoDMP.005199C0
004E01D7   . 83C4 04        ADD ESP,4
```

![Hack Screenshot](screenshot_player.jpg?raw=true "Screenshot Hack")

### Drawing Cars, Foliage, and Dynamic Entities
```
004E01DC   > E8 2F3B0300    CALL CoDMP.00513D10                      ;  Case 2 of switch 004E0164
```

![Hack Screenshot](screenshot_entities.jpg?raw=true "Screenshot Hack")

### Drawing Switch Case
```
004E01E3   > 68 6CBD5800    PUSH CoDMP.0058BD6C                      ;  ASCII 15,"R_AddEntitySurfaces: "; Default case of switch 004E0164
```

### OpenGL Stuff
Addresses:
```
00575BF6     FF15 E0BE9901  CALL DWORD PTR DS:[199BEE0]              ;  opengl32.glDisable
00575C0D     FF15 3CC69901  CALL DWORD PTR DS:[199C63C]              ;  opengl32.glDrawElements
00575C19     FF15 68C49901  CALL DWORD PTR DS:[199C468]              ;  opengl32.glEnable
```

Drawing calls:
```
00508153   CALL DWORD PTR DS:[199C63C]               opengl32.glDrawElements	;draw the sky
005145CC   CALL DWORD PTR DS:[199C63C]               opengl32.glDrawElements	;draw model statics
00518D6C   CALL DWORD PTR DS:[199C63C]               opengl32.glDrawElements	;models, compass, etc.
0051A39F   CALL DWORD PTR DS:[199C63C]               opengl32.glDrawElements	;gun models
```

```

`idkmybffCoD/README.md`:

```md
A multihack for CoD1 that features a wallhack, chams, full-bright, no-scope, no-fog and internal ui.

Compiled with VS6, but should compile with any C++ compiler.

![Hack Screenshot](screenshot.jpg?raw=true "Screenshot Hack")

Originally written 2008/02/23 by attilathedud.

```

`idkmybffCoD/main.cpp`:

```cpp
/*!
*	A multihack for CoD1 that features a wallhack, chams, full-bright, no-scope, no-fog and internal ui.
*
*	Originally written 2008/02/23 by attilathedud.
*/

#include <windows.h>
#include <detours.h>
#include "opengl.h"

/*!
*	The LoadLibrary hooks is responsible for detecting when OpenGL is loaded and detouring 
*	glDrawElements, glViewport, and glTexCoordPointer.
*/
HMODULE (WINAPI *orig_LoadLibrary) ( LPCSTR lpFileName );
HMODULE WINAPI LoadLibrary_Hook ( LPCSTR lpFileName ) 
{
	HMODULE hM = orig_LoadLibrary( lpFileName );
	if ( strstr( lpFileName, "opengl32.dll" ) ) 
	{
		DetourFunction((unsigned char*)GetProcAddress(hM, "glDrawElements"), (unsigned char*)att_glDrawElements);
		DetourFunction((unsigned char*)GetProcAddress(hM, "glViewport"), (unsigned char*)att_glViewport);
		DetourFunction((unsigned char*)GetProcAddress(hM, "glTexCoordPointer"), (unsigned char*)att_glTexCoordPointer);
	}

	return orig_LoadLibrary( lpFileName );
}

// On attach, detour LoadLibrary to a custom function so that we can hook the needed gl functions. 
// Store the original address in orig_LoadLibrary.
void attach_Hook()
{
	DetourFunction((LPBYTE) LoadLibraryA, (LPBYTE) LoadLibrary_Hook );
	__asm mov [ orig_LoadLibrary ], eax;
}

bool APIENTRY DllMain(DWORD hInstance, DWORD reason, LPVOID lpReserved)
{
	if(reason == DLL_PROCESS_ATTACH)
	{
		// While we are in the process of attaching our hook, make sure no processes are 
		// attempting to access external references to the old endpoint.
		DisableThreadLibraryCalls((HINSTANCE)hInstance);
		attach_Hook();
	}	
	else if(reason == DLL_PROCESS_DETACH)
		// On detach, delete the lists allocated to hold our font.
		glDeleteLists(1000, 256);
	else
	{
		MessageBox(0, "Could not attach", "idkmybffCoD", 0);
		return false;
	}

	return true;
}
```

`idkmybffCoD/opengl.cpp`:

```cpp
/*!
*	Contains all our OpenGL hooked functions along with several helper functions to render text and ui.
*
*	Also contains all the state variables for our hack. Should be abstracted to a class.
*/

#include <windows.h>
#include "opengl.h"

// Toggles
bool menu = 0, menuDrawn = 0, keydown = 0, text = 0, wallhack = 0, scope = 0, scopeDrawn = 0, fog = 0, chamsDrawn = 0;

// Menu location
float y1 = 100,y2 = 120, MAX_INDEX = 200, MIN_INDEX = 100;

// Current location of pointer, chams value, and wallcolor value.
BYTE index = 0, chams = 0, wallcolor = 0;

// Device context of CoD in order to render text.
HDC hDc = 0;

/*!
*	A helper function to render text to the screen. Uses raster positions to place the text over the 
*	world along with bitmap fonts to render the text.
*/
void drawText(char* text, float x, float y, float R, float G, float B, float A)
{
	glPushMatrix();
	glLoadIdentity();
	glDisable(GL_TEXTURE_2D);
	glColor4f(R,G,B,A);
	glRasterPos2f(x, y);
	glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);
	glEnable(GL_TEXTURE_2D);
	glPopMatrix();
}

/*!
*	Helper function that renders a box of a given color.
*/
void drawBox(float x1, float y1, float x2, float y2, float R, float G, float B, float A)
{
	glColor4f(R,G,B,A);
	glBegin(GL_QUADS);
		glVertex2f(x1, y1);
		glVertex2f(x1, y2);
		glVertex2f(x2, y2);
		glVertex2f(x2, y1);
	glEnd();
}

/*! 
*	Helper function that renders a line of a given color and width.
*/
void drawLine(float x1, float y1, float x2, float y2, float width, float R, float G, float B, float A)
{
	glColor4f(R,G,B,A);
	glLineWidth(width);

	glBegin(GL_LINES);
		glVertex2f(x1, y1);
		glVertex2f(x2, y2);
	glEnd();
}
	
/*!
*	Helper function that abstracts away code for the menu display. The menu is made up of a title
*	bar box, a line, and a main box that contains all the text and options. Also draws the box
*	representing our current selection.
*/
void drawMenu()
{
	drawBox(100, y1, 300, y2,0, 0, 1, .5f);
	drawBox(100,80, 300, 100, .2f, 0, 0.2f, .5f);
	drawBox(100,100,300,200,0,0,0,.5f);
	drawLine(100,100,300,100,1,1,1,1,1);
	drawText("idkmybffCoD :: ^attilathedud^", 100, 93, 1, 1, 0, .5f);
	drawText("Wallhack", 100, 113, 1, 1, 0, .5f);		
	if(wallhack)
		drawText("On", 275, 113, 0, 1, 0, .5f);
	else
		drawText("Off", 275, 113, 1, 0, 0, .5f);
	drawText("Chams", 100, 133, 1, 1, 0, .5f);
	switch(chams)
	{
		case 0:		drawText("Off", 275, 133, 1, 0, 0, .5f);		break;
		case 1:		drawText("All*", 275, 133, 1, 0, 0, .5f);		break;
		case 2:		drawText("All*", 275, 133, 0, 1, 0, .5f);		break;
		case 3:		drawText("All*", 275, 133, 0, 0, 1,	.5f);		break;
		case 4:		drawText("All*", 275, 133, 1, 0, 1, .5f);		break;
	}
	drawText("Full Bright", 100, 153, 1, 1, 0, .5f);
	switch(wallcolor)
	{
		case 0:		drawText("Off", 275, 153, 1, 0, 0, .5f);		break;
		case 1:		drawText("Black", 260, 153, .1f, .1f, .1f, .5f);		break;
		case 2:		drawText("White", 260, 153, 1, 1, 1, .5f);		break;
	}
	drawText("No Scope", 100, 173, 1, 1, 0, .5f);
	if(scope)
		drawText("On", 275, 173, 0, 1, 0, .5f);
	else
		drawText("Off", 275, 173, 1, 0, 0, .5f);
	drawText("No Fog", 100, 193, 1, 1, 0, .5f);
	if(fog)
		drawText("On", 275, 193, 0, 1, 0, .5f);
	else
		drawText("Off", 275, 193, 1, 0, 0, .5f);
}

/*!
*	The glDrawElements hook is responsible for rendering the menu, initializing text, no-scope, 
*	wallhack, full-bright, and chams.
*/
void APIENTRY att_glDrawElements(GLenum mode,  GLsizei count,  GLenum type,  const GLvoid *indices)
{
	if(menu)
	{
		if(!menuDrawn)
		{
			glDisable(GL_TEXTURE_2D);
			glPushMatrix();
			glLoadIdentity();
			drawMenu();
			glPopMatrix();
			glEnable(GL_TEXTURE_2D);
			menuDrawn = 1;
		}
	}

	// If our text isn't initialized, get the current context, create a bitmap font and store
	// it in a list.
	if(!text)
	{
		hDc = wglGetCurrentDC();
		wglUseFontBitmaps(hDc, 0, 256, 1000);
		glListBase(1000);
		text = 1;
	}

	// No-scope works by drawing a 0x0 box with no alpha and distrupting the scope blur rendering.
	if(scope)
	{
		if(!scopeDrawn)						
		{
			glDisable(GL_TEXTURE_2D);
			glPushMatrix();
			glLoadIdentity();
			drawBox(0,0,0,0,1,1,1,0);
			glPopMatrix();
			glEnable(GL_TEXTURE_2D);
			scopeDrawn = 1;
		}
	}

	// Wallhack works by setting the depth to GL_ALWAYS before rendering the entity
	if(wallhack)
	{
		if( mode == GL_TRIANGLES && indices != NULL)
		{
			glDepthFunc(GL_ALWAYS);
			glDrawElements(mode, count, type, indices);
			glDepthFunc(GL_LEQUAL);
		}
	}

	// Full-bright works by bluring the texture mode on environmental pieces into a solid color.
	if(wallcolor)
	{
			if(wallcolor == 1)
			{
				glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND); 
			}
			else if(wallcolor == 2)
			{
				glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
			}
	}
	else if(!wallcolor)
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
			
	// Chams works by modifying the color before rendering the entity.
	if(!chams && !chamsDrawn)
	{
		glEnable(GL_COLOR_MATERIAL);
		glColor3f(.6f,.6f,.6f);
		glDrawElements(mode, count, type, indices);
		glDisable(GL_COLOR_MATERIAL);
		chamsDrawn = 1;
	}
	else if(chams > 0 && indices != NULL && mode != GL_QUADS && !chamsDrawn)
	{
		glEnable(GL_COLOR_MATERIAL);
		switch(chams)
		{
			case 1:   glColor3f(.6f,.2f,.2f);	break;
			case 2:	  glColor3f(.2f,.6f,.2f);	break;
			case 3:	  glColor3f(.2f,.2f,.6f);	break;
			case 4:	  glColor3f(.6f,.2f,.6f);	break;
		}
		glDrawElements(mode, count, type, indices);
		glDisable(GL_COLOR_MATERIAL);
		chamsDrawn = 1;
	}

	glDrawElements(mode, count, type, indices);
}

/*!
*	The glViewport hook is responsible for dealing with input and menu navigation via the numpad.
*/
void APIENTRY att_glViewport(GLint x,  GLint y,  GLsizei width,  GLsizei height)
{
	if(GetAsyncKeyState(VK_NUMPAD0) && keydown == 0)
	{
		menu = !menu;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD2) && menu == true && keydown == 0)
	{
		y1 += 20; y2 += 20; index++;
		if(y2 > MAX_INDEX)
		{
			y1 = MIN_INDEX;
			y2 = MIN_INDEX+20;
			index = 0;
		}

		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD8) && menu == true && keydown == 0)
	{
		y1 -= 20; y2 -= 20; index--;
		if(y1 < MIN_INDEX)
		{
			y1 = MAX_INDEX-20;
			y2 = MAX_INDEX;
			index = 4;
		}

		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD6) && menu == true && keydown == 0)
	{
		if(index == 0)
			wallhack = !wallhack;
		else if(index == 1)
		{
			if(chams < 4)
				chams++;
			else
				chams = 0;
			chamsDrawn = false;
		}
		else if(index == 2)
		{
			if(wallcolor < 2)
				wallcolor++;
			else
				wallcolor = 0;
		}
		else if(index == 3)
			scope = !scope;
		else if(index == 4)
			fog = !fog;
		keydown = 1;
	}
	else if(GetAsyncKeyState(VK_NUMPAD4) && menu == true && keydown == 0)
	{
		if(index == 0)
			wallhack = !wallhack;
		else if(index == 1)
		{
			if(chams > 0)
				chams--;
			else
				chams = 4;
			chamsDrawn = false;
		}
		else if(index == 2)
		{
			if(wallcolor > 0)
				wallcolor--;
			else
				wallcolor = 2;
		}
		else if(index == 3)
			scope = !scope;
		else if(index == 4)
			fog = !fog;
		keydown = 1;
	}
	else if(!(GetAsyncKeyState(VK_NUMPAD0) || GetAsyncKeyState(VK_NUMPAD2) || GetAsyncKeyState(VK_NUMPAD8) || GetAsyncKeyState(VK_NUMPAD6) || GetAsyncKeyState(VK_NUMPAD4)))
		keydown = 0;

	menuDrawn = false;
	scopeDrawn = false;

	glViewport(x, y, width, height);
}

/*!
*	glTexCoordPointer hook is responsible for disabling fog.
*/
void APIENTRY att_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
	if(fog)
		glDisable(GL_FOG);

	glTexCoordPointer(size, type, stride, pointer);
}

```

`idkmybffCoD/opengl.h`:

```h
#include <gl/gl.h>

void APIENTRY att_glDrawElements(GLenum mode,  GLsizei count,  GLenum type,  const GLvoid *indices);
void APIENTRY att_glViewport(GLint x,  GLint y,  GLsizei width,  GLsizei height);
void APIENTRY att_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

```