Project Path: arc_gmh5225_AwaitFuscator_puhquqz0

Source Tree:

```txt
arc_gmh5225_AwaitFuscator_puhquqz0
├── AwaitFuscator.sln
├── LICENSE.md
├── README.md
├── assets
│   └── example.png
├── deps
│   └── Echo
├── samples
│   ├── AwaitFuscator.Playground
│   │   ├── AwaitFuscator.Playground.csproj
│   │   └── Program.cs
│   └── AwaitFuscator.Sample
│       ├── AwaitFuscator.Sample.csproj
│       └── Program.cs
└── src
    └── AwaitFuscator
        ├── AwaitFuscator.csproj
        ├── ConsoleErrorListener.cs
        ├── Engine
        │   ├── AsyncCodeFactory.cs
        │   ├── AsyncMethodBuilderFactory.cs
        │   ├── AsyncStateMachineType.cs
        │   ├── AwaiterType.cs
        │   ├── ExpressionTypeInference.cs
        │   ├── MethodTransformer.cs
        │   ├── MoveNextBuilder.cs
        │   ├── ObfuscatorContext.cs
        │   └── ObfuscatorParameters.cs
        └── Program.cs

```

`AwaitFuscator.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AwaitFuscator.Sample", "samples\AwaitFuscator.Sample\AwaitFuscator.Sample.csproj", "{DF08E472-31D8-4DE3-9341-F4249F2F64D8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AwaitFuscator.Playground", "samples\AwaitFuscator.Playground\AwaitFuscator.Playground.csproj", "{6AA18698-9892-488F-B446-D5292C934A4E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AwaitFuscator", "src\AwaitFuscator\AwaitFuscator.csproj", "{19661810-1E96-4507-B91E-AADBBA7ED979}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{7EA4A039-BF3C-4316-A6A0-5BD3D2B3CB72}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "deps", "deps", "{108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "samples", "samples", "{7C6ACA1F-9C7A-4BBD-8ECF-5740529C79E8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Echo.Platforms.AsmResolver", "deps\Echo\src\Platforms\Echo.Platforms.AsmResolver\Echo.Platforms.AsmResolver.csproj", "{BA40D772-47F2-4B42-96BC-31ECA0568D2B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Echo", "deps\Echo\src\Core\Echo\Echo.csproj", "{05B0806B-0528-4CA5-B88E-60EC28076D30}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Echo.Ast", "deps\Echo\src\Core\Echo.Ast\Echo.Ast.csproj", "{18F2F7AB-A57A-4638-A5D5-D068A4E13474}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Echo.ControlFlow", "deps\Echo\src\Core\Echo.ControlFlow\Echo.ControlFlow.csproj", "{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Echo.DataFlow", "deps\Echo\src\Core\Echo.DataFlow\Echo.DataFlow.csproj", "{2F145165-973C-4316-A128-E9F8716E6C06}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DF08E472-31D8-4DE3-9341-F4249F2F64D8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DF08E472-31D8-4DE3-9341-F4249F2F64D8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DF08E472-31D8-4DE3-9341-F4249F2F64D8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DF08E472-31D8-4DE3-9341-F4249F2F64D8}.Release|Any CPU.Build.0 = Release|Any CPU
		{6AA18698-9892-488F-B446-D5292C934A4E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6AA18698-9892-488F-B446-D5292C934A4E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6AA18698-9892-488F-B446-D5292C934A4E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6AA18698-9892-488F-B446-D5292C934A4E}.Release|Any CPU.Build.0 = Release|Any CPU
		{19661810-1E96-4507-B91E-AADBBA7ED979}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19661810-1E96-4507-B91E-AADBBA7ED979}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19661810-1E96-4507-B91E-AADBBA7ED979}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19661810-1E96-4507-B91E-AADBBA7ED979}.Release|Any CPU.Build.0 = Release|Any CPU
		{BA40D772-47F2-4B42-96BC-31ECA0568D2B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA40D772-47F2-4B42-96BC-31ECA0568D2B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA40D772-47F2-4B42-96BC-31ECA0568D2B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA40D772-47F2-4B42-96BC-31ECA0568D2B}.Release|Any CPU.Build.0 = Release|Any CPU
		{05B0806B-0528-4CA5-B88E-60EC28076D30}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{05B0806B-0528-4CA5-B88E-60EC28076D30}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{05B0806B-0528-4CA5-B88E-60EC28076D30}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{05B0806B-0528-4CA5-B88E-60EC28076D30}.Release|Any CPU.Build.0 = Release|Any CPU
		{18F2F7AB-A57A-4638-A5D5-D068A4E13474}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{18F2F7AB-A57A-4638-A5D5-D068A4E13474}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{18F2F7AB-A57A-4638-A5D5-D068A4E13474}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{18F2F7AB-A57A-4638-A5D5-D068A4E13474}.Release|Any CPU.Build.0 = Release|Any CPU
		{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B}.Release|Any CPU.Build.0 = Release|Any CPU
		{2F145165-973C-4316-A128-E9F8716E6C06}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2F145165-973C-4316-A128-E9F8716E6C06}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2F145165-973C-4316-A128-E9F8716E6C06}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2F145165-973C-4316-A128-E9F8716E6C06}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{6AA18698-9892-488F-B446-D5292C934A4E} = {7C6ACA1F-9C7A-4BBD-8ECF-5740529C79E8}
		{DF08E472-31D8-4DE3-9341-F4249F2F64D8} = {7C6ACA1F-9C7A-4BBD-8ECF-5740529C79E8}
		{19661810-1E96-4507-B91E-AADBBA7ED979} = {7EA4A039-BF3C-4316-A6A0-5BD3D2B3CB72}
		{BA40D772-47F2-4B42-96BC-31ECA0568D2B} = {108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}
		{05B0806B-0528-4CA5-B88E-60EC28076D30} = {108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}
		{18F2F7AB-A57A-4638-A5D5-D068A4E13474} = {108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}
		{8E1B175F-ACF4-4762-A88B-D239FB8D3F5B} = {108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}
		{2F145165-973C-4316-A128-E9F8716E6C06} = {108E9E47-3A1E-4D4C-BD9D-FD214A9E812E}
	EndGlobalSection
EndGlobal

```

`LICENSE.md`:

```md
The MIT License (MIT)
=====================

Copyright © `2024` `Washi`

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


```

`README.md`:

```md
# AwaitFuscator

This is the AwaitFuscator; a .NET binary-to-binary obfuscator that translates your code into long chains of `await` expressions:

![](/assets/example.png)

For more details on how it works, check the [FAQ](#how-does-it-work) or read the [accompanied blog post](https://blog.washi.dev/posts/awaitfuscator).


## How To Build

This project depends on a few other projects.
Make sure you have all submodules cloned:

```sh
$ git clone --recursive https://github.com/Washi1337/AwaitFuscator.git
```

If you accidentally didn't clone the submodules, you can go to your repository directory and run the following instead:

```sh
$ git submodule update --init
```

Then, just compile using your favourite IDE like Visual Studio or JetBrains Rider, or run the following:

```sh
$ dotnet build
```

The binaries will then appear in `src/AwaitFuscator/bin`.


## How To Use

To awaitfuscate a program, simply run Awaitfuscator with the path of the binary to obfuscate:

```sh
$ AwaitFuscator [path]
```

If everything goes well (which is a big "if"), this will create a folder called `Obfuscated` in the parent directory of the input file containing the output.

For example:

```sh
$ AwaitFuscator /path/to/file.exe
```

will produce a file at `/path/to/Obfuscated/file.exe`.

## FAQ

### How does it work?

C# allows for custom awaiters to be defined on any type using custom `GetAwaiter` extension methods and custom awaiter types.
These awaiter types define a method called `GetResult` can contain any code you want.

Awaitfuscator locates all "awaitifiable" methods in the input binary, and creates for each statement a new awaiter with the original statement's code moved into its `GetResult` method.
Then, by defining custom `GetAwaiter` extension methods, it is possible to await the custom awaiters, and thus chain a bunch of awaiters together.
This effectively rewrites the entire method body as one long chain of awaits.

For more details, read the [accompanied blog post](https://blog.washi.dev/posts/awaitfuscator).


### Is the code in the output binary really hidden?

No. 
The original code is still more or less there, just slightly rewritten and scattered around the assembly in different places.
Awaitfuscator just plays a bunch of tricks that confuses decompilers a lot.

For more details, read the [accompanied blog post](https://blog.washi.dev/posts/awaitfuscator).


### Can I use it in my next product?

You could.
Not sure if it is a good idea though.


### Is it production-ready?

Probably not.


### Heeelp it...

- ... crashes,
- ... produces errors I don't understand,
- ... corrupts my files,

These are very likely to happen as this is more of a proof of concept rather than a finalized product.
Nonetheless, [bug reports](https://github.com/Washi1337/AwaitFuscator/issues/new) are appreciated :).

```

`samples/AwaitFuscator.Playground/AwaitFuscator.Playground.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>

```

`samples/AwaitFuscator.Playground/Program.cs`:

```cs
using System.Runtime.CompilerServices;

namespace AwaitFuscator.Playground;

public static class Program
{
    public static async Task Main()
    {
        await await await 1337;
    }

    public static IntAwaiter GetAwaiter(this int self) => new();
    public static DoubleAwaiter GetAwaiter(this double self) => new();
    public static FloatAwaiter GetAwaiter(this float self) => new();

    public readonly struct IntAwaiter : INotifyCompletion
    {
        public bool IsCompleted => true;
        public void OnCompleted(Action continuation) {}
        public double GetResult() { Console.WriteLine("Who needs actual statements"); return 1337.0; }
    }

    public readonly struct DoubleAwaiter : INotifyCompletion
    {
        public bool IsCompleted => true;
        public void OnCompleted(Action continuation) {}
        public float GetResult() { Console.WriteLine("when all you need"); return 1337f; }
    }

    public readonly struct FloatAwaiter : INotifyCompletion
    {
        public bool IsCompleted => true;
        public void OnCompleted(Action continuation) {}
        public void GetResult() => Console.WriteLine("is a little bit of patience!");
    }
}
```

`samples/AwaitFuscator.Sample/AwaitFuscator.Sample.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>

```

`samples/AwaitFuscator.Sample/Program.cs`:

```cs
internal static class Program
{
    public static void Main()
    {
        Console.WriteLine("Hello, world!");

        while (true)
        {
            Console.Write("What is your name [Leave empty to exit]?: ");
            string? name = Console.ReadLine();
            if (string.IsNullOrEmpty(name))
                break;

            Console.WriteLine($"Hi {name}. That's a cool name!");

            int age = AskInteger("How old are you?: ");
            if (age < 21)
                Console.WriteLine("You are too young to drink!");
            else
                Console.WriteLine("You are allowed to drink!");
        }

        Console.WriteLine("See you around!");
    }

    public static int AskInteger(string prompt)
    {
        while (true)
        {
            Console.Write(prompt);
            string? input = Console.ReadLine();
            if (string.IsNullOrEmpty(input))
                continue;

            if (!int.TryParse(input, out int age))
                continue;

            return age;
        }
    }
}
```

`src/AwaitFuscator/AwaitFuscator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <Version>0.1.0</Version>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="AsmResolver.DotNet" Version="5.5.0" />
      <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\deps\Echo\src\Core\Echo.Ast\Echo.Ast.csproj" />
      <ProjectReference Include="..\..\deps\Echo\src\Platforms\Echo.Platforms.AsmResolver\Echo.Platforms.AsmResolver.csproj" />
    </ItemGroup>


</Project>
```

`src/AwaitFuscator/ConsoleErrorListener.cs`:

```cs
using AsmResolver;

namespace AwaitFuscator;

internal class ConsoleErrorListener : IErrorListener
{
    public void MarkAsFatal()
    {
    }

    public void RegisterException(Exception? exception)
    {
        string indent = "";
        while (exception is not null)
        {
            Console.Error.WriteLine($"[!] {indent}{exception.Message}");
            exception = exception.InnerException;
            indent += "  ";
        }
    }
}
```

`src/AwaitFuscator/Engine/AsyncCodeFactory.cs`:

```cs
using System.Runtime.CompilerServices;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using static AsmResolver.PE.DotNet.Cil.CilOpCodes;

namespace AwaitFuscator.Engine;

/// <summary>
/// Provides members for easily constructing new code associated with asynchronous methods.
/// </summary>
public class AsyncCodeFactory
{
    private readonly Dictionary<TypeSignature, AsyncMethodBuilderFactory> _methodBuilderFactories = new();

    public AsyncCodeFactory(ModuleDefinition targetModule)
    {
        TargetModule = targetModule;

        var factory = targetModule.CorLibTypeFactory;

        ValueTypeType = factory.CorLibScope
            .CreateTypeReference("System", "ValueType")
            .ImportWith(targetModule.DefaultImporter);

        ActionType = factory.CorLibScope
            .CreateTypeReference("System", "Action")
            .ImportWith(targetModule.DefaultImporter);

        ExceptionType = factory.CorLibScope
            .CreateTypeReference("System", "Exception")
            .ImportWith(targetModule.DefaultImporter);

        INotifyCompletionType = factory.CorLibScope
            .CreateTypeReference("System.Runtime.CompilerServices", "INotifyCompletion")
            .ImportWith(targetModule.DefaultImporter);

        ExtensionAttributeConstructor = factory.CorLibScope
            .CreateTypeReference("System.Runtime.CompilerServices", "ExtensionAttribute")
            .CreateMemberReference(".ctor", MethodSignature.CreateInstance(factory.Void))
            .ImportWith(targetModule.DefaultImporter);

        CompilerGeneratedAttributeConstructor = factory.CorLibScope
            .CreateTypeReference("System.Runtime.CompilerServices", "CompilerGeneratedAttribute")
            .CreateMemberReference(".ctor", MethodSignature.CreateInstance(factory.Void))
            .ImportWith(targetModule.DefaultImporter);

        IAsyncStateMachineType = factory.CorLibScope
            .CreateTypeReference("System.Runtime.CompilerServices", "IAsyncStateMachine")
            .ImportWith(targetModule.DefaultImporter);

        IAsyncStateMachine_MoveNextMethod = IAsyncStateMachineType
            .CreateMemberReference(
                "MoveNext",
                MethodSignature.CreateInstance(TargetModule.CorLibTypeFactory.Void)
            ).ImportWith(targetModule.DefaultImporter);

        IAsyncStateMachine_SetStateMachineMethod = IAsyncStateMachineType
            .CreateMemberReference(
                "SetStateMachine",
                MethodSignature.CreateInstance(
                    TargetModule.CorLibTypeFactory.Void,
                    IAsyncStateMachineType.ToTypeSignature(false)
                )
            ).ImportWith(targetModule.DefaultImporter);
    }

    /// <summary>
    /// Gets the module the factory is targeting.
    /// </summary>
    public ModuleDefinition TargetModule { get; }

    /// <summary>
    /// Gets a reference to <see cref="ValueType"/>.
    /// </summary>
    public ITypeDefOrRef ValueTypeType { get; }

    /// <summary>
    /// Gets a reference to <see cref="Action"/>.
    /// </summary>
    public ITypeDefOrRef ActionType { get; }

    /// <summary>
    /// Gets a reference to <see cref="Exception"/>.
    /// </summary>
    public ITypeDefOrRef ExceptionType { get; }

    /// <summary>
    /// Gets a reference to the parameterless constructor of <see cref="ExtensionAttribute"/>.
    /// </summary>
    public MemberReference ExtensionAttributeConstructor { get; }

    /// <summary>
    /// Gets a reference to the parameterless constructor of <see cref="CompilerGeneratedAttribute"/>.
    /// </summary>
    public MemberReference CompilerGeneratedAttributeConstructor { get; }

    /// <summary>
    /// Gets a reference to the <see cref="INotifyCompletion"/> interface.
    /// </summary>
    public ITypeDefOrRef INotifyCompletionType { get; }

    /// <summary>
    /// Gets a reference to the <see cref="IAsyncStateMachine"/> interface.
    /// </summary>
    public ITypeDefOrRef IAsyncStateMachineType { get; }

    /// <summary>
    /// Gets a reference to the <see cref="IAsyncStateMachine.MoveNext"/> method.
    /// </summary>
    public MemberReference IAsyncStateMachine_MoveNextMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="IAsyncStateMachine.SetStateMachine"/> method.
    /// </summary>
    public MemberReference IAsyncStateMachine_SetStateMachineMethod { get; }

    /// <summary>
    /// Obtains the factory for a <see cref="AsyncTaskMethodBuilder{TResult}"/>, initialized to the provided return type.
    /// </summary>
    /// <param name="returnType">The return type to get the factory for.</param>
    /// <returns>The factory.</returns>
    /// <remarks>
    /// This method returns a factory for <see cref="AsyncVoidMethodBuilder"/> if <paramref name="returnType"/> encodes
    /// <see cref="Void"/>.
    /// </remarks>
    public AsyncMethodBuilderFactory GetMethodBuilderFactory(TypeSignature returnType)
    {
        if (!_methodBuilderFactories.TryGetValue(returnType, out var factory))
        {
            factory = new AsyncMethodBuilderFactory(TargetModule, returnType, IAsyncStateMachineType, ExceptionType);
            _methodBuilderFactories.Add(returnType, factory);
        }

        return factory;
    }

    /// <summary>
    /// Creates a new state machine startup stub that is to be placed in an async method.
    /// </summary>
    /// <param name="stateMachineType">The state machine to initialize.</param>
    /// <param name="method">The method to create the stub for.</param>
    /// <returns>The new method body starting the state machine.</returns>
    public CilMethodBody CreateStartupStub(AsyncStateMachineType stateMachineType, MethodDefinition method)
    {
        var returnType = method.Signature!.ReturnType;

        var methodBuilder = GetMethodBuilderFactory(returnType);
        var stateMachineLocal = new CilLocalVariable(stateMachineType.Definition.ToTypeSignature(true));

        var stub = new CilMethodBody(method)
        {
            InitializeLocals = true,
            LocalVariables = { stateMachineLocal }
        };

        var il = stub.Instructions;

        // stateMachine.<>t__builder = AsyncTaskMethodBuilder<T>.Create() / AsyncVoidMethodBuilder.Create();
        il.Add(Ldloca, stateMachineLocal);
        il.Add(Call, methodBuilder.CreateMethod);
        il.Add(Stfld, stateMachineType.BuilderField);

        foreach (var parameter in method.Parameters)
        {
            // stateMachine.Parameter = parameter;
            il.Add(Ldloca, stateMachineLocal);
            il.Add(Ldarg, parameter);
            il.Add(Stfld, stateMachineType.ParameterFields[parameter]);
        }

        // stateMachine.<>1__state = -1;
        il.Add(Ldloca, stateMachineLocal);
        il.Add(Ldc_I4_M1);

        // stateMachine.<>t__builder.Start(ref stateMachine);
        il.Add(Stfld, stateMachineType.StateField);
        il.Add(Ldloca, stateMachineLocal);
        il.Add(Ldflda, stateMachineType.BuilderField);
        il.Add(Ldloca, stateMachineLocal);
        il.Add(Call, methodBuilder.StartMethod
            .MakeGenericInstanceMethod(stateMachineType.Definition.ToTypeSignature(true))
            .ImportWith(TargetModule.DefaultImporter));

        if (returnType.ElementType != ElementType.Void)
        {
            // return stateMachine.<>t__builder.Task;
            il.Add(Ldloca, stateMachineLocal);
            il.Add(Ldflda, stateMachineType.BuilderField);
            il.Add(Call, methodBuilder.GetTaskMethod);
        }

        // return;
        il.Add(Ret);

        il.OptimizeMacros();

        return stub;
    }

    /// <summary>
    /// Constructs a new GetAwaiter extension method for the provided input type that returns an instance of the
    /// provided awaiter type.
    /// </summary>
    /// <param name="awaiterType">The awaiter type to instantiate.</param>
    /// <param name="inputType">The type of expressions to await.</param>
    /// <returns>The new GetAwaiter method.</returns>
    public MethodDefinition CreateGetAwaiterMethod(AwaiterType awaiterType, TypeSignature inputType)
    {
        var awaiterTypeSig = awaiterType.Definition.ToTypeSignature(true);
        var getAwaiter = new MethodDefinition(
            "GetAwaiter",
            MethodAttributes.Assembly | MethodAttributes.Static | MethodAttributes.HideBySig,
            MethodSignature.CreateStatic(awaiterTypeSig, inputType)
        );

        getAwaiter.CilMethodBody = new CilMethodBody(getAwaiter)
        {
            Instructions =
            {
                Ldarg_0,
                {Newobj, awaiterType.Constructor},
                Ret
            }
        };

        getAwaiter.CustomAttributes.Add(new CustomAttribute(ExtensionAttributeConstructor));

        return getAwaiter;
    }
}
```

`src/AwaitFuscator/Engine/AsyncMethodBuilderFactory.cs`:

```cs
using System.Runtime.CompilerServices;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;

namespace AwaitFuscator.Engine;

/// <summary>
/// Provides members for easily constructing new references to various metadata related to <see cref="AsyncVoidMethodBuilder"/>
/// and <see cref="AsyncTaskMethodBuilder{TResult}"/>.
/// </summary>
public class AsyncMethodBuilderFactory
{
    public AsyncMethodBuilderFactory(
        ModuleDefinition targetModule,
        TypeSignature returnType,
        ITypeDefOrRef asyncStateMachineType,
        ITypeDefOrRef exceptionType)
    {
        var factory = targetModule.CorLibTypeFactory;

        if (returnType.ElementType == ElementType.Void)
        {
            Type = factory.CorLibScope
                .CreateTypeReference("System.Runtime.CompilerServices", "AsyncVoidMethodBuilder")
                .ImportWith(targetModule.DefaultImporter);

            CreateMethod = Type
                .CreateMemberReference("Create", MethodSignature.CreateStatic(Type.ToTypeSignature(true)))
                .ImportWith(targetModule.DefaultImporter);
        }
        else
        {
            Type = factory.CorLibScope
                .CreateTypeReference("System.Runtime.CompilerServices", "AsyncTaskMethodBuilder`1")
                .ToTypeSignature(true)
                .MakeGenericInstanceType(returnType)
                .ToTypeDefOrRef()
                .ImportWith(targetModule.DefaultImporter);

            CreateMethod = Type
                .CreateMemberReference(
                    "Create",
                    MethodSignature.CreateStatic(factory.CorLibScope
                        .CreateTypeReference("System.Runtime.CompilerServices", "AsyncTaskMethodBuilder`1")
                        .ToTypeSignature(true)
                        .MakeGenericInstanceType(new GenericParameterSignature(GenericParameterType.Type, 0)))
                ).ImportWith(targetModule.DefaultImporter);
        }

        StartMethod = Type
            .CreateMemberReference(
                "Start",
                MethodSignature.CreateInstance(
                    factory.Void, 1,
                    new GenericParameterSignature(GenericParameterType.Method, 0).MakeByReferenceType()
                )
            ).ImportWith(targetModule.DefaultImporter);

        SetStateMachineMethod = Type
            .CreateMemberReference(
                "SetStateMachine",
                MethodSignature.CreateInstance(
                    targetModule.CorLibTypeFactory.Void,
                    asyncStateMachineType.ToTypeSignature(false)
                )
            ).ImportWith(targetModule.DefaultImporter);

        SetExceptionMethod = Type
            .CreateMemberReference(
                "SetException",
                MethodSignature.CreateInstance(factory.Void, exceptionType.ToTypeSignature(false))
            ).ImportWith(targetModule.DefaultImporter);

        AwaitOnCompleted = Type
            .CreateMemberReference("AwaitOnCompleted", MethodSignature.CreateInstance(
                factory.Void, 2,
                new GenericParameterSignature(GenericParameterType.Method, 0).MakeByReferenceType(),
                new GenericParameterSignature(GenericParameterType.Method, 1).MakeByReferenceType()
            )).ImportWith(targetModule.DefaultImporter);

        if (returnType.ElementType == ElementType.Void)
        {
            SetResult = Type
                .CreateMemberReference("SetResult", MethodSignature.CreateInstance(factory.Void))
                .ImportWith(targetModule.DefaultImporter);

            TaskType = factory.CorLibScope
                .CreateTypeReference("System.Threading.Tasks", "Task")
                .ToTypeSignature(false)
                .ImportWith(targetModule.DefaultImporter);

            GetTaskMethod = Type
                .CreateMemberReference("get_Task", MethodSignature.CreateInstance(TaskType))
                .ImportWith(targetModule.DefaultImporter);

            TaskAwaiterType = factory.CorLibScope
                .CreateTypeReference("System.Runtime.CompilerServices", "TaskAwaiter")
                .ToTypeSignature(true)
                .ImportWith(targetModule.DefaultImporter);

            GetAwaiterMethod = TaskType
                .ToTypeDefOrRef()
                .CreateMemberReference("GetAwaiter", MethodSignature.CreateInstance(TaskAwaiterType))
                .ImportWith(targetModule.DefaultImporter);

            GetResultMethod = TaskAwaiterType
                .ToTypeDefOrRef()
                .CreateMemberReference("GetResult", MethodSignature.CreateInstance(factory.Void))
                .ImportWith(targetModule.DefaultImporter);
        }
        else
        {
            SetResult = Type
                .CreateMemberReference(
                    "SetResult",
                    MethodSignature.CreateInstance(
                        factory.Void,
                        new GenericParameterSignature(GenericParameterType.Type, 0))
                ).ImportWith(targetModule.DefaultImporter);

            TaskType = factory.CorLibScope
                .CreateTypeReference("System.Threading.Tasks", "Task`1")
                .ToTypeSignature(false)
                .MakeGenericInstanceType(returnType)
                .ImportWith(targetModule.DefaultImporter);

            GetTaskMethod = Type
                .CreateMemberReference(
                    "get_Task",
                    MethodSignature.CreateInstance(factory.CorLibScope
                        .CreateTypeReference("System.Threading.Tasks", "Task`1")
                        .ToTypeSignature(false)
                        .MakeGenericInstanceType(new GenericParameterSignature(GenericParameterType.Type, 0))
                    )
                ).ImportWith(targetModule.DefaultImporter);

            TaskAwaiterType = factory.CorLibScope
                .CreateTypeReference("System.Runtime.CompilerServices", "TaskAwaiter`1")
                .ToTypeSignature(true)
                .MakeGenericInstanceType(returnType)
                .ImportWith(targetModule.DefaultImporter);

            GetAwaiterMethod = TaskType
                .ToTypeDefOrRef()
                .CreateMemberReference("GetAwaiter", MethodSignature.CreateInstance(factory.CorLibScope
                    .CreateTypeReference("System.Runtime.CompilerServices", "TaskAwaiter`1")
                    .ToTypeSignature(true)
                    .MakeGenericInstanceType(new GenericParameterSignature(GenericParameterType.Type, 0))))
                .ImportWith(targetModule.DefaultImporter);

            GetResultMethod = TaskAwaiterType
                .ToTypeDefOrRef()
                .CreateMemberReference("GetResult", MethodSignature.CreateInstance(
                    new GenericParameterSignature(GenericParameterType.Type, 0)))
                .ImportWith(targetModule.DefaultImporter);
        }
    }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncVoidMethodBuilder"/> or <see cref="AsyncTaskMethodBuilder{TResult}"/> type.
    /// </summary>
    public ITypeDefOrRef Type { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.Create"/> method.
    /// </summary>
    public MemberReference CreateMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.Start{TStateMachine}"/> method.
    /// </summary>
    public MemberReference StartMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.SetStateMachine"/> method.
    /// </summary>
    public MemberReference SetStateMachineMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.SetException"/> method.
    /// </summary>
    public MemberReference SetExceptionMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.SetResult"/> method.
    /// </summary>
    public MemberReference SetResult { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.AwaitOnCompleted{TAwaiter,TStateMachine}"/> method.
    /// </summary>
    public MemberReference AwaitOnCompleted { get; }

    /// <summary>
    /// Gets a reference to the <see cref="AsyncTaskMethodBuilder{TResult}.get_Task" /> method.
    /// </summary>
    public MemberReference GetTaskMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="Task{TResult}"/> type associated to the factory.
    /// </summary>
    public TypeSignature TaskType { get; }

    /// <summary>
    /// Gets a reference to the <see cref="Task{TResult}.GetAwaiter"/> method.
    /// </summary>
    public MemberReference GetAwaiterMethod { get; }

    /// <summary>
    /// Gets a reference to the <see cref="TaskAwaiter{TResult}"/> structure.
    /// </summary>
    public TypeSignature TaskAwaiterType { get; }

    /// <summary>
    /// Gets a reference to the <see cref="TaskAwaiter{TResult}.GetResult"/> method.
    /// </summary>
    public MemberReference GetResultMethod { get; }
}
```

`src/AwaitFuscator/Engine/AsyncStateMachineType.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Collections;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using static AsmResolver.PE.DotNet.Cil.CilOpCodes;

namespace AwaitFuscator.Engine;

/// <summary>
/// Represents a single type implementing a state machine for an asynchronous method.
/// </summary>
public class AsyncStateMachineType
{
    public AsyncStateMachineType(ObfuscatorContext context, MethodDefinition method)
    {
        var methodBuilder = context.CodeFactory.GetMethodBuilderFactory(method.Signature!.ReturnType);

        var factory = context.TargetModule.CorLibTypeFactory;

        // Define base state machine type definition.
        Definition = new TypeDefinition(
            null,
            context.Parameters.UseAnonymousTypes
                ? $"<{method.Name}>d__0"
                : $"StateMachine_{method.Name}",
            TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit | TypeAttributes.NestedAssembly,
            context.CodeFactory.ValueTypeType
        );

        // Wire interfaces.
        Definition.Interfaces.Add(new InterfaceImplementation(context.CodeFactory.IAsyncStateMachineType));
        Definition.CustomAttributes.Add(new CustomAttribute(context.CodeFactory.CompilerGeneratedAttributeConstructor));

        // Add internal state fields.
        Definition.Fields.Add(StateField = new FieldDefinition("<>1__state", FieldAttributes.Public, factory.Int32));
        Definition.Fields.Add(BuilderField = new FieldDefinition("<>t__builder", FieldAttributes.Public,
            methodBuilder.Type.ToTypeSignature(true)
        ));
        Definition.Fields.Add(ConditionField = new FieldDefinition("<>s__1", FieldAttributes.Private, factory.Boolean));

        // Lift parameters to fields.
        var parameters = new Dictionary<Parameter, FieldDefinition>();
        ParameterFields = parameters;

        foreach (var parameter in method.Parameters)
        {
            var field = new FieldDefinition(parameter.Name, FieldAttributes.Public, parameter.ParameterType);
            Definition.Fields.Add(field);
            parameters[parameter] = field;
        }

        // Add code for standard explicit implemented methods.
        AddSetStateMachineMethod(context, methodBuilder);
    }

    /// <summary>
    /// Gets the type definition that is to be added to the target module.
    /// </summary>
    public TypeDefinition Definition { get; }

    /// <summary>
    /// Gets the field containing the method builder for this state machine.
    /// </summary>
    public FieldDefinition BuilderField { get; }

    /// <summary>
    /// Gets the field containing the current state of this state machine.
    /// </summary>
    public FieldDefinition StateField { get; }

    /// <summary>
    /// Gets a field containing the result of a boolean condition in the MoveNext method.
    /// </summary>
    public FieldDefinition ConditionField { get; }

    /// <summary>
    /// Gets a mapping from parameters to their lifted fields added to the state machine.
    /// </summary>
    public IReadOnlyDictionary<Parameter, FieldDefinition> ParameterFields { get; }

    private void AddSetStateMachineMethod(ObfuscatorContext context, AsyncMethodBuilderFactory methodBuilder)
    {
        var setStateMachine = new MethodDefinition(
            "SetStateMachine",
            MethodAttributes.Private | MethodAttributes.Final | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual,
            (MethodSignature?) context.CodeFactory.IAsyncStateMachine_SetStateMachineMethod.Signature
        );

        setStateMachine.CilMethodBody = new CilMethodBody(setStateMachine)
        {
            Instructions =
            {
                // this.SetStateMachine(P_0);
                Ldarg_0,
                {Ldflda, BuilderField},
                Ldarg_1,
                {Call, methodBuilder.SetStateMachineMethod },

                // return;
                Ret
            }
        };

        Definition.MethodImplementations.Add(new MethodImplementation(
            context.CodeFactory.IAsyncStateMachine_SetStateMachineMethod,
            setStateMachine
        ));

        Definition.Methods.Add(setStateMachine);
    }
}
```

`src/AwaitFuscator/Engine/AwaiterType.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using static AsmResolver.PE.DotNet.Cil.CilOpCodes;

namespace AwaitFuscator.Engine;

/// <summary>
/// Provides information about a single Awaiter type introduced by AwaitFuscator.
/// </summary>
public class AwaiterType
{
    /// <summary>
    /// Creates a new awaiter type.
    /// </summary>
    /// <param name="context">The context the obfuscator is situated in.</param>
    /// <param name="name">The name of the awaiter type.</param>
    /// <param name="frameType">The type signature referencing the frame type containing all local variables.</param>
    /// <param name="inputType">The type of expressions to generate an awaiter for.</param>
    /// <param name="outputType">The type of values to produce as a result for this awaiter, or <c>null</c> if the type should be its own result.</param>
    /// <remarks>
    /// This populates everything in the awaiter type, except for the implementation of the <c>GetResult</c> method.
    /// </remarks>
    public AwaiterType(
        ObfuscatorContext context, 
        string name, 
        TypeSignature frameType,
        TypeSignature inputType,
        TypeSignature? outputType)
    {
        // Create a new struct awaiter.
        Definition = new TypeDefinition(
            null, name,
            TypeAttributes.SequentialLayout | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit,
            context.CodeFactory.ValueTypeType
        );

        Definition.Interfaces.Add(new InterfaceImplementation(context.CodeFactory.INotifyCompletionType));
        Definition.CustomAttributes.Add(new CustomAttribute(context.CodeFactory.CompilerGeneratedAttributeConstructor));

        // Add the frame field.
        Definition.Fields.Add(FrameField = new FieldDefinition(
            "Frame",
            FieldAttributes.Public,
            frameType)
        );

        // Add the required methods.
        Constructor = CreateConstructor(context, inputType, frameType);
        GetIsCompletedMethod = CreateIsCompletedProperty(context);
        OnCompletedMethod = CreateOnCompletedMethod(context);
        GetResultMethod = CreateGetResultMethod(context, outputType ?? Definition.ToTypeSignature(true));
    }

    /// <summary>
    /// Gets the awaiter type definition that is to be added to the module.
    /// </summary>
    public TypeDefinition Definition { get; }

    /// <summary>
    /// Gets the constructor method of the awaiter.
    /// </summary>
    public MethodDefinition Constructor { get; }

    /// <summary>
    /// Gets the definition for the <c>get_isCompleted</c> method for this awaiter.
    /// </summary>
    public MethodDefinition GetIsCompletedMethod { get; }

    /// <summary>
    /// Gets the definition for the <c>OnCompleted</c> method for this awaiter.
    /// </summary>
    public MethodDefinition OnCompletedMethod { get; }

    /// <summary>
    /// Gets the definition for the <c>GetResult</c> method for this awaiter.
    /// </summary>
    public MethodDefinition GetResultMethod { get; }

    /// <summary>
    /// Gets the field storing the current frame.
    /// </summary>
    public FieldDefinition FrameField { get; }

    private MethodDefinition CreateConstructor(ObfuscatorContext context, TypeSignature inputType, TypeSignature frameType)
    {
        var result = MethodDefinition.CreateConstructor(context.TargetModule, inputType);

        var il = result.CilMethodBody!.Instructions;
        il.Clear();

        il.Add(Ldarg_0);
        il.Add(Ldarg_1);

        // If the input type is not an object (i.e., another awaiter), we need to extract the current frame from it.
        if (inputType.ElementType != ElementType.Object)
        {
            il.Add(Ldfld, inputType.Resolve()!
                .Fields.First(x => SignatureComparer.Default.Equals(x.Signature!.FieldType, frameType)));
        }

        il.Add(Stfld, FrameField);
        il.Add(Ret);

        Definition.Methods.Add(result);
        return result;
    }

    private MethodDefinition CreateIsCompletedProperty(ObfuscatorContext context)
    {
        var factory = context.TargetModule.CorLibTypeFactory;

        // Define getter method.
        var result = new MethodDefinition(
            "get_IsCompleted",
            MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName,
            MethodSignature.CreateInstance(factory.Boolean)
        );

        result.MethodBody = new CilMethodBody(result)
        {
            Instructions =
            {
                // return true;
                Ldc_I4_1,
                Ret
            }
        };

        Definition.Methods.Add(result);

        // Define IsCompleted property.
        var isCompleted = new PropertyDefinition("IsCompleted", 0, PropertySignature.CreateInstance(factory.Boolean));
        isCompleted.Semantics.Add(new MethodSemantics(result, MethodSemanticsAttributes.Getter));
        Definition.Properties.Add(isCompleted);

        return result;
    }

    private MethodDefinition CreateOnCompletedMethod(ObfuscatorContext context)
    {
        var factory = context.TargetModule.CorLibTypeFactory;

        var result = new MethodDefinition(
            "OnCompleted",
            MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual,
            MethodSignature.CreateInstance(
                factory.Void,
                context.CodeFactory.ActionType.ToTypeSignature(false)
            )
        );

        // We don't need to do anything on completion, as we are never an actual asynchronous operation.
        result.MethodBody = new CilMethodBody(result)
        {
            Instructions = {Ret}
        };

        Definition.Methods.Add(result);

        return result;
    }

    private MethodDefinition CreateGetResultMethod(ObfuscatorContext context, TypeSignature outputType)
    {
        var result = new MethodDefinition(
            "GetResult",
            MethodAttributes.Public | MethodAttributes.HideBySig,
            MethodSignature.CreateInstance(outputType)
        );

        // Note: Body is to be filled in by caller.
        result.CilMethodBody = new CilMethodBody(result);

        Definition.Methods.Add(result);
        return result;
    }

}
```

`src/AwaitFuscator/Engine/ExpressionTypeInference.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using Echo.Ast;
using Echo.Code;

namespace AwaitFuscator.Engine;

public class ExpressionTypeInference : IAstNodeVisitor<CilInstruction, object?, TypeSignature?>
{
    private readonly Dictionary<IVariable, TypeSignature> _variableTypes = new();
    private readonly MethodDefinition _method;

    public ExpressionTypeInference(MethodDefinition method)
    {
        _method = method;
    }

    public void SetVariableType(IVariable variable, TypeSignature type) => _variableTypes[variable] = type;

    public TypeSignature? InferType(Expression<CilInstruction> expression) => expression.Accept(this, null);

    public TypeSignature? Visit(AssignmentStatement<CilInstruction> statement, object? state) => null;

    public TypeSignature? Visit(ExpressionStatement<CilInstruction> statement, object? state)
    {
        return statement.Expression.Accept(this, state);
    }

    public TypeSignature? Visit(PhiStatement<CilInstruction> statement, object? state) => null;

    public TypeSignature? Visit(InstructionExpression<CilInstruction> expression, object? state)
    {
        var argumentTypes = expression.Arguments
            .Select(x => x.Accept(this, state))
            .ToArray();

        switch (expression.Instruction.OpCode.Code)
        {
            case CilCode.Not:
            case CilCode.Neg:
            case CilCode.Dup:
            case CilCode.Or:
            case CilCode.And:
            case CilCode.Xor:
            case CilCode.Shl:
            case CilCode.Shr:
            case CilCode.Shr_Un:
                return argumentTypes[0];

            case CilCode.Ldstr:
                return _method.Module!.CorLibTypeFactory.String;

            case CilCode.Ceq:
            case CilCode.Cgt:
            case CilCode.Cgt_Un:
            case CilCode.Clt:
            case CilCode.Clt_Un:
                return _method.Module!.CorLibTypeFactory.Boolean;

            case CilCode.Add:
            case CilCode.Add_Ovf:
            case CilCode.Add_Ovf_Un:
            case CilCode.Sub:
            case CilCode.Sub_Ovf:
            case CilCode.Sub_Ovf_Un:
            case CilCode.Mul:
            case CilCode.Mul_Ovf:
            case CilCode.Mul_Ovf_Un:
            case CilCode.Div:
            case CilCode.Div_Un:
            case CilCode.Rem:
            case CilCode.Rem_Un:
                return ArithmeticOperator(argumentTypes[0], argumentTypes[1]);

            case CilCode.Ldc_I4:
            case CilCode.Ldc_I4_0:
            case CilCode.Ldc_I4_1:
            case CilCode.Ldc_I4_2:
            case CilCode.Ldc_I4_3:
            case CilCode.Ldc_I4_4:
            case CilCode.Ldc_I4_5:
            case CilCode.Ldc_I4_6:
            case CilCode.Ldc_I4_7:
            case CilCode.Ldc_I4_8:
            case CilCode.Ldc_I4_S:
            case CilCode.Ldc_I4_M1:
            case CilCode.Ldelem_I4:
            case CilCode.Ldind_I4:
            case CilCode.Conv_I4:
            case CilCode.Conv_Ovf_I4:
            case CilCode.Conv_Ovf_I4_Un:
                return _method.Module!.CorLibTypeFactory.Int32;

            case CilCode.Ldc_I8:
            case CilCode.Ldelem_I8:
            case CilCode.Ldind_I8:
            case CilCode.Conv_I8:
            case CilCode.Conv_Ovf_I8:
            case CilCode.Conv_Ovf_I8_Un:
                return _method.Module!.CorLibTypeFactory.Int64;

            case CilCode.Ldc_R4:
            case CilCode.Conv_R4:
            case CilCode.Ldind_R4:
                return _method.Module!.CorLibTypeFactory.Single;

            case CilCode.Ldc_R8:
            case CilCode.Ldind_R8:
            case CilCode.Conv_R8:
            case CilCode.Conv_R_Un:
                return _method.Module!.CorLibTypeFactory.Double;

            case CilCode.Ldelem_I1:
            case CilCode.Ldind_I1:
            case CilCode.Conv_I1:
            case CilCode.Conv_Ovf_I1:
            case CilCode.Conv_Ovf_I1_Un:
                return _method.Module!.CorLibTypeFactory.SByte;

            case CilCode.Ldelem_I2:
            case CilCode.Ldind_I2:
            case CilCode.Conv_I2:
            case CilCode.Conv_Ovf_I2:
            case CilCode.Conv_Ovf_I2_Un:
                return _method.Module!.CorLibTypeFactory.Int16;

            case CilCode.Ldelem_U1:
            case CilCode.Ldind_U1:
            case CilCode.Conv_U1:
            case CilCode.Conv_Ovf_U1:
            case CilCode.Conv_Ovf_U1_Un:
                return _method.Module!.CorLibTypeFactory.Byte;

            case CilCode.Ldelem_U2:
            case CilCode.Ldind_U2:
            case CilCode.Conv_U2:
            case CilCode.Conv_Ovf_U2:
            case CilCode.Conv_Ovf_U2_Un:
                return _method.Module!.CorLibTypeFactory.UInt16;

            case CilCode.Ldelem_U4:
            case CilCode.Ldind_U4:
            case CilCode.Conv_U4:
            case CilCode.Conv_Ovf_U4:
            case CilCode.Conv_Ovf_U4_Un:
                return _method.Module!.CorLibTypeFactory.UInt32;

            case CilCode.Conv_U8:
            case CilCode.Conv_Ovf_U8:
            case CilCode.Conv_Ovf_U8_Un:
                return _method.Module!.CorLibTypeFactory.UInt64;

            case CilCode.Ldelem_I:
            case CilCode.Ldind_I:
            case CilCode.Conv_I:
            case CilCode.Conv_Ovf_I:
            case CilCode.Conv_Ovf_I_Un:
                return _method.Module!.CorLibTypeFactory.IntPtr;

            case CilCode.Conv_U:
            case CilCode.Conv_Ovf_U:
            case CilCode.Conv_Ovf_U_Un:
                return _method.Module!.CorLibTypeFactory.UIntPtr;

            case CilCode.Ldarg:
            case CilCode.Ldarg_0:
            case CilCode.Ldarg_1:
            case CilCode.Ldarg_2:
            case CilCode.Ldarg_3:
            case CilCode.Ldarg_S:
                return expression.Instruction.GetParameter(_method.Parameters).ParameterType;

            case CilCode.Ldloc:
            case CilCode.Ldloc_0:
            case CilCode.Ldloc_1:
            case CilCode.Ldloc_2:
            case CilCode.Ldloc_3:
            case CilCode.Ldloc_S:
                return expression.Instruction.GetLocalVariable(_method.CilMethodBody!.LocalVariables).VariableType;

            case CilCode.Ldfld:
            case CilCode.Ldsfld:
                return ((IFieldDescriptor) expression.Instruction.Operand!).Signature!.FieldType;

            case CilCode.Call:
            case CilCode.Callvirt:
                return ((IMethodDescriptor) expression.Instruction.Operand!).Signature!.ReturnType;

            case CilCode.Calli:
                return ((MethodSignature) ((StandAloneSignature) expression.Instruction.Operand!).Signature!).ReturnType;

            case CilCode.Newobj:
                return ((IMethodDescriptor) expression.Instruction.Operand!).DeclaringType!.ToTypeSignature();

            case CilCode.Newarr:
                return ((ITypeDefOrRef) expression.Instruction.Operand!).MakeSzArrayType();

            case CilCode.Box:
                return _method.Module!.CorLibTypeFactory.Object;

            case CilCode.Unbox_Any:
                return ((ITypeDefOrRef) expression.Instruction.Operand!).ToTypeSignature();

            default:
                return null;
        }
    }

    private TypeSignature? ArithmeticOperator(TypeSignature? a, TypeSignature? b)
    {
        if (a is null)
            return b;
        if (b is null)
            return a;

        var factory = _method.Module!.CorLibTypeFactory;

        return (ToCliType(a).ElementType, ToCliType(b).ElementType) switch
        {
            (ElementType.I4, ElementType.I4) => factory.Int32,
            (ElementType.I4, ElementType.I8) => factory.Int64,
            (ElementType.I8, ElementType.I4) => factory.Int64,
            (ElementType.I8, ElementType.I8) => factory.Int64,

            (ElementType.I, ElementType.I4) => factory.IntPtr,
            (ElementType.I, ElementType.I8) => factory.IntPtr,
            (ElementType.I4, ElementType.I) => factory.IntPtr,
            (ElementType.I8, ElementType.I) => factory.IntPtr,
            (ElementType.I, ElementType.I) => factory.IntPtr,

            (ElementType.R4, ElementType.R4) => factory.Single,
            (ElementType.R4, ElementType.R8) => factory.Double,
            (ElementType.R8, ElementType.R4) => factory.Double,
            (ElementType.R8, ElementType.R8) => factory.Double,

            _ => a
        };
    }

    private TypeSignature ToCliType(TypeSignature a)
    {
        var factory = _method.Module!.CorLibTypeFactory;

        switch (a.ElementType)
        {
            case ElementType.Boolean:
            case ElementType.Char:
            case ElementType.I1:
            case ElementType.I2:
            case ElementType.I4:
            case ElementType.U1:
            case ElementType.U2:
            case ElementType.U4:
                return factory.Int32;

            case ElementType.I8:
            case ElementType.U8:
                return factory.Int64;

            case ElementType.I:
            case ElementType.U:
                return factory.IntPtr;

            case ElementType.Class:
            case ElementType.Object:
                return factory.Object;

            default:
                return a;
        }
    }

    public TypeSignature? Visit(VariableExpression<CilInstruction> expression, object? state)
    {
        _variableTypes.TryGetValue(expression.Variable, out var type);
        return type;
    }
}
```

`src/AwaitFuscator/Engine/MethodTransformer.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Collections;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using Echo.Ast.Construction;
using Echo.Platforms.AsmResolver;

namespace AwaitFuscator.Engine;

/// <summary>
/// Transforms a non-asynchronous method into an asynchronous method.
/// </summary>
public class MethodTransformer
{
    private readonly ObfuscatorContext _context;
    private readonly MethodDefinition _method;
    private readonly AsyncStateMachineType _stateMachine;
    private readonly MoveNextBuilder _moveNextBuilder;

    /// <summary>
    /// Creates a new method transformer.
    /// </summary>
    /// <param name="context">The obfuscator context.</param>
    /// <param name="method">The method to transform its method body for.</param>
    public MethodTransformer(ObfuscatorContext context, MethodDefinition method)
    {
        _context = context;
        _method = method;
        _stateMachine = new AsyncStateMachineType(_context, _method);
        _moveNextBuilder = new MoveNextBuilder(_context, _stateMachine, _method);
    }

    /// <summary>
    /// Applies the transformation to the method.
    /// </summary>
    public void ApplyTransformation()
    {
        var declaringType = _method.DeclaringType!;

        var moveNext = DoTransform();

        // Add MoveNext to the state machine type.
        _stateMachine.Definition.Methods.Add(moveNext);
        _stateMachine.Definition.MethodImplementations.Add(new MethodImplementation(
            _context.CodeFactory.IAsyncStateMachine_MoveNextMethod,
            moveNext
        ));

        // Add fields required by MoveNext to the state machine type.
        foreach (var awaiterField in _moveNextBuilder.GetAwaiterFields())
            _stateMachine.Definition.Fields.Add(awaiterField);
        foreach (var localFields in _moveNextBuilder.GetLocalFields())
            _stateMachine.Definition.Fields.Add(localFields);

        // Add types required by MoveNext to the module.
        foreach (var awaiterType in _moveNextBuilder.GetAwaiterTypes())
            _context.TargetModule.TopLevelTypes.Add(awaiterType);

        _context.TargetModule.TopLevelTypes.Add(_moveNextBuilder.FrameType);
        declaringType.NestedTypes.Add(_stateMachine.Definition);

        AddExtensionMethodsToModule();

        // Replace the original method body with a state machine startup stub.
        _method.CilMethodBody = _context.CodeFactory.CreateStartupStub(_stateMachine, _method);

        if (_method.Signature!.ReturnsValue)
        {
            // If the method returns a value, we need to move the state machine to a local proxy method
            // so that we can make it return Task<T>.

            var methodBuilder = _context.CodeFactory.GetMethodBuilderFactory(_method.Signature.ReturnType);

            var proxy = MoveToAsyncTaskProxyMethod();
            var local = new CilLocalVariable(methodBuilder.TaskAwaiterType);

            var body = _method.CilMethodBody!;
            body.LocalVariables.Clear();
            body.LocalVariables.Add(local);

            var il = body.Instructions;
            il.Clear();

            // Push all arguments.
            foreach (var parameter in _method.Parameters)
                il.Add(CilOpCodes.Ldarg, parameter);

            // Call the proxy method, its awaiter and its GetResult method.
            il.Add(CilOpCodes.Call, proxy);
            il.Add(CilOpCodes.Callvirt, methodBuilder.GetAwaiterMethod);
            il.Add(CilOpCodes.Stloc, local);
            il.Add(CilOpCodes.Ldloca, local);
            il.Add(CilOpCodes.Call, methodBuilder.GetResultMethod);
            il.Add(CilOpCodes.Ret);
            il.OptimizeMacros();

            declaringType.Methods.Add(proxy);
        }
    }

    private MethodDefinition DoTransform()
    {
        _moveNextBuilder.Begin();

        var astCfg = _method.CilMethodBody!
            .ConstructStaticFlowGraph()
            .ToAst(new CilPurityClassifier());

        _moveNextBuilder.RegisterLabels(astCfg.Nodes.Select(x => (int) x.Offset));

        foreach (var node in astCfg.Nodes)
        {
            _moveNextBuilder.BeginBlock((int) node.Offset);
            foreach (var statement in node.Contents.Instructions)
                _moveNextBuilder.AppendStatement(statement);
            _moveNextBuilder.EndBlock();
        }

        return _moveNextBuilder.End();
    }

    private void AddExtensionMethodsToModule()
    {
        var extensionsContainer = new TypeDefinition(
            null,
            _context.Parameters.UseAnonymousTypes
                ? $"<>AnonType_{_method.MetadataToken.Rid}"
                : $"Extensions_{_method.MetadataToken}",
            TypeAttributes.Abstract | TypeAttributes.Sealed,
            _context.TargetModule.CorLibTypeFactory.Object.Type
        );
        extensionsContainer.CustomAttributes.Add(new CustomAttribute(_context.CodeFactory.CompilerGeneratedAttributeConstructor));
        _context.TargetModule.TopLevelTypes.Add(extensionsContainer);

        foreach (var getAwaiterMethod in _moveNextBuilder.GetGetAwaiterMethods())
            extensionsContainer.Methods.Add(getAwaiterMethod);
    }

    private MethodDefinition MoveToAsyncTaskProxyMethod()
    {
        var taskType = _context.CodeFactory
            .GetMethodBuilderFactory(_method.Signature!.ReturnType)
            .TaskType;

        var result = new MethodDefinition(
            $"<{_method.Name}>g__{_method.Name}Async|0_0",
            MethodAttributes.Assembly | MethodAttributes.Static,
            MethodSignature.CreateStatic(taskType, _method.Signature.ParameterTypes)
        );

        // Copy all parameters.
        foreach (var parameter in _method.ParameterDefinitions)
            result.ParameterDefinitions.Add(new ParameterDefinition(parameter.Sequence, parameter.Name, parameter.Attributes));
        result.Parameters.PullUpdatesFromMethodSignature();

        // Add compiler generated attribute.
        result.CustomAttributes.Add(
            new CustomAttribute(_context.CodeFactory.CompilerGeneratedAttributeConstructor)
        );

        var originalBody = _method.CilMethodBody!;
        result.CilMethodBody = new CilMethodBody(result);

        // Move all locals from the original method to the new one.
        foreach (var local in originalBody.LocalVariables.ToArray())
        {
            originalBody.LocalVariables.Remove(local);
            result.CilMethodBody.LocalVariables.Add(local);
        }

        // Copy all instructions, but map the parameters to the new parameters.
        foreach (var instruction in originalBody.Instructions)
        {
            if (instruction.Operand is Parameter p)
                instruction.Operand = result.Parameters[p.Index];

            result.CilMethodBody.Instructions.Add(instruction);
        }

        return result;
    }
}
```

`src/AwaitFuscator/Engine/MoveNextBuilder.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Collections;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using Echo.Ast;
using Echo.Code;
using static AsmResolver.PE.DotNet.Cil.CilOpCodes;

namespace AwaitFuscator.Engine;

/// <summary>
/// Provides a mechanism for constructing new MoveNext methods in an async state machine.
/// </summary>
public class MoveNextBuilder
{
    private readonly ObfuscatorContext _context;
    private readonly AsyncStateMachineType _stateMachineType;
    private readonly MethodDefinition _method;

    private readonly MethodDefinition _moveNext;
    private readonly CilMethodBody _body;
    private readonly CilInstructionCollection _il;
    private readonly CilInstructionLabel _tryStart = new();
    private readonly CilInstructionLabel _handlerEnd = new();
    private readonly CilInstructionLabel _normalReturn = new();
    private readonly CilInstructionLabel _return = new();
    private readonly List<ICilLabel> _switchLabels = new();
    private readonly CilLocalVariable _stateLocal;
    private readonly CilLocalVariable _conditionLocal;
    private readonly CilLocalVariable? _resultLocal;

    private readonly List<Awaiter> _awaiters = new();
    private TypeSignature? _currentInputType;

    private readonly Dictionary<Parameter, FieldDefinition> _mappedParameters = new();
    private readonly Dictionary<CilLocalVariable, FieldDefinition> _mappedLocals = new();
    private readonly Dictionary<IVariable, FieldDefinition> _syntheticVariables = new();
    private readonly FieldDefinition _frameLocalField;
    private readonly FieldDefinition _conditionLocalField;
    private readonly TypeSignature _frameTypeSignature;

    private readonly Dictionary<int, CilInstructionLabel> _mappedLabels = new();

    private readonly AsyncMethodBuilderFactory _methodBuilderFactory;
    private readonly ExpressionTypeInference _typeInference;

    public MoveNextBuilder(ObfuscatorContext context, AsyncStateMachineType stateMachineType, MethodDefinition method)
    {
        _context = context;
        _stateMachineType = stateMachineType;
        _method = method;
        _methodBuilderFactory = context.CodeFactory.GetMethodBuilderFactory(method.Signature!.ReturnType);
        _typeInference = new ExpressionTypeInference(_method);

        var factory = _context.TargetModule.CorLibTypeFactory;

        // Create MoveNext definition.
        _moveNext = new MethodDefinition(
            "MoveNext",
            MethodAttributes.Private | MethodAttributes.Final | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual,
            MethodSignature.CreateInstance(factory.Void)
        );

        _body = _moveNext.CilMethodBody = new CilMethodBody(_moveNext);

        // Define important local variables.
        _body.LocalVariables.Add(_stateLocal = new CilLocalVariable(factory.Int32));
        _body.LocalVariables.Add(_conditionLocal = new CilLocalVariable(factory.Boolean));
        if (method.Signature.ReturnsValue)
            _body.LocalVariables.Add(_resultLocal = new CilLocalVariable(method.Signature.ReturnType));

        _il = _body.Instructions;

        // Construct Frame Type.
        FrameType = new TypeDefinition(
            null,
            context.Parameters.UseAnonymousTypes
                ? $"<>AnonType_{method.MetadataToken.Rid}_Frame"
                : $"Frame_{method.MetadataToken}",
            TypeAttributes.Sealed,
            context.TargetModule.CorLibTypeFactory.Object.Type
        );
        FrameType.CustomAttributes.Add(new CustomAttribute(context.CodeFactory.CompilerGeneratedAttributeConstructor));

        // Define parameters as fields.
        foreach (var (parameter, parameterField) in stateMachineType.ParameterFields)
        {
            var frameField = new FieldDefinition(
                parameter.Name,
                FieldAttributes.Public,
                parameterField.Signature!.FieldType
            );

            FrameType.Fields.Add(frameField);
            _mappedParameters[parameter] = frameField;
        }

        // Define locals as fields.
        foreach (var local in method.CilMethodBody!.LocalVariables)
        {
            var frameField = new FieldDefinition(
                $"_local{local.Index}",
                FieldAttributes.Public,
                local.VariableType
            );

            FrameType.Fields.Add(frameField);
            _mappedLocals[local] = frameField;
        }

        // Define the frame as a local field.
        _frameLocalField = new FieldDefinition(
            $"<x>5__1",
            FieldAttributes.Public,
            factory.Object
        );

        // We need an extra field to store the result of a condition of a branch.
        _conditionLocalField = new FieldDefinition("<c>5__2",FieldAttributes.Public, factory.Boolean);

        // Add a default constructor.
        FrameType.Methods.Add(MethodDefinition.CreateConstructor(_context.TargetModule));

        _frameTypeSignature = FrameType.ToTypeSignature(false);
    }

    /// <summary>
    /// Gets the type containing all fields representing the local variables in this method.
    /// </summary>
    public TypeDefinition FrameType { get; }

    /// <summary>
    /// Gets all the awaiter types the MoveNext method depends on and need to be added to the module.
    /// </summary>
    public IEnumerable<TypeDefinition> GetAwaiterTypes() => _awaiters.Select(x => x.Type.Definition);

    /// <summary>
    /// Gets all the awaiter fields the MoveNext method depends on and need to be added to the declaring state machine.
    /// </summary>
    public IEnumerable<FieldDefinition> GetAwaiterFields() => _awaiters.Select(x => x.Field);

    /// <summary>
    /// Gets all the local fields the MoveNext method directly depends on and need to be added to the declaring state
    /// machine.
    /// </summary>
    public IEnumerable<FieldDefinition> GetLocalFields() => new[] { _frameLocalField, _conditionLocalField };

    /// <summary>
    /// Gets all the GetAwaiter methods the MoveNext method depends on and need to be added to the module.
    /// </summary>
    public IEnumerable<MethodDefinition> GetGetAwaiterMethods() => _awaiters.Select(x => x.GetAwaiter);

    /// <summary>
    /// Gets the field representing the provided local variable.
    /// </summary>
    /// <param name="local">The local.</param>
    /// <returns>The field.</returns>
    public FieldDefinition GetLocalField(CilLocalVariable local) => _mappedLocals[local];

    /// <summary>
    /// Gets the field representing the provided parameter.
    /// </summary>
    /// <param name="parameter">The parameter.</param>
    /// <returns>The field.</returns>
    public FieldDefinition GetParameterField(Parameter parameter) => _mappedParameters[parameter];

    public FieldDefinition GetSyntheticField(IVariable variable)
    {
        if (!_syntheticVariables.TryGetValue(variable, out var field))
        {
            field = new FieldDefinition($"<>s__{_syntheticVariables.Count}", FieldAttributes.Public,
                _context.TargetModule.CorLibTypeFactory.Object);
            _syntheticVariables.Add(variable, field);
            FrameType.Fields.Add(field);
        }

        return field;
    }

    /// <summary>
    /// Starts a new MoveNext method.
    /// </summary>
    public void Begin()
    {
        // state = <>1__state;
        _il.Add(Ldarg_0);
        _il.Add(Ldfld, _stateMachineType.StateField);
        _il.Add(Stloc, _stateLocal);

        // try
        // {
        //      switch (state)
        _tryStart.Instruction = _il.Add(Ldloc, _stateLocal);
        _il.Add(new CilInstruction(Switch, _switchLabels));

        //      default:
        //          frame = new Frame();
        _il.Add(Ldarg_0);
        _il.Add(Newobj, FrameType.GetConstructor()!);

        if (_mappedParameters.Count > 0)
        {
            foreach (var parameter in _mappedParameters)
            {
                // frame.Parameter = this.Parameter;
                _il.Add(Dup);
                _il.Add(Ldarg_0);
                _il.Add(Ldfld, _stateMachineType.ParameterFields[parameter.Key]);
                _il.Add(Stfld, _mappedParameters[parameter.Key]);
            }
        }

        _il.Add(Stfld, _frameLocalField);
    }

    /// <summary>
    /// Finalizes the MoveNext code generation.
    /// </summary>
    /// <returns>The finalized MoveNext method.</returns>
    public MethodDefinition End()
    {
        var ex = new CilLocalVariable(_context.CodeFactory.ExceptionType.ToTypeSignature(false));
        _body.LocalVariables.Add(ex);

        _normalReturn.Instruction = _il.Add(Leave, _handlerEnd);

        // }
        // catch (Exception ex)
        // {
        var handlerStart = _il.Add(Stloc, ex).CreateLabel();

        //      <>1__state = -2;
        _il.Add(Ldarg_0);
        _il.Add(Ldc_I4, -2);
        _il.Add(Stfld, _stateMachineType.StateField);

        //      <>t__builder.SetException(ex);
        _il.Add(Ldarg_0);
        _il.Add(Ldflda, _stateMachineType.BuilderField);
        _il.Add(Ldloc, ex);
        _il.Add(Call, _methodBuilderFactory.SetExceptionMethod);

        //      return;
        _il.Add(Nop);
        _il.Add(Leave, _return);

        // }

        // <>1__state = -2;
        _handlerEnd.Instruction = _il.Add(Ldarg_0);
        _il.Add(Ldc_I4, -2);
        _il.Add(Stfld, _stateMachineType.StateField);

        // <>t__builder.SetResult([result]);
        _il.Add(Ldarg_0);
        _il.Add(Ldflda, _stateMachineType.BuilderField);
        if (_resultLocal is not null)
            _il.Add(Ldloc, _resultLocal);
        _il.Add(Call, _methodBuilderFactory.SetResult);
        _il.Add(Nop);

        // return;
        _return.Instruction = _il.Add(Ret);

        _body.ExceptionHandlers.Add(new CilExceptionHandler
        {
            HandlerType = CilExceptionHandlerType.Exception,
            TryStart = _tryStart,
            TryEnd = handlerStart,
            HandlerStart = handlerStart,
            HandlerEnd = _handlerEnd,
            ExceptionType = _context.CodeFactory.ExceptionType
        });

        _il.OptimizeMacros();

        return _moveNext;
    }

    /// <summary>
    /// Registers all basic block labels of the original method.
    /// </summary>
    /// <param name="offsets">The offsets of all basic blocks.</param>
    public void RegisterLabels(IEnumerable<int> offsets)
    {
        foreach (int offset in offsets)
            _mappedLabels[offset] = new CilInstructionLabel();
    }

    /// <summary>
    /// Starts the code generation of a new basic block.
    /// </summary>
    /// <param name="offset">The original offset of the basic block.</param>
    public void BeginBlock(int offset)
    {
        _currentInputType = _context.TargetModule.CorLibTypeFactory.Object;
        AppendSequential(new CilInstruction(offset, Ldarg_0));
        _il.Add(Ldfld, _frameLocalField);
    }

    /// <summary>
    /// Ends the code generation of the current basic block.
    /// </summary>
    public void EndBlock()
    {
        EnsureCurrentAwaiterPopped(-1);
    }

    private void EnsureCurrentAwaiterPopped(int offset)
    {
        if (_currentInputType is not null)
        {
            AppendSequential(new CilInstruction(offset, Pop));
            _currentInputType = null;
        }
    }

    /// <summary>
    /// Appends a statement to the current block.
    /// </summary>
    /// <param name="statement">The statement to append.</param>
    /// <exception cref="InvalidOperationException">Occurs when no block was started yet.</exception>
    public void AppendStatement(Statement<CilInstruction> statement)
    {
        if (_currentInputType is null)
            throw new InvalidOperationException();

        switch (statement)
        {
            // Special-case on some types of instructions that alter flow or are redundant.
            case ExpressionStatement<CilInstruction>
            {
                Expression: InstructionExpression<CilInstruction> {Instruction: { } instruction} expression
            } when instruction.IsUnconditionalBranch():
                AppendUnconditionalBranch(expression);
                return;

            case ExpressionStatement<CilInstruction>
            {
                Expression: InstructionExpression<CilInstruction> {Instruction: { } instruction} expression
            } when instruction.IsConditionalBranch():
                AppendConditionalBranch(expression);
                return;

            case ExpressionStatement<CilInstruction>
            {
                Expression: InstructionExpression<CilInstruction> {Instruction.OpCode.Code: var code} expression
            }:
                switch (code)
                {
                    case CilCode.Nop:
                        // Don't create an awaiter for nops (drastically reduces the amount of NOP awaiters).
                        AppendSequential(expression.Instruction);
                        return;

                    case CilCode.Ret:
                        AppendReturn(expression);
                        return;
                }

                break;
        }

        // Otherwise just append a normal awaiter construction.
        AppendAwaitedSequential(statement);
    }

    private void AppendSequential(CilInstruction instruction)
    {
        // Copy to prevent mutability bugs.
        var copy = new CilInstruction(instruction.OpCode, instruction.Operand);

        // Emit to the state.
        _il.Add(copy);

        // Is this the start of a basic block? Register it if necessary.
        if (_mappedLabels.TryGetValue(instruction.Offset, out var label))
            label.Instruction ??= copy;
    }

    private void AppendAwaitedSequential(AstNode<CilInstruction> statement)
    {
        // Create the next awaiter.
        var awaiter = CreateNextAwaiter(statement, null);

        // Copy the statement into the GetResult of the awaiter.
        var getResultIl = awaiter.Type.GetResultMethod.CilMethodBody!.Instructions;
        var serializer = new StatementSerializer(this, awaiter.Type);
        AstNodeWalker<CilInstruction>.Walk(serializer, statement);

        // Append 'return this' to GetResult().
        getResultIl.Add(Ldarg_0);
        getResultIl.Add(Ldobj, awaiter.Type.Definition);
        getResultIl.Add(Ret);

        // Append normal awaiter pattern to MoveNext.
        EmitAwaiterStatements(awaiter);

        _currentInputType = awaiter.Type.Definition.ToTypeSignature(true);
    }

    private void AppendReturn(InstructionExpression<CilInstruction> expression)
    {
        if (_resultLocal is not null && expression.Arguments.Count == 1)
        {
            // We are exiting the method with a value as a result. Create a new awaiter for it.
            var awaiter = CreateNextAwaiter(expression, _resultLocal.VariableType);

            // Emit expression to the GetResult of the awaiter.
            var serializer = new StatementSerializer(this, awaiter.Type);
            AstNodeWalker<CilInstruction>.Walk(serializer, expression.Arguments[0]);
            awaiter.Type.GetResultMethod.CilMethodBody!.Instructions.Add(Ret);

            // Append normal awaiter pattern.
            EmitAwaiterStatements(awaiter);

            // Store result in result variable.
            _il.Add(Stloc, _resultLocal);
        }
        else
        {
            // We're exiting the method without a value, ensure stack balance.
            EnsureCurrentAwaiterPopped(expression.Instruction.Offset);
        }

        // Rets have to be replaced with a branch to the end of the state machine.
        AppendSequential(new CilInstruction(expression.Instruction.Offset, Br, _normalReturn));
    }

    private void AppendUnconditionalBranch(InstructionExpression<CilInstruction> branch)
    {
        int offset = branch.Instruction.Offset;

        // We're exiting the block, ensure stack balance before jumping.
        EnsureCurrentAwaiterPopped(offset);

        // Map the branch target to the label in MoveNext.
        AppendSequential(new CilInstruction(offset, Br, _mappedLabels[((ICilLabel) branch.Instruction.Operand!).Offset]));

        _currentInputType = null;
    }

    private void AppendConditionalBranch(InstructionExpression<CilInstruction> branch)
    {
        // Create the next awaiter.
        var awaiter = CreateNextAwaiter(branch, _context.TargetModule.CorLibTypeFactory.Boolean);

        // Copy the statement into the GetResult of the awaiter.
        var getResultBody = awaiter.Type.GetResultMethod.CilMethodBody!;
        var getResultIl = getResultBody.Instructions;
        var serializer = new StatementSerializer(this, awaiter.Type);

        // We don't actually want to emit the branch to the awaiter, but instead let the awaiter return only the result
        // of the condition. Hence, we only compile the branch arguments.
        foreach (var argument in branch.Arguments)
            AstNodeWalker<CilInstruction>.Walk(serializer, argument);

        // Rewrite the branch opcode to a boolean expression.
        AppendBooleanBranchConditionExpression(branch.Instruction.OpCode, getResultIl);

        getResultIl.Add(Ret);

        // Append normal awaiter pattern.
        EmitAwaiterStatements(awaiter, new CilInstruction(Ldarg_0));

        // Store to intermediate stack field such that dnSpy properly interprets it as an 'await' put into a condition.
        // NOTE: This is a limitation of dnSpy's await decompiler. Latest ILSpy works fine without this.
        _il.Add(Stfld, _stateMachineType.ConditionField);
        _il.Add(Ldarg_0);
        _il.Add(Ldfld, _stateMachineType.ConditionField);
        _il.Add(Stloc, _conditionLocal);
        _il.Add(Ldloc, _conditionLocal);

        // Follow up with a generic brtrue branch, mapping the branch target to the representative label in MoveNext().
        _il.Add(Brtrue, _mappedLabels[((ICilLabel) branch.Instruction.Operand!).Offset]);

        _currentInputType = null;
    }

    private static void AppendBooleanBranchConditionExpression(CilOpCode opCode, CilInstructionCollection getResultIl)
    {
        switch (opCode.Code)
        {
            case CilCode.Brtrue:
            case CilCode.Brtrue_S:
                // We don't have to rewrite anything!
                break;

            case CilCode.Brfalse:
            case CilCode.Brfalse_S:
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            case CilCode.Beq:
            case CilCode.Beq_S:
                getResultIl.Add(Ceq);
                break;

            case CilCode.Bne_Un:
            case CilCode.Bne_Un_S:
                getResultIl.Add(Ceq);
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            case CilCode.Blt:
            case CilCode.Blt_S:
                getResultIl.Add(Clt);
                break;

            case CilCode.Blt_Un:
            case CilCode.Blt_Un_S:
                getResultIl.Add(Clt_Un);
                break;

            case CilCode.Bgt:
            case CilCode.Bgt_S:
                getResultIl.Add(Cgt);
                break;

            case CilCode.Bgt_Un:
            case CilCode.Bgt_Un_S:
                getResultIl.Add(Cgt_Un);
                break;

            case CilCode.Ble:
            case CilCode.Ble_S:
                getResultIl.Add(Cgt);
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            case CilCode.Ble_Un:
            case CilCode.Ble_Un_S:
                getResultIl.Add(Cgt_Un);
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            case CilCode.Bge:
            case CilCode.Bge_S:
                getResultIl.Add(Clt);
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            case CilCode.Bge_Un:
            case CilCode.Bge_Un_S:
                getResultIl.Add(Clt_Un);
                getResultIl.Add(Ldc_I4_0);
                getResultIl.Add(Ceq);
                break;

            default:
                throw new NotSupportedException($"Unsupported branch opcode {opCode}");
        }
    }

    private Awaiter CreateNextAwaiter(AstNode<CilInstruction> node, TypeSignature? outputType)
    {
        if (_currentInputType is null)
            throw new InvalidOperationException();

        int id = _awaiters.Count;

        long offset = node.OriginalRange!.Value.Start;
        var awaiterType = new AwaiterType(
            _context,
            _context.Parameters.UseAnonymousTypes
                ? $"<>AnonType_{_method.MetadataToken.Rid}_{offset:X}"
                : $"Awaiter_{_method.MetadataToken}_{offset:X}",
            _frameTypeSignature,
            _currentInputType,
            outputType
        );

        var awaiterTypeSig = awaiterType.Definition.ToTypeSignature(true);
        var awaiterField = new FieldDefinition($"<>u__{id + 1}", FieldAttributes.Private, awaiterTypeSig);
        var getAwaiterMethod = _context.CodeFactory.CreateGetAwaiterMethod(awaiterType, _currentInputType);

        var awaiter = new Awaiter(id, awaiterType, awaiterField, getAwaiterMethod);
        _awaiters.Add(awaiter);

        return awaiter;
    }

    private void EmitAwaiterStatements(Awaiter awaiter, CilInstruction? prepend = null)
    {
        var awaiterTypeSig = awaiter.Type.Definition.ToTypeSignature(true);

        // Awaiter awaiter;
        var awaiterLocal = new CilLocalVariable(awaiterTypeSig);
        _body.LocalVariables.Add(awaiterLocal);

        var nextStatement = new CilInstructionLabel();

        // awaiter = current.GetAwaiter();
        _il.Add(Call, awaiter.GetAwaiter);
        _il.Add(Stloc, awaiterLocal);

        // if (awaiter.IsCompleted) goto nextStatement;
        _il.Add(Ldloca, awaiterLocal);
        _il.Add(Call, awaiter.Type.GetIsCompletedMethod);
        _il.Add(Brtrue, nextStatement);

        // state = <>1__state = id;
        _il.Add(Ldarg_0);
        _il.Add(Ldc_I4, awaiter.StateId);
        _il.Add(Dup);
        _il.Add(Stloc, _stateLocal);
        _il.Add(Stfld, _stateMachineType.StateField);

        // <>u__x = awaiter;
        _il.Add(Ldarg_0);
        _il.Add(Ldloc, awaiterLocal);
        _il.Add(Stfld, awaiter.Field);

        // <>t__builder.AwaitOnCompleted(ref awaiter, ref stateMachine);
        _il.Add(Ldarg_0);
        _il.Add(Ldflda, _stateMachineType.BuilderField);
        _il.Add(Ldloca, awaiterLocal);
        _il.Add(Ldarg_0);
        _il.Add(Call, _methodBuilderFactory.AwaitOnCompleted
            .MakeGenericInstanceMethod(
                awaiterTypeSig,
                _stateMachineType.Definition.ToTypeSignature(true)
            ));

        // return;
        _il.Add(Leave, _return);

        // awaiter = <>u__x;
        var initLabel = _il.Add(Ldarg_0).CreateLabel();
        _il.Add(Ldfld, awaiter.Field);
        _il.Add(Stloc, awaiterLocal);
        _switchLabels.Add(initLabel);

        // <>u__x = default(Awaiter);
        _il.Add(Ldarg_0);
        _il.Add(Ldflda, awaiter.Field);
        _il.Add(Initobj, awaiter.Type.Definition);

        // state = <>1__state = -1;
        _il.Add(Ldarg_0);
        _il.Add(Ldc_I4_M1);
        _il.Add(Dup);
        _il.Add(Stloc, _stateLocal);
        _il.Add(Stfld, _stateMachineType.StateField);

        // awaiter.GetResult();
        if (prepend is not null)
        {
            // HACK: sometimes we need to prepend the instruction for stack balance. We should probably tidy this up
            //       into something more clean...
            nextStatement.Instruction = prepend;
            _il.Add(prepend);
            _il.Add(Ldloca, awaiterLocal);
        }
        else
        {
            nextStatement.Instruction = _il.Add(Ldloca, awaiterLocal);
        }

        _il.Add(Call, awaiter.Type.GetResultMethod);
    }

    private sealed record Awaiter(int StateId, AwaiterType Type, FieldDefinition Field, MethodDefinition GetAwaiter);

    private sealed class StatementSerializer : AstNodeListener<CilInstruction>
    {
        private readonly MoveNextBuilder _builder;
        private readonly AwaiterType _awaiterType;

        public StatementSerializer(MoveNextBuilder builder, AwaiterType awaiterType)
        {
            _builder = builder;
            _awaiterType = awaiterType;
        }

        public override void EnterInstructionExpression(InstructionExpression<CilInstruction> expression)
        {
            // If the beginning of this expression is supposed to be a branch label, register it.
            if (_builder._mappedLabels.ContainsKey((int) expression.OriginalRange!.Value.Start))
                _builder.AppendSequential(new CilInstruction((int) expression.OriginalRange.Value.Start, Nop));

            var instruction = expression.Instruction;

            if (instruction.IsLdloc()
                || instruction.IsStloc()
                || instruction.IsLdarg()
                || instruction.IsStarg()
                || instruction.OpCode.Code is CilCode.Ldloca or CilCode.Ldloca_S or CilCode.Ldarga or CilCode.Ldarga_S)
            {
                // We need to prepend locals with a push to the current frame so that we can access its fields.
                var il = _awaiterType.GetResultMethod.CilMethodBody!.Instructions;

                il.Add(Ldarg_0);
                il.Add(Ldfld, _awaiterType.FrameField);
            }

            base.EnterInstructionExpression(expression);
        }

        public override void ExitInstructionExpression(InstructionExpression<CilInstruction> expression)
        {
            var opCode = expression.Instruction.OpCode;
            object? operand = expression.Instruction.Operand;

            // Translate local accesses to field accesses in the current frame.
            if (expression.Instruction.IsLdloc())
            {
                opCode = Ldfld;
                operand = _builder.GetLocalField(expression.Instruction.GetLocalVariable(_builder._method.CilMethodBody!.LocalVariables));
            }
            else if (expression.Instruction.OpCode.Code is CilCode.Ldloca or CilCode.Ldloca_S)
            {
                opCode = Ldflda;
                operand = _builder.GetLocalField(expression.Instruction.GetLocalVariable(_builder._method.CilMethodBody!.LocalVariables));
            }
            else if (expression.Instruction.IsStloc())
            {
                opCode = Stfld;
                operand = _builder.GetLocalField(expression.Instruction.GetLocalVariable(_builder._method.CilMethodBody!.LocalVariables));
            }
            else if (expression.Instruction.IsLdarg())
            {
                opCode = Ldfld;
                operand = _builder.GetParameterField(expression.Instruction.GetParameter(_builder._method.Parameters));
            }
            else if (expression.Instruction.OpCode.Code is CilCode.Ldarga or CilCode.Ldarga_S)
            {
                opCode = Ldflda;
                operand = _builder.GetParameterField(expression.Instruction.GetParameter(_builder._method.Parameters));
            }
            else if (expression.Instruction.IsStarg())
            {
                opCode = Stfld;
                operand = _builder.GetParameterField(expression.Instruction.GetParameter(_builder._method.Parameters));
            }
            else if (expression.Instruction.IsBranch())
            {
                throw new ArgumentException("Cannot move branch instructions into an awaiter type.");
            }

            _awaiterType.GetResultMethod.CilMethodBody!.Instructions.Add(new CilInstruction(opCode, operand));

            base.ExitInstructionExpression(expression);
        }

        public override void ExitVariableExpression(VariableExpression<CilInstruction> expression)
        {
            base.ExitVariableExpression(expression);

            var il = _awaiterType.GetResultMethod.CilMethodBody!.Instructions;

            il.Add(Ldarg_0);
            il.Add(Ldfld, _builder.GetSyntheticField(expression.Variable));
        }

        public override void EnterAssignmentStatement(AssignmentStatement<CilInstruction> statement)
        {
            base.EnterAssignmentStatement(statement);

            foreach (var variable in statement.Variables)
                _awaiterType.GetResultMethod.CilMethodBody!.Instructions.Add(Ldarg_0);
        }

        public override void ExitAssignmentStatement(AssignmentStatement<CilInstruction> statement)
        {
            base.ExitAssignmentStatement(statement);

            var type = _builder._typeInference.InferType(statement.Expression);

            foreach (var variable in statement.Variables)
            {
                var field = _builder.GetSyntheticField(variable);
                if (type is not null)
                {
                    field.Signature!.FieldType = type;
                    _builder._typeInference.SetVariableType(variable, type);
                }

                _awaiterType.GetResultMethod.CilMethodBody!.Instructions.Add(Stfld, field);
            }
        }

        public override void ExitPhiStatement(PhiStatement<CilInstruction> statement)
        {
            throw new NotSupportedException("Phi nodes are not supported yet.");
        }
    }
}
```

`src/AwaitFuscator/Engine/ObfuscatorContext.cs`:

```cs
using AsmResolver.DotNet;

namespace AwaitFuscator.Engine;

/// <summary>
/// Provides a context for an obfuscator.
/// </summary>
public sealed class ObfuscatorContext
{
    public ObfuscatorContext(ModuleDefinition targetModule, ObfuscatorParameters parameters)
    {
        TargetModule = targetModule;
        Parameters = parameters;
        CodeFactory = new AsyncCodeFactory(targetModule);
    }

    /// <summary>
    /// Gets the target module to obfuscate.
    /// </summary>
    public ModuleDefinition TargetModule
    {
        get;
    }

    /// <summary>
    /// Gets the parameters to use during the obfuscation process.
    /// </summary>
    public ObfuscatorParameters Parameters
    {
        get;
    }

    /// <summary>
    /// Gets a factory for constructing new async code.
    /// </summary>
    public AsyncCodeFactory CodeFactory
    {
        get;
    }

}
```

`src/AwaitFuscator/Engine/ObfuscatorParameters.cs`:

```cs
namespace AwaitFuscator.Engine;

/// <summary>
/// Defines parameters to use for obfuscating a module.
/// </summary>
public class ObfuscatorParameters
{
    /// <summary>
    /// Gets or sets a value indicating whether the obfuscator should introduce types with anonymous names.
    /// </summary>
    public bool UseAnonymousTypes { get; set; } = true;
    
}
```

`src/AwaitFuscator/Program.cs`:

```cs
using System.CommandLine;
using System.Reflection;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Builder;
using AsmResolver.DotNet.Signatures.Types;
using AwaitFuscator.Engine;

namespace AwaitFuscator;

internal static class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine(@"                      _ _     ______                   _              ____    ");
        Console.WriteLine(@"                     (_) |   |  ____|                 | |            / /\ \ _");
        Console.WriteLine(@"   __ ___      ____ _ _| |_  | |__ _   _ ___  ___ __ _| |_ ___  _ __| |  | (_)");
        Console.WriteLine(@"  / _` \ \ /\ / / _` | | __| |  __| | | / __|/ __/ _` | __/ _ \| '__| |  | |");
        Console.WriteLine(@" | (_| |\ V  V / (_| | | |_  | |  | |_| \__ \ (_| (_| | || (_) | |  | |  | |_");
        Console.WriteLine(@"  \__,_| \_/\_/ \__,_|_|\__| |_|   \__,_|___/\___\__,_|\__\___/|_|  | |  | ( )");
        Console.WriteLine(@"                                                                     \_\/_/|/");

        Console.WriteLine("Version:   {0}", Assembly.GetExecutingAssembly().GetName().Version);
        Console.WriteLine("Copyright: Washi 2024 (https://washi.dev/)");
        Console.WriteLine();

        var rootCommand = new RootCommand();
        var path = new Argument<string>("path");

        rootCommand.AddArgument(path);
        rootCommand.SetHandler(OnObfuscate, path);

        rootCommand.Invoke(args);
    }

    private static void OnObfuscate(string path)
    {
        string file = Path.GetFullPath(path);
        string workingDirectory = Path.GetDirectoryName(file)!;

        Console.WriteLine($"Loading input file {file}");

        var module = ModuleDefinition.FromFile(file);
        var parameters = new ObfuscatorParameters
        {
            UseAnonymousTypes = true
        };

        var context = new ObfuscatorContext(module, parameters);

        ProcessModule(context, module);

        // Create output directory if it doesn't exist already.
        string outputDirectory = Path.Combine(workingDirectory, "Obfuscated");
        if (!Directory.Exists(outputDirectory))
            Directory.CreateDirectory(outputDirectory);

        // Esnure runtimeconfig.json file is copied over.
        string runtimeConfigFile = Path.ChangeExtension(file, ".runtimeconfig.json");;
        string runtimeConfigTarget = Path.Combine(outputDirectory, Path.GetFileName(runtimeConfigFile));
        if (File.Exists(runtimeConfigFile) && !File.Exists(runtimeConfigTarget))
            File.Copy(runtimeConfigFile, runtimeConfigTarget);

        // Save the final file.
        string outputFile = Path.Combine(outputDirectory, Path.GetFileName(file));
        Console.WriteLine($"Writing to {outputFile}...");
        module.Write(outputFile, new ManagedPEImageBuilder(new ConsoleErrorListener()));
    }

    private static void ProcessModule(ObfuscatorContext context, ModuleDefinition module)
    {
        var selection = module.GetAllTypes()
            .SelectMany(x => x.Methods)
            .Where(CanObfuscate)
            .ToArray();

        foreach (var method in selection)
            ProcessMethod(context, method);
    }

    private static bool CanObfuscate(MethodDefinition method)
    {
        if (method is not { CilMethodBody: {} body })
            return false;

        // Constructors cannot be made async by definition.
        if (method.IsConstructor)
            return false;

        // Async methods inherently do not support `ref` parameters.
        if (method.Parameters.Any(x => x.ParameterType is ByReferenceTypeSignature))
            return false;

        // We currently only support static methods.
        if (!method.IsStatic)
            return false;

        // We currently cannot transform exception handlers.
        if (body.ExceptionHandlers.Count > 0)
            return false;

        return true;
    }

    private static void ProcessMethod(ObfuscatorContext context, MethodDefinition method)
    {
        Console.WriteLine($"Processing {method}");

        var transformer = new MethodTransformer(context, method);
        transformer.ApplyTransformation();
    }
}
```